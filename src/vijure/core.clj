(ns vijure.core
    (:refer-clojure :exclude [boolean byte short int long])
    (:require [org.baznex.imports :refer [import-static]])
    (:import [java.util Arrays])
    (:gen-class))

(org.baznex.imports/rename {vijure.VimA$Bytes 'Bytes})

(import-static vijure.VimA char_u u8 BEQ BNE BDIFF BLT BLE asc_toupper asc_tolower MEMCMP ACOPY BCOPY AFILL BFILL STRCAT STRCMP STRCPY STRLEN STRNCASECMP STRNCMP STRNCPY)
; %% (import-static vijure.VimB SIGHUP SIGQUIT SIGILL SIGTRAP SIGABRT SIGFPE SIGBUS SIGSEGV SIGSYS SIGALRM SIGTERM SIGVTALRM SIGPROF SIGXCPU SIGXFSZ SIGUSR1 SIGUSR2 SIGINT SIGWINCH SIGTSTP SIGPIPE)

(defmacro ยง [& _])
(defmacro ร [& _])

(defmacro def- [symbol & init] (list* 'def (vary-meta symbol assoc :private true) init))

(def- null nil)

(defmacro != [x y] `(not (== ~x ~y)))

(defmacro non-nil? [x] `(not (nil? ~x)))
(defmacro non-zero? [x] `(not (zero? ~x)))

(def- % rem)

(def- & bit-and)
(def- | bit-or)
(def- << bit-shift-left)
(def- >>> unsigned-bit-shift-right)

(defn- boolean? [b] (instance? Boolean b))

(def- byte! unchecked-byte)

(defn- boolean ([] (boolean nil)) ([b] (cond (nil? b) false (boolean? b) b :else (throw (IllegalArgumentException. (str "fuzzy boolean " b))))))
(defn- byte    ([] (byte nil))    ([n] (clojure.core/byte (if (nil? n) 0 n))))
(defn- short   ([] (short nil))   ([n] (clojure.core/short (if (nil? n) 0 n))))
(defn- int     ([] (int nil))     ([n] (clojure.core/int (if (nil? n) 0 n))))
(defn- long    ([] (long nil))    ([n] (clojure.core/long (if (nil? n) 0 n))))
(defn- object  ([] (object nil))  ([o] o))

(def- maybean int)

(defmacro def'type* [& types] (cons 'do
    (map (fn [t] (let [t* (symbol (str t \*))]
        `(defn- ~t* [v#] (cond (sequential? v#) (mapv ~t v#) (number? v#) (recur (repeat v# nil)) :else (assert (nil? v#) (str "fuzzy " '~t* " " v#))))
    )) types)))
(def'type* boolean byte byte* int int* long object object*)

(def- frag_C* object*)

(def- C (map #(symbol (str % "_C")) '(barray buffblock buffer buffheader cmdline_info fmark fragnode frame lpos match matchitem memline msgchunk nfa_pim nfa_state oparg pos posmatch reg_extmatch regmatch regmmatch regprog regsave regsub regsubs save_se soffset termios typebuf u_entry u_header u_link visualinfo window winopt yankreg)))

(def- C* (map #(symbol (str % "_C*")) '(attrentry backpos btcap cmdname decomp digr fmark frag frame hl_group key_name linepos llpos lpos modmasktable multipos nfa_state nfa_thread nv_cmd pos save_se signalinfo spat termcode typebuf vimoption wline yankreg)))

(def- C** (map #(symbol (str % "_C**")) '(histentry)))

(def- F (map #(symbol (str % "_F")) '(ex_func nv_func)))

(let [I '(byte byte! byte* byte** int int* long maybean) O (concat '(Bytes Object) C) O* (concat '(Bytes* Bytes*') C*)
      T (merge (zipmap I I) (zipmap O (repeat 'object)) (zipmap O* (repeat 'object*)))]
    (letfn [(f [t s] (if s (cons `(def- ~(first s) (~t ~(second s))) (f t (nnext s))) '(nil)))]
        (defmacro final [t & s] (let [t' (T t)] (assert t' (str "unexpected type: " t)) (when s (cons 'do (f t' s)))))))

(let [I '(boolean boolean* int int* int** long long* maybean) O (cons 'Bytes C) O* (concat '(Bytes* Object*) C*) O** C**
      T (merge (zipmap I I) (zipmap O (repeat 'object)) (zipmap O* (repeat 'object*)) (zipmap O** (repeat 'object**)))]
    (letfn [(f [t s] (if s (cons `(def- ~(first s) (atom (~t ~(second s)))) (f t (nnext s))) '(nil)))]
        (defmacro atom! [t & s] (let [t' (T t)] (assert t' (str "unexpected type: " t)) (when s (cons 'do (f t' s)))))))

(let [I '#{boolean byte int long} A '(byte* int*) O (concat '(Bytes Object) C F) O* (concat '(Bytes* Object*) C*) O** C**
      T (merge (zipmap I I) (zipmap A A) (zipmap O (repeat 'object)) (zipmap O* (repeat 'object*)) (zipmap O** (repeat 'object**)))]
    (letfn [(f' [[f t n & [v]]] (let [t' (T t)] (assert t' (str "unexpected type: " t))
            (case f atom' `[~n (atom (~t' ~v))]
                    field `[~(if (I t) (vary-meta n assoc :tag t) n) (~t' ~v)])))]
        (defmacro class! [c [& fs] & _] (let [fs' (map f' fs)]
            `(do (defrecord ~c ~(mapv first fs') ~@_)
                 (defn- ~(symbol (str "ยง_" c)) [] (new ~c ~@(map second fs'))) nil)))))

;;; ============================================================================================== VimA

(final maybean FALSE 0, TRUE 1, MAYBE 2)

#_(final Bytes VIMVERSION (u8 "VIM - Vi IMproved 7.4.692"))

(declare alphaOrd lowerOrd upperOrd rot13 ctrl_key is_special TERMCAP2KEY KEY2TERMCAP0 KEY2TERMCAP1 KB_SECOND KB_THIRD toSpecial vim_iswhite new_pos COPY_pos ARRAY_pos MIN1_lpos COPY_lpos ARRAY_lpos COPY__lpos COPY_regmmatch COPY_fmark ARRAY_fmark COPY_visualinfo COPY_buffblock COPY_buffheader ZER0_attrentry COPY_attrentry COPY_wline ARRAY_wline COPY_frame COPY_llpos ARRAY_llpos asc_islower asc_isupper asc_isalpha asc_isalnum asc_iscntrl asc_isgraph asc_isprint asc_ispunct hl_attr ltpos eqpos ltoreq clearpos lineempty bufempty mch_write mch_inchar handle_resize mch_delay sig_winch catch_sigint catch_sigpwr may_core_dump deathtrap mch_suspend mch_init set_signals catch_int_signal reset_signals catch_signals vim_handle_signal exit_scroll mch_exit mch_settmode get_stty mch_get_shellsize mch_set_shellsize mch_new_shellsize mch_breakcheck waitForChar realWaitForChar msg msg_attr msg_attr_keep msg_strtrunc trunc_string smsg smsg_attr emsg_not_now emsg emsg2 emsg_invreg msg_trunc_attr msg_may_trunc wait_return hit_return_msg set_keep_msg msg_start msg_starthere msg_putchar msg_putchar_attr msg_outtrans msg_outtrans_attr msg_outtrans_len msg_outtrans_len_attr screen_puts_mbyte msg_puts msg_puts_title msg_puts_attr msg_puts_attr_len msg_puts_display msg_scroll_up inc_msg_scrolled store_sb_text may_clear_sb_text clear_sb_text show_sb_text msg_sb_start disp_sb_line t_puts msg_use_printf msg_puts_printf do_more_prompt msg_screen_putchar msg_moremsg repeat_message msg_check_screen msg_clr_eos msg_clr_eos_force msg_clr_cmdline msg_end msg_check give_warning display_confirm_msg new_vimoption bool_opt long_opt utf8_opt set_init_1 set_option_default set_options_default set_number_default set_init_2 do_set illegal_char didset_options check_options check_buf_options clear_string_option check_string_option did_set_string_option check_colorcolumn set_bool_option set_num_option check_redraw findoption get_highlight_default showoneopt comp_col get_varp win_copy_options copy_winopt check_win_options check_winopt clear_winopt paste_option_changed fill_breakat_flags check_opt_strings opt_strings_flags can_bs get_sw_value get_sts_value find_mps_values briopt_check do_ascii linelen ex_retab ex_fixdel ex_sub do_sub_msg COPY_cmdline_info COPY_histentry ARRAY_histentry getcmdline text_locked text_locked_msg cmdline_charsize set_cmdspos set_cmdspos_cursor correct_cmdspos getexline alloc_cmdbuff realloc_cmdbuff draw_cmdline putcmdline unputcmdline put_on_cmdline save_cmdline restore_cmdline save_cmdline_alloc restore_cmdline_alloc cmdline_paste cmdline_paste_str redrawcmdline redrawcmdprompt redrawcmd compute_cmdrow cursorcmd gotocmdline hist_char2type init_history clear_hist_entry in_history add_to_history ex_window do_cmdline_cmd do_cmdline current_win_nr do_one_cmd append_command find_command skip_range get_address invalid_range correct_range check_nextcmd ex_close ex_win_close ex_only ex_stop ex_syncbind do_sleep ex_set eval_to_string profile_setlimit profile_passed_limit can_abandon find__command normal_cmd do_pending_operator op_colon op_function check_visual_highlight end_visual_mode reset_VIsual_and_resel reset_VIsual find_ident_under_cursor find_ident_at_pos prep_redo_cmd prep_redo checkclearop checkclearopq clearop clearopbeep unshift_special clear_showcmd add_to_showcmd add_to_showcmd_c del_from_showcmd push_showcmd pop_showcmd display_showcmd do_check_scrollbind check_scrollbind nv_ignore nv_nop nv_error nv_addsub nv_page nv_gd nv_screengo nv_scroll_line scroll_redraw nv_zet nv_exmode nv_colon nv_ctrlg nv_ctrlh nv_clear nv_ctrlo nv_hat nv_Zet do_nv_ident nv_ident get_visual_text nv_scroll nv_right nv_left nv_up nv_down nv_end nv_dollar nv_search nv_next normal_search nv_csearch nv_brackets nv_percent nv_brace nv_mark nv_findpar nv_undo nv_kundo nv_replace v_swap_corners nv_Replace nv_vreplace n_swapchar nv_cursormark v_visop nv_subst nv_abbrev nv_optrans nv_gomark nv_pcmark nv_regname nv_visual start_selection may_start_select n_start_visual_mode nv_window nv_suspend nv_g_cmd n_opencmd nv_dot nv_redo nv_Undo nv_tilde nv_operator nv_lineop nv_home nv_pipe nv_bck_word nv_wordcmd adjust_cursor nv_beginline adjust_for_sel unadjust_for_sel nv_select nv_goto nv_normal nv_esc nv_edit invoke_edit nv_object nv_record nv_at nv_halfpage nv_join nv_put nv_open nv_drop nv_cursorhold COPY_yankreg ARRAY_yankreg get_op_type op_on_lines get_op_char get_extra_op_char op_shift shift_line shift_block block_insert op_reindent get_expr_register get_expr_line valid_yank_reg get_yank_register get_register put_register do_record stuff_yank do_execreg put_reedit_in_typebuf put_in_typebuf insert_reg stuffescaped get_spec_reg cmdline_paste_reg adjust_clip_reg may_get_selection op_delete mb_adjust_opend op_replace op_tilde swapchars swapchar op_insert op_change init_yank op_yank yank_copy_line do_put adjust_cursor_eol do_join block_prep do_addsub line_count_info cursor_pos_info setmark setmark_pos setpcmark checkpcmark movemark movechangelist getmark_buf getmark getmark_buf_fnum getnextmark check_mark clrallmarks one_adjust one_adjust_nodel mark_adjust col_adjust mark_col_adjust cleanup_jumplist copy_jumplist set_last_cursor free_buff get_buffcont get_recorded get_inserted add_buff add_num_buff add_char_buff read_readbuf read_readbuffers start_stuff stuff_empty typeahead_noflush flush_buffers resetRedobuff cancelRedo appendToRedobuff appendToRedobuffLit appendCharToRedobuff appendNumberToRedobuff stuffReadbuff stuffRedoReadbuff stuffReadbuffLen stuffcharReadbuff stuffnumReadbuff init_redo read_redo start_redo start_redo_ins stop_redo_ins init_typebuf ins_typebuf ins_char_typebuf typebuf_changed del_typebuf gotchars may_sync_undo before_blocking updatescript vgetc safe_vgetc plain_vgetc vpeekc char_avail vungetc vgetorpeek inchar fix_input_buffer input_available vim_strsave_escape_special vim_unescape_special edit ins_redraw ins_ctrl_v edit_putchar edit_unputchar change_indent truncate_spaces backspace_until_column del_char_after_col get_literal insert_special isspecial insertchar redo_literal start_arrow stop_arrow stop_insert set_last_insert add_char2buf beginline oneright oneleft cursor_up cursor_down stuff_inserted get_last_insert get_last_insert_save replace_push replace_push_mb replace_pop replace_join replace_pop_ins mb_replace_pop_ins replace_flush replace_do_bs ins_reg ins_ctrl_g ins_ctrl_hat ins_esc ins_start_select ins_insert ins_ctrl_o ins_shift ins_del ins_bs_one ins_bs ins_left ins_home ins_end ins_s_left ins_right ins_s_right ins_up ins_pageup ins_down ins_pagedown ins_drop ins_tab ins_eol ins_digraph ins_copychar ins_ctrl_ey ins_try_si get_nolist_virtcol do_insert_char_pre with_nl Magic un_Magic is_Magic no_Magic toggle_Magic re_op re_next operand operand_min operand_max operand_cmp re_multi_type backslash_trans get_char_class init_class_tab ri_digit ri_hex ri_octal ri_word ri_head ri_alpha ri_lower ri_upper ri_white re_multiline re_lookbehind get_equi_class reg_equi_class get_coll_element get_cpo_flags skip_anyof skip_regexp bt_regcomp regcomp_start reg regbranch regconcat regpiece regatom do_multibyte use_multibytecode regnode regc regmbc reginsert reginsert_nr reginsert_limits re_put_long regtail regoptail initchr save_parse_state restore_parse_state peekchr skipchr skipchr_keepstart getchr ungetchr gethexchrs getdecchrs getoctchrs coll_get_char read_limits COPY_regsave ARRAY_save_se create_regstack create_backpos reg_getline bt_regexec_nl bt_regexec_multi bt_regexec_both make_extmatch regtry reg_prev_class reg_match_visual regmatch push_regitem pop_regitem drop_regbehind drop_regstar regrepeat regnext prog_magic_wrong cleanup_subexpr cleanup_zsubexpr save_subexpr restore_subexpr reg_nextline reg_save reg_restore reg_save_equal save_se_multi save_se_one save_se restore_se re_num_cmp match_with_backref re_mult_next mb_decompose cstrncmp cstrchr regtilde vim_regsub vim_regsub_multi vim_regsub_both nfa_regcomp_start nfa_get_reganch nfa_get_regstart nfa_get_match_text grow_post_array nfa_recognize_char_class emc1 emc2 nfa_emit_equi_class nfa_regatom nfa_do_multibyte nfa_regpiece nfa_regconcat nfa_regbranch nfa_reg re2post alloc_state nfa_max_width COPY_frag alloc_frag fr_single fr_patch fr_append new_nfa_stack st_push st_pop st_error post2nfa nfa_postprocess MIN1_multipos COPY_multipos ARRAY_multipos COPY__multipos ZER0_linepos COPY_linepos ARRAY_linepos COPY__linepos COPY_regsub COPY_regsubs COPY_nfa_pim COPY_nfa_thread ARRAY_nfa_thread ARRAY_nfa_list copy_pim clear_sub copy_sub copy_sub_off copy_ze_off sub_equal has_state_with_pos pim_equal match_follows state_in_list addstate addstate_here check_char_class match_backref match_zref nfa_save_listids nfa_restore_listids nfa_re_num_cmp recursive_regmatch failure_chance skip_to_start find_match_text nfa_regmatch nfa_regtry nfa_regexec_both nfa_regcomp nfa_regexec_nl nfa_regexec_multi vim_regcomp report_re_switch vim_regexec_both vim_regexec_prog vim_regexec vim_regexec_nl vim_regexec_multi COPY_soffset new_spat search_regcomp get_search_pat save_re_pat ignorecase pat_has_uppercase last_search_pat last_pat_prog searchit first_submatch do_search searchc findmatch check_prevcol findmatchlimit check_linecomment showmatch cls fwd_word bck_word end_word bckend_word skip_chars back_in_line current_word current_block find_next_quote find_prev_quote current_quote current_search is_one_char linewhite ml_open ml_get ml_get_pos ml_get_curline ml_get_cursor ml_get_buf ml_append ml_replace ml_delete close_buffer newBuffer fileinfo col_print get_rel_pos buf_spname set_chartab reset_chartab get_chartab init_chartab buf_init_chartab trans_characters transchar transchar_byte transchar_nonprint transchar_hex nr2hex mb_byte2cells mb_char2cells mb_ptr2cells mb_string2cells win_buf_chartabsize chartabsize linetabsize linetabsize_col win_linetabsize vim_isIDc vim_iswordc us_iswordb us_iswordp vim_isfilec vim_isprintc lbr_chartabsize lbr_chartabsize_adv win_lbr_chartabsize win_nolbr_chartabsize in_win_border getvcol getvcol_nolist getvvcol getvcols skipwhite skipdigits asc_isdigit asc_isodigit asc_isxdigit getdigits vim_str2nr hex2nr digr do_digraph get_digraph getexactdigraph getdigraph us_byte2len mb_byte2len us_get_class intable utf_char2cells us_ptr2cells us_string2cells utf_off2cells us_ptr2char us_safe_read_char_adv us_ptr2char_adv us_ptr2char_cc us_ptr2char_cc_len utfc_char2bytes us_ptr2len us_ptr2len_len us_ptr2len_cc us_ptr2len_cc_len utf_char2len utf_char2bytes utf_iscomposing utf_printable utf_class utf_convert utf_fold utf_tolower utf_toupper utf_islower utf_isupper us__strnicmp us_strnicmp show_utf8 us_head_off us_off_next us_tail_off utf_find_illegal mb_adjust_pos us_ptr_back us_prevptr us_charlen mb_lefthalve mb_fix_col get_indent get_indent_str set_indent copy_indent get_breakindent_win cin_is_cinword open_line plines plines_win plines_win_nofold plines_win_col plines_m_win ins_bytes ins_bytes_len ins_char ins_char_bytes ins_str del_char del_chars del_bytes truncate_line del_lines gchar_pos gchar_cursor inindent skip_to_option_part changed changed_bytes changed_one_line appended_lines appended_lines_mark deleted_lines deleted_lines_mark changed_lines changed_lines_buf changed_common unchanged check_status ask_yesno get_keystroke msgmore beep_flush vim_beep prepare_to_exit preserve_exit line_breakcheck fast_breakcheck goto_im virtual_active getviscol getviscol2 coladvance_force coladvance getvpos coladvance2 inc_cursor incp incl dec_cursor decp decl get_cursor_rel_lnum check_cursor_lnum check_cursor_col check_cursor_col_win check_cursor adjust_cursor_col leftcol_changed STRDUP STRNDUP vim_strsave_escaped vim_strsave_escaped_ext vim_strup vim_strsave_up copy_spaces copy_chars vim_strncpy vim_strcat copy_option_part vim_strchr vim_strbyte vim_strrchr vim_isspace simplify_key handle_x_keys get_special_key_name find_special_key_in_table get_real_state emsg3 emsgn trigger_cursorhold u_save_cursor u_save u_savesub u_inssub u_savedel undo_allowed get_undolevel u_savecommon u_undo u_redo u_doit undo_time u_undoredo u_undo_end u_sync u_add_time u_get_headentry u_getbot u_freeheader u_freebranch u_freeentries u_saveline u_clearline u_undoline parse_builtin_tcap set_term out_flush out_flush_check out_char out_char_nf _addfmt _tgoto _tputs out_str_nf out_str term_windgoto term_cursor_right term_append_lines term_delete_lines term_set_winsize term_fg_color term_bg_color term_color ttest check_shellsize limit_screen_size win_new_shellsize shell_resized set_shellsize settmode starttermcap stoptermcap swapping_screen scroll_start cursor_on cursor_off term_cursor_shape scroll_region_set scroll_region_reset COPY_termcode ARRAY_termcode clear_termcodes add_termcode termcode_star find_termcode del_termcode del_termcode_idx check_termcode gather_termleader ui_write ui_inchar ui_delay ui_suspend ui_get_shellsize ui_set_shellsize ui_new_shellsize ui_breakcheck is_input_buf_full is_input_buf_empty read_from_input_buf fill_input_buf ui_cursor_shape check_col check_row redraw_later redraw_win_later redraw_later_clear redraw_all_later redraw_curbuf_later redraw_buf_later redrawWinline update_curbuf update_screen conceal_cursor_line conceal_check_cursor_line update_single_line win_update win_draw_end advance_color_col win_line comp_char_differs char_needs_redraw screen_line status_redraw_all redraw_statuslines draw_vsep_win win_redr_status stl_connected screen_putchar screen_getbytes screen_comp_differs screen_puts screen_puts_len start_search_hl end_search_hl init_search_hl prepare_search_hl next_search_hl next_search_hl_pos screen_start_highlight screen_stop_highlight reset_cterm_colors screen_char screen_draw_rectangle redraw_block screen_fill check_for_delay screen_valid screenalloc screenclear screenclear2 lineclear lineinvalid linecopy can_clear screen_start windgoto setcursor win_ins_lines win_del_lines win_do_lines win_rest_invalid screen_ins_lines screen_del_lines showmode msg_pos_mode unshowmode get_trans_bufname fillchar_status fillchar_vsep redrawing messaging showruler win_redr_ruler number_width screen_screencol screen_screenrow do_window cmd_with_count win_split win_split_ins win_init win_valid win_exchange win_rotate win_totop win_equal win_equal_rec one_window win_close win_free_mem winframe_remove win_altframe frame2win frame_has_win frame_new_height frame_fixed_height frame_fixed_width frame_add_statusline frame_new_width frame_add_vsep frame_fix_width frame_fix_height frame_minheight frame_minwidth close_others win_init_empty win_alloc_first newFrame win_init_size win_goto win_goto_ver win_goto_hor win_enter win_enter_ext newWindow win_free win_append win_remove frame_append frame_insert frame_remove win_alloc_lines win_free_lines shell_new_rows shell_new_columns win_comp_pos frame_comp_pos win_setheight win_setheight_win frame_setheight win_setwidth win_setwidth_win frame_setwidth win_setminheight set_fraction win_new_height win_new_width win_comp_scroll command_height frame_add_height last_status last_status_rec min_rows clear_matches frame_check_height frame_check_width COPY_lineoff comp_botline redraw_for_cursorline update_topline_redraw update_topline scrolljump_value check_top_offset update_curswant check_cursor_moved changed_window_setting changed_window_setting_win set_topline changed_cline_bef_curs changed_cline_bef_curs_win changed_line_abv_curs changed_line_abv_curs_win validate_botline invalidate_botline invalidate_botline_win approximate_botline_win cursor_valid validate_cursor curs_rows validate_virtcol validate_virtcol_win validate_cheight validate_cursor_col win_col_off curwin_col_off win_col_off2 curwin_col_off2 curs_columns scrolldown scrollup topline_back botline_forw scroll_cursor_top set_empty_rows scroll_cursor_bot scroll_cursor_halfway cursor_correct onepage get_scroll_overlap halfpage do_check_cursorbind COPY_hl_group syn_get_sub_char restore_cterm_colors get_attr_entry clear_hl_tables hl_combine_attr syn_attr2attr syn_term_attr2entry syn_cterm_attr2entry set_hl_attr syn_name2id syn_check_group syn_add_group syn_id2attr syn_get_final_id highlight_changed main_loop getout)

;;; ============================================================================================== VimC

;; Definitions of various common control characters.

(final byte NUL     000)    ;; %% VimA/NUL
(final byte BELL    007)
(final byte BS      010)
(final byte TAB     011)
(final byte NL      012)
(final byte FF      014)
(final byte CAR     015)    ;; CR is used by Mac OS X
(final byte ESC     033)
(final byte DEL    0x7f)

(final byte! POUND 0xa3)

(final Bytes
    NL_STR   (u8 "\012")
    ESC_STR  (u8 "\033")
    DEL_STR  (u8 "\177"))

(defn- eos?
    ([x] (eos? x 0))
    ([x y] (== (.at x y) NUL)))
(defn- non-eos?
    ([x] (non-eos? x 0))
    ([x y] (!= (.at x y) NUL)))

(defn- #_int alphaOrd [#_int x]
    (if (< x (byte \a)) (- x (byte \A)) (- x (byte \a))))

(defn- #_int lowerOrd [#_int x]
    (- x (byte \a)))
(defn- #_int upperOrd [#_int x]
    (- x (byte \A)))

(defn- #_int rot13 [#_int c, #_int a]
    (+ (% (+ (- c a) 13) 26) a))

(defn- #_int ctrl_key [#_byte c]
    (if (< c NUL) (char_u c) (bit-xor (asc_toupper c) 0x40)))       ;; '?' -> DEL, '@' -> ^@, etc.

(final Bytes
    CTRL_H_STR (u8 "\010")
    CTRL_V_STR (u8 "\026"))

(final byte
    Ctrl_AT   0,        ;; @
    Ctrl_A    1,
    Ctrl_B    2,
    Ctrl_C    3,
    Ctrl_D    4,
    Ctrl_E    5,
    Ctrl_F    6,
    Ctrl_G    7,
    Ctrl_H    8,
    Ctrl_I    9,
    Ctrl_J   10,
    Ctrl_K   11,
    Ctrl_L   12,
    Ctrl_M   13,
    Ctrl_N   14,
    Ctrl_O   15,
    Ctrl_P   16,
    Ctrl_Q   17,
    Ctrl_R   18,
    Ctrl_S   19,
    Ctrl_T   20,
    Ctrl_U   21,
    Ctrl_V   22,
    Ctrl_W   23,
    Ctrl_X   24,
    Ctrl_Y   25,
    Ctrl_Z   26,
                        ;; CTRL- [ Left Square Bracket == ESC
    Ctrl_BSL 28,        ;; \ BackSLash
    Ctrl_RSB 29,        ;; ] Right Square Bracket
    Ctrl_HAT 30,        ;; ^
    Ctrl__   31)

;; ----------------------------------------------------------------------- ;;

;; Keycode definitions for special keys.
;;
;; Any special key code sequences are replaced by these codes.

;; KB_SPECIAL is the first byte of a special key code and is always followed by two bytes.
;; The second byte can have any value.  ASCII is used for normal termcap entries,
;; 0x80 and higher for special keys, see below.
;; The third byte is guaranteed to be between 0x02 and 0x7f.

(final byte! KB_SPECIAL         0x80)

;; Positive characters are "normal" characters.
;; Negative characters are special key codes.  Only characters below -0x200 are used,
;; so that the absolute value can't be mistaken for a single-byte character.

(defn- #_boolean is_special [#_int c]
    (< c 0))

;; NUL cannot be in the input string, therefore it is replaced by
;;      KB_SPECIAL  KS_ZERO     KE_FILLER

(final byte! KS_ZERO            255)

;; KB_SPECIAL cannot be in the input string, therefore it is replaced by
;;      KB_SPECIAL  KS_SPECIAL  KE_FILLER

(final byte! KS_SPECIAL         254)

;; KS_EXTRA is used for keys that have no termcap name
;;      KB_SPECIAL  KS_EXTRA    KE_xxx

(final byte! KS_EXTRA           253)

;; KS_MODIFIER is used when a modifier is given for a (special) key
;;      KB_SPECIAL  KS_MODIFIER bitmask

(final byte! KS_MODIFIER        252)

;; These are used for the GUI
;;      KB_SPECIAL  KS_xxx      KE_FILLER

(final byte! KS_VER_SCROLLBAR   249)
(final byte! KS_HOR_SCROLLBAR   248)

;; Used for switching Select mode back on after a mapping or menu.

(final byte! KS_SELECT          245)

;; Used a termcap entry that produces a normal character.

(final byte! KS_KEY             242)

;; Filler used after KS_SPECIAL and others.

(final byte KE_FILLER            \X)

;; Translation of three byte code "KB_SPECIAL a b" into int "K_xxx" and back.

(defn- #_int TERMCAP2KEY [#_byte a, #_byte b]
    (int (- (+ (char_u a) (<< (char_u b) 8)))))

(defn- #_byte KEY2TERMCAP0 [#_int x]
    (byte! (& (- x) 0xff)))

(defn- #_byte KEY2TERMCAP1 [#_int x]
    (byte! (& (>>> (- x) 8) 0xff)))

;; Get second or third byte when translating special key code into three bytes.

(defn- #_byte KB_SECOND [#_int c]
    (cond (== c (char_u KB_SPECIAL)) KS_SPECIAL (== c NUL) KS_ZERO :else (KEY2TERMCAP0 c)))

(defn- #_byte KB_THIRD [#_int c]
    (if (or (== c (char_u KB_SPECIAL)) (== c NUL)) KE_FILLER (KEY2TERMCAP1 c)))

;; Codes for keys that do not have a termcap name.
;;
;; KB_SPECIAL KS_EXTRA KE_xxx

(final byte
    KE_S_UP 4,            ;; shift-up
    KE_S_DOWN 5,          ;; shift-down

    KE_S_F1 6,            ;; shifted function keys
    KE_S_F2 7,
    KE_S_F3 8,
    KE_S_F4 9,
    KE_S_F5 10,
    KE_S_F6 11,
    KE_S_F7 12,
    KE_S_F8 13,
    KE_S_F9 14,
    KE_S_F10 15,

    KE_S_F11 16,
    KE_S_F12 17,

;; Symbols for pseudo keys which are translated from the real key symbols above.

    KE_IGNORE 53,         ;; ignored mouse drag/release

    KE_TAB 54,            ;; unshifted TAB key

    KE_XF1 56,            ;; extra vt100 function keys for xterm
    KE_XF2 57,
    KE_XF3 58,
    KE_XF4 59,
    KE_XEND 60,           ;; extra (vt100) end key for xterm
    KE_ZEND 61,           ;; extra (vt100) end key for xterm
    KE_XHOME 62,          ;; extra (vt100) home key for xterm
    KE_ZHOME 63,          ;; extra (vt100) home key for xterm
    KE_XUP 64,            ;; extra vt100 cursor keys for xterm
    KE_XDOWN 65,
    KE_XLEFT 66,
    KE_XRIGHT 67,

    KE_S_XF1 70,          ;; extra vt100 shifted function keys for xterm
    KE_S_XF2 71,
    KE_S_XF3 72,
    KE_S_XF4 73,

    KE_KINS 78,           ;; keypad Insert key
    KE_KDEL 79,           ;; keypad Delete key

    KE_CMDWIN 83,         ;; open command-line window from Command-line Mode

    KE_C_LEFT 84,         ;; control-left
    KE_C_RIGHT 85,        ;; control-right
    KE_C_HOME 86,         ;; control-home
    KE_C_END 87,          ;; control-end

    KE_DROP 94,           ;; DnD data is available
    KE_CURSORHOLD 95,     ;; CursorHold event

    KE_NOP 98)            ;; doesn't do anything

;; the three byte codes are replaced with the following int when using vgetc()

(final int
    K_ZERO          (TERMCAP2KEY KS_ZERO KE_FILLER),

    K_UP            (TERMCAP2KEY (byte \k) (byte \u)),
    K_DOWN          (TERMCAP2KEY (byte \k) (byte \d)),
    K_LEFT          (TERMCAP2KEY (byte \k) (byte \l)),
    K_RIGHT         (TERMCAP2KEY (byte \k) (byte \r)),
    K_S_UP          (TERMCAP2KEY KS_EXTRA KE_S_UP),
    K_S_DOWN        (TERMCAP2KEY KS_EXTRA KE_S_DOWN),
    K_S_LEFT        (TERMCAP2KEY (byte \#) (byte \4)),
    K_C_LEFT        (TERMCAP2KEY KS_EXTRA KE_C_LEFT),
    K_S_RIGHT       (TERMCAP2KEY (byte \%) (byte \i)),
    K_C_RIGHT       (TERMCAP2KEY KS_EXTRA KE_C_RIGHT),
    K_S_HOME        (TERMCAP2KEY (byte \#) (byte \2)),
    K_C_HOME        (TERMCAP2KEY KS_EXTRA KE_C_HOME),
    K_S_END         (TERMCAP2KEY (byte \*) (byte \7)),
    K_C_END         (TERMCAP2KEY KS_EXTRA KE_C_END),
    K_TAB           (TERMCAP2KEY KS_EXTRA KE_TAB),
    K_S_TAB         (TERMCAP2KEY (byte \k) (byte \B)),

;; extra set of function keys F1-F4, for vt100 compatible xterm
    K_XF1           (TERMCAP2KEY KS_EXTRA KE_XF1),
    K_XF2           (TERMCAP2KEY KS_EXTRA KE_XF2),
    K_XF3           (TERMCAP2KEY KS_EXTRA KE_XF3),
    K_XF4           (TERMCAP2KEY KS_EXTRA KE_XF4),

;; extra set of cursor keys for vt100 compatible xterm
    K_XUP           (TERMCAP2KEY KS_EXTRA KE_XUP),
    K_XDOWN         (TERMCAP2KEY KS_EXTRA KE_XDOWN),
    K_XLEFT         (TERMCAP2KEY KS_EXTRA KE_XLEFT),
    K_XRIGHT        (TERMCAP2KEY KS_EXTRA KE_XRIGHT),

    K_F1            (TERMCAP2KEY (byte \k) (byte \1)),   ;; function keys
    K_F2            (TERMCAP2KEY (byte \k) (byte \2)),
    K_F3            (TERMCAP2KEY (byte \k) (byte \3)),
    K_F4            (TERMCAP2KEY (byte \k) (byte \4)),
    K_F5            (TERMCAP2KEY (byte \k) (byte \5)),
    K_F6            (TERMCAP2KEY (byte \k) (byte \6)),
    K_F7            (TERMCAP2KEY (byte \k) (byte \7)),
    K_F8            (TERMCAP2KEY (byte \k) (byte \8)),
    K_F9            (TERMCAP2KEY (byte \k) (byte \9)),
    K_F10           (TERMCAP2KEY (byte \k) (byte \;)),

    K_F11           (TERMCAP2KEY (byte \F) (byte \1)),
    K_F12           (TERMCAP2KEY (byte \F) (byte \2)),

;; extra set of shifted function keys F1-F4, for vt100 compatible xterm
    K_S_XF1         (TERMCAP2KEY KS_EXTRA KE_S_XF1),
    K_S_XF2         (TERMCAP2KEY KS_EXTRA KE_S_XF2),
    K_S_XF3         (TERMCAP2KEY KS_EXTRA KE_S_XF3),
    K_S_XF4         (TERMCAP2KEY KS_EXTRA KE_S_XF4),

    K_S_F1          (TERMCAP2KEY KS_EXTRA KE_S_F1),  ;; shifted func. keys
    K_S_F2          (TERMCAP2KEY KS_EXTRA KE_S_F2),
    K_S_F3          (TERMCAP2KEY KS_EXTRA KE_S_F3),
    K_S_F4          (TERMCAP2KEY KS_EXTRA KE_S_F4),
    K_S_F5          (TERMCAP2KEY KS_EXTRA KE_S_F5),
    K_S_F6          (TERMCAP2KEY KS_EXTRA KE_S_F6),
    K_S_F7          (TERMCAP2KEY KS_EXTRA KE_S_F7),
    K_S_F8          (TERMCAP2KEY KS_EXTRA KE_S_F8),
    K_S_F9          (TERMCAP2KEY KS_EXTRA KE_S_F9),
    K_S_F10         (TERMCAP2KEY KS_EXTRA KE_S_F10),

    K_S_F11         (TERMCAP2KEY KS_EXTRA KE_S_F11),
    K_S_F12         (TERMCAP2KEY KS_EXTRA KE_S_F12),

    K_HELP          (TERMCAP2KEY (byte \%) (byte \1)),
    K_UNDO          (TERMCAP2KEY (byte \&) (byte \8)),

    K_BS            (TERMCAP2KEY (byte \k) (byte \b)),

    K_INS           (TERMCAP2KEY (byte \k) (byte \I)),
    K_KINS          (TERMCAP2KEY KS_EXTRA KE_KINS),
    K_DEL           (TERMCAP2KEY (byte \k) (byte \D)),
    K_KDEL          (TERMCAP2KEY KS_EXTRA KE_KDEL),
    K_HOME          (TERMCAP2KEY (byte \k) (byte \h)),
    K_KHOME         (TERMCAP2KEY (byte \K) (byte \1)),   ;; keypad home (upper left)
    K_XHOME         (TERMCAP2KEY KS_EXTRA KE_XHOME),
    K_ZHOME         (TERMCAP2KEY KS_EXTRA KE_ZHOME),
    K_END           (TERMCAP2KEY (byte \@) (byte \7)),
    K_KEND          (TERMCAP2KEY (byte \K) (byte \4)),   ;; keypad end (lower left)
    K_XEND          (TERMCAP2KEY KS_EXTRA KE_XEND),
    K_ZEND          (TERMCAP2KEY KS_EXTRA KE_ZEND),
    K_PAGEUP        (TERMCAP2KEY (byte \k) (byte \P)),
    K_PAGEDOWN      (TERMCAP2KEY (byte \k) (byte \N)),
    K_KPAGEUP       (TERMCAP2KEY (byte \K) (byte \3)),   ;; keypad pageup (upper R.)
    K_KPAGEDOWN     (TERMCAP2KEY (byte \K) (byte \5)),   ;; keypad pagedown (lower R.)

    K_KPLUS         (TERMCAP2KEY (byte \K) (byte \6)),   ;; keypad plus
    K_KMINUS        (TERMCAP2KEY (byte \K) (byte \7)),   ;; keypad minus
    K_KDIVIDE       (TERMCAP2KEY (byte \K) (byte \8)),   ;; keypad /
    K_KMULTIPLY     (TERMCAP2KEY (byte \K) (byte \9)),   ;; keypad *
    K_KENTER        (TERMCAP2KEY (byte \K) (byte \A)),   ;; keypad Enter
    K_KPOINT        (TERMCAP2KEY (byte \K) (byte \B)),   ;; keypad . or ,

    K_K0            (TERMCAP2KEY (byte \K) (byte \C)),   ;; keypad 0
    K_K1            (TERMCAP2KEY (byte \K) (byte \D)),   ;; keypad 1
    K_K2            (TERMCAP2KEY (byte \K) (byte \E)),   ;; keypad 2
    K_K3            (TERMCAP2KEY (byte \K) (byte \F)),   ;; keypad 3
    K_K4            (TERMCAP2KEY (byte \K) (byte \G)),   ;; keypad 4
    K_K5            (TERMCAP2KEY (byte \K) (byte \H)),   ;; keypad 5
    K_K6            (TERMCAP2KEY (byte \K) (byte \I)),   ;; keypad 6
    K_K7            (TERMCAP2KEY (byte \K) (byte \J)),   ;; keypad 7
    K_K8            (TERMCAP2KEY (byte \K) (byte \K)),   ;; keypad 8
    K_K9            (TERMCAP2KEY (byte \K) (byte \L)),   ;; keypad 9

    K_VER_SCROLLBAR (TERMCAP2KEY KS_VER_SCROLLBAR KE_FILLER),
    K_HOR_SCROLLBAR (TERMCAP2KEY KS_HOR_SCROLLBAR KE_FILLER),

    K_SELECT        (TERMCAP2KEY KS_SELECT KE_FILLER),

;; Symbols for pseudo keys which are translated from the real key symbols above.

    K_IGNORE        (TERMCAP2KEY KS_EXTRA KE_IGNORE),
    K_NOP           (TERMCAP2KEY KS_EXTRA KE_NOP),

    K_CMDWIN        (TERMCAP2KEY KS_EXTRA KE_CMDWIN),

    K_DROP          (TERMCAP2KEY KS_EXTRA KE_DROP),

    K_CURSORHOLD    (TERMCAP2KEY KS_EXTRA KE_CURSORHOLD))

;; Bits for modifier mask.
;; 0x01 cannot be used, because the modifier must be 0x02 or higher
(final int MOD_MASK_SHIFT      0x02)
(final int MOD_MASK_CTRL       0x04)
(final int MOD_MASK_ALT        0x08)        ;; aka META
(final int MOD_MASK_META       0x10)        ;; META when it's different from ALT
(final int MOD_MASK_2CLICK     0x20)        ;; use MOD_MASK_MULTI_CLICK
(final int MOD_MASK_3CLICK     0x40)        ;; use MOD_MASK_MULTI_CLICK
(final int MOD_MASK_4CLICK     0x60)        ;; use MOD_MASK_MULTI_CLICK

(final int MOD_MASK_MULTI_CLICK (| MOD_MASK_2CLICK MOD_MASK_3CLICK MOD_MASK_4CLICK))

;; The length of the longest special key name, including modifiers.
;; Current longest is <M-C-S-T-4-MiddleRelease> (length includes '<' and '>').

(final int MAX_KEY_NAME_LEN    25)

;; Maximum length of a special key event as tokens.  This includes modifiers.
;; The longest event is something like <M-C-S-T-4-LeftDrag> which would be the
;; following string of tokens:
;;
;; <KB_SPECIAL> <KS_MODIFIER> bitmask <KB_SPECIAL> <KS_EXTRA> <KE_LEFTDRAG>.
;;
;; This is a total of 6 tokens, and is currently the longest one possible.

(final int MAX_KEY_CODE_LEN    6)

;; Get single int code from second byte after KB_SPECIAL.

(defn- #_int toSpecial [#_byte a, #_byte b]
    (cond (== a KS_SPECIAL) (char_u KB_SPECIAL) (== a KS_ZERO) K_ZERO :else (TERMCAP2KEY a, b)))

;; ----------------------------------------------------------------------- ;;

;; This file contains the defines for the machine dependent escape sequences
;; that the editor needs to perform various operations.  All of the sequences
;; here are optional, except "cm" (cursor motion).

;; Index of the termcap codes in the 'term_strings' array.

(final int
    KS_NAME  0,     ;; name of this terminal entry
    KS_CE    1,     ;; clear to end of line
    KS_AL    2,     ;; add new blank line
    KS_CAL   3,     ;; add number of blank lines
    KS_DL    4,     ;; delete line
    KS_CDL   5,     ;; delete number of lines
    KS_CS    6,     ;; scroll region
    KS_CL    7,     ;; clear screen
    KS_CD    8,     ;; clear to end of display
    KS_UT    9,     ;; clearing uses current background color
    KS_DA   10,     ;; text may be scrolled down from up
    KS_DB   11,     ;; text may be scrolled up from down
    KS_VI   12,     ;; cursor invisible
    KS_VE   13,     ;; cursor visible
    KS_VS   14,     ;; cursor very visible
    KS_ME   15,     ;; normal mode
    KS_MR   16,     ;; reverse mode
    KS_MD   17,     ;; bold mode
    KS_SE   18,     ;; normal mode
    KS_SO   19,     ;; standout mode
    KS_CZH  20,     ;; italic mode start
    KS_CZR  21,     ;; italic mode end
    KS_UE   22,     ;; exit underscore (underline) mode
    KS_US   23,     ;; underscore (underline) mode
    KS_MS   24,     ;; save to move cur in reverse mode
    KS_CM   25,     ;; cursor motion
    KS_SR   26,     ;; scroll reverse (backward)
    KS_CRI  27,     ;; cursor number of chars right
    KS_VB   28,     ;; visual bell
    KS_KS   29,     ;; put term in "keypad transmit" mode
    KS_KE   30,     ;; out of "keypad transmit" mode
    KS_TI   31,     ;; put terminal in termcap mode
    KS_TE   32,     ;; out of termcap mode
    KS_BC   33,     ;; backspace character (cursor left)
    KS_CCO  34,     ;; number of colors
    KS_CSF  35,     ;; set foreground color
    KS_CSB  36,     ;; set background color
    KS_XN   37,     ;; newline glitch
    KS_CAF  38,     ;; set foreground color (ANSI)
    KS_CAB  39,     ;; set background color (ANSI)
    KS_LE   40,     ;; cursor left (mostly backspace)
    KS_ND   41,     ;; cursor right
    KS_CWS  42,     ;; set window size in characters
    KS_CSI  43,     ;; start insert mode (bar cursor)
    KS_CEI  44,     ;; end insert mode (block cursor)
    KS_CSR  45,     ;; start replace mode (underline cursor)
    KS_CSV  46,     ;; scroll region vertical
    KS_OP   47)     ;; original color pair

;; The terminal capabilities are stored in this array.
;; IMPORTANT: When making changes, note the following:
;; - there should be an entry for each code in the builtin termcaps
;; - there should be an option for each code in option.c
;; - there should be code in term.c to obtain the value from the termcap

;; strings used for terminal

(atom! Bytes
    T_NAME  nil,    ;; terminal name
    T_CE    nil,    ;; clear to end of line
    T_AL    nil,    ;; add new blank line
    T_CAL   nil,    ;; add number of blank lines
    T_DL    nil,    ;; delete line
    T_CDL   nil,    ;; delete number of lines
    T_CS    nil,    ;; scroll region
    T_CL    nil,    ;; clear screen
    T_CD    nil,    ;; clear to end of display
    T_UT    nil,    ;; clearing uses background color
    T_DA    nil,    ;; text may be scrolled down from up
    T_DB    nil,    ;; text may be scrolled up from down
    T_VI    nil,    ;; cursor invisible
    T_VE    nil,    ;; cursor visible
    T_VS    nil,    ;; cursor very visible
    T_ME    nil,    ;; normal mode
    T_MR    nil,    ;; reverse mode
    T_MD    nil,    ;; bold mode
    T_SE    nil,    ;; normal mode
    T_SO    nil,    ;; standout mode
    T_CZH   nil,    ;; italic mode start
    T_CZR   nil,    ;; italic mode end
    T_UE    nil,    ;; exit underscore (underline) mode
    T_US    nil,    ;; underscore (underline) mode
    T_MS    nil,    ;; save to move cur in reverse mode
    T_CM    nil,    ;; cursor motion
    T_SR    nil,    ;; scroll reverse (backward)
    T_CRI   nil,    ;; cursor number of chars right
    T_VB    nil,    ;; visual bell
    T_KS    nil,    ;; put term in "keypad transmit" mode
    T_KE    nil,    ;; out of "keypad transmit" mode
    T_TI    nil,    ;; put terminal in termcap mode
    T_TE    nil,    ;; out of termcap mode
    T_BC    nil,    ;; backspace character
    T_CCO   nil,    ;; number of colors
    T_CSF   nil,    ;; set foreground color
    T_CSB   nil,    ;; set background color
    T_XN    nil,    ;; newline glitch
    T_CAF   nil,    ;; set foreground color (ANSI)
    T_CAB   nil,    ;; set background color (ANSI)
    T_LE    nil,    ;; cursor left
    T_ND    nil,    ;; cursor right
    T_CWS   nil,    ;; window size
    T_CSI   nil,    ;; start insert mode
    T_CEI   nil,    ;; end insert mode
    T_CSR   nil,    ;; start replace mode
    T_CSV   nil,    ;; scroll region vertical
    T_OP    nil)    ;; original color pair

;; 'term_strings' contains currently used terminal output strings.
;; It is initialized with the default values by parse_builtin_tcap().
;; The values can be changed by setting the option with the same name.

(final Bytes*' term_strings [ T_NAME T_CE T_AL  T_CAL T_DL  T_CDL T_CS  T_CL
                              T_CD   T_UT T_DA  T_DB  T_VI  T_VE  T_VS  T_ME
                              T_MR   T_MD T_SE  T_SO  T_CZH T_CZR T_UE  T_US
                              T_MS   T_CM T_SR  T_CRI T_VB  T_KS  T_KE  T_TI
                              T_TE   T_BC T_CCO T_CSF T_CSB T_XN  T_CAF T_CAB
                              T_LE   T_ND T_CWS T_CSI T_CEI T_CSR T_CSV T_OP ])

(final int TMODE_COOK  0)   ;; terminal mode for external cmds and Ex mode
(final int TMODE_SLEEP 1)   ;; terminal mode for sleeping (cooked but no echo)
(final int TMODE_RAW   2)   ;; terminal mode for Normal and Insert mode

;; ----------------------------------------------------------------------- ;;

;; flags for update_screen()
;; The higher the value, the higher the priority

(final int VALID        10) ;; buffer not changed, or changes marked with b_mod_*
(final int INVERTED     20) ;; redisplay inverted part that changed
(final int INVERTED_ALL 25) ;; redisplay whole inverted part
(final int REDRAW_TOP   30) ;; display first w_upd_rows screen lines
(final int SOME_VALID   35) ;; like NOT_VALID but may scroll
(final int NOT_VALID    40) ;; buffer needs complete redraw
(final int CLEAR        50) ;; screen messed up, clear it

;; Flags for w_valid.
;; These are set when something in a window structure becomes invalid, except when the cursor is moved.
;; Call check_cursor_moved() before testing one of the flags.
;; These are reset when that thing has been updated and is valid again.
;;
;; Every function that invalidates one of these must call one of the invalidate_* functions.
;;
;; w_valid is supposed to be encapsulated: use the functions that set or reset the flags, instead.
;;
;; VALID_BOTLINE    VALID_BOTLINE_AP
;;     on               on              w_botline valid
;;     off              on              w_botline approximated
;;     off              off             w_botline not valid
;;     on               off             not possible

(final int VALID_WROW         0x01)     ;; w_wrow (window row) is valid
(final int VALID_WCOL         0x02)     ;; w_wcol (window col) is valid
(final int VALID_VIRTCOL      0x04)     ;; w_virtcol (file col) is valid
(final int VALID_CHEIGHT      0x08)     ;; w_cline_height and w_cline_folded valid
(final int VALID_CROW         0x10)     ;; w_cline_row is valid
(final int VALID_BOTLINE      0x20)     ;; w_botine and w_empty_rows are valid
(final int VALID_BOTLINE_AP   0x40)     ;; w_botine is approximated
(final int VALID_TOPLINE      0x80)     ;; w_topline is valid (for cursor position)

;; Terminal highlighting attribute bits.
;; Attributes above HL_ALL are used for syntax highlighting.

(final int HL_NORMAL          0x00)
(final int HL_INVERSE         0x01)
(final int HL_BOLD            0x02)
(final int HL_ITALIC          0x04)
(final int HL_UNDERLINE       0x08)
(final int HL_UNDERCURL       0x10)
(final int HL_STANDOUT        0x20)
(final int HL_ALL             0x3f)

;; values for State
;;
;; The lower bits up to 0x20 are used to distinguish normal/visual/op_pending
;; and cmdline/insert+replace mode.  This is used for mapping.
;; If none of these bits are set, no mapping is done.
;; The upper bits are used to distinguish between other states.

(final int
    NORMAL          0x01,             ;; normal mode, command expected
    VISUAL          0x02,             ;; visual mode - use get_real_state()
    OP_PENDING      0x04,             ;; normal mode, operator is pending - use get_real_state()
    CMDLINE         0x08,             ;; editing command line
    INSERT          0x10,             ;; insert mode

    REPLACE_FLAG    0x40,             ;; replace mode flag
    REPLACE         (+ REPLACE_FLAG INSERT),
    VREPLACE_FLAG   0x80,             ;; virtual-replace mode flag
    VREPLACE        (+ REPLACE_FLAG VREPLACE_FLAG INSERT),

    NORMAL_BUSY     (+ 0x100 NORMAL), ;; normal mode, busy with a command
    HITRETURN       (+ 0x200 NORMAL), ;; waiting for return or command
    ASKMORE         0x300,            ;; asking if you want --more--
    SETWSIZE        0x400,            ;; window size has changed
    SHOWMATCH       (+ 0x700 INSERT), ;; show matching paren
    CONFIRM         0x800,            ;; ":confirm" prompt
    SELECTMODE      0x1000)           ;; select mode, only for mappings

;; directions
(final int FORWARD        1)
(final int BACKWARD       -1)

(final int HL_CONTAINED    0x01)    ;; not used on toplevel
(final int HL_TRANSP       0x02)    ;; has no highlighting
(final int HL_ONELINE      0x04)    ;; match within one line only
(final int HL_HAS_EOL      0x08)    ;; end pattern that matches with $
(final int HL_SYNC_HERE    0x10)    ;; sync point after this item (syncing only)
(final int HL_SYNC_THERE   0x20)    ;; sync point at current line (syncing only)
(final int HL_MATCH        0x40)    ;; use match ID instead of item ID
(final int HL_SKIPNL       0x80)    ;; nextgroup can skip newlines
(final int HL_SKIPWHITE    0x100)   ;; nextgroup can skip white space
(final int HL_SKIPEMPTY    0x200)   ;; nextgroup can skip empty lines
(final int HL_KEEPEND      0x400)   ;; end match always kept
(final int HL_EXCLUDENL    0x800)   ;; exclude NL from match
(final int HL_DISPLAY      0x1000)  ;; only used for displaying, not syncing
(final int HL_FOLD         0x2000)  ;; define fold
(final int HL_EXTEND       0x4000)  ;; ignore a keepend
(final int HL_MATCHCONT    0x8000)  ;; match continued from previous line
(final int HL_TRANS_CONT   0x10000) ;; transparent item without contains arg
(final int HL_CONCEAL      0x20000) ;; can be concealed
(final int HL_CONCEALENDS  0x40000) ;; can be concealed

;; Values for 'options' argument in do_search() and searchit().
(final int SEARCH_REV      0x01)    ;; go in reverse of previous dir.
(final int SEARCH_ECHO     0x02)    ;; echo the search command and handle options
(final int SEARCH_MSG      0x0c)    ;; give messages (yes, it's not 0x04)
(final int SEARCH_NFMSG    0x08)    ;; give all messages except not found
(final int SEARCH_OPT      0x10)    ;; interpret optional flags
(final int SEARCH_HIS      0x20)    ;; put search pattern in history
(final int SEARCH_END      0x40)    ;; put cursor at end of match
(final int SEARCH_NOOF     0x80)    ;; don't add offset to position
(final int SEARCH_START    0x100)   ;; start search without col offset
(final int SEARCH_MARK     0x200)   ;; set previous context mark
(final int SEARCH_KEEP     0x400)   ;; keep previous search pattern
(final int SEARCH_PEEK     0x800)   ;; peek for typed char, cancel search

;; Values for find_ident_under_cursor().
(final int FIND_IDENT      1)       ;; find identifier (word)
(final int FIND_STRING     2)       ;; find any string (WORD)
(final int FIND_EVAL       4)       ;; include "->", "[]" and "."

;; Values for change_indent().
(final int INDENT_SET      1)       ;; set indent
(final int INDENT_INC      2)       ;; increase indent
(final int INDENT_DEC      3)       ;; decrease indent

;; Values for flags argument for findmatchlimit().
(final int FM_BACKWARD     0x01)    ;; search backwards
(final int FM_FORWARD      0x02)    ;; search forwards
(final int FM_BLOCKSTOP    0x04)    ;; stop at start/end of block

;; Values for sub_cmd and which_pat argument for search_regcomp().
;; Also used for which_pat argument for searchit().
(final int RE_SEARCH       0)       ;; save/use pat in/from search_pattern
(final int RE_SUBST        1)       ;; save/use pat in/from subst_pattern
(final int RE_BOTH         2)       ;; save pat in both patterns
(final int RE_LAST         2)       ;; use last used pattern if "pat" is null

;; Second argument for vim_regcomp().
(final int RE_MAGIC        1)       ;; 'magic' option
(final int RE_STRING       2)       ;; match in string instead of buffer text
(final int RE_STRICT       4)       ;; don't allow [abc] without ]
(final int RE_AUTO         8)       ;; automatic engine selection

;; values for reg_do_extmatch
(final int REX_SET         1)       ;; to allow \z\(...\),
(final int REX_USE         2)       ;; to allow \z\1 et al.

;; flags for do_cmdline()
(final int DOCMD_VERBOSE   0x01)    ;; included command in error message
(final int DOCMD_NOWAIT    0x02)    ;; don't call wait_return() and friends
(final int DOCMD_KEYTYPED  0x08)    ;; don't reset keyTyped
(final int DOCMD_KEEPLINE  0x20)    ;; keep typed line for repeating with "."

;; flags for beginline()
(final int BL_WHITE        1)       ;; cursor on first non-white in the line
(final int BL_SOL          2)       ;; use 'sol' option
(final int BL_FIX          4)       ;; don't leave cursor on a NUL

;; flags for do_put()
(final int PUT_FIXINDENT   1)       ;; make indent look nice
(final int PUT_CURSEND     2)       ;; leave cursor after end of new text
(final int PUT_CURSLINE    4)       ;; leave cursor on last line of new text
(final int PUT_LINE        8)       ;; put register as lines
(final int PUT_LINE_SPLIT  16)      ;; split line for linewise register
(final int PUT_LINE_FORWARD 32)     ;; put linewise register below Visual sel.

;; flags for set_indent()
(final int SIN_CHANGED     1)       ;; call changed_bytes() when line changed
(final int SIN_INSERT      2)       ;; insert indent before existing text
(final int SIN_UNDO        4)       ;; save line for undo before changing it

;; flags for insertchar()
(final int INSCHAR_CTRLV   4)       ;; char typed just after CTRL-V

;; There are four history tables:

(final int HIST_CMD        0)       ;; colon commands
(final int HIST_SEARCH     1)       ;; search commands
(final int HIST_EXPR       2)       ;; expressions (from entering = register)
(final int HIST_INPUT      3)       ;; input() lines
(final int HIST_COUNT      4)       ;; number of history tables

;; Flags for chartab[].

(final int CT_CELL_MASK    0x07)    ;; mask: nr of display cells (1, 2 or 4)
(final int CT_PRINT_CHAR   0x10)    ;; flag: set for printable chars
(final int CT_ID_CHAR      0x20)    ;; flag: set for ID chars
(final int CT_FNAME_CHAR   0x40)    ;; flag: set for file name chars

;; arguments for win_split()

(final int WSP_VERT        2)       ;; split vertically
(final int WSP_TOP         4)       ;; window at top-left of shell
(final int WSP_BOT         8)       ;; window at bottom-right of shell
(final int WSP_BELOW       32)      ;; put new window below/right
(final int WSP_ABOVE       64)      ;; put new window above/left

;; Values for "starting".
(final int NO_SCREEN       2)       ;; no screen updating yet
(final int NO_BUFFERS      1)       ;; not all buffers loaded yet
;;                         0           not starting anymore

;; Values for index in highlight_attr[].
;; When making changes, also update HL_FLAGS below!
;; And update the default value of 'highlight' in option.c.

(final int
    HLF_8 0,        ;; Meta & special keys listed with ":map", text that is displayed different from what it is
    HLF_AT 1,       ;; @ and ~ characters at end of screen, characters that don't really exist in the text
    HLF_E 2,        ;; error messages
    HLF_I 3,        ;; incremental search
    HLF_L 4,        ;; last search string
    HLF_M 5,        ;; "--More--" message
    HLF_CM 6,       ;; Mode (e.g., "-- INSERT --")
    HLF_N 7,        ;; line number for ":number" and ":#" commands
    HLF_CLN 8,      ;; current line number
    HLF_R 9,        ;; return to continue message and yes/no questions
    HLF_S 10,       ;; status lines
    HLF_SNC 11,     ;; status lines of not-current windows
    HLF_C 12,       ;; column to separate vertically split windows
    HLF_T 13,       ;; Titles for output from ":set all", ":autocmd" etc.
    HLF_V 14,       ;; Visual mode
    HLF_W 15,       ;; warning messages
    HLF_CONCEAL 16, ;; Concealed text
    HLF_CUC 17,     ;; 'cursorcolumn'
    HLF_CUL 18,     ;; 'cursorline'
    HLF_MC 19,      ;; 'colorcolumn'

    HLF_COUNT 20)   ;; MUST be the last one

;; Operator IDs; The order must correspond to opchars[] in ops.c!

(final int
    OP_NOP       0,       ;; no pending operation
    OP_DELETE    1,       ;; "d"  delete operator
    OP_YANK      2,       ;; "y"  yank operator
    OP_CHANGE    3,       ;; "c"  change operator
    OP_LSHIFT    4,       ;; "<"  left shift operator
    OP_RSHIFT    5,       ;; ">"  right shift operator
    OP_FILTER    6,       ;; "!"  filter operator
    OP_TILDE     7,       ;; "g~" switch case operator
    OP_INDENT    8,       ;; "="  indent operator
    OP_FORMAT    9,       ;; "gq" format operator
    OP_COLON    10,       ;; ":"  colon operator
    OP_UPPER    11,       ;; "gU" make upper case operator
    OP_LOWER    12,       ;; "gu" make lower case operator
    OP_JOIN     13,       ;; "J"  join operator, only for Visual mode
    OP_JOIN_NS  14,       ;; "gJ"  join operator, only for Visual mode
    OP_ROT13    15,       ;; "g?" rot-13 encoding
    OP_REPLACE  16,       ;; "r"  replace chars, only for Visual mode
    OP_INSERT   17,       ;; "I"  Insert column, only for Visual mode
    OP_APPEND   18,       ;; "A"  Append column, only for Visual mode
    OP_FORMAT2  19,       ;; "gw" format operator, keeps cursor pos
    OP_FUNCTION 20)       ;; "g@" call 'operatorfunc'

;; Motion types, used for operators and for yank/delete registers.

(final byte!
    MCHAR   0,            ;; character-wise movement/register
    MLINE   1,            ;; line-wise movement/register
    MBLOCK  2,            ;; block-wise register
    MAUTO   0xff)         ;; decide between MLINE/MCHAR

;; Minimum screen size.

(final int MIN_COLUMNS     12)          ;; minimal columns for screen
(final int MIN_LINES       2)           ;; minimal lines for screen
(final int STATUS_HEIGHT   1)           ;; height of a status line under a window

(final int IOSIZE          (inc 1024))  ;; file i/o and sprintf buffer size
(final int MAXPATHL         4096)

(final int
    MSG_BUF_LEN     480,                ;; length of buffer for small messages
    MSG_BUF_CLEN    (/ MSG_BUF_LEN 6))  ;; cell length (worst case: utf-8 takes 6 bytes for one cell)

;; Maximum length of key sequence to be mapped.

(final int MAXMAPLEN 50)

(final long MAXLNUM 0x7fffffff)      ;; maximum (invalid) line number
(final int MAXCOL 0x7fffffff)           ;; maximum column number, 31 bits

(final int SHOWCMD_COLS 10)             ;; columns needed by shown command

;; vim_iswhite() is used for "^" and the like.  It differs from isspace()
;; because it doesn't include <CR> and <LF> and the like.

(defn- #_boolean vim_iswhite [#_int x]
    (or (== x (byte \space)) (== x (byte \tab))))

(final int MAX_MCO        6)        ;; maximum value for 'maxcombine'

;; Maximum number of bytes in a multi-byte character.  It can be one 32-bit
;; character of up to 6 bytes, or one 16-bit character of up to three bytes
;; plus six following composing characters of three bytes each.

(final int MB_MAXBYTES    21)

;;; ============================================================================================== VimD

;; option.h: definition of global variables for settable options

;; characters for the "p_cpo" option:
(final byte
    CPO_SEARCH      \c,
    CPO_DIGRAPH     \D,  ;; no digraph after "r", "f", etc.
    CPO_EMPTYREGION \E,  ;; operating on empty region is an error
    CPO_INSEND      \H,  ;; "I" inserts before last blank in line
    CPO_INDENT      \I,  ;; remove auto-indent more often
    CPO_JOINSP      \j,  ;; only use two spaces for join after '.'
    CPO_LITERAL     \l,  ;; take char after backslash in [] literal
    CPO_SHOWMATCH   \m,
    CPO_MATCHBSL    \M,  ;; "%" ignores use of backslashes
    CPO_NUMCOL      \n,  ;; 'number' column also used for text
    CPO_LINEOFF     \o,
    CPO_JOINCOL     \q,  ;; with "3J" use column after first join
    CPO_REDO        \r,
    CPO_UNDO        \u,  ;; "u" undoes itself
    CPO_CW          \w,  ;; "cw" only changes one blank
    CPO_ESC         \x,
    CPO_REPLCNT     \X,  ;; "R" with a count only deletes chars once
    CPO_YANK        \y,
    CPO_FILTER      \!,
    CPO_MATCH       \%,
    CPO_MINUS       \-,  ;; "9-" fails at and before line 9
    CPO_REGAPPEND   \>,  ;; insert NL when appending to a register

;; POSIX flags
    CPO_HASH        \#,  ;; "D", "o" and "O" do not use a count
    CPO_SUBPERCENT  \/,  ;; % in :s string uses previous one
    CPO_BACKSL      \\,  ;; \ is not special in []
    CPO_SCOLON      \;)  ;; using "," and ";" will skip over char if cursor would not move

;; default values for Vim, Vi and POSIX
(final Bytes CPO_VIM  (u8 "c"))
(final Bytes CPO_ALL  (u8 "cDEHIjlmMnoqruwxXy!%->#/\\;"))

;; characters for "p_ww" option:
(final Bytes WW_ALL   (u8 "bshl<>[],~"))

(final Bytes COCU_ALL     (u8 "nvic"))     ;; flags for 'concealcursor'

;; arguments for can_bs()
(final byte BS_INDENT     \i)      ;; "Indent"
(final byte BS_EOL        \o)      ;; "eOl"
(final byte BS_START      \s)      ;; "Start"

;; The following are actual variables for the options:

(atom! Bytes   p_bs)        ;; 'backspace'
(atom! Bytes   p_breakat)   ;; 'breakat'
(atom! long    p_ch)        ;; 'cmdheight'
(atom! long    p_cwh)       ;; 'cmdwinheight'
(atom! Bytes   p_cpo)       ;; 'cpoptions'
(atom! boolean p_deco)      ;; 'delcombine'
(atom! boolean p_dg)        ;; 'digraph'
(atom! Bytes   p_dy)        ;; 'display'

(final int
    DY_LASTLINE 0x001,
    DY_UHEX     0x002)
(atom! int    dy_flags)
(final Bytes* p_dy_values [ (u8 "lastline"), (u8 "uhex"), null ])

(atom! Bytes   p_ead)       ;; 'eadirection'
(atom! boolean p_ea)        ;; 'equalalways'
(atom! boolean p_eb)        ;; 'errorbells'
(atom! boolean p_ek)        ;; 'esckeys'
(atom! boolean p_gd)        ;; 'gdefault'
(atom! Bytes   p_hl)        ;; 'highlight'
(atom! long    p_hi)        ;; 'history'
(atom! boolean p_hls)       ;; 'hlsearch'
(atom! boolean p_ic)        ;; 'ignorecase'
(atom! boolean p_is)        ;; 'incsearch'
(atom! boolean p_im)        ;; 'insertmode'
(atom! Bytes   p_isf)       ;; 'isfname'
(atom! Bytes   p_isi)       ;; 'isident'
(atom! Bytes   p_isp)       ;; 'isprint'
(atom! boolean p_js)        ;; 'joinspaces'
(atom! Bytes   p_km)        ;; 'keymodel'
(atom! long    p_ls)        ;; 'laststatus'
(atom! boolean p_lz)        ;; 'lazyredraw'
(atom! boolean p_magic)     ;; 'magic'
(atom! long    p_mat)       ;; 'matchtime'
(atom! long    p_mco)       ;; 'maxcombine'
(atom! long    p_mmp)       ;; 'maxmempattern'
(atom! boolean p_more)      ;; 'more'
(atom! Bytes   p_opfunc)    ;; 'operatorfunc'
(atom! boolean p_paste)     ;; 'paste'
(atom! boolean p_prompt)    ;; 'prompt'
(atom! long    p_rdt)       ;; 'redrawtime'
(atom! long    p_re)        ;; 'regexpengine'
(atom! long    p_report)    ;; 'report'
(atom! boolean p_ru)        ;; 'ruler'
(atom! long    p_sj)        ;; 'scrolljump'
(atom! long    p_so)        ;; 'scrolloff'
(atom! Bytes   p_sbo)       ;; 'scrollopt'
(atom! Bytes   p_sel)       ;; 'selection'
(atom! Bytes   p_slm)       ;; 'selectmode'
(atom! boolean p_sr)        ;; 'shiftround'
(atom! Bytes   p_sbr)       ;; 'showbreak'
(atom! boolean p_sc)        ;; 'showcmd'
(atom! boolean p_sm)        ;; 'showmatch'
(atom! boolean p_smd)       ;; 'showmode'
(atom! long    p_ss)        ;; 'sidescroll'
(atom! long    p_siso)      ;; 'sidescrolloff'
(atom! boolean p_scs)       ;; 'smartcase'
(atom! boolean p_sta)       ;; 'smarttab'
(atom! boolean p_sb)        ;; 'splitbelow'
(atom! boolean p_spr)       ;; 'splitright'
(atom! boolean p_sol)       ;; 'startofline'
(atom! boolean p_to)        ;; 'tildeop'
(atom! boolean p_timeout)   ;; 'timeout'
(atom! long    p_tm)        ;; 'timeoutlen'
(atom! boolean p_ttimeout)  ;; 'ttimeout'
(atom! long    p_ttm)       ;; 'ttimeoutlen'
(atom! long    p_ttyscroll) ;; 'ttyscroll'
(atom! long    p_ut)        ;; 'updatetime'
(atom! long    p_verbose)   ;; 'verbose'
(atom! Bytes   p_ve)        ;; 'virtualedit'

(final int
    VE_BLOCK   5,       ;; includes "all"
    VE_INSERT  6,       ;; includes "all"
    VE_ALL     4,
    VE_ONEMORE 8)
(atom! int    ve_flags)
(final Bytes* p_ve_values [ (u8 "block"), (u8 "insert"), (u8 "all"), (u8 "onemore"), null ])

(atom! boolean p_vb)        ;; 'visualbell'
(atom! Bytes   p_ww)        ;; 'whichwrap'
(atom! long    p_wh)        ;; 'winheight'
(atom! long    p_wmh)       ;; 'winminheight'
(atom! long    p_wmw)       ;; 'winminwidth'
(atom! long    p_wiw)       ;; 'winwidth'
(atom! boolean p_ws)        ;; 'wrapscan'
(atom! long    p_wd)        ;; 'writedelay'

;; "indir" values for buffer-local opions.

(final int
    BV_AI     0,
    BV_CI     5,
    BV_CINW   9,
    BV_ET    14,
    BV_ISK   26,
    BV_KP    27,
    BV_MOD   31,
    BV_MPS   32,
    BV_NF    33,
    BV_PI    34,
    BV_QE    35,
    BV_SI    37,
    BV_STS   40,
    BV_SW    41,
    BV_TS    42,
    BV_UL    46)

;; "indir" values for window-local options.

(final int
    WV_COCU    1,
    WV_COLE    2,
    WV_CRBIND  3,
    WV_BRI     4,
    WV_BRIOPT  5,
    WV_LBR     6,
    WV_NU      7,
    WV_RNU     8,
    WV_NUW     9,
    WV_SCBIND 12,
    WV_SCROLL 13,
    WV_CUC    14,
    WV_CUL    15,
    WV_CC     16,
    WV_WFH    18,
    WV_WFW    19,
    WV_WRAP   20)

;; ----------------------------------------------------------------------- ;;

;; position in file or buffer

(class! #_final pos_C
    [
        (field long     lnum)       ;; line number
        (field int      col)        ;; column number
        (field int      coladd)
    ])

(final pos_C NOPOS (ยง_pos_C))

(defn- #_pos_C new_pos [#_long lnum, #_int col, #_int coladd]
    (ยง
        ((ร pos_C p =) (ยง ยง_pos_C()))
        ((ร p.lnum =) lnum)
        ((ร p.col =) col)
        ((ร p.coladd =) coladd)
        p
    ))

(defn- #_void COPY_pos [#_pos_C p1, #_pos_C p0]
    (ยง
        ((ร p1.lnum =) (. p0 lnum))
        ((ร p1.col =) (. p0 col))
        ((ร p1.coladd =) (. p0 coladd))
    ))

(defn- #_pos_C* ARRAY_pos [#_int n]
    (vec (repeatedly n ยง_pos_C)))

;; Same, but without coladd.

(class! #_final lpos_C
    [
        (field long     lnum)       ;; line number
        (field int      col)        ;; column number
    ])

(defn- #_void MIN1_lpos [#_lpos_C lp]
    (ยง
        ((ร lp.lnum =) -1)
        ((ร lp.col =) -1)
    ))

(defn- #_void COPY_lpos [#_lpos_C lp1, #_lpos_C lp0]
    (ยง
        ((ร lp1.lnum =) (. lp0 lnum))
        ((ร lp1.col =) (. lp0 col))
    ))

(defn- #_lpos_C* ARRAY_lpos [#_int n]
    (vec (repeatedly n ยง_lpos_C)))

(defn- #_void COPY__lpos [#_lpos_C* a1, #_lpos_C* a0, #_int n]
    (ยง
        ((ร FOR) (ร (ยง int i = 0) (< i n) (ยง i++))
            (COPY_lpos (ยง a1[i]), (ยง a0[i]))
        )
    ))

;; ----------------------------------------------------------------------- ;;

;; The number of sub-matches is limited to 10.
;; The first one (index 0) is the whole match, referenced with "\0".
;; The second one (index 1) is the first sub-match, referenced with "\1".
;; This goes up to the tenth (index 9), referenced with "\9".

(final int NSUBEXP  10)

;; In the NFA engine: how many braces are allowed.

(final int NFA_MAX_BRACES 20)

;; In the NFA engine: how many states are allowed.

(final int NFA_MAX_STATES 100000)
(final int NFA_TOO_EXPENSIVE -1)

;; Which regexp engine to use? Needed for vim_regcomp().
;; Must match with 'regexpengine'.

(final int
    AUTOMATIC_ENGINE    0,
    BACKTRACKING_ENGINE 1,
    NFA_ENGINE          2)

;; Structure returned by vim_regcomp() to pass on to vim_regexec().
;; This is the general structure.  For the actual matcher, two specific
;; structures are used.  See code below.

(ยง
;   static abstract class regprog_C
    (ยง
;       regengine_C         engine;
;       int                 regflags;
;       int                 re_engine;      ;; automatic, backtracking or nfa engine
;       int                 re_flags;       ;; second argument for vim_regcomp()

;       protected regprog_C()
;       {
;       }
    ))

;; Structure used by the back track matcher.
;; These fields are only to be used in regexp.c!
;; See regexp.c for an explanation.

(ยง
;   static final class bt_regprog_C extends regprog_C
    (ยง
;       int                 reganch;
;       int                 regstart;
;       Bytes               regmust;
;       int                 regmlen;
;       int                 reghasz;
;       Bytes               program;
    ))

;; Structure representing a NFA state.
;; A NFA state may have no outgoing edge, when it is a NFA_MATCH state.

(declare ยง_fragnode_C)

(class! #_final nfa_state_C
    [
        (field int          c)
        (field fragnode_C   out0        (ยง_fragnode_C))
        (field fragnode_C   out1        (ยง_fragnode_C))
        (field int          id)
        (field int*         lastlist    2)  ;; 0: normal, 1: recursive
        (field int          val)

;       #_private void out0(nfa_state_C out0)
;       {
; %%        ((ร this.out0.fn_next =) out0)
;       }

;       #_private void out1(nfa_state_C out1)
;       {
; %%        ((ร this.out1.fn_next =) out1)
;       }

;       #_private nfa_state_C out0()
;       {
; %%        ((ร RETURN) (ยง (nfa_state_C)out0.fn_next))
;       }

;       #_private nfa_state_C out1()
;       {
; %%        ((ร RETURN) (ยง (nfa_state_C)out1.fn_next))
;       }
    ])

;; Structure used by the NFA matcher.

(ยง
;   static final class nfa_regprog_C extends regprog_C
    (ยง
;       nfa_state_C         start;          ;; points into state[]

;       int                 reganch;        ;; pattern starts with ^
;       int                 regstart;       ;; char at start of pattern
;       Bytes               match_text;     ;; plain text to match with

;       boolean             has_zend;       ;; pattern contains \ze
;       boolean             has_backref;    ;; pattern contains \1 .. \9
;       int                 reghasz;
;       Bytes               pattern;
;       int                 nsubexp;        ;; number of ()

;       int                 nstate;         ;; states.length
;       nfa_state_C[]       states;
;       int                 istate;         ;; index in states == number of states allocated
    ))

;; Structure to be used for single-line matching.
;; Sub-match "no" starts at "startp[no]" and ends just before "endp[no]".
;; When there is no match, the pointer is null.

(class! #_final regmatch_C
    [
        (field regprog_C    regprog)
        (field Bytes*       startp      NSUBEXP)
        (field Bytes*       endp        NSUBEXP)
        (field boolean      rm_ic)
    ])

;; Structure to be used for multi-line matching.
;; Sub-match "no" starts in line "startpos[no].lnum" column "startpos[no].col"
;; and ends in line "endpos[no].lnum" just before column "endpos[no].col".
;; The line numbers are relative to the first line, thus startpos[0].lnum is always 0.
;; When there is no match, the line number is -1.

(class! #_final regmmatch_C
    [
        (field regprog_C    regprog)
        (field lpos_C*      startpos    (ARRAY_lpos NSUBEXP))
        (field lpos_C*      endpos      (ARRAY_lpos NSUBEXP))
        (field boolean      rmm_ic)
        (field int          rmm_maxcol)     ;; when not zero: maximum column
    ])

(defn- #_void COPY_regmmatch [#_regmmatch_C rmm1, #_regmmatch_C rmm0]
    (ยง
        ((ร rmm1.regprog =) (. rmm0 regprog))
        (COPY__lpos (. rmm1 startpos), (. rmm0 startpos), NSUBEXP)
        (COPY__lpos (. rmm1 endpos), (. rmm0 endpos), NSUBEXP)
        ((ร rmm1.rmm_ic =) (. rmm0 rmm_ic))
        ((ร rmm1.rmm_maxcol =) (. rmm0 rmm_maxcol))
    ))

;; Structure used to store external references: "\z\(\)" to "\z\1".
;; Use a reference count to avoid the need to copy this around.
;; When it goes from 1 to zero the matches need to be freed.

(class! #_final reg_extmatch_C
    [
        (field Bytes*       matches     NSUBEXP)
    ])

(ยง
;   static abstract class regengine_C
    (ยง
        ((ร Bytes expr =) (u8 ""))

;       protected regengine_C()
;       {
;       }

;       public abstract regprog_C regcomp(Bytes expr, int re_flags);
;       public abstract long regexec_nl(regmatch_C rmp, Bytes line, int col, boolean line_lbr);
;       public abstract long regexec_multi(regmmatch_C rmp, window_C win, buffer_C buf, long lnum, int col, long nsec);
    ))

;; ----------------------------------------------------------------------- ;;

;; marks: positions in a file
;; (a normal mark is a lnum/col pair, the same as a file position)

(final int NMARKS (inc (- (int \z) (int \a))))  ;; max. # of named marks
(final int JUMPLISTSIZE 100)        ;; max. # of marks in jump list

(class! #_final fmark_C
    [
        (field pos_C    mark    (ยง_pos_C))      ;; cursor position
    ])

(defn- #_void COPY_fmark [#_fmark_C fm1, #_fmark_C fm0]
    (ยง
        (COPY_pos (. fm1 mark), (. fm0 mark))
    ))

(defn- #_fmark_C* ARRAY_fmark [#_int n]
    (vec (repeatedly n ยง_fmark_C)))

;; Structure that contains all options that are local to a window.
;; Used twice in a window: for the current buffer and for all buffers.

(class! #_final winopt_C
    [
        (atom' boolean wo_bri)      ;; 'breakindent'
        (atom' Bytes   wo_briopt)   ;; 'breakindentopt'
        (atom' boolean wo_lbr)      ;; 'linebreak'
        (atom' boolean wo_nu)       ;; 'number'
        (atom' boolean wo_rnu)      ;; 'relativenumber'
        (atom' long    wo_nuw)      ;; 'numberwidth'
        (atom' boolean wo_wfh)      ;; 'winfixheight'
        (atom' boolean wo_wfw)      ;; 'winfixwidth'
        (atom' long    wo_scr)      ;; 'scroll'
        (atom' boolean wo_cuc)      ;; 'cursorcolumn'
        (atom' boolean wo_cul)      ;; 'cursorline'
        (atom' Bytes   wo_cc)       ;; 'colorcolumn'
        (atom' boolean wo_scb)      ;; 'scrollbind'
        (atom' boolean wo_wrap)     ;; 'wrap'
        (atom' Bytes   wo_cocu)     ;; 'concealcursor'
        (atom' long    wo_cole)     ;; 'conceallevel'
        (atom' boolean wo_crb)      ;; 'cursorbind'
    ])

;; Structure to store info about the Visual area.
(class! #_final visualinfo_C
    [
        (field pos_C        vi_start    (ยง_pos_C))      ;; start pos of last VIsual
        (field pos_C        vi_end      (ยง_pos_C))      ;; end position of last VIsual
        (field int          vi_mode)                    ;; VIsual_mode of last VIsual
        (field int          vi_curswant)                ;; MAXCOL from w_curswant
    ])

(defn- #_void COPY_visualinfo [#_visualinfo_C vi1, #_visualinfo_C vi0]
    (ยง
        (COPY_pos (. vi1 vi_start), (. vi0 vi_start))
        (COPY_pos (. vi1 vi_end), (. vi0 vi_end))
        ((ร vi1.vi_mode =) (. vi0 vi_mode))
        ((ร vi1.vi_curswant =) (. vi0 vi_curswant))
    ))

;; structures used for undo

(class! #_final u_entry_C
    [
        (field u_entry_C    ue_next)        ;; pointer to next entry in list
        (field long         ue_top)         ;; number of line above undo block
        (field long         ue_bot)         ;; number of line below undo block
        (field long         ue_lcount)      ;; linecount when u_save() called
        (field Bytes*       ue_array)       ;; array of lines in undo block
        (field long         ue_size)        ;; number of lines in "ue_array"
    ])

(class! #_final u_link_C
    [
        (field u_header_C   ptr)
        (field long         seq)
    ])

(class! #_final u_header_C
    [
        ;; The following have a pointer and a number.
        ;; The number is used when reading the undo file in u_read_undo().
        (field u_link_C     uh_next         (ยง_u_link_C))       ;; next undo header in list
        (field u_link_C     uh_prev         (ยง_u_link_C))       ;; previous header in list
        (field u_link_C     uh_alt_next     (ยง_u_link_C))       ;; next header for alt. redo
        (field u_link_C     uh_alt_prev     (ยง_u_link_C))       ;; previous header for alt. redo
        (field long         uh_seq)                             ;; sequence number, higher == newer undo
        (field int          uh_walk)                            ;; used by undo_time()
        (field u_entry_C    uh_entry)                           ;; pointer to first entry
        (field u_entry_C    uh_getbot_entry)                    ;; pointer to where ue_bot must be set
        (field pos_C        uh_cursor       (ยง_pos_C))          ;; cursor position before saving
        (field long         uh_cursor_vcol)
        (field int          uh_flags)                           ;; see below
        (field pos_C*       uh_namedm       (ARRAY_pos NMARKS)) ;; marks before undo/after redo
        (field visualinfo_C uh_visual       (ยง_visualinfo_C))   ;; Visual areas before undo/after redo
        (field long         uh_time)                            ;; timestamp when the change was made
    ])

;; values for uh_flags
(final int UH_CHANGED  0x01)            ;; "b_changed" flag before undo/after redo
(final int UH_EMPTYBUF 0x02)            ;; buffer was empty

;; structure used to store one block of the stuff/redo/recording buffers

(class! #_final buffblock_C
    [
        (field buffblock_C  bb_next)        ;; pointer to next buffblock
        (field Bytes        bb_str)         ;; contents
    ])

(defn- #_void COPY_buffblock [#_buffblock_C bb1, #_buffblock_C bb0]
    (ยง
        ((ร bb1.bb_next =) (. bb0 bb_next))
        ((ร bb1.bb_str =) (. bb0 bb_str))
    ))

;; header used for the stuff buffer and the redo buffer

(class! #_final buffheader_C
    [
        (field buffblock_C  bh_first    (ยง_buffblock_C))    ;; first (dummy) block of list
        (field buffblock_C  bh_curr)        ;; buffblock for appending
        (field int          bh_index)       ;; index for reading
        (field int          bh_space)       ;; space in bh_curr for appending
    ])

(defn- #_void COPY_buffheader [#_buffheader_C bh1, #_buffheader_C bh0]
    (ยง
        (COPY_buffblock (. bh1 bh_first), (. bh0 bh_first))
        ((ร bh1.bh_curr =) (. bh0 bh_curr))
        ((ร bh1.bh_index =) (. bh0 bh_index))
        ((ร bh1.bh_space =) (. bh0 bh_space))
    ))

;; things used in memline.c

;; 'ml_flags':
(final int ML_EMPTY        1)   ;; empty buffer

;; The memline structure holds all the information about a memline.

(class! #_final memline_C
    [
        (field long         ml_line_count)      ;; number of lines in the buffer

        (field int          ml_flags)
    ])

;; Structure shared between syntax.c and screen.c.

(class! #_final attrentry_C
    [
        (field int          ae_attr)            ;; HL_BOLD, etc.
        (field Bytes        ae_esc_start)       ;; start escape sequence
        (field Bytes        ae_esc_stop)        ;; stop escape sequence
    ;; These colors need to be > 8 bits to hold 256.
        (field int          ae_fg_color)        ;; foreground color number
        (field int          ae_bg_color)        ;; background color number
    ])

(defn- #_void ZER0_attrentry [#_attrentry_C ae]
    (ยง
        ((ร ae.ae_attr =) 0)
        ((ร ae.ae_esc_start =) null)
        ((ร ae.ae_esc_stop =) null)
        ((ร ae.ae_fg_color =) 0)
        ((ร ae.ae_bg_color =) 0)
    ))

(defn- #_void COPY_attrentry [#_attrentry_C ae1, #_attrentry_C ae0]
    (ยง
        ((ร ae1.ae_attr =) (. ae0 ae_attr))
        ((ร ae1.ae_esc_start =) (. ae0 ae_esc_start))
        ((ร ae1.ae_esc_stop =) (. ae0 ae_esc_stop))
        ((ร ae1.ae_fg_color =) (. ae0 ae_fg_color))
        ((ร ae1.ae_bg_color =) (. ae0 ae_bg_color))
    ))

;; Used for the typeahead buffer: typebuf.

(class! #_final typebuf_C
    [
        (field Bytes        tb_buf)             ;; buffer for typed characters
        (field int          tb_buflen)          ;; size of "tb_buf"
        (field int          tb_off)             ;; current position in "tb_buf"
        (field int          tb_len)             ;; number of valid bytes in "tb_buf"
        (field int          tb_change_cnt)      ;; nr of time "tb_buf" was changed; never zero
    ])

;; buffer: structure that holds information about one file
;;
;; Several windows can share a single Buffer.

(class! #_final buffer_C
    [
        (field memline_C    b_ml)               ;; associated memline (also contains line count)

        (field int          b_nwindows)         ;; nr of windows open on this buffer

        (atom' boolean      b_changed)          ;; 'modified'
        (field int          b_changedtick)      ;; incremented for each change, also for undo

        ;; Changes to a buffer require updating of the display.
        ;; To minimize the work, remember changes made and update everything at once.

        (field boolean      b_mod_set)          ;; true when there are changes since the last time the display was updated
        (field long         b_mod_top)          ;; topmost lnum that was changed
        (field long         b_mod_bot)          ;; lnum below last changed line, AFTER the change
        (field long         b_mod_xlines)       ;; number of extra buffer lines inserted; negative when lines were deleted

        (field pos_C*       b_namedm)           ;; current named marks (mark.c)

        ;; These variables are set when VIsual_active becomes false.
        (field visualinfo_C b_visual)
        (field int          b_visual_mode_eval) ;; b_visual.vi_mode for visualmode()

        (field pos_C        b_last_cursor)      ;; cursor position when last unloading this buffer
        (field pos_C        b_last_insert)      ;; where Insert mode was left
        (field pos_C        b_last_change)      ;; position of last change: '. mark

        ;; the changelist contains old change positions

        (field pos_C*       b_changelist)
        (field int          b_changelistlen)    ;; number of active entries
        (field boolean      b_new_change)       ;; set by u_savecommon()

        ;; Character table, only used in charset.c for 'iskeyword'.
        ;; 8 bytes of 32 bits: 1 bit per character 0-255.

        (field int*         b_chartab)

        ;; start and end of an operator, also used for '[ and ']

        (field pos_C        b_op_start)
        (field pos_C        b_op_start_orig)    ;; used for insStart_orig
        (field pos_C        b_op_end)

        ;; The following only used in undo.c.

        (field u_header_C   b_u_oldhead)        ;; pointer to oldest header
        (field u_header_C   b_u_newhead)        ;; pointer to newest header; may not be valid if b_u_curhead is not null
        (field u_header_C   b_u_curhead)        ;; pointer to current header
        (field int          b_u_numhead)        ;; current number of headers
        (field boolean      b_u_synced)         ;; entry lists are synced
        (field long         b_u_seq_last)       ;; last used undo sequence number
        (field long         b_u_seq_cur)        ;; hu_seq of header below which we are now
        (field long         b_u_time_cur)       ;; uh_time of header below which we are now

        ;; variables for "U" command in undo.c

        (field Bytes        b_u_line_ptr)       ;; saved line for "U" command
        (field long         b_u_line_lnum)      ;; line number of line in u_line
        (field int          b_u_line_colnr)     ;; optional column number

        ;; Options local to a buffer.
        ;; They are here because their value depends on the type of file
        ;; or contents of the file being edited.

        (atom' boolean      b_p_ai)             ;; 'autoindent'
        (field boolean      b_p_ai_nopaste)     ;; "b_p_ai" saved for paste mode
        (atom' boolean      b_p_ci)             ;; 'copyindent'
        (atom' Bytes        b_p_cinw)           ;; 'cinwords'
        (atom' boolean      b_p_et)             ;; 'expandtab'
        (atom' Bytes        b_p_isk)            ;; 'iskeyword'
        (atom' Bytes        b_p_kp)             ;; 'keywordprg'
        (atom' Bytes        b_p_mps)            ;; 'matchpairs'
        (atom' Bytes        b_p_nf)             ;; 'nrformats'
        (atom' boolean      b_p_pi)             ;; 'preserveindent'
        (atom' Bytes        b_p_qe)             ;; 'quoteescape'
        (atom' long         b_p_sw)             ;; 'shiftwidth'
        (atom' boolean      b_p_si)             ;; 'smartindent'
        (atom' long         b_p_sts)            ;; 'softtabstop'
        (field long         b_p_sts_nopaste)    ;; "b_p_sts" saved for paste mode
        (atom' long         b_p_ts)             ;; 'tabstop'
        (atom' long         b_p_ul)             ;; 'undolevels'
    ])

(atom! long         ch_used)         ;; value of 'cmdheight' when frame size was set

;; Structure to cache info for displayed lines in w_lines[].
;; Each logical line has one entry.
;; The entry tells how the logical line is currently displayed in the window.
;; This is updated when displaying the window.
;; When the display is changed (e.g., when clearing the screen) w_lines_valid
;; is changed to exclude invalid entries.
;; When making changes to the buffer, wl_valid is reset to indicate wl_size
;; may not reflect what is actually in the buffer.  When wl_valid is false,
;; the entries can only be used to count the number of displayed lines used.
;; wl_lnum and wl_lastlnum are invalid too.

(class! #_final wline_C
    [
        (field long         wl_lnum)        ;; buffer line number for logical line
        (field int          wl_size)        ;; height in screen lines
        (field boolean      wl_valid)       ;; true values are valid for text in buffer
    ])

(defn- #_void COPY_wline [#_wline_C wl1, #_wline_C wl0]
    (ยง
        ((ร wl1.wl_lnum =) (. wl0 wl_lnum))
        ((ร wl1.wl_size =) (. wl0 wl_size))
        ((ร wl1.wl_valid =) (. wl0 wl_valid))
    ))

(defn- #_wline_C* ARRAY_wline [#_int n]
    (vec (repeatedly n ยง_wline_C)))

;; Windows are kept in a tree of frames.  Each frame has a column (FR_COL)
;; or row (FR_ROW) layout or is a leaf, which has a window.

(class! #_final frame_C
    [
        (field byte         fr_layout)      ;; FR_LEAF, FR_COL or FR_ROW
        (field int          fr_width)
        (field int          fr_newwidth)    ;; new width used in win_equal_rec()
        (field int          fr_height)
        (field int          fr_newheight)   ;; new height used in win_equal_rec()
        (field frame_C      fr_parent)      ;; containing frame or null
        (field frame_C      fr_next)        ;; frame right or below in same parent, null for first
        (field frame_C      fr_prev)        ;; frame left or above in same parent, null for last
                                            ;; fr_child and fr_win are mutually exclusive
        (field frame_C      fr_child)       ;; first contained frame
        (field window_C     fr_win)         ;; window that fills this frame
    ])

(defn- #_void COPY_frame [#_frame_C fr1, #_frame_C fr0]
    (ยง
        ((ร fr1.fr_layout =) (. fr0 fr_layout))
        ((ร fr1.fr_width =) (. fr0 fr_width))
        ((ร fr1.fr_newwidth =) (. fr0 fr_newwidth))
        ((ร fr1.fr_height =) (. fr0 fr_height))
        ((ร fr1.fr_newheight =) (. fr0 fr_newheight))
        ((ร fr1.fr_parent =) (. fr0 fr_parent))
        ((ร fr1.fr_next =) (. fr0 fr_next))
        ((ร fr1.fr_prev =) (. fr0 fr_prev))
        ((ร fr1.fr_child =) (. fr0 fr_child))
        ((ร fr1.fr_win =) (. fr0 fr_win))
    ))

(final byte
    FR_LEAF 0,            ;; frame is a leaf
    FR_ROW  1,            ;; frame with a row of windows
    FR_COL  2)            ;; frame with a column of windows

;; Struct used for highlighting 'hlsearch' matches, matches defined by ":match" and
;; matches defined by match functions.  For 'hlsearch' there is one pattern for all windows.
;; For ":match" and the match functions there is a different pattern for each window.

(class! #_final match_C
    [
        (field regmmatch_C  rmm     (ยง_regmmatch_C))    ;; points to the regexp program; contains last found match (may continue in next line)
        (field buffer_C     buf)                        ;; the buffer to search for a match
        (field long         lnum)                       ;; the line to search for a match
        (field int          attr)                       ;; attributes to be used for a match
        (field int          attr_cur)                   ;; attributes currently active in win_line()
        (field long         first_lnum)                 ;; first lnum to search for multi-line pat
        (field int          startcol)                   ;; in win_line() points to char where HL starts
        (field int          endcol)                     ;; in win_line() points to char where HL ends
        (field long         nsec)                       ;; for a time limit
    ])

;; number of positions supported by matchaddpos()
(final int MAXPOSMATCH 8)

;; Same as lpos_C, but with additional field len.

(class! #_final llpos_C
    [
        (field long     lnum)       ;; line number
        (field int      col)        ;; column number
        (field int      len)        ;; length: 0 - to the end of line
    ])

(defn- #_void COPY_llpos [#_llpos_C llp1, #_llpos_C llp0]
    (ยง
        ((ร llp1.lnum =) (. llp0 lnum))
        ((ร llp1.col =) (. llp0 col))
        ((ร llp1.len =) (. llp0 len))
    ))

(defn- #_llpos_C* ARRAY_llpos [#_int n]
    (vec (repeatedly n ยง_llpos_C)))

;; posmatch_C provides an array for storing match items for matchaddpos() function.

(class! #_final posmatch_C
    [
        (field llpos_C* pm_pos  (ARRAY_llpos MAXPOSMATCH))  ;; array of positions
        (field int      cur)        ;; internal position counter
        (field long     toplnum)    ;; top buffer line
        (field long     botlnum)    ;; bottom buffer line
    ])

;; matchitem_C provides a linked list for storing match items for ":match" and the match functions.

(class! #_final matchitem_C
    [
        (field matchitem_C  next)
        (field int          id)             ;; match ID
        (field int          priority)       ;; match priority
        (field Bytes        pattern)        ;; pattern to highlight
        (field int          hlg_id)         ;; highlight group ID
        (field regmmatch_C  mi_match    (ยง_regmmatch_C))    ;; regexp program for "pattern"
        (field posmatch_C   mi_pos      (ยง_posmatch_C))     ;; position matches
        (field match_C      mi_hl       (ยง_match_C))        ;; struct for doing the actual highlighting
    ])

;; Structure which contains all information that belongs to a window
;;
;; All row numbers are relative to the start of the window, except w_winrow.

(class! #_final window_C
    [
        (field window_C     w_prev)             ;; link to previous window
        (field window_C     w_next)             ;; link to next window

        (field frame_C      w_frame)            ;; frame containing this window

        (field pos_C        w_cursor            (ยง_pos_C))  ;; cursor position in buffer
        (field int          w_curswant)         ;; column we'd like to be at: used to try to stay in the same column for up/down cursor motions
        (field boolean      w_set_curswant)     ;; if set, update w_curswant the next time through cursupdate() to the current virtual column

        ;; the next six are used to update the visual part

        (field int          w_old_visual_mode)  ;; last known VIsual_mode
        (field long         w_old_cursor_lnum)  ;; last known end of visual part
        (field int          w_old_cursor_fcol)  ;; first column for block visual part
        (field int          w_old_cursor_lcol)  ;; last column for block visual part
        (field long         w_old_visual_lnum)  ;; last known start of visual part
        (field int          w_old_visual_col)   ;; last known start of visual part
        (field int          w_old_curswant)     ;; last known value of curswant

        ;; "w_topline", "w_leftcol" and "w_skipcol" specify the offsets for displaying the buffer.

        (field long         w_topline)          ;; buffer line number of the line at the top of the window
        (field boolean      w_topline_was_set)  ;; flag set to true when topline is set, e.g. by winrestview()
        (field int          w_leftcol)          ;; window column of the leftmost character in the window; used when 'wrap' is off
        (field int          w_skipcol)          ;; starting column when a single line doesn't fit in the window

        ;; Layout of the window in the screen.
        ;; May need to add "msg_scrolled" to "w_winrow" in rare situations.

        (field int          w_winrow)           ;; first row of window in screen
        (field int          w_height)           ;; number of rows in window, excluding status/command line(s)
        (field int          w_status_height)    ;; number of status lines (0 or 1)
        (field int          w_wincol)           ;; leftmost column of window in screen
        (field int          w_width)            ;; width of window, excluding separation
        (field int          w_vsep_width)       ;; number of separator columns (0 or 1)

        ;; === start of cached values ====

        ;; Recomputing is minimized by storing the result of computations.
        ;; Use functions in screen.c to check if they are valid and to update.
        ;; w_valid is a bitfield of flags, which indicate if specific values are
        ;; valid or need to be recomputed.  See screen.c for values.

        (field int          w_valid)
        (field pos_C        w_valid_cursor      (ยง_pos_C))  ;; last known position of w_cursor, used to adjust w_valid
        (field int          w_valid_leftcol)    ;; last known w_leftcol

        ;; w_cline_height is the number of physical lines taken by the buffer line
        ;; that the cursor is on.  We use this to avoid extra calls to plines().

        (field int          w_cline_height)     ;; current size of cursor line

        (field int          w_cline_row)        ;; starting row of the cursor line

        (field int          w_virtcol)          ;; Column number of the cursor in the buffer line,
                                                ;; as opposed to the column number we're at on the screen.
                                                ;; This makes a difference on lines which span more than
                                                ;; one screen line or when w_leftcol is non-zero.

        ;; w_wrow and w_wcol specify the cursor position in the window.
        ;; This is related to positions in the window, not in the display
        ;; or buffer, thus w_wrow is relative to w_winrow.

        (field int          w_wrow)
        (field int          w_wcol)

        (field long         w_botline)          ;; number of the line below the bottom of the screen
        (field int          w_empty_rows)       ;; number of ~ rows in window

        ;; Info about the lines currently in the window is remembered to avoid
        ;; recomputing it every time.  The allocated size of w_lines[] is Rows.
        ;; Only the w_lines_valid entries are actually valid.
        ;; When the display is up-to-date w_lines[0].wl_lnum is equal to w_topline
        ;; and w_lines[w_lines_valid - 1].wl_lnum is equal to w_botline.
        ;; Between changing text and updating the display w_lines[] represents
        ;; what is currently displayed.  wl_valid is reset to indicated this.
        ;; This is used for efficient redrawing.

        (field int          w_lines_valid)      ;; number of valid entries
        (field wline_C*     w_lines)
        (field int          w_lines_len)

        (field int          w_nrwidth)          ;; width of 'number' and 'relativenumber' column being used

        ;; === end of cached values ===

        (field int          w_redr_type)        ;; type of redraw to be performed on win
        (field int          w_upd_rows)         ;; number of window lines to update when w_redr_type is REDRAW_TOP
        (field long         w_redraw_top)       ;; when != 0: first line needing redraw
        (field long         w_redraw_bot)       ;; when != 0: last line needing redraw
        (field boolean      w_redr_status)      ;; if true status line must be redrawn

        ;; remember what is shown in the ruler for this window (if 'ruler' set)
        (field pos_C        w_ru_cursor         (ยง_pos_C))  ;; cursor position shown in ruler
        (field int          w_ru_virtcol)       ;; virtcol shown in ruler
        (field long         w_ru_topline)       ;; topline shown in ruler
        (field long         w_ru_line_count)    ;; line count used for ruler
        (field boolean      w_ru_empty)         ;; true if ruler shows 0-1 (empty line)

        ;; Options local to a window.
        ;; They are local because they influence the layout of the window or depend on the window layout.

        (field winopt_C     w_options    (ยง_winopt_C))

        (field int*         w_p_cc_cols)        ;; array of columns to highlight or null
        (field int          w_p_brimin)         ;; minimum width for breakindent
        (field int          w_p_brishift)       ;; additional shift for breakindent
        (field boolean      w_p_brisbr)         ;; sbr in 'briopt'

        (field long         w_scbind_pos)

        ;; w_prev_pcmark is used to check whether we really did jump to a new line after setting w_pcmark.
        ;; If not, we revert to using the previous w_pcmark.

        (field pos_C        w_pcmark            (ยง_pos_C))  ;; previous context mark
        (field pos_C        w_prev_pcmark       (ยง_pos_C))  ;; previous w_pcmark

        ;; the jumplist contains old cursor positions

        (field fmark_C*     w_jumplist      (ARRAY_fmark JUMPLISTSIZE))
        (field int          w_jumplistlen)      ;; number of active entries
        (field int          w_jumplistidx)      ;; current position

        (field int          w_changelistidx)    ;; current position in b_changelist

        (field matchitem_C  w_match_head)       ;; head of match list
        (field int          w_next_match_id)    ;; next match ID

        ;; w_fraction is the fractional row of the cursor within the window,
        ;; from 0 at the top row to FRACTION_MULT at the last row.
        ;; w_prev_fraction_row was the actual cursor row when w_fraction was last calculated.

        (field int          w_fraction)
        (field int          w_prev_fraction_row)

        (field long         w_nrwidth_line_count)   ;; line count when ml_nrwidth_width was computed
        (field long         w_nuw_cached)           ;; 'numberwidth' option cached
        (field int          w_nrwidth_width)        ;; nr of chars to print line count
    ])

;; Arguments for operators.

(class! #_final oparg_C
    [
        (field int          op_type)            ;; current pending operator type
        (field int          regname)            ;; register to use for the operator
        (field byte         motion_type)        ;; type of the current cursor motion
        (field int          motion_force)       ;; force motion type: 'v', 'V' or CTRL-V
        (field boolean      use_reg_one)        ;; true if delete uses reg 1 even when not linewise
        (field boolean      inclusive)          ;; true if char motion is inclusive (only valid when motion_type is MCHAR)
        (field boolean      end_adjusted)       ;; backuped b_op_end one char (only used by do_format())
        (field pos_C        op_start        (ยง_pos_C))  ;; start of the operator
        (field pos_C        op_end          (ยง_pos_C))  ;; end of the operator
        (field pos_C        cursor_start    (ยง_pos_C))  ;; cursor position before motion for "gw"
        (field long         line_count)         ;; number of lines from op_start to op_end (inclusive)
        (field boolean      empty)              ;; op_start and op_end the same (only used by do_change())
        (field boolean      is_VIsual)          ;; operator on Visual area
        (field boolean      block_mode)         ;; current operator is Visual block mode
        (field int          start_vcol)         ;; start col for block mode operator
        (field int          end_vcol)           ;; end col for block mode operator
        (field long         prev_opcount)       ;; ca.opcount saved for K_CURSORHOLD
        (field long         prev_count0)        ;; ca.count0 saved for K_CURSORHOLD
    ])

;; Arguments for Normal mode commands.

(class! #_final cmdarg_C
    [
        (field oparg_C      oap)                ;; operator arguments
        (field int          prechar)            ;; prefix character (optional, always 'g')
        (field int          cmdchar)            ;; command character
        (atom' int          nchar)              ;; next command character (optional)
        (field int          ncharC1)            ;; first composing character (optional)
        (field int          ncharC2)            ;; second composing character (optional)
        (atom' int          extra_char)         ;; yet another character (optional)
        (field long         opcount)            ;; count before an operator
        (field long         count0)             ;; count before command, default 0
        (field long         count1)             ;; count before command, default 1
        (field int          arg)                ;; extra argument from nv_cmds[]
        (field int          retval)             ;; return: CA_* values
        (field Bytes        searchbuf)          ;; return: pointer to search pattern or null
    ])

;; values for retval:
(final int CA_COMMAND_BUSY  1)  ;; skip restarting edit() once
(final int CA_NO_ADJ_OP_END 2)  ;; don't adjust operator end

;;; ============================================================================================== VimE

;; ex_cmds.h --------------------------------------------------------------------------------------

(final int
    RANGE           0x001,   ;; allow a linespecs
    BANG            0x002,   ;; allow a ! after the command name
    EXTRA           0x004,   ;; allow extra args after command name
    NOSPC           0x010,   ;; no spaces allowed in the extra part
    DFLALL          0x020,   ;; default file range is 1,$
    NEEDARG         0x080,   ;; argument required
    COUNT           0x400,   ;; allow count in argument, after command
    ZEROR          0x1000,   ;; zero line number allowed
    NOTADR         0x4000,   ;; number before command is not an address
    CMDWIN       0x100000,   ;; allowed in cmdline window

    WORD1 (| EXTRA NOSPC))   ;; one extra word allowed

;; values for cmd_addr_type
(final byte
    ADDR_LINES          0,
    ADDR_WINDOWS        1)

(final int
    CMD_close 0,
    CMD_fixdel 1,
    CMD_only 2,
    CMD_retab 3,
    CMD_substitute 4,
    CMD_set 5,
    CMD_stop 6,
    CMD_suspend 7,
    CMD_syncbind 8,

    CMD_SIZE 9)     ;; MUST be after all real commands!

;; Arguments used for Ex commands.

(class! #_final exarg_C
    [
        (field Bytes        arg)            ;; argument of the command
        (field Bytes        nextcmd)        ;; next command (null if none)
        (field Bytes        cmd)            ;; the name of the command (except for :make)
        (field Bytes*       cmdlinep)       ;; pointer to pointer of allocated cmdline
        (field int          cmdidx)         ;; the index for the command
        (field long         argt)           ;; flags for the command
        (field boolean      skip)           ;; don't execute the command, only parse it
        (field boolean      forceit)        ;; true if ! present
        (field int          addr_count)     ;; the number of addresses given
        (field long         line1)          ;; the first line number
        (field long         line2)          ;; the second line number or count
        (field int          addr_type)      ;; type of the count/range
        (field int          regname)        ;; register name (NUL if none)
        (field Bytes        errmsg)         ;; returned error message
    ])

;; ----------------------------------------------------------------------- ;;

(defn- #_boolean asc_islower [#_int c]
    (and (<= (byte \a) c) (<= c (byte \z))))

(defn- #_boolean asc_isupper [#_int c]
    (and (<= (byte \A) c) (<= c (byte \Z))))

(defn- #_boolean asc_isalpha [#_int c]
    (or (asc_isupper c) (asc_islower c)))

(defn- #_boolean asc_isalnum [#_int c]
    (or (asc_isalpha c) (asc_isdigit c)))

(defn- #_boolean asc_iscntrl [#_int c]
    (or (and (<= 0x00 c) (<= c 0x1f)) (== c 0x7f)))

(defn- #_boolean asc_isgraph [#_int c]
    (and (<= 0x21 c) (<= c 0x7e)))

(defn- #_boolean asc_isprint [#_int c]
    (and (<= 0x20 c) (<= c 0x7e)))

(defn- #_boolean asc_ispunct [#_int c]
    (or (and (<= 0x21 c) (<= c 0x2f)) (and (<= 0x3a c) (<= c 0x40)) (and (<= 0x5b c) (<= c 0x60)) (and (<= 0x7b c) (<= c 0x7e))))

;;; ============================================================================================== VimF

;; #include "globals.h"             ;; global variables and messages

;; Number of Rows and Columns in the screen.
;; Must be long to be able to use them as options in option.c.
;; Note: Use screenRows and screenColumns to access items in screenLines[].
;; They may have different values when the screen wasn't (re)allocated yet
;; after setting Rows or Columns (e.g., when starting up).

(atom! long   Rows      24)      ;; nr of rows in the screen
(atom! long   Columns   80)      ;; nr of columns in the screen

;; The characters that are currently on the screen are kept in screenLines[].
;; It is a single block of characters, the size of the screen plus one line.
;; The attributes for those characters are kept in screenAttrs[].
;;
;; "lineOffset[n]" is the offset from screenLines[] for the start of line 'n'.
;; The same value is used for screenLinesUC[] and screenAttrs[].
;;
;; Note: before the screen is initialized and when out of memory these can be null.

(atom! Bytes    screenLines)
(atom! int*     screenAttrs)
(atom! int*     lineOffset)
(atom! boolean* lineWraps)          ;; line wraps to next line

;; When using Unicode characters (in UTF-8 encoding) the character in
;; screenLinesUC[] contains the Unicode for the character at this position,
;; or NUL when the character in screenLines[] is to be used (ASCII char).
;; The composing characters are to be drawn on top of the original character.
;; screenLinesC[0][off] is only to be used when screenLinesUC[off] != 0.

(atom! int*     screenLinesUC)      ;; decoded UTF-8 characters
(atom! int**    screenLinesC    MAX_MCO)    ;; composing characters
(atom! int      screen_mco)         ;; value of "p_mco" used when allocating screenLinesC[]

(atom! int      screenRows)         ;; actual size of screenLines[]
(atom! int      screenColumns)      ;; actual size of screenLines[]

;; When vgetc() is called, it sets mod_mask to the set of modifiers that are
;; held down based on the MOD_MASK_* symbols that are read first.

(atom! int      mod_mask)           ;; current key modifiers

;; Cmdline_row is the row where the command line starts, just below the last window.
;; When the cmdline gets longer than the available space the screen gets scrolled up.
;; After a CTRL-D (show matches), after hitting ':' after "hit return",
;; and for the :global command, the command line is temporarily moved.
;; The old position is restored with the next call to update_screen().

(atom! int      cmdline_row)

(atom! boolean  redraw_cmdline)     ;; cmdline must be redrawn
(atom! boolean  clear_cmdline)      ;; cmdline must be cleared
(atom! boolean  mode_displayed)     ;; mode is being displayed
(atom! int      cmdline_star)       ;; cmdline is crypted

(atom! boolean  exec_from_reg)      ;; executing register

(atom! maybean  screen_cleared FALSE)     ;; screen has been cleared

;; Functions for putting characters in the command line,
;; while keeping screenLines[] updated.

(atom! int      msg_col)
(atom! int      msg_row)
(atom! int      msg_scrolled)       ;; number of screen lines that windows have scrolled because of printing messages
(atom! boolean  msg_scrolled_ign)   ;; when true don't set need_wait_return in msg_puts_attr() when msg_scrolled is non-zero

(atom! Bytes    keep_msg)           ;; msg to be shown after redraw
(atom! int      keep_msg_attr)      ;; highlight attr for "keep_msg"
(atom! boolean  keep_msg_more)      ;; "keep_msg" was set by msgmore()
(atom! boolean  need_fileinfo)      ;; do fileinfo() after redraw
(atom! boolean  msg_scroll)         ;; msg_start() will scroll
(atom! boolean  msg_didout)         ;; msg_outstr() was used in line
(atom! boolean  msg_didany)         ;; msg_outstr() was used at all
(atom! boolean  msg_nowait)         ;; don't wait for this msg
(atom! int      emsg_off)           ;; don't display errors for now
(atom! boolean  info_message)       ;; printing informative message
(atom! boolean  need_clr_eos)       ;; need to clear text before displaying a message
(atom! int      emsg_skip)          ;; don't display errors for expression that is skipped
(atom! boolean  did_emsg)           ;; set by emsg() when the message is displayed or thrown
(atom! boolean  did_emsg_syntax)    ;; did_emsg set because of a syntax error
(atom! boolean  called_emsg)        ;; always set by emsg()
(atom! int      ex_exitval)         ;; exit value for ex mode
(atom! boolean  emsg_on_display)    ;; there is an error message
(atom! boolean  rc_did_emsg)        ;; vim_regcomp() called emsg()

(atom! int      no_wait_return)     ;; don't wait for return for now
(atom! boolean  need_wait_return)   ;; need to wait for return later
(atom! boolean  did_wait_return)    ;; wait_return() was used and nothing written since then

(atom! boolean  quit_more)          ;; 'q' hit at "--more--" msg
(atom! boolean  newline_on_exit)    ;; did msg in altern. screen
(atom! int      intr_char)          ;; extra interrupt character
(atom! int      vgetc_busy)         ;; when inside vgetc() then > 0

;; Lines left before a "more" message.
;; Ex mode needs to be able to reset this after you type something.

(atom! int      lines_left      -1)     ;; lines left for listing
(atom! boolean  msg_no_more)            ;; don't use more prompt, truncate messages

(atom! boolean  scroll_region)                  ;; term supports scroll region
(atom! int      t_colors)                       ;; int value of T_CCO

;; When highlight_match is true, highlight a match, starting at the cursor position.
;; Search_match_lines is the number of lines after the match (0 for a match within one line),
;; search_match_endcol the column number of the character just after the match in the last line.

(atom! boolean  highlight_match)                ;; show search match pos
(atom! long     search_match_lines)             ;; lines of of matched string
(atom! int      search_match_endcol)            ;; col nr of match end

(atom! boolean  no_smartcase)                   ;; don't use 'smartcase' once

(atom! int*     highlight_attr HLF_COUNT)       ;; highl. attr. for each context
(atom! int      cterm_normal_fg_color)
(atom! int      cterm_normal_fg_bold)
(atom! int      cterm_normal_bg_color)

(defn- #_int hl_attr [#_int n]
    (ยง
        (ยง @highlight_attr[n])
    ))

;; While redrawing the screen this flag is set.
;; It means the screen size ('lines' and 'rows') must not be changed.

(atom! boolean  updating_screen)

;; All windows are linked in a list.  "firstwin" points to the first entry,
;; "lastwin" to the last entry (can be the same as "firstwin") and "curwin"
;; to the currently active window.

(atom! window_C firstwin)               ;; first window
(atom! window_C lastwin)                ;; last window
(atom! window_C prevwin)                ;; previous window
(atom! window_C curwin)                 ;; currently active window

;; The window layout is kept in a tree of frames.  "topframe" points to the top of the tree.

(atom! frame_C  topframe)               ;; top of the window frame tree

(atom! buffer_C curbuf)                 ;; currently active buffer

(atom! int      ru_col)                 ;; column for ruler
(atom! int      ru_wid)                 ;; 'rulerfmt' width of ruler when non-zero
(atom! int      sc_col)                 ;; column for shown command

;; When starting or exiting some things are done differently (e.g. screen updating).

(atom! int      starting NO_SCREEN)     ;; first NO_SCREEN, then NO_BUFFERS and then set to 0 when starting up finished
(atom! boolean  exiting)                ;; true when planning to exit Vim.  Might still keep on running if there is a changed buffer.

;; volatile because it is used in signal handler deathtrap().
(atom! #_"/*volatile*/transient" boolean full_screen)   ;; true when doing full-screen output
                                                        ;; otherwise only writing some messages

(atom! int      textlock)               ;; non-zero when changing text and jumping to another window or buffer is not allowed

(atom! pos_C    VIsual      (ยง_pos_C))  ;; start position of active Visual selection
(atom! boolean  VIsual_active)          ;; whether Visual mode is active
(atom! boolean  VIsual_select)          ;; whether Select mode is active
(atom! boolean  VIsual_reselect)        ;; whether to restart the selection after a Select mode mapping or menu

(atom! int      VIsual_mode \v)         ;; type of Visual mode

(atom! boolean  redo_VIsual_busy)       ;; true when redoing Visual

;; When pasting text with the middle mouse button in visual mode with
;; restart_edit set, remember where it started so we can set insStart.

(atom! pos_C    where_paste_started     (ยง_pos_C))

;; This flag is used to make auto-indent work right on lines where only a
;; <RETURN> or <ESC> is typed.  It is set when an auto-indent is done, and
;; reset when any other editing is done on the line.  If an <ESC> or <RETURN>
;; is received, and did_ai is true, the line is truncated.

(atom! boolean  did_ai)

;; Column of first char after autoindent.  0 when no autoindent done.
;; Used when 'backspace' is 0, to avoid backspacing over autoindent.

(atom! int      ai_col)

;; This flag is set after a ":syncbind" to let the check_scrollbind() function
;; know that it should not attempt to perform scrollbinding due to the scroll
;; that was a result of the ":syncbind." (Otherwise, check_scrollbind() will
;; undo some of the work done by ":syncbind.")  -ralston

(atom! boolean  did_syncbind)

;; This flag is set when a smart indent has been performed.
;; When the next typed character is a '{' the inserted tab will be deleted again.

(atom! boolean  did_si)

;; This flag is set after an auto indent.
;; If the next typed character is a '}' one indent will be removed.

(atom! boolean  can_si)

;; This flag is set after an "O" command.
;; If the next typed character is a '{' one indent will be removed.

(atom! boolean  can_si_back)

(atom! pos_C    saved_cursor    (ยง_pos_C)) ;; w_cursor before formatting text.

;; Stuff for insert mode.
;; This is where the latest insert/append mode started.

(atom! pos_C    insStart        (ยง_pos_C))

;; This is where the latest insert/append mode started.  In contrast to
;; insStart, this won't be reset by certain keys and is needed for
;; op_insert(), to detect correctly where inserting by the user started.

(atom! pos_C    insStart_orig   (ยง_pos_C))

;; Stuff for VREPLACE mode.

(atom! long     orig_line_count)    ;; Line count when "gR" started
(atom! int      vr_lines_changed)   ;; #Lines changed by "gR" so far

;; "State" is the main state of Vim.
;; There are other variables that modify the state:
;; "Visual_mode"    When State is NORMAL or INSERT.
;; "finish_op"      When State is NORMAL, after typing the operator and before typing the motion command.

(atom! int      State NORMAL)       ;; This is the current state of the command interpreter.

(atom! boolean  finish_op)          ;; true while an operator is pending
(atom! long     opcount)            ;; count for pending operator

(atom! boolean  Recording)          ;; true when recording into a reg.
(atom! boolean  execReg)            ;; true when executing a register

(atom! int      no_mapping)         ;; currently no mapping allowed
(atom! int      allow_keys)         ;; allow key codes when no_mapping is set
(atom! int      no_u_sync)          ;; Don't call u_sync()
(atom! int      u_sync_once)        ;; Call u_sync() once when evaluating an expression.

(atom! int      restart_edit)       ;; call edit when next cmd finished
(atom! boolean  arrow_used)         ;; Normally false, set to true after hitting cursor key in insert mode.
                                    ;; Used by vgetorpeek() to decide when to call u_sync()
(atom! boolean  ins_at_eol)         ;; put cursor after eol when restarting edit after CTRL-O

(atom! Bytes    ioBuff      (Bytes. IOSIZE))        ;; sprintf's are done in this buffer, size is IOSIZE
(atom! Bytes    nameBuff    (Bytes. MAXPATHL))      ;; file names are expanded in this buffer, size is MAXPATHL

(atom! int      redrawingDisabled)          ;; When non-zero, postpone redrawing.

(atom! typebuf_C typebuf    (ยง_typebuf_C))  ;; typeahead buffer
(atom! boolean  stop_insert_mode)           ;; for ":stopinsert" and 'insertmode'

(atom! boolean  keyTyped)                   ;; true if user typed current char
(atom! boolean  keyStuffed)                 ;; true if current char from stuffbuf
(atom! int      maptick)                    ;; tick for each non-mapped char

(final byte*    chartab     256)            ;; table used in charset.c; see init_chartab()

(atom! int      must_redraw)                ;; type of redraw necessary
(atom! boolean  skip_redraw)                ;; skip redraw once
(atom! boolean  do_redraw)                  ;; extra redraw once

(atom! boolean  need_highlight_changed true)

(atom! int      read_cmd_fd)                ;; fd to read commands from

;; volatile because it is used in signal handler catch_sigint().
(atom! #_"/*volatile*/transient" boolean got_int) ;; set to true when interrupt signal occurred

(atom! boolean  termcap_active)             ;; set by starttermcap()
(atom! int      cur_tmode       TMODE_COOK) ;; input terminal mode
(atom! boolean  bangredo)                   ;; set to true with ! command
(atom! int      searchcmdlen)               ;; length of previous search cmd
(atom! int      reg_do_extmatch)            ;; Used when compiling regexp:
                                                        ;; REX_SET to allow \z\(...\),
                                                        ;; REX_USE to allow \z\1 et al.
(atom! reg_extmatch_C re_extmatch_in)       ;; Used by vim_regexec():
                                                        ;; strings for \z\1...\z\9
(atom! reg_extmatch_C re_extmatch_out)      ;; Set by vim_regexec()
                                                        ;; to store \z\(...\) matches

(atom! boolean  need_start_insertmode)      ;; start insert mode soon
(atom! Bytes    last_cmdline)               ;; last command line (for ":)
(atom! Bytes    repeat_cmdline)             ;; command line for "."
(atom! Bytes    new_last_cmdline)           ;; new value for "last_cmdline"
(atom! boolean  did_cursorhold)             ;; set when CursorHold t'gerd
(atom! pos_C    last_cursormoved    (ยง_pos_C)) ;; for CursorMoved event
(atom! int      last_changedtick)           ;; for TextChanged event
(atom! buffer_C last_changedtick_buf)

(atom! int      postponed_split)            ;; for CTRL-W CTRL-] command
(atom! int      postponed_split_flags)      ;; args for win_split()
(atom! int      replace_offset)             ;; offset for replace_push()

;; When a string option is null (which only happens in out-of-memory situations),
;; it is set to EMPTY_OPTION to avoid having to check for null everywhere.

(final Bytes EMPTY_OPTION (u8 ""))

(atom! boolean* breakat_flags 256) ;; which characters are in 'breakat'

;; Characters from 'fillchars' option.
(atom! int
    fill_stl    \space,
    fill_stlnc  \space,
    fill_vert   \|)

;; Characters from 'listchars' option.
(atom! int
    lcs_eol     \$,
    lcs_ext     NUL,
    lcs_tab     NUL,
    lcs_trail   NUL,
    lcs_conceal \space)

;; Whether 'keymodel' contains "stopsel" and "startsel".
(atom! boolean  km_stopsel)
(atom! boolean  km_startsel)

(atom! int      cedit_key   Ctrl_F)     ;; key value of 'cedit' option
(atom! int      cmdwin_type)            ;; type of cmdline window or 0
(atom! int      cmdwin_result)          ;; result of cmdline window or 0

(final Bytes    no_lines_msg (u8 "--No lines in buffer--"))

;; When ":global" is used to number of substitutions and changed lines is
;; accumulated until it's finished.

(atom! long     sub_nsubs)              ;; total number of substitutions
(atom! long     sub_nlines)             ;; total number of lines changed

;; don't use 'hlsearch' temporarily
(atom! boolean  no_hlsearch)

(atom! boolean  term_is_xterm   true)   ;; xterm-like 'term'

;; Set to TRUE when an operator is being executed with virtual editing,
;; MAYBE when no operator is being executed, FALSE otherwise.

(atom! maybean  virtual_op  MAYBE)

;; Set when the cursor line needs to be redrawn.
(atom! boolean  need_cursor_line_redraw)

;; The error messages that can be shared are included here.
;; Excluded are errors that are only used once.

(final Bytes
    e_abort           (u8 "E470: Command aborted"),
    e_argreq          (u8 "E471: Argument required"),
    e_backslash       (u8 "E10: \\ should be followed by /, ? or &"),
    e_cmdwin          (u8 "E11: Invalid in command-line window; <CR> executes, CTRL-C quits"),
    e_internal        (u8 "E473: Internal error"),
    e_interr          (u8 "Interrupted"),
    e_invaddr         (u8 "E14: Invalid address"),
    e_invarg          (u8 "E474: Invalid argument"),
    e_invarg2         (u8 "E475: Invalid argument: %s"),
    e_invrange        (u8 "E16: Invalid range"),
    e_invcmd          (u8 "E476: Invalid command"),
    e_markinval       (u8 "E19: Mark has invalid line number"),
    e_marknotset      (u8 "E20: Mark not set"),
    e_nobang          (u8 "E477: No ! allowed"),
    e_noinstext       (u8 "E29: No inserted text yet"),
    e_nolastcmd       (u8 "E30: No previous command line"),
    e_nopresub        (u8 "E33: No previous substitute regular expression"),
    e_noprevre        (u8 "E35: No previous regular expression"),
    e_norange         (u8 "E481: No range allowed"),
    e_noroom          (u8 "E36: Not enough room"),
    e_nowrtmsg        (u8 "E37: No write since last change (add ! to override)"),
    e_null            (u8 "E38: Null argument"),
    e_number_exp      (u8 "E39: Number expected"),
    e_patnotf2        (u8 "E486: Pattern not found: %s"),
    e_positive        (u8 "E487: Argument must be positive"),
    e_re_damg         (u8 "E43: Damaged match string"),
    e_re_corr         (u8 "E44: Corrupted regexp program"),
    e_secure          (u8 "E523: Not allowed here"),
    e_scroll          (u8 "E49: Invalid scroll size"),
    e_toomsbra        (u8 "E76: Too many ["),
    e_trailing        (u8 "E488: Trailing characters"),
    e_umark           (u8 "E78: Unknown mark"),
    e_winheight       (u8 "E591: 'winheight' cannot be smaller than 'winminheight'"),
    e_winwidth        (u8 "E592: 'winwidth' cannot be smaller than 'winminwidth'"),
    e_zerocount       (u8 "Zero count"),
    e_intern2         (u8 "E685: Internal error: %s"),
    e_maxmempat       (u8 "E363: pattern uses more memory than 'maxmempattern'"),
    e_emptybuf        (u8 "E749: empty buffer"))

;; For undo we need to know the lowest time possible.
(atom! long starttime)

;; ----------------------------------------------------------------------- ;;

;; values for vim_handle_signal() that are not a signal
(final int SIGNAL_BLOCK    -1)
(final int SIGNAL_UNBLOCK  -2)

(final int KEYLEN_PART_KEY -1)      ;; keylen value for incomplete key-code
(final int KEYLEN_REMOVED  9999)    ;; keylen value for removed sequence

;; Position comparisons

(defn- #_boolean ltpos [#_pos_C a, #_pos_C b]
    (ยง
        (cond (!= (. a lnum) (. b lnum)) (< (. a lnum) (. b lnum)) (!= (. a col) (. b col)) (< (. a col) (. b col)) :else (< (. a coladd) (. b coladd)))
    ))

(defn- #_boolean eqpos [#_pos_C a, #_pos_C b]
    (ยง
        (and (== (. a lnum) (. b lnum)) (== (. a col) (. b col)) (== (. a coladd) (. b coladd)))
    ))

(defn- #_boolean ltoreq [#_pos_C a, #_pos_C b]
    (or (ltpos a, b) (eqpos a, b)))

(defn- #_void clearpos [#_pos_C a]
    (ยง
        ((ร a.lnum =) 0)
        ((ร a.col =) 0)
        ((ร a.coladd =) 0)
    ))

;; true if the line is empty

(defn- #_boolean lineempty [#_long lnum]
    (ยง
        (== (.at (ml_get lnum) 0) NUL)
    ))

;; true if the current buffer is empty

(defn- #_boolean bufempty []
    (ยง
        (and (== (.. @curbuf b_ml ml_line_count) 1) (lineempty 1))
    ))

;;; ============================================================================================== VimH

;; os_unix.c --------------------------------------------------------------------------------------

;; volatile because it is used in signal handler sig_winch().
(atom! #_"/*volatile*/transient" boolean do_resize)
;; volatile because it is used in signal handler deathtrap().
(atom! #_"/*volatile*/transient" int deadly_signal)                     ;; the signal we caught
;; volatile because it is used in signal handler deathtrap().
(atom! #_"/*volatile*/transient" boolean in_mch_delay)                  ;; sleeping in mch_delay()

(atom! int curr_tmode TMODE_COOK)                 ;; contains current terminal mode

(class! #_final signalinfo_C
    [
        (field int      sig)        ;; Signal number, e.g. SIGSEGV etc.
        (field Bytes    name)       ;; Signal name.
        (field boolean  deadly)     ;; Catch as a deadly signal?
    ])

(final signalinfo_C* signal_info
    [
; %%    (->signalinfo_C SIGHUP,    (u8 "HUP"),      true ),
; %%    (->signalinfo_C SIGQUIT,   (u8 "QUIT"),     true ),
; %%    (->signalinfo_C SIGILL,    (u8 "ILL"),      true ),
; %%    (->signalinfo_C SIGTRAP,   (u8 "TRAP"),     true ),
; %%    (->signalinfo_C SIGABRT,   (u8 "ABRT"),     true ),
; %%    (->signalinfo_C SIGFPE,    (u8 "FPE"),      true ),
; %%    (->signalinfo_C SIGBUS,    (u8 "BUS"),      true ),
; %%    (->signalinfo_C SIGSEGV,   (u8 "SEGV"),     true ),
; %%    (->signalinfo_C SIGSYS,    (u8 "SYS"),      true ),
; %%    (->signalinfo_C SIGALRM,   (u8 "ALRM"),     false),
; %%    (->signalinfo_C SIGTERM,   (u8 "TERM"),     true ),
; %%    (->signalinfo_C SIGVTALRM, (u8 "VTALRM"),   true ),
; %%    (->signalinfo_C SIGPROF,   (u8 "PROF"),     true ),
; %%    (->signalinfo_C SIGXCPU,   (u8 "XCPU"),     true ),
; %%    (->signalinfo_C SIGXFSZ,   (u8 "XFSZ"),     true ),
; %%    (->signalinfo_C SIGUSR1,   (u8 "USR1"),     true ),
; %%    (->signalinfo_C SIGUSR2,   (u8 "USR2"),     true ),
; %%    (->signalinfo_C SIGINT,    (u8 "INT"),      false),
; %%    (->signalinfo_C SIGWINCH,  (u8 "WINCH"),    false),
; %%    (->signalinfo_C SIGTSTP,   (u8 "TSTP"),     false),
; %%    (->signalinfo_C SIGPIPE,   (u8 "PIPE"),     false),

        (->signalinfo_C -1,        (u8 "Unknown!"), false)
    ])

;; Write s[len] to the screen.

(defn- #_void mch_write [#_Bytes s, #_int len]
    (ยง
        (ยง libC.write(1, s, len))
        (when (non-zero? @p_wd)           ;; Unix is too fast, slow down a bit more
            (realWaitForChar @read_cmd_fd, @p_wd)
        )
    ))

;; mch_inchar(): low level input function.
;; Get a characters from the keyboard.
;; Return the number of characters that are available.
;; If wtime == 0 do not wait for characters.
;; If wtime == n wait a short time for characters.
;; If wtime == -1 wait forever for characters.

(defn- #_int mch_inchar [#_Bytes buf, #_int maxlen, #_long wtime, #_int tb_change_cnt]
    ;; wtime: don't use "time", MIPS cannot handle it
    (ยง
        ;; Check if window changed size while we were busy, perhaps the ":set columns=99" command was used.
        (while @do_resize
            (handle_resize)
        )

        (cond (<= 0 wtime)
        (ยง
            (while (ยง !waitForChar(wtime))         ;; no character available
                (if (not @do_resize)                     ;; return if not interrupted by resize
                    ((ร RETURN) 0)
                )
                (handle_resize)
            )
        )
        :else        ;; wtime == -1
        (ยง
            ;; If there is no character available within 'updatetime' seconds
            ;; flush all the swap files to disk.
            ;; Also done when interrupted by SIGWINCH.

            (when (not (waitForChar @p_ut))
                (when (and (trigger_cursorhold) (<= 3 maxlen) (not (typebuf_changed tb_change_cnt)))
                    (.be buf 0, KB_SPECIAL)
                    (.be buf 1, KS_EXTRA)
                    (.be buf 2, KE_CURSORHOLD)
                    ((ร RETURN) 3)
                )
                (before_blocking)
            )
        ))

        (while true                                 ;; repeat until we got a character
            (while @do_resize
                (handle_resize)
            )                       ;; window changed size

            ;; We want to be interrupted by the winch signal
            ;; or by an event on the monitored file descriptors.

            (when (not (waitForChar -1))
                (if @do_resize                      ;; interrupted by SIGWINCH signal
                    (handle_resize))
                ((ร RETURN) 0)
            )

            ;; If input was put directly in typeahead buffer bail out here.
            (if (typebuf_changed tb_change_cnt)
                ((ร RETURN) 0)
            )

            ;; For some terminals we only get one character at a time.
            ;; We want the get all available characters, so we could keep on trying until none is available.
            ;; For some other terminals this is quite slow, that's why we don't do it.

            ((ร int len =) (read_from_input_buf buf, maxlen))
            (if (< 0 len)
                ((ร RETURN) len)
            )
        )
    ))

(defn- #_void handle_resize []
    (ยง
        (reset! do_resize false)
        (shell_resized)
    ))

(defn- #_void mch_delay [#_long msec, #_boolean ignoreinput]
    (ยง
        (cond ignoreinput
        (ยง
            ;; Go to cooked mode without echo, to allow SIGINT interrupting us here.
            ;; But we don't want QUIT to kill us (CTRL-\ used in a shell may produce SIGQUIT).
            (reset! in_mch_delay true)
            ((ร int old_tmode =) @curr_tmode)
            (if (== @curr_tmode TMODE_RAW)
                (settmode TMODE_SLEEP))

            ;; Everybody sleeps in a different way...
            ;; Prefer nanosleep(), some versions of usleep() can only sleep up to one second.

;           {
                ((ร timespec_C ts =) (ยง new timespec_C()))

                (ยง ts.tv_sec(msec / 1000))
                (ยง ts.tv_nsec((msec % 1000) * 1000000))
                (ยง libc.nanosleep(ts, null))
;           }

            (settmode old_tmode)
            (reset! in_mch_delay false)
        )
        :else
        (ยง
            (waitForChar msec)
        ))
    ))

;; We need correct prototypes for a signal function, otherwise mean compilers
;; will barf when the second argument to sigset() is ``wrong''.

(defn- #_void sig_winch [#_int _sigarg]
    (ยง
        ;; this is not required on all systems, but it doesn't hurt anybody
        (ยง libC.sigset(SIGWINCH, #_"/*(void (*)())sig_winch*/"null))
        (reset! do_resize true)
    ))

(defn- #_void catch_sigint [#_int _sigarg]
    (ยง
        ;; this is not required on all systems, but it doesn't hurt anybody
        (ยง libC.sigset(SIGINT, #_"/*(void (*)())catch_sigint*/"null))
        (reset! got_int true)
    ))

(defn- #_void catch_sigpwr [#_int _sigarg]
    (ยง
        ;; this is not required on all systems, but it doesn't hurt anybody
        (ยง libC.sigset(SIGPWR, #_"/*(void (*)())catch_sigpwr*/"null))
    ))

(atom! int trap__entered)       ;; Count the number of times we got here.
                                            ;; Note: when memory has been corrupted
                                            ;; this may get an arbitrary value!

(defn- #_void may_core_dump []
    (ยง
        (when (non-zero? @deadly_signal)
            (ยง libC.sigset(@deadly_signal, #_"/*SIG_DFL*/"null))
            (ยง libc.kill(libc.getpid(), @deadly_signal))        ;; Die using the signal we caught
        )
    ))

;; This function handles deadly signals.
;; It tries to preserve any swap files and exit properly.
;; NOTE: Avoid unsafe functions, such as allocating memory, they can result in a deadlock.

(defn- #_void deathtrap [#_int sigarg]
    (ยง
        ;; While in mch_delay() we go to cooked mode to allow a CTRL-C to interrupt us.
        ;; But in cooked mode we may also get SIGQUIT, e.g., when pressing CTRL-\,
        ;; but we don't want Vim to exit then.
        (if (and @in_mch_delay (== sigarg SIGQUIT))
            (ร RETURN)
        )

        ;; When SIGHUP, SIGQUIT, etc. are blocked: postpone the effect and return here.
        ;; This avoids that a non-reentrant function is interrupted, e.g. free().
        ;; Calling free() again may then cause a crash.
        (if (and (zero? @trap__entered) (or (== sigarg SIGHUP) (== sigarg SIGQUIT) (== sigarg SIGTERM) (== sigarg SIGPWR) (== sigarg SIGUSR1) (== sigarg SIGUSR2)) (not (vim_handle_signal sigarg)))
            (ร RETURN)
        )

        ;; Remember how often we have been called.
        (swap! trap__entered inc)

        (ร int i)

        ;; try to find the name of this signal
        ((ร FOR) (ร (ยง i = 0) (ยง signal_info[i].sig != -1) (ยง i++))
            (if (== sigarg (ยง signal_info[i].sig))
                (ร BREAK)
            )
        )
        (reset! deadly_signal sigarg)

        (reset! full_screen false)    ;; don't write message to the GUI, it might be part of the problem...

        ;; If something goes wrong after entering here, we may get here again.
        ;; When this happens, give a message and try to exit nicely (resetting the terminal mode, etc.)
        ;; When this happens twice, just exit, don't even try to give a message,
        ;; stack may be corrupt or something weird.
        ;; When this still happens again (or memory was corrupted in such a way
        ;; that "trap__entered" was clobbered) use _exit(), don't try freeing resources.

        (when (<= 3 @trap__entered)
            (reset_signals)        ;; don't catch any signals anymore
            (may_core_dump)
            (if (<= 4 @trap__entered)
                (ยง libc._exit(8))
            )
            (ยง libc.exit(7))
        )
        (when (== @trap__entered 2)
            (out_str (u8 "Vim: Double signal, exiting\n"))
            (out_flush)
            (getout 1)
        )

        (ยง libC.sprintf(@ioBuff, (u8 "Vim: Caught deadly signal %s\n"), signal_info[i].name))

        ;; Preserve files and exit.
        (preserve_exit)
    ))

;; If the machine has job control, use it to suspend the program,
;; otherwise fake it by starting a new shell.

(defn- #_void mch_suspend []
    (ยง
        (out_flush)                        ;; needed to make cursor visible on some systems
        (settmode TMODE_COOK)
        (out_flush)                        ;; needed to disable mouse on some systems

        (ยง libc.kill(0, SIGTSTP))              ;; send ourselves a STOP signal

        (settmode TMODE_RAW)
    ))

(defn- #_void mch_init []
    (ยง
        (reset! Columns 80)
        (reset! Rows 24)

        (out_flush)
        (set_signals)
    ))

(defn- #_void set_signals []
    (ยง
        ;; WINDOW CHANGE signal is handled with sig_winch().

        (ยง libC.sigset(SIGWINCH, #_"/*(void (*)())sig_winch*/"null))

        ;; We want the STOP signal to work, to make mch_suspend() work.
        ;; For "rvim" the STOP signal is ignored.

        (ยง libC.sigset(SIGTSTP, #_"/*SIG_DFL*/"null))

        ;; We want to ignore breaking of PIPEs.

        (ยง libC.sigset(SIGPIPE, #_"/*SIG_IGN*/"null))

        (catch_int_signal)

        ;; Ignore alarm signals (Perl's alarm() generates it).

        (ยง libC.sigset(SIGALRM, #_"/*SIG_IGN*/"null))

        ;; Catch SIGPWR (power failure?) to preserve the swap files, so that no work will be lost.

        (ยง libC.sigset(SIGPWR, #_"/*(void (*)())catch_sigpwr*/"null))

        ;; Arrange for other signals to gracefully shutdown Vim.

        (catch_signals #_"/*deathtrap*//*null*/"0, SIG_ERR)
    ))

;; Catch CTRL-C (only works while in Cooked mode).

(defn- #_void catch_int_signal []
    (ยง
        (ยง libC.sigset(SIGINT, #_"/*(void (*)())catch_sigint*/"null))
    ))

(defn- #_void reset_signals []
    (ยง
        (catch_signals SIG_DFL, SIG_DFL)
    ))

(defn- #_void catch_signals #_"/*(void (*func_deadly)(), void (*func_other)())*/" [#_@sighandler_t #_long func_deadly, #_@sighandler_t #_long func_other]
    (ยง
        ((ร FOR) (ร (ยง int i = 0) (ยง signal_info[i].sig != -1) (ยง i++))
            (cond (ยง signal_info[i].deadly)
            (ยง
;            // sigaction_C sa = new sigaction_C();

                ;; Setup to use the alternate stack for the signal function.
;            // sa.sa_handler(func_deadly);
                (ยง libC.sigemptyset(#_"/*&sa.sa_mask*/"null))
;            // sa.sa_flags(SA_ONSTACK);
                (ยง libC.sigaction(signal_info[i].sig, #_"/*sa*/"null, null))
            )
            (!= func_other SIG_ERR)
            (ยง
                (ยง libC.sigset(signal_info[i].sig, #_"/*func_other*/"null))
            ))
        )
    ))

(atom! int got_signal)
(atom! boolean __blocked true)

;; Handling of SIGHUP, SIGQUIT and SIGTERM:
;; "when" == a signal:       when busy, postpone and return false, otherwise return true
;; "when" == SIGNAL_BLOCK:   Going to be busy, block signals
;; "when" == SIGNAL_UNBLOCK: Going to wait, unblock signals, use postponed signal
;; Returns true when Vim should exit.

(defn- #_boolean vim_handle_signal [#_int sig]
    (ยง
        ((ร SWITCH) sig
            ((ร CASE) SIGNAL_BLOCK)
            (ยง
                (reset! __blocked true)
                (ร BREAK)
            )
            ((ร CASE) SIGNAL_UNBLOCK)
            (ยง
                (reset! __blocked false)
                (when (non-zero? @got_signal)
                    (ยง libc.kill(libc.getpid(), @got_signal))
                    (reset! got_signal 0)
                )
                (ร BREAK)
            )
            (ร DEFAULT)
            (ยง
                (if (not @__blocked)
                    ((ร RETURN) true)            ;; exit!
                )
                (reset! got_signal sig)
                (if (!= sig SIGPWR)
                    (reset! got_int true))         ;; break any loops
                (ร BREAK)
            )
        )
        false
    ))

;; Output a newline when exiting.
;; Make sure the newline goes to the same stream as the text.

(defn- #_void exit_scroll []
    (ยง
        (cond (or @newline_on_exit @msg_didout)
        (ยง
            (cond (msg_use_printf)
            (ยง
                (if @info_message
                    (ยง libC.fprintf(stdout, (u8 "\n")))
                    (ยง libC.fprintf(stderr, (u8 "\r\n")))
                )
            )
            :else
            (ยง
                (out_char (byte \newline))
            ))
        )
        :else
        (ยง
            (restore_cterm_colors)         ;; get original colors back
            (msg_clr_eos_force)            ;; clear the rest of the display
            (windgoto (- (int @Rows) 1), 0)     ;; may have moved the cursor
        ))
    ))

(defn- #_void mch_exit [#_int r]
    (ยง
        (reset! exiting true)

        (settmode TMODE_COOK)

        ;; When t_ti is not empty, but it doesn't cause swapping terminal pages,
        ;; need to output a newline when msg_didout is set.
        ;; But when t_ti does swap pages, it should not go to the shell page.
        ;; Do this before stoptermcap().

        (if (and (swapping_screen) (not @newline_on_exit))
            (exit_scroll))

        (stoptermcap)

        ;; A newline is only required after a message in the alternate screen.
        ;; This is set to true by wait_return().
        (if (or (not (swapping_screen)) @newline_on_exit)
            (exit_scroll))

        ;; Cursor may have been switched off without calling starttermcap()
        ;; when doing "vim -u vimrc" and vimrc contains ":q".
        (if @full_screen
            (cursor_on))

        (out_flush)

        (may_core_dump)

        (ยง libc.exit(r))
    ))

;; for "new" tty systems

(atom! termios_C stm__told)

(defn- #_void mch_settmode [#_int tmode]
    (ยง
        (when (nil? @stm__told)
            (reset! stm__told (ยง new termios_C()))
            (ยง libc.tcgetattr(@read_cmd_fd, @stm__told))
        )

        ((ร termios_C tnew =) (ยง new termios_C()))
        (COPY_termios tnew, @stm__told)

        (cond (== tmode TMODE_RAW)
        (ยง
            ;; ~ICRNL enables typing ^V^M

            (ยง tnew.c_iflag(tnew.c_iflag() & ~(ICRNL)))
            (ยง tnew.c_lflag(tnew.c_lflag() & ~(ICANON | ECHO | ISIG | ECHOE | IEXTEN)))
            (ยง tnew.c_oflag(tnew.c_oflag() & ~(ONLCR)))
            (ยง tnew.c_vmin((short)1))      ;; return after 1 char
            (ยง tnew.c_vtime((short)0))     ;; don't wait
        )
        (== tmode TMODE_SLEEP)
        (ยง
            (ยง tnew.c_lflag(tnew.c_lflag() & ~(ECHO)))
        ))

        ;; A signal may cause tcsetattr() to fail (e.g., SIGCONT).  Retry a few times.
        ((ร FOR) (ร (ยง int n = 10) (ยง libc.tcsetattr(@read_cmd_fd, TCSANOW, tnew) == -1 && libC.errno() == EINTR && 0 < n) (ยง --n))
;           ;
        )

        (reset! curr_tmode tmode)
    ))

;; try to get the code for "t_kb" from the stty setting
;;
;; Even if termcap claims a backspace key, the user's setting *should*
;; prevail.  stty knows more about reality than termcap does, and if
;; somebody's usual erase key is DEL (which, for most BSD users, it will
;; be), they're going to get really annoyed if their erase key starts
;; doing forward deletes for no reason.

(defn- #_void get_stty []
    (ยง
        ;; for "new" tty systems
        ((ร termios_C keys =) (ยง new termios_C()))

        (when (ยง libc.tcgetattr(@read_cmd_fd, keys) != -1)
            ((ร Bytes buf =) (ยง new Bytes(2)))

            (.be buf 0, (ยง keys.c_verase()))
            (reset! intr_char (ยง keys.c_vintr()))
            (.be buf 1, NUL)
            (add_termcode (u8 "kb"), buf)

            ;; If <BS> and <DEL> are now the same, redefine <DEL>.

            ((ร Bytes p =) (find_termcode (u8 "kD")))
            (if (and (non-nil? p) (== (.at p 0) (.at buf 0)) (== (.at p 1) (.at buf 1)))
                (ex_fixdel null))
        )
    ))

;; Try to get the current window size:
;; 1. with an ioctl(), most accurate method
;; 2. from the environment variables LINES and COLUMNS
;; 4. keep using the old values
;; Return true when size could be determined, false otherwise.

(defn- #_boolean mch_get_shellsize []
    (ยง
        ((ร long rows =) 0)
        ((ร long columns =) 0)

        ;; 1. try using an ioctl.  It is the most accurate method.
;       {
            ((ร int fd =) 1)

            ;; When stdout is not a tty, use stdin for the ioctl().
            (if (and (== (ยง libc.isatty(fd)) 0) (!= (ยง libc.isatty(@read_cmd_fd)) 0))
                ((ร fd =) @read_cmd_fd)
            )

            ((ร winsize_C ws =) (ยง new winsize_C()))

            (when (ยง libc.ioctl(fd, TIOCGWINSZ, ws) == 0)
                ((ร rows =) (ยง ws.ws_row()))
                ((ร columns =) (ยง ws.ws_col()))
            )
;       }

        ;; 2. get size from environment

        (when (or (zero? columns) (zero? rows))
            (ร Bytes p)
            (if (non-nil? ((ร p =) (.getenv libC (u8 "LINES"))))
                ((ร rows =) (.atoi libC p))
            )
            (if (non-nil? ((ร p =) (.getenv libC (u8 "COLUMNS"))))
                ((ร columns =) (.atoi libC p))
            )
        )

        ;; 4. If everything fails, use the old values

        (if (or (<= columns 0) (<= rows 0))
            ((ร RETURN) false)
        )

        (reset! Rows rows)
        (reset! Columns columns)
        (limit_screen_size)
        true
    ))

;; Try to set the window size to Rows and Columns.

(defn- #_void mch_set_shellsize []
    (ยง
        (when (non-eos? @T_CWS)
            ;; NOTE: if you get an error here that term_set_winsize() is undefined,
            ;; check the output of configure.  It could probably not find a ncurses,
            ;; termcap or termlib library.

            (term_set_winsize (int @Rows), (int @Columns))
            (out_flush)
            (screen_start)                 ;; don't know where cursor is now
        )
    ))

;; Rows and/or Columns has changed.

(defn- #_void mch_new_shellsize []
    (ยง
        ;; Nothing to do.
    ))

;; Check for CTRL-C typed by reading all available characters.
;; In cooked mode we should get SIGINT, no need to check.

(defn- #_void mch_breakcheck []
    (ยง
        (when (and (== @curr_tmode TMODE_RAW) (realWaitForChar @read_cmd_fd, 0))
            (fill_input_buf false)
        )
    ))

;; Wait "msec" msec until a character is available from the keyboard or from inbuf[].
;; "msec" == -1 will block forever.

(defn- #_boolean waitForChar [#_long msec]
    (ยง
        (if (input_available)          ;; something in inbuf[]
            ((ร RETURN) true)
        )

        (realWaitForChar @read_cmd_fd, msec)
    ))

;; Wait "msec" msec until a character is available from file descriptor "fd".
;; "msec" == 0 will check for characters once.
;; "msec" == -1 will block until a character is available.

(defn- #_boolean realWaitForChar [#_int fd, #_long msec]
    (ยง
        ((ร timeval_C tv =) (ยง new timeval_C()))
        (when (<= 0 msec)
            (ยง tv.tv_sec(msec / 1000))
            (ยง tv.tv_usec((msec % 1000) * 1000))
        )

        ;; Select on ready for reading and exceptional condition (end of file).

        ((ร FOR) (ร (ยง long[] rfds = new long[FD_SET_LENGTH], efds = new long[FD_SET_LENGTH]) true nil)
            (FD_ZERO rfds)
            (FD_ZERO efds)
            (FD_SET fd, rfds)
            (FD_SET fd, efds)

            ((ร int ret =) (.select libc (+ fd 1), rfds, null, efds, (if (< msec 0) null tv)))

            (when (and (== ret -1) (== (.errno libC) EINTR))
                ;; Check whether window has been resized, EINTR may be caused by SIGWINCH.

                (if @do_resize
                    (handle_resize))

                ;; Interrupted by a signal, need to try again.  We ignore msec here,
                ;; because we do want to check even after a timeout if characters are available.
                ;; Needed for reading output of an external command after the process has finished.

                (ร CONTINUE)
            )

            ((ร RETURN) (ยง (0 < ret)))
        )

        ;; NOTREACHED
    ))

;; message.c: functions for displaying messages on the command line -------------------------------

(atom! int      confirm_msg_used)       ;; displaying "confirm_msg"
(atom! Bytes    confirm_msg)            ;; ":confirm" message
(atom! Bytes    confirm_msg_tail)       ;; tail of "confirm_msg"

;; When writing messages to the screen, there are many different situations.
;; A number of variables is used to remember the current state:
;; msg_didany       true when messages were written since the last time the user reacted to a prompt.
;;                  Reset: After hitting a key for the hit-return prompt,
;;                  hitting <CR> for the command line or input().
;;                  Set: When any message is written to the screen.
;; msg_didout       true when something was written to the current line.
;;                  Reset: When advancing to the next line, when the current text can be overwritten.
;;                  Set: When any message is written to the screen.
;; msg_nowait       No extra delay for the last drawn message.
;;                  Used in normal_cmd() before the mode message is drawn.
;; emsg_on_display  There was an error message recently.
;;                  Indicates that there should be a delay before redrawing.
;; msg_scroll       The next message should not overwrite the current one.
;; msg_scrolled     How many lines the screen has been scrolled (because of messages).
;;                  Used in update_screen() to scroll the screen back.
;;                  Incremented each time the screen scrolls a line.
;; msg_scrolled_ign true when msg_scrolled is non-zero and msg_puts_attr() writes something
;;                  without scrolling should not make need_wait_return to be set.
;;                  This is a hack to make ":ts" work without an extra prompt.
;; lines_left       Number of lines available for messages before the more-prompt is to be given.
;;                  -1 when not set.
;; need_wait_return true when the hit-return prompt is needed.
;;                  Reset: After giving the hit-return prompt, when the user has answered some other prompt.
;;                  Set: When the ruler or typeahead display is overwritten,
;;                  scrolling the screen for some message.
;; keep_msg         Message to be displayed after redrawing the screen, in main_loop().
;;                  This is an allocated string or null when not used.

;; msg(s) - displays the string 's' on the status line.
;; Return true if wait_return not called.

(defn- #_boolean msg [#_Bytes s]
    (msg_attr_keep s, 0, false))

(defn- #_boolean msg_attr [#_Bytes s, #_int attr]
    (msg_attr_keep s, attr, false))

(atom! int msg__entered)

(defn- #_boolean msg_attr_keep [#_Bytes s, #_int attr, #_boolean keep]
    ;; keep: true: set "keep_msg" if it doesn't scroll
    (ยง
        ;; It is possible that displaying a messages causes a problem
        ;; (e.g. when redrawing the window), which causes another message, etc.
        ;; To break this loop, limit the recursiveness to 3 levels.

        (if (<= 3 @msg__entered)
            ((ร RETURN) true)
        )
        (swap! msg__entered inc)

        ;; When displaying "keep_msg", don't let msg_start() free it, caller must do that.
        (if (BEQ s, @keep_msg)
            (reset! keep_msg null))

        ;; Truncate the message if needed.
        (msg_start)

        ((ร Bytes buf =) (msg_strtrunc s, false))
        (if (non-nil? buf)
            ((ร s =) buf)
        )

        (msg_outtrans_attr s, attr)
        (msg_clr_eos)

        ((ร boolean retval =) (msg_end))

        (if (and keep retval (< (mb_string2cells s, -1) (+ (* (int (- @Rows @cmdline_row 1)) (int @Columns)) @sc_col)))
            (set_keep_msg s, 0))

        (swap! msg__entered dec)
        retval
    ))

;; Truncate a string such that it can be printed without causing a scroll.
;; Returns an allocated string or null when no truncating is done.

(defn- #_Bytes msg_strtrunc [#_Bytes s, #_boolean force]
    ;; force: always truncate
    (ยง
        ((ร Bytes buf =) null)

        ;; May truncate message to avoid a hit-return prompt.
        (when (or (and (not @msg_scroll) (not @need_wait_return)) force)
            (ร int room)
            ((ร int len =) (mb_string2cells s, -1))
            (cond (non-zero? @msg_scrolled)
            (ยง
                ;; Use all the columns.
                ((ร room =) (ยง (int)(@Rows - @msg_row) * (int)@Columns - 1))
            )
            :else
            (ยง
                ;; Use up to 'showcmd' column.
                ((ร room =) (ยง (int)(@Rows - @msg_row - 1) * (int)@Columns + @sc_col - 1))
            ))
            (when (and (< room len) (< 0 room))
                ;; may have up to 18 bytes per cell (6 per char, up to two composing chars)
                ((ร len =) (ยง (room + 2) * 18))
                ((ร buf =) (ยง new Bytes(len)))
                (trunc_string s, buf, room, len)
            )
        )

        buf
    ))

;; Truncate a string "s" to "buf" with cell width "room".
;; "s" and "buf" may be equal.

(defn- #_void trunc_string [#_Bytes s, #_Bytes buf, #_int room, #_int buflen]
    (ยง
        ((ร room -=) 3)

        ((ร int half =) (/ room 2))
        ((ร int len =) 0)

        (ร int e)

        ;; First part: Start of the string.
        ((ร FOR) (ร (ยง e = 0) (ยง len < half && e < buflen) (ยง e++))
            (when (eos? s e)
                ;; text fits without truncating!
                (.be buf e, NUL)
                (ร RETURN)
            )

            ((ร int n =) (ยง mb_ptr2cells(s.plus(e))))
            (if (<= half (+ len n))
                (ร BREAK)
            )
            ((ร len +=) n)
            (.be buf e, (ยง s.at(e)))

            ((ร FOR) (ร (ยง n = us_ptr2len_cc(s.plus(e))) (ยง 0 < --n) nil)
                (if (== (ยง ++e) buflen)
                    (ร BREAK)
                )
                (.be buf e, (ยง s.at(e)))
            )
        )

        ;; Last part: End of the string.
        ((ร int i =) e)

        ;; For UTF-8 we can go backwards easily.
        ((ร half =) (ยง i = STRLEN(s)))
        (while true
;           do
;           {
                ((ร half =) (ยง half - us_head_off(s, s.plus(half - 1)) - 1))
;           } while (utf_iscomposing(us_ptr2char(s.plus(half))) && 0 < half);
            ((ร int n =) (ยง mb_ptr2cells(s.plus(half))))
            (if (< room (+ len n))
                (ร BREAK)
            )
            ((ร len +=) n)
            ((ร i =) half)
        )

        ;; Set the middle and copy the last part.
        (cond (< (+ e 3) buflen)
        (ยง
            (BCOPY buf, e, (u8 "..."), 0, 3)
            ((ร len =) (ยง STRLEN(s, i) + 1))
            (if (ยง buflen - e - 3 <= len)
                ((ร len =) (ยง buflen - e - 3 - 1))
            )
            (BCOPY buf, (+ e 3), s, i, len)
            (ยง buf.be(e + 3 + len - 1, NUL))
        )
        :else
        (ยง
            (ยง buf.be(e - 1, NUL))     ;; make sure it is truncated
        ))
    ))

(defn- #_final #_boolean smsg [#_Bytes s, #_Object... args]
    (smsg_attr 0, s, args))

(defn- #_boolean smsg_attr [#_int attr, #_Bytes s, #_Object... args]
    (ยง
        (ยง vim_snprintf(@ioBuff, IOSIZE, s, args))

        (msg_attr @ioBuff, attr)
    ))

;; Return true if not giving error messages right now:
;; If "emsg_off" is set: no error messages at the moment.
;; If "emsg_skip" is set: never do error messages.

(defn- #_boolean emsg_not_now []
    (or (< 0 @emsg_off) (< 0 @emsg_skip)))

;; emsg() - display an error message.
;;
;; Rings the bell, if appropriate, and calls message() to do the real work.
;;
;; Return true if wait_return not called.

(defn- #_boolean emsg [#_Bytes s]
    (ยง
        ;; Skip this if not giving error messages at the moment.
        (if (emsg_not_now)
            ((ร RETURN) true)
        )

        (reset! called_emsg true)
        (reset! ex_exitval 1)

        (when (zero? @emsg_off)
            (if @p_eb
                (beep_flush)               ;; also includes flush_buffers()
                (flush_buffers false))       ;; flush internal buffers
            (reset! did_emsg true)                ;; flag for DoOneCmd()
        )

        (reset! emsg_on_display true)             ;; remember there is an error message
        (reset! msg_scroll true)                  ;; don't overwrite a previous message
        ((ร int attr =) (hl_attr HLF_E))          ;; set highlight mode for error messages
        (when (non-zero? @msg_scrolled)
            (reset! need_wait_return true)        ;; needed in case emsg() is called after
                                            ;; wait_return has reset need_wait_return
                                            ;; and a redraw is expected because
                                            ;; msg_scrolled is non-zero
        )

        ;; Display the error message itself.

        (reset! msg_nowait false)                 ;; wait for this msg
        (msg_attr s, attr)
    ))

;; Print an error message with one "%s" and one string argument.

(defn- #_boolean emsg2 [#_Bytes s, #_Bytes a1]
    (emsg3 s, a1, null))

;; emsg3() and emsgn() are in misc.c to avoid warnings for the prototypes.

(defn- #_void emsg_invreg [#_int name]
    (emsg2 (u8 "E354: Invalid register name: '%s'"), (transchar name)))

;; Like msg(), but truncate to a single line when "force" is true.
;; This truncates in another way as for normal messages.
;; Careful: The string may be changed by msg_may_trunc()!
;; Returns a pointer to the printed message, if wait_return() not called.

(defn- #_Bytes msg_trunc_attr [#_Bytes s, #_boolean force, #_int attr]
    (ยง
        ((ร s =) (msg_may_trunc force, s))

        (if (msg_attr s, attr) s null)
    ))

;; Check if message "s" should be truncated at the start (for filenames).
;; Return a pointer to where the truncated message starts.
;; Note: May change the message by replacing a character with '<'.

(defn- #_Bytes msg_may_trunc [#_boolean force, #_Bytes s]
    (ยง
        ((ร int room =) (ยง (int)(@Rows - @cmdline_row - 1) * (int)@Columns + @sc_col - 1))

        (when (< 0 (- (STRLEN s) room))
            ((ร int cells =) (mb_string2cells s, -1))

            ;; There may be room anyway when there are multibyte chars.
            (if (<= cells room)
                ((ร RETURN) s)
            )

            (ร int n)
            ((ร FOR) (ร (ยง n = 0) (<= room cells) (ยง n += us_ptr2len_cc(s.plus(n))))
                ((ร cells -=) (ยง us_ptr2cells(s.plus(n))))
            )
            (ยง --n)

            ((ร s =) (ยง s.plus(n)))
            (.be s 0, (byte \<))
        )

        s
    ))

;; wait for the user to hit a key (normally a return)
;; if 'redraw' is true, clear and redraw the screen
;; if 'redraw' is false, just redraw the screen
;; if 'redraw' is -1, don't redraw at all

(defn- #_void wait_return [#_int redraw]
    (ยง
        (if (== redraw TRUE)
            (reset! must_redraw CLEAR))

        ;; When inside vgetc(), we can't wait for a typed character at all.
        ;; With the global command (and some others) we only need one return at
        ;; the end.  Adjust cmdline_row to avoid the next message overwriting the last one.

        (if (< 0 @vgetc_busy)
            (ร RETURN)
        )

        (reset! need_wait_return true)

        (when (non-zero? @no_wait_return)
            (reset! cmdline_row @msg_row)
            (ร RETURN)
        )

        (ร int c)

        ((ร int oldState =) @State)
        (cond @quit_more
        (ยง
            ((ร c =) CAR)                    ;; just pretend CR was hit
            (reset! quit_more false)
            (reset! got_int false)
        )
        :else
        (ยง
            ;; Make sure the hit-return prompt is on screen when 'guioptions' was just changed.
            (screenalloc false)

            (reset! State HITRETURN)

            (hit_return_msg)

            (ร boolean had_got_int)
;           do
;           {
                ;; Remember "got_int", if it is set vgetc() probably returns a CTRL-C,
                ;; but we need to loop then.
                ((ร had_got_int =) @got_int)

                ;; Don't do mappings here, we put the character back in the typeahead buffer.
                (swap! no_mapping inc)
                (swap! allow_keys inc)

                ;; Temporarily disable Recording.
                ;; If Recording is active, the character will be recorded later,
                ;; since it will be added to the typebuf after the loop.
                ((ร boolean save_Recording =) @Recording)
                (reset! Recording false)
                ((ร c =) (safe_vgetc))
                (if had_got_int
                    (reset! got_int false))
                (swap! no_mapping dec)
                (swap! allow_keys dec)
                (reset! Recording save_Recording)

                ;; Allow scrolling back in the messages.
                ;; Also accept scroll-down commands when messages fill the screen,
                ;; to avoid that typing one 'j' too many makes the messages disappear.

                (when @p_more
                    (cond (or (== c (byte \b)) (== c (byte \k)) (== c (byte \u)) (== c (byte \g)) (== c K_UP) (== c K_PAGEUP))
                    (ยง
                        (cond (< @Rows @msg_scrolled)
                        (ยง
                            ;; scroll back to show older messages
                            (do_more_prompt c)
                        )
                        :else
                        (ยง
                            (reset! msg_didout false)
                            ((ร c =) K_IGNORE)
                            (reset! msg_col 0)
                        ))
                        (cond @quit_more
                        (ยง
                            ((ร c =) CAR)                ;; just pretend CR was hit
                            (reset! quit_more false)
                            (reset! got_int false)
                        )
                        (!= c K_IGNORE)
                        (ยง
                            ((ร c =) K_IGNORE)
                            (hit_return_msg)
                        ))
                    )
                    (and (< (- @Rows 2) @msg_scrolled) (or (== c (byte \j)) (== c (byte \d)) (== c (byte \f)) (== c K_DOWN) (== c K_PAGEDOWN)))
                    (ยง
                        ((ร c =) K_IGNORE)
                    ))
                )
;           } while ((had_got_int && c == Ctrl_C) || c == K_IGNORE);
            (ui_breakcheck)

            (when (and (nil? (vim_strchr (u8 "\r\n "), c)) (!= c Ctrl_C))
                ;; Put the character back in the typeahead buffer.
                ;; Don't use the stuff buffer, because lmaps wouldn't work.
                (ins_char_typebuf c)
                (reset! do_redraw true)       ;; need a redraw even though there is typeahead
            )
        ))

        ;; If the user hits ':', '?' or '/' we get a command line from the next line.

        (when (or (== c (byte \:)) (== c (byte \?)) (== c (byte \/)))
            (reset! cmdline_row @msg_row)
            (reset! skip_redraw true)         ;; skip redraw once
            (reset! do_redraw false)
        )

        ;; If the window size changed set_shellsize() will redraw the screen.
        ;; Otherwise the screen is only redrawn if 'redraw' is set and no ':' typed.

        ((ร int tmpState =) @State)
        (reset! State oldState)               ;; restore State before set_shellsize
        (msg_check)

        ;; When switching screens, we need to output an extra newline on exit.

        (if (and (swapping_screen) (not @termcap_active))
            (reset! newline_on_exit true))

        (reset! need_wait_return false)
        (reset! did_wait_return true)
        (reset! emsg_on_display false)    ;; can delete error message now
        (reset! lines_left -1)            ;; reset lines_left at next msg_start()

        (when (and (non-nil? @keep_msg) (<= (+ (* (int (- @Rows @cmdline_row 1)) (int @Columns)) @sc_col) (mb_string2cells @keep_msg, -1)))
            (reset! keep_msg null)            ;; don't redisplay message, it's too long
        )

        (cond (== tmpState SETWSIZE)       ;; got resize event while in vgetc()
        (ยง
            (starttermcap)             ;; start termcap before redrawing
            (shell_resized)
        )
        (and (not @skip_redraw) (or (== redraw TRUE) (and (non-zero? @msg_scrolled) (!= redraw -1))))
        (ยง
            (starttermcap)             ;; start termcap before redrawing
            (redraw_later VALID)
        ))
    ))

;; Write the hit-return prompt.

(defn- #_void hit_return_msg []
    (ยง
        ((ร boolean save_p_more =) @p_more)

        (reset! p_more false)             ;; don't want see this message when scrolling back
        (if @msg_didout             ;; start on a new line
            (msg_putchar (byte \newline)))
        (if @got_int
            (msg_puts (u8 "Interrupt: ")))

        (msg_puts_attr (u8 "Press ENTER or type command to continue"), (hl_attr HLF_R))
        (if (not (msg_use_printf))
            (msg_clr_eos))
        (reset! p_more save_p_more)
    ))

;; Set "keep_msg" to "s".  Free the old value and check for null pointer.

(defn- #_void set_keep_msg [#_Bytes s, #_int attr]
    (ยง
        (if (non-nil? s)
            (reset! keep_msg (STRDUP s))
            (reset! keep_msg null))
        (reset! keep_msg_more false)
        (reset! keep_msg_attr attr)
    ))

;; Prepare for outputting characters in the command line.

(defn- #_void msg_start []
    (ยง
        ((ร boolean did_return =) false)

        (reset! keep_msg null)                    ;; don't display old message now

        (when @need_clr_eos
            ;; Halfway an ":echo" command and getting an (error) message:
            ;; clear any text from the command.
            (reset! need_clr_eos false)
            (msg_clr_eos)
        )

        (cond (and (not @msg_scroll) @full_screen)         ;; overwrite last message
        (ยง
            (reset! msg_row @cmdline_row)
            (reset! msg_col 0)
        )
        @msg_didout                    ;; start message on next line
        (ยง
            (msg_putchar (byte \newline))
            ((ร did_return =) true)
            (reset! cmdline_row @msg_row)
        ))

        (if (or (not @msg_didany) (< @lines_left 0))
            (msg_starthere))

        (reset! msg_didout false)                 ;; no output on current line yet
        (cursor_off)
    ))

;; Note that the current msg position is where messages start.

(defn- #_void msg_starthere []
    (ยง
        (reset! lines_left @cmdline_row)
        (reset! msg_didany false)
    ))

(defn- #_void msg_putchar [#_int c]
    (msg_putchar_attr c, 0))

(defn- #_void msg_putchar_attr [#_int c, #_int attr]
    (ยง
        ((ร Bytes buf =) (ยง new Bytes(MB_MAXBYTES + 1)))

        (cond (is_special c)
        (ยง
            (.be buf 0, KB_SPECIAL)
            (.be buf 1, (KB_SECOND c))
            (.be buf 2, (KB_THIRD c))
            (.be buf 3, NUL)
        )
        :else
        (ยง
            (ยง buf.be(utf_char2bytes(c, buf), NUL))
        ))
        (msg_puts_attr buf, attr)
    ))

;; Output 'len' characters in 'p' (including NULs) with translation
;; if 'len' is -1, output upto a NUL character.
;; Use attributes 'attr'.
;; Return the number of characters it takes on the screen.

(defn- #_int msg_outtrans [#_Bytes p]
    (msg_outtrans_attr p, 0))

(defn- #_int msg_outtrans_attr [#_Bytes p, #_int attr]
    (msg_outtrans_len_attr p, (STRLEN p), attr))

(defn- #_int msg_outtrans_len [#_Bytes p, #_int len]
    (msg_outtrans_len_attr p, len, 0))

(defn- #_int msg_outtrans_len_attr [#_Bytes p, #_int len, #_int attr]
    (ยง
        ((ร int cells =) 0)

        ;; If the string starts with a composing character,
        ;; first draw a space on which the composing char can be drawn.
        (if (utf_iscomposing (us_ptr2char p))
            (msg_puts_attr (u8 " "), attr))

        ((ร Bytes q =) p)

        ;; Go over the string.  Special characters are translated and printed.
        ;; Normal characters are printed several at a time.

        (while (ยง 0 <= --len)
            ;; Don't include composing chars after the end.
            ((ร int l =) (ยง us_ptr2len_cc_len(p, len + 1)))
            (cond (< 1 l)
            (ยง
                ((ร int c =) (us_ptr2char p))
                (cond (vim_isprintc c)
                (ยง
                    ;; printable multi-byte char: count the cells.
                    ((ร cells +=) (us_ptr2cells p))
                )
                :else
                (ยง
                    ;; unprintable multi-byte char: print the printable chars
                    ;; so far and the translation of the unprintable char
                    (if (BLT q, p)
                        (msg_puts_attr_len q, (BDIFF p, q), attr))
                    ((ร q =) (ยง p.plus(l)))
                    (msg_puts_attr (transchar c), (if (zero? attr) (hl_attr HLF_8) attr))
                    ((ร cells +=) (mb_char2cells c))
                ))
                ((ร len -=) (- l 1))
                ((ร p =) (ยง p.plus(l)))
            )
            :else
            (ยง
                ((ร Bytes s =) (ยง transchar_byte(p.at(0))))
                (cond (non-eos? s 1)
                (ยง
                    ;; unprintable char: print the printable chars so far
                    ;; and the translation of the unprintable char
                    (if (BLT q, p)
                        (msg_puts_attr_len q, (BDIFF p, q), attr))
                    ((ร q =) (ยง p.plus(1)))
                    (msg_puts_attr s, (if (zero? attr) (hl_attr HLF_8) attr))
                    ((ร cells +=) (STRLEN s))
                )
                :else
                (ยง
                    (ยง cells++)
                ))
                ((ร p =) (ยง p.plus(1)))
            ))
        )

        (when (BLT q, p)
            ;; print the printable chars at the end
            (msg_puts_attr_len q, (BDIFF p, q), attr)
        )

        cells
    ))

;; Use screen_puts() to output one multi-byte character.
;; Return the pointer "s" advanced to the next character.

(defn- #_Bytes screen_puts_mbyte [#_Bytes s, #_int len, #_int attr]
    (ยง
        (reset! msg_didout true)          ;; remember that line is not empty

        ((ร int cells =) (us_ptr2cells s))
        (when (and (< 1 cells) (== @msg_col (- (int @Columns) 1)))
            ;; Doesn't fit, print a highlighted '>' to fill it up.
            (msg_screen_putchar (byte \>), (hl_attr HLF_AT))
            ((ร RETURN) s)
        )

        (screen_puts_len s, len, @msg_row, @msg_col, attr)

        ((ร @msg_col +=) cells)
        (when (<= (int @Columns) @msg_col)
            (reset! msg_col 0)
            (swap! msg_row inc)
        )

        (.plus s len)
    ))

;; Output a string to the screen at position msg_row, msg_col.
;; Update msg_row and msg_col for the next message.

(defn- #_void msg_puts [#_Bytes s]
    (msg_puts_attr s, 0))

(defn- #_void msg_puts_title [#_Bytes s]
    (msg_puts_attr s, (hl_attr HLF_T)))

;; Basic function for writing a message with highlight attributes.

(defn- #_void msg_puts_attr [#_Bytes s, #_int attr]
    (msg_puts_attr_len s, -1, attr))

;; Like msg_puts_attr(), but with a maximum length "maxlen" (in bytes).
;; When "maxlen" is -1 there is no maximum length.
;; When "maxlen" is >= 0 the message is not put in the history.

(defn- #_void msg_puts_attr_len [#_Bytes str, #_int maxlen, #_int attr]
    (ยง
        ;; When writing something to the screen after it has scrolled, requires
        ;; a wait-return prompt later.  Needed when scrolling, resetting need_wait_return
        ;; after some prompt, and then outputting something without scrolling

        (if (and (non-zero? @msg_scrolled) (not @msg_scrolled_ign))
            (reset! need_wait_return true))
        (reset! msg_didany true)          ;; remember that something was outputted

        ;; If there is no valid screen, use fprintf so we can see error messages.
        ;; If termcap is not active, we may be writing in an alternate console window,
        ;; cursor positioning may not work correctly (window size may be different,
        ;; e.g. for Win32 console) or we just don't know where the cursor is.

        (if (msg_use_printf)
            (msg_puts_printf str, maxlen)
            (msg_puts_display str, maxlen, attr, false))
    ))

;; The display part of msg_puts_attr_len().
;; May be called recursively to display scroll-back text.

(defn- #_void msg_puts_display [#_Bytes str, #_int maxlen, #_int attr, #_boolean recurse]
    (ยง
        ((ร Bytes s =) str)
        ((ร Bytes t_s =) str)       ;; string from "t_s" to "s" is still todo
        ((ร int t_col =) 0)          ;; screen cells todo, 0 when "t_s" not used
; %%    ((ร Bytes[] sb_str =) (ยง { str }))
; %%    ((ร int[] sb_col =) (ยง { @msg_col }))

        (reset! did_wait_return false)
        (while (ยง (maxlen < 0 || BDIFF(s, str) < maxlen) && s.at(0) != NUL)
            ;; We are at the end of the screen line when:
            ;; - When outputting a newline.
            ;; - When outputting a character in the last column.

            (when (and (not recurse) (<= (- @Rows 1) @msg_row) (or (== (.at s 0) (byte \newline)) (<= (- (int @Columns) 1) (+ @msg_col t_col)) (and (== (.at s 0) TAB) (<= (& (- (int @Columns) 1) (ยง ~7)) (+ @msg_col t_col))) (and (< 1 (us_ptr2cells s)) (<= (- (int @Columns) 2) (+ @msg_col t_col)))))
                ;; The screen is scrolled up when at the last row (some terminals scroll
                ;; automatically, some don't.  To avoid problems we scroll ourselves).

                (when (< 0 t_col)
                    ;; output postponed text
                    ((ร t_col =) (t_puts t_col, t_s, s, attr))
                )

                ;; When no more prompt and no more room, truncate here.
                (if (and @msg_no_more (zero? @lines_left))
                    (ร BREAK)
                )

                ;; Scroll the screen up one line.
                (msg_scroll_up)

                (reset! msg_row (- (int @Rows) 2))
                (if (<= (int @Columns) @msg_col)     ;; can happen after screen resize
                    (reset! msg_col (- (int @Columns) 1)))

                (ร boolean did_last_char)

                ;; Display char in last column before showing more-prompt.
                (cond (<= (byte \space) (.at s 0))
                (ยง
                    (ร int len)
                    (cond (<= 0 maxlen)
                    (ยง
                        ;; avoid including composing chars after the end
                        ((ร len =) (ยง us_ptr2len_cc_len(s, BDIFF(str.plus(maxlen), s))))
                    )
                    :else
                    (ยง
                        ((ร len =) (us_ptr2len_cc s))
                    ))
                    ((ร s =) (screen_puts_mbyte s, len, attr))

                    ((ร did_last_char =) true)
                )
                :else
                (ยง
                    ((ร did_last_char =) false)
                ))

                (when @p_more
                    ;; store text for scrolling back
                    (store_sb_text sb_str, s, attr, sb_col, true)
                )

                (inc_msg_scrolled)
                (reset! need_wait_return true)    ;; may need wait_return in main()
                (if (< @must_redraw VALID)
                    (reset! must_redraw VALID))
                (reset! redraw_cmdline true)
                (if (< 0 @cmdline_row)
                    (swap! cmdline_row dec))

                ;; If screen is completely filled and 'more' is set then wait for a character.

                (if (< 0 @lines_left)
                    (swap! lines_left dec))
                (when (and @p_more (zero? @lines_left) (!= @State HITRETURN) (not @msg_no_more))
                    (if (do_more_prompt NUL)
                        ((ร s =) @confirm_msg_tail)
                    )
                    (if @quit_more
                        (ร RETURN)
                    )
                )

                ;; When we displayed a char in last column need to check if there is still more.
                (if did_last_char
                    (ร CONTINUE)
                )
            )

            ((ร boolean wrap =) (ยง (s.at(0) == (byte \newline)) || (int)@Columns <= @msg_col + t_col || (1 < us_ptr2cells(s) && (int)@Columns - 1 <= @msg_col + t_col)))

            (when (and (< 0 t_col) (or wrap (== (.at s 0) (byte \return)) (== (.at s 0) (byte \backspace)) (== (.at s 0) (byte \tab)) (== (.at s 0) BELL)))
                ;; output any postponed text
                ((ร t_col =) (t_puts t_col, t_s, s, attr))
            )

            (when (and wrap @p_more (not recurse))
                ;; store text for scrolling back
                (store_sb_text sb_str, s, attr, sb_col, true)
            )

            (cond (== (.at s 0) (byte \newline))                 ;; go to next line
            (ยง
                (reset! msg_didout false)         ;; remember that line is empty
                (reset! msg_col 0)
                (if (<= @Rows (ยง ++@msg_row))      ;; safety check
                    (reset! msg_row (- (int @Rows) 1)))
            )
            (== (.at s 0) (byte \return))            ;; go to column 0
            (ยง
                (reset! msg_col 0)
            )
            (== (.at s 0) (byte \backspace))            ;; go to previous char
            (ยง
                (if (< 0 @msg_col)
                    (swap! msg_col dec))
            )
            (== (.at s 0) TAB)                    ;; translate Tab into spaces
            (ยง
;               do
;               {
                    (msg_screen_putchar (byte \space), attr)
;               } while ((@msg_col & 7) != 0);
            )
            (== (.at s 0) BELL)                   ;; beep (from ":sh")
            (ยง
                (vim_beep)
            )
            :else
            (ยง
                ((ร int cells =) (us_ptr2cells s))

                (ร int len)
                (cond (<= 0 maxlen)
                (ยง
                    ;; avoid including composing chars after the end
                    ((ร len =) (ยง us_ptr2len_cc_len(s, BDIFF(str.plus(maxlen), s))))
                )
                :else
                (ยง
                    ((ร len =) (us_ptr2len_cc s))
                ))

                ;; When a double-wide character doesn't fit, draw a single character here.
                ;; Otherwise collect characters and draw them all at once later.
                (cond (and (< 1 cells) (<= (- (int @Columns) 1) (+ @msg_col t_col)))
                (ยง
                    (if (< 1 len)
                        ((ร s =) (ยง screen_puts_mbyte(s, len, attr).minus(1)))
                        (msg_screen_putchar (.at s 0), attr))
                )
                :else
                (ยง
                    ;; postpone this character until later
                    (if (zero? t_col)
                        ((ร t_s =) s)
                    )
                    ((ร t_col +=) cells)
                    ((ร s =) (ยง s.plus(len - 1)))
                ))
            ))
            ((ร s =) (ยง s.plus(1)))
        )

        ;; output any postponed text
        (if (< 0 t_col)
            ((ร t_col =) (t_puts t_col, t_s, s, attr))
        )
        (if (and @p_more (not recurse))
            (store_sb_text sb_str, s, attr, sb_col, false))

        (msg_check)
    ))

;; Scroll the screen up one line for displaying the next message line.

(defn- #_void msg_scroll_up []
    (ยง
        ;; scrolling up always works
        (screen_del_lines 0, 0, 1, (int @Rows), true, null)

        (when (not (can_clear (u8 " ")))
            ;; Scrolling up doesn't result in the right background.
            ;; Set the background here.  It's not efficient,
            ;; but avoids that we have to do it all over the code.
            (screen_fill (- (int @Rows) 1), (int @Rows), 0, (int @Columns), (byte \space), (byte \space), 0)

            ;; Also clear the last char of the last but one line
            ;; if it was not cleared before to avoid a scroll-up.
            (if (ยง @screenAttrs[@lineOffset[(int)@Rows - 2] + (int)@Columns - 1] == -1)
                (screen_fill (- (int @Rows) 2), (- (int @Rows) 1), (- (int @Columns) 1), (int @Columns), (byte \space), (byte \space), 0))
        )
    ))

;; Increment "msg_scrolled".

(defn- #_void inc_msg_scrolled []
    (swap! msg_scrolled inc))

;; To be able to scroll back at the "more" and "hit-enter" prompts we need to
;; store the displayed text and remember where screen lines start.

(class! #_final msgchunk_C
    [
        (field msgchunk_C   sb_next)
        (field msgchunk_C   sb_prev)
        (field boolean      sb_eol)         ;; true when line ends after this text
        (field int          sb_msg_col)     ;; column in which text starts
        (field int          sb_attr)        ;; text attributes
        (field Bytes        sb_text)        ;; text to be displayed, actually longer
    ])

(atom! msgchunk_C last_msgchunk)    ;; last displayed text

(atom! boolean do_clear_sb_text)    ;; clear text on next msg

;; Store part of a printed message for displaying when scrolling back.

(defn- #_void store_sb_text [#_Bytes* sb_str, #_Bytes s, #_int attr, #_int* sb_col, #_boolean finish]
    ;; sb_str: start of string
    ;; s: just after string
    ;; finish: line ends
    (ยง
        (when @do_clear_sb_text
            (clear_sb_text)
            (reset! do_clear_sb_text false)
        )

        (cond (BLT (ยง sb_str[0]), s)
        (ยง
            ((ร msgchunk_C mp =) (ยง ยง_msgchunk_C()))

            ((ร mp.sb_eol =) finish)
            ((ร mp.sb_msg_col =) (ยง sb_col[0]))
            ((ร mp.sb_attr =) attr)
            ((ร mp.sb_text =) (ยง STRNDUP(sb_str[0], BDIFF(s, sb_str[0]))))

            (cond (nil? @last_msgchunk)
            (ยง
                (reset! last_msgchunk mp)
                ((ร mp.sb_prev =) null)
            )
            :else
            (ยง
                ((ร mp.sb_prev =) @last_msgchunk)
                ((ร @last_msgchunk.sb_next =) mp)
                (reset! last_msgchunk mp)
            ))
            ((ร mp.sb_next =) null)
        )
        (and finish (non-nil? @last_msgchunk))
        (ยง
            ((ร @last_msgchunk.sb_eol =) true)
        ))

        ((ร sb_str[0] =) s)
        ((ร sb_col[0] =) 0)
    ))

;; Finished showing messages, clear the scroll-back text on the next message.

(defn- #_void may_clear_sb_text []
    (reset! do_clear_sb_text true))

;; Clear any text remembered for scrolling back.
;; Called when redrawing the screen.

(defn- #_void clear_sb_text []
    (reset! last_msgchunk null))

;; "g<" command.

(defn- #_void show_sb_text []
    (ยง
        ;; Only show something if there is more than one line, otherwise it looks weird,
        ;; typing a command without output results in one line.
        ((ร msgchunk_C mp =) (msg_sb_start @last_msgchunk))
        (cond (or (nil? mp) (nil? (. mp sb_prev)))
        (ยง
            (vim_beep)
        )
        :else
        (ยง
            (do_more_prompt (byte \G))
            (wait_return FALSE)
        ))
    ))

;; Move to the start of screen line in already displayed text.

(defn- #_msgchunk_C msg_sb_start [#_msgchunk_C mps]
    (ยง
        ((ร msgchunk_C mp =) mps)

        (while (ยง mp != null && mp.sb_prev != null && !mp.sb_prev.sb_eol)
            ((ร mp =) (. mp sb_prev))
        )

        mp
    ))

;; Display a screen line from previously displayed text at row "row".
;; Returns a pointer to the text for the next line (can be null).

(defn- #_msgchunk_C disp_sb_line [#_int row, #_msgchunk_C smp]
    (ยง
        ((ร msgchunk_C mp =) smp)

        (while true
            (reset! msg_row row)
            (reset! msg_col (. mp sb_msg_col))
            ((ร Bytes p =) (. mp sb_text))
            (if (== (.at p 0) (byte \newline))             ;; don't display the line break
                ((ร p =) (ยง p.plus(1)))
            )
            (msg_puts_display p, -1, (. mp sb_attr), true)
            (if (or (. mp sb_eol) (nil? (. mp sb_next)))
                (ร BREAK)
            )
            ((ร mp =) (. mp sb_next))
        )

        (. mp sb_next)
    ))

;; Output any postponed text for msg_puts_attr_len().

(defn- #_int t_puts [#_int t_col, #_Bytes t_s, #_Bytes s, #_int attr]
    (ยง
        ;; output postponed text
        (reset! msg_didout true)          ;; remember that line is not empty
        (screen_puts_len t_s, (BDIFF s, t_s), @msg_row, @msg_col, attr)
        ((ร @msg_col +=) t_col)
        ((ร t_col =) 0)
        ;; If the string starts with a composing character,
        ;; don't increment the column position for it.
        (if (utf_iscomposing (us_ptr2char t_s))
            (swap! msg_col dec))
        (when (<= (int @Columns) @msg_col)
            (reset! msg_col 0)
            (swap! msg_row inc)
        )
        t_col
    ))

;; Returns true when messages should be printed with mch_errmsg().
;; This is used when there is no valid screen, so we can see error messages.
;; If termcap is not active, we may be writing in an alternate console window,
;; cursor positioning may not work correctly (window size may be different)
;; or we just don't know where the cursor is.

(defn- #_boolean msg_use_printf []
    (or (not (msg_check_screen)) (and (swapping_screen) (not @termcap_active))))

;; Print a message when there is no valid screen.

(defn- #_void msg_puts_printf [#_Bytes str, #_int maxlen]
    (ยง
        ((ร FOR) (ร (ยง Bytes s = str) (ยง s.at(0) != NUL && (maxlen < 0 || BDIFF(s, str) < maxlen)) (ยง s = s.plus(1)))
            ((ร Bytes buf =) (ยง new Bytes(4)))
            ((ร Bytes p =) buf)

            ;; NL --> CR NL translation (for Unix, not for "--version")
            (if (and (== (.at s 0) (byte \newline)) (not @info_message))
                (ยง (p = p.plus(1)).be(-1, (byte \return)))
            )
            (ยง (p = p.plus(1)).be(-1, s.at(0)))
            (.be p 0, NUL)
            (if @info_message   ;; informative message, not an error
                (ยง libC.fprintf(stdout, (u8 "%s"), buf))
                (ยง libC.fprintf(stderr, (u8 "%s"), buf))
            )

            ;; primitive way to compute the current column
            (if (or (== (.at s 0) (byte \return)) (== (.at s 0) (byte \newline)))
                (reset! msg_col 0)
                (swap! msg_col inc))
        )

        (reset! msg_didout true)      ;; assume that line is not empty
    ))

;; Show the more-prompt and handle the user response.
;; This takes care of scrolling back and displaying previously displayed text.
;; When at hit-enter prompt "typed_char" is the already typed character,
;; otherwise it's NUL.
;; Returns true when jumping ahead to "confirm_msg_tail".

(defn- #_boolean do_more_prompt [#_int typed_char]
    (ยง
        ((ร boolean retval =) false)

        ((ร int used_typed_char =) typed_char)
        ((ร int oldState =) @State)

        ((ร msgchunk_C mp_last =) null)
        (when (== typed_char (byte \G))
            ;; "g<": Find first line on the last page.
            ((ร mp_last =) (msg_sb_start @last_msgchunk))
            ((ร FOR) (ร (ยง int i = 0) (ยง i < @Rows - 2 && mp_last != null && mp_last.sb_prev != null) (ยง i++))
                ((ร mp_last =) (ยง msg_sb_start(mp_last.sb_prev)))
            )
        )

        (reset! State ASKMORE)
        (if (== typed_char NUL)
            (msg_moremsg false))

        (while true
            (ร int c)

            ;; Get a typed character directly from the user.

            (cond (!= used_typed_char NUL)
            (ยง
                ((ร c =) used_typed_char)        ;; was typed at hit-enter prompt
                ((ร used_typed_char =) NUL)
            )
            :else
            (ยง
                ((ร c =) (get_keystroke))
            ))

            ((ร int toscroll =) 0)
            ((ร SWITCH) c
                ((ร CASE) BS)                    ;; scroll one line back
                ((ร CASE) K_BS)
                ((ร CASE) (byte \k))
                ((ร CASE) K_UP)
                (ยง
                    ((ร toscroll =) -1)
                    (ร BREAK)
                )

                ((ร CASE) CAR)                   ;; one extra line
                ((ร CASE) NL)
                ((ร CASE) (byte \j))
                ((ร CASE) K_DOWN)
                (ยง
                    ((ร toscroll =) 1)
                    (ร BREAK)
                )

                ((ร CASE) (byte \u))                   ;; up half a page
                (ยง
                    ((ร toscroll =) (ยง -((int)@Rows / 2)))
                    (ร BREAK)
                )

                ((ร CASE) (byte \d))                   ;; down half a page
                (ยง
                    ((ร toscroll =) (ยง (int)@Rows / 2))
                    (ร BREAK)
                )

                ((ร CASE) (byte \b))                   ;; one page back
                ((ร CASE) K_PAGEUP)
                (ยง
                    ((ร toscroll =) (ยง -((int)@Rows - 1)))
                    (ร BREAK)
                )

                ((ร CASE) (byte \space))                   ;; one extra page
                ((ร CASE) (byte \f))
                ((ร CASE) K_PAGEDOWN)
                (ยง
                    ((ร toscroll =) (ยง (int)@Rows - 1))
                    (ร BREAK)
                )

                ((ร CASE) (byte \g))                   ;; all the way back to the start
                (ยง
                    ((ร toscroll =) -999999)
                    (ร BREAK)
                )

                ((ร CASE) (byte \G))                   ;; all the way to the end
                (ยง
                    ((ร toscroll =) 999999)
                    (reset! lines_left 999999)
                    (ร BREAK)
                )

                ((ร CASE) (byte \:))                   ;; start new command line
                (ยง
                    (when (zero? @confirm_msg_used)
                        ;; Since got_int is set all typeahead will be flushed, but we
                        ;; want to keep this ':', remember that in a special way.
                        (typeahead_noflush (byte \:))
                        (reset! cmdline_row (- (int @Rows) 1))         ;; put ':' on this line
                        (reset! skip_redraw true)             ;; skip redraw once
                        (reset! need_wait_return false)       ;; don't wait in main()
                    )
                    (ร FALLTHROUGH)
                )
                ((ร CASE) (byte \q))                   ;; quit
                ((ร CASE) Ctrl_C)
                ((ร CASE) ESC)
                (ยง
                    (cond (non-zero? @confirm_msg_used)
                    (ยง
                        ;; Jump to the choices of the dialog.
                        ((ร retval =) true)
                    )
                    :else
                    (ยง
                        (reset! got_int true)
                        (reset! quit_more true)
                    ))
                    ;; When there is some more output (wrapping line)
                    ;; display that without another prompt.
                    (reset! lines_left (- (int @Rows) 1))
                    (ร BREAK)
                )

                ((ร CASE) Ctrl_Y)
                (ยง
                    ;; Strange way to allow copying (yanking) a modeless
                    ;; selection at the more prompt.  Use CTRL-Y,
                    ;; because the same is used in Cmdline-mode and at the
                    ;; hit-enter prompt.  However, scrolling one line up
                    ;; might be expected...
;                   
                    (ร CONTINUE)
                )

                (ร DEFAULT)                    ;; no valid response
                (ยง
                    (msg_moremsg true)
                    (ร CONTINUE)
                )
            )

            (when (non-zero? toscroll)
                (cond (< toscroll 0)
                (ยง
                    (ร msgchunk_C mp)
                    ;; go to start of last line
                    (cond (nil? mp_last)
                    (ยง
                        ((ร mp =) (msg_sb_start @last_msgchunk))
                    )
                    (!= (. mp_last sb_prev) null)
                    (ยง
                        ((ร mp =) (ยง msg_sb_start(mp_last.sb_prev)))
                    )
                    :else
                    (ยง
                        ((ร mp =) null)
                    ))

                    ;; go to start of line at top of the screen
                    ((ร FOR) (ร (ยง int i = 0) (ยง i < @Rows - 2 && mp != null && mp.sb_prev != null) (ยง i++))
                        ((ร mp =) (ยง msg_sb_start(mp.sb_prev)))
                    )

                    (when (and (non-nil? mp) (!= (. mp sb_prev) null))
                        ;; Find line to be displayed at top.
                        ((ร FOR) (ร (ยง int i = 0) (< toscroll i) (ยง --i))
                            (if (or (nil? mp) (nil? (. mp sb_prev)))
                                (ร BREAK)
                            )
                            ((ร mp =) (ยง msg_sb_start(mp.sb_prev)))
                            (if (nil? mp_last)
                                ((ร mp_last =) (msg_sb_start @last_msgchunk))
                                ((ร mp_last =) (ยง msg_sb_start(mp_last.sb_prev)))
                            )
                        )

                        (cond (and (== toscroll -1) (screen_ins_lines 0, 0, 1, (int @Rows), null))
                        (ยง
                            ;; display line at top
                            (disp_sb_line 0, mp)
                        )
                        :else
                        (ยง
                            ;; redisplay all lines
                            (screenclear)
                            ((ร FOR) (ร (ยง int i = 0) (ยง mp != null && i < @Rows - 1) (ยง i++))
                                ((ร mp =) (disp_sb_line i, mp))
                                (swap! msg_scrolled inc)
                            )
                        ))
                        ((ร toscroll =) 0)
                    )
                )
                :else
                (ยง
                    ;; First display any text that we scrolled back.
                    (while (ยง 0 < toscroll && mp_last != null)
                        ;; scroll up, display line at bottom
                        (msg_scroll_up)
                        (inc_msg_scrolled)
                        (screen_fill (- (int @Rows) 2), (- (int @Rows) 1), 0, (int @Columns), (byte \space), (byte \space), 0)
                        ((ร mp_last =) (ยง disp_sb_line((int)@Rows - 2, mp_last)))
                        (ยง --toscroll)
                    )
                ))

                (when (<= toscroll 0)
                    ;; displayed the requested text, more prompt again
                    (screen_fill (- (int @Rows) 1), (int @Rows), 0, (int @Columns), (byte \space), (byte \space), 0)
                    (msg_moremsg false)
                    (ร CONTINUE)
                )

                ;; display more text, return to caller
                (reset! lines_left toscroll)
            )

            (ร BREAK)
        )

        ;; clear the --more-- message
        (screen_fill (- (int @Rows) 1), (int @Rows), 0, (int @Columns), (byte \space), (byte \space), 0)
        (reset! State oldState)

        (when @quit_more
            (reset! msg_row (- (int @Rows) 1))
            (reset! msg_col 0)
        )

        retval
    ))

;; Put a character on the screen at the current message position and advance
;; to the next position.  Only for printable ASCII!

(defn- #_void msg_screen_putchar [#_int c, #_int attr]
    (ยง
        (reset! msg_didout true)          ;; remember that line is not empty

        (screen_putchar c, @msg_row, @msg_col, attr)

        (when (<= (int @Columns) (ยง ++@msg_col))
            (reset! msg_col 0)
            (swap! msg_row inc)
        )
    ))

(defn- #_void msg_moremsg [#_boolean full]
    (ยง
        ((ร Bytes s =) (u8 "-- More --"))

        ((ร int attr =) (hl_attr HLF_M))
        (screen_puts s, (- (int @Rows) 1), 0, attr)
        (when full
            (screen_puts (u8 " SPACE/d/j: screen/page/line down, b/u/k: up, q: quit "), (- (int @Rows) 1), (mb_string2cells s, -1), attr)
        )
    ))

;; Repeat the message for the current mode: ASKMORE or CONFIRM.

(defn- #_void repeat_message []
    (ยง
        (cond (== @State ASKMORE)
        (ยง
            (msg_moremsg true)      ;; display --more-- message again
            (reset! msg_row (- (int @Rows) 1))
        )
        (== @State CONFIRM)
        (ยง
            (display_confirm_msg)  ;; display ":confirm" message again
            (reset! msg_row (- (int @Rows) 1))
        )
        (or (== @State HITRETURN) (== @State SETWSIZE))
        (ยง
            (when (== @msg_row (- (int @Rows) 1))
                ;; Avoid drawing the "hit-enter" prompt below the previous one,
                ;; overwrite it.  Esp. useful when regaining focus and a
                ;; FocusGained autocmd exists but didn't draw anything.
                (reset! msg_didout false)
                (reset! msg_col 0)
                (msg_clr_eos)
            )
            (hit_return_msg)
            (reset! msg_row (- (int @Rows) 1))
        ))
    ))

;; msg_check_screen - check if the screen is initialized.
;; Also check msg_row and msg_col, if they are too big it may cause a crash.
;; While starting the GUI the terminal codes will be set for the GUI, but the
;; output goes to the terminal.  Don't use the terminal codes then.

(defn- #_boolean msg_check_screen []
    (ยง
        (if (or (not @full_screen) (not (screen_valid false)))
            ((ร RETURN) false)
        )

        (if (<= (int @Rows) @msg_row)
            (reset! msg_row (- (int @Rows) 1)))
        (if (<= (int @Columns) @msg_col)
            (reset! msg_col (- (int @Columns) 1)))
        true
    ))

;; Clear from current message position to end of screen.
;; Skip this when ":silent" was used, no need to clear for redirection.

(defn- #_void msg_clr_eos []
    (msg_clr_eos_force))

;; Clear from current message position to end of screen.
;; Note: msg_col is not updated, so we remember the end of the message for msg_check().

(defn- #_void msg_clr_eos_force []
    (ยง
        (cond (msg_use_printf)
        (ยง
            (when @full_screen        ;; only when termcap codes are valid
                (cond (non-eos? @T_CD)
                (ยง
                    (out_str @T_CD)  ;; clear to end of display
                )
                (non-eos? @T_CE)
                (ยง
                    (out_str @T_CE)  ;; clear to end of line
                ))
            )
        )
        :else
        (ยง
            (screen_fill @msg_row, (+ @msg_row 1), @msg_col, (int @Columns), (byte \space), (byte \space), 0)
            (screen_fill (+ @msg_row 1), (int @Rows), 0, (int @Columns), (byte \space), (byte \space), 0)
        ))
    ))

;; Clear the command line.

(defn- #_void msg_clr_cmdline []
    (ยง
        (reset! msg_row @cmdline_row)
        (reset! msg_col 0)
        (msg_clr_eos_force)
    ))

;; end putting a message on the screen
;; call wait_return if the message does not fit in the available space
;; return true if wait_return not called.

(defn- #_boolean msg_end []
    (ยง
        ;; If the string is larger than the window,
        ;; or the ruler option is set and we run into it,
        ;; we have to redraw the window.
        ;; Do not do this if we are abandoning the file or editing the command line.

        (when (and (not @exiting) @need_wait_return (zero? (& @State CMDLINE)))
            (wait_return FALSE)
            ((ร RETURN) false)
        )
        (out_flush)
        true
    ))

;; If the written message runs into the shown command or ruler, we have to
;; wait for hit-return and redraw the window later.

(defn- #_void msg_check []
    (ยง
        (when (and (== @msg_row (- (int @Rows) 1)) (<= @sc_col @msg_col))
            (reset! need_wait_return true)
            (reset! redraw_cmdline true)
        )
    ))

;; Give a warning message (for searching).
;; Use 'w' highlighting and may repeat the message after redrawing

(defn- #_void give_warning [#_Bytes message, #_boolean hl]
    (ยง
        ;; Don't want a hit-enter prompt here.
        (swap! no_wait_return inc)

        (reset! keep_msg null)
        (if hl
            (reset! keep_msg_attr (hl_attr HLF_W))
            (reset! keep_msg_attr 0))
        (if (and (msg_attr message, @keep_msg_attr) (zero? @msg_scrolled))
            (set_keep_msg message, @keep_msg_attr))
        (reset! msg_didout false)     ;; overwrite this message
        (reset! msg_nowait true)      ;; don't wait for this message
        (reset! msg_col 0)

        (swap! no_wait_return dec)
    ))

;; Display the ":confirm" message.  Also called when screen resized.

(defn- #_void display_confirm_msg []
    (ยง
        ;; avoid that 'q' at the more prompt truncates the message here
        (swap! confirm_msg_used inc)
        (if (non-nil? @confirm_msg)
            (msg_puts_attr @confirm_msg, (hl_attr HLF_M)))
        (swap! confirm_msg_used dec)
    ))

;; Code to handle user-settable options.  This is all pretty much table-
;; driven.  Checklist for adding a new option:
;; - Put it in the options array below (copy an existing entry).
;; - For a global option: Add a variable for it in option.h.
;; - For a buffer or window local option:
;;   - Add a PV_XX entry to the enum below.
;;   - Add a variable to the window or buffer struct in structs.h.
;;   - For a window option, add some code to copy_winopt().
;;   - For a buffer string option, add code to check_buf_options().
;; - If it's a numeric option, add any necessary bounds checks to do_set().
;; - If it's a list of flags, add some code in do_set(), search for WW_ALL.
;; When making changes:
;; - When an entry has the P_VIM flag, or is lacking the P_VI_DEF flag,
;;   add a comment at the help for the 'compatible' option.

;; The options that are local to a window or buffer have "indir" set to
;; one of these values.  Special values:
;; 0: global option.
;; PV_WIN is added: window-local option.
;; PV_BUF is added: buffer-local option.

(final int
    PV_WIN  0x2000,
    PV_BUF  0x4000)

;; Definition of the PV_ values for buffer-local options.
;; The BV_ values are defined in option.h.

(final int
    PV_AI   (| BV_AI   PV_BUF),
    PV_CI   (| BV_CI   PV_BUF),
    PV_CINW (| BV_CINW PV_BUF),
    PV_ET   (| BV_ET   PV_BUF),
    PV_ISK  (| BV_ISK  PV_BUF),
    PV_KP   (| BV_KP   PV_BUF),
    PV_MOD  (| BV_MOD  PV_BUF),
    PV_MPS  (| BV_MPS  PV_BUF),
    PV_NF   (| BV_NF   PV_BUF),
    PV_PI   (| BV_PI   PV_BUF),
    PV_QE   (| BV_QE   PV_BUF),
    PV_SI   (| BV_SI   PV_BUF),
    PV_STS  (| BV_STS  PV_BUF),
    PV_SW   (| BV_SW   PV_BUF),
    PV_TS   (| BV_TS   PV_BUF),
    PV_UL   (| BV_UL   PV_BUF))

;; Definition of the PV_ values for window-local options.
;; The WV_ values are defined in option.h.

(final int
    PV_COCU   (| WV_COCU   PV_WIN),
    PV_COLE   (| WV_COLE   PV_WIN),
    PV_CRBIND (| WV_CRBIND PV_WIN),
    PV_BRI    (| WV_BRI    PV_WIN),
    PV_BRIOPT (| WV_BRIOPT PV_WIN),
    PV_LBR    (| WV_LBR    PV_WIN),
    PV_NU     (| WV_NU     PV_WIN),
    PV_RNU    (| WV_RNU    PV_WIN),
    PV_NUW    (| WV_NUW    PV_WIN),
    PV_SCBIND (| WV_SCBIND PV_WIN),
    PV_SCROLL (| WV_SCROLL PV_WIN),
    PV_CUC    (| WV_CUC    PV_WIN),
    PV_CUL    (| WV_CUL    PV_WIN),
    PV_CC     (| WV_CC     PV_WIN),
    PV_WFH    (| WV_WFH    PV_WIN),
    PV_WFW    (| WV_WFW    PV_WIN),
    PV_WRAP   (| WV_WRAP   PV_WIN))

(class! #_final vimoption_C
    [
        (field Bytes    fullname)   ;; full option name
        (field Bytes    shortname)  ;; permissible abbreviation
        (field long     flags)      ;; see below
        (field Object   var)        ;; pointer to variable
        (field int      indir)      ;; indirect option index
        (field Object   def_val)    ;; default value for variable
    ])

(defn- #_vimoption_C new_vimoption [#_Bytes fullname, #_Bytes shortname, #_long flags, #_Object var, #_int indir, #_Object def_val]
    (ยง
        ((ร vimoption_C v =) (ยง ยง_vimoption_C()))

        ((ร v.fullname =) fullname)
        ((ร v.shortname =) shortname)
        ((ร v.flags =) flags)
        ((ร v.var =) var)
        ((ร v.indir =) indir)
        ((ร v.def_val =) def_val)

        v
    ))

;; Flags

(final int P_BOOL               0x01)   ;; the option is boolean
(final int P_NUM                0x02)   ;; the option is numeric
(final int P_STRING             0x04)   ;; the option is a string

                                        ;; when option changed, what to display:
(final int P_RSTAT            0x1000)   ;; redraw status lines
(final int P_RWIN             0x2000)   ;; redraw current window
(final int P_RBUF             0x4000)   ;; redraw current buffer
(final int P_RALL             0x6000)   ;; redraw all windows
(final int P_RCLR             0x7000)   ;; clear and redraw all

(final int P_COMMA            0x8000)   ;; comma separated list
(final int P_NODUP           0x10000)   ;; don't allow duplicate strings
(final int P_FLAGLIST        0x20000)   ;; list of single-char flags

(final int P_CURSWANT      0x2000000)   ;; update curswant required; not needed when there is a redraw flag

(final Bytes HIGHLIGHT_INIT (u8 "8:SpecialKey,@:NonText,e:ErrorMsg,i:IncSearch,l:Search,m:MoreMsg,M:ModeMsg,n:LineNr,N:CursorLineNr,r:Question,s:StatusLine,S:StatusLineNC,c:VertSplit,t:Title,v:Visual,w:WarningMsg,-:Conceal,!:CursorColumn,.:CursorLine,o:ColorColumn"))

(defn- #_vimoption_C bool_opt [#_Bytes fname, #_Bytes sname, #_long flags, #_"/*boolean[]*/Object" var, #_int indir, #_boolean def]
    (ยง
        (new_vimoption fname, sname, (| P_BOOL flags), var, indir, def)
    ))

(defn- #_vimoption_C long_opt [#_Bytes fname, #_Bytes sname, #_long flags, #_"/*long[]*/Object" var, #_int indir, #_long def]
    (ยง
        (new_vimoption fname, sname, (| P_NUM flags), var, indir, def)
    ))

(defn- #_vimoption_C utf8_opt [#_Bytes fname, #_Bytes sname, #_long flags, #_"/*Bytes[]*/Object" var, #_int indir, #_Bytes def]
    (ยง
        (new_vimoption fname, sname, (| P_STRING flags), var, indir, def)
    ))

;; vimoptions[] are initialized here.
;;
;; The order of the options MUST be alphabetic for ":set all" and findoption().
;; All option names MUST start with a lowercase letter (for findoption()).

(final vimoption_C* vimoptions
    [
        (bool_opt (u8 "autoindent"),     (u8 "ai"),        0,                           null,        PV_AI,      false),
        (utf8_opt (u8 "backspace"),      (u8 "bs"),     (| P_COMMA P_NODUP),            p_bs,        0,         (u8 "")),
        (utf8_opt (u8 "breakat"),        (u8 "brk"),    (| P_RALL P_FLAGLIST),          p_breakat,   0,         (u8 " \t!@*-+;:,./?")),
        (bool_opt (u8 "breakindent"),    (u8 "bri"),       P_RWIN,                      null,        PV_BRI,     false),
        (utf8_opt (u8 "breakindentopt"), (u8 "briopt"), (| P_RBUF P_COMMA P_NODUP),     null,        PV_BRIOPT, (u8 "")),
        (utf8_opt (u8 "cinwords"),       (u8 "cinw"),   (| P_COMMA P_NODUP),            null,        PV_CINW,   (u8 "if,else,while,do,for,switch")),
        (long_opt (u8 "cmdheight"),      (u8 "ch"),        P_RALL,                      p_ch,        0,          1),
        (long_opt (u8 "cmdwinheight"),   (u8 "cwh"),       0,                           p_cwh,       0,          7),
        (utf8_opt (u8 "colorcolumn"),    (u8 "cc"),     (| P_COMMA P_NODUP P_RWIN),     null,        PV_CC,     (u8 "")),
        (utf8_opt (u8 "concealcursor"),  (u8 "cocu"),      P_RWIN,                      null,        PV_COCU,   (u8 "")),
        (long_opt (u8 "conceallevel"),   (u8 "cole"),      P_RWIN,                      null,        PV_COLE,    0),
        (bool_opt (u8 "copyindent"),     (u8 "ci"),        0,                           null,        PV_CI,      false),
        (utf8_opt (u8 "cpoptions"),      (u8 "cpo"),    (| P_RALL P_FLAGLIST),          p_cpo,       0,          CPO_VIM),
        (bool_opt (u8 "cursorbind"),     (u8 "crb"),       0,                           null,        PV_CRBIND,  false),
        (bool_opt (u8 "cursorcolumn"),   (u8 "cuc"),       P_RWIN,                      null,        PV_CUC,     false),
        (bool_opt (u8 "cursorline"),     (u8 "cul"),       P_RWIN,                      null,        PV_CUL,     false),
        (bool_opt (u8 "delcombine"),     (u8 "deco"),      0,                           p_deco,      0,          false),
        (bool_opt (u8 "digraph"),        (u8 "dg"),        0,                           p_dg,        0,          false),
        (utf8_opt (u8 "display"),        (u8 "dy"),     (| P_COMMA P_RALL P_NODUP),     p_dy,        0,         (u8 "")),
        (utf8_opt (u8 "eadirection"),    (u8 "ead"),       0,                           p_ead,       0,         (u8 "both")),
        (bool_opt (u8 "equalalways"),    (u8 "ea"),        P_RALL,                      p_ea,        0,          true),
        (bool_opt (u8 "errorbells"),     (u8 "eb"),        0,                           p_eb,        0,          false),
        (bool_opt (u8 "esckeys"),        (u8 "ek"),        0,                           p_ek,        0,          true),
        (bool_opt (u8 "expandtab"),      (u8 "et"),        0,                           null,        PV_ET,      false),
        (bool_opt (u8 "gdefault"),       (u8 "gd"),        0,                           p_gd,        0,          false),
        (utf8_opt (u8 "highlight"),      (u8 "hl"),     (| P_RCLR P_COMMA P_NODUP),     p_hl,        0,          HIGHLIGHT_INIT),
        (long_opt (u8 "history"),        (u8 "hi"),        0,                           p_hi,        0,          50),
        (bool_opt (u8 "hlsearch"),       (u8 "hls"),       P_RALL,                      p_hls,       0,          false),
        (bool_opt (u8 "ignorecase"),     (u8 "ic"),        0,                           p_ic,        0,          false),
        (bool_opt (u8 "incsearch"),      (u8 "is"),        0,                           p_is,        0,          false),
        (bool_opt (u8 "insertmode"),     (u8 "im"),        0,                           p_im,        0,          false),
        (utf8_opt (u8 "isfname"),        (u8 "isf"),    (| P_COMMA P_NODUP),            p_isf,       0,         (u8 "@,48-57,/,.,-,_,+,,,#,$,%,~,=")),
        (utf8_opt (u8 "isident"),        (u8 "isi"),    (| P_COMMA P_NODUP),            p_isi,       0,         (u8 "@,48-57,_,192-255")),
        (utf8_opt (u8 "iskeyword"),      (u8 "isk"),    (| P_COMMA P_NODUP),            null,        PV_ISK,    (u8 "@,48-57,_,192-255")),
        (utf8_opt (u8 "isprint"),        (u8 "isp"),    (| P_RALL P_COMMA P_NODUP),     p_isp,       0,         (u8 "@,161-255")),
        (bool_opt (u8 "joinspaces"),     (u8 "js"),        0,                           p_js,        0,          true),
        (utf8_opt (u8 "keymodel"),       (u8 "km"),     (| P_COMMA P_NODUP),            p_km,        0,         (u8 "")),
        (utf8_opt (u8 "keywordprg"),     (u8 "kp"),        0,                           null,        PV_KP,     (u8 ":echo")),
        (long_opt (u8 "laststatus"),     (u8 "ls"),        P_RALL,                      p_ls,        0,          1),
        (bool_opt (u8 "lazyredraw"),     (u8 "lz"),        0,                           p_lz,        0,          false),
        (bool_opt (u8 "linebreak"),      (u8 "lbr"),       P_RWIN,                      null,        PV_LBR,     false),
        (bool_opt (u8 "magic"),           null,            0,                           p_magic,     0,          true),
        (utf8_opt (u8 "matchpairs"),     (u8 "mps"),    (| P_COMMA P_NODUP),            null,        PV_MPS,    (u8 "(:),{:},[:]")),
        (long_opt (u8 "matchtime"),      (u8 "mat"),       0,                           p_mat,       0,          5),
        (long_opt (u8 "maxcombine"),     (u8 "mco"),       P_CURSWANT,                  p_mco,       0,          2),
        (long_opt (u8 "maxmempattern"),  (u8 "mmp"),       0,                           p_mmp,       0,          1000),
        (bool_opt (u8 "modified"),       (u8 "mod"),       P_RSTAT,                     null,        PV_MOD,     false),
        (bool_opt (u8 "more"),            null,            0,                           p_more,      0,          true),
        (utf8_opt (u8 "nrformats"),      (u8 "nf"),     (| P_COMMA P_NODUP),            null,        PV_NF,     (u8 "octal,hex")),
        (bool_opt (u8 "number"),         (u8 "nu"),        P_RWIN,                      null,        PV_NU,      false),
        (long_opt (u8 "numberwidth"),    (u8 "nuw"),       P_RWIN,                      null,        PV_NUW,     4),
        (utf8_opt (u8 "operatorfunc"),   (u8 "opfunc"),    0,                           p_opfunc,    0,         (u8 "")),
        (bool_opt (u8 "paste"),           null,            0,                           p_paste,     0,          false),
        (bool_opt (u8 "preserveindent"), (u8 "pi"),        0,                           null,        PV_PI,      false),
        (bool_opt (u8 "prompt"),          null,            0,                           p_prompt,    0,          true),
        (utf8_opt (u8 "quoteescape"),    (u8 "qe"),        0,                           null,        PV_QE,     (u8 "\\")),
        (long_opt (u8 "redrawtime"),     (u8 "rdt"),       0,                           p_rdt,       0,          2000),
        (long_opt (u8 "regexpengine"),   (u8 "re"),        0,                           p_re,        0,          0),
        (bool_opt (u8 "relativenumber"), (u8 "rnu"),       P_RWIN,                      null,        PV_RNU,     false),
        (long_opt (u8 "report"),          null,            0,                           p_report,    0,          2),
        (bool_opt (u8 "ruler"),          (u8 "ru"),        P_RSTAT,                     p_ru,        0,          false),
        (long_opt (u8 "scroll"),         (u8 "scr"),       0,                           null,        PV_SCROLL,  12),
        (bool_opt (u8 "scrollbind"),     (u8 "scb"),       0,                           null,        PV_SCBIND,  false),
        (long_opt (u8 "scrolljump"),     (u8 "sj"),        0,                           p_sj,        0,          1),
        (long_opt (u8 "scrolloff"),      (u8 "so"),        P_RALL,                      p_so,        0,          0),
        (utf8_opt (u8 "scrollopt"),      (u8 "sbo"),    (| P_COMMA P_NODUP),            p_sbo,       0,         (u8 "ver,jump")),
        (utf8_opt (u8 "selection"),      (u8 "sel"),       0,                           p_sel,       0,         (u8 "inclusive")),
        (utf8_opt (u8 "selectmode"),     (u8 "slm"),    (| P_COMMA P_NODUP),            p_slm,       0,         (u8 "")),
        (bool_opt (u8 "shiftround"),     (u8 "sr"),        0,                           p_sr,        0,          false),
        (long_opt (u8 "shiftwidth"),     (u8 "sw"),        0,                           null,        PV_SW,      8),
        (utf8_opt (u8 "showbreak"),      (u8 "sbr"),       P_RALL,                      p_sbr,       0,         (u8 "")),
        (bool_opt (u8 "showcmd"),        (u8 "sc"),        0,                           p_sc,        0,          false),
        (bool_opt (u8 "showmatch"),      (u8 "sm"),        0,                           p_sm,        0,          false),
        (bool_opt (u8 "showmode"),       (u8 "smd"),       0,                           p_smd,       0,          true),
        (long_opt (u8 "sidescroll"),     (u8 "ss"),        0,                           p_ss,        0,          0),
        (long_opt (u8 "sidescrolloff"),  (u8 "siso"),      P_RBUF,                      p_siso,      0,          0),
        (bool_opt (u8 "smartcase"),      (u8 "scs"),       0,                           p_scs,       0,          false),
        (bool_opt (u8 "smartindent"),    (u8 "si"),        0,                           null,        PV_SI,      false),
        (bool_opt (u8 "smarttab"),       (u8 "sta"),       0,                           p_sta,       0,          false),
        (long_opt (u8 "softtabstop"),    (u8 "sts"),       0,                           null,        PV_STS,     0),
        (bool_opt (u8 "splitbelow"),     (u8 "sb"),        0,                           p_sb,        0,          false),
        (bool_opt (u8 "splitright"),     (u8 "spr"),       0,                           p_spr,       0,          false),
        (bool_opt (u8 "startofline"),    (u8 "sol"),       0,                           p_sol,       0,          true),
        (long_opt (u8 "tabstop"),        (u8 "ts"),        P_RBUF,                      null,        PV_TS,      8),
        (bool_opt (u8 "tildeop"),        (u8 "top"),       0,                           p_to,        0,          false),
        (bool_opt (u8 "timeout"),        (u8 "to"),        0,                           p_timeout,   0,          true),
        (long_opt (u8 "timeoutlen"),     (u8 "tm"),        0,                           p_tm,        0,          1000),
        (bool_opt (u8 "ttimeout"),        null,            0,                           p_ttimeout,  0,          false),
        (long_opt (u8 "ttimeoutlen"),    (u8 "ttm"),       0,                           p_ttm,       0,          -1),
        (long_opt (u8 "ttyscroll"),      (u8 "tsl"),       0,                           p_ttyscroll, 0,          999),
        (long_opt (u8 "undolevels"),     (u8 "ul"),        0,                           null,        PV_UL,      1000),
        (long_opt (u8 "updatetime"),     (u8 "ut"),        0,                           p_ut,        0,          4000),
        (long_opt (u8 "verbose"),        (u8 "vbs"),       0,                           p_verbose,   0,          0),
        (utf8_opt (u8 "virtualedit"),    (u8 "ve"),     (| P_COMMA P_NODUP P_CURSWANT), p_ve,        0,         (u8 "")),
        (bool_opt (u8 "visualbell"),     (u8 "vb"),        0,                           p_vb,        0,          false),
        (utf8_opt (u8 "whichwrap"),      (u8 "ww"),     (| P_COMMA P_FLAGLIST),         p_ww,        0,         (u8 "b,s")),
        (long_opt (u8 "winheight"),      (u8 "wh"),        0,                           p_wh,        0,          1),
        (bool_opt (u8 "winfixheight"),   (u8 "wfh"),       P_RSTAT,                     null,        PV_WFH,     false),
        (bool_opt (u8 "winfixwidth"),    (u8 "wfw"),       P_RSTAT,                     null,        PV_WFW,     false),
        (long_opt (u8 "winminheight"),   (u8 "wmh"),       0,                           p_wmh,       0,          1),
        (long_opt (u8 "winminwidth"),    (u8 "wmw"),       0,                           p_wmw,       0,          1),
        (long_opt (u8 "winwidth"),       (u8 "wiw"),       0,                           p_wiw,       0,          20),
        (bool_opt (u8 "wrap"),            null,            P_RWIN,                      null,        PV_WRAP,    true),
        (bool_opt (u8 "wrapscan"),       (u8 "ws"),        0,                           p_ws,        0,          true),
        (long_opt (u8 "writedelay"),     (u8 "wd"),        0,                           p_wd,        0,          0),
    ])

(final Bytes*
    p_nf_values     [ (u8 "octal"), (u8 "hex"), (u8 "alpha"), null ],
    p_sel_values    [ (u8 "inclusive"), (u8 "exclusive"), (u8 "old"), null ],
    p_slm_values    [ (u8 "key"), (u8 "cmd"), null ],
    p_km_values     [ (u8 "startsel"), (u8 "stopsel"), null ],
    p_scbopt_values [ (u8 "ver"), (u8 "hor"), (u8 "jump"), null ],
    p_ead_values    [ (u8 "both"), (u8 "ver"), (u8 "hor"), null ],
    p_bs_values     [ (u8 "indent"), (u8 "eol"), (u8 "start"), null ])

;; Initialize the options, first part.
;;
;; Called only once from main(), just after creating the first buffer.

(defn- #_void set_init_1 []
    (ยง
        ;; Set all the options (except the terminal options) to their default value.
        ;; Also set the global value for local options.

        (set_options_default)

        (check_buf_options @curbuf)
        (check_win_options @curwin)
        (check_options)

        (didset_options)

        ;; initialize the table for 'breakat'.

        (fill_breakat_flags)

        ;; Initialize the highlight_attr[] table.
        (highlight_changed)

        ;; The cell width depends on the type of multi-byte characters.
        (init_chartab)

        ;; When enc_utf8 is set or reset, (de)allocate screenLinesUC[].
        (screenalloc false)
    ))

;; Set an option to its default value.
;; This does not take care of side effects!

(defn- #_void set_option_default [#_int opt_idx]
    (ยง
        ((ร vimoption_C v =) (ยง vimoptions[opt_idx]))

        ((ร Object varp =) (get_varp v))

        (cond (non-zero? (& (. v flags) P_STRING))
        (ยง
            (ยง (Bytes)@varp = STRDUP((Bytes)v.def_val))
        )
        (non-zero? (& (. v flags) P_NUM))
        (ยง
            (if (== (. v indir) PV_SCROLL)
                (win_comp_scroll @curwin)
                ((ร (long)@varp =) (ยง (long)v.def_val))
            )
        )
        (non-zero? (& (. v flags) P_BOOL))
        (ยง
            ((ร (boolean)@varp =) (ยง (boolean)v.def_val))
        ))
    ))

;; Set all options (except terminal options) to their default value.

(defn- #_void set_options_default []
    (ยง
        ((ร FOR) (ร (ยง int i = 0) (ยง i < vimoptions.length) (ยง i++))
            (set_option_default i)
        )

        ;; The 'scroll' option must be computed for all windows.
        ((ร FOR) (ร (ยง window_C wp = @firstwin) (!= wp null) (ยง wp = wp.w_next))
            (win_comp_scroll wp)
        )
    ))

;; Set the Vi-default value of a number option.
;; Used for 'lines' and 'columns'.

(defn- #_void set_number_default [#_Bytes name, #_long val]
    (ยง
        ((ร int opt_idx =) (findoption name))
        (when (<= 0 opt_idx)
            ((ร vimoptions[opt_idx].def_val =) val)
        )
    ))

;; Initialize the options, part two: After getting Rows and Columns and setting 'term'.

(defn- #_void set_init_2 []
    (ยง
        ;; 'scroll' defaults to half the window height.
        ;; Note that this default is wrong when the window height changes.

        (set_number_default (u8 "scroll"), (ยง @Rows >>> 1))
        (win_comp_scroll @curwin)
        (comp_col)
    ))

;; Parse 'arg' for option settings.
;;
;; returns false if an error is detected, true otherwise

(defn- #_boolean do_set [#_Bytes arg]
    ;; arg: option string (may be written to!)
    (ยง
        ((ร boolean did_show =) false)           ;; already showed one value

        ((ร Bytes errbuf =) (ยง new Bytes(80)))

        ((ร FOR) (ร (ยง  ) (ยง arg.at(0) != NUL) (ยง arg = skipwhite(arg)))             ;; loop to process all options
            ((ร Bytes errmsg =) null)
            ((ร Bytes startarg =) arg)      ;; remember for error message

            ((ร int prefix =) 1)     ;; 1: nothing, 0: "no", 2: "inv" in front of name
            (cond (and (zero? (STRNCMP arg, (u8 "no"), 2)) (non-zero? (STRNCMP arg, (u8 "novice"), 6)))
            (ยง
                ((ร prefix =) 0)
                ((ร arg =) (ยง arg.plus(2)))
            )
            (zero? (STRNCMP arg, (u8 "inv"), 3))
            (ยง
                ((ร prefix =) 2)
                ((ร arg =) (ยง arg.plus(3)))
            ))

;           skip:
;           {
                (when (== (.at arg 0) (byte \<))
                    ((ร errmsg =) e_invarg)
                    (ร BREAK skip)
                )

                (ร int nextchar)           ;; next non-white char after option name

                ;; find end of name
                ((ร int len =) 0)
                (while (ยง asc_isalnum(arg.at(len)) || arg.at(len) == (byte \_))
                    (ยง len++)
                )
                ((ร nextchar =) (ยง arg.at(len)))
                (.be arg len, NUL)                           ;; put NUL after name
                ((ร int opt_idx =) (findoption arg))
                (.be arg len, nextchar)                      ;; restore nextchar

                (when (== opt_idx -1)      ;; found a mismatch: skip
                    ((ร errmsg =) (u8 "E518: Unknown option"))
                    (ร BREAK skip)
                )

                ;; remember character after option name
                ((ร byte afterchar =) (ยง arg.at(len)))

                ;; skip white space, allow ":set ai  ?"
                (while (ยง vim_iswhite(arg.at(len)))
                    (ยง len++)
                )

                ((ร nextchar =) (ยง arg.at(len)))

                (when (and (!= nextchar NUL) (== (.at arg (+ len 1)) (byte \=)))
                    ((ร errmsg =) e_invarg)
                    (ร BREAK skip)
                )

                ((ร vimoption_C v =) (ยง vimoptions[opt_idx]))

                ((ร Object varp =) (get_varp v))

                (when (non-nil? (vim_strchr (u8 "?=:!&<"), nextchar))
                    ((ร arg =) (ยง arg.plus(len)))
                    (when (and (non-nil? (vim_strchr (u8 "?!&<"), nextchar)) (non-eos? arg 1) (not (vim_iswhite (ยง arg.at(1)))))
                        ((ร errmsg =) e_trailing)
                        (ร BREAK skip)
                    )
                )

                ;; allow '=' and ':' as MSDOS command.com allows
                ;; only one '=' character per "set" command line

                (cond (or (== nextchar (byte \?)) (and (== prefix 1) (nil? (vim_strchr (u8 "=:&<"), nextchar)) (zero? (& (. v flags) P_BOOL))))
                (ยง
                    ;; print value
                    (cond did_show
                    (ยง
                        (msg_putchar (byte \newline))      ;; cursor below last one
                    )
                    :else
                    (ยง
                        (gotocmdline true)      ;; cursor at status line
                        ((ร did_show =) true)        ;; remember that we did a line
                    ))

                    (showoneopt v)

                    (if (and (!= nextchar (byte \?)) (!= nextchar NUL) (not (vim_iswhite afterchar)))
                        ((ร errmsg =) e_trailing)
                    )
                )
                :else
                (ยง
                    (cond (non-zero? (& (. v flags) P_BOOL))          ;; boolean
                    (ยง
                        (when (or (== nextchar (byte \=)) (== nextchar (byte \:)) (== nextchar (byte \<)))
                            ((ร errmsg =) e_invarg)
                            (ร BREAK skip)
                        )

                        (ร boolean value)

                        ;; ":set opt!": invert
                        ;; ":set opt&": reset to default value

                        (cond (== nextchar (byte \!))
                        (ยง
                            ((ร value =) (ยง !(boolean)@varp))
                        )
                        (== nextchar (byte \&))
                        (ยง
                            ((ร value =) (ยง (boolean)v.def_val))
                        )
                        :else
                        (ยง
                            ;; ":set invopt": invert
                            ;; ":set opt" or ":set noopt": set or reset

                            (when (and (!= nextchar NUL) (not (vim_iswhite afterchar)))
                                ((ร errmsg =) e_trailing)
                                (ร BREAK skip)
                            )
                            (if (== prefix 2)            ;; inv
                                ((ร value =) (ยง !(boolean)@varp))
                                ((ร value =) (ยง (prefix != 0)))
                            )
                        ))

                        ((ร errmsg =) (ยง set_bool_option(opt_idx, (boolean[])varp, value)))
                    )
                    :else                                ;; numeric or string
                    (ยง
                        (when (or (nil? (vim_strchr (u8 "=:&"), nextchar)) (!= prefix 1))
                            ((ร errmsg =) e_invarg)
                            (ร BREAK skip)
                        )

                        (cond (non-zero? (& (. v flags) P_NUM))       ;; numeric
                        (ยง
                            (ร long value)

                            ;; Different ways to set a number option:
                            ;; &        set to default value
                            ;; <xx>     accept special key codes for 'wildchar'
                            ;; c        accept any non-digit for 'wildchar'
                            ;; [-]0-9   set number
                            ;; other    error

                            ((ร arg =) (ยง arg.plus(1)))
                            (cond (== nextchar (byte \&))
                            (ยง
                                ((ร value =) (ยง (long)v.def_val))
                            )
                            (or (== (.at arg 0) (byte \-)) (asc_isdigit (.at arg 0)))
                            (ยง
                                ((ร int[] ip =) (ยง new int[1]))

                                ;; Allow negative (for 'undolevels'), octal and hex numbers.
;                               { long[] __ = new long[1]; vim_str2nr(arg, null, ip, TRUE, TRUE, __); value = __[0]; }
                                (when (and (!= (.at arg (ยง ip[0])) NUL) (not (vim_iswhite (.at arg (ยง ip[0])))))
                                    ((ร errmsg =) e_invarg)
                                    (ร BREAK skip)
                                )
                            )
                            :else
                            (ยง
                                ((ร errmsg =) (u8 "E521: Number required after ="))
                                (ร BREAK skip)
                            ))

                            ((ร errmsg =) (ยง set_num_option(opt_idx, (long[])varp, value, errbuf, errbuf.size())))
                        )
                        :else                  ;; string
                        (ยง
                            ((ร Bytes save_arg =) null)

                            (ร Bytes newval)
                            ;; The old value is kept until we are sure that the new value is valid.
                            ((ร Bytes oldval =) (ยง (Bytes)@varp))
                            (cond (== nextchar (byte \&))    ;; set to default val
                            (ยง
                                ((ร newval =) (ยง (Bytes)v.def_val))

                                (if (nil? newval)
                                    ((ร newval =) EMPTY_OPTION)
                                    ((ร newval =) (STRDUP newval))
                                )
                            )
                            :else
                            (ยง
                                ((ร arg =) (ยง arg.plus(1)))      ;; jump to after the '=' or ':'

                                ;; Set 'keywordprg' to ":echo" if an empty
                                ;; value was passed to :set by the user.
                                ;; Misuse errbuf[] for the resulting string.

                                (when (and (== varp @(. @curbuf b_p_kp)) (or (eos? arg) (== (.at arg 0) (byte \space))))
                                    (STRCPY errbuf, (u8 ":echo"))
                                    ((ร save_arg =) arg)
                                    ((ร arg =) errbuf)
                                )

                                ((ร Bytes origval =) oldval)

                                ((ร newval =) (ยง new Bytes(STRLEN(arg) + 1)))
                                ((ร Bytes s =) newval)

                                ;; Copy the string, skip over escaped chars.

                                (while (ยง arg.at(0) != NUL && !vim_iswhite(arg.at(0)))
                                    (if (and (== (.at arg 0) (byte \\)) (non-eos? arg 1))
                                        ((ร arg =) (ยง arg.plus(1)))      ;; remove backslash
                                    )
                                    ((ร int i =) (us_ptr2len_cc arg))
                                    (cond (< 1 i)
                                    (ยง
                                        ;; copy multibyte char
                                        (BCOPY s, arg, i)
                                        ((ร arg =) (ยง arg.plus(i)))
                                        ((ร s =) (ยง s.plus(i)))
                                    )
                                    :else
                                    (ยง
                                        (ยง (s = s.plus(1)).be(-1, (arg = arg.plus(1)).at(-1)))
                                    ))
                                )
                                (.be s 0, NUL)

                                ;; Locate newval[] in origval[] when removing it and when adding to avoid duplicates.
                                ((ร int i =) 0)
                                (when (non-zero? (& (. v flags) P_NODUP))
                                    ((ร i =) (STRLEN newval))
                                    ((ร int bs =) 0)
                                    ((ร FOR) (ร (ยง s = origval) (ยง s.at(0) != NUL) (ยง s = s.plus(1)))
                                        (if (and (or (zero? (& (. v flags) P_COMMA)) (BEQ s, origval) (and (== (.at s -1) (byte \,)) (zero? (& bs 1)))) (zero? (STRNCMP s, newval, i)) (or (zero? (& (. v flags) P_COMMA)) (== (.at s i) (byte \,)) (eos? s i)))
                                            (ร BREAK)
                                        )
                                        ;; Count backslashes.
                                        ;; Only a comma with an even number of backslashes before it is recognized as a separator.
                                        (if (and (BLT origval, s) (== (.at s -1) (byte \\)))
                                            (ยง bs++)
                                            ((ร bs =) 0)
                                        )
                                    )
                                )

                                (when (non-zero? (& (. v flags) P_FLAGLIST))
                                    ;; Remove flags that appear twice.
                                    ((ร FOR) (ร (ยง s = newval) (ยง s.at(0) != NUL) (ยง s = s.plus(1)))
                                        (when (and (or (zero? (& (. v flags) P_COMMA)) (!= (.at s 0) (byte \,))) (non-nil? (ยง vim_strbyte(s.plus(1), s.at(0)))))
                                            (BCOPY s, 0, s, 1, (+ (STRLEN s, 1) 1))
                                            ((ร s =) (ยง s.minus(1)))
                                        )
                                    )
                                )

                                (if (non-nil? save_arg)   ;; number for 'whichwrap'
                                    ((ร arg =) save_arg)
                                )
                            ))

                            ;; Set the new value.
                            ((ร (Bytes)@varp =) newval)

                            ;; Handle side effects, and set the global value for ":set" on local options.
                            ((ร errmsg =) (ยง did_set_string_option(opt_idx, (Bytes[])varp, oldval, errbuf)))

                            ;; If error detected, print the error message.
                            (if (non-nil? errmsg)
                                (ร BREAK skip)
                            )
                        ))
                    ))
                ))
;           }

            ;; Advance to next argument.
            ;; - skip until a blank found, taking care of backslashes
            ;; - skip blanks
            ;; - skip one "=val" argument (for hidden options ":set gfn =xx")

            ((ร FOR) (ร (ยง int i = 0) (ยง i < 2 ) (ยง i++))
                (while (ยง arg.at(0) != NUL && !vim_iswhite(arg.at(0)))
                    (if (and (== (ยง (arg = arg.plus(1)).at(-1)) (byte \\)) (non-eos? arg))
                        ((ร arg =) (ยง arg.plus(1)))
                    )
                )
                ((ร arg =) (skipwhite arg))
                (if (!= (.at arg 0) (byte \=))
                    (ร BREAK)
                )
            )

            (when (non-nil? errmsg)
                (vim_strncpy @ioBuff, errmsg, (- IOSIZE 1))
                ((ร int i =) (ยง STRLEN(@ioBuff) + 2))
                (when (ยง i + BDIFF(arg, startarg) < IOSIZE)
                    ;; append the argument with the error
                    (STRCAT @ioBuff, (u8 ": "))
                    (BCOPY @ioBuff, i, startarg, 0, (BDIFF arg, startarg))
                    (ยง @ioBuff.be(i + BDIFF(arg, startarg), NUL))
                )
                ;; make sure all characters are printable
                (trans_characters @ioBuff, IOSIZE)

                (swap! no_wait_return inc)       ;; wait_return done later
                (emsg @ioBuff)           ;; show error highlighted
                (swap! no_wait_return dec)

                ((ร RETURN) false)
            )
        )

        true
    ))

(defn- #_Bytes illegal_char [#_Bytes errbuf, #_int c]
    (ยง
        (if (nil? errbuf)
            ((ร RETURN) (u8 ""))
        )

        (ยง libC.sprintf(errbuf, (u8 "E539: Illegal character <%s>"), transchar(c)))
        errbuf
    ))

;; After setting various option values: recompute variables that depend on option values.

(defn- #_void didset_options []
    (ยง
        ;; initialize the table for 'iskeyword' et al.
        (init_chartab)

        (opt_strings_flags @p_dy, p_dy_values, dy_flags, true)
        (opt_strings_flags @p_ve, p_ve_values, ve_flags, true)

        (briopt_check @curwin)
    ))

;; Check for string options that are null (normally only termcap options).

(defn- #_void check_options []
    (ยง
        ((ร FOR) (ร (ยง int i = 0) (ยง i < vimoptions.length) (ยง i++))
            (when (non-zero? (& (ยง vimoptions[i].flags) P_STRING))
                (check_string_option (ยง (Bytes[])get_varp(vimoptions[i])))
            )
        )
    ))

;; Check string options in a buffer for null value.

(defn- #_void check_buf_options [#_buffer_C buf]
    (ยง
        (check_string_option (. buf b_p_kp))
        (check_string_option (. buf b_p_mps))
        (check_string_option (. buf b_p_isk))
        (check_string_option (. buf b_p_nf))
        (check_string_option (. buf b_p_qe))
        (check_string_option (. buf b_p_cinw))
    ))

(defn- #_void clear_string_option [#_Bytes* pp]
    (ยง
        ((ร pp[0] =) EMPTY_OPTION)
    ))

(defn- #_void check_string_option [#_Bytes* pp]
    (ยง
        (when (nil? (ยง pp[0]))
            ((ร pp[0] =) EMPTY_OPTION)
        )
    ))

;; Handle string options that need some action to perform when changed.
;; Returns null for success, or an error message for an error.

(defn- #_Bytes did_set_string_option [#_int opt_idx, #_Bytes* varp, #_Bytes oldval, #_Bytes errbuf]
    ;; opt_idx: index in vimoptions[] table
    ;; varp: pointer to the option variable
    ;; oldval: previous value of the option
    ;; errbuf: buffer for errors, or null
    (ยง
        ((ร vimoption_C v =) (ยง vimoptions[opt_idx]))

        ((ร Bytes errmsg =) null)
        ((ร boolean did_chartab =) false)

        ;; 'breakindentopt'
        (cond (== varp (.. @curwin w_options wo_briopt))
        (ยง
            (if (not (briopt_check @curwin))
                ((ร errmsg =) e_invarg)
            )
        )

        ;; 'isident', 'iskeyword', 'isprint' or 'isfname' option: refill chartab[]
        ;; If the new option is invalid, use old value.

        (or (== varp p_isi) (== varp (. @curbuf b_p_isk)) (== varp p_isp) (== varp p_isf))
        (ยง
            (when (not (init_chartab))
                ((ร did_chartab =) true)     ;; need to restore it below
                ((ร errmsg =) e_invarg)      ;; error in value
            )
        )

        ;; 'colorcolumn'
        (== varp (.. @curwin w_options wo_cc))
        (ยง
            ((ร errmsg =) (check_colorcolumn @curwin))
        )

        ;; 'highlight'
        (== varp p_hl)
        (ยง
            (if (not (highlight_changed))
                ((ร errmsg =) e_invarg)  ;; invalid flags
            )
        )

        ;; 'nrformats'
        (== varp (. @curbuf b_p_nf))
        (ยง
            (if (not (check_opt_strings (ยง varp[0]), p_nf_values, true))
                ((ร errmsg =) e_invarg)
            )
        )

        ;; 'scrollopt'
        (== varp p_sbo)
        (ยง
            (if (not (check_opt_strings @p_sbo, p_scbopt_values, true))
                ((ร errmsg =) e_invarg)
            )
        )

        ;; 'matchpairs'
        (== varp (. @curbuf b_p_mps))
        (ยง
            ((ร FOR) (ร (ยง Bytes p = varp[0]) (ยง p.at(0) != NUL) (ยง p = p.plus(1)))
                ((ร int x2 =) -1)
                ((ร int x3 =) -1)

                (if (non-eos? p)
                    ((ร p =) (ยง p.plus(us_ptr2len_cc(p))))
                )
                (if (non-eos? p)
                    ((ร x2 =) (ยง (p = p.plus(1)).at(-1)))
                )
                (when (non-eos? p)
                    ((ร x3 =) (us_ptr2char p))
                    ((ร p =) (ยง p.plus(us_ptr2len_cc(p))))
                )
                (when (or (!= x2 (byte \:)) (== x3 -1) (and (non-eos? p) (!= (.at p 0) (byte \,))))
                    ((ร errmsg =) e_invarg)
                    (ร BREAK)
                )
                (if (eos? p)
                    (ร BREAK)
                )
            )
        )

        ;; 'showbreak'
        (== varp p_sbr)
        (ยง
            ((ร FOR) (ร (ยง Bytes s = @p_sbr) (ยง s.at(0) != NUL) nil)
                (if (!= (mb_ptr2cells s) 1)
                    ((ร errmsg =) (u8 "E595: contains unprintable or wide character"))
                )
                ((ร s =) (ยง s.plus(us_ptr2len_cc(s))))
            )
        )

        ;; 'breakat'
        (== varp p_breakat)
        (ยง
            (fill_breakat_flags)
        )

        ;; 'selection'
        (== varp p_sel)
        (ยง
            (if (or (eos? @p_sel) (not (check_opt_strings @p_sel, p_sel_values, false)))
                ((ร errmsg =) e_invarg)
            )
        )

        ;; 'selectmode'
        (== varp p_slm)
        (ยง
            (if (not (check_opt_strings @p_slm, p_slm_values, true))
                ((ร errmsg =) e_invarg)
            )
        )

        ;; 'keymodel'
        (== varp p_km)
        (ยง
            (cond (not (check_opt_strings @p_km, p_km_values, true))
            (ยง
                ((ร errmsg =) e_invarg)
            )
            :else
            (ยง
                (reset! km_stopsel (non-nil? (vim_strchr @p_km, (byte \o))))
                (reset! km_startsel (non-nil? (vim_strchr @p_km, (byte \a))))
            ))
        )

        ;; 'display'
        (== varp p_dy)
        (ยง
            (if (not (opt_strings_flags @p_dy, p_dy_values, dy_flags, true))
                ((ร errmsg =) e_invarg)
                (init_chartab))
        )

        ;; 'eadirection'
        (== varp p_ead)
        (ยง
            (if (not (check_opt_strings @p_ead, p_ead_values, false))
                ((ร errmsg =) e_invarg)
            )
        )

        ;; 'backspace'
        (== varp p_bs)
        (ยง
            (if (not (check_opt_strings @p_bs, p_bs_values, true))
                ((ร errmsg =) e_invarg)
            )
        )

        ;; 'virtualedit'
        (== varp p_ve)
        (ยง
            (cond (not (opt_strings_flags @p_ve, p_ve_values, ve_flags, true))
            (ยง
                ((ร errmsg =) e_invarg)
            )
            (non-zero? (STRCMP @p_ve, oldval))
            (ยง
                ;; Recompute cursor position in case the new 've' setting changes something.
                (validate_virtcol)
                (coladvance (. @curwin w_virtcol))
            ))
        )

        ;; Options that are a list of flags.
        :else
        (ยง
            ((ร Bytes p =) null)
            (cond (== varp p_ww)
            (ยง
                ((ร p =) WW_ALL)
            )
            (== varp p_cpo)
            (ยง
                ((ร p =) CPO_ALL)
            )
            (== varp (.. @curwin w_options wo_cocu))
            (ยง
                ((ร p =) COCU_ALL)
            ))
            (when (non-nil? p)
                ((ร FOR) (ร (ยง Bytes s = varp[0]) (ยง s.at(0) != NUL) (ยง s = s.plus(1)))
                    (when (nil? (ยง vim_strchr(p, s.at(0))))
                        ((ร errmsg =) (ยง illegal_char(errbuf, s.at(0))))
                        (ร BREAK)
                    )
                )
            )
        ))

        ;; If error detected, restore the previous value.

        (when (non-nil? errmsg)
            ((ร varp[0] =) oldval)

            ;; When resetting some values, need to act on it.

            (if did_chartab
                (init_chartab))
            (if (== varp p_hl)
                (highlight_changed))
        )

        (if (and (!= (. @curwin w_curswant) MAXCOL) (non-zero? (ยง v.flags & (P_CURSWANT | P_RALL))))
            ((ร @curwin.w_set_curswant =) true)
        )
        (check_redraw (. v flags))

        errmsg
    ))

;; Handle setting 'colorcolumn' in window "wp".
;; Returns error message, null if it's OK.

(defn- #_Bytes check_colorcolumn [#_window_C wp]
    (ยง
        ((ร int count =) 0)
        ((ร int[] color_cols =) (ยง new int[256]))

        ((ร FOR) (ร (ยง Bytes s = wp.w_options.@wo_cc) (ยง s.at(0) != NUL && count < 255) nil)
            (if (not (asc_isdigit (ยง s.at(0))))
                ((ร RETURN) e_invarg)
            )

            (ร int col)
;           Bytes[] __ = { s }; col = (int)getdigits(__); s = __[0];

            ((ร color_cols[count++] =) (- col 1))  ;; 1-based to 0-based

            (if (eos? s)
                (ร BREAK)
            )
            (if (!= (.at s 0) (byte \,))
                ((ร RETURN) e_invarg)
            )
            (if (ยง (s = s.plus(1)).at(0) == NUL)
                ((ร RETURN) e_invarg)    ;; illegal trailing comma as in "set cc=80,"
            )
        )

        (cond (zero? count)
        (ยง
            ((ร wp.w_p_cc_cols =) null)
        )
        :else
        (ยง
            ((ร wp.w_p_cc_cols =) (ยง new int[count + 1]))

            ;; sort the columns for faster usage on screen redraw inside win_line()
            (ยง Arrays.sort(color_cols, 0, count))

            ((ร int j =) 0)
            ((ร FOR) (ร (ยง int i = 0) (< i count) (ยง i++))
                ;; skip duplicates
                (if (or (zero? j) (ยง wp.w_p_cc_cols[j - 1] != color_cols[i]))
                    ((ร wp.w_p_cc_cols[j++] =) (ยง color_cols[i]))
                )
            )
            ((ร wp.w_p_cc_cols[j] =) -1)     ;; end marker
        ))

        null    ;; no error
    ))

;; Set the value of a boolean option, and take care of side effects.
;; Returns null for success, or an error message for an error.

(defn- #_Bytes set_bool_option [#_int opt_idx, #_boolean* varp, #_boolean value]
    ;; opt_idx: index in vimoptions[] table
    ;; varp: pointer to the option variable
    ;; value: new value
    (ยง
        ((ร vimoption_C v =) (ยง vimoptions[opt_idx]))

        ((ร boolean old_value =) (ยง varp[0]))
        ((ร varp[0] =) value)                    ;; set the new value

        ;; Handle side effects of changing a bool option.

        ;; when 'paste' is set or reset also change other options
        (cond (== varp p_paste)
        (ยง
            (paste_option_changed)
        )

        ;; when 'insertmode' is set from an autocommand need to do work here
        (== varp p_im)
        (ยง
            (cond @p_im
            (ยง
                (if (zero? (& @State INSERT))
                    (reset! need_start_insertmode true))
                (reset! stop_insert_mode false)
            )
            :else
            (ยง
                (reset! need_start_insertmode false)
                (reset! stop_insert_mode true)
                (if (and (non-zero? @restart_edit) @mode_displayed)
                    (reset! clear_cmdline true))   ;; remove "(insert)"
                (reset! restart_edit 0)
            ))
        )

        ;; when 'ignorecase' is set or reset and 'hlsearch' is set, redraw
        (and (== varp p_ic) @p_hls)
        (ยง
            (redraw_all_later SOME_VALID)
        )

        ;; when 'hlsearch' is set or reset: reset no_hlsearch
        (== varp p_hls)
        (ยง
            (reset! no_hlsearch false)
        )

        ;; when 'scrollbind' is set:
        ;; snapshot the current position to avoid a jump at the end of normal_cmd()
        (== varp (.. @curwin w_options wo_scb))
        (ยง
            (when @(.. @curwin w_options wo_scb)
                (do_check_scrollbind false)
                ((ร @curwin.w_scbind_pos =) (. @curwin w_topline))
            )
        )

        ;; If 'wrap' is set, set w_leftcol to zero.
        (== varp (.. @curwin w_options wo_wrap))
        (ยง
            (if @(.. @curwin w_options wo_wrap)
                ((ร @curwin.w_leftcol =) 0)
            )
        )

        (== varp p_ea)
        (ยง
            (if (and @p_ea (not old_value))
                (win_equal @curwin, false, 0))
        ))

        ;; End of handling side effects for bool options.

        (comp_col)                     ;; in case 'ruler' or 'showcmd' changed
        (if (and (!= (. @curwin w_curswant) MAXCOL) (non-zero? (ยง v.flags & (P_CURSWANT | P_RALL))))
            ((ร @curwin.w_set_curswant =) true)
        )
        (check_redraw (. v flags))

        null
    ))

;; Set the value of a number option, and take care of side effects.
;; Returns null for success, or an error message for an error.

(defn- #_Bytes set_num_option [#_int opt_idx, #_long* varp, #_long value, #_Bytes errbuf, #_int errbuflen]
    ;; opt_idx: index in vimoptions[] table
    ;; varp: pointer to the option variable
    ;; value: new value
    ;; errbuf: buffer for error messages
    ;; errbuflen: length of "errbuf"
    (ยง
        ((ร Bytes errmsg =) null)
        ((ร long old_value =) (ยง varp[0]))
        ((ร long old_Rows =) @Rows)               ;; remember old Rows
        ((ร long old_Columns =) @Columns)         ;; remember old Columns

        ((ร varp[0] =) value)

        (when (< @(. @curbuf b_p_sw) 0)
            ((ร errmsg =) e_positive)
            ((ร @curbuf.@b_p_sw =) @(. @curbuf b_p_ts))
        )

        ;; Number options that need some action when changed.

        (cond (== varp p_wh)
        (ยง
            (when (< @p_wh 1)
                ((ร errmsg =) e_positive)
                (reset! p_wh 1)
            )
            (when (< @p_wh @p_wmh)
                ((ร errmsg =) e_winheight)
                (reset! p_wh @p_wmh)
            )

            ;; Change window height NOW.
            (when (!= @lastwin @firstwin)
                (if (and (== varp p_wh) (< (. @curwin w_height) @p_wh))
                    (win_setheight (int @p_wh)))
            )
        )

        ;; 'winminheight'
        (== varp p_wmh)
        (ยง
            (when (< @p_wmh 0)
                ((ร errmsg =) e_positive)
                (reset! p_wmh 0)
            )
            (when (< @p_wh @p_wmh)
                ((ร errmsg =) e_winheight)
                (reset! p_wmh @p_wh)
            )
            (win_setminheight)
        )

        (== varp p_wiw)
        (ยง
            (when (< @p_wiw 1)
                ((ร errmsg =) e_positive)
                (reset! p_wiw 1)
            )
            (when (< @p_wiw @p_wmw)
                ((ร errmsg =) e_winwidth)
                (reset! p_wiw @p_wmw)
            )

            ;; Change window width NOW.
            (if (and (!= @lastwin @firstwin) (< (. @curwin w_width) @p_wiw))
                (win_setwidth (int @p_wiw)))
        )

        ;; 'winminwidth'
        (== varp p_wmw)
        (ยง
            (when (< @p_wmw 0)
                ((ร errmsg =) e_positive)
                (reset! p_wmw 0)
            )
            (when (< @p_wiw @p_wmw)
                ((ร errmsg =) e_winwidth)
                (reset! p_wmw @p_wiw)
            )
            (win_setminheight)
        )

        ;; (re)set last window status line
        (== varp p_ls)
        (ยง
            (last_status false)
        )

        ;; 'maxcombine'
        (== varp p_mco)
        (ยง
            (cond (< MAX_MCO @p_mco)
            (ยง
                (reset! p_mco MAX_MCO)
            )
            (< @p_mco 0)
            (ยง
                (reset! p_mco 0)
            ))
            (screenclear)      ;; will re-allocate the screen
        )

        ;; if "p_ch" changed value, change the command line height
        (== varp p_ch)
        (ยง
            (when (< @p_ch 1)
                ((ร errmsg =) e_positive)
                (reset! p_ch 1)
            )
            ((ร int min =) (min_rows))
            (if (> @p_ch (ยง @Rows - min + 1))
                (reset! p_ch (ยง @Rows - min + 1)))

            ;; Only compute the new window layout when startup has been completed,
            ;; otherwise the frame sizes may be wrong.
            (if (and (!= @p_ch old_value) @full_screen)
                (command_height))
        )

        (== varp (.. @curwin w_options wo_cole))
        (ยง
            (cond (< @(.. @curwin w_options wo_cole) 0)
            (ยง
                ((ร errmsg =) e_positive)
                ((ร @curwin.w_options.@wo_cole =) 0)
            )
            (< 3 @(.. @curwin w_options wo_cole))
            (ยง
                ((ร errmsg =) e_invarg)
                ((ร @curwin.w_options.@wo_cole =) 3)
            ))
        )

        ;; sync undo before 'undolevels' changes
        (== varp (. @curbuf b_p_ul))
        (ยง
            ;; use the old value, otherwise u_sync() may not work properly
            ((ร @curbuf.@b_p_ul =) old_value)
            (u_sync true)
            ((ร @curbuf.@b_p_ul =) value)
        )

        ;; 'numberwidth' must be positive
        (== varp (.. @curwin w_options wo_nuw))
        (ยง
            (when (< @(.. @curwin w_options wo_nuw) 1)
                ((ร errmsg =) e_positive)
                ((ร @curwin.w_options.@wo_nuw =) 1)
            )
            (when (< 10 @(.. @curwin w_options wo_nuw))
                ((ร errmsg =) e_invarg)
                ((ร @curwin.w_options.@wo_nuw =) 10)
            )
            ((ร @curwin.w_nrwidth_line_count =) 0)    ;; trigger a redraw
        ))

        ;; Check the bounds for numeric options here.

        (when @full_screen
            ((ร int min =) (min_rows))
            (when (< @Rows min)
                (when (non-nil? errbuf)
                    (ยง vim_snprintf(errbuf, errbuflen, (u8 "E593: Need at least %d lines"), min))
                    ((ร errmsg =) errbuf)
                )
                (reset! Rows min)
            )
            (when (< (int @Columns) MIN_COLUMNS)
                (when (non-nil? errbuf)
                    (ยง vim_snprintf(errbuf, errbuflen, (u8 "E594: Need at least %d columns"), MIN_COLUMNS))
                    ((ร errmsg =) errbuf)
                )
                (reset! Columns MIN_COLUMNS)
            )
        )
        (limit_screen_size)

        ;; If the screen (shell) height has been changed, assume it is the physical screenheight.

        (when (or (!= old_Rows @Rows) (!= old_Columns @Columns))
            ;; Changing the screen size is not allowed while updating the screen.
            (cond @updating_screen
            (ยง
                ((ร varp[0] =) old_value)
            )
            @full_screen
            (ยง
                (set_shellsize (int @Columns), (int @Rows), true)
            )
            :else
            (ยง
                ;; Postpone the resizing; check the size and cmdline position for messages.
                (check_shellsize)
                (if (and (> @cmdline_row (- @Rows @p_ch)) (< @p_ch @Rows))
                    (reset! cmdline_row (int (- @Rows @p_ch))))
            ))
        )

        (when (<= @(. @curbuf b_p_ts) 0)
            ((ร errmsg =) e_positive)
            ((ร @curbuf.@b_p_ts =) 8)
        )
        (when (< @p_tm 0)
            ((ร errmsg =) e_positive)
            (reset! p_tm 0)
        )
        (when (and (or (<= @(.. @curwin w_options wo_scr) 0) (and (< (. @curwin w_height) @(.. @curwin w_options wo_scr)) (< 0 (. @curwin w_height)))) @full_screen)
            (cond (== varp (.. @curwin w_options wo_scr))
            (ยง
                (if (!= @(.. @curwin w_options wo_scr) 0)
                    ((ร errmsg =) e_scroll)
                )
                (win_comp_scroll @curwin)
            )
            ;; If 'scroll' became invalid because of a side effect silently adjust it.
            (<= @(.. @curwin w_options wo_scr) 0)
            (ยง
                ((ร @curwin.w_options.@wo_scr =) 1)
            )
            :else ;; @curwin.w_options.@wo_scr > @curwin.w_height
            (ยง
                ((ร @curwin.w_options.@wo_scr =) (. @curwin w_height))
            ))
        )
        (cond (< @p_hi 0)
        (ยง
            ((ร errmsg =) e_positive)
            (reset! p_hi 0)
        )
        (< 10000 @p_hi)
        (ยง
            ((ร errmsg =) e_invarg)
            (reset! p_hi 10000)
        ))
        (when (or (< @p_re 0) (< 2 @p_re))
            ((ร errmsg =) e_invarg)
            (reset! p_re 0)
        )
        (when (< @p_report 0)
            ((ร errmsg =) e_positive)
            (reset! p_report 1)
        )
        (when (and (or (< @p_sj -100) (<= @Rows @p_sj)) @full_screen)
            (cond (!= @Rows old_Rows)   ;; Rows changed, just adjust "p_sj"
            (ยง
                (reset! p_sj (/ @Rows 2))
            )
            :else
            (ยง
                ((ร errmsg =) e_scroll)
                (reset! p_sj 1)
            ))
        )
        (when (and (< @p_so 0) @full_screen)
            ((ร errmsg =) e_scroll)
            (reset! p_so 0)
        )
        (when (and (< @p_siso 0) @full_screen)
            ((ร errmsg =) e_positive)
            (reset! p_siso 0)
        )
        (when (< @p_cwh 1)
            ((ร errmsg =) e_positive)
            (reset! p_cwh 1)
        )
        (when (< @p_ut 0)
            ((ร errmsg =) e_positive)
            (reset! p_ut 2000)
        )
        (when (< @p_ss 0)
            ((ร errmsg =) e_positive)
            (reset! p_ss 0)
        )

        ((ร vimoption_C v =) (ยง vimoptions[opt_idx]))

        (comp_col)                     ;; in case 'columns' or 'ls' changed
        (if (and (!= (. @curwin w_curswant) MAXCOL) (non-zero? (ยง v.flags & (P_CURSWANT | P_RALL))))
            ((ร @curwin.w_set_curswant =) true)
        )
        (check_redraw (. v flags))

        errmsg
    ))

;; Called after an option changed: check if something needs to be redrawn.

(defn- #_void check_redraw [#_long flags]
    (ยง
        ;; Careful: P_RCLR and P_RALL are a combination of other P_ flags.
        ((ร boolean doclear =) (ยง ((flags & P_RCLR) == P_RCLR)))
        ((ร boolean all =) (ยง ((flags & P_RALL) == P_RALL || doclear)))

        (if (or (non-zero? (& flags P_RSTAT)) all)      ;; mark all status lines dirty
            (status_redraw_all))

        (if (or (non-zero? (& flags P_RBUF)) (non-zero? (& flags P_RWIN)) all)
            (changed_window_setting))
        (if (non-zero? (& flags P_RBUF))
            (redraw_curbuf_later NOT_VALID))
        (cond doclear
        (ยง
            (redraw_all_later CLEAR)
        )
        all
        (ยง
            (redraw_all_later NOT_VALID)
        ))
    ))

;; Find index for option 'arg'.
;; Return -1 if not found.

(defn- #_int findoption [#_Bytes arg]
    (ยง
        ;; Check for name starting with an illegal character.

        (if (or (< (.at arg 0) (byte \a)) (< (byte \z) (.at arg 0)))
            ((ร RETURN) -1)
        )

        ((ร FOR) (ร (ยง int opt_idx = 0) (ยง opt_idx < vimoptions.length) (ยง opt_idx++))
            ((ร Bytes s =) (ยง vimoptions[opt_idx].fullname))
            (if (zero? (STRCMP arg, s))                    ;; match full name
                ((ร RETURN) opt_idx)
            )
        )

        ((ร FOR) (ร (ยง int opt_idx = 0) (ยง opt_idx < vimoptions.length) (ยง opt_idx++))
            ((ร Bytes s =) (ยง vimoptions[opt_idx].shortname))
            (if (and (non-nil? s) (zero? (STRCMP arg, s)))       ;; match short name
                ((ร RETURN) opt_idx)
            )
        )

        -1
    ))

(defn- #_Bytes get_highlight_default []
    (ยง
        ((ร int i =) (findoption (u8 "hl")))
        (if (< i 0)
            ((ร RETURN) null)
        )

        (ยง (Bytes)vimoptions[i].def_val)
    ))

;; showoneopt: show the value of one option

(defn- #_void showoneopt [#_vimoption_C v]
    (ยง
        (reset! info_message true)

        ((ร Object varp =) (get_varp v))

        (if (and (non-zero? (& (. v flags) P_BOOL)) (not (boolean @varp)))
            (msg_puts (u8 "no"))
            (msg_puts (u8 "  ")))

        (msg_puts (. v fullname))

        (when (zero? (& (. v flags) P_BOOL))
            (msg_putchar (byte \=))

            (cond (non-zero? (& (. v flags) P_NUM))
            (ยง
                (ยง libC.sprintf(@nameBuff, (u8 "%ld"), (long)@varp))
            )
            (non-zero? (& (. v flags) P_STRING))
            (ยง
                (if (nil? @varp)              ;; just in case
                    (.be @nameBuff 0, NUL)
                    (vim_strncpy @nameBuff, (ยง (Bytes)@varp), (- MAXPATHL 1)))
            ))

            (msg_outtrans @nameBuff)
        )

        (reset! info_message false)
    ))

;; Compute columns for ruler and shown command. 'sc_col' is also used to
;; decide what the maximum length of a message on the status line can be.
;; If there is a status line for the last window, 'sc_col' is independent
;; of 'ru_col'.

(final int COL_RULER 17)        ;; columns needed by standard ruler

(defn- #_void comp_col []
    (ยง
        ((ร boolean last_has_status =) (ยง (@p_ls == 2 || (@p_ls == 1 && @firstwin != @lastwin))))

        (reset! sc_col 0)
        (reset! ru_col 0)
        (when @p_ru
            (reset! ru_col (inc (if (non-zero? @ru_wid) @ru_wid COL_RULER)))
            ;; no last status line, adjust sc_col
            (if (not last_has_status)
                (reset! sc_col @ru_col))
        )
        (when @p_sc
            ((ร @sc_col +=) SHOWCMD_COLS)
            (if (or (not @p_ru) last_has_status)       ;; no need for separating space
                (swap! sc_col inc))
        )
        (reset! sc_col (- (int @Columns) @sc_col))
        (reset! ru_col (- (int @Columns) @ru_col))
        (if (<= @sc_col 0)            ;; screen too narrow, will become a mess
            (reset! sc_col 1))
        (when (<= @ru_col 0)
            (reset! ru_col 1)
        )
    ))

;; Get pointer to option variable.

(defn- #_Object get_varp [#_vimoption_C v]
    (ยง
        ((ร SWITCH) (. v indir)
            ((ร CASE) PV_BRI)
            (ยง
                ((ร RETURN) (.. @curwin w_options wo_bri))
            )
            ((ร CASE) PV_BRIOPT)
            (ยง
                ((ร RETURN) (.. @curwin w_options wo_briopt))
            )
            ((ร CASE) PV_CC)
            (ยง
                ((ร RETURN) (.. @curwin w_options wo_cc))
            )
            ((ร CASE) PV_COCU)
            (ยง
                ((ร RETURN) (.. @curwin w_options wo_cocu))
            )
            ((ร CASE) PV_COLE)
            (ยง
                ((ร RETURN) (.. @curwin w_options wo_cole))
            )
            ((ร CASE) PV_CRBIND)
            (ยง
                ((ร RETURN) (.. @curwin w_options wo_crb))
            )
            ((ร CASE) PV_CUC)
            (ยง
                ((ร RETURN) (.. @curwin w_options wo_cuc))
            )
            ((ร CASE) PV_CUL)
            (ยง
                ((ร RETURN) (.. @curwin w_options wo_cul))
            )
            ((ร CASE) PV_LBR)
            (ยง
                ((ร RETURN) (.. @curwin w_options wo_lbr))
            )
            ((ร CASE) PV_NU)
            (ยง
                ((ร RETURN) (.. @curwin w_options wo_nu))
            )
            ((ร CASE) PV_NUW)
            (ยง
                ((ร RETURN) (.. @curwin w_options wo_nuw))
            )
            ((ร CASE) PV_RNU)
            (ยง
                ((ร RETURN) (.. @curwin w_options wo_rnu))
            )
            ((ร CASE) PV_SCBIND)
            (ยง
                ((ร RETURN) (.. @curwin w_options wo_scb))
            )
            ((ร CASE) PV_SCROLL)
            (ยง
                ((ร RETURN) (.. @curwin w_options wo_scr))
            )
            ((ร CASE) PV_WFH)
            (ยง
                ((ร RETURN) (.. @curwin w_options wo_wfh))
            )
            ((ร CASE) PV_WFW)
            (ยง
                ((ร RETURN) (.. @curwin w_options wo_wfw))
            )
            ((ร CASE) PV_WRAP)
            (ยง
                ((ร RETURN) (.. @curwin w_options wo_wrap))
            )

            ((ร CASE) PV_AI)
            (ยง
                ((ร RETURN) (. @curbuf b_p_ai))
            )
            ((ร CASE) PV_CI)
            (ยง
                ((ร RETURN) (. @curbuf b_p_ci))
            )
            ((ร CASE) PV_CINW)
            (ยง
                ((ร RETURN) (. @curbuf b_p_cinw))
            )
            ((ร CASE) PV_ET)
            (ยง
                ((ร RETURN) (. @curbuf b_p_et))
            )
            ((ร CASE) PV_ISK)
            (ยง
                ((ร RETURN) (. @curbuf b_p_isk))
            )
            ((ร CASE) PV_KP)
            (ยง
                ((ร RETURN) (. @curbuf b_p_kp))
            )
            ((ร CASE) PV_MOD)
            (ยง
                ((ร RETURN) (. @curbuf b_changed))
            )
            ((ร CASE) PV_MPS)
            (ยง
                ((ร RETURN) (. @curbuf b_p_mps))
            )
            ((ร CASE) PV_NF)
            (ยง
                ((ร RETURN) (. @curbuf b_p_nf))
            )
            ((ร CASE) PV_PI)
            (ยง
                ((ร RETURN) (. @curbuf b_p_pi))
            )
            ((ร CASE) PV_QE)
            (ยง
                ((ร RETURN) (. @curbuf b_p_qe))
            )
            ((ร CASE) PV_SI)
            (ยง
                ((ร RETURN) (. @curbuf b_p_si))
            )
            ((ร CASE) PV_STS)
            (ยง
                ((ร RETURN) (. @curbuf b_p_sts))
            )
            ((ร CASE) PV_SW)
            (ยง
                ((ร RETURN) (. @curbuf b_p_sw))
            )
            ((ร CASE) PV_TS)
            (ยง
                ((ร RETURN) (. @curbuf b_p_ts))
            )
            ((ร CASE) PV_UL)
            (ยง
                ((ร RETURN) (. @curbuf b_p_ul))
            )
        )

        (. v var)
    ))

;; Copy options from one window to another.
;; Used when splitting a window.

(defn- #_void win_copy_options [#_window_C wp_from, #_window_C wp_to]
    (ยง
        (copy_winopt (. wp_from w_options), (. wp_to w_options))
        (briopt_check wp_to)
    ))

;; Copy the options from one winopt_C to another.
;; Doesn't free the old option values in "to", use clear_winopt() for that.
;; The 'scroll' option is not copied, because it depends on the window height.
;; The 'previewwindow' option is reset, there can be only one preview window.

(defn- #_void copy_winopt [#_winopt_C from, #_winopt_C to]
    (ยง
        ((ร to.@wo_nu =) @(. from wo_nu))
        ((ร to.@wo_rnu =) @(. from wo_rnu))
        ((ร to.@wo_nuw =) @(. from wo_nuw))
        ((ร to.@wo_wrap =) @(. from wo_wrap))
        ((ร to.@wo_lbr =) @(. from wo_lbr))
        ((ร to.@wo_bri =) @(. from wo_bri))
        ((ร to.@wo_briopt =) (ยง STRDUP(from.@wo_briopt)))
        ((ร to.@wo_scb =) @(. from wo_scb))
        ((ร to.@wo_crb =) @(. from wo_crb))
        ((ร to.@wo_cuc =) @(. from wo_cuc))
        ((ร to.@wo_cul =) @(. from wo_cul))
        ((ร to.@wo_cc =) (ยง STRDUP(from.@wo_cc)))
        ((ร to.@wo_cocu =) (ยง STRDUP(from.@wo_cocu)))
        ((ร to.@wo_cole =) @(. from wo_cole))

        (check_winopt to)           ;; don't want null pointers
    ))

;; Check string options in a window for a null value.

(defn- #_void check_win_options [#_window_C win]
    (ยง
        (check_winopt (. win w_options))
    ))

;; Check for null pointers in a winopt_C and replace them with EMPTY_OPTION.

(defn- #_void check_winopt [#_winopt_C wop]
    (ยง
        (check_string_option (. wop wo_briopt))
        (check_string_option (. wop wo_cc))
        (check_string_option (. wop wo_cocu))
    ))

;; Free the allocated memory inside a winopt_C.

(defn- #_void clear_winopt [#_winopt_C wop]
    (ยง
        (clear_string_option (. wop wo_briopt))
        (clear_string_option (. wop wo_cc))
        (clear_string_option (. wop wo_cocu))
    ))

(atom! boolean old_p_paste)
(atom! boolean save_sm)
(atom! boolean save_ru)

;; paste_option_changed() - Called after "p_paste" was set or reset.

(defn- #_void paste_option_changed []
    (ยง
        (cond @p_paste
        (ยง
            ;; Paste switched from off to on.
            ;; Save the current values, so they can be restored later.

            (when (not @old_p_paste)
                ;; save options
                ((ร buffer_C buf =) @curbuf)
;               {
                    ((ร buf.b_p_sts_nopaste =) @(. buf b_p_sts))
                    ((ร buf.b_p_ai_nopaste =) @(. buf b_p_ai))
;               }

                ;; save global options
                (reset! save_sm @p_sm)
                (reset! save_ru @p_ru)
            )

            ;; Always set the option values, also when 'paste' is set when it is already on.

            ;; set options
            ((ร buffer_C buf =) @curbuf)
;           {
                ((ร buf.@b_p_sts =) 0)        ;; softtabstop is 0
                ((ร buf.@b_p_ai =) false)         ;; no auto-indent
;           }

            ;; set global options
            (reset! p_sm false)                   ;; no showmatch
            (if @p_ru
                (status_redraw_all))    ;; redraw to remove the ruler
            (reset! p_ru false)                   ;; no ruler
        )

        ;; Paste switched from on to off: Restore saved values.

        @old_p_paste
        (ยง
            ;; restore options
            ((ร buffer_C buf =) @curbuf)
;           {
                ((ร buf.@b_p_sts =) (. buf b_p_sts_nopaste))
                ((ร buf.@b_p_ai =) (. buf b_p_ai_nopaste))
;           }

            ;; restore global options
            (reset! p_sm @save_sm)
            (if (!= @p_ru @save_ru)
                (status_redraw_all))    ;; redraw to draw the ruler
            (reset! p_ru @save_ru)
        ))

        (reset! old_p_paste @p_paste)
    ))

;; fill_breakat_flags() -- called when 'breakat' changes value.

(defn- #_void fill_breakat_flags []
    (ยง
        ((ร FOR) (ร (ยง int i = 0) (< i 256) (ยง i++))
            ((ร @breakat_flags[i] =) false)
        )

        (when (non-nil? @p_breakat)
            ((ร FOR) (ร (ยง Bytes p = @p_breakat) (ยง p.at(0) != NUL) (ยง p = p.plus(1)))
                ((ร @breakat_flags[char_u(p.at(0))] =) true)
            )
        )
    ))

;; Check an option that can be a range of string values.
;;
;; Return true for correct value, false otherwise.
;; Empty is always OK.

(defn- #_boolean check_opt_strings [#_Bytes val, #_Bytes* values, #_boolean list]
    ;; list: when true: accept a list of values
    (opt_strings_flags val, values, null, list))

;; Handle an option that can be a range of string values.
;; Set a flag in "*flagp" for each string present.
;;
;; Return true for correct value, false otherwise.
;; Empty is always OK.

(defn- #_boolean opt_strings_flags [#_Bytes val, #_Bytes* values, #_int* flagp, #_boolean list]
    ;; val: new value
    ;; values: array of valid string values
    ;; list: when true: accept a list of values
    (ยง
        ((ร int new_flags =) 0)

        (while (ยง val.at(0) != NUL)
            ((ร FOR) (ร (ยง int i = 0) true (ยง i++))
                (if (nil? (ยง values[i]))      ;; "val" not found in values[]
                    ((ร RETURN) false)
                )

                ((ร int len =) (ยง STRLEN(values[i])))
                (when (and (zero? (ยง STRNCMP(values[i], val, len))) (or (and list (== (.at val len) (byte \,))) (eos? val len)))
                    ((ร val =) (.plus val (+ len (if (== (.at val len) (byte \,)) 1 0))))
                    ((ร new_flags |=) (ยง (1 << i)))
                    (ร BREAK)                  ;; check next item in "val" list
                )
            )
        )
        (if (non-nil? flagp)
            ((ร flagp[0] =) new_flags)
        )

        true
    ))

;; Check if backspacing over something is allowed.

(defn- #_boolean can_bs [#_int what]
    ;; what: BS_INDENT, BS_EOL or BS_START
    (ยง
        (non-nil? (vim_strchr @p_bs, what))
    ))

;; Return the effective shiftwidth value for current buffer,
;; using the 'tabstop' value when 'shiftwidth' is zero.

(defn- #_long get_sw_value [#_buffer_C buf]
    (ยง
        (if (!= @(. buf b_p_sw) 0) @(. buf b_p_sw) @(. buf b_p_ts))
    ))

;; Return the effective softtabstop value for the current buffer,
;; using the 'tabstop' value when 'softtabstop' is negative.

(defn- #_long get_sts_value []
    (ยง
        (if (< @(. @curbuf b_p_sts) 0) (get_sw_value @curbuf) @(. @curbuf b_p_sts))
    ))

;; Check matchpairs option for "*initc".
;; If there is a match set "*initc" to the matching character and "*findc" to the opposite.
;; Set "*backwards" to the direction.
;; When "switchit" is true, swap the direction.

(defn- #_void find_mps_values [#_int* initc, #_int* findc, #_boolean* backwards, #_boolean switchit]
    (ยง
        ((ร Bytes ptr =) @(. @curbuf b_p_mps))
        (while (ยง ptr.at(0) != NUL)
            (ร Bytes prev)

            (when (== (us_ptr2char ptr) (ยง initc[0]))
                (cond switchit
                (ยง
                    ((ร findc[0] =) (ยง initc[0]))
                    ((ร initc[0] =) (ยง us_ptr2char(ptr.plus(us_ptr2len_cc(ptr) + 1))))
                    ((ร backwards[0] =) true)
                )
                :else
                (ยง
                    ((ร findc[0] =) (ยง us_ptr2char(ptr.plus(us_ptr2len_cc(ptr) + 1))))
                    ((ร backwards[0] =) false)
                ))
                (ร RETURN)
            )
            ((ร prev =) ptr)
            ((ร ptr =) (ยง ptr.plus(us_ptr2len_cc(ptr) + 1)))
            (when (== (us_ptr2char ptr) (ยง initc[0]))
                (cond switchit
                (ยง
                    ((ร findc[0] =) (ยง initc[0]))
                    ((ร initc[0] =) (us_ptr2char prev))
                    ((ร backwards[0] =) false)
                )
                :else
                (ยง
                    ((ร findc[0] =) (us_ptr2char prev))
                    ((ร backwards[0] =) true)
                ))
                (ร RETURN)
            )
            ((ร ptr =) (ยง ptr.plus(us_ptr2len_cc(ptr))))

            (if (== (.at ptr 0) (byte \,))
                ((ร ptr =) (ยง ptr.plus(1)))
            )
        )
    ))

;; This is called when 'breakindentopt' is changed and when a window is initialized.

(defn- #_boolean briopt_check [#_window_C wp]
    (ยง
        ((ร int bri_shift =) 0)
        ((ร int bri_min =) 20)
        ((ร boolean bri_sbr =) false)

        ((ร Bytes p =) @(.. wp w_options wo_briopt))
        (while (ยง p.at(0) != NUL)
            (cond (and (zero? (STRNCMP p, (u8 "shift:"), 6)) (or (and (== (.at p 6) (byte \-)) (asc_isdigit (ยง p.at(7)))) (asc_isdigit (ยง p.at(6)))))
            (ยง
                ((ร p =) (ยง p.plus(6)))
;               { Bytes[] __ = { p }; bri_shift = (int)getdigits(__); p = __[0]; }
            )
            (and (zero? (STRNCMP p, (u8 "min:"), 4)) (asc_isdigit (ยง p.at(4))))
            (ยง
                ((ร p =) (ยง p.plus(4)))
;               { Bytes[] __ = { p }; bri_min = (int)getdigits(__); p = __[0]; }
            )
            (zero? (STRNCMP p, (u8 "sbr"), 3))
            (ยง
                ((ร p =) (ยง p.plus(3)))
                ((ร bri_sbr =) true)
            ))
            (if (and (!= (.at p 0) (byte \,)) (non-eos? p))
                ((ร RETURN) false)
            )
            (if (== (.at p 0) (byte \,))
                ((ร p =) (ยง p.plus(1)))
            )
        )

        ((ร wp.w_p_brishift =) bri_shift)
        ((ร wp.w_p_brimin =) bri_min)
        ((ร wp.w_p_brisbr =) bri_sbr)

        true
    ))

;; ex_cmds.c: some functions for command line commands --------------------------------------------

;; ":ascii" and "ga".

(defn- #_void do_ascii []
    (ยง
        ((ร int[] cc =) (ยง new int[MAX_MCO]))

        ((ร int c =) (ยง us_ptr2char_cc(ml_get_cursor(), cc)))
        (when (== c NUL)
            (msg (u8 "NUL"))
            (ร RETURN)
        )

        ((ร int ci =) 0)

        (.be @ioBuff 0, NUL)
        (when (< c 0x80)
            (if (== c NL)        ;; NUL is stored as NL
                ((ร c =) NUL)
            )

            ((ร int cval =) c)

            ((ร Bytes buf1 =) (ยง new Bytes(20)))
            (cond (and (vim_isprintc c) (or (< c (byte \space)) (< (byte \~) c)))
            (ยง
                ((ร Bytes buf3 =) (ยง new Bytes(7)))
                (transchar_nonprint buf3, c)
                (ยง vim_snprintf(buf1, buf1.size(), (u8 "  <%s>"), buf3))
            )
            :else
            (ยง
                (.be buf1 0, NUL)
            ))

            ((ร Bytes buf2 =) (ยง new Bytes(20)))
            (if (<= 0x80 c)
                (ยง vim_snprintf(buf2, buf2.size(), (u8 "  <M-%s>"), transchar(c & 0x7f)))
                (.be buf2 0, NUL)
            )

            (ยง vim_snprintf(@ioBuff, IOSIZE, (u8 "<%s>%s%s  %d,  Hex %02x,  Octal %03o"), transchar(c), buf1, buf2, cval, cval, cval))
            ((ร c =) (ยง cc[ci++]))
        )

        ;; Repeat for combining characters.
        (while (ยง 0x100 <= c || 0x80 <= c)
            ((ร int len =) (STRLEN @ioBuff))
            ;; This assumes every multi-byte char is printable...
            (if (< 0 len)
                (ยง @ioBuff.be(len++, (byte \space)))
            )
            (.be @ioBuff (ยง len++), (byte \<))
            (if (utf_iscomposing c)
                (ยง @ioBuff.be(len++, (byte \space)))                ;; draw composing char on top of a space
            )
            ((ร len +=) (ยง utf_char2bytes(c, @ioBuff.plus(len))))
            (vim_snprintf (.plus @ioBuff len), (- IOSIZE len), (if (< c 0x10000) (u8 "> %d, Hex %04x, Octal %o") (u8 "> %d, Hex %08x, Octal %o")), c, c, c)
            (if (== ci MAX_MCO)
                (ร BREAK)
            )
            ((ร c =) (ยง cc[ci++]))
        )

        (msg @ioBuff)
    ))

;; Get the length of the current line, excluding trailing white space.

(defn- #_int linelen [#_boolean* has_tab]
    (ยง
        ;; find the first non-blank character
        ((ร Bytes line =) (ml_get_curline))
        ((ร Bytes first =) (skipwhite line))

        ;; find the character after the last non-blank character
        (ร Bytes last)
        ((ร FOR) (ร (ยง last = first.plus(STRLEN(first))) (ยง BLT(first, last) && vim_iswhite(last.at(-1))) (ยง last = last.minus(1)))
            ;
        )

        ((ร byte save =) (ยง last.at(0)))
        (.be last 0, NUL)
        ((ร int len =) (linetabsize line))        ;; get line length
        (if (non-nil? has_tab)                ;; check for embedded TAB
            ((ร has_tab[0] =) (ยง (vim_strrchr(first, TAB) != null)))
        )
        (.be last 0, save)

        len
    ))

;; ":retab".

(defn- #_void ex_retab [#_exarg_C eap]
    (ยง
        ((ร boolean got_tab =) false)
        ((ร int num_spaces =) 0)
        ((ร int start_col =) 0)                          ;; for start of white-space string
        ((ร int start_vcol =) 0)                         ;; for start of white-space string
        ((ร long first_line =) 0)                        ;; first changed line
        ((ร long last_line =) 0)                         ;; last changed line

        (ร int new_ts)
;       { Bytes[] __ = { eap.arg }; new_ts = (int)getdigits(__); eap.arg = __[0]; }
        (when (< new_ts 0)
            (emsg e_positive)
            (ร RETURN)
        )
        (if (zero? new_ts)
            ((ร new_ts =) (ยง (int)@curbuf.@b_p_ts))
        )

;       loop:
        ((ร FOR) (ร (ยง long lnum = eap.line1) (ยง !@got_int && lnum <= eap.line2) (ยง lnum++))
            ((ร Bytes ptr =) (ml_get lnum))
            ((ร int col =) 0)
            ((ร int vcol =) 0)
            ((ร boolean did_undo =) false)           ;; called u_save() for current line
            (while true
                (cond (vim_iswhite (ยง ptr.at(col)))
                (ยง
                    (when (and (not got_tab) (zero? num_spaces))
                        ;; First consecutive white-space.
                        ((ร start_vcol =) vcol)
                        ((ร start_col =) col)
                    )
                    (if (== (.at ptr col) (byte \space))
                        (ยง num_spaces++)
                        ((ร got_tab =) true)
                    )
                )
                :else
                (ยง
                    (when (or got_tab (and (. eap forceit) (< 1 num_spaces)))
                        ;; Retabulate this string of white-space.

                        ;; len is virtual length of white string
                        ((ร int len =) (ยง num_spaces = vcol - start_vcol))
                        ((ร int num_tabs =) 0)
                        (when (not @(. @curbuf b_p_et))
                            ((ร int temp =) (ยง new_ts - (start_vcol % new_ts)))
                            (when (<= temp num_spaces)
                                ((ร num_spaces -=) temp)
                                (ยง num_tabs++)
                            )
                            ((ร num_tabs +=) (/ num_spaces new_ts))
                            ((ร num_spaces -=) (ยง (num_spaces / new_ts) * new_ts))
                        )
                        (when (or @(. @curbuf b_p_et) got_tab (< (+ num_spaces num_tabs) len))
                            (when (not did_undo)
                                ((ร did_undo =) true)
                                (if (not (u_save (- lnum 1), (+ lnum 1)))
                                    (ร BREAK loop)        ;; out-of-memory ???
                                )
                            )

                            ;; len is actual number of white characters used
                            ((ร len =) (+ num_spaces num_tabs))
                            ((ร int old_len =) (STRLEN ptr))
                            ((ร Bytes new_line =) (ยง new Bytes(old_len - col + start_col + len + 1)))

                            (if (< 0 start_col)
                                (BCOPY new_line, ptr, start_col))
                            (BCOPY new_line, (+ start_col len), ptr, col, (ยง old_len - col + 1))
                            ((ร ptr =) (ยง new_line.plus(start_col)))
                            ((ร FOR) (ร (ยง col = 0) (< col len) (ยง col++))
                                (.be ptr col, (if (< col num_tabs) (byte \tab) (byte \space)))
                            )
                            (ml_replace lnum, new_line)
                            (if (zero? first_line)
                                ((ร first_line =) lnum)
                            )
                            ((ร last_line =) lnum)
                            ((ร ptr =) new_line)
                            ((ร col =) (+ start_col len))
                        )
                    )
                    ((ร got_tab =) false)
                    ((ร num_spaces =) 0)
                ))
                (if (eos? ptr col)
                    (ร BREAK)
                )
                ((ร vcol +=) (ยง chartabsize(ptr.plus(col), vcol)))
                ((ร col +=) (ยง us_ptr2len_cc(ptr.plus(col))))
            )
            (line_breakcheck)
        )
        (if @got_int
            (emsg e_interr))

        (if (!= @(. @curbuf b_p_ts) new_ts)
            (redraw_curbuf_later NOT_VALID))
        (if (non-zero? first_line)
            (changed_lines first_line, 0, (+ last_line 1), 0))

        ((ร @curbuf.@b_p_ts =) new_ts)
        (coladvance (. @curwin w_curswant))

        (u_clearline)
    ))

;; Implementation of ":fixdel", also used by get_stty().
;;  <BS>    resulting <Del>
;;   ^?         ^H
;; not ^?       ^?

(defn- #_void ex_fixdel [#_exarg_C _eap]
    (ยง
        ((ร Bytes p =) (find_termcode (u8 "kb")))
        (add_termcode (u8 "kD"), (if (and (non-nil? p) (== (.at p 0) DEL)) CTRL_H_STR DEL_STR))
    ))

(atom! Bytes old_sub)              ;; previous substitute pattern

(atom! boolean do__all)                 ;; do multiple substitutions per line
(atom! boolean do__count)               ;; count only
(atom! boolean do__error true)        ;; if false, ignore errors
(atom! int do__ic)                      ;; ignore case flag

;; Perform a substitution from line eap.line1 to line eap.line2 using
;; the command pointed to by eap.arg which should be of the form:
;;
;; /pattern/substitution/{flags}
;;
;; The usual escapes are supported as described in the regexp docs.

(defn- #_void ex_sub [#_exarg_C eap]
    (ยง
        ((ร long i =) 0)

        ((ร Bytes pat =) (ยง null, sub = null))
        ((ร boolean got_quit =) false)
        ((ร boolean got_match =) false)
        ((ร long first_line =) 0)                        ;; first changed line
;       long last_line= 0;                          ;; below last changed line AFTER the change
        ((ร long old_line_count =) (.. @curbuf b_ml ml_line_count))
        ((ร boolean endcolumn =) false)                  ;; cursor in last column when done
        ((ร pos_C old_cursor =) (ยง ยง_pos_C()))
        (COPY_pos old_cursor, (. @curwin w_cursor))

        ((ร Bytes cmd =) (. eap arg))

        (reset! sub_nsubs 0)
        (reset! sub_nlines 0)

        ((ร long start_nsubs =) @sub_nsubs)

        (ร int which_pat)
        (if (== (. eap cmdidx) (ยง CMD_tilde))
            ((ร which_pat =) RE_LAST)            ;; use last used regexp
            ((ร which_pat =) RE_SUBST)           ;; use last substitute regexp
        )

                                                ;; new pattern and substitution
        (cond (and (== (ยง eap.cmd.at(0)) (byte \s)) (non-eos? cmd) (not (vim_iswhite (ยง cmd.at(0)))) (nil? (vim_strbyte (u8 "0123456789cegriIp|\""), (.at cmd 0))))
        (ยง
            (when (asc_isalpha (ยง cmd.at(0)))         ;; don't accept alphanumeric for separator
                (emsg (u8 "E146: Regular expressions can't be delimited by letters"))
                (ร RETURN)
            )

            (ร byte delimiter)

            ;; undocumented vi feature:
            ;;  "\/sub/" and "\?sub?" use last used search pattern (almost like //sub/r).
            ;; "\&sub&" use last substitute pattern (like //sub/).

            (cond (== (.at cmd 0) (byte \\))
            (ยง
                ((ร cmd =) (ยง cmd.plus(1)))
                (when (nil? (vim_strbyte (u8 "/?&"), (.at cmd 0)))
                    (emsg e_backslash)
                    (ร RETURN)
                )
                (if (!= (.at cmd 0) (byte \&))
                    ((ร which_pat =) RE_SEARCH)      ;; use last '/' pattern
                )
                ((ร pat =) (u8 ""))                       ;; empty search pattern
                ((ร delimiter =) (ยง (cmd = cmd.plus(1)).at(-1)))             ;; remember delimiter character
            )
            :else            ;; find the end of the regexp
            (ยง
                ((ร which_pat =) RE_LAST)            ;; use last used regexp
                ((ร delimiter =) (ยง (cmd = cmd.plus(1)).at(-1)))             ;; remember delimiter character
                ((ร pat =) cmd)                      ;; remember start of search pattern
;               { Bytes[] __ = { eap.arg }; cmd = skip_regexp(cmd, delimiter, @p_magic, __); eap.arg = __[0]; }
                (if (== (.at cmd 0) delimiter)        ;; end delimiter found
                    (ยง (cmd = cmd.plus(1)).be(-1, NUL))               ;; replace it with a NUL
                )
            ))

            ;; Small incompatibility: vi sees '\n' as end of the command, but in
            ;; Vim we want to use '\n' to find/substitute a NUL.

            ((ร sub =) cmd)          ;; remember the start of the substitution

            (while (ยง cmd.at(0) != NUL)
                (when (== (.at cmd 0) delimiter)            ;; end delimiter found
                    (ยง (cmd = cmd.plus(1)).be(-1, NUL))                   ;; replace it with a NUL
                    (ร BREAK)
                )
                (if (and (== (.at cmd 0) (byte \\)) (non-eos? cmd 1))  ;; skip escaped characters
                    ((ร cmd =) (ยง cmd.plus(1)))
                )
                ((ร cmd =) (ยง cmd.plus(us_ptr2len_cc(cmd))))
            )

            (when (not (. eap skip))
                ;; In POSIX vi ":s/pat/%/" uses the previous subst. string.
                (cond (and (zero? (ยง STRCMP(sub, (u8 "%")))) (non-nil? (vim_strbyte @p_cpo, CPO_SUBPERCENT)))
                (ยง
                    (when (nil? @old_sub)    ;; there is no previous command
                        (emsg e_nopresub)
                        (ร RETURN)
                    )
                    ((ร sub =) @old_sub)
                )
                :else
                (ยง
                    (reset! old_sub (STRDUP sub))
                ))
            )
        )
        (not (. eap skip))         ;; use previous pattern and substitution
        (ยง
            (when (nil? @old_sub)    ;; there is no previous command
                (emsg e_nopresub)
                (ร RETURN)
            )
            ((ร pat =) null)             ;; search_regcomp() will use previous pattern
            ((ร sub =) @old_sub)

            ;; Vi compatibility quirk:
            ;; repeating with ":s" keeps the cursor in the last column after using "$".
            ((ร endcolumn =) (ยง (@curwin.w_curswant == MAXCOL)))
        ))

        ;; Recognize ":%s/\n//" and turn it into a join command, which is much more efficient.
        ;; TODO: find a generic solution to make line-joining operations more
        ;; efficient, avoid allocating a string that grows in size.

        (when (and (non-nil? pat) (zero? (ยง STRCMP(pat, (u8 "\\n")))) (eos? sub) (or (eos? cmd) (and (eos? cmd 1) (== (.at cmd 0) (byte \g)))))
            ((ร @curwin.w_cursor.lnum =) (. eap line1))

            ;; The number of lines joined is the number of lines in the range plus one.
            ;; One less when the last line is included.
            ((ร int joined_lines_count =) (ยง (int)(eap.line2 - eap.line1 + 1)))
            (if (< (. eap line2) (.. @curbuf b_ml ml_line_count))
                (ยง joined_lines_count++)
            )
            (when (< 1 joined_lines_count)
                (do_join joined_lines_count, false, true, false, true)
                (reset! sub_nsubs (- joined_lines_count 1))
                (reset! sub_nlines 1)
                (do_sub_msg false)
            )

            (save_re_pat RE_SUBST, pat, @p_magic)
            ;; put pattern in history
            (add_to_history HIST_SEARCH, pat, NUL)

            (ร RETURN)
        )

        ;; Find trailing options.  When '&' is used, keep old options.

        (cond (== (.at cmd 0) (byte \&))
        (ยง
            ((ร cmd =) (ยง cmd.plus(1)))
        )
        :else
        (ยง
            (reset! do__all @p_gd)         ;; default is global on
            (reset! do__error true)
            (reset! do__count false)
            (reset! do__ic 0)
        ))
        (while (ยง cmd.at(0) != NUL)
            ;; Note that 'g' and 'c' are always inverted.
            ;; 'r' is never inverted.

            (cond (== (.at cmd 0) (byte \g))
            (ยง
                (reset! do__all (not @do__all))
            )
            (== (.at cmd 0) (byte \n))
            (ยง
                (reset! do__count true)
            )
            (== (.at cmd 0) (byte \e))
            (ยง
                (reset! do__error (not @do__error))
            )
            (== (.at cmd 0) (byte \r))       ;; use last used regexp
            (ยง
                ((ร which_pat =) RE_LAST)
            )
            (== (.at cmd 0) (byte \i))       ;; ignore case
            (ยง
                (reset! do__ic (byte \i))
            )
            (== (.at cmd 0) (byte \I))       ;; don't ignore case
            (ยง
                (reset! do__ic (byte \I))
            )
            :else
            (ยง
                (ร BREAK)
            ))
            ((ร cmd =) (ยง cmd.plus(1)))
        )

        ;; check for a trailing count

        ((ร cmd =) (skipwhite cmd))
        (when (asc_isdigit (ยง cmd.at(0)))
;           { Bytes[] __ = { cmd }; i = getdigits(__); cmd = __[0]; }
            (when (and (<= i 0) (not (. eap skip)) @do__error)
                (emsg e_zerocount)
                (ร RETURN)
            )
            ((ร eap.line1 =) (. eap line2))
            ((ร eap.line2 +=) (- i 1))
            (if (> (. eap line2) (.. @curbuf b_ml ml_line_count))
                ((ร eap.line2 =) (.. @curbuf b_ml ml_line_count))
            )
        )

        ;; check for trailing command or garbage

        ((ร cmd =) (skipwhite cmd))
        (when (and (non-eos? cmd) (!= (.at cmd 0) (byte \")))        ;; if not end-of-line or comment """
            ((ร eap.nextcmd =) (check_nextcmd cmd))
            (when (nil? (. eap nextcmd))
                (emsg e_trailing)
                (ร RETURN)
            )
        )

        (if (. eap skip)       ;; not executing commands, only parsing
            (ร RETURN)
        )

        ((ร regmmatch_C regmatch =) (ยง ยง_regmmatch_C()))
        (when (not (search_regcomp pat, RE_SUBST, which_pat, SEARCH_HIS, regmatch))
            (if @do__error
                (emsg e_invcmd))
            (ร RETURN)
        )

        ;; the 'i' or 'I' flag overrules 'ignorecase' and 'smartcase'
        (cond (== @do__ic (byte \i))
        (ยง
            ((ร regmatch.rmm_ic =) true)
        )
        (== @do__ic (byte \I))
        (ยง
            ((ร regmatch.rmm_ic =) false)
        ))

        ((ร Bytes sub_firstline =) null)        ;; allocated copy of first sub line

        ;; ~ in the substitute pattern is replaced with the old pattern.
        ;; We do it here once to avoid it to be replaced over and over again.
        ;; But don't do it when it starts with "\=", then it's an expression.

        (if (not (and (== (.at sub 0) (byte \\)) (== (.at sub 1) (byte \=))))
            ((ร sub =) (regtilde sub, @p_magic))
        )

        ;; Check for a match on each line.

        ((ร long line2 =) (. eap line2))
        ((ร FOR) (ร (ยง long lnum = eap.line1) (ยง lnum <= line2 && !(got_quit || @got_int)) (ยง lnum++))
            ((ร long nmatch =) (vim_regexec_multi regmatch, @curwin, @curbuf, lnum, 0, null))
            (when (non-zero? nmatch)                        ;; number of lines in match
                ;; The new text is build up step by step, to avoid too much copying.
                ;; There are these pieces:
                ;;
                ;; sub_firstline    The old text, unmodified.
                ;; copycol          Column in the old text where we started looking for a match;
                ;;                  from here old text still needs to be copied to the new text.
                ;; matchcol         Column number of the old text where to look for the next match.
                ;;                  It's just after the previous match or one further.
                ;; prev_matchcol    Column just after the previous match (if any).
                ;;                  Mostly equal to matchcol, except for the first
                ;;                  match and after skipping an empty match.
                ;; regmatch.*pos    Where the pattern matched in the old text.
                ;; new_start        The new text, all that has been produced so far.
                ;; new_end          The new text, where to append new text.
                ;;
                ;; lnum             The line number where we found the start of the match.
                ;;                  Can be below the line we searched when there is a \n
                ;;                  before a \zs in the pattern.
                ;; sub_firstlnum    The line number in the buffer where to look for a match.
                ;;                  Can be different from "lnum" when the pattern or substitute
                ;;                  string contains line breaks.
                ;;
                ;; Special situations:
                ;; - When the substitute string contains a line break, the part up to the line
                ;;   break is inserted in the text, but the copy of the original line is kept.
                ;;   "sub_firstlnum" is adjusted for the inserted lines.
                ;; - When the matched pattern contains a line break, the old line is taken from
                ;;   the line at the end of the pattern.  The lines in the match are deleted
                ;;   later, "sub_firstlnum" is adjusted accordingly.
                ;;
                ;; The new text is built up in new_start[].  It has some extra room to avoid
                ;; using calloc()/free() too often.  new_start_len is the length of the allocated
                ;; memory at new_start.
                ;;
                ;; Make a copy of the old line, so it won't be taken away when updating the screen
                ;; or handling a multi-line match.  The "old_" pointers point into this copy.

                ((ร int prev_matchcol =) MAXCOL)
                ((ร Bytes new_start =) null)
                ((ร int new_start_len =) 0)
                ((ร boolean did_sub =) false)
                ((ร long nmatch_tl =) 0)                     ;; nr of lines matched below lnum
                ((ร boolean skip_match =) false)

                ((ร long sub_firstlnum =) lnum)              ;; nr of first sub line
                ((ร int copycol =) 0)
                ((ร int matchcol =) 0)

                ;; At first match, remember current cursor position.
                (when (not got_match)
                    (setpcmark)
                    ((ร got_match =) true)
                )

                ;; Loop until nothing more to replace in this line.
                ;; 1. Handle match with empty string.
                ;; 3. Substitute the string.
                ;; 4. If do__all is set, find next match.
                ;; 5. Break if there isn't another match in this line.

                (while true
                    ;; Advance "lnum" to the line where the match starts.
                    ;; The match does not start in the first line when there is a line break before \zs.
                    (when (< 0 (ยง regmatch.startpos[0].lnum))
                        ((ร lnum +=) (ยง regmatch.startpos[0].lnum))
                        ((ร sub_firstlnum +=) (ยง regmatch.startpos[0].lnum))
                        ((ร nmatch -=) (ยง regmatch.startpos[0].lnum))
                        ((ร sub_firstline =) null)
                    )

                    (if (nil? sub_firstline)
                        ((ร sub_firstline =) (ยง STRDUP(ml_get(sub_firstlnum))))
                    )

                    ;; Save the line number of the last change for the final cursor position (just like Vi).
                    ((ร @curwin.w_cursor.lnum =) lnum)
                    ((ร boolean do_again =) false)               ;; do it again after joining lines

;                   skip:
;                   {
                        ;; 1. Match empty string does not count, except for first match.
                        ;; This reproduces the strange vi behaviour.
                        ;; This also catches endless loops.

                        (when (and (== matchcol prev_matchcol) (zero? (ยง regmatch.endpos[0].lnum)) (== matchcol (ยง regmatch.endpos[0].col)))
                            (cond (eos? sub_firstline matchcol)
                            (ยง
                                ;; We already were at the end of the line.
                                ;; Don't look for a match in this line again.
                                ((ร skip_match =) true)
                            )
                            :else
                            (ยง
                                ;; search for a match at next column
                                ((ร matchcol +=) (ยง us_ptr2len_cc(sub_firstline.plus(matchcol))))
                            ))
                            (ร BREAK skip)
                        )

                        ;; Normally we continue searching for a match just after the previous match.
                        ((ร matchcol =) (ยง regmatch.endpos[0].col))
                        ((ร prev_matchcol =) matchcol)

                        ;; 2. If do__count is set only increase the counter.

                        (when @do__count
                            ;; For a multi-line match, put matchcol at the NUL at
                            ;; the end of the line and set nmatch to one, so that
                            ;; we continue looking for a match on the next line.
                            ;; Avoids that ":s/\nB\@=//gc" get stuck.
                            (when (< 1 nmatch)
                                ((ร matchcol =) (STRLEN sub_firstline))
                                ((ร nmatch =) 1)
                                ((ร skip_match =) true)
                            )
                            (swap! sub_nsubs inc)
                            ((ร did_sub =) true)
                            ;; Skip the substitution, unless an expression is used,
                            ;; then it is evaluated in the sandbox.
                            (if (not (and (== (.at sub 0) (byte \\)) (== (.at sub 1) (byte \=))))
                                (ร BREAK skip)
                            )
                        )

                        ;; Move the cursor to the start of the match, so that we can use "\=col(".").
                        ((ร @curwin.w_cursor.col =) (ยง regmatch.startpos[0].col))

                        ;; 3. substitute the string.

                        ;; get length of substitution part
                        ((ร int sublen =) (ยง vim_regsub_multi(regmatch, sub_firstlnum - regmatch.startpos[0].lnum, sub, sub_firstline, false, @p_magic, true)))

                        (if @do__count
                            (ร BREAK skip)
                        )

                        ;; When the match included the "$" of the last line it may
                        ;; go beyond the last line of the buffer.
                        (when (> nmatch (ยง @curbuf.b_ml.ml_line_count - sub_firstlnum + 1))
                            ((ร nmatch =) (ยง @curbuf.b_ml.ml_line_count - sub_firstlnum + 1))
                            ((ร skip_match =) true)
                        )

                        ;; Need room for:
                        ;; - result so far in "new_start" (not for first sub in line)
                        ;; - original text up to match
                        ;; - length of substituted part
                        ;; - original text after match

                        (ร Bytes p1)
                        (cond (== nmatch 1)
                        (ยง
                            ((ร p1 =) sub_firstline)
                        )
                        :else
                        (ยง
                            ((ร p1 =) (ยง ml_get(sub_firstlnum + nmatch - 1)))
                            ((ร nmatch_tl +=) (- nmatch 1))
                        ))
                        ((ร int copy_len =) (ยง regmatch.startpos[0].col - copycol))
                        ((ร int needed_len =) (ยง copy_len + (STRLEN(p1) - regmatch.endpos[0].col) + sublen + 1))
                        (ร Bytes new_end)
                        (cond (nil? new_start)
                        (ยง
                            ;; Get some space for a temporary buffer to do the substitution into
                            ;; (and some extra space to avoid too many calls to calloc()/free()).

                            ((ร new_start_len =) (+ needed_len 50))
                            ((ร new_start =) (ยง new Bytes(new_start_len)))
                            (.be new_start 0, NUL)
                            ((ร new_end =) new_start)
                        )
                        :else
                        (ยง
                            ;; Check if the temporary buffer is long enough to do the
                            ;; substitution into.  If not, make it larger (with a bit
                            ;; extra to avoid too many calls to calloc()/free()).

                            ((ร int len =) (STRLEN new_start))
                            ((ร needed_len +=) len)
                            (when (< new_start_len needed_len)
                                ((ร new_start_len =) (+ needed_len 50))
                                ((ร p1 =) (ยง new Bytes(new_start_len)))
                                (BCOPY p1, new_start, (+ len 1))
                                ((ร new_start =) p1)
                            )
                            ((ร new_end =) (ยง new_start.plus(len)))
                        ))

                        ;; copy the text up to the part that matched

                        (BCOPY new_end, 0, sub_firstline, copycol, copy_len)
                        ((ร new_end =) (ยง new_end.plus(copy_len)))

                        (vim_regsub_multi regmatch, (- sub_firstlnum (ยง regmatch.startpos[0].lnum)), sub, new_end, true, @p_magic, true)

                        (swap! sub_nsubs inc)
                        ((ร did_sub =) true)

                        ;; Move the cursor to the start of the line, to avoid that
                        ;; it is beyond the end of the line after the substitution.
                        ((ร @curwin.w_cursor.col =) 0)

                        ;; For a multi-line match, make a copy of the last matched
                        ;; line and continue in that one.
                        (when (< 1 nmatch)
                            ((ร sub_firstlnum +=) (- nmatch 1))
                            ((ร sub_firstline =) (ยง STRDUP(ml_get(sub_firstlnum))))
                            ;; When going beyond the last line, stop substituting.
                            (if (<= sub_firstlnum line2)
                                ((ร do_again =) true)
                                (reset! do__all false))
                        )

                        ;; Remember next character to be copied.
                        ((ร copycol =) (ยง regmatch.endpos[0].col))

                        (when skip_match
                            ;; Already hit end of the buffer,
                            ;; sub_firstlnum is one less than what it ought to be.
                            ((ร sub_firstline =) (STRDUP (u8 "")))
                            ((ร copycol =) 0)
                        )

                        ;; Now the trick is to replace CTRL-M chars with a real line break.
                        ;; This would make it impossible to insert a CTRL-M in the text.
                        ;; The line break can be avoided by preceding the CTRL-M with a backslash.
                        ;; To be able to insert a backslash, they must be doubled in the string
                        ;; and are halved here.
                        ;; That is Vi compatible.

                        ((ร FOR) (ร (ยง p1 = new_end) (ยง p1.at(0) != NUL) (ยง p1 = p1.plus(1)))
                            (cond (and (== (.at p1 0) (byte \\)) (non-eos? p1 1))  ;; remove backslash
                            (ยง
                                (BCOPY p1, 0, p1, 1, (+ (STRLEN p1, 1) 1))
                            )
                            (== (.at p1 0) CAR)
                            (ยง
                                (when (u_inssub lnum)     ;; prepare for undo
                                    (.be p1 0, NUL)                  ;; truncate up to the CR
                                    (ml_append (- lnum 1), new_start)
                                    (mark_adjust (+ lnum 1), MAXLNUM, 1, 0)

                                    (if (zero? first_line)
                                        ((ร first_line =) lnum)
                                    )
                                    ((ร last_line =) (+ lnum 1))

                                    ;; All line numbers increase.
                                    (ยง sub_firstlnum++)
                                    (ยง lnum++)
                                    (ยง line2++)
                                    ;; move the cursor to the new line, like Vi
                                    (ยง @curwin.w_cursor.lnum++)
                                    ;; copy the rest
                                    (BCOPY new_start, 0, p1, 1, (+ (STRLEN p1, 1) 1))
                                    ((ร p1 =) (ยง new_start.minus(1)))
                                )
                            )
                            :else
                            (ยง
                                ((ร p1 =) (ยง p1.plus(us_ptr2len_cc(p1) - 1)))
                            ))
                        )
;                   }

                    ;; 4. If do__all is set, find next match.
                    ;; Prevent endless loop with patterns that match empty
                    ;; strings, e.g. :s/$/pat/g or :s/[a-z]* /(&)/g.
                    ;; But ":s/\n/#/" is OK.

                    ;; We already know that we did the last subst when we are at the end of the line,
                    ;; except that a pattern like "bar\|\nfoo" may match at the NUL.
                    ;; "lnum" can be below "line2" when there is a \zs in the pattern after a line break.

                    ((ร boolean lastone =) (ยง (skip_match || @got_int || got_quit || line2 < lnum || !(@do__all || do_again) || (sub_firstline.at(matchcol) == NUL && nmatch <= 1 && !re_multiline(regmatch.regprog)))))
                    ((ร nmatch =) -1)

                    ;; Replace the line in the buffer when needed.
                    ;; This is skipped when there are more matches.
                    ;; The check for nmatch_tl is needed for when multi-line matching must replace
                    ;; the lines before trying to do another match, otherwise "\@<=" won't work.
                    ;; When the match starts below where we start searching
                    ;; also need to replace the line first (using \zs after \n).

                    (when (or lastone (< 0 nmatch_tl) (zero? (ยง nmatch = vim_regexec_multi(regmatch, @curwin, @curbuf, sub_firstlnum, matchcol, null))) (< 0 (ยง regmatch.startpos[0].lnum)))
                        (when (non-nil? new_start)
                            ;; Copy the rest of the line, that didn't match.
                            ;; "matchcol" has to be adjusted, we use the end of the line as reference,
                            ;; because the substitute may have changed the number of characters.
                            ;; Same for "prev_matchcol".

                            (STRCAT new_start, (.plus sub_firstline copycol))
                            ((ร matchcol =) (ยง STRLEN(sub_firstline) - matchcol))
                            ((ร prev_matchcol =) (ยง STRLEN(sub_firstline) - prev_matchcol))

                            (if (!= (u_savesub lnum) true)
                                (ร BREAK)
                            )
                            (ml_replace lnum, new_start)

                            (when (< 0 nmatch_tl)
                                ;; Matched lines have now been substituted and are useless, delete them.
                                ;; The part after the match has been appended to "new_start", we don't need
                                ;; it in the buffer.

                                (ยง lnum++)
                                (if (not (u_savedel lnum, nmatch_tl))
                                    (ร BREAK)
                                )
                                ((ร FOR) (ร (ยง i = 0) (< i nmatch_tl) (ยง i++))
                                    (ml_delete lnum, false)
                                )
                                (mark_adjust lnum, (ยง lnum + nmatch_tl - 1), MAXLNUM, (- nmatch_tl))
                                (ยง --lnum)
                                ((ร line2 -=) nmatch_tl) ;; nr of lines decreases
                                ((ร nmatch_tl =) 0)
                            )

                            (if (zero? first_line)
                                ((ร first_line =) lnum)
                            )
                            ((ร last_line =) (+ lnum 1))

                            ((ร sub_firstlnum =) lnum)
                            ((ร sub_firstline =) new_start)
                            ((ร new_start =) null)
                            ((ร matchcol =) (ยง STRLEN(sub_firstline) - matchcol))
                            ((ร prev_matchcol =) (ยง STRLEN(sub_firstline) - prev_matchcol))
                            ((ร copycol =) 0)
                        )
                        (if (and (== nmatch -1) (not lastone))
                            ((ร nmatch =) (vim_regexec_multi regmatch, @curwin, @curbuf, sub_firstlnum, matchcol, null))
                        )

                        ;; 5. break if there isn't another match in this line

                        (when (<= nmatch 0)
                            ;; If the match found didn't start where we were
                            ;; searching, do the next search in the line where we
                            ;; found the match.
                            (if (== nmatch -1)
                                ((ร lnum -=) (ยง regmatch.startpos[0].lnum))
                            )
                            (ร BREAK)
                        )
                    )

                    (line_breakcheck)
                )

                (if did_sub
                    (swap! sub_nlines inc))
                ((ร sub_firstline =) null)
            )

            (line_breakcheck)
        )

        (when (non-zero? first_line)
            ;; Need to subtract the number of added lines from "last_line" to get
            ;; the line number before the change (same as adding the number of deleted lines).

            ((ร i =) (ยง @curbuf.b_ml.ml_line_count - old_line_count))
            (changed_lines first_line, 0, (- last_line i), i)
        )

        ;; ":s/pat//n" doesn't move the cursor
        (if @do__count
            (COPY_pos (. @curwin w_cursor), old_cursor))

        (cond (< start_nsubs @sub_nsubs)
        (ยง
            ;; Set the '[ and '] marks.
            ((ร @curbuf.b_op_start.lnum =) (. eap line1))
            ((ร @curbuf.b_op_end.lnum =) line2)
            ((ร @curbuf.b_op_start.col =) (ยง @curbuf.b_op_end.col = 0))

            (if endcolumn
                (coladvance MAXCOL)
                (beginline (| BL_WHITE BL_FIX)))

            (do_sub_msg @do__count)
        )
        :else
        (ยง
            (cond @got_int                ;; interrupted
            (ยง
                (emsg e_interr)
            )
            got_match         ;; did find something but nothing substituted
            (ยง
                (msg (u8 ""))
            )
            @do__error         ;; nothing found
            (ยง
                (emsg2 e_patnotf2, (get_search_pat))
            ))
        ))
    ))

;; Give message for number of substitutions.
;; Return true if a message was given.

(defn- #_boolean do_sub_msg [#_boolean count_only]
    ;; count_only: used 'n' flag for ":s"
    (ยง
        ;; Only report substitutions when:
        ;; - more than 'report' substitutions
        ;; - command was typed by user, or number of changed lines > 'report'
        ;; - giving messages is not disabled by 'lazyredraw'

        (when (and (or (and (< @p_report @sub_nsubs) (or @keyTyped (< 1 @sub_nlines) (< @p_report 1))) count_only) (messaging))
            ((ร Bytes msg_buf =) (ยง new Bytes(MSG_BUF_LEN)))
            (if @got_int
                (STRCPY msg_buf, (u8 "(Interrupted) "))
                (.be msg_buf 0, NUL)
            )
            (if (== @sub_nsubs 1)
                (vim_snprintf_add msg_buf, MSG_BUF_LEN, (u8 "%s"), (if count_only (u8 "1 match") (u8 "1 substitution")))
                (vim_snprintf_add msg_buf, MSG_BUF_LEN, (if count_only (u8 "%ld matches") (u8 "%ld substitutions")), @sub_nsubs)
            )
            (if (== @sub_nlines 1)
                (vim_snprintf_add msg_buf, MSG_BUF_LEN, (u8 "%s"), (u8 " on 1 line"))
                (vim_snprintf_add msg_buf, MSG_BUF_LEN, (u8 " on %ld lines"), @sub_nlines)
            )
            (when (msg msg_buf)
                ;; save message to display it after redraw
                (set_keep_msg msg_buf, 0)
            )
            ((ร RETURN) true)
        )
        (when @got_int
            (emsg e_interr)
            ((ร RETURN) true)
        )
        false
    ))

;; ex_getln.c: Functions for entering and editing an Ex command line ------------------------------

;; Variables shared between getcmdline(), redrawcmdline() and others.
;; These need to be saved when using CTRL-R |, that's why they are in a structure.

(class! #_final cmdline_info_C
    [
        (field Bytes        cmdbuff)        ;; pointer to command line buffer
        (field int          cmdbufflen)     ;; length of "cmdbuff"
        (field int          cmdlen)         ;; number of chars in command line
        (field int          cmdpos)         ;; current cursor position
        (field int          cmdspos)        ;; cursor column on screen
        (field int          cmdfirstc)      ;; ':', '/', '?', '=' or NUL
        (field int          cmdindent)      ;; number of spaces before cmdline
        (field Bytes        cmdprompt)      ;; message in front of cmdline
        (field int          cmdattr)        ;; attributes for prompt
        (field boolean      overstrike)     ;; Typing mode on the command line.  Shared by getcmdline() and put_on_cmdline().
    ])

(defn- #_void COPY_cmdline_info [#_cmdline_info_C cli1, #_cmdline_info_C cli0]
    (ยง
        ((ร cli1.cmdbuff =) (. cli0 cmdbuff))
        ((ร cli1.cmdbufflen =) (. cli0 cmdbufflen))
        ((ร cli1.cmdlen =) (. cli0 cmdlen))
        ((ร cli1.cmdpos =) (. cli0 cmdpos))
        ((ร cli1.cmdspos =) (. cli0 cmdspos))
        ((ร cli1.cmdfirstc =) (. cli0 cmdfirstc))
        ((ร cli1.cmdindent =) (. cli0 cmdindent))
        ((ร cli1.cmdprompt =) (. cli0 cmdprompt))
        ((ร cli1.cmdattr =) (. cli0 cmdattr))
        ((ร cli1.overstrike =) (. cli0 overstrike))
    ))

;; The current cmdline_info.  It is initialized in getcmdline() and after that
;; used by other functions.  When invoking getcmdline() recursively it needs
;; to be saved with save_cmdline() and restored with restore_cmdline().
;; TODO: make it local to getcmdline() and pass it around.

(atom! cmdline_info_C ccline    (ยง_cmdline_info_C))

(atom! int new_cmdpos)  ;; position set by set_cmdline_pos()

(class! #_final histentry_C
    [
        (field int      hisnum)     ;; identifying number
        (field Bytes    hisstr)     ;; actual entry, separator char after the NUL
    ])

(defn- #_void COPY_histentry [#_histentry_C he1, #_histentry_C he0]
    (ยง
        ((ร he1.hisnum =) (. he0 hisnum))
        ((ร he1.hisstr =) (. he0 hisstr))
    ))

(defn- #_histentry_C* ARRAY_histentry [#_int n]
    (vec (repeatedly n ยง_histentry_C)))

(atom! histentry_C**    history     HIST_COUNT)
(atom! int*             hisidx      (repeat HIST_COUNT -1))     ;; last used entry
;; identifying (unique) number of newest history entry
(atom! int*             hisnum      HIST_COUNT)
(atom! int              hislen)                                 ;; actual length of history tables

;; getcmdline() - accept a command line starting with firstc.
;;
;; firstc == ':'            get ":" command line.
;; firstc == '/' or '?'     get search pattern
;; firstc == '='            get expression
;; firstc == '@'            get text for input() function
;; firstc == '>'            get text for debug mode
;; firstc == NUL            get text for :insert command
;; firstc == -1             like NUL, and break on CTRL-C
;;
;; The line is collected in ccline.cmdbuff, which is reallocated to fit the command line.
;;
;; Careful: getcmdline() can be called recursively!
;;
;; Return pointer to allocated string if there is a commandline, null otherwise.

(defn- #_Bytes getcmdline [#_int firstc, #_long count]
    ;; count: only used for incremental search
    (ยง
        ((ร boolean gotesc =) false)                 ;; true when <ESC> just typed
        ((ร Bytes lookfor =) null)                  ;; string to match
        ((ร boolean did_incsearch =) false)
        ((ร boolean incsearch_postponed =) false)
        ((ร boolean did_wild_list =) false)          ;; did wild_list() recently
        ((ร boolean save_msg_scroll =) @msg_scroll)
        ((ร int save_State =) @State)                 ;; remember State when called
        ((ร boolean some_key_typed =) false)         ;; one of the keys was typed

        ((ร boolean break_ctrl_c =) false)

        ;; Everything that may work recursively should save and restore the current command line in save_cli.
        ;; That includes update_screen(), a custom status line may invoke ":normal".

        ((ร cmdline_info_C save_cli =) (ยง ยง_cmdline_info_C()))

        (when (== firstc -1)
            ((ร firstc =) NUL)
            ((ร break_ctrl_c =) true)
        )

        ((ร @ccline.overstrike =) false)                  ;; always start in insert mode
        ((ร pos_C old_cursor =) (ยง ยง_pos_C()))
        (COPY_pos old_cursor, (. @curwin w_cursor))      ;; needs to be restored later
        ((ร int old_curswant =) (. @curwin w_curswant))
        ((ร int old_leftcol =) (. @curwin w_leftcol))
        ((ร long old_topline =) (. @curwin w_topline))
        ((ร long old_botline =) (. @curwin w_botline))

        ;; set some variables for redrawcmd()

        ((ร @ccline.cmdfirstc =) (if (== firstc (byte \@)) 0 firstc))
        ((ร @ccline.cmdindent =) 0)

        ;; alloc initial ccline.cmdbuff
        (alloc_cmdbuff 1)
        ((ร @ccline.cmdlen =) (ยง @ccline.cmdpos = 0))
        (.be (. @ccline cmdbuff) 0, NUL)

        ;; autoindent for :insert and :append
        (when (<= firstc 0)
;           copy_spaces(@ccline.cmdbuff, 0);
            (.be (. @ccline cmdbuff) 0, NUL)
            ((ร @ccline.cmdpos =) 0)
            ((ร @ccline.cmdspos =) 0)
            ((ร @ccline.cmdlen =) 0)
        )

;       {
            ((ร int i =) @msg_scrolled)
            (reset! msg_scrolled 0)               ;; avoid wait_return message
            (gotocmdline true)
            ((ร @msg_scrolled +=) i)
            (redrawcmdprompt)
            (set_cmdspos)
;       }

        ;; Avoid scrolling when called by a recursive do_cmdline(),
        ;; e.g. when doing ":@0" when register 0 doesn't contain a CR.

        (reset! msg_scroll false)

        (reset! State CMDLINE)

        (ui_cursor_shape)          ;; may show different cursor shape

        ;; When inside an autocommand for writing "exiting" may be set and terminal mode set to cooked.
        ;; Need to set raw mode here then.
        (settmode TMODE_RAW)

        (init_history)
        ((ร int hiscnt =) @hislen)        ;; current history line in use; set to impossible history value
        ((ร int histype =) (hist_char2type firstc))   ;; history type to be used

        (do_digraph -1)             ;; init digraph typeahead

        ;; If something above caused an error, reset the flags, we do want to type and execute commands.
        ;; Display may be messed up a bit.
        (if @did_emsg
            (redrawcmd))
        (reset! did_emsg false)
        (reset! got_int false)

        ;; Collect the command string, handling editing keys.

;       returncmd:
        (while true
            (reset! quit_more false)  ;; reset after CTRL-D which had a more-prompt

            (cursorcmd)        ;; set the cursor on the right spot

            ;; Get a character.
            ;; Ignore K_IGNORE, it should not do anything, such as stop completion.
            (ร int c)
;           do
;           {
                ((ร c =) (safe_vgetc))
;           } while (c == K_IGNORE);

            (when @keyTyped
                ((ร some_key_typed =) true)
            )

            ;; Ignore got_int when CTRL-C was typed here.
            ;; Don't ignore it in :global, we really need to break then,
            ;; e.g. for ":g/pat/normal /pat" (without the <CR>).
            ;; Don't ignore it for the input() function.

            (when (and (or (== c Ctrl_C) (== c @intr_char)) (!= firstc (byte \@)) (not break_ctrl_c))
                (reset! got_int false)
            )

            ;; free old command line when finished moving around in the history list
            (when (and (non-nil? lookfor) (!= c K_S_DOWN) (!= c K_S_UP) (!= c K_DOWN) (!= c K_UP) (!= c K_PAGEDOWN) (!= c K_PAGEUP) (!= c K_KPAGEDOWN) (!= c K_KPAGEUP) (!= c K_LEFT) (!= c K_RIGHT) (!= c Ctrl_P) (!= c Ctrl_N))
                ((ร lookfor =) null)
            )

;           cmdline_changed:
;           {
;               cmdline_not_changed:
;               {
                    ;; CTRL-\ CTRL-N goes to Normal mode,
                    ;; CTRL-\ CTRL-G goes to Insert mode when 'insertmode' is set,
                    ;; CTRL-\ e prompts for an expression.
                    (when (== c Ctrl_BSL)
                        (swap! no_mapping inc)
                        (swap! allow_keys inc)
                        ((ร c =) (plain_vgetc))
                        (swap! no_mapping dec)
                        (swap! allow_keys dec)
                        ;; CTRL-\ e doesn't work when obtaining an expression, unless it is in a mapping.
                        (cond (and (!= c Ctrl_N) (!= c Ctrl_G) (or (!= c (byte \e)) (and (== (. @ccline cmdfirstc) (byte \=)) @keyTyped)))
                        (ยง
                            (vungetc c)
                            ((ร c =) Ctrl_BSL)
                        )
                        (== c (byte \e))
                        (ยง
                            ;; Replace the command line with the result of an expression.
                            ;; Need to save and restore the current command line, to be
                            ;; able to enter a new one...

                            (if (== (. @ccline cmdpos) (. @ccline cmdlen))
                                (reset! new_cmdpos 99999) ;; keep it at the end
                                (reset! new_cmdpos (. @ccline cmdpos)))

                            (save_cmdline save_cli)
                            ((ร c =) (get_expr_register))
                            (restore_cmdline save_cli)

                            (when (== c (byte \=))
                                ;; Need to save and restore ccline, and set "textlock" to avoid nasty things
                                ;; like going to another buffer when evaluating an expression.
                                (save_cmdline save_cli)
                                (swap! textlock inc)
                                ((ร Bytes p =) (get_expr_line))
                                (swap! textlock dec)
                                (restore_cmdline save_cli)

                                (when (non-nil? p)
                                    ((ร int len =) (STRLEN p))
                                    (realloc_cmdbuff (+ len 1))

                                    ((ร @ccline.cmdlen =) len)
                                    (STRCPY (. @ccline cmdbuff), p)

                                    ;; Restore the cursor or use the position set with set_cmdline_pos().
                                    (if (< (. @ccline cmdlen) @new_cmdpos)
                                        ((ร @ccline.cmdpos =) (. @ccline cmdlen))
                                        ((ร @ccline.cmdpos =) @new_cmdpos)
                                    )

                                    (reset! keyTyped false)   ;; Don't do 'wildchar' completion.
                                    (redrawcmd)
                                    (ร BREAK cmdline_changed)
                                )
                            )

                            (beep_flush)
                            (reset! got_int false)        ;; don't abandon the command line
                            (reset! did_emsg false)
                            (reset! emsg_on_display false)
                            (redrawcmd)
                            (ร BREAK cmdline_not_changed)
                        )
                        :else
                        (ยง
                            (if (and (== c Ctrl_G) @p_im (zero? @restart_edit))
                                (reset! restart_edit (byte \a)))
                            ((ร gotesc =) true)          ;; will free ccline.cmdbuff after putting it in history
                            (ร BREAK returncmd)        ;; back to Normal mode
                        ))
                    )

                    (cond (or (== c @cedit_key) (== c K_CMDWIN))
                    (ยง
                        (when (not @got_int)
                            ;; Open a window to edit the command line (and history).
                            ((ร c =) (ex_window))
                            ((ร some_key_typed =) true)
                        )
                    )
                    :else
                    (ยง
                        ((ร c =) (do_digraph c))
                    ))

                    (when (or (== c (byte \newline)) (== c (byte \return)) (== c K_KENTER) (and (== c ESC) (or (not @keyTyped) (non-nil? (vim_strbyte @p_cpo, CPO_ESC)))))
                        ((ร gotesc =) false)                     ;; Might have typed ESC previously,
                                                            ;; don't truncate the cmdline now.
                        (windgoto @msg_row, 0)
                        (out_flush)
                        (ร BREAK)
                    )

                    ((ร gotesc =) false)

                    (if (or (== c NUL) (== c K_ZERO))        ;; NUL is stored as NL
                        ((ร c =) NL)
                    )

                    ((ร boolean do_abbr =) true)             ;; default: check for abbreviation

                    ;; Big switch for a typed command line character.

                    ((ร SWITCH) c
                        ((ร CASE) K_BS)
                        ((ร CASE) Ctrl_H)
                        ((ร CASE) K_DEL)
                        ((ร CASE) K_KDEL)
                        ((ร CASE) Ctrl_W)
                        (ยง
                            (if (== c K_KDEL)
                                ((ร c =) K_DEL)
                            )

                            ;; delete current character is the same as backspace on next
                            ;; character, except at end of line

                            (if (and (== c K_DEL) (!= (. @ccline cmdpos) (. @ccline cmdlen)))
                                (ยง @ccline.cmdpos++)
                            )
                            (if (== c K_DEL)
                                ((ร @ccline.cmdpos +=) (ยง us_off_next(@ccline.cmdbuff, @ccline.cmdbuff.plus(@ccline.cmdpos))))
                            )
                            (cond (< 0 (. @ccline cmdpos))
                            (ยง
                                ((ร int j =) (. @ccline cmdpos))
                                ((ร Bytes p =) (ยง us_prevptr(@ccline.cmdbuff, @ccline.cmdbuff.plus(j))))

                                (when (== c Ctrl_W)
                                    (while (ยง BLT(@ccline.cmdbuff, p) && vim_isspace(p.at(0)))
                                        ((ร p =) (ยง us_prevptr(@ccline.cmdbuff, p)))
                                    )
                                    ((ร int i =) (us_get_class p, @curbuf))
                                    (while (ยง BLT(@ccline.cmdbuff, p) && us_get_class(p, @curbuf) == i)
                                        ((ร p =) (ยง us_prevptr(@ccline.cmdbuff, p)))
                                    )
                                    (if (ยง (us_get_class(p, @curbuf)) != i)
                                        ((ร p =) (ยง p.plus(us_ptr2len_cc(p))))
                                    )
                                )

                                ((ร @ccline.cmdpos =) (ยง BDIFF(p, @ccline.cmdbuff)))
                                ((ร @ccline.cmdlen -=) (ยง j - @ccline.cmdpos))
                                ((ร int i =) (. @ccline cmdpos))
                                (while (ยง i < @ccline.cmdlen)
                                    (.be (. @ccline cmdbuff) (ยง i++), (ยง @ccline.cmdbuff.at(j++)))
                                )

                                ;; Truncate at the end, required for multi-byte chars.
                                (.be (. @ccline cmdbuff) (. @ccline cmdlen), NUL)
                                (redrawcmd)
                            )
                            (and (zero? (. @ccline cmdlen)) (!= c Ctrl_W) (nil? (. @ccline cmdprompt)))
                            (ยง
                                ((ร @ccline.cmdbuff =) null)     ;; no commandline to return

                                (reset! msg_col 0)
                                (msg_putchar (byte \space))           ;; delete ':'

                                (reset! redraw_cmdline true)
                                (ร BREAK returncmd)            ;; back to cmd mode
                            ))
                            (ร BREAK cmdline_changed)
                        )

                        ((ร CASE) K_INS)
                        ((ร CASE) K_KINS)
                        (ยง
                            ((ร @ccline.overstrike =) (ยง !@ccline.overstrike))
                            (ui_cursor_shape)              ;; may show different cursor shape
                            (ร BREAK cmdline_not_changed)
                        )

                        ((ร CASE) Ctrl_HAT)
                        (ยง
                            (ร BREAK cmdline_not_changed)
                        )

                        ((ร CASE) Ctrl_U)
                        (ยง
                            ;; delete all characters left of the cursor
                            ((ร int j =) (. @ccline cmdpos))
                            ((ร @ccline.cmdlen -=) j)
                            ((ร int i =) (ยง @ccline.cmdpos = 0))
                            (while (ยง i < @ccline.cmdlen)
                                (.be (. @ccline cmdbuff) (ยง i++), (ยง @ccline.cmdbuff.at(j++)))
                            )
                            ;; Truncate at the end, required for multi-byte chars.
                            (.be (. @ccline cmdbuff) (. @ccline cmdlen), NUL)
                            (redrawcmd)
                            (ร BREAK cmdline_changed)
                        )

                        ((ร CASE) ESC)       ;; get here when ESC typed twice
                        ((ร CASE) Ctrl_C)
                        (ยง
                            ((ร gotesc =) true)              ;; will free ccline.cmdbuff after putting it in history
                            (ร BREAK returncmd)            ;; back to cmd mode
                        )

                        ((ร CASE) Ctrl_R)                    ;; insert register
                        (ยง
                            (putcmdline (byte \"), true)    ;; """
                            (swap! no_mapping inc)
                            ((ร int i =) (ยง c = plain_vgetc()))  ;; CTRL-R <char>
                            (if (== i Ctrl_O)
                                ((ร i =) Ctrl_R)             ;; CTRL-R CTRL-O == CTRL-R CTRL-R
                            )
                            (if (== i Ctrl_R)
                                ((ร c =) (plain_vgetc))      ;; CTRL-R CTRL-R <char>
                            )
                            (swap! no_mapping dec)

                            ;; Insert the result of an expression.
                            ;; Need to save the current command line, to be able to enter a new one...

                            (reset! new_cmdpos -1)
                            (when (== c (byte \=))
                                (cond (== (. @ccline cmdfirstc) (byte \=))    ;; can't do this recursively
                                (ยง
                                    (beep_flush)
                                    ((ร c =) ESC)
                                )
                                :else
                                (ยง
                                    (save_cmdline save_cli)
                                    ((ร c =) (get_expr_register))
                                    (restore_cmdline save_cli)
                                ))
                            )
                            (when (!= c ESC)               ;; use ESC to cancel inserting register
                                (cmdline_paste c, (== i Ctrl_R), false)

                                ;; When there was a serious error abort getting the command line.
                                (when @got_int
                                    ((ร gotesc =) true)      ;; will free ccline.cmdbuff after putting it in history
                                    (ร BREAK returncmd)    ;; back to cmd mode
                                )
                                (reset! keyTyped false)       ;; Don't do 'wildchar' completion.
                                (when (<= 0 @new_cmdpos)
                                    ;; set_cmdline_pos() was used
                                    (if (< (. @ccline cmdlen) @new_cmdpos)
                                        ((ร @ccline.cmdpos =) (. @ccline cmdlen))
                                        ((ร @ccline.cmdpos =) @new_cmdpos)
                                    )
                                )
                            )
                            (redrawcmd)
                            (ร BREAK cmdline_changed)
                        )

                        ((ร CASE) K_RIGHT)
                        ((ร CASE) K_S_RIGHT)
                        ((ร CASE) K_C_RIGHT)
                        (ยง
;                           do
;                           {
                                (if (<= (. @ccline cmdlen) (. @ccline cmdpos))
                                    (ร BREAK)
                                )
                                ((ร int i =) (ยง cmdline_charsize(@ccline.cmdpos)))
                                (if (and @keyTyped (ยง (int)@Columns * (int)@Rows <= @ccline.cmdspos + i))
                                    (ร BREAK)
                                )
                                ((ร @ccline.cmdspos +=) i)
                                ((ร @ccline.cmdpos +=) (ยง us_ptr2len_cc(@ccline.cmdbuff.plus(@ccline.cmdpos))))
;                           }
                            (while (ยง (c == K_S_RIGHT || c == K_C_RIGHT || (@mod_mask & (MOD_MASK_SHIFT|MOD_MASK_CTRL)) != 0) && @ccline.cmdbuff.at(@ccline.cmdpos) != (byte \space))
;                               ;
                            )
                            (set_cmdspos_cursor)
                            (ร BREAK cmdline_not_changed)
                        )

                        ((ร CASE) K_LEFT)
                        ((ร CASE) K_S_LEFT)
                        ((ร CASE) K_C_LEFT)
                        (ยง
                            (if (zero? (. @ccline cmdpos))
                                (ร BREAK cmdline_not_changed)
                            )
;                           do
;                           {
                                (ยง --@ccline.cmdpos)
                                ;; move to first byte of char
                                ((ร @ccline.cmdpos -=) (ยง us_head_off(@ccline.cmdbuff, @ccline.cmdbuff.plus(@ccline.cmdpos))))
                                ((ร @ccline.cmdspos -=) (ยง cmdline_charsize(@ccline.cmdpos)))
;                           }
                            (while (ยง 0 < @ccline.cmdpos && (c == K_S_LEFT || c == K_C_LEFT || (@mod_mask & (MOD_MASK_SHIFT|MOD_MASK_CTRL)) != 0) && @ccline.cmdbuff.at(@ccline.cmdpos - 1) != (byte \space))
;                               ;
                            )
                            (set_cmdspos_cursor)
                            (ร BREAK cmdline_not_changed)
                        )

                        ((ร CASE) K_IGNORE)
                        (ยง
                            (ร BREAK cmdline_not_changed)          ;; Ignore mouse event or ex_window() result.
                        )

                        ((ร CASE) K_DROP)
                        (ยง
                            (cmdline_paste (byte \~), true, false)
                            (redrawcmd)
                            (ร BREAK cmdline_changed)
                        )

                        ((ร CASE) K_SELECT)      ;; end of Select mode mapping - ignore
                        (ยง
                            (ร BREAK cmdline_not_changed)
                        )

                        ((ร CASE) Ctrl_B)        ;; begin of command line
                        ((ร CASE) K_HOME)
                        ((ร CASE) K_KHOME)
                        ((ร CASE) K_S_HOME)
                        ((ร CASE) K_C_HOME)
                        (ยง
                            ((ร @ccline.cmdpos =) 0)
                            (set_cmdspos)
                            (ร BREAK cmdline_not_changed)
                        )

                        ((ร CASE) Ctrl_E)        ;; end of command line
                        ((ร CASE) K_END)
                        ((ร CASE) K_KEND)
                        ((ร CASE) K_S_END)
                        ((ร CASE) K_C_END)
                        (ยง
                            ((ร @ccline.cmdpos =) (. @ccline cmdlen))
                            (set_cmdspos_cursor)
                            (ร BREAK cmdline_not_changed)
                        )

                        ((ร CASE) Ctrl_L)
                        (ยง
                            (when (and @p_is (or (== firstc (byte \/)) (== firstc (byte \?))))
                                ;; Add a character from under the cursor for 'incsearch'.
                                (when (and did_incsearch (not (eqpos (. @curwin w_cursor), old_cursor)))
                                    ((ร c =) (gchar_cursor))
                                    ;; If 'ignorecase' and 'smartcase' are set and the command line
                                    ;; has no uppercase characters, convert the character to lowercase.
                                    (if (and @p_ic @p_scs (not (pat_has_uppercase (. @ccline cmdbuff))))
                                        ((ร c =) (utf_tolower c))
                                    )
                                    (when (!= c NUL)
                                        (when (or (== c firstc) (!= (vim_strchr (if @p_magic (u8 "\\^$.*[") (u8 "\\^$")), c) null))
                                            ;; put a backslash before special characters
                                            (stuffcharReadbuff c)
                                            ((ร c =) (byte \\))
                                        )
                                        (ร BREAK)
                                    )
                                )
                                (ร BREAK cmdline_not_changed)
                            )

                            (ร BREAK)
                        )

                        ((ร CASE) Ctrl_N)        ;; next match
                        ((ร CASE) Ctrl_P)        ;; previous match

                        ((ร CASE) K_UP)
                        ((ร CASE) K_DOWN)
                        ((ร CASE) K_S_UP)
                        ((ร CASE) K_S_DOWN)
                        ((ร CASE) K_PAGEUP)
                        ((ร CASE) K_KPAGEUP)
                        ((ร CASE) K_PAGEDOWN)
                        ((ร CASE) K_KPAGEDOWN)
                        (ยง
                            (if (or (zero? @hislen) (== firstc NUL))       ;; no history
                                (ร BREAK cmdline_not_changed)
                            )

                            ((ร int i =) hiscnt)

                            ;; save current command string so it can be restored later
                            (when (nil? lookfor)
                                ((ร lookfor =) (ยง STRDUP(@ccline.cmdbuff)))
                                (if (nil? lookfor)
                                    (ร BREAK cmdline_not_changed)
                                )
                                (.be lookfor (. @ccline cmdpos), NUL)
                            )

                            ((ร FOR) (ร (ยง int n = STRLEN(lookfor)) true nil)
                                ;; one step backwards
                                (cond (or (== c K_UP) (== c K_S_UP) (== c Ctrl_P) (== c K_PAGEUP) (== c K_KPAGEUP))
                                (ยง
                                    (cond (== hiscnt @hislen)   ;; first time
                                    (ยง
                                        ((ร hiscnt =) (ยง @hisidx[histype]))
                                    )
                                    (and (zero? hiscnt) (!= (ยง @hisidx[histype]) (- @hislen 1)))
                                    (ยง
                                        ((ร hiscnt =) (- @hislen 1))
                                    )
                                    (!= hiscnt (+ (ยง @hisidx[histype]) 1))
                                    (ยง
                                        (ยง --hiscnt)
                                    )
                                    :else                    ;; at top of list
                                    (ยง
                                        ((ร hiscnt =) i)
                                        (ร BREAK)
                                    ))
                                )
                                :else    ;; one step forwards
                                (ยง
                                    ;; on last entry, clear the line
                                    (when (== hiscnt (ยง @hisidx[histype]))
                                        ((ร hiscnt =) @hislen)
                                        (ร BREAK)
                                    )

                                    ;; not on a history line, nothing to do
                                    (if (== hiscnt @hislen)
                                        (ร BREAK)
                                    )
                                    (if (== hiscnt (- @hislen 1))   ;; wrap around
                                        ((ร hiscnt =) 0)
                                        (ยง hiscnt++)
                                    )
                                ))
                                (when (or (< hiscnt 0) (nil? (ยง @history[histype][hiscnt].hisstr)))
                                    ((ร hiscnt =) i)
                                    (ร BREAK)
                                )
                                (when (or (and (!= c K_UP) (!= c K_DOWN)) (== hiscnt i) (zero? (ยง STRNCMP(@history[histype][hiscnt].hisstr, lookfor, n))))
                                    (ร BREAK)
                                )
                            )

                            (when (!= hiscnt i)        ;; jumped to other entry
                                ((ร @ccline.cmdbuff =) null)

                                (ร Bytes p)
                                (if (== hiscnt @hislen)
                                    ((ร p =) lookfor)    ;; back to the old one
                                    ((ร p =) (ยง @history[histype][hiscnt].hisstr))
                                )

                                (ร int old_firstc)
                                (cond (and (== histype HIST_SEARCH) (BNE p, lookfor) (ยง (old_firstc = p.at(STRLEN(p) + 1)) != firstc))
                                (ยง
                                    ;; Correct for the separator character used when
                                    ;; adding the history entry vs the one used now.
                                    ;; First loop: count length.
                                    ;; Second loop: copy the characters.
                                    ((ร FOR) (ร (ยง int round = 0) (<= round 1) (ยง round++))
                                        ((ร int len =) 0)

                                        ((ร FOR) (ร (ยง #_"/*int */"i = 0) (ยง p.at(i) != NUL) (ยง i++))
                                            ;; Replace old sep with new sep, unless it is escaped.
                                            (cond (and (== (.at p i) old_firstc) (or (zero? i) (!= (.at p (- i 1)) (byte \\))))
                                            (ยง
                                                (if (< 0 round)
                                                    (.be (. @ccline cmdbuff) len, firstc)
                                                )
                                            )
                                            :else
                                            (ยง
                                                ;; Escape new sep, unless it is already escaped.
                                                (when (and (== (.at p i) firstc) (or (zero? i) (!= (.at p (- i 1)) (byte \\))))
                                                    (if (< 0 round)
                                                        (.be (. @ccline cmdbuff) len, (byte \\))
                                                    )
                                                    (ยง len++)
                                                )
                                                (if (< 0 round)
                                                    (.be (. @ccline cmdbuff) len, (ยง p.at(i)))
                                                )
                                            ))
                                            (ยง len++)
                                        )

                                        (if (< 0 round)
                                            (.be (. @ccline cmdbuff) len, NUL)
                                            (alloc_cmdbuff len))
                                    )
                                )
                                :else
                                (ยง
                                    (alloc_cmdbuff (STRLEN p))
                                    (STRCPY (. @ccline cmdbuff), p)
                                ))

                                ((ร @ccline.cmdpos =) (ยง @ccline.cmdlen = STRLEN(@ccline.cmdbuff)))
                                (redrawcmd)
                                (ร BREAK cmdline_changed)
                            )
                            (beep_flush)
                            (ร BREAK cmdline_not_changed)
                        )

                        ((ร CASE) Ctrl_V)
                        ((ร CASE) Ctrl_Q)
                        (ยง
                            (putcmdline (byte \^), true)
                            ((ร c =) (get_literal))          ;; get next (two) character(s)
                            ((ร do_abbr =) false)            ;; don't do abbreviation now
                            ;; may need to remove ^ when composing char was typed
                            (when (utf_iscomposing c)
                                (draw_cmdline (. @ccline cmdpos), (- (. @ccline cmdlen) (. @ccline cmdpos)))
                                (msg_putchar (byte \space))
                                (cursorcmd)
                            )
                            (ร BREAK)
                        )

                        ((ร CASE) Ctrl_K)
                        (ยง
                            (putcmdline (byte \?), true)
                            ((ร c =) (get_digraph true))
                            (if (!= c NUL)
                                (ร BREAK)
                            )

                            (redrawcmd)
                            (ร BREAK cmdline_not_changed)
                        )

                        (ร DEFAULT)
                        (ยง
                            (when (== c @intr_char)
                                ((ร gotesc =) true)      ;; will free ccline.cmdbuff after putting it in history
                                (ร BREAK returncmd)    ;; back to Normal mode
                            )

                            ;; Normal character with no special meaning.  Just set mod_mask
                            ;; to 0x0 so that typing Shift-Space in the GUI doesn't enter
                            ;; the string <S-Space>.  This should only happen after ^V.

                            (if (not (is_special c))
                                (reset! mod_mask 0x0))
                            (ร BREAK)
                        )
                    )

                    ;; End of switch on command line character.
                    ;; We come here if we have a normal character.

                    (if (and do_abbr (or (is_special c) (not (vim_iswordc c, @curbuf))) (== c Ctrl_RSB))
                        (ร BREAK cmdline_changed)
                    )

                    ;; put the character in the command line

                    (cond (or (is_special c) (non-zero? @mod_mask))
                    (ยง
                        (put_on_cmdline (get_special_key_name c, @mod_mask), -1, true)
                    )
                    :else
                    (ยง
                        ((ร int j =) (utf_char2bytes c, @ioBuff))
                        (.be @ioBuff j, NUL)          ;; exclude composing chars
                        (put_on_cmdline @ioBuff, j, true)
                    ))
                    (ร BREAK cmdline_changed)
;               }

                ;; This part implements incremental searches for "/" and "?"
                ;; Jump to cmdline_not_changed when a character has been read but the command
                ;; line did not change.  Then we only search and redraw if something changed in the past.
                ;; Jump to cmdline_changed when the command line did change.

                (if (not incsearch_postponed)
                    (ร CONTINUE)
                )
;           }

            ;; 'incsearch' highlighting.

            (when (and @p_is (or (== firstc (byte \/)) (== firstc (byte \?))))
                ;; if there is a character waiting, search and redraw later
                (when (char_avail)
                    ((ร incsearch_postponed =) true)
                    (ร CONTINUE)
                )
                ((ร incsearch_postponed =) false)
                (COPY_pos (. @curwin w_cursor), old_cursor) ;; start at old position

                ;; If there is no command line, don't do anything.
                (ร int i)
                (cond (zero? (. @ccline cmdlen))
                (ยง
                    ((ร i =) 0)
                )
                :else
                (ยง
                    (cursor_off)               ;; so the user knows we're busy
                    (out_flush)
                    (swap! emsg_off inc)                 ;; so it doesn't beep if bad expr
                    ;; Set the time limit to half a second.
                    ((ร long nsec =) (profile_setlimit 500))
                    ((ร i =) (ยง do_search(null, (byte)firstc, @ccline.cmdbuff, count, SEARCH_KEEP + SEARCH_OPT + SEARCH_NOOF + SEARCH_PEEK, nsec)))
                    (swap! emsg_off dec)
                    ;; if interrupted while searching, behave like it failed
                    (cond @got_int
                    (ยง
                        (vpeekc)               ;; remove <C-C> from input stream
                        (reset! got_int false)        ;; don't abandon the command line
                        ((ร i =) 0)
                    )
                    (char_avail)
                    (ยง
                        ;; cancelled searching because a char was typed
                        ((ร incsearch_postponed =) true)
                    ))
                ))
                (if (non-zero? i)
                    (reset! highlight_match true)         ;; highlight position
                    (reset! highlight_match false))        ;; remove highlight

                ;; First restore the old curwin values, so the screen is
                ;; positioned in the same way as the actual search command.
                ((ร @curwin.w_leftcol =) old_leftcol)
                ((ร @curwin.w_topline =) old_topline)
                ((ร @curwin.w_botline =) old_botline)
                (changed_cline_bef_curs)
                (update_topline)

                ((ร pos_C end_pos =) (ยง ยง_pos_C()))
                (cond (non-zero? i)
                (ยง
                    ((ร pos_C save_pos =) (ยง ยง_pos_C()))
                    (COPY_pos save_pos, (. @curwin w_cursor))

                    ;; First move the cursor to the end of the match, then to the start.
                    ;; This moves the whole match onto the screen when 'nowrap' is set.

                    ((ร @curwin.w_cursor.lnum +=) @search_match_lines)
                    ((ร @curwin.w_cursor.col =) @search_match_endcol)
                    (when (> (.. @curwin w_cursor lnum) (.. @curbuf b_ml ml_line_count))
                        ((ร @curwin.w_cursor.lnum =) (.. @curbuf b_ml ml_line_count))
                        (coladvance MAXCOL)
                    )
                    (validate_cursor)
                    (COPY_pos end_pos, (. @curwin w_cursor))
                    (COPY_pos (. @curwin w_cursor), save_pos)
                )
                :else
                (ยง
                    (COPY_pos end_pos, (. @curwin w_cursor))
                ))

                (validate_cursor)
                ;; May redraw the status line to show the cursor position.
                (if (and @p_ru (< 0 (. @curwin w_status_height)))
                    ((ร @curwin.w_redr_status =) true)
                )

                (save_cmdline save_cli)
                (update_screen SOME_VALID)
                (restore_cmdline save_cli)

                ;; Leave it at the end to make CTRL-R CTRL-W work.
                (if (non-zero? i)
                    (COPY_pos (. @curwin w_cursor), end_pos))

                (msg_starthere)
                (redrawcmdline)
                ((ร did_incsearch =) true)
            )
        )

        (when did_incsearch
            (COPY_pos (. @curwin w_cursor), old_cursor)
            ((ร @curwin.w_curswant =) old_curswant)
            ((ร @curwin.w_leftcol =) old_leftcol)
            ((ร @curwin.w_topline =) old_topline)
            ((ร @curwin.w_botline =) old_botline)
            (reset! highlight_match false)
            (validate_cursor)      ;; needed for TAB
            (redraw_later SOME_VALID)
        )

        (when (!= (. @ccline cmdbuff) null)
            ;; Put line in history buffer (":" and "=" only when it was typed).

            (when (and (!= (. @ccline cmdlen) 0) (!= firstc NUL) (or some_key_typed (== histype HIST_SEARCH)))
                (add_to_history histype, (. @ccline cmdbuff), (if (== histype HIST_SEARCH) firstc NUL))
                (if (== firstc (byte \:))
                    (reset! new_last_cmdline (STRDUP (. @ccline cmdbuff))))
            )

            (when gotesc         ;; abandon command line
                ((ร @ccline.cmdbuff =) null)
                (if (zero? @msg_scrolled)
                    (compute_cmdrow))
                (msg (u8 ""))
                (reset! redraw_cmdline true)
            )
        )

        ;; If the screen was shifted up, redraw the whole screen (later).
        ;; If the line is too long, clear it, so ruler and shown command
        ;; do not get printed in the middle of it.

        (msg_check)
        (reset! msg_scroll save_msg_scroll)

        ;; When the command line was typed, no need for a wait-return prompt.
        (if some_key_typed
            (reset! need_wait_return false))

        (reset! State save_State)
        (ui_cursor_shape)          ;; may show different cursor shape

        ((ร Bytes p =) (. @ccline cmdbuff))
        ;; Make ccline empty, getcmdline() may try to use it.
        ((ร @ccline.cmdbuff =) null)
        p
    ))

;; Return true when the text must not be changed and we can't switch to
;; another window or buffer.  Used when editing the command line, etc.

(defn- #_boolean text_locked []
    (ยง
        (if (non-zero? @cmdwin_type)
            ((ร RETURN) true)
        )

        (non-zero? @textlock)
    ))

;; Give an error message for a command that isn't allowed while the cmdline
;; window is open or editing the cmdline in another way.

(defn- #_void text_locked_msg []
    (ยง
        (if (non-zero? @cmdwin_type)
            (emsg e_cmdwin)
            (emsg e_secure))
    ))

(defn- #_int cmdline_charsize [#_int idx]
    (ยง
        (if (< 0 @cmdline_star)           ;; showing '*', always 1 position
            ((ร RETURN) 1)
        )

        (mb_ptr2cells (.plus (. @ccline cmdbuff) idx))
    ))

;; Compute the offset of the cursor on the command line for the prompt.

(defn- #_void set_cmdspos []
    (ยง
        (if (!= (. @ccline cmdfirstc) NUL)
            ((ร @ccline.cmdspos =) (ยง 1 + @ccline.cmdindent))
            ((ร @ccline.cmdspos =) (ยง 0 + @ccline.cmdindent))
        )
    ))

;; Compute the screen position for the cursor on the command line.

(defn- #_void set_cmdspos_cursor []
    (ยง
        (ร int i, m, c)

        (set_cmdspos)
        (cond @keyTyped
        (ยง
            ((ร m =) (ยง (int)@Columns * (int)@Rows))
            (if (< m 0)      ;; overflow, Columns or Rows at weird value
                ((ร m =) MAXCOL)
            )
        )
        :else
        (ยง
            ((ร m =) MAXCOL)
        ))
        ((ร FOR) (ร (ยง i = 0) (ยง i < @ccline.cmdlen && i < @ccline.cmdpos) (ยง i++))
            ((ร c =) (cmdline_charsize i))
            ;; Count ">" for double-wide multi-byte char that doesn't fit.
            (correct_cmdspos i, c)
            ;; If the cmdline doesn't fit, show cursor on last visible char.
            ;; Don't move the cursor itself, so we can still append.
            (when (<= m (ยง (@ccline.cmdspos += c)))
                ((ร @ccline.cmdspos -=) c)
                (ร BREAK)
            )
            ((ร i +=) (ยง us_ptr2len_cc(@ccline.cmdbuff.plus(i)) - 1))
        )
    ))

;; Check if the character at "idx", which is "cells" wide, is a multi-byte
;; character that doesn't fit, so that a ">" must be displayed.

(defn- #_void correct_cmdspos [#_int idx, #_int cells]
    (ยง
        (when (and (< 1 (us_ptr2len_cc (.plus (. @ccline cmdbuff) idx))) (< 1 (us_ptr2cells (.plus (. @ccline cmdbuff) idx))) (< (int @Columns) (+ (% (. @ccline cmdspos) (int @Columns)) cells)))
            (ยง @ccline.cmdspos++)
        )
    ))

;; Get an Ex command line for the ":" command.

(defn- #_Bytes getexline []
    (ยง
        ;; When executing a register, remove ':' that's in front of each line.
        (if (and @exec_from_reg (== (vpeekc) (byte \:)))
            (vgetc))
        (getcmdline (byte \:), 1)
    ))

;; Allocate a new command line buffer.
;; Assigns the new buffer to ccline.cmdbuff and ccline.cmdbufflen.
;; Returns the new value of ccline.cmdbuff and ccline.cmdbufflen.

(defn- #_void alloc_cmdbuff [#_int len]
    (ยง
        ;; give some extra space to avoid having to allocate all the time

        (if (< len 80)
            ((ร len =) 100)
            ((ร len +=) 20)
        )

        ((ร @ccline.cmdbuff =) (ยง new Bytes(len)))
        ((ร @ccline.cmdbufflen =) len)
    ))

;; Re-allocate the command line to length len + something extra.

(defn- #_void realloc_cmdbuff [#_int len]
    (ยง
        (if (< len (. @ccline cmdbufflen))
            (ร RETURN)                             ;; no need to resize
        )

        ((ร Bytes p =) (. @ccline cmdbuff))
        (alloc_cmdbuff len)                     ;; will get some more
        ;; There isn't always a NUL after the command, but it may need to be there,
        ;; thus copy up to the NUL and add a NUL.
        (BCOPY (. @ccline cmdbuff), p, (. @ccline cmdlen))
        (.be (. @ccline cmdbuff) (. @ccline cmdlen), NUL)
    ))

;; Draw part of the cmdline at the current cursor position;
;; but draw stars when cmdline_star is true.

(defn- #_void draw_cmdline [#_int start, #_int len]
    (ยง
        (cond (< 0 @cmdline_star)
        (ยง
            ((ร FOR) (ร (ยง int i = 0) (< i len) (ยง i++))
                (msg_putchar (byte \*))
                ((ร i +=) (ยง us_ptr2len_cc(@ccline.cmdbuff.plus(start + i)) - 1))
            )
        )
        :else
        (ยง
            (msg_outtrans_len (.plus (. @ccline cmdbuff) start), len)
        ))
    ))

;; Put a character on the command line.  Shifts the following text to the
;; right when "shift" is true.  Used for CTRL-V, CTRL-K, etc.
;; "c" must be printable (fit in one display cell)!

(defn- #_void putcmdline [#_int c, #_boolean shift]
    (ยง
        (reset! msg_no_more true)
        (msg_putchar c)
        (if shift
            (draw_cmdline (. @ccline cmdpos), (- (. @ccline cmdlen) (. @ccline cmdpos))))
        (reset! msg_no_more false)
        (cursorcmd)
    ))

;; Undo a putcmdline(c, false).

(defn- #_void unputcmdline []
    (ยง
        (reset! msg_no_more true)
        (if (== (. @ccline cmdlen) (. @ccline cmdpos))
            (msg_putchar (byte \space))
            (draw_cmdline (. @ccline cmdpos), (us_ptr2len_cc (ยง @ccline.cmdbuff.plus(@ccline.cmdpos)))))
        (reset! msg_no_more false)
        (cursorcmd)
    ))

;; Put the given string, of the given length, onto the command line.
;; If len is -1, then STRLEN() is used to calculate the length.
;; If 'redraw' is true then the new part of the command line, and the remaining part
;; will be redrawn, otherwise it will not.  If this function is called twice in a row,
;; then 'redraw' should be false and redrawcmd() should be called afterwards.

(defn- #_void put_on_cmdline [#_Bytes str, #_int len, #_boolean redraw]
    (ยง
        (if (< len 0)
            ((ร len =) (STRLEN str))
        )

        ;; Check if ccline.cmdbuff needs to be longer.
        (if (<= (. @ccline cmdbufflen) (ยง @ccline.cmdlen + len + 1))
            (realloc_cmdbuff (ยง @ccline.cmdlen + len + 1)))

        (cond (not (. @ccline overstrike))
        (ยง
            (BCOPY (. @ccline cmdbuff), (+ (. @ccline cmdpos) len), (. @ccline cmdbuff), (. @ccline cmdpos), (- (. @ccline cmdlen) (. @ccline cmdpos)))
            ((ร @ccline.cmdlen +=) len)
        )
        :else
        (ยง
            ;; Count nr of characters in the new string.
            ((ร int m =) (ยง 0, n))
            ((ร FOR) (ร (ยง n = 0) (< n len) (ยง n += us_ptr2len_cc(str.plus(n))))
                (ยง m++)
            )
            ;; Count nr of bytes in cmdline that are overwritten by these characters.
            ((ร FOR) (ร (ยง n = @ccline.cmdpos) (ยง n < @ccline.cmdlen && 0 < m) (ยง n += us_ptr2len_cc(@ccline.cmdbuff.plus(n))))
                (ยง --m)
            )
            (cond (< n (. @ccline cmdlen))
            (ยง
                (BCOPY (. @ccline cmdbuff), (+ (. @ccline cmdpos) len), (. @ccline cmdbuff), n, (- (. @ccline cmdlen) n))
                ((ร @ccline.cmdlen +=) (ยง @ccline.cmdpos + len - n))
            )
            :else
            (ยง
                ((ร @ccline.cmdlen =) (ยง @ccline.cmdpos + len))
            ))
        ))
        (BCOPY (. @ccline cmdbuff), (. @ccline cmdpos), str, 0, len)
        (.be (. @ccline cmdbuff) (. @ccline cmdlen), NUL)

        ;; When the inserted text starts with a composing character,
        ;; backup to the character before it.  There could be two of them.

        ((ร int i =) 0)
        ((ร int c =) (ยง us_ptr2char(@ccline.cmdbuff.plus(@ccline.cmdpos))))
        (while (ยง 0 < @ccline.cmdpos && utf_iscomposing(c))
            ((ร i =) (ยง us_head_off(@ccline.cmdbuff, @ccline.cmdbuff.plus(@ccline.cmdpos - 1)) + 1))
            ((ร @ccline.cmdpos -=) i)
            ((ร len +=) i)
            ((ร c =) (ยง us_ptr2char(@ccline.cmdbuff.plus(@ccline.cmdpos))))
        )
        (when (non-zero? i)
            ;; Also backup the cursor position.
            ((ร i =) (ยง mb_ptr2cells(@ccline.cmdbuff.plus(@ccline.cmdpos))))
            ((ร @ccline.cmdspos -=) i)
            ((ร @msg_col -=) i)
            (when (< @msg_col 0)
                ((ร @msg_col +=) (ยง (int)@Columns))
                (swap! msg_row dec)
            )
        )

        (when redraw
            (reset! msg_no_more true)
            ((ร i =) @cmdline_row)
            (cursorcmd)
            (draw_cmdline (. @ccline cmdpos), (- (. @ccline cmdlen) (. @ccline cmdpos)))
            ;; Avoid clearing the rest of the line too often.
            (if (or (!= @cmdline_row i) (. @ccline overstrike))
                (msg_clr_eos))
            (reset! msg_no_more false)
        )

        (ร int m)
        (cond @keyTyped
        (ยง
            ((ร m =) (ยง (int)@Columns * (int)@Rows))
            (if (< m 0)      ;; overflow, Columns or Rows at weird value
                ((ร m =) MAXCOL)
            )
        )
        :else
        (ยง
            ((ร m =) MAXCOL)
        ))

        ((ร FOR) (ร (ยง i = 0) (< i len) (ยง i++))
            ((ร c =) (ยง cmdline_charsize(@ccline.cmdpos)))
            ;; count ">" for a double-wide char that doesn't fit.
            (correct_cmdspos (. @ccline cmdpos), c)
            ;; Stop cursor at the end of the screen, but do increment the insert position,
            ;; so that entering a very long command works, even though you can't see it.
            (if (ยง @ccline.cmdspos + c < m)
                ((ร @ccline.cmdspos +=) c)
            )

            ((ร c =) (ยง us_ptr2len_cc(@ccline.cmdbuff.plus(@ccline.cmdpos)) - 1))
            (if (> c (ยง len - i - 1))
                ((ร c =) (ยง len - i - 1))
            )
            ((ร @ccline.cmdpos +=) c)
            ((ร i +=) c)

            (ยง @ccline.cmdpos++)
        )

        (when redraw
            (msg_check)
        )
    ))

(atom! cmdline_info_C prev_ccline)

;; Save ccline, because obtaining the "=" register may execute "normal :cmd" and overwrite it.
;; But get_cmdline_str() may need it, thus make it available globally in prev_ccline.

(defn- #_void save_cmdline [#_cmdline_info_C cli]
    (ยง
        (if (nil? @prev_ccline)
            (reset! prev_ccline (ยง ยง_cmdline_info_C())))

        (COPY_cmdline_info cli, @prev_ccline)
        (COPY_cmdline_info @prev_ccline, @ccline)

        ((ร @ccline.cmdbuff =) null)
        ((ร @ccline.cmdprompt =) null)
    ))

;; Restore ccline after it has been saved with save_cmdline().

(defn- #_void restore_cmdline [#_cmdline_info_C cli]
    (ยง
        (COPY_cmdline_info @ccline, @prev_ccline)
        (COPY_cmdline_info @prev_ccline, cli)
    ))

;; Save the command line into allocated memory.
;; Returns a pointer to be passed to restore_cmdline_alloc() later.

(defn- #_cmdline_info_C save_cmdline_alloc []
    (ยง
        ((ร cmdline_info_C cli =) (ยง ยง_cmdline_info_C()))
        (save_cmdline cli)
        cli
    ))

;; Restore the command line from the return value of save_cmdline_alloc().

(defn- #_void restore_cmdline_alloc [#_cmdline_info_C cli]
    (ยง
        (when (non-nil? cli)
            (restore_cmdline cli)
        )
    ))

;; Paste a yank register into the command line.
;; Used by CTRL-R command in command-line mode.
;; insert_reg() can't be used here, because special characters
;; from the register contents will be interpreted as commands.
;;
;; return false for failure, true otherwise

(defn- #_boolean cmdline_paste [#_int regname, #_boolean literally, #_boolean remcr]
    ;; literally: Insert text literally instead of "as typed"
    ;; remcr: remove trailing CR
    (ยง
        ;; check for valid regname; also accept special characters for CTRL-R in the command line
        (if (and (!= regname Ctrl_F) (!= regname Ctrl_P) (!= regname Ctrl_W) (!= regname Ctrl_A) (not (valid_yank_reg regname, false)))
            ((ร RETURN) false)
        )

        ;; A register containing CTRL-R can cause an endless loop.
        ;; Allow using CTRL-C to break the loop.
        (line_breakcheck)
        (if @got_int
            ((ร RETURN) false)
        )

        ((ร regname =) (may_get_selection regname))

        ;; Need to save and restore ccline.  And set "textlock" to avoid nasty
        ;; things like going to another buffer when evaluating an expression.
        ((ร cmdline_info_C save_cli =) (save_cmdline_alloc))
        (swap! textlock inc)

        ((ร Bytes[] arg =) (ยง new Bytes[1]))
        ((ร boolean[] allocated =) (ยง new boolean[1]))
        ((ร boolean got =) (get_spec_reg regname, arg, allocated, true))

        (swap! textlock dec)
        (restore_cmdline_alloc save_cli)

        (when got
            ;; Got the value of a special register in "arg".
            (if (nil? (ยง arg[0]))
                ((ร RETURN) false)
            )

            ;; When 'incsearch' is set and CTRL-R CTRL-W used: skip the duplicate part of the word.
            ((ร Bytes p =) (ยง arg[0]))

            (when (and @p_is (== regname Ctrl_W))
                ;; Locate start of last word in the cmd buffer.
                (ร Bytes w)
                ((ร FOR) (ร (ยง w = @ccline.cmdbuff.plus(@ccline.cmdpos)) (ยง BLT(@ccline.cmdbuff, w)) nil)
                    ((ร int len =) (ยง us_head_off(@ccline.cmdbuff, w.minus(1)) + 1))
                    (if (not (vim_iswordc (us_ptr2char (ยง w.minus(len))), @curbuf))
                        (ร BREAK)
                    )
                    ((ร w =) (ยง w.minus(len)))
                )
                ((ร int len =) (ยง BDIFF(@ccline.cmdbuff.plus(@ccline.cmdpos), w)))
                (if (if @p_ic (zero? (ยง STRNCASECMP(w, arg[0], len))) (zero? (ยง STRNCMP(w, arg[0], len))))
                    ((ร p =) (ยง p.plus(len)))
                )
            )

            (cmdline_paste_str p, literally)

            ((ร RETURN) true)
        )

        (cmdline_paste_reg regname, literally, remcr)
    ))

;; Put a string on the command line.
;; When "literally" is true, insert literally.
;; When "literally" is false, insert as typed, but don't leave the command line.

(defn- #_void cmdline_paste_str [#_Bytes _s, #_boolean literally]
    (ยง
; %%    ((ร Bytes[] s =) (ยง { _s }))
        (cond literally
        (ยง
            (put_on_cmdline (ยง s[0]), -1, true)
        )
        :else
        (ยง
            (while (ยง s[0].at(0) != NUL)
                ((ร int cv =) (ยง s[0].at(0)))
                (if (and (== cv Ctrl_V) (!= (.at (ยง s[0]) 1) NUL))
                    ((ร s[0] =) (ยง s[0].plus(1)))
                )
                ((ร int c =) (us_ptr2char_adv s, false))
                (when (or (== cv Ctrl_V) (== c ESC) (== c Ctrl_C) (== c CAR) (== c NL) (== c Ctrl_L) (== c @intr_char) (and (== c Ctrl_BSL) (== (.at (ยง s[0]) 0) Ctrl_N)))
                    (stuffcharReadbuff Ctrl_V)
                )
                (stuffcharReadbuff c)
            )
        ))
    ))

;; this function is called when the screen size changes and with incremental search

(defn- #_void redrawcmdline []
    (ยง
        (reset! need_wait_return false)
        (compute_cmdrow)
        (redrawcmd)
        (cursorcmd)
    ))

(defn- #_void redrawcmdprompt []
    (ยง
        (if (!= (. @ccline cmdfirstc) NUL)
            (msg_putchar (. @ccline cmdfirstc)))
        (cond (!= (. @ccline cmdprompt) null)
        (ยง
            (msg_puts_attr (. @ccline cmdprompt), (. @ccline cmdattr))
            ((ร @ccline.cmdindent =) (ยง @msg_col + (@msg_row - @cmdline_row) * (int)@Columns))
            ;; do the reverse of set_cmdspos()
            (if (!= (. @ccline cmdfirstc) NUL)
                (ยง --@ccline.cmdindent)
            )
        )
        :else
        (ยง
            ((ร FOR) (ร (ยง int i = @ccline.cmdindent) (< 0 i) (ยง --i))
                (msg_putchar (byte \space))
            )
        ))
    ))

;; Redraw what is currently on the command line.

(defn- #_void redrawcmd []
    (ยง
        ;; when 'incsearch' is set there may be no command line while redrawing
        (when (nil? (. @ccline cmdbuff))
            (windgoto @cmdline_row, 0)
            (msg_clr_eos)
            (ร RETURN)
        )

        (msg_start)
        (redrawcmdprompt)

        ;; Don't use more prompt, truncate the cmdline if it doesn't fit.
        (reset! msg_no_more true)
        (draw_cmdline 0, (. @ccline cmdlen))
        (msg_clr_eos)
        (reset! msg_no_more false)

        (set_cmdspos_cursor)

        ;; An emsg() before may have set msg_scroll.  This is used in normal mode,
        ;; in cmdline mode we can reset them now.

        (reset! msg_scroll false)         ;; next message overwrites cmdline

        ;; Typing ':' at the more prompt may set skip_redraw.  We don't want this in cmdline mode.
        (reset! skip_redraw false)
    ))

(defn- #_void compute_cmdrow []
    (ยง
        (if (non-zero? @msg_scrolled)
            (reset! cmdline_row (- (int @Rows) 1))
            (reset! cmdline_row (ยง @lastwin.w_winrow + @lastwin.w_height + @lastwin.w_status_height)))
    ))

(defn- #_void cursorcmd []
    (ยง
        (reset! msg_row (ยง @cmdline_row + (@ccline.cmdspos / (int)@Columns)))
        (reset! msg_col (ยง @ccline.cmdspos % (int)@Columns))
        (if (<= @Rows @msg_row)
            (reset! msg_row (- (int @Rows) 1)))

        (windgoto @msg_row, @msg_col)
    ))

(defn- #_void gotocmdline [#_boolean clr]
    (ยง
        (msg_start)
        (reset! msg_col 0)           ;; always start in column 0
        (if clr                ;; clear the bottom line(s)
            (msg_clr_eos))      ;; will reset clear_cmdline

        (windgoto @cmdline_row, 0)
    ))

;; Command line history stuff

;; Translate a history character to the associated type number.

(defn- #_int hist_char2type [#_int c]
    (ยง
        (if (== c (byte \:))
            ((ร RETURN) HIST_CMD)
        )
        (if (== c (byte \=))
            ((ร RETURN) HIST_EXPR)
        )
        (if (== c (byte \@))
            ((ร RETURN) HIST_INPUT)
        )

        HIST_SEARCH     ;; must be '?' or '/'
    ))

;; init_history() - Initialize the command line history.
;; Also used to re-allocate the history when the size changes.

(defn- #_void init_history []
    (ยง
        ;; If size of history table changed, reallocate it.

        ((ร int newlen =) (ยง (int)@p_hi))
        (when (!= newlen @hislen)                                   ;; history length changed
            ((ร FOR) (ร (ยง int type = 0) (< type HIST_COUNT) (ยง type++))       ;; adjust the tables
                ((ร histentry_C[] temp =) null)

                (if (non-zero? newlen)
                    ((ร temp =) (ARRAY_histentry newlen))
                )

                (when (or (zero? newlen) (non-nil? temp))
                    (cond (< (ยง @hisidx[type]) 0)                       ;; there are no entries yet
                    (ยง
                        ((ร FOR) (ร (ยง int i = 0) (< i newlen) (ยง i++))
                            (clear_hist_entry (ยง temp[i]))
                        )
                    )
                    (< @hislen newlen)                   ;; array becomes bigger
                    (ยง
                        (ร int i)
                        ((ร FOR) (ร (ยง i = 0) (ยง i <= @hisidx[type]) (ยง i++))
                            (COPY_histentry (ยง temp[i]), (ยง @history[type][i]))
                        )
                        ((ร int j =) i)
                        ((ร FOR) (ร (ยง  ) (ยง i <= newlen - (@hislen - @hisidx[type])) (ยง i++))
                            (clear_hist_entry (ยง temp[i]))
                        )
                        ((ร FOR) (ร (ยง  ) (< j @hislen) (ยง i++, j++))
                            (COPY_histentry (ยง temp[i]), (ยง @history[type][j]))
                        )
                    )
                    :else                                        ;; array becomes smaller or 0
                    (ยง
                        ((ร int j =) (ยง @hisidx[type]))
                        ((ร FOR) (ร (ยง int i = newlen - 1) true (ยง --i))
                            (if (<= 0 i)
                                (COPY_histentry (ยง temp[i]), (ยง @history[type][j]))      ;; copy newest entries
                                ((ร @history[type][j].hisstr =) null)                    ;; remove older entries
                            )
                            (if (< (ยง --j) 0)
                                ((ร j =) (- @hislen 1))
                            )
                            (if (== j (ยง @hisidx[type]))
                                (ร BREAK)
                            )
                        )
                        ((ร @hisidx[type] =) (- newlen 1))
                    ))
                    ((ร @history[type] =) temp)
                )
            )
            (reset! hislen newlen)
        )
    ))

(defn- #_void clear_hist_entry [#_histentry_C hisptr]
    (ยง
        ((ร hisptr.hisnum =) 0)
        ((ร hisptr.hisstr =) null)
    ))

;; Check if command line 'str' is already in history.
;; If 'move_to_front' is true, matching entry is moved to end of history.

(defn- #_boolean in_history [#_int type, #_Bytes str, #_boolean move_to_front, #_int sep]
    ;; move_to_front: Move the entry to the front if it exists
    (ยง
        (if (< (ยง @hisidx[type]) 0)
            ((ร RETURN) false)
        )

        ((ร int last_i =) -1)

        ((ร int i =) (ยง @hisidx[type]))
;       do
;       {
            (if (nil? (ยง @history[type][i].hisstr))
                ((ร RETURN) false)
            )

            ;; For search history, check that the separator character matches as well.
            ((ร Bytes p =) (ยง @history[type][i].hisstr))
            (when (and (zero? (STRCMP str, p)) (or (!= type HIST_SEARCH) (== sep (ยง p.at(STRLEN(p) + 1)))))
                (if (not move_to_front)
                    ((ร RETURN) true)
                )
                ((ร last_i =) i)
                (ร BREAK)
            )
            (if (< (ยง --i) 0)
                ((ร i =) (- @hislen 1))
            )
;       } while (i != @hisidx[type]);

        (when (<= 0 last_i)
            ((ร str =) (ยง @history[type][i].hisstr))
            (while (ยง i != @hisidx[type])
                (if (<= @hislen (ยง ++i))
                    ((ร i =) 0)
                )
                (COPY_histentry (ยง @history[type][last_i]), (ยง @history[type][i]))
                ((ร last_i =) i)
            )
            ((ร @history[type][i].hisnum =) (ยง ++@hisnum[type]))
            ((ร @history[type][i].hisstr =) str)
            ((ร RETURN) true)
        )

        false
    ))

(atom! int      last_maptick -1)      ;; last seen maptick

;; Add the given string to the given history.  If the string is already in the
;; history then it is moved to the front.  "histype" may be one of he HIST_ values.

(defn- #_void add_to_history [#_int histype, #_Bytes new_entry, #_int sep]
    ;; sep: separator character used (search hist)
    (ยง
        (if (zero? @hislen)            ;; no history
            (ร RETURN)
        )

        ;; Searches inside the same mapping overwrite each other, so that only
        ;; the last line is kept.  Be careful not to remove a line that was moved
        ;; down, only lines that were added.

        (when (== histype HIST_SEARCH)
            (when (== @maptick @last_maptick)
                ;; Current line is from the same mapping, remove it.
                ((ร histentry_C hisptr =) (ยง @history[HIST_SEARCH][@hisidx[HIST_SEARCH]]))
                ((ร hisptr.hisstr =) null)
                (clear_hist_entry hisptr)
                (ยง --@hisnum[histype])
                (if (< (ยง --@hisidx[HIST_SEARCH]) 0)
                    ((ร @hisidx[HIST_SEARCH] =) (- @hislen 1))
                )
            )
            (reset! last_maptick -1)
        )

        (when (not (in_history histype, new_entry, true, sep))
            (if (== (ยง ++@hisidx[histype]) @hislen)
                ((ร @hisidx[histype] =) 0)
            )

            ((ร histentry_C hisptr =) (ยง @history[histype][@hisidx[histype]]))

            ;; Store the separator after the NUL of the string.
            ((ร int len =) (STRLEN new_entry))
            ((ร hisptr.hisstr =) (ยง STRNDUP(new_entry, len + 2)))
;           hisptr.hisstr.be(len + 1, sep);

            ((ร hisptr.hisnum =) (ยง ++@hisnum[histype]))
            (if (== histype HIST_SEARCH)
                (reset! last_maptick @maptick))
        )
    ))

;; Open a window on the current command line and history.
;; Allow editing in the window.  When the window is closed,
;; returns:
;;      CR       if the command is to be executed
;;      Ctrl_C   if it is to be abandoned
;;      K_IGNORE if editing continues

(defn- #_int ex_window []
    (ยง
        (beep_flush)
        K_IGNORE
    ))

;; ex_docmd.c: functions for executing an Ex command line -----------------------------------------

(atom! int      quitmore)
(atom! boolean  ex_pressedreturn)

;;; ============================================================================================== VimI

;; This file defines the Ex commands.
;;
;; When adding an Ex command:
;; 1. Add an entry in the table below.  Keep it sorted on the shortest
;;    version of the command name that works.  If it doesn't start with a
;;    lower case letter, add it at the end.
;; 2. Add a "case: CMD_xxx" in the big switch in ex_docmd.c.

;; This array maps ex command names to command codes.
;; The order in which command names are listed below is significant --
;; ambiguous abbreviations are always resolved to be the first possible match
;; (e.g. "r" is taken to mean "read", not "rewind", because "read" comes before "rewind").
;; Not supported commands are included to avoid ambiguities.

(class! #_final cmdname_C
    [
        (field Bytes        cmd_name)       ;; name of the command
        (field ex_func_F    cmd_func)       ;; function for this command
        (field long         cmd_argt)       ;; flags declared above
        (field int          cmd_addr_type)  ;; flag for address type
    ])

;; ----------------------------------------------------------------------- ;;

;; Execute a simple command line.  Used for translated commands like "*".

(defn- #_boolean do_cmdline_cmd [#_Bytes cmd]
    (ยง
        (do_cmdline cmd, false, (ยง DOCMD_VERBOSE|DOCMD_NOWAIT|DOCMD_KEYTYPED))
    ))

(atom! int _0_recurse)              ;; recursive depth

;; do_cmdline(): execute one Ex command line
;;
;; 1. Execute "cmdline" when it is not null.
;;    If "cmdline" is null, or more lines are needed, getexline() is used.
;; 2. Split up in parts separated with '|'.
;;
;; This function can be called recursively!
;;
;; flags:
;; DOCMD_VERBOSE  - The command will be included in the error message.
;; DOCMD_NOWAIT   - Don't call wait_return() and friends.
;; DOCMD_KEYTYPED - Don't reset keyTyped.
;; DOCMD_KEEPLINE - Store first typed line (for repeating with ".").
;;
;; return false if cmdline could not be executed, true otherwise

(defn- #_boolean do_cmdline [#_Bytes cmdline, #_boolean use_getline, #_int flags]
    (ยง
        ((ร boolean retval =) true)

        ((ร boolean used_getline =) false)               ;; used getexline() to obtain command

        ((ร boolean msg_didout_before_start =) false)
        ((ร int count =) 0)                              ;; line number count
        ((ร boolean did_inc =) false)                    ;; incremented redrawingDisabled

        ;; "did_emsg" will be set to true when emsg() is used,
        ;; in which case we cancel the whole command line, and any if/endif or loop.

        (reset! did_emsg false)

        ;; keyTyped is only set when calling vgetc().
        ;; Reset it here when not calling vgetc() (sourced command lines).

        (if (and (zero? (& flags DOCMD_KEYTYPED)) (not use_getline))
            (reset! keyTyped false))

; %%    ((ร Bytes[] cmdline_copy =) (ยง { null }))                ;; copy of cmd line

        ;; Continue executing command lines:
        ;; - when inside an ":if", ":while" or ":for"
        ;; - for multiple commands on one line, separated with '|'
        ;; - when repeating until there are no more lines (for ":source")

        ((ร Bytes next_cmdline =) cmdline)
;       do
;       {
            ;; stop skipping cmds for an error msg after all endif/while/for
            (if (nil? next_cmdline)
                (reset! did_emsg false))

            ;; 2. If no line given, get an allocated line with getexline().
            (cond (nil? next_cmdline)
            (ยง
                ;; Need to set msg_didout for the first line after an ":if",
                ;; otherwise the ":if" will be overwritten.

                (if (and (== count 1) use_getline)
                    (reset! msg_didout true))
                (when (or (not use_getline) (nil? (ยง next_cmdline = getexline())))
                    ;; Don't call wait_return for aborted command line.  The null
                    ;; returned for the end of a sourced file or executed function
                    ;; doesn't do this.
                    (if @keyTyped
                        (reset! need_wait_return false))
                    ((ร retval =) false)
                    (ร BREAK)
                )
                ((ร used_getline =) true)

                ;; Keep the first typed line.  Clear it when more lines are typed.

                (when (non-zero? (& flags DOCMD_KEEPLINE))
                    (if (zero? count)
                        (reset! repeat_cmdline (STRDUP next_cmdline))
                        (reset! repeat_cmdline null))
                )
            )

            ;; 3. Make a copy of the command so we can mess with it.
            (nil? (ยง cmdline_copy[0]))
            (ยง
                ((ร next_cmdline =) (STRDUP next_cmdline))
            ))
            ((ร cmdline_copy[0] =) next_cmdline)

            (when (zero? (ยง count++))
                ;; All output from the commands is put below each other, without waiting for a return.
                ;; Don't do this when executing commands from a script or when being called recursive
                ;; (e.g. for ":e +command file").

                (when (and (zero? (& flags DOCMD_NOWAIT)) (zero? @_0_recurse))
                    ((ร msg_didout_before_start =) @msg_didout)
                    (reset! msg_didany false) ;; no output yet
                    (msg_start)
                    (reset! msg_scroll true)  ;; put messages below each other
                    (swap! no_wait_return inc)   ;; don't wait for return until finished
                    (swap! redrawingDisabled inc)
                    ((ร did_inc =) true)
                )
            )

            ;; 2. Execute one '|' separated command.
            ;;    do_one_cmd() will return null if there is no trailing '|'.
            ;;    "cmdline_copy" can change, e.g. for '%' and '#' expansion.

            (swap! _0_recurse inc)
            ((ร next_cmdline =) (ยง do_one_cmd(cmdline_copy, (flags & DOCMD_VERBOSE) != 0)))
            (swap! _0_recurse dec)

            (cond (nil? next_cmdline)
            (ยง
                ((ร cmdline_copy[0] =) null)

                ;; If the command was typed, remember it for the ':' register.
                ;; Do this AFTER executing the command to make :@: work.

                (when (and use_getline (non-nil? @new_last_cmdline))
                    (reset! last_cmdline @new_last_cmdline)
                    (reset! new_last_cmdline null)
                )
            )
            :else
            (ยง
                ;; Need to copy the command after the '|' to 'cmdline_copy',
                ;; for the next do_one_cmd().
                (BCOPY (ยง cmdline_copy[0]), next_cmdline, (+ (STRLEN next_cmdline) 1))
                ((ร next_cmdline =) (ยง cmdline_copy[0]))
            ))
;       }

        ;; Continue executing command lines when:
        ;; - no CTRL-C typed, no aborting error, no exception thrown or try conditionals need
        ;;   to be checked for executing finally clauses or catching an interrupt exception
        ;; - didn't get an error message or lines are not typed
        ;; - there is a command after '|', inside a :if, :while, :for or :try, or looping
        ;;   for ":source" command or function call.

        (while (ยง !@got_int && !(@did_emsg && used_getline && use_getline) && (next_cmdline != null))
;           ;
        )

        (reset! did_emsg_syntax false)

        ;; If there was too much output to fit on the command line, ask the user to
        ;; hit return before redrawing the screen.  With the ":global" command we do
        ;; this only once after the command is finished.

        (when did_inc
            (swap! redrawingDisabled dec)
            (swap! no_wait_return dec)
            (reset! msg_scroll false)

            ;; When just finished an ":if"-":else" which was typed, no need to
            ;; wait for hit-return.  Also for an error situation.

            (cond (not retval)
            (ยง
                (reset! need_wait_return false)
                (reset! msg_didany false)         ;; don't wait when restarting edit
            )
            @need_wait_return
            (ยง
                ;; The msg_start() above clears msg_didout.  The wait_return we do here
                ;; should not overwrite the command that may be shown before doing that.

                ((ร @msg_didout |=) msg_didout_before_start)
                (wait_return FALSE)
            ))
        )

        retval
    ))

(defn- #_int current_win_nr [#_window_C win]
    (ยง
        ((ร int nr =) 0)

        ((ร FOR) (ร (ยง window_C wp = @firstwin) (!= wp null) (ยง wp = wp.w_next))
            (ยง nr++)
            (if (== wp win)
                (ร BREAK)
            )
        )

        nr
    ))

;; Execute one Ex command.
;;
;; If 'verbose' is true, the command will be included in the error message.
;;
;; 1. skip comment lines and leading space
;; 2. handle command modifiers
;; 3. find the command
;; 4. parse range
;; 5. parse the command
;; 6. parse arguments
;; 7. switch on command name
;;
;; This function may be called recursively!

(defn- #_Bytes do_one_cmd [#_Bytes* cmdlinep, #_boolean verbose]
    (ยง
        ((ร Bytes errormsg =) null)         ;; error message
        ((ร boolean save_msg_scroll =) @msg_scroll)
        ((ร int did_esilent =) 0)

        ((ร exarg_C ea =) (ยง ยง_exarg_C()))     ;; Ex command arguments
        ((ร ea.line1 =) 1)
        ((ร ea.line2 =) 1)

        ;; When the last file has not been edited :q has to be typed twice.
        (if (non-zero? @quitmore)
            (swap! quitmore dec))

;       doend:
;       {
            ;; "#!anything" is handled like a comment.
            (if (and (== (ยง cmdlinep[0].at(0)) (byte \#)) (== (ยง cmdlinep[0].at(1)) (byte \!)))
                (ร BREAK doend)
            )

            ;; Repeat until no more command modifiers are found.

            ((ร ea.cmd =) (ยง cmdlinep[0]))
            (while true
                ;; 1. Skip comment lines and leading white space and colons.

                (while (ยง ea.cmd.at(0) == (byte \space) || ea.cmd.at(0) == (byte \tab) || ea.cmd.at(0) == (byte \:))
                    ((ร ea.cmd =) (ยง ea.cmd.plus(1)))
                )

                ;; ignore comment and empty lines
                (if (== (ยง ea.cmd.at(0)) (byte \")) ;; """
                    (ร BREAK doend)
                )
                (when (== (ยง ea.cmd.at(0)) NUL)
                    (reset! ex_pressedreturn true)
                    (ร BREAK doend)
                )

                ;; 2. Handle command modifiers.

; %%            ((ร Bytes[] p =) (ยง { ea.cmd }))
                (if (asc_isdigit (ยง p[0].at(0)))
                    ((ร p[0] =) (ยง skipwhite(skipdigits(p[0]))))
                )
                ((ร SWITCH) (ยง p[0].at(0))
;                   
                )
                (ร BREAK)
            )

            ((ร ea.skip =) (ยง (@did_emsg || @got_int)))

            ;; 3. Skip over the range to find the command.  Let "p" point to after it.
            ;;
            ;; We need the command to know what kind of range it uses.

            ((ร Bytes cmd =) (. ea cmd))
            ((ร ea.cmd =) (ยง skip_range(ea.cmd)))
            (if (== (ยง ea.cmd.at(0)) (byte \*))
                ((ร ea.cmd =) (ยง skipwhite(ea.cmd.plus(1))))
            )

            ((ร Bytes p =) (find_command ea))

            ;; 4. parse a range specifier of the form: addr [,addr] [;addr] ..
            ;;
            ;; where 'addr' is:
            ;;
            ;; %          (entire file)
            ;; $  [+-NUM]
            ;; 'x [+-NUM] (where x denotes a currently defined mark)
            ;; .  [+-NUM]
            ;; [+-NUM]..
            ;; NUM
            ;;
            ;; The ea.cmd pointer is updated to point to the first character following the range spec.
            ;; If an initial address is found, but no second, the upper bound is equal to the lower.

;           {
                (if (!= (. ea cmdidx) CMD_SIZE)
                    ((ร ea.addr_type =) (ยง cmdnames[ea.cmdidx].cmd_addr_type))
                    ((ร ea.addr_type =) ADDR_LINES)
                )
;           }

            (ร long lnum)

            ;; repeat for all ',' or ';' separated addresses
            ((ร ea.cmd =) cmd)
            (while true
                ((ร ea.line1 =) (. ea line2))
                ((ร SWITCH) (. ea addr_type)
                    ((ร CASE) ADDR_LINES)
                    (ยง
                        ;; default is current line number
                        ((ร ea.line2 =) (.. @curwin w_cursor lnum))
                        (ร BREAK)
                    )

                    ((ร CASE) ADDR_WINDOWS)
                    (ยง
                        ((ร lnum =) (current_win_nr @curwin))
                        ((ร ea.line2 =) lnum)
                        (ร BREAK)
                    )
                )
                ((ร ea.cmd =) (ยง skipwhite(ea.cmd)))
;               { Bytes[] __ = { ea.cmd }; lnum = get_address(__, ea.addr_type, ea.skip, ea.addr_count == 0); ea.cmd = __[0]; }
                (if (nil? (. ea cmd))                 ;; error detected
                    (ร BREAK doend)
                )
                (cond (== lnum MAXLNUM)
                (ยง
                    (cond (== (ยง ea.cmd.at(0)) (byte \%))          ;; '%' - all lines
                    (ยง
                        ((ร ea.cmd =) (ยง ea.cmd.plus(1)))
                        ((ร SWITCH) (. ea addr_type)
                            ((ร CASE) ADDR_LINES)
                            (ยง
                                ((ร ea.line1 =) 1)
                                ((ร ea.line2 =) (.. @curbuf b_ml ml_line_count))
                                (ร BREAK)
                            )

                            ((ร CASE) ADDR_WINDOWS)
                            (ยง
                                ;; There is no Vim command which uses '%' and ADDR_WINDOWS.
                                ((ร errormsg =) e_invrange)
                                (ร BREAK doend)
                            )
                        )
                        (ยง ea.addr_count++)
                    )
                    (== (ยง ea.cmd.at(0)) (byte \*))     ;; '*' - visual area
                    (ยง
                        (when (!= (. ea addr_type) ADDR_LINES)
                            ((ร errormsg =) e_invrange)
                            (ร BREAK doend)
                        )

                        ((ร ea.cmd =) (ยง ea.cmd.plus(1)))
                        (when (not (. ea skip))
                            ((ร pos_C fp =) (ยง getmark((byte \<), false)))
                            (if (not (check_mark fp))
                                (ร BREAK doend)
                            )
                            ((ร ea.line1 =) (. fp lnum))
                            ((ร fp =) (ยง getmark((byte \>), false)))
                            (if (not (check_mark fp))
                                (ร BREAK doend)
                            )
                            ((ร ea.line2 =) (. fp lnum))
                            (ยง ea.addr_count++)
                        )
                    ))
                )
                :else
                (ยง
                    ((ร ea.line2 =) lnum)
                ))
                (ยง ea.addr_count++)

                (cond (== (ยง ea.cmd.at(0)) (byte \;))
                (ยง
                    (if (not (. ea skip))
                        ((ร @curwin.w_cursor.lnum =) (. ea line2))
                    )
                )
                (!= (ยง ea.cmd.at(0)) (byte \,))
                (ยง
                    (ร BREAK)
                ))
                ((ร ea.cmd =) (ยง ea.cmd.plus(1)))
            )

            ;; One address given: set start and end lines.
            (when (== (. ea addr_count) 1)
                ((ร ea.line1 =) (. ea line2))
                ;; ... but only implicit: really no address given
                (if (== lnum MAXLNUM)
                    ((ร ea.addr_count =) 0)
                )
            )

            ;; Don't leave the cursor on an illegal line (caused by ';').
            (check_cursor_lnum)

            ;; 5. Parse the command.

            ;; Skip ':' and any white space

            ((ร ea.cmd =) (ยง skipwhite(ea.cmd)))
            (while (ยง ea.cmd.at(0) == (byte \:))
                ((ร ea.cmd =) (ยง skipwhite(ea.cmd.plus(1))))
            )

            ;; If we got a line, but no command, then go to the line.
            ;; If we find a '|' or '\n' we set ea.nextcmd.

            (when (or (== (ยง ea.cmd.at(0)) NUL) (== (ยง ea.cmd.at(0)) (byte \")) (non-nil? (ยง ea.nextcmd = check_nextcmd(ea.cmd))))  ;; """
                ;; strange vi behaviour:
                ;; ":3"         jumps to line 3
                ;; ":3|..."     prints line 3
                ;; ":|"         prints current line

                (if (. ea skip)    ;; skip this if inside :if
                    (ร BREAK doend)
                )
                (cond (== (ยง ea.cmd.at(0)) (byte \|))
                (ยง
                    ((ร ea.cmdidx =) (ยง CMD_print))
                    ((ร ea.argt =) (+ RANGE COUNT))
                    (when (nil? (ยง errormsg = invalid_range(ea)))
                        (correct_range ea)
;                       ex_print(ea);
                    )
                )
                (!= (. ea addr_count) 0)
                (ยง
                    (when (< (.. @curbuf b_ml ml_line_count) (. ea line2))
                        ;; With '-' in 'cpoptions' a line number past the file is an error,
                        ;; otherwise put it at the end of the file.
                        (if (non-nil? (vim_strbyte @p_cpo, CPO_MINUS))
                            ((ร ea.line2 =) -1)
                            ((ร ea.line2 =) (.. @curbuf b_ml ml_line_count))
                        )
                    )

                    (cond (< (. ea line2) 0)
                    (ยง
                        ((ร errormsg =) e_invrange)
                    )
                    :else
                    (ยง
                        (if (zero? (. ea line2))
                            ((ร @curwin.w_cursor.lnum =) 1)
                            ((ร @curwin.w_cursor.lnum =) (. ea line2))
                        )
                        (beginline (| BL_SOL BL_FIX))
                    ))
                ))
                (ร BREAK doend)
            )

            (when (nil? p)
                (if (not (. ea skip))
                    ((ร errormsg =) (u8 "E464: Ambiguous use of user-defined command"))
                )
                (ร BREAK doend)
            )

            (when (== (. ea cmdidx) CMD_SIZE)
                (when (not (. ea skip))
                    (STRCPY @ioBuff, (u8 "E492: Not an editor command"))
                    (if (not verbose)
                        (append_command (ยง cmdlinep[0])))
                    ((ร errormsg =) @ioBuff)
                    (reset! did_emsg_syntax true)
                )
                (ร BREAK doend)
            )

            ;; forced commands
            (cond (and (== (.at p 0) (byte \!)) (!= (. ea cmdidx) CMD_substitute))
            (ยง
                ((ร p =) (ยง p.plus(1)))
                ((ร ea.forceit =) true)
            )
            :else
            (ยง
                ((ร ea.forceit =) false)
            ))

            ;; 6. Parse arguments.

            ((ร ea.argt =) (ยง cmdnames[ea.cmdidx].cmd_argt))

            (when (not (. ea skip))
                (when (and (text_locked) (zero? (& (. ea argt) CMDWIN)))
                    ;; Command not allowed when editing the command line.
                    (if (non-zero? @cmdwin_type)
                        ((ร errormsg =) e_cmdwin)
                        ((ร errormsg =) e_secure)
                    )
                    (ร BREAK doend)
                )

                (when (and (zero? (& (. ea argt) RANGE)) (< 0 (. ea addr_count)))
                    ;; no range allowed
                    ((ร errormsg =) e_norange)
                    (ร BREAK doend)
                )
            )

            (when (and (zero? (& (. ea argt) BANG)) (. ea forceit)) ;; no <!> allowed
                ((ร errormsg =) e_nobang)
                (ร BREAK doend)
            )

            ;; Don't complain about the range if it is not used
            ;; (could happen if line_count is accidentally set to 0).

            (when (not (. ea skip))
                ;; If the range is backwards, ask for confirmation and, if given,
                ;; swap ea.line1 & ea.line2 so it's forwards again.

                (when (< (. ea line2) (. ea line1))
                    (when verbose
                        ((ร errormsg =) (u8 "E493: Backwards range given"))
                        (ร BREAK doend)
                    )
                    (if (!= (ask_yesno (u8 "Backwards range given, OK to swap"), false) (byte \y))
                        (ร BREAK doend)
                    )

                    ((ร lnum =) (. ea line1))
                    ((ร ea.line1 =) (. ea line2))
                    ((ร ea.line2 =) lnum)
                )
                (if (non-nil? (ยง errormsg = invalid_range(ea)))
                    (ร BREAK doend)
                )
            )

            (if (and (non-zero? (& (. ea argt) NOTADR)) (zero? (. ea addr_count))) ;; default is 1, not cursor
                ((ร ea.line2 =) 1)
            )

            (correct_range ea)

            ;; Skip to start of argument.

            ((ร ea.arg =) (skipwhite p))

            (when (and (non-zero? (& (. ea argt) DFLALL)) (zero? (. ea addr_count)))
                ((ร ea.line1 =) 1)
                ((ร SWITCH) (. ea addr_type)
                    ((ร CASE) ADDR_LINES)
                    (ยง
                        ((ร ea.line2 =) (.. @curbuf b_ml ml_line_count))
                        (ร BREAK)
                    )

                    ((ร CASE) ADDR_WINDOWS)
                    (ยง
                        ((ร ea.line2 =) (current_win_nr null))
                        (ร BREAK)
                    )
                )
            )

            ;; Check for a count.

            (when (and (non-zero? (& (. ea argt) COUNT)) (asc_isdigit (ยง ea.arg.at(0))))
                (ร long n)
;               { Bytes[] __ = { ea.arg }; n = getdigits(__); ea.arg = __[0]; }
                ((ร ea.arg =) (ยง skipwhite(ea.arg)))
                (when (and (<= n 0) (zero? (& (. ea argt) ZEROR)))
                    ((ร errormsg =) e_zerocount)
                    (ร BREAK doend)
                )
                (cond (non-zero? (& (. ea argt) NOTADR))    ;; e.g. :buffer 2, :sleep 3
                (ยง
                    ((ร ea.line2 =) n)
                    (if (zero? (. ea addr_count))
                        ((ร ea.addr_count =) 1)
                    )
                )
                :else
                (ยง
                    ((ร ea.line1 =) (. ea line2))
                    ((ร ea.line2 +=) (- n 1))
                    (ยง ea.addr_count++)

                    ;; Be vi compatible: no error message for out of range.

                    (if (> (. ea line2) (.. @curbuf b_ml ml_line_count))
                        ((ร ea.line2 =) (.. @curbuf b_ml ml_line_count))
                    )
                ))
            )

            (when (and (zero? (& (. ea argt) EXTRA)) (!= (ยง ea.arg.at(0)) NUL) (!= (ยง ea.arg.at(0)) (byte \"))) ;; """
                ((ร errormsg =) e_trailing)
                (ร BREAK doend)
            )

            (when (and (non-zero? (& (. ea argt) NEEDARG)) (== (ยง ea.arg.at(0)) NUL))
                ((ร errormsg =) e_argreq)
                (ร BREAK doend)
            )

            ;; Skip the command when it's not going to be executed.
            ;; The commands like :if, :endif, etc. always need to be executed.
            ;; Also make an exception for commands that handle a trailing command themselves.

            (when (. ea skip)
                ((ร SWITCH) (. ea cmdidx)
                    ;; Commands that handle '|' themselves.  Check: A command should
                    ;; either have the TRLBAR flag, appear in this list or appear in
                    ;; the list at ":help :bar".
                    ((ร CASE) CMD_substitute)
                    (ยง
                        (ร BREAK)
                    )

                    (ร DEFAULT)
                    (ยง
                        (ร BREAK doend)
                    )
                )
            )

            ;; 7. Switch on command name.
            ;;
            ;; The "ea" structure holds the arguments that can be used.

            ((ร ea.cmdlinep =) cmdlinep)

            ;; Call the function to execute the command.

            ((ร ea.errmsg =) null)
;           cmdnames[ea.cmdidx].cmd_func(ea);
            (if (!= (. ea errmsg) null)
                ((ร errormsg =) (. ea errmsg))
            )
;       }

        (if (zero? (.. @curwin w_cursor lnum))  ;; can happen with zero line number
            ((ร @curwin.w_cursor.lnum =) 1)
        )

        (when (and (non-nil? errormsg) (non-eos? errormsg) (not @did_emsg))
            (when verbose
                (when (BNE errormsg, @ioBuff)
                    (STRCPY @ioBuff, errormsg)
                    ((ร errormsg =) @ioBuff)
                )
                (append_command (ยง cmdlinep[0]))
            )
            (emsg errormsg)
        )

        (if (and (!= (. ea nextcmd) null) (== (ยง ea.nextcmd.at(0)) NUL))      ;; not really a next command
            ((ร ea.nextcmd =) null)
        )

        (. ea nextcmd)
    ))

;; Append "cmd" to the error message in ioBuff.
;; Takes care of limiting the length and handling 0xa0,
;; which would be invisible otherwise.

(defn- #_void append_command [#_Bytes cmd]
    (ยง
        (STRCAT @ioBuff, (u8 ": "))

        ((ร Bytes d =) (ยง @ioBuff.plus(STRLEN(@ioBuff))))
        ((ร FOR) (ร (ยง Bytes s = cmd) (ยง s.at(0) != NUL && BDIFF(d, @ioBuff) < IOSIZE - 7) nil)
            (cond (and (== (char_u (ยง s.at(0))) 0xc2) (== (char_u (ยง s.at(1))) 0xa0))
            (ยง
                ((ร s =) (ยง s.plus(2)))
                (STRCPY d, (u8 "<a0>"))
                ((ร d =) (ยง d.plus(4)))
            )
            :else
            (ยง
                ((ร int len =) (us_ptr2len_cc s))
                (BCOPY d, s, len)
                ((ร d =) (ยง d.plus(len)))
                ((ร s =) (ยง s.plus(len)))
            ))
        )
        (.be d 0, NUL)
    ))

;; Find an Ex command by its name, either built-in or user.
;; Start of the name can be found at eap.cmd.
;; Returns pointer to char after the command name.
;; Returns null for an ambiguous user command.

(defn- #_Bytes find_command [#_exarg_C eap]
    (ยง
        ;; Isolate the command and search for it in the command table.
        ;; Exceptions:
        ;; - the 's' command can be followed directly by 'c', 'g', 'i', 'I' or 'r',
        ;;      but :sre[wind] is another command, as are :scr[iptnames], :scs[cope], :sim[alt], :sig[ns] and :sil[ent].

        ((ร Bytes p =) (. eap cmd))
        (cond (and (== (.at p 0) (byte \s)) (or (and (== (.at p 1) (byte \c)) (!= (.at p 2) (byte \s)) (!= (.at p 2) (byte \r)) (!= (.at p 3) (byte \i)) (!= (.at p 4) (byte \p))) (== (.at p 1) (byte \g)) (and (== (.at p 1) (byte \i)) (!= (.at p 2) (byte \m)) (!= (.at p 2) (byte \l)) (!= (.at p 2) (byte \g))) (== (.at p 1) (byte \I)) (and (== (.at p 1) (byte \r)) (!= (.at p 2) (byte \e)))))
        (ยง
            ((ร eap.cmdidx =) CMD_substitute)
            ((ร p =) (ยง p.plus(1)))
        )
        :else
        (ยง
            (while (ยง asc_isalpha(p.at(0)))
                ((ร p =) (ยง p.plus(1)))
            )

            ;; check for non-alpha command
            (if (and (BEQ p, (. eap cmd)) (non-nil? (vim_strbyte (u8 "@*!=><&~#"), (.at p 0))))
                ((ร p =) (ยง p.plus(1)))
            )

            ((ร int len =) (ยง BDIFF(p, eap.cmd)))

            ((ร FOR) (ร (ยง eap.cmdidx = 0) (ยง eap.cmdidx < CMD_SIZE) (ยง eap.cmdidx++))
                (if (zero? (ยง STRNCMP(cmdnames[eap.cmdidx].cmd_name, eap.cmd, len)))
                    (ร BREAK)
                )
            )

            ;; Look for a user defined command as a last resort.
            (when (and (== (. eap cmdidx) CMD_SIZE) (<= (byte \A) (ยง eap.cmd.at(0))) (<= (ยง eap.cmd.at(0)) (byte \Z)))
                ;; User defined commands may contain digits.
                (while (ยง asc_isalnum(p.at(0)))
                    ((ร p =) (ยง p.plus(1)))
                )
            )

            (if (BEQ p, (. eap cmd))
                ((ร eap.cmdidx =) CMD_SIZE)
            )
        ))

        p
    ))

;; skip a range specifier of the form: addr [,addr] [;addr] ..
;;
;; Backslashed delimiters after / or ? will be skipped, and commands will
;; not be expanded between /'s and ?'s or after "'".
;;
;; Also skip white space and ":" characters.
;; Returns the "cmd" pointer advanced to beyond the range.

(defn- #_Bytes skip_range [#_Bytes cmd]
    (ยง
        (while (non-nil? (vim_strbyte (u8 " \t0123456789.$%'/?-+,;"), (.at cmd 0)))
            (cond (== (.at cmd 0) (byte \'))
            (ยง
                ((ร cmd =) (ยง cmd.plus(1)))
            )
            (or (== (.at cmd 0) (byte \/)) (== (.at cmd 0) (byte \?)))
            (ยง
                ((ร byte delim =) (ยง (cmd = cmd.plus(1)).at(-1)))
                (while (ยง cmd.at(0) != NUL && cmd.at(0) != delim)
                    (if (and (== (ยง (cmd = cmd.plus(1)).at(-1)) (byte \\)) (non-eos? cmd))
                        ((ร cmd =) (ยง cmd.plus(1)))
                    )
                )
            ))
            (if (non-eos? cmd)
                ((ร cmd =) (ยง cmd.plus(1)))
            )
        )

        ;; Skip ":" and white space.
        (while (ยง cmd.at(0) == (byte \:))
            ((ร cmd =) (ยง skipwhite(cmd.plus(1))))
        )

        cmd
    ))

;; get a single EX address
;;
;; Set ptr to the next character after the part that was interpreted.
;; Set ptr to null when an error is encountered.
;;
;; Return MAXLNUM when no Ex address was found.

(defn- #_long get_address [#_Bytes* ptr, #_int addr_type, #_boolean skip, #_boolean to_other_file]
    ;; addr_type: flag: one of ADDR_LINES, ...
    ;; skip: only skip the address, don't use it
    ;; to_other_file: flag: may jump to other file
    (ยง
        ((ร long lnum =) MAXLNUM)
        ((ร Bytes cmd =) (ยง skipwhite(ptr[0])))

;       error:
;       do
;       {
            ((ร SWITCH) (ยง cmd.at(0))
                ((ร CASE) (byte \.))                       ;; '.' - Cursor position
                (ยง
                    ((ร cmd =) (ยง cmd.plus(1)))
                    ((ร SWITCH) addr_type
                        ((ร CASE) ADDR_LINES)
                        (ยง
                            ((ร lnum =) (.. @curwin w_cursor lnum))
                            (ร BREAK)
                        )

                        ((ร CASE) ADDR_WINDOWS)
                        (ยง
                            ((ร lnum =) (current_win_nr @curwin))
                            (ร BREAK)
                        )
                    )
                    (ร BREAK)
                )

                ((ร CASE) (byte \$))                       ;; '$' - last line
                (ยง
                    ((ร cmd =) (ยง cmd.plus(1)))
                    ((ร SWITCH) addr_type
                        ((ร CASE) ADDR_LINES)
                        (ยง
                            ((ร lnum =) (.. @curbuf b_ml ml_line_count))
                            (ร BREAK)
                        )

                        ((ร CASE) ADDR_WINDOWS)
                        (ยง
                            ((ร lnum =) (current_win_nr null))
                            (ร BREAK)
                        )
                    )
                    (ร BREAK)
                )

                ((ร CASE) (byte \'))                      ;; ''' - mark
                (ยง
                    (when (ยง (cmd = cmd.plus(1)).at(0) == NUL)
                        ((ร cmd =) null)
                        (ร BREAK error)
                    )
                    (when (!= addr_type ADDR_LINES)
                        (emsg e_invaddr)
                        ((ร cmd =) null)
                        (ร BREAK error)
                    )
                    (cond skip
                    (ยง
                        ((ร cmd =) (ยง cmd.plus(1)))
                    )
                    :else
                    (ยง
                        ;; Only accept a mark in another file when it is used by itself: ":'M".
                        ((ร pos_C fp =) (ยง getmark(cmd.at(0), to_other_file && cmd.at(1) == NUL)))
                        ((ร cmd =) (ยง cmd.plus(1)))
                        (cond (== fp NOPOS)
                        (ยง
                            ;; Jumped to another file.
                            ((ร lnum =) (.. @curwin w_cursor lnum))
                        )
                        :else
                        (ยง
                            (when (not (check_mark fp))
                                ((ร cmd =) null)
                                (ร BREAK error)
                            )
                            ((ร lnum =) (. fp lnum))
                        ))
                    ))
                    (ร BREAK)
                )

                ((ร CASE) (byte \/))
                ((ร CASE) (byte \?))                   ;; '/' or '?' - search
                (ยง
                    ((ร byte c =) (ยง (cmd = cmd.plus(1)).at(-1)))
                    (when (!= addr_type ADDR_LINES)
                        (emsg e_invaddr)
                        ((ร cmd =) null)
                        (ร BREAK error)
                    )
                    (cond skip       ;; skip "/pat/"
                    (ยง
                        ((ร cmd =) (skip_regexp cmd, c, @p_magic, null))
                        (if (== (.at cmd 0) c)
                            ((ร cmd =) (ยง cmd.plus(1)))
                        )
                    )
                    :else
                    (ยง
                        ((ร pos_C save_pos =) (ยง ยง_pos_C()))
                        (COPY_pos save_pos, (. @curwin w_cursor))

                        ;; When '/' or '?' follows another address, start from there.

                        (if (!= lnum MAXLNUM)
                            ((ร @curwin.w_cursor.lnum =) lnum)
                        )

                        ;; Start a forward search at the end of the line.
                        ;; Start a backward search at the start of the line.
                        ;; This makes sure we never match in the current line,
                        ;; and can match anywhere in the next/previous line.

                        ((ร @curwin.w_cursor.col =) (if (== c (byte \/)) MAXCOL 0))
                        (reset! searchcmdlen 0)
                        (when (zero? (do_search null, c, cmd, 1, (| SEARCH_HIS SEARCH_MSG), null))
                            (COPY_pos (. @curwin w_cursor), save_pos)
                            ((ร cmd =) null)
                            (ร BREAK error)
                        )
                        ((ร lnum =) (.. @curwin w_cursor lnum))
                        (COPY_pos (. @curwin w_cursor), save_pos)
                        ;; adjust command string pointer
                        ((ร cmd =) (ยง cmd.plus(@searchcmdlen)))
                    ))
                    (ร BREAK)
                )

                ((ร CASE) (byte \\))              ;; "\?", "\/" or "\&", repeat search
                (ยง
                    ((ร cmd =) (ยง cmd.plus(1)))
                    (when (!= addr_type ADDR_LINES)
                        (emsg e_invaddr)
                        ((ร cmd =) null)
                        (ร BREAK error)
                    )
                    (ร int i)
                    (cond (== (.at cmd 0) (byte \&))
                    (ยง
                        ((ร i =) RE_SUBST)
                    )
                    (or (== (.at cmd 0) (byte \?)) (== (.at cmd 0) (byte \/)))
                    (ยง
                        ((ร i =) RE_SEARCH)
                    )
                    :else
                    (ยง
                        (emsg e_backslash)
                        ((ร cmd =) null)
                        (ร BREAK error)
                    ))

                    (when (not skip)
                        ((ร pos_C pos =) (ยง ยง_pos_C()))

                        ;; When search follows another address, start from there.

                        ((ร pos.lnum =) (if (!= lnum MAXLNUM) lnum (.. @curwin w_cursor lnum)))

                        ;; Start the search just like for the above do_search().

                        ((ร pos.col =) (if (!= (.at cmd 0) (byte \?)) MAXCOL 0))

                        (cond (!= (searchit @curwin, @curbuf, pos, (if (== (.at cmd 0) (byte \?)) BACKWARD FORWARD), (u8 ""), 1, SEARCH_MSG, i, 0, null) 0)
                        (ยง
                            ((ร lnum =) (. pos lnum))
                        )
                        :else
                        (ยง
                            ((ร cmd =) null)
                            (ร BREAK error)
                        ))
                    )
                    ((ร cmd =) (ยง cmd.plus(1)))
                    (ร BREAK)
                )

                (ร DEFAULT)
                (ยง
                    (when (asc_isdigit (ยง cmd.at(0)))     ;; absolute line number
;                       Bytes[] __ = { cmd }; lnum = getdigits(__); cmd = __[0];
                    )
                    (ร BREAK)
                )
            )

            (while true
                ((ร cmd =) (skipwhite cmd))
                (if (and (!= (.at cmd 0) (byte \-)) (!= (.at cmd 0) (byte \+)) (not (asc_isdigit (ยง cmd.at(0)))))
                    (ร BREAK)
                )

                (when (== lnum MAXLNUM)
                    ((ร SWITCH) addr_type
                        ((ร CASE) ADDR_LINES)
                        (ยง
                            ;; "+1" is same as ".+1"
                            ((ร lnum =) (.. @curwin w_cursor lnum))
                            (ร BREAK)
                        )

                        ((ร CASE) ADDR_WINDOWS)
                        (ยง
                            ((ร lnum =) (current_win_nr @curwin))
                            (ร BREAK)
                        )
                    )
                )

                (ร int m)
                (if (asc_isdigit (ยง cmd.at(0)))
                    ((ร m =) (byte \+))                    ;; "number" is same as "+number"
                    ((ร m =) (ยง (cmd = cmd.plus(1)).at(-1)))
                )
                (ร int n)
                (cond (not (asc_isdigit (ยง cmd.at(0))))    ;; '+' is '+1', but '+0' is not '+1'
                (ยง
                    ((ร n =) 1)
                )
                :else
                (ยง
;                   Bytes[] __ = { cmd }; n = (int)getdigits(__); cmd = __[0];
                ))
                (if (== m (byte \-))
                    ((ร lnum -=) n)
                    ((ร lnum +=) n)
                )
            )
;       } while (cmd.at(0) == (byte \/) || cmd.at(0) == (byte \?));

        ((ร ptr[0] =) cmd)
        lnum
    ))

;; Check range in Ex command for validity.
;; Return null when valid, error message when invalid.

(defn- #_Bytes invalid_range [#_exarg_C eap]
    (ยง
        (if (or (< (. eap line1) 0) (< (. eap line2) 0) (< (. eap line2) (. eap line1)))
            ((ร RETURN) e_invrange)
        )

        (when (non-zero? (& (. eap argt) RANGE))
            ((ร SWITCH) (. eap addr_type)
                ((ร CASE) ADDR_LINES)
                (ยง
                    (if (and (zero? (& (. eap argt) NOTADR)) (< (.. @curbuf b_ml ml_line_count) (. eap line2)))
                        ((ร RETURN) e_invrange)
                    )
                    (ร BREAK)
                )

                ((ร CASE) ADDR_WINDOWS)
                (ยง
                    (if (< (current_win_nr null) (. eap line2))
                        ((ร RETURN) e_invrange)
                    )
                    (ร BREAK)
                )
            )
        )

        null
    ))

;; Correct the range for zero line number, if required.

(defn- #_void correct_range [#_exarg_C eap]
    (ยง
        (when (zero? (& (. eap argt) ZEROR))    ;; zero in range not allowed
            (if (zero? (. eap line1))
                ((ร eap.line1 =) 1)
            )
            (if (zero? (. eap line2))
                ((ร eap.line2 =) 1)
            )
        )
    ))

;; Check if *p is a separator between Ex commands.
;; Return null if it isn't, (p + 1) if it is.

(defn- #_Bytes check_nextcmd [#_Bytes p]
    (ยง
        ((ร p =) (skipwhite p))
        (if (or (== (.at p 0) (byte \|)) (== (.at p 0) (byte \newline)))
            ((ร RETURN) (ยง p.plus(1)))
            ((ร RETURN) null)
        )
    ))

;; ":close": close current window, unless it is the last one

(defn- #_void ex_close [#_exarg_C eap]
    (ยง
        (cond (non-zero? @cmdwin_type)
        (ยง
            (reset! cmdwin_result Ctrl_C)
        )
        (not (text_locked))
        (ยง
            (cond (zero? (. eap addr_count))
            (ยง
                (ex_win_close (. eap forceit), @curwin)
            )
            :else
            (ยง
                (ร window_C win)
                ((ร int winnr =) 0)
                ((ร FOR) (ร (ยง win = @firstwin) (!= win null) (ยง win = win.w_next))
                    (if (== (ยง ++winnr) (. eap line2))
                        (ร BREAK)
                    )
                )
                (if (nil? win)
                    ((ร win =) @lastwin)
                )
                (ex_win_close (. eap forceit), win)
            ))
        ))
    ))

;; Close window "win" and take care of handling closing the last window for a modified buffer.

(defn- #_void ex_win_close [#_boolean forceit, #_window_C win]
    (ยง
        ((ร buffer_C buf =) @curbuf)

        ((ร boolean need_hide =) (ยง (buf.@b_changed && buf.b_nwindows <= 1)))
        (when (and need_hide (not forceit))
            (emsg e_nowrtmsg)
            (ร RETURN)
        )

        (win_close win, (not need_hide))
    ))

;; ":only".

(defn- #_void ex_only [#_exarg_C eap]
    (ยง
        (when (< 0 (. eap addr_count))
            ((ร int wnr =) (ยง (int)eap.line2))
            (ร window_C wp)
            ((ร FOR) (ร (ยง wp = @firstwin) (ยง 0 < --wnr) nil)
                (if (nil? (. wp w_next))
                    (ร BREAK)
                    ((ร wp =) (. wp w_next))
                )
            )
            (win_goto wp)
        )

        (close_others true, (. eap forceit))
    ))

;; ":stop" and ":suspend": Suspend Vim.

(defn- #_void ex_stop [#_exarg_C eap]
    (ยง
        (windgoto (- (int @Rows) 1), 0)
        (out_char (byte \newline))
        (out_flush)
        (stoptermcap)
        (out_flush)            ;; needed for SUN to restore xterm buffer
        (ui_suspend)           ;; call machine specific function
        (starttermcap)
        (scroll_start)         ;; scroll screen before redrawing
        (redraw_later_clear)
        (shell_resized)        ;; may have resized window
    ))

;; ":syncbind" forces all 'scrollbind' windows to have the same relative offset.

(defn- #_void ex_syncbind [#_exarg_C _eap]
    (ยง
        ((ร window_C save_curwin =) @curwin)
        ((ร long old_linenr =) (.. @curwin w_cursor lnum))

        (setpcmark)

        (ร long topline)
        ;; determine max topline
        (cond @(.. @curwin w_options wo_scb)
        (ยง
            ((ร topline =) (. @curwin w_topline))
            ((ร FOR) (ร (ยง window_C wp = @firstwin) (!= wp null) (ยง wp = wp.w_next))
                (when @(.. wp w_options wo_scb)
                    ((ร long y =) (ยง @curbuf.b_ml.ml_line_count - @p_so))
                    (if (< y topline)
                        ((ร topline =) y)
                    )
                )
            )
            (if (< topline 1)
                ((ร topline =) 1)
            )
        )
        :else
        (ยง
            ((ร topline =) 1)
        ))

        ;; Set all scrollbind windows to the same topline.

        ((ร FOR) (ร (ยง @curwin = @firstwin) (!= @curwin null) (ยง @curwin = @curwin.w_next))
            (when @(.. @curwin w_options wo_scb)
                ((ร long y =) (ยง topline - @curwin.w_topline))
                (if (< 0 y)
                    (scrollup y)
                    (scrolldown (- y)))
                ((ร @curwin.w_scbind_pos =) topline)
                (redraw_later VALID)
                (cursor_correct)
                ((ร @curwin.w_redr_status =) true)
            )
        )
        (reset! curwin save_curwin)
        (when @(.. @curwin w_options wo_scb)
            (reset! did_syncbind true)
            (checkpcmark)
            (when (!= old_linenr (.. @curwin w_cursor lnum))
                ((ร Bytes ctrl_o =) (ยง new Bytes(2)))

                (.be ctrl_o 0, Ctrl_O)
                (.be ctrl_o 1, NUL)

                (ins_typebuf ctrl_o)
            )
        )
    ))

;; Sleep for "msec" milliseconds, but keep checking for a CTRL-C every second.

(defn- #_void do_sleep [#_long msec]
    (ยง
        (cursor_on)
        (out_flush)
        ((ร FOR) (ร (ยง long done = 0) (ยง !@got_int && done < msec) (ยง done += 1000))
            (ui_delay (if (< 1000 (- msec done)) 1000 (- msec done)), true)
            (ui_breakcheck)
        )
    ))

;; ":set"

(defn- #_void ex_set [#_exarg_C eap]
    (ยง
        (do_set (. eap arg))
    ))

;;; ============================================================================================== VimJ

;; eval.c: Expression evaluation ------------------------------------------------------------------

;; Top level evaluation function, returning a string.

(defn- #_Bytes eval_to_string [#_Bytes arg, #_Bytes* nextcmd]
    (ยง
        (ยง null)
    ))

;; Return the time 'msec' past now.

(defn- #_long profile_setlimit [#_long msec]
    (if (< 0 msec)
        (+ (System/nanoTime) (* msec 1000 1000))
        0)) ;; no limit

;; Return true if the current time is past 'nsec'.

(defn- #_boolean profile_passed_limit [#_long nsec]
    (if (zero? nsec) ;; timer was not set
        false
        (< nsec (System/nanoTime))))

;; Return true if the buffer "buf" can be abandoned, either by making it
;; hidden, autowriting it or unloading it.

(defn- #_boolean can_abandon [#_buffer_C buf, #_boolean forceit]
    (ยง
        (or (not @(. buf b_changed)) (< 1 (. buf b_nwindows)) forceit)
    ))

;;; ============================================================================================== VimK

;; normal.c ---------------------------------------------------------------------------------------
;; Contains the main routine for processing characters in command mode.
;; Communicates closely with the code in ops.c to handle the operators.

;; The Visual area is remembered for reselection.

(atom! int      resel_VIsual_mode       NUL)    ;; 'v', 'V', or Ctrl-V
(atom! long     resel_VIsual_line_count)        ;; number of lines
(atom! int      resel_VIsual_vcol)              ;; nr of cols or end col
(atom! int      VIsual_mode_orig        NUL)    ;; saved Visual mode

(atom! int      restart_VIsual_select)

;; nv_*(): functions called to handle Normal and Visual mode commands.
;; n_*(): functions called to handle Normal mode commands.
;; v_*(): functions called to handle Visual mode commands.

(final Bytes e_noident (u8 "E349: No identifier under cursor"))

;; Values for cmd_flags.
(final int NV_NCH      0x01)            ;; may need to get a second char
(final int NV_NCH_NOP  (| 0x02 NV_NCH))   ;; get second char when no operator pending
(final int NV_NCH_ALW  (| 0x04 NV_NCH))   ;; always get a second char
(final int NV_LANG     0x08)            ;; second char needs language adjustment

(final int NV_SS       0x10)            ;; may start selection
(final int NV_SSS      0x20)            ;; may start selection with shift modifier
(final int NV_STS      0x40)            ;; may stop selection without shift modif.
(final int NV_RL       0x80)            ;; 'rightleft' modifies command
(final int NV_KEEPREG  0x100)           ;; don't clear regname
(final int NV_NCW      0x200)           ;; not allowed in command-line window

;; Generally speaking, every Normal mode command should either clear any
;; pending operator (with *clearop*()), or set the motion type variable
;; oap.motion_type.
;;
;; When a cursor motion command is made, it is marked as being a character or
;; line oriented motion.  Then, if an operator is in effect, the operation
;; becomes character or line oriented accordingly.

;; Function to be called for a Normal or Visual mode command.
;; The argument is a cmdarg_C.

(class! #_final nv_cmd_C
    [
        (field int          cmd_char)           ;; (first) command character
        (field nv_func_F    cmd_func)           ;; function for this command
        (field int          cmd_flags)          ;; NV_ flags
        (field int          cmd_arg)            ;; value for ca.arg
    ])

;; Search for a command in the commands table.
;; Returns -1 for invalid command.

(defn- #_int find__command [#_int cmdchar]
    (ยง
        ;; A multi-byte character is never a command.
        (if (<= 0x100 cmdchar)
            ((ร RETURN) -1)
        )

;       %% return nv_cmds index for cmd_char or -1
    ))

;; Execute a command in Normal mode.

(defn- #_void normal_cmd [#_oparg_C oap, #_boolean toplevel]
    ;; toplevel: true when called from main()
    (ยง
        ((ร int old_col =) (. @curwin w_curswant))

        ((ร cmdarg_C ca =) (ยง ยง_cmdarg_C()))   ;; command arguments
        ((ร ca.oap =) oap)

        ;; Use a count remembered from before entering an operator.
        ;; After typing "3d" we return from normal_cmd() and come back here,
        ;; the "3" is remembered in "opcount".
        ((ร ca.opcount =) @opcount)

        ;; If there is an operator pending, then the command we take this time
        ;; will terminate it.  finish_op tells us to finish the operation before
        ;; returning this time (unless the operation was cancelled).

        ((ร boolean save_finish_op =) @finish_op)
        (reset! finish_op (!= (. oap op_type) OP_NOP))
        (when (!= @finish_op save_finish_op)
            (ui_cursor_shape)              ;; may show different cursor shape
        )

        ;; When not finishing an operator and no register name typed, reset the count.
        (when (and (not @finish_op) (zero? (. oap regname)))
            ((ร ca.opcount =) 0)
        )

        ;; Restore counts from before receiving K_CURSORHOLD.
        ;; This means after typing "3", handling K_CURSORHOLD
        ;; and then typing "2" we get "32", not "3 * 2".
        (when (or (< 0 (. oap prev_opcount)) (< 0 (. oap prev_count0)))
            ((ร ca.opcount =) (. oap prev_opcount))
            ((ร ca.count0 =) (. oap prev_count0))
            ((ร oap.prev_opcount =) 0)
            ((ร oap.prev_count0 =) 0)
        )

        (reset! State NORMAL_BUSY)

        ;; Get the command character from the user.

        ((ร int c =) (safe_vgetc))

        (if (== c NUL)
            ((ร c =) K_ZERO)
        )

        ;; In Select mode, typed text replaces the selection.

        (when (and @VIsual_active @VIsual_select (or (vim_isprintc c) (== c NL) (== c CAR) (== c K_KENTER)))
            ;; Fake a "c"hange command.
            ;; When "restart_edit" is set (e.g., because 'insertmode' is set)
            ;; fake a "d"elete command, Insert mode will restart automatically.
            ;; Insert the typed character in the typeahead buffer, so it can be
            ;; mapped in Insert mode.  Required for ":lmap" to work.
            (ins_char_typebuf c)
            (if (non-zero? @restart_edit)
                ((ร c =) (byte \d))
                ((ร c =) (byte \c))
            )
            (reset! msg_nowait true)      ;; don't delay going to insert mode
        )

        ((ร boolean need_flushbuf =) (add_to_showcmd c))      ;; need to call out_flush()
        ((ร boolean ctrl_w =) false)                         ;; got CTRL-W command

;       getcount:
        (while true
            (when (not (and @VIsual_active @VIsual_select))
                ;; Handle a count before a command and compute ca.count0.
                ;; Note that '0' is a command and not the start of a count,
                ;; but it's part of a count after other digits.

                (while (ยง ((byte \1) <= c && c <= (byte \9)) || (ca.count0 != 0 && (c == K_DEL || c == K_KDEL || c == (byte \0))))
                    (cond (or (== c K_DEL) (== c K_KDEL))
                    (ยง
; %%                    ((ร ca.count0 /=) 10)
                        (del_from_showcmd 4)    ;; delete the digit and ~@%
                    )
                    :else
                    (ยง
                        ((ร ca.count0 =) (ยง ca.count0 * 10 + (c - (byte \0))))
                    ))
                    (if (< (. ca count0) 0)          ;; got too large!
                        ((ร ca.count0 =) 999999999)
                    )

                    (when ctrl_w
                        (swap! no_mapping inc)
                        (swap! allow_keys inc)           ;; no mapping for nchar, but keys
                    )
                    ((ร c =) (plain_vgetc))
                    (when ctrl_w
                        (swap! no_mapping dec)
                        (swap! allow_keys dec)
                    )
                    ((ร need_flushbuf |=) (add_to_showcmd c))
                )

                ;; If we got CTRL-W there may be a/another count

                (when (and (== c Ctrl_W) (not ctrl_w) (== (. oap op_type) OP_NOP))
                    ((ร ctrl_w =) true)
                    ((ร ca.opcount =) (. ca count0))     ;; remember first count
                    ((ร ca.count0 =) 0)
                    (swap! no_mapping inc)
                    (swap! allow_keys inc)               ;; no mapping for nchar, but keys
                    ((ร c =) (plain_vgetc))          ;; get next character
                    (swap! no_mapping dec)
                    (swap! allow_keys dec)
                    ((ร need_flushbuf |=) (add_to_showcmd c))
                    (ร CONTINUE getcount)              ;; jump back
                )
            )

            (ร BREAK)
        )

        (cond (== c K_CURSORHOLD)
        (ยง
            ;; Save the count values so that ca.opcount and ca.count0 are exactly
            ;; the same when coming back here after handling K_CURSORHOLD.
            ((ร oap.prev_opcount =) (. ca opcount))
            ((ร oap.prev_count0 =) (. ca count0))
        )
        (!= (. ca opcount) 0)
        (ยง
            ;; If we're in the middle of an operator (including after entering a
            ;; yank buffer with '"') AND we had a count before the operator, then
            ;; that count overrides the current value of ca.count0.
            ;; What this means effectively, is that commands like "3dw" get turned
            ;; into "d3w" which makes things fall into place pretty neatly.
            ;; If you give a count before AND after the operator, they are multiplied.

            (if (!= (. ca count0) 0)
                ((ร ca.count0 *=) (. ca opcount))
                ((ร ca.count0 =) (. ca opcount))
            )
        ))

        ;; Always remember the count.
        ;; It will be set to zero (on the next call, above) when there is no pending operator.
        ;; When called from main(), save the count for use by the "count" built-in variable.

        ((ร ca.opcount =) (. ca count0))
        ((ร ca.count1 =) (if (== (. ca count0) 0) 1 (. ca count0)))

        ;; Find the command character in the table of commands.
        ;; For CTRL-W we already got nchar when looking for a count.

        (cond ctrl_w
        (ยง
            ((ร ca.@nchar =) c)
            ((ร ca.cmdchar =) Ctrl_W)
        )
        :else
        (ยง
            ((ร ca.cmdchar =) c)
        ))

;       normal_end:
;       {
            ((ร int idx =) (ยง find__command(ca.cmdchar)))
            (when (< idx 0)
                ;; Not a known command: beep.
                (clearopbeep oap)
                (ร BREAK normal_end)
            )

            (when (and (text_locked) (non-zero? (& (ยง nv_cmds[idx].cmd_flags) NV_NCW)))
                ;; This command is not allowed while editing a cmdline: beep.
                (clearopbeep oap)
                (text_locked_msg)
                (ร BREAK normal_end)
            )

            ;; In Visual/Select mode, a few keys are handled in a special way.

            (when @VIsual_active
                ;; when 'keymodel' contains "stopsel" may stop Select/Visual mode
                (when (and @km_stopsel (non-zero? (& (ยง nv_cmds[idx].cmd_flags) NV_STS)) (zero? (& @mod_mask MOD_MASK_SHIFT)))
                    (end_visual_mode)
                    (redraw_curbuf_later INVERTED)
                )

                ;; Keys that work different when 'keymodel' contains "startsel".
                (when @km_startsel
                    (cond (non-zero? (& (ยง nv_cmds[idx].cmd_flags) NV_SS))
                    (ยง
                        (unshift_special ca)
                        ((ร idx =) (ยง find__command(ca.cmdchar)))
                        (when (< idx 0)
                            ;; Just in case.
                            (clearopbeep oap)
                            (ร BREAK normal_end)
                        )
                    )
                    (and (non-zero? (& (ยง nv_cmds[idx].cmd_flags) NV_SSS)) (non-zero? (& @mod_mask MOD_MASK_SHIFT)))
                    (ยง
                        ((ร @mod_mask &=) (ยง ~MOD_MASK_SHIFT))
                    ))
                )
            )

            ;; Get an additional character if we need one.

            (when (ยง (nv_cmds[idx].cmd_flags & NV_NCH) != 0 && (((nv_cmds[idx].cmd_flags & NV_NCH_NOP) == NV_NCH_NOP && oap.op_type == OP_NOP) || (nv_cmds[idx].cmd_flags & NV_NCH_ALW) == NV_NCH_ALW || (ca.cmdchar == (byte \q) && oap.op_type == OP_NOP && !@Recording && !@execReg) || ((ca.cmdchar == (byte \a) || ca.cmdchar == (byte \i)) && (oap.op_type != OP_NOP || @VIsual_active))))
                ((ร boolean repl =) false)                   ;; get character for replace mode
                ((ร boolean lit =) false)                    ;; get extra character literally

                (swap! no_mapping inc)
                (swap! allow_keys inc)                           ;; no mapping for nchar, but allow key codes
                ;; Don't generate a CursorHold event here,
                ;; most commands can't handle it, e.g. nv_replace(), nv_csearch().
                (reset! did_cursorhold true)
                (ร int[] cp)
                (cond (== (. ca cmdchar) (byte \g))
                (ยง
                    ;; For 'g' get the next character now, so that we can check for "gr", "g'" and "g`".

                    ((ร ca.@nchar =) (plain_vgetc))
                    ((ร need_flushbuf |=) (ยง add_to_showcmd(ca.@nchar)))
                    (cond (or (== @(. ca nchar) (byte \r)) (== @(. ca nchar) (byte \')) (== @(. ca nchar) (byte \`)) (== @(. ca nchar) Ctrl_BSL))
                    (ยง
                        ((ร cp =) (. ca extra_char))            ;; need to get a third character
                        (if (!= @(. ca nchar) (byte \r))
                            ((ร lit =) true)                 ;; get it literally
                            ((ร repl =) true)                ;; get it in replace mode
                        )
                    )
                    :else
                    (ยง
                        ((ร cp =) null)                      ;; no third character needed
                    ))
                )
                :else
                (ยง
                    (if (== (. ca cmdchar) (byte \r))              ;; get it in replace mode
                        ((ร repl =) true)
                    )
                    ((ร cp =) (. ca nchar))
                ))

                ((ร boolean lang =) (ยง (repl || (nv_cmds[idx].cmd_flags & NV_LANG) != 0)))

                ;; Get a second or third character.

                (when (non-nil? cp)
                    (when repl
                        (reset! State REPLACE)                ;; pretend Replace mode
                        (ui_cursor_shape)              ;; show different cursor shape
                    )

                    ((ร cp[0] =) (plain_vgetc))

                    (reset! State NORMAL_BUSY)
                    ((ร need_flushbuf |=) (ยง add_to_showcmd(cp[0])))

                    (when (not lit)
                        ;; Typing CTRL-K gets a digraph.
                        (when (and (== (ยง cp[0]) Ctrl_K) (or (non-zero? (& (ยง nv_cmds[idx].cmd_flags) NV_LANG)) (== cp (. ca extra_char))) (nil? (vim_strbyte @p_cpo, CPO_DIGRAPH)))
                            ((ร c =) (get_digraph false))
                            (when (< 0 c)
                                ((ร cp[0] =) c)
                                ;; Guessing how to update showcmd here...
                                (del_from_showcmd 3)
                                ((ร need_flushbuf |=) (ยง add_to_showcmd(cp[0])))
                            )
                        )
                    )

                    ;; When the next character is CTRL-\ a following CTRL-N means
                    ;; the command is aborted and we go to Normal mode.

                    (cond (and (== cp (. ca extra_char)) (== @(. ca nchar) Ctrl_BSL) (or (== @(. ca extra_char) Ctrl_N) (== @(. ca extra_char) Ctrl_G)))
                    (ยง
                        ((ร ca.cmdchar =) Ctrl_BSL)
                        ((ร ca.@nchar =) @(. ca extra_char))
                        ((ร idx =) (ยง find__command(ca.cmdchar)))
                    )
                    (and (or (== @(. ca nchar) (byte \n)) (== @(. ca nchar) (byte \N))) (== (. ca cmdchar) (byte \g)))
                    (ยง
                        ((ร ca.oap.op_type =) (ยง get_op_type(cp[0], NUL)))
                    )
                    (== (ยง cp[0]) Ctrl_BSL)
                    (ยง
                        ((ร long towait =) (if (<= 0 @p_ttm) @p_ttm @p_tm))

                        ;; There is a busy wait here when typing "f<C-\>" and then
                        ;; something different from CTRL-N.  Can't be avoided.
                        (while (ยง (c = vpeekc()) <= 0 && 0 < towait)
                            (do_sleep (if (< 50 towait) 50 towait))
                            ((ร towait -=) 50)
                        )
                        (when (< 0 c)
                            ((ร c =) (plain_vgetc))
                            (cond (and (!= c Ctrl_N) (!= c Ctrl_G))
                            (ยง
                                (vungetc c)
                            )
                            :else
                            (ยง
                                ((ร ca.cmdchar =) Ctrl_BSL)
                                ((ร ca.@nchar =) c)
                                ((ร idx =) (ยง find__command(ca.cmdchar)))
                            ))
                        )
                    ))

                    ;; When getting a text character and the next character is a multi-byte character,
                    ;; it could be a composing character.  However, don't wait for it to arrive.
                    ;; Also, do enable mapping, because if it's put back with vungetc() it's too late
                    ;; to apply mapping.
                    (swap! no_mapping dec)
                    (while (ยง lang && 0 < (c = vpeekc()) && (0x100 <= c || 1 < mb_byte2len(vpeekc())))
                        ((ร c =) (plain_vgetc))
                        (cond (not (utf_iscomposing c))
                        (ยง
                            (vungetc c)         ;; it wasn't, put it back
                            (ร BREAK)
                        )
                        (zero? (. ca ncharC1))
                        (ยง
                            ((ร ca.ncharC1 =) c)
                        )
                        :else
                        (ยง
                            ((ร ca.ncharC2 =) c)
                        ))
                    )
                    (swap! no_mapping inc)
                )
                (swap! no_mapping dec)
                (swap! allow_keys dec)
            )

            ;; Flush the showcmd characters onto the screen so we can see them while the command
            ;; is being executed.  Only do this when the shown command was actually displayed,
            ;; otherwise this will slow down a lot when executing mappings.

            (if need_flushbuf
                (out_flush))
            (if (!= (. ca cmdchar) K_IGNORE)
                (reset! did_cursorhold false))

            (reset! State NORMAL)

            (when (== @(. ca nchar) ESC)
                (clearop oap)
                (if (and (zero? @restart_edit) (goto_im))
                    (reset! restart_edit (byte \a)))
                (ร BREAK normal_end)
            )

            (when (!= (. ca cmdchar) K_IGNORE)
                (reset! msg_didout false)         ;; don't scroll screen up for normal command
                (reset! msg_col 0)
            )

            ((ร pos_C old_pos =) (ยง ยง_pos_C()))
            (COPY_pos old_pos, (. @curwin w_cursor))     ;; remember where cursor was

            ;; When 'keymodel' contains "startsel" some keys start Select/Visual mode.
            (when (and (not @VIsual_active) @km_startsel)
                (cond (non-zero? (& (ยง nv_cmds[idx].cmd_flags) NV_SS))
                (ยง
                    (start_selection)
                    (unshift_special ca)
                    ((ร idx =) (ยง find__command(ca.cmdchar)))
                )
                (and (non-zero? (& (ยง nv_cmds[idx].cmd_flags) NV_SSS)) (non-zero? (& @mod_mask MOD_MASK_SHIFT)))
                (ยง
                    (start_selection)
                    ((ร @mod_mask &=) (ยง ~MOD_MASK_SHIFT))
                ))
            )

            ;; Execute the command!
            ;; Call the command function found in the commands table.

            ((ร ca.arg =) (ยง nv_cmds[idx].cmd_arg))
;           nv_cmds[idx].cmd_func(ca);

            ;; If we didn't start or finish an operator, reset oap.regname, unless we need it later.

            (when (and (not @finish_op) (== (. oap op_type) OP_NOP) (or (< idx 0) (zero? (& (ยง nv_cmds[idx].cmd_flags) NV_KEEPREG))))
                (clearop oap)
            )

            ;; If an operation is pending, handle it...

            (do_pending_operator ca, old_col, false)

            ;; Wait for a moment when a message is displayed that will be overwritten by the mode message.
            ;; In Visual mode and with "^O" in Insert mode, a short message will be
            ;; overwritten by the mode message.  Wait a bit, until a key is hit.
            ;; In Visual mode, it's more important to keep the Visual area updated
            ;; than keeping a message (e.g. from a /pat search).
            ;; Only do this if the command was typed, not from a mapping.
            ;; Also wait a bit after an error message, e.g. for "^O:".
            ;; Don't redraw the screen, it would remove the message.

            (when (ยง ((@p_smd && (@restart_edit != 0 || (@VIsual_active && old_pos.lnum == @curwin.w_cursor.lnum && old_pos.col == @curwin.w_cursor.col)) && (@clear_cmdline || @redraw_cmdline) && (@msg_didout || (@msg_didany && @msg_scroll)) && !@msg_nowait && @keyTyped) || (@restart_edit != 0 && !@VIsual_active && (@msg_scroll || @emsg_on_display))) && oap.regname == 0 && (ca.retval & CA_COMMAND_BUSY) == 0 && stuff_empty() && !@did_wait_return && oap.op_type == OP_NOP)
                ((ร int save_State =) @State)

                ;; Draw the cursor with the right shape here.
                (if (non-zero? @restart_edit)
                    (reset! State INSERT))

                ;; If need to redraw, and there is a "keep_msg", redraw before the delay.
                (when (and (non-zero? @must_redraw) (non-nil? @keep_msg) (not @emsg_on_display))
                    ((ร Bytes kmsg =) @keep_msg)
                    (reset! keep_msg null)
                    ;; showmode() will clear "keep_msg", but we want to use it anyway
                    (update_screen 0)
                    ;; now reset it, otherwise it's put in the history again
                    (reset! keep_msg kmsg)
                    (msg_attr kmsg, @keep_msg_attr)
                )
                (setcursor)
                (cursor_on)
                (out_flush)
                (if (or @msg_scroll @emsg_on_display)
                    (ui_delay 1000, true))      ;; wait at least one second
                (ui_delay 3000, false)         ;; wait up to three seconds
                (reset! State save_State)

                (reset! msg_scroll false)
                (reset! emsg_on_display false)
            )
;       }

        ;; Finish up after executing a Normal mode command.

        (reset! msg_nowait false)

        ;; Reset finish_op, in case it was set.
        ((ร save_finish_op =) @finish_op)
        (reset! finish_op false)
        ;; Redraw the cursor with another shape,
        ;; if we were in Operator-pending mode or did a replace command.
        (when (or save_finish_op (== (. ca cmdchar) (byte \r)))
            (ui_cursor_shape)              ;; may show different cursor shape
        )

        (if (and (== (. oap op_type) OP_NOP) (zero? (. oap regname)) (!= (. ca cmdchar) K_CURSORHOLD))
            (clear_showcmd))

        (checkpcmark)                      ;; check if we moved since setting pcmark
        ((ร ca.searchbuf =) null)

        (mb_adjust_pos @curbuf, (. @curwin w_cursor))

        (when (and @(.. @curwin w_options wo_scb) toplevel)
            (validate_cursor)              ;; may need to update w_leftcol
            (do_check_scrollbind true)
        )

        (when (and @(.. @curwin w_options wo_crb) toplevel)
            (validate_cursor)              ;; may need to update w_leftcol
            (do_check_cursorbind)
        )

        ;; May restart edit(), if we got here with CTRL-O in Insert mode
        ;; (but not if still inside a mapping that started in Visual mode).
        ;; May switch from Visual to Select mode after CTRL-O command.

        (when (and (== (. oap op_type) OP_NOP) (or (and (non-zero? @restart_edit) (not @VIsual_active)) (== @restart_VIsual_select 1)) (zero? (& (. ca retval) CA_COMMAND_BUSY)) (stuff_empty) (zero? (. oap regname)))
            (when (== @restart_VIsual_select 1)
                (reset! VIsual_select true)
                (showmode)
                (reset! restart_VIsual_select 0)
            )
            (if (and (non-zero? @restart_edit) (not @VIsual_active))
                (edit @restart_edit, false, 1))
        )

        (if (== @restart_VIsual_select 2)
            (reset! restart_VIsual_select 1))

        ;; Save count before an operator for next time.
        (reset! opcount (. ca opcount))
    ))

;; The visual area is remembered for redo.
(atom! int      redo_VIsual_mode NUL)     ;; 'v', 'V', or Ctrl-V
(atom! long     redo_VIsual_line_count)     ;; number of lines
(atom! int      redo_VIsual_vcol)           ;; number of cols or end column
(atom! long     redo_VIsual_count)          ;; count for Visual operator

;; Handle an operator after visual mode or when the movement is finished.

(defn- #_void do_pending_operator [#_cmdarg_C cap, #_int old_col, #_boolean gui_yank]
    (ยง
        ((ร oparg_C oap =) (. cap oap))

        ((ร boolean lbr_saved =) @(.. @curwin w_options wo_lbr))
        ((ร boolean include_line_break =) false)

        ((ร pos_C old_cursor =) (ยง ยง_pos_C()))
        (COPY_pos old_cursor, (. @curwin w_cursor))

        ;; If an operation is pending, handle it...

        (when (and (or @finish_op @VIsual_active) (!= (. oap op_type) OP_NOP))
            ;; Avoid a problem with unwanted linebreaks in block mode.
            ((ร @curwin.w_options.@wo_lbr =) false)
            ((ร oap.is_VIsual =) @VIsual_active)
            (cond (== (. oap motion_force) (byte \V))
            (ยง
                ((ร oap.motion_type =) MLINE)
            )
            (== (. oap motion_force) (byte \v))
            (ยง
                ;; If the motion was linewise, "inclusive" will not have been set.
                ;; Use "exclusive" to be consistent.  Makes "dvj" work nice.
                (cond (== (. oap motion_type) MLINE)
                (ยง
                    ((ร oap.inclusive =) false)
                )
                ;; If the motion already was characterwise, toggle "inclusive".
                (== (. oap motion_type) MCHAR)
                (ยง
                    ((ร oap.inclusive =) (ยง !oap.inclusive))
                ))
                ((ร oap.motion_type =) MCHAR)
            )
            (== (. oap motion_force) Ctrl_V)
            (ยง
                ;; Change line- or characterwise motion into Visual block mode.
                (reset! VIsual_active true)
                (COPY_pos @VIsual, (. oap op_start))
                (reset! VIsual_mode Ctrl_V)
                (reset! VIsual_select false)
                (reset! VIsual_reselect false)
            ))

            ;; Only redo yank when 'y' flag is in 'cpoptions'.
            ;; Also redo Operator-pending Visual mode mappings.
            (when (ยง (vim_strbyte(@p_cpo, CPO_YANK) != null || oap.op_type != OP_YANK) && ((!@VIsual_active || oap.motion_force != 0) || (@VIsual_active && cap.cmdchar == (byte \:) && oap.op_type != OP_COLON)) && cap.cmdchar != (byte \D))
                (ยง prep_redo(oap.regname, cap.count0, get_op_char(oap.op_type), get_extra_op_char(oap.op_type), oap.motion_force, cap.cmdchar, cap.@nchar))
                (cond (or (== (. cap cmdchar) (byte \/)) (== (. cap cmdchar) (byte \?))) ;; was a search
                (ยง
                    ;; If 'cpoptions' does not contain 'r',
                    ;; insert the search pattern to really repeat the same command.

                    (if (nil? (vim_strbyte @p_cpo, CPO_REDO))
                        (appendToRedobuffLit (. cap searchbuf), -1))
                    (appendToRedobuff NL_STR)
                )
                (== (. cap cmdchar) (byte \:))
                (ยง
                    ;; do_cmdline() has stored the first typed line in "repeat_cmdline".
                    ;; When several lines are typed repeating won't be possible.

                    (cond (nil? @repeat_cmdline)
                    (ยง
                        (resetRedobuff)
                    )
                    :else
                    (ยง
                        (appendToRedobuffLit @repeat_cmdline, -1)
                        (appendToRedobuff NL_STR)
                        (reset! repeat_cmdline null)
                    ))
                ))
            )

            (cond @redo_VIsual_busy
            (ยง
                ;; Redo of an operation on a Visual area.
                ;; Use the same size from redo_VIsual_line_count and redo_VIsual_vcol.

                (COPY_pos (. oap op_start), (. @curwin w_cursor))
                ((ร @curwin.w_cursor.lnum +=) (- @redo_VIsual_line_count 1))
                (if (> (.. @curwin w_cursor lnum) (.. @curbuf b_ml ml_line_count))
                    ((ร @curwin.w_cursor.lnum =) (.. @curbuf b_ml ml_line_count))
                )
                (reset! VIsual_mode @redo_VIsual_mode)
                (when (or (== @redo_VIsual_vcol MAXCOL) (== @VIsual_mode (byte \v)))
                    (cond (== @VIsual_mode (byte \v))
                    (ยง
                        (cond (<= @redo_VIsual_line_count 1)
                        (ยง
                            (validate_virtcol)
                            ((ร @curwin.w_curswant =) (ยง @curwin.w_virtcol + @redo_VIsual_vcol - 1))
                        )
                        :else
                        (ยง
                            ((ร @curwin.w_curswant =) @redo_VIsual_vcol)
                        ))
                    )
                    :else
                    (ยง
                        ((ร @curwin.w_curswant =) MAXCOL)
                    ))
                    (coladvance (. @curwin w_curswant))
                )
                ((ร cap.count0 =) @redo_VIsual_count)
                (if (non-zero? @redo_VIsual_count)
                    ((ร cap.count1 =) @redo_VIsual_count)
                    ((ร cap.count1 =) 1)
                )
            )
            @VIsual_active
            (ยง
                (when (not gui_yank)
                    ;; Save the current VIsual area for '< and '> marks, and "gv".
                    (COPY_pos (.. @curbuf b_visual vi_start), @VIsual)
                    (COPY_pos (.. @curbuf b_visual vi_end), (. @curwin w_cursor))
                    ((ร @curbuf.b_visual.vi_mode =) @VIsual_mode)
                    (when (!= @VIsual_mode_orig NUL)
                        ((ร @curbuf.b_visual.vi_mode =) @VIsual_mode_orig)
                        (reset! VIsual_mode_orig NUL)
                    )
                    ((ร @curbuf.b_visual.vi_curswant =) (. @curwin w_curswant))
                    ((ร @curbuf.b_visual_mode_eval =) @VIsual_mode)
                )

                ;; In Select mode,
                ;; a linewise selection is operated upon like a characterwise selection.
                (cond (and @VIsual_select (== @VIsual_mode (byte \V)))
                (ยง
                    (cond (ltpos @VIsual, (. @curwin w_cursor))
                    (ยง
                        ((ร @VIsual.col =) 0)
                        ((ร @curwin.w_cursor.col =) (ยง STRLEN(ml_get(@curwin.w_cursor.lnum))))
                    )
                    :else
                    (ยง
                        ((ร @curwin.w_cursor.col =) 0)
                        ((ร @VIsual.col =) (ยง STRLEN(ml_get(@VIsual.lnum))))
                    ))
                    (reset! VIsual_mode (byte \v))
                )
                ;; If 'selection' is "exclusive", backup one character for charwise selections.
                (== @VIsual_mode (byte \v))
                (ยง
                    ((ร include_line_break =) (unadjust_for_sel))
                ))

                (COPY_pos (. oap op_start), @VIsual)
                (if (== @VIsual_mode (byte \V))
                    ((ร oap.op_start.col =) 0)
                )
            ))

            ;; Set oap.op_start to the first position of the operated text, oap.op_end
            ;; to the end of the operated text.  w_cursor is equal to oap.op_start.

            (cond (ltpos (. oap op_start), (. @curwin w_cursor))
            (ยง
                (COPY_pos (. oap op_end), (. @curwin w_cursor))
                (COPY_pos (. @curwin w_cursor), (. oap op_start))

                ;; w_virtcol may have been updated; if the cursor goes back to its previous
                ;; position, w_virtcol becomes invalid and isn't updated automatically.
                ((ร @curwin.w_valid &=) (ยง ~VALID_VIRTCOL))
            )
            :else
            (ยง
                (COPY_pos (. oap op_end), (. oap op_start))
                (COPY_pos (. oap op_start), (. @curwin w_cursor))
            ))

            ((ร oap.line_count =) (ยง oap.op_end.lnum - oap.op_start.lnum + 1))

            ;; Set "virtual_op" before resetting VIsual_active.
            (reset! virtual_op (if (virtual_active) TRUE FALSE))

            (when (or @VIsual_active @redo_VIsual_busy)
                (when (== @VIsual_mode Ctrl_V)  ;; block mode
                    ((ร oap.block_mode =) true)

; %%                ((ร int[] start =) (ยง { oap.start_vcol }))
; %%                ((ร int[] end =) (ยง { oap.end_vcol }))
                    (getvvcol @curwin, (. oap op_start), start, null, end)
                    ((ร oap.start_vcol =) (ยง start[0]))
                    ((ร oap.end_vcol =) (ยง end[0]))

                    (when (not @redo_VIsual_busy)
                        (getvvcol @curwin, (. oap op_end), start, null, end)

                        (if (< (ยง start[0]) (. oap start_vcol))
                            ((ร oap.start_vcol =) (ยง start[0]))
                        )
                        (when (< (. oap end_vcol) (ยง end[0]))
                            (if (and (== (.at @p_sel 0) (byte \e)) (<= 1 (ยง start[0])) (<= (. oap end_vcol) (- (ยง start[0]) 1)))
                                ((ร oap.end_vcol =) (ยง start[0] - 1))
                                ((ร oap.end_vcol =) (ยง end[0]))
                            )
                        )
                    )

                    ;; if '$' was used, get oap.end_vcol from longest line
                    (cond (== (. @curwin w_curswant) MAXCOL)
                    (ยง
                        ((ร @curwin.w_cursor.col =) MAXCOL)
                        ((ร oap.end_vcol =) 0)
                        ((ร FOR) (ร (ยง @curwin.w_cursor.lnum = oap.op_start.lnum) (ยง @curwin.w_cursor.lnum <= oap.op_end.lnum) (ยง @curwin.w_cursor.lnum++))
                            (getvvcol @curwin, (. @curwin w_cursor), null, null, end)
                            (if (< (. oap end_vcol) (ยง end[0]))
                                ((ร oap.end_vcol =) (ยง end[0]))
                            )
                        )
                    )
                    @redo_VIsual_busy
                    (ยง
                        ((ร oap.end_vcol =) (ยง oap.start_vcol + @redo_VIsual_vcol - 1))
                    ))

                    ;; Correct oap.op_end.col and oap.op_start.col to be the
                    ;; upper-left and lower-right corner of the block area.
                    ;;
                    ;; (Actually, this does convert column positions into character positions.)

                    ((ร @curwin.w_cursor.lnum =) (.. oap op_end lnum))
                    (coladvance (. oap end_vcol))
                    (COPY_pos (. oap op_end), (. @curwin w_cursor))

                    (COPY_pos (. @curwin w_cursor), (. oap op_start))
                    (coladvance (. oap start_vcol))
                    (COPY_pos (. oap op_start), (. @curwin w_cursor))
                )

                (when (and (not @redo_VIsual_busy) (not gui_yank))
                    ;; Prepare to reselect and redo Visual:
                    ;; this is based on the size of the Visual text

                    (reset! resel_VIsual_mode @VIsual_mode)
                    (cond (== (. @curwin w_curswant) MAXCOL)
                    (ยง
                        (reset! resel_VIsual_vcol MAXCOL)
                    )
                    :else
                    (ยง
                        (when (!= @VIsual_mode Ctrl_V)
; %%                        ((ร int[] __ =) (ยง { oap.end_vcol }))
                            (getvvcol @curwin, (. oap op_end), null, null, __)
                            ((ร oap.end_vcol =) (ยง __[0]))
                        )
                        (cond (or (== @VIsual_mode Ctrl_V) (<= (. oap line_count) 1))
                        (ยง
                            (when (!= @VIsual_mode Ctrl_V)
; %%                            ((ร int[] __ =) (ยง { oap.start_vcol }))
                                (getvvcol @curwin, (. oap op_start), __, null, null)
                                ((ร oap.start_vcol =) (ยง __[0]))
                            )
                            (reset! resel_VIsual_vcol (ยง oap.end_vcol - oap.start_vcol + 1))
                        )
                        :else
                        (ยง
                            (reset! resel_VIsual_vcol (. oap end_vcol))
                        ))
                    ))
                    (reset! resel_VIsual_line_count (. oap line_count))
                )

                ;; can't redo yank (unless 'y' is in 'cpoptions') and ":"
                (when (and (or (non-nil? (vim_strbyte @p_cpo, CPO_YANK)) (!= (. oap op_type) OP_YANK)) (!= (. oap op_type) OP_COLON) (== (. oap motion_force) NUL))
                    ;; Prepare for redoing.  Only use the nchar field for "r",
                    ;; otherwise it might be the second char of the operator.

                    (cond (and (== (. cap cmdchar) (byte \g)) (or (== @(. cap nchar) (byte \n)) (== @(. cap nchar) (byte \N))))
                    (ยง
                        (prep_redo (. oap regname), (. cap count0), (get_op_char (. oap op_type)), (get_extra_op_char (. oap op_type)), (. oap motion_force), (. cap cmdchar), @(. cap nchar))
                    )
                    (!= (. cap cmdchar) (byte \:))
                    (ยง
                        (prep_redo (. oap regname), 0, NUL, (byte \v), (get_op_char (. oap op_type)), (get_extra_op_char (. oap op_type)), (if (== (. oap op_type) OP_REPLACE) @(. cap nchar) NUL))
                    ))
                    (when (not @redo_VIsual_busy)
                        (reset! redo_VIsual_mode @resel_VIsual_mode)
                        (reset! redo_VIsual_vcol @resel_VIsual_vcol)
                        (reset! redo_VIsual_line_count @resel_VIsual_line_count)
                        (reset! redo_VIsual_count (. cap count0))
                    )
                )

                ;; oap.inclusive defaults to true.
                ;; If oap.op_end is on a NUL (empty line) oap.inclusive becomes false.
                ;; This makes "d}P" and "v}dP" work the same.

                (if (or (== (. oap motion_force) NUL) (== (. oap motion_type) MLINE))
                    ((ร oap.inclusive =) true)
                )
                (cond (== @VIsual_mode (byte \V))
                (ยง
                    ((ร oap.motion_type =) MLINE)
                )
                :else
                (ยง
                    ((ร oap.motion_type =) MCHAR)
                    (when (and (!= @VIsual_mode Ctrl_V) (== (.at (ml_get_pos (. oap op_end)) 0) NUL) (or include_line_break (== @virtual_op FALSE)))
                        ((ร oap.inclusive =) false)
                        ;; Try to include the newline,
                        ;; unless it's an operator that works on lines only.
                        (when (and (!= (.at @p_sel 0) (byte \o)) (not (op_on_lines (. oap op_type))))
                            (cond (< (.. oap op_end lnum) (.. @curbuf b_ml ml_line_count))
                            (ยง
                                (ยง oap.op_end.lnum++)
                                ((ร oap.op_end.col =) 0)
                                ((ร oap.op_end.coladd =) 0)
                                (ยง oap.line_count++)
                            )
                            :else
                            (ยง
                                ;; Cannot move below the last line, make the op inclusive
                                ;; to tell the operation to include the line break.
                                ((ร oap.inclusive =) true)
                            ))
                        )
                    )
                ))

                (reset! redo_VIsual_busy false)

                ;; Switch Visual off now, so screen updating does
                ;; not show inverted text when the screen is redrawn.
                ;; With OP_YANK and sometimes with OP_COLON and OP_FILTER there is
                ;; no screen redraw, so it is done here to remove the inverted part.

                (when (not gui_yank)
                    (reset! VIsual_active false)
                    (if @mode_displayed
                        (reset! clear_cmdline true)   ;; unshow visual mode later
                        (clear_showcmd))
                    (when (and (or (== (. oap op_type) OP_YANK) (== (. oap op_type) OP_COLON) (== (. oap op_type) OP_FUNCTION) (== (. oap op_type) OP_FILTER)) (== (. oap motion_force) NUL))
                        ;; make sure redrawing is correct
                        ((ร @curwin.w_options.@wo_lbr =) lbr_saved)
                        (redraw_curbuf_later INVERTED)
                    )
                )
            )

            ;; Include the trailing byte of a multi-byte char.
            (when (. oap inclusive)
                ((ร int l =) (ยง us_ptr2len_cc(ml_get_pos(oap.op_end))))
                (if (< 1 l)
                    ((ร oap.op_end.col +=) (- l 1))
                )
            )
            ((ร @curwin.w_set_curswant =) true)

            ;; oap.empty is set when start and end are the same.
            ;; The inclusive flag affects this too, unless yanking and the end is on a NUL.

            ((ร oap.empty =) (ยง (oap.motion_type == MCHAR && (!oap.inclusive || (oap.op_type == OP_YANK && gchar_pos(oap.op_end) == NUL)) && eqpos(oap.op_start, oap.op_end) && !(@virtual_op != FALSE && oap.op_start.coladd != oap.op_end.coladd))))

            ;; For delete, change and yank, it's an error to operate on an
            ;; empty region, when 'E' included in 'cpoptions' (Vi compatible).

            ((ร boolean empty_region_error =) (ยง (oap.empty && vim_strbyte(@p_cpo, CPO_EMPTYREGION) != null)))

            ;; Force a redraw when operating on an empty Visual region,
            ;; when 'modifiable' is off or creating a fold.
            (when (and (. oap is_VIsual) (. oap empty))
                ((ร @curwin.w_options.@wo_lbr =) lbr_saved)
                (redraw_curbuf_later INVERTED)
            )

            ;; If the end of an operator is in column one while oap.motion_type
            ;; is MCHAR and oap.inclusive is false, we put op_end after the last
            ;; character in the previous line.  If op_start is on or before the
            ;; first non-blank in the line, the operator becomes linewise
            ;; (strange, but that's the way vi does it).

            (cond (ยง oap.motion_type == MCHAR && !oap.inclusive && (cap.retval & CA_NO_ADJ_OP_END) == 0 && oap.op_end.col == 0 && (!oap.is_VIsual || @p_sel.at(0) == (byte \o)) && !oap.block_mode && 1 < oap.line_count)
            (ยง
                ((ร oap.end_adjusted =) true)    ;; remember that we did this
                (ยง --oap.line_count)
                (ยง --oap.op_end.lnum)
                (cond (inindent 0)
                (ยง
                    ((ร oap.motion_type =) MLINE)
                )
                :else
                (ยง
                    ((ร oap.op_end.col =) (ยง STRLEN(ml_get(oap.op_end.lnum))))
                    (when (< 0 (.. oap op_end col))
                        (ยง --oap.op_end.col)
                        ((ร oap.inclusive =) true)
                    )
                ))
            )
            :else
            (ยง
                ((ร oap.end_adjusted =) false)
            ))

            ((ร SWITCH) (. oap op_type)
                ((ร CASE) OP_LSHIFT)
                ((ร CASE) OP_RSHIFT)
                (ยง
                    (op_shift oap, true, (if (. oap is_VIsual) (int (. cap count1)) 1))
                    (ร BREAK)
                )

                ((ร CASE) OP_JOIN_NS)
                ((ร CASE) OP_JOIN)
                (ยง
                    (if (< (. oap line_count) 2)
                        ((ร oap.line_count =) 2)
                    )
                    (if (< (.. @curbuf b_ml ml_line_count) (ยง @curwin.w_cursor.lnum + oap.line_count - 1))
                        (beep_flush)
                        (do_join (int (. oap line_count)), (== (. oap op_type) OP_JOIN), true, true, true))
                    (ร BREAK)
                )

                ((ร CASE) OP_DELETE)
                (ยง
                    (reset! VIsual_reselect false)        ;; don't reselect now
                    (cond empty_region_error
                    (ยง
                        (vim_beep)
                        (cancelRedo)
                    )
                    :else
                    (ยง
                        (op_delete oap)
                    ))
                    (ร BREAK)
                )

                ((ร CASE) OP_YANK)
                (ยง
                    (cond empty_region_error
                    (ยง
                        (when (not gui_yank)
                            (vim_beep)
                            (cancelRedo)
                        )
                    )
                    :else
                    (ยง
                        ((ร @curwin.w_options.@wo_lbr =) lbr_saved)
                        (op_yank oap, false, (not gui_yank))
                    ))
                    (check_cursor_col)
                    (ร BREAK)
                )

                ((ร CASE) OP_CHANGE)
                (ยง
                    (reset! VIsual_reselect false)        ;; don't reselect now
                    (cond empty_region_error
                    (ยง
                        (vim_beep)
                        (cancelRedo)
                    )
                    :else
                    (ยง
                        ;; This is a new edit command, not a restart.
                        ;; Need to remember it to make 'insertmode' work with mappings for Visual mode.
                        ;; But do this only once and not when typed and 'insertmode' isn't set.
                        (ร int restart_edit_save)
                        (if (or @p_im (not @keyTyped))
                            ((ร restart_edit_save =) @restart_edit)
                            ((ร restart_edit_save =) 0)
                        )
                        (reset! restart_edit 0)
                        ;; Restore linebreak, so that when the user edits it looks as before.
                        ((ร @curwin.w_options.@wo_lbr =) lbr_saved)
                        ;; Reset finish_op now, don't want it set inside edit().
                        (reset! finish_op false)
                        (if (op_change oap)         ;; will call edit()
                            ((ร cap.retval |=) CA_COMMAND_BUSY)
                        )
                        (if (zero? @restart_edit)
                            (reset! restart_edit restart_edit_save))
                    ))
                    (ร BREAK)
                )

                ((ร CASE) OP_INDENT)
                (ยง
                    (op_reindent oap, (ยง get_c_indent))
                    (ร BREAK)
                )

                ((ร CASE) OP_FILTER)
                (ยง
                    (if (non-nil? (vim_strbyte @p_cpo, CPO_FILTER))
                        (appendToRedobuff (u8 "!\r"))    ;; use any last used !cmd
                        (reset! bangredo true))            ;; do_bang() will put cmd in redo buffer
                    (ร FALLTHROUGH)
                )

                ((ร CASE) OP_COLON)
                (ยง
                    (op_colon oap)
                    (ร BREAK)
                )

                ((ร CASE) OP_TILDE)
                ((ร CASE) OP_UPPER)
                ((ร CASE) OP_LOWER)
                ((ร CASE) OP_ROT13)
                (ยง
                    (cond empty_region_error
                    (ยง
                        (vim_beep)
                        (cancelRedo)
                    )
                    :else
                    (ยง
                        (op_tilde oap)
                    ))
                    (check_cursor_col)
                    (ร BREAK)
                )

                ((ร CASE) OP_FORMAT)
                (ยง
;                   op_format(oap, false);              ;; use internal function
                    (ร BREAK)
                )

                ((ร CASE) OP_FORMAT2)
                (ยง
;                   op_format(oap, true);               ;; use internal function
                    (ร BREAK)
                )

                ((ร CASE) OP_FUNCTION)
                (ยง
                    (op_function oap)                   ;; call 'operatorfunc'
                    (ร BREAK)
                )

                ((ร CASE) OP_INSERT)
                ((ร CASE) OP_APPEND)
                (ยง
                    (reset! VIsual_reselect false)           ;; don't reselect now
                    (cond empty_region_error
                    (ยง
                        (vim_beep)
                        (cancelRedo)
                    )
                    :else
                    (ยง
                        ;; This is a new edit command, not a restart.
                        ;; Need to remember it to make 'insertmode' work with mappings for Visual mode.
                        ;; But do this only once.
                        ((ร int restart_edit_save =) @restart_edit)
                        (reset! restart_edit 0)
                        ;; Restore linebreak, so that when the user edits it looks as before.
                        ((ร @curwin.w_options.@wo_lbr =) lbr_saved)
                        (op_insert oap, (. cap count1))
                        ;; Reset linebreak, so that formatting works correctly.
                        ((ร @curwin.w_options.@wo_lbr =) false)

                        (if (zero? @restart_edit)
                            (reset! restart_edit restart_edit_save))
                    ))
                    (ร BREAK)
                )

                ((ร CASE) OP_REPLACE)
                (ยง
                    (reset! VIsual_reselect false)    ;; don't reselect now
                    (cond empty_region_error
                    (ยง
                        (vim_beep)
                        (cancelRedo)
                    )
                    :else
                    (ยง
                        ;; Restore linebreak, so that when the user edits it looks as before.
                        ((ร @curwin.w_options.@wo_lbr =) lbr_saved)
                        (op_replace oap, @(. cap nchar))
                    ))
                    (ร BREAK)
                )

                (ร DEFAULT)
                (ยง
                    (clearopbeep oap)
                    (ร BREAK)
                )
            )

            (reset! virtual_op MAYBE)

            (cond (not gui_yank)
            (ยง
                ;; if 'sol' not set, go back to old column for some commands

                (when (and (not @p_sol) (== (. oap motion_type) MLINE) (not (. oap end_adjusted)) (or (== (. oap op_type) OP_LSHIFT) (== (. oap op_type) OP_RSHIFT) (== (. oap op_type) OP_DELETE)))
                    ((ร @curwin.w_options.@wo_lbr =) false)
                    (coladvance (ยง @curwin.w_curswant = old_col))
                )
            )
            :else
            (ยง
                (COPY_pos (. @curwin w_cursor), old_cursor)
            ))
            ((ร oap.block_mode =) false)
            (clearop oap)
        )

        ((ร @curwin.w_options.@wo_lbr =) lbr_saved)
    ))

;; Handle filter operator and visual mode ":".

(defn- #_void op_colon [#_oparg_C oap]
    (ยง
        (stuffcharReadbuff (byte \:))
        (cond (. oap is_VIsual)
        (ยง
            (stuffReadbuff (u8 "'<,'>"))
        )
        :else
        (ยง
            ;; Make the range look nice, so it can be repeated.

            (if (== (.. oap op_start lnum) (.. @curwin w_cursor lnum))
                (stuffcharReadbuff (byte \.))
                (stuffnumReadbuff (.. oap op_start lnum)))
            (when (!= (.. oap op_end lnum) (.. oap op_start lnum))
                (stuffcharReadbuff (byte \,))
                (cond (== (.. oap op_end lnum) (.. @curwin w_cursor lnum))
                (ยง
                    (stuffcharReadbuff (byte \.))
                )
                (== (.. oap op_end lnum) (.. @curbuf b_ml ml_line_count))
                (ยง
                    (stuffcharReadbuff (byte \$))
                )
                (== (.. oap op_start lnum) (.. @curwin w_cursor lnum))
                (ยง
                    (stuffReadbuff (u8 ".+"))
                    (stuffnumReadbuff (- (. oap line_count) 1))
                )
                :else
                (ยง
                    (stuffnumReadbuff (.. oap op_end lnum))
                ))
            )
        ))
        (when (!= (. oap op_type) OP_COLON)
            (stuffReadbuff (u8 "!"))
        )

        ;; do_cmdline() does the rest
    ))

;; Handle the "g@" operator: call 'operatorfunc'.

(defn- #_void op_function [#_oparg_C oap]
    (ยง
        ((ร Bytes[] argv =) (ยง new Bytes[1]))
        ((ร maybean save_virtual_op =) @virtual_op)

        (cond (eos? @p_opfunc)
        (ยง
            (emsg (u8 "E774: 'operatorfunc' is empty"))
        )
        :else
        (ยง
            ;; Set '[ and '] marks to text to be operated on.
            (COPY_pos (. @curbuf b_op_start), (. oap op_start))
            (COPY_pos (. @curbuf b_op_end), (. oap op_end))
            (when (and (!= (. oap motion_type) MLINE) (not (. oap inclusive)))
                ;; Exclude the end position.
                (decl (. @curbuf b_op_end))
            )

            (cond (. oap block_mode)
            (ยง
                ((ร argv[0] =) (u8 "block"))
            )
            (== (. oap motion_type) MLINE)
            (ยง
                ((ร argv[0] =) (u8 "line"))
            )
            :else
            (ยง
                ((ร argv[0] =) (u8 "char"))
            ))

            ;; Reset virtual_op so that 'virtualedit' can be changed in the function.
            (reset! virtual_op MAYBE)

;           call_func_retnr(@p_opfunc, 1, argv, false);

            (reset! virtual_op save_virtual_op)
        ))
    ))

(atom! boolean did_check_visual_highlight)

;; Check if highlighting for visual mode is possible, give a warning message if not.

(defn- #_void check_visual_highlight []
    (ยง
        (when @full_screen
            (if (and (not @did_check_visual_highlight) (== (hl_attr HLF_V) 0))
                (msg (u8 "Warning: terminal cannot highlight")))
            (reset! did_check_visual_highlight true)
        )
    ))

;; End Visual mode.
;; This function should ALWAYS be called to end Visual mode, except from do_pending_operator().

(defn- #_void end_visual_mode []
    (ยง
        (reset! VIsual_active false)

        ;; Save the current VIsual area for '< and '> marks, and "gv".
        ((ร @curbuf.b_visual.vi_mode =) @VIsual_mode)
        (COPY_pos (.. @curbuf b_visual vi_start), @VIsual)
        (COPY_pos (.. @curbuf b_visual vi_end), (. @curwin w_cursor))
        ((ร @curbuf.b_visual.vi_curswant =) (. @curwin w_curswant))
        ((ร @curbuf.b_visual_mode_eval =) @VIsual_mode)
        (if (not (virtual_active))
            ((ร @curwin.w_cursor.coladd =) 0)
        )

        (if @mode_displayed
            (reset! clear_cmdline true)           ;; unshow visual mode later
            (clear_showcmd))

        (adjust_cursor_eol)
    ))

;; Reset VIsual_active and VIsual_reselect.

(defn- #_void reset_VIsual_and_resel []
    (ยง
        (when @VIsual_active
            (end_visual_mode)
            (redraw_curbuf_later INVERTED)  ;; delete the inversion later
        )
        (reset! VIsual_reselect false)
    ))

;; Reset VIsual_active and VIsual_reselect if it's set.

(defn- #_void reset_VIsual []
    (ยง
        (when @VIsual_active
            (end_visual_mode)
            (redraw_curbuf_later INVERTED)  ;; delete the inversion later
            (reset! VIsual_reselect false)
        )
    ))

;; Find the identifier under or to the right of the cursor.
;; "find_type" can have one of three values:
;; FIND_IDENT:   find an identifier (keyword)
;; FIND_STRING:  find any non-white string
;; FIND_IDENT + FIND_STRING: find any non-white string, identifier preferred.
;; FIND_EVAL:    find text useful for C program debugging
;;
;; There are three steps:
;; 1. Search forward for the start of an identifier/string.
;;    Doesn't move if already on one.
;; 2. Search backward for the start of this identifier/string.
;;    This doesn't match the real Vi but I like it a little better
;;    and it shouldn't bother anyone.
;; 3. Search forward to the end of this identifier/string.
;;    When FIND_IDENT isn't defined, we backup until a blank.
;;
;; Returns the length of the string, or zero if no string is found.
;; If a string is found, a pointer to the string is put in "*string".
;; This string is not always NUL terminated.

(defn- #_int find_ident_under_cursor [#_Bytes* string, #_int find_type]
    (ยง
        (find_ident_at_pos @curwin, (.. @curwin w_cursor lnum), (.. @curwin w_cursor col), string, find_type)
    ))

;; Like find_ident_under_cursor(), but for any window and any position.
;; However: Uses 'iskeyword' from the current window!.

(defn- #_int find_ident_at_pos [#_window_C wp, #_long lnum, #_int startcol, #_Bytes* string, #_int find_type]
    (ยง
        ((ร Bytes p =) (ml_get_buf @curbuf, lnum))

        ((ร int col =) 0)
        ((ร int this_class =) 0)

        (ร int round)

        ;; if round == 0: try to find an identifier
        ;; if round == 1: try to find any non-white string

        ((ร FOR) (ร ((ร round =) (if (!= (& find_type FIND_IDENT) 0) 0 1)) (< round 2) (ยง round++))
            ;; 1. Skip to start of identifier/string.

            ((ร col =) startcol)
            (while (ยง p.at(col) != NUL)
                ((ร this_class =) (ยง us_get_class(p.plus(col), @curbuf)))
                (if (and (non-zero? this_class) (or (== round 1) (!= this_class 1)))
                    (ร BREAK)
                )
                ((ร col +=) (ยง us_ptr2len_cc(p.plus(col))))
            )

            ;; 2. Back up to start of identifier/string.

            ;; Remember class of character under cursor.
            ((ร this_class =) (ยง us_get_class(p.plus(col), @curbuf)))
            (while (ยง 0 < col && this_class != 0)
                ((ร int prevcol =) (ยง col - 1 - us_head_off(p, p.plus(col - 1))))
                ((ร int prev_class =) (ยง us_get_class(p.plus(prevcol), @curbuf)))
                (if (and (!= this_class prev_class) (or (zero? round) (zero? prev_class) (non-zero? (& find_type FIND_IDENT))))
                    (ร BREAK)
                )
                ((ร col =) prevcol)
            )

            ;; If we don't want just any old string, or we've found an identifier, stop searching.
            (if (< 2 this_class)
                ((ร this_class =) 2)
            )
            (if (or (zero? (& find_type FIND_STRING)) (== this_class 2))
                (ร BREAK)
            )
        )

        (when (or (eos? p col) (and (zero? round) (!= this_class 2)))
            ;; didn't find an identifier or string

            (if (non-zero? (& find_type FIND_STRING))
                (emsg (u8 "E348: No string under cursor"))
                (emsg e_noident))
            ((ร RETURN) 0)
        )
        ((ร p =) (ยง p.plus(col)))
        ((ร string[0] =) p)

        ;; 3. Find the end if the identifier/string.

        ((ร col =) 0)
        ;; Search for point of changing multibyte character class.
        ((ร this_class =) (us_get_class p, @curbuf))
        (while (and (!= (.at p col) NUL) (if (== round 0) (== (us_get_class (.plus p col), @curbuf) this_class) (!= (us_get_class (.plus p col), @curbuf) 0)))
            ((ร col +=) (us_ptr2len_cc (.plus p col)))
        )

        col
    ))

;; Prepare for redo of a normal command.

(defn- #_void prep_redo_cmd [#_cmdarg_C cap]
    (ยง
        (prep_redo (.. cap oap regname), (. cap count0), NUL, (. cap cmdchar), NUL, NUL, @(. cap nchar))
    ))

;; Prepare for redo of any command.
;; Note that only the last argument can be a multi-byte char.

(defn- #_void prep_redo [#_int regname, #_long num, #_int cmd1, #_int cmd2, #_int cmd3, #_int cmd4, #_int cmd5]
    (ยง
        (resetRedobuff)
        (when (non-zero? regname)   ;; yank from specified buffer
            (appendCharToRedobuff (byte \"))    ;; """
            (appendCharToRedobuff regname)
        )
        (if (non-zero? num)
            (appendNumberToRedobuff num))

        (if (!= cmd1 NUL)
            (appendCharToRedobuff cmd1))
        (if (!= cmd2 NUL)
            (appendCharToRedobuff cmd2))
        (if (!= cmd3 NUL)
            (appendCharToRedobuff cmd3))
        (if (!= cmd4 NUL)
            (appendCharToRedobuff cmd4))
        (if (!= cmd5 NUL)
            (appendCharToRedobuff cmd5))
    ))

;; check for operator active and clear it
;;
;; return true if operator was active

(defn- #_boolean checkclearop [#_oparg_C oap]
    (ยง
        (if (== (. oap op_type) OP_NOP)
            ((ร RETURN) false)
        )
        (clearopbeep oap)
        true
    ))

;; Check for operator or Visual active.  Clear active operator.
;;
;; Return true if operator or Visual was active.

(defn- #_boolean checkclearopq [#_oparg_C oap]
    (ยง
        (if (and (== (. oap op_type) OP_NOP) (not @VIsual_active))
            ((ร RETURN) false)
        )
        (clearopbeep oap)
        true
    ))

(defn- #_void clearop [#_oparg_C oap]
    (ยง
        ((ร oap.op_type =) OP_NOP)
        ((ร oap.regname =) 0)
        ((ร oap.motion_force =) NUL)
        ((ร oap.use_reg_one =) false)
    ))

(defn- #_void clearopbeep [#_oparg_C oap]
    (ยง
        (clearop oap)
        (beep_flush)
    ))

;; Remove the shift modifier from a special key.

(defn- #_void unshift_special [#_cmdarg_C cap]
    (ยง
        ((ร SWITCH) (. cap cmdchar)
            ((ร CASE) K_S_RIGHT)
            (ยง
                ((ร cap.cmdchar =) K_RIGHT)
                (ร BREAK)
            )
            ((ร CASE) K_S_LEFT)
            (ยง
                ((ร cap.cmdchar =) K_LEFT)
                (ร BREAK)
            )
            ((ร CASE) K_S_UP)
            (ยง
                ((ร cap.cmdchar =) K_UP)
                (ร BREAK)
            )
            ((ร CASE) K_S_DOWN)
            (ยง
                ((ร cap.cmdchar =) K_DOWN)
                (ร BREAK)
            )
            ((ร CASE) K_S_HOME)
            (ยง
                ((ร cap.cmdchar =) K_HOME)
                (ร BREAK)
            )
            ((ร CASE) K_S_END)
            (ยง
                ((ร cap.cmdchar =) K_END)
                (ร BREAK)
            )
        )
;       { int[] __ = { @mod_mask }; cap.cmdchar = simplify_key(cap.cmdchar, __); @mod_mask = __[0]; }
    ))

;; Routines for displaying a partly typed command

(final int SHOWCMD_BUFLEN (+ SHOWCMD_COLS 1 30))
(final Bytes    showcmd_buf     (Bytes. SHOWCMD_BUFLEN))
(final Bytes    old_showcmd_buf (Bytes. SHOWCMD_BUFLEN))    ;; for push_showcmd()
(atom! boolean  showcmd_is_clear true)
(atom! boolean  showcmd_visual)

(defn- #_void clear_showcmd []
    (ยง
        (if (not @p_sc)
            (ร RETURN)
        )

        (cond (and @VIsual_active (not (char_avail)))
        (ยง
            ((ร boolean cursor_bot =) (ยง ltpos(@VIsual, @curwin.w_cursor)))
            (ร long lines)
            (ร long top, bot)

            ;; Show the size of the Visual area.
            (cond cursor_bot
            (ยง
                ((ร top =) (. @VIsual lnum))
                ((ร bot =) (.. @curwin w_cursor lnum))
            )
            :else
            (ยง
                ((ร top =) (.. @curwin w_cursor lnum))
                ((ร bot =) (. @VIsual lnum))
            ))
            ((ร lines =) (ยง bot - top + 1))

            (cond (== @VIsual_mode Ctrl_V)
            (ยง
                ((ร Bytes saved_sbr =) @p_sbr)
                ((ร int[] leftcol =) (ยง new int[1]))
                ((ร int[] rightcol =) (ยง new int[1]))

                ;; Make 'sbr' empty for a moment to get the correct size.
                (reset! p_sbr EMPTY_OPTION)
                (getvcols @curwin, (. @curwin w_cursor), @VIsual, leftcol, rightcol)
                (reset! p_sbr saved_sbr)
                (ยง libC.sprintf(showcmd_buf, (u8 "%ldx%ld"), lines, (long)(rightcol[0] - leftcol[0] + 1)))
            )
            (or (== @VIsual_mode (byte \V)) (!= (. @VIsual lnum) (.. @curwin w_cursor lnum)))
            (ยง
                (ยง libC.sprintf(showcmd_buf, (u8 "%ld"), lines))
            )
            :else
            (ยง
                ((ร int bytes =) 0)
                ((ร int chars =) 0)

                (ร Bytes s, e)
                (cond cursor_bot
                (ยง
                    ((ร s =) (ml_get_pos @VIsual))
                    ((ร e =) (ml_get_cursor))
                )
                :else
                (ยง
                    ((ร s =) (ml_get_cursor))
                    ((ร e =) (ml_get_pos @VIsual))
                ))
                (while (if (!= (.at @p_sel 0) (byte \e)) (BLE s, e) (BLT s, e))
                    ((ร int l =) (us_ptr2len_cc s))
                    (when (zero? l)
                        (ยง bytes++)
                        (ยง chars++)
                        (ร BREAK)  ;; end of line
                    )
                    ((ร bytes +=) l)
                    (ยง chars++)
                    ((ร s =) (.plus s l))
                )
                (if (== bytes chars)
                    (.sprintf libC showcmd_buf, (u8 "%d"), chars)
                    (.sprintf libC showcmd_buf, (u8 "%d-%d"), chars, bytes)
                )
            ))
            (.be showcmd_buf SHOWCMD_COLS, NUL)      ;; truncate
            (reset! showcmd_visual true)
        )
        :else
        (ยง
            (.be showcmd_buf 0, NUL)
            (reset! showcmd_visual false)

            ;; Don't actually display something if there is nothing to clear.
            (if @showcmd_is_clear
                (ร RETURN)
            )
        ))

        (display_showcmd)
    ))

(final int* ignore_showcmd
    [
        K_IGNORE,
        K_CURSORHOLD,
        0
    ])

;; Add 'c' to string of shown command chars.
;; Return true if output has been written (and setcursor() has been called).

(defn- #_boolean add_to_showcmd [#_int c]
    (ยง
        (if (not @p_sc)
            ((ร RETURN) false)
        )

        (when @showcmd_visual
            (.be showcmd_buf 0, NUL)
            (reset! showcmd_visual false)
        )

        ;; Ignore keys that are scrollbar updates and mouse clicks.
        (when (is_special c)
            ((ร FOR) (ร (ยง int i = 0) (ยง ignore_showcmd[i] != 0) (ยง i++))
                (if (== (ยง ignore_showcmd[i]) c)
                    ((ร RETURN) false)
                )
            )
        )

        ((ร Bytes p =) (transchar c))
        (if (== (.at p 0) (byte \space))
            (STRCPY p, (u8 "<20>")))

        ((ร int old_len =) (STRLEN showcmd_buf))
        ((ร int extra_len =) (STRLEN p))
        ((ร int overflow =) (ยง old_len + extra_len - SHOWCMD_COLS))
        (if (< 0 overflow)
            (BCOPY showcmd_buf, 0, showcmd_buf, overflow, (ยง old_len - overflow + 1)))
        (STRCAT showcmd_buf, p)

        (if (char_avail)
            ((ร RETURN) false)
        )

        (display_showcmd)

        true
    ))

(defn- #_void add_to_showcmd_c [#_int c]
    (ยง
        (when (not (add_to_showcmd c))
            (setcursor)
        )
    ))

;; Delete 'len' characters from the end of the shown command.

(defn- #_void del_from_showcmd [#_int len]
    (ยง
        (if (not @p_sc)
            (ร RETURN)
        )

        ((ร int old_len =) (STRLEN showcmd_buf))
        (if (< old_len len)
            ((ร len =) old_len)
        )
        (ยง showcmd_buf.be(old_len - len, NUL))

        (when (not (char_avail))
            (display_showcmd)
        )
    ))

;; push_showcmd() and pop_showcmd() are used when waiting for the user
;; to type something and there is a partial mapping.

(defn- #_void push_showcmd []
    (ยง
        (when @p_sc
            (STRCPY old_showcmd_buf, showcmd_buf)
        )
    ))

(defn- #_void pop_showcmd []
    (ยง
        (if (not @p_sc)
            (ร RETURN)
        )

        (STRCPY showcmd_buf, old_showcmd_buf)

        (display_showcmd)
    ))

(defn- #_void display_showcmd []
    (ยง
        (cursor_off)

        ((ร int len =) (STRLEN showcmd_buf))
        (cond (zero? len)
        (ยง
            (reset! showcmd_is_clear true)
        )
        :else
        (ยง
            (screen_puts showcmd_buf, (- (int @Rows) 1), @sc_col, 0)
            (reset! showcmd_is_clear false)
        ))

        ;; clear the rest of an old message by outputting up to SHOWCMD_COLS spaces

        (screen_puts (.plus (u8 "          ") len), (- (int @Rows) 1), (+ @sc_col len), 0)

        (setcursor)            ;; put cursor back where it belongs
    ))

(atom! window_C scr_old_curwin)
(atom! long scr_old_topline)
(atom! int scr_old_leftcol)

;; When "check" is false, prepare for commands that scroll the window.
;; When "check" is true, take care of scroll-binding after the window has scrolled.
;; Called from normal_cmd() and edit().

(defn- #_void do_check_scrollbind [#_boolean check]
    (ยง
        (when (and check @(.. @curwin w_options wo_scb))
            ;; If a ":syncbind" command was just used, don't scroll, only reset the values.
            (cond @did_syncbind
            (ยง
                (reset! did_syncbind false)
            )
            (== @curwin @scr_old_curwin)
            (ยง
                ;; Synchronize other windows, as necessary according to 'scrollbind'.

                (when (or (!= (. @curwin w_topline) @scr_old_topline) (!= (. @curwin w_leftcol) @scr_old_leftcol))
                    (check_scrollbind (- (. @curwin w_topline) @scr_old_topline), (long (- (. @curwin w_leftcol) @scr_old_leftcol)))
                )
            )
            (!= (vim_strchr @p_sbo, (byte \j)) null) ;; jump flag set in 'scrollopt'
            (ยง
                ;; When switching between windows, make sure that the relative
                ;; vertical offset is valid for the new window.  The relative
                ;; offset is invalid whenever another 'scrollbind' window has
                ;; scrolled to a point that would force the current window to
                ;; scroll past the beginning or end of its buffer.  When the
                ;; resync is performed, some of the other 'scrollbind' windows may
                ;; need to jump so that the current window's relative position is
                ;; visible on-screen.

                (check_scrollbind (- (. @curwin w_topline) (. @curwin w_scbind_pos)), 0)
            ))
            ((ร @curwin.w_scbind_pos =) (. @curwin w_topline))
        )

        (reset! scr_old_curwin @curwin)
        (reset! scr_old_topline (. @curwin w_topline))
        (reset! scr_old_leftcol (. @curwin w_leftcol))
    ))

;; Synchronize any windows that have "scrollbind" set,
;; based on the number of rows by which the current window has changed.

(defn- #_void check_scrollbind [#_long topline_diff, #_long leftcol_diff]
    (ยง
        ((ร window_C old_curwin =) @curwin)
        ((ร boolean old_VIsual_select =) @VIsual_select)
        ((ร boolean old_VIsual_active =) @VIsual_active)
        ((ร int tgt_leftcol =) (. @curwin w_leftcol))

        ;; check 'scrollopt' string for vertical and horizontal scroll options

        ((ร boolean want_ver =) (ยง (vim_strchr(@p_sbo, (byte \v)) != null && topline_diff != 0)))
        ((ร boolean want_hor =) (ยง (vim_strchr(@p_sbo, (byte \h)) != null && (leftcol_diff != 0 || topline_diff != 0))))

        ;; loop through the scrollbound windows and scroll accordingly

        (reset! VIsual_select (ยง @VIsual_active = false))
        ((ร FOR) (ร (ยง @curwin = @firstwin) (!= @curwin null) (ยง @curwin = @curwin.w_next))
            ;; skip original window and windows with 'noscrollbind'
            (when (and (!= @curwin old_curwin) @(.. @curwin w_options wo_scb))
                ;; do the vertical scroll

                (when want_ver
                    ((ร @curwin.w_scbind_pos +=) topline_diff)
                    ((ร long topline =) (. @curwin w_scbind_pos))
                    (if (> topline (.. @curbuf b_ml ml_line_count))
                        ((ร topline =) (.. @curbuf b_ml ml_line_count))
                    )
                    (if (< topline 1)
                        ((ร topline =) 1)
                    )

                    ((ร long y =) (ยง topline - @curwin.w_topline))
                    (if (< 0 y)
                        (scrollup y)
                        (scrolldown (- y)))

                    (redraw_later VALID)
                    (cursor_correct)
                    ((ร @curwin.w_redr_status =) true)
                )

                ;; do the horizontal scroll

                (when (and want_hor (!= (. @curwin w_leftcol) tgt_leftcol))
                    ((ร @curwin.w_leftcol =) tgt_leftcol)
                    (leftcol_changed)
                )
            )
        )

        ;; reset current-window

        (reset! VIsual_select old_VIsual_select)
        (reset! VIsual_active old_VIsual_active)
        (reset! curwin old_curwin)
    ))

;; Command character that's ignored.
;; Used for CTRL-Q and CTRL-S to avoid problems with terminals that use xon/xoff.

(defn- #_void nv_ignore [#_cmdarg_C cap]
    (ยง
        ((ร cap.retval |=) CA_COMMAND_BUSY)      ;; don't call edit() now
    ))

;; Command character that doesn't do anything, but unlike nv_ignore()
;; does start edit().  Used for "startinsert" executed while starting up.

(defn- #_void nv_nop [#_cmdarg_C _cap]
    (ยง
    ))

;; Command character doesn't exist.

(defn- #_void nv_error [#_cmdarg_C cap]
    (ยง
        (clearopbeep (. cap oap))
    ))

;; CTRL-A and CTRL-X: Add or subtract from letter or number under cursor.

(defn- #_void nv_addsub [#_cmdarg_C cap]
    (ยง
        (when (and (not (checkclearopq (. cap oap))) (do_addsub (. cap cmdchar), (. cap count1)))
            (prep_redo_cmd cap)
        )
    ))

;; CTRL-F, CTRL-B, etc: Scroll page up or down.

(defn- #_void nv_page [#_cmdarg_C cap]
    (ยง
        (when (not (checkclearop (. cap oap)))
            (if (zero? (& @mod_mask MOD_MASK_CTRL))
                (onepage (. cap arg), (. cap count1)))
        )
    ))

;; Implementation of "gd" and "gD" command.

(defn- #_void nv_gd [#_oparg_C oap, #_int nchar, #_boolean thisblock]
    ;; thisblock: true for "1gd" and "1gD"
    (ยง
        ((ร Bytes[] ptr =) (ยง new Bytes[1]))
        ((ร int len =) (find_ident_under_cursor ptr, FIND_IDENT))
        (when (or (zero? len) (not (find_decl (ยง ptr[0]), len, (== nchar (byte \d)), thisblock, 0)))
            (clearopbeep oap)
        )
    ))

;; Move 'dist' lines in direction 'dir',
;; counting lines by *screen* lines rather than lines in the file.
;; 'dist' must be positive.
;;
;; Return true if able to move cursor, false otherwise.

(defn- #_boolean nv_screengo [#_oparg_C oap, #_int dir, #_long dist]
    (ยง
        ((ร boolean retval =) true)
        ((ร boolean atend =) false)

        ((ร int linelen =) (ยง linetabsize(ml_get_curline())))

        ((ร oap.motion_type =) MCHAR)
        ((ร oap.inclusive =) (ยง (@curwin.w_curswant == MAXCOL)))

        ((ร int col_off1 =) (curwin_col_off))                ;; margin offset for first screen line
        ((ร int col_off2 =) (ยง col_off1 - curwin_col_off2()))    ;; margin offset for wrapped screen line
        ((ร int width1 =) (ยง @curwin.w_width - col_off1))         ;; text width for first screen line
        ((ร int width2 =) (ยง @curwin.w_width - col_off2))         ;; test width for wrapped screen line
        (if (zero? width2)
            ((ร width2 =) 1)                                 ;; avoid divide by zero
        )

        (when (!= (. @curwin w_width) 0)
            ;; Instead of sticking at the last character of the buffer line we
            ;; try to stick in the last column of the screen.

            (cond (== (. @curwin w_curswant) MAXCOL)
            (ยง
                ((ร atend =) true)
                (validate_virtcol)
                (cond (<= width1 0)
                (ยง
                    ((ร @curwin.w_curswant =) 0)
                )
                :else
                (ยง
                    ((ร @curwin.w_curswant =) (- width1 1))
                    (if (< (. @curwin w_curswant) (. @curwin w_virtcol))
                        ((ร @curwin.w_curswant +=) (ยง ((@curwin.w_virtcol - @curwin.w_curswant - 1) / width2 + 1) * width2))
                    )
                ))
            )
            :else
            (ยง
                (ร int n)
                (if (< width1 linelen)
                    ((ร n =) (ยง ((linelen - width1 - 1) / width2 + 1) * width2 + width1))
                    ((ร n =) width1)
                )
                (if (> (. @curwin w_curswant) (+ n 1))
                    ((ร @curwin.w_curswant -=) (ยง ((@curwin.w_curswant - n) / width2 + 1) * width2))
                )
            ))

            (while (ยง 0 < dist--)
                (cond (== dir BACKWARD)
                (ยง
                    (cond (<= width2 (long (. @curwin w_curswant)))
                    (ยง
                        ;; move back within line
                        ((ร @curwin.w_curswant -=) width2)
                    )
                    :else
                    (ยง
                        ;; to previous line
                        (when (== (.. @curwin w_cursor lnum) 1)
                            ((ร retval =) false)
                            (ร BREAK)
                        )
                        (ยง --@curwin.w_cursor.lnum)
                        ((ร linelen =) (ยง linetabsize(ml_get_curline())))
                        (if (< width1 linelen)
                            ((ร @curwin.w_curswant +=) (ยง (((linelen - width1 - 1) / width2) + 1) * width2))
                        )
                    ))
                )
                :else ;; dir == FORWARD
                (ยง
                    (ร int n)
                    (if (< width1 linelen)
                        ((ร n =) (ยง ((linelen - width1 - 1) / width2 + 1) * width2 + width1))
                        ((ร n =) width1)
                    )
                    (cond (ยง @curwin.w_curswant + width2 < n)
                    (ยง
                        ;; move forward within line
                        ((ร @curwin.w_curswant +=) width2)
                    )
                    :else
                    (ยง
                        ;; to next line
                        (when (== (.. @curwin w_cursor lnum) (.. @curbuf b_ml ml_line_count))
                            ((ร retval =) false)
                            (ร BREAK)
                        )
                        (ยง @curwin.w_cursor.lnum++)
                        ((ร @curwin.w_curswant %=) width2)
                        ((ร linelen =) (ยง linetabsize(ml_get_curline())))
                    ))
                ))
            )
        )

        (if (and (virtual_active) atend)
            (coladvance MAXCOL)
            (coladvance (. @curwin w_curswant)))

        (when (and (< 0 (.. @curwin w_cursor col)) @(.. @curwin w_options wo_wrap))
            (ร int virtcol)

            ;; Check for landing on a character that got split at the end of the
            ;; last line.  We want to advance a screenline, not end up in the same
            ;; screenline or move two screenlines.

            (validate_virtcol)
            ((ร virtcol =) (. @curwin w_virtcol))
            (if (and (> virtcol width1) (non-eos? @p_sbr))
                ((ร virtcol -=) (mb_string2cells @p_sbr, -1))
            )

            (when (and (< (. @curwin w_curswant) virtcol) (if (< (. @curwin w_curswant) width1) (> (. @curwin w_curswant) (/ width1 2)) (ยง (@curwin.w_curswant - width1) % width2 > width2 / 2)))
                (ยง --@curwin.w_cursor.col)
            )
        )

        (if atend
            ((ร @curwin.w_curswant =) MAXCOL)     ;; stick in the last column
        )

        retval
    ))

;; Handle CTRL-E and CTRL-Y commands: scroll a line up or down.
;; cap.arg must be TRUE for CTRL-E.

(defn- #_void nv_scroll_line [#_cmdarg_C cap]
    (ยง
        (when (not (checkclearop (. cap oap)))
            (scroll_redraw (!= (. cap arg) 0), (. cap count1))
        )
    ))

;; Scroll "count" lines up or down, and redraw.

(defn- #_void scroll_redraw [#_boolean up, #_long count]
    (ยง
        ((ร long prev_topline =) (. @curwin w_topline))
        ((ร long prev_lnum =) (.. @curwin w_cursor lnum))

        (if up
            (scrollup count)
            (scrolldown count))
        (when (non-zero? @p_so)
            ;; Adjust the cursor position for 'scrolloff'.  Mark w_topline as valid,
            ;; otherwise the screen jumps back at the end of the file.
            (cursor_correct)
            (check_cursor_moved @curwin)
            ((ร @curwin.w_valid |=) VALID_TOPLINE)

            ;; If moved back to where we were, at least move the cursor, otherwise
            ;; we get stuck at one position.  Don't move the cursor up if the
            ;; first line of the buffer is already on the screen.
            (while (ยง @curwin.w_topline == prev_topline)
                (cond up
                (ยง
                    (if (or (< prev_lnum (.. @curwin w_cursor lnum)) (not (cursor_down 1, false)))
                        (ร BREAK)
                    )
                )
                :else
                (ยง
                    (if (or (< (.. @curwin w_cursor lnum) prev_lnum) (== prev_topline 1) (not (cursor_up 1, false)))
                        (ร BREAK)
                    )
                ))
                ;; Mark w_topline as valid, otherwise the screen jumps back at the end of the file.
                (check_cursor_moved @curwin)
                ((ร @curwin.w_valid |=) VALID_TOPLINE)
            )
        )
        (if (!= (.. @curwin w_cursor lnum) prev_lnum)
            (coladvance (. @curwin w_curswant)))
        (redraw_later VALID)
    ))

;; Commands that start with "z".

(defn- #_void nv_zet [#_cmdarg_C cap]
    (ยง
        ((ร int nchar =) @(. cap nchar))

;       dozet:
        (when (asc_isdigit nchar)
            ;; "z123{nchar}": edit the count before obtaining {nchar}

            (if (checkclearop (. cap oap))
                (ร RETURN)
            )

            ((ร FOR) (ร (ยง long n = nchar - (byte \0)) true nil)
                (swap! no_mapping inc)
                (swap! allow_keys inc)   ;; no mapping for nchar, but allow key codes
                ((ร nchar =) (plain_vgetc))
                (swap! no_mapping dec)
                (swap! allow_keys dec)

                (add_to_showcmd nchar)

                (cond (or (== nchar K_DEL) (== nchar K_KDEL))
                (ยง
; %%                ((ร n /=) 10)
                )
                (asc_isdigit nchar)
                (ยง
                    ((ร n =) (ยง n * 10 + (nchar - (byte \0))))
                )
                (== nchar CAR)
                (ยง
                    (win_setheight (int n))
                    (ร BREAK)
                )
                (or (== nchar (byte \l)) (== nchar (byte \h)) (== nchar K_LEFT) (== nchar K_RIGHT))
                (ยง
                    ((ร cap.count1 =) (if (!= n 0) (* n (. cap count1)) (. cap count1)))
                    (ร BREAK dozet)
                )
                :else
                (ยง
                    (clearopbeep (. cap oap))
                    (ร BREAK)
                ))
            )

            ((ร cap.oap.op_type =) OP_NOP)
            (ร RETURN)
        )

        (if (checkclearop (. cap oap))
            (ร RETURN)
        )

        ;; For "z+", "z<CR>", "zt", "z.", "zz", "z^", "z-", "zb":
        ;; If line number given, set cursor.

        (when (and (non-nil? (vim_strchr (u8 "+\r\nt.z^-b"), nchar)) (!= (. cap count0) 0) (!= (. cap count0) (.. @curwin w_cursor lnum)))
            (setpcmark)
            (if (< (.. @curbuf b_ml ml_line_count) (. cap count0))
                ((ร @curwin.w_cursor.lnum =) (.. @curbuf b_ml ml_line_count))
                ((ร @curwin.w_cursor.lnum =) (. cap count0))
            )
            (check_cursor_col)
        )

        ((ร SWITCH) nchar
            ((ร CASE) (byte \+))   ;; "z+", "z<CR>" and "zt": put cursor at top of screen
            (ยง
                (when (zero? (. cap count0))
                    ;; No count given: put cursor at the line below screen.
                    (validate_botline) ;; make sure w_botline is valid
                    (if (< (.. @curbuf b_ml ml_line_count) (. @curwin w_botline))
                        ((ร @curwin.w_cursor.lnum =) (.. @curbuf b_ml ml_line_count))
                        ((ร @curwin.w_cursor.lnum =) (. @curwin w_botline))
                    )
                )
                (ร FALLTHROUGH)
            )

            ((ร CASE) NL)
            ((ร CASE) CAR)
            ((ร CASE) K_KENTER)
            (ยง
                (beginline (| BL_WHITE BL_FIX))
                (ร FALLTHROUGH)
            )

            ((ร CASE) (byte \t))
            (ยง
                (scroll_cursor_top 0, true)
                (redraw_later VALID)
                (ร BREAK)
            )

            ((ร CASE) (byte \.))   ;; "z." and "zz": put cursor in middle of screen
            (ยง
                (beginline (| BL_WHITE BL_FIX))
                (ร FALLTHROUGH)
            )

            ((ร CASE) (byte \z))
            (ยง
                (scroll_cursor_halfway true)
                (redraw_later VALID)
                (ร BREAK)
            )

            ((ร CASE) (byte \^))   ;; "z^", "z-" and "zb": put cursor at bottom of screen
            (ยง
                ;; Strange Vi behavior:
                ;; <count>z^ finds line at top of window when <count> is at bottom of window,
                ;; and puts that one at bottom of window.
                (cond (!= (. cap count0) 0)
                (ยง
                    (scroll_cursor_bot 0, true)
                    ((ร @curwin.w_cursor.lnum =) (. @curwin w_topline))
                )
                (== (. @curwin w_topline) 1)
                (ยง
                    ((ร @curwin.w_cursor.lnum =) 1)
                )
                :else
                (ยง
                    ((ร @curwin.w_cursor.lnum =) (ยง @curwin.w_topline - 1))
                ))
                (ร FALLTHROUGH)
            )

            ((ร CASE) (byte \-))
            (ยง
                (beginline (| BL_WHITE BL_FIX))
                (ร FALLTHROUGH)
            )

            ((ร CASE) (byte \b))
            (ยง
                (scroll_cursor_bot 0, true)
                (redraw_later VALID)
                (ร BREAK)
            )

            ((ร CASE) (byte \H))   ;; "zH" - scroll screen right half-page
            (ยง
                ((ร cap.count1 *=) (ยง @curwin.w_width / 2))
                (ร FALLTHROUGH)
            )

            ((ร CASE) (byte \h))   ;; "zh" - scroll screen to the right
            ((ร CASE) K_LEFT)
            (ยง
                (when (not @(.. @curwin w_options wo_wrap))
                    (if (< (. @curwin w_leftcol) (int (. cap count1)))
                        ((ร @curwin.w_leftcol =) 0)
                        ((ร @curwin.w_leftcol -=) (ยง (int)cap.count1))
                    )
                    (leftcol_changed)
                )
                (ร BREAK)
            )

            ((ร CASE) (byte \L))   ;; "zL" - scroll screen left half-page
            (ยง
                ((ร cap.count1 *=) (ยง @curwin.w_width / 2))
                (ร FALLTHROUGH)
            )

            ((ร CASE) (byte \l))   ;; "zl" - scroll screen to the left
            ((ร CASE) K_RIGHT)
            (ยง
                (when (not @(.. @curwin w_options wo_wrap))
                    ;; scroll the window left
                    ((ร @curwin.w_leftcol +=) (ยง (int)cap.count1))
                    (leftcol_changed)
                )
                (ร BREAK)
            )

            ((ร CASE) (byte \s))   ;; "zs" - scroll screen, cursor at the start
            (ยง
                (when (not @(.. @curwin w_options wo_wrap))
                    ((ร int[] col =) (ยง new int[1]))
                    (getvcol @curwin, (. @curwin w_cursor), col, null, null)
                    (if (< @p_siso (long (ยง col[0])))
                        ((ร col[0] -=) @p_siso)
                        ((ร col[0] =) 0)
                    )
                    (when (!= (. @curwin w_leftcol) (ยง col[0]))
                        ((ร @curwin.w_leftcol =) (ยง col[0]))
                        (redraw_later NOT_VALID)
                    )
                )
                (ร BREAK)
            )

            ((ร CASE) (byte \e))   ;; "ze" - scroll screen, cursor at the end
            (ยง
                (when (not @(.. @curwin w_options wo_wrap))
                    ((ร int[] col =) (ยง new int[1]))
                    (getvcol @curwin, (. @curwin w_cursor), null, null, col)
                    ((ร long n =) (ยง @curwin.w_width - curwin_col_off()))
                    (if (< (+ (long (ยง col[0])) @p_siso) n)
                        ((ร col[0] =) 0)
                        ((ร col[0] +=) (ยง @p_siso - n + 1))
                    )
                    (when (!= (. @curwin w_leftcol) (ยง col[0]))
                        ((ร @curwin.w_leftcol =) (ยง col[0]))
                        (redraw_later NOT_VALID)
                    )
                )
                (ร BREAK)
            )

            (ร DEFAULT)
            (ยง
                (clearopbeep (. cap oap))
                (ร BREAK)
            )
        )
    ))

;; "Q" command.

(defn- #_void nv_exmode [#_cmdarg_C cap]
    (ยง
        ;; Ignore 'Q' in Visual mode, just give a beep.

        (cond @VIsual_active
        (ยง
            (vim_beep)
        )
        (not (checkclearop (. cap oap)))
        (ยง
;           do_exmode(false);
        ))
    ))

;; Handle a ":" command.

(defn- #_void nv_colon [#_cmdarg_C cap]
    (ยง
        (cond @VIsual_active
        (ยง
            (nv_operator cap)
        )
        :else
        (ยง
            (cond (!= (.. cap oap op_type) OP_NOP)
            (ยง
                ;; Using ":" as a movement is characterwise exclusive.
                ((ร cap.oap.motion_type =) MCHAR)
                ((ร cap.oap.inclusive =) false)
            )
            (!= (. cap count0) 0)
            (ยง
                ;; translate "count:" into ":.,.+(count - 1)"
                (stuffcharReadbuff (byte \.))
                (when (< 1 (. cap count0))
                    (stuffReadbuff (u8 ",.+"))
                    (stuffnumReadbuff (- (. cap count0) 1))
                )
            ))

            ;; When typing, don't type below an old message.
            (if @keyTyped
                (compute_cmdrow))

            ((ร boolean old_p_im =) @p_im)

            ;; get a command line and execute it
            ((ร boolean cmd_result =) (do_cmdline null, true, (if (!= (.. cap oap op_type) OP_NOP) DOCMD_KEEPLINE 0)))

            ;; If 'insertmode' changed, enter or exit Insert mode.
            (when (!= @p_im old_p_im)
                (if @p_im
                    (reset! restart_edit (byte \i))
                    (reset! restart_edit 0))
            )

            (cond (not cmd_result)
            (ยง
                ;; The Ex command failed, do not execute the operator.
                (clearop (. cap oap))
            )
            (and (!= (.. cap oap op_type) OP_NOP) (or (< (.. @curbuf b_ml ml_line_count) (.. cap oap op_start lnum)) (< (STRLEN (ml_get (.. cap oap op_start lnum))) (.. cap oap op_start col)) @did_emsg))
            (ยง
                ;; The start of the operator has become invalid by the Ex command.
                (clearopbeep (. cap oap))
            ))
        ))
    ))

;; Handle CTRL-G command.

(defn- #_void nv_ctrlg [#_cmdarg_C cap]
    (ยง
        (cond @VIsual_active  ;; toggle Selection/Visual mode
        (ยง
            (reset! VIsual_select (not @VIsual_select))
            (showmode)
        )
        (not (checkclearop (. cap oap)))
        (ยง
            ;; print full name if count given
            (fileinfo (int (. cap count0)), true)
        ))
    ))

;; Handle CTRL-H <Backspace> command.

(defn- #_void nv_ctrlh [#_cmdarg_C cap]
    (ยง
        (cond (and @VIsual_active @VIsual_select)
        (ยง
            ((ร cap.cmdchar =) (byte \x))  ;; BS key behaves like 'x' in Select mode
            (v_visop cap)
        )
        :else
        (ยง
            (nv_left cap)
        ))
    ))

;; CTRL-L: clear screen and redraw.

(defn- #_void nv_clear [#_cmdarg_C cap]
    (ยง
        (when (not (checkclearop (. cap oap)))
            (redraw_later CLEAR)
        )
    ))

;; CTRL-O: In Select mode: switch to Visual mode for one command.
;; Otherwise: Go to older pcmark.

(defn- #_void nv_ctrlo [#_cmdarg_C cap]
    (ยง
        (cond (and @VIsual_active @VIsual_select)
        (ยง
            (reset! VIsual_select false)
            (showmode)
            (reset! restart_VIsual_select 2)      ;; restart Select mode later
        )
        :else
        (ยง
            ((ร cap.count1 =) (ยง -cap.count1))
            (nv_pcmark cap)
        ))
    ))

;; CTRL-^ command, short for ":e #"

(defn- #_void nv_hat [#_cmdarg_C cap]
    (ยง
        (when (not (checkclearopq (. cap oap)))
;           buflist_getfile((int)cap.count0, 0, GETF_SETMARK|GETF_ALT, false);
        )
    ))

;; "Z" commands.

(defn- #_void nv_Zet [#_cmdarg_C cap]
    (ยง
        (when (not (checkclearopq (. cap oap)))
            ((ร SWITCH) @(. cap nchar)
                ;; "ZZ": equivalent to ":x".
                ((ร CASE) (byte \Z))
                (ยง
                    (do_cmdline_cmd (u8 "x"))
                    (ร BREAK)
                )

                ;; "ZQ": equivalent to ":q!" (Elvis compatible).
                ((ร CASE) (byte \Q))
                (ยง
                    (do_cmdline_cmd (u8 "q!"))
                    (ร BREAK)
                )

                (ร DEFAULT)
                (ยง
                    (clearopbeep (. cap oap))
                    (ร BREAK)
                )
            )
        )
    ))

;; Call nv_ident() as if "c1" was used, with "c2" as next character.

(defn- #_void do_nv_ident [#_int c1, #_int c2]
    (ยง
        ((ร oparg_C oa =) (ยง ยง_oparg_C()))
        ((ร cmdarg_C ca =) (ยง ยง_cmdarg_C()))

        ((ร ca.oap =) oa)
        ((ร ca.cmdchar =) c1)
        ((ร ca.@nchar =) c2)
        (nv_ident ca)
    ))

;; Handle the commands that use the word under the cursor.
;; [g] CTRL-]   :ta to current identifier
;; [g] 'K'      run program for current identifier
;; [g] '*'      / to current identifier or string
;; [g] '#'      ? to current identifier or string
;;  g  ']'      :tselect for current identifier

(defn- #_void nv_ident [#_cmdarg_C cap]
    (ยง
        ((ร int cmdchar =) (. cap cmdchar))

        ((ร boolean g_cmd =) (ยง (cmdchar == (byte \g))))
        (if g_cmd                          ;; "g*", "g#", "g]" and "gCTRL-]"
            ((ร cmdchar =) @(. cap nchar))
        )

        (if (== cmdchar (char_u POUND))       ;; the pound sign, '#' for English keyboards
            ((ร cmdchar =) (byte \#))
        )

; %%    ((ร Bytes[] ident =) (ยง { null }))
; %%    ((ร int[] n =) (ยง { 0 }))

        ;; The "]", "CTRL-]" and "K" commands accept an argument in Visual mode.

        (when (or (== cmdchar (byte \])) (== cmdchar Ctrl_RSB) (== cmdchar (byte \K)))
            (if (and @VIsual_active (not (get_visual_text cap, ident, n)))
                (ร RETURN)
            )
            (if (checkclearopq (. cap oap))
                (ร RETURN)
            )
        )

        (when (nil? (ยง ident[0]))
            ((ร int type =) (if (or (== cmdchar (byte \*)) (== cmdchar (byte \#))) (| FIND_IDENT FIND_STRING) FIND_IDENT))
            ((ร n[0] =) (find_ident_under_cursor ident, type))
            (when (zero? (ยง n[0]))
                (clearop (. cap oap))
                (ร RETURN)
            )
        )

        ;; Allocate buffer to put the command in.
        ;; Inserting backslashes can double the length of the word.
        ;; "curbuf.b_p_kp" could be added and some numbers.

        ((ร Bytes kp =) @(. @curbuf b_p_kp))    ;; value of 'keywordprg'

        ((ร Bytes buf =) (ยง new Bytes(n[0] * 2 + 30 + STRLEN(kp))))
        (.be buf 0, NUL)

        ((ร boolean tag_cmd =) false)

        ((ร SWITCH) cmdchar
            ((ร CASE) (byte \*))
            ((ร CASE) (byte \#))
            (ยง
                ;; Put cursor at start of word, makes search skip the word under the cursor.
                ;; Call setpcmark() first, so "*``" puts the cursor back where it was.

                (setpcmark)
                ((ร @curwin.w_cursor.col =) (ยง BDIFF(ident[0], ml_get_curline())))

                (if (and (not g_cmd) (us_iswordp (ยง ident[0]), @curbuf))
                    (STRCPY buf, (u8 "\\<")))
                (reset! no_smartcase true)        ;; don't use 'smartcase' now
                (ร BREAK)
            )

            ((ร CASE) (byte \K))
            (ยง
                ;; An external command will probably use an argument starting
                ;; with "-" as an option.  To avoid trouble we skip the "-".

                ((ร FOR) (ร (ยง  ) (ยง 0 < n[0] && ident[0].at(0) == (byte \-)) (ยง --n[0]))
                    ((ร ident[0] =) (ยง ident[0].plus(1)))
                )
                (when (zero? (ยง n[0]))
                    (emsg e_noident)        ;; found dashes only
                    (ร RETURN)
                )

                ;; When a count is given, turn it into a range.  Is this really what we want?
                (if (!= (. cap count0) 0)
                    (ยง libC.sprintf(buf, (u8 ".,.+%ld"), cap.count0 - 1))
                )

                (if (!= (.at kp 0) (byte \:))
                    (STRCAT buf, (u8 "!")))
                (STRCAT buf, (if (!= (.at kp 0) (byte \:)) kp (.plus kp 1)))
                (STRCAT buf, (u8 " "))
                (ร BREAK)
            )

            ((ร CASE) (byte \]))
            (ยง
                ((ร tag_cmd =) true)
                (STRCPY buf, (u8 "ts "))
                (ร BREAK)
            )

            (ร DEFAULT)
            (ยง
                ((ร tag_cmd =) true)
                (if g_cmd
                    (STRCPY buf, (u8 "tj "))
                    (ยง libC.sprintf(buf, (u8 "%ldta "), cap.count0))
                )
                (ร BREAK)
            )
        )

        ;; Now grab the chars in the identifier

        (ร Bytes aux)
        (cond (== cmdchar (byte \*))
        (ยง
            ((ร aux =) (if @p_magic (u8 "/.*~[^$\\") (u8 "/^$\\")))
        )
        (== cmdchar (byte \#))
        (ยง
            ((ร aux =) (if @p_magic (u8 "/?.*~[^$\\") (u8 "/?^$\\")))
        )
        tag_cmd
        (ยง
            ((ร aux =) (u8 "\\|\"\n["))
        )
        :else
        (ยง
            ((ร aux =) (u8 "\\|\"\n*?["))
        ))

        ((ร Bytes p =) (ยง buf.plus(STRLEN(buf))))
        (while (ยง 0 < n[0]--)
            ;; put a backslash before \ and some others
            (if (non-nil? (ยง vim_strchr(aux, ident[0].at(0))))
                (ยง (p = p.plus(1)).be(-1, (byte \\)))
            )

            ;; When current byte is part of multibyte character, copy all bytes of the character.
            ((ร FOR) (ร (ยง int i = 0, len = us_ptr2len_cc(ident[0]) - 1) (ยง i < len && 1 <= n[0]) (ยง ++i, --n[0]))
                (ยง (p = p.plus(1)).be(-1, (ident[0] = ident[0].plus(1)).at(-1)))
            )

            (ยง (p = p.plus(1)).be(-1, (ident[0] = ident[0].plus(1)).at(-1)))
        )
        (.be p 0, NUL)

        ;; Execute the command.

        (cond (or (== cmdchar (byte \*)) (== cmdchar (byte \#)))
        (ยง
            (if (and (not g_cmd) (us_iswordp (us_prevptr (ml_get_curline), (ยง ident[0])), @curbuf))
                (STRCAT buf, (u8 "\\>")))
            ;; put pattern in search history
            (init_history)
            (add_to_history HIST_SEARCH, buf, NUL)
            (normal_search cap, (if (== cmdchar (byte \*)) (byte \/) (byte \?)), buf, 0)
        )
        :else
        (ยง
            (do_cmdline_cmd buf)
        ))
    ))

;; Get visually selected text, within one line only.
;; Returns false if more than one line selected.

(defn- #_boolean get_visual_text [#_cmdarg_C cap, #_Bytes* pp, #_int* lenp]
    ;; pp: return: start of selected text
    ;; lenp: return: length of selected text
    (ยง
        (if (!= @VIsual_mode (byte \V))
            (unadjust_for_sel))
        (when (!= (. @VIsual lnum) (.. @curwin w_cursor lnum))
            (if (non-nil? cap)
                (clearopbeep (. cap oap)))
            ((ร RETURN) false)
        )
        (cond (== @VIsual_mode (byte \V))
        (ยง
            ((ร pp[0] =) (ml_get_curline))
            ((ร lenp[0] =) (ยง STRLEN(pp[0])))
        )
        :else
        (ยง
            (cond (ltpos (. @curwin w_cursor), @VIsual)
            (ยง
                ((ร pp[0] =) (ยง ml_get_pos(@curwin.w_cursor)))
                ((ร lenp[0] =) (ยง @VIsual.col - @curwin.w_cursor.col + 1))
            )
            :else
            (ยง
                ((ร pp[0] =) (ml_get_pos @VIsual))
                ((ร lenp[0] =) (ยง @curwin.w_cursor.col - @VIsual.col + 1))
            ))

            ;; Correct the length to include the whole last character.
            ((ร lenp[0] +=) (ยง us_ptr2len_cc(pp[0].plus(lenp[0] - 1)) - 1))
        ))
        (reset_VIsual_and_resel)
        true
    ))

;; Handle scrolling command 'H', 'L' and 'M'.

(defn- #_void nv_scroll [#_cmdarg_C cap]
    (ยง
        ((ร cap.oap.motion_type =) MLINE)
        (setpcmark)

        (cond (== (. cap cmdchar) (byte \L))
        (ยง
            (validate_botline)         ;; make sure curwin.w_botline is valid
            ((ร @curwin.w_cursor.lnum =) (ยง @curwin.w_botline - 1))
            (cond (<= (.. @curwin w_cursor lnum) (- (. cap count1) 1))
            (ยง
                ((ร @curwin.w_cursor.lnum =) 1)
            )
            :else
            (ยง
                ((ร @curwin.w_cursor.lnum -=) (ยง cap.count1 - 1))
            ))
        )
        :else
        (ยง
            (ร long n)
            (cond (== (. cap cmdchar) (byte \M))
            (ยง
                (validate_botline)     ;; make sure w_empty_rows is valid

                ((ร int half =) (ยง (@curwin.w_height - @curwin.w_empty_rows + 1) / 2))
                ((ร int used =) 0)
                ((ร FOR) (ร (ยง n = 0) (ยง @curwin.w_topline + n < @curbuf.b_ml.ml_line_count) (ยง n++))
                    ((ร used +=) (ยง plines(@curwin.w_topline + n)))
                    (if (<= half used)
                        (ร BREAK)
                    )
                )
                (if (and (< 0 n) (< (. @curwin w_height) used))
                    (ยง --n)
                )
            )
            :else ;; (cap.cmdchar == 'H')
            (ยง
                ((ร n =) (ยง cap.count1 - 1))
            ))
            ((ร @curwin.w_cursor.lnum =) (ยง @curwin.w_topline + n))
            (if (> (.. @curwin w_cursor lnum) (.. @curbuf b_ml ml_line_count))
                ((ร @curwin.w_cursor.lnum =) (.. @curbuf b_ml ml_line_count))
            )
        ))

        (cursor_correct)   ;; correct for 'so'
        (beginline (| BL_SOL BL_FIX))
    ))

;; Cursor right commands.

(defn- #_void nv_right [#_cmdarg_C cap]
    (ยง
        (when (non-zero? (ยง @mod_mask & (MOD_MASK_SHIFT | MOD_MASK_CTRL)))
            ;; <C-Right> and <S-Right> move a word or WORD right
            (if (non-zero? (& @mod_mask MOD_MASK_CTRL))
                ((ร cap.arg =) TRUE)
            )
            (nv_wordcmd cap)
            (ร RETURN)
        )

        ((ร cap.oap.motion_type =) MCHAR)
        ((ร cap.oap.inclusive =) false)
        ((ร boolean past_line =) (ยง (@VIsual_active && @p_sel.at(0) != (byte \o))))

        ;; In virtual edit mode, there's no such thing as "past_line",
        ;; as lines are (theoretically) infinitely long.

        (if (virtual_active)
            ((ร past_line =) false)
        )

        ((ร FOR) (ร (ยง long n = cap.count1) (< 0 n) (ยง --n))
            (cond (or (and (not past_line) (not (oneright))) (and past_line (== (.at (ml_get_cursor) 0) NUL)))
            (ยง
                ;;    <Space> wraps to next line if 'whichwrap' has 's'.
                ;;        'l' wraps to next line if 'whichwrap' has 'l'.
                ;; CURS_RIGHT wraps to next line if 'whichwrap' has '>'.

                (when (and (or (and (== (. cap cmdchar) (byte \space)) (!= (vim_strchr @p_ww, (byte \s)) null)) (and (== (. cap cmdchar) (byte \l)) (!= (vim_strchr @p_ww, (byte \l)) null)) (and (== (. cap cmdchar) K_RIGHT) (!= (vim_strchr @p_ww, (byte \>)) null))) (< (.. @curwin w_cursor lnum) (.. @curbuf b_ml ml_line_count)))
                    ;; When deleting we also count the NL as a character.
                    ;; Set cap.oap.inclusive when last char in the line is
                    ;; included, move to next line after that
                    (cond (and (!= (.. cap oap op_type) OP_NOP) (not (.. cap oap inclusive)) (not (lineempty (.. @curwin w_cursor lnum))))
                    (ยง
                        ((ร cap.oap.inclusive =) true)
                    )
                    :else
                    (ยง
                        (ยง @curwin.w_cursor.lnum++)
                        ((ร @curwin.w_cursor.col =) 0)
                        ((ร @curwin.w_cursor.coladd =) 0)
                        ((ร @curwin.w_set_curswant =) true)
                        ((ร cap.oap.inclusive =) false)
                    ))
                    (ร CONTINUE)
                )
                (cond (== (.. cap oap op_type) OP_NOP)
                (ยง
                    ;; Only beep and flush if not moved at all.
                    (if (== n (. cap count1))
                        (beep_flush))
                )
                :else
                (ยง
                    (if (not (lineempty (.. @curwin w_cursor lnum)))
                        ((ร cap.oap.inclusive =) true)
                    )
                ))
                (ร BREAK)
            )
            past_line
            (ยง
                ((ร @curwin.w_set_curswant =) true)
                (if (virtual_active)
                    (oneright)
                    ((ร @curwin.w_cursor.col +=) (ยง us_ptr2len_cc(ml_get_cursor())))
                )
            ))
        )
    ))

;; Cursor left commands.
;;
;; Returns true when operator end should not be adjusted.

(defn- #_void nv_left [#_cmdarg_C cap]
    (ยง
        (when (non-zero? (ยง @mod_mask & (MOD_MASK_SHIFT | MOD_MASK_CTRL)))
            ;; <C-Left> and <S-Left> move a word or WORD left
            (if (non-zero? (& @mod_mask MOD_MASK_CTRL))
                ((ร cap.arg =) 1)
            )
            (nv_bck_word cap)
            (ร RETURN)
        )

        ((ร cap.oap.motion_type =) MCHAR)
        ((ร cap.oap.inclusive =) false)

        ((ร FOR) (ร (ยง long n = cap.count1) (< 0 n) (ยง --n))
            (when (not (oneleft))
                ;; <BS> and <Del> wrap to previous line if 'whichwrap' has 'b'.
                ;;           'h' wraps to previous line if 'whichwrap' has 'h'.
                ;;     CURS_LEFT wraps to previous line if 'whichwrap' has '<'.

                (cond (and (or (and (or (== (. cap cmdchar) K_BS) (== (. cap cmdchar) Ctrl_H)) (!= (vim_strchr @p_ww, (byte \b)) null)) (or (and (== (. cap cmdchar) (byte \h)) (!= (vim_strchr @p_ww, (byte \h)) null)) (and (== (. cap cmdchar) K_LEFT) (!= (vim_strchr @p_ww, (byte \<)) null)))) (< 1 (.. @curwin w_cursor lnum)))
                (ยง
                    (ยง --@curwin.w_cursor.lnum)
                    (coladvance MAXCOL)
                    ((ร @curwin.w_set_curswant =) true)

                    ;; When the NL before the first char has to be deleted we
                    ;; put the cursor on the NUL after the previous line.
                    ;; This is a very special case, be careful!
                    ;; Don't adjust op_end now, otherwise it won't work.
                    (when (and (or (== (.. cap oap op_type) OP_DELETE) (== (.. cap oap op_type) OP_CHANGE)) (not (lineempty (.. @curwin w_cursor lnum))))
                        ((ร Bytes cp =) (ml_get_cursor))

                        (if (non-eos? cp)
                            ((ร @curwin.w_cursor.col +=) (us_ptr2len_cc cp))
                        )
                        ((ร cap.retval |=) CA_NO_ADJ_OP_END)
                    )
                    (ร CONTINUE)
                )
                ;; Only beep and flush if not moved at all.
                (and (== (.. cap oap op_type) OP_NOP) (== n (. cap count1)))
                (ยง
                    (beep_flush)
                ))
                (ร BREAK)
            )
        )
    ))

;; Cursor up commands.
;; cap.arg is TRUE for "-": Move cursor to first non-blank.

(defn- #_void nv_up [#_cmdarg_C cap]
    (ยง
        (cond (non-zero? (& @mod_mask MOD_MASK_SHIFT))
        (ยง
            ;; <S-Up> is page up
            ((ร cap.arg =) BACKWARD)
            (nv_page cap)
        )
        :else
        (ยง
            ((ร cap.oap.motion_type =) MLINE)
            (cond (not (cursor_up (. cap count1), (== (.. cap oap op_type) OP_NOP)))
            (ยง
                (clearopbeep (. cap oap))
            )
            (!= (. cap arg) 0)
            (ยง
                (beginline (| BL_WHITE BL_FIX))
            ))
        ))
    ))

;; Cursor down commands.
;; cap.arg is TRUE for CR and "+": Move cursor to first non-blank.

(defn- #_void nv_down [#_cmdarg_C cap]
    (ยง
        (cond (non-zero? (& @mod_mask MOD_MASK_SHIFT))
        (ยง
            ;; <S-Down> is page down
            ((ร cap.arg =) FORWARD)
            (nv_page cap)
        )
        :else
        (ยง
            ;; In the cmdline window a <CR> executes the command.
            (cond (and (non-zero? @cmdwin_type) (== (. cap cmdchar) CAR))
            (ยง
                (reset! cmdwin_result CAR)
            )
            :else
            (ยง
                ((ร cap.oap.motion_type =) MLINE)
                (cond (not (cursor_down (. cap count1), (== (.. cap oap op_type) OP_NOP)))
                (ยง
                    (clearopbeep (. cap oap))
                )
                (!= (. cap arg) 0)
                (ยง
                    (beginline (| BL_WHITE BL_FIX))
                ))
            ))
        ))
    ))

;; <End> command: to end of current line or last line.

(defn- #_void nv_end [#_cmdarg_C cap]
    (ยง
        (when (or (!= (. cap arg) 0) (non-zero? (& @mod_mask MOD_MASK_CTRL)))    ;; CTRL-END = goto last line
            ((ร cap.arg =) TRUE)
            (nv_goto cap)
            ((ร cap.count1 =) 1)             ;; to end of current line
        )
        (nv_dollar cap)
    ))

;; Handle the "$" command.

(defn- #_void nv_dollar [#_cmdarg_C cap]
    (ยง
        ((ร cap.oap.motion_type =) MCHAR)
        ((ร cap.oap.inclusive =) true)

        ;; In virtual mode when off the edge of a line and an operator
        ;; is pending (whew!) keep the cursor where it is.
        ;; Otherwise, send it to the end of the line.

        (if (or (not (virtual_active)) (!= (gchar_cursor) NUL) (== (.. cap oap op_type) OP_NOP))
            ((ร @curwin.w_curswant =) MAXCOL)     ;; so we stay at the end
        )
        (when (not (cursor_down (- (. cap count1) 1), (== (.. cap oap op_type) OP_NOP)))
            (clearopbeep (. cap oap))
        )
    ))

;; Implementation of '?' and '/' commands.
;; If cap.arg is TRUE, don't set PC mark.

(defn- #_void nv_search [#_cmdarg_C cap]
    (ยง
        ((ร oparg_C oap =) (. cap oap))

        (when (and (== (. cap cmdchar) (byte \?)) (== (.. cap oap op_type) OP_ROT13))
            ;; Translate "g??" to "g?g?".
            ((ร cap.cmdchar =) (byte \g))
            ((ร cap.@nchar =) (byte \?))
            (nv_operator cap)
            (ร RETURN)
        )

        ((ร cap.searchbuf =) (ยง getcmdline(cap.cmdchar, cap.count1)))

        (when (nil? (. cap searchbuf))
            (clearop oap)
            (ร RETURN)
        )

        (normal_search cap, (byte (. cap cmdchar)), (. cap searchbuf), (if (!= (. cap arg) 0) 0 SEARCH_MARK))
    ))

;; Handle "N" and "n" commands.
;; cap.arg is SEARCH_REV for "N", 0 for "n".

(defn- #_void nv_next [#_cmdarg_C cap]
    (ยง
        ((ร pos_C old =) (ยง ยง_pos_C()))
        (COPY_pos old, (. @curwin w_cursor))
        ((ร int i =) (ยง normal_search(cap, NUL, null, SEARCH_MARK | cap.arg)))

        (when (and (== i 1) (eqpos old, (. @curwin w_cursor)))
            ;; Avoid getting stuck on the current cursor position, which can
            ;; happen when an offset is given and the cursor is on the last char
            ;; in the buffer: Repeat with count + 1.
            ((ร cap.count1 +=) 1)
            (normal_search cap, NUL, null, (ยง SEARCH_MARK | cap.arg))
            ((ร cap.count1 -=) 1)
        )
    ))

;; Search for "pat" in direction "dirc" ('/' or '?', 0 for repeat).
;; Uses only cap.count1 and cap.oap from "cap".
;; Return 0 for failure, 1 for found, 2 for found and line offset added.

(defn- #_int normal_search [#_cmdarg_C cap, #_byte dirc, #_Bytes pat, #_int opt]
    ;; opt: extra flags for do_search()
    (ยง
        ((ร cap.oap.motion_type =) MCHAR)
        ((ร cap.oap.inclusive =) false)
        ((ร cap.oap.use_reg_one =) true)
        ((ร @curwin.w_set_curswant =) true)

        ((ร int i =) (ยง do_search(cap.oap, dirc, pat, cap.count1, opt | SEARCH_OPT | SEARCH_ECHO | SEARCH_MSG, null)))
        (cond (zero? i)
        (ยง
            (clearop (. cap oap))
        )
        :else
        (ยง
            (if (== i 2)
                ((ร cap.oap.motion_type =) MLINE)
            )
            ((ร @curwin.w_cursor.coladd =) 0)
        ))

        ;; "/$" will put the cursor after the end of the line, may need to correct that here
        (check_cursor)
        i
    ))

;; Character search commands.
;; cap.arg is BACKWARD for 'F' and 'T', FORWARD for 'f' and 't', TRUE for ',' and FALSE for ';'.
;; cap.nchar is NUL for ',' and ';' (repeat the search).

(defn- #_void nv_csearch [#_cmdarg_C cap]
    (ยง
        ((ร boolean t_cmd =) (ยง (cap.cmdchar == (byte \t) || cap.cmdchar == (byte \T))))

        ((ร cap.oap.motion_type =) MCHAR)
        (cond (or (is_special @(. cap nchar)) (not (searchc cap, t_cmd)))
        (ยง
            (clearopbeep (. cap oap))
        )
        :else
        (ยง
            ((ร @curwin.w_set_curswant =) true)
            ;; Include a Tab for "tx" and for "dfx".
            (cond (and (== (gchar_cursor) TAB) (virtual_active) (== (. cap arg) FORWARD) (or t_cmd (!= (.. cap oap op_type) OP_NOP)))
            (ยง
                ((ร int[] scol =) (ยง new int[1]))
                ((ร int[] ecol =) (ยง new int[1]))

                (getvcol @curwin, (. @curwin w_cursor), scol, null, ecol)
                ((ร @curwin.w_cursor.coladd =) (ยง ecol[0] - scol[0]))
            )
            :else
            (ยง
                ((ร @curwin.w_cursor.coladd =) 0)
            ))
            (adjust_for_sel cap)
        ))
    ))

;; "[" and "]" commands.
;; cap.arg is BACKWARD for "[" and FORWARD for "]".

(defn- #_void nv_brackets [#_cmdarg_C cap]
    (ยง
        ((ร cap.oap.motion_type =) MCHAR)
        ((ร cap.oap.inclusive =) false)
        ((ร pos_C old_pos =) (ยง ยง_pos_C()))
        (COPY_pos old_pos, (. @curwin w_cursor))     ;; cursor position before command
        ((ร @curwin.w_cursor.coladd =) 0)             ;; TODO: don't do this for an error

        ((ร pos_C prev_pos =) (ยง ยง_pos_C()))

        ;; "[{", "[(", "]}" or "])": go to Nth unclosed '{', '(', '}' or ')'
        ;; "[#", "]#": go to start/end of Nth innermost #if..#endif construct.
        ;; "[/", "[*", "]/", "]*": go to Nth comment start/end.
        ;; "[m" or "]m" search for prev/next start of (Java) method.
        ;; "[M" or "]M" search for prev/next end of (Java) method.

        (cond (or (and (== (. cap cmdchar) (byte \[)) (non-nil? (vim_strchr (u8 "{(*/#mM"), @(. cap nchar)))) (and (== (. cap cmdchar) (byte \])) (non-nil? (vim_strchr (u8 "})*/#mM"), @(. cap nchar)))))
        (ยง
            (if (== @(. cap nchar) (byte \*))
                ((ร cap.@nchar =) (byte \/))
            )

            (ร int findc)
            (ร long n)
            (cond (or (== @(. cap nchar) (byte \m)) (== @(. cap nchar) (byte \M)))
            (ยง
                (if (== (. cap cmdchar) (byte \[))
                    ((ร findc =) (byte \{))
                    ((ร findc =) (byte \}))
                )
                ((ร n =) 9999)
            )
            :else
            (ยง
                ((ร findc =) @(. cap nchar))
                ((ร n =) (. cap count1))
            ))

            ((ร pos_C pos =) null)
            ((ร prev_pos.lnum =) 0)
            ((ร pos_C new_pos =) (ยง ยง_pos_C()))

            ((ร FOR) (ร (ยง  ) (< 0 n) (ยง --n))
                ((ร pos =) (findmatchlimit (. cap oap), findc, (if (== (. cap cmdchar) (byte \[)) FM_BACKWARD FM_FORWARD), 0))
                (when (nil? pos)
                    (cond (zero? (. new_pos lnum)) ;; nothing found
                    (ยง
                        (if (and (!= @(. cap nchar) (byte \m)) (!= @(. cap nchar) (byte \M)))
                            (clearopbeep (. cap oap)))
                    )
                    :else
                    (ยง
                        ((ร pos =) new_pos)      ;; use last one found
                    ))
                    (ร BREAK)
                )
                (COPY_pos prev_pos, new_pos)
                (COPY_pos (. @curwin w_cursor), pos)
                (COPY_pos new_pos, pos)
            )
            (COPY_pos (. @curwin w_cursor), old_pos)

            ;; Handle "[m", "]m", "[M" and "[M".  The findmatchlimit() only
            ;; brought us to the match for "[m" and "]M" when inside a method.
            ;; Try finding the '{' or '}' we want to be at.
            ;; Also repeat for the given count.

            (when (or (== @(. cap nchar) (byte \m)) (== @(. cap nchar) (byte \M)))
                ;; norm is true for "]M" and "[m"
                ((ร boolean norm =) (ยง ((findc == (byte \{)) == (cap.@nchar == (byte \m)))))

                ((ร n =) (. cap count1))
                ;; found a match: we were inside a method
                (cond (!= (. prev_pos lnum) 0)
                (ยง
                    ((ร pos =) prev_pos)
                    (COPY_pos (. @curwin w_cursor), prev_pos)
                    (if norm
                        (ยง --n)
                    )
                )
                :else
                (ยง
                    ((ร pos =) null)
                ))
                ((ร FOR) (ร (ยง  ) (< 0 n) (ยง --n))
                    (while true
                        (when (< (if (== findc (byte \{)) (dec_cursor) (inc_cursor)) 0)
                            ;; if not found anything, that's an error
                            (if (nil? pos)
                                (clearopbeep (. cap oap)))
                            ((ร n =) 0)
                            (ร BREAK)
                        )
                        ((ร int c =) (gchar_cursor))
                        (when (or (== c (byte \{)) (== c (byte \})))
                            ;; Must have found end/start of class: use it.
                            ;; Or found the place to be at.
                            (cond (or (and (== c findc) norm) (and (== n 1) (not norm)))
                            (ยง
                                (COPY_pos new_pos, (. @curwin w_cursor))
                                ((ร pos =) new_pos)
                                ((ร n =) 0)
                            )
                            ;; If no match found at all, we started outside of the class
                            ;; and we're inside now.  Just go on.
                            (zero? (. new_pos lnum))
                            (ยง
                                (COPY_pos new_pos, (. @curwin w_cursor))
                                ((ร pos =) new_pos)
                            )
                            ;; found start/end of other method: go to match
                            (nil? ((ร pos =) (findmatchlimit (. cap oap), findc, (if (== (. cap cmdchar) (byte \[)) FM_BACKWARD FM_FORWARD), 0)))
                            (ยง
                                ((ร n =) 0)
                            )
                            :else
                            (ยง
                                (COPY_pos (. @curwin w_cursor), pos)
                            ))
                            (ร BREAK)
                        )
                    )
                )
                (COPY_pos (. @curwin w_cursor), old_pos)
                (if (and (nil? pos) (!= (. new_pos lnum) 0))
                    (clearopbeep (. cap oap)))
            )
            (when (non-nil? pos)
                (setpcmark)
                (COPY_pos (. @curwin w_cursor), pos)
                ((ร @curwin.w_set_curswant =) true)
            )
        )

        ;; "[[", "[]", "]]" and "][": move to start or end of function

        (or (== @(. cap nchar) (byte \[)) (== @(. cap nchar) (byte \])))
        (ยง
            (ร int flag)
            (if (== @(. cap nchar) (. cap cmdchar))   ;; "]]" or "[["
                ((ร flag =) (byte \{))
                ((ร flag =) (byte \}))                 ;; "][" or "[]"
            )

            ((ร @curwin.w_set_curswant =) true)

            ;; Imitate strange Vi behaviour: When using "]]" with an operator we also stop at '}'.

            (ร boolean b)
;           { boolean[] __ = { cap.oap.inclusive }; b = findpar(__, cap.arg, cap.count1, flag, (cap.oap.op_type != OP_NOP && cap.arg == FORWARD && flag == (byte \{))); cap.oap.inclusive = __[0]; }
            (cond (not b)
            (ยง
                (clearopbeep (. cap oap))
            )
            :else
            (ยง
                (if (== (.. cap oap op_type) OP_NOP)
                    (beginline (| BL_WHITE BL_FIX)))
            ))
        )

        ;; "[p", "[P", "]P" and "]p": put with indent adjustment

        (or (== @(. cap nchar) (byte \p)) (== @(. cap nchar) (byte \P)))
        (ยง
            (when (not (checkclearop (. cap oap)))
                ((ร int dir =) (if (and (== (. cap cmdchar) (byte \])) (== @(. cap nchar) (byte \p))) FORWARD BACKWARD))
                ((ร int regname =) (.. cap oap regname))
                ((ร boolean was_visual =) @VIsual_active)
                ((ร long line_count =) (.. @curbuf b_ml ml_line_count))

                ((ร pos_C start =) (ยง ยง_pos_C()))
                ((ร pos_C end =) (ยง ยง_pos_C()))
                (when @VIsual_active
                    (COPY_pos start, (if (ltoreq @VIsual, (. @curwin w_cursor)) @VIsual (. @curwin w_cursor)))
                    (COPY_pos end, (if (eqpos start, @VIsual) (. @curwin w_cursor) @VIsual))
                    (COPY_pos (. @curwin w_cursor), (if (== dir BACKWARD) start end))
                )

                ((ร regname =) (adjust_clip_reg regname))
                (prep_redo_cmd cap)

                (do_put regname, dir, (int (. cap count1)), PUT_FIXINDENT)

                (when was_visual
                    (COPY_pos @VIsual, start)
                    (COPY_pos (. @curwin w_cursor), end)
                    (when (== dir BACKWARD)
                        ;; adjust lines
                        ((ร @VIsual.lnum +=) (ยง @curbuf.b_ml.ml_line_count - line_count))
                        ((ร @curwin.w_cursor.lnum +=) (ยง @curbuf.b_ml.ml_line_count - line_count))
                    )

                    (reset! VIsual_active true)
                    (when (== @VIsual_mode (byte \V))
                        ;; delete visually selected lines
                        ((ร cap.cmdchar =) (byte \d))
                        ((ร cap.@nchar =) NUL)
                        ((ร cap.oap.regname =) regname)
                        (nv_operator cap)
                        (do_pending_operator cap, 0, false)
                    )
                    (when @VIsual_active
                        (end_visual_mode)
                        (redraw_later SOME_VALID)
                    )
                )
            )
        )

        ;; "['", "[`", "]'" and "]`": jump to next mark

        (or (== @(. cap nchar) (byte \')) (== @(. cap nchar) (byte \`)))
        (ยง
            ((ร pos_C pos =) (. @curwin w_cursor))
            ((ร FOR) (ร (ยง long n = cap.count1) (< 0 n) (ยง --n))
                (COPY_pos prev_pos, pos)
                ((ร pos =) (getnextmark pos, (if (== (. cap cmdchar) (byte \[)) BACKWARD FORWARD), (== @(. cap nchar) (byte \'))))
                (if (nil? pos)
                    (ร BREAK)
                )
            )
            (if (nil? pos)
                ((ร pos =) prev_pos)
            )
            (nv_cursormark cap, (== @(. cap nchar) (byte \')), pos)
        )

        ;; Not a valid cap.nchar.
        :else
        (ยง
            (clearopbeep (. cap oap))
        ))
    ))

;; Handle Normal mode "%" command.

(defn- #_void nv_percent [#_cmdarg_C cap]
    (ยง
        ((ร cap.oap.inclusive =) true)
        (cond (!= (. cap count0) 0)                ;; {cnt}% : goto {cnt} percentage in file
        (ยง
            (cond (< 100 (. cap count0))
            (ยง
                (clearopbeep (. cap oap))
            )
            :else
            (ยง
                ((ร cap.oap.motion_type =) MLINE)
                (setpcmark)
                ;; Round up, so CTRL-G will give same value.
                ;; Watch out for a large line count, the line number must not go negative!
                (if (< 1000000 (.. @curbuf b_ml ml_line_count))
                    ((ร @curwin.w_cursor.lnum =) (ยง (@curbuf.b_ml.ml_line_count + 99) / 100 * cap.count0))
                    ((ร @curwin.w_cursor.lnum =) (ยง (@curbuf.b_ml.ml_line_count * cap.count0 + 99) / 100))
                )
                (if (> (.. @curwin w_cursor lnum) (.. @curbuf b_ml ml_line_count))
                    ((ร @curwin.w_cursor.lnum =) (.. @curbuf b_ml ml_line_count))
                )
                (beginline (| BL_SOL BL_FIX))
            ))
        )
        :else                            ;; "%" : go to matching paren
        (ยง
            ((ร cap.oap.motion_type =) MCHAR)
            ((ร cap.oap.use_reg_one =) true)

            ((ร pos_C pos =) (ยง findmatch(cap.oap, NUL)))
            (cond (nil? pos)
            (ยง
                (clearopbeep (. cap oap))
            )
            :else
            (ยง
                (setpcmark)
                (COPY_pos (. @curwin w_cursor), pos)
                ((ร @curwin.w_set_curswant =) true)
                ((ร @curwin.w_cursor.coladd =) 0)
                (adjust_for_sel cap)
            ))
        ))
    ))

;; Handle "(" and ")" commands.
;; cap.arg is BACKWARD for "(" and FORWARD for ")".

(defn- #_void nv_brace [#_cmdarg_C cap]
    (ยง
        ((ร cap.oap.motion_type =) MCHAR)
        ((ร cap.oap.use_reg_one =) true)
        ;; The motion used to be inclusive for "(", but that is not what Vi does.
        ((ร cap.oap.inclusive =) false)
        ((ร @curwin.w_set_curswant =) true)

        (cond (not (ยง findsent(cap.arg, cap.count1)))
        (ยง
            (clearopbeep (. cap oap))
        )
        :else
        (ยง
            ;; Don't leave the cursor on the NUL past end of line.
            (adjust_cursor (. cap oap))
            ((ร @curwin.w_cursor.coladd =) 0)
        ))
    ))

;; "m" command: Mark a position.

(defn- #_void nv_mark [#_cmdarg_C cap]
    (ยง
        (when (not (checkclearop (. cap oap)))
            (if (not (setmark @(. cap nchar)))
                (clearopbeep (. cap oap)))
        )
    ))

;; "{" and "}" commands.
;; cmd.arg is BACKWARD for "{" and FORWARD for "}".

(defn- #_void nv_findpar [#_cmdarg_C cap]
    (ยง
        ((ร cap.oap.motion_type =) MCHAR)
        ((ร cap.oap.inclusive =) false)
        ((ร cap.oap.use_reg_one =) true)
        ((ร @curwin.w_set_curswant =) true)
        (ร boolean b)
;       { boolean[] __ = { cap.oap.inclusive }; b = findpar(__, cap.arg, cap.count1, NUL, false); cap.oap.inclusive = __[0]; }
        (if (not b)
            (clearopbeep (. cap oap))
            ((ร @curwin.w_cursor.coladd =) 0)
        )
    ))

;; "u" command: Undo or make lower case.

(defn- #_void nv_undo [#_cmdarg_C cap]
    (ยง
        (cond (or (== (.. cap oap op_type) OP_LOWER) @VIsual_active)
        (ยง
            ;; translate "<Visual>u" to "<Visual>gu" and "guu" to "gugu"
            ((ร cap.cmdchar =) (byte \g))
            ((ร cap.@nchar =) (byte \u))
            (nv_operator cap)
        )
        :else
        (ยง
            (nv_kundo cap)
        ))
    ))

;; <Undo> command.

(defn- #_void nv_kundo [#_cmdarg_C cap]
    (ยง
        (when (not (checkclearopq (. cap oap)))
            (u_undo (int (. cap count1)))
            ((ร @curwin.w_set_curswant =) true)
        )
    ))

;; Handle the "r" command.

(defn- #_void nv_replace [#_cmdarg_C cap]
    (ยง
        (if (checkclearop (. cap oap))
            (ร RETURN)
        )

        ;; get another character
        (ร int had_ctrl_v)
        (cond (== @(. cap nchar) Ctrl_V)
        (ยง
            ((ร had_ctrl_v =) Ctrl_V)
            ((ร cap.@nchar =) (get_literal))
            ;; Don't redo a multibyte character with CTRL-V.
            (if (< DEL @(. cap nchar))
                ((ร had_ctrl_v =) NUL)
            )
        )
        :else
        (ยง
            ((ร had_ctrl_v =) NUL)
        ))

        ;; Abort if the character is a special key.
        (when (is_special @(. cap nchar))
            (clearopbeep (. cap oap))
            (ร RETURN)
        )

        ;; Visual mode "r".
        (when @VIsual_active
            (if @got_int
                (reset_VIsual))
            (when (!= had_ctrl_v NUL)
                (cond (== @(. cap nchar) (byte \return))
                (ยง
                    ((ร cap.@nchar =) -1)
                )
                (== @(. cap nchar) (byte \newline))
                (ยง
                    ((ร cap.@nchar =) -2)
                ))
            )
            (nv_operator cap)
            (ร RETURN)
        )

        ;; Break tabs, etc.
        (when (virtual_active)
            (if (not (u_save_cursor))
                (ร RETURN)
            )
            (cond (== (gchar_cursor) NUL)
            (ยง
                ;; Add extra space and put the cursor on the first one.
                (coladvance_force (int (+ (getviscol) (. cap count1))))
                ((ร @curwin.w_cursor.col -=) (. cap count1))
            )
            (== (gchar_cursor) TAB)
            (ยง
                (coladvance_force (getviscol))
            ))
        )

        ;; Abort if not enough characters to replace.
        ((ร Bytes ptr =) (ml_get_cursor))
        (when (or (< (STRLEN ptr) (. cap count1)) (< (us_charlen ptr) (. cap count1)))
            (clearopbeep (. cap oap))
            (ร RETURN)
        )

        ;; Replacing with a TAB is done by edit() when it is complicated because
        ;; 'expandtab' or 'smarttab' is set.  CTRL-V TAB inserts a literal TAB.
        ;; Other characters are done below to avoid problems with things like
        ;; CTRL-V 048 (for edit() this would be R CTRL-V 0 ESC).

        (when (and (!= had_ctrl_v Ctrl_V) (== @(. cap nchar) (byte \tab)) (or @(. @curbuf b_p_et) @p_sta))
            (stuffnumReadbuff (. cap count1))
            (stuffcharReadbuff (byte \R))
            (stuffcharReadbuff (byte \tab))
            (stuffcharReadbuff ESC)
            (ร RETURN)
        )

        ;; save line for undo
        (if (not (u_save_cursor))
            (ร RETURN)
        )

        (cond (and (!= had_ctrl_v Ctrl_V) (or (== @(. cap nchar) (byte \return)) (== @(. cap nchar) (byte \newline))))
        (ยง
            ;; Replace character(s) by a single newline.
            ;; Strange vi behaviour: Only one newline is inserted.
            ;; Delete the characters here.
            ;; Insert the newline with an insert command, takes care of
            ;; autoindent.  The insert command depends on being on the last
            ;; character of a line or not.

            (del_chars (int (. cap count1)), false)      ;; delete the characters
            (stuffcharReadbuff (byte \return))
            (stuffcharReadbuff ESC)

            ;; Give 'r' to edit(), to get the redo command right.
            (invoke_edit cap, true, (byte \r), false)
        )
        :else
        (ยง
            (prep_redo (.. cap oap regname), (. cap count1), NUL, (byte \r), NUL, had_ctrl_v, @(. cap nchar))

            (COPY_pos (. @curbuf b_op_start), (. @curwin w_cursor))

;           {
                ((ร int old_State =) @State)

                (if (!= (. cap ncharC1) 0)
                    (appendCharToRedobuff (. cap ncharC1)))
                (if (!= (. cap ncharC2) 0)
                    (appendCharToRedobuff (. cap ncharC2)))

                ;; This is slow, but it handles replacing a single-byte with a
                ;; multi-byte and the other way around.  Also handles adding
                ;; composing characters for utf-8.
                ((ร FOR) (ร (ยง long n = cap.count1) (< 0 n) (ยง --n))
                    (reset! State REPLACE)
                    (cond (or (== @(. cap nchar) Ctrl_E) (== @(. cap nchar) Ctrl_Y))
                    (ยง
                        ((ร int c =) (ins_copychar (+ (.. @curwin w_cursor lnum) (if (== @(. cap nchar) Ctrl_Y) -1 1))))
                        (cond (!= c NUL)
                        (ยง
                            (ins_char c)
                        )
                        :else
                        (ยง
                            ;; will be decremented further down
                            (ยง @curwin.w_cursor.col++)
                        ))
                    )
                    :else
                    (ยง
                        (ins_char @(. cap nchar))
                    ))
                    (reset! State old_State)
                    (if (!= (. cap ncharC1) 0)
                        (ins_char (. cap ncharC1)))
                    (if (!= (. cap ncharC2) 0)
                        (ins_char (. cap ncharC2)))
                )
;           }

            (ยง --@curwin.w_cursor.col)      ;; cursor on the last replaced char

            ;; If the character on the left of the current cursor
            ;; is a multi-byte character, move two characters left.
            (mb_adjust_pos @curbuf, (. @curwin w_cursor))
            (COPY_pos (. @curbuf b_op_end), (. @curwin w_cursor))
            ((ร @curwin.w_set_curswant =) true)
            (set_last_insert @(. cap nchar))
        ))
    ))

;; 'o': Exchange start and end of Visual area.
;; 'O': same, but in block mode exchange left and right corners.

(defn- #_void v_swap_corners [#_int cmdchar]
    (ยง
        (cond (and (== cmdchar (byte \O)) (== @VIsual_mode Ctrl_V))
        (ยง
            ((ร pos_C old_cursor =) (ยง ยง_pos_C()))
            (COPY_pos old_cursor, (. @curwin w_cursor))
            ((ร int[] left =) (ยง new int[1]))
            ((ร int[] right =) (ยง new int[1]))
            (getvcols @curwin, old_cursor, @VIsual, left, right)
            ((ร @curwin.w_cursor.lnum =) (. @VIsual lnum))
            (coladvance (ยง left[0]))
            (COPY_pos @VIsual, (. @curwin w_cursor))

            ((ร @curwin.w_cursor.lnum =) (. old_cursor lnum))
            ((ร @curwin.w_curswant =) (ยง right[0]))
            ;; 'selection "exclusive" and cursor at right-bottom corner: move it right one column
            (if (and (<= (. @VIsual lnum) (. old_cursor lnum)) (== (.at @p_sel 0) (byte \e)))
                (ยง @curwin.w_curswant++)
            )
            (coladvance (. @curwin w_curswant))
            (when (and (== (.. @curwin w_cursor col) (. old_cursor col)) (or (not (virtual_active)) (== (.. @curwin w_cursor coladd) (. old_cursor coladd))))
                ((ร @curwin.w_cursor.lnum =) (. @VIsual lnum))
                (if (and (<= (. old_cursor lnum) (. @VIsual lnum)) (== (.at @p_sel 0) (byte \e)))
                    (ยง right[0]++)
                )
                (coladvance (ยง right[0]))
                (COPY_pos @VIsual, (. @curwin w_cursor))

                ((ร @curwin.w_cursor.lnum =) (. old_cursor lnum))
                (coladvance (ยง left[0]))
                ((ร @curwin.w_curswant =) (ยง left[0]))
            )
        )
        :else
        (ยง
            ((ร pos_C old_cursor =) (ยง ยง_pos_C()))
            (COPY_pos old_cursor, (. @curwin w_cursor))
            (COPY_pos (. @curwin w_cursor), @VIsual)
            (COPY_pos @VIsual, old_cursor)
            ((ร @curwin.w_set_curswant =) true)
        ))
    ))

;; "R" (cap.arg is FALSE) and "gR" (cap.arg is TRUE).

(defn- #_void nv_Replace [#_cmdarg_C cap]
    (ยง
        (cond @VIsual_active          ;; "R" is replace lines
        (ยง
            ((ร cap.cmdchar =) (byte \c))
            ((ร cap.@nchar =) NUL)
            (reset! VIsual_mode_orig @VIsual_mode) ;; remember original area for gv
            (reset! VIsual_mode (byte \V))
            (nv_operator cap)
        )
        (not (checkclearopq (. cap oap)))
        (ยง
            (if (virtual_active)
                (coladvance (getviscol)))
            (invoke_edit cap, false, (if (!= (. cap arg) 0) (byte \V) (byte \R)), false)
        ))
    ))

;; "gr".

(defn- #_void nv_vreplace [#_cmdarg_C cap]
    (ยง
        (cond @VIsual_active
        (ยง
            ((ร cap.cmdchar =) (byte \r))
            ((ร cap.@nchar =) @(. cap extra_char))
            (nv_replace cap)        ;; do same as "r" in Visual mode for now
        )
        (not (checkclearopq (. cap oap)))
        (ยง
            (if (== @(. cap extra_char) Ctrl_V)       ;; get another character
                ((ร cap.@extra_char =) (get_literal))
            )
            (stuffcharReadbuff @(. cap extra_char))
            (stuffcharReadbuff ESC)
            (if (virtual_active)
                (coladvance (getviscol)))
            (invoke_edit cap, true, (byte \v), false)
        ))
    ))

;; Swap case for "~" command, when it does not work like an operator.

(defn- #_void n_swapchar [#_cmdarg_C cap]
    (ยง
        (if (checkclearopq (. cap oap))
            (ร RETURN)
        )

        (when (and (lineempty (.. @curwin w_cursor lnum)) (== (vim_strchr @p_ww, (byte \~)) null))
            (clearopbeep (. cap oap))
            (ร RETURN)
        )

        (prep_redo_cmd cap)

        (if (not (u_save_cursor))
            (ร RETURN)
        )

        ((ร boolean did_change =) false)

        ((ร pos_C startpos =) (ยง ยง_pos_C()))
        (COPY_pos startpos, (. @curwin w_cursor))

        ((ร FOR) (ร (ยง long n = cap.count1) (< 0 n) (ยง --n))
            ((ร did_change |=) (ยง swapchar(cap.oap.op_type, @curwin.w_cursor)))
            (inc_cursor)
            (when (== (gchar_cursor) NUL)
                (cond (and (!= (vim_strchr @p_ww, (byte \~)) null) (< (.. @curwin w_cursor lnum) (.. @curbuf b_ml ml_line_count)))
                (ยง
                    (ยง @curwin.w_cursor.lnum++)
                    ((ร @curwin.w_cursor.col =) 0)
                    (when (< 1 n)
                        (if (not (u_savesub (.. @curwin w_cursor lnum)))
                            (ร BREAK)
                        )
                        (u_clearline)
                    )
                )
                :else
                (ยง
                    (ร BREAK)
                ))
            )
        )

        (check_cursor)
        ((ร @curwin.w_set_curswant =) true)

        (when did_change
            (changed_lines (. startpos lnum), (. startpos col), (+ (.. @curwin w_cursor lnum) 1), 0)
            (COPY_pos (. @curbuf b_op_start), startpos)
            (COPY_pos (. @curbuf b_op_end), (. @curwin w_cursor))
            (if (< 0 (.. @curbuf b_op_end col))
                (ยง --@curbuf.b_op_end.col)
            )
        )
    ))

;; Move cursor to mark.

(defn- #_void nv_cursormark [#_cmdarg_C cap, #_boolean flag, #_pos_C pos]
    (ยง
        (cond (not (check_mark pos))
        (ยง
            (clearop (. cap oap))
        )
        :else
        (ยง
            (if (or (== (. cap cmdchar) (byte \')) (== (. cap cmdchar) (byte \`)) (== (. cap cmdchar) (byte \[)) (== (. cap cmdchar) (byte \])))
                (setpcmark))
            (COPY_pos (. @curwin w_cursor), pos)
            (if flag
                (beginline (| BL_WHITE BL_FIX))
                (check_cursor))
        ))
        ((ร cap.oap.motion_type =) (if flag MLINE MCHAR))
        (if (== (. cap cmdchar) (byte \`))
            ((ร cap.oap.use_reg_one =) true)
        )
        ((ร cap.oap.inclusive =) false)              ;; ignored if not MCHAR
        ((ร @curwin.w_set_curswant =) true)
    ))

(final Bytes visop_trans (u8 "YyDdCcxdXdAAIIrr"))

;; Handle commands that are operators in Visual mode.

(defn- #_void v_visop [#_cmdarg_C cap]
    (ยง
        ;; Uppercase means linewise, except in block mode,
        ;; then "D" deletes, and "C" replaces till EOL.
        (when (asc_isupper (. cap cmdchar))
            (cond (!= @VIsual_mode Ctrl_V)
            (ยง
                (reset! VIsual_mode_orig @VIsual_mode)
                (reset! VIsual_mode (byte \V))
            )
            (or (== (. cap cmdchar) (byte \C)) (== (. cap cmdchar) (byte \D)))
            (ยง
                ((ร @curwin.w_curswant =) MAXCOL)
            ))
        )
        ((ร cap.cmdchar =) (ยง vim_strchr(visop_trans, cap.cmdchar).at(1)))
        (nv_operator cap)
    ))

;; "s" and "S" commands.

(defn- #_void nv_subst [#_cmdarg_C cap]
    (ยง
        (cond @VIsual_active  ;; "vs" and "vS" are the same as "vc"
        (ยง
            (when (== (. cap cmdchar) (byte \S))
                (reset! VIsual_mode_orig @VIsual_mode)
                (reset! VIsual_mode (byte \V))
            )
            ((ร cap.cmdchar =) (byte \c))
            (nv_operator cap)
        )
        :else
        (ยง
            (nv_optrans cap)
        ))
    ))

;; Abbreviated commands.

(defn- #_void nv_abbrev [#_cmdarg_C cap]
    (ยง
        (if (or (== (. cap cmdchar) K_DEL) (== (. cap cmdchar) K_KDEL))
            ((ร cap.cmdchar =) (byte \x))          ;; DEL key behaves like 'x'
        )

        ;; in Visual mode these commands are operators
        (if @VIsual_active
            (v_visop cap)
            (nv_optrans cap))
    ))

(final Bytes* #_"[/*8*/]" optrans_ar
    [
        (u8 "dl"), (u8 "dh"),
        (u8 "d$"), (u8 "c$"),
        (u8 "cl"), (u8 "cc"),
        (u8 "yy"), (u8 ":s\r")
    ])
(final Bytes optrans_str (u8 "xXDCsSY&"))

;; Translate a command into another command.

(defn- #_void nv_optrans [#_cmdarg_C cap]
    (ยง
        (when (not (checkclearopq (. cap oap)))
            ;; In Vi "2D" doesn't delete the next line.
            ;; Can't translate it either, because "2." should also not use the count.
            (cond (and (== (. cap cmdchar) (byte \D)) (non-nil? (vim_strbyte @p_cpo, CPO_HASH)))
            (ยง
                (COPY_pos (.. cap oap op_start), (. @curwin w_cursor))
                ((ร cap.oap.op_type =) OP_DELETE)
                ((ร cap.count1 =) 1)
                (nv_dollar cap)
                (reset! finish_op true)
                (resetRedobuff)
                (appendCharToRedobuff (byte \D))
            )
            :else
            (ยง
                (if (!= (. cap count0) 0)
                    (stuffnumReadbuff (. cap count0)))
                (stuffReadbuff (ยง optrans_ar[BDIFF(vim_strchr(optrans_str, cap.cmdchar), optrans_str)]))
            ))
        )
        ((ร cap.opcount =) 0)
    ))

;; "'" and "`" commands.  Also for "g'" and "g`".
;; cap.arg is TRUE for "'" and "g'".

(defn- #_void nv_gomark [#_cmdarg_C cap]
    (ยง
        (ร int c)
        (if (== (. cap cmdchar) (byte \g))
            ((ร c =) @(. cap extra_char))
            ((ร c =) @(. cap nchar))
        )

        ((ร pos_C pos =) (ยง getmark(c, (cap.oap.op_type == OP_NOP))))
        (cond (== pos NOPOS)   ;; jumped to other file
        (ยง
            (cond (!= (. cap arg) 0)
            (ยง
                (check_cursor_lnum)
                (beginline (| BL_WHITE BL_FIX))
            )
            :else
            (ยง
                (check_cursor)
            ))
        )
        :else
        (ยง
            (nv_cursormark cap, (!= (. cap arg) 0), pos)
        ))

        ;; May need to clear the coladd that a mark includes.
        (when (not (virtual_active))
            ((ร @curwin.w_cursor.coladd =) 0)
        )
    ))

;; Handle CTRL-O, CTRL-I, "g;" and "g," commands.

(defn- #_void nv_pcmark [#_cmdarg_C cap]
    (ยง
        (ร pos_C pos)

        (when (not (checkclearopq (. cap oap)))
            (if (== (. cap cmdchar) (byte \g))
                ((ร pos =) (ยง movechangelist((int)cap.count1)))
                ((ร pos =) (ยง movemark((int)cap.count1)))
            )
            (cond (== pos NOPOS)           ;; jump to other file
            (ยง
                ((ร @curwin.w_set_curswant =) true)
                (check_cursor)
            )
            (non-nil? pos)               ;; can jump
            (ยง
                (nv_cursormark cap, false, pos)
            )
            (== (. cap cmdchar) (byte \g))
            (ยง
                (cond (zero? (. @curbuf b_changelistlen))
                (ยง
                    (emsg (u8 "E664: changelist is empty"))
                )
                (< (. cap count1) 0)
                (ยง
                    (emsg (u8 "E662: At start of changelist"))
                )
                :else
                (ยง
                    (emsg (u8 "E663: At end of changelist"))
                ))
            )
            :else
            (ยง
                (clearopbeep (. cap oap))
            ))
        )
    ))

;; Handle '"' command.

(defn- #_void nv_regname [#_cmdarg_C cap]
    (ยง
        (if (checkclearop (. cap oap))
            (ร RETURN)
        )
        (if (== @(. cap nchar) (byte \=))
            ((ร cap.@nchar =) (get_expr_register))
        )
        (cond (and (!= @(. cap nchar) NUL) (valid_yank_reg @(. cap nchar), false))
        (ยง
            ((ร cap.oap.regname =) @(. cap nchar))
            ((ร cap.opcount =) (. cap count0))       ;; remember count before '"'
        )
        :else
        (ยง
            (clearopbeep (. cap oap))
        ))
    ))

;; Handle "v", "V" and "CTRL-V" commands.
;; Also for "gh", "gH" and "g^H" commands: Always start Select mode, cap.arg is TRUE.
;; Handle CTRL-Q just like CTRL-V.

(defn- #_void nv_visual [#_cmdarg_C cap]
    (ยง
        (if (== (. cap cmdchar) Ctrl_Q)
            ((ร cap.cmdchar =) Ctrl_V)
        )

        ;; 'v', 'V' and CTRL-V can be used while an operator is pending to make it
        ;; characterwise, linewise, or blockwise.
        (when (!= (.. cap oap op_type) OP_NOP)
            ((ร cap.oap.motion_force =) (. cap cmdchar))
            (reset! finish_op false)      ;; operator doesn't finish now but later
            (ร RETURN)
        )

        (reset! VIsual_select (!= (. cap arg) 0))
        (cond @VIsual_active      ;; change Visual mode
        (ยง
            (cond (== @VIsual_mode (. cap cmdchar))     ;; stop visual mode
            (ยง
                (end_visual_mode)
            )
            :else                                ;; toggle char/block mode or char/line mode
            (ยง
                (reset! VIsual_mode (. cap cmdchar))
                (showmode)
            ))
            (redraw_curbuf_later INVERTED)      ;; update the inversion
        )
        :else                    ;; start Visual mode
        (ยง
            (check_visual_highlight)
            (cond (and (< 0 (. cap count0)) (!= @resel_VIsual_mode NUL))
            (ยง
                ;; use previously selected part
                (COPY_pos @VIsual, (. @curwin w_cursor))

                (reset! VIsual_active true)
                (reset! VIsual_reselect true)
                (when (zero? (. cap arg))
                    ;; start Select mode when 'selectmode' contains "cmd"
                    (may_start_select (byte \c))
                )
                (if @p_smd
                    (reset! redraw_cmdline true))      ;; show visual mode later

                ;; For V and ^V, we multiply the number of lines even if there was only one.

                (when (or (!= @resel_VIsual_mode (byte \v)) (< 1 @resel_VIsual_line_count))
                    ((ร @curwin.w_cursor.lnum +=) (ยง @resel_VIsual_line_count * cap.count0 - 1))
                    (if (> (.. @curwin w_cursor lnum) (.. @curbuf b_ml ml_line_count))
                        ((ร @curwin.w_cursor.lnum =) (.. @curbuf b_ml ml_line_count))
                    )
                )
                (reset! VIsual_mode @resel_VIsual_mode)
                (when (== @VIsual_mode (byte \v))
                    (cond (<= @resel_VIsual_line_count 1)
                    (ยง
                        (validate_virtcol)
                        ((ร @curwin.w_curswant =) (ยง @curwin.w_virtcol + @resel_VIsual_vcol * (int)cap.count0 - 1))
                    )
                    :else
                    (ยง
                        ((ร @curwin.w_curswant =) @resel_VIsual_vcol)
                    ))
                    (coladvance (. @curwin w_curswant))
                )
                (cond (== @resel_VIsual_vcol MAXCOL)
                (ยง
                    ((ร @curwin.w_curswant =) MAXCOL)
                    (coladvance MAXCOL)
                )
                (== @VIsual_mode Ctrl_V)
                (ยง
                    (validate_virtcol)
                    ((ร @curwin.w_curswant =) (ยง @curwin.w_virtcol + @resel_VIsual_vcol * (int)cap.count0 - 1))
                    (coladvance (. @curwin w_curswant))
                )
                :else
                (ยง
                    ((ร @curwin.w_set_curswant =) true)
                ))
                (redraw_curbuf_later INVERTED)      ;; show the inversion
            )
            :else
            (ยง
                (when (zero? (. cap arg))
                    ;; start Select mode when 'selectmode' contains "cmd"
                    (may_start_select (byte \c))
                )
                (n_start_visual_mode (. cap cmdchar))
                (if (and (!= @VIsual_mode (byte \V)) (== (.at @p_sel 0) (byte \e)))
                    (ยง cap.count1++)   ;; include one more char
                )
                (when (and (< 0 (. cap count0)) (< 0 (ยง --cap.count1)))
                    ;; With a count select that many characters or lines.
                    (cond (or (== @VIsual_mode (byte \v)) (== @VIsual_mode Ctrl_V))
                    (ยง
                        (nv_right cap)
                    )
                    (== @VIsual_mode (byte \V))
                    (ยง
                        (nv_down cap)
                    ))
                )
            ))
        ))
    ))

;; Start selection for Shift-movement keys.

(defn- #_void start_selection []
    (ยง
        ;; if 'selectmode' contains "key", start Select mode
        (may_start_select (byte \k))
        (n_start_visual_mode (byte \v))
    ))

;; Start Select mode, if "c" is in 'selectmode' and not in a mapping or menu.

(defn- #_void may_start_select [#_int c]
    (ยง
        (reset! VIsual_select (and (stuff_empty) (non-nil? (vim_strchr @p_slm, c))))
    ))

;; Start Visual mode "c".
;; Should set VIsual_select before calling this.

(defn- #_void n_start_visual_mode [#_int c]
    (ยง
        ;; Check for redraw before changing the state.
        (conceal_check_cursor_line)

        (reset! VIsual_mode c)
        (reset! VIsual_active true)
        (reset! VIsual_reselect true)
        ;; Corner case: the 0 position in a tab may change when going into
        ;; virtualedit.  Recalculate curwin.w_cursor to avoid bad hilighting.

        (when (and (== c Ctrl_V) (non-zero? (& @ve_flags VE_BLOCK)) (== (gchar_cursor) TAB))
            (validate_virtcol)
            (coladvance (. @curwin w_virtcol))
        )
        (COPY_pos @VIsual, (. @curwin w_cursor))

        ;; Check for redraw after changing the state.
        (conceal_check_cursor_line)

        (if @p_smd
            (reset! redraw_cmdline true))  ;; show visual mode later

        ;; Only need to redraw this line, unless still need to redraw
        ;; an old Visual area (when 'lazyredraw' is set).
        (when (< (. @curwin w_redr_type) INVERTED)
            ((ร @curwin.w_old_cursor_lnum =) (.. @curwin w_cursor lnum))
            ((ร @curwin.w_old_visual_lnum =) (.. @curwin w_cursor lnum))
        )
    ))

;; CTRL-W: Window commands

(defn- #_void nv_window [#_cmdarg_C cap]
    (ยง
        (when (not (checkclearop (. cap oap)))
            (do_window @(. cap nchar), (. cap count0), NUL)
        )
    ))

;; CTRL-Z: Suspend

(defn- #_void nv_suspend [#_cmdarg_C cap]
    (ยง
        (clearop (. cap oap))
        (if @VIsual_active
            (end_visual_mode))              ;; stop Visual mode
        (do_cmdline_cmd (u8 "st"))
    ))

;; Commands starting with "g".

(defn- #_void nv_g_cmd [#_cmdarg_C cap]
    (ยง
        ((ร oparg_C oap =) (. cap oap))
        ((ร boolean flag =) false)

        ((ร SWITCH) @(. cap nchar)
            ;; "gR": Enter virtual replace mode.

            ((ร CASE) (byte \R))
            (ยง
                ((ร cap.arg =) TRUE)
                (nv_Replace cap)
                (ร BREAK)
            )

            ((ร CASE) (byte \r))
            (ยง
                (nv_vreplace cap)
                (ร BREAK)
            )

            ((ร CASE) (byte \&))
            (ยง
                (do_cmdline_cmd (u8 "%s//~/&"))
                (ร BREAK)
            )

            ;; "gv": Reselect the previous Visual area.
            ;;       If Visual already active, exchange previous and current Visual area.

            ((ร CASE) (byte \v))
            (ยง
                (if (checkclearop oap)
                    (ร BREAK)
                )

                (cond (or (zero? (.. @curbuf b_visual vi_start lnum)) (< (.. @curbuf b_ml ml_line_count) (.. @curbuf b_visual vi_start lnum)) (zero? (.. @curbuf b_visual vi_end lnum)))
                (ยง
                    (beep_flush)
                )
                :else
                (ยง
                    ;; set w_cursor to the start of the Visual area, tpos to the end
                    ((ร pos_C tpos =) (ยง ยง_pos_C()))
                    (cond @VIsual_active
                    (ยง
                        ((ร int i =) @VIsual_mode)
                        (reset! VIsual_mode (.. @curbuf b_visual vi_mode))
                        ((ร @curbuf.b_visual.vi_mode =) i)
                        ((ร @curbuf.b_visual_mode_eval =) i)
                        ((ร i =) (. @curwin w_curswant))
                        ((ร @curwin.w_curswant =) (.. @curbuf b_visual vi_curswant))
                        ((ร @curbuf.b_visual.vi_curswant =) i)

                        (COPY_pos tpos, (.. @curbuf b_visual vi_end))
                        (COPY_pos (.. @curbuf b_visual vi_end), (. @curwin w_cursor))
                        (COPY_pos (. @curwin w_cursor), (.. @curbuf b_visual vi_start))
                        (COPY_pos (.. @curbuf b_visual vi_start), @VIsual)
                    )
                    :else
                    (ยง
                        (reset! VIsual_mode (.. @curbuf b_visual vi_mode))
                        ((ร @curwin.w_curswant =) (.. @curbuf b_visual vi_curswant))
                        (COPY_pos tpos, (.. @curbuf b_visual vi_end))
                        (COPY_pos (. @curwin w_cursor), (.. @curbuf b_visual vi_start))
                    ))

                    (reset! VIsual_active true)
                    (reset! VIsual_reselect true)

                    ;; Set Visual to the start and w_cursor to the end of the Visual area.
                    ;; Make sure they are on an existing character.
                    (check_cursor)
                    (COPY_pos @VIsual, (. @curwin w_cursor))
                    (COPY_pos (. @curwin w_cursor), tpos)
                    (check_cursor)
                    (update_topline)

                    ;; When called from normal "g" command: start Select mode when 'selectmode'
                    ;; contains "cmd".  When called for K_SELECT, always start Select mode.

                    (if (!= (. cap arg) 0)
                        (reset! VIsual_select true)
                        (may_start_select (byte \c)))

                    (redraw_curbuf_later INVERTED)
                    (showmode)
                ))
                (ร BREAK)
            )

            ;; "gV": Don't reselect the previous Visual area after a Select mode mapping of menu.

            ((ร CASE) (byte \V))
            (ยง
                (reset! VIsual_reselect false)
                (ร BREAK)
            )

            ;; "gh":  start Select mode.
            ;; "gH":  start Select line mode.
            ;; "g^H": start Select block mode.

            ((ร CASE) K_BS)
            (ยง
                ((ร cap.@nchar =) Ctrl_H)
                (ร FALLTHROUGH)
            )

            ((ร CASE) (byte \h))
            ((ร CASE) (byte \H))
            ((ร CASE) Ctrl_H)
            (ยง
                ((ร cap.cmdchar =) (ยง cap.@nchar + ((byte \v) - (byte \h))))
                ((ร cap.arg =) TRUE)
                (nv_visual cap)
                (ร BREAK)
            )

            ;; "gn", "gN" visually select next/previous search match
            ;; "gn" selects next match
            ;; "gN" selects previous match

            ((ร CASE) (byte \N))
            ((ร CASE) (byte \n))
            (ยง
                (if (not (current_search (. cap count1), (== @(. cap nchar) (byte \n))))
                    (clearopbeep oap))
                (ร BREAK)
            )

            ;; "gj" and "gk" two new funny movement keys -- up and down
            ;; movement based on *screen* line rather than *file* line.

            ((ร CASE) (byte \j))
            ((ร CASE) K_DOWN)
            (ยง
                (ร boolean i)

                ;; with 'nowrap' it works just like the normal "j" command;
                ;; also when in a closed fold
                (cond (not @(.. @curwin w_options wo_wrap))
                (ยง
                    ((ร oap.motion_type =) MLINE)
                    ((ร i =) (ยง cursor_down(cap.count1, oap.op_type == OP_NOP)))
                )
                :else
                (ยง
                    ((ร i =) (ยง nv_screengo(oap, FORWARD, cap.count1)))
                ))
                (if (not i)
                    (clearopbeep oap))
                (ร BREAK)
            )

            ((ร CASE) (byte \k))
            ((ร CASE) K_UP)
            (ยง
                (ร boolean i)

                ;; with 'nowrap' it works just like the normal "k" command;
                ;; also when in a closed fold
                (cond (not @(.. @curwin w_options wo_wrap))
                (ยง
                    ((ร oap.motion_type =) MLINE)
                    ((ร i =) (ยง cursor_up(cap.count1, oap.op_type == OP_NOP)))
                )
                :else
                (ยง
                    ((ร i =) (ยง nv_screengo(oap, BACKWARD, cap.count1)))
                ))
                (if (not i)
                    (clearopbeep oap))
                (ร BREAK)
            )

            ;; "gJ": join two lines without inserting a space.

            ((ร CASE) (byte \J))
            (ยง
                (nv_join cap)
                (ร BREAK)
            )

            ;; "g0", "g^" and "g$": Like "0", "^" and "$" but for screen lines.
            ;; "gm": middle of "g0" and "g$".

            ((ร CASE) (byte \^))
            (ยง
                ((ร flag =) true)
                (ร FALLTHROUGH)
            )

            ((ร CASE) (byte \0))
            ((ร CASE) (byte \m))
            ((ร CASE) K_HOME)
            ((ร CASE) K_KHOME)
            (ยง
                (ร int i)

                ((ร oap.motion_type =) MCHAR)
                ((ร oap.inclusive =) false)
                (cond (and @(.. @curwin w_options wo_wrap) (!= (. @curwin w_width) 0))
                (ยง
                    ((ร int width1 =) (ยง @curwin.w_width - curwin_col_off()))
                    ((ร int width2 =) (ยง width1 + curwin_col_off2()))

                    (validate_virtcol)
                    ((ร i =) 0)
                    (if (and (<= width1 (. @curwin w_virtcol)) (< 0 width2))
                        ((ร i =) (ยง (@curwin.w_virtcol - width1) / width2 * width2 + width1))
                    )
                )
                :else
                (ยง
                    ((ร i =) (. @curwin w_leftcol))
                ))
                ;; Go to the middle of the screen line.  When 'number' or 'relativenumber' is on
                ;; and lines are wrapping the middle can be more to the left.
                (when (== @(. cap nchar) (byte \m))
                    ((ร i +=) (/ (+ (- (. @curwin w_width) (curwin_col_off)) (if (and @(.. @curwin w_options wo_wrap) (< 0 i)) (curwin_col_off2) 0)) 2))
                )
                (coladvance i)
                (when flag
;                   do
;                   {
                        ((ร i =) (gchar_cursor))
;                   } while (vim_iswhite(i) && oneright());
                )
                ((ร @curwin.w_set_curswant =) true)
                (ร BREAK)
            )

            ((ร CASE) (byte \_))
            (ยง
                ;; "g_": to the last non-blank character in the line or <count> lines downward.
                ((ร cap.oap.motion_type =) MCHAR)
                ((ร cap.oap.inclusive =) true)
                ((ร @curwin.w_curswant =) MAXCOL)
                (cond (not (cursor_down (- (. cap count1) 1), (== (.. cap oap op_type) OP_NOP)))
                (ยง
                    (clearopbeep (. cap oap))
                )
                :else
                (ยง
                    ((ร Bytes ptr =) (ml_get_curline))

                    ;; In Visual mode we may end up after the line.
                    (if (and (< 0 (.. @curwin w_cursor col)) (== (.at ptr (.. @curwin w_cursor col)) NUL))
                        (ยง --@curwin.w_cursor.col)
                    )

                    ;; Decrease the cursor column until it's on a non-blank.
                    (while (ยง 0 < @curwin.w_cursor.col && vim_iswhite(ptr.at(@curwin.w_cursor.col)))
                        (ยง --@curwin.w_cursor.col)
                    )
                    ((ร @curwin.w_set_curswant =) true)
                    (adjust_for_sel cap)
                ))
                (ร BREAK)
            )

            ((ร CASE) (byte \$))
            ((ร CASE) K_END)
            ((ร CASE) K_KEND)
            (ยง
                ((ร int col_off =) (curwin_col_off))

                ((ร oap.motion_type =) MCHAR)
                ((ร oap.inclusive =) true)
                (cond (and @(.. @curwin w_options wo_wrap) (!= (. @curwin w_width) 0))
                (ยง
                    ((ร @curwin.w_curswant =) MAXCOL) ;; so we stay at the end
                    (cond (== (. cap count1) 1)
                    (ยง
                        ((ร int width1 =) (ยง @curwin.w_width - col_off))
                        ((ร int width2 =) (ยง width1 + curwin_col_off2()))

                        (validate_virtcol)
                        ((ร int i =) (- width1 1))
                        (if (<= width1 (. @curwin w_virtcol))
                            ((ร i +=) (ยง ((@curwin.w_virtcol - width1) / width2 + 1) * width2))
                        )
                        (coladvance i)

                        ;; Make sure we stick in this column.
                        (validate_virtcol)
                        ((ร @curwin.w_curswant =) (. @curwin w_virtcol))
                        ((ร @curwin.w_set_curswant =) false)
                        (when (and (< 0 (.. @curwin w_cursor col)) @(.. @curwin w_options wo_wrap))
                            ;; Check for landing on a character that got split at the end of the line.
                            ;; We do not want to advance to the next screen line.

                            (if (< i (. @curwin w_virtcol))
                                (ยง --@curwin.w_cursor.col)
                            )
                        )
                    )
                    (not (nv_screengo oap, FORWARD, (- (. cap count1) 1)))
                    (ยง
                        (clearopbeep oap)
                    ))
                )
                :else
                (ยง
                    ((ร int i =) (ยง @curwin.w_leftcol + @curwin.w_width - col_off - 1))
                    (coladvance i)

                    ;; Make sure we stick in this column.
                    (validate_virtcol)
                    ((ร @curwin.w_curswant =) (. @curwin w_virtcol))
                    ((ร @curwin.w_set_curswant =) false)
                ))
                (ร BREAK)
            )

            ;; "g*" and "g#", like "*" and "#" but without using "\<" and "\>"

            ((ร CASE) (byte \*))
            ((ร CASE) (byte \#))
            ((ร CASE) (char_u POUND))             ;; pound sign (sometimes equal to '#')
            ((ร CASE) Ctrl_RSB)                  ;; :tag or :tselect for current identifier
            ((ร CASE) (byte \]))                       ;; :tselect for current identifier
            (ยง
                (nv_ident cap)
                (ร BREAK)
            )

            ;; ge and gE: go back to end of word

            ((ร CASE) (byte \e))
            ((ร CASE) (byte \E))
            (ยง
                ((ร oap.motion_type =) MCHAR)
                ((ร @curwin.w_set_curswant =) true)
                ((ร oap.inclusive =) true)
                (if (not (bckend_word (. cap count1), (== @(. cap nchar) (byte \E)), false))
                    (clearopbeep oap))
                (ร BREAK)
            )

            ;; "g CTRL-G": display info about cursor position.

            ((ร CASE) Ctrl_G)
            (ยง
                (cursor_pos_info)
                (ร BREAK)
            )

            ;; "gi": start Insert at the last position.

            ((ร CASE) (byte \i))
            (ยง
                (when (!= (.. @curbuf b_last_insert lnum) 0)
                    (COPY_pos (. @curwin w_cursor), (. @curbuf b_last_insert))
                    (check_cursor_lnum)
                    ((ร int i =) (ยง STRLEN(ml_get_curline())))
                    (when (< i (.. @curwin w_cursor col))
                        (if (virtual_active)
                            ((ร @curwin.w_cursor.coladd +=) (ยง @curwin.w_cursor.col - i))
                        )
                        ((ร @curwin.w_cursor.col =) i)
                    )
                )
                ((ร cap.cmdchar =) (byte \i))
                (nv_edit cap)
                (ร BREAK)
            )

            ;; "gI": Start insert in column 1.

            ((ร CASE) (byte \I))
            (ยง
                (beginline 0)
                (if (not (checkclearopq oap))
                    (invoke_edit cap, false, (byte \g), false))
                (ร BREAK)
            )

            ;; "g'm" and "g`m": jump to mark without setting pcmark.

            ((ร CASE) (byte \'))
            (ยง
                ((ร cap.arg =) TRUE)
                (ร FALLTHROUGH)
            )

            ((ร CASE) (byte \`))
            (ยง
                (nv_gomark cap)
                (ร BREAK)
            )

            ;; "gs": Goto sleep.

            ((ร CASE) (byte \s))
            (ยง
                (do_sleep (* (. cap count1) 1000))
                (ร BREAK)
            )

            ;; "ga": Display the ascii value of the character under the cursor.
            ;;       It is displayed in decimal, hex, and octal.

            ((ร CASE) (byte \a))
            (ยง
                (do_ascii)
                (ร BREAK)
            )

            ;; "g8": Display the bytes used for the UTF-8 character under the cursor.
            ;;       It is displayed in hex.
            ;; "8g8" finds illegal byte sequence.

            ((ร CASE) (byte \8))
            (ยง
                (if (== (. cap count0) 8)
                    (utf_find_illegal)
                    (show_utf8)
                )
                (ร BREAK)
            )

            ((ร CASE) (byte \<))
            (ยง
                (show_sb_text)
                (ร BREAK)
            )

            ;; "gg": Goto the first line in file.
            ;;       With a count it goes to that line number like for "G".

            ((ร CASE) (byte \g))
            (ยง
                ((ร cap.arg =) FALSE)
                (nv_goto cap)
                (ร BREAK)
            )

            ;; Two-character operators:
            ;;  "gq"    Format text.
            ;;  "gw"    Format text and keep cursor position.
            ;;  "g~"    Toggle the case of the text.
            ;;  "gu"    Change text to lower case.
            ;;  "gU"    Change text to upper case.
            ;;  "g?"    rot13 encoding
            ;;  "g@"    call 'operatorfunc'

            ((ร CASE) (byte \q))
            ((ร CASE) (byte \w))
            (ยง
                (COPY_pos (. oap cursor_start), (. @curwin w_cursor))
                (ร FALLTHROUGH)
            )

            ((ร CASE) (byte \~))
            ((ร CASE) (byte \u))
            ((ร CASE) (byte \U))
            ((ร CASE) (byte \?))
            ((ร CASE) (byte \@))
            (ยง
                (nv_operator cap)
                (ร BREAK)
            )

            ;; "gd": Find first occurrence of pattern under the cursor in the current function;
            ;; "gD": idem, but in the current file.

            ((ร CASE) (byte \d))
            ((ร CASE) (byte \D))
            (ยง
                (nv_gd oap, @(. cap nchar), (== (. cap count0) 1))
                (ร BREAK)
            )

            ((ร CASE) K_IGNORE)
            (ยง
                (ร BREAK)
            )

            ;; "gP" and "gp": same as "P" and "p" but leave cursor just after new text.

            ((ร CASE) (byte \p))
            ((ร CASE) (byte \P))
            (ยง
                (nv_put cap)
                (ร BREAK)
            )

            ;; "go": goto byte count from start of buffer
            ((ร CASE) (byte \o))
            (ยง
;               goto_byte(cap.count0);
                (ร BREAK)
            )

            ;; "gQ": improved Ex mode
            ((ร CASE) (byte \Q))
            (ยง
                (when (text_locked)
                    (clearopbeep (. cap oap))
                    (text_locked_msg)
                    (ร BREAK)
                )

                (if (not (checkclearopq oap))
;                   do_exmode(true);
                )
                (ร BREAK)
            )

            ((ร CASE) (byte \,))
            (ยง
                (nv_pcmark cap)
                (ร BREAK)
            )

            ((ร CASE) (byte \;))
            (ยง
                ((ร cap.count1 =) (ยง -cap.count1))
                (nv_pcmark cap)
                (ร BREAK)
            )

            ;; "g+" and "g-": undo or redo along the timeline.

            ((ร CASE) (byte \+))
            ((ร CASE) (byte \-))
            (ยง
                (if (not (checkclearopq oap))
                    (undo_time (if (== @(. cap nchar) (byte \-)) (ยง -cap.count1) (. cap count1)), false, false))
                (ร BREAK)
            )

            (ร DEFAULT)
            (ยง
                (clearopbeep oap)
                (ร BREAK)
            )
        )
    ))

;; Handle "o" and "O" commands.

(defn- #_void n_opencmd [#_cmdarg_C cap]
    (ยง
        ((ร long oldline =) (.. @curwin w_cursor lnum))

        (when (not (checkclearopq (. cap oap)))
            (when (and (u_save (- (.. @curwin w_cursor lnum) (if (== (. cap cmdchar) (byte \O)) 1 0)), (+ (.. @curwin w_cursor lnum) (if (== (. cap cmdchar) (byte \o)) 1 0))) (open_line (if (== (. cap cmdchar) (byte \O)) BACKWARD FORWARD), 0, 0))
                (if (and (< 0 @(.. @curwin w_options wo_cole)) (!= oldline (.. @curwin w_cursor lnum)))
                    (update_single_line @curwin, oldline))
                ;; When '#' is in 'cpoptions' ignore the count.
                (if (non-nil? (vim_strbyte @p_cpo, CPO_HASH))
                    ((ร cap.count1 =) 1)
                )
                (invoke_edit cap, false, (. cap cmdchar), true)
            )
        )
    ))

;; "." command: redo last change.

(defn- #_void nv_dot [#_cmdarg_C cap]
    (ยง
        (when (not (checkclearopq (. cap oap)))
            ;; If "restart_edit" is true, the last but one command is repeated
            ;; instead of the last command (inserting text).  This is used for
            ;; CTRL-O <.> in insert mode.

            (if (not (start_redo (. cap count0), (and (non-zero? @restart_edit) (not @arrow_used))))
                (clearopbeep (. cap oap)))
        )
    ))

;; CTRL-R: undo undo

(defn- #_void nv_redo [#_cmdarg_C cap]
    (ยง
        (when (not (checkclearopq (. cap oap)))
            (u_redo (int (. cap count1)))
            ((ร @curwin.w_set_curswant =) true)
        )
    ))

;; Handle "U" command.

(defn- #_void nv_Undo [#_cmdarg_C cap]
    (ยง
        ;; In Visual mode and typing "gUU" triggers an operator.
        (cond (or (== (.. cap oap op_type) OP_UPPER) @VIsual_active)
        (ยง
            ;; translate "gUU" to "gUgU"
            ((ร cap.cmdchar =) (byte \g))
            ((ร cap.@nchar =) (byte \U))
            (nv_operator cap)
        )
        (not (checkclearopq (. cap oap)))
        (ยง
            (u_undoline)
            ((ร @curwin.w_set_curswant =) true)
        ))
    ))

;; '~' command: If tilde is not an operator and Visual is off: swap case of a single character.

(defn- #_void nv_tilde [#_cmdarg_C cap]
    (ยง
        (if (and (not @p_to) (not @VIsual_active) (!= (.. cap oap op_type) OP_TILDE))
            (n_swapchar cap)
            (nv_operator cap))
    ))

;; Handle an operator command.
;; The actual work is done by do_pending_operator().

(defn- #_void nv_operator [#_cmdarg_C cap]
    (ยง
        ((ร int op_type =) (ยง get_op_type(cap.cmdchar, cap.@nchar)))

        (cond (== op_type (.. cap oap op_type))     ;; double operator works on lines
        (ยง
            (nv_lineop cap)
        )
        (not (checkclearop (. cap oap)))
        (ยง
            (COPY_pos (.. cap oap op_start), (. @curwin w_cursor))
            ((ร cap.oap.op_type =) op_type)
        ))
    ))

;; Handle linewise operator "dd", "yy", etc.
;;
;; "_" is is a strange motion command that helps make operators more logical.
;; It is actually implemented, but not documented in the real Vi.  This motion
;; command actually refers to "the current line".  Commands like "dd" and "yy"
;; are really an alternate form of "d_" and "y_".  It does accept a count, so
;; "d3_" works to delete 3 lines.

(defn- #_void nv_lineop [#_cmdarg_C cap]
    (ยง
        ((ร cap.oap.motion_type =) MLINE)
        (cond (not (cursor_down (- (. cap count1) 1), (== (.. cap oap op_type) OP_NOP)))
        (ยง
            (clearopbeep (. cap oap))
        )
        ;; only with linewise motions
        (or (and (== (.. cap oap op_type) OP_DELETE) (!= (.. cap oap motion_force) (byte \v)) (!= (.. cap oap motion_force) Ctrl_V)) (== (.. cap oap op_type) OP_LSHIFT) (== (.. cap oap op_type) OP_RSHIFT))
        (ยง
            (beginline (| BL_SOL BL_FIX))
        )
        (!= (.. cap oap op_type) OP_YANK)        ;; 'Y' does not move cursor
        (ยง
            (beginline (| BL_WHITE BL_FIX))
        ))
    ))

;; <Home> command.

(defn- #_void nv_home [#_cmdarg_C cap]
    (ยง
        ;; CTRL-HOME is like "gg"
        (cond (non-zero? (& @mod_mask MOD_MASK_CTRL))
        (ยง
            (nv_goto cap)
        )
        :else
        (ยง
            ((ร cap.count0 =) 1)
            (nv_pipe cap)
        ))
        (reset! ins_at_eol false)     ;; Don't move cursor past eol
                                    ;; (only necessary in a one-character line).
    ))

;; "|" command.

(defn- #_void nv_pipe [#_cmdarg_C cap]
    (ยง
        ((ร cap.oap.motion_type =) MCHAR)
        ((ร cap.oap.inclusive =) false)
        (beginline 0)
        (cond (< 0 (. cap count0))
        (ยง
            (coladvance (int (- (. cap count0) 1)))
            ((ร @curwin.w_curswant =) (ยง (int)(cap.count0 - 1)))
        )
        :else
        (ยง
            ((ร @curwin.w_curswant =) 0)
        ))
        ;; Keep curswant at the column where we wanted to go,
        ;; not where we ended; differs if line is too short.
        ((ร @curwin.w_set_curswant =) false)
    ))

;; Handle back-word command "b" and "B".
;; cap.arg is 1 for "B"

(defn- #_void nv_bck_word [#_cmdarg_C cap]
    (ยง
        ((ร cap.oap.motion_type =) MCHAR)
        ((ร cap.oap.inclusive =) false)
        ((ร @curwin.w_set_curswant =) true)
        (when (not (bck_word (. cap count1), (!= (. cap arg) 0), false))
            (clearopbeep (. cap oap))
        )
    ))

;; Handle word motion commands "e", "E", "w" and "W".
;; cap.arg is TRUE for "E" and "W".

(defn- #_void nv_wordcmd [#_cmdarg_C cap]
    (ยง
        ((ร pos_C startpos =) (ยง ยง_pos_C()))
        (COPY_pos startpos, (. @curwin w_cursor))

        ;; Set inclusive for the "E" and "e" command.

        ((ร boolean word_end =) (ยง (cap.cmdchar == (byte \e) || cap.cmdchar == (byte \E))))
        ((ร cap.oap.inclusive =) word_end)

        ((ร boolean flag =) false)

        ;; "cw" and "cW" are a special case.

        (when (and (not word_end) (== (.. cap oap op_type) OP_CHANGE))
            ((ร int n =) (gchar_cursor))
            (when (!= n NUL)                   ;; not an empty line
                (cond (vim_iswhite n)
                (ยง
                    ;; Reproduce a funny Vi behaviour: "cw" on a blank only
                    ;; changes one character, not all blanks until the start of
                    ;; the next word.  Only do this when the 'w' flag is included
                    ;; in 'cpoptions'.

                    (when (and (== (. cap count1) 1) (non-nil? (vim_strbyte @p_cpo, CPO_CW)))
                        ((ร cap.oap.inclusive =) true)
                        ((ร cap.oap.motion_type =) MCHAR)
                        (ร RETURN)
                    )
                )
                :else
                (ยง
                    ;; This is a little strange.  To match what the real Vi does,
                    ;; we effectively map 'cw' to 'ce', and 'cW' to 'cE', provided
                    ;; that we are not on a space or a TAB.  This seems impolite
                    ;; at first, but it's really more what we mean when we say 'cw'.
                    ;; Another strangeness: When standing on the end of a word
                    ;; "ce" will change until the end of the next word, but "cw"
                    ;; will change only one character! This is done by setting flag.

                    ((ร cap.oap.inclusive =) true)
                    ((ร word_end =) true)
                    ((ร flag =) true)
                ))
            )
        )

        ((ร cap.oap.motion_type =) MCHAR)
        ((ร @curwin.w_set_curswant =) true)
        (ร boolean n)
        (if word_end
            ((ร n =) (ยง end_word(cap.count1, cap.arg != 0, flag, false)))
            ((ร n =) (ยง fwd_word(cap.count1, cap.arg != 0, cap.oap.op_type != OP_NOP)))
        )

        ;; Don't leave the cursor on the NUL past the end of line.
        ;; Unless we didn't move it forward.
        (if (ltpos startpos, (. @curwin w_cursor))
            (adjust_cursor (. cap oap)))

        (if (and (not n) (== (.. cap oap op_type) OP_NOP))
            (clearopbeep (. cap oap))
            (adjust_for_sel cap))
    ))

;; Used after a movement command: if the cursor ends up on the NUL after the end of the line,
;; may move it back to the last character and make the motion inclusive.

(defn- #_void adjust_cursor [#_oparg_C oap]
    (ยง
        ;; The cursor cannot remain on the NUL when:
        ;; - the column is > 0
        ;; - not in Visual mode or 'selection' is "o"
        ;; - 'virtualedit' is not "all" and not "onemore".

        (when (and (< 0 (.. @curwin w_cursor col)) (== (gchar_cursor) NUL) (or (not @VIsual_active) (== (.at @p_sel 0) (byte \o))) (not (virtual_active)) (zero? (& @ve_flags VE_ONEMORE)))
            (ยง --@curwin.w_cursor.col)
            ;; prevent cursor from moving on the trail byte
            (mb_adjust_pos @curbuf, (. @curwin w_cursor))
            ((ร oap.inclusive =) true)
        )
    ))

;; "0" and "^" commands.
;; cap.arg is the argument for beginline().

(defn- #_void nv_beginline [#_cmdarg_C cap]
    (ยง
        ((ร cap.oap.motion_type =) MCHAR)
        ((ร cap.oap.inclusive =) false)
        (beginline (. cap arg))
        (reset! ins_at_eol false)     ;; Don't move cursor past eol
                                    ;; (only necessary in a one-character line).
    ))

;; In exclusive Visual mode, may include the last character.

(defn- #_void adjust_for_sel [#_cmdarg_C cap]
    (ยง
        (when (and @VIsual_active (.. cap oap inclusive) (== (.at @p_sel 0) (byte \e)) (!= (gchar_cursor) NUL) (ltpos @VIsual, (. @curwin w_cursor)))
            (inc_cursor)
            ((ร cap.oap.inclusive =) false)
        )
    ))

;; Exclude last character at end of Visual area for 'selection' == "exclusive".
;; Should check VIsual_mode before calling this.
;; Returns true when backed up to the previous line.

(defn- #_boolean unadjust_for_sel []
    (ยง
        (when (and (== (.at @p_sel 0) (byte \e)) (not (eqpos @VIsual, (. @curwin w_cursor))))
            (ร pos_C pp)
            (if (ltpos @VIsual, (. @curwin w_cursor))
                ((ร pp =) (. @curwin w_cursor))
                ((ร pp =) @VIsual)
            )
            (cond (< 0 (. pp coladd))
            (ยง
                (ยง --pp.coladd)
            )
            (< 0 (. pp col))
            (ยง
                (ยง --pp.col)
                (mb_adjust_pos @curbuf, pp)
            )
            (< 1 (. pp lnum))
            (ยง
                (ยง --pp.lnum)
                ((ร pp.col =) (ยง STRLEN(ml_get(pp.lnum))))
                ((ร RETURN) true)
            ))
        )
        false
    ))

;; SELECT key in Normal or Visual mode: end of Select mode mapping.

(defn- #_void nv_select [#_cmdarg_C cap]
    (ยง
        (cond @VIsual_active
        (ยง
            (reset! VIsual_select true)
        )
        @VIsual_reselect
        (ยง
            ((ร cap.@nchar =) (byte \v))        ;; fake "gv" command
            ((ร cap.arg =) TRUE)
            (nv_g_cmd cap)
        ))
    ))

;; "G", "gg", CTRL-END, CTRL-HOME.
;; cap.arg is TRUE for "G".

(defn- #_void nv_goto [#_cmdarg_C cap]
    (ยง
        (ร long lnum)
        (if (!= (. cap arg) 0)
            ((ร lnum =) (.. @curbuf b_ml ml_line_count))
            ((ร lnum =) 1)
        )

        ((ร cap.oap.motion_type =) MLINE)
        (setpcmark)

        ;; When a count is given, use it instead of the default lnum.
        (if (!= (. cap count0) 0)
            ((ร lnum =) (. cap count0))
        )
        (cond (< lnum 1)
        (ยง
            ((ร lnum =) 1)
        )
        (< (.. @curbuf b_ml ml_line_count) lnum)
        (ยง
            ((ร lnum =) (.. @curbuf b_ml ml_line_count))
        ))
        ((ร @curwin.w_cursor.lnum =) lnum)
        (beginline (| BL_SOL BL_FIX))
    ))

;; CTRL-\ in Normal mode.

(defn- #_void nv_normal [#_cmdarg_C cap]
    (ยง
        (cond (or (== @(. cap nchar) Ctrl_N) (== @(. cap nchar) Ctrl_G))
        (ยง
            (clearop (. cap oap))
            (if (and (non-zero? @restart_edit) @mode_displayed)
                (reset! clear_cmdline true))               ;; unshow mode later
            (reset! restart_edit 0)
            (if (non-zero? @cmdwin_type)
                (reset! cmdwin_result Ctrl_C))
            (when @VIsual_active
                (end_visual_mode)          ;; stop Visual
                (redraw_curbuf_later INVERTED)
            )
            ;; CTRL-\ CTRL-G restarts Insert mode when 'insertmode' is set.
            (if (and (== @(. cap nchar) Ctrl_G) @p_im)
                (reset! restart_edit (byte \a)))
        )
        :else
        (ยง
            (clearopbeep (. cap oap))
        ))
    ))

;; ESC in Normal mode: beep, but don't flush buffers.
;; Don't even beep if we are canceling a command.

(defn- #_void nv_esc [#_cmdarg_C cap]
    (ยง
        ((ร boolean no_reason =) (ยง (cap.oap.op_type == OP_NOP && cap.opcount == 0 && cap.count0 == 0 && cap.oap.regname == 0 && !@p_im)))

        (when (!= (. cap arg) 0)                   ;; true for CTRL-C
            (if (and (zero? @restart_edit) (zero? @cmdwin_type) (not @VIsual_active) no_reason)
                (msg (u8 "Type  :quit<Enter>  to exit Vim")))

            ;; Don't reset "restart_edit" when 'insertmode' is set,
            ;; it won't be set again below when halfway a mapping.
            (if (not @p_im)
                (reset! restart_edit 0))
            (when (non-zero? @cmdwin_type)
                (reset! cmdwin_result K_IGNORE)
                (reset! got_int false)            ;; don't stop executing autocommands et al.
                (ร RETURN)
            )
        )

        (cond @VIsual_active
        (ยง
            (end_visual_mode)              ;; stop Visual
            (check_cursor_col)             ;; make sure cursor is not beyond EOL
            ((ร @curwin.w_set_curswant =) true)
            (redraw_curbuf_later INVERTED)
        )
        no_reason
        (ยง
            (vim_beep)
        ))
        (clearop (. cap oap))

        ;; A CTRL-C is often used at the start of a menu.
        ;; When 'insertmode' is set, return to Insert mode afterwards.
        (when (and (zero? @restart_edit) (goto_im))
            (reset! restart_edit (byte \a))
        )
    ))

;; Handle "A", "a", "I", "i" and <Insert> commands.

(defn- #_void nv_edit [#_cmdarg_C cap]
    (ยง
        ;; <Insert> is equal to "i"
        (if (or (== (. cap cmdchar) K_INS) (== (. cap cmdchar) K_KINS))
            ((ร cap.cmdchar =) (byte \i))
        )

        ;; in Visual mode "A" and "I" are an operator
        (cond (and @VIsual_active (or (== (. cap cmdchar) (byte \A)) (== (. cap cmdchar) (byte \I))))
        (ยง
            (v_visop cap)
        )
        ;; in Visual mode and after an operator "a" and "i" are for text objects
        (and (or (== (. cap cmdchar) (byte \a)) (== (. cap cmdchar) (byte \i))) (or (!= (.. cap oap op_type) OP_NOP) @VIsual_active))
        (ยง
            (nv_object cap)
        )
        (not (checkclearopq (. cap oap)))
        (ยง
            ((ร SWITCH) (. cap cmdchar)
                ((ร CASE) (byte \A))   ;; "A"ppend after the line
                (ยง
                    ((ร @curwin.w_set_curswant =) true)
                    (cond (== @ve_flags VE_ALL)
                    (ยง
                        ((ร int save_State =) @State)

                        ;; Pretend Insert mode here to allow the cursor
                        ;; on the character past the end of the line.
                        (reset! State INSERT)
                        (coladvance MAXCOL)
                        (reset! State save_State)
                    )
                    :else
                    (ยง
                        ((ร @curwin.w_cursor.col +=) (ยง STRLEN(ml_get_cursor())))
                    ))
                    (ร BREAK)
                )

                ((ร CASE) (byte \I))   ;; "I"nsert before the first non-blank
                (ยง
                    (if (nil? (vim_strbyte @p_cpo, CPO_INSEND))
                        (beginline BL_WHITE)
                        (beginline (ยง BL_WHITE|BL_FIX)))
                    (ร BREAK)
                )

                ((ร CASE) (byte \a))   ;; "a"ppend is like "i"nsert on the next character
                (ยง
                    ;; Increment coladd when in virtual space, increment the
                    ;; column otherwise, also to append after an unprintable char.
                    (cond (and (virtual_active) (or (< 0 (.. @curwin w_cursor coladd)) (== (.at (ml_get_cursor) 0) NUL) (== (.at (ml_get_cursor) 0) TAB)))
                    (ยง
                        (ยง @curwin.w_cursor.coladd++)
                    )
                    (!= (.at (ml_get_cursor) 0) NUL)
                    (ยง
                        (inc_cursor)
                    ))
                    (ร BREAK)
                )
            )

            (when (and (!= (.. @curwin w_cursor coladd) 0) (!= (. cap cmdchar) (byte \A)))
                ((ร int save_State =) @State)

                ;; Pretend Insert mode here to allow the cursor
                ;; on the character past the end of the line.
                (reset! State INSERT)
                (coladvance (getviscol))
                (reset! State save_State)
            )

            (invoke_edit cap, false, (. cap cmdchar), false)
        ))
    ))

;; Invoke edit() and take care of "restart_edit" and the return value.

(defn- #_void invoke_edit [#_cmdarg_C cap, #_boolean repl, #_int cmd, #_boolean startln]
    ;; repl: "r" or "gr" command
    (ยง
        ((ร int restart_edit_save =) 0)

        ;; Complicated: when the user types "a<C-O>a", we don't want to do Insert mode recursively.
        ;; But when doing "a<C-O>." or "a<C-O>rx", we do allow it.
        (if (or repl (not (stuff_empty)))
            ((ร restart_edit_save =) @restart_edit)
            ((ร restart_edit_save =) 0)
        )

        ;; Always reset "restart_edit", this is not a restarted edit.
        (reset! restart_edit 0)

        (if (edit cmd, startln, (. cap count1))
            ((ร cap.retval |=) CA_COMMAND_BUSY)
        )

        (when (zero? @restart_edit)
            (reset! restart_edit restart_edit_save)
        )
    ))

;; "a" or "i" while an operator is pending or in Visual mode: object motion.

(defn- #_void nv_object [#_cmdarg_C cap]
    (ยง
        (ร boolean include)
        (if (== (. cap cmdchar) (byte \i))
            ((ร include =) false)    ;; "ix" = inner object: exclude white space
            ((ร include =) true)     ;; "ax" = an object: include white space
        )

        ;; Make sure (), [], {} and <> are in 'matchpairs'.
        ((ร Bytes mps_save =) @(. @curbuf b_p_mps))
        ((ร @curbuf.@b_p_mps =) (u8 "(:),{:},[:],<:>"))

        (ร boolean flag)
        ((ร SWITCH) @(. cap nchar)
            ((ร CASE) (byte \w)) ;; "aw" = a word
            (ยง
                ((ร flag =) (ยง current_word(cap.oap, cap.count1, include, false)))
                (ร BREAK)
            )
            ((ร CASE) (byte \W)) ;; "aW" = a WORD
            (ยง
                ((ร flag =) (ยง current_word(cap.oap, cap.count1, include, true)))
                (ร BREAK)
            )
            ((ร CASE) (byte \b)) ;; "ab" = a braces block
            ((ร CASE) (byte \())
            ((ร CASE) (byte \)))
            (ยง
                ((ร flag =) (ยง current_block(cap.oap, cap.count1, include, (byte \(), (byte \)))))
                (ร BREAK)
            )
            ((ร CASE) (byte \B)) ;; "aB" = a Brackets block
            ((ร CASE) (byte \{))
            ((ร CASE) (byte \}))
            (ยง
                ((ร flag =) (ยง current_block(cap.oap, cap.count1, include, (byte \{), (byte \}))))
                (ร BREAK)
            )
            ((ร CASE) (byte \[)) ;; "a[" = a [] block
            ((ร CASE) (byte \]))
            (ยง
                ((ร flag =) (ยง current_block(cap.oap, cap.count1, include, (byte \[), (byte \]))))
                (ร BREAK)
            )
            ((ร CASE) (byte \<)) ;; "a<" = a <> block
            ((ร CASE) (byte \>))
            (ยง
                ((ร flag =) (ยง current_block(cap.oap, cap.count1, include, (byte \<), (byte \>))))
                (ร BREAK)
            )
            ((ร CASE) (byte \p)) ;; "ap" = a paragraph
            (ยง
                ((ร flag =) (ยง current_par(cap.oap, cap.count1, include, (byte \p))))
                (ร BREAK)
            )
            ((ร CASE) (byte \s)) ;; "as" = a sentence
            (ยง
                ((ร flag =) (ยง current_sent(cap.oap, cap.count1, include)))
                (ร BREAK)
            )
            ((ร CASE) (byte \")) ;; "a"" = a double quoted string
            ((ร CASE) (byte \')) ;; "a'" = a single quoted string
            ((ร CASE) (byte \`)) ;; "a`" = a backtick quoted string
            (ยง
                ((ร flag =) (ยง current_quote(cap.oap, cap.count1, include, cap.@nchar)))
                (ร BREAK)
            )
            (ร DEFAULT)
            (ยง
                ((ร flag =) false)
                (ร BREAK)
            )
        )

        ((ร @curbuf.@b_p_mps =) mps_save)
        (if (not flag)
            (clearopbeep (. cap oap)))
        (adjust_cursor_col)
        ((ร @curwin.w_set_curswant =) true)
    ))

;; "q" command: Start/stop recording.
;; "q:", "q/", "q?": edit command-line in command-line window.

(defn- #_void nv_record [#_cmdarg_C cap]
    (ยง
        (cond (== (.. cap oap op_type) OP_FORMAT)
        (ยง
            ;; "gqq" is the same as "gqgq": format line
            ((ร cap.cmdchar =) (byte \g))
            ((ร cap.@nchar =) (byte \q))
            (nv_operator cap)
        )
        (not (checkclearop (. cap oap)))
        (ยง
            (cond (or (== @(. cap nchar) (byte \:)) (== @(. cap nchar) (byte \/)) (== @(. cap nchar) (byte \?)))
            (ยง
                (stuffcharReadbuff @(. cap nchar))
                (stuffcharReadbuff K_CMDWIN)
            )
            :else
            (ยง
                ;; (stop) recording into a named register, unless executing a register
                (if (and (not @execReg) (not (do_record @(. cap nchar))))
                    (clearopbeep (. cap oap)))
            ))
        ))
    ))

;; Handle the "@r" command.

(defn- #_void nv_at [#_cmdarg_C cap]
    (ยง
        (if (checkclearop (. cap oap))
            (ร RETURN)
        )
        (when (== @(. cap nchar) (byte \=))
            (if (== (get_expr_register) NUL)
                (ร RETURN)
            )
        )
        (while (ยง 0 < cap.count1-- && !@got_int)
            (when (not (do_execreg @(. cap nchar)))
                (clearopbeep (. cap oap))
                (ร BREAK)
            )
            (line_breakcheck)
        )
    ))

;; Handle the CTRL-U and CTRL-D commands.

(defn- #_void nv_halfpage [#_cmdarg_C cap]
    (ยง
        (cond (or (and (== (. cap cmdchar) Ctrl_U) (== (.. @curwin w_cursor lnum) 1)) (and (== (. cap cmdchar) Ctrl_D) (== (.. @curwin w_cursor lnum) (.. @curbuf b_ml ml_line_count))))
        (ยง
            (clearopbeep (. cap oap))
        )
        (not (checkclearop (. cap oap)))
        (ยง
            (halfpage (== (. cap cmdchar) Ctrl_D), (. cap count0))
        ))
    ))

;; Handle "J" or "gJ" command.

(defn- #_void nv_join [#_cmdarg_C cap]
    (ยง
        (cond @VIsual_active  ;; join the visual lines
        (ยง
            (nv_operator cap)
        )
        (not (checkclearop (. cap oap)))
        (ยง
            (if (<= (. cap count0) 1)
                ((ร cap.count0 =) 2)         ;; default for join is two lines!
            )
            (cond (< (.. @curbuf b_ml ml_line_count) (ยง @curwin.w_cursor.lnum + cap.count0 - 1))
            (ยง
                (clearopbeep (. cap oap))   ;; beyond last line
            )
            :else
            (ยง
                (prep_redo (.. cap oap regname), (. cap count0), NUL, (. cap cmdchar), NUL, NUL, @(. cap nchar))
                (do_join (int (. cap count0)), (== @(. cap nchar) NUL), true, true, true)
            ))
        ))
    ))

;; "P", "gP", "p" and "gp" commands.

(defn- #_void nv_put [#_cmdarg_C cap]
    (ยง
        ((ร int regname =) 0)
        ((ร boolean empty =) false)
        ((ร boolean was_visual =) false)
        ((ร int flags =) 0)

        (cond (!= (.. cap oap op_type) OP_NOP)
        (ยง
            (clearopbeep (. cap oap))
        )
        :else
        (ยง
            ((ร int dir =) (if (or (== (. cap cmdchar) (byte \P)) (and (== (. cap cmdchar) (byte \g)) (== @(. cap nchar) (byte \P)))) BACKWARD FORWARD))
            (prep_redo_cmd cap)
            (if (== (. cap cmdchar) (byte \g))
                ((ร flags |=) PUT_CURSEND)
            )

            ((ร yankreg_C reg1 =) (ยง null, reg2 = null))

            (when @VIsual_active
                ;; Putting in Visual mode: The put text replaces the selected
                ;; text.  First delete the selected text, then put the new text.
                ;; Need to save and restore the registers that the delete
                ;; overwrites if the old contents is being put.

                ((ร was_visual =) true)
                ((ร regname =) (.. cap oap regname))
                ((ร regname =) (adjust_clip_reg regname))
                (when (or (zero? regname) (== regname (byte \")) (asc_isdigit regname) (== regname (byte \-)))  ;; """
                    ;; The delete is going to overwrite the register we want to put, save it first.
                    ((ร reg1 =) (get_register regname, true))
                )

                ;; Now delete the selected text.
                ((ร cap.cmdchar =) (byte \d))
                ((ร cap.@nchar =) NUL)
                ((ร cap.oap.regname =) NUL)
                (nv_operator cap)
                (do_pending_operator cap, 0, false)
                ((ร empty =) (ยง ((@curbuf.b_ml.ml_flags & ML_EMPTY) != 0)))

                ;; delete PUT_LINE_BACKWARD;
                ((ร cap.oap.regname =) regname)

                (when (non-nil? reg1)
                    ;; Delete probably changed the register we want to put, save it first.
                    ;; Then put back what was there before the delete.
                    ((ร reg2 =) (get_register regname, false))
                    (put_register regname, reg1)
                )

                ;; When deleted a linewise Visual area,
                ;; put the register as lines to avoid it joined with the next line.
                ;; When deletion was characterwise, split a line when putting lines.
                (cond (== @VIsual_mode (byte \V))
                (ยง
                    ((ร flags |=) PUT_LINE)
                )
                (== @VIsual_mode (byte \v))
                (ยง
                    ((ร flags |=) PUT_LINE_SPLIT)
                ))
                (if (and (== @VIsual_mode Ctrl_V) (== dir FORWARD))
                    ((ร flags |=) PUT_LINE_FORWARD)
                )
                ((ร dir =) BACKWARD)
                (when (or (and (!= @VIsual_mode (byte \V)) (< (.. @curwin w_cursor col) (.. @curbuf b_op_start col))) (and (== @VIsual_mode (byte \V)) (< (.. @curwin w_cursor lnum) (.. @curbuf b_op_start lnum))))
                    ;; cursor is at the end of the line or end of file, put forward.
                    ((ร dir =) FORWARD)
                )
                ;; May have been reset in do_put().
                (reset! VIsual_active true)
            )

            (do_put (.. cap oap regname), dir, (int (. cap count1)), flags)

            ;; If a register was saved, put it back now.
            (if (non-nil? reg2)
                (put_register regname, reg2))

            ;; What to reselect with "gv"?
            ;; Selecting the just put text seems to be the most useful, since the original was removed.
            (when was_visual
                (COPY_pos (.. @curbuf b_visual vi_start), (. @curbuf b_op_start))
                (COPY_pos (.. @curbuf b_visual vi_end), (. @curbuf b_op_end))
            )

            ;; When all lines were selected and deleted do_put() leaves
            ;; an empty line that needs to be deleted now.
            (when (and empty (== (.at (ml_get (.. @curbuf b_ml ml_line_count)) 0) NUL))
                (ml_delete (.. @curbuf b_ml ml_line_count), true)

                ;; If the cursor was in that line, move it to the end of the last line.
                (when (> (.. @curwin w_cursor lnum) (.. @curbuf b_ml ml_line_count))
                    ((ร @curwin.w_cursor.lnum =) (.. @curbuf b_ml ml_line_count))
                    (coladvance MAXCOL)
                )
            )
        ))
    ))

;; "o" and "O" commands.

(defn- #_void nv_open [#_cmdarg_C cap]
    (ยง
        (if @VIsual_active  ;; switch start and end of visual
            (v_swap_corners (. cap cmdchar))
            (n_opencmd cap))
    ))

(defn- #_void nv_drop [#_cmdarg_C _cap]
    (do_put (byte \~), BACKWARD, 1, PUT_CURSEND))

;; Trigger CursorHold event.
;; When waiting for a character for 'updatetime' K_CURSORHOLD is put in the
;; input buffer.  "did_cursorhold" is set to avoid retriggering.

(defn- #_void nv_cursorhold [#_cmdarg_C cap]
    (ยง
        (reset! did_cursorhold true)
        ((ร cap.retval |=) CA_COMMAND_BUSY)  ;; don't call edit() now
    ))

;; This table contains one entry for every Normal or Visual mode command.
;; The order doesn't matter, init_normal_cmds() will create a sorted index.
;; It is faster when all keys from zero to '~' are present.

(final nv_cmd_C* nv_cmds
    [
        (->nv_cmd_C NUL,              nv_error,       0,                      0               ),
        (->nv_cmd_C Ctrl_A,           nv_addsub,      0,                      0               ),
        (->nv_cmd_C Ctrl_B,           nv_page,        NV_STS,                 BACKWARD        ),
        (->nv_cmd_C Ctrl_C,           nv_esc,         0,                      TRUE            ),
        (->nv_cmd_C Ctrl_D,           nv_halfpage,    0,                      0               ),
        (->nv_cmd_C Ctrl_E,           nv_scroll_line, 0,                      TRUE            ),
        (->nv_cmd_C Ctrl_F,           nv_page,        NV_STS,                 FORWARD         ),
        (->nv_cmd_C Ctrl_G,           nv_ctrlg,       0,                      0               ),
        (->nv_cmd_C Ctrl_H,           nv_ctrlh,       0,                      0               ),
        (->nv_cmd_C Ctrl_I,           nv_pcmark,      0,                      0               ),
        (->nv_cmd_C NL,               nv_down,        0,                      FALSE           ),
        (->nv_cmd_C Ctrl_K,           nv_error,       0,                      0               ),
        (->nv_cmd_C Ctrl_L,           nv_clear,       0,                      0               ),
        (->nv_cmd_C Ctrl_M,           nv_down,        0,                      TRUE            ),
        (->nv_cmd_C Ctrl_N,           nv_down,        NV_STS,                 FALSE           ),
        (->nv_cmd_C Ctrl_O,           nv_ctrlo,       0,                      0               ),
        (->nv_cmd_C Ctrl_P,           nv_up,          NV_STS,                 FALSE           ),
        (->nv_cmd_C Ctrl_Q,           nv_visual,      0,                      FALSE           ),
        (->nv_cmd_C Ctrl_R,           nv_redo,        0,                      0               ),
        (->nv_cmd_C Ctrl_S,           nv_ignore,      0,                      0               ),
        (->nv_cmd_C Ctrl_T,           nv_error,       0,                      0               ),
        (->nv_cmd_C Ctrl_U,           nv_halfpage,    0,                      0               ),
        (->nv_cmd_C Ctrl_V,           nv_visual,      0,                      FALSE           ),
        (->nv_cmd_C (int \V),         nv_visual,      0,                      FALSE           ),
        (->nv_cmd_C (int \v),         nv_visual,      0,                      FALSE           ),
        (->nv_cmd_C Ctrl_W,           nv_window,      0,                      0               ),
        (->nv_cmd_C Ctrl_X,           nv_addsub,      0,                      0               ),
        (->nv_cmd_C Ctrl_Y,           nv_scroll_line, 0,                      FALSE           ),
        (->nv_cmd_C Ctrl_Z,           nv_suspend,     0,                      0               ),
        (->nv_cmd_C ESC,              nv_esc,         0,                      FALSE           ),
        (->nv_cmd_C Ctrl_BSL,         nv_normal,      NV_NCH_ALW,             0               ),
        (->nv_cmd_C Ctrl_RSB,         nv_ident,       NV_NCW,                 0               ),
        (->nv_cmd_C Ctrl_HAT,         nv_hat,         NV_NCW,                 0               ),
        (->nv_cmd_C Ctrl__,           nv_error,       0,                      0               ),
        (->nv_cmd_C (int \space),     nv_right,       0,                      0               ),
        (->nv_cmd_C (int \!),         nv_operator,    0,                      0               ),
        (->nv_cmd_C (int \"),         nv_regname,  (| NV_NCH_NOP NV_KEEPREG), 0               ),    ;; """
        (->nv_cmd_C (int \#),         nv_ident,       0,                      0               ),
        (->nv_cmd_C (int \$),         nv_dollar,      0,                      0               ),
        (->nv_cmd_C (int \%),         nv_percent,     0,                      0               ),
        (->nv_cmd_C (int \&),         nv_optrans,     0,                      0               ),
        (->nv_cmd_C (int \'),         nv_gomark,      NV_NCH_ALW,             TRUE            ),
        (->nv_cmd_C (int \(),         nv_brace,       0,                      BACKWARD        ),
        (->nv_cmd_C (int \)),         nv_brace,       0,                      FORWARD         ),
        (->nv_cmd_C (int \*),         nv_ident,       0,                      0               ),
        (->nv_cmd_C (int \+),         nv_down,        0,                      TRUE            ),
        (->nv_cmd_C (int \,),         nv_csearch,     0,                      TRUE            ),
        (->nv_cmd_C (int \-),         nv_up,          0,                      TRUE            ),
        (->nv_cmd_C (int \.),         nv_dot,         NV_KEEPREG,             0               ),
        (->nv_cmd_C (int \/),         nv_search,      0,                      FALSE           ),
        (->nv_cmd_C (int \0),         nv_beginline,   0,                      0               ),
        (->nv_cmd_C (int \1),         nv_ignore,      0,                      0               ),
        (->nv_cmd_C (int \2),         nv_ignore,      0,                      0               ),
        (->nv_cmd_C (int \3),         nv_ignore,      0,                      0               ),
        (->nv_cmd_C (int \4),         nv_ignore,      0,                      0               ),
        (->nv_cmd_C (int \5),         nv_ignore,      0,                      0               ),
        (->nv_cmd_C (int \6),         nv_ignore,      0,                      0               ),
        (->nv_cmd_C (int \7),         nv_ignore,      0,                      0               ),
        (->nv_cmd_C (int \8),         nv_ignore,      0,                      0               ),
        (->nv_cmd_C (int \9),         nv_ignore,      0,                      0               ),
        (->nv_cmd_C (int \:),         nv_colon,       0,                      0               ),
        (->nv_cmd_C (int \;),         nv_csearch,     0,                      FALSE           ),
        (->nv_cmd_C (int \<),         nv_operator,    NV_RL,                  0               ),
        (->nv_cmd_C (int \=),         nv_operator,    0,                      0               ),
        (->nv_cmd_C (int \>),         nv_operator,    NV_RL,                  0               ),
        (->nv_cmd_C (int \?),         nv_search,      0,                      FALSE           ),
        (->nv_cmd_C (int \@),         nv_at,          NV_NCH_NOP,             FALSE           ),
        (->nv_cmd_C (int \A),         nv_edit,        0,                      0               ),
        (->nv_cmd_C (int \B),         nv_bck_word,    0,                      1               ),
        (->nv_cmd_C (int \C),         nv_abbrev,      NV_KEEPREG,             0               ),
        (->nv_cmd_C (int \D),         nv_abbrev,      NV_KEEPREG,             0               ),
        (->nv_cmd_C (int \E),         nv_wordcmd,     0,                      TRUE            ),
        (->nv_cmd_C (int \F),         nv_csearch,  (| NV_NCH_ALW NV_LANG),    BACKWARD        ),
        (->nv_cmd_C (int \G),         nv_goto,        0,                      TRUE            ),
        (->nv_cmd_C (int \H),         nv_scroll,      0,                      0               ),
        (->nv_cmd_C (int \I),         nv_edit,        0,                      0               ),
        (->nv_cmd_C (int \J),         nv_join,        0,                      0               ),
        (->nv_cmd_C (int \K),         nv_ident,       0,                      0               ),
        (->nv_cmd_C (int \L),         nv_scroll,      0,                      0               ),
        (->nv_cmd_C (int \M),         nv_scroll,      0,                      0               ),
        (->nv_cmd_C (int \N),         nv_next,        0,                      SEARCH_REV      ),
        (->nv_cmd_C (int \O),         nv_open,        0,                      0               ),
        (->nv_cmd_C (int \P),         nv_put,         0,                      0               ),
        (->nv_cmd_C (int \Q),         nv_exmode,      NV_NCW,                 0               ),
        (->nv_cmd_C (int \R),         nv_Replace,     0,                      FALSE           ),
        (->nv_cmd_C (int \S),         nv_subst,       NV_KEEPREG,             0               ),
        (->nv_cmd_C (int \T),         nv_csearch,  (| NV_NCH_ALW NV_LANG),    BACKWARD        ),
        (->nv_cmd_C (int \U),         nv_Undo,        0,                      0               ),
        (->nv_cmd_C (int \W),         nv_wordcmd,     0,                      TRUE            ),
        (->nv_cmd_C (int \X),         nv_abbrev,      NV_KEEPREG,             0               ),
        (->nv_cmd_C (int \Y),         nv_abbrev,      NV_KEEPREG,             0               ),
        (->nv_cmd_C (int \Z),         nv_Zet,      (| NV_NCH_NOP NV_NCW),     0               ),
        (->nv_cmd_C (int \[),         nv_brackets,    NV_NCH_ALW,             BACKWARD        ),
        (->nv_cmd_C (int \\),         nv_error,       0,                      0               ),
        (->nv_cmd_C (int \]),         nv_brackets,    NV_NCH_ALW,             FORWARD         ),
        (->nv_cmd_C (int \^),         nv_beginline,   0,                   (| BL_WHITE BL_FIX)),
        (->nv_cmd_C (int \_),         nv_lineop,      0,                      0               ),
        (->nv_cmd_C (int \`),         nv_gomark,      NV_NCH_ALW,             FALSE           ),
        (->nv_cmd_C (int \a),         nv_edit,        NV_NCH,                 0               ),
        (->nv_cmd_C (int \b),         nv_bck_word,    0,                      0               ),
        (->nv_cmd_C (int \c),         nv_operator,    0,                      0               ),
        (->nv_cmd_C (int \d),         nv_operator,    0,                      0               ),
        (->nv_cmd_C (int \e),         nv_wordcmd,     0,                      FALSE           ),
        (->nv_cmd_C (int \f),         nv_csearch,  (| NV_NCH_ALW NV_LANG),    FORWARD         ),
        (->nv_cmd_C (int \g),         nv_g_cmd,       NV_NCH_ALW,             FALSE           ),
        (->nv_cmd_C (int \h),         nv_left,        NV_RL,                  0               ),
        (->nv_cmd_C (int \i),         nv_edit,        NV_NCH,                 0               ),
        (->nv_cmd_C (int \j),         nv_down,        0,                      FALSE           ),
        (->nv_cmd_C (int \k),         nv_up,          0,                      FALSE           ),
        (->nv_cmd_C (int \l),         nv_right,       NV_RL,                  0               ),
        (->nv_cmd_C (int \m),         nv_mark,        NV_NCH_NOP,             0               ),
        (->nv_cmd_C (int \n),         nv_next,        0,                      0               ),
        (->nv_cmd_C (int \o),         nv_open,        0,                      0               ),
        (->nv_cmd_C (int \p),         nv_put,         0,                      0               ),
        (->nv_cmd_C (int \q),         nv_record,      NV_NCH,                 0               ),
        (->nv_cmd_C (int \r),         nv_replace,  (| NV_NCH_NOP NV_LANG),    0               ),
        (->nv_cmd_C (int \s),         nv_subst,       NV_KEEPREG,             0               ),
        (->nv_cmd_C (int \t),         nv_csearch,  (| NV_NCH_ALW NV_LANG),    FORWARD         ),
        (->nv_cmd_C (int \u),         nv_undo,        0,                      0               ),
        (->nv_cmd_C (int \w),         nv_wordcmd,     0,                      FALSE           ),
        (->nv_cmd_C (int \x),         nv_abbrev,      NV_KEEPREG,             0               ),
        (->nv_cmd_C (int \y),         nv_operator,    0,                      0               ),
        (->nv_cmd_C (int \z),         nv_zet,         NV_NCH_ALW,             0               ),
        (->nv_cmd_C (int \{),         nv_findpar,     0,                      BACKWARD        ),
        (->nv_cmd_C (int \|),         nv_pipe,        0,                      0               ),
        (->nv_cmd_C (int \}),         nv_findpar,     0,                      FORWARD         ),
        (->nv_cmd_C (int \~),         nv_tilde,       0,                      0               ),

        ;; pound sign
        (->nv_cmd_C (char_u POUND),   nv_ident,       0,                      0               ),
        (->nv_cmd_C K_IGNORE,         nv_ignore,      NV_KEEPREG,             0               ),
        (->nv_cmd_C K_NOP,            nv_nop,         0,                      0               ),
        (->nv_cmd_C K_INS,            nv_edit,        0,                      0               ),
        (->nv_cmd_C K_KINS,           nv_edit,        0,                      0               ),
        (->nv_cmd_C K_BS,             nv_ctrlh,       0,                      0               ),
        (->nv_cmd_C K_UP,             nv_up,       (| NV_SSS NV_STS),         FALSE           ),
        (->nv_cmd_C K_S_UP,           nv_page,        NV_SS,                  BACKWARD        ),
        (->nv_cmd_C K_DOWN,           nv_down,     (| NV_SSS NV_STS),         FALSE           ),
        (->nv_cmd_C K_S_DOWN,         nv_page,        NV_SS,                  FORWARD         ),
        (->nv_cmd_C K_LEFT,           nv_left,     (| NV_SSS NV_STS NV_RL),   0               ),
        (->nv_cmd_C K_S_LEFT,         nv_bck_word, (| NV_SS NV_RL),           0               ),
        (->nv_cmd_C K_C_LEFT,         nv_bck_word, (| NV_SSS NV_RL NV_STS),   1               ),
        (->nv_cmd_C K_RIGHT,          nv_right,    (| NV_SSS NV_STS NV_RL),   0               ),
        (->nv_cmd_C K_S_RIGHT,        nv_wordcmd,  (| NV_SS NV_RL),           FALSE           ),
        (->nv_cmd_C K_C_RIGHT,        nv_wordcmd,  (| NV_SSS NV_RL NV_STS),   TRUE            ),
        (->nv_cmd_C K_PAGEUP,         nv_page,     (| NV_SSS NV_STS),         BACKWARD        ),
        (->nv_cmd_C K_KPAGEUP,        nv_page,     (| NV_SSS NV_STS),         BACKWARD        ),
        (->nv_cmd_C K_PAGEDOWN,       nv_page,     (| NV_SSS NV_STS),         FORWARD         ),
        (->nv_cmd_C K_KPAGEDOWN,      nv_page,     (| NV_SSS NV_STS),         FORWARD         ),
        (->nv_cmd_C K_END,            nv_end,      (| NV_SSS NV_STS),         FALSE           ),
        (->nv_cmd_C K_KEND,           nv_end,      (| NV_SSS NV_STS),         FALSE           ),
        (->nv_cmd_C K_S_END,          nv_end,         NV_SS,                  FALSE           ),
        (->nv_cmd_C K_C_END,          nv_end,      (| NV_SSS NV_STS),         TRUE            ),
        (->nv_cmd_C K_HOME,           nv_home,     (| NV_SSS NV_STS),         0               ),
        (->nv_cmd_C K_KHOME,          nv_home,     (| NV_SSS NV_STS),         0               ),
        (->nv_cmd_C K_S_HOME,         nv_home,        NV_SS,                  0               ),
        (->nv_cmd_C K_C_HOME,         nv_goto,     (| NV_SSS NV_STS),         FALSE           ),
        (->nv_cmd_C K_DEL,            nv_abbrev,      0,                      0               ),
        (->nv_cmd_C K_KDEL,           nv_abbrev,      0,                      0               ),
        (->nv_cmd_C K_UNDO,           nv_kundo,       0,                      0               ),
        (->nv_cmd_C K_SELECT,         nv_select,      0,                      0               ),
        (->nv_cmd_C K_DROP,           nv_drop,        NV_STS,                 0               ),
        (->nv_cmd_C K_CURSORHOLD,     nv_cursorhold,  NV_KEEPREG,             0               ),
    ])

;; ops.c: implementation of op_shift, op_delete, op_tilde, op_change, op_yank, do_put and do_join

;; Number of registers.
;;      0 = unnamed register, for normal yanks and puts
;;   1..9 = registers '1' to '9', for deletes
;; 10..35 = registers 'a' to 'z'
;;     36 = delete register '-'
;;     37 = Selection register '*'.  Only if FEAT_CLIPBOARD defined
;;     38 = Clipboard register '+'.  Only if FEAT_CLIPBOARD and FEAT_X11 defined

;; Symbolic names for some registers.

(final int DELETION_REGISTER       36)
(final int STAR_REGISTER           37)
(final int PLUS_REGISTER           STAR_REGISTER)           ;; there is only one
(final int TILDE_REGISTER          (inc PLUS_REGISTER))

(final int NUM_REGISTERS           (inc TILDE_REGISTER))

;; Each yank register is an array of pointers to lines.

(class! #_final yankreg_C
    [
        (field Bytes*       y_array)            ;; pointer to array of line pointers
        (field int          y_size)             ;; number of lines in "y_array"
        (field byte         y_type)             ;; MLINE, MCHAR or MBLOCK
        (field int          y_width)            ;; only set if y_type == MBLOCK
    ])

(defn- #_void COPY_yankreg [#_yankreg_C y1, #_yankreg_C y0]
    (ยง
        ((ร y1.y_array =) (. y0 y_array))
        ((ร y1.y_size =) (. y0 y_size))
        ((ร y1.y_type =) (. y0 y_type))
        ((ร y1.y_width =) (. y0 y_width))
    ))

(defn- #_yankreg_C* ARRAY_yankreg [#_int n]
    (vec (repeatedly n ยง_yankreg_C)))

(final yankreg_C*   y_regs    (ARRAY_yankreg NUM_REGISTERS))

(atom! yankreg_C    y_current)      ;; ptr to current yankreg
(atom! boolean      y_append)       ;; true when appending
(atom! yankreg_C    y_previous)     ;; ptr to last written yankreg

;; structure used by block_prep, op_delete and op_yank for blockwise operators
;; also op_change, op_shift, op_insert, op_replace

(class! #_final block_def_C
    [
        (field int          startspaces)        ;; 'extra' cols before first char
        (field int          endspaces)          ;; 'extra' cols after last char
        (field int          textlen)            ;; chars in block
        (field Bytes        textstart)          ;; pointer to 1st char (partially) in block
        (field int          textcol)            ;; index of chars (partially) in block
        (field int          start_vcol)         ;; start col of 1st char wholly inside block
        (field int          end_vcol)           ;; start col of 1st char wholly after block
        (field boolean      is_short)           ;; true if line is too short to fit in block
        (field boolean      is_MAX)             ;; true if curswant == MAXCOL when starting
        (field boolean      is_oneChar)         ;; true if block within one character
        (field int          pre_whitesp)        ;; screen cols of ws before block
        (field int          pre_whitesp_c)      ;; chars of ws before block
        (field int          end_char_vcols)     ;; number of vcols of post-block char
        (field int          start_char_vcols)   ;; number of vcols of pre-block char
    ])

;; The names of operators.
;; IMPORTANT: Index must correspond with defines in vim.h!!!
;; The third field indicates whether the operator always works on lines.

(final byte** #_"[/*3*/]" opchars
    [
        [ NUL, NUL, FALSE ],    ;; OP_NOP
        [ \d,  NUL, FALSE ],    ;; OP_DELETE
        [ \y,  NUL, FALSE ],    ;; OP_YANK
        [ \c,  NUL, FALSE ],    ;; OP_CHANGE
        [ \<,  NUL, TRUE  ],    ;; OP_LSHIFT
        [ \>,  NUL, TRUE  ],    ;; OP_RSHIFT
        [ \!,  NUL, TRUE  ],    ;; OP_FILTER
        [ \g,  \~,  FALSE ],    ;; OP_TILDE
        [ \=,  NUL, TRUE  ],    ;; OP_INDENT
        [ \g,  \q,  TRUE  ],    ;; OP_FORMAT
        [ \:,  NUL, TRUE  ],    ;; OP_COLON
        [ \g,  \U,  FALSE ],    ;; OP_UPPER
        [ \g,  \u,  FALSE ],    ;; OP_LOWER
        [ \J,  NUL, TRUE  ],    ;; DO_JOIN
        [ \g,  \J,  TRUE  ],    ;; DO_JOIN_NS
        [ \g,  \?,  FALSE ],    ;; OP_ROT13
        [ \r,  NUL, FALSE ],    ;; OP_REPLACE
        [ \I,  NUL, FALSE ],    ;; OP_INSERT
        [ \A,  NUL, FALSE ],    ;; OP_APPEND
        [ \g,  \w,  TRUE  ],    ;; OP_FORMAT2
        [ \g,  \@,  FALSE ],    ;; OP_FUNCTION
    ])

;; Translate a command name into an operator type.
;; Must only be called with a valid operator name!

(defn- #_int get_op_type [#_int char1, #_int char2]
    (ยง
        (if (== char1 (byte \r))           ;; ignore second character
            ((ร RETURN) OP_REPLACE)
        )
        (if (== char1 (byte \~))           ;; when tilde is an operator
            ((ร RETURN) OP_TILDE)
        )

        (ร int i)
        ((ร FOR) (ร (ยง i = 0) true (ยง i++))
            (if (and (== (ยง opchars[i][0]) char1) (== (ยง opchars[i][1]) char2))
                (ร BREAK)
            )
        )
        i
    ))

;; Return true if operator "op" always works on whole lines.

(defn- #_boolean op_on_lines [#_int op]
    (ยง
        (!= (ยง opchars[op][2]) FALSE)
    ))

;; Get first operator command character.
;; Returns 'g' or 'z' if there is another command character.

(defn- #_int get_op_char [#_int optype]
    (ยง
        (ยง opchars[optype][0])
    ))

;; Get second operator command character.

(defn- #_int get_extra_op_char [#_int optype]
    (ยง
        (ยง opchars[optype][1])
    ))

;; op_shift - handle a shift operation

(defn- #_void op_shift [#_oparg_C oap, #_boolean curs_top, #_int amount]
    (ยง
        ((ร int block_col =) 0)

        (if (not (u_save (- (.. oap op_start lnum) 1), (+ (.. oap op_end lnum) 1)))
            (ร RETURN)
        )

        (if (. oap block_mode)
            ((ร block_col =) (.. @curwin w_cursor col))
        )

        ((ร FOR) (ร (ยง long n = oap.line_count) (ยง 0 <= --n) (ยง @curwin.w_cursor.lnum++))
            ((ร byte c0 =) (ยง ml_get_curline().at(0)))
            (cond (== c0 NUL)                      ;; empty line
            (ยง
                ((ร @curwin.w_cursor.col =) 0)
            )
            (. oap block_mode)
            (ยง
                (shift_block oap, amount)
            )
            :else
            (ยง
                (shift_line (== (. oap op_type) OP_LSHIFT), @p_sr, amount, false)
            ))
        )

        (changed_lines (.. oap op_start lnum), 0, (+ (.. oap op_end lnum) 1), 0)

        (cond (. oap block_mode)
        (ยง
            ((ร @curwin.w_cursor.lnum =) (.. oap op_start lnum))
            ((ร @curwin.w_cursor.col =) block_col)
        )
        curs_top      ;; put cursor on first line, for ">>"
        (ยง
            ((ร @curwin.w_cursor.lnum =) (.. oap op_start lnum))
            (beginline (| BL_SOL BL_FIX))     ;; shift_line() may have set cursor.col
        )
        :else
        (ยง
            (ยง --@curwin.w_cursor.lnum)         ;; put cursor on last line, for ":>"
        ))

        (when (< @p_report (. oap line_count))
            ((ร Bytes s =) (if (== (. oap op_type) OP_RSHIFT) (u8 ">") (u8 "<")))
            (cond (== (. oap line_count) 1)
            (ยง
                (if (== amount 1)
                    (ยง libC.sprintf(@ioBuff, (u8 "1 line %sed 1 time"), s))
                    (ยง libC.sprintf(@ioBuff, (u8 "1 line %sed %d times"), s, amount))
                )
            )
            :else
            (ยง
                (if (== amount 1)
                    (ยง libC.sprintf(@ioBuff, (u8 "%ld lines %sed 1 time"), oap.line_count, s))
                    (ยง libC.sprintf(@ioBuff, (u8 "%ld lines %sed %d times"), oap.line_count, s, amount))
                )
            ))
            (msg @ioBuff)
        )

        ;; Set "'[" and "']" marks.

        (COPY_pos (. @curbuf b_op_start), (. oap op_start))
        ((ร @curbuf.b_op_end.lnum =) (.. oap op_end lnum))
        ((ร @curbuf.b_op_end.col =) (ยง STRLEN(ml_get(oap.op_end.lnum))))
        (when (< 0 (.. @curbuf b_op_end col))
            (ยง --@curbuf.b_op_end.col)
        )
    ))

;; shift the current line one shiftwidth left (if left != 0) or right
;; leaves cursor on first blank in the line

(defn- #_void shift_line [#_boolean left, #_boolean round, #_int amount, #_boolean call_changed_bytes]
    ;; call_changed_bytes: call changed_bytes()
    (ยง
        ((ร int q_sw =) (ยง (int)get_sw_value(@curbuf)))

        ((ร int count =) (get_indent))       ;; get current indent

        (cond round                      ;; round off indent
        (ยง
            ((ร int i =) (/ count q_sw))       ;; number of 'shiftwidth' rounded down
            ((ร int j =) (% count q_sw))       ;; extra spaces
            (if (and (non-zero? j) left)         ;; first remove extra spaces
                (ยง --amount)
            )
            (cond left
            (ยง
                ((ร i -=) amount)
                (if (< i 0)
                    ((ร i =) 0)
                )
            )
            :else
            (ยง
                ((ร i +=) amount)
            ))
            ((ร count =) (* i q_sw))
        )
        :else                            ;; original vi indent
        (ยง
            (cond left
            (ยง
                ((ร count -=) (* q_sw amount))
                (if (< count 0)
                    ((ร count =) 0)
                )
            )
            :else
            (ยง
                ((ร count +=) (* q_sw amount))
            ))
        ))

        ;; Set new indent.
        (if (non-zero? (& @State VREPLACE_FLAG))
            (change_indent INDENT_SET, count, false, NUL, call_changed_bytes)
            (set_indent count, (if call_changed_bytes SIN_CHANGED 0)))
    ))

;; Shift one line of the current block one shiftwidth right or left.
;; Leaves cursor on first character in block.

(defn- #_void shift_block [#_oparg_C oap, #_int amount]
    (ยง
        ((ร boolean left =) (ยง (oap.op_type == OP_LSHIFT)))

        ((ร int oldcol =) (.. @curwin w_cursor col))
        ((ร int q_sw =) (ยง (int)get_sw_value(@curbuf)))
        ((ร int q_ts =) (ยง (int)@curbuf.@b_p_ts))

        ((ร int oldstate =) @State)
        (reset! State INSERT)             ;; don't want REPLACE for State

        ((ร block_def_C bd =) (ยง ยง_block_def_C()))
        (block_prep oap, bd, (.. @curwin w_cursor lnum), true)
        (if (. bd is_short)
            (ร RETURN)
        )

        ;; total is number of screen columns to be inserted/removed
        ((ร int total =) (* amount q_sw))
        ((ร Bytes oldp =) (ml_get_curline))
        (ร Bytes newp)

        (cond (not left)
        (ยง
            ;;  1. Get start vcol
            ;;  2. Total ws vcols
            ;;  3. Divvy into TABs & spp
            ;;  4. Construct new string

            ((ร total +=) (. bd pre_whitesp))    ;; all virtual WS upto & incl. a split TAB
            ((ร int ws_vcol =) (ยง bd.start_vcol - bd.pre_whitesp))
            (if (!= (. bd startspaces) 0)
                ((ร bd.textstart =) (ยง bd.textstart.plus(us_ptr2len_cc(bd.textstart))))
            )
            (while (ยง vim_iswhite(bd.textstart.at(0)))
                ;; TODO: is passing bd.textstart for start of the line OK?
                (ร int incr)
;               { Bytes[] __ = { bd.textstart }; incr = lbr_chartabsize_adv(bd.textstart, __, bd.start_vcol); bd.textstart = __[0]; }
                ((ร total +=) incr)
                ((ร bd.start_vcol +=) incr)
            )
            ;; OK, now total=all the VWS reqd, and textstart
            ;; points at the 1st non-ws char in the block.
            ((ร int i =) (ยง 0, j = total))
            (if (not @(. @curbuf b_p_et))
                ((ร i =) (ยง ((ws_vcol % q_ts) + total) / q_ts)) ;; number of tabs
            )
            (if (non-zero? i)
                ((ร j =) (ยง ((ws_vcol % q_ts) + total) % q_ts)) ;; number of spp
            )
            ;; if we're splitting a TAB, allow for it
            ((ร bd.textcol -=) (- (. bd pre_whitesp_c) (if (!= (. bd startspaces) 0) 1 0)))
            ((ร int len =) (ยง STRLEN(bd.textstart) + 1))
            ((ร newp =) (ยง new Bytes(bd.textcol + i + j + len)))

            (BCOPY newp, oldp, (. bd textcol))
            (copy_chars (.plus newp (. bd textcol)), i, TAB)
            (copy_spaces (.plus newp (+ (. bd textcol) i)), j)
            (BCOPY newp, (ยง bd.textcol + i + j), (. bd textstart), 0, len)
        )
        :else ;; left
        (ยง
            ;; Firstly, let's find the first non-whitespace character that is
            ;; displayed after the block's start column and the character's column
            ;; number.  Also, let's calculate the width of all the whitespace
            ;; characters that are displayed in the block and precede the searched
            ;; non-whitespace character.

            ;; If "bd.startspaces" is set, "bd.textstart" points to the character,
            ;; the part of which is displayed at the block's beginning.  Let's start
            ;; searching from the next character.
; %%        ((ร Bytes[] non_white =) (ยง { bd.textstart }))
            (if (!= (. bd startspaces) 0)
                ((ร non_white[0] =) (ยง non_white[0].plus(us_ptr2len_cc(non_white[0]))))
            )

            ;; The character's column is in "bd.start_vcol".
            ((ร int non_white_col =) (. bd start_vcol))

            (while (ยง vim_iswhite(non_white[0].at(0)))
                ((ร int incr =) (ยง lbr_chartabsize_adv(bd.textstart, non_white, non_white_col)))
                ((ร non_white_col +=) incr)
            )

            ((ร int block_space_width =) (ยง non_white_col - oap.start_vcol))
            ;; We will shift by "total" or "block_space_width", whichever is less.
            ((ร int shift_amount =) (if (< block_space_width total) block_space_width total))

            ;; The column to which we will shift the text.
            ((ร int destination_col =) (- non_white_col shift_amount))

            ;; Now let's find out how much of the beginning
            ;; of the line we can reuse without modification.

            ;; end of the part of the line which is copied verbatim
            ((ร Bytes verbatim_copy_end =) (. bd textstart))
            ;; the (displayed) width of this part of line
            ((ร int verbatim_copy_width =) (. bd start_vcol))

            ;; If "bd.startspaces" is set, "bd.textstart" points to the character preceding the block.
            ;; We have to subtract its width to obtain its column number.
            (if (!= (. bd startspaces) 0)
                ((ร verbatim_copy_width -=) (. bd start_char_vcols))
            )
            (while (< verbatim_copy_width destination_col)
                ((ร Bytes line =) verbatim_copy_end)

                ;; TODO: is passing "verbatim_copy_end" for start of the line OK?
                ((ร int incr =) (lbr_chartabsize line, verbatim_copy_end, verbatim_copy_width))
                (if (< destination_col (+ verbatim_copy_width incr))
                    (ร BREAK)
                )
                ((ร verbatim_copy_width +=) incr)
                ((ร verbatim_copy_end =) (ยง verbatim_copy_end.plus(us_ptr2len_cc(verbatim_copy_end))))
            )

            ;; If "destination_col" is different from the width of the initial
            ;; part of the line that will be copied, it means we encountered a tab
            ;; character, which we will have to partly replace with spaces.
            ((ร int fill =) (- destination_col verbatim_copy_width))

            ;; The replacement line will consist of:
            ;; - the beginning of the original line up to "verbatim_copy_end",
            ;; - "fill" number of spaces,
            ;; - the rest of the line, pointed to by "non_white".

            ;; the length of the line after the block shift
            ((ร int diff =) (BDIFF verbatim_copy_end, oldp))
            ((ร int new_line_len =) (ยง diff + fill + STRLEN(non_white[0]) + 1))

            ((ร newp =) (ยง new Bytes(new_line_len)))

            (BCOPY newp, oldp, diff)
            (copy_spaces (.plus newp diff), fill)
            (BCOPY newp, (+ diff fill), (ยง non_white[0]), 0, (+ (STRLEN (ยง non_white[0])) 1))
        ))

        ;; replace the line
        (ml_replace (.. @curwin w_cursor lnum), newp)
        (changed_bytes (.. @curwin w_cursor lnum), (. bd textcol))
        (reset! State oldstate)
        ((ร @curwin.w_cursor.col =) oldcol)
    ))

;; Insert string "s" (b_insert ? before : after) block.
;; Caller must prepare for undo.

(defn- #_void block_insert [#_oparg_C oap, #_Bytes s, #_boolean b_insert, #_block_def_C bdp]
    (ยง
        ((ร int count =) 0)                                  ;; extra spaces to replace a cut TAB
        ((ร int spaces =) 0)                                 ;; non-zero if cutting a TAB

        ((ร int oldstate =) @State)
        (reset! State INSERT)                                 ;; don't want REPLACE for State

        ((ร int s_len =) (STRLEN s))

        ((ร FOR) (ร (ยง long lnum = oap.op_start.lnum + 1) (ยง lnum <= oap.op_end.lnum) (ยง lnum++))
            (block_prep oap, bdp, lnum, true)
            (if (and (. bdp is_short) b_insert)
                (ร CONTINUE)                               ;; OP_INSERT, line ends before block start
            )

            ((ร Bytes oldp =) (ml_get lnum))

            (ร int q_ts)
            (ร int offset)
            (cond b_insert
            (ยง
                ((ร q_ts =) (. bdp start_char_vcols))
                ((ร spaces =) (. bdp startspaces))
                (if (non-zero? spaces)
                    ((ร count =) (- q_ts 1))                   ;; we're cutting a TAB
                )
                ((ร offset =) (. bdp textcol))
            )
            :else                                        ;; append
            (ยง
                ((ร q_ts =) (. bdp end_char_vcols))
                (cond (not (. bdp is_short))                      ;; spaces = padding after block
                (ยง
                    ((ร spaces =) (if (!= (. bdp endspaces) 0) (- q_ts (. bdp endspaces)) 0))
                    (if (non-zero? spaces)
                        ((ร count =) (- q_ts 1))               ;; we're cutting a TAB
                    )
                    ((ร offset =) (- (+ (. bdp textcol) (. bdp textlen)) (if (!= spaces 0) 1 0)))
                )
                :else                                    ;; spaces = padding to block edge
                (ยง
                    ;; if $ used, just append to EOL (ie spaces==0)
                    (if (not (. bdp is_MAX))
                        ((ร spaces =) (ยง (oap.end_vcol - bdp.end_vcol) + 1))
                    )
                    ((ร count =) spaces)
                    ((ร offset =) (ยง bdp.textcol + bdp.textlen))
                ))
            ))

            (when (< 0 spaces)
                (ร int off)

                ;; Avoid starting halfway a multi-byte character.
                (cond b_insert
                (ยง
                    ((ร off =) (ยง us_head_off(oldp, oldp.plus(offset + spaces))))
                )
                :else
                (ยง
                    ((ร off =) (ยง us_off_next(oldp, oldp.plus(offset))))
                    ((ร offset +=) off)
                ))
                ((ร spaces -=) off)
                ((ร count -=) off)
            )

            ((ร Bytes newp =) (ยง new Bytes(STRLEN(oldp) + s_len + count + 1)))

            ;; copy up to shifted part
            (BCOPY newp, oldp, offset)
            ((ร oldp =) (ยง oldp.plus(offset)))

            ;; insert pre-padding
            (copy_spaces (.plus newp offset), spaces)

            ;; copy the new text
            (BCOPY newp, (+ offset spaces), s, 0, s_len)
            ((ร offset +=) s_len)

            (when (and (< 0 spaces) (not (. bdp is_short)))
                ;; insert post-padding
                (copy_spaces (.plus newp (+ offset spaces)), (- q_ts spaces))
                ;; We're splitting a TAB, don't copy it.
                ((ร oldp =) (ยง oldp.plus(1)))
                ;; We allowed for that TAB, remember this now.
                (ยง count++)
            )

            (if (< 0 spaces)
                ((ร offset +=) count)
            )
            (BCOPY newp, offset, oldp, 0, (+ (STRLEN oldp) 1))

            (ml_replace lnum, newp)

            (when (== lnum (.. oap op_end lnum))
                ;; Set "']" mark to the end of the block instead of the end of the insert in the first line.
                ((ร @curbuf.b_op_end.lnum =) (.. oap op_end lnum))
                ((ร @curbuf.b_op_end.col =) offset)
            )
        )

        (changed_lines (+ (.. oap op_start lnum) 1), 0, (+ (.. oap op_end lnum) 1), 0)

        (reset! State oldstate)
    ))

;; op_reindent - handle reindenting a block of lines.

(defn- #_void op_reindent [#_oparg_C oap, #_getindent_F getindent]
    (ยง
        ((ร long first_changed =) 0)
        ((ร long last_changed =) 0)
        ((ร long start_lnum =) (.. @curwin w_cursor lnum))

        (ร long i)
        ((ร FOR) (ร (ยง i = oap.line_count) (ยง 0 <= --i && !@got_int) nil)
            ;; It's a slow thing to do, so give feedback,
            ;; so there's no worry that the computer's just hung.

            (if (and (< 1 i) (or (== (% i 50) 0) (== i (- (. oap line_count) 1))) (< @p_report (. oap line_count)))
                (smsg (u8 "%ld lines to indent... "), i))

            ((ร int count =) 0)
            ((ร Bytes l =) (ยง skipwhite(ml_get_curline())))
            (if (non-eos? l)                     ;; empty or blank line
                ((ร count =) (getindent))            ;; get the indent for this line
            )

            (when (set_indent count, SIN_UNDO)
                ;; did change the indent, call changed_lines() later
                (if (zero? first_changed)
                    ((ร first_changed =) (.. @curwin w_cursor lnum))
                )
                ((ร last_changed =) (.. @curwin w_cursor lnum))
            )

            (ยง @curwin.w_cursor.lnum++)
            ((ร @curwin.w_cursor.col =) 0)            ;; make sure it's valid
        )

        ;; put cursor on first non-blank of indented line
        ((ร @curwin.w_cursor.lnum =) start_lnum)
        (beginline (| BL_SOL BL_FIX))

        ;; Mark changed lines so that they will be redrawn.
        ;; When Visual highlighting was present, need to continue until the last line.
        ;; When there is no change still need to remove the Visual highlighting.
        (cond (non-zero? last_changed)
        (ยง
            (changed_lines first_changed, 0, (if (. oap is_VIsual) (+ start_lnum (. oap line_count)) (+ last_changed 1)), 0)
        )
        (. oap is_VIsual)
        (ยง
            (redraw_curbuf_later INVERTED)
        ))

        (when (< @p_report (. oap line_count))
            ((ร i =) (ยง oap.line_count - (i + 1)))
            (if (== i 1)
                (msg (u8 "1 line indented "))
                (smsg (u8 "%ld lines indented "), i))
        )
        ;; set '[ and '] marks
        (COPY_pos (. @curbuf b_op_start), (. oap op_start))
        (COPY_pos (. @curbuf b_op_end), (. oap op_end))
    ))

;; Keep the last expression line here, for repeating.

(atom! Bytes expr_line)

;; Get an expression for the "\"=expr1" or "CTRL-R =expr1"
;; Returns '=' when OK, NUL otherwise.

(defn- #_int get_expr_register []
    (ยง
        ((ร Bytes new_line =) (ยง getcmdline((byte \=), 0)))
        (if (nil? new_line)
            ((ร RETURN) NUL)
        )

        (cond (eos? new_line)
        (ยง
            ; ;; use previous line
        )
        :else
        (ยง
            (reset! expr_line new_line)
        ))

        (byte \=)
    ))

(atom! int __nested)

;; Get the result of the '=' register expression.
;; Returns a pointer to allocated memory, or null for failure.

(defn- #_Bytes get_expr_line []
    (ยง
        (if (nil? @expr_line)
            ((ร RETURN) null)
        )

        ;; Make a copy of the expression, because evaluating it may cause it to be changed.
        ((ร Bytes expr_copy =) (STRDUP @expr_line))

        ;; When we are invoked recursively limit the evaluation to 10 levels.
        ;; Then return the string as-is.
        (if (<= 10 @__nested)
            ((ร RETURN) expr_copy)
        )

        (swap! __nested inc)
        ((ร Bytes rv =) (eval_to_string expr_copy, null))
        (swap! __nested dec)
        rv
    ))

;; Check if 'regname' is a valid name of a yank register.
;; Note: There is no check for 0 (default register), caller should do this.

(defn- #_boolean valid_yank_reg [#_int regname, #_boolean writing]
    ;; writing: if true check for writable registers
    (ยง
        (or (and (< 0 regname) (asc_isalnum regname)) (and (not writing) (non-nil? (vim_strchr (u8 "/.%:="), regname))) (== regname (byte \#)) (== regname (byte \")) (== regname (byte \-)) (== regname (byte \_)) (== regname (byte \*)) (== regname (byte \+)) (and (not writing) (== regname (byte \~))))   ;; """
    ))

;; Set y_current and y_append, according to the value of "regname".
;; Cannot handle the '_' register.
;; Must only be called with a valid register name!
;;
;; If regname is 0 and writing, use register 0.
;; If regname is 0 and reading, use previous register.

(defn- #_void get_yank_register [#_int regname, #_boolean writing]
    (ยง
        (reset! y_append false)

        (when (and (or (zero? regname) (== regname (byte \"))) (not writing) (non-nil? @y_previous))    ;; """
            (reset! y_current @y_previous)
            (ร RETURN)
        )

        ((ร int i =) regname)
        (cond (asc_isdigit i)
        (ยง
            ((ร i -=) (byte \0))
        )
        (asc_islower i)
        (ยง
            ((ร i =) (ยง lowerOrd(i) + 10))
        )
        (asc_isupper i)
        (ยง
            ((ร i =) (ยง upperOrd(i) + 10))
            (reset! y_append true)
        )
        (== regname (byte \-))
        (ยง
            ((ร i =) DELETION_REGISTER)
        )
        (and (not writing) (== regname (byte \~)))
        (ยง
            ((ร i =) TILDE_REGISTER)
        )
        :else                ;; not 0-9, a-z, A-Z or '-': use register 0
        (ยง
            ((ร i =) 0)
        ))

        (reset! y_current (ยง y_regs[i]))

        (when writing        ;; remember the register we write into for do_put()
            (reset! y_previous @y_current)
        )
    ))

;; Obtain the contents of a "normal" register.  The register is made empty.
;; The returned pointer has allocated memory, use put_register() later.

(defn- #_yankreg_C get_register [#_int name, #_boolean copy]
    ;; copy: make a copy, if false make register empty.
    (ยง
        (get_yank_register name, false)

        ((ร yankreg_C reg =) (ยง ยง_yankreg_C()))

        (COPY_yankreg reg, @y_current)
        (cond copy
        (ยง
            ;; If we run out of memory some or all of the lines are empty.
            (cond (zero? (. reg y_size))
            (ยง
                ((ร reg.y_array =) null)
            )
            :else
            (ยง
                ((ร reg.y_array =) (ยง new Bytes[reg.y_size]))

                ((ร FOR) (ร (ยง int i = 0) (ยง i < reg.y_size) (ยง i++))
                    ((ร reg.y_array[i] =) (ยง STRDUP(@y_current.y_array[i])))
                )
            ))
        )
        :else
        (ยง
            ((ร @y_current.y_array =) null)
        ))

        reg
    ))

;; Put "reg" into register "name".  Free any previous contents and "reg".

(defn- #_void put_register [#_int name, #_yankreg_C reg]
    (ยง
        (get_yank_register name, false)
        ((ร @y_current.y_array =) null)
        (COPY_yankreg @y_current, reg)
    ))

(atom! int rec__regname)

;; Start or stop recording into a yank register.
;;
;; Return false for failure, true otherwise.

(defn- #_boolean do_record [#_int c]
    (ยง
        (ร boolean retval)

        (cond (not @Recording)         ;; start recording
        (ยง
            ;; registers 0-9, a-z and " are allowed
            (cond (or (< c 0) (and (not (asc_isalnum c)) (!= c (byte \")))) ;; """
            (ยง
                ((ร retval =) false)
            )
            :else
            (ยง
                (reset! Recording true)
                (showmode)
                (reset! rec__regname c)
                ((ร retval =) true)
            ))
        )
        :else                            ;; stop recording
        (ยง
            ;; Get the recorded key hits.
            ;; KB_SPECIAL will be escaped, this needs to be removed again to put it in a register.
            ;; exec_reg then adds the escaping back later.

            (reset! Recording false)
            (msg (u8 ""))
            ((ร Bytes p =) (get_recorded))
            (cond (nil? p)
            (ยง
                ((ร retval =) false)
            )
            :else
            (ยง
                ;; Remove escaping for KB_SPECIAL in multi-byte chars.
                (vim_unescape_special p)

                ;; We don't want to change the default register here,
                ;; so save and restore the current register name.

                ((ร yankreg_C old_y_previous =) @y_previous)
                ((ร yankreg_C old_y_current =) @y_current)

                ((ร retval =) (stuff_yank @rec__regname, p))

                (reset! y_previous old_y_previous)
                (reset! y_current old_y_current)
            ))
        ))

        retval
    ))

;; Stuff string "p" into yank register "regname" as a single line (append if uppercase).
;; "p" must have been alloced.
;;
;; return false for failure, true otherwise

(defn- #_boolean stuff_yank [#_int regname, #_Bytes p]
    (ยง
        ;; check for read-only register
        (if (and (non-zero? regname) (not (valid_yank_reg regname, true)))
            ((ร RETURN) false)
        )
        (if (== regname (byte \_))             ;; black hole: don't do anything
            ((ร RETURN) true)
        )

        (get_yank_register regname, true)

        (cond (and @y_append (!= (. @y_current y_array) null))
        (ยง
            ((ร Bytes[] a =) (. @y_current y_array))
            ((ร int i =) (ยง @y_current.y_size - 1))

            ((ร Bytes lp =) (ยง new Bytes(STRLEN(a[i]) + STRLEN(p) + 1)))
            (STRCPY lp, (ยง a[i]))
            (STRCAT lp, p)
            ((ร a[i] =) lp)
        )
        :else
        (ยง
            ((ร @y_current.y_array =) (ยง new Bytes[1]))
            ((ร @y_current.y_array[0] =) p)
            ((ร @y_current.y_size =) 1)
            ((ร @y_current.y_type =) MCHAR)   ;; used to be MLINE, why?
        ))

        true
    ))

(atom! int execreg_lastc NUL)

;; execute a yank register: copy it into the stuff buffer
;;
;; return false for failure, true otherwise

(defn- #_boolean do_execreg [#_int regname]
    (ยง
        (when (== regname (byte \@))                 ;; repeat previous one
            (when (== @execreg_lastc NUL)
                (emsg (u8 "E748: No previously used register"))
                ((ร RETURN) false)
            )
            ((ร regname =) @execreg_lastc)
        )
                                            ;; check for valid regname
        (when (or (== regname (byte \%)) (== regname (byte \#)) (not (valid_yank_reg regname, false)))
            (emsg_invreg regname)
            ((ร RETURN) false)
        )
        (reset! execreg_lastc regname)

        ((ร regname =) (may_get_selection regname))

        (if (== regname (byte \_))                 ;; black hole: don't stuff anything
            ((ร RETURN) true)
        )

        (when (== regname (byte \:))                 ;; use last command line
            (when (nil? @last_cmdline)
                (emsg e_nolastcmd)
                ((ร RETURN) false)
            )

            (reset! new_last_cmdline null)        ;; don't keep the cmdline containing @:

            ;; Escape all control characters with a CTRL-V.
            ((ร Bytes p =) (ยง vim_strsave_escaped_ext(@last_cmdline, (u8 "\001\002\003\004\005\006\007\010\011\012\013\014\015\016\017\020\021\022\023\024\025\026\027\030\031\032\033\034\035\036\037"), Ctrl_V)))

            ;; When in Visual mode "'<,'>" will be prepended to the command.
            ;; Remove it when it's already there.
            (if (and @VIsual_active (zero? (STRNCMP p, (u8 "'<,'>"), 5)))
                ((ร p =) (ยง p.plus(5)))
            )

            ((ร RETURN) (put_in_typebuf p, true, true))
        )

        (when (== regname (byte \=))
            ((ร Bytes p =) (get_expr_line))
            (if (nil? p)
                ((ร RETURN) false)
            )

            ((ร RETURN) (put_in_typebuf p, true, false))
        )

        (when (== regname (byte \.))            ;; use last inserted text
            ((ร Bytes p =) (get_last_insert_save))
            (when (nil? p)
                (emsg e_noinstext)
                ((ร RETURN) false)
            )
            ((ร RETURN) (put_in_typebuf p, false, false))
        )

        (get_yank_register regname, false)
        (if (nil? (. @y_current y_array))
            ((ร RETURN) false)
        )

        ;; Insert lines into typeahead buffer, from last one to first one.

        (put_reedit_in_typebuf)

        ((ร FOR) (ร (ยง int i = @y_current.y_size) (ยง 0 <= --i) nil)
            ;; insert NL between lines and after last line if type is MLINE
            (if (or (== (. @y_current y_type) MLINE) (< i (- (. @y_current y_size) 1)))
                (ins_typebuf (u8 "\n")))

            ((ร Bytes escaped =) (ยง vim_strsave_escape_special(@y_current.y_array[i])))

            (ins_typebuf escaped)
        )

        (reset! execReg true)         ;; disable the 'q' command

        true
    ))

;; If "restart_edit" is not zero, put it in the typeahead buffer,
;; so that it's used only after other typeahead has been processed.

(defn- #_void put_reedit_in_typebuf []
    (ยง
        (when (!= @restart_edit NUL)
            ((ร Bytes buf =) (ยง new Bytes(3)))

            (cond (== @restart_edit (byte \V))
            (ยง
                (.be buf 0, (byte \g))
                (.be buf 1, (byte \R))
                (.be buf 2, NUL)
            )
            :else
            (ยง
                (.be buf 0, (if (== @restart_edit (byte \I)) (byte \i) @restart_edit))
                (.be buf 1, NUL)
            ))

            (ins_typebuf buf)
            (reset! restart_edit NUL)
        )
    ))

;; Insert register contents "s" into the typeahead buffer, so that it will be executed again.
;; When "esc" is true it is to be taken literally: escape CSI characters and no remapping.

(defn- #_boolean put_in_typebuf [#_Bytes s, #_boolean esc, #_boolean colon]
    ;; colon: add ':' before the line
    (ยง
        (put_reedit_in_typebuf)

        (if colon
            (ins_typebuf (u8 "\n")))

        ((ร Bytes p =) (if esc (vim_strsave_escape_special s) s))
        (if (nil? p)
            ((ร RETURN) false)
        )

        (ins_typebuf p)

        (if colon
            (ins_typebuf (u8 ":")))

        true
    ))

;; Insert a yank register: copy it into the Read buffer.
;; Used by CTRL-R command and middle mouse button in insert mode.
;;
;; return false for failure, true otherwise

(defn- #_boolean insert_reg [#_int regname, #_boolean literally]
    ;; literally: insert literally, not as if typed
    (ยง
        ((ร boolean retval =) true)

        ;; It is possible to get into an endless loop by having CTRL-R a in
        ;; register a and then, in insert mode, doing CTRL-R a.
        ;; If you hit CTRL-C, the loop will be broken here.

        (ui_breakcheck)
        (if @got_int
            ((ร RETURN) false)
        )

        ;; check for valid regname
        (if (and (!= regname NUL) (not (valid_yank_reg regname, false)))
            ((ร RETURN) false)
        )

        ((ร regname =) (may_get_selection regname))

        ((ร Bytes[] arg =) (ยง new Bytes[1]))
        ((ร boolean[] allocated =) (ยง new boolean[1]))

        (cond (== regname (byte \.))                 ;; insert last inserted text
        (ยง
            ((ร retval =) (stuff_inserted NUL, 1, true))
        )
        (get_spec_reg regname, arg, allocated, true)
        (ยง
            (if (nil? (ยง arg[0]))
                ((ร RETURN) false)
            )
            (stuffescaped (ยง arg[0]), literally)
        )
        :else                                ;; name or number register
        (ยง
            (get_yank_register regname, false)
            (cond (nil? (. @y_current y_array))
            (ยง
                ((ร retval =) false)
            )
            :else
            (ยง
                ((ร FOR) (ร (ยง int i = 0) (ยง i < @y_current.y_size) (ยง i++))
                    (stuffescaped (ยง @y_current.y_array[i]), literally)

                    ;; Insert a newline between lines and after last line if y_type is MLINE.

                    (if (or (== (. @y_current y_type) MLINE) (< i (- (. @y_current y_size) 1)))
                        (stuffcharReadbuff (byte \newline)))
                )
            ))
        ))

        retval
    ))

;; Stuff a string into the typeahead buffer, such that edit() will insert it
;; literally ("literally" true) or interpret is as typed characters.

(defn- #_void stuffescaped [#_Bytes _arg, #_boolean literally]
    (ยง
; %%    ((ร Bytes[] arg =) (ยง { _arg }))
        (while (ยง arg[0].at(0) != NUL)
            ;; Stuff a sequence of normal ASCII characters, that's fast.
            ;; Also stuff KB_SPECIAL to get the effect of a special key when "literally" is true.
            ((ร Bytes start =) (ยง arg[0]))
            (while (ยง ((byte \space) <= arg[0].at(0) && arg[0].at(0) < DEL) || (arg[0].at(0) == KB_SPECIAL && !literally))
                ((ร arg[0] =) (ยง arg[0].plus(1)))
            )
            (if (BLT start, (ยง arg[0]))
                (stuffReadbuffLen start, (BDIFF (ยง arg[0]), start)))

            ;; stuff a single special character
            (when (!= (.at (ยง arg[0]) 0) NUL)
                ((ร int c =) (us_ptr2char_adv arg, false))
                (if (and literally (or (and (< c (byte \space)) (!= c TAB)) (== c DEL)))
                    (stuffcharReadbuff Ctrl_V))
                (stuffcharReadbuff c)
            )
        )
    ))

;; If "regname" is a special register, return true and store a pointer to its value in "argp".

(defn- #_boolean get_spec_reg [#_int regname, #_Bytes* argp, #_boolean* allocated, #_boolean errmsg]
    ;; allocated: return: true when value was allocated
    ;; errmsg: give error message when failing
    (ยง
        ((ร argp[0] =) null)
        ((ร allocated[0] =) false)

        ((ร SWITCH) regname
            ((ร CASE) (byte \%))                                       ;; file name
            ((ร CASE) (byte \#))                                       ;; alternate file name
            (ยง
                ((ร argp[0] =) (ยง null))
                ((ร RETURN) false)
            )

            ((ร CASE) (byte \=))                                       ;; result of expression
            (ยง
                ((ร argp[0] =) (get_expr_line))
                ((ร allocated[0] =) true)
                ((ร RETURN) true)
            )

            ((ร CASE) (byte \:))                                       ;; last command line
            (ยง
                (if (and (nil? @last_cmdline) errmsg)
                    (emsg e_nolastcmd))
                ((ร argp[0] =) @last_cmdline)
                ((ร RETURN) true)
            )

            ((ร CASE) (byte \/))                                       ;; last search-pattern
            (ยง
                (if (and (nil? (last_search_pat)) errmsg)
                    (emsg e_noprevre))
                ((ร argp[0] =) (last_search_pat))
                ((ร RETURN) true)
            )

            ((ร CASE) (byte \.))                                       ;; last inserted text
            (ยง
                ((ร argp[0] =) (get_last_insert_save))
                ((ร allocated[0] =) true)
                (if (and (nil? (ยง argp[0])) errmsg)
                    (emsg e_noinstext))
                ((ร RETURN) true)
            )

            ((ร CASE) Ctrl_W)                                    ;; word under cursor
            ((ร CASE) Ctrl_A)                                    ;; WORD (mnemonic All) under cursor
            (ยง
                (if (not errmsg)
                    ((ร RETURN) false)
                )
                ((ร int cnt =) (find_ident_under_cursor argp, (if (== regname Ctrl_W) (| FIND_IDENT FIND_STRING) FIND_STRING)))
                ((ร argp[0] =) (if (!= cnt 0) (STRNDUP (ยง argp[0]), cnt) null))
                ((ร allocated[0] =) true)
                ((ร RETURN) true)
            )

            ((ร CASE) (byte \_))               ;; black hole: always empty
            (ยง
                ((ร argp[0] =) (u8 ""))
                ((ร RETURN) true)
            )
        )

        false
    ))

;; Paste a yank register into the command line.
;; Only for non-special registers.
;; Used by CTRL-R command in command-line mode
;; insert_reg() can't be used here, because special characters from the
;; register contents will be interpreted as commands.
;;
;; return false for failure, true otherwise

(defn- #_boolean cmdline_paste_reg [#_int regname, #_boolean literally, #_boolean remcr]
    ;; literally: Insert text literally instead of "as typed"
    ;; remcr: don't add trailing CR
    (ยง
        (get_yank_register regname, false)
        (if (nil? (. @y_current y_array))
            ((ร RETURN) false)
        )

        ((ร FOR) (ร (ยง int i = 0) (ยง i < @y_current.y_size) (ยง i++))
            (cmdline_paste_str (ยง @y_current.y_array[i]), literally)

            ;; Insert ^M between lines and after last line if type is MLINE.
            ;; Don't do this when "remcr" is true and the next line is empty.
            (when (or (== (. @y_current y_type) MLINE) (and (< i (- (. @y_current y_size) 1)) (not (and remcr (== i (- (. @y_current y_size) 2)) (ยง @y_current.y_array[i + 1].at(0) == NUL)))))
                (cmdline_paste_str (u8 "\r"), literally)
            )

            ;; Check for CTRL-C in case someone tries to paste
            ;; a few thousand lines and gets bored.
            (ui_breakcheck)
            (if @got_int
                ((ร RETURN) false)
            )
        )

        true
    ))

;; Adjust the register name "reg" for the clipboard being used always and the clipboard being available.

(defn- #_int adjust_clip_reg [#_int reg]
    (ยง
        (if (or (== reg (byte \*)) (== reg (byte \+)))
            ((ร reg =) 0)
        )

        reg
    ))

;; When "reg" is a clipboard register, obtain the selection.
;; If it's not available return zero, otherwise return "reg".

(defn- #_int may_get_selection [#_int reg]
    (ยง
        (if (or (== reg (byte \*)) (== reg (byte \+)))
            ((ร reg =) 0)
        )

        reg
    ))

;; Handle a delete operation.
;;
;; Return false if undo failed, true otherwise.

(defn- #_boolean op_delete [#_oparg_C oap]
    (ยง
        ((ร long old_lcount =) (.. @curbuf b_ml ml_line_count))
        ((ร boolean did_yank =) false)
        ((ร int orig_regname =) (. oap regname))

        (if (non-zero? (& (.. @curbuf b_ml ml_flags) ML_EMPTY)) ;; nothing to do
            ((ร RETURN) true)
        )

        ;; Nothing to delete, return here.  Do prepare undo, for op_change().
        (if (. oap empty)
            ((ร RETURN) (u_save_cursor))
        )

        ((ร oap.regname =) (ยง adjust_clip_reg(oap.regname)))

        (mb_adjust_opend oap)

        ;; Imitate the strange Vi behaviour: If the delete spans more than one
        ;; line and motion_type == MCHAR and the result is a blank line, make the
        ;; delete linewise.  Don't do this for the change command or Visual mode.

        (when (ยง oap.motion_type == MCHAR && !oap.is_VIsual && !oap.block_mode && 1 < oap.line_count && oap.motion_force == NUL && oap.op_type == OP_DELETE)
            ((ร Bytes ptr =) (ยง ml_get(oap.op_end.lnum).plus(oap.op_end.col)))
            (if (and (non-eos? ptr) (. oap inclusive))
                ((ร ptr =) (ยง ptr.plus(1)))
            )
            ((ร ptr =) (skipwhite ptr))
            (if (and (eos? ptr) (inindent 0))
                ((ร oap.motion_type =) MLINE)
            )
        )

;       setmarks:
;       {
            ;; Check for trying to delete (e.g. "D") in an empty line.
            ;; Note: For the change operator it is ok.

            (when (and (== (. oap motion_type) MCHAR) (== (. oap line_count) 1) (== (. oap op_type) OP_DELETE) (== (.at (ml_get (.. oap op_start lnum)) 0) NUL))
                ;; It's an error to operate on an empty region,
                ;; when 'E' included in 'cpoptions' (Vi compatible).

                (when (!= @virtual_op FALSE)
                    ;; Virtual editing: nothing gets deleted,
                    ;; but we set the '[ and '] marks as if it happened.
                    (ร BREAK setmarks)
                )
                (if (non-nil? (vim_strbyte @p_cpo, CPO_EMPTYREGION))
                    (beep_flush))
                ((ร RETURN) true)
            )

            ;; Do a yank of whatever we're about to delete.
            ;; If a yank register was specified, put the deleted text into that register.
            ;; For the black hole register '_' don't yank anything.

            (when (!= (. oap regname) (byte \_))
                (when (!= (. oap regname) 0)
                    ;; check for read-only register
                    (when (not (valid_yank_reg (. oap regname), true))
                        (beep_flush)
                        ((ร RETURN) true)
                    )
                    (get_yank_register (. oap regname), true)       ;; yank into specif'd reg.
                    (if (op_yank oap, true, false)      ;; yank without message
                        ((ร did_yank =) true)
                    )
                )

                ;; Put deleted text into register 1 and shift number registers if the
                ;; delete contains a line break, or when a regname has been specified.
                ;; Use the register name from before adjust_clip_reg() may have changed it.

                (when (or (non-zero? orig_regname) (== (. oap motion_type) MLINE) (< 1 (. oap line_count)) (. oap use_reg_one))
                    (reset! y_current (ยง y_regs[9]))
                    ((ร @y_current.y_array =) null)               ;; free register nine
                    ((ร FOR) (ร (ยง int n = 9) (< 1 n) (ยง --n))
                        (COPY_yankreg (ยง y_regs[n]), (ยง y_regs[n - 1]))
                    )
                    (reset! y_previous (ยง @y_current = y_regs[1]))
                    ((ร y_regs[1].y_array =) null)               ;; set register one to empty
                    (if (op_yank oap, true, false)
                        ((ร did_yank =) true)
                    )
                )

                ;; Yank into small delete register when no named register specified
                ;; and the delete is within one line.
                (when (and (zero? (. oap regname)) (!= (. oap motion_type) MLINE) (== (. oap line_count) 1))
                    ((ร oap.regname =) (byte \-))
                    (get_yank_register (. oap regname), true)
                    (if (op_yank oap, true, false)
                        ((ร did_yank =) true)
                    )
                    ((ร oap.regname =) 0)
                )

                ;; If there's too much stuff to fit in the yank register, then get a
                ;; confirmation before doing the delete.  This is crude, but simple.
                ;; And it avoids doing a delete of something we can't put back if we want.

                (when (and (not did_yank) (!= (ask_yesno (u8 "cannot yank; delete anyway"), true) (byte \y)))
                    (emsg e_abort)
                    ((ร RETURN) false)
                )
            )

            ;; block mode delete

            (cond (. oap block_mode)
            (ยง
                (if (not (u_save (- (.. oap op_start lnum) 1), (+ (.. oap op_end lnum) 1)))
                    ((ร RETURN) false)
                )

                ((ร block_def_C bd =) (ยง ยง_block_def_C()))
                ((ร FOR) (ร (ยง long lnum = @curwin.w_cursor.lnum) (ยง lnum <= oap.op_end.lnum) (ยง lnum++))
                    (block_prep oap, bd, lnum, true)
                    (if (zero? (. bd textlen))    ;; nothing to delete
                        (ร CONTINUE)
                    )

                    ;; Adjust cursor position for tab replaced by spaces and 'lbr'.
                    (when (== lnum (.. @curwin w_cursor lnum))
                        ((ร @curwin.w_cursor.col =) (ยง bd.textcol + bd.startspaces))
                        ((ร @curwin.w_cursor.coladd =) 0)
                    )

                    ;; n == number of chars deleted
                    ;; If we delete a TAB, it may be replaced by several characters.
                    ;; Thus the number of characters may increase!

                    ((ร int n =) (ยง bd.textlen - bd.startspaces - bd.endspaces))
                    ((ร Bytes oldp =) (ml_get lnum))
                    ((ร Bytes newp =) (ยง new Bytes(STRLEN(oldp) + 1 - n)))

                    ;; copy up to deleted part
                    (BCOPY newp, oldp, (. bd textcol))
                    ;; insert spaces
                    (copy_spaces (.plus newp (. bd textcol)), (+ (. bd startspaces) (. bd endspaces)))
                    ;; copy the part after the deleted part
                    ((ร oldp =) (ยง oldp.plus(bd.textcol + bd.textlen)))
                    (BCOPY newp, (ยง bd.textcol + bd.startspaces + bd.endspaces), oldp, 0, (+ (STRLEN oldp) 1))
                    ;; replace the line
                    (ml_replace lnum, newp)
                )

                (check_cursor_col)
                (changed_lines (.. @curwin w_cursor lnum), (.. @curwin w_cursor col), (+ (.. oap op_end lnum) 1), 0)
                ((ร oap.line_count =) 0)     ;; no lines deleted
            )
            (== (. oap motion_type) MLINE)
            (ยง
                (cond (== (. oap op_type) OP_CHANGE)
                (ยง
                    ;; Delete the lines except the first one.  Temporarily move the
                    ;; cursor to the next line.  Save the current line number, if the
                    ;; last line is deleted it may be changed.

                    (when (< 1 (. oap line_count))
                        ((ร long lnum =) (.. @curwin w_cursor lnum))
                        (ยง @curwin.w_cursor.lnum++)
                        (del_lines (- (. oap line_count) 1), true)
                        ((ร @curwin.w_cursor.lnum =) lnum)
                    )
                    (if (not (u_save_cursor))
                        ((ร RETURN) false)
                    )
                    (cond @(. @curbuf b_p_ai)                  ;; don't delete indent
                    (ยง
                        (beginline BL_WHITE)            ;; cursor on first non-white
                        (reset! did_ai true)                  ;; delete the indent when ESC hit
                        (reset! ai_col (.. @curwin w_cursor col))
                    )
                    :else
                    (ยง
                        (beginline 0)                   ;; cursor in column 0
                    ))
                    (truncate_line false)               ;; delete the rest of the line
                                                        ;; leave cursor past last char in line
                    (if (< 1 (. oap line_count))
                        (u_clearline))                  ;; "U" command not possible after "2cc"
                )
                :else
                (ยง
                    (del_lines (. oap line_count), true)
                    (beginline (| BL_WHITE BL_FIX))
                    (u_clearline)                      ;; "U" command not possible after "dd"
                ))
            )
            :else
            (ยง
                (when (!= @virtual_op FALSE)
                    ((ร int endcol =) 0)

                    ;; For virtualedit: break the tabs that are partly included.
                    (when (== (gchar_pos (. oap op_start)) (byte \tab))
                        (if (not (u_save_cursor))       ;; save first line for undo
                            ((ร RETURN) false)
                        )
                        (if (== (. oap line_count) 1)
                            ((ร endcol =) (ยง getviscol2(oap.op_end.col, oap.op_end.coladd)))
                        )
                        (coladvance_force (getviscol2 (.. oap op_start col), (.. oap op_start coladd)))
                        (COPY_pos (. oap op_start), (. @curwin w_cursor))
                        (when (== (. oap line_count) 1)
                            (coladvance endcol)
                            ((ร oap.op_end.col =) (.. @curwin w_cursor col))
                            ((ร oap.op_end.coladd =) (.. @curwin w_cursor coladd))
                            (COPY_pos (. @curwin w_cursor), (. oap op_start))
                        )
                    )

                    ;; Break a tab only when it's included in the area.
                    (when (and (== (gchar_pos (. oap op_end)) (byte \tab)) (< (.. oap op_end coladd) (if (. oap inclusive) 1 0)))
                        ;; save last line for undo
                        (if (not (u_save (- (.. oap op_end lnum) 1), (+ (.. oap op_end lnum) 1)))
                            ((ร RETURN) false)
                        )
                        (COPY_pos (. @curwin w_cursor), (. oap op_end))
                        (coladvance_force (getviscol2 (.. oap op_end col), (.. oap op_end coladd)))
                        (COPY_pos (. oap op_end), (. @curwin w_cursor))
                        (COPY_pos (. @curwin w_cursor), (. oap op_start))
                    )
                )

                (cond (== (. oap line_count) 1)            ;; delete characters within one line
                (ยง
                    (if (not (u_save_cursor))           ;; save line for undo
                        ((ร RETURN) false)
                    )

                    ((ร int n =) (- (+ (- (.. oap op_end col) (.. oap op_start col)) 1) (if (not (. oap inclusive)) 1 0)))

                    (when (!= @virtual_op FALSE)
                        ;; fix up things for virtualedit-delete:
                        ;; break the tabs which are going to get in our way

                        ((ร Bytes curline =) (ml_get_curline))
                        ((ร int len =) (STRLEN curline))

                        (when (and (!= (.. oap op_end coladd) 0) (ยง len - 1 <= oap.op_end.col) (not (and (!= (.. oap op_start coladd) 0) (ยง len - 1 <= oap.op_end.col))))
                            (ยง n++)
                        )
                        ;; Delete at least one char (e.g, when on a control char).
                        (if (and (zero? n) (!= (.. oap op_start coladd) (.. oap op_end coladd)))
                            ((ร n =) 1)
                        )

                        ;; When deleted a char in the line, reset coladd.
                        (if (!= (gchar_cursor) NUL)
                            ((ร @curwin.w_cursor.coladd =) 0)
                        )
                    )
                    (cond (and (== (. oap op_type) OP_DELETE) (. oap inclusive) (== (.. oap op_end lnum) (.. @curbuf b_ml ml_line_count)) (< (STRLEN (ml_get (.. oap op_end lnum))) n))
                    (ยง
                        ;; Special case: gH<Del> deletes the last line.
                        (del_lines 1, false)
                    )
                    :else
                    (ยง
                        (del_bytes n, (== @virtual_op FALSE), (and (== (. oap op_type) OP_DELETE) (not (. oap is_VIsual))))
                    ))
                )
                :else                                    ;; delete characters between lines
                (ยง
                    ;; save deleted and changed lines for undo
                    (if (not (u_save (- (.. @curwin w_cursor lnum) 1), (+ (.. @curwin w_cursor lnum) (. oap line_count))))
                        ((ร RETURN) false)
                    )

                    ((ร boolean delete_last_line =) (ยง (oap.op_end.lnum == @curbuf.b_ml.ml_line_count)))
                    (truncate_line true)                ;; delete from cursor to end of line

                    ((ร pos_C curpos =) (ยง ยง_pos_C()))
                    (COPY_pos curpos, (. @curwin w_cursor))

                    (ยง @curwin.w_cursor.lnum++)
                    (del_lines (- (. oap line_count) 2), false)

                    (if delete_last_line
                        ((ร oap.op_end.lnum =) (.. @curbuf b_ml ml_line_count))
                    )

                    ((ร int n =) (- (+ (.. oap op_end col) 1) (if (not (. oap inclusive)) 1 0)))
                    (cond (and (. oap inclusive) delete_last_line (< (STRLEN (ml_get (.. oap op_end lnum))) n))
                    (ยง
                        ;; Special case: gH<Del> deletes the last line.
                        (del_lines 1, false)
                        (COPY_pos (. @curwin w_cursor), curpos)
                        (if (> (.. @curwin w_cursor lnum) (.. @curbuf b_ml ml_line_count))
                            ((ร @curwin.w_cursor.lnum =) (.. @curbuf b_ml ml_line_count))
                        )
                    )
                    :else
                    (ยง
                        ;; delete from start of line until op_end
                        ((ร @curwin.w_cursor.col =) 0)
                        (del_bytes n, (== @virtual_op FALSE), (and (== (. oap op_type) OP_DELETE) (not (. oap is_VIsual))))
                        (COPY_pos (. @curwin w_cursor), curpos)
                    ))
                    (if (< (.. @curwin w_cursor lnum) (.. @curbuf b_ml ml_line_count))
                        (do_join 2, false, false, false, false))
                ))
            ))

            (msgmore (- (.. @curbuf b_ml ml_line_count) old_lcount))
;       }

        (cond (. oap block_mode)
        (ยง
            ((ร @curbuf.b_op_end.lnum =) (.. oap op_end lnum))
            ((ร @curbuf.b_op_end.col =) (.. oap op_start col))
        )
        :else
        (ยง
            (COPY_pos (. @curbuf b_op_end), (. oap op_start))
        ))
        (COPY_pos (. @curbuf b_op_start), (. oap op_start))

        true
    ))

;; Adjust end of operating area for ending on a multi-byte character.
;; Used for deletion.

(defn- #_void mb_adjust_opend [#_oparg_C oap]
    (ยง
        (when (. oap inclusive)
            ((ร Bytes p =) (ยง ml_get(oap.op_end.lnum)))
            ((ร oap.op_end.col +=) (ยง us_tail_off(p, p.plus(oap.op_end.col))))
        )
    ))

;; Replace a whole area with one character.

(defn- #_boolean op_replace [#_oparg_C oap, #_int c]
    (ยง
        ((ร Bytes after_p =) null)
        ((ร boolean had_ctrl_v_cr =) (ยง (c == -1 || c == -2)))

        (if (or (non-zero? (& (.. @curbuf b_ml ml_flags) ML_EMPTY)) (. oap empty))
            ((ร RETURN) true)            ;; nothing to do
        )

        (if had_ctrl_v_cr
            ((ร c =) (if (== c -1) (byte \return) (byte \newline)))
        )

        (mb_adjust_opend oap)

        (if (not (u_save (- (.. oap op_start lnum) 1), (+ (.. oap op_end lnum) 1)))
            ((ร RETURN) false)
        )

        ;; block mode replace

        (cond (. oap block_mode)
        (ยง
            ((ร block_def_C bd =) (ยง ยง_block_def_C()))

            ((ร bd.is_MAX =) (ยง (@curwin.w_curswant == MAXCOL)))
            ((ร FOR) (ร (ยง  ) (ยง @curwin.w_cursor.lnum <= oap.op_end.lnum) (ยง @curwin.w_cursor.lnum++))
                ((ร @curwin.w_cursor.col =) 0)    ;; make sure cursor position is valid
                (block_prep oap, bd, (.. @curwin w_cursor lnum), true)
                (when (and (zero? (. bd textlen)) (or (== @virtual_op FALSE) (. bd is_MAX)))
                    (ร CONTINUE)               ;; nothing to replace
                )

                ;; n == number of extra chars required
                ;; If we split a TAB, it may be replaced by several characters.
                ;; Thus the number of characters may increase!

                ;; If the range starts in virtual space,
                ;; count the initial coladd offset as part of "startspaces".
                (ร int n)
                (cond (and (!= @virtual_op FALSE) (. bd is_short) (== (ยง bd.textstart.at(0)) NUL))
                (ยง
                    ((ร pos_C vpos =) (ยง ยง_pos_C()))

                    ((ร vpos.lnum =) (.. @curwin w_cursor lnum))
                    (getvpos vpos, (. oap start_vcol))
                    ((ร bd.startspaces +=) (. vpos coladd))
                    ((ร n =) (. bd startspaces))
                )
                :else
                (ยง
                    ;; allow for pre spaces
                    ((ร n =) (if (!= (. bd startspaces) 0) (- (. bd start_char_vcols) 1) 0))
                ))

                ;; allow for post spp
                ((ร n +=) (if (and (!= (. bd endspaces) 0) (not (. bd is_oneChar)) (< 0 (. bd end_char_vcols))) (- (. bd end_char_vcols) 1) 0))
                ;; Figure out how many characters to replace.
                ((ร int numc =) (ยง oap.end_vcol - oap.start_vcol + 1))
                (if (and (. bd is_short) (or (== @virtual_op FALSE) (. bd is_MAX)))
                    ((ร numc -=) (ยง (oap.end_vcol - bd.end_vcol) + 1))
                )

                ;; A double-wide character can be replaced only up to half the times.
                (when (< 1 (utf_char2cells c))
                    (when (and (non-zero? (& numc 1)) (not (. bd is_short)))
                        (ยง bd.endspaces++)
                        (ยง n++)
                    )
                    ((ร numc =) (/ numc 2))
                )

                ;; Compute bytes needed, move character count to num_chars.
                ((ร int num_chars =) numc)
                ((ร numc *=) (utf_char2len c))
                ;; oldlen includes textlen, so don't double count
                ((ร n +=) (ยง numc - bd.textlen))

                ((ร Bytes oldp =) (ml_get_curline))
                ((ร int oldlen =) (STRLEN oldp))
                ((ร Bytes newp =) (ยง new Bytes(oldlen + 1 + n)))

                ;; copy up to deleted part
                (BCOPY newp, oldp, (. bd textcol))
                ((ร oldp =) (ยง oldp.plus(bd.textcol + bd.textlen)))
                ;; insert pre-spaces
                (copy_spaces (.plus newp (. bd textcol)), (. bd startspaces))
                ;; insert replacement chars CHECK FOR ALLOCATED SPACE
                ;; -1/-2 is used for entering CR literally.
                (cond (or had_ctrl_v_cr (and (!= c (byte \return)) (!= c (byte \newline))))
                (ยง
                    ((ร n =) (STRLEN newp))
                    (while (ยง 0 <= --num_chars)
                        ((ร n +=) (ยง utf_char2bytes(c, newp.plus(n))))
                    )

                    (when (not (. bd is_short))
                        ;; insert post-spaces
                        (copy_spaces (ยง newp.plus(STRLEN(newp)), bd.endspaces))
                        ;; copy the part after the changed part
                        (BCOPY newp, (STRLEN newp), oldp, 0, (+ (STRLEN oldp) 1))
                    )
                )
                :else
                (ยง
                    ;; Replacing with \r or \n means splitting the line.
                    ((ร after_p =) (ยง new Bytes(oldlen + 1 + n - STRLEN(newp))))
                    (BCOPY after_p, oldp, (+ (STRLEN oldp) 1))
                ))
                ;; replace the line
                (ml_replace (.. @curwin w_cursor lnum), newp)
                (when (non-nil? after_p)
                    (ml_append (ยง @curwin.w_cursor.lnum++), after_p)
                    (appended_lines_mark (.. @curwin w_cursor lnum), 1)
                    (ยง oap.op_end.lnum++)
                )
            )
        )
        :else
        (ยง
            ;; MCHAR and MLINE motion replace.

            (cond (== (. oap motion_type) MLINE)
            (ยง
                ((ร oap.op_start.col =) 0)
                ((ร @curwin.w_cursor.col =) 0)
                ((ร oap.op_end.col =) (ยง STRLEN(ml_get(oap.op_end.lnum))))
                (if (!= (.. oap op_end col) 0)
                    (ยง --oap.op_end.col)
                )
            )
            (not (. oap inclusive))
            (ยง
                (decp (. oap op_end))
            ))

            (while (ยง ltoreq(@curwin.w_cursor, oap.op_end))
                ((ร int n =) (gchar_cursor))
                (cond (!= n NUL)
                (ยง
                    (cond (or (< 1 (utf_char2len c)) (< 1 (utf_char2len n)))
                    (ยง
                        ;; This is slow, but it handles replacing a single-byte
                        ;; with a multi-byte and the other way around.
                        (if (== (.. @curwin w_cursor lnum) (.. oap op_end lnum))
                            ((ร oap.op_end.col +=) (ยง utf_char2len(c) - utf_char2len(n)))
                        )
                        ((ร n =) @State)
                        (reset! State REPLACE)
                        (ins_char c)
                        (reset! State n)
                        ;; Backup to the replaced character.
                        (dec_cursor)
                    )
                    :else
                    (ยง
                        (when (== n TAB)
                            ((ร int end_vcol =) 0)

                            (when (== (.. @curwin w_cursor lnum) (.. oap op_end lnum))
                                ;; oap.op_end has to be recalculated when the tab breaks
                                ((ร end_vcol =) (ยง getviscol2(oap.op_end.col, oap.op_end.coladd)))
                            )
                            (coladvance_force (getviscol))
                            (if (== (.. @curwin w_cursor lnum) (.. oap op_end lnum))
                                (getvpos (. oap op_end), end_vcol))
                        )
                        (.be (ml_get_buf @curbuf, (.. @curwin w_cursor lnum)) (.. @curwin w_cursor col), c)
                    ))
                )
                (and (!= @virtual_op FALSE) (== (.. @curwin w_cursor lnum) (.. oap op_end lnum)))
                (ยง
                    ((ร int virtcols =) (.. oap op_end coladd))

                    (when (and (== (.. @curwin w_cursor lnum) (.. oap op_start lnum)) (== (.. oap op_start col) (.. oap op_end col)) (!= (.. oap op_start coladd) 0))
                        ((ร virtcols -=) (.. oap op_start coladd))
                    )

                    ;; 'oap.op_end' has been trimmed, so it's effectively inclusive;
                    ;; as a result, an extra +1 must be counted, so we don't trample the NUL byte.
                    (coladvance_force (+ (getviscol2 (.. oap op_end col), (.. oap op_end coladd)) 1))
                    ((ร @curwin.w_cursor.col -=) (ยง (virtcols + 1)))
                    ((ร FOR) (ร (ยง  ) (<= 0 virtcols) (ยง virtcols--))
                        (.be (ml_get_buf @curbuf, (.. @curwin w_cursor lnum)) (.. @curwin w_cursor col), c)
                        (if (== (incp (. @curwin w_cursor)) -1)
                            (ร BREAK)
                        )
                    )
                ))

                ;; Advance to next character, stop at the end of the file.
                (if (== (inc_cursor) -1)
                    (ร BREAK)
                )
            )
        ))

        (COPY_pos (. @curwin w_cursor), (. oap op_start))
        (check_cursor)
        (changed_lines (.. oap op_start lnum), (.. oap op_start col), (+ (.. oap op_end lnum) 1), 0)

        ;; Set "'[" and "']" marks.
        (COPY_pos (. @curbuf b_op_start), (. oap op_start))
        (COPY_pos (. @curbuf b_op_end), (. oap op_end))

        true
    ))

;; Handle the (non-standard vi) tilde operator.  Also for "gu", "gU" and "g?".

(defn- #_void op_tilde [#_oparg_C oap]
    (ยง
        ((ร boolean did_change =) false)

        (if (not (u_save (- (.. oap op_start lnum) 1), (+ (.. oap op_end lnum) 1)))
            (ร RETURN)
        )

        ((ร pos_C pos =) (ยง ยง_pos_C()))
        (COPY_pos pos, (. oap op_start))

        (cond (. oap block_mode)                     ;; Visual block mode
        (ยง
            ((ร FOR) (ร (ยง  ) (ยง pos.lnum <= oap.op_end.lnum) (ยง pos.lnum++))
                ((ร block_def_C bd =) (ยง ยง_block_def_C()))
                (block_prep oap, bd, (. pos lnum), false)
                ((ร pos.col =) (. bd textcol))
                ((ร boolean one_change =) (ยง swapchars(oap.op_type, pos, bd.textlen)))
                ((ร did_change |=) one_change)
            )
            (if did_change
                (changed_lines (.. oap op_start lnum), 0, (+ (.. oap op_end lnum) 1), 0))
        )
        :else                                    ;; not block mode
        (ยง
            (cond (== (. oap motion_type) MLINE)
            (ยง
                ((ร oap.op_start.col =) 0)
                ((ร pos.col =) 0)
                ((ร oap.op_end.col =) (ยง STRLEN(ml_get(oap.op_end.lnum))))
                (if (!= (.. oap op_end col) 0)
                    (ยง --oap.op_end.col)
                )
            )
            (not (. oap inclusive))
            (ยง
                (decp (. oap op_end))
            ))

            (cond (== (. pos lnum) (.. oap op_end lnum))
            (ยง
                ((ร did_change =) (swapchars (. oap op_type), pos, (+ (- (.. oap op_end col) (. pos col)) 1)))
            )
            :else
            (ยง
                (while true
                    ((ร did_change |=) (swapchars (. oap op_type), pos, (if (== (. pos lnum) (.. oap op_end lnum)) (+ (.. oap op_end col) 1) (STRLEN (ml_get_pos pos)))))
                    (if (or (ltoreq (. oap op_end), pos) (== (incp pos) -1))
                        (ร BREAK)
                    )
                )
            ))

            (when did_change
                (changed_lines (.. oap op_start lnum), (.. oap op_start col), (+ (.. oap op_end lnum) 1), 0)
            )
        ))

        (when (and (not did_change) (. oap is_VIsual))
            ;; No change: need to remove the Visual selection.
            (redraw_curbuf_later INVERTED)
        )

        ;; Set '[ and '] marks.

        (COPY_pos (. @curbuf b_op_start), (. oap op_start))
        (COPY_pos (. @curbuf b_op_end), (. oap op_end))

        (when (< @p_report (. oap line_count))
            (if (== (. oap line_count) 1)
                (msg (u8 "1 line changed"))
                (smsg (u8 "%ld lines changed"), (. oap line_count)))
        )
    ))

;; Invoke swapchar() on "length" bytes at position "pos".
;; "pos" is advanced to just after the changed characters.
;; "length" is rounded up to include the whole last multi-byte character.
;; Also works correctly when the number of bytes changes.
;; Returns true if some character was changed.

(defn- #_boolean swapchars [#_int op_type, #_pos_C pos, #_int length]
    (ยง
        ((ร boolean did_change =) false)

        ((ร FOR) (ร (ยง int todo = length) (< 0 todo) (ยง --todo))
            ((ร int len =) (ยง us_ptr2len_cc(ml_get_pos(pos))))

            ;; we're counting bytes, not characters
            (if (< 0 len)
                ((ร todo -=) (- len 1))
            )

            ((ร did_change |=) (swapchar op_type, pos))
            (if (== (incp pos) -1)     ;; at end of file
                (ร BREAK)
            )
        )

        did_change
    ))

;; If op_type == OP_UPPER: make uppercase,
;; if op_type == OP_LOWER: make lowercase,
;; if op_type == OP_ROT13: do rot13 encoding,
;; else swap case of character at 'pos'
;; returns true when something actually changed.

(defn- #_boolean swapchar [#_int op_type, #_pos_C pos]
    (ยง
        ((ร int c =) (gchar_pos pos))

        ;; Only do rot13 encoding for ASCII characters.
        (if (and (<= 0x80 c) (== op_type OP_ROT13))
            ((ร RETURN) false)
        )

        (when (and (== op_type OP_UPPER) (== c 0xdf))
            ((ร pos_C sp =) (ยง ยง_pos_C()))
            (COPY_pos sp, (. @curwin w_cursor))

            ;; Special handling of German sharp s: change to "SS".
            (COPY_pos (. @curwin w_cursor), pos)
            (del_char false)
            (ins_char (byte \S))
            (ins_char (byte \S))
            (COPY_pos (. @curwin w_cursor), sp)
            (incp pos)
        )

        ((ร int nc =) c)
        (cond (utf_islower c)
        (ยง
            (cond (== op_type OP_ROT13)
            (ยง
                ((ร nc =) (ยง rot13(c, (byte \a))))
            )
            (!= op_type OP_LOWER)
            (ยง
                ((ร nc =) (utf_toupper c))
            ))
        )
        (utf_isupper c)
        (ยง
            (cond (== op_type OP_ROT13)
            (ยง
                ((ร nc =) (ยง rot13(c, (byte \A))))
            )
            (!= op_type OP_UPPER)
            (ยง
                ((ร nc =) (utf_tolower c))
            ))
        ))
        (when (!= nc c)
            (cond (or (<= 0x80 c) (<= 0x80 nc))
            (ยง
                ((ร pos_C sp =) (ยง ยง_pos_C()))
                (COPY_pos sp, (. @curwin w_cursor))

                (COPY_pos (. @curwin w_cursor), pos)
                ;; don't use del_char(), it also removes composing chars
                (del_bytes (us_ptr2len (ml_get_cursor)), false, false)
                (ins_char nc)
                (COPY_pos (. @curwin w_cursor), sp)
            )
            :else
            (ยง
                (.be (ml_get_buf @curbuf, (. pos lnum)) (. pos col), nc)
            ))
            ((ร RETURN) true)
        )
        false
    ))

;; op_insert - Insert and append operators for Visual mode.

(defn- #_void op_insert [#_oparg_C oap, #_long count1]
    (ยง
        ((ร int pre_textlen =) 0)

        ;; edit() changes this - record it for OP_APPEND
        ((ร block_def_C bd =) (ยง ยง_block_def_C()))
        ((ร bd.is_MAX =) (ยง (@curwin.w_curswant == MAXCOL)))

        ;; vis block is still marked.  Get rid of it now.
        ((ร @curwin.w_cursor.lnum =) (.. oap op_start lnum))
        (update_screen INVERTED)

        (when (. oap block_mode)
            ;; When 'virtualedit' is used, need to insert the extra spaces before doing block_prep().
            ;; When only "block" is used, virtual edit is already disabled,
            ;; but still need it when calling coladvance_force().
            (when (< 0 (.. @curwin w_cursor coladd))
                ((ร int old_ve_flags =) @ve_flags)

                (reset! ve_flags VE_ALL)
                (if (not (u_save_cursor))
                    (ร RETURN)
                )

                (coladvance_force (if (== (. oap op_type) OP_APPEND) (+ (. oap end_vcol) 1) (getviscol)))
                (if (== (. oap op_type) OP_APPEND)
                    (ยง --@curwin.w_cursor.col)
                )
                (reset! ve_flags old_ve_flags)
            )
            ;; Get the info about the block before entering the text.
            (block_prep oap, bd, (.. oap op_start lnum), true)
            ((ร Bytes firstline =) (ยง ml_get(oap.op_start.lnum).plus(bd.textcol)))
            (if (== (. oap op_type) OP_APPEND)
                ((ร firstline =) (ยง firstline.plus(bd.textlen)))
            )
            ((ร pre_textlen =) (STRLEN firstline))
        )

        (when (== (. oap op_type) OP_APPEND)
            (cond (and (. oap block_mode) (zero? (.. @curwin w_cursor coladd)))
            (ยง
                ;; Move the cursor to the character right of the block.
                ((ร @curwin.w_set_curswant =) true)
                (while (ยง ml_get_cursor().at(0) != NUL && @curwin.w_cursor.col < bd.textcol + bd.textlen)
                    (ยง @curwin.w_cursor.col++)
                )
                (when (and (. bd is_short) (not (. bd is_MAX)))
                    ;; First line was too short, make it longer and adjust the values in "bd".
                    (if (not (u_save_cursor))
                        (ร RETURN)
                    )

                    ((ร FOR) (ร (ยง int i = 0) (ยง i < bd.endspaces) (ยง i++))
                        (ins_char (byte \space))
                    )
                    ((ร bd.textlen +=) (. bd endspaces))
                )
            )
            :else
            (ยง
                (COPY_pos (. @curwin w_cursor), (. oap op_end))
                (check_cursor_col)

                ;; Works just like an 'i'nsert on the next character.
                (if (and (not (lineempty (.. @curwin w_cursor lnum))) (!= (. oap start_vcol) (. oap end_vcol)))
                    (inc_cursor))
            ))
        )

        ((ร pos_C t1 =) (ยง ยง_pos_C()))
        (COPY_pos t1, (. oap op_start))

        (edit NUL, false, count1)

        ;; When a tab was inserted, and the characters in front of the tab
        ;; have been converted to a tab as well, the column of the cursor
        ;; might have actually been reduced, so need to adjust here.
        (if (and (== (. t1 lnum) (.. @curbuf b_op_start_orig lnum)) (ltpos (. @curbuf b_op_start_orig), t1))
            (COPY_pos (. oap op_start), (. @curbuf b_op_start_orig)))

        ;; If user has moved off this line, we don't know what to do, so do nothing.
        ;; Also don't repeat the insert when Insert mode ended with CTRL-C.
        (if (or (!= (.. @curwin w_cursor lnum) (.. oap op_start lnum)) @got_int)
            (ร RETURN)
        )

        (when (. oap block_mode)
            ((ร block_def_C bd2 =) (ยง ยง_block_def_C()))

            ;; The user may have moved the cursor before inserting something,
            ;; try to adjust the block for that.
            (when (and (== (.. oap op_start lnum) (.. @curbuf b_op_start_orig lnum)) (not (. bd is_MAX)))
                (cond (and (== (. oap op_type) OP_INSERT) (ยง oap.op_start.col + oap.op_start.coladd != @curbuf.b_op_start_orig.col + @curbuf.b_op_start_orig.coladd))
                (ยง
                    ((ร int t =) (ยง getviscol2(@curbuf.b_op_start_orig.col, @curbuf.b_op_start_orig.coladd)))
                    ((ร oap.op_start.col =) (.. @curbuf b_op_start_orig col))
                    ((ร pre_textlen -=) (ยง t - oap.start_vcol))
                    ((ร oap.start_vcol =) t)
                )
                (and (== (. oap op_type) OP_APPEND) (ยง @curbuf.b_op_start_orig.col + @curbuf.b_op_start_orig.coladd <= oap.op_end.col + oap.op_end.coladd))
                (ยง
                    ((ร int t =) (ยง getviscol2(@curbuf.b_op_start_orig.col, @curbuf.b_op_start_orig.coladd)))
                    ((ร oap.op_start.col =) (.. @curbuf b_op_start_orig col))
                    ;; reset pre_textlen to the value of OP_INSERT
                    ((ร pre_textlen +=) (. bd textlen))
                    ((ร pre_textlen -=) (ยง t - oap.start_vcol))
                    ((ร oap.start_vcol =) t)
                    ((ร oap.op_type =) OP_INSERT)
                ))
            )

            ;; Spaces and tabs in the indent may have changed to other spaces and tabs.
            ;; Get the starting column again and correct the length.
            ;; Don't do this when "$" used, end-of-line will have changed.

            (block_prep oap, bd2, (.. oap op_start lnum), true)
            (when (or (not (. bd is_MAX)) (< (. bd2 textlen) (. bd textlen)))
                (when (== (. oap op_type) OP_APPEND)
                    ((ร pre_textlen +=) (ยง bd2.textlen - bd.textlen))
                    (if (!= (. bd2 endspaces) 0)
                        (ยง --bd2.textlen)
                    )
                )
                ((ร bd.textcol =) (. bd2 textcol))
                ((ร bd.textlen =) (. bd2 textlen))
            )

            ;; Subsequent calls to ml_get() flush the firstline data
            ;; - take a copy of the required string.

            ((ร Bytes firstline =) (ยง ml_get(oap.op_start.lnum).plus(bd.textcol)))
            (if (== (. oap op_type) OP_APPEND)
                ((ร firstline =) (ยง firstline.plus(bd.textlen)))
            )

            (ร int ins_len)
            (when (and (<= 0 pre_textlen) (< 0 (ยง (ins_len = STRLEN(firstline) - pre_textlen))))
                ((ร Bytes ins_text =) (STRNDUP firstline, ins_len))

                ;; block handled here
                (if (u_save (.. oap op_start lnum), (+ (.. oap op_end lnum) 1))
                    (block_insert oap, ins_text, (== (. oap op_type) OP_INSERT), bd))

                ((ร @curwin.w_cursor.col =) (.. oap op_start col))
                (check_cursor)
            )
        )
    ))

;; op_change - handle a change operation
;;
;; return true if edit() returns because of a CTRL-O command

(defn- #_boolean op_change [#_oparg_C oap]
    (ยง
        ((ร int pre_textlen =) 0)
        ((ร int pre_indent =) 0)

        ((ร int l =) (.. oap op_start col))
        (when (== (. oap motion_type) MLINE)
            ((ร l =) 0)
            (if (and (not @p_paste) @(. @curbuf b_p_si))
                (reset! can_si true))      ;; It's like opening a new line, do si
        )

        ;; First delete the text in the region.  In an empty buffer only need to save for undo.
        (cond (non-zero? (& (.. @curbuf b_ml ml_flags) ML_EMPTY))
        (ยง
            (if (not (u_save_cursor))
                ((ร RETURN) false)
            )
        )
        (not (op_delete oap))
        (ยง
            ((ร RETURN) false)
        ))

        (if (and (< (.. @curwin w_cursor col) l) (not (lineempty (.. @curwin w_cursor lnum))) (== @virtual_op FALSE))
            (inc_cursor))

        ((ร block_def_C bd =) (ยง ยง_block_def_C()))
        ;; check for still on same line (<CR> in inserted text meaningless); skip blank lines too
        (when (. oap block_mode)
            ;; Add spaces before getting the current line length.
            (if (and (!= @virtual_op FALSE) (or (< 0 (.. @curwin w_cursor coladd)) (== (gchar_cursor) NUL)))
                (coladvance_force (getviscol)))
            ((ร Bytes firstline =) (ยง ml_get(oap.op_start.lnum)))
            ((ร pre_textlen =) (STRLEN firstline))
            ((ร pre_indent =) (ยง BDIFF(skipwhite(firstline), firstline)))
            ((ร bd.textcol =) (.. @curwin w_cursor col))
        )

        ((ร boolean retval =) (edit NUL, false, 1))

        ;; In Visual block mode, handle copying the new text to all lines of the block.
        ;; Don't repeat the insert when Insert mode ended with CTRL-C.

        (when (and (. oap block_mode) (!= (.. oap op_start lnum) (.. oap op_end lnum)) (not @got_int))
            ;; Auto-indenting may have changed the indent.  If the cursor was past
            ;; the indent, exclude that indent change from the inserted text.
            ((ร Bytes firstline =) (ยง ml_get(oap.op_start.lnum)))
            (when (< pre_indent (. bd textcol))
                ((ร int new_indent =) (ยง BDIFF(skipwhite(firstline), firstline)))

                ((ร pre_textlen +=) (- new_indent pre_indent))
                ((ร bd.textcol +=) (- new_indent pre_indent))
            )

            ((ร int ins_len =) (ยง STRLEN(firstline) - pre_textlen))
            (when (< 0 ins_len)
                ;; Subsequent calls to ml_get() flush the "firstline" data
                ;; -- take a copy of the inserted text.
                ((ร Bytes ins_text =) (ยง STRNDUP(firstline.plus(bd.textcol), ins_len)))

                ((ร FOR) (ร (ยง long linenr = oap.op_start.lnum + 1) (ยง linenr <= oap.op_end.lnum) (ยง linenr++))
                    (block_prep oap, bd, linenr, true)
                    (when (or (not (. bd is_short)) (!= @virtual_op FALSE))
                        ((ร pos_C vpos =) (ยง ยง_pos_C()))

                        ;; If the block starts in virtual space, count the
                        ;; initial coladd offset as part of "startspaces".
                        (cond (. bd is_short)
                        (ยง
                            ((ร vpos.lnum =) linenr)
                            (getvpos vpos, (. oap start_vcol))
                        )
                        :else
                        (ยง
                            ((ร vpos.coladd =) 0)
                        ))
                        ((ร Bytes oldp =) (ml_get linenr))
                        ((ร Bytes newp =) (ยง new Bytes(STRLEN(oldp) + vpos.coladd + ins_len + 1)))

                        ;; copy up to block start
                        (BCOPY newp, oldp, (. bd textcol))
                        ((ร int offset =) (. bd textcol))
                        (copy_spaces (.plus newp offset), (. vpos coladd))
                        ((ร offset +=) (. vpos coladd))
                        (BCOPY newp, offset, ins_text, 0, ins_len)
                        ((ร offset +=) ins_len)
                        ((ร oldp =) (ยง oldp.plus(bd.textcol)))
                        (BCOPY newp, offset, oldp, 0, (+ (STRLEN oldp) 1))
                        (ml_replace linenr, newp)
                    )
                )
                (check_cursor)

                (changed_lines (+ (.. oap op_start lnum) 1), 0, (+ (.. oap op_end lnum) 1), 0)
            )
        )

        retval
    ))

;; set all the yank registers to empty (called from main())

(defn- #_void init_yank []
    (ยง
        ((ร FOR) (ร (ยง int i = 0) (< i NUM_REGISTERS) (ยง i++))
            ((ร y_regs[i].y_array =) null)
        )
    ))

;; Yank the text between "oap.op_start" and "oap.op_end" into a yank register.
;; If we are to append (uppercase register), we first yank into a new yank
;; register and then concatenate the old and the new one (so we keep the old
;; one in case of out-of-memory).
;;
;; Return false for failure, true otherwise.

(defn- #_boolean op_yank [#_oparg_C oap, #_boolean deleting, #_boolean mess]
    (ยง
        ((ร byte yanktype =) (. oap motion_type))
        ((ร int yanklines =) (ยง (int)oap.line_count))
        ((ร long yankendlnum =) (.. oap op_end lnum))

                                                        ;; check for read-only register
        (when (and (!= (. oap regname) 0) (not (valid_yank_reg (. oap regname), true)))
            (beep_flush)
            ((ร RETURN) false)
        )
        (if (== (. oap regname) (byte \_))                         ;; black hole: nothing to do
            ((ร RETURN) true)
        )

        (cond (== (. oap regname) (byte \*))
        (ยง
            ((ร oap.regname =) 0)
        )
        (== (. oap regname) (byte \+))
        (ยง
            ((ร oap.regname =) 0)
        ))

        (if (not deleting)                                  ;; op_delete() already set y_current
            (get_yank_register (. oap regname), true))

        ((ร yankreg_C curr =) @y_current)                     ;; copy of y_current
        ((ร yankreg_C newreg =) (ยง ยง_yankreg_C()))             ;; new yank register when appending
        (if (and @y_append (!= (. @y_current y_array) null))      ;; append to existing contents
            (reset! y_current newreg)
            ((ร @y_current.y_array =) null)                   ;; free previously yanked lines
        )

        ;; If the cursor was in column 1 before and after the movement,
        ;; and the operator is not inclusive, the yank is always linewise.

        (when (and (== (. oap motion_type) MCHAR) (zero? (.. oap op_start col)) (not (. oap inclusive)) (or (not (. oap is_VIsual)) (== (.at @p_sel 0) (byte \o))) (not (. oap block_mode)) (zero? (.. oap op_end col)) (< 1 yanklines))
            ((ร yanktype =) MLINE)
            (ยง --yankendlnum)
            (ยง --yanklines)
        )

        ((ร @y_current.y_size =) yanklines)
        ((ร @y_current.y_type =) yanktype)                    ;; set the yank register type
        ((ร @y_current.y_width =) 0)
        ((ร @y_current.y_array =) (ยง new Bytes[yanklines]))

        ((ร int y_idx =) 0)                                 ;; index in y_array[]
        ((ร long lnum =) (.. oap op_start lnum))                  ;; current line number

        (when (. oap block_mode)
            ;; Visual block mode.
            ((ร @y_current.y_type =) MBLOCK)                  ;; set the yank register type
            ((ร @y_current.y_width =) (ยง oap.end_vcol - oap.start_vcol))

            (if (and (== (. @curwin w_curswant) MAXCOL) (< 0 (. @y_current y_width)))
                (ยง @y_current.y_width--)
            )
        )

        ((ร block_def_C bd =) (ยง ยง_block_def_C()))

        ((ร FOR) (ร (ยง  ) (<= lnum yankendlnum) (ยง lnum++, y_idx++))
            ((ร SWITCH) (. @y_current y_type)
                ((ร CASE) MBLOCK)
                (ยง
                    (block_prep oap, bd, lnum, false)
                    (yank_copy_line bd, y_idx)
                    (ร BREAK)
                )

                ((ร CASE) MLINE)
                (ยง
                    (ยง @y_current.y_array[y_idx] = STRDUP(ml_get(lnum)))
                    (ร BREAK)
                )

                ((ร CASE) MCHAR)
                (ยง
                    ((ร int startcol =) (ยง 0, endcol = MAXCOL))
                    ((ร boolean is_oneChar =) false)
                    ((ร Bytes p =) (ml_get lnum))
                    ((ร bd.startspaces =) 0)
                    ((ร bd.endspaces =) 0)

                    (when (== lnum (.. oap op_start lnum))
                        ((ร startcol =) (.. oap op_start col))
                        (when (!= @virtual_op FALSE)
                            ((ร int[] cs =) (ยง new int[1]))
                            ((ร int[] ce =) (ยง new int[1]))
                            (getvcol @curwin, (. oap op_start), cs, null, ce)
                            (when (and (!= (ยง ce[0]) (ยง cs[0])) (< 0 (.. oap op_start coladd)))
                                ;; Part of a tab selected -- but don't double-count it.
                                ((ร bd.startspaces =) (ยง (ce[0] - cs[0] + 1) - oap.op_start.coladd))
                                (ยง startcol++)
                            )
                        )
                    )

                    (when (== lnum (.. oap op_end lnum))
                        ((ร endcol =) (.. oap op_end col))
                        (when (!= @virtual_op FALSE)
                            ((ร int[] cs =) (ยง new int[1]))
                            ((ร int[] ce =) (ยง new int[1]))
                            (getvcol @curwin, (. oap op_end), cs, null, ce)
                            ;; Don't add space for double-wide char; endcol will be on last byte of multi-byte char.
                            (when (or (eos? p endcol) (and (ยง cs[0] + oap.op_end.coladd < ce[0]) (zero? (ยง us_head_off(p, p.plus(endcol))))))
                                (cond (and (== (.. oap op_start lnum) (.. oap op_end lnum)) (== (.. oap op_start col) (.. oap op_end col)))
                                (ยง
                                    ;; Special case: inside a single char.
                                    ((ร is_oneChar =) true)
                                    ((ร bd.startspaces =) (+ (- (.. oap op_end coladd) (.. oap op_start coladd)) (if (. oap inclusive) 1 0)))
                                    ((ร endcol =) startcol)
                                )
                                :else
                                (ยง
                                    ((ร bd.endspaces =) (+ (.. oap op_end coladd) (if (. oap inclusive) 1 0)))
                                    ((ร endcol -=) (if (. oap inclusive) 1 0))
                                ))
                            )
                        )
                    )
                    (if (== endcol MAXCOL)
                        ((ร endcol =) (STRLEN p))
                    )
                    (if (or (< endcol startcol) is_oneChar)
                        ((ร bd.textlen =) 0)
                        ((ร bd.textlen =) (+ (- endcol startcol) (if (. oap inclusive) 1 0)))
                    )
                    ((ร bd.textstart =) (ยง p.plus(startcol)))
                    (yank_copy_line bd, y_idx)
                    (ร BREAK)
                )
            )
        )

        (when (!= curr @y_current)      ;; append the new block to the old block
            ((ร Bytes[] new_ptr =) (ยง new Bytes[curr.y_size + @y_current.y_size]))

            (ร int j)
            ((ร FOR) (ร (ยง j = 0) (ยง j < curr.y_size) (ยง j++))
                ((ร new_ptr[j] =) (ยง curr.y_array[j]))
            )
            ((ร curr.y_array =) new_ptr)

            (if (== yanktype MLINE)  ;; MLINE overrides MCHAR and MBLOCK
                ((ร curr.y_type =) MLINE)
            )

            ;; Concatenate the last line of the old block with the first line of the new block,
            ;; unless being Vi compatible.
            (cond (and (== (. curr y_type) MCHAR) (nil? (vim_strbyte @p_cpo, CPO_REGAPPEND)))
            (ยง
                ((ร Bytes p =) (ยง new Bytes(STRLEN(curr.y_array[curr.y_size - 1]) + STRLEN(@y_current.y_array[0]) + 1)))

                (STRCPY p, (ยง curr.y_array[--j]))
                (STRCAT p, (ยง @y_current.y_array[0]))
                ((ร @y_current.y_array[0] =) null)
                ((ร curr.y_array[j++] =) p)
                ((ร y_idx =) 1)
            )
            :else
            (ยง
                ((ร y_idx =) 0)
            ))
            (while (ยง y_idx < @y_current.y_size)
                ((ร curr.y_array[j++] =) (ยง @y_current.y_array[y_idx++]))
            )
            ((ร curr.y_size =) j)
            ((ร @y_current.y_array =) null)
            (reset! y_current curr)
        )

        (if @(.. @curwin w_options wo_rnu)
            (redraw_later SOME_VALID))       ;; cursor moved to start

        (when mess                   ;; Display message about yank?
            (if (and (== yanktype MCHAR) (not (. oap block_mode)) (== yanklines 1))
                ((ร yanklines =) 0)
            )
            ;; Some versions of Vi use ">=" here, some don't...
            (when (< @p_report yanklines)
                ;; redisplay now, so message is not deleted
                (update_topline_redraw)
                (cond (== yanklines 1)
                (ยง
                    (if (. oap block_mode)
                        (msg (u8 "block of 1 line yanked"))
                        (msg (u8 "1 line yanked")))
                )
                (. oap block_mode)
                (ยง
                    (smsg (u8 "block of %ld lines yanked"), yanklines)
                )
                :else
                (ยง
                    (smsg (u8 "%ld lines yanked"), yanklines)
                ))
            )
        )

        ;; Set "'[" and "']" marks.

        (COPY_pos (. @curbuf b_op_start), (. oap op_start))
        (COPY_pos (. @curbuf b_op_end), (. oap op_end))
        (when (and (== yanktype MLINE) (not (. oap block_mode)))
            ((ร @curbuf.b_op_start.col =) 0)
            ((ร @curbuf.b_op_end.col =) MAXCOL)
        )

        true
    ))

(defn- #_void yank_copy_line [#_block_def_C bd, #_int y_idx]
    (ยง
        ((ร Bytes pnew =) (ยง new Bytes(bd.startspaces + bd.endspaces + bd.textlen + 1)))

        ((ร @y_current.y_array[y_idx] =) pnew)
        (copy_spaces pnew, (. bd startspaces))
        ((ร pnew =) (ยง pnew.plus(bd.startspaces)))
        (BCOPY pnew, (. bd textstart), (. bd textlen))
        ((ร pnew =) (ยง pnew.plus(bd.textlen)))
        (copy_spaces pnew, (. bd endspaces))
        ((ร pnew =) (ยง pnew.plus(bd.endspaces)))
        (.be pnew 0, NUL)
    ))

;; Put contents of register "regname" into the text.
;; Caller must check "regname" to be valid!
;; "flags": PUT_FIXINDENT       make indent look nice
;;          PUT_CURSEND         leave cursor after end of new text
;;          PUT_LINE            force linewise put (":put")

(defn- #_void do_put [#_int regname, #_int dir, #_int count, #_int flags]
    ;; dir: BACKWARD for 'P', FORWARD for 'p'
    (ยง
        ((ร int totlen =) 0)
        ((ร int y_width =) 0)
        ((ร int incr =) 0)
        ((ร long nr_lines =) 0)
        ((ร int orig_indent =) 0)
        ((ร int indent_diff =) 0)
        ((ร boolean first_indent =) true)
        ((ร int lendiff =) 0)

        ;; Adjust register name for "unnamed" in 'clipboard'.
        ((ร regname =) (adjust_clip_reg regname))
        (may_get_selection regname)

        (if (non-zero? (& flags PUT_FIXINDENT))
            ((ร orig_indent =) (get_indent))
        )

        (COPY_pos (. @curbuf b_op_start), (. @curwin w_cursor))   ;; default for '[ mark
        (COPY_pos (. @curbuf b_op_end), (. @curwin w_cursor))     ;; default for '] mark

        ;; Using inserted text works differently, because the register includes
        ;; special characters (newlines, etc.).

        (when (== regname (byte \.))
            (stuff_inserted (if (== dir FORWARD) (if (== count -1) (byte \o) (byte \a)) (if (== count -1) (byte \O) (byte \i))), count, false)
            ;; Putting the text is done later, so can't really move the cursor
            ;; to the next character.  Use "l" to simulate it.
            (if (and (non-zero? (& flags PUT_CURSEND)) (!= (gchar_cursor) NUL))
                (stuffcharReadbuff (byte \l)))
            (ร RETURN)
        )

        ;; For special registers '%' (file name), '#' (alternate file name) and
        ;; ':' (last command line), etc. we have to create a fake yank register.

; %%    ((ร Bytes[] insert_string =) (ยง { null }))
; %%    ((ร boolean[] allocated =) (ยง { false }))
        (when (get_spec_reg regname, insert_string, allocated, true)
            (if (nil? (ยง insert_string[0]))
                (ร RETURN)
            )
        )

        ;; Autocommands may be executed when saving lines for undo,
        ;; which may make "y_array" invalid.  Start undo now to avoid that.
        (u_save (.. @curwin w_cursor lnum), (+ (.. @curwin w_cursor lnum) 1))

        (ร int y_type)
        (ร int y_size)
        ((ร Bytes[] y_array =) null)

        (cond (!= (ยง insert_string[0]) null)
        (ยง
            ((ร y_type =) MCHAR)
            (cond (== regname (byte \=))
            (ยง
                ;; For the = register we need to split the string at NL characters.
                ;; Loop twice: count the number of lines and save them.
                (while true
                    ((ร y_size =) 0)
                    ((ร FOR) (ร (ยง Bytes p = insert_string[0]) (!= p null) nil)
                        (if (non-nil? y_array)
                            ((ร y_array[y_size] =) p)
                        )
                        (ยง y_size++)
                        ((ร p =) (ยง vim_strchr(p, (byte \newline))))
                        (when (non-nil? p)
                            (if (non-nil? y_array)
                                (.be p 0, NUL)
                            )
                            ((ร p =) (ยง p.plus(1)))
                            ;; A trailing '\n' makes the register linewise.
                            (when (eos? p)
                                ((ร y_type =) MLINE)
                                (ร BREAK)
                            )
                        )
                    )
                    (if (non-nil? y_array)
                        (ร BREAK)
                    )
                    ((ร y_array =) (ยง new Bytes[y_size]))
                )
            )
            :else
            (ยง
                ((ร y_size =) 1)         ;; use fake one-line yank register
; %%            ((ร y_array =) (ยง new Bytes[] { insert_string[0] }))
            ))
        )
        :else
        (ยง
            (get_yank_register regname, false)

            ((ร y_type =) (. @y_current y_type))
            ((ร y_width =) (. @y_current y_width))
            ((ร y_size =) (. @y_current y_size))
            ((ร y_array =) (. @y_current y_array))
        ))

;       theend:
;       {
            (when (== y_type MLINE)
                (when (non-zero? (& flags PUT_LINE_SPLIT))
                    ;; "p" or "P" in Visual mode: split the lines to put the text in between.
                    (if (not (u_save_cursor))
                        (ร BREAK theend)
                    )

                    ((ร Bytes p =) (ยง STRDUP(ml_get_cursor())))
                    (ml_append (.. @curwin w_cursor lnum), p)
                    ((ร p =) (ยง STRNDUP(ml_get_curline(), @curwin.w_cursor.col)))
                    (ml_replace (.. @curwin w_cursor lnum), p)
                    (ยง nr_lines++)
                    ((ร dir =) FORWARD)
                )
                (when (non-zero? (& flags PUT_LINE_FORWARD))
                    ;; Must be "p" for a Visual block, put lines below the block.
                    (COPY_pos (. @curwin w_cursor), (.. @curbuf b_visual vi_end))
                    ((ร dir =) FORWARD)
                )
                (COPY_pos (. @curbuf b_op_start), (. @curwin w_cursor))   ;; default for '[ mark
                (COPY_pos (. @curbuf b_op_end), (. @curwin w_cursor))     ;; default for '] mark
            )

            (if (non-zero? (& flags PUT_LINE))        ;; :put command or "p" in Visual line mode.
                ((ร y_type =) MLINE)
            )

            (when (or (zero? y_size) (nil? y_array))
                (emsg2 (u8 "E353: Nothing in register %s"), (if (zero? regname) (u8 "\"") (transchar regname)))
                (ร BREAK theend)
            )

            (ร long lnum)
            (cond (== y_type MBLOCK)
            (ยง
                ((ร lnum =) (ยง @curwin.w_cursor.lnum + y_size + 1))
                (if (> lnum (.. @curbuf b_ml ml_line_count))
                    ((ร lnum =) (ยง @curbuf.b_ml.ml_line_count + 1))
                )
                (if (not (u_save (- (.. @curwin w_cursor lnum) 1), lnum))
                    (ร BREAK theend)
                )
            )
            (== y_type MLINE)
            (ยง
                ((ร lnum =) (.. @curwin w_cursor lnum))
                (if (== dir FORWARD)
                    (ยง lnum++)
                )
                ;; In an empty buffer the empty line is going to be replaced,
                ;; include it in the saved lines.
                (if (not (if (bufempty) (u_save 0, 2) (u_save (- lnum 1), lnum)))
                    (ร BREAK theend)
                )
            )
            (not (u_save_cursor))
            (ยง
                (ร BREAK theend)
            ))

            ((ร int yanklen =) (ยง STRLEN(y_array[0])))

            (when (and (== @ve_flags VE_ALL) (== y_type MCHAR))
                (cond (== (gchar_cursor) TAB)
                (ยง
                    ;; Don't need to insert spaces when "p" on the last position
                    ;; of a tab or "P" on the first position.
                    (cond (if (== dir FORWARD) (< (.. @curwin w_cursor coladd) (- @(. @curbuf b_p_ts) 1)) (< 0 (.. @curwin w_cursor coladd)))
                    (ยง
                        (coladvance_force (getviscol))
                    )
                    :else
                    (ยง
                        ((ร @curwin.w_cursor.coladd =) 0)
                    ))
                )
                (or (< 0 (.. @curwin w_cursor coladd)) (== (gchar_cursor) NUL))
                (ยง
                    (coladvance_force (+ (getviscol) (if (== dir FORWARD) 1 0)))
                ))
            )

            ((ร lnum =) (.. @curwin w_cursor lnum))
; %%        ((ร int[] col =) (ยง { @curwin.w_cursor.col }))

            ;; Block mode

            (cond (== y_type MBLOCK)
            (ยง
                ((ร block_def_C bd =) (ยง ยง_block_def_C()))
                ((ร int c =) (gchar_cursor))
; %%            ((ร int[] endcol2 =) (ยง { 0 }))

                (cond (and (== dir FORWARD) (!= c NUL))
                (ยง
                    (if (== @ve_flags VE_ALL)
                        (getvcol @curwin, (. @curwin w_cursor), col, null, endcol2)
                        (getvcol @curwin, (. @curwin w_cursor), null, null, col))

                    ;; move to start of next multi-byte character
                    ((ร @curwin.w_cursor.col +=) (ยง us_ptr2len_cc(ml_get_cursor())))

                    (ยง col[0]++)
                )
                :else
                (ยง
                    (getvcol @curwin, (. @curwin w_cursor), col, null, endcol2)
                ))

                ((ร col[0] +=) (.. @curwin w_cursor coladd))
                (when (and (== @ve_flags VE_ALL) (or (< 0 (.. @curwin w_cursor coladd)) (== (ยง endcol2[0]) (.. @curwin w_cursor col))))
                    (if (and (== dir FORWARD) (== c NUL))
                        (ยง col[0]++)
                    )
                    (if (and (!= dir FORWARD) (!= c NUL))
                        (ยง @curwin.w_cursor.col++)
                    )
                    (when (== c TAB)
                        (if (and (== dir BACKWARD) (< 0 (.. @curwin w_cursor col)))
                            (ยง @curwin.w_cursor.col--)
                        )
                        (if (and (== dir FORWARD) (ยง col[0] - 1 == endcol2[0]))
                            (ยง @curwin.w_cursor.col++)
                        )
                    )
                )
                ((ร @curwin.w_cursor.coladd =) 0)
                ((ร bd.textcol =) 0)
                ((ร FOR) (ร (ยง int i = 0) (< i y_size) (ยง i++))
                    ((ร bd.startspaces =) 0)
                    ((ร bd.endspaces =) 0)
                    ((ร int vcol =) 0)
                    ((ร int delcount =) 0)

                    ;; add a new line
                    (when (< (.. @curbuf b_ml ml_line_count) (.. @curwin w_cursor lnum))
                        (if (not (ml_append (.. @curbuf b_ml ml_line_count), (u8 "")))
                            (ร BREAK)
                        )
                        (ยง nr_lines++)
                    )
                    ;; get the old line and advance to the position to insert at
                    ((ร Bytes oldp =) (ml_get_curline))
                    ((ร int oldlen =) (STRLEN oldp))
                    ((ร Bytes[] pp =) (ยง new Bytes[1]))
                    ((ร FOR) (ร (ยง pp[0] = oldp) (ยง vcol < col[0] && pp[0].at(0) != NUL) nil)
                        ;; Count a tab for what it's worth (if list mode not on).
                        ((ร incr =) (lbr_chartabsize_adv oldp, pp, vcol))
                        ((ร vcol +=) incr)
                    )
                    ((ร bd.textcol =) (ยง BDIFF(pp[0], oldp)))

                    ((ร boolean shortline =) (ยง (vcol < col[0]) || (vcol == col[0] && pp[0].at(0) == NUL)))

                    (cond (< vcol (ยง col[0])) ;; line too short, padd with spaces
                    (ยง
                        ((ร bd.startspaces =) (ยง col[0] - vcol))
                    )
                    (< (ยง col[0]) vcol)
                    (ยง
                        ((ร bd.endspaces =) (ยง vcol - col[0]))
                        ((ร bd.startspaces =) (ยง incr - bd.endspaces))
                        (ยง --bd.textcol)
                        ((ร delcount =) 1)
                        ((ร bd.textcol -=) (ยง us_head_off(oldp, oldp.plus(bd.textcol))))
                        (when (!= (.at oldp (. bd textcol)) TAB)
                            ;; Only a Tab can be split into spaces.
                            ;; Other characters will have to be moved to after the block,
                            ;; causing misalignment.
                            ((ร delcount =) 0)
                            ((ร bd.endspaces =) 0)
                        )
                    ))

                    ((ร yanklen =) (ยง STRLEN(y_array[i])))

                    ;; calculate number of spaces required to fill right side of block
                    ((ร int spaces =) (+ y_width 1))
                    ((ร FOR) (ร (ยง int j = 0) (< j yanklen) (ยง j++))
                        ((ร spaces -=) (ยง lbr_chartabsize(null, y_array[i].plus(j), 0)))
                    )
                    (if (< spaces 0)
                        ((ร spaces =) 0)
                    )

                    ;; insert the new text
                    ((ร totlen =) (ยง count * (yanklen + spaces) + bd.startspaces + bd.endspaces))
                    ((ร Bytes newp =) (ยง new Bytes(totlen + oldlen + 1)))

                    ;; copy part up to cursor to new line
                    ((ร Bytes p =) newp)
                    (BCOPY p, oldp, (. bd textcol))
                    ((ร p =) (ยง p.plus(bd.textcol)))
                    ;; may insert some spaces before the new text
                    (copy_spaces p, (. bd startspaces))
                    ((ร p =) (ยง p.plus(bd.startspaces)))
                    ;; insert the new text
                    ((ร FOR) (ร (ยง int j = 0) (< j count) (ยง j++))
                        (BCOPY p, (ยง y_array[i]), yanklen)
                        ((ร p =) (ยง p.plus(yanklen)))

                        ;; insert block's trailing spaces only if there's text behind
                        (when (and (or (< j (- count 1)) (not shortline)) (non-zero? spaces))
                            (copy_spaces p, spaces)
                            ((ร p =) (ยง p.plus(spaces)))
                        )
                    )
                    ;; may insert some spaces after the new text
                    (copy_spaces p, (. bd endspaces))
                    ((ร p =) (ยง p.plus(bd.endspaces)))
                    ;; move the text after the cursor to the end of the line.
                    (BCOPY p, 0, oldp, (+ (. bd textcol) delcount), (ยง oldlen - bd.textcol - delcount + 1))
                    (ml_replace (.. @curwin w_cursor lnum), newp)

                    (ยง @curwin.w_cursor.lnum++)
                    (if (zero? i)
                        ((ร @curwin.w_cursor.col +=) (. bd startspaces))
                    )
                )

                (changed_lines lnum, 0, (.. @curwin w_cursor lnum), nr_lines)

                ;; Set '[ mark.
                (COPY_pos (. @curbuf b_op_start), (. @curwin w_cursor))
                ((ร @curbuf.b_op_start.lnum =) lnum)

                ;; Adjust '] mark.
                ((ร @curbuf.b_op_end.lnum =) (ยง @curwin.w_cursor.lnum - 1))
                ((ร @curbuf.b_op_end.col =) (ยง bd.textcol + totlen - 1))
                ((ร @curbuf.b_op_end.coladd =) 0)
                (cond (non-zero? (& flags PUT_CURSEND))
                (ยง
                    (COPY_pos (. @curwin w_cursor), (. @curbuf b_op_end))
                    (ยง @curwin.w_cursor.col++)

                    ;; in Insert mode we might be after the NUL, correct for that
                    ((ร int len =) (ยง STRLEN(ml_get_curline())))
                    (if (> (.. @curwin w_cursor col) len)
                        ((ร @curwin.w_cursor.col =) len)
                    )
                )
                :else
                (ยง
                    ((ร @curwin.w_cursor.lnum =) lnum)
                ))
            )
            :else
            (ยง
                ;; Character or Line mode

                (cond (== y_type MCHAR)
                (ยง
                    ;; if type is MCHAR, FORWARD is the same as BACKWARD on the next char
                    (when (and (== dir FORWARD) (!= (gchar_cursor) NUL))
                        ((ร int bytelen =) (ยง us_ptr2len_cc(ml_get_cursor())))

                        ;; put it on the next of the multi-byte character.
                        ((ร col[0] +=) bytelen)
                        (when (non-zero? yanklen)
                            ((ร @curwin.w_cursor.col +=) bytelen)
                            ((ร @curbuf.b_op_end.col +=) bytelen)
                        )
                    )
                    (COPY_pos (. @curbuf b_op_start), (. @curwin w_cursor))
                )

                ;; Line mode: BACKWARD is the same as FORWARD on the previous line

                (== dir BACKWARD)
                (ยง
                    (ยง --lnum)
                ))

                ((ร pos_C new_cursor =) (ยง ยง_pos_C()))
                (COPY_pos new_cursor, (. @curwin w_cursor))

                ;; simple case: insert into current line

                (cond (and (== y_type MCHAR) (== y_size 1))
                (ยง
;                   do
;                   {
                        ((ร totlen =) (* count yanklen))
                        (when (< 0 totlen)
                            ((ร Bytes oldp =) (ml_get lnum))
                            ((ร Bytes newp =) (ยง new Bytes(STRLEN(oldp) + totlen + 1)))

                            (BCOPY newp, oldp, (ยง col[0]))
                            ((ร Bytes p =) (ยง newp.plus(col[0])))
                            ((ร FOR) (ร (ยง long i = 0) (< i count) (ยง i++))
                                (BCOPY p, (ยง y_array[0]), yanklen)
                                ((ร p =) (ยง p.plus(yanklen)))
                            )
                            (BCOPY p, 0, oldp, (ยง col[0]), (ยง (STRLEN(oldp, col[0])) + 1))
                            (ml_replace lnum, newp)
                            ;; Place cursor on last putted char.
                            (when (== lnum (.. @curwin w_cursor lnum))
                                ;; make sure curwin.w_virtcol is updated
                                (changed_cline_bef_curs)
                                ((ร @curwin.w_cursor.col +=) (- totlen 1))
                            )
                        )
                        (if @VIsual_active
                            (ยง lnum++)
                        )
;                   } while (@VIsual_active && lnum <= @curbuf.b_visual.vi_end.lnum);

                    (if @VIsual_active ;; reset lnum to the last visual line
                        (ยง lnum--)
                    )

                    (COPY_pos (. @curbuf b_op_end), (. @curwin w_cursor))
                    ;; For "CTRL-O p" in Insert mode, put cursor after last char.
                    (if (and (non-zero? totlen) (or (non-zero? @restart_edit) (non-zero? (& flags PUT_CURSEND))))
                        (ยง @curwin.w_cursor.col++)
                    )
                    (changed_bytes lnum, (ยง col[0]))
                )
                :else
                (ยง
                    ;; Insert at least one line.  When y_type is MCHAR, break the first line in two.

;                   error:
                    ((ร FOR) (ร (ยง long cnt = 1) (<= cnt count) (ยง cnt++))
                        ((ร int i =) 0)
                        (when (== y_type MCHAR)
                            ;; Split the current line in two at the insert position.
                            ;; First insert y_array[size - 1] in front of second line.
                            ;; Then append y_array[0] to first line.

                            ((ร lnum =) (. new_cursor lnum))
                            ((ร Bytes p =) (ยง ml_get(lnum).plus(col[0])))
                            ((ร totlen =) (ยง STRLEN(y_array[y_size - 1])))
                            ((ร Bytes newp =) (ยง new Bytes(STRLEN(p) + totlen + 1)))
                            (STRCPY newp, (ยง y_array[y_size - 1]))
                            (STRCAT newp, p)
                            ;; insert second line
                            (ml_append lnum, newp)

                            ((ร Bytes oldp =) (ml_get lnum))
                            ((ร newp =) (ยง new Bytes(col[0] + yanklen + 1)))
                            ;; copy first part of line
                            (BCOPY newp, oldp, (ยง col[0]))
                            ;; append to first line
                            (BCOPY newp, (ยง col[0]), (ยง y_array[0]), 0, (+ yanklen 1))
                            (ml_replace lnum, newp)

                            ((ร @curwin.w_cursor.lnum =) lnum)
                            ((ร i =) 1)
                        )

                        ((ร FOR) (ร (ยง  ) (< i y_size) (ยง i++))
                            (if (and (or (!= y_type MCHAR) (< i (- y_size 1))) (not (ml_append lnum, (ยง y_array[i]))))
                                (ร BREAK error)
                            )
                            (ยง lnum++)
                            (ยง nr_lines++)
                            (when (non-zero? (& flags PUT_FIXINDENT))
                                ((ร pos_C old_pos =) (ยง ยง_pos_C()))
                                (COPY_pos old_pos, (. @curwin w_cursor))
                                ((ร @curwin.w_cursor.lnum =) lnum)
                                ((ร Bytes p =) (ml_get lnum))
                                (if (and (== cnt count) (== i (- y_size 1)))
                                    ((ร lendiff =) (STRLEN p))
                                )
                                (ร int indent)
                                (cond (eos? p)
                                (ยง
                                    ((ร indent =) 0)     ;; ignore empty lines
                                )
                                first_indent
                                (ยง
                                    ((ร indent_diff =) (ยง orig_indent - get_indent()))
                                    ((ร indent =) orig_indent)
                                    ((ร first_indent =) false)
                                )
                                (ยง (indent = get_indent() + indent_diff) < 0)
                                (ยง
                                    ((ร indent =) 0)
                                ))
                                (set_indent indent, 0)
                                (COPY_pos (. @curwin w_cursor), old_pos)
                                ;; remember how many chars were removed
                                (if (and (== cnt count) (== i (- y_size 1)))
                                    ((ร lendiff -=) (ยง STRLEN(ml_get(lnum))))
                                )
                            )
                        )
                    )

                    ;; Adjust marks.
                    (when (== y_type MLINE)
                        ((ร @curbuf.b_op_start.col =) 0)
                        (if (== dir FORWARD)
                            (ยง @curbuf.b_op_start.lnum++)
                        )
                    )
                    (mark_adjust (+ (.. @curbuf b_op_start lnum) (if (== y_type MCHAR) 1 0)), MAXLNUM, nr_lines, 0)

                    ;; note changed text for displaying and folding
                    (if (== y_type MCHAR)
                        (changed_lines (.. @curwin w_cursor lnum), (ยง col[0]), (+ (.. @curwin w_cursor lnum) 1), nr_lines)
                        (changed_lines (.. @curbuf b_op_start lnum), 0, (.. @curbuf b_op_start lnum), nr_lines))

                    ;; put '] mark at last inserted character
                    ((ร @curbuf.b_op_end.lnum =) lnum)
                    ;; correct length for change in indent
                    ((ร col[0] =) (ยง STRLEN(y_array[y_size - 1]) - lendiff))
                    (if (< 1 (ยง col[0]))
                        ((ร @curbuf.b_op_end.col =) (ยง col[0] - 1))
                        ((ร @curbuf.b_op_end.col =) 0)
                    )

                    (cond (non-zero? (& flags PUT_CURSLINE))
                    (ยง
                        ;; ":put": put cursor on last inserted line
                        ((ร @curwin.w_cursor.lnum =) lnum)
                        (beginline (| BL_WHITE BL_FIX))
                    )
                    (non-zero? (& flags PUT_CURSEND))
                    (ยง
                        ;; put cursor after inserted text
                        (cond (== y_type MLINE)
                        (ยง
                            (if (<= (.. @curbuf b_ml ml_line_count) lnum)
                                ((ร @curwin.w_cursor.lnum =) (.. @curbuf b_ml ml_line_count))
                                ((ร @curwin.w_cursor.lnum =) (+ lnum 1))
                            )
                            ((ร @curwin.w_cursor.col =) 0)
                        )
                        :else
                        (ยง
                            ((ร @curwin.w_cursor.lnum =) lnum)
                            ((ร @curwin.w_cursor.col =) (ยง col[0]))
                        ))
                    )
                    (== y_type MLINE)
                    (ยง
                        ;; put cursor on first non-blank in first inserted line
                        ((ร @curwin.w_cursor.col =) 0)
                        (if (== dir FORWARD)
                            (ยง @curwin.w_cursor.lnum++)
                        )
                        (beginline (| BL_WHITE BL_FIX))
                    )
                    :else        ;; put cursor on first inserted character
                    (ยง
                        (COPY_pos (. @curwin w_cursor), new_cursor)
                    ))
                ))
            ))

            (msgmore nr_lines)
            ((ร @curwin.w_set_curswant =) true)
;       }

        (reset! VIsual_active false)

        ;; If the cursor is past the end of the line put it at the end.
        (adjust_cursor_eol)
    ))

;; When the cursor is on the NUL past the end of the line
;; and it should not be there, move it left.

(defn- #_void adjust_cursor_eol []
    (ยง
        (when (and (< 0 (.. @curwin w_cursor col)) (== (gchar_cursor) NUL) (zero? (& @ve_flags VE_ONEMORE)) (zero? @restart_edit) (zero? (& @State INSERT)))
            ;; Put the cursor on the last character in the line.
            (dec_cursor)

            (when (== @ve_flags VE_ALL)
                ((ร int[] scol =) (ยง new int[1]))
                ((ร int[] ecol =) (ยง new int[1]))

                ;; Coladd is set to the width of the last character.
                (getvcol @curwin, (. @curwin w_cursor), scol, null, ecol)
                ((ร @curwin.w_cursor.coladd =) (ยง ecol[0] - scol[0] + 1))
            )
        )
    ))

;; Join 'count' lines (minimal 2) at cursor position.
;; When "save_undo" is true save lines for undo first.
;; Set "use_formatoptions" to false when e.g. processing backspace and comment
;; leaders should not be removed.
;; When setmark is true, sets the '[ and '] mark, else, the caller is expected
;; to set those marks.
;;
;; return false for failure, true otherwise

(defn- #_boolean do_join [#_int count, #_boolean insert_space, #_boolean save_undo, #_boolean use_formatoptions, #_boolean setmark]
    (ยง
        ((ร boolean retval =) true)

        ((ร Bytes curr =) null)
        ((ร Bytes curr_start =) null)
        ((ร int endcurr1 =) NUL)
        ((ร int endcurr2 =) NUL)
        ((ร int currsize =) 0)               ;; size of the current line
        ((ร int sumsize =) 0)                ;; size of the long new line
        ((ร int col =) 0)

        (if (and save_undo (not (u_save (- (.. @curwin w_cursor lnum) 1), (+ (.. @curwin w_cursor lnum) count))))
            ((ร RETURN) false)
        )

        ;; Allocate an array to store the number of spaces inserted before each line.
        ;; We will use it to pre-compute the length of the new line and the
        ;; proper placement of each original line in the new one.
        ((ร int[] spaces =) (ยง new int[count]))

        ;; Don't move anything, just compute the final line length
        ;; and setup the array of space strings lengths.

        ((ร FOR) (ร (ยง int t = 0) (< t count) (ยง t++))
            ((ร curr =) (ยง curr_start = ml_get(@curwin.w_cursor.lnum + t)))
            (when (and (zero? t) setmark)
                ;; Set the '[ mark.
                ((ร @curbuf.b_op_start.lnum =) (.. @curwin w_cursor lnum))
                ((ร @curbuf.b_op_start.col =) (STRLEN curr))
            )

            (when (and insert_space (< 0 t))
                ((ร curr =) (skipwhite curr))
                (when (and (!= (.at curr 0) (byte \))) (non-zero? currsize) (!= endcurr1 TAB))
                    ;; don't add a space if the line is ending in a space
                    (if (== endcurr1 (byte \space))
                        ((ร endcurr1 =) endcurr2)
                        (ยง ++spaces[t])
                    )
                    ;; extra space when 'joinspaces' set and line ends in '.'
                    (if (and @p_js (or (== endcurr1 (byte \.)) (and (nil? (vim_strbyte @p_cpo, CPO_JOINSP)) (or (== endcurr1 (byte \?)) (== endcurr1 (byte \!))))))
                        (ยง ++spaces[t])
                    )
                )
            )
            ((ร currsize =) (STRLEN curr))
            ((ร sumsize +=) (ยง currsize + spaces[t]))
            ((ร endcurr1 =) (ยง endcurr2 = NUL))
            (when (and insert_space (< 0 currsize))
                ((ร Bytes cend =) (ยง curr.plus(currsize)))
                ((ร cend =) (ยง cend.minus(us_ptr_back(curr, cend))))
                ((ร endcurr1 =) (us_ptr2char cend))
                (when (BLT curr, cend)
                    ((ร cend =) (ยง cend.minus(us_ptr_back(curr, cend))))
                    ((ร endcurr2 =) (us_ptr2char cend))
                )
            )
            (line_breakcheck)
            (if @got_int
                ((ร RETURN) false)
            )
        )

        ;; store the column position before last line
        ((ร col =) (ยง sumsize - currsize - spaces[count - 1]))

        ;; allocate the space for the new line
        ((ร Bytes newp =) (ยง new Bytes(sumsize + 1)))
        ((ร Bytes cend =) (ยง newp.plus(sumsize)))
        (.be cend 0, NUL)

        ;; Move affected lines to the new long one.
        ;;
        ;; Move marks from each deleted line to the joined line, adjusting the
        ;; column.  This is not Vi compatible, but Vi deletes the marks, thus that
        ;; should not really be a problem.

        ((ร FOR) (ร (ยง int t = count - 1) true (ยง --t))
            ((ร cend =) (ยง cend.minus(currsize)))
            (BCOPY cend, curr, currsize)
            (when (< 0 (ยง spaces[t]))
                ((ร cend =) (ยง cend.minus(spaces[t])))
                (copy_spaces cend, (ยง spaces[t]))
            )
            (mark_col_adjust (+ (.. @curwin w_cursor lnum) t), 0, (long (- t)), (ยง (long)(BDIFF(cend, newp) + spaces[t] - BDIFF(curr, curr_start))))
            (if (zero? t)
                (ร BREAK)
            )
            ((ร curr =) (ยง curr_start = ml_get(@curwin.w_cursor.lnum + t - 1)))
            (if (and insert_space (< 1 t))
                ((ร curr =) (skipwhite curr))
            )
            ((ร currsize =) (STRLEN curr))
        )
        (ml_replace (.. @curwin w_cursor lnum), newp)

        (when setmark
            ;; Set the '] mark.
            ((ร @curbuf.b_op_end.lnum =) (.. @curwin w_cursor lnum))
            ((ร @curbuf.b_op_end.col =) (STRLEN newp))
        )

        ;; Only report the change in the first line here,
        ;; del_lines() will report the deleted line.
        (changed_lines (.. @curwin w_cursor lnum), currsize, (+ (.. @curwin w_cursor lnum) 1), 0)

        ;; Delete following lines.  To do this we move the cursor there
        ;; briefly, and then move it back.  After del_lines() the cursor may
        ;; have moved up (last line deleted), so the current lnum is kept in t.

        ((ร long t =) (.. @curwin w_cursor lnum))
        (ยง @curwin.w_cursor.lnum++)
        (del_lines (- count 1), false)
        ((ร @curwin.w_cursor.lnum =) t)

        ;; Set the cursor column:
        ;; Vi compatible: use the column of the first join
        ;; vim:           use the column of the last join

        ((ร @curwin.w_cursor.col =) (if (non-nil? (vim_strbyte @p_cpo, CPO_JOINCOL)) currsize col))
        (check_cursor_col)

        ((ร @curwin.w_cursor.coladd =) 0)
        ((ร @curwin.w_set_curswant =) true)

        retval
    ))

;; prepare a few things for block mode yank/delete/tilde
;;
;; for delete:
;; - textlen includes the first/last char to be (partly) deleted
;; - start/endspaces is the number of columns that are taken by the
;;   first/last deleted char minus the number of columns that have to be deleted.
;; for yank and tilde:
;; - textlen includes the first/last char to be wholly yanked
;; - start/endspaces is the number of columns of the first/last yanked char
;;   that are to be yanked.

(defn- #_void block_prep [#_oparg_C oap, #_block_def_C bdp, #_long lnum, #_boolean is_del]
    (ยง
        ((ร int incr =) 0)

        ((ร bdp.startspaces =) 0)
        ((ร bdp.endspaces =) 0)
        ((ร bdp.textlen =) 0)
        ((ร bdp.start_vcol =) 0)
        ((ร bdp.end_vcol =) 0)
        ((ร bdp.is_short =) false)
        ((ร bdp.is_oneChar =) false)
        ((ร bdp.pre_whitesp =) 0)
        ((ร bdp.pre_whitesp_c =) 0)
        ((ร bdp.end_char_vcols =) 0)
        ((ร bdp.start_char_vcols =) 0)

        ((ร Bytes line =) (ml_get lnum))

        ((ร Bytes pstart =) line)
        ((ร Bytes prev_pstart =) line)

        (while (ยง bdp.start_vcol < oap.start_vcol && pstart.at(0) != NUL)
            ;; Count a tab for what it's worth (if list mode not on).
            ((ร incr =) (ยง lbr_chartabsize(line, pstart, bdp.start_vcol)))
            ((ร bdp.start_vcol +=) incr)
            (cond (vim_iswhite (ยง pstart.at(0)))
            (ยง
                ((ร bdp.pre_whitesp +=) incr)
                (ยง bdp.pre_whitesp_c++)
            )
            :else
            (ยง
                ((ร bdp.pre_whitesp =) 0)
                ((ร bdp.pre_whitesp_c =) 0)
            ))
            ((ร prev_pstart =) pstart)
            ((ร pstart =) (ยง pstart.plus(us_ptr2len_cc(pstart))))
        )

        ((ร bdp.start_char_vcols =) incr)

        (cond (< (. bdp start_vcol) (. oap start_vcol))        ;; line too short
        (ยง
            ((ร bdp.end_vcol =) (. bdp start_vcol))
            ((ร bdp.is_short =) true)
            (if (or (not is_del) (== (. oap op_type) OP_APPEND))
                ((ร bdp.endspaces =) (ยง oap.end_vcol - oap.start_vcol + 1))
            )
        )
        :else
        (ยง
            ;; notice: this converts partly selected Multibyte characters to spaces, too.
            ((ร bdp.startspaces =) (ยง bdp.start_vcol - oap.start_vcol))
            (if (and is_del (!= (. bdp startspaces) 0))
                ((ร bdp.startspaces =) (ยง bdp.start_char_vcols - bdp.startspaces))
            )
; %%        ((ร Bytes[] pend =) (ยง { pstart }))
            ((ร bdp.end_vcol =) (. bdp start_vcol))
            (cond (< (. oap end_vcol) (. bdp end_vcol))        ;; it's all in one character
            (ยง
                ((ร bdp.is_oneChar =) true)
                (cond (== (. oap op_type) OP_INSERT)
                (ยง
                    ((ร bdp.endspaces =) (ยง bdp.start_char_vcols - bdp.startspaces))
                )
                (== (. oap op_type) OP_APPEND)
                (ยง
                    ((ร bdp.startspaces +=) (ยง oap.end_vcol - oap.start_vcol + 1))
                    ((ร bdp.endspaces =) (ยง bdp.start_char_vcols - bdp.startspaces))
                )
                :else
                (ยง
                    ((ร bdp.startspaces =) (ยง oap.end_vcol - oap.start_vcol + 1))
                    (when (and is_del (!= (. oap op_type) OP_LSHIFT))
                        ;; just putting the sum of those two into
                        ;; bdp.startspaces doesn't work for Visual replace,
                        ;; so we have to split the tab in two
                        ((ร bdp.startspaces =) (ยง bdp.start_char_vcols - (bdp.start_vcol - oap.start_vcol)))
                        ((ร bdp.endspaces =) (ยง bdp.end_vcol - oap.end_vcol - 1))
                    )
                ))
            )
            :else
            (ยง
                ((ร Bytes prev_pend =) (ยง pend[0]))
                (while (ยง bdp.end_vcol <= oap.end_vcol && pend[0].at(0) != NUL)
                    ;; Count a tab for what it's worth (if list mode not on).
                    ((ร prev_pend =) (ยง pend[0]))
                    ((ร incr =) (ยง lbr_chartabsize_adv(line, pend, bdp.end_vcol)))
                    ((ร bdp.end_vcol +=) incr)
                )
                (cond (and (<= (. bdp end_vcol) (. oap end_vcol)) (or (not is_del) (== (. oap op_type) OP_APPEND) (== (. oap op_type) OP_REPLACE))) ;; line too short
                (ยง
                    ((ร bdp.is_short =) true)
                    ;; Alternative: include spaces to fill up the block.
                    ;; Disadvantage: can lead to trailing spaces when
                    ;; the line is short where the text is put.
                    ;; if (!is_del || oap.op_type == OP_APPEND)
                    (if (or (== (. oap op_type) OP_APPEND) (!= @virtual_op FALSE))
                        ((ร bdp.endspaces =) (+ (- (. oap end_vcol) (. bdp end_vcol)) (if (. oap inclusive) 1 0)))
                        ((ร bdp.endspaces =) 0) ;; replace doesn't add characters
                    )
                )
                (< (. oap end_vcol) (. bdp end_vcol))
                (ยง
                    ((ร bdp.endspaces =) (- (. bdp end_vcol) (. oap end_vcol) 1))
                    (when (and (not is_del) (!= (. bdp endspaces) 0))
                        ((ร bdp.endspaces =) (- incr (. bdp endspaces)))
                        (if (BNE (ยง pend[0]), pstart)
                            ((ร pend[0] =) prev_pend)
                        )
                    )
                ))
            ))
            ((ร bdp.end_char_vcols =) incr)
            (if (and is_del (!= (. bdp startspaces) 0))
                ((ร pstart =) prev_pstart)
            )
            ((ร bdp.textlen =) (ยง BDIFF(pend[0], pstart)))
        ))

        ((ร bdp.textcol =) (BDIFF pstart, line))
        ((ร bdp.textstart =) pstart)
    ))

(final int NUMBUFLEN 30)        ;; length of a buffer to store a number in ASCII

(atom! boolean hexupper)                                ;; 0xABC

;; add or subtract 'Prenum1' from a number in a line
;; 'command' is CTRL-A for add, CTRL-X for subtract
;;
;; return false for failure, true otherwise

(defn- #_boolean do_addsub [#_int command, #_long Prenum1]
    (ยง
        ((ร boolean dohex =) (ยง (vim_strchr(@curbuf.@b_p_nf, (byte \x)) != null)))   ;; "heX"
        ((ร boolean dooct =) (ยง (vim_strchr(@curbuf.@b_p_nf, (byte \o)) != null)))   ;; "Octal"
        ((ร boolean doalp =) (ยง (vim_strchr(@curbuf.@b_p_nf, (byte \p)) != null)))   ;; "alPha"

        ((ร Bytes ptr =) (ml_get_curline))

        ;; First check if we are on a hexadecimal number, after the "0x".

        ((ร int col =) (.. @curwin w_cursor col))
        (when dohex
            (while (ยง 0 < col && asc_isxdigit(ptr.at(col)))
                (ยง --col)
            )
        )
        (cond (and dohex (< 0 col) (or (== (.at ptr col) (byte \X)) (== (.at ptr col) (byte \x))) (== (.at ptr (- col 1)) (byte \0)) (asc_isxdigit (.at ptr (+ col 1))))
        (ยง
            ;; Found hexadecimal number, move to its start.

            (ยง --col)
        )
        :else
        (ยง
            ;; Search forward and then backward to find the start of number.

            ((ร col =) (.. @curwin w_cursor col))

            (while (ยง ptr.at(col) != NUL && !asc_isdigit(ptr.at(col)) && !(doalp && asc_isalpha(ptr.at(col))))
                (ยง col++)
            )

            (while (ยง 0 < col && asc_isdigit(ptr.at(col - 1)) && !(doalp && asc_isalpha(ptr.at(col))))
                (ยง --col)
            )
        ))

        ;; If a number was found, and saving for undo works, replace the number.

        ((ร int firstdigit =) (ยง ptr.at(col)))

        (when (or (and (not (asc_isdigit firstdigit)) (not (and doalp (asc_isalpha firstdigit)))) (not (u_save_cursor)))
            (beep_flush)
            ((ร RETURN) false)
        )

        ;; get 'ptr' again, because u_save() may have changed it
        ((ร ptr =) (ml_get_curline))

        (cond (and doalp (asc_isalpha firstdigit))
        (ยง
            ;; decrement or increment alphabetic character
            (cond (== command Ctrl_X)
            (ยง
                (cond (< (alphaOrd firstdigit) Prenum1)
                (ยง
                    (if (asc_isupper firstdigit)
                        ((ร firstdigit =) (byte \A))
                        ((ร firstdigit =) (byte \a))
                    )
                )
                :else
                (ยง
                    ((ร firstdigit -=) Prenum1)
                ))
            )
            :else
            (ยง
                (cond (ยง 26 - alphaOrd(firstdigit) - 1 < Prenum1)
                (ยง
                    (if (asc_isupper firstdigit)
                        ((ร firstdigit =) (byte \Z))
                        ((ร firstdigit =) (byte \z))
                    )
                )
                :else
                (ยง
                    ((ร firstdigit +=) Prenum1)
                ))
            ))
            ((ร @curwin.w_cursor.col =) col)
            (del_char false)
            (ins_char firstdigit)
        )
        :else
        (ยง
            ((ร boolean negative =) false)
            (when (and (< 0 col) (== (.at ptr (- col 1)) (byte \-)))        ;; negative number
                (ยง --col)
                ((ร negative =) true)
            )

            ((ร int[] hex =) (ยง new int[1]))                             ;; 'X' or 'x': hex; '0': octal
; %%        ((ร int[] length =) (ยง { 0 }))                               ;; character length of the number
            ((ร long[] n =) (ยง new long[1]))
            ;; get the number value (unsigned)
            (vim_str2nr (.plus ptr col), hex, length, (if dooct TRUE FALSE), (if dohex TRUE FALSE), n)
            (if (< (ยง n[0]) 0)
                ((ร n[0] =) (ยง -n[0]))
            )

            ;; ignore leading '-' for hex and octal numbers
            (when (and (!= (ยง hex[0]) 0) negative)
                (ยง col++)
                (ยง --length[0])
                ((ร negative =) false)
            )

            ;; add or subtract
            ((ร boolean subtract =) false)
            (if (== command Ctrl_X)
; %%            ((ร subtract ^=) true)
            )
            (if negative
; %%            ((ร subtract ^=) true)
            )

            ((ร long oldn =) (ยง n[0]))
            (if subtract
                ((ร n[0] -=) Prenum1)
                ((ร n[0] +=) Prenum1)
            )

            ((ร final long roof =) 0x7fffffffffffffff)
            ((ร n[0] &=) roof)

            ;; handle wraparound for decimal numbers
            (when (zero? (ยง hex[0]))
                (cond subtract
                (ยง
                    (when (< oldn (ยง n[0]))
; %%                    ((ร n[0] =) (ยง 1 + (n[0] ^ roof)))
; %%                    ((ร negative ^=) true)
                    )
                )
                :else ;; add
                (ยง
                    (when (< (ยง n[0]) oldn)
; %%                    ((ร n[0] =) (ยง (n[0] ^ roof)))
; %%                    ((ร negative ^=) true)
                    )
                ))
                (if (zero? (ยง n[0]))
                    ((ร negative =) false)
                )
            )

            ;; Delete the old number.

            ((ร @curwin.w_cursor.col =) col)
            ((ร int todel =) (ยง length[0]))
            ((ร int c =) (gchar_cursor))

            ;; Don't include the '-' in the length, only the length of the part
            ;; after it is kept the same.

            (if (== c (byte \-))
                (ยง --length[0])
            )
            (while (ยง 0 < todel--)
                (when (and (< c 0x100) (asc_isalpha c))
                    (if (asc_isupper c)
                        (reset! hexupper true)
                        (reset! hexupper false))
                )
                ;; del_char() will mark line needing displaying
                (del_char false)
                ((ร c =) (gchar_cursor))
            )

            ;; Prepare the leading characters in buf1[].
            ;; When there are many leading zeros it could be very long.
            ;; Allocate a bit too much.

            ((ร Bytes buf1 =) (ยง new Bytes(length[0] + NUMBUFLEN)))

            ((ร ptr =) buf1)
            (when negative
                (ยง (ptr = ptr.plus(1)).be(-1, (byte \-)))
            )
            (when (!= (ยง hex[0]) 0)
                (ยง (ptr = ptr.plus(1)).be(-1, (byte \0)))
                (ยง --length[0])
            )
            (when (or (== (ยง hex[0]) (byte \x)) (== (ยง hex[0]) (byte \X)))
                (ยง (ptr = ptr.plus(1)).be(-1, hex[0]))
                (ยง --length[0])
            )

            ;; Put the number characters in buf2[].

            ((ร Bytes buf2 =) (ยง new Bytes(NUMBUFLEN)))
            (cond (zero? (ยง hex[0]))
            (ยง
                (ยง libC.sprintf(buf2, (u8 "%ld"), n[0]))
            )
            (== (ยง hex[0]) (byte \0))
            (ยง
                (ยง libC.sprintf(buf2, (u8 "%lo"), n[0]))
            )
            (and (!= (ยง hex[0]) 0) @hexupper)
            (ยง
                (ยง libC.sprintf(buf2, (u8 "%lX"), n[0]))
            )
            :else
            (ยง
                (ยง libC.sprintf(buf2, (u8 "%lx"), n[0]))
            ))
            ((ร length[0] -=) (STRLEN buf2))

            ;; Adjust number of zeros to the new number of digits,
            ;; so the total length of the number remains the same.
            ;; Don't do this when the result may look like an octal number.

            (when (and (== firstdigit (byte \0)) (not (and dooct (zero? (ยง hex[0])))))
                (while (ยง 0 < length[0]--)
                    (ยง (ptr = ptr.plus(1)).be(-1, (byte \0)))
                )
            )
            (.be ptr 0, NUL)
            (STRCAT buf1, buf2)
            (ins_str buf1)          ;; insert the new number
        ))

        (ยง --@curwin.w_cursor.col)
        ((ร @curwin.w_set_curswant =) true)
        ((ร ptr =) (ยง ml_get_buf(@curbuf, @curwin.w_cursor.lnum)))

        true
    ))

;; Count the number of bytes, characters and "words" in a line.
;;
;; "Words" are counted by looking for boundaries between non-space and
;; space characters.  (it seems to produce results that match 'wc'.)
;;
;; Return value is byte count; word count for the line is added to "*wc".
;; Char count is added to "*cc".
;;
;; The function will only examine the first "limit" characters in the
;; line, stopping if it encounters an end-of-line (NUL byte).  In that
;; case, eol_size will be added to the character count to account for
;; the size of the EOL character.

(defn- #_int line_count_info [#_Bytes line, #_int* wc, #_int* cc, #_int limit, #_int eol_size]
    (ยง
        (ร int i)

        ((ร int words =) 0)
        ((ร int chars =) 0)
        ((ร boolean is_word =) false)

        ((ร FOR) (ร (ยง i = 0) (ยง i < limit && line.at(i) != NUL) nil)
            (cond is_word
            (ยง
                (when (vim_isspace (ยง line.at(i)))
                    (ยง words++)
                    ((ร is_word =) false)
                )
            )
            (not (vim_isspace (ยง line.at(i))))
            (ยง
                ((ร is_word =) true)
            ))
            (ยง chars++)
            ((ร i +=) (ยง us_ptr2len_cc(line.plus(i))))
        )

        (if is_word
            (ยง words++)
        )
        ((ร wc[0] +=) words)

        ;; Add eol_size if the end of line was reached before hitting limit.
        (when (and (< i limit) (eos? line i))
            ((ร i +=) eol_size)
            ((ร chars +=) eol_size)
        )
        ((ร cc[0] +=) chars)

        i
    ))

;; Give some info about the position of the cursor (for "g CTRL-G").
;; In Visual mode, give some info about the selected region.  (In this case,
;; the *_count_cursor variables store running totals for the selection.)

(defn- #_void cursor_pos_info []
    (ยง
        ;; Compute the length of the file in characters.

        (when (non-zero? (& (.. @curbuf b_ml ml_flags) ML_EMPTY))
            (msg no_lines_msg)
            (ร RETURN)
        )

        ((ร Bytes buf1 =) (ยง new Bytes(50)))
        ((ร Bytes buf2 =) (ยง new Bytes(40)))
        ((ร int byte_count =) 0)
        ((ร int byte_count_cursor =) 0)
; %%    ((ร int[] char_count =) (ยง { 0 }))
; %%    ((ร int[] char_count_cursor =) (ยง { 0 }))
; %%    ((ร int[] word_count =) (ยง { 0 }))
; %%    ((ร int[] word_count_cursor =) (ยง { 0 }))
        ((ร int last_check =) 100000)
        ((ร long line_count_selected =) 0)

        ((ร pos_C min_pos =) (ยง ยง_pos_C()))
        ((ร pos_C max_pos =) (ยง ยง_pos_C()))
        ((ร oparg_C oparg =) (ยง ยง_oparg_C()))

        ((ร int eol_size =) 1)

        (when @VIsual_active
            (cond (ltpos @VIsual, (. @curwin w_cursor))
            (ยง
                (COPY_pos min_pos, @VIsual)
                (COPY_pos max_pos, (. @curwin w_cursor))
            )
            :else
            (ยง
                (COPY_pos min_pos, (. @curwin w_cursor))
                (COPY_pos max_pos, @VIsual)
            ))
            (if (and (== (.at @p_sel 0) (byte \e)) (< 0 (. max_pos col)))
                (ยง --max_pos.col)
            )

            (when (== @VIsual_mode Ctrl_V)
                ((ร Bytes saved_sbr =) @p_sbr)

                ;; Make 'sbr' empty for a moment to get the correct size.
                (reset! p_sbr EMPTY_OPTION)
                ((ร oparg.is_VIsual =) true)
                ((ร oparg.block_mode =) true)
                ((ร oparg.op_type =) OP_NOP)
;               {
; %%                ((ร int[] scol =) (ยง { oparg.start_vcol }))
; %%                ((ร int[] ecol =) (ยง { oparg.end_vcol }))
                    (getvcols @curwin, min_pos, max_pos, scol, ecol)
                    ((ร oparg.start_vcol =) (ยง scol[0]))
                    ((ร oparg.end_vcol =) (ยง ecol[0]))
;               }
                (reset! p_sbr saved_sbr)
                (if (== (. @curwin w_curswant) MAXCOL)
                    ((ร oparg.end_vcol =) MAXCOL)
                )
                ;; Swap the start, end vcol if needed.
                (when (< (. oparg end_vcol) (. oparg start_vcol))
                    ((ร oparg.end_vcol +=) (. oparg start_vcol))
                    ((ร oparg.start_vcol =) (ยง oparg.end_vcol - oparg.start_vcol))
                    ((ร oparg.end_vcol -=) (. oparg start_vcol))
                )
            )

            ((ร line_count_selected =) (ยง max_pos.lnum - min_pos.lnum + 1))
        )

        ((ร FOR) (ร (ยง long lnum = 1) (ยง lnum <= @curbuf.b_ml.ml_line_count) (ยง lnum++))
            ;; Check for a CTRL-C every 100000 characters.
            (when (< last_check byte_count)
                (ui_breakcheck)
                (if @got_int
                    (ร RETURN)
                )
                ((ร last_check =) (+ byte_count 100000))
            )

            ;; Do extra processing for VIsual mode.
            (cond (and @VIsual_active (<= (. min_pos lnum) lnum) (<= lnum (. max_pos lnum)))
            (ยง
                ((ร Bytes s =) null)
                ((ร int len =) 0)

                ((ร SWITCH) @VIsual_mode
                    ((ร CASE) Ctrl_V)
                    (ยง
                        (reset! virtual_op (if (virtual_active) TRUE FALSE))
                        ((ร block_def_C bd =) (ยง ยง_block_def_C()))
                        (block_prep oparg, bd, lnum, false)
                        (reset! virtual_op MAYBE)
                        ((ร s =) (. bd textstart))
                        ((ร len =) (. bd textlen))
                        (ร BREAK)
                    )

                    ((ร CASE) (byte \V))
                    (ยง
                        ((ร s =) (ml_get lnum))
                        ((ร len =) MAXCOL)
                        (ร BREAK)
                    )

                    ((ร CASE) (byte \v))
                    (ยง
                        ((ร int start_col =) (if (== lnum (. min_pos lnum)) (. min_pos col) 0))
                        ((ร int end_col =) (if (== lnum (. max_pos lnum)) (+ (- (. max_pos col) start_col) 1) MAXCOL))

                        ((ร s =) (ยง ml_get(lnum).plus(start_col)))
                        ((ร len =) end_col)
                        (ร BREAK)
                    )
                )

                (if (non-nil? s)
                    ((ร byte_count_cursor +=) (line_count_info s, word_count_cursor, char_count_cursor, len, eol_size))
                )
            )
            :else
            (ยง
                ;; In non-visual mode, check for the line the cursor is on.
                (when (== lnum (.. @curwin w_cursor lnum))
                    ((ร word_count_cursor[0] +=) (ยง word_count[0]))
                    ((ร char_count_cursor[0] +=) (ยง char_count[0]))
;                   byte_count_cursor = byte_count +
                        (line_count_info (ml_get lnum), word_count_cursor, char_count_cursor, (+ (.. @curwin w_cursor col) 1), eol_size)
                )
            ))

            ;; Add to the running totals.
            ((ร byte_count +=) (ยง line_count_info(ml_get(lnum), word_count, char_count, MAXCOL, eol_size)))
        )

        (cond @VIsual_active
        (ยง
            (cond (and (== @VIsual_mode Ctrl_V) (< (. @curwin w_curswant) MAXCOL))
            (ยง
;               {
; %%                ((ร int[] _1 =) (ยง { min_pos.col }))
; %%                ((ร int[] _2 =) (ยง { max_pos.col }))
                    (getvcols @curwin, min_pos, max_pos, _1, _2)
                    ((ร min_pos.col =) (ยง _1[0]))
                    ((ร max_pos.col =) (ยง _2[0]))
;               }
                (ยง vim_snprintf(buf1, buf1.size(), (u8 "%ld Cols; "), oparg.end_vcol - oparg.start_vcol + 1))
            )
            :else
            (ยง
                (.be buf1 0, NUL)
            ))

            (cond (and (== (ยง char_count_cursor[0]) byte_count_cursor) (== (ยง char_count[0]) byte_count))
            (ยง
                (ยง vim_snprintf(@ioBuff, IOSIZE, (u8 "Selected %s%ld of %ld Lines; %ld of %ld Words; %ld of %ld Bytes"), buf1, line_count_selected, @curbuf.b_ml.ml_line_count, word_count_cursor[0], word_count[0], byte_count_cursor, byte_count))
            )
            :else
            (ยง
                (ยง vim_snprintf(@ioBuff, IOSIZE, (u8 "Selected %s%ld of %ld Lines; %ld of %ld Words; %ld of %ld Chars; %ld of %ld Bytes"), buf1, line_count_selected, @curbuf.b_ml.ml_line_count, word_count_cursor[0], word_count[0], char_count_cursor[0], char_count[0], byte_count_cursor, byte_count))
            ))
        )
        :else
        (ยง
            ((ร Bytes p =) (ml_get_curline))
            (validate_virtcol)
            (col_print buf1, (ยง buf1.size()), (+ (.. @curwin w_cursor col) 1), (+ (. @curwin w_virtcol) 1))
            (col_print buf2, (ยง buf2.size()), (STRLEN p), (linetabsize p))

            (cond (and (== (ยง char_count_cursor[0]) byte_count_cursor) (== (ยง char_count[0]) byte_count))
            (ยง
                (ยง vim_snprintf(@ioBuff, IOSIZE, (u8 "Col %s of %s; Line %ld of %ld; Word %ld of %ld; Byte %ld of %ld"), buf1, buf2, @curwin.w_cursor.lnum, @curbuf.b_ml.ml_line_count, word_count_cursor[0], word_count[0], byte_count_cursor, byte_count))
            )
            :else
            (ยง
                (ยง vim_snprintf(@ioBuff, IOSIZE, (u8 "Col %s of %s; Line %ld of %ld; Word %ld of %ld; Char %ld of %ld; Byte %ld of %ld"), buf1, buf2, @curwin.w_cursor.lnum, @curbuf.b_ml.ml_line_count, word_count_cursor[0], word_count[0], char_count_cursor[0], char_count[0], byte_count_cursor, byte_count))
            ))
        ))

        (msg @ioBuff)
    ))

;; mark.c: functions for setting marks and jumping to them ----------------------------------------

;; If a named file mark's lnum is non-zero, it is valid.
;; There are marks 'A - 'Z (set by user) and '0 to '9 (set when writing viminfo).

(final int EXTRA_MARKS 10)                                              ;; marks 0-9
(final fmark_C*    namedfm    (ARRAY_fmark (+ NMARKS EXTRA_MARKS)))   ;; marks with file nr

;; Set named mark "c" at current cursor position.
;; Returns true on success, false if bad name given.

(defn- #_boolean setmark [#_int c]
    (ยง
        (setmark_pos c, (. @curwin w_cursor))
    ))

;; Set named mark "c" to position "pos".
;; Returns true on success, false if bad name given.

(defn- #_boolean setmark_pos [#_int c, #_pos_C pos]
    (ยง
        ;; Check for a special key (may cause islower() to crash).
        (if (< c 0)
            ((ร RETURN) false)
        )

        (when (or (== c (byte \')) (== c (byte \`)))
            (cond (== pos (. @curwin w_cursor))
            (ยง
                (setpcmark)
                ;; keep it even when the cursor doesn't move
                (COPY_pos (. @curwin w_prev_pcmark), (. @curwin w_pcmark))
            )
            :else
            (ยง
                (COPY_pos (. @curwin w_pcmark), pos)
            ))
            ((ร RETURN) true)
        )

        (when (== c (byte \"))  ;; """
            (COPY_pos (. @curbuf b_last_cursor), pos)
            ((ร RETURN) true)
        )

        ;; Allow setting '[ and '] for an autocommand that simulates reading a file.
        (when (== c (byte \[))
            (COPY_pos (. @curbuf b_op_start), pos)
            ((ร RETURN) true)
        )
        (when (== c (byte \]))
            (COPY_pos (. @curbuf b_op_end), pos)
            ((ร RETURN) true)
        )

        (when (or (== c (byte \<)) (== c (byte \>)))
            (if (== c (byte \<))
                (COPY_pos (.. @curbuf b_visual vi_start), pos)
                (COPY_pos (.. @curbuf b_visual vi_end), pos))
            (when (== (.. @curbuf b_visual vi_mode) NUL)
                ;; Visual_mode has not yet been set, use a sane default.
                ((ร @curbuf.b_visual.vi_mode =) (byte \v))
            )
            ((ร RETURN) true)
        )

        (if (< (byte \z) c)        ;; some islower() and isupper() cannot handle characters above 127
            ((ร RETURN) false)
        )
        (when (asc_islower c)
            ((ร int i =) (ยง c - (byte \a)))
            (COPY_pos (ยง @curbuf.b_namedm[i]), pos)
            ((ร RETURN) true)
        )
        (when (asc_isupper c)
            ((ร int i =) (ยง c - (byte \A)))
            (COPY_pos (ยง namedfm[i].mark), pos)
            ((ร RETURN) true)
        )

        false
    ))

;; Set the previous context mark to the current position and add it to the jump list.

(defn- #_void setpcmark []
    (ยง
        (COPY_pos (. @curwin w_prev_pcmark), (. @curwin w_pcmark))
        (COPY_pos (. @curwin w_pcmark), (. @curwin w_cursor))

        ;; If jumplist is full: remove oldest entry.
        (when (> (ยง ++@curwin.w_jumplistlen) JUMPLISTSIZE)
            ((ร @curwin.w_jumplistlen =) JUMPLISTSIZE)
            ((ร FOR) (ร (ยง int i = 1) (< i JUMPLISTSIZE) (ยง i++))
                (COPY_fmark (ยง @curwin.w_jumplist[i - 1]), (ยง @curwin.w_jumplist[i]))
            )
        )
        ((ร @curwin.w_jumplistidx =) (. @curwin w_jumplistlen))
        ((ร fmark_C fm =) (ยง @curwin.w_jumplist[@curwin.w_jumplistlen - 1]))

        (COPY_pos (. fm mark), (. @curwin w_pcmark))
    ))

;; To change context, call setpcmark(), then move the current position to
;; where ever, then call checkpcmark().  This ensures that the previous
;; context will only be changed if the cursor moved to a different line.
;; If pcmark was deleted (with "dG") the previous mark is restored.

(defn- #_void checkpcmark []
    (ยง
        (when (and (!= (.. @curwin w_prev_pcmark lnum) 0) (or (eqpos (. @curwin w_pcmark), (. @curwin w_cursor)) (zero? (.. @curwin w_pcmark lnum))))
            (COPY_pos (. @curwin w_pcmark), (. @curwin w_prev_pcmark))
            ((ร @curwin.w_prev_pcmark.lnum =) 0)      ;; show it has been checked
        )
    ))

;; Move "count" positions in the jump list (count may be negative).

(defn- #_pos_C movemark [#_int count]
    (ยง
        (cleanup_jumplist)

        (if (zero? (. @curwin w_jumplistlen))          ;; nothing to jump to
            ((ร RETURN) null)
        )

        (while true
            (if (or (ยง @curwin.w_jumplistidx + count < 0) (<= (. @curwin w_jumplistlen) (+ (. @curwin w_jumplistidx) count)))
                ((ร RETURN) null)
            )

            ;; If first CTRL-O or CTRL-I command after a jump, add cursor position
            ;; to list.  Careful: If there are duplicates (CTRL-O immediately after
            ;; starting Vim on a file), another entry may have been removed.

            (when (== (. @curwin w_jumplistidx) (. @curwin w_jumplistlen))
                (setpcmark)
                (ยง --@curwin.w_jumplistidx)         ;; skip the new entry
                (if (ยง @curwin.w_jumplistidx + count < 0)
                    ((ร RETURN) null)
                )
            )

            ((ร @curwin.w_jumplistidx +=) count)

            ((ร RETURN) (ยง @curwin.w_jumplist[@curwin.w_jumplistidx].mark))
        )
    ))

;; Move "count" positions in the changelist (count may be negative).

(defn- #_pos_C movechangelist [#_int count]
    (ยง
        (if (zero? (. @curbuf b_changelistlen))    ;; nothing to jump to
            ((ร RETURN) null)
        )

        ((ร int n =) (. @curwin w_changelistidx))
        (cond (< (+ n count) 0)
        (ยง
            (if (zero? n)
                ((ร RETURN) null)
            )
            ((ร n =) 0)
        )
        (<= (. @curbuf b_changelistlen) (+ n count))
        (ยง
            (if (== n (- (. @curbuf b_changelistlen) 1))
                ((ร RETURN) null)
            )
            ((ร n =) (ยง @curbuf.b_changelistlen - 1))
        )
        :else
        (ยง
            ((ร n +=) count)
        ))
        ((ร @curwin.w_changelistidx =) n)
        (ยง @curbuf.b_changelist[n])
    ))

;; Find mark "c" in buffer pointed to by "buf".
;; If "changefile" is true it's allowed to edit another file for '0, 'A, etc.
;; Returns:
;; - pointer to pos_C if found.  lnum is 0 when mark not set, -1 when mark is
;;   in another file which can't be gotten. (caller needs to check lnum!)
;; - null if there is no mark called 'c'.
;; - -1 if mark is in other file and jumped there (only if changefile is true)

(defn- #_pos_C getmark_buf [#_buffer_C buf, #_int c, #_boolean changefile]
    (getmark_buf_fnum buf, c, changefile))

(defn- #_pos_C getmark [#_int c, #_boolean changefile]
    (getmark_buf_fnum @curbuf, c, changefile))

(atom! pos_C _1_pos_copy    (ยง_pos_C))

(defn- #_pos_C getmark_buf_fnum [#_buffer_C buf, #_int c, #_boolean changefile]
    (ยง
        ((ร pos_C posp =) null)

        ;; Check for special key, can't be a mark name and might cause islower() to crash.
        (if (< c 0)
            ((ร RETURN) posp)
        )

        (cond (< (byte \~) c)                                ;; check for islower()/isupper()
        (ยง
            ;
        )
        (or (== c (byte \')) (== c (byte \`)))             ;; previous context mark
        (ยง
            (COPY_pos @_1_pos_copy, (. @curwin w_pcmark)) ;; need to make a copy because
            ((ร posp =) @_1_pos_copy)                     ;; w_pcmark may be changed soon
        )
        (== c (byte \"))                          ;; to pos when leaving buffer """
        (ยง
            ((ร posp =) (. buf b_last_cursor))
        )
        (== c (byte \^))                          ;; to where Insert mode stopped
        (ยง
            ((ร posp =) (. buf b_last_insert))
        )
        (== c (byte \.))                          ;; to where last change was made
        (ยง
            ((ร posp =) (. buf b_last_change))
        )
        (== c (byte \[))                          ;; to start of previous operator
        (ยง
            ((ร posp =) (. buf b_op_start))
        )
        (== c (byte \]))                          ;; to end of previous operator
        (ยง
            ((ร posp =) (. buf b_op_end))
        )
        (or (== c (byte \{)) (== c (byte \})))              ;; to previous/next paragraph
        (ยง
;           
        )
        (or (== c (byte \()) (== c (byte \))))              ;; to previous/next sentence
        (ยง
;           
        )
        (or (== c (byte \<)) (== c (byte \>)))              ;; start/end of visual area
        (ยง
            ((ร pos_C startp =) (.. buf b_visual vi_start))
            ((ร pos_C endp =) (.. buf b_visual vi_end))
            (if (== (== c (byte \<)) (ltpos startp, endp))
                ((ร posp =) startp)
                ((ร posp =) endp)
            )

            ;; For Visual line mode, set mark at begin or end of line

            (when (== (.. buf b_visual vi_mode) (byte \V))
                (COPY_pos @_1_pos_copy, posp)
                ((ร posp =) @_1_pos_copy)
                (if (== c (byte \<))
                    ((ร @_1_pos_copy.col =) 0)
                    ((ร @_1_pos_copy.col =) MAXCOL)
                )
                ((ร @_1_pos_copy.coladd =) 0)
            )
        )
        (asc_islower c)                    ;; normal named mark
        (ยง
            ((ร posp =) (ยง buf.b_namedm[c - (byte \a)]))
        )
        (or (asc_isupper c) (asc_isdigit c))  ;; named file mark
        (ยง
            (if (asc_isdigit c)
                ((ร c =) (ยง c - (byte \0) + NMARKS))
                ((ร c -=) (byte \A))
            )
            ((ร posp =) (ยง namedfm[c].mark))
        ))

        posp
    ))

;; Search for the next named mark in the current file.
;;
;; Returns pointer to pos_C of the next mark or null if no mark is found.

(defn- #_pos_C getnextmark [#_pos_C startpos, #_int dir, #_boolean begin_line]
    ;; startpos: where to start
    ;; dir: direction for search
    (ยง
        ((ร pos_C result =) null)
        ((ร pos_C pos =) (ยง ยง_pos_C()))
        (COPY_pos pos, startpos)

        ;; When searching backward and leaving the cursor on the first non-blank,
        ;; position must be in a previous line.
        ;; When searching forward and leaving the cursor on the first non-blank,
        ;; position must be in a next line.
        (cond (and (== dir BACKWARD) begin_line)
        (ยง
            ((ร pos.col =) 0)
        )
        (and (== dir FORWARD) begin_line)
        (ยง
            ((ร pos.col =) MAXCOL)
        ))

        ((ร FOR) (ร (ยง int i = 0) (< i NMARKS) (ยง i++))
            (when (< 0 (ยง @curbuf.b_namedm[i].lnum))
                (cond (== dir FORWARD)
                (ยง
                    (if (and (or (nil? result) (ltpos (ยง @curbuf.b_namedm[i]), result)) (ltpos pos, (ยง @curbuf.b_namedm[i])))
                        ((ร result =) (ยง @curbuf.b_namedm[i]))
                    )
                )
                :else
                (ยง
                    (if (and (or (nil? result) (ltpos result, (ยง @curbuf.b_namedm[i]))) (ltpos (ยง @curbuf.b_namedm[i]), pos))
                        ((ร result =) (ยง @curbuf.b_namedm[i]))
                    )
                ))
            )
        )

        result
    ))

;; Check a if a position from a mark is valid.
;; Give and error message and return false if not.

(defn- #_boolean check_mark [#_pos_C pos]
    (ยง
        (when (nil? pos)
            (emsg e_umark)
            ((ร RETURN) false)
        )
        (when (<= (. pos lnum) 0)
            ;; 'lnum' is negative if mark is in another file and can't get that file,
            ;; error message already give then.
            (if (zero? (. pos lnum))
                (emsg e_marknotset))
            ((ร RETURN) false)
        )
        (when (< (.. @curbuf b_ml ml_line_count) (. pos lnum))
            (emsg e_markinval)
            ((ร RETURN) false)
        )
        true
    ))

(atom! int mark_i -1)

;; clrallmarks() - clear all marks in the buffer 'buf'
;;
;; Used mainly when trashing the entire buffer during ":e" type commands

(defn- #_void clrallmarks [#_buffer_C buf]
    (ยง
        (when (== @mark_i -1)                   ;; first call ever: initialize
            ((ร FOR) (ร (ยง @mark_i = 0) (ยง @mark_i < NMARKS + 1) (ยง @mark_i++))
                ((ร namedfm[@mark_i].mark.lnum =) 0)
            )
        )

        ((ร FOR) (ร (ยง @mark_i = 0) (< @mark_i NMARKS) (ยง @mark_i++))
            ((ร buf.b_namedm[@mark_i].lnum =) 0)
        )
        ((ร buf.b_op_start.lnum =) 0)            ;; start/end op mark cleared
        ((ร buf.b_op_end.lnum =) 0)
        ((ร buf.b_last_cursor.lnum =) 1)         ;; '" mark cleared
        ((ร buf.b_last_cursor.col =) 0)
        ((ร buf.b_last_cursor.coladd =) 0)
        ((ร buf.b_last_insert.lnum =) 0)         ;; '^ mark cleared
        ((ร buf.b_last_change.lnum =) 0)         ;; '. mark cleared
        ((ร buf.b_changelistlen =) 0)
    ))

(defn- #_long one_adjust [#_long add, #_long line1, #_long line2, #_long amount, #_long amount_after]
    (ยง
        (cond (and (<= line1 add) (<= add line2))
        (ยง
            (if (== amount MAXLNUM)
                ((ร add =) 0)
                ((ร add +=) amount)
            )
        )
        (and (non-zero? amount_after) (< line2 add))
        (ยง
            ((ร add +=) amount_after)
        ))

        add
    ))

;; don't delete the line, just put at first deleted line
(defn- #_long one_adjust_nodel [#_long add, #_long line1, #_long line2, #_long amount, #_long amount_after]
    (ยง
        (cond (and (<= line1 add) (<= add line2))
        (ยง
            (if (== amount MAXLNUM)
                ((ร add =) line1)
                ((ร add +=) amount)
            )
        )
        (and (non-zero? amount_after) (< line2 add))
        (ยง
            ((ร add +=) amount_after)
        ))

        add
    ))

(atom! pos_C mark_initpos (new_pos 1, 0, 0))

;; Adjust marks between line1 and line2 (inclusive) to move 'amount' lines.
;; Must be called before changed_*(), appended_lines() or deleted_lines().
;; May be called before or after changing the text.
;; When deleting lines line1 to line2, use an 'amount' of MAXLNUM:
;; The marks within this range are made invalid.
;; If 'amount_after' is non-zero adjust marks after line2.
;; Example: Delete lines 34 and 35: mark_adjust(34, 35, MAXLNUM, -2);
;; Example: Insert two lines below 55: mark_adjust(56, MAXLNUM, 2, 0);
;;                                 or: mark_adjust(56, 55, MAXLNUM, 2);

(defn- #_void mark_adjust [#_long line1, #_long line2, #_long amount, #_long amount_after]
    (ยง
        (if (and (< line2 line1) (zero? amount_after))                ;; nothing to do
            (ร RETURN)
        )

        ;; named marks, lower case and upper case
        ((ร FOR) (ร (ยง int i = 0) (< i NMARKS) (ยง i++))
            ((ร @curbuf.b_namedm[i].lnum =) (ยง one_adjust(@curbuf.b_namedm[i].lnum, line1, line2, amount, amount_after)))
            ((ร namedfm[i].mark.lnum =) (ยง one_adjust_nodel(namedfm[i].mark.lnum, line1, line2, amount, amount_after)))
        )
        ((ร FOR) (ร (ยง int i = NMARKS) (ยง i < NMARKS + EXTRA_MARKS) (ยง i++))
            ((ร namedfm[i].mark.lnum =) (ยง one_adjust_nodel(namedfm[i].mark.lnum, line1, line2, amount, amount_after)))
        )

        ;; last Insert position
        ((ร @curbuf.b_last_insert.lnum =) (ยง one_adjust(@curbuf.b_last_insert.lnum, line1, line2, amount, amount_after)))

        ;; last change position
        ((ร @curbuf.b_last_change.lnum =) (ยง one_adjust(@curbuf.b_last_change.lnum, line1, line2, amount, amount_after)))

        ;; last cursor position, if it was set
        (if (not (eqpos (. @curbuf b_last_cursor), @mark_initpos))
            ((ร @curbuf.b_last_cursor.lnum =) (ยง one_adjust(@curbuf.b_last_cursor.lnum, line1, line2, amount, amount_after)))
        )

        ;; list of change positions
        ((ร FOR) (ร (ยง int i = 0) (ยง i < @curbuf.b_changelistlen) (ยง i++))
            ((ร @curbuf.b_changelist[i].lnum =) (ยง one_adjust_nodel(@curbuf.b_changelist[i].lnum, line1, line2, amount, amount_after)))
        )

        ;; Visual area.
        ((ร @curbuf.b_visual.vi_start.lnum =) (ยง one_adjust_nodel(@curbuf.b_visual.vi_start.lnum, line1, line2, amount, amount_after)))
        ((ร @curbuf.b_visual.vi_end.lnum =) (ยง one_adjust_nodel(@curbuf.b_visual.vi_end.lnum, line1, line2, amount, amount_after)))

        ;; previous context mark
        ((ร @curwin.w_pcmark.lnum =) (ยง one_adjust(@curwin.w_pcmark.lnum, line1, line2, amount, amount_after)))

        ;; previous pcmark
        ((ร @curwin.w_prev_pcmark.lnum =) (ยง one_adjust(@curwin.w_prev_pcmark.lnum, line1, line2, amount, amount_after)))

        ;; saved cursor for formatting
        (if (!= (. @saved_cursor lnum) 0)
            ((ร @saved_cursor.lnum =) (ยง one_adjust_nodel(@saved_cursor.lnum, line1, line2, amount, amount_after)))
        )

        ;; Adjust items in all windows related to the current buffer.

        ((ร FOR) (ร (ยง window_C win = @firstwin) (!= win null) (ยง win = win.w_next))
            ;; Marks in the jumplist.  When deleting lines, this may create
            ;; duplicate marks in the jumplist, they will be removed later.
            ((ร FOR) (ร (ยง int i = 0) (ยง i < win.w_jumplistlen) (ยง i++))
                ((ร win.w_jumplist[i].mark.lnum =) (ยง one_adjust_nodel(win.w_jumplist[i].mark.lnum, line1, line2, amount, amount_after)))
            )

            ;; the displayed Visual area
            (when (!= (. win w_old_cursor_lnum) 0)
                ((ร win.w_old_cursor_lnum =) (ยง one_adjust_nodel(win.w_old_cursor_lnum, line1, line2, amount, amount_after)))
                ((ร win.w_old_visual_lnum =) (ยง one_adjust_nodel(win.w_old_visual_lnum, line1, line2, amount, amount_after)))
            )

            ;; topline and cursor position for windows with the same buffer
            ;; other than the current window
            (when (!= win @curwin)
                (cond (and (<= line1 (. win w_topline)) (<= (. win w_topline) line2))
                (ยง
                    (cond (== amount MAXLNUM)              ;; topline is deleted
                    (ยง
                        (if (<= line1 1)
                            ((ร win.w_topline =) 1)
                            ((ร win.w_topline =) (- line1 1))
                        )
                    )
                    :else                                ;; keep topline on the same line
                    (ยง
                        ((ร win.w_topline +=) amount)
                    ))
                )
                (and (non-zero? amount_after) (< line2 (. win w_topline)))
                (ยง
                    ((ร win.w_topline +=) amount_after)
                ))

                (cond (and (<= line1 (.. win w_cursor lnum)) (<= (.. win w_cursor lnum) line2))
                (ยง
                    (cond (== amount MAXLNUM)              ;; line with cursor is deleted
                    (ยง
                        (if (<= line1 1)
                            ((ร win.w_cursor.lnum =) 1)
                            ((ร win.w_cursor.lnum =) (- line1 1))
                        )
                        ((ร win.w_cursor.col =) 0)
                    )
                    :else                                ;; keep cursor on the same line
                    (ยง
                        ((ร win.w_cursor.lnum +=) amount)
                    ))
                )
                (and (non-zero? amount_after) (< line2 (.. win w_cursor lnum)))
                (ยง
                    ((ร win.w_cursor.lnum +=) amount_after)
                ))
            )
        )
    ))

;; This code is used often, needs to be fast.
(defn- #_void col_adjust [#_pos_C posp, #_long lnum, #_int mincol, #_long lnum_amount, #_long col_amount]
    (ยง
        (when (and (== (. posp lnum) lnum) (<= mincol (. posp col)))
            ((ร posp.lnum +=) lnum_amount)
            (if (and (< col_amount 0) (<= (. posp col) (int (- col_amount))))
                ((ร posp.col =) 0)
                ((ร posp.col +=) col_amount)
            )
        )
    ))

;; Adjust marks in line "lnum" at column "mincol" and further: add
;; "lnum_amount" to the line number and add "col_amount" to the column position.

(defn- #_void mark_col_adjust [#_long lnum, #_int mincol, #_long lnum_amount, #_long col_amount]
    (ยง
        (if (and (zero? col_amount) (zero? lnum_amount))
            (ร RETURN) ;; nothing to do
        )

        ;; named marks, lower case and upper case
        ((ร FOR) (ร (ยง int i = 0) (< i NMARKS) (ยง i++))
            (col_adjust (ยง @curbuf.b_namedm[i]), lnum, mincol, lnum_amount, col_amount)
            (col_adjust (ยง namedfm[i].mark), lnum, mincol, lnum_amount, col_amount)
        )
        ((ร FOR) (ร (ยง int i = NMARKS) (ยง i < NMARKS + EXTRA_MARKS) (ยง i++))
            (col_adjust (ยง namedfm[i].mark), lnum, mincol, lnum_amount, col_amount)
        )

        ;; last Insert position
        (col_adjust (. @curbuf b_last_insert), lnum, mincol, lnum_amount, col_amount)

        ;; last change position
        (col_adjust (. @curbuf b_last_change), lnum, mincol, lnum_amount, col_amount)

        ;; list of change positions
        ((ร FOR) (ร (ยง int i = 0) (ยง i < @curbuf.b_changelistlen) (ยง i++))
            (col_adjust (ยง @curbuf.b_changelist[i]), lnum, mincol, lnum_amount, col_amount)
        )

        ;; Visual area.
        (col_adjust (.. @curbuf b_visual vi_start), lnum, mincol, lnum_amount, col_amount)
        (col_adjust (.. @curbuf b_visual vi_end), lnum, mincol, lnum_amount, col_amount)

        ;; previous context mark
        (col_adjust (. @curwin w_pcmark), lnum, mincol, lnum_amount, col_amount)

        ;; previous pcmark
        (col_adjust (. @curwin w_prev_pcmark), lnum, mincol, lnum_amount, col_amount)

        ;; saved cursor for formatting
        (col_adjust @saved_cursor, lnum, mincol, lnum_amount, col_amount)

        ;; Adjust items in all windows related to the current buffer.

        ((ร FOR) (ร (ยง window_C wp = @firstwin) (!= wp null) (ยง wp = wp.w_next))
            ;; marks in the jumplist
            ((ร FOR) (ร (ยง int i = 0) (ยง i < wp.w_jumplistlen) (ยง i++))
                (col_adjust (ยง wp.w_jumplist[i].mark), lnum, mincol, lnum_amount, col_amount)
            )

            ;; cursor position for other windows with the same buffer
            (if (!= wp @curwin)
                (col_adjust (. wp w_cursor), lnum, mincol, lnum_amount, col_amount))
        )
    ))

;; When deleting lines, this may create duplicate marks in the jumplist.
;; They will be removed here for the current window.

(defn- #_void cleanup_jumplist []
    (ยง
        ((ร int to =) 0)

        ((ร FOR) (ร (ยง int from = 0) (ยง from < @curwin.w_jumplistlen) (ยง from++))
            (if (== (. @curwin w_jumplistidx) from)
                ((ร @curwin.w_jumplistidx =) to)
            )
            (ร int i)
            ((ร FOR) (ร (ยง i = from + 1) (ยง i < @curwin.w_jumplistlen) (ยง i++))
                (if (== (ยง @curwin.w_jumplist[i].mark.lnum) (ยง @curwin.w_jumplist[from].mark.lnum))
                    (ร BREAK)
                )
            )
            (if (<= (. @curwin w_jumplistlen) i)  ;; no duplicate
                (COPY_fmark (ยง @curwin.w_jumplist[to++]), (ยง @curwin.w_jumplist[from])))
        )

        (if (== (. @curwin w_jumplistidx) (. @curwin w_jumplistlen))
            ((ร @curwin.w_jumplistidx =) to)
        )
        ((ร @curwin.w_jumplistlen =) to)
    ))

;; Copy the jumplist from window "from" to window "to".

(defn- #_void copy_jumplist [#_window_C from, #_window_C to]
    (ยง
        ((ร FOR) (ร (ยง int i = 0) (ยง i < from.w_jumplistlen) (ยง i++))
            (COPY_fmark (ยง to.w_jumplist[i]), (ยง from.w_jumplist[i]))
        )
        ((ร to.w_jumplistlen =) (. from w_jumplistlen))
        ((ร to.w_jumplistidx =) (. from w_jumplistidx))
    ))

(defn- #_void set_last_cursor [#_window_C win]
    (ยง
        (COPY_pos (. @curbuf b_last_cursor), (. win w_cursor))
    ))

;;; ============================================================================================== VimL

;; getchar.c --------------------------------------------------------------------------------------
;;
;; functions related with getting a character from the user/mapping/redo/...
;;
;; manipulations with redo buffer and stuff buffer
;; mappings and abbreviations

;; These buffers are used for storing:
;; - stuffed characters: A command that is translated into another command.
;; - redo characters: will redo the last change.
;; - recorded characters: for the "q" command.
;;
;; The bytes are stored like in the typeahead buffer:
;; - KB_SPECIAL introduces a special key (two more bytes follow).
;;   A literal KB_SPECIAL is stored as KB_SPECIAL KS_SPECIAL KE_FILLER.
;; These translations are also done on multi-byte characters!
;;
;; Escaping KB_SPECIAL is done by inchar().
;; Un-escaping is done by vgetc().

(atom! buffheader_C redobuff    (ยง_buffheader_C))
(atom! buffheader_C old_redobuff    (ยง_buffheader_C))
(atom! buffheader_C recordbuff  (ยง_buffheader_C))

(atom! int typeahead_char)      ;; typeahead char that's not flushed

;; When block_redo is true redo buffer will not be changed;
;; used by edit() to repeat insertions and 'V' command for redoing.

(atom! boolean block_redo)

;; Variables used by vgetorpeek() and flush_buffers().
;;
;; typebuf.tb_buf[] contains all characters that are not consumed yet.
;; typebuf.tb_buf[typebuf.tb_off] is the first valid character.
;; typebuf.tb_buf[typebuf.tb_off + typebuf.tb_len - 1] is the last valid char.
;; typebuf.tb_buf[typebuf.tb_off + typebuf.tb_len] must be NUL.
;;
;; After the head are characters that come from the terminal.

;; typebuf.tb_buf has three parts:
;;  room in front (for result of mappings),
;;  the middle for typeahead and
;;  room for new characters (which needs to be 3 * MAXMAPLEN).

(atom! int      last_recorded_len)          ;; number of last recorded chars

;; Free and clear a buffer.

(defn- #_void free_buff [#_buffheader_C buf]
    (ยง
        ((ร buf.bh_first.bb_next =) null)
    ))

;; Return the contents of a buffer as a single string.
;; KB_SPECIAL in the returned string is escaped.

(defn- #_Bytes get_buffcont [#_buffheader_C buffer, #_boolean dozero]
    ;; dozero: count == zero is not an error
    (ยง
        ((ร int count =) 0)

        ;; compute the total length of the string
        ((ร FOR) (ร (ยง buffblock_C bp = buffer.bh_first.bb_next) (!= bp null) (ยง bp = bp.bb_next))
            ((ร count +=) (ยง STRLEN(bp.bb_str)))
        )

        ((ร Bytes p =) null)

        (when (or (< 0 count) dozero)
            ((ร p =) (ยง new Bytes(count + 1)))

            ((ร Bytes q =) p)
            ((ร FOR) (ร (ยง buffblock_C bp = buffer.bh_first.bb_next) (!= bp null) (ยง bp = bp.bb_next))
                ((ร FOR) (ร (ยง Bytes s = bp.bb_str) (ยง s.at(0) != NUL) nil)
                    (ยง (q = q.plus(1)).be(-1, (s = s.plus(1)).at(-1)))
                )
            )
            (.be q 0, NUL)
        )

        p
    ))

;; Return the contents of the record buffer as a single string and clear the record buffer.
;; KB_SPECIAL in the returned string is escaped.

(defn- #_Bytes get_recorded []
    (ยง
        ((ร Bytes p =) (get_buffcont @recordbuff, true))
        (free_buff @recordbuff)

        ;; Remove the characters that were added the last time, these must be the
        ;; (possibly mapped) characters that stopped the recording.

        ((ร int len =) (STRLEN p))
        (when (<= @last_recorded_len len)
            ((ร len -=) @last_recorded_len)
            (.be p len, NUL)
        )

        ;; When stopping recording from Insert mode with CTRL-O q, also remove the CTRL-O.

        (if (and (< 0 len) (non-zero? @restart_edit) (ยง p.at(len - 1) == Ctrl_O))
            (ยง p.be(len - 1, NUL))
        )

        p
    ))

;; Return the contents of the redo buffer as a single string.
;; KB_SPECIAL in the returned string is escaped.

(defn- #_Bytes get_inserted []
    (get_buffcont @redobuff, false))

;; Add string "s" after the current block of buffer "buf".
;; KB_SPECIAL should have been escaped already.

(defn- #_void add_buff [#_buffheader_C buf, #_Bytes s, #_long slen]
    ;; slen: length of "s" or -1
    (ยง
        (if (< slen 0)
            ((ร slen =) (STRLEN s))
        )
        (if (zero? slen)                          ;; don't add empty strings
            (ร RETURN)
        )

        (cond (nil? (.. buf bh_first bb_next))       ;; first add to list
        (ยง
            ((ร buf.bh_space =) 0)
            ((ร buf.bh_curr =) (. buf bh_first))
        )
        (nil? (. buf bh_curr))           ;; buffer has already been read
        (ยง
            (emsg (u8 "E222: Add to read buffer"))
            (ร RETURN)
        )
        (!= (. buf bh_index) 0)
        (ยง
            ((ร buffblock_C bp =) (.. buf bh_first bb_next))
            ((ร int len =) (ยง STRLEN(bp.bb_str.plus(buf.bh_index)) + 1))
            (BCOPY (. bp bb_str), 0, (. bp bb_str), (. buf bh_index), len)
        ))
        ((ร buf.bh_index =) 0)

        (cond (<= (int slen) (. buf bh_space))
        (ยง
            ((ร int len =) (ยง STRLEN(buf.bh_curr.bb_str)))
            (vim_strncpy (.plus (.. buf bh_curr bb_str) len), s, (int slen))
            ((ร buf.bh_space -=) slen)
        )
        :else
        (ยง
            ((ร final int MINIMAL_SIZE =) 20)            ;; minimal size for bb_str

            ((ร int len =) (if (< (int slen) MINIMAL_SIZE) MINIMAL_SIZE (int slen)))

            ((ร buffblock_C bp =) (ยง ยง_buffblock_C()))

            ((ร bp.bb_str =) (ยง new Bytes(len + 1)))
            (vim_strncpy (. bp bb_str), s, (int slen))
            ((ร buf.bh_space =) (ยง len - (int)slen))

            ((ร bp.bb_next =) (.. buf bh_curr bb_next))
            ((ร buf.bh_curr.bb_next =) bp)
            ((ร buf.bh_curr =) bp)
        ))
    ))

;; Add number "n" to buffer "buf".

(defn- #_void add_num_buff [#_buffheader_C buf, #_long n]
    (ยง
        ((ร Bytes number =) (ยง new Bytes(32)))

        (ยง libC.sprintf(number, (u8 "%ld"), n))
        (add_buff buf, number, -1)
    ))

;; Add character 'c' to buffer "buf".
;; Translates special keys, NUL, KB_SPECIAL and multibyte characters.

(defn- #_void add_char_buff [#_buffheader_C buf, #_int c]
    (ยง
        ((ร Bytes bytes =) (ยง new Bytes(MB_MAXBYTES + 1)))

        ((ร int len =) (if (is_special c) 1 (utf_char2bytes c, bytes)))

        ((ร Bytes temp =) (ยง new Bytes(4)))

        ((ร FOR) (ร (ยง int i = 0) (< i len) (ยง i++))
            (if (not (is_special c))
                ((ร c =) (ยง char_u(bytes.at(i))))
            )

            (cond (or (is_special c) (== c (char_u KB_SPECIAL)) (== c NUL))
            (ยง
                ;; translate special key code into three byte sequence
                (.be temp 0, KB_SPECIAL)
                (.be temp 1, (KB_SECOND c))
                (.be temp 2, (KB_THIRD c))
                (.be temp 3, NUL)
            )
            :else
            (ยง
                (.be temp 0, c)
                (.be temp 1, NUL)
            ))

            (add_buff buf, temp, -1)
        )
    ))

;; First read ahead buffer.  Used for translated commands.
(atom! buffheader_C readbuf1    (ยง_buffheader_C))

;; Second read ahead buffer.  Used for redo.
(atom! buffheader_C readbuf2    (ยง_buffheader_C))

;; Get one byte from a read buffer.
;; If advance == true go to the next char.
;; No translation is done KB_SPECIAL is escaped.

(defn- #_byte read_readbuf [#_buffheader_C buf, #_boolean advance]
    (ยง
        ((ร buffblock_C bp =) (.. buf bh_first bb_next))
        (if (nil? bp) ;; buffer is empty
            ((ร RETURN) NUL)
        )

        ((ร byte b =) (ยง bp.bb_str.at(buf.bh_index)))

        (when (and advance (== (ยง bp.bb_str.at(++buf.bh_index)) NUL))
            ((ร buf.bh_first.bb_next =) (. bp bb_next))
            ((ร buf.bh_index =) 0)
        )

        b
    ))

;; Get one byte from the read buffers.
;; Use readbuf1 one first, use readbuf2 if that one is empty.
;; If advance == true go to the next char.
;; No translation is done KB_SPECIAL is escaped.

(defn- #_byte read_readbuffers [#_boolean advance]
    (ยง
        ((ร byte b =) (read_readbuf @readbuf1, advance))
        (if (== b NUL)
            ((ร b =) (read_readbuf @readbuf2, advance))
        )
        b
    ))

;; Prepare the read buffers for reading (if they contain something).

(defn- #_void start_stuff []
    (ยง
        (when (!= (.. @readbuf1 bh_first bb_next) null)
            ((ร @readbuf1.bh_curr =) (. @readbuf1 bh_first))
            ((ร @readbuf1.bh_space =) 0)
        )
        (when (!= (.. @readbuf2 bh_first bb_next) null)
            ((ร @readbuf2.bh_curr =) (. @readbuf2 bh_first))
            ((ร @readbuf2.bh_space =) 0)
        )
    ))

;; Return true if the stuff buffer is empty.

(defn- #_boolean stuff_empty []
    (ยง
        (and (nil? (.. @readbuf1 bh_first bb_next)) (nil? (.. @readbuf2 bh_first bb_next)))
    ))

;; Set a typeahead character that won't be flushed.

(defn- #_void typeahead_noflush [#_int c]
    (reset! typeahead_char c))

;; Remove the contents of the stuff buffer and the mapped characters
;; in the typeahead buffer (used in case of an error).
;; If "flush_typeahead" is true, flush all typeahead characters
;; (used when interrupted by a CTRL-C).

(defn- #_void flush_buffers [#_boolean flush_typeahead]
    (ยง
        (init_typebuf)

        (start_stuff)
        (while (ยง read_readbuffers(true) != NUL)
            ;
        )

        (when flush_typeahead            ;; remove all typeahead
            ;; We have to get all characters, because we may delete the first part of an escape sequence.
            ;; In an xterm we get one char at a time and we have to get them all.

            (while (ยง inchar(@typebuf.tb_buf, @typebuf.tb_buflen - 1, 10, @typebuf.tb_change_cnt) != 0)
                ;
            )
            ((ร @typebuf.tb_off =) MAXMAPLEN)
            ((ร @typebuf.tb_len =) 0)
        )
    ))

;; The previous contents of the redo buffer is kept in old_redobuffer.
;; This is used for the CTRL-O <.> command in insert mode.

(defn- #_void resetRedobuff []
    (ยง
        (when (not @block_redo)
            (free_buff @old_redobuff)
            (COPY_buffheader @old_redobuff, @redobuff)
            ((ร @redobuff.bh_first.bb_next =) null)
        )
    ))

;; Discard the contents of the redo buffer and restore the previous redo buffer.

(defn- #_void cancelRedo []
    (ยง
        (when (not @block_redo)
            (free_buff @redobuff)
            (COPY_buffheader @redobuff, @old_redobuff)
            ((ร @old_redobuff.bh_first.bb_next =) null)
            (start_stuff)
            (while (ยง read_readbuffers(true) != NUL)
                ;
            )
        )
    ))

;; Append "s" to the redo buffer.
;; KB_SPECIAL should already have been escaped.

(defn- #_void appendToRedobuff [#_Bytes s]
    (ยง
        (when (not @block_redo)
            (add_buff @redobuff, s, -1)
        )
    ))

;; Append to Redo buffer literally, escaping special characters with CTRL-V.
;; KB_SPECIAL is escaped as well.

(defn- #_void appendToRedobuffLit [#_Bytes str, #_int len]
    ;; len: length of "str" or -1 for up to the NUL
    (ยง
        (if @block_redo
            (ร RETURN)
        )

; %%    ((ร FOR) (ร (ยง Bytes[] s = { str }) (if (< len 0) (!= (ยง s[0].at(0)) NUL) (< (BDIFF (ยง s[0]), str) len)) nil)
            ;; Put a string of normal characters in the redo buffer (that's faster).
            ((ร Bytes start =) (ยง s[0]))
            (while (ยง (byte \space) <= s[0].at(0) && s[0].at(0) < DEL && (len < 0 || BDIFF(s[0], str) < len))
                ((ร s[0] =) (ยง s[0].plus(1)))
            )

            ;; Don't put '0' or '^' as last character, just in case a CTRL-D is typed next.
            (if (and (== (ยง s[0].at(0)) NUL) (or (== (ยง s[0].at(-1)) (byte \0)) (== (ยง s[0].at(-1)) (byte \^))))
                ((ร s[0] =) (ยง s[0].minus(1)))
            )
            (if (BLT start, (ยง s[0]))
                (add_buff @redobuff, start, (BDIFF (ยง s[0]), start)))

            (if (or (== (ยง s[0].at(0)) NUL) (and (<= 0 len) (<= len (BDIFF (ยง s[0]), str))))
                (ร BREAK)
            )

            ;; Handle a special or multibyte character.
            ;; Handle composing chars separately.
            ((ร int c =) (us_ptr2char_adv s, false))
            (if (or (< c (byte \space)) (== c DEL) (and (== (ยง s[0].at(0)) NUL) (or (== c (byte \0)) (== c (byte \^)))))
                (add_char_buff @redobuff, Ctrl_V))

            ;; CTRL-V '0' must be inserted as CTRL-V 048
            (if (and (== (ยง s[0].at(0)) NUL) (== c (byte \0)))
                (add_buff @redobuff, (u8 "048"), 3)
                (add_char_buff @redobuff, c))
; %%    )
    ))

;; Append a character to the redo buffer.
;; Translates special keys, NUL, KB_SPECIAL and multibyte characters.

(defn- #_void appendCharToRedobuff [#_int c]
    (ยง
        (when (not @block_redo)
            (add_char_buff @redobuff, c)
        )
    ))

;; Append a number to the redo buffer.

(defn- #_void appendNumberToRedobuff [#_long n]
    (ยง
        (when (not @block_redo)
            (add_num_buff @redobuff, n)
        )
    ))

;; Append string "s" to the stuff buffer.
;; KB_SPECIAL must already have been escaped.

(defn- #_void stuffReadbuff [#_Bytes s]
    (add_buff @readbuf1, s, -1))

;; Append string "s" to the redo stuff buffer.
;; KB_SPECIAL must already have been escaped.

(defn- #_void stuffRedoReadbuff [#_Bytes s]
    (add_buff @readbuf2, s, -1))

(defn- #_void stuffReadbuffLen [#_Bytes s, #_long len]
    (add_buff @readbuf1, s, len))

;; Append a character to the stuff buffer.
;; Translates special keys, NUL, KB_SPECIAL and multibyte characters.

(defn- #_void stuffcharReadbuff [#_int c]
    (add_char_buff @readbuf1, c))

;; Append a number to the stuff buffer.

(defn- #_void stuffnumReadbuff [#_long n]
    (add_num_buff @readbuf1, n))

(atom! buffblock_C redo_bp)
(atom! Bytes redo_sp)

;; Prepare for redo; return false if nothing to redo, true otherwise.
;; If old_redo is true, use old_redobuff instead of redobuff.

(defn- #_boolean init_redo [#_boolean old_redo]
    (ยง
        (if old_redo
            (reset! redo_bp (.. @old_redobuff bh_first bb_next))
            (reset! redo_bp (.. @redobuff bh_first bb_next)))
        (if (nil? @redo_bp)
            ((ร RETURN) false)
        )

        (reset! redo_sp (. @redo_bp bb_str))
        true
    ))

;; Read a character from the redo buffer.
;; Translates KB_SPECIAL and multibyte characters.
;; The redo buffer is left as it is.

(defn- #_int read_redo []
    (ยง
        (when (non-eos? @redo_sp)
            ;; For a multi-byte character get all the bytes and return the converted character.
            (ร int n)
            (if (or (!= (.at @redo_sp 0) KB_SPECIAL) (== (.at @redo_sp 1) KS_SPECIAL))
                ((ร n =) (ยง mb_byte2len(char_u(@redo_sp.at(0)))))
                ((ร n =) 1)
            )

            ((ร Bytes buf =) (ยง new Bytes(MB_MAXBYTES + 1)))

            ((ร FOR) (ร (ยง int i = 0) true (ยง i++))
                (ร int c)
                (cond (== (.at @redo_sp 0) KB_SPECIAL)   ;; special key or escaped KB_SPECIAL
                (ยง
                    ((ร c =) (ยง toSpecial(@redo_sp.at(1), @redo_sp.at(2))))
                    (reset! redo_sp (.plus @redo_sp 3))
                )
                :else
                (ยง
                    ((ร c =) (ยง char_u(@redo_sp.at(0))))
                    (reset! redo_sp (.plus @redo_sp 1))
                ))

                (when (and (eos? @redo_sp) (!= (. @redo_bp bb_next) null))
                    (reset! redo_bp (. @redo_bp bb_next))
                    (reset! redo_sp (. @redo_bp bb_str))
                )

                (.be buf i, c)
                (when (== i (- n 1))                 ;; last byte of a character
                    (if (!= n 1)
                        ((ร c =) (us_ptr2char buf))
                    )
                    ((ร RETURN) c)
                )

                (if (== (ยง @redo_sp.at(0)) NUL)          ;; cannot happen?
                    (ร BREAK)
                )
            )
        )

        NUL
    ))

;; Stuff the redo buffer into readbuf2.
;; Insert the redo count into the command.
;; If "old_redo" is true, the last but one command is repeated
;; instead of the last command (inserting text).
;; This is used for CTRL-O <.> in insert mode.
;;
;; Return false for failure, true otherwise.

(defn- #_boolean start_redo [#_long count, #_boolean old_redo]
    (ยง
        ;; init the pointers; return if nothing to redo
        (if (not (init_redo old_redo))
            ((ร RETURN) false)
        )

        ((ร int c =) (read_redo))

        ;; copy the buffer name, if present
        (when (== c (byte \"))
            (add_buff @readbuf2, (u8 "\""), 1)
            ((ร c =) (read_redo))

            ;; if a numbered buffer is used, increment the number
            (if (and (<= (byte \1) c) (< c (byte \9)))
                (ยง c++)
            )
            (add_char_buff @readbuf2, c)
            ((ร c =) (read_redo))
        )

        (when (== c (byte \v))   ;; redo Visual
            (COPY_pos @VIsual, (. @curwin w_cursor))
            (reset! VIsual_active true)
            (reset! VIsual_select false)
            (reset! VIsual_reselect true)
            (reset! redo_VIsual_busy true)
            ((ร c =) (read_redo))
        )

        ;; try to enter the count (in place of a previous count)
        (when (non-zero? count)
            (while (asc_isdigit c)  ;; skip "old" count
                ((ร c =) (read_redo))
            )
            (add_num_buff @readbuf2, count)
        )

        ;; copy from the redo buffer into the stuff buffer
        (add_char_buff @readbuf2, c)
        (while (ยง (c = read_redo()) != NUL)
            (add_char_buff @readbuf2, c)
        )

        true
    ))

;; Repeat the last insert (R, o, O, a, A, i or I command) by stuffing the redo buffer into readbuf2.
;; Return false for failure, true otherwise.

(defn- #_boolean start_redo_ins []
    (ยง
        (if (not (init_redo false))
            ((ร RETURN) false)
        )

        (start_stuff)

        ;; skip the count and the command character
        ((ร FOR) (ร (ยง int c) (ยง (c = read_redo()) != NUL) nil)
            (when (non-nil? (vim_strchr (u8 "AaIiRrOo"), c))
                (if (or (== c (byte \O)) (== c (byte \o)))
                    (add_buff @readbuf2, NL_STR, -1))
                (ร BREAK)
            )
        )

        ;; copy the typed text from the redo buffer into the stuff buffer
        ((ร FOR) (ร (ยง int c) (ยง (c = read_redo()) != NUL) nil)
            (add_char_buff @readbuf2, c)
        )

        (reset! block_redo true)
        true
    ))

(defn- #_void stop_redo_ins []
    (reset! block_redo false))

(final int TYPELEN_INIT    (* 5 (+ MAXMAPLEN 3)))

;; Initialize typebuf.

(defn- #_void init_typebuf []
    (ยง
        (when (nil? (. @typebuf tb_buf))
            ((ร @typebuf.tb_buf =) (ยง (Bytes. TYPELEN_INIT)))
            ((ร @typebuf.tb_buflen =) TYPELEN_INIT)
            ((ร @typebuf.tb_len =) 0)
            ((ร @typebuf.tb_off =) 0)
            ((ร @typebuf.tb_change_cnt =) 1)
        )
    ))

;; Insert a string in the typeahead buffer.

(defn- #_void ins_typebuf [#_Bytes str]
    (ยง
        (init_typebuf)
        (if (zero? (ยง ++@typebuf.tb_change_cnt))
            ((ร @typebuf.tb_change_cnt =) 1)
        )

        ((ร int addlen =) (STRLEN str))

        ;; Easy case: there is room in front of typebuf.tb_buf[typebuf.tb_off]

        (cond (<= addlen (. @typebuf tb_off))
        (ยง
            ((ร @typebuf.tb_off -=) addlen)
            (BCOPY (. @typebuf tb_buf), (. @typebuf tb_off), str, 0, addlen)
        )
        :else
        (ยง
            ;; Need to allocate a new buffer.
            ;; In typebuf.tb_buf there must always be room for 3 * MAXMAPLEN + 4 characters.
            ;; We add some extra room to avoid having to allocate too often.

            ((ร int newoff =) (+ MAXMAPLEN 4))
            ((ร int newlen =) (ยง @typebuf.tb_len + addlen + newoff + 4 * (MAXMAPLEN + 4)))

            ((ร Bytes newbuf =) (ยง new Bytes(newlen)))
            ((ร @typebuf.tb_buflen =) newlen)

            ;; copy the new chars
            (BCOPY newbuf, newoff, str, 0, addlen)
            ;; copy the old chars, after the insertion point, including the NUL at the end
            (BCOPY newbuf, (+ newoff addlen), (. @typebuf tb_buf), (. @typebuf tb_off), (+ (. @typebuf tb_len) 1))

            ((ร @typebuf.tb_buf =) newbuf)
            ((ร @typebuf.tb_off =) newoff)
        ))

        ((ร @typebuf.tb_len +=) addlen)
    ))

;; Put character "c" back into the typeahead buffer.
;; Can be used for a character obtained by vgetc() that needs to be put back.
;; Uses keyTyped to restore the flags belonging to the char.

(defn- #_void ins_char_typebuf [#_int c]
    (ยง
        ((ร Bytes buf =) (ยง new Bytes(MB_MAXBYTES + 1)))

        (cond (is_special c)
        (ยง
            (.be buf 0, KB_SPECIAL)
            (.be buf 1, (KB_SECOND c))
            (.be buf 2, (KB_THIRD c))
            (.be buf 3, NUL)
        )
        :else
        (ยง
            (ยง buf.be(utf_char2bytes(c, buf), NUL))
        ))

        (ins_typebuf buf)
    ))

;; Return true if the typeahead buffer was changed (while waiting for a character to arrive).
;; Happens when a message was received from a client or from feedkeys().
;; But check in a more generic way to avoid trouble: When "typebuf.tb_buf"
;; changed it was reallocated and the old pointer can no longer be used.
;; Or "typebuf.tb_off" may have been changed and we would overwrite characters that was just added.

(defn- #_boolean typebuf_changed [#_int tb_change_cnt]
    ;; tb_change_cnt: old value of typebuf.tb_change_cnt
    (ยง
        (and (non-zero? tb_change_cnt) (!= (. @typebuf tb_change_cnt) tb_change_cnt))
    ))

;; remove "len" characters from typebuf.tb_buf[typebuf.tb_off]

(defn- #_void del_typebuf [#_int len]
    (ยง
        (if (zero? len)
            (ร RETURN)         ;; nothing to do
        )

        ((ร @typebuf.tb_len -=) len)

        (cond (ยง 3 * MAXMAPLEN + 3 <= @typebuf.tb_buflen - (@typebuf.tb_off + len))
        (ยง
            ((ร @typebuf.tb_off +=) len)
        )
        :else
        (ยง
            ((ร int i =) (. @typebuf tb_off))

            ;; Leave some extra room at the end to avoid reallocation.

            (if (< MAXMAPLEN (. @typebuf tb_off))
                ((ร @typebuf.tb_off =) MAXMAPLEN)
            )

            ;; adjust typebuf.tb_buf (include the NUL at the end)
            (BCOPY (. @typebuf tb_buf), (. @typebuf tb_off), (. @typebuf tb_buf), (+ i len), (+ (. @typebuf tb_len) 1))
        ))

        (when (zero? (ยง ++@typebuf.tb_change_cnt))
            ((ร @typebuf.tb_change_cnt =) 1)
        )
    ))

;; Write typed characters to script file.
;; If recording is on put the character in the recordbuffer.

(defn- #_void gotchars [#_Bytes chars, #_int len]
    (ยง
        ((ร Bytes buf =) (ยง new Bytes(2)))

        ;; Remember how many chars were last recorded.
        (if @Recording
            ((ร @last_recorded_len +=) len)
        )

        ((ร FOR) (ร (ยง int i = 0) (< i len) (ยง i++))
            ;; Handle one byte at a time; no translation to be done.
            ((ร byte c =) (ยง chars.at(i)))
            (updatescript c)

            (when @Recording
                (.be buf 0, c)
                (add_buff @recordbuff, buf, 1)
            )
        )
        (may_sync_undo)

        ;; Since characters have been typed, consider the following to be in another mapping.
        ;; Search string will be kept in history.
        (swap! maptick inc)
    ))

;; Sync undo.  Called when typed characters are obtained from the typeahead
;; buffer, or when a menu is used.
;; Do not sync:
;; - In Insert mode, unless cursor key has been used.
;; - While reading a script file.
;; - When no_u_sync is non-zero.

(defn- #_void may_sync_undo []
    (ยง
        (when (or (zero? (ยง @State & (INSERT + CMDLINE))) @arrow_used)
            (u_sync false)
        )
    ))

(atom! int old_char         -1) ;; character put back by vungetc()
(atom! int old_mod_mask)        ;; mod_mask for ungotten character

;; This function is called just before doing a blocking wait.
;; Thus after waiting 'updatetime' for a character to arrive.

(defn- #_void before_blocking []
    (updatescript NUL))

;; updatescipt() is called when a character can be written into the script file
;; or when we have waited some time for a character (c == 0)

(defn- #_void updatescript [#_byte c]
    (ยง
;       
    ))

;; Get the next input character.
;; Can return a special key or a multi-byte character.
;; Can return NUL when called recursively, use safe_vgetc() if that's not wanted.
;; This translates escaped KB_SPECIAL bytes to a KB_SPECIAL byte.
;; Collects the bytes of a multibyte character into the whole character.
;; Returns the modifiers in the global "mod_mask".

(defn- #_int vgetc []
    (ยง
        (ร int c)

        ;; If a character was put back with vungetc, it was already processed.
        ;; Return it directly.

        (cond (!= @old_char -1)
        (ยง
            ((ร c =) @old_char)
            (reset! old_char -1)
            (reset! mod_mask @old_mod_mask)
        )
        :else
        (ยง
            ((ร Bytes buf =) (ยง new Bytes(MB_MAXBYTES + 1)))

            (reset! mod_mask 0)
            (reset! last_recorded_len 0)

            (while true                     ;; this is done twice if there are modifiers
                (when (non-zero? @mod_mask)          ;; no mapping after modifier has been read
                    (swap! no_mapping inc)
                    (swap! allow_keys inc)
                )
                ((ร c =) (vgetorpeek true))
                (when (non-zero? @mod_mask)
                    (swap! no_mapping dec)
                    (swap! allow_keys dec)
                )

                ;; Get two extra bytes for special keys.
                (when (== c (char_u KB_SPECIAL))
                    ((ร int save_allow_keys =) @allow_keys)

                    (swap! no_mapping inc)
                    (reset! allow_keys 0)                 ;; make sure BS is not found
                    ((ร int c2 =) (vgetorpeek true))      ;; no mapping for these chars
                    ((ร c =) (vgetorpeek true))
                    (swap! no_mapping dec)
                    (reset! allow_keys save_allow_keys)

                    (when (== c2 (char_u KS_MODIFIER))
                        (reset! mod_mask c)
                        (ร CONTINUE)
                    )
                    ((ร c =) (ยง toSpecial((byte)c2, (byte)c)))
                )

                ;; a keypad or special function key was not mapped, use it like its ASCII equivalent
                ((ร SWITCH) c
                    ((ร CASE) K_KPLUS)
                    (ยง
                        ((ร c =) (byte \+))
                        (ร BREAK)
                    )
                    ((ร CASE) K_KMINUS)
                    (ยง
                        ((ร c =) (byte \-))
                        (ร BREAK)
                    )
                    ((ร CASE) K_KDIVIDE)
                    (ยง
                        ((ร c =) (byte \/))
                        (ร BREAK)
                    )
                    ((ร CASE) K_KMULTIPLY)
                    (ยง
                        ((ร c =) (byte \*))
                        (ร BREAK)
                    )
                    ((ร CASE) K_KENTER)
                    (ยง
                        ((ร c =) CAR)
                        (ร BREAK)
                    )
                    ((ร CASE) K_KPOINT)
                    (ยง
                        ((ร c =) (byte \.))
                        (ร BREAK)
                    )
                    ((ร CASE) K_K0)
                    (ยง
                        ((ร c =) (byte \0))
                        (ร BREAK)
                    )
                    ((ร CASE) K_K1)
                    (ยง
                        ((ร c =) (byte \1))
                        (ร BREAK)
                    )
                    ((ร CASE) K_K2)
                    (ยง
                        ((ร c =) (byte \2))
                        (ร BREAK)
                    )
                    ((ร CASE) K_K3)
                    (ยง
                        ((ร c =) (byte \3))
                        (ร BREAK)
                    )
                    ((ร CASE) K_K4)
                    (ยง
                        ((ร c =) (byte \4))
                        (ร BREAK)
                    )
                    ((ร CASE) K_K5)
                    (ยง
                        ((ร c =) (byte \5))
                        (ร BREAK)
                    )
                    ((ร CASE) K_K6)
                    (ยง
                        ((ร c =) (byte \6))
                        (ร BREAK)
                    )
                    ((ร CASE) K_K7)
                    (ยง
                        ((ร c =) (byte \7))
                        (ร BREAK)
                    )
                    ((ร CASE) K_K8)
                    (ยง
                        ((ร c =) (byte \8))
                        (ร BREAK)
                    )
                    ((ร CASE) K_K9)
                    (ยง
                        ((ร c =) (byte \9))
                        (ร BREAK)
                    )

                    ((ร CASE) K_XHOME)
                    ((ร CASE) K_ZHOME)
                    (ยง
                        (cond (== @mod_mask MOD_MASK_SHIFT)
                        (ยง
                            ((ร c =) K_S_HOME)
                            (reset! mod_mask 0)
                        )
                        (== @mod_mask MOD_MASK_CTRL)
                        (ยง
                            ((ร c =) K_C_HOME)
                            (reset! mod_mask 0)
                        )
                        :else
                        (ยง
                            ((ร c =) K_HOME)
                        ))
                        (ร BREAK)
                    )
                    ((ร CASE) K_XEND)
                    ((ร CASE) K_ZEND)
                    (ยง
                        (cond (== @mod_mask MOD_MASK_SHIFT)
                        (ยง
                            ((ร c =) K_S_END)
                            (reset! mod_mask 0)
                        )
                        (== @mod_mask MOD_MASK_CTRL)
                        (ยง
                            ((ร c =) K_C_END)
                            (reset! mod_mask 0)
                        )
                        :else
                        (ยง
                            ((ร c =) K_END)
                        ))
                        (ร BREAK)
                    )

                    ((ร CASE) K_XUP)
                    (ยง
                        ((ร c =) K_UP)
                        (ร BREAK)
                    )
                    ((ร CASE) K_XDOWN)
                    (ยง
                        ((ร c =) K_DOWN)
                        (ร BREAK)
                    )
                    ((ร CASE) K_XLEFT)
                    (ยง
                        ((ร c =) K_LEFT)
                        (ร BREAK)
                    )
                    ((ร CASE) K_XRIGHT)
                    (ยง
                        ((ร c =) K_RIGHT)
                        (ร BREAK)
                    )
                )

                ;; For a multi-byte character get all the bytes and return the converted character.
                ;; Note: This will loop until enough bytes are received!

                ((ร int n =) (mb_byte2len c))
                (when (< 1 n)
                    (swap! no_mapping inc)
                    (.be buf 0, c)
                    ((ร FOR) (ร (ยง int i = 1) (< i n) (ยง i++))
                        (.be buf i, (vgetorpeek true))
                        (when (== (.at buf i) KB_SPECIAL)
                            ;; Must be a KB_SPECIAL - KS_SPECIAL - KE_FILLER sequence,
                            ;; which represents a KB_SPECIAL (0x80).
                            ((ร c =) (vgetorpeek true))
                        )
                    )
                    (swap! no_mapping dec)
                    ((ร c =) (us_ptr2char buf))
                )

                (ร BREAK)
            )
        ))

        c
    ))

;; Like vgetc(), but never return a NUL when called recursively,
;; get a key directly from the user (ignoring typeahead).

(defn- #_int safe_vgetc []
    (ยง
        ((ร int c =) (vgetc))
        (if (== c NUL)
            ((ร c =) (get_keystroke))
        )
        c
    ))

;; Like safe_vgetc(), but loop to handle K_IGNORE.
;; Also ignore scrollbar events.

(defn- #_int plain_vgetc []
    (ยง
        (ร int c)

;       do
;       {
            ((ร c =) (safe_vgetc))
;       } while (c == K_IGNORE || c == K_VER_SCROLLBAR || c == K_HOR_SCROLLBAR);

        c
    ))

;; Check if a character is available, such that vgetc() will not block.
;; If the next character is a special character or multi-byte, the returned character is not valid!

(defn- #_int vpeekc []
    (ยง
        (if (!= @old_char -1)
            ((ร RETURN) @old_char)
        )

        (vgetorpeek false)
    ))

;; Call vpeekc() without causing anything to be mapped.
;; Return true if a character is available, false otherwise.

(defn- #_boolean char_avail []
    (ยง
        (ร int retval)

        (swap! no_mapping inc)
        ((ร retval =) (vpeekc))
        (swap! no_mapping dec)

        (!= retval NUL)
    ))

;; unget one character (can only be done once!)
(defn- #_void vungetc [#_int c]
    (ยง
        (reset! old_char c)
        (reset! old_mod_mask @mod_mask)
    ))

(atom! int __tc)

;; get a character:
;; 1. from the stuffbuffer
;;      This is used for abbreviated commands like "D" -> "d$".
;;      Also used to redo a command for ".".
;; 2. from the typeahead buffer
;;      Stores text obtained previously but not used yet.
;;      Also stores the result of mappings.
;;      Also used for the ":normal" command.
;; 3. from the user
;;      This may do a blocking wait if "advance" is true.
;;
;; if "advance" is true (vgetc()):
;;      really get the character.
;;      keyTyped is set to true in the case the user typed the key.
;;      keyStuffed is true if the character comes from the stuff buffer.
;; if "advance" is false (vpeekc()):
;;      just look whether there is a character available.
;;
;; When "no_mapping" is zero, checks for mappings in the current mode.
;; Only returns one byte (of a multi-byte character).
;; KB_SPECIAL may be escaped, need to get two more bytes then.

(defn- #_int vgetorpeek [#_boolean advance]
    (ยง
        ;; This function doesn't work very well when called recursively.
        ;; It may happen though, because of:
        ;;
        ;; 1. The call to add_to_showcmd(). char_avail() is then used to check
        ;; if there is a character available, which calls this function.
        ;; In that case we must return NUL, to indicate no character is available.
        ;;
        ;; 2. A GUI callback function writes to the screen, causing a wait_return().
        ;; Using ":normal" can also do this, but it saves the typeahead buffer,
        ;; thus it should be OK.  But don't get a key from the user then.

        (if (< 0 @vgetc_busy)
            ((ร RETURN) NUL)
        )

        (swap! vgetc_busy inc)

        (if advance
            (reset! keyStuffed false))

        (init_typebuf)
        (start_stuff)
        (if advance
            (reset! execReg false))

        ((ร boolean timedout =) false)       ;; waited for more than 1 second for mapping to complete
        ((ร int mapdepth =) 0)               ;; check for recursive mapping
        ((ร boolean mode_deleted =) false)   ;; set when mode has been deleted

        (ร int c)

;       do
;       {
;; get a character: 1. from the stuffbuffer

            (cond (non-zero? @typeahead_char)
            (ยง
                ((ร c =) @typeahead_char)
                (if advance
                    (reset! typeahead_char 0))
            )
            :else
            (ยง
                ((ร c =) (ยง char_u(read_readbuffers(advance))))
            ))

            (cond (and (!= c NUL) (not @got_int))
            (ยง
                (when advance
                    ;; keyTyped = false;
                    ;; When the command that stuffed something was typed,
                    ;; behave like the stuffed command was typed;
                    ;; needed e.g. for CTRL-W CTRl-] to open a fold.
                    (reset! keyStuffed true)
                )
            )
            :else
            (ยง
                ;; Loop until we either find a matching mapped key,
                ;; or we are sure that it is not a mapped key.
                ;; If a mapped key sequence is found, we go back to the start to try re-mapping.

                (while true
                    (ui_breakcheck)            ;; check for CTRL-C

                    (when @got_int
                        ;; flush all input
                        ((ร int len =) (ยง inchar(@typebuf.tb_buf, @typebuf.tb_buflen - 1, 0, @typebuf.tb_change_cnt)))

                        ;; If inchar() returns true (script file was active)
                        ;; or we are inside a mapping, get out of insert mode.
                        ;; Otherwise we behave like having gotten a CTRL-C.
                        ;; As a result typing CTRL-C in insert mode will really insert a CTRL-C.

                        (if (and (non-zero? len) (non-zero? (ยง @State & (INSERT + CMDLINE))))
                            ((ร c =) ESC)
                            ((ร c =) Ctrl_C)
                        )

                        (flush_buffers true)        ;; flush all typeahead

                        (when advance
                            ;; Also record this character, it might be needed to get out of Insert mode.
                            (.be (. @typebuf tb_buf) 0, c)
                            (gotchars (. @typebuf tb_buf), 1)
                        )

                        (ร BREAK)
                    )

                    ((ร int keylen =) 0)

                    (when (< 0 (. @typebuf tb_len))
                        ;; When no matching mapping found or found a non-matching mapping
                        ;; that matches at least what the matching mapping matched:
                        ;; Check if we have a terminal code, when:
                        ;; - mapping is allowed,
                        ;; - keys have not been mapped,
                        ;; - and when not timed out.

                        (when (and (or (zero? @no_mapping) (non-zero? @allow_keys)) (not timedout))
                            ((ร keylen =) (check_termcode null, 0, null))

                            ;; When getting a partial match, but the last characters were not typed,
                            ;; don't wait for a typed character to complete the termcode.
                            ;; This helps a lot when a ":normal" command ends in an ESC.

                            (if (and (< keylen 0) (zero? (. @typebuf tb_len)))
                                ((ร keylen =) 0)
                            )
                        )

                        (when (zero? keylen)        ;; no matching terminal code
;; get a character: 2. from the typeahead buffer

                            ((ร c =) (ยง @typebuf.tb_buf.at(@typebuf.tb_off) & 0xff))
                            (when advance    ;; remove chars from tb_buf
                                (reset! keyTyped true)
                                ;; write char to script file(s)
                                (gotchars (.plus (. @typebuf tb_buf) (. @typebuf tb_off)), 1)

                                (del_typebuf 1)
                            )
                            (ร BREAK)          ;; got character, break for loop
                        )

                        (when (< 0 keylen)         ;; full matching terminal code
                            (ร CONTINUE)           ;; try mapping again
                        )

                        ;; Partial match: get some more characters.
                        ((ร keylen =) KEYLEN_PART_KEY)
                    )

;; get a character: 3. from the user - handle <Esc> in Insert mode

                    ;; Special case: if we get an <ESC> in insert mode and there are no more
                    ;; characters at once, we pretend to go out of insert mode.  This prevents
                    ;; the one second delay after typing an <ESC>.  If we get something after
                    ;; all, we may have to redisplay the mode.  That the cursor is in the wrong
                    ;; place does not matter.

                    ((ร int len =) 0)
                    ((ร int new_wcol =) (. @curwin w_wcol))
                    ((ร int new_wrow =) (. @curwin w_wrow))
                    (when (ยง advance && @typebuf.tb_len == 1 && @typebuf.tb_buf.at(@typebuf.tb_off) == ESC && @no_mapping == 0 && (@State & INSERT) != 0 && (@p_timeout || (keylen == KEYLEN_PART_KEY && @p_ttimeout)) && (len = inchar(@typebuf.tb_buf.plus(@typebuf.tb_off + @typebuf.tb_len), 3, 25, @typebuf.tb_change_cnt)) == 0)
                        (when @mode_displayed
                            (unshowmode true)
                            ((ร mode_deleted =) true)
                        )
                        (validate_cursor)
                        ((ร int old_wcol =) (. @curwin w_wcol))
                        ((ร int old_wrow =) (. @curwin w_wrow))

                        ;; move cursor left, if possible
                        (when (!= (.. @curwin w_cursor col) 0)
                            ((ร int col =) 0)
                            (cond (< 0 (. @curwin w_wcol))
                            (ยง
                                (cond @did_ai
                                (ยง
                                    ;; We are expecting to truncate the trailing white-space,
                                    ;; so find the last non-white character.

                                    ((ร col =) (ยง @curwin.w_wcol = 0))
                                    ((ร Bytes ptr =) (ml_get_curline))
                                    ((ร FOR) (ร (ยง int vcol = col) (ยง col < @curwin.w_cursor.col) nil)
                                        (if (not (vim_iswhite (ยง ptr.at(col))))
                                            ((ร @curwin.w_wcol =) vcol)
                                        )
                                        ((ร vcol +=) (ยง lbr_chartabsize(ptr, ptr.plus(col), vcol)))
                                        ((ร col +=) (ยง us_ptr2len_cc(ptr.plus(col))))
                                    )
                                    ((ร @curwin.w_wrow =) (ยง @curwin.w_cline_row + @curwin.w_wcol / @curwin.w_width))
                                    ((ร @curwin.w_wcol %=) (. @curwin w_width))
                                    ((ร @curwin.w_wcol +=) (curwin_col_off))
                                    ((ร col =) 0)        ;; no correction needed
                                )
                                :else
                                (ยง
                                    (ยง --@curwin.w_wcol)
                                    ((ร col =) (ยง @curwin.w_cursor.col - 1))
                                ))
                            )
                            (and @(.. @curwin w_options wo_wrap) (< 0 (. @curwin w_wrow)))
                            (ยง
                                (ยง --@curwin.w_wrow)
                                ((ร @curwin.w_wcol =) (ยง @curwin.w_width - 1))
                                ((ร col =) (ยง @curwin.w_cursor.col - 1))
                            ))

                            (when (and (< 0 col) (< 0 (. @curwin w_wcol)))
                                ;; Correct when the cursor is on the right halve of a double-wide character.
                                ((ร Bytes p =) (ml_get_curline))
                                ((ร col -=) (ยง us_head_off(p, p.plus(col))))
                                (if (< 1 (us_ptr2cells (ยง p.plus(col))))
                                    (ยง --@curwin.w_wcol)
                                )
                            )
                        )
                        (setcursor)
                        (out_flush)
                        ((ร new_wcol =) (. @curwin w_wcol))
                        ((ร new_wrow =) (. @curwin w_wrow))
                        ((ร @curwin.w_wcol =) old_wcol)
                        ((ร @curwin.w_wrow =) old_wrow)
                    )
                    (if (< len 0)
                        (ร CONTINUE)   ;; end of input script reached
                    )

                    ((ร @typebuf.tb_len +=) len)

                    ;; buffer full, don't map
                    (when (<= MAXMAPLEN (. @typebuf tb_len))
                        ((ร timedout =) true)
                        (ร CONTINUE)
                    )

;; get a character: 3. from the user - update display

                    ;; In insert mode a screen update is skipped when characters are still available.
                    ;; But when those available characters are part of a mapping, and we are going
                    ;; to do a blocking wait here.  Need to update the screen to display the changed
                    ;; text so far.  Also for when 'lazyredraw' is set and redrawing was postponed
                    ;; because there was something in the input buffer (e.g., termresponse).

                    (when (and (or (non-zero? (& @State INSERT)) @p_lz) (zero? (& @State CMDLINE)) advance (non-zero? @must_redraw) (not @need_wait_return))
                        (update_screen 0)
                        (setcursor)            ;; put cursor back where it belongs
                    )

                    ;; If we have a partial match (and are going to wait for more input from the user),
                    ;; show the partially matched characters to the user with showcmd.

                    ((ร int i =) 0)
                    ((ร int c1 =) 0)
                    (when (and (< 0 (. @typebuf tb_len)) advance)
                        (when (and (non-zero? (ยง @State & (NORMAL | INSERT))) (!= @State HITRETURN))
                            ;; this looks nice when typing a dead character map
                            (when (and (non-zero? (& @State INSERT)) (== (mb_ptr2cells (.plus (. @typebuf tb_buf) (- (+ (. @typebuf tb_off) (. @typebuf tb_len)) 1))) 1))
                                (edit_putchar (.at (. @typebuf tb_buf) (- (+ (. @typebuf tb_off) (. @typebuf tb_len)) 1)), false)
                                (setcursor)    ;; put cursor back where it belongs
                                ((ร c1 =) 1)
                            )
                            ;; need to use the col and row from above here
                            ((ร int old_wcol =) (. @curwin w_wcol))
                            ((ร int old_wrow =) (. @curwin w_wrow))
                            ((ร @curwin.w_wcol =) new_wcol)
                            ((ร @curwin.w_wrow =) new_wrow)
                            (push_showcmd)
                            (if (< SHOWCMD_COLS (. @typebuf tb_len))
                                ((ร i =) (ยง @typebuf.tb_len - SHOWCMD_COLS))
                            )
                            ((ร FOR) (ร (ยง  ) (ยง i < @typebuf.tb_len) (ยง i++))
                                (add_to_showcmd (ยง @typebuf.tb_buf.at(@typebuf.tb_off + i)))
                            )
                            ((ร @curwin.w_wcol =) old_wcol)
                            ((ร @curwin.w_wrow =) old_wrow)
                        )

                        ;; this looks nice when typing a dead character map
                        (when (and (non-zero? (& @State CMDLINE)) (zero? @cmdline_star) (== (mb_ptr2cells (.plus (. @typebuf tb_buf) (- (+ (. @typebuf tb_off) (. @typebuf tb_len)) 1))) 1))
                            (putcmdline (.at (. @typebuf tb_buf) (- (+ (@typebuf.tb_off) (@typebuf.tb_len)) 1)), false)
                            ((ร c1 =) 1)
                        )
                    )

;; get a character: 3. from the user - get it

                    ((ร int wait_tb_len =) (. @typebuf tb_len))
                    ((ร len =) (inchar (.plus (. @typebuf tb_buf) (+ (. @typebuf tb_off) (. @typebuf tb_len))), (- (. @typebuf tb_buflen) (. @typebuf tb_off) (. @typebuf tb_len) 1), (if (not advance) 0 (if (or (== (. @typebuf tb_len) 0) (not (or @p_timeout (and @p_ttimeout (== keylen KEYLEN_PART_KEY))))) -1 (if (and (== keylen KEYLEN_PART_KEY) (<= 0 @p_ttm)) @p_ttm @p_tm))), (. @typebuf tb_change_cnt)))

                    (if (non-zero? i)
                        (pop_showcmd))
                    (when (== c1 1)
                        (if (non-zero? (& @State INSERT))
                            (edit_unputchar))
                        (if (non-zero? (& @State CMDLINE))
                            (unputcmdline)
                            (setcursor))            ;; put cursor back where it belongs
                    )

                    (if (< len 0)
                        (ร CONTINUE)                   ;; end of input script reached
                    )
                    (cond (zero? len)                   ;; no character available
                    (ยง
                        (when (not advance)
                            ((ร c =) NUL)
                            (ร BREAK)
                        )
                        (when (< 0 wait_tb_len)        ;; timed out
                            ((ร timedout =) true)
                            (ร CONTINUE)
                        )
                    )
                    :else
                    (ยง
                        (while (ยง @typebuf.tb_buf.at(@typebuf.tb_off + @typebuf.tb_len) != NUL)
                            (ยง @typebuf.tb_len++)
                        )
                    ))
                )
            ))
;       } while (c < 0 || (advance && c == NUL));   ;; if advance is false don't loop on NULs

        ;; The "INSERT" message is taken care of here:
        ;;   if we return an ESC to exit insert mode, the message is deleted;
        ;;   if we don't return an ESC, but deleted the message before, redisplay it.

        (when (and advance @p_smd (non-zero? (& @State INSERT)))
            (cond (and (== c ESC) (not mode_deleted) (zero? @no_mapping) @mode_displayed)
            (ยง
                (if (and (!= (. @typebuf tb_len) 0) (not @keyTyped))
                    (reset! redraw_cmdline true)          ;; delete mode later
                    (unshowmode false))
            )
            (and (!= c ESC) mode_deleted)
            (ยง
                (if (and (!= (. @typebuf tb_len) 0) (not @keyTyped))
                    (reset! redraw_cmdline true)          ;; show mode later
                    (showmode))
            ))
        )

        (swap! vgetc_busy dec)

        c
    ))

;; inchar() - get one character from
;;      1. a scriptfile
;;      2. the keyboard
;;
;; As much characters as we can get (upto 'maxlen') are put in "buf" and
;; NUL terminated (buffer length must be 'maxlen' + 1).
;; Minimum for "maxlen" is 3!!!!
;;
;; "tb_change_cnt" is the value of typebuf.tb_change_cnt if "buf" points into it.
;; When typebuf.tb_change_cnt changes (e.g., when a message is received from
;; a remote client) "buf" can no longer be used.  "tb_change_cnt" is 0 otherwise.
;;
;; If we got an interrupt all input is read until none is available.
;;
;; If wait_time == 0  there is no waiting for the char.
;; If wait_time == n  we wait for n msec for a character to arrive.
;; If wait_time == -1 we wait forever for a character to arrive.
;;
;; Return the number of obtained characters.
;; Return -1 when end of input script reached.

(defn- #_int inchar [#_Bytes buf, #_int maxlen, #_long wait_time, #_int tb_change_cnt]
    ;; wait_time: milli seconds
    (ยง
        (when (or (== wait_time -1) (< 100 wait_time))   ;; flush output before waiting
            (cursor_on)
            (out_flush)
        )

        ((ร int len =) 0)
        ((ร boolean retesc =) false)                     ;; return ESC with gotint

        ;; If we got an interrupt, skip all previously typed characters
        ;; and return true if quit reading script file.
        ;; Stop reading typeahead when a single CTRL-C was read,
        ;; fill_input_buf() returns this when not able to read from stdin.
        ;; Don't use *buf here, closescript() may have freed typebuf.tb_buf[]
        ;; and "buf" may be pointing inside typebuf.tb_buf[].

        (when @got_int
            ((ร final int DUM_LEN =) (ยง MAXMAPLEN * 3 + 3))
            ((ร Bytes dum =) (ยง new Bytes(DUM_LEN + 1)))

            (while true
                ((ร len =) (ui_inchar dum, DUM_LEN, 0, 0))
                (if (or (zero? len) (and (== len 1) (== (.at dum 0) 3)))
                    (ร BREAK)
                )
            )
            ((ร RETURN) (if retesc 1 0))
        )

        ;; Always flush the output characters when getting input characters from the user.

        (out_flush)

        ;; Fill up to a third of the buffer, because each character may be tripled below.

        ((ร len =) (ยง ui_inchar(buf, maxlen / 3, wait_time, tb_change_cnt)))

        (if (typebuf_changed tb_change_cnt)
            ((ร RETURN) 0)
        )

        (fix_input_buffer buf, len)
    ))

;; Fix typed characters for use by vgetc() and check_termcode().
;; buf[] must have room to triple the number of bytes!
;; Returns the new length.

(defn- #_int fix_input_buffer [#_Bytes buf, #_int len]
    (ยง
        ;; Two characters are special: NUL and KB_SPECIAL.
        ;; Replace        NUL by KB_SPECIAL KS_ZERO    KE_FILLER
        ;; Replace KB_SPECIAL by KB_SPECIAL KS_SPECIAL KE_FILLER

        ((ร Bytes p =) buf)
        ((ร FOR) (ร (ยง int i = len) (ยง 0 <= --i) (ยง p = p.plus(1)))
            ;; timeout may generate K_CURSORHOLD
            (when (or (eos? p) (and (== (.at p 0) KB_SPECIAL) (or (< i 2) (!= (.at p 1) KS_EXTRA) (!= (.at p 2) KE_CURSORHOLD))))
                (BCOPY p, 3, p, 1, i)
                (.be p 2, (ยง KB_THIRD(char_u(p.at(0)))))
                (.be p 1, (ยง KB_SECOND(char_u(p.at(0)))))
                (.be p 0, KB_SPECIAL)
                ((ร p =) (ยง p.plus(2)))
                ((ร len +=) 2)
            )
        )
        (.be p 0, NUL)           ;; add trailing NUL

        len
    ))

;; Return true when bytes are in the input buffer or in the typeahead buffer.

(defn- #_boolean input_available []
    (not (is_input_buf_empty)))

;; Escape KB_SPECIAL so that the result can be put in the typeahead buffer.

(defn- #_Bytes vim_strsave_escape_special [#_Bytes p]
    (ยง
        ;; Need a buffer to hold up to three times as much.
        ((ร Bytes res =) (ยง new Bytes(STRLEN(p) * 3 + 1)))

        ((ร Bytes d =) res)
        ((ร FOR) (ร (ยง Bytes s = p) (ยง s.at(0) != NUL) nil)
            (cond (and (== (.at s 0) KB_SPECIAL) (non-eos? s 1) (non-eos? s 2))
            (ยง
                ;; Copy special key unmodified.
                (ยง (d = d.plus(1)).be(-1, (s = s.plus(1)).at(-1)))
                (ยง (d = d.plus(1)).be(-1, (s = s.plus(1)).at(-1)))
                (ยง (d = d.plus(1)).be(-1, (s = s.plus(1)).at(-1)))
            )
            :else
            (ยง
                ;; Add character, possibly multi-byte to destination, escaping KB_SPECIAL.
                ((ร int c =) (us_ptr2char s))
                ((ร d =) (add_char2buf c, d))
                ((ร FOR) (ร (ยง int len = utf_char2len(c), end = us_ptr2len_cc(s)) (< len end) (ยง len += utf_char2len(c)))
                    ;; Add following combining char.
                    ((ร c =) (ยง us_ptr2char(s.plus(len))))
                    ((ร d =) (add_char2buf c, d))
                )
                ((ร s =) (ยง s.plus(us_ptr2len_cc(s))))
            ))
        )
        (.be d 0, NUL)

        res
    ))

;; Remove escaping from KB_SPECIAL characters.
;; Reverse of vim_strsave_escape_special().
;; Works in-place.

(defn- #_void vim_unescape_special [#_Bytes p]
    (ยง
        ((ร Bytes d =) p)
        ((ร FOR) (ร (ยง Bytes s = p) (ยง s.at(0) != NUL) nil)
            (cond (and (== (.at s 0) KB_SPECIAL) (== (.at s 1) KS_SPECIAL) (== (.at s 2) KE_FILLER))
            (ยง
                (ยง (d = d.plus(1)).be(-1, KB_SPECIAL))
                ((ร s =) (ยง s.plus(3)))
            )
            :else
            (ยง
                (ยง (d = d.plus(1)).be(-1, (s = s.plus(1)).at(-1)))
            ))
        )
        (.be d 0, NUL)
    ))

;;; ============================================================================================== VimM

;; edit.c: functions for Insert mode --------------------------------------------------------------

(final int BACKSPACE_CHAR              1)
(final int BACKSPACE_WORD              2)
(final int BACKSPACE_WORD_NOT_SPACE    3)
(final int BACKSPACE_LINE              4)

(atom! int      insStart_textlen)               ;; length of line when insert started
(atom! int      insStart_blank_vcol)            ;; vcol for first inserted blank
(atom! boolean  update_insStart_orig true)    ;; set insStart_orig to insStart

(atom! Bytes    last_insert)                    ;; the text of the previous insert, KB_SPECIAL is escaped
(atom! int      last_insert_skip)               ;; nr of chars in front of previous insert
(atom! int      new_insert_skip)                ;; nr of chars in front of current insert
(atom! int      did_restart_edit)               ;; "restart_edit" when calling edit()

(atom! boolean  can_cindent)                    ;; may do cindenting on this line

(atom! int      old_indent)                     ;; for ^^D command in insert mode

(atom! boolean  ins_need_undo)                  ;; call u_save() before inserting a char;
                                                            ;; set when edit() is called;
                                                            ;; after that arrow_used is used

(atom! long     o_lnum)

;; edit(): Start inserting text.
;;
;; "cmdchar" can be:
;; 'i'  normal insert command
;; 'a'  normal append command
;; 'R'  replace command
;; 'r'  "r<CR>" command: insert one <CR>.  Note: count can be > 1, for redo,
;;      but still only one <CR> is inserted.  The <Esc> is not used for redo.
;; 'g'  "gI" command.
;; 'V'  "gR" command for Virtual Replace mode.
;; 'v'  "gr" command for single character Virtual Replace mode.
;;
;; This function is not called recursively.  For CTRL-O commands, it returns
;; and lets the caller handle the Normal-mode command.
;;
;; Return true if a CTRL-O command caused the return (insert mode pending).

(defn- #_boolean edit [#_int cmdchar, #_boolean startln, #_long _count]
    ;; startln: if set, insert at start of line
    (ยง
; %%    ((ร long[] count =) (ยง { _count }))

        ((ร boolean did_backspace =) true)           ;; previous char was backspace
        ((ร boolean line_is_white =) false)          ;; line is empty before insert
        ((ร long old_topline =) 0)                   ;; topline before insertion
; %%    ((ร boolean[] inserted_space =) (ยง { false }))         ;; just inserted a space
        ((ร boolean nomove =) false)                 ;; don't move cursor on return

        ;; Remember whether editing was restarted after CTRL-O.
        (reset! did_restart_edit @restart_edit)

        ;; sleep before redrawing, needed for "CTRL-O :" that results in an error message
        (check_for_delay true)

        ;; set insStart_orig to insStart
        (reset! update_insStart_orig true)

        ;; Don't allow changes in the buffer while editing the cmdline.
        ;; The caller of getcmdline() may get confused.
        (when (non-zero? @textlock)
            (emsg e_secure)
            ((ร RETURN) false)
        )

        ;; Check if the cursor line needs redrawing before changing State.
        ;; If 'concealcursor' is "n", it needs to be redrawn without concealing.
        (conceal_check_cursor_line)

        ;; When doing a paste with the middle mouse button,
        ;; insStart is set to where the paste started.

        (cond (!= (. @where_paste_started lnum) 0)
        (ยง
            (COPY_pos @insStart, @where_paste_started)
        )
        :else
        (ยง
            (COPY_pos @insStart, (. @curwin w_cursor))
            (if startln
                ((ร @insStart.col =) 0)
            )
        ))
        (reset! insStart_textlen (linetabsize (ml_get_curline)))
        (reset! insStart_blank_vcol MAXCOL)
        (if (not @did_ai)
            (reset! ai_col 0))

        (when (and (!= cmdchar NUL) (zero? @restart_edit))
            (resetRedobuff)
            (appendNumberToRedobuff (ยง count[0]))
            (cond (or (== cmdchar (byte \V)) (== cmdchar (byte \v)))
            (ยง
                ;; "gR" or "gr" command
                (appendCharToRedobuff (byte \g))
                (appendCharToRedobuff (if (== cmdchar (byte \v)) (byte \r) (byte \R)))
            )
            :else
            (ยง
                (appendCharToRedobuff cmdchar)
                (cond (== cmdchar (byte \g))             ;; "gI" command
                (ยง
                    (appendCharToRedobuff (byte \I))
                )
                (== cmdchar (byte \r))        ;; "r<CR>" command
                (ยง
                    ((ร count[0] =) 1)                  ;; insert only one <CR>
                ))
            ))
        )

        ((ร int replaceState =) REPLACE)
        (cond (== cmdchar (byte \R))
        (ยง
            (reset! State REPLACE)
        )
        (or (== cmdchar (byte \V)) (== cmdchar (byte \v)))
        (ยง
            (reset! State VREPLACE)
            ((ร replaceState =) VREPLACE)
            (reset! orig_line_count (.. @curbuf b_ml ml_line_count))
            (reset! vr_lines_changed 1)
        )
        :else
        (ยง
            (reset! State INSERT)
        ))

        (reset! stop_insert_mode false)

        ;; Need to recompute the cursor position,
        ;; it might move when the cursor is on a TAB or special character.

        (curs_columns true)

        (clear_showcmd)

        ;; Handle restarting Insert mode.
        ;; Don't do this for "CTRL-O ." (repeat an insert): we get here with
        ;; restart_edit non-zero, and something in the stuff buffer.

        (cond (and (non-zero? @restart_edit) (stuff_empty))
        (ยง
            ;; After a paste we consider text typed to be part of the insert for
            ;; the pasted text.  You can backspace over the pasted text too.

            (reset! arrow_used (zero? (. @where_paste_started lnum)))
            (reset! restart_edit 0)

            ;; If the cursor was after the end-of-line before the CTRL-O and it is
            ;; now at the end-of-line, put it after the end-of-line (this is not
            ;; correct in very rare cases).
            ;; Also do this if curswant is greater than the current virtual column.
            ;; E.g. after "^O$" or "^O80|".

            (validate_virtcol)
            (update_curswant)
            (when (or (and @ins_at_eol (== (.. @curwin w_cursor lnum) @o_lnum)) (< (. @curwin w_virtcol) (. @curwin w_curswant)))
                ((ร Bytes p =) (ยง ml_get_curline().plus(@curwin.w_cursor.col)))
                (when (non-eos? p)
                    (cond (eos? p 1)
                    (ยง
                        (ยง @curwin.w_cursor.col++)
                    )
                    :else
                    (ยง
                        ((ร int n =) (us_ptr2len_cc p))
                        (if (eos? p n)
                            ((ร @curwin.w_cursor.col +=) n)
                        )
                    ))
                )
            )
            (reset! ins_at_eol false)
        )
        :else
        (ยง
            (reset! arrow_used false)
        ))

        ;; We are in insert mode now, don't need to start it anymore.
        (reset! need_start_insertmode false)

        ;; Need to save the line for undo before inserting the first char.
        (reset! ins_need_undo true)

        ((ร @where_paste_started.lnum =) 0)
        (reset! can_cindent true)

        ;; If 'showmode' is set, show the current (insert/replace/..) mode.
        ;; A warning message for changing a readonly file is given here, before
        ;; actually changing anything.  It's put after the mode, if any.

        ((ร int i =) 0)
        (if @p_smd
            ((ร i =) (showmode))
        )

        (ui_cursor_shape)          ;; may show different cursor shape
        (do_digraph -1)             ;; clear digraphs

        ;; Get the current length of the redo buffer,
        ;; those characters have to be skipped if we want to get to the inserted characters.

        ((ร Bytes ptr =) (get_inserted))
        (if (nil? ptr)
            (reset! new_insert_skip 0)
            (reset! new_insert_skip (STRLEN ptr)))

        (reset! old_indent 0)

        ;; Main loop in Insert mode: repeat until Insert mode is left.

        ((ร FOR) (ร (ยง int lastc = 0, c = 0) true nil)
            (if @arrow_used     ;; don't repeat insert when arrow key used
                ((ร count[0] =) 0)
            )

            (if @update_insStart_orig
                (COPY_pos @insStart_orig, @insStart))

;           doESCkey:
;           {
                (when @stop_insert_mode
                    ;; ":stopinsert" used or 'insertmode' reset
                    ((ร count[0] =) 0)
                    (ร BREAK doESCkey)
                )

                ;; set curwin.w_curswant for next K_DOWN or K_UP
                (if (not @arrow_used)
                    ((ร @curwin.w_set_curswant =) true)
                )

                ;; When emsg() was called msg_scroll will have been set.

                (reset! msg_scroll false)

                ;; If we inserted a character at the last position of the last line in the window,
                ;; scroll the window one line up.  This avoids an extra redraw.
                ;; This is detected when the cursor column is smaller after inserting something.
                ;; Don't do this when the topline changed already,
                ;; it has already been adjusted (by insertchar() calling open_line())).

                (when (and (. @curbuf b_mod_set) @(.. @curwin w_options wo_wrap) (not did_backspace) (== (. @curwin w_topline) old_topline))
                    ((ร int mincol =) (. @curwin w_wcol))
                    (validate_cursor_col)

                    (when (and (< (. @curwin w_wcol) (- mincol @(. @curbuf b_p_ts))) (== (. @curwin w_wrow) (ยง @curwin.w_winrow + @curwin.w_height - 1 - @p_so)) (!= (.. @curwin w_cursor lnum) (. @curwin w_topline)))
                        (set_topline @curwin, (+ (. @curwin w_topline) 1))
                    )
                )

                ;; May need to adjust w_topline to show the cursor.
                (update_topline)

                ((ร did_backspace =) false)

                (validate_cursor)              ;; may set must_redraw

                ;; Redraw the display when no characters are waiting.
                ;; Also shows mode, ruler and positions cursor.

                (ins_redraw true)

                (if @(.. @curwin w_options wo_scb)
                    (do_check_scrollbind true))

                (if @(.. @curwin w_options wo_crb)
                    (do_check_cursorbind))
                (update_curswant)
                ((ร old_topline =) (. @curwin w_topline))

                ;; Get a character for Insert mode.  Ignore K_IGNORE.

                (if (!= c K_CURSORHOLD)
                    ((ร lastc =) c)          ;; remember the previous char for CTRL-D
                )
;               do
;               {
                    ((ร c =) (safe_vgetc))
;               } while (c == K_IGNORE);

                ;; Don't want K_CURSORHOLD for the second key, e.g., after CTRL-V.
                (reset! did_cursorhold true)

                ;; CTRL-\ CTRL-N goes to Normal mode,
                ;; CTRL-\ CTRL-G goes to mode selected with 'insertmode',
                ;; CTRL-\ CTRL-O is like CTRL-O but without moving the cursor.
                (when (== c Ctrl_BSL)
                    ;; may need to redraw when no more chars available now
                    (ins_redraw false)

                    (swap! no_mapping inc)
                    (swap! allow_keys inc)
                    ((ร c =) (plain_vgetc))
                    (swap! no_mapping dec)
                    (swap! allow_keys dec)

                    (cond (and (!= c Ctrl_N) (!= c Ctrl_G) (!= c Ctrl_O))
                    (ยง
                        ;; it's something else
                        (vungetc c)
                        ((ร c =) Ctrl_BSL)
                    )
                    (and (== c Ctrl_G) @p_im)
                    (ยง
                        (ร CONTINUE)
                    )
                    :else
                    (ยง
                        (when (== c Ctrl_O)
                            (ins_ctrl_o)
                            (reset! ins_at_eol false) ;; cursor keeps its column
                            ((ร nomove =) true)
                        )
                        ((ร count[0] =) 0)
                        (ร BREAK doESCkey)
                    ))
                )

                ((ร c =) (do_digraph c))

                (when (or (== c Ctrl_V) (== c Ctrl_Q))
                    (ins_ctrl_v)
                    ((ร c =) Ctrl_V)         ;; pretend CTRL-V is last typed character
                    (ร CONTINUE)
                )

                ;; If 'keymodel' contains "startsel", may start selection.
                ;; If it does, a CTRL-O and c will be stuffed, we need to get these characters.

                (if (ins_start_select c)
                    (ร CONTINUE)
                )

;               normalchar:
;               {
                    ;; The big switch to handle a character in insert mode.

                    ((ร SWITCH) c
                        ((ร CASE) ESC)                           ;; end input mode
                        (ยง
                            (ร FALLTHROUGH)
                        )

                        ((ร CASE) Ctrl_C)                        ;; end input mode
                        (ยง
                            (when (and (== c Ctrl_C) (non-zero? @cmdwin_type))
                                ;; Close the cmdline window.
                                (reset! cmdwin_result K_IGNORE)
                                (reset! got_int false)            ;; don't stop executing autocommands et al.
                                ((ร nomove =) true)
                                (ร BREAK doESCkey)
                            )

                            ;; When 'insertmode' set, and not halfway a mapping, don't leave Insert mode.
                            (when (goto_im)
                                (cond @got_int
                                (ยง
                                    (vgetc)                ;; flush all buffers
                                    (reset! got_int false)
                                )
                                :else
                                (ยง
                                    (vim_beep)
                                ))
                                (ร BREAK normalchar)
                            )
                            (ร BREAK doESCkey)
                        )

                        ((ร CASE) Ctrl_Z)                        ;; suspend when 'insertmode' set
                        (ยง
                            (if (not @p_im)
                                (ร BREAK)            ;; insert CTRL-Z as normal char
                            )
                            (stuffReadbuff (u8 ":st\r"))
                            ((ร c =) Ctrl_O)
                            (ร FALLTHROUGH)
                        )

                        ((ร CASE) Ctrl_O)                        ;; execute one command
                        (ยง
                            (ins_ctrl_o)

                            ;; Don't move the cursor left when 'virtualedit' has "onemore".
                            (when (non-zero? (& @ve_flags VE_ONEMORE))
                                (reset! ins_at_eol false)
                                ((ร nomove =) true)
                            )
                            ((ร count[0] =) 0)
                            (ร BREAK doESCkey)
                        )

                        ((ร CASE) K_INS)                         ;; toggle insert/replace mode
                        ((ร CASE) K_KINS)
                        (ยง
                            (ins_insert replaceState)
                            (ร BREAK normalchar)
                        )

                        ((ร CASE) K_SELECT)                      ;; end of Select mode mapping - ignore
                        (ยง
                            (ร BREAK normalchar)
                        )

                        ((ร CASE) K_HELP)                        ;; Help key works like <ESC> <Help>
                        ((ร CASE) K_F1)
                        ((ร CASE) K_XF1)
                        (ยง
                            (stuffcharReadbuff K_HELP)
                            (if @p_im
                                (reset! need_start_insertmode true))
                            (ร BREAK doESCkey)
                        )

                        ((ร CASE) K_ZERO)                        ;; insert the previously inserted text
                        ((ร CASE) NUL)
                        ((ร CASE) Ctrl_A)
                        (ยง
                            ;; For ^@ the trailing ESC will end the insert, unless there is an error.
                            (if (and (not (stuff_inserted NUL, 1, (== c Ctrl_A))) (!= c Ctrl_A) (not @p_im))
                                (ร BREAK doESCkey)             ;; quit insert mode
                            )
                            ((ร inserted_space[0] =) false)
                            (ร BREAK normalchar)
                        )

                        ((ร CASE) Ctrl_R)                        ;; insert the contents of a register
                        (ยง
                            (ins_reg)
                            ((ร inserted_space[0] =) false)
                            (ร BREAK normalchar)
                        )

                        ((ร CASE) Ctrl_G)                        ;; commands starting with CTRL-G
                        (ยง
                            (ins_ctrl_g)
                            (ร BREAK normalchar)
                        )

                        ((ร CASE) Ctrl_HAT)                      ;; switch input mode and/or langmap
                        (ยง
                            (ins_ctrl_hat)
                            (ร BREAK normalchar)
                        )

                        ((ร CASE) Ctrl__)                        ;; switch between languages
                        (ยง
                            (ร BREAK)
                        )

                        ((ร CASE) Ctrl_D)                        ;; make indent one shiftwidth smaller
                        (ยง
                            (ร FALLTHROUGH)
                        )
                        ((ร CASE) Ctrl_T)                        ;; make indent one shiftwidth greater
                        (ยง
                            (ins_shift c, lastc)
                            ((ร inserted_space[0] =) false)
                            (ร BREAK normalchar)
                        )

                        ((ร CASE) K_DEL)                         ;; delete character under the cursor
                        ((ร CASE) K_KDEL)
                        (ยง
                            (ins_del)
                            (ร BREAK normalchar)
                        )

                        ((ร CASE) K_BS)                          ;; delete character before the cursor
                        ((ร CASE) Ctrl_H)
                        (ยง
                            ((ร did_backspace =) (ins_bs c, BACKSPACE_CHAR, inserted_space))
                            (ร BREAK normalchar)
                        )

                        ((ร CASE) Ctrl_W)                        ;; delete word before the cursor
                        (ยง
                            ((ร did_backspace =) (ins_bs c, BACKSPACE_WORD, inserted_space))
                            (ร BREAK normalchar)
                        )

                        ((ร CASE) Ctrl_U)                        ;; delete all inserted text in current line
                        (ยง
                            ((ร did_backspace =) (ins_bs c, BACKSPACE_LINE, inserted_space))
                            ((ร inserted_space[0] =) false)
                            (ร BREAK normalchar)
                        )

                        ((ร CASE) K_IGNORE)                      ;; something mapped to nothing
                        (ยง
                            (ร BREAK normalchar)
                        )

                        ((ร CASE) K_CURSORHOLD)                  ;; didn't type something for a while
                        (ยง
                            (reset! did_cursorhold true)
                            (ร BREAK normalchar)
                        )

                        ((ร CASE) K_HOME)                        ;; <Home>
                        ((ร CASE) K_KHOME)
                        ((ร CASE) K_S_HOME)
                        ((ร CASE) K_C_HOME)
                        (ยง
                            (ins_home c)
                            (ร BREAK normalchar)
                        )

                        ((ร CASE) K_END)                         ;; <End>
                        ((ร CASE) K_KEND)
                        ((ร CASE) K_S_END)
                        ((ร CASE) K_C_END)
                        (ยง
                            (ins_end c)
                            (ร BREAK normalchar)
                        )

                        ((ร CASE) K_LEFT)                        ;; <Left>
                        (ยง
                            (if (non-zero? (ยง @mod_mask & (MOD_MASK_SHIFT|MOD_MASK_CTRL)))
                                (ins_s_left)
                                (ins_left))
                            (ร BREAK normalchar)
                        )

                        ((ร CASE) K_S_LEFT)                      ;; <S-Left>
                        ((ร CASE) K_C_LEFT)
                        (ยง
                            (ins_s_left)
                            (ร BREAK normalchar)
                        )

                        ((ร CASE) K_RIGHT)                       ;; <Right>
                        (ยง
                            (if (non-zero? (ยง @mod_mask & (MOD_MASK_SHIFT|MOD_MASK_CTRL)))
                                (ins_s_right)
                                (ins_right))
                            (ร BREAK normalchar)
                        )

                        ((ร CASE) K_S_RIGHT)                     ;; <S-Right>
                        ((ร CASE) K_C_RIGHT)
                        (ยง
                            (ins_s_right)
                            (ร BREAK normalchar)
                        )

                        ((ร CASE) K_UP)                          ;; <Up>
                        (ยง
                            (if (non-zero? (& @mod_mask MOD_MASK_SHIFT))
                                (ins_pageup)
                                (ins_up false))
                            (ร BREAK normalchar)
                        )

                        ((ร CASE) K_S_UP)                        ;; <S-Up>
                        ((ร CASE) K_PAGEUP)
                        ((ร CASE) K_KPAGEUP)
                        (ยง
                            (ins_pageup)
                            (ร BREAK normalchar)
                        )

                        ((ร CASE) K_DOWN)                        ;; <Down>
                        (ยง
                            (if (non-zero? (& @mod_mask MOD_MASK_SHIFT))
                                (ins_pagedown)
                                (ins_down false))
                            (ร BREAK normalchar)
                        )

                        ((ร CASE) K_S_DOWN)                      ;; <S-Down>
                        ((ร CASE) K_PAGEDOWN)
                        ((ร CASE) K_KPAGEDOWN)
                        (ยง
                            (ins_pagedown)
                            (ร BREAK normalchar)
                        )

                        ((ร CASE) K_DROP)                        ;; drag-n-drop event
                        (ยง
                            (ins_drop)
                            (ร BREAK normalchar)
                        )

                        ((ร CASE) K_S_TAB)                       ;; when not mapped, use like a normal TAB
                        (ยง
                            ((ร c =) TAB)
                            (ร FALLTHROUGH)
                        )
                        ((ร CASE) TAB)                           ;; TAB or Complete patterns along path
                        (ยง
                            ((ร inserted_space[0] =) false)
                            (if (ins_tab)
                                (ร BREAK)            ;; insert TAB as a normal char
                            )
                            (ร BREAK normalchar)
                        )

                        ((ร CASE) K_KENTER)                      ;; <Enter>
                        (ยง
                            ((ร c =) CAR)
                            (ร FALLTHROUGH)
                        )
                        ((ร CASE) CAR)
                        ((ร CASE) NL)
                        (ยง
                            (when (non-zero? @cmdwin_type)
                                ;; Execute the command in the cmdline window.
                                (reset! cmdwin_result CAR)
                                (ร BREAK doESCkey)
                            )
                            (if (and (ins_eol c) (not @p_im))
                                (ร BREAK doESCkey)             ;; out of memory
                            )
                            ((ร inserted_space[0] =) false)
                            (ร BREAK normalchar)
                        )

                        ((ร CASE) Ctrl_K)                        ;; digraph or keyword completion
                        (ยง
                            ((ร c =) (ins_digraph))
                            (if (== c NUL)
                                (ร BREAK normalchar)
                            )
                            (ร BREAK)
                        )

                        ((ร CASE) Ctrl_L)                        ;; whole line completion after ^X
                        (ยง
                            ;; CTRL-L with 'insertmode' set: Leave Insert mode.
                            (if @p_im
                                (ร BREAK doESCkey)
                            )
                            (ร BREAK)
                        )

                        ((ร CASE) Ctrl_Y)                        ;; copy from previous line or scroll down
                        ((ร CASE) Ctrl_E)                        ;; copy from next     line or scroll up
                        (ยง
                            ((ร c =) (ins_ctrl_ey c))
                            (ร BREAK normalchar)
                        )

                        (ร DEFAULT)
                        (ยง
                            (when (== c @intr_char)             ;; special interrupt char
                                ;; When 'insertmode' set, and not halfway a mapping, don't leave Insert mode.
                                (when (goto_im)
                                    (cond @got_int
                                    (ยง
                                        (vgetc)                ;; flush all buffers
                                        (reset! got_int false)
                                    )
                                    :else
                                    (ยง
                                        (vim_beep)
                                    ))
                                    (ร BREAK normalchar)
                                )
                                (ร BREAK doESCkey)
                            )
                            (ร BREAK)
                        )
                    )

                    ;; Insert a normal character.

                    (when (not @p_paste)
                        ;; Trigger InsertCharPre.
                        ((ร Bytes s =) (do_insert_char_pre c))

                        (when (non-nil? s)
                            (when (and (non-eos? s) (stop_arrow))
                                ;; Insert the new value of v:char literally.
                                ((ร FOR) (ร (ยง Bytes p = s) (ยง p.at(0) != NUL) (ยง p = p.plus(us_ptr2len_cc(p))))
                                    ((ร c =) (us_ptr2char p))
                                    (if (or (== c CAR) (== c K_KENTER) (== c NL))
                                        (ins_eol c)
                                        (ins_char c))
                                )
                                (appendToRedobuffLit s, -1)
                            )
                            ((ร c =) NUL)
                        )

                        ;; If the new value is already inserted or an empty string,
                        ;; then don't insert any character.
                        (if (== c NUL)
                            (ร BREAK normalchar)
                        )
                    )
                    ;; Try to perform smart-indenting.
                    (ins_try_si c)

                    (when (== c (byte \space))
                        ((ร inserted_space[0] =) true)
                        (if (inindent 0)
                            (reset! can_cindent false))
                        (if (and (== @insStart_blank_vcol MAXCOL) (== (.. @curwin w_cursor lnum) (. @insStart lnum)))
                            (reset! insStart_blank_vcol (get_nolist_virtcol)))
                    )

                    ;; Insert a normal character and check for abbreviations on a special character.
                    ;; Let CTRL-] expand abbreviations without inserting it.
                    (when (or (vim_iswordc c, @curbuf) (!= c Ctrl_RSB))
                        (insert_special c, false, false)
                    )
;               }

                ;; If typed something may trigger CursorHoldI again.
                (if (!= c K_CURSORHOLD)
                    (reset! did_cursorhold false))

                ;; If the cursor was moved we didn't just insert a space.
                (if @arrow_used
                    ((ร inserted_space[0] =) false)
                )

                (ร CONTINUE)
;           }

            ;; This is the ONLY return from edit()!

            ;; Always update o_lnum, so that a "CTRL-O ." that adds a line
            ;; still puts the cursor back after the inserted text.
            (if (and @ins_at_eol (== (gchar_cursor) NUL))
                (reset! o_lnum (.. @curwin w_cursor lnum)))

            (when (ins_esc count, cmdchar, nomove)
                (reset! did_cursorhold false)
                ((ร RETURN) (ยง (c == Ctrl_O)))
            )
        )

        ;; NOTREACHED
    ))

;; Redraw for Insert mode.
;; This is postponed until getting the next character to make '$' in the 'cpo' option work correctly.
;; Only redraw when there are no characters available.
;; This speeds up inserting sequences of characters (e.g., for CTRL-R).

(defn- #_void ins_redraw [#_boolean ready]
    ;; ready: not busy with something
    (ยง
        (if (char_avail)
            (ร RETURN)
        )

        ((ร long conceal_old_cursor_line =) 0)
        ((ร long conceal_new_cursor_line =) 0)
        ((ร boolean conceal_update_lines =) false)

        ;; Trigger CursorMoved if the cursor moved.
        ;; Not when the popup menu is visible, the command might delete it.
        (when (and ready (< 0 @(.. @curwin w_options wo_cole)) (not (eqpos @last_cursormoved, (. @curwin w_cursor))))
            ((ร conceal_old_cursor_line =) (. @last_cursormoved lnum))
            ((ร conceal_new_cursor_line =) (.. @curwin w_cursor lnum))
            ((ร conceal_update_lines =) true)

            (COPY_pos @last_cursormoved, (. @curwin w_cursor))
        )

        (cond (non-zero? @must_redraw)
        (ยง
            (update_screen 0)
        )
        (or @clear_cmdline @redraw_cmdline)
        (ยง
            (showmode)             ;; clear cmdline and show mode
        ))
        (when (or (and conceal_update_lines (or (!= conceal_old_cursor_line conceal_new_cursor_line) (conceal_cursor_line @curwin))) @need_cursor_line_redraw)
            (if (!= conceal_old_cursor_line conceal_new_cursor_line)
                (update_single_line @curwin, conceal_old_cursor_line))
            (update_single_line @curwin, (if (zero? conceal_new_cursor_line) (.. @curwin w_cursor lnum) conceal_new_cursor_line))
            ((ร @curwin.w_valid &=) (ยง ~VALID_CROW))
        )
        (showruler false)
        (setcursor)
        (reset! emsg_on_display false)    ;; may remove error message now
    ))

;; Handle a CTRL-V or CTRL-Q typed in Insert mode.

(defn- #_void ins_ctrl_v []
    (ยง
        ((ร boolean did_putchar =) false)

        ;; may need to redraw when no more chars available now
        (ins_redraw false)

        (when (and (redrawing) (not (char_avail)))
            (edit_putchar (byte \^), true)
            ((ร did_putchar =) true)
        )
        (appendToRedobuff CTRL_V_STR)   ;; CTRL-V

        (add_to_showcmd_c Ctrl_V)

        ((ร int c =) (get_literal))
        (when did_putchar
            ;; When the line fits in 'columns' the '^' is at the start
            ;; of the next line and will not removed by the redraw.
            (edit_unputchar)
        )
        (clear_showcmd)
        (insert_special c, false, true)
    ))

;; Put a character directly onto the screen.  It's not stored in a buffer.
;; Used while handling CTRL-K, CTRL-V, etc. in Insert mode.

(atom! int  pc_status)
(final int PC_STATUS_UNSET 0)                   ;; "pc_bytes" was not set
(final int PC_STATUS_RIGHT 1)                   ;; right halve of double-wide char
(final int PC_STATUS_LEFT  2)                   ;; left halve of double-wide char
(final int PC_STATUS_SET   3)                   ;; "pc_bytes" was filled

(final Bytes pc_bytes (Bytes. (inc MB_MAXBYTES)))   ;; saved bytes
(atom! int  pc_attr)
(atom! int  pc_row)
(atom! int  pc_col)

(defn- #_void edit_putchar [#_int c, #_boolean highlight]
    (ยง
        (when (non-nil? @screenLines)
            (update_topline)       ;; just in case w_topline isn't valid
            (validate_cursor)

            ((ร int attr =) (if highlight (hl_attr HLF_8) 0))

            (reset! pc_row (+ (. @curwin w_winrow) (. @curwin w_wrow)))
            (reset! pc_col (. @curwin w_wincol))
            (reset! pc_status PC_STATUS_UNSET)

            ((ร @pc_col +=) (. @curwin w_wcol))
            (if (mb_lefthalve @pc_row, @pc_col)
                (reset! pc_status PC_STATUS_LEFT))

            ;; save the character to be able to put it back
            (when (== @pc_status PC_STATUS_UNSET)
                (screen_getbytes @pc_row, @pc_col, pc_bytes, pc_attr)
                (reset! pc_status PC_STATUS_SET)
            )
            (screen_putchar c, @pc_row, @pc_col, attr)
        )
    ))

;; Undo the previous edit_putchar().

(defn- #_void edit_unputchar []
    (ยง
        (when (and (!= @pc_status PC_STATUS_UNSET) (<= @msg_scrolled @pc_row))
            (if (== @pc_status PC_STATUS_RIGHT)
                (ยง @curwin.w_wcol++)
            )
            (if (or (== @pc_status PC_STATUS_RIGHT) (== @pc_status PC_STATUS_LEFT))
                (redrawWinline (.. @curwin w_cursor lnum))
                (screen_puts pc_bytes, (- @pc_row @msg_scrolled), @pc_col, @pc_attr))
        )
    ))

;; Insert an indent (for <Tab> or CTRL-T) or delete an indent (for CTRL-D).
;; Keep the cursor on the same character.
;; type == INDENT_INC   increase indent (for CTRL-T or <Tab>)
;; type == INDENT_DEC   decrease indent (for CTRL-D)
;; type == INDENT_SET   set indent to "amount"
;; If round is true, round the indent to 'shiftwidth' (only with _INC and _DEC).

(defn- #_void change_indent [#_int type, #_int amount, #_boolean round, #_int replaced, #_boolean call_changed_bytes]
    ;; replaced: replaced character, put on replace stack
    ;; call_changed_bytes: call changed_bytes()
    (ยง
        ((ร Bytes orig_line =) null)
        ((ร int orig_col =) 0)

        ;; VREPLACE mode needs to know what the line was like before changing.
        (when (non-zero? (& @State VREPLACE_FLAG))
            ((ร orig_line =) (ยง STRDUP(ml_get_curline())))   ;; Deal with null below
            ((ร orig_col =) (.. @curwin w_cursor col))
        )

        ((ร int vc =) (ยง getvcol_nolist(@curwin.w_cursor)))
        ((ร int vcol =) vc)

        ;; For Replace mode we need to fix the replace stack later, which is only
        ;; possible when the cursor is in the indent.  Remember the number of
        ;; characters before the cursor if it's possible.

        ((ร int start_col =) (.. @curwin w_cursor col))

        ;; determine offset from first non-blank
        ((ร int new_cursor_col =) (.. @curwin w_cursor col))
        (beginline BL_WHITE)
        ((ร new_cursor_col -=) (.. @curwin w_cursor col))

        ((ร int insstart_less =) (.. @curwin w_cursor col))    ;; reduction for insStart.col

        ;; If the cursor is in the indent, compute how many screen columns the
        ;; cursor is to the left of the first non-blank.

        (if (< new_cursor_col 0)
            ((ร vcol =) (ยง get_indent() - vcol))
        )

        (if (< 0 new_cursor_col)         ;; can't fix replace stack
            ((ร start_col =) -1)
        )

        ;; Set the new indent.  The cursor will be put on the first non-blank.

        (cond (== type INDENT_SET)
        (ยง
            (set_indent amount, (if call_changed_bytes SIN_CHANGED 0))
        )
        :else
        (ยง
            ((ร int save_State =) @State)

            ;; Avoid being called recursively.
            (if (non-zero? (& @State VREPLACE_FLAG))
                (reset! State INSERT))
            (shift_line (== type INDENT_DEC), round, 1, call_changed_bytes)

            (reset! State save_State)
        ))
        ((ร insstart_less -=) (.. @curwin w_cursor col))

        ;; Try to put cursor on same character.
        ;; If the cursor is at or after the first non-blank in the line,
        ;; compute the cursor column relative to the column of the first non-blank character.
        ;; If we are not in insert mode, leave the cursor on the first non-blank.
        ;; If the cursor is before the first non-blank, position it relative
        ;; to the first non-blank, counted in screen columns.

        (cond (<= 0 new_cursor_col)
        (ยง
            ;; When changing the indent while the cursor is touching it, reset insStart_col to 0.

            (if (zero? new_cursor_col)
                ((ร insstart_less =) MAXCOL)
            )
            ((ร new_cursor_col +=) (.. @curwin w_cursor col))
        )
        (zero? (& @State INSERT))
        (ยง
            ((ร new_cursor_col =) (.. @curwin w_cursor col))
        )
        :else
        (ยง
            ;; Compute the screen column where the cursor should be.

            ((ร vcol =) (ยง get_indent() - vcol))
            ((ร @curwin.w_virtcol =) (if (< vcol 0) 0 vcol))

            ;; Advance the cursor until we reach the right screen column.

            ((ร int last_vcol =) (ยง vcol = 0))
            ((ร new_cursor_col =) -1)
            ((ร Bytes ptr =) (ml_get_curline))
            (while (ยง vcol <= @curwin.w_virtcol)
                ((ร last_vcol =) vcol)
                (if (<= 0 new_cursor_col)
                    ((ร new_cursor_col +=) (ยง us_ptr2len_cc(ptr.plus(new_cursor_col))))
                    (ยง new_cursor_col++)
                )
                ((ร vcol +=) (ยง lbr_chartabsize(ptr, ptr.plus(new_cursor_col), vcol)))
            )
            ((ร vcol =) last_vcol)

            ;; May need to insert spaces to be able to position the cursor on
            ;; the right screen column.

            (when (!= vcol (. @curwin w_virtcol))
                ((ร @curwin.w_cursor.col =) new_cursor_col)
                ((ร int i =) (ยง @curwin.w_virtcol - vcol))
                ((ร ptr =) (ยง new Bytes(i + 1)))

                ((ร new_cursor_col +=) i)
                (.be ptr i, NUL)
                (while (ยง 0 <= --i)
                    (ยง ptr.be(i, (byte \space)))
                )
                (ins_str ptr)
            )

            ;; When changing the indent while the cursor is in it, reset insStart_col to 0.

            ((ร insstart_less =) MAXCOL)
        ))

        (if (<= new_cursor_col 0)
            ((ร @curwin.w_cursor.col =) 0)
            ((ร @curwin.w_cursor.col =) new_cursor_col)
        )
        ((ร @curwin.w_set_curswant =) true)
        (changed_cline_bef_curs)

        ;; May have to adjust the start of the insert.

        (when (non-zero? (& @State INSERT))
            (when (and (== (.. @curwin w_cursor lnum) (. @insStart lnum)) (!= (. @insStart col) 0))
                (if (<= (. @insStart col) insstart_less)
                    ((ร @insStart.col =) 0)
                    ((ร @insStart.col -=) insstart_less)
                )
            )
            (if (<= @ai_col insstart_less)
                (reset! ai_col 0)
                ((ร @ai_col -=) insstart_less)
            )
        )

        ;; For REPLACE mode, may have to fix the replace stack, if it's possible.
        ;; If the number of characters before the cursor decreased, need to pop a
        ;; few characters from the replace stack.
        ;; If the number of characters before the cursor increased, need to push a
        ;; few NULs onto the replace stack.

        (when (and (non-zero? (& @State REPLACE_FLAG)) (zero? (& @State VREPLACE_FLAG)) (<= 0 start_col))
            (while (ยง @curwin.w_cursor.col < start_col)
                (replace_join 0)        ;; remove a NUL from the replace stack
                (ยง --start_col)
            )
            (while (ยง start_col < @curwin.w_cursor.col || replaced != NUL)
                (replace_push NUL)
                (when (!= replaced NUL)
                    (replace_push replaced)
                    ((ร replaced =) NUL)
                )
                (ยง start_col++)
            )
        )

        ;; For VREPLACE mode, we also have to fix the replace stack.  In this case
        ;; it is always possible because we backspace over the whole line and then
        ;; put it back again the way we wanted it.

        (when (non-zero? (& @State VREPLACE_FLAG))
            ;; If 'orig_line' didn't allocate, just return.
            ;; At least we did the job, even if you can't backspace.
            (if (nil? orig_line)
                (ร RETURN)
            )

            ;; Save new line.
            ((ร Bytes new_line =) (ยง STRDUP(ml_get_curline())))

            ;; We only put back the new line up to the cursor.
            (.be new_line (.. @curwin w_cursor col), NUL)

            ;; Put back original line.
            (ml_replace (.. @curwin w_cursor lnum), orig_line)
            ((ร @curwin.w_cursor.col =) orig_col)

            ;; Backspace from cursor to start of line.
            (backspace_until_column 0)

            ;; Insert new stuff into line again.
            (ins_bytes new_line)
        )
    ))

;; Truncate the space at the end of a line.  This is to be used only in an
;; insert mode.  It handles fixing the replace stack for REPLACE and VREPLACE modes.

(defn- #_void truncate_spaces [#_Bytes line]
    (ยง
        ;; find start of trailing white space
        (ร int i)
        ((ร FOR) (ร (ยง i = STRLEN(line) - 1) (ยง 0 <= i && vim_iswhite(line.at(i))) (ยง i--))
            (if (non-zero? (& @State REPLACE_FLAG))
                (replace_join 0))        ;; remove a NUL from the replace stack
        )
        (ยง line.be(i + 1, NUL))
    ))

;; Backspace the cursor until the given column.  Handles REPLACE and VREPLACE
;; modes correctly.  May also be used when not in insert mode at all.
;; Will attempt not to go before "col" even when there is a composing character.

(defn- #_void backspace_until_column [#_int col]
    (ยง
        (while (ยง col < @curwin.w_cursor.col)
            (ยง --@curwin.w_cursor.col)
            (cond (non-zero? (& @State REPLACE_FLAG))
            (ยง
                (replace_do_bs col)
            )
            (not (del_char_after_col col))
            (ยง
                (ร BREAK)
            ))
        )
    ))

;; Like del_char(), but make sure not to go before column "limit_col".
;; Only matters when there are composing characters.
;; Return true when something was deleted.

(defn- #_boolean del_char_after_col [#_int limit_col]
    (ยง
        (cond (<= 0 limit_col)
        (ยง
            ((ร int ecol =) (ยง @curwin.w_cursor.col + 1))

            ;; Make sure the cursor is at the start of a character, but
            ;; skip forward again when going too far back because of a
            ;; composing character.
            (mb_adjust_pos @curbuf, (. @curwin w_cursor))
            (while (ยง @curwin.w_cursor.col < limit_col)
                ((ร int l =) (ยง us_ptr2len(ml_get_cursor())))

                (if (zero? l)     ;; end of line
                    (ร BREAK)
                )
                ((ร @curwin.w_cursor.col +=) l)
            )
            (if (or (== (.at (ml_get_cursor) 0) NUL) (== (.. @curwin w_cursor col) ecol))
                ((ร RETURN) false)
            )
            (del_bytes (- ecol (.. @curwin w_cursor col)), false, true)
        )
        :else
        (ยง
            (del_char false)
        ))
        true
    ))

;; Next character is interpreted literally.
;; A one, two or three digit decimal number is interpreted as its byte value.
;; If one or two digits are entered, the next character is given to vungetc().
;; For Unicode a character > 255 may be returned.

(defn- #_int get_literal []
    (ยง
        (if @got_int
            ((ร RETURN) Ctrl_C)
        )

        ((ร boolean hex =) false)
        ((ร boolean octal =) false)
        ((ร int unicode =) 0)

        (ร int nc)
        (swap! no_mapping inc)               ;; don't map the next key hits

        ((ร int cc =) 0)
        ((ร int i =) 0)
        (while true
            ((ร nc =) (plain_vgetc))

            (if (and (zero? (& @State CMDLINE)) (== (mb_byte2len nc) 1))
                (add_to_showcmd nc))

            (cond (or (== nc (byte \x)) (== nc (byte \X)))
            (ยง
                ((ร hex =) true)
            )
            (or (== nc (byte \o)) (== nc (byte \O)))
            (ยง
                ((ร octal =) true)
            )
            (or (== nc (byte \u)) (== nc (byte \U)))
            (ยง
                ((ร unicode =) nc)
            )
            :else
            (ยง
                (cond (or hex (non-zero? unicode))
                (ยง
                    (if (not (asc_isxdigit nc))
                        (ร BREAK)
                    )
                    ((ร cc =) (ยง cc * 16 + hex2nr(nc)))
                )
                octal
                (ยง
                    (if (or (< nc (byte \0)) (< (byte \7) nc))
                        (ร BREAK)
                    )
                    ((ร cc =) (ยง cc * 8 + nc - (byte \0)))
                )
                :else
                (ยง
                    (if (not (asc_isdigit nc))
                        (ร BREAK)
                    )
                    ((ร cc =) (ยง cc * 10 + nc - (byte \0)))
                ))

                (ยง i++)
            ))

            (if (and (> cc 255) (zero? unicode))
                ((ร cc =) 255)           ;; limit range to 0-255
            )
            ((ร nc =) 0)

            (cond hex                ;; hex: up to two chars
            (ยง
                (if (<= 2 i)
                    (ร BREAK)
                )
            )
            (non-zero? unicode)  ;; Unicode: up to four or eight chars
            (ยง
                (if (or (and (== unicode (byte \u)) (<= 4 i)) (and (== unicode (byte \U)) (<= 8 i)))
                    (ร BREAK)
                )
            )
            (<= 3 i)        ;; decimal or octal: up to three chars
            (ยง
                (ร BREAK)
            ))
        )
        (when (zero? i)                 ;; no number entered
            (cond (== nc K_ZERO)       ;; NUL is stored as NL
            (ยง
                ((ร cc =) (ยง (byte \newline)))
                ((ร nc =) 0)
            )
            :else
            (ยง
                ((ร cc =) nc)
                ((ร nc =) 0)
            ))
        )

        (if (zero? cc)                ;; NUL is stored as NL
            ((ร cc =) (ยง (byte \newline)))
        )

        (swap! no_mapping dec)
        (if (non-zero? nc)
            (vungetc nc))

        (reset! got_int false)            ;; CTRL-C typed after CTRL-V is not an interrupt
        cc
    ))

;; Insert character, taking care of special keys and mod_mask

(defn- #_void insert_special [#_int c, #_boolean allow_modmask, #_boolean ctrlv]
    ;; ctrlv: c was typed after CTRL-V
    (ยง
        ;; Special function key, translate into "<Key>".  Up to the last '>' is
        ;; inserted with ins_str(), so as not to replace characters in replace mode.
        ;; Only use mod_mask for special keys, to avoid things like <S-Space>,
        ;; unless 'allow_modmask' is true.

        (when (or (is_special c) (and (non-zero? @mod_mask) allow_modmask))
            ((ร Bytes p =) (get_special_key_name c, @mod_mask))
            ((ร int len =) (STRLEN p))
            ((ร c =) (ยง p.at(len - 1)))
            (when (< 2 len)
                (if (not (stop_arrow))
                    (ร RETURN)
                )
                (ยง p.be(len - 1, NUL))
                (ins_str p)
                (appendToRedobuffLit p, -1)
                ((ร ctrlv =) false)
            )
        )
        (when (stop_arrow)
            (insertchar c, (if ctrlv INSCHAR_CTRLV 0))
        )
    ))

;; Special characters in this context are those that need processing other
;; than the simple insertion that can be performed here.  This includes ESC
;; which terminates the insert, and CR/NL which need special processing to
;; open up a new line.  This routine tries to optimize insertions performed by
;; the "redo", "undo" or "put" commands, so it needs to know when it should
;; stop and defer processing to the "normal" mechanism.
;; '0' and '^' are special, because they can be followed by CTRL-D.

(defn- #_boolean isspecial [#_int c]
    (or (< c (byte \space)) (<= DEL c) (== c (byte \0)) (== c (byte \^))))

;; "flags": INSCHAR_CTRLV  - char typed just after CTRL-V

(defn- #_void insertchar [#_int c, #_int flags]
    ;; c: character to insert or NUL
    (ยง
        (if (== c NUL)           ;; only formatting was wanted
            (ร RETURN)
        )

        (reset! did_ai false)
        (reset! did_si false)
        (reset! can_si false)
        (reset! can_si_back false)

        ;; If there's any pending input, grab up to INPUT_BUFLEN at once.
        ;; This speeds up normal text input considerably.
        ;; Don't do this when 'cindent' or 'indentexpr' is set, because we might
        ;; need to re-indent at a ':', or any other character (but not what 'paste' is set)..
        ;; Don't do this when there an InsertCharPre autocommand is defined,
        ;; because we need to fire the event for every character.

        (cond (and (not (isspecial c)) (== (utf_char2len c) 1) (!= (vpeekc) NUL) (zero? (& @State REPLACE_FLAG)))
        (ยง
            ((ร final int INPUT_BUFLEN =) 100)
            ((ร Bytes buf =) (ยง new Bytes(INPUT_BUFLEN + 1)))

            (.be buf 0, c)
            ((ร int i =) 1)

            ;; Stop the string when:
            ;; - no more chars available
            ;; - finding a special character (command key)
            ;; - buffer is full
            ;; - running into the 'textwidth' boundary

            (while (ยง (c = vpeekc()) != NUL && !isspecial(c) && mb_byte2len(c) == 1 && i < INPUT_BUFLEN)
                ((ร c =) (vgetc))
                (.be buf (ยง i++), c)
            )

            (do_digraph -1)                 ;; clear digraphs
            (do_digraph (.at buf (- i 1)))      ;; may be the start of a digraph
            (.be buf i, NUL)
            (ins_str buf)
            (cond (non-zero? (& flags INSCHAR_CTRLV))
            (ยง
                (redo_literal (.at buf 0))
                ((ร i =) 1)
            )
            :else
            (ยง
                ((ร i =) 0)
            ))
            (if (non-eos? buf i)
                (appendToRedobuffLit (.plus buf i), -1))
        )
        :else
        (ยง
            ((ร int cc =) (utf_char2len c))
            (cond (< 1 cc)
            (ยง
                ((ร Bytes buf =) (ยง new Bytes(MB_MAXBYTES + 1)))

                (utf_char2bytes c, buf)
                (.be buf cc, NUL)
                (ins_char_bytes buf, cc)
                (appendCharToRedobuff c)
            )
            :else
            (ยง
                (ins_char c)
                (if (non-zero? (& flags INSCHAR_CTRLV))
                    (redo_literal c)
                    (appendCharToRedobuff c))
            ))
        ))
    ))

;; Put a character in the redo buffer, for when just after a CTRL-V.

(defn- #_void redo_literal [#_int c]
    (ยง
        ((ร Bytes buf =) (ยง new Bytes(10)))

        ;; Only digits need special treatment.  Translate them into a string of three digits.
        (cond (asc_isdigit c)
        (ยง
            (ยง vim_snprintf(buf, buf.size(), (u8 "%03d"), c))
            (appendToRedobuff buf)
        )
        :else
        (ยง
            (appendCharToRedobuff c)
        ))
    ))

;; start_arrow() is called when an arrow key is used in insert mode.
;; For undo/redo it resembles hitting the <ESC> key.

(defn- #_void start_arrow [#_pos_C end_insert_pos]
    ;; end_insert_pos: can be null
    (ยง
        (when (not @arrow_used)                ;; something has been inserted
            (appendToRedobuff ESC_STR)
            (stop_insert end_insert_pos, false, false)
            (reset! arrow_used true)          ;; this means we stopped the current insert
        )
    ))

;; stop_arrow() is called before a change is made in insert mode.
;; If an arrow key has been used, start a new insertion.
;; Returns false if undo is impossible, shouldn't insert then.

(defn- #_boolean stop_arrow []
    (ยง
        (cond @arrow_used
        (ยง
            (COPY_pos @insStart, (. @curwin w_cursor))    ;; new insertion starts here
            (when (and (< (. @insStart_orig col) (. @insStart col)) (not @ins_need_undo))
                ;; Don't update the original insert position when moved to the right,
                ;; except when nothing was inserted yet.
                (reset! update_insStart_orig false)
            )
            (reset! insStart_textlen (linetabsize (ml_get_curline)))

            (when (u_save_cursor)
                (reset! arrow_used false)
                (reset! ins_need_undo false)
            )

            (reset! ai_col 0)
            (when (non-zero? (& @State VREPLACE_FLAG))
                (reset! orig_line_count (.. @curbuf b_ml ml_line_count))
                (reset! vr_lines_changed 1)
            )
            (resetRedobuff)
            (appendToRedobuff (u8 "1i"))         ;; pretend we start an insertion
            (reset! new_insert_skip 2)
        )
        @ins_need_undo
        (ยง
            (if (u_save_cursor)
                (reset! ins_need_undo false))
        ))

        (or @arrow_used (not @ins_need_undo))
    ))

;; Do a few things to stop inserting.
;; "end_insert_pos" is where insert ended.
;; It is null when we already jumped to another window/buffer.

(defn- #_void stop_insert [#_pos_C end_insert_pos, #_boolean esc, #_boolean nomove]
    ;; esc: called by ins_esc()
    ;; nomove: <c-\><c-o>, don't move cursor
    (ยง
        (stop_redo_ins)
        (replace_flush)            ;; abandon replace stack

        ;; Save the inserted text for later redo with ^@ and CTRL-A.
        ;; Don't do it when "restart_edit" was set and nothing was inserted,
        ;; otherwise CTRL-O w and then <Left> will clear "last_insert".

        ((ร Bytes ptr =) (get_inserted))
        (when (or (zero? @did_restart_edit) (and (non-nil? ptr) (< @new_insert_skip (STRLEN ptr))))
            (reset! last_insert ptr)
            (reset! last_insert_skip @new_insert_skip)
        )

        (when (and (not @arrow_used) (non-nil? end_insert_pos))
            ;; If we just did an auto-indent, remove the white space from the end of the line,
            ;; and put the cursor back.  Do this when ESC was used or moving the cursor up/down.
            ;; Check for the old position still being valid, just in case the text got changed
            ;; unexpectedly.
            (when (and (not nomove) @did_ai (or esc (and (nil? (vim_strbyte @p_cpo, CPO_INDENT)) (!= (.. @curwin w_cursor lnum) (. end_insert_pos lnum)))) (<= (. end_insert_pos lnum) (.. @curbuf b_ml ml_line_count)))
                (ร int cc)

                ((ร pos_C tpos =) (ยง ยง_pos_C()))
                (COPY_pos tpos, (. @curwin w_cursor))

                (COPY_pos (. @curwin w_cursor), end_insert_pos)
                (check_cursor_col)                     ;; make sure it is not past the line
                (while true
                    (if (and (== (gchar_cursor) NUL) (< 0 (.. @curwin w_cursor col)))
                        (ยง --@curwin.w_cursor.col)
                    )
                    ((ร cc =) (gchar_cursor))
                    (if (not (vim_iswhite cc))
                        (ร BREAK)
                    )
                    (if (not (del_char true))
                        (ร BREAK)  ;; should not happen
                    )
                )
                (cond (!= (.. @curwin w_cursor lnum) (. tpos lnum))
                (ยง
                    (COPY_pos (. @curwin w_cursor), tpos)
                )
                :else
                (ยง
                    ;; reset tpos, could have been invalidated in the loop above
                    (COPY_pos tpos, (. @curwin w_cursor))
                    (ยง tpos.col++)
                    (if (and (!= cc NUL) (== (gchar_pos tpos) NUL))
                        (ยง @curwin.w_cursor.col++)      ;; put cursor back on the NUL
                    )
                ))

                ;; <C-S-Right> may have started Visual mode, adjust the position for deleted characters.
                (when (and @VIsual_active (== (. @VIsual lnum) (.. @curwin w_cursor lnum)))
                    ((ร int len =) (ยง STRLEN(ml_get_curline())))

                    (when (< len (. @VIsual col))
                        ((ร @VIsual.col =) len)
                        ((ร @VIsual.coladd =) 0)
                    )
                )
            )
        )

        (reset! did_ai false)
        (reset! did_si false)
        (reset! can_si false)
        (reset! can_si_back false)

        ;; Set '[ and '] to the inserted text.
        ;; When end_insert_pos is null we are now in a different buffer.
        (when (non-nil? end_insert_pos)
            (COPY_pos (. @curbuf b_op_start), @insStart)
            (COPY_pos (. @curbuf b_op_start_orig), @insStart_orig)
            (COPY_pos (. @curbuf b_op_end), end_insert_pos)
        )
    ))

;; Set the last inserted text to a single character.
;; Used for the replace command.

(defn- #_void set_last_insert [#_int c]
    (ยง
        (reset! last_insert (ยง new Bytes(MB_MAXBYTES * 3 + 5)))

        ((ร Bytes s =) @last_insert)
        ;; Use the CTRL-V only when entering a special char.
        (if (or (< c (byte \space)) (== c DEL))
            (ยง (s = s.plus(1)).be(-1, Ctrl_V))
        )
        ((ร s =) (add_char2buf c, s))
        (ยง (s = s.plus(1)).be(-1, ESC))
        (ยง (s = s.plus(1)).be(-1, NUL))
        (reset! last_insert_skip 0)
    ))

;; Add character "c" to buffer "s".
;; Escape the special meaning of KB_SPECIAL.
;; Handle multi-byte characters.
;; Returns a pointer to after the added bytes.

(defn- #_Bytes add_char2buf [#_int c, #_Bytes s]
    (ยง
        ((ร Bytes temp =) (ยง new Bytes(MB_MAXBYTES + 1)))
        ((ร int len =) (utf_char2bytes c, temp))
        ((ร FOR) (ร (ยง int i = 0) (< i len) (ยง i++))
            ((ร byte b =) (ยง temp.at(i)))
            ;; Need to escape KB_SPECIAL like in the typeahead buffer.
            (cond (== b KB_SPECIAL)
            (ยง
                (ยง (s = s.plus(1)).be(-1, KB_SPECIAL))
                (ยง (s = s.plus(1)).be(-1, KS_SPECIAL))
                (ยง (s = s.plus(1)).be(-1, KE_FILLER))
            )
            :else
            (ยง
                (ยง (s = s.plus(1)).be(-1, b))
            ))
        )
        s
    ))

;; Move cursor to start of line:
;;  if (flags & BL_WHITE) move to first non-white;
;;  if (flags & BL_SOL)   move to first non-white if startofline is set, otherwise keep "curswant" column;
;;  if (flags & BL_FIX)   don't leave the cursor on a NUL.

(defn- #_void beginline [#_int flags]
    (ยง
        (cond (and (non-zero? (& flags BL_SOL)) (not @p_sol))
        (ยง
            (coladvance (. @curwin w_curswant))
        )
        :else
        (ยง
            ((ร @curwin.w_cursor.col =) 0)
            ((ร @curwin.w_cursor.coladd =) 0)

            (when (non-zero? (ยง flags & (BL_WHITE | BL_SOL)))
                ((ร FOR) (ร (ยง Bytes ptr = ml_get_curline()) (ยง vim_iswhite(ptr.at(0)) && !((flags & BL_FIX) != 0 && ptr.at(1) == NUL)) (ยง ptr = ptr.plus(1)))
                    (ยง @curwin.w_cursor.col++)
                )
            )
            ((ร @curwin.w_set_curswant =) true)
        ))
    ))

;; oneright oneleft cursor_down cursor_up
;;
;; Move one char {right,left,down,up}.
;; Doesn't move onto the NUL past the end of the line, unless it is allowed.
;; Return true when successful, false when we hit a line of file boundary.

(defn- #_boolean oneright []
    (ยง
        (when (virtual_active)
            ((ร pos_C prevpos =) (ยง ยง_pos_C()))
            (COPY_pos prevpos, (. @curwin w_cursor))

            ;; Adjust for multi-wide char (excluding TAB).
            ((ร Bytes ptr =) (ml_get_cursor))
            (coladvance (+ (getviscol) (if (and (!= (.at ptr 0) TAB) (vim_isprintc (us_ptr2char ptr))) (mb_ptr2cells ptr) 1)))
            ((ร @curwin.w_set_curswant =) true)
            ;; Return true if the cursor moved, false otherwise (at window edge).
            ((ร RETURN) (ยง (prevpos.col != @curwin.w_cursor.col || prevpos.coladd != @curwin.w_cursor.coladd)))
        )

        ((ร Bytes ptr =) (ml_get_cursor))
        (if (eos? ptr)
            ((ร RETURN) false)           ;; already at the very end
        )

        ((ร int l =) (us_ptr2len_cc ptr))

        ;; Move "l" bytes right, but don't end up on the NUL, unless 'virtualedit' contains "onemore".
        (if (and (eos? ptr l) (zero? (& @ve_flags VE_ONEMORE)))
            ((ร RETURN) false)
        )
        ((ร @curwin.w_cursor.col +=) l)

        ((ร @curwin.w_set_curswant =) true)
        true
    ))

(defn- #_boolean oneleft []
    (ยง
        (when (virtual_active)
            ((ร int v =) (getviscol))
            (if (zero? v)
                ((ร RETURN) false)
            )

            ;; We might get stuck on 'showbreak', skip over it.
            ((ร FOR) (ร (ยง int width = 1) true nil)
                (coladvance (- v width))
                ;; getviscol() is slow, skip it when 'showbreak' is empty,
                ;; 'breakindent' is not set and there are no multi-byte characters
                (if (< (getviscol) v)
                    (ร BREAK)
                )
                (ยง width++)
            )

            (when (== (.. @curwin w_cursor coladd) 1)
                ;; Adjust for multi-wide char (not a TAB).
                ((ร Bytes ptr =) (ml_get_cursor))
                (if (and (!= (.at ptr 0) TAB) (vim_isprintc (us_ptr2char ptr)) (< 1 (mb_ptr2cells ptr)))
                    ((ร @curwin.w_cursor.coladd =) 0)
                )
            )

            ((ร @curwin.w_set_curswant =) true)
            ((ร RETURN) true)
        )

        (if (zero? (.. @curwin w_cursor col))
            ((ร RETURN) false)
        )

        ((ร @curwin.w_set_curswant =) true)
        (ยง --@curwin.w_cursor.col)

        ;; If the character on the left of the current cursor is a multi-byte character,
        ;; move to its first byte.
        (mb_adjust_pos @curbuf, (. @curwin w_cursor))
        true
    ))

(defn- #_boolean cursor_up [#_long n, #_boolean upd_topline]
    ;; upd_topline: When true: update topline
    (ยง
        (when (< 0 n)
            ((ร long lnum =) (.. @curwin w_cursor lnum))
            ;; This fails if the cursor is already in the first line or the count
            ;; is larger than the line number and '-' is in 'cpoptions'.
            (if (or (<= lnum 1) (and (<= lnum n) (non-nil? (vim_strbyte @p_cpo, CPO_MINUS))))
                ((ร RETURN) false)
            )
            (if (<= lnum n)
                ((ร lnum =) 1)
                ((ร lnum -=) n)
            )
            ((ร @curwin.w_cursor.lnum =) lnum)
        )

        ;; try to advance to the column we want to be at
        (coladvance (. @curwin w_curswant))

        (if upd_topline
            (update_topline))       ;; make sure curwin.w_topline is valid

        true
    ))

;; Cursor down a number of logical lines.

(defn- #_boolean cursor_down [#_long n, #_boolean upd_topline]
    ;; upd_topline: When true: update topline
    (ยง
        (when (< 0 n)
            ((ร long lnum =) (.. @curwin w_cursor lnum))
            ;; This fails if the cursor is already in the last line
            ;; or would move beyond the last line and '-' is in 'cpoptions'.
            (if (or (<= (.. @curbuf b_ml ml_line_count) lnum) (and (< (.. @curbuf b_ml ml_line_count) (+ lnum n)) (non-nil? (vim_strbyte @p_cpo, CPO_MINUS))))
                ((ร RETURN) false)
            )
            (if (<= (.. @curbuf b_ml ml_line_count) (+ lnum n))
                ((ร lnum =) (.. @curbuf b_ml ml_line_count))
                ((ร lnum +=) n)
            )
            ((ร @curwin.w_cursor.lnum =) lnum)
        )

        ;; try to advance to the column we want to be at
        (coladvance (. @curwin w_curswant))

        (if upd_topline
            (update_topline))       ;; make sure curwin.w_topline is valid

        true
    ))

;; Stuff the last inserted text in the read buffer.
;; Last_insert actually is a copy of the redo buffer, so we
;; first have to remove the command.

(defn- #_boolean stuff_inserted [#_int c, #_long count, #_boolean no_esc]
    ;; c: Command character to be inserted
    ;; count: Repeat this many times
    ;; no_esc: Don't add an ESC at the end
    (ยง
        ((ร Bytes ptr =) (get_last_insert))
        (when (nil? ptr)
            (emsg e_noinstext)
            ((ร RETURN) false)
        )

        ;; may want to stuff the command character, to start Insert mode
        (if (!= c NUL)
            (stuffcharReadbuff c))
        ((ร Bytes esc_ptr =) (vim_strrchr ptr, ESC))
        (if (non-nil? esc_ptr)
            (.be esc_ptr 0, NUL)     ;; remove the ESC
        )

        ((ร byte last =) NUL)

        ;; when the last char is either "0" or "^" it will be quoted if no ESC comes
        ;; after it OR if it will inserted more than once and "ptr" starts with ^D.

        ((ร Bytes last_ptr =) (if (!= esc_ptr null) (.minus esc_ptr 1) (.plus ptr (- (STRLEN ptr) 1))))
        (when (and (BLE ptr, last_ptr) (or (== (.at last_ptr 0) (byte \0)) (== (.at last_ptr 0) (byte \^))) (or no_esc (and (== (.at ptr 0) Ctrl_D) (< 1 count))))
            ((ร last =) (ยง last_ptr.at(0)))
            (.be last_ptr 0, NUL)
        )

;       do
;       {
            (stuffReadbuff ptr)
            ;; a trailing "0" is inserted as "<C-V>048", "^" as "<C-V>^"
            (if (!= last NUL)
                (stuffReadbuff (if (== last (byte \0)) (u8 "\026\060\064\070") (u8 "\026^"))))
;       } while (0 < --count);

        (if (!= last NUL)
            (.be last_ptr 0, last)
        )

        (if (non-nil? esc_ptr)
            (.be esc_ptr 0, ESC)     ;; put the ESC back
        )

        ;; may want to stuff a trailing ESC, to get out of Insert mode
        (if (not no_esc)
            (stuffcharReadbuff ESC))

        true
    ))

(defn- #_Bytes get_last_insert []
    (ยง
        (if (nil? @last_insert)
            ((ร RETURN) null)
        )

        (.plus @last_insert @last_insert_skip)
    ))

;; Get last inserted string, and remove trailing <Esc>.
;; Returns pointer to allocated memory (must be freed) or null.

(defn- #_Bytes get_last_insert_save []
    (ยง
        (if (nil? @last_insert)
            ((ร RETURN) null)
        )

        ((ร Bytes s =) (ยง STRDUP(@last_insert.plus(@last_insert_skip))))
        ((ร int len =) (STRLEN s))
        (if (and (< 0 len) (ยง s.at(len - 1) == ESC))       ;; remove trailing ESC
            (ยง s.be(len - 1, NUL))
        )
        s
    ))

;; replace-stack functions
;;
;; When replacing characters, the replaced characters are remembered for each
;; new character.  This is used to re-insert the old text when backspacing.
;;
;; There is a NUL headed list of characters for each character that is
;; currently in the file after the insertion point.  When BS is used, one NUL
;; headed list is put back for the deleted character.
;;
;; For a newline, there are two NUL headed lists.  One contains the characters
;; that the NL replaced.  The extra one stores the characters after the cursor
;; that were deleted (always white space).
;;
;; Replace_offset is normally 0, in which case replace_push will add a new
;; character at the end of the stack.  If replace_offset is not 0, that many
;; characters will be left on the stack above the newly inserted character.

(atom! Bytes    replace_stack)
(atom! int      replace_stack_nr)       ;; next entry in replace stack
(atom! int      replace_stack_len)      ;; max. number of entries

(defn- #_void replace_push [#_int c]
    ;; c: character that is replaced (NUL is none)
    (ยง
        (if (< @replace_stack_nr @replace_offset)      ;; nothing to do
            (ร RETURN)
        )

        (when (<= @replace_stack_len @replace_stack_nr)
            ((ร @replace_stack_len +=) 50)
            ((ร Bytes p =) (ยง new Bytes(@replace_stack_len)))
            (if (non-nil? @replace_stack)
                (BCOPY p, @replace_stack, @replace_stack_nr))
            (reset! replace_stack p)
        )

        ((ร Bytes p =) (ยง @replace_stack.plus(@replace_stack_nr - @replace_offset)))
        (if (non-zero? @replace_offset)
            (BCOPY p, 1, p, 0, @replace_offset))
        (.be p 0, c)
        (swap! replace_stack_nr inc)
    ))

;; Push a character onto the replace stack.
;; Handles a multi-byte character in reverse byte order, so that the first byte is popped off first.
;; Return the number of bytes done (includes composing characters).

(defn- #_int replace_push_mb [#_Bytes p]
    (ยง
        ((ร int l =) (us_ptr2len_cc p))

        ((ร FOR) (ร (ยง int j = l - 1) (<= 0 j) (ยง --j))
            (replace_push (.at p j))
        )

        l
    ))

;; Pop one item from the replace stack.
;; return -1 if stack empty
;; return replaced character or NUL otherwise

(defn- #_int replace_pop []
    (ยง
        (if (zero? @replace_stack_nr)
            ((ร RETURN) -1)
        )

        (.at @replace_stack (ยง --@replace_stack_nr))
    ))

;; Join the top two items on the replace stack.  This removes to "off"'th NUL encountered.

(defn- #_void replace_join [#_int off]
    ;; off: offset for which NUL to remove
    (ยง
        ((ร FOR) (ร (ยง int i = @replace_stack_nr) (ยง 0 <= --i) nil)
            (when (and (eos? @replace_stack i) (<= (ยง off--) 0))
                (swap! replace_stack_nr dec)
                (BCOPY @replace_stack, i, @replace_stack, (+ i 1), (- @replace_stack_nr i))
                (ร RETURN)
            )
        )
    ))

;; Pop bytes from the replace stack until a NUL is found, and insert them
;; before the cursor.  Can only be used in REPLACE or VREPLACE mode.

(defn- #_void replace_pop_ins []
    (ยง
        ((ร int oldState =) @State)
        (reset! State NORMAL)                     ;; don't want REPLACE here

        ((ร FOR) (ร (ยง int cc) (ยง 0 < (cc = replace_pop())) nil)
            (mb_replace_pop_ins cc)
            (dec_cursor)
        )

        (reset! State oldState)
    ))

;; Insert bytes popped from the replace stack. "cc" is the first byte.
;; If it indicates a multi-byte char, pop the other bytes too.

(defn- #_void mb_replace_pop_ins [#_int cc]
    (ยง
        ((ร Bytes buf =) (ยง new Bytes(MB_MAXBYTES + 1)))

        ((ร int n =) (mb_byte2len cc))
        (cond (< 1 n)
        (ยง
            (.be buf 0, cc)
            ((ร FOR) (ร (ยง int i = 1) (< i n) (ยง i++))
                (.be buf i, (replace_pop))
            )
            (ins_bytes_len buf, n)
        )
        :else
        (ยง
            (ins_char cc)
        ))

        ;; Handle composing chars.
        (while true
            ((ร int c =) (replace_pop))
            (if (== c -1)            ;; stack empty
                (ร BREAK)
            )
            (cond (ยง (n = mb_byte2len(c)) == 1)
            (ยง
                ;; Not a multi-byte char, put it back.
                (replace_push c)
                (ร BREAK)
            )
            :else
            (ยง
                (.be buf 0, c)
                ((ร FOR) (ร (ยง int i = 1) (< i n) (ยง i++))
                    (.be buf i, (replace_pop))
                )
                (cond (utf_iscomposing (us_ptr2char buf))
                (ยง
                    (ins_bytes_len buf, n)
                )
                :else
                (ยง
                    ;; Not a composing char, put it back.
                    ((ร FOR) (ร (ยง int i = n - 1) (<= 0 i) (ยง --i))
                        (replace_push (.at buf i))
                    )
                    (ร BREAK)
                ))
            ))
        )
    ))

;; make the replace stack empty
;; (called when exiting replace mode)

(defn- #_void replace_flush []
    (ยง
        (reset! replace_stack null)
        (reset! replace_stack_len 0)
        (reset! replace_stack_nr 0)
    ))

;; Handle doing a BS for one character.
;; cc < 0: replace stack empty, just move cursor
;; cc == 0: character was inserted, delete it
;; cc > 0: character was replaced, put cc (first byte of original char) back
;; and check for more characters to be put back
;; When "limit_col" is >= 0, don't delete before this column.  Matters when
;; using composing characters, use del_char_after_col() instead of del_char().

(defn- #_void replace_do_bs [#_int limit_col]
    (ยง
        ((ร int orig_len =) 0)
        ((ร int orig_vcols =) 0)

        ((ร int cc =) (replace_pop))
        (cond (< 0 cc)
        (ยง
            ((ร int[] start_vcol =) (ยง new int[1]))
            (when (non-zero? (& @State VREPLACE_FLAG))
                ;; Get the number of screen cells used by the character we are going to delete.
                (getvcol @curwin, (. @curwin w_cursor), null, start_vcol, null)
                ((ร orig_vcols =) (ยง chartabsize(ml_get_cursor(), start_vcol[0])))
            )

            (del_char_after_col limit_col)
            (if (non-zero? (& @State VREPLACE_FLAG))
                ((ร orig_len =) (ยง STRLEN(ml_get_cursor())))
            )
            (replace_push cc)

            (replace_pop_ins)

            (when (non-zero? (& @State VREPLACE_FLAG))
                ;; Get the number of screen cells used by the inserted characters.
                ((ร Bytes p =) (ml_get_cursor))
                ((ร int ins_len =) (ยง STRLEN(p) - orig_len))
                ((ร int vcol =) (ยง start_vcol[0]))
                ((ร FOR) (ร (ยง int i = 0) (< i ins_len) (ยง i++))
                    ((ร vcol +=) (ยง chartabsize(p.plus(i), vcol)))
                    ((ร i +=) (ยง us_ptr2len_cc(p) - 1))
                )
                ((ร vcol -=) (ยง start_vcol[0]))

                ;; Delete spaces that were inserted after the cursor to keep the text aligned.
                ((ร @curwin.w_cursor.col +=) ins_len)
                (while (ยง orig_vcols < vcol && gchar_cursor() == (byte \space))
                    (del_char false)
                    (ยง orig_vcols++)
                )
                ((ร @curwin.w_cursor.col -=) ins_len)
            )

            ;; mark the buffer as changed and prepare for displaying
            (changed_bytes (.. @curwin w_cursor lnum), (.. @curwin w_cursor col))
        )
        (zero? cc)
        (ยง
            (del_char_after_col limit_col)
        ))
    ))

(defn- #_void ins_reg []
    (ยง
        ((ร boolean need_redraw =) false)
        ((ร int literally =) 0)
        ((ร boolean vis_active =) @VIsual_active)

        ;; If we are going to wait for a character, show a '"'.

        (reset! pc_status PC_STATUS_UNSET)
        (when (and (redrawing) (not (char_avail)))
            ;; May need to redraw when no more chars available now.
            (ins_redraw false)

            (edit_putchar (byte \"), true)  ;; """
            (add_to_showcmd_c Ctrl_R)
        )

        ;; Don't map the register name.
        ;; This also prevents the mode message to be deleted when ESC is hit.

        (swap! no_mapping inc)
        ((ร int regname =) (plain_vgetc))
        (when (or (== regname Ctrl_R) (== regname Ctrl_O) (== regname Ctrl_P))
            ;; Get a third key for literal register insertion.
            ((ร literally =) regname)
            (add_to_showcmd_c literally)
            ((ร regname =) (plain_vgetc))
        )
        (swap! no_mapping dec)

        ;; Don't call u_sync() while typing the expression or giving an error message for it.
        ;; Only call it explicitly.
        (swap! no_u_sync inc)
        (when (== regname (byte \=))
            ;; Sync undo when evaluating the expression calls setline() or append(),
            ;; so that it can be undone separately.
            (reset! u_sync_once 2)

            ((ร regname =) (get_expr_register))
        )
        (cond (or (== regname NUL) (not (valid_yank_reg regname, false)))
        (ยง
            (vim_beep)
            ((ร need_redraw =) true)     ;; remove the '"'
        )
        :else
        (ยง
            (cond (or (== literally Ctrl_O) (== literally Ctrl_P))
            (ยง
                ;; Append the command to the redo buffer.
                (appendCharToRedobuff Ctrl_R)
                (appendCharToRedobuff literally)
                (appendCharToRedobuff regname)

                (do_put regname, BACKWARD, 1, (| (if (== literally Ctrl_P) PUT_FIXINDENT 0) PUT_CURSEND))
            )
            (not (insert_reg regname, (non-zero? literally)))
            (ยง
                (vim_beep)
                ((ร need_redraw =) true) ;; remove the '"'
            )
            @stop_insert_mode
            (ยง
                ;; When the '=' register was used and a function was invoked that
                ;; did ":stopinsert" then stuff_empty() returns false but we won't
                ;; insert anything, need to remove the '"'
                ((ร need_redraw =) true)
            ))
        ))
        (swap! no_u_sync dec)
        (if (== @u_sync_once 1)
            (reset! ins_need_undo true))
        (reset! u_sync_once 0)
        (clear_showcmd)

        ;; If the inserted register is empty, we need to remove the '"'.
        (if (or need_redraw (stuff_empty))
            (edit_unputchar))

        ;; Disallow starting Visual mode here, would get a weird mode.
        (when (and (not vis_active) @VIsual_active)
            (end_visual_mode)
        )
    ))

;; CTRL-G commands in Insert mode.

(defn- #_void ins_ctrl_g []
    (ยง
        ;; Don't map the second key.  This also prevents the mode message to be deleted when ESC is hit.

        (swap! no_mapping inc)
        ((ร int c =) (plain_vgetc))
        (swap! no_mapping dec)
        ((ร SWITCH) c
            ;; CTRL-G k and CTRL-G <Up>: cursor up to insStart.col.
            ((ร CASE) K_UP)
            ((ร CASE) Ctrl_K)
            ((ร CASE) (byte \k))
            (ยง
                (ins_up true)
                (ร BREAK)
            )

            ;; CTRL-G j and CTRL-G <Down>: cursor down to insStart.col.
            ((ร CASE) K_DOWN)
            ((ร CASE) Ctrl_J)
            ((ร CASE) (byte \j))
            (ยง
                (ins_down true)
                (ร BREAK)
            )

            ;; CTRL-G u: start new undoable edit.
            ((ร CASE) (byte \u))
            (ยง
                (u_sync true)
                (reset! ins_need_undo true)

                ;; Need to reset insStart, esp. because a BS that joins
                ;; a line to the previous one must save for undo.
                (reset! update_insStart_orig false)
                (COPY_pos @insStart, (. @curwin w_cursor))
                (ร BREAK)
            )

            ;; Unknown CTRL-G command, reserved for future expansion.
            (ร DEFAULT)
            (ยง
                (vim_beep)
                (ร BREAK)
            )
        )
    ))

;; CTRL-^ in Insert mode.

(defn- #_void ins_ctrl_hat []
    (ยง
;       
        (showmode)
    ))

(atom! boolean disabled_redraw)

;; Handle ESC in insert mode.
;; Returns true when leaving insert mode, false when going to repeat the insert.

(defn- #_boolean ins_esc [#_long* count, #_int cmdchar, #_boolean nomove]
    ;; nomove: don't move cursor
    (ยง
        ((ร int temp =) (.. @curwin w_cursor col))

        (when @disabled_redraw
            (swap! redrawingDisabled dec)
            (reset! disabled_redraw false)
        )
        (when (not @arrow_used)
            ;; Don't append the ESC for "r<CR>" and "grx".
            ;; When 'insertmode' is set only CTRL-L stops Insert mode.
            ;; Needed for when "count" is non-zero.

            (if (and (!= cmdchar (byte \r)) (!= cmdchar (byte \v)))
                (appendToRedobuff (if @p_im (u8 "\014") ESC_STR)))

            ;; Repeating insert may take a long time.  Check for interrupt now and then.

            (when (< 0 (ยง count[0]))
                (line_breakcheck)
                (if @got_int
                    ((ร count[0] =) 0)
                )
            )

            (when (< 0 (ยง --count[0]))       ;; repeat what was typed
                ;; Vi repeats the insert without replacing characters.
                (if (non-nil? (vim_strbyte @p_cpo, CPO_REPLCNT))
                    ((ร @State &=) (ยง ~REPLACE_FLAG))
                )

                (start_redo_ins)
                (if (or (== cmdchar (byte \r)) (== cmdchar (byte \v)))
                    (stuffRedoReadbuff ESC_STR))     ;; no ESC in redo buffer
                (swap! redrawingDisabled inc)
                (reset! disabled_redraw true)
                ((ร RETURN) false)       ;; repeat the insert
            )
            (stop_insert (. @curwin w_cursor), true, nomove)
        )

        ;; When an autoindent was removed, curswant stays after the indent.
        (if (and (== @restart_edit NUL) (== temp (.. @curwin w_cursor col)))
            ((ร @curwin.w_set_curswant =) true)
        )

        ;; Remember the last Insert position in the '^ mark.
        (COPY_pos (. @curbuf b_last_insert), (. @curwin w_cursor))

        ;; The cursor should end up on the last inserted character.
        ;; Don't do it for CTRL-O, unless past the end of the line.

        (when (and (not nomove) (or (!= (.. @curwin w_cursor col) 0) (< 0 (.. @curwin w_cursor coladd))) (or (== @restart_edit NUL) (and (== (gchar_cursor) NUL) (not @VIsual_active))))
            (cond (or (< 0 (.. @curwin w_cursor coladd)) (== @ve_flags VE_ALL))
            (ยง
                (oneleft)
                (if (!= @restart_edit NUL)
                    (ยง @curwin.w_cursor.coladd++)
                )
            )
            :else
            (ยง
                (ยง --@curwin.w_cursor.col)
                ;; Correct cursor for multi-byte character.
                (mb_adjust_pos @curbuf, (. @curwin w_cursor))
            ))
        )

        (reset! State NORMAL)
        ;; need to position cursor again (e.g. when on a TAB )
        (changed_cline_bef_curs)

        (ui_cursor_shape)          ;; may show different cursor shape

        ;; When recording or for CTRL-O, need to display the new mode.
        ;; Otherwise remove the mode message.

        (cond (or @Recording (!= @restart_edit NUL))
        (ยง
            (showmode)
        )
        @p_smd
        (ยง
            (msg (u8 ""))
        ))

        true            ;; exit Insert mode
    ))

;; If 'keymodel' contains "startsel", may start selection.
;; Returns true when a CTRL-O and other keys stuffed.

(defn- #_boolean ins_start_select [#_int c]
    (ยง
        (when @km_startsel
            ((ร SWITCH) c
                ((ร CASE) K_KHOME)
                ((ร CASE) K_KEND)
                ((ร CASE) K_PAGEUP)
                ((ร CASE) K_KPAGEUP)
                ((ร CASE) K_PAGEDOWN)
                ((ร CASE) K_KPAGEDOWN)
                (ยง
                    (if (zero? (& @mod_mask MOD_MASK_SHIFT))
                        (ร BREAK)
                    )
                    (ร FALLTHROUGH)
                )
                ((ร CASE) K_S_LEFT)
                ((ร CASE) K_S_RIGHT)
                ((ร CASE) K_S_UP)
                ((ร CASE) K_S_DOWN)
                ((ร CASE) K_S_END)
                ((ร CASE) K_S_HOME)
                (ยง
                    ;; Start selection right away, the cursor can move with
                    ;; CTRL-O when beyond the end of the line.
                    (start_selection)

                    ;; Execute the key in (insert) Select mode.
                    (stuffcharReadbuff Ctrl_O)
                    (when (non-zero? @mod_mask)
                        ((ร Bytes buf =) (ยง new Bytes(4)))

                        (.be buf 0, KB_SPECIAL)
                        (.be buf 1, KS_MODIFIER)
                        (.be buf 2, @mod_mask)
                        (.be buf 3, NUL)
                        (stuffReadbuff buf)
                    )
                    (stuffcharReadbuff c)
                    ((ร RETURN) true)
                )
            )
        )

        false
    ))

;; <Insert> key in Insert mode: toggle insert/replace mode.

(defn- #_void ins_insert [#_int replaceState]
    (ยง
        (if (non-zero? (& @State REPLACE_FLAG))
            (reset! State INSERT)
            (reset! State replaceState))
        (appendCharToRedobuff K_INS)
        (showmode)
        (ui_cursor_shape)          ;; may show different cursor shape
    ))

;; Pressed CTRL-O in Insert mode.

(defn- #_void ins_ctrl_o []
    (ยง
        (cond (non-zero? (& @State VREPLACE_FLAG))
        (ยง
            (reset! restart_edit (byte \V))
        )
        (non-zero? (& @State REPLACE_FLAG))
        (ยง
            (reset! restart_edit (byte \R))
        )
        :else
        (ยง
            (reset! restart_edit (byte \I))
        ))

        (if (virtual_active)
            (reset! ins_at_eol false)     ;; cursor always keeps its column
            (reset! ins_at_eol (== (gchar_cursor) NUL)))
    ))

;; If the cursor is on an indent, ^T/^D insert/delete one shiftwidth.
;; Otherwise ^T/^D behave like a "<<" or ">>".
;; Always round the indent to 'shiftwidth', this is compatible with vi.
;; But vi only supports ^T and ^D after an autoindent, we support it everywhere.

(defn- #_void ins_shift [#_int c, #_int lastc]
    (ยง
        (if (not (stop_arrow))
            (ร RETURN)
        )

        (appendCharToRedobuff c)

        ;; 0^D and ^^D: remove all indent.

        (cond (and (== c Ctrl_D) (or (== lastc (byte \0)) (== lastc (byte \^))) (< 0 (.. @curwin w_cursor col)))
        (ยง
            (ยง --@curwin.w_cursor.col)
            (del_char false)                ;; delete the '^' or '0'
            ;; In Replace mode, restore the characters that '^' or '0' replaced.
            (if (non-zero? (& @State REPLACE_FLAG))
                (replace_pop_ins))
            (if (== lastc (byte \^))
                (reset! old_indent (get_indent)))  ;; remember curr. indent
            (change_indent INDENT_SET, 0, true, NUL, true)
        )
        :else
        (ยง
            (change_indent (if (== c Ctrl_D) INDENT_DEC INDENT_INC), 0, true, NUL, true)
        ))

        (if (and @did_ai (!= (.at (skipwhite (ml_get_curline)) 0) NUL))
            (reset! did_ai false))
        (reset! did_si false)
        (reset! can_si false)
        (reset! can_si_back false)
        (reset! can_cindent false)        ;; no cindenting after ^D or ^T
    ))

(defn- #_void ins_del []
    (ยง
        (if (not (stop_arrow))
            (ร RETURN)
        )

        (cond (== (gchar_cursor) NUL)              ;; delete newline
        (ยง
            ((ร int temp =) (.. @curwin w_cursor col))
            (cond (or (not (can_bs BS_EOL)) (not (do_join 2, false, true, false, false)))                 ;; only if "eol" included
            (ยง
                (vim_beep)
            )
            :else
            (ยง
                ((ร @curwin.w_cursor.col =) temp)
            ))
        )
        (not (del_char false))      ;; delete char under cursor
        (ยง
            (vim_beep)
        ))

        (reset! did_ai false)
        (reset! did_si false)
        (reset! can_si false)
        (reset! can_si_back false)

        (appendCharToRedobuff K_DEL)
    ))

;; Delete one character for ins_bs().

(defn- #_void ins_bs_one [#_int* vcolp]
    (ยง
        (dec_cursor)
        (getvcol @curwin, (. @curwin w_cursor), vcolp, null, null)
        (cond (non-zero? (& @State REPLACE_FLAG))
        (ยง
            ;; Don't delete characters before the insert point when in Replace mode.
            (if (or (!= (.. @curwin w_cursor lnum) (. @insStart lnum)) (<= (. @insStart col) (.. @curwin w_cursor col)))
                (replace_do_bs -1))
        )
        :else
        (ยง
            (del_char false)
        ))
    ))

;; Handle Backspace, delete-word and delete-line in Insert mode.
;; Return true when backspace was actually used.

(defn- #_boolean ins_bs [#_int c, #_int mode, #_boolean* inserted_space_p]
    (ยง
        ((ร boolean did_backspace =) false)

        ;; can't delete anything in an empty file
        ;; can't backup past first character in buffer
        ;; can't backup past starting point unless 'backspace' > 1
        ;; can backup to a previous line if 'backspace' == 0

        (when (or (bufempty) (and (== (.. @curwin w_cursor lnum) 1) (zero? (.. @curwin w_cursor col))) (and (not (can_bs BS_START)) (or @arrow_used (and (== (.. @curwin w_cursor lnum) (. @insStart_orig lnum)) (<= (.. @curwin w_cursor col) (. @insStart_orig col))))) (and (not (can_bs BS_INDENT)) (not @arrow_used) (< 0 @ai_col) (<= (.. @curwin w_cursor col) @ai_col)) (and (not (can_bs BS_EOL)) (zero? (.. @curwin w_cursor col))))
            (vim_beep)
            ((ร RETURN) false)
        )

        (if (not (stop_arrow))
            ((ร RETURN) false)
        )

        ((ร boolean in_indent =) (inindent 0))
        (if in_indent
            (reset! can_cindent false))

        ;; Virtualedit:
        ;;  BACKSPACE_CHAR eats a virtual space
        ;;  BACKSPACE_WORD eats all coladd
        ;;  BACKSPACE_LINE eats all coladd and keeps going

        (when (< 0 (.. @curwin w_cursor coladd))
            (when (== mode BACKSPACE_CHAR)
                (ยง --@curwin.w_cursor.coladd)
                ((ร RETURN) true)
            )
            (when (== mode BACKSPACE_WORD)
                ((ร @curwin.w_cursor.coladd =) 0)
                ((ร RETURN) true)
            )
            ((ร @curwin.w_cursor.coladd =) 0)
        )

        ;; delete newline!

        (cond (zero? (.. @curwin w_cursor col))
        (ยง
            ((ร long lnum =) (. @insStart lnum))
            (when (== (.. @curwin w_cursor lnum) lnum)
                (if (not (u_save (- (.. @curwin w_cursor lnum) 2), (+ (.. @curwin w_cursor lnum) 1)))
                    ((ร RETURN) false)
                )
                (ยง --@insStart.lnum)
                ((ร @insStart.col =) MAXCOL)
            )

            ;; In replace mode:
            ;; cc < 0: NL was inserted, delete it
            ;; cc >= 0: NL was replaced, put original characters back

            ((ร int cc =) -1)
            (if (non-zero? (& @State REPLACE_FLAG))
                ((ร cc =) (replace_pop))     ;; returns -1 if NL was inserted
            )

            ;; In replace mode, in the line we started replacing, we only move the cursor.

            (cond (and (non-zero? (& @State REPLACE_FLAG)) (<= (.. @curwin w_cursor lnum) lnum))
            (ยง
                (dec_cursor)
            )
            :else
            (ยง
                (cond (or (zero? (& @State VREPLACE_FLAG)) (< @orig_line_count (.. @curwin w_cursor lnum)))
                (ยง
                    ((ร int temp =) (gchar_cursor))      ;; remember current char
                    (ยง --@curwin.w_cursor.lnum)

                    (do_join 2, false, false, false, false)
                    (if (and (== temp NUL) (!= (gchar_cursor) NUL))
                        (inc_cursor))
                )
                :else
                (ยง
                    (dec_cursor)
                ))

                ;; In REPLACE mode we have to put back the text that was replaced by the NL.
                ;; On the replace stack is first a NUL-terminated sequence of characters
                ;; that were deleted and then the characters that NL replaced.

                (when (non-zero? (& @State REPLACE_FLAG))
                    ;; Do the next ins_char() in NORMAL state, to prevent ins_char()
                    ;; from replacing characters and avoiding showmatch().

                    ((ร int oldState =) @State)
                    (reset! State NORMAL)

                    ;; restore characters (blanks) deleted after cursor

                    (while (< 0 cc)
                        ((ร int save_col =) (.. @curwin w_cursor col))
                        (mb_replace_pop_ins cc)
                        ((ร @curwin.w_cursor.col =) save_col)
                        ((ร cc =) (replace_pop))
                    )
                    ;; restore the characters that NL replaced
                    (replace_pop_ins)
                    (reset! State oldState)
                )
            ))
            (reset! did_ai false)
        )
        :else
        (ยง
            ;; Delete character(s) before the cursor.

            ((ร int mincol =) 0)
                                                    ;; keep indent
            (when (and (== mode BACKSPACE_LINE) @(. @curbuf b_p_ai))
                ((ร int save_col =) (.. @curwin w_cursor col))
                (beginline BL_WHITE)
                (if (< (.. @curwin w_cursor col) save_col)
                    ((ร mincol =) (.. @curwin w_cursor col))
                )
                ((ร @curwin.w_cursor.col =) save_col)
            )

            ;; Handle deleting one 'shiftwidth' or 'softtabstop'.

            (cond (and (== mode BACKSPACE_CHAR) (or (and @p_sta in_indent) (and (non-zero? (get_sts_value)) (< 0 (.. @curwin w_cursor col)) (or (== (.at (ml_get_cursor) -1) TAB) (and (== (.at (ml_get_cursor) -1) (byte \space)) (or (not (ยง inserted_space_p[0])) @arrow_used))))))
            (ยง
                ((ร inserted_space_p[0] =) false)

                (ร int ts)
                (if (and @p_sta in_indent)
                    ((ร ts =) (ยง (int)get_sw_value(@curbuf)))
                    ((ร ts =) (ยง (int)get_sts_value()))
                )

                ;; Compute the virtual column where we want to be.  Since 'showbreak' may
                ;; get in the way, need to get the last column of the previous character.
                ((ร int[] vcol =) (ยง new int[1]))
                (getvcol @curwin, (. @curwin w_cursor), vcol, null, null)
                ((ร int start_vcol =) (ยง vcol[0]))
                (dec_cursor)
                ((ร int[] want_vcol =) (ยง new int[1]))
                (getvcol @curwin, (. @curwin w_cursor), null, null, want_vcol)
                (inc_cursor)
                ((ร want_vcol[0] =) (ยง (want_vcol[0] / ts) * ts))

                ;; delete characters until we are at or before "want_vcol"
                (while (ยง want_vcol[0] < vcol[0] && vim_iswhite(ml_get_cursor().at(-1)))
                    (ins_bs_one vcol)
                )

                ;; insert extra spaces until we are at "want_vcol"
                (while (ยง vcol[0] < want_vcol[0])
                    ;; Remember the first char we inserted.
                    (if (and (== (.. @curwin w_cursor lnum) (. @insStart_orig lnum)) (< (.. @curwin w_cursor col) (. @insStart_orig col)))
                        ((ร @insStart_orig.col =) (.. @curwin w_cursor col))
                    )

                    (cond (non-zero? (& @State VREPLACE_FLAG))
                    (ยง
                        (ins_char (byte \space))
                    )
                    :else
                    (ยง
                        (ins_str (u8 " "))
                        (if (non-zero? (& @State REPLACE_FLAG))
                            (replace_push NUL))
                    ))
                    (getvcol @curwin, (. @curwin w_cursor), vcol, null, null)
                )

                ;; If we are now back where we started delete one character.
                ;; Can happen when using 'sts' and 'linebreak'.
                (if (<= start_vcol (ยง vcol[0]))
                    (ins_bs_one vcol))
            )
            :else ;; Delete upto starting point, start of line or previous word.
            (ยง
                ((ร int prev_cclass =) 0)
                ((ร int cclass =) (ยง us_get_class(ml_get_cursor(), @curbuf)))

                ((ร boolean temp =) false)
;               do
;               {
                    (dec_cursor)           ;; put cursor on char to be deleted

                    ((ร int cc =) (gchar_cursor))
                    ;; look multi-byte character class
                    ((ร prev_cclass =) cclass)
                    ((ร cclass =) (ยง us_get_class(ml_get_cursor(), @curbuf)))

                    ;; start of word?
                    (cond (and (== mode BACKSPACE_WORD) (not (vim_isspace cc)))
                    (ยง
                        ((ร mode =) BACKSPACE_WORD_NOT_SPACE)
                        ((ร temp =) (vim_iswordc cc, @curbuf))
                    )
                    ;; end of word?
                    (and (== mode BACKSPACE_WORD_NOT_SPACE) (or (vim_isspace cc) (!= (vim_iswordc cc, @curbuf) temp) (!= prev_cclass cclass)))
                    (ยง
                        (inc_cursor)
                        (ร BREAK)
                    ))

                    (cond (non-zero? (& @State REPLACE_FLAG))
                    (ยง
                        (replace_do_bs -1)
                    )
                    :else
                    (ยง
                        ((ร int[] cpc =) (ยง new int[MAX_MCO]))   ;; composing characters
                        (if @p_deco
                            (us_ptr2char_cc (ml_get_cursor), cpc))
                        (del_char false)

                        ;; If there are combining characters and 'delcombine' is set
                        ;; move the cursor back.  Don't back up before the base character.

                        (if (and @p_deco (!= (ยง cpc[0]) NUL))
                            (inc_cursor))
                    ))
                    ;; Just a single backspace?:
                    (if (== mode BACKSPACE_CHAR)
                        (ร BREAK)
                    )
;               } while (mincol < @curwin.w_cursor.col && (@curwin.w_cursor.lnum != @insStart_orig.lnum || @curwin.w_cursor.col != @insStart_orig.col));
            ))
            ((ร did_backspace =) true)
        ))

        (reset! did_si false)
        (reset! can_si false)
        (reset! can_si_back false)
        (if (<= (.. @curwin w_cursor col) 1)
            (reset! did_ai false))

        ;; It's a little strange to put backspaces into the redo buffer,
        ;; but it makes auto-indent a lot easier to deal with.

        (appendCharToRedobuff c)

        ;; If deleted before the insertion point, adjust it.
        (if (and (== (.. @curwin w_cursor lnum) (. @insStart_orig lnum)) (< (.. @curwin w_cursor col) (. @insStart_orig col)))
            ((ร @insStart_orig.col =) (.. @curwin w_cursor col))
        )

        did_backspace
    ))

(defn- #_void ins_left []
    (ยง
        ((ร pos_C tpos =) (ยง ยง_pos_C()))
        (COPY_pos tpos, (. @curwin w_cursor))

        (cond (oneleft)
        (ยง
            (start_arrow tpos)
        )
        ;; if 'whichwrap' set for cursor in insert mode may go to previous line
        (and (!= (vim_strchr @p_ww, (byte \[)) null) (< 1 (.. @curwin w_cursor lnum)))
        (ยง
            (start_arrow tpos)
            (ยง --@curwin.w_cursor.lnum)
            (coladvance MAXCOL)
            ((ร @curwin.w_set_curswant =) true)   ;; so we stay at the end
        )
        :else
        (ยง
            (vim_beep)
        ))
    ))

(defn- #_void ins_home [#_int c]
    (ยง
        ((ร pos_C tpos =) (ยง ยง_pos_C()))
        (COPY_pos tpos, (. @curwin w_cursor))

        (if (== c K_C_HOME)
            ((ร @curwin.w_cursor.lnum =) 1)
        )
        ((ร @curwin.w_cursor.col =) 0)
        ((ร @curwin.w_cursor.coladd =) 0)
        ((ร @curwin.w_curswant =) 0)

        (start_arrow tpos)
    ))

(defn- #_void ins_end [#_int c]
    (ยง
        ((ร pos_C tpos =) (ยง ยง_pos_C()))
        (COPY_pos tpos, (. @curwin w_cursor))

        (if (== c K_C_END)
            ((ร @curwin.w_cursor.lnum =) (.. @curbuf b_ml ml_line_count))
        )
        (coladvance MAXCOL)
        ((ร @curwin.w_curswant =) MAXCOL)

        (start_arrow tpos)
    ))

(defn- #_void ins_s_left []
    (ยง
        (cond (or (< 1 (.. @curwin w_cursor lnum)) (< 0 (.. @curwin w_cursor col)))
        (ยง
            (start_arrow (. @curwin w_cursor))
            (bck_word 1, false, false)
            ((ร @curwin.w_set_curswant =) true)
        )
        :else
        (ยง
            (vim_beep)
        ))
    ))

(defn- #_void ins_right []
    (ยง
        (cond (or (!= (gchar_cursor) NUL) (virtual_active))
        (ยง
            (start_arrow (. @curwin w_cursor))
            ((ร @curwin.w_set_curswant =) true)
            (if (virtual_active)
                (oneright)
                ((ร @curwin.w_cursor.col +=) (ยง us_ptr2len_cc(ml_get_cursor())))
            )
        )
        ;; if 'whichwrap' set for cursor in insert mode, may move the cursor to the next line
        (and (!= (vim_strchr @p_ww, (byte \])) null) (< (.. @curwin w_cursor lnum) (.. @curbuf b_ml ml_line_count)))
        (ยง
            (start_arrow (. @curwin w_cursor))
            ((ร @curwin.w_set_curswant =) true)
            (ยง @curwin.w_cursor.lnum++)
            ((ร @curwin.w_cursor.col =) 0)
        )
        :else
        (ยง
            (vim_beep)
        ))
    ))

(defn- #_void ins_s_right []
    (ยง
        (cond (or (< (.. @curwin w_cursor lnum) (.. @curbuf b_ml ml_line_count)) (!= (gchar_cursor) NUL))
        (ยง
            (start_arrow (. @curwin w_cursor))
            (fwd_word 1, false, false)
            ((ร @curwin.w_set_curswant =) true)
        )
        :else
        (ยง
            (vim_beep)
        ))
    ))

(defn- #_void ins_up [#_boolean startcol]
    ;; startcol: when true move to insStart.col
    (ยง
        ((ร long old_topline =) (. @curwin w_topline))

        ((ร pos_C tpos =) (ยง ยง_pos_C()))
        (COPY_pos tpos, (. @curwin w_cursor))

        (cond (cursor_up 1, true)
        (ยง
            (if startcol
                (coladvance (getvcol_nolist @insStart)))
            (if (!= old_topline (. @curwin w_topline))
                (redraw_later VALID))
            (start_arrow tpos)
            (reset! can_cindent true)
        )
        :else
        (ยง
            (vim_beep)
        ))
    ))

(defn- #_void ins_pageup []
    (ยง
        (when (zero? (& @mod_mask MOD_MASK_CTRL))
            ((ร pos_C tpos =) (ยง ยง_pos_C()))
            (COPY_pos tpos, (. @curwin w_cursor))

            (cond (onepage BACKWARD, 1)
            (ยง
                (start_arrow tpos)
                (reset! can_cindent true)
            )
            :else
            (ยง
                (vim_beep)
            ))
        )
    ))

(defn- #_void ins_down [#_boolean startcol]
    ;; startcol: when true move to insStart.col
    (ยง
        ((ร long old_topline =) (. @curwin w_topline))

        ((ร pos_C tpos =) (ยง ยง_pos_C()))
        (COPY_pos tpos, (. @curwin w_cursor))

        (cond (cursor_down 1, true)
        (ยง
            (if startcol
                (coladvance (getvcol_nolist @insStart)))
            (if (!= old_topline (. @curwin w_topline))
                (redraw_later VALID))
            (start_arrow tpos)
            (reset! can_cindent true)
        )
        :else
        (ยง
            (vim_beep)
        ))
    ))

(defn- #_void ins_pagedown []
    (ยง
        (when (zero? (& @mod_mask MOD_MASK_CTRL))
            ((ร pos_C tpos =) (ยง ยง_pos_C()))
            (COPY_pos tpos, (. @curwin w_cursor))

            (cond (onepage FORWARD, 1)
            (ยง
                (start_arrow tpos)
                (reset! can_cindent true)
            )
            :else
            (ยง
                (vim_beep)
            ))
        )
    ))

(defn- #_void ins_drop []
    (do_put (byte \~), BACKWARD, 1, PUT_CURSEND))

;; Handle TAB in Insert or Replace mode.
;; Return true when the TAB needs to be inserted like a normal character.

(defn- #_boolean ins_tab []
    (ยง
        (if (and (== @insStart_blank_vcol MAXCOL) (== (.. @curwin w_cursor lnum) (. @insStart lnum)))
            (reset! insStart_blank_vcol (get_nolist_virtcol)))

        ((ร boolean ind =) (inindent 0))
        (if ind
            (reset! can_cindent false))

        ;; When nothing special, insert TAB like a normal character

        (when (and (not @(. @curbuf b_p_et)) (not (and @p_sta ind (!= @(. @curbuf b_p_ts) (get_sw_value @curbuf)))) (zero? (get_sts_value)))
            ((ร RETURN) true)
        )

        (if (not (stop_arrow))
            ((ร RETURN) true)
        )

        (reset! did_ai false)
        (reset! did_si false)
        (reset! can_si false)
        (reset! can_si_back false)

        (appendToRedobuff (u8 "\t"))

        (ร int temp)
        (cond (and @p_sta ind)                       ;; insert tab in indent, use 'shiftwidth'
        (ยง
            ((ร temp =) (ยง (int)get_sw_value(@curbuf)))
        )
        (!= @(. @curbuf b_p_sts) 0)           ;; use 'softtabstop' when set
        (ยง
            ((ร temp =) (ยง (int)get_sts_value()))
        )
        :else                                    ;; otherwise use 'tabstop'
        (ยง
            ((ร temp =) (ยง (int)@curbuf.@b_p_ts))
        ))
        ((ร temp -=) (ยง get_nolist_virtcol() % temp))

        ;; Insert the first space with ins_char().  It will delete one char in
        ;; replace mode.  Insert the rest with ins_str(); it will not delete any
        ;; chars.  For VREPLACE mode, we use ins_char() for all characters.

        (ins_char (byte \space))
        (while (ยง 0 < --temp)
            (cond (non-zero? (& @State VREPLACE_FLAG))
            (ยง
                (ins_char (byte \space))
            )
            :else
            (ยง
                (ins_str (u8 " "))
                (if (non-zero? (& @State REPLACE_FLAG))    ;; no char replaced
                    (replace_push NUL))
            ))
        )

        ;; When 'expandtab' not set: Replace spaces by TABs where possible.

        (when (and (not @(. @curbuf b_p_et)) (or (non-zero? (get_sts_value)) (and @p_sta ind)))
            ;; Get the current line.
            ;; For VREPLACE mode, don't make real changes yet, just work on a copy of the line.

            ((ร pos_C pos =) (ยง ยง_pos_C()))
            (ร pos_C cursor)
            ((ร Bytes saved_line =) null)
            (ร Bytes ptr)
            (cond (non-zero? (& @State VREPLACE_FLAG))
            (ยง
                (COPY_pos pos, (. @curwin w_cursor))
                ((ร cursor =) pos)
                ((ร saved_line =) (ยง STRDUP(ml_get_curline())))
                ((ร ptr =) (ยง saved_line.plus(pos.col)))
            )
            :else
            (ยง
                ((ร ptr =) (ml_get_cursor))
                ((ร cursor =) (. @curwin w_cursor))
            ))

            ;; Find first white before the cursor.
            ((ร pos_C fpos =) (ยง ยง_pos_C()))
            (COPY_pos fpos, (. @curwin w_cursor))
            (while (ยง 0 < fpos.col && vim_iswhite(ptr.at(-1)))
                (ยง --fpos.col)
                ((ร ptr =) (ยง ptr.minus(1)))
            )

            ;; In Replace mode, don't change characters before the insert point.
            (when (and (non-zero? (& @State REPLACE_FLAG)) (== (. fpos lnum) (. @insStart lnum)) (< (. fpos col) (. @insStart col)))
                ((ร ptr =) (ยง ptr.plus(@insStart.col - fpos.col)))
                ((ร fpos.col =) (. @insStart col))
            )

            ;; compute virtual column numbers of first white and cursor
            ((ร int[] vcol =) (ยง new int[1]))
            (getvcol @curwin, fpos, vcol, null, null)
            ((ร int[] want_vcol =) (ยง new int[1]))
            (getvcol @curwin, cursor, want_vcol, null, null)

            ((ร int change_col =) -1)
            ;; Use as many TABs as possible.
            ;; Beware of 'breakindent', 'showbreak' and 'linebreak' adding extra virtual columns.
            (while (ยง vim_iswhite(ptr.at(0)))
                ((ร int i =) (ยง lbr_chartabsize(null, (u8 "\t"), vcol[0])))
                (if (< (ยง want_vcol[0]) (+ (ยง vcol[0]) i))
                    (ร BREAK)
                )
                (when (!= (.at ptr 0) TAB)
                    (.be ptr 0, TAB)
                    (when (< change_col 0)
                        ((ร change_col =) (. fpos col)) ;; column of first change
                        ;; May have to adjust insStart.
                        (if (and (== (. fpos lnum) (. @insStart lnum)) (< (. fpos col) (. @insStart col)))
                            ((ร @insStart.col =) (. fpos col))
                        )
                    )
                )
                (ยง fpos.col++)
                ((ร ptr =) (ยง ptr.plus(1)))
                ((ร vcol[0] +=) i)
            )

            (when (<= 0 change_col)
                ((ร int repl_off =) 0)
                ((ร Bytes line =) ptr)

                ;; Skip over the spaces we need.
                (while (ยง vcol[0] < want_vcol[0] && ptr.at(0) == (byte \space))
                    ((ร vcol[0] +=) (ยง lbr_chartabsize(line, ptr, vcol[0])))
                    ((ร ptr =) (ยง ptr.plus(1)))
                    (ยง repl_off++)
                )
                (when (< (ยง want_vcol[0]) (ยง vcol[0]))
                    ;; Must have a char with 'showbreak' just before it.
                    ((ร ptr =) (ยง ptr.minus(1)))
                    (ยง --repl_off)
                )
                ((ร fpos.col +=) repl_off)

                ;; Delete following spaces.
                ((ร int i =) (ยง cursor.col - fpos.col))
                (when (< 0 i)
                    (BCOPY ptr, 0, ptr, i, (+ (STRLEN ptr, i) 1))
                    ;; correct replace stack.
                    (when (and (non-zero? (& @State REPLACE_FLAG)) (zero? (& @State VREPLACE_FLAG)))
                        ((ร FOR) (ร (ยง temp = i) (ยง 0 <= --temp) nil)
                            (replace_join repl_off)
                        )
                    )
                )
                ((ร cursor.col -=) i)

                ;; In VREPLACE mode, we haven't changed anything yet.  Do it now by
                ;; backspacing over the changed spacing and then inserting the new spacing.

                (when (non-zero? (& @State VREPLACE_FLAG))
                    ;; Backspace from real cursor to change_col.
                    (backspace_until_column change_col)

                    ;; Insert each char in saved_line from changed_col to ptr-cursor.
                    (ins_bytes_len (.plus saved_line change_col), (- (. cursor col) change_col))
                )
            )
        )

        false
    ))

;; Handle CR or NL in insert mode.
;; Return true when out of memory or can't undo.

(defn- #_boolean ins_eol [#_int c]
    (ยง
        (if (not (stop_arrow))
            ((ร RETURN) true)
        )

        ;; Strange Vi behaviour:
        ;; In Replace mode, typing a NL will not delete the character under the cursor.
        ;; Only push a NUL on the replace stack, nothing to put back when the NL is deleted.

        (when (and (non-zero? (& @State REPLACE_FLAG)) (zero? (& @State VREPLACE_FLAG)))
            (replace_push NUL)
        )

        ;; In VREPLACE mode, a NL replaces the rest of the line, and starts replacing the next line,
        ;; so we push all of the characters left on the line onto the replace stack.
        ;; This is not done here though, it is done in open_line().

        ;; Put cursor on NUL if on the last char and coladd is 1 (happens after CTRL-O).
        (if (and (virtual_active) (< 0 (.. @curwin w_cursor coladd)))
            (coladvance (getviscol)))

        (appendToRedobuff NL_STR)
        ((ร boolean b =) (open_line FORWARD, 0, @old_indent))
        (reset! old_indent 0)
        (reset! can_cindent true)

        (not b)
    ))

;; Handle digraph in insert mode.
;; Returns character still to be inserted, or NUL when nothing remaining to be done.

(defn- #_int ins_digraph []
    (ยง
        ((ร boolean did_putchar =) false)

        (reset! pc_status PC_STATUS_UNSET)
        (when (and (redrawing) (not (char_avail)))
            ;; May need to redraw when no more chars available now.
            (ins_redraw false)

            (edit_putchar (byte \?), true)
            ((ร did_putchar =) true)
            (add_to_showcmd_c Ctrl_K)
        )

        ;; Don't map the digraph chars.
        ;; This also prevents the mode message to be deleted when ESC is hit.
        (swap! no_mapping inc)
        (swap! allow_keys inc)
        ((ร int c =) (plain_vgetc))
        (swap! no_mapping dec)
        (swap! allow_keys dec)
        (when did_putchar
            ;; When the line fits in 'columns',
            ;; the '?' is at the start of the next line and will not be removed by the redraw.
            (edit_unputchar)
        )

        (when (or (is_special c) (non-zero? @mod_mask))         ;; special key
            (clear_showcmd)
            (insert_special c, true, false)
            ((ร RETURN) NUL)
        )

        (when (!= c ESC)
            ((ร did_putchar =) false)
            (when (and (redrawing) (not (char_avail)))
                ;; May need to redraw when no more chars available now.
                (ins_redraw false)

                (when (== (mb_char2cells c) 1)
                    (ins_redraw false)
                    (edit_putchar c, true)
                    ((ร did_putchar =) true)
                )
                (add_to_showcmd_c c)
            )
            (swap! no_mapping inc)
            (swap! allow_keys inc)
            ((ร int cc =) (plain_vgetc))
            (swap! no_mapping dec)
            (swap! allow_keys dec)
            (when did_putchar
                ;; When the line fits in 'columns',
                ;; the '?' is at the start of the next line and will not be removed by a redraw.
                (edit_unputchar)
            )
            (when (!= cc ESC)
                (appendToRedobuff CTRL_V_STR)
                ((ร c =) (getdigraph c, cc, true))
                (clear_showcmd)
                ((ร RETURN) c)
            )
        )
        (clear_showcmd)
        NUL
    ))

;; Handle CTRL-E and CTRL-Y in Insert mode: copy char from other line.
;; Returns the char to be inserted, or NUL if none found.

(defn- #_int ins_copychar [#_long lnum]
    (ยง
        (when (or (< lnum 1) (< (.. @curbuf b_ml ml_line_count) lnum))
            (vim_beep)
            ((ร RETURN) NUL)
        )

        ;; try to advance to the cursor column
        ((ร Bytes line =) (ml_get lnum))
; %%    ((ร Bytes[] ptr =) (ยง { line }))
        ((ร Bytes prev_ptr =) (ยง ptr[0]))
        (validate_virtcol)

        ((ร int temp =) 0)
        (while (ยง temp < @curwin.w_virtcol && ptr[0].at(0) != NUL)
            ((ร prev_ptr =) (ยง ptr[0]))
            ((ร temp +=) (lbr_chartabsize_adv line, ptr, temp))
        )
        (if (< (. @curwin w_virtcol) temp)
            ((ร ptr[0] =) prev_ptr)
        )

        ((ร int c =) (ยง us_ptr2char(ptr[0])))
        (if (== c NUL)
            (vim_beep))
        c
    ))

;; CTRL-Y or CTRL-E typed in Insert mode.

(defn- #_int ins_ctrl_ey [#_int tc]
    (ยง
        ((ร int c =) (ins_copychar (+ (.. @curwin w_cursor lnum) (if (== tc Ctrl_Y) -1 1))))
        (when (!= c NUL)
            ;; The character must be taken literally, insert like it was typed after a CTRL-V.
            ;; Digits, 'o' and 'x' are special after a CTRL-V, don't use it for these.
            (if (and (< c 256) (not (asc_isalnum c)))
                (appendToRedobuff CTRL_V_STR)) ;; CTRL-V

            (insert_special c, true, false)

            ((ร c =) Ctrl_V)                     ;; pretend CTRL-V is last character
        )

        c
    ))

;; Try to do some very smart auto-indenting.
;; Used when inserting a "normal" character.

(defn- #_void ins_try_si [#_int c]
    (ยง
        ;; do some very smart indenting when entering '{' or '}'

        (when (or (and (or @did_si @can_si_back) (== c (byte \{))) (and @can_si (== c (byte \}))))
            (ร pos_C pos)

            ;; for '}' set indent equal to indent of line containing matching '{'

            (cond (and (== c (byte \})) (non-nil? ((ร pos =) (findmatch null, (byte \{)))))
            (ยง
                ((ร pos_C old_pos =) (ยง ยง_pos_C()))
                (COPY_pos old_pos, (. @curwin w_cursor))

                ;; If the matching '{' has a ')' immediately before it (ignoring
                ;; white-space), then line up with the start of the line containing
                ;; the matching '(' if there is one.  This handles the case where
                ;; an "if (..\n..) {" statement continues over multiple lines.

                ((ร Bytes ptr =) (ยง ml_get(pos.lnum)))
                ((ร int i =) (. pos col))
                (when (< 0 i)          ;; skip blanks before '{'
                    (while (ยง 0 < --i && vim_iswhite(ptr.at(i)))
                        ;
                    )
                )
                ((ร @curwin.w_cursor.lnum =) (. pos lnum))
                ((ร @curwin.w_cursor.col =) i)
                (if (and (== (.at ptr i) (byte \))) (non-nil? ((ร pos =) (findmatch null, (byte \()))))
                    (COPY_pos (. @curwin w_cursor), pos))
                ((ร i =) (get_indent))
                (COPY_pos (. @curwin w_cursor), old_pos)
                (if (non-zero? (& @State VREPLACE_FLAG))
                    (change_indent INDENT_SET, i, false, NUL, true)
                    (set_indent i, SIN_CHANGED))
            )
            (< 0 (.. @curwin w_cursor col))
            (ยง
                ;; when inserting '{' after "O" reduce indent,
                ;; but not more than indent of previous line

                ((ร boolean temp =) true)
                (when (and (== c (byte \{)) @can_si_back (< 1 (.. @curwin w_cursor lnum)))
                    ((ร pos_C old_pos =) (ยง ยง_pos_C()))
                    (COPY_pos old_pos, (. @curwin w_cursor))
                    ((ร int i =) (get_indent))
                    (while (ยง 1 < @curwin.w_cursor.lnum)
                        ((ร Bytes ptr =) (ยง skipwhite(ml_get(--@curwin.w_cursor.lnum))))

                        ;; ignore empty lines and lines starting with '#'.
                        (if (and (!= (.at ptr 0) (byte \#)) (non-eos? ptr))
                            (ร BREAK)
                        )
                    )
                    (if (<= i (get_indent))
                        ((ร temp =) false)
                    )
                    (COPY_pos (. @curwin w_cursor), old_pos)
                )
                (if temp
                    (shift_line true, false, 1, true))
            ))
        )

        ;; set indent of '#' always to 0

        (when (and (< 0 (.. @curwin w_cursor col)) @can_si (== c (byte \#)))
            ;; remember current indent for next line
            (reset! old_indent (get_indent))
            (set_indent 0, SIN_CHANGED)
        )

        ;; Adjust ai_col, the char at this position can be deleted.
        (when (> @ai_col (.. @curwin w_cursor col))
            (reset! ai_col (.. @curwin w_cursor col))
        )
    ))

;; Get the value that w_virtcol would have when 'list' is off.

(defn- #_int get_nolist_virtcol []
    (ยง
        (validate_virtcol)
        (. @curwin w_virtcol)
    ))

;; Handle the InsertCharPre autocommand.
;; "c" is the character that was typed.
;; Return a pointer to allocated memory with the replacement string.
;; Return null to continue inserting "c".

(defn- #_Bytes do_insert_char_pre [#_int c]
    (ยง
        (ยง null)
    ))

;;; ============================================================================================== VimN

;; regexp.c ---------------------------------------------------------------------------------------

;; Handling of regular expressions: vim_regcomp(), vim_regexec(), vim_regsub()
;;
;; Beware that some of this code is subtly aware of the way operator
;; precedence is structured in regular expressions.  Serious changes in
;; regular-expression syntax might require a total rethink.

;; The "internal use only" fields in regexp.h are present to pass info from
;; compile to execute that permits the execute phase to run lots faster on
;; simple cases.  They are:
;;
;; regstart     char that must begin a match; NUL if none obvious; Can be a
;;              multi-byte character.
;; reganch      is the match anchored (at beginning-of-line only)?
;; regmust      string (pointer into program) that match must include, or null
;; regmlen      length of regmust string
;; regflags     RF_ values or'ed together
;;
;; Regstart and reganch permit very fast decisions on suitable starting points
;; for a match, cutting down the work a lot.  Regmust permits fast rejection
;; of lines that cannot possibly match.  The regmust tests are costly enough
;; that vim_regcomp() supplies a regmust only if the r.e. contains something
;; potentially expensive (at present, the only such thing detected is * or +
;; at the start of the r.e., which can involve a lot of backup).  Regmlen is
;; supplied because the test in vim_regexec() needs it and vim_regcomp() is
;; computing it anyway.

;; Structure for regexp "program".  This is essentially a linear encoding
;; of a nondeterministic finite-state machine (aka syntax charts or
;; "railroad normal form" in parsing technology).  Each node is an opcode
;; plus a "next" pointer, possibly plus an operand.  "Next" pointers of
;; all nodes except BRANCH and BRACES_COMPLEX implement concatenation; a "next"
;; pointer with a BRANCH on both ends of it is connecting two alternatives.
;; (Here we have one of the subtle syntax dependencies: an individual BRANCH
;; (as opposed to a collection of them) is never concatenated with anything
;; because of operator precedence).  The "next" pointer of a BRACES_COMPLEX
;; node points to the node after the stuff to be repeated.
;; The operand of some types of node is a literal string; for others, it is a
;; node leading into a sub-FSM.  In particular, the operand of a BRANCH node
;; is the first node of the branch.
;; (NB this is *not* a tree structure: the tail of the branch connects to the
;; thing following the set of BRANCHes.)
;;
;; pattern      is coded like:
;;
;;                        +-----------------+
;;                        |                 V
;; <aa>\|<bb>   BRANCH <aa> BRANCH <bb> --> END
;;                   |      ^    |          ^
;;                   +------+    +----------+
;;
;;                     +------------------+
;;                     V                  |
;; <aa>*        BRANCH BRANCH <aa> --> BACK BRANCH --> NOTHING --> END
;;                   |      |               ^                      ^
;;                   |      +---------------+                      |
;;                   +---------------------------------------------+
;;
;;                     +----------------------+
;;                     V                      |
;; <aa>\+       BRANCH <aa> --> BRANCH --> BACK  BRANCH --> NOTHING --> END
;;                   |               |           ^                      ^
;;                   |               +-----------+                      |
;;                   +--------------------------------------------------+
;;
;;                                      +-------------------------+
;;                                      V                         |
;; <aa>\{}      BRANCH BRACE_LIMITS --> BRACE_COMPLEX <aa> --> BACK  END
;;                   |                              |                ^
;;                   |                              +----------------+
;;                   +-----------------------------------------------+
;;
;; <aa>\@!<bb>  BRANCH NOMATCH <aa> --> END  <bb> --> END
;;                   |       |                ^       ^
;;                   |       +----------------+       |
;;                   +--------------------------------+
;;
;;                                                    +---------+
;;                                                    |         V
;; \z[abc]      BRANCH BRANCH  a  BRANCH  b  BRANCH  c  BRANCH  NOTHING --> END
;;                   |      |          |          |     ^                   ^
;;                   |      |          |          +-----+                   |
;;                   |      |          +----------------+                   |
;;                   |      +---------------------------+                   |
;;                   +------------------------------------------------------+
;;
;; They all start with a BRANCH for "\|" alternatives, even when there is only
;; one alternative.

;; The opcodes are:

;; definition   number             opnd?    meaning
(final int END             0)       ;;      End of program or NOMATCH operand.
(final int BOL             1)       ;;      Match "" at beginning of line.
(final int EOL             2)       ;;      Match "" at end of line.
(final int BRANCH          3)       ;; node Match this alternative, or the next...
(final int BACK            4)       ;;      Match "", "next" ptr points backward.
(final int EXACTLY         5)       ;; str  Match this string.
(final int NOTHING         6)       ;;      Match empty string.
(final int STAR            7)       ;; node Match this (simple) thing 0 or more times.
(final int PLUS            8)       ;; node Match this (simple) thing 1 or more times.
(final int MATCH           9)       ;; node match the operand zero-width
(final int NOMATCH         10)      ;; node check for no match with operand
(final int BEHIND          11)      ;; node look behind for a match with operand
(final int NOBEHIND        12)      ;; node look behind for no match with operand
(final int SUBPAT          13)      ;; node match the operand here
(final int BRACE_SIMPLE    14)      ;; node Match this (simple) thing between m and
                                    ;;      n times (\{m,n\}).
(final int BOW             15)      ;;      Match "" after [^a-zA-Z0-9_]
(final int EOW             16)      ;;      Match "" at    [^a-zA-Z0-9_]
(final int BRACE_LIMITS    17)      ;; nr nr  define the min & max for BRACE_SIMPLE
                                    ;;      and BRACE_COMPLEX.
(final int NEWL            18)      ;;      Match line-break
(final int BHPOS           19)      ;;      End position for BEHIND or NOBEHIND

;; character classes: 20-48 normal, 50-78 include a line-break
(final int ADD_NL          30)

(final int ANY             20)      ;;      Match any one character.
(final int ANYOF           21)      ;; str  Match any character in this string.
(final int ANYBUT          22)      ;; str  Match any character not in this string.
(final int IDENT           23)      ;;      Match identifier char
(final int SIDENT          24)      ;;      Match identifier char but no digit
(final int KWORD           25)      ;;      Match keyword char
(final int SKWORD          26)      ;;      Match word char but no digit
(final int FNAME           27)      ;;      Match file name char
(final int SFNAME          28)      ;;      Match file name char but no digit
(final int PRINT           29)      ;;      Match printable char
(final int SPRINT          30)      ;;      Match printable char but no digit
(final int WHITE           31)      ;;      Match whitespace char
(final int NWHITE          32)      ;;      Match non-whitespace char
(final int DIGIT           33)      ;;      Match digit char
(final int NDIGIT          34)      ;;      Match non-digit char
(final int HEX             35)      ;;      Match hex char
(final int NHEX            36)      ;;      Match non-hex char
(final int OCTAL           37)      ;;      Match octal char
(final int NOCTAL          38)      ;;      Match non-octal char
(final int WORD            39)      ;;      Match word char
(final int NWORD           40)      ;;      Match non-word char
(final int HEAD            41)      ;;      Match head char
(final int NHEAD           42)      ;;      Match non-head char
(final int ALPHA           43)      ;;      Match alpha char
(final int NALPHA          44)      ;;      Match non-alpha char
(final int LOWER           45)      ;;      Match lowercase char
(final int NLOWER          46)      ;;      Match non-lowercase char
(final int UPPER           47)      ;;      Match uppercase char
(final int NUPPER          48)      ;;      Match non-uppercase char

(final int FIRST_NL        (+ ANY ADD_NL))
(final int LAST_NL         (+ NUPPER ADD_NL))

(defn- #_boolean with_nl [#_int op]
    (and (<= FIRST_NL op) (<= op LAST_NL)))

(final int MOPEN           80)  ;; -89       Mark this point in input as start of
                                    ;;       \( subexpr.  MOPEN + 0 marks start of match.
(final int MCLOSE          90)  ;; -99       Analogous to MOPEN.  MCLOSE + 0 marks
                                    ;;       end of match.
(final int BACKREF         100) ;; -109 node Match same string again \1-\9

(final int ZOPEN           110) ;; -119      Mark this point in input as start of \z( subexpr.
(final int ZCLOSE          120) ;; -129      Analogous to ZOPEN.
(final int ZREF            130) ;; -139 node Match external submatch \z1-\z9

(final int BRACE_COMPLEX   140) ;; -149 node Match nodes between m & n times

(final int NOPEN           150)     ;;      Mark this point in input as start of \%( subexpr.
(final int NCLOSE          151)     ;;      Analogous to NOPEN.

(final int MULTIBYTECODE   200)     ;; mbc  Match one multi-byte character
(final int RE_BOF          201)     ;;      Match "" at beginning of file.
(final int RE_EOF          202)     ;;      Match "" at end of file.
(final int CURSOR          203)     ;;      Match location of cursor.

(final int RE_LNUM         204)     ;; nr cmp  Match line number
(final int RE_COL          205)     ;; nr cmp  Match column number
(final int RE_VCOL         206)     ;; nr cmp  Match virtual column number

(final int RE_MARK         207)     ;; mark cmp  Match mark position
(final int RE_VISUAL       208)     ;;      Match Visual area
(final int RE_COMPOSING    209)     ;; any composing characters

;; Magic characters have a special meaning, they don't match literally.
;; Magic characters are negative.  This separates them from literal characters
;; (possibly multi-byte).  Only ASCII characters can be Magic.

(defn- #_final #_int Magic [#_int x]
    (- x 256))

(defn- #_int un_Magic [#_int x]
    (+ x 256))

(defn- #_boolean is_Magic [#_int x]
    (< x 0))

(defn- #_int no_Magic [#_int x]
    (if (is_Magic x) (un_Magic x) x))

(defn- #_int toggle_Magic [#_int x]
    (if (is_Magic x) (un_Magic x) (Magic x)))

;; The first byte of the regexp internal "program" is actually this magic number;
;; the start node begins in the second byte.
;; It's used to catch the most severe mutilation of the program by the caller.

(final byte! REGMAGIC 0234)

;; Opcode notes:
;;
;; BRANCH           The set of branches constituting a single choice are hooked
;;                  together with their "next" pointers, since precedence prevents
;;                  anything being concatenated to any individual branch.  The
;;                  "next" pointer of the last BRANCH in a choice points to the
;;                  thing following the whole choice.  This is also where the
;;                  final "next" pointer of each individual branch points; each
;;                  branch starts with the operand node of a BRANCH node.
;;
;; BACK             Normal "next" pointers all implicitly point forward; BACK
;;                  exists to make loop structures possible.
;;
;; STAR,PLUS        '=', and complex '*' and '+', are implemented as circular
;;                  BRANCH structures using BACK.  Simple cases (one character
;;                  per match) are implemented with STAR and PLUS for speed
;;                  and to minimize recursive plunges.
;;
;; BRACE_LIMITS     This is always followed by a BRACE_SIMPLE or BRACE_COMPLEX
;;                  node, and defines the min and max limits to be used for that node.
;;
;; MOPEN, MCLOSE    ... are numbered at compile time.
;; ZOPEN, ZCLOSE    ... ditto

;; A node is one char of opcode followed by two chars of "next" pointer.
;; "Next" pointers are stored as two 8-bit bytes, high order first.  The
;; value is a positive offset from the opcode of the node containing it.
;; An operand, if any, simply follows the node.  (Note that much of the
;; code generation knows about this implicit relationship.)
;;
;; Using two bytes for the "next" pointer is vast overkill for most things,
;; but allows patterns to get big without disasters.

(defn- #_int re_op [#_Bytes p]
    (ยง
        (ยง (int)p.at(0))
    ))

(defn- #_int re_next [#_Bytes p]
    (ยง
        (ยง ((int)p.at(1) << 8) + (int)p.at(2))
    ))

(defn- #_Bytes operand [#_Bytes p]
    (ยง
        (.plus p 3)
    ))

;; Obtain an operand that was stored as four bytes, MSB first.
(defn- #_long operand_min [#_Bytes p]
    (ยง
        (ยง ((long)p.at(3) << 24) + ((long)p.at(4) << 16) + ((long)p.at(5) << 8) + (long)p.at(6))
    ))

;; Obtain a second operand stored as four bytes.
(defn- #_long operand_max [#_Bytes p]
    (ยง
        (operand_min (.plus p 4))
    ))

;; Obtain a second single-byte operand stored after a four bytes operand.
(defn- #_byte operand_cmp [#_Bytes p]
    (ยง
        (.at p 7)
    ))

(final long MAX_LIMIT       (<< 32767 16))

(final Bytes e_missingbracket  (u8 "E769: Missing ] after %s["))
(final Bytes e_unmatchedpp     (u8 "E53: Unmatched %s%%("))
(final Bytes e_unmatchedp      (u8 "E54: Unmatched %s("))
(final Bytes e_unmatchedpar    (u8 "E55: Unmatched %s)"))
(final Bytes e_z_not_allowed   (u8 "E66: \\z( not allowed here"))
(final Bytes e_z1_not_allowed  (u8 "E67: \\z1 et al. not allowed here"))
(final Bytes e_missing_sb      (u8 "E69: Missing ] after %s%%["))
(final Bytes e_empty_sb        (u8 "E70: Empty %s%%[]"))

(final int NOT_MULTI       0)
(final int MULTI_ONE       1)
(final int MULTI_MULT      2)

;; Return NOT_MULTI if c is not a "multi" operator.
;; Return MULTI_ONE if c is a single "multi" operator.
;; Return MULTI_MULT if c is a multi "multi" operator.

(defn- #_int re_multi_type [#_int c]
    (cond
        (or (== c (Magic (byte \@))) (== c (Magic (byte \=))) (== c (Magic (byte \?))))
            MULTI_ONE
        (or (== c (Magic (byte \*))) (== c (Magic (byte \+))) (== c (Magic (byte \{))))
            MULTI_MULT
        :else
            NOT_MULTI
    ))

;; Flags to be passed up and down.

(final int HASWIDTH        0x1)     ;; Known never to match null string.
(final int SIMPLE          0x2)     ;; Simple enough to be STAR/PLUS operand.
(final int SPSTART         0x4)     ;; Starts with * or +.
(final int HASNL           0x8)     ;; Contains some \n.
(final int HASLOOKBH       0x10)    ;; Contains "\@<=" or "\@<!".
(final int WORST           0)       ;; Worst case.

;; When regcode is set to this value, code is not emitted and size is computed instead.

(final Bytes JUST_CALC_SIZE (u8 ""))

(atom! Bytes reg_prev_sub)

;; REGEXP_INRANGE contains all characters which are always special in a [] range after '\'.
;; REGEXP_ABBR contains all characters which act as abbreviations after '\'.
;; These are:
;;  \n  - New line (NL).
;;  \r  - Carriage Return (CR).
;;  \t  - Tab (TAB).
;;  \e  - Escape (ESC).
;;  \b  - Backspace (Ctrl_H).
;;  \d  - Character code in decimal, e.g. \d123
;;  \o  - Character code in octal, e.g. \o80
;;  \x  - Character code in hex, e.g. \x4a
;;  \\u (sic!) - Multibyte character code, e.g. \u20ac
;;  \U  - Long multibyte character code, e.g. \U12345678

(final Bytes REGEXP_INRANGE (u8 "]^-n\\"))
(final Bytes REGEXP_ABBR (u8 "nrtebdoxuU"))

;; Translate '\x' to its control character, except "\n", which is Magic.

(defn- #_int backslash_trans [#_int c]
    (ยง
        ((ร SWITCH) c
            ((ร CASE) (byte \r))
            (ยง
                ((ร RETURN) CAR)
            )
            ((ร CASE) (byte \t))
            (ยง
                ((ร RETURN) TAB)
            )
            ((ร CASE) (byte \e))
            (ยง
                ((ร RETURN) ESC)
            )
            ((ร CASE) (byte \b))
            (ยง
                ((ร RETURN) BS)
            )
        )
        c
    ))

(final int
    CLASS_ALNUM 0,
    CLASS_ALPHA 1,
    CLASS_BLANK 2,
    CLASS_CNTRL 3,
    CLASS_DIGIT 4,
    CLASS_GRAPH 5,
    CLASS_LOWER 6,
    CLASS_PRINT 7,
    CLASS_PUNCT 8,
    CLASS_SPACE 9,
    CLASS_UPPER 10,
    CLASS_XDIGIT 11,
    CLASS_TAB 12,
    CLASS_RETURN 13,
    CLASS_BACKSPACE 14,
    CLASS_ESCAPE 15,
    CLASS_NONE 99)

(final Bytes* class_names
    [
        (u8 "alnum:]")
        (u8 "alpha:]")
        (u8 "blank:]")
        (u8 "cntrl:]")
        (u8 "digit:]")
        (u8 "graph:]")
        (u8 "lower:]")
        (u8 "print:]")
        (u8 "punct:]")
        (u8 "space:]")
        (u8 "upper:]")
        (u8 "xdigit:]")
        (u8 "tab:]")
        (u8 "return:]")
        (u8 "backspace:]")
        (u8 "escape:]")
    ])

;; Check for a character class name "[:name:]".  "pp" points to the '['.
;; Returns one of the CLASS_ items.  CLASS_NONE means that no item was
;; recognized.  Otherwise "pp" is advanced to after the item.

(defn- #_int get_char_class [#_Bytes* pp]
    (ยง
        (when (== (ยง pp[0].at(1)) (byte \:))
            ((ร FOR) (ร (ยง int i = 0) (ยง i < class_names.length) (ยง i++))
                ((ร int len =) (ยง STRLEN(class_names[i])))
                (when (zero? (ยง STRNCMP(pp[0].plus(2), class_names[i], len)))
                    ((ร pp[0] =) (ยง pp[0].plus(len + 2)))
                    ((ร RETURN) i)
                )
            )
        )
        CLASS_NONE
    ))

;; Specific version of character class functions.
;; Using a table to keep this fast.

(atom! int* class_tab 256)

(final int RI_DIGIT    0x01)
(final int RI_HEX      0x02)
(final int RI_OCTAL    0x04)
(final int RI_WORD     0x08)
(final int RI_HEAD     0x10)
(final int RI_ALPHA    0x20)
(final int RI_LOWER    0x40)
(final int RI_UPPER    0x80)
(final int RI_WHITE    0x100)

(atom! boolean class_tab_done)

(defn- #_void init_class_tab []
    (ยง
        (if @class_tab_done
            (ร RETURN)
        )

        ((ร FOR) (ร (ยง int i = 0) (< i 256) (ยง i++))
            (cond (and (<= (byte \0) i) (<= i (byte \7)))
            (ยง
                ((ร @class_tab[i] =) (ยง RI_DIGIT + RI_HEX + RI_OCTAL + RI_WORD))
            )
            (and (<= (byte \8) i) (<= i (byte \9)))
            (ยง
                ((ร @class_tab[i] =) (ยง RI_DIGIT + RI_HEX + RI_WORD))
            )
            (and (<= (byte \a) i) (<= i (byte \f)))
            (ยง
                ((ร @class_tab[i] =) (ยง RI_HEX + RI_WORD + RI_HEAD + RI_ALPHA + RI_LOWER))
            )
            (and (<= (byte \g) i) (<= i (byte \z)))
            (ยง
                ((ร @class_tab[i] =) (ยง RI_WORD + RI_HEAD + RI_ALPHA + RI_LOWER))
            )
            (and (<= (byte \A) i) (<= i (byte \F)))
            (ยง
                ((ร @class_tab[i] =) (ยง RI_HEX + RI_WORD + RI_HEAD + RI_ALPHA + RI_UPPER))
            )
            (and (<= (byte \G) i) (<= i (byte \Z)))
            (ยง
                ((ร @class_tab[i] =) (ยง RI_WORD + RI_HEAD + RI_ALPHA + RI_UPPER))
            )
            (== i (byte \_))
            (ยง
                ((ร @class_tab[i] =) (+ RI_WORD RI_HEAD))
            )
            :else
            (ยง
                ((ร @class_tab[i] =) 0)
            ))
        )
        ((ร @class_tab[(byte \space)] |=) RI_WHITE)
        ((ร @class_tab[(byte \tab)] |=) RI_WHITE)

        (reset! class_tab_done true)
    ))

(defn- #_boolean ri_digit [#_int c]
    (ยง
        (and (< c 0x100) (non-zero? (& (ยง @class_tab[c]) RI_DIGIT)))
    ))

(defn- #_boolean ri_hex [#_int c]
    (ยง
        (and (< c 0x100) (non-zero? (& (ยง @class_tab[c]) RI_HEX)))
    ))

(defn- #_boolean ri_octal [#_int c]
    (ยง
        (and (< c 0x100) (non-zero? (& (ยง @class_tab[c]) RI_OCTAL)))
    ))

(defn- #_boolean ri_word [#_int c]
    (ยง
        (and (< c 0x100) (non-zero? (& (ยง @class_tab[c]) RI_WORD)))
    ))

(defn- #_boolean ri_head [#_int c]
    (ยง
        (and (< c 0x100) (non-zero? (& (ยง @class_tab[c]) RI_HEAD)))
    ))

(defn- #_boolean ri_alpha [#_int c]
    (ยง
        (and (< c 0x100) (non-zero? (& (ยง @class_tab[c]) RI_ALPHA)))
    ))

(defn- #_boolean ri_lower [#_int c]
    (ยง
        (and (< c 0x100) (non-zero? (& (ยง @class_tab[c]) RI_LOWER)))
    ))

(defn- #_boolean ri_upper [#_int c]
    (ยง
        (and (< c 0x100) (non-zero? (& (ยง @class_tab[c]) RI_UPPER)))
    ))

(defn- #_boolean ri_white [#_int c]
    (ยง
        (and (< c 0x100) (non-zero? (& (ยง @class_tab[c]) RI_WHITE)))
    ))

;; flags for regflags
(final int RF_ICASE    1)   ;; ignore case
(final int RF_NOICASE  2)   ;; don't ignore case
(final int RF_HASNL    4)   ;; can match a NL
(final int RF_ICOMBINE 8)   ;; ignore combining characters
(final int RF_LOOKBH   16)  ;; uses "\@<=" or "\@<!"

;; Global work variables for vim_regcomp().

(atom! Bytes    regparse)                   ;; input-scan pointer
(atom! int      prevchr_len)                ;; byte length of previous char
(atom! int      num_complex_braces)         ;; complex \{...} count
(atom! int      regnpar)                    ;; () count
(atom! int      regnzpar)                   ;; \z() count
(atom! int      re_has_z)                   ;; \z item detected
(atom! Bytes    regcode)                    ;; code-emit pointer, or JUST_CALC_SIZE
(atom! int      regsize)                    ;; code size
(atom! boolean  reg_toolong)                ;; true when offset out of range
(atom! boolean* had_endbrace    NSUBEXP)    ;; flags, true if end of () found
(atom! int      regflags)                   ;; RF_ flags for prog
(atom! long*    brace_min       10)         ;; minimums for complex brace repeats
(atom! long*    brace_max       10)         ;; maximums for complex brace repeats
(atom! int*     brace_count     10)         ;; current counts for complex brace repeats
(atom! boolean  one_exactly)                ;; only do one char for EXACTLY

(atom! int      reg_magic)                  ;; magicness of the pattern:
(final int
    MAGIC_NONE  1,                   ;; "\V" very unmagic
    MAGIC_OFF   2,                   ;; "\M" or 'magic' off
    MAGIC_ON    3,                   ;; "\m" or 'magic'
    MAGIC_ALL   4)                   ;; "\v" very magic

(atom! boolean  reg_string)                 ;; matching with a string instead of a buffer line
(atom! boolean  reg_strict)                 ;; "[abc" is illegal

;; META contains all characters that may be magic, except '^' and '$'.

;; META[] is used often enough to justify turning it into a table.
(final byte* META_flags
    [
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
;;                     %  &     (  )  *  +        .
        0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 1, 0,
;;         1  2  3  4  5  6  7  8  9        <  =  >  ?
        0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1,
;;      @  A     C  D     F     H  I     K  L  M     O
        1, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 1, 1, 0, 1,
;;      P        S     U  V  W  X     Z  [           _
        1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 1,
;;         a     c  d     f     h  i     k  l  m  n  o
        0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1,
;;      p        s     u  v  w  x     z  {  |     ~
        1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1
    ])

(atom! int      curchr)             ;; currently parsed character

;; Previous character.  Note: prevchr is sometimes -1 when we are not at the start,
;; e.g. in /[ ^I]^ the pattern was never found even if it existed,
;; because ^ was taken to be magic.

(atom! int      prevchr)
(atom! int      prevprevchr)        ;; previous-previous character
(atom! int      nextchr)            ;; used for ungetchr()

;; arguments for reg()
(final int REG_NOPAREN     0)           ;; toplevel reg()
(final int REG_PAREN       1)           ;; \(\)
(final int REG_ZPAREN      2)           ;; \z(\)
(final int REG_NPAREN      3)           ;; \%(\)

(class! #_final parse_state_C
    [
        (field Bytes        regparse)
        (field int          prevchr_len)
        (field int          curchr)
        (field int          prevchr)
        (field int          prevprevchr)
        (field int          nextchr)
        (field boolean      at_start)
        (field boolean      prev_at_start)
        (field int          regnpar)
    ])

;; Forward declarations for vim_regcomp()'s friends.

;   static regengine_C bt_regengine = new regengine_C()
;   {
;       public regprog_C regcomp(Bytes expr, int re_flags)
;       {
; %%        ((ร RETURN) (bt_regcomp expr, re_flags))
;       }

;       public long regexec_nl(regmatch_C rmp, Bytes line, int col, boolean line_lbr)
;       {
; %%        ((ร RETURN) (bt_regexec_nl rmp, line, col, line_lbr))
;       }

;       public long regexec_multi(regmmatch_C rmp, window_C win, buffer_C buf, long lnum, int col, long nsec)
;       {
; %%        ((ร RETURN) (bt_regexec_multi rmp, win, buf, lnum, col, nsec))
;       }
;   };

;   static regengine_C nfa_regengine = new regengine_C()
;   {
;       public regprog_C regcomp(Bytes expr, int re_flags)
;       {
; %%        ((ร RETURN) (nfa_regcomp expr, re_flags))
;       }

;       public long regexec_nl(regmatch_C rmp, Bytes line, int col, boolean line_lbr)
;       {
; %%        ((ร RETURN) (nfa_regexec_nl rmp, line, col, line_lbr))
;       }

;       public long regexec_multi(regmmatch_C rmp, window_C win, buffer_C buf, long lnum, int col, long nsec)
;       {
; %%        ((ร RETURN) (nfa_regexec_multi rmp, win, buf, lnum, col, nsec))
;       }
;   };

;; Return true if compiled regular expression "prog" can match a line break.

(defn- #_boolean re_multiline [#_regprog_C prog]
    (ยง
        (non-zero? (& (. prog regflags) RF_HASNL))
    ))

;; Return true if compiled regular expression "prog" looks before the start
;; position (pattern contains "\@<=" or "\@<!").

(defn- #_boolean re_lookbehind [#_regprog_C prog]
    (ยง
        (non-zero? (& (. prog regflags) RF_LOOKBH))
    ))

;; Check for an equivalence class name "[=a=]".  "pp" points to the '['.
;; Returns a character representing the class.  Zero means that no item was
;; recognized.  Otherwise "pp" is advanced to after the item.

(defn- #_int get_equi_class [#_Bytes* pp]
    (ยง
        ((ร Bytes p =) (ยง pp[0]))
        (when (== (.at p 1) (byte \=))
            ((ร int len =) (ยง us_ptr2len_cc(p.plus(2))))
            (when (and (== (.at p (+ len 2)) (byte \=)) (== (.at p (+ len 3)) (byte \])))
                ((ร int c =) (ยง us_ptr2char(p.plus(2))))
                ((ร pp[0] =) (ยง pp[0].plus(len + 4)))
                ((ร RETURN) c)
            )
        )
        0
    ))

;; Produce the bytes for equivalence class "c".
;; Currently only handles latin1, latin9 and utf-8.
;;
;; NOTE! When changing this function, also change nfa_emit_equi_class()

(defn- #_void reg_equi_class [#_int c]
    (ยง
        ((ร SWITCH) c
            ((ร CASE) (byte \A))
            ((ร CASE) 0xc0) ((ร CASE) 0xc1) ((ร CASE) 0xc2)
            ((ร CASE) 0xc3) ((ร CASE) 0xc4) ((ร CASE) 0xc5)
            ((ร CASE) 0x100) ((ร CASE) 0x102) ((ร CASE) 0x104)
            ((ร CASE) 0x1cd) ((ร CASE) 0x1de) ((ร CASE) 0x1e0)
            ((ร CASE) 0x1ea2)
            (ยง
                (regmbc (byte \A))
                (regmbc 0xc0) regmbc(0xc1) (regmbc 0xc2)
                (regmbc 0xc3) regmbc(0xc4) (regmbc 0xc5)
                (regmbc 0x100) regmbc(0x102) (regmbc 0x104)
                (regmbc 0x1cd) regmbc(0x1de) (regmbc 0x1e0)
                (regmbc 0x1ea2)
                (ร RETURN)
            )
            ((ร CASE) (byte \a))
            ((ร CASE) 0xe0) ((ร CASE) 0xe1) ((ร CASE) 0xe2)
            ((ร CASE) 0xe3) ((ร CASE) 0xe4) ((ร CASE) 0xe5)
            ((ร CASE) 0x101) ((ร CASE) 0x103) ((ร CASE) 0x105)
            ((ร CASE) 0x1ce) ((ร CASE) 0x1df) ((ร CASE) 0x1e1)
            ((ร CASE) 0x1ea3)
            (ยง
                (regmbc (byte \a))
                (regmbc 0xe0) regmbc(0xe1) (regmbc 0xe2)
                (regmbc 0xe3) regmbc(0xe4) (regmbc 0xe5)
                (regmbc 0x101) regmbc(0x103) (regmbc 0x105)
                (regmbc 0x1ce) regmbc(0x1df) (regmbc 0x1e1)
                (regmbc 0x1ea3)
                (ร RETURN)
            )

            ((ร CASE) (byte \B))
            ((ร CASE) 0x1e02) ((ร CASE) 0x1e06)
            (ยง
                (regmbc (byte \B))
                (regmbc 0x1e02) regmbc(0x1e06)
                (ร RETURN)
            )
            ((ร CASE) (byte \b))
            ((ร CASE) 0x1e03) ((ร CASE) 0x1e07)
            (ยง
                (regmbc (byte \b))
                (regmbc 0x1e03) regmbc(0x1e07)
                (ร RETURN)
            )

            ((ร CASE) (byte \C))
            ((ร CASE) 0xc7)
            ((ร CASE) 0x106) ((ร CASE) 0x108) ((ร CASE) 0x10a) ((ร CASE) 0x10c)
            (ยง
                (regmbc (byte \C))
                (regmbc 0xc7)
                (regmbc 0x106) regmbc(0x108) (regmbc 0x10a) regmbc(0x10c)
                (ร RETURN)
            )
            ((ร CASE) (byte \c))
            ((ร CASE) 0xe7)
            ((ร CASE) 0x107) ((ร CASE) 0x109) ((ร CASE) 0x10b) ((ร CASE) 0x10d)
            (ยง
                (regmbc (byte \c))
                (regmbc 0xe7)
                (regmbc 0x107) regmbc(0x109) (regmbc 0x10b) regmbc(0x10d)
                (ร RETURN)
            )

            ((ร CASE) (byte \D))
            ((ร CASE) 0x10e) ((ร CASE) 0x110)
            ((ร CASE) 0x1e0a) ((ร CASE) 0x1e0c) ((ร CASE) 0x1e0e) ((ร CASE) 0x1e10) ((ร CASE) 0x1e12)
            (ยง
                (regmbc (byte \D))
                (regmbc 0x10e) regmbc(0x110)
                (regmbc 0x1e0a) regmbc(0x1e0c) (regmbc 0x1e0e) regmbc(0x1e10) (regmbc 0x1e12)
                (ร RETURN)
            )
            ((ร CASE) (byte \d))
            ((ร CASE) 0x10f) ((ร CASE) 0x111)
            ((ร CASE) 0x1e0b) ((ร CASE) 0x1e0d) ((ร CASE) 0x1e0f) ((ร CASE) 0x1e11) ((ร CASE) 0x1e13)
            (ยง
                (regmbc (byte \d))
                (regmbc 0x10f) regmbc(0x111)
                (regmbc 0x1e0b) regmbc(0x1e0d) (regmbc 0x1e0f) regmbc(0x1e11) (regmbc 0x1e13)
                (ร RETURN)
            )

            ((ร CASE) (byte \E))
            ((ร CASE) 0xc8) ((ร CASE) 0xc9) ((ร CASE) 0xca) ((ร CASE) 0xcb)
            ((ร CASE) 0x112) ((ร CASE) 0x114) ((ร CASE) 0x116) ((ร CASE) 0x118) ((ร CASE) 0x11a)
            ((ร CASE) 0x1eba) ((ร CASE) 0x1ebc)
            (ยง
                (regmbc (byte \E))
                (regmbc 0xc8) regmbc(0xc9) (regmbc 0xca) regmbc(0xcb)
                (regmbc 0x112) regmbc(0x114) (regmbc 0x116) regmbc(0x118) (regmbc 0x11a)
                (regmbc 0x1eba) regmbc(0x1ebc)
                (ร RETURN)
            )
            ((ร CASE) (byte \e))
            ((ร CASE) 0xe8) ((ร CASE) 0xe9) ((ร CASE) 0xea) ((ร CASE) 0xeb)
            ((ร CASE) 0x113) ((ร CASE) 0x115) ((ร CASE) 0x117) ((ร CASE) 0x119) ((ร CASE) 0x11b)
            ((ร CASE) 0x1ebb) ((ร CASE) 0x1ebd)
            (ยง
                (regmbc (byte \e))
                (regmbc 0xe8) regmbc(0xe9) (regmbc 0xea) regmbc(0xeb)
                (regmbc 0x113) regmbc(0x115) (regmbc 0x117) regmbc(0x119) (regmbc 0x11b)
                (regmbc 0x1ebb) regmbc(0x1ebd)
                (ร RETURN)
            )

            ((ร CASE) (byte \F))
            ((ร CASE) 0x1e1e)
            (ยง
                (regmbc (byte \F))
                (regmbc 0x1e1e)
                (ร RETURN)
            )
            ((ร CASE) (byte \f))
            ((ร CASE) 0x1e1f)
            (ยง
                (regmbc (byte \f))
                (regmbc 0x1e1f)
                (ร RETURN)
            )

            ((ร CASE) (byte \G))
            ((ร CASE) 0x11c) ((ร CASE) 0x11e) ((ร CASE) 0x120) ((ร CASE) 0x122)
            ((ร CASE) 0x1e4) ((ร CASE) 0x1e6) ((ร CASE) 0x1f4)
            ((ร CASE) 0x1e20)
            (ยง
                (regmbc (byte \G))
                (regmbc 0x11c) regmbc(0x11e) (regmbc 0x120) regmbc(0x122)
                (regmbc 0x1e4) regmbc(0x1e6) (regmbc 0x1f4)
                (regmbc 0x1e20)
                (ร RETURN)
            )
            ((ร CASE) (byte \g))
            ((ร CASE) 0x11d) ((ร CASE) 0x11f) ((ร CASE) 0x121) ((ร CASE) 0x123)
            ((ร CASE) 0x1e5) ((ร CASE) 0x1e7) ((ร CASE) 0x1f5)
            ((ร CASE) 0x1e21)
            (ยง
                (regmbc (byte \g))
                (regmbc 0x11d) regmbc(0x11f) (regmbc 0x121) regmbc(0x123)
                (regmbc 0x1e5) regmbc(0x1e7) (regmbc 0x1f5)
                (regmbc 0x1e21)
                (ร RETURN)
            )

            ((ร CASE) (byte \H))
            ((ร CASE) 0x124) ((ร CASE) 0x126)
            ((ร CASE) 0x1e22) ((ร CASE) 0x1e26) ((ร CASE) 0x1e28)
            (ยง
                (regmbc (byte \H))
                (regmbc 0x124) regmbc(0x126)
                (regmbc 0x1e22) regmbc(0x1e26) (regmbc 0x1e28)
                (ร RETURN)
            )
            ((ร CASE) (byte \h))
            ((ร CASE) 0x125) ((ร CASE) 0x127)
            ((ร CASE) 0x1e23) ((ร CASE) 0x1e27) ((ร CASE) 0x1e29) ((ร CASE) 0x1e96)
            (ยง
                (regmbc (byte \h))
                (regmbc 0x125) regmbc(0x127)
                (regmbc 0x1e23) regmbc(0x1e27) (regmbc 0x1e29) regmbc(0x1e96)
                (ร RETURN)
            )

            ((ร CASE) (byte \I))
            ((ร CASE) 0xcc) ((ร CASE) 0xcd) ((ร CASE) 0xce) ((ร CASE) 0xcf)
            ((ร CASE) 0x128) ((ร CASE) 0x12a) ((ร CASE) 0x12c) ((ร CASE) 0x12e) ((ร CASE) 0x130)
            ((ร CASE) 0x1cf)
            ((ร CASE) 0x1ec8)
            (ยง
                (regmbc (byte \I))
                (regmbc 0xcc) regmbc(0xcd) (regmbc 0xce) regmbc(0xcf)
                (regmbc 0x128) regmbc(0x12a) (regmbc 0x12c) regmbc(0x12e) (regmbc 0x130)
                (regmbc 0x1cf)
                (regmbc 0x1ec8)
                (ร RETURN)
            )
            ((ร CASE) (byte \i))
            ((ร CASE) 0xec) ((ร CASE) 0xed) ((ร CASE) 0xee) ((ร CASE) 0xef)
            ((ร CASE) 0x129) ((ร CASE) 0x12b) ((ร CASE) 0x12d) ((ร CASE) 0x12f) ((ร CASE) 0x131)
            ((ร CASE) 0x1d0)
            ((ร CASE) 0x1ec9)
            (ยง
                (regmbc (byte \i))
                (regmbc 0xec) regmbc(0xed) (regmbc 0xee) regmbc(0xef)
                (regmbc 0x129) regmbc(0x12b) (regmbc 0x12d) regmbc(0x12f) (regmbc 0x131)
                (regmbc 0x1d0)
                (regmbc 0x1ec9)
                (ร RETURN)
            )

            ((ร CASE) (byte \J))
            ((ร CASE) 0x134)
            (ยง
                (regmbc (byte \J))
                (regmbc 0x134)
                (ร RETURN)
            )
            ((ร CASE) (byte \j))
            ((ร CASE) 0x135) ((ร CASE) 0x1f0)
            (ยง
                (regmbc (byte \j))
                (regmbc 0x135) regmbc(0x1f0)
                (ร RETURN)
            )

            ((ร CASE) (byte \K))
            ((ร CASE) 0x136) ((ร CASE) 0x1e8)
            ((ร CASE) 0x1e30) ((ร CASE) 0x1e34)
            (ยง
                (regmbc (byte \K))
                (regmbc 0x136) regmbc(0x1e8)
                (regmbc 0x1e30) regmbc(0x1e34)
                (ร RETURN)
            )
            ((ร CASE) (byte \k))
            ((ร CASE) 0x137) ((ร CASE) 0x1e9)
            ((ร CASE) 0x1e31) ((ร CASE) 0x1e35)
            (ยง
                (regmbc (byte \k))
                (regmbc 0x137) regmbc(0x1e9)
                (regmbc 0x1e31) regmbc(0x1e35)
                (ร RETURN)
            )

            ((ร CASE) (byte \L))
            ((ร CASE) 0x139) ((ร CASE) 0x13b) ((ร CASE) 0x13d) ((ร CASE) 0x13f) ((ร CASE) 0x141)
            ((ร CASE) 0x1e3a)
            (ยง
                (regmbc (byte \L))
                (regmbc 0x139) regmbc(0x13b) (regmbc 0x13d) regmbc(0x13f) (regmbc 0x141)
                (regmbc 0x1e3a)
                (ร RETURN)
            )
            ((ร CASE) (byte \l))
            ((ร CASE) 0x13a) ((ร CASE) 0x13c) ((ร CASE) 0x13e) ((ร CASE) 0x140) ((ร CASE) 0x142)
            ((ร CASE) 0x1e3b)
            (ยง
                (regmbc (byte \l))
                (regmbc 0x13a) regmbc(0x13c) (regmbc 0x13e) regmbc(0x140) (regmbc 0x142)
                (regmbc 0x1e3b)
                (ร RETURN)
            )

            ((ร CASE) (byte \M))
            ((ร CASE) 0x1e3e) ((ร CASE) 0x1e40)
            (ยง
                (regmbc (byte \M))
                (regmbc 0x1e3e) regmbc(0x1e40)
                (ร RETURN)
            )
            ((ร CASE) (byte \m))
            ((ร CASE) 0x1e3f) ((ร CASE) 0x1e41)
            (ยง
                (regmbc (byte \m))
                (regmbc 0x1e3f) regmbc(0x1e41)
                (ร RETURN)
            )

            ((ร CASE) (byte \N))
            ((ร CASE) 0xd1)
            ((ร CASE) 0x143) ((ร CASE) 0x145) ((ร CASE) 0x147)
            ((ร CASE) 0x1e44) ((ร CASE) 0x1e48)
            (ยง
                (regmbc (byte \N))
                (regmbc 0xd1)
                (regmbc 0x143) regmbc(0x145) (regmbc 0x147)
                (regmbc 0x1e44) regmbc(0x1e48)
                (ร RETURN)
            )
            ((ร CASE) (byte \n))
            ((ร CASE) 0xf1)
            ((ร CASE) 0x144) ((ร CASE) 0x146) ((ร CASE) 0x148) ((ร CASE) 0x149)
            ((ร CASE) 0x1e45) ((ร CASE) 0x1e49)
            (ยง
                (regmbc (byte \n))
                (regmbc 0xf1)
                (regmbc 0x144) regmbc(0x146) (regmbc 0x148) regmbc(0x149)
                (regmbc 0x1e45) regmbc(0x1e49)
                (ร RETURN)
            )

            ((ร CASE) (byte \O))
            ((ร CASE) 0xd2) ((ร CASE) 0xd3) ((ร CASE) 0xd4)
            ((ร CASE) 0xd5) ((ร CASE) 0xd6) ((ร CASE) 0xd8)
            ((ร CASE) 0x14c) ((ร CASE) 0x14e) ((ร CASE) 0x150)
            ((ร CASE) 0x1a0) ((ร CASE) 0x1d1) ((ร CASE) 0x1ea) ((ร CASE) 0x1ec)
            ((ร CASE) 0x1ece)
            (ยง
                (regmbc (byte \O))
                (regmbc 0xd2) regmbc(0xd3) (regmbc 0xd4)
                (regmbc 0xd5) regmbc(0xd6) (regmbc 0xd8)
                (regmbc 0x14c) regmbc(0x14e) (regmbc 0x150)
                (regmbc 0x1a0) regmbc(0x1d1) (regmbc 0x1ea) regmbc(0x1ec)
                (regmbc 0x1ece)
                (ร RETURN)
            )
            ((ร CASE) (byte \o))
            ((ร CASE) 0xf2) ((ร CASE) 0xf3) ((ร CASE) 0xf4)
            ((ร CASE) 0xf5) ((ร CASE) 0xf6) ((ร CASE) 0xf8)
            ((ร CASE) 0x14d) ((ร CASE) 0x14f) ((ร CASE) 0x151)
            ((ร CASE) 0x1a1) ((ร CASE) 0x1d2) ((ร CASE) 0x1eb) ((ร CASE) 0x1ed)
            ((ร CASE) 0x1ecf)
            (ยง
                (regmbc (byte \o))
                (regmbc 0xf2) regmbc(0xf3) (regmbc 0xf4)
                (regmbc 0xf5) regmbc(0xf6) (regmbc 0xf8)
                (regmbc 0x14d) regmbc(0x14f) (regmbc 0x151)
                (regmbc 0x1a1) regmbc(0x1d2) (regmbc 0x1eb) regmbc(0x1ed)
                (regmbc 0x1ecf)
                (ร RETURN)
            )

            ((ร CASE) (byte \P))
            ((ร CASE) 0x1e54) ((ร CASE) 0x1e56)
            (ยง
                (regmbc (byte \P))
                (regmbc 0x1e54) regmbc(0x1e56)
                (ร RETURN)
            )
            ((ร CASE) (byte \p))
            ((ร CASE) 0x1e55) ((ร CASE) 0x1e57)
            (ยง
                (regmbc (byte \p))
                (regmbc 0x1e55) regmbc(0x1e57)
                (ร RETURN)
            )

            ((ร CASE) (byte \R))
            ((ร CASE) 0x154) ((ร CASE) 0x156) ((ร CASE) 0x158)
            ((ร CASE) 0x1e58) ((ร CASE) 0x1e5e)
            (ยง
                (regmbc (byte \R))
                (regmbc 0x154) regmbc(0x156) (regmbc 0x158)
                (regmbc 0x1e58) regmbc(0x1e5e)
                (ร RETURN)
            )
            ((ร CASE) (byte \r))
            ((ร CASE) 0x155) ((ร CASE) 0x157) ((ร CASE) 0x159)
            ((ร CASE) 0x1e59) ((ร CASE) 0x1e5f)
            (ยง
                (regmbc (byte \r))
                (regmbc 0x155) regmbc(0x157) (regmbc 0x159)
                (regmbc 0x1e59) regmbc(0x1e5f)
                (ร RETURN)
            )

            ((ร CASE) (byte \S))
            ((ร CASE) 0x15a) ((ร CASE) 0x15c) ((ร CASE) 0x15e) ((ร CASE) 0x160)
            ((ร CASE) 0x1e60)
            (ยง
                (regmbc (byte \S))
                (regmbc 0x15a) regmbc(0x15c) (regmbc 0x15e) regmbc(0x160)
                (regmbc 0x1e60)
                (ร RETURN)
            )
            ((ร CASE) (byte \s))
            ((ร CASE) 0x15b) ((ร CASE) 0x15d) ((ร CASE) 0x15f) ((ร CASE) 0x161)
            ((ร CASE) 0x1e61)
            (ยง
                (regmbc (byte \s))
                (regmbc 0x15b) regmbc(0x15d) (regmbc 0x15f) regmbc(0x161)
                (regmbc 0x1e61)
                (ร RETURN)
            )

            ((ร CASE) (byte \T))
            ((ร CASE) 0x162) ((ร CASE) 0x164) ((ร CASE) 0x166)
            ((ร CASE) 0x1e6a) ((ร CASE) 0x1e6e)
            (ยง
                (regmbc (byte \T))
                (regmbc 0x162) regmbc(0x164) (regmbc 0x166)
                (regmbc 0x1e6a) regmbc(0x1e6e)
                (ร RETURN)
            )
            ((ร CASE) (byte \t))
            ((ร CASE) 0x163) ((ร CASE) 0x165) ((ร CASE) 0x167)
            ((ร CASE) 0x1e6b) ((ร CASE) 0x1e6f) ((ร CASE) 0x1e97)
            (ยง
                (regmbc (byte \t))
                (regmbc 0x163) regmbc(0x165) (regmbc 0x167)
                (regmbc 0x1e6b) regmbc(0x1e6f) (regmbc 0x1e97)
                (ร RETURN)
            )

            ((ร CASE) (byte \U))
            ((ร CASE) 0xd9) ((ร CASE) 0xda) ((ร CASE) 0xdb) ((ร CASE) 0xdc)
            ((ร CASE) 0x168) ((ร CASE) 0x16a) ((ร CASE) 0x16c) ((ร CASE) 0x16e)
            ((ร CASE) 0x170) ((ร CASE) 0x172) ((ร CASE) 0x1af) ((ร CASE) 0x1d3)
            ((ร CASE) 0x1ee6)
            (ยง
                (regmbc (byte \U))
                (regmbc 0xd9) regmbc(0xda) (regmbc 0xdb) regmbc(0xdc)
                (regmbc 0x168) regmbc(0x16a) (regmbc 0x16c) regmbc(0x16e)
                (regmbc 0x170) regmbc(0x172) (regmbc 0x1af) regmbc(0x1d3)
                (regmbc 0x1ee6)
                (ร RETURN)
            )
            ((ร CASE) (byte \u))
            ((ร CASE) 0xf9) ((ร CASE) 0xfa) ((ร CASE) 0xfb) ((ร CASE) 0xfc)
            ((ร CASE) 0x169) ((ร CASE) 0x16b) ((ร CASE) 0x16d) ((ร CASE) 0x16f)
            ((ร CASE) 0x171) ((ร CASE) 0x173) ((ร CASE) 0x1b0) ((ร CASE) 0x1d4)
            ((ร CASE) 0x1ee7)
            (ยง
                (regmbc (byte \u))
                (regmbc 0xf9) regmbc(0xfa) (regmbc 0xfb) regmbc(0xfc)
                (regmbc 0x169) regmbc(0x16b) (regmbc 0x16d) regmbc(0x16f)
                (regmbc 0x171) regmbc(0x173) (regmbc 0x1b0) regmbc(0x1d4)
                (regmbc 0x1ee7)
                (ร RETURN)
            )

            ((ร CASE) (byte \V))
            ((ร CASE) 0x1e7c)
            (ยง
                (regmbc (byte \V))
                (regmbc 0x1e7c)
                (ร RETURN)
            )
            ((ร CASE) (byte \v))
            ((ร CASE) 0x1e7d)
            (ยง
                (regmbc (byte \v))
                (regmbc 0x1e7d)
                (ร RETURN)
            )

            ((ร CASE) (byte \W))
            ((ร CASE) 0x174)
            ((ร CASE) 0x1e80) ((ร CASE) 0x1e82) ((ร CASE) 0x1e84) ((ร CASE) 0x1e86)
            (ยง
                (regmbc (byte \W))
                (regmbc 0x174)
                (regmbc 0x1e80) regmbc(0x1e82) (regmbc 0x1e84) regmbc(0x1e86)
                (ร RETURN)
            )
            ((ร CASE) (byte \w))
            ((ร CASE) 0x175)
            ((ร CASE) 0x1e81) ((ร CASE) 0x1e83) ((ร CASE) 0x1e85) ((ร CASE) 0x1e87) ((ร CASE) 0x1e98)
            (ยง
                (regmbc (byte \w))
                (regmbc 0x175)
                (regmbc 0x1e81) regmbc(0x1e83) (regmbc 0x1e85) regmbc(0x1e87) (regmbc 0x1e98)
                (ร RETURN)
            )

            ((ร CASE) (byte \X))
            ((ร CASE) 0x1e8a) ((ร CASE) 0x1e8c)
            (ยง
                (regmbc (byte \X))
                (regmbc 0x1e8a) regmbc(0x1e8c)
                (ร RETURN)
            )
            ((ร CASE) (byte \x))
            ((ร CASE) 0x1e8b) ((ร CASE) 0x1e8d)
            (ยง
                (regmbc (byte \x))
                (regmbc 0x1e8b) regmbc(0x1e8d)
                (ร RETURN)
            )

            ((ร CASE) (byte \Y))
            ((ร CASE) 0xdd)
            ((ร CASE) 0x176) ((ร CASE) 0x178)
            ((ร CASE) 0x1e8e) ((ร CASE) 0x1ef2) ((ร CASE) 0x1ef6) ((ร CASE) 0x1ef8)
            (ยง
                (regmbc (byte \Y))
                (regmbc 0xdd)
                (regmbc 0x176) regmbc(0x178)
                (regmbc 0x1e8e) regmbc(0x1ef2) (regmbc 0x1ef6) regmbc(0x1ef8)
                (ร RETURN)
            )
            ((ร CASE) (byte \y))
            ((ร CASE) 0xfd) ((ร CASE) 0xff)
            ((ร CASE) 0x177)
            ((ร CASE) 0x1e8f) ((ร CASE) 0x1e99) ((ร CASE) 0x1ef3) ((ร CASE) 0x1ef7) ((ร CASE) 0x1ef9)
            (ยง
                (regmbc (byte \y))
                (regmbc 0xfd) regmbc(0xff)
                (regmbc 0x177)
                (regmbc 0x1e8f) regmbc(0x1e99) (regmbc 0x1ef3) regmbc(0x1ef7) (regmbc 0x1ef9)
                (ร RETURN)
            )

            ((ร CASE) (byte \Z))
            ((ร CASE) 0x179) ((ร CASE) 0x17b) ((ร CASE) 0x17d) ((ร CASE) 0x1b5)
            ((ร CASE) 0x1e90) ((ร CASE) 0x1e94)
            (ยง
                (regmbc (byte \Z))
                (regmbc 0x179) regmbc(0x17b) (regmbc 0x17d) regmbc(0x1b5)
                (regmbc 0x1e90) regmbc(0x1e94)
                (ร RETURN)
            )
            ((ร CASE) (byte \z))
            ((ร CASE) 0x17a) ((ร CASE) 0x17c) ((ร CASE) 0x17e) ((ร CASE) 0x1b6)
            ((ร CASE) 0x1e91) ((ร CASE) 0x1e95)
            (ยง
                (regmbc (byte \z))
                (regmbc 0x17a) regmbc(0x17c) (regmbc 0x17e) regmbc(0x1b6)
                (regmbc 0x1e91) regmbc(0x1e95)
                (ร RETURN)
            )
        )

        (regmbc c)
    ))

;; Check for a collating element "[.a.]".  "pp" points to the '['.
;; Returns a character.  Zero means that no item was recognized.
;; Otherwise "pp" is advanced to after the item.
;; Currently only single characters are recognized!

(defn- #_int get_coll_element [#_Bytes* pp]
    (ยง
        ((ร Bytes p =) (ยง pp[0]))

        (when (== (.at p 1) (byte \.))
            ((ร int len =) (ยง us_ptr2len_cc(p.plus(2))))
            (when (and (== (.at p (+ len 2)) (byte \.)) (== (.at p (+ len 3)) (byte \])))
                ((ร int c =) (ยง us_ptr2char(p.plus(2))))
                ((ร pp[0] =) (ยง pp[0].plus(len + 4)))
                ((ร RETURN) c)
            )
        )

        0
    ))

(atom! boolean reg_cpo_lit)     ;; 'cpoptions' contains 'l' flag
(atom! boolean reg_cpo_bsl)     ;; 'cpoptions' contains '\' flag

(defn- #_void get_cpo_flags []
    (ยง
        (reset! reg_cpo_lit (non-nil? (vim_strbyte @p_cpo, CPO_LITERAL)))
        (reset! reg_cpo_bsl (non-nil? (vim_strbyte @p_cpo, CPO_BACKSL)))
    ))

;; Skip over a "[]" range.
;; "p" must point to the character after the '['.
;; The returned pointer is on the matching ']', or the terminating NUL.

(defn- #_Bytes skip_anyof [#_Bytes p]
    (ยง
        (if (== (.at p 0) (byte \^))      ;; Complement of range.
            ((ร p =) (ยง p.plus(1)))
        )
        (if (or (== (.at p 0) (byte \])) (== (.at p 0) (byte \-)))
            ((ร p =) (ยง p.plus(1)))
        )
        (while (ยง p.at(0) != NUL && p.at(0) != (byte \]))
            ((ร int l =) (us_ptr2len_cc p))
            (cond (< 1 l)
            (ยง
                ((ร p =) (ยง p.plus(l)))
            )
            (== (.at p 0) (byte \-))
            (ยง
                ((ร p =) (ยง p.plus(1)))
                (if (and (!= (.at p 0) (byte \])) (non-eos? p))
                    ((ร p =) (ยง p.plus(us_ptr2len_cc(p))))
                )
            )
            (and (== (.at p 0) (byte \\)) (not @reg_cpo_bsl) (or (non-nil? (ยง vim_strchr(REGEXP_INRANGE, p.at(1)))) (and (not @reg_cpo_lit) (non-nil? (ยง vim_strchr(REGEXP_ABBR, p.at(1)))))))
            (ยง
                ((ร p =) (ยง p.plus(2)))
            )
            (== (.at p 0) (byte \[))
            (ยง
                (ร boolean b)
;               { Bytes[] __ = { p }; b = (get_char_class(__) == CLASS_NONE && get_equi_class(__) == 0 && get_coll_element(__) == 0); p = __[0]; }
                (if b
                    ((ร p =) (ยง p.plus(1))) ;; not a class name
                )
            )
            :else
            (ยง
                ((ร p =) (ยง p.plus(1)))
            ))
        )

        p
    ))

;; Skip past regular expression.
;; Stop at end of "startp" or where "dirc" is found ('/', '?', etc).
;; Take care of characters with a backslash in front of it.
;; Skip strings inside [ and ].
;; When "newp" is not null and "dirc" is '?', make an allocated copy of the expression
;; and change "\?" to "?".  If "*newp" is not null the expression is changed in-place.

(defn- #_Bytes skip_regexp [#_Bytes startp, #_byte dirc, #_boolean magic, #_Bytes* newp]
    (ยง
        ((ร Bytes p =) startp)

        (ร int mymagic)
        (if magic
            ((ร mymagic =) MAGIC_ON)
            ((ร mymagic =) MAGIC_OFF)
        )

        (get_cpo_flags)

        ((ร FOR) (ร (ยง  ) (ยง p.at(0) != NUL) (ยง p = p.plus(us_ptr2len_cc(p))))
            (if (== (.at p 0) dirc)       ;; found end of regexp
                (ร BREAK)
            )
            (cond (or (and (== (.at p 0) (byte \[)) (<= MAGIC_ON mymagic)) (and (== (.at p 0) (byte \\)) (== (.at p 1) (byte \[)) (<= mymagic MAGIC_OFF)))
            (ยง
                ((ร p =) (ยง skip_anyof(p.plus(1))))
                (if (eos? p)
                    (ร BREAK)
                )
            )
            (and (== (.at p 0) (byte \\)) (non-eos? p 1))
            (ยง
                (cond (and (== dirc (byte \?)) (non-nil? newp) (== (.at p 1) (byte \?)))
                (ยง
                    ;; change "\?" to "?", make a copy first.
                    (when (nil? (ยง newp[0]))
                        ((ร newp[0] =) (STRDUP startp))
                        ((ร p =) (ยง newp[0].plus(BDIFF(p, startp))))
                    )
                    (if (!= (ยง newp[0]) null)
                        (BCOPY p, 0, p, 1, (+ (STRLEN p, 1) 1))
                        ((ร p =) (ยง p.plus(1)))
                    )
                )
                :else
                (ยง
                    ((ร p =) (ยง p.plus(1)))    ;; skip next character
                ))
                (cond (== (.at p 0) (byte \v))
                (ยง
                    ((ร mymagic =) MAGIC_ALL)
                )
                (== (.at p 0) (byte \V))
                (ยง
                    ((ร mymagic =) MAGIC_NONE)
                ))
            ))
        )

        p
    ))

;; bt_regcomp() - compile a regular expression into internal code for the
;; traditional back track matcher.
;; Returns the program in allocated space.  Returns null for an error.
;;
;; We can't allocate space until we know how big the compiled form will be,
;; but we can't compile it (and thus know how big it is) until we've got a
;; place to put the code.  So we cheat:  we compile it twice, once with code
;; generation turned off and size counting turned on, and once "for real".
;; This also means that we don't allocate space until we are sure that the
;; thing really will compile successfully, and we never have to move the
;; code and thus invalidate pointers into it.
;;
;; Whether upper/lower case is to be ignored is decided when executing the
;; program, it does not matter here.
;;
;; Beware that the optimization-preparation code in here knows about some
;; of the structure of the compiled regexp.
;; "re_flags": RE_MAGIC and/or RE_STRING.

(defn- #_regprog_C bt_regcomp [#_Bytes expr, #_int re_flags]
    (ยง
        (when (nil? expr)
            (emsg e_null)
            (reset! rc_did_emsg true)
            ((ร RETURN) null)
        )

        (init_class_tab)

        ;; First pass: determine size, legality.

        (regcomp_start expr, re_flags)
        (reset! regcode JUST_CALC_SIZE)
        (regc REGMAGIC)
        ((ร int[] flags =) (ยง new int[1]))
        (if (nil? (reg REG_NOPAREN, flags))
            ((ร RETURN) null)
        )

        ;; Allocate space.
        ((ร bt_regprog_C r =) (ยง new bt_regprog_C()))
        ((ร r.program =) (ยง new Bytes(@regsize + 1)))

        ;; Second pass: emit code.

        (regcomp_start expr, re_flags)
        (reset! regcode (. r program))
        (regc REGMAGIC)
        (when (or (nil? (reg REG_NOPAREN, flags)) @reg_toolong)
            (when @reg_toolong
                (emsg (u8 "E339: Pattern too long"))
                (reset! rc_did_emsg true)
            )
            ((ร RETURN) null)
        )

        ;; Dig out information for optimizations.
        ((ร r.regstart =) NUL)                   ;; Worst-case defaults.
        ((ร r.reganch =) 0)
        ((ร r.regmust =) null)
        ((ร r.regmlen =) 0)
        ((ร r.regflags =) @regflags)
        (if (non-zero? (& (ยง flags[0]) HASNL))
            ((ร r.regflags |=) RF_HASNL)
        )
        (if (non-zero? (& (ยง flags[0]) HASLOOKBH))
            ((ร r.regflags |=) RF_LOOKBH)
        )
        ;; Remember whether this pattern has any \z specials in it.
        ((ร r.reghasz =) @re_has_z)

        ((ร Bytes scan =) (ยง r.program.plus(1)))        ;; First BRANCH.
        (when (== (re_op (regnext scan)) END)    ;; Only one top-level choice.
            ((ร scan =) (operand scan))

            ;; Starting-point info.
            (when (or (== (re_op scan) BOL) (== (re_op scan) RE_BOF))
                (ยง r.reganch++)
                ((ร scan =) (regnext scan))
            )

            (cond (== (re_op scan) EXACTLY)
            (ยง
                ((ร r.regstart =) (ยง us_ptr2char(operand(scan))))
            )
            (and (or (== (re_op scan) BOW) (== (re_op scan) EOW) (== (re_op scan) NOTHING) (== (re_op scan) (+ MOPEN 0)) (== (re_op scan) NOPEN) (== (re_op scan) (+ MCLOSE 0)) (== (re_op scan) NCLOSE)) (== (re_op (regnext scan)) EXACTLY))
            (ยง
                ((ร r.regstart =) (ยง us_ptr2char(operand(regnext(scan)))))
            ))

            ;; If there's something expensive in the r.e., find the longest literal string
            ;; that must appear and make it the regmust.  Resolve ties in favor of later strings,
            ;; since the regstart check works with the beginning of the r.e. and avoiding duplication
            ;; strengthens checking.  Not a strong reason, but sufficient in the absence of others.

            ;; When the r.e. starts with BOW, it is faster to look for a regmust first.
            ;; Used a lot for "#" and "*" commands.

            (when (and (or (non-zero? (& (ยง flags[0]) SPSTART)) (== (re_op scan) BOW) (== (re_op scan) EOW)) (zero? (& (ยง flags[0]) HASNL)))
                ((ร Bytes longest =) null)
                ((ร int len =) 0)
                ((ร FOR) (ร (ยง  ) (!= scan null) (ยง scan = regnext(scan)))
                    (when (and (== (re_op scan) EXACTLY) (<= len (STRLEN (operand scan))))
                        ((ร longest =) (operand scan))
                        ((ร len =) (ยง STRLEN(operand(scan))))
                    )
                )
                ((ร r.regmust =) longest)
                ((ร r.regmlen =) len)
            )
        )

        ((ร r.engine =) bt_regengine)
        (ยง (regprog_C)r)
    ))

;; Setup to parse the regexp.  Used once to get the length and once to do it.

(defn- #_void regcomp_start [#_Bytes expr, #_int re_flags]
    ;; re_flags: see vim_regcomp()
    (ยง
        (initchr expr)
        (if (non-zero? (& re_flags RE_MAGIC))
            (reset! reg_magic MAGIC_ON)
            (reset! reg_magic MAGIC_OFF))
        (reset! reg_string (non-zero? (& re_flags RE_STRING)))
        (reset! reg_strict (non-zero? (& re_flags RE_STRICT)))
        (get_cpo_flags)

        (reset! num_complex_braces 0)
        (reset! regnpar 1)
        (AFILL @had_endbrace, false)
        (reset! regnzpar 1)
        (reset! re_has_z 0)
        (reset! regsize 0)
        (reset! reg_toolong false)
        (reset! regflags 0)
    ))

;; Parse regular expression, i.e. main body or parenthesized thing.
;;
;; Caller must absorb opening parenthesis.
;;
;; Combining parenthesis handling with the base level of regular expression
;; is a trifle forced, but the need to tie the tails of the branches to what
;; follows makes it hard to avoid.

(defn- #_Bytes reg [#_int paren, #_int* flagp]
    ;; paren: REG_NOPAREN, REG_PAREN, REG_NPAREN or REG_ZPAREN
    (ยง
        (ร Bytes ret)

        ((ร flagp[0] =) HASWIDTH)          ;; Tentatively.

        ((ร int parno =) 0)
        (cond (== paren REG_ZPAREN)
        (ยง
            ;; Make a ZOPEN node.
            (when (<= NSUBEXP @regnzpar)
                (emsg (u8 "E50: Too many \\z("))
                (reset! rc_did_emsg true)
                ((ร RETURN) null)
            )
            ((ร parno =) @regnzpar)
            (swap! regnzpar inc)
            ((ร ret =) (ยง regnode(ZOPEN + parno)))
        )
        (== paren REG_PAREN)
        (ยง
            ;; Make a MOPEN node.
            (when (<= NSUBEXP @regnpar)
                (emsg2 (u8 "E51: Too many %s("), (if (== @reg_magic MAGIC_ALL) (u8 "") (u8 "\\")))
                (reset! rc_did_emsg true)
                ((ร RETURN) null)
            )
            ((ร parno =) @regnpar)
            (swap! regnpar inc)
            ((ร ret =) (ยง regnode(MOPEN + parno)))
        )
        (== paren REG_NPAREN)
        (ยง
            ;; Make a NOPEN node.
            ((ร ret =) (regnode NOPEN))
        )
        :else
        (ยง
            ((ร ret =) null)
        ))

        ;; Pick up the branches, linking them together.
        ((ร int[] flags =) (ยง new int[1]))
        ((ร Bytes br =) (regbranch flags))
        (if (nil? br)
            ((ร RETURN) null)
        )
        (if (non-nil? ret)
            (regtail ret, br)       ;; [MZ]OPEN -> first.
            ((ร ret =) br)
        )
        ;; If one of the branches can be zero-width, the whole thing can.
        ;; If one of the branches has * at start or matches a line-break, the whole thing can.
        (if (zero? (& (ยง flags[0]) HASWIDTH))
            ((ร flagp[0] &=) (ยง ~HASWIDTH))
        )
        ((ร flagp[0] |=) (ยง flags[0] & (SPSTART | HASNL | HASLOOKBH)))
        (while (ยง peekchr() == Magic((byte \|)))
            (skipchr)
            ((ร br =) (regbranch flags))
            (if (or (nil? br) @reg_toolong)
                ((ร RETURN) null)
            )
            (regtail ret, br)       ;; BRANCH -> BRANCH.
            (if (zero? (& (ยง flags[0]) HASWIDTH))
                ((ร flagp[0] &=) (ยง ~HASWIDTH))
            )
            ((ร flagp[0] |=) (ยง flags[0] & (SPSTART | HASNL | HASLOOKBH)))
        )

        ;; Make a closing node, and hook it on the end.
        ((ร Bytes ender =) (regnode (cond (== paren REG_ZPAREN) (+ ZCLOSE parno) (== paren REG_PAREN) (+ MCLOSE parno) (== paren REG_NPAREN) NCLOSE :else END)))

        (regtail ret, ender)

        ;; Hook the tails of the branches to the closing node.
        ((ร FOR) (ร (ยง br = ret) (!= br null) (ยง br = regnext(br)))
            (regoptail br, ender)
        )

        ;; Check for proper termination.
        (cond (and (!= paren REG_NOPAREN) (!= (getchr) (Magic (byte \)))))
        (ยง
            (cond (== paren REG_ZPAREN)
            (ยง
                (emsg (u8 "E52: Unmatched \\z("))
            )
            (== paren REG_NPAREN)
            (ยง
                (emsg2 e_unmatchedpp, (if (== @reg_magic MAGIC_ALL) (u8 "") (u8 "\\")))
            )
            :else
            (ยง
                (emsg2 e_unmatchedp, (if (== @reg_magic MAGIC_ALL) (u8 "") (u8 "\\")))
            ))
            (reset! rc_did_emsg true)
            ((ร RETURN) null)
        )
        (and (== paren REG_NOPAREN) (!= (peekchr) NUL))
        (ยง
            (if (== @curchr (Magic (byte \))))
                (emsg2 e_unmatchedpar, (if (== @reg_magic MAGIC_ALL) (u8 "") (u8 "\\")))
                (emsg e_trailing))
            (reset! rc_did_emsg true)
            ((ร RETURN) null)                    ;; "Can't happen".
        ))

        ;; Here we set the flag allowing back references to this set of parentheses.

        (if (== paren REG_PAREN)
            ((ร @had_endbrace[parno] =) true)     ;; have seen the close paren
        )
        ret
    ))

;; Parse one alternative of an | operator.
;; Implements the & operator.

(defn- #_Bytes regbranch [#_int* flagp]
    (ยง
        ((ร flagp[0] =) (ยง (WORST | HASNL)))           ;; Tentatively.

        ((ร Bytes ret =) (regnode BRANCH))

        ((ร FOR) (ร (ยง Bytes chain = null) true nil)
            ((ร int[] flags =) (ยง new int[1]))
            ((ร Bytes latest =) (regconcat flags))
            (if (nil? latest)
                ((ร RETURN) null)
            )

            ;; If one of the branches has width, the whole thing has.
            ;; If one of the branches anchors at start-of-line, the whole thing does.
            ;; If one of the branches uses look-behind, the whole thing does.
            ((ร flagp[0] |=) (ยง flags[0] & (HASWIDTH | SPSTART | HASLOOKBH)))
            ;; If one of the branches doesn't match a line-break, the whole thing doesn't.
            ((ร flagp[0] &=) (ยง ~HASNL | (flags[0] & HASNL)))
            (if (non-nil? chain)
                (regtail chain, latest))
            (if (!= (peekchr) (Magic (byte \&)))
                (ร BREAK)
            )

            (skipchr)
            (regtail latest, (regnode END)) ;; operand ends
            (if @reg_toolong
                (ร BREAK)
            )

            (reginsert MATCH, latest)
            ((ร chain =) latest)
        )

        ret
    ))

;; Parse one alternative of an | or & operator.
;; Implements the concatenation operator.

(defn- #_Bytes regconcat [#_int* flagp]
    (ยง
        ((ร Bytes first =) null)
        ((ร Bytes chain =) null)

        ((ร flagp[0] =) WORST)             ;; Tentatively.

        ((ร FOR) (ร (ยง boolean cont = true) cont nil)
            ((ร SWITCH) (peekchr)
                ((ร CASE) NUL)
                ((ร CASE) (Magic (byte \|)))
                ((ร CASE) (Magic (byte \&)))
                ((ร CASE) (Magic (byte \))))
                (ยง
                    ((ร cont =) false)
                    (ร BREAK)
                )

                ((ร CASE) (Magic (byte \Z)))
                (ยง
                    ((ร @regflags |=) RF_ICOMBINE)
                    (skipchr_keepstart)
                    (ร BREAK)
                )

                ((ร CASE) (Magic (byte \c)))
                (ยง
                    ((ร @regflags |=) RF_ICASE)
                    (skipchr_keepstart)
                    (ร BREAK)
                )

                ((ร CASE) (Magic (byte \C)))
                (ยง
                    ((ร @regflags |=) RF_NOICASE)
                    (skipchr_keepstart)
                    (ร BREAK)
                )

                ((ร CASE) (Magic (byte \v)))
                (ยง
                    (reset! reg_magic MAGIC_ALL)
                    (skipchr_keepstart)
                    (reset! curchr -1)
                    (ร BREAK)
                )

                ((ร CASE) (Magic (byte \m)))
                (ยง
                    (reset! reg_magic MAGIC_ON)
                    (skipchr_keepstart)
                    (reset! curchr -1)
                    (ร BREAK)
                )

                ((ร CASE) (Magic (byte \M)))
                (ยง
                    (reset! reg_magic MAGIC_OFF)
                    (skipchr_keepstart)
                    (reset! curchr -1)
                    (ร BREAK)
                )

                ((ร CASE) (Magic (byte \V)))
                (ยง
                    (reset! reg_magic MAGIC_NONE)
                    (skipchr_keepstart)
                    (reset! curchr -1)
                    (ร BREAK)
                )

                (ร DEFAULT)
                (ยง
                    ((ร int[] flags =) (ยง new int[1]))
                    ((ร Bytes latest =) (regpiece flags))
                    (if (or (nil? latest) @reg_toolong)
                        ((ร RETURN) null)
                    )

                    ((ร flagp[0] |=) (ยง flags[0] & (HASWIDTH | HASNL | HASLOOKBH)))
                    (if (nil? chain)  ;; First piece.
                        ((ร flagp[0] |=) (ยง flags[0] & SPSTART))
                        (regtail chain, latest))
                    ((ร chain =) latest)
                    (if (nil? first)
                        ((ร first =) latest)
                    )
                    (ร BREAK)
                )
            )
        )

        (if (nil? first)          ;; Loop ran zero times.
            ((ร first =) (regnode NOTHING))
        )
        first
    ))

;; Parse something followed by possible [*+=].
;;
;; Note that the branching code sequences used for = and the general cases
;; of * and + are somewhat optimized:  they use the same NOTHING node as
;; both the endmarker for their branch list and the body of the last branch.
;; It might seem that this node could be dispensed with entirely, but the
;; endmarker role is not redundant.

(defn- #_Bytes regpiece [#_int* flagp]
    (ยง
        ((ร int[] flags =) (ยง new int[1]))
        ((ร Bytes ret =) (regatom flags))
        (if (nil? ret)
            ((ร RETURN) null)
        )

        ((ร int op =) (peekchr))
        (when (== (re_multi_type op) NOT_MULTI)
            ((ร flagp[0] =) (ยง flags[0]))
            ((ร RETURN) ret)
        )

        ;; default flags
        ((ร flagp[0] =) (ยง (WORST | SPSTART | (flags[0] & (HASNL | HASLOOKBH)))))

        (skipchr)
        ((ร SWITCH) op
            ((ร CASE) (Magic (byte \*)))
            (ยง
                (cond (non-zero? (& (ยง flags[0]) SIMPLE))
                (ยง
                    (reginsert STAR, ret)
                )
                :else
                (ยง
                    ;; Emit x* as (x&|), where & means "self".
                    (reginsert BRANCH, ret)             ;; Either x
                    (regoptail ret, (regnode BACK))      ;; and loop
                    (regoptail ret, ret)                ;; back
                    (regtail ret, (regnode BRANCH))      ;; or
                    (regtail ret, (regnode NOTHING))     ;; null.
                ))
                (ร BREAK)
            )

            ((ร CASE) (Magic (byte \+)))
            (ยง
                (cond (non-zero? (& (ยง flags[0]) SIMPLE))
                (ยง
                    (reginsert PLUS, ret)
                )
                :else
                (ยง
                    ;; Emit x+ as x(&|), where & means "self".
                    ((ร Bytes next =) (regnode BRANCH))      ;; Either
                    (regtail ret, next)
                    (regtail (regnode BACK), ret)        ;; loop back
                    (regtail next, (regnode BRANCH))     ;; or
                    (regtail ret, (regnode NOTHING))     ;; null.
                ))
                ((ร flagp[0] =) (ยง (WORST | HASWIDTH | (flags[0] & (HASNL | HASLOOKBH)))))
                (ร BREAK)
            )

            ((ร CASE) (Magic (byte \@)))
            (ยง
                ((ร int lop =) END)
                ((ร int nr =) (getdecchrs))

                ((ร SWITCH) (ยง no_Magic(getchr()))
                    ((ร CASE) (byte \=))
                    (ยง
                        ((ร lop =) MATCH)                ;; \@=
                        (ร BREAK)
                    )
                    ((ร CASE) (byte \!))
                    (ยง
                        ((ร lop =) NOMATCH)              ;; \@!
                        (ร BREAK)
                    )
                    ((ร CASE) (byte \>))
                    (ยง
                        ((ร lop =) SUBPAT)               ;; \@>
                        (ร BREAK)
                    )
                    ((ร CASE) (byte \<))
                    (ยง
                        ((ร SWITCH) (ยง no_Magic(getchr()))
                            ((ร CASE) (byte \=))
                            (ยง
                                ((ร lop =) BEHIND)       ;; \@<=
                                (ร BREAK)
                            )
                            ((ร CASE) (byte \!))
                            (ยง
                                ((ร lop =) NOBEHIND)     ;; \@<!
                                (ร BREAK)
                            )
                        )
                        (ร BREAK)
                    )
                )

                (when (== lop END)
                    (emsg2 (u8 "E59: invalid character after %s@"), (if (== @reg_magic MAGIC_ALL) (u8 "") (u8 "\\")))
                    (reset! rc_did_emsg true)
                    ((ร RETURN) null)
                )
                ;; Look behind must match with behind_pos.
                (when (or (== lop BEHIND) (== lop NOBEHIND))
                    (regtail ret, (regnode BHPOS))
                    ((ร flagp[0] |=) HASLOOKBH)
                )
                (regtail ret, (regnode END))                 ;; operand ends
                (cond (or (== lop BEHIND) (== lop NOBEHIND))
                (ยง
                    (if (< nr 0)
                        ((ร nr =) 0)                             ;; no limit is same as zero limit
                    )
                    (reginsert_nr lop, nr, ret)
                )
                :else
                (ยง
                    (reginsert lop, ret)
                ))
                (ร BREAK)
            )

            ((ร CASE) (Magic (byte \?)))
            ((ร CASE) (Magic (byte \=)))
            (ยง
                ;; Emit x= as (x|).
                (reginsert BRANCH, ret)                 ;; Either x
                (regtail ret, (regnode BRANCH))          ;; or
                ((ร Bytes next =) (regnode NOTHING))         ;; null.
                (regtail ret, next)
                (regoptail ret, next)
                (ร BREAK)
            )

            ((ร CASE) (Magic (byte \{)))
            (ยง
                ((ร long[] minval =) (ยง new long[1]))
                ((ร long[] maxval =) (ยง new long[1]))
                (if (not (read_limits minval, maxval))
                    ((ร RETURN) null)
                )

                (cond (non-zero? (& (ยง flags[0]) SIMPLE))
                (ยง
                    (reginsert BRACE_SIMPLE, ret)
                    (reginsert_limits BRACE_LIMITS, (ยง minval[0]), (ยง maxval[0]), ret)
                )
                :else
                (ยง
                    (when (<= 10 @num_complex_braces)
                        (emsg2 (u8 "E60: Too many complex %s{...}s"), (if (== @reg_magic MAGIC_ALL) (u8 "") (u8 "\\")))
                        (reset! rc_did_emsg true)
                        ((ร RETURN) null)
                    )
                    (reginsert (+ BRACE_COMPLEX @num_complex_braces), ret)
                    (regoptail ret, (regnode BACK))
                    (regoptail ret, ret)
                    (reginsert_limits BRACE_LIMITS, (ยง minval[0]), (ยง maxval[0]), ret)
                    (swap! num_complex_braces inc)
                ))
                (if (and (< 0 (ยง minval[0])) (< 0 (ยง maxval[0])))
                    ((ร flagp[0] =) (ยง (HASWIDTH | (flags[0] & (HASNL | HASLOOKBH)))))
                )
                (ร BREAK)
            )
        )

        (when (!= (re_multi_type (peekchr)) NOT_MULTI)
            ;; Can't have a multi follow a multi.
            (if (== (peekchr) (Magic (byte \*)))
                (.sprintf libC @ioBuff, (u8 "E61: Nested %s*"), (if (<= MAGIC_ON @reg_magic) (u8 "") (u8 "\\")))
                (.sprintf libC @ioBuff, (u8 "E62: Nested %s%c"), (if (== @reg_magic MAGIC_ALL) (u8 "") (u8 "\\")), (no_Magic (peekchr)))
            )

            (emsg @ioBuff)
            (reset! rc_did_emsg true)
            ((ร RETURN) null)
        )

        ret
    ))

;; When making changes to "classchars" also change "nfa_classcodes".
(final Bytes classchars (u8 ".iIkKfFpPsSdDxXoOwWhHaAlLuU"))
(final int* classcodes
    [
        ANY,
        IDENT, SIDENT,
        KWORD, SKWORD,
        FNAME, SFNAME,
        PRINT, SPRINT,
        WHITE, NWHITE,
        DIGIT, NDIGIT,
        HEX,   NHEX,
        OCTAL, NOCTAL,
        WORD,  NWORD,
        HEAD,  NHEAD,
        ALPHA, NALPHA,
        LOWER, NLOWER,
        UPPER, NUPPER
    ])

;; Parse the lowest level.
;;
;; Optimization:  gobbles an entire sequence of ordinary characters so that
;; it can turn them into a single node, which is smaller to store and
;; faster to run.  Don't do this when one_exactly is set.

(defn- #_Bytes regatom [#_int* flagp]
    (ยง
        (ร Bytes ret)

        ((ร int extra =) 0)

        ((ร flagp[0] =) WORST)             ;; Tentatively.

        ((ร int c =) (getchr))

;       collection:
;       {
            ((ร SWITCH) c
                ((ร CASE) (Magic (byte \^)))
                (ยง
                    ((ร ret =) (regnode BOL))
                    (ร BREAK)
                )

                ((ร CASE) (Magic (byte \$)))
                (ยง
                    ((ร ret =) (regnode EOL))
                    (ร BREAK)
                )

                ((ร CASE) (Magic (byte \<)))
                (ยง
                    ((ร ret =) (regnode BOW))
                    (ร BREAK)
                )

                ((ร CASE) (Magic (byte \>)))
                (ยง
                    ((ร ret =) (regnode EOW))
                    (ร BREAK)
                )

                ((ร CASE) (Magic (byte \_)))
                (ยง
                    ((ร c =) (ยง no_Magic(getchr())))
                    (when (== c (byte \^))           ;; "\_^" is start-of-line
                        ((ร ret =) (regnode BOL))
                        (ร BREAK)
                    )
                    (when (== c (byte \$))           ;; "\_$" is end-of-line
                        ((ร ret =) (regnode EOL))
                        (ร BREAK)
                    )

                    ((ร extra =) ADD_NL)
                    ((ร flagp[0] |=) HASNL)

                    ;; "\_[" is character range plus newline
                    (if (== c (byte \[))
                        (ร BREAK collection)
                    )

                    ;; "\_x" is character class plus newline
                    (ร FALLTHROUGH)
                )

                ;; Character classes.

                ((ร CASE) (Magic (byte \.)))
                ((ร CASE) (Magic (byte \i)))
                ((ร CASE) (Magic (byte \I)))
                ((ร CASE) (Magic (byte \k)))
                ((ร CASE) (Magic (byte \K)))
                ((ร CASE) (Magic (byte \f)))
                ((ร CASE) (Magic (byte \F)))
                ((ร CASE) (Magic (byte \p)))
                ((ร CASE) (Magic (byte \P)))
                ((ร CASE) (Magic (byte \s)))
                ((ร CASE) (Magic (byte \S)))
                ((ร CASE) (Magic (byte \d)))
                ((ร CASE) (Magic (byte \D)))
                ((ร CASE) (Magic (byte \x)))
                ((ร CASE) (Magic (byte \X)))
                ((ร CASE) (Magic (byte \o)))
                ((ร CASE) (Magic (byte \O)))
                ((ร CASE) (Magic (byte \w)))
                ((ร CASE) (Magic (byte \W)))
                ((ร CASE) (Magic (byte \h)))
                ((ร CASE) (Magic (byte \H)))
                ((ร CASE) (Magic (byte \a)))
                ((ร CASE) (Magic (byte \A)))
                ((ร CASE) (Magic (byte \l)))
                ((ร CASE) (Magic (byte \L)))
                ((ร CASE) (Magic (byte \u)))
                ((ร CASE) (Magic (byte \U)))
                (ยง
                    ((ร Bytes p =) (ยง vim_strchr(classchars, no_Magic(c))))
                    (when (nil? p)
                        (emsg (u8 "E63: invalid use of \\_"))
                        (reset! rc_did_emsg true)
                        ((ร RETURN) null)
                    )
                    ;; When '.' is followed by a composing char ignore the dot,
                    ;; so that the composing char is matched here.
                    (when (and (== c (Magic (byte \.))) (utf_iscomposing (peekchr)))
                        ((ร c =) (getchr))
                        ((ร ret =) (regnode MULTIBYTECODE))
                        (regmbc c)
                        ((ร flagp[0] |=) (| HASWIDTH SIMPLE))
                        (ร BREAK)
                    )
                    ((ร ret =) (ยง regnode(classcodes[BDIFF(p, classchars)] + extra)))
                    ((ร flagp[0] |=) (| HASWIDTH SIMPLE))
                    (ร BREAK)
                )

                ((ร CASE) (Magic (byte \n)))
                (ยง
                    (cond @reg_string
                    (ยง
                        ;; In a string "\n" matches a newline character.
                        ((ร ret =) (regnode EXACTLY))
                        (regc NL)
                        (regc NUL)
                        ((ร flagp[0] |=) (| HASWIDTH SIMPLE))
                    )
                    :else
                    (ยง
                        ;; In buffer text "\n" matches the end of a line.
                        ((ร ret =) (regnode NEWL))
                        ((ร flagp[0] |=) (| HASWIDTH HASNL))
                    ))
                    (ร BREAK)
                )

                ((ร CASE) (Magic (byte \()))
                (ยง
                    (when @one_exactly
                        (emsg2 (u8 "E369: invalid item in %s%%[]"), (if (== @reg_magic MAGIC_ALL) (u8 "") (u8 "\\")))
                        (reset! rc_did_emsg true)
                        ((ร RETURN) null)
                    )
                    ((ร int[] flags =) (ยง new int[1]))
                    ((ร ret =) (reg REG_PAREN, flags))
                    (if (nil? ret)
                        ((ร RETURN) null)
                    )
                    ((ร flagp[0] |=) (ยง flags[0] & (HASWIDTH | SPSTART | HASNL | HASLOOKBH)))
                    (ร BREAK)
                )

                ((ร CASE) NUL)
                ((ร CASE) (Magic (byte \|)))
                ((ร CASE) (Magic (byte \&)))
                ((ร CASE) (Magic (byte \))))
                (ยง
                    (if @one_exactly
                        (emsg2 (u8 "E369: invalid item in %s%%[]"), (if (== @reg_magic MAGIC_ALL) (u8 "") (u8 "\\")))
                        (emsg e_internal))       ;; Supposed to be caught earlier.
                    (reset! rc_did_emsg true)
                    ((ร RETURN) null)
                )

                ((ร CASE) (Magic (byte \=)))
                ((ร CASE) (Magic (byte \?)))
                ((ร CASE) (Magic (byte \+)))
                ((ร CASE) (Magic (byte \@)))
                ((ร CASE) (Magic (byte \{)))
                ((ร CASE) (Magic (byte \*)))
                (ยง
                    ((ร c =) (no_Magic c))
                    (.sprintf libC @ioBuff, (u8 "E64: %s%c follows nothing"), (if (if (== c (byte \*)) (<= MAGIC_ON @reg_magic) (== @reg_magic MAGIC_ALL)) (u8 "") (u8 "\\")), c)

                    (emsg @ioBuff)
                    (reset! rc_did_emsg true)
                    ((ร RETURN) null)
                )

                ((ร CASE) (Magic (byte \~)))                    ;; previous substitute pattern
                (ยง
                    (cond (non-nil? @reg_prev_sub)
                    (ยง
                        ((ร ret =) (regnode EXACTLY))
                        ((ร Bytes lp =) @reg_prev_sub)
                        (while (ยง lp.at(0) != NUL)
                            (regc (ยง (lp = lp.plus(1)).at(-1)))
                        )
                        (regc NUL)
                        (when (non-eos? @reg_prev_sub)
                            ((ร flagp[0] |=) HASWIDTH)
                            (if (== (BDIFF lp, @reg_prev_sub) 1)
                                ((ร flagp[0] |=) SIMPLE)
                            )
                        )
                    )
                    :else
                    (ยง
                        (emsg e_nopresub)
                        (reset! rc_did_emsg true)
                        ((ร RETURN) null)
                    ))
                    (ร BREAK)
                )

                ((ร CASE) (Magic (byte \1)))
                ((ร CASE) (Magic (byte \2)))
                ((ร CASE) (Magic (byte \3)))
                ((ร CASE) (Magic (byte \4)))
                ((ร CASE) (Magic (byte \5)))
                ((ร CASE) (Magic (byte \6)))
                ((ร CASE) (Magic (byte \7)))
                ((ร CASE) (Magic (byte \8)))
                ((ร CASE) (Magic (byte \9)))
                (ยง
                    ((ร int refnum =) (ยง c - Magic((byte \0))))

                    ;; Check if the back reference is legal.  We must have seen the close brace.
                    ;; TODO: Should also check that we don't refer to something
                    ;; that is repeated (+*=): what instance of the repetition should we match?

                    (when (not (ยง @had_endbrace[refnum]))
                        ;; Trick: check if "@<=" or "@<!" follows, in which case
                        ;; the \1 can appear before the referenced match.
                        (ร Bytes p)
                        ((ร FOR) (ร (ยง p = @regparse) (ยง p.at(0) != NUL) (ยง p = p.plus(1)))
                            (if (and (== (.at p 0) (byte \@)) (== (.at p 1) (byte \<)) (or (== (.at p 2) (byte \!)) (== (.at p 2) (byte \=))))
                                (ร BREAK)
                            )
                        )
                        (when (eos? p)
                            (emsg (u8 "E65: Illegal back reference"))
                            (reset! rc_did_emsg true)
                            ((ร RETURN) null)
                        )
                    )
                    ((ร ret =) (ยง regnode(BACKREF + refnum)))
                    (ร BREAK)
                )

                ((ร CASE) (Magic (byte \z)))
                (ยง
                    ((ร c =) (ยง no_Magic(getchr())))
                    ((ร SWITCH) c
                        ((ร CASE) (byte \())
                        (ยง
                            (when (!= @reg_do_extmatch REX_SET)
                                (emsg e_z_not_allowed)
                                (reset! rc_did_emsg true)
                                ((ร RETURN) null)
                            )
                            (when @one_exactly
                                (emsg2 (u8 "E369: invalid item in %s%%[]"), (if (== @reg_magic MAGIC_ALL) (u8 "") (u8 "\\")))
                                (reset! rc_did_emsg true)
                                ((ร RETURN) null)
                            )
                            ((ร int[] flags =) (ยง new int[1]))
                            ((ร ret =) (reg REG_ZPAREN, flags))
                            (if (nil? ret)
                                ((ร RETURN) null)
                            )
                            ((ร flagp[0] |=) (ยง flags[0] & (HASWIDTH|SPSTART|HASNL|HASLOOKBH)))
                            (reset! re_has_z REX_SET)
                            (ร BREAK)
                        )
                        ((ร CASE) (byte \1))
                        ((ร CASE) (byte \2))
                        ((ร CASE) (byte \3))
                        ((ร CASE) (byte \4))
                        ((ร CASE) (byte \5))
                        ((ร CASE) (byte \6))
                        ((ร CASE) (byte \7))
                        ((ร CASE) (byte \8))
                        ((ร CASE) (byte \9))
                        (ยง
                            (when (!= @reg_do_extmatch REX_USE)
                                (emsg e_z1_not_allowed)
                                (reset! rc_did_emsg true)
                                ((ร RETURN) null)
                            )
                            ((ร ret =) (ยง regnode(ZREF + c - (byte \0))))
                            (reset! re_has_z REX_USE)
                            (ร BREAK)
                        )
                        ((ร CASE) (byte \s))
                        (ยง
                            ((ร ret =) (ยง regnode(MOPEN + 0)))
                            (if (not (re_mult_next (u8 "\\zs")))
                                ((ร RETURN) null)
                            )
                            (ร BREAK)
                        )
                        ((ร CASE) (byte \e))
                        (ยง
                            ((ร ret =) (ยง regnode(MCLOSE + 0)))
                            (if (not (re_mult_next (u8 "\\ze")))
                                ((ร RETURN) null)
                            )
                            (ร BREAK)
                        )
                        (ร DEFAULT)
                        (ยง
                            (emsg (u8 "E68: Invalid character after \\z"))
                            (reset! rc_did_emsg true)
                            ((ร RETURN) null)
                        )
                    )
                    (ร BREAK)
                )

                ((ร CASE) (Magic (byte \%)))
                (ยง
                    ((ร c =) (ยง no_Magic(getchr())))
                    ((ร SWITCH) c
                        ;; () without a back reference
                        ((ร CASE) (byte \())
                        (ยง
                            (when @one_exactly
                                (emsg2 (u8 "E369: invalid item in %s%%[]"), (if (== @reg_magic MAGIC_ALL) (u8 "") (u8 "\\")))
                                (reset! rc_did_emsg true)
                                ((ร RETURN) null)
                            )
                            ((ร int[] flags =) (ยง new int[1]))
                            ((ร ret =) (reg REG_NPAREN, flags))
                            (if (nil? ret)
                                ((ร RETURN) null)
                            )
                            ((ร flagp[0] |=) (ยง flags[0] & (HASWIDTH | SPSTART | HASNL | HASLOOKBH)))
                            (ร BREAK)
                        )
                        ;; Catch \%^ and \%$ regardless of where they appear in the
                        ;; pattern -- regardless of whether or not it makes sense.
                        ((ร CASE) (byte \^))
                        (ยง
                            ((ร ret =) (regnode RE_BOF))
                            (ร BREAK)
                        )

                        ((ร CASE) (byte \$))
                        (ยง
                            ((ร ret =) (regnode RE_EOF))
                            (ร BREAK)
                        )

                        ((ร CASE) (byte \#))
                        (ยง
                            ((ร ret =) (regnode CURSOR))
                            (ร BREAK)
                        )

                        ((ร CASE) (byte \V))
                        (ยง
                            ((ร ret =) (regnode RE_VISUAL))
                            (ร BREAK)
                        )

                        ((ร CASE) (byte \C))
                        (ยง
                            ((ร ret =) (regnode RE_COMPOSING))
                            (ร BREAK)
                        )

                        ;; \%[abc]: Emit as a list of branches,
                        ;; all ending at the last branch which matches nothing.
                        ((ร CASE) (byte \[))
                        (ยง
                            (when @one_exactly        ;; doesn't nest
                                (emsg2 (u8 "E369: invalid item in %s%%[]"), (if (== @reg_magic MAGIC_ALL) (u8 "") (u8 "\\")))
                                (reset! rc_did_emsg true)
                                ((ร RETURN) null)
                            )

                            (ร Bytes lastbranch)
                            ((ร Bytes lastnode =) null)
                            (ร Bytes br)

                            ((ร ret =) null)
                            (while (ยง (c = getchr()) != (byte \]))
                                (when (== c NUL)
                                    (emsg2 e_missing_sb, (if (== @reg_magic MAGIC_ALL) (u8 "") (u8 "\\")))
                                    (reset! rc_did_emsg true)
                                    ((ร RETURN) null)
                                )
                                ((ร br =) (regnode BRANCH))
                                (if (nil? ret)
                                    ((ร ret =) br)
                                    (regtail lastnode, br))

                                (ungetchr)
                                (reset! one_exactly true)
                                ((ร lastnode =) (regatom flagp))
                                (reset! one_exactly false)
                                (if (nil? lastnode)
                                    ((ร RETURN) null)
                                )
                            )
                            (when (nil? ret)
                                (emsg2 e_empty_sb, (if (== @reg_magic MAGIC_ALL) (u8 "") (u8 "\\")))
                                (reset! rc_did_emsg true)
                                ((ร RETURN) null)
                            )
                            ((ร lastbranch =) (regnode BRANCH))
                            ((ร br =) (regnode NOTHING))
                            (when (!= ret JUST_CALC_SIZE)
                                (regtail lastnode, br)
                                (regtail lastbranch, br)
                                ;; connect all branches to the NOTHING branch at the end
                                ((ร FOR) (ร (ยง br = ret) (BNE br, lastnode) nil)
                                    (cond (== (re_op br) BRANCH)
                                    (ยง
                                        (regtail br, lastbranch)
                                        ((ร br =) (operand br))
                                    )
                                    :else
                                    (ยง
                                        ((ร br =) (regnext br))
                                    ))
                                )
                            )
                            ((ร flagp[0] &=) (ยง ~(HASWIDTH | SIMPLE)))
                            (ร BREAK)
                        )
                        ((ร CASE) (byte \d))   ;; %d123 decimal
                        ((ร CASE) (byte \o))   ;; %o123 octal
                        ((ร CASE) (byte \x))   ;; %xab hex 2
                        ((ร CASE) (byte \u))   ;; %uabcd hex 4
                        ((ร CASE) (byte \U))   ;; %U1234abcd hex 8
                        (ยง
                            (ร int i)
                            ((ร SWITCH) c
                                ((ร CASE) (byte \d))
                                (ยง
                                    ((ร i =) (getdecchrs))
                                    (ร BREAK)
                                )
                                ((ร CASE) (byte \o))
                                (ยง
                                    ((ร i =) (getoctchrs))
                                    (ร BREAK)
                                )
                                ((ร CASE) (byte \x))
                                (ยง
                                    ((ร i =) (gethexchrs 2))
                                    (ร BREAK)
                                )
                                ((ร CASE) (byte \u))
                                (ยง
                                    ((ร i =) (gethexchrs 4))
                                    (ร BREAK)
                                )
                                ((ร CASE) (byte \U))
                                (ยง
                                    ((ร i =) (gethexchrs 8))
                                    (ร BREAK)
                                )
                                (ร DEFAULT)
                                (ยง
                                    ((ร i =) -1)
                                    (ร BREAK)
                                )
                            )

                            (when (< i 0)
                                (emsg2 (u8 "E678: Invalid character after %s%%[dxouU]"), (if (== @reg_magic MAGIC_ALL) (u8 "") (u8 "\\")))
                                (reset! rc_did_emsg true)
                                ((ร RETURN) null)
                            )
                            (if (use_multibytecode i)
                                ((ร ret =) (regnode MULTIBYTECODE))
                                ((ร ret =) (regnode EXACTLY))
                            )
                            (if (zero? i)
                                (regc 0x0a)
                                (regmbc i))
                            (regc NUL)
                            ((ร flagp[0] |=) HASWIDTH)
                            (ร BREAK)
                        )
                        (ร DEFAULT)
                        (ยง
                            (when (or (asc_isdigit c) (== c (byte \<)) (== c (byte \>)) (== c (byte \')))
                                ((ร int cmp =) c)
                                (if (or (== cmp (byte \<)) (== cmp (byte \>)))
                                    ((ร c =) (getchr))
                                )

                                ((ร long n =) 0)
                                (while (asc_isdigit c)
                                    ((ร n =) (ยง n * 10 + (c - (byte \0))))
                                    ((ร c =) (getchr))
                                )

                                (cond (and (== c (byte \')) (zero? n))
                                (ยง
                                    ;; "\%'m", "\%<'m" and "\%>'m": Mark
                                    ((ร c =) (getchr))
                                    ((ร ret =) (regnode RE_MARK))
                                    (cond (== ret JUST_CALC_SIZE)
                                    (ยง
                                        ((ร @regsize +=) 2)
                                    )
                                    :else
                                    (ยง
                                        (ยง (@regcode = @regcode.plus(1)).be(-1, c))
                                        (ยง (@regcode = @regcode.plus(1)).be(-1, cmp))
                                    ))
                                    (ร BREAK)
                                )
                                (or (== c (byte \l)) (== c (byte \c)) (== c (byte \v)))
                                (ยง
                                    (cond (== c (byte \l))
                                    (ยง
                                        ((ร ret =) (regnode RE_LNUM))
                                    )
                                    (== c (byte \c))
                                    (ยง
                                        ((ร ret =) (regnode RE_COL))
                                    )
                                    :else
                                    (ยง
                                        ((ร ret =) (regnode RE_VCOL))
                                    ))
                                    (cond (== ret JUST_CALC_SIZE)
                                    (ยง
                                        ((ร @regsize +=) 5)
                                    )
                                    :else
                                    (ยง
                                        ;; put the number and the optional
                                        ;; comparator after the opcode
                                        (reset! regcode (re_put_long @regcode, n))
                                        (ยง (@regcode = @regcode.plus(1)).be(-1, cmp))
                                    ))
                                    (ร BREAK)
                                ))
                            )

                            (emsg2 (u8 "E71: Invalid character after %s%%"), (if (== @reg_magic MAGIC_ALL) (u8 "") (u8 "\\")))
                            (reset! rc_did_emsg true)
                            ((ร RETURN) null)
                        )
                    )
                    (ร BREAK)
                )

                ((ร CASE) (Magic (byte \[)))
                (ยง
                    (ร BREAK collection)
                )

                (ร DEFAULT)
                (ยง
                    ((ร RETURN) (do_multibyte c, flagp))
                )
            )

            ((ร RETURN) ret)
;       }

        ;; If there is no matching ']', we assume the '[' is a normal character.
        ;; This makes 'incsearch' and ":help [" work.

        ((ร Bytes lp =) (skip_anyof @regparse))

        (when (== (.at lp 0) (byte \]))     ;; there is a matching ']'
            ((ร int startc =) -1)    ;; > 0 when next '-' is a range
            (ร int endc)

            ;; In a character class, different parsing rules apply.
            ;; Not even \ is special anymore, nothing is.

            (cond (== (.at @regparse 0) (byte \^))       ;; Complement of range.
            (ยง
                ((ร ret =) (ยง regnode(ANYBUT + extra)))
                (reset! regparse (.plus @regparse 1))
            )
            :else
            (ยง
                ((ร ret =) (ยง regnode(ANYOF + extra)))
            ))

            ;; At the start ']' and '-' mean the literal character.
            (when (or (== (.at @regparse 0) (byte \])) (== (.at @regparse 0) (byte \-)))
                ((ร startc =) (ยง @regparse.at(0)))
                (regc (ยง (@regparse = @regparse.plus(1)).at(-1)))
            )

            (while (ยง @regparse.at(0) != NUL && @regparse.at(0) != (byte \]))
                (cond (== (.at @regparse 0) (byte \-))
                (ยง
                    (reset! regparse (.plus @regparse 1))
                    ;; The '-' is not used for a range at the end and after or before a '\n'.
                    (cond (or (== (.at @regparse 0) (byte \])) (eos? @regparse) (== startc -1) (and (== (.at @regparse 0) (byte \\)) (== (.at @regparse 1) (byte \n))))
                    (ยง
                        (regc (byte \-))
                        ((ร startc =) (byte \-))       ;; [--x] is a range
                    )
                    :else
                    (ยง
                        ;; Also accept "a-[.z.]".
                        ((ร endc =) 0)
                        (when (== (.at @regparse 0) (byte \[))
; %%                        ((ร Bytes[] __ =) (ยง { @regparse }))
                            ((ร endc =) (get_coll_element __))
                            (reset! regparse (ยง __[0]))
                        )
                        (when (zero? endc)
; %%                        ((ร Bytes[] __ =) (ยง { @regparse }))
                            ((ร endc =) (us_ptr2char_adv __, true))
                            (reset! regparse (ยง __[0]))
                        )

                        ;; Handle \o40, \x20 and \u20AC style sequences.
                        (if (and (== endc (byte \\)) (not @reg_cpo_lit) (not @reg_cpo_bsl))
                            ((ร endc =) (coll_get_char))
                        )

                        (when (< endc startc)
                            (emsg e_invrange)
                            (reset! rc_did_emsg true)
                            ((ร RETURN) null)
                        )
                        (cond (or (< 1 (utf_char2len startc)) (< 1 (utf_char2len endc)))
                        (ยง
                            ;; Limit to a range of 256 chars.
                            (when (< (+ startc 256) endc)
                                (emsg e_invrange)
                                (reset! rc_did_emsg true)
                                ((ร RETURN) null)
                            )
                            (while (ยง ++startc <= endc)
                                (regmbc startc)
                            )
                        )
                        :else
                        (ยง
                            (while (ยง ++startc <= endc)
                                (regc startc)
                            )
                        ))
                        ((ร startc =) -1)
                    ))
                )

                ;; Only "\]", "\^", "\]" and "\\" are special in Vi.  Vim
                ;; accepts "\t", "\e", etc., but only when the 'l' flag in
                ;; 'cpoptions' is not included.
                ;; Posix doesn't recognize backslash at all.

                (and (== (.at @regparse 0) (byte \\)) (not @reg_cpo_bsl) (or (non-nil? (ยง vim_strchr(REGEXP_INRANGE, @regparse.at(1)))) (and (not @reg_cpo_lit) (non-nil? (ยง vim_strchr(REGEXP_ABBR, @regparse.at(1)))))))
                (ยง
                    (reset! regparse (.plus @regparse 1))
                    (cond (== (.at @regparse 0) (byte \n))
                    (ยง
                        ;; '\n' in range: also match NL
                        (when (!= ret JUST_CALC_SIZE)
                            ;; Using \n inside [^] does not change what
                            ;; matches.  "[^\n]" is the same as ".".
                            (when (== (.at ret 0) ANYOF)
                                (ยง ret.be(0, ANYOF + ADD_NL))
                                ((ร flagp[0] |=) HASNL)
                            )
                            ;; else: must have had a \n already
                        )
                        (reset! regparse (.plus @regparse 1))
                        ((ร startc =) -1)
                    )
                    (or (== (.at @regparse 0) (byte \d)) (== (.at @regparse 0) (byte \o)) (== (.at @regparse 0) (byte \x)) (== (.at @regparse 0) (byte \u)) (== (.at @regparse 0) (byte \U)))
                    (ยง
                        ((ร startc =) (coll_get_char))
                        (if (zero? startc)
                            (regc 0x0a)
                            (regmbc startc))
                    )
                    :else
                    (ยง
                        ((ร startc =) (ยง backslash_trans((@regparse = @regparse.plus(1)).at(-1))))
                        (regc startc)
                    ))
                )
                (== (.at @regparse 0) (byte \[))
                (ยง
                    (ร int cu)

                    (ร int c_class)
;                   { Bytes[] __ = { @regparse }; c_class = get_char_class(__); @regparse = __[0]; }
                    ((ร startc =) -1)
                    ;; Characters assumed to be 8 bits!
                    ((ร SWITCH) c_class
                        ((ร CASE) CLASS_NONE)
                        (ยง
;                           { Bytes[] __ = { @regparse }; c_class = get_equi_class(__); @regparse = __[0]; }
                            (cond (non-zero? c_class)
                            (ยง
                                ;; produce equivalence class
                                (reg_equi_class c_class)
                            )
                            :else
                            (ยง
;                               { Bytes[] __ = { @regparse }; c_class = get_coll_element(__); @regparse = __[0]; }
                                (cond (non-zero? c_class)
                                (ยง
                                    ;; produce a collating element
                                    (regmbc c_class)
                                )
                                :else
                                (ยง
                                    ;; literal '[', allow [[-x] as a range
                                    ((ร startc =) (ยง (@regparse = @regparse.plus(1)).at(-1)))
                                    (regc startc)
                                ))
                            ))
                            (ร BREAK)
                        )
                        ((ร CASE) CLASS_ALNUM)
                        (ยง
                            ((ร FOR) (ร (ยง cu = 1) (<= cu 255) (ยง cu++))
                                (if (asc_isalnum cu)
                                    (regc cu))
                            )
                            (ร BREAK)
                        )
                        ((ร CASE) CLASS_ALPHA)
                        (ยง
                            ((ร FOR) (ร (ยง cu = 1) (<= cu 255) (ยง cu++))
                                (if (asc_isalpha cu)
                                    (regc cu))
                            )
                            (ร BREAK)
                        )
                        ((ร CASE) CLASS_BLANK)
                        (ยง
                            (regc (byte \space))
                            (regc (byte \tab))
                            (ร BREAK)
                        )
                        ((ร CASE) CLASS_CNTRL)
                        (ยง
                            ((ร FOR) (ร (ยง cu = 1) (<= cu 255) (ยง cu++))
                                (if (asc_iscntrl cu)
                                    (regc cu))
                            )
                            (ร BREAK)
                        )
                        ((ร CASE) CLASS_DIGIT)
                        (ยง
                            ((ร FOR) (ร (ยง cu = 1) (<= cu 255) (ยง cu++))
                                (if (asc_isdigit cu)
                                    (regc cu))
                            )
                            (ร BREAK)
                        )
                        ((ร CASE) CLASS_GRAPH)
                        (ยง
                            ((ร FOR) (ร (ยง cu = 1) (<= cu 255) (ยง cu++))
                                (if (asc_isgraph cu)
                                    (regc cu))
                            )
                            (ร BREAK)
                        )
                        ((ร CASE) CLASS_LOWER)
                        (ยง
                            ((ร FOR) (ร (ยง cu = 1) (<= cu 255) (ยง cu++))
                                (if (utf_islower cu)
                                    (regc cu))
                            )
                            (ร BREAK)
                        )
                        ((ร CASE) CLASS_PRINT)
                        (ยง
                            ((ร FOR) (ร (ยง cu = 1) (<= cu 255) (ยง cu++))
                                (if (vim_isprintc cu)
                                    (regc cu))
                            )
                            (ร BREAK)
                        )
                        ((ร CASE) CLASS_PUNCT)
                        (ยง
                            ((ร FOR) (ร (ยง cu = 1) (<= cu 255) (ยง cu++))
                                (if (asc_ispunct cu)
                                    (regc cu))
                            )
                            (ร BREAK)
                        )
                        ((ร CASE) CLASS_SPACE)
                        (ยง
                            ((ร FOR) (ร (ยง cu = 9) (<= cu 13) (ยง cu++))
                                (regc cu)
                            )
                            (regc (byte \space))
                            (ร BREAK)
                        )
                        ((ร CASE) CLASS_UPPER)
                        (ยง
                            ((ร FOR) (ร (ยง cu = 1) (<= cu 255) (ยง cu++))
                                (if (utf_isupper cu)
                                    (regc cu))
                            )
                            (ร BREAK)
                        )
                        ((ร CASE) CLASS_XDIGIT)
                        (ยง
                            ((ร FOR) (ร (ยง cu = 1) (<= cu 255) (ยง cu++))
                                (if (asc_isxdigit cu)
                                    (regc cu))
                            )
                            (ร BREAK)
                        )
                        ((ร CASE) CLASS_TAB)
                        (ยง
                            (regc (byte \tab))
                            (ร BREAK)
                        )
                        ((ร CASE) CLASS_RETURN)
                        (ยง
                            (regc (byte \return))
                            (ร BREAK)
                        )
                        ((ร CASE) CLASS_BACKSPACE)
                        (ยง
                            (regc (byte \backspace))
                            (ร BREAK)
                        )
                        ((ร CASE) CLASS_ESCAPE)
                        (ยง
                            (regc ESC)
                            (ร BREAK)
                        )
                    )
                )
                :else
                (ยง
                    ;; produce a multibyte character,
                    ;; including any following composing characters
                    ((ร startc =) (us_ptr2char @regparse))
                    ((ร int len =) (us_ptr2len_cc @regparse))
                    (if (!= (utf_char2len startc) len)
                        ((ร startc =) -1)        ;; composing chars
                    )
                    (while (ยง 0 <= --len)
                        (regc (ยง (@regparse = @regparse.plus(1)).at(-1)))
                    )
                ))
            )
            (regc NUL)
            (reset! prevchr_len 1)                ;; last char was the ']'
            (when (!= (.at @regparse 0) (byte \]))
                (emsg e_toomsbra)
                (reset! rc_did_emsg true)
                ((ร RETURN) null)                ;; Cannot happen?
            )
            (skipchr)                      ;; let's be friends with the lexer again
            ((ร flagp[0] |=) (| HASWIDTH SIMPLE))
            ((ร RETURN) ret)
        )

        (when @reg_strict
            (emsg2 e_missingbracket, (if (< MAGIC_OFF @reg_magic) (u8 "") (u8 "\\")))
            (reset! rc_did_emsg true)
            ((ร RETURN) null)
        )

        (do_multibyte c, flagp)
    ))

(defn- #_final #_Bytes do_multibyte [#_int c, #_int* flagp]
    (ยง
        (ร Bytes ret)

        ;; A multi-byte character is handled as a separate atom
        ;; if it's before a multi and when it's a composing char.
        (when (use_multibytecode c)
            ((ร ret =) (regnode MULTIBYTECODE))
            (regmbc c)
            ((ร flagp[0] |=) (| HASWIDTH SIMPLE))
            ((ร RETURN) ret)
        )

        ((ร ret =) (regnode EXACTLY))

        ;; Append characters as long as:
        ;; - there is no following multi, we then need the character in
        ;;   front of it as a single character operand
        ;; - not running into a Magic character
        ;; - "one_exactly" is not set
        ;; But always emit at least one character.  Might be a Multi,
        ;; e.g., a "[" without matching "]".

        (ร int len)
        ((ร FOR) (ร (ยง len = 0) (ยง c != NUL && (len == 0 || (re_multi_type(peekchr()) == NOT_MULTI && !@one_exactly && !is_Magic(c)))) (ยง len++))
            ((ร c =) (no_Magic c))

            (regmbc c)

            ;; Need to get composing character too.
            (while true
                ((ร int l =) (us_ptr2len @regparse))
                (if (not (utf_iscomposing (us_ptr2char (ยง @regparse.plus(l)))))
                    (ร BREAK)
                )
                (regmbc (us_ptr2char @regparse))
                (skipchr)
            )

            ((ร c =) (getchr))
        )
        (ungetchr)

        (regc NUL)

        ((ร flagp[0] |=) HASWIDTH)
        (if (== len 1)
            ((ร flagp[0] |=) SIMPLE)
        )

        ret
    ))

;; Return true if MULTIBYTECODE should be used instead of EXACTLY for character "c".

(defn- #_boolean use_multibytecode [#_int c]
    (ยง
        (and (< 1 (utf_char2len c)) (or (!= (re_multi_type (peekchr)) NOT_MULTI) (utf_iscomposing c)))
    ))

;; Emit a node.
;; Return pointer to generated code.

(defn- #_Bytes regnode [#_int op]
    (ยง
        ((ร Bytes ret =) @regcode)

        (cond (== ret JUST_CALC_SIZE)
        (ยง
            ((ร @regsize +=) 3)
        )
        :else
        (ยง
            (ยง (@regcode = @regcode.plus(1)).be(-1, op))
            (ยง (@regcode = @regcode.plus(1)).be(-1, NUL))           ;; Null "next" pointer.
            (ยง (@regcode = @regcode.plus(1)).be(-1, NUL))
        ))

        ret
    ))

;; Emit (if appropriate) a byte of code.

(defn- #_void regc [#_int b]
    (ยง
        (if (== @regcode JUST_CALC_SIZE)
            (swap! regsize inc)
            (ยง (@regcode = @regcode.plus(1)).be(-1, b))
        )
    ))

;; Emit (if appropriate) a multi-byte character of code.

(defn- #_void regmbc [#_int c]
    (ยง
        (if (== @regcode JUST_CALC_SIZE)
            ((ร @regsize +=) (utf_char2len c))
            (reset! regcode (ยง @regcode.plus(utf_char2bytes(c, @regcode)))))
    ))

;; Insert an operator in front of already-emitted operand.
;;
;; Means relocating the operand.

(defn- #_void reginsert [#_int op, #_Bytes opnd]
    (ยง
        (when (== @regcode JUST_CALC_SIZE)
            ((ร @regsize +=) 3)
            (ร RETURN)
        )

        ((ร Bytes src =) @regcode)
        (reset! regcode (.plus @regcode 3))
        ((ร Bytes dst =) @regcode)
        (while (BLT opnd, src)
            (ยง (dst = dst.minus(1)).be(0, (src = src.minus(1)).at(0)))
        )

        ((ร Bytes place =) opnd) ;; Op node, where operand used to be.
        (ยง (place = place.plus(1)).be(-1, op))
        (ยง (place = place.plus(1)).be(-1, NUL))
        (.be place 0, NUL)
    ))

;; Insert an operator in front of already-emitted operand.
;; Add a number to the operator.

(defn- #_void reginsert_nr [#_int op, #_long val, #_Bytes opnd]
    (ยง
        (when (== @regcode JUST_CALC_SIZE)
            ((ร @regsize +=) 7)
            (ร RETURN)
        )

        ((ร Bytes src =) @regcode)
        (reset! regcode (.plus @regcode 7))
        ((ร Bytes dst =) @regcode)
        (while (BLT opnd, src)
            (ยง (dst = dst.minus(1)).be(0, (src = src.minus(1)).at(0)))
        )

        ((ร Bytes place =) opnd) ;; Op node, where operand used to be.
        (ยง (place = place.plus(1)).be(-1, op))
        (ยง (place = place.plus(1)).be(-1, NUL))
        (ยง (place = place.plus(1)).be(-1, NUL))
        ((ร place =) (re_put_long place, val))
    ))

;; Insert an operator in front of already-emitted operand.
;; The operator has the given limit values as operands.
;; Also set next pointer.
;;
;; Means relocating the operand.

(defn- #_void reginsert_limits [#_int op, #_long minval, #_long maxval, #_Bytes opnd]
    (ยง
        (when (== @regcode JUST_CALC_SIZE)
            ((ร @regsize +=) 11)
            (ร RETURN)
        )

        ((ร Bytes src =) @regcode)
        (reset! regcode (.plus @regcode 11))
        ((ร Bytes dst =) @regcode)
        (while (BLT opnd, src)
            (ยง (dst = dst.minus(1)).be(0, (src = src.minus(1)).at(0)))
        )

        ((ร Bytes place =) opnd) ;; Op node, where operand used to be.
        (ยง (place = place.plus(1)).be(-1, op))
        (ยง (place = place.plus(1)).be(-1, NUL))
        (ยง (place = place.plus(1)).be(-1, NUL))
        ((ร place =) (re_put_long place, minval))
        ((ร place =) (re_put_long place, maxval))
        (regtail opnd, place)
    ))

;; Write a long as four bytes at "p" and return pointer to the next char.

(defn- #_Bytes re_put_long [#_Bytes p, #_long val]
    (ยง
        (ยง (p = p.plus(1)).be(-1, (byte)((val >>> 24) & 0xff)))
        (ยง (p = p.plus(1)).be(-1, (byte)((val >>> 16) & 0xff)))
        (ยง (p = p.plus(1)).be(-1, (byte)((val >>>  8) & 0xff)))
        (ยง (p = p.plus(1)).be(-1, (byte)((val       ) & 0xff)))
        p
    ))

;; Set the next-pointer at the end of a node chain.

(defn- #_void regtail [#_Bytes p, #_Bytes val]
    (ยง
        (if (== p JUST_CALC_SIZE)
            (ร RETURN)
        )

        ;; Find last node.
        ((ร Bytes scan =) p)
        (while true
            ((ร Bytes temp =) (regnext scan))
            (if (nil? temp)
                (ร BREAK)
            )
            ((ร scan =) temp)
        )

        (ร int offset)
        (if (== (re_op scan) BACK)
            ((ร offset =) (BDIFF scan, val))
            ((ร offset =) (BDIFF val, scan))
        )
        ;; When the offset uses more than 16 bits it can no longer fit in the two bytes available.
        ;; Use a global flag to avoid having to check return values in too many places.
        (cond (< 0xffff offset)
        (ยง
            (reset! reg_toolong true)
        )
        :else
        (ยง
            (ยง scan.be(1, (byte)((offset >>> 8) & 0xff)))
            (ยง scan.be(2, (byte)((offset      ) & 0xff)))
        ))
    ))

;; Like regtail, on item after a BRANCH; nop if none.

(defn- #_void regoptail [#_Bytes p, #_Bytes val]
    (ยง
        ;; When op is neither BRANCH nor BRACE_COMPLEX0-9, it is "operandless".
        (when (or (nil? p) (== p JUST_CALC_SIZE) (and (!= (re_op p) BRANCH) (or (< (re_op p) BRACE_COMPLEX) (ยง BRACE_COMPLEX + 9 < re_op(p)))))
            (ร RETURN)
        )

        (regtail (operand p), val)
    ))

;; Functions for getting characters from the regexp input.

(atom! boolean at_start)        ;; true when on the first character
(atom! boolean prev_at_start)   ;; true when on the second character

;; Start parsing at "str".

(defn- #_void initchr [#_Bytes str]
    (ยง
        (reset! regparse str)
        (reset! prevchr_len 0)
        (reset! curchr (ยง @prevprevchr = @prevchr = @nextchr = -1))
        (reset! at_start true)
        (reset! prev_at_start false)
    ))

;; Save the current parse state, so that it can be restored and parsing
;; starts in the same state again.

(defn- #_void save_parse_state [#_parse_state_C ps]
    (ยง
        ((ร ps.regparse =) @regparse)
        ((ร ps.prevchr_len =) @prevchr_len)
        ((ร ps.curchr =) @curchr)
        ((ร ps.prevchr =) @prevchr)
        ((ร ps.prevprevchr =) @prevprevchr)
        ((ร ps.nextchr =) @nextchr)
        ((ร ps.at_start =) @at_start)
        ((ร ps.prev_at_start =) @prev_at_start)
        ((ร ps.regnpar =) @regnpar)
    ))

;; Restore a previously saved parse state.

(defn- #_void restore_parse_state [#_parse_state_C ps]
    (ยง
        (reset! regparse (. ps regparse))
        (reset! prevchr_len (. ps prevchr_len))
        (reset! curchr (. ps curchr))
        (reset! prevchr (. ps prevchr))
        (reset! prevprevchr (. ps prevprevchr))
        (reset! nextchr (. ps nextchr))
        (reset! at_start (. ps at_start))
        (reset! prev_at_start (. ps prev_at_start))
        (reset! regnpar (. ps regnpar))
    ))

(atom! int after_slash)

;; Get the next character without advancing.

(defn- #_int peekchr []
    (ยง
        (when (== @curchr -1)
            ((ร SWITCH) (ยง @curchr = @regparse.at(0))
                ((ร CASE) (byte \.))
                ((ร CASE) (byte \[))
                ((ร CASE) (byte \~))
                (ยง
                    ;; magic when 'magic' is on
                    (if (<= MAGIC_ON @reg_magic)
                        (reset! curchr (Magic @curchr)))
                    (ร BREAK)
                )

                ((ร CASE) (byte \())
                ((ร CASE) (byte \)))
                ((ร CASE) (byte \{))
                ((ร CASE) (byte \%))
                ((ร CASE) (byte \+))
                ((ร CASE) (byte \=))
                ((ร CASE) (byte \?))
                ((ร CASE) (byte \@))
                ((ร CASE) (byte \!))
                ((ร CASE) (byte \&))
                ((ร CASE) (byte \|))
                ((ร CASE) (byte \<))
                ((ร CASE) (byte \>))
                ((ร CASE) (byte \#))       ;; future ext.
                ((ร CASE) (byte \"))       ;; future ext. """
                ((ร CASE) (byte \'))      ;; future ext.
                ((ร CASE) (byte \,))       ;; future ext.
                ((ร CASE) (byte \-))       ;; future ext.
                ((ร CASE) (byte \:))       ;; future ext.
                ((ร CASE) (byte \;))       ;; future ext.
                ((ร CASE) (byte \`))       ;; future ext.
                ((ร CASE) (byte \/))       ;; can't be used in / command
                (ยง
                    ;; magic only after "\v"
                    (if (== @reg_magic MAGIC_ALL)
                        (reset! curchr (Magic @curchr)))
                    (ร BREAK)
                )

                ((ร CASE) (byte \*))
                (ยง
                    ;; * is not magic as the very first character, e.g. "?*ptr",
                    ;; when after '^', e.g. "/^*ptr" and when after "\(", "\|", "\&".
                    ;; But "\(\*" is not magic, thus must be magic if "after_slash"
                    (when (ยง MAGIC_ON <= @reg_magic && !@at_start && !(@prev_at_start && @prevchr == Magic((byte \^))) && (@after_slash != 0 || (@prevchr != Magic((byte \()) && @prevchr != Magic((byte \&)) && @prevchr != Magic((byte \|)))))
                        (reset! curchr (Magic (byte \*)))
                    )
                    (ร BREAK)
                )

                ((ร CASE) (byte \^))
                (ยง
                    ;; '^' is only magic as the very first character
                    ;; and if it's after "\(", "\|", "\&' or "\n"
                    (when (ยง MAGIC_OFF <= @reg_magic && (@at_start || @reg_magic == MAGIC_ALL || @prevchr == Magic((byte \()) || @prevchr == Magic((byte \|)) || @prevchr == Magic((byte \&)) || @prevchr == Magic((byte \n)) || (no_Magic(@prevchr) == (byte \() && @prevprevchr == Magic((byte \%)))))
                        (reset! curchr (Magic (byte \^)))
                        (reset! at_start true)
                        (reset! prev_at_start false)
                    )
                    (ร BREAK)
                )

                ((ร CASE) (byte \$))
                (ยง
                    ;; '$' is only magic as the very last char
                    ;; and if it's in front of either "\|", "\)", "\&", or "\n"
                    (when (<= MAGIC_OFF @reg_magic)
                        ((ร Bytes p =) (ยง @regparse.plus(1)))
                        ((ร boolean is_magic_all =) (ยง (@reg_magic == MAGIC_ALL)))

                        ;; ignore \c \C \m \M \v \V and \Z after '$'
                        (while (ยง p.at(0) == (byte \\) && (p.at(1) == (byte \c) || p.at(1) == (byte \C) || p.at(1) == (byte \m) || p.at(1) == (byte \M) || p.at(1) == (byte \v) || p.at(1) == (byte \V) || p.at(1) == (byte \Z)))
                            (cond (== (.at p 1) (byte \v))
                            (ยง
                                ((ร is_magic_all =) true)
                            )
                            (or (== (.at p 1) (byte \m)) (== (.at p 1) (byte \M)) (== (.at p 1) (byte \V)))
                            (ยง
                                ((ร is_magic_all =) false)
                            ))
                            ((ร p =) (ยง p.plus(2)))
                        )
                        (if (ยง p.at(0) == NUL || (p.at(0) == (byte \\) && (p.at(1) == (byte \|) || p.at(1) == (byte \&) || p.at(1) == (byte \)) || p.at(1) == (byte \n))) || (is_magic_all && (p.at(0) == (byte \|) || p.at(0) == (byte \&) || p.at(0) == (byte \)))) || @reg_magic == MAGIC_ALL)
                            (reset! curchr (Magic (byte \$)))
                        )
                    )
                    (ร BREAK)
                )

                ((ร CASE) (byte \\))
                (ยง
                    ((ร int c =) (ยง @regparse.at(1)))

                    (cond (== c NUL)
                    (ยง
                        (reset! curchr (byte \\))      ;; trailing '\'
                    )
                    (and (<= (char_u (byte c)) (byte \~)) (!= (ยง META_flags[c]) 0))
                    (ยง
                        ;; META contains everything that may be magic sometimes,
                        ;; except ^ and $ ("\^" and "\$" are only magic after "\v").
                        ;; We now fetch the next character and toggle its magicness.
                        ;; Therefore, \ is so meta-magic that it is not in META.

                        (reset! curchr -1)
                        (reset! prev_at_start @at_start)
                        (reset! at_start false)   ;; be able to say "/\*ptr"
                        (reset! regparse (.plus @regparse 1))
                        (swap! after_slash inc)
                        (peekchr)
                        (reset! regparse (.minus @regparse 1))
                        (swap! after_slash dec)
                        (reset! curchr (toggle_Magic @curchr))
                    )
                    (non-nil? (vim_strchr REGEXP_ABBR, c))
                    (ยง
                        ;; Handle abbreviations, like "\t" for TAB.

                        (reset! curchr (backslash_trans c))
                    )
                    (and (== @reg_magic MAGIC_NONE) (or (== c (byte \$)) (== c (byte \^))))
                    (ยง
                        (reset! curchr (toggle_Magic c))
                    )
                    :else
                    (ยง
                        ;; Next character can never be (made) magic?
                        ;; Then backslashing it won't do anything.

                        (reset! curchr (us_ptr2char (ยง @regparse.plus(1))))
                    ))
                    (ร BREAK)
                )

                (ร DEFAULT)
                (ยง
                    (reset! curchr (us_ptr2char @regparse))
                    (ร BREAK)
                )
            )
        )

        @curchr
    ))

;; Eat one lexed character.  Do this in a way that we can undo it.

(defn- #_void skipchr []
    (ยง
        ;; peekchr() eats a backslash, do the same here
        (if (== (.at @regparse 0) (byte \\))
            (reset! prevchr_len 1)
            (reset! prevchr_len 0))
        (when (non-eos? @regparse @prevchr_len)
            ;; exclude composing chars that us_ptr2len_cc does include
            ((ร @prevchr_len +=) (ยง us_ptr2len(@regparse.plus(@prevchr_len))))
        )
        (reset! regparse (.plus @regparse @prevchr_len))
        (reset! prev_at_start @at_start)
        (reset! at_start false)
        (reset! prevprevchr @prevchr)
        (reset! prevchr @curchr)
        (reset! curchr @nextchr)       ;; use previously unget char, or -1
        (reset! nextchr -1)
    ))

;; Skip a character while keeping the value of prev_at_start for at_start.
;; prevchr and prevprevchr are also kept.

(defn- #_void skipchr_keepstart []
    (ยง
        ((ร boolean as =) @prev_at_start)
        ((ร int pr =) @prevchr)
        ((ร int prpr =) @prevprevchr)

        (skipchr)

        (reset! at_start as)
        (reset! prevchr pr)
        (reset! prevprevchr prpr)
    ))

;; Get the next character from the pattern.  We know about magic and such, so
;; therefore we need a lexical analyzer.

(defn- #_int getchr []
    (ยง
        ((ร int chr =) (peekchr))

        (skipchr)

        chr
    ))

;; put character back.  Works only once!

(defn- #_void ungetchr []
    (ยง
        (reset! nextchr @curchr)
        (reset! curchr @prevchr)
        (reset! prevchr @prevprevchr)
        (reset! at_start @prev_at_start)
        (reset! prev_at_start false)

        ;; Backup "regparse", so that it's at the same position as before the getchr().
        (reset! regparse (.minus @regparse @prevchr_len))
    ))

;; Get and return the value of the hex string at the current position.
;; Return -1 if there is no valid hex number.
;; The position is updated:
;;     blahblah\%x20asdf
;;         before-^ ^-after
;; The parameter controls the maximum number of input characters.  This will be
;; 2 when reading a \%x20 sequence and 4 when reading a \%u20AC sequence.

(defn- #_int gethexchrs [#_int maxinputlen]
    (ยง
        ((ร int nr =) 0)
        (ร int i)

        ((ร FOR) (ร (ยง i = 0) (< i maxinputlen) (ยง i++))
            ((ร int c =) (ยง @regparse.at(0)))
            (if (not (asc_isxdigit c))
                (ร BREAK)
            )
;           nr <<= 4;
            ((ร nr |=) (hex2nr c))
            (reset! regparse (.plus @regparse 1))
        )

        (if (zero? i)
            ((ร RETURN) -1)
        )

        nr
    ))

;; Get and return the value of the decimal string immediately after the
;; current position.  Return -1 for invalid.  Consumes all digits.

(defn- #_int getdecchrs []
    (ยง
        ((ร int nr =) 0)
        (ร int i)

        ((ร FOR) (ร (ยง i = 0) true (ยง i++))
            ((ร int c =) (ยง @regparse.at(0)))
            (if (or (< c (byte \0)) (< (byte \9) c))
                (ร BREAK)
            )
            ((ร nr *=) 10)
            ((ร nr +=) (ยง c - (byte \0)))
            (reset! regparse (.plus @regparse 1))
            (reset! curchr -1)    ;; no longer valid
        )

        (if (zero? i)
            ((ร RETURN) -1)
        )

        nr
    ))

;; get and return the value of the octal string immediately after the current
;; position. Return -1 for invalid, or 0-255 for valid.  Smart enough to handle
;; numbers > 377 correctly (for example, 400 is treated as 40) and doesn't
;; treat 8 or 9 as recognised characters.  Position is updated:
;;     blahblah\%o210asdf
;;         before-^  ^-after

(defn- #_int getoctchrs []
    (ยง
        ((ร int nr =) 0)
        (ร int i)

        ((ร FOR) (ร (ยง i = 0) (ยง i < 3 && nr < 040) (ยง i++))
            ((ร int c =) (ยง @regparse.at(0)))
            (if (or (< c (byte \0)) (< (byte \7) c))
                (ร BREAK)
            )
;           nr <<= 3;
            ((ร nr |=) (hex2nr c))
            (reset! regparse (.plus @regparse 1))
        )

        (if (zero? i)
            ((ร RETURN) -1)
        )

        nr
    ))

;; Get a number after a backslash that is inside [].
;; When nothing is recognized return a backslash.

(defn- #_int coll_get_char []
    (ยง
        ((ร int nr =) -1)

        ((ร SWITCH) (ยง (@regparse = @regparse.plus(1)).at(-1))
            ((ร CASE) (byte \d))
            (ยง
                ((ร nr =) (getdecchrs))
                (ร BREAK)
            )
            ((ร CASE) (byte \o))
            (ยง
                ((ร nr =) (getoctchrs))
                (ร BREAK)
            )
            ((ร CASE) (byte \x))
            (ยง
                ((ร nr =) (gethexchrs 2))
                (ร BREAK)
            )
            ((ร CASE) (byte \u))
            (ยง
                ((ร nr =) (gethexchrs 4))
                (ร BREAK)
            )
            ((ร CASE) (byte \U))
            (ยง
                ((ร nr =) (gethexchrs 8))
                (ร BREAK)
            )
        )
        (when (< nr 0)
            ;; If getting the number fails be backwards compatible: the character is a backslash.
            (reset! regparse (.minus @regparse 1))
            ((ร nr =) (byte \\))
        )

        nr
    ))

;; read_limits - Read two integers to be taken as a minimum and maximum.
;; If the first character is '-', then the range is reversed.
;; Should end with 'end'.  If minval is missing, zero is default,
;; if maxval is missing, a very big number is the default.

(defn- #_boolean read_limits [#_long* minval, #_long* maxval]
    (ยง
        ((ร boolean reverse =) false)

        (when (== (.at @regparse 0) (byte \-))
            ;; starts with '-', so reverse the range later
            (reset! regparse (.plus @regparse 1))
            ((ร reverse =) true)
        )
        ((ร Bytes first_char =) @regparse)
;       { Bytes[] __ = { @regparse }; minval[0] = getdigits(__); @regparse = __[0]; }
        (cond (== (.at @regparse 0) (byte \,))                       ;; there is a comma
        (ยง
            (cond (asc_isdigit (.at (ยง @regparse = @regparse.plus(1)) 0))
            (ยง
;               Bytes[] __ = { @regparse }; maxval[0] = getdigits(__); @regparse = __[0];
            )
            :else
            (ยง
                ((ร maxval[0] =) MAX_LIMIT)
            ))
        )
        (asc_isdigit (ยง first_char.at(0)))
        (ยง
            ((ร maxval[0] =) (ยง minval[0]))                      ;; it was \{n} or \{-n}
        )
        :else
        (ยง
            ((ร maxval[0] =) MAX_LIMIT)                      ;; it was \{} or \{-}
        ))
        (if (== (.at @regparse 0) (byte \\))
            (reset! regparse (.plus @regparse 1)))                ;; allow either \{...} or \{...\}
        (when (!= (.at @regparse 0) (byte \}))
            (.sprintf libC @ioBuff, (u8 "E554: Syntax error in %s{...}"), (if (== @reg_magic MAGIC_ALL) (u8 "") (u8 "\\")))

            (emsg @ioBuff)
            (reset! rc_did_emsg true)
            ((ร RETURN) false)
        )

        ;; Reverse the range if there was a '-', or make sure it is in the right order otherwise.

        (when (or (and (not reverse) (< (ยง maxval[0]) (ยง minval[0]))) (and reverse (< (ยง minval[0]) (ยง maxval[0]))))
            ((ร long tmp =) (ยง minval[0]))
            ((ร minval[0] =) (ยง maxval[0]))
            ((ร maxval[0] =) tmp)
        )
        (skipchr)          ;; let's be friends with the lexer again
        true
    ))

;; Global work variables for vim_regexec().

;; The current match-position is remembered with these variables:
(atom! long     reglnum)                ;; line number, relative to first line
(atom! Bytes    regline)                ;; start of current line
(atom! Bytes    reginput)               ;; current input, points into "regline"

(atom! boolean  need_clear_subexpr)     ;; subexpressions still need to be cleared
(atom! boolean  need_clear_zsubexpr)    ;; extmatch subexpressions still need to be cleared

;; Structure used to save the current input state, when it needs to be
;; restored after trying a match.  Used by reg_save() and reg_restore().
;; Also stores the length of "backpos".

(class! #_final regsave_C
    [
        (field Bytes        rs_ptr)     ;; reginput pointer, for single-line regexp
        (field lpos_C       rs_pos      (ยง_lpos_C)) ;; reginput pos, for multi-line regexp
        (field int          rs_len)
    ])

(defn- #_void COPY_regsave [#_regsave_C rs1, #_regsave_C rs0]
    (ยง
        ((ร rs1.rs_ptr =) (. rs0 rs_ptr))
        (COPY_lpos (. rs1 rs_pos), (. rs0 rs_pos))
        ((ร rs1.rs_len =) (. rs0 rs_len))
    ))

;; struct to save start/end pointer/position in for \(\)
(class! #_final save_se_C
    [
        (field Bytes        se_ptr)
        (field lpos_C       se_pos      (ยง_lpos_C))
    ])

(defn- #_save_se_C* ARRAY_save_se [#_int n]
    (vec (repeatedly n ยง_save_se_C)))

;; used for BEHIND and NOBEHIND matching
(class! #_final regbehind_C
    [
        (field regsave_C    save_after      (ยง_regsave_C))
        (field regsave_C    save_behind     (ยง_regsave_C))
        (field boolean      save_need_clear_subexpr)
        (field save_se_C*   save_start  (ARRAY_save_se NSUBEXP))
        (field save_se_C*   save_end    (ARRAY_save_se NSUBEXP))
    ])

;; Internal copy of 'ignorecase'.  It is set at each call to vim_regexec().
;; Normally it gets the value of "rm_ic" or "rmm_ic", but when the pattern
;; contains '\c' or '\C' the value is overruled.

(atom! boolean ireg_ic)

;; Similar to ireg_ic, but only for 'combining' characters.  Set with \Z flag
;; in the regexp.  Defaults to false, always.

(atom! boolean ireg_icombine)

;; Copy of "rmm_maxcol": maximum column to search for a match.  Zero when
;; there is no maximum.

(atom! int     ireg_maxcol)

;; Sometimes need to save a copy of a line.  Since calloc()/free() is very
;; slow, we keep one allocated piece of memory and only re-allocate it when
;; it's too small.  It's freed in bt_regexec_both() when finished.

(atom! Bytes reg_tofree)
(atom! int reg_tofree_len)

;; These variables are set when executing a regexp to speed up the execution.
;; Which ones are set depends on whether a single-line or multi-line match is
;; done:
;;                      single-line             multi-line
;; reg_match            regmatch_C              null
;; reg_mmatch           null                    regmmatch_C
;; reg_startp           reg_match.startp        <invalid>
;; reg_endp             reg_match.endp          <invalid>
;; reg_startpos         <invalid>               reg_mmatch.startpos
;; reg_endpos           <invalid>               reg_mmatch.endpos
;; reg_win              null                    window in which to search
;; reg_buf              curbuf                  buffer in which to search
;; reg_firstlnum        <invalid>               first line in which to search
;; reg_maxline          0                       last line nr
;; reg_line_lbr         false or true           false

(atom! regmatch_C   reg_match)
(atom! regmmatch_C  reg_mmatch)
(atom! Bytes*       reg_startp)
(atom! Bytes*       reg_endp)
(atom! lpos_C*      reg_startpos)
(atom! lpos_C*      reg_endpos)
(atom! window_C     reg_win)
(atom! buffer_C     reg_buf)
(atom! long         reg_firstlnum)
(atom! long         reg_maxline)
(atom! boolean      reg_line_lbr)       ;; "\n" in string is line break

;; Values for rs_state in regitem_C.
(final int
    RS_NOPEN 0,           ;; NOPEN and NCLOSE
    RS_MOPEN 1,           ;; MOPEN + [0-9]
    RS_MCLOSE 2,          ;; MCLOSE + [0-9]
    RS_ZOPEN 3,           ;; ZOPEN + [0-9]
    RS_ZCLOSE 4,          ;; ZCLOSE + [0-9]
    RS_BRANCH 5,          ;; BRANCH
    RS_BRCPLX_MORE 6,     ;; BRACE_COMPLEX and trying one more match
    RS_BRCPLX_LONG 7,     ;; BRACE_COMPLEX and trying longest match
    RS_BRCPLX_SHORT 8,    ;; BRACE_COMPLEX and trying shortest match
    RS_NOMATCH 9,         ;; NOMATCH
    RS_BEHIND1 10,        ;; BEHIND / NOBEHIND matching rest
    RS_BEHIND2 11,        ;; BEHIND / NOBEHIND matching behind part
    RS_STAR_LONG 12,      ;; STAR/PLUS/BRACE_SIMPLE longest match
    RS_STAR_SHORT 13)     ;; STAR/PLUS/BRACE_SIMPLE shortest match

;; When there are alternatives, a RS_ is put on the regstack to remember what we are doing.
;; Before it may be another type of item, depending on "rs_state", to remember more things.

(class! #_final regitem_C
    [
        (field int          rs_state)       ;; what we are doing, one of RS_ above
        (field Bytes        rs_scan)        ;; current node in program
        (field save_se_C    rs_sesave       (ยง_save_se_C))  ;; union room for saving reginput
        (field regsave_C    rs_regsave      (ยง_regsave_C))  ;; union room for saving reginput
        (field int          rs_no)          ;; submatch nr or BEHIND/NOBEHIND
    ])

;; Used for STAR, PLUS and BRACE_SIMPLE matching.
(class! #_final regstar_C
    [
        (field int          nextb)          ;; next byte
        (field int          nextb_ic)       ;; next byte reverse case
        (field long         count)
        (field long         minval)
        (field long         maxval)
    ])

;; Used to store input position when a BACK was encountered,
;; so that we now if we made any progress since the last time.

(class! #_final backpos_C
    [
        (field Bytes        bp_scan)        ;; "scan" where BACK was encountered
        (field regsave_C    bp_pos      (ยง_regsave_C))  ;; last input position
    ])

;; "regstack" and "backpos" are used by regmatch().
;; They are kept over calls to avoid invoking calloc() and free() often.
;; "regstack" is a stack with regitem_C items, sometimes preceded by regstar_C or regbehind_C.
;; "backpos" is a table with backpos_C items for BACK.

(atom! Object*      regstack)
(atom! backpos_C*   backpos)

;; Both for regstack and backpos tables we use the following strategy of allocation
;; (to reduce calloc/free calls):
;; - Initial size is fairly small.
;; - When needed, the tables are grown bigger (8 times at first, double after that).
;; - After executing the match we free the memory only if the array has grown.
;;   Thus the memory is kept allocated when it's at the initial size.
;; This makes it fast while not keeping a lot of memory allocated.
;; A three times speed increase was observed when using many simple patterns.

(final int REGSTACK_INITIAL 2048)
(final int BACKPOS_INITIAL    64)

;; Create "regstack" and "backpos".
;; We allocate *_INITIAL amount of bytes first and then set the grow size to much bigger value
;; to avoid many calloc calls in case of deep regular expressions.

(defn- #_void create_regstack []
    (ยง
        ;; Use Object item, since we push different things onto the regstack.
        (reset! regstack (ยง new Growing<Object>(Object.class, REGSTACK_INITIAL)))
        (ยง @regstack.ga_grow(REGSTACK_INITIAL))
        ((ร @regstack.ga_growsize =) (* REGSTACK_INITIAL 8))
    ))

(defn- #_void create_backpos []
    (ยง
        (reset! backpos (ยง new Growing<backpos_C>(backpos_C.class, BACKPOS_INITIAL)))
        (ยง @backpos.ga_grow(BACKPOS_INITIAL))
        ((ร @backpos.ga_growsize =) (* BACKPOS_INITIAL 8))
    ))

;; Get pointer to the line "lnum", which is relative to "reg_firstlnum".

(defn- #_Bytes reg_getline [#_long lnum]
    (ยง
        ;; When looking behind for a match/no-match, lnum is negative, but we can't go before line 1.
        (if (< (+ @reg_firstlnum lnum) 1)
            ((ร RETURN) null)
        )
        (when (< @reg_maxline lnum)
            ;; Must have matched the "\n" in the last line.
            ((ร RETURN) (u8 ""))
        )

        (ml_get_buf @reg_buf, (+ @reg_firstlnum lnum))
    ))

(atom! regsave_C    behind_pos      (ยง_regsave_C))

(final Bytes*       reg_startzp     NSUBEXP)                ;; Workspace to mark beginning
(final Bytes*       reg_endzp       NSUBEXP)                ;;   and end of \z(...\) matches
(final lpos_C*      reg_startzpos   (ARRAY_lpos NSUBEXP))   ;; idem, beginning pos
(final lpos_C*      reg_endzpos     (ARRAY_lpos NSUBEXP))   ;; idem, end pos

;; Match a regexp against a string.
;; "rmp.regprog" is a compiled regexp as returned by vim_regcomp().
;; Uses curbuf for line count and 'iskeyword'.
;; If "line_lbr" is true, consider a "\n" in "line" to be a line break.
;;
;; Returns 0 for failure, number of lines contained in the match otherwise.

(defn- #_long bt_regexec_nl [#_regmatch_C rmp, #_Bytes line, #_int col, #_boolean line_lbr]
    ;; line: string to match against
    ;; col: column to start looking for match
    (ยง
        (reset! reg_match rmp)
        (reset! reg_mmatch null)
        (reset! reg_maxline 0)
        (reset! reg_line_lbr line_lbr)
        (reset! reg_buf @curbuf)
        (reset! reg_win null)
        (reset! ireg_ic (. rmp rm_ic))
        (reset! ireg_icombine false)
        (reset! ireg_maxcol 0)

        (bt_regexec_both line, col, null)
    ))

;; Match a regexp against multiple lines.
;; "rmp.regprog" is a compiled regexp as returned by vim_regcomp().
;; Uses curbuf for line count and 'iskeyword'.
;;
;; Return zero if there is no match.  Return number of lines contained in the match otherwise.

(defn- #_long bt_regexec_multi [#_regmmatch_C rmp, #_window_C win, #_buffer_C buf, #_long lnum, #_int col, #_long nsec]
    ;; win: window in which to search or null
    ;; buf: buffer in which to search
    ;; lnum: nr of line to start looking for match
    ;; col: column to start looking for match
    ;; nsec: timeout limit or 0
    (ยง
        (reset! reg_match null)
        (reset! reg_mmatch rmp)
        (reset! reg_buf buf)
        (reset! reg_win win)
        (reset! reg_firstlnum lnum)
        (reset! reg_maxline (- (.. @reg_buf b_ml ml_line_count) lnum))
        (reset! reg_line_lbr false)
        (reset! ireg_ic (. rmp rmm_ic))
        (reset! ireg_icombine false)
        (reset! ireg_maxcol (. rmp rmm_maxcol))

        (bt_regexec_both null, col, nsec)
    ))

;; Match a regexp against a string ("line" points to the string)
;; or multiple lines ("line" is null, use reg_getline()).
;; Returns 0 for failure, number of lines contained in the match otherwise.

(defn- #_long bt_regexec_both [#_Bytes line, #_int col, #_long nsec]
    ;; col: column to start looking for match
    ;; nsec: timeout limit or 0
    (ยง
        ((ร long retval =) 0)

        (if (nil? @regstack)
            (create_regstack))
        (if (nil? @backpos)
            (create_backpos))

        (ร bt_regprog_C prog)
        (cond (nil? @reg_match)
        (ยง
            ((ร prog =) (ยง (bt_regprog_C)@reg_mmatch.regprog))
            ((ร line =) (reg_getline 0))
            (reset! reg_startpos (. @reg_mmatch startpos))
            (reset! reg_endpos (. @reg_mmatch endpos))
        )
        :else
        (ยง
            ((ร prog =) (ยง (bt_regprog_C)@reg_match.regprog))
            (reset! reg_startp (. @reg_match startp))
            (reset! reg_endp (. @reg_match endp))
        ))

;       theend:
;       {
            ;; Be paranoid...
            (when (or (nil? prog) (nil? line))
                (emsg e_null)
                (ร BREAK theend)
            )

            ;; Check validity of program.
            (if (prog_magic_wrong)
                (ร BREAK theend)
            )

            ;; If the start column is past the maximum column: no need to try.
            (if (and (< 0 @ireg_maxcol) (<= @ireg_maxcol col))
                (ร BREAK theend)
            )

            ;; If pattern contains "\c" or "\C": overrule value of ireg_ic.
            (cond (non-zero? (& (. prog regflags) RF_ICASE))
            (ยง
                (reset! ireg_ic true)
            )
            (non-zero? (& (. prog regflags) RF_NOICASE))
            (ยง
                (reset! ireg_ic false)
            ))

            ;; If pattern contains "\Z" overrule value of ireg_icombine.
            (if (non-zero? (& (. prog regflags) RF_ICOMBINE))
                (reset! ireg_icombine true))

            ;; If there is a "must appear" string, look for it.
            (when (!= (. prog regmust) null)
                ((ร int c =) (ยง us_ptr2char(prog.regmust)))
                ((ร Bytes s =) (ยง line.plus(col)))

                ;; This is used very often, esp. for ":global".
                ;; Use three versions of the loop to avoid overhead of conditions.

                (cond (not @ireg_ic)
                (ยง
                    (while (ยง (s = vim_strchr(s, c)) != null)
                        (ร int cmp)
;                       { int[] __ = { prog.regmlen }; cmp = cstrncmp(s, prog.regmust, __); prog.regmlen = __[0]; }
                        (if (zero? cmp)
                            (ร BREAK)              ;; Found it.
                        )
                        ((ร s =) (ยง s.plus(us_ptr2len_cc(s))))
                    )
                )
                :else
                (ยง
                    (while (ยง (s = cstrchr(s, c)) != null)
                        (ร int cmp)
;                       { int[] __ = { prog.regmlen }; cmp = cstrncmp(s, prog.regmust, __); prog.regmlen = __[0]; }
                        (if (zero? cmp)
                            (ร BREAK)              ;; Found it.
                        )
                        ((ร s =) (ยง s.plus(us_ptr2len_cc(s))))
                    )
                ))
                (if (nil? s)          ;; Not present.
                    (ร BREAK theend)
                )
            )

            (reset! regline line)
            (reset! reglnum 0)
            (reset! reg_toolong false)

            ;; Simplest case: Anchored match need be tried only once.
            (cond (!= (. prog reganch) 0)
            (ยง
                ((ร int c =) (ยง us_ptr2char(@regline.plus(col))))
                (cond (or (== (. prog regstart) NUL) (== (. prog regstart) c) (and @ireg_ic (or (== (utf_fold (. prog regstart)) (utf_fold c)) (and (< c 255) (< (. prog regstart) 255) (== (utf_tolower (. prog regstart)) (utf_tolower c))))))
                (ยง
                    ((ร retval =) (regtry prog, col))
                )
                :else
                (ยง
                    ((ร retval =) 0)
                ))
            )
            :else
            (ยง
                ((ร int tm_count =) 0)
                ;; Messy cases: Unanchored match.
                (while (ยง !@got_int)
                    (when (!= (. prog regstart) NUL)
                        ;; Skip until the char we know it must start with.
                        ;; Used often, do some work to avoid call overhead.
                        ((ร Bytes s =) (ยง cstrchr(@regline.plus(col), prog.regstart)))
                        (when (nil? s)
                            ((ร retval =) 0)
                            (ร BREAK)
                        )
                        ((ร col =) (BDIFF s, @regline))
                    )

                    ;; Check for maximum column to try.
                    (when (and (< 0 @ireg_maxcol) (<= @ireg_maxcol col))
                        ((ร retval =) 0)
                        (ร BREAK)
                    )

                    ((ร retval =) (regtry prog, col))
                    (if (< 0 retval)
                        (ร BREAK)
                    )

                    ;; if not currently on the first line, get it again
                    (when (non-zero? @reglnum)
                        (reset! reglnum 0)
                        (reset! regline (reg_getline 0))
                    )
                    (if (eos? @regline col)
                        (ร BREAK)
                    )
                    ((ร col +=) (ยง us_ptr2len_cc(@regline.plus(col))))
                    ;; Check for timeout once in a twenty times to avoid overhead.
                    (when (and (non-zero? nsec) (== (ยง ++tm_count) 20))
                        ((ร tm_count =) 0)
                        (if (profile_passed_limit nsec)
                            (ร BREAK)
                        )
                    )
                )
            ))
;       }

        ;; Free "reg_tofree" when it's a bit big.
        (if (< 400 @reg_tofree_len)
            (reset! reg_tofree null))

        ;; Free backpos and regstack if they are bigger than their initial size.
        (when (< BACKPOS_INITIAL (. @backpos ga_maxlen))
            ((ร backpos_C[] bpp =) (. @backpos ga_data))
            (while (ยง 0 < @backpos.ga_len--)
                ((ร bpp[@backpos.ga_len] =) null)
            )
            (ยง @backpos.ga_clear())
            (reset! backpos null)
        )
        (when (< REGSTACK_INITIAL (. @regstack ga_maxlen))
            ((ร Object[] rpp =) (. @regstack ga_data))
            (while (ยง 0 < @regstack.ga_len--)
                ((ร rpp[@regstack.ga_len] =) null)
            )
            (ยง @regstack.ga_clear())
            (reset! regstack null)
        )

        retval
    ))

;; Create a new extmatch and mark it as referenced once.

(defn- #_reg_extmatch_C make_extmatch []
    (ยง
        (ยง ยง_reg_extmatch_C())
    ))

;; Try match of "prog" with at regline[col].
;; Returns 0 for failure, number of lines contained in the match otherwise.

(defn- #_long regtry [#_bt_regprog_C prog, #_int col]
    (ยง
        (reset! reginput (.plus @regline col))
        (reset! need_clear_subexpr true)
        ;; Clear the external match subpointers if necessary.
        (if (== (. prog reghasz) REX_SET)
            (reset! need_clear_zsubexpr true))

        (if (not (regmatch (ยง prog.program.plus(1))))
            ((ร RETURN) 0)
        )

        (cleanup_subexpr)
        (cond (nil? @reg_match)
        (ยง
            (when (< (ยง @reg_startpos[0].lnum) 0)
                ((ร @reg_startpos[0].lnum =) 0)
                ((ร @reg_startpos[0].col =) col)
            )
            (cond (< (ยง @reg_endpos[0].lnum) 0)
            (ยง
                ((ร @reg_endpos[0].lnum =) @reglnum)
                ((ร @reg_endpos[0].col =) (BDIFF @reginput, @regline))
            )
            :else
            (ยง
                ;; Use line number of "\ze".
                (reset! reglnum (ยง @reg_endpos[0].lnum))
            ))
        )
        :else
        (ยง
            (if (nil? (ยง @reg_startp[0]))
                ((ร @reg_startp[0] =) (ยง @regline.plus(col)))
            )
            (if (nil? (ยง @reg_endp[0]))
                ((ร @reg_endp[0] =) @reginput)
            )
        ))
        ;; Package any found \z(...\) matches for export.  Default is none.
        (reset! re_extmatch_out null)

        (when (== (. prog reghasz) REX_SET)
            (cleanup_zsubexpr)
            (reset! re_extmatch_out (make_extmatch))
            ((ร FOR) (ร (ยง int i = 0) (< i NSUBEXP) (ยง i++))
                (cond (nil? @reg_match)
                (ยง
                    ;; Only accept single line matches.
                    (when (and (<= 0 (ยง reg_startzpos[i].lnum)) (== (ยง reg_endzpos[i].lnum) (ยง reg_startzpos[i].lnum)) (>= (ยง reg_endzpos[i].col) (ยง reg_startzpos[i].col)))
                        ((ร @re_extmatch_out.matches[i] =) (STRNDUP (.plus (reg_getline (ยง reg_startzpos[i].lnum)) (ยง reg_startzpos[i].col)), (- (ยง reg_endzpos[i].col) (ยง reg_startzpos[i].col))))
                    )
                )
                :else
                (ยง
                    (when (and (!= (ยง reg_startzp[i]) null) (!= (ยง reg_endzp[i]) null))
                        ((ร @re_extmatch_out.matches[i] =) (STRNDUP (ยง reg_startzp[i]), (BDIFF (ยง reg_endzp[i]), (ยง reg_startzp[i]))))
                    )
                ))
            )
        )
        (+ 1 @reglnum)
    ))

;; Get class of previous character.

(defn- #_int reg_prev_class []
    (ยง
        (if (BLT @regline, @reginput)
            ((ร RETURN) (ยง us_get_class(@reginput.minus(1 + us_head_off(@regline, @reginput.minus(1))), @reg_buf)))
        )

        -1
    ))

;; Return true if the current reginput position matches the Visual area.

(defn- #_boolean reg_match_visual []
    (ยง
        ((ร window_C wp =) (if (nil? @reg_win) @curwin @reg_win))

        ;; Check if the buffer is the current buffer.
        (if (or (!= @reg_buf @curbuf) (zero? (. @VIsual lnum)))
            ((ร RETURN) false)
        )

        ((ร pos_C top =) (ยง ยง_pos_C()))
        ((ร pos_C bot =) (ยง ยง_pos_C()))
        (ร int mode)
        (cond @VIsual_active
        (ยง
            (cond (ltpos @VIsual, (. wp w_cursor))
            (ยง
                (COPY_pos top, @VIsual)
                (COPY_pos bot, (. wp w_cursor))
            )
            :else
            (ยง
                (COPY_pos top, (. wp w_cursor))
                (COPY_pos bot, @VIsual)
            ))
            ((ร mode =) @VIsual_mode)
        )
        :else
        (ยง
            (cond (ltpos (.. @curbuf b_visual vi_start), (.. @curbuf b_visual vi_end))
            (ยง
                (COPY_pos top, (.. @curbuf b_visual vi_start))
                (COPY_pos bot, (.. @curbuf b_visual vi_end))
            )
            :else
            (ยง
                (COPY_pos top, (.. @curbuf b_visual vi_end))
                (COPY_pos bot, (.. @curbuf b_visual vi_start))
            ))
            ((ร mode =) (.. @curbuf b_visual vi_mode))
        ))
        ((ร long lnum =) (+ @reglnum @reg_firstlnum))
        (if (or (< lnum (. top lnum)) (< (. bot lnum) lnum))
            ((ร RETURN) false)
        )

        (cond (== mode (byte \v))
        (ยง
            ((ร int col =) (BDIFF @reginput, @regline))
            (if (or (and (== lnum (. top lnum)) (< col (. top col))) (and (== lnum (. bot lnum)) (>= col (+ (. bot col) (if (!= (.at @p_sel 0) (byte \e)) 1 0)))))
                ((ร RETURN) false)
            )
        )
        (== mode Ctrl_V)
        (ยง
            ((ร int[] start1 =) (ยง new int[1]))
            ((ร int[] end1 =) (ยง new int[1]))
            (getvvcol wp, top, start1, null, end1)
            ((ร int[] start2 =) (ยง new int[1]))
            ((ร int[] end2 =) (ยง new int[1]))
            (getvvcol wp, bot, start2, null, end2)
            (if (< (ยง start2[0]) (ยง start1[0]))
                ((ร start1[0] =) (ยง start2[0]))
            )
            (if (< (ยง end1[0]) (ยง end2[0]))
                ((ร end1[0] =) (ยง end2[0]))
            )
            (if (or (== (. top col) MAXCOL) (== (. bot col) MAXCOL))
                ((ร end1[0] =) MAXCOL)
            )
            ((ร int cols =) (ยง win_linetabsize(wp, @regline, BDIFF(@reginput, @regline))))
            (if (or (< cols (ยง start1[0])) (< (- (ยง end1[0]) (if (== (.at @p_sel 0) (byte \e)) 1 0)) cols))
                ((ร RETURN) false)
            )
        ))

        true
    ))

;; The arguments from BRACE_LIMITS are stored here.  They are actually local
;; to regmatch(), but they are here to reduce the amount of stack space used
;; (it can be called recursively many times).

(atom! long     bl_minval)
(atom! long     bl_maxval)

(final int
    RA_FAIL 1,            ;; something failed, abort
    RA_CONT 2,            ;; continue in inner loop
    RA_BREAK 3,           ;; break inner loop
    RA_MATCH 4,           ;; successful match
    RA_NOMATCH 5)         ;; didn't match

;; regmatch - main matching routine
;;
;; Conceptually the strategy is simple:
;; check to see whether the current node matches, push an item onto the regstack
;; and loop to see whether the rest matches, and then act accordingly.
;;
;; In practice we make some effort to avoid using the regstack,
;; in particular by going through "ordinary" nodes (that don't need to know
;; whether the rest of the match failed) by a nested loop.
;;
;; Returns true when there is a match.
;; Leaves reginput and reglnum just after the last matched character.
;;
;; Returns false when there is no match.
;; Leaves reginput and reglnum in an undefined state!

(defn- #_boolean regmatch [#_Bytes scan]
    ;; scan: Current node.
    (ยง
        (ร int status)                 ;; one of the RA_ values:

        ;; Make "regstack" and "backpos" empty.
        ;; They are allocated and freed in bt_regexec_both() to reduce calloc()/free() calls.
        ((ร @regstack.ga_len =) 0)
        ((ร @backpos.ga_len =) 0)

        ;; Repeat until "regstack" is empty.

        (while true
            ;; Some patterns may take a long time to match, e.g., "\([a-z]\+\)\+Q".
            ;; Allow interrupting them with CTRL-C.
            (fast_breakcheck)

            ;; Repeat for items that can be matched sequentially, without using the regstack.

            (while true
                (when (or @got_int (nil? scan))
                    ((ร status =) RA_FAIL)
                    (ร BREAK)
                )
                ((ร status =) RA_CONT)

                ((ร Bytes next =) (regnext scan))        ;; Next node.

                ((ร int op =) (re_op scan))
                ;; Check for character class with NL added.
                (cond (and (not @reg_line_lbr) (with_nl op) (nil? @reg_match) (eos? @reginput) (<= @reglnum @reg_maxline))
                (ยง
                    (reg_nextline)
                )
                (and @reg_line_lbr (with_nl op) (== (.at @reginput 0) (byte \newline)))
                (ยง
                    (reset! reginput (ยง @reginput.plus(us_ptr2len_cc(@reginput))))
                )
                :else
                (ยง
                    (if (with_nl op)
                        ((ร op -=) ADD_NL)
                    )
                    ((ร int c =) (us_ptr2char @reginput))
                    ((ร SWITCH) op
                        ((ร CASE) BOL)
                        (ยง
                            (if (BNE @reginput, @regline)
                                ((ร status =) RA_NOMATCH)
                            )
                            (ร BREAK)
                        )

                        ((ร CASE) EOL)
                        (ยง
                            (if (!= c NUL)
                                ((ร status =) RA_NOMATCH)
                            )
                            (ร BREAK)
                        )

                        ((ร CASE) RE_BOF)
                        (ยง
                            ;; We're not at the beginning of the file when below the first
                            ;; line where we started, not at the start of the line or we
                            ;; didn't start at the first line of the buffer.
                            (if (or (non-zero? @reglnum) (BNE @reginput, @regline) (and (nil? @reg_match) (< 1 @reg_firstlnum)))
                                ((ร status =) RA_NOMATCH)
                            )
                            (ร BREAK)
                        )

                        ((ร CASE) RE_EOF)
                        (ยง
                            (if (or (!= @reglnum @reg_maxline) (!= c NUL))
                                ((ร status =) RA_NOMATCH)
                            )
                            (ร BREAK)
                        )

                        ((ร CASE) CURSOR)
                        (ยง
                            ;; Check if the buffer is in a window and compare the
                            ;; reg_win.w_cursor position to the match position.
                            (when (or (nil? @reg_win) (ยง @reglnum + @reg_firstlnum != @reg_win.w_cursor.lnum) (!= (BDIFF @reginput, @regline) (.. @reg_win w_cursor col)))
                                ((ร status =) RA_NOMATCH)
                            )
                            (ร BREAK)
                        )

                        ((ร CASE) RE_MARK)
                        (ยง
                            ;; Compare the mark position to the match position.
                            ((ร int mark =) (ยง operand(scan).at(0)))
                            ((ร int cmp =) (ยง operand(scan).at(1)))

                            ((ร pos_C pos =) (getmark_buf @reg_buf, mark, false))
                                                            ;; mark doesn't exist
                                                            ;; mark isn't set in reg_buf
                            (if (or (== pos null) (<= (. pos lnum) 0) (if (== (. pos lnum) (+ @reglnum @reg_firstlnum)) (if (== (. pos col) (BDIFF @reginput, @regline)) (or (== cmp (byte \<)) (== cmp (byte \>))) (if (< (. pos col) (BDIFF @reginput, @regline)) (!= cmp (byte \>)) (!= cmp (byte \<)))) (if (< (. pos lnum) (+ @reglnum @reg_firstlnum)) (!= cmp (byte \>)) (!= cmp (byte \<)))))
                                ((ร status =) RA_NOMATCH)
                            )
                            (ร BREAK)
                        )

                        ((ร CASE) RE_VISUAL)
                        (ยง
                            (if (not (reg_match_visual))
                                ((ร status =) RA_NOMATCH)
                            )
                            (ร BREAK)
                        )

                        ((ร CASE) RE_LNUM)
                        (ยง
                            (if (or (non-nil? @reg_match) (not (re_num_cmp (+ @reglnum @reg_firstlnum), scan)))
                                ((ร status =) RA_NOMATCH)
                            )
                            (ร BREAK)
                        )

                        ((ร CASE) RE_COL)
                        (ยง
                            (if (not (re_num_cmp (+ (BDIFF @reginput, @regline) 1), scan))
                                ((ร status =) RA_NOMATCH)
                            )
                            (ร BREAK)
                        )

                        ((ร CASE) RE_VCOL)
                        (ยง
                            (if (not (re_num_cmp (+ (long (win_linetabsize (if (nil? @reg_win) @curwin @reg_win), @regline, (BDIFF @reginput, @regline))) 1), scan))
                                ((ร status =) RA_NOMATCH)
                            )
                            (ร BREAK)
                        )

                        ((ร CASE) BOW)                           ;; \<word; reginput points to w
                        (ยง
                            (cond (== c NUL)                   ;; Can't match at end of line
                            (ยง
                                ((ร status =) RA_NOMATCH)
                            )
                            :else
                            (ยง
                                (ร int this_class)

                                ;; Get class of current and previous char (if it exists).
                                ((ร this_class =) (us_get_class @reginput, @reg_buf))
                                (cond (<= this_class 1)
                                (ยง
                                    ((ร status =) RA_NOMATCH)    ;; not on a word at all
                                )
                                (== (reg_prev_class) this_class)
                                (ยง
                                    ((ร status =) RA_NOMATCH)    ;; previous char is in same word
                                ))
                            ))
                            (ร BREAK)
                        )

                        ((ร CASE) EOW)                           ;; word\>; reginput points after d
                        (ยง
                            (cond (BEQ @reginput, @regline)        ;; Can't match at start of line
                            (ยง
                                ((ร status =) RA_NOMATCH)
                            )
                            :else
                            (ยง
                                (ร int this_class, prev_class)

                                ;; Get class of current and previous char (if it exists).
                                ((ร this_class =) (us_get_class @reginput, @reg_buf))
                                ((ร prev_class =) (reg_prev_class))
                                (if (or (== this_class prev_class) (zero? prev_class) (== prev_class 1))
                                    ((ร status =) RA_NOMATCH)
                                )
                            ))
                            (ร BREAK) ;; Matched with EOW
                        )

                        ((ร CASE) ANY)
                        (ยง
                            ;; ANY does not match new lines.
                            (if (== c NUL)
                                ((ร status =) RA_NOMATCH)
                                (reset! reginput (ยง @reginput.plus(us_ptr2len_cc(@reginput)))))
                            (ร BREAK)
                        )

                        ((ร CASE) IDENT)
                        (ยง
                            (if (not (vim_isIDc c))
                                ((ร status =) RA_NOMATCH)
                                (reset! reginput (ยง @reginput.plus(us_ptr2len_cc(@reginput)))))
                            (ร BREAK)
                        )

                        ((ร CASE) SIDENT)
                        (ยง
                            (if (or (asc_isdigit (ยง @reginput.at(0))) (not (vim_isIDc c)))
                                ((ร status =) RA_NOMATCH)
                                (reset! reginput (ยง @reginput.plus(us_ptr2len_cc(@reginput)))))
                            (ร BREAK)
                        )

                        ((ร CASE) KWORD)
                        (ยง
                            (if (not (us_iswordp @reginput, @reg_buf))
                                ((ร status =) RA_NOMATCH)
                                (reset! reginput (ยง @reginput.plus(us_ptr2len_cc(@reginput)))))
                            (ร BREAK)
                        )

                        ((ร CASE) SKWORD)
                        (ยง
                            (if (or (asc_isdigit (ยง @reginput.at(0))) (not (us_iswordp @reginput, @reg_buf)))
                                ((ร status =) RA_NOMATCH)
                                (reset! reginput (ยง @reginput.plus(us_ptr2len_cc(@reginput)))))
                            (ร BREAK)
                        )

                        ((ร CASE) FNAME)
                        (ยง
                            (if (not (vim_isfilec c))
                                ((ร status =) RA_NOMATCH)
                                (reset! reginput (ยง @reginput.plus(us_ptr2len_cc(@reginput)))))
                            (ร BREAK)
                        )

                        ((ร CASE) SFNAME)
                        (ยง
                            (if (or (asc_isdigit (ยง @reginput.at(0))) (not (vim_isfilec c)))
                                ((ร status =) RA_NOMATCH)
                                (reset! reginput (ยง @reginput.plus(us_ptr2len_cc(@reginput)))))
                            (ร BREAK)
                        )

                        ((ร CASE) PRINT)
                        (ยง
                            (if (not (vim_isprintc (us_ptr2char @reginput)))
                                ((ร status =) RA_NOMATCH)
                                (reset! reginput (ยง @reginput.plus(us_ptr2len_cc(@reginput)))))
                            (ร BREAK)
                        )

                        ((ร CASE) SPRINT)
                        (ยง
                            (if (or (asc_isdigit (ยง @reginput.at(0))) (not (vim_isprintc (us_ptr2char @reginput))))
                                ((ร status =) RA_NOMATCH)
                                (reset! reginput (ยง @reginput.plus(us_ptr2len_cc(@reginput)))))
                            (ร BREAK)
                        )

                        ((ร CASE) WHITE)
                        (ยง
                            (if (not (vim_iswhite c))
                                ((ร status =) RA_NOMATCH)
                                (reset! reginput (ยง @reginput.plus(us_ptr2len_cc(@reginput)))))
                            (ร BREAK)
                        )

                        ((ร CASE) NWHITE)
                        (ยง
                            (if (or (== c NUL) (vim_iswhite c))
                                ((ร status =) RA_NOMATCH)
                                (reset! reginput (ยง @reginput.plus(us_ptr2len_cc(@reginput)))))
                            (ร BREAK)
                        )

                        ((ร CASE) DIGIT)
                        (ยง
                            (if (not (ri_digit c))
                                ((ร status =) RA_NOMATCH)
                                (reset! reginput (ยง @reginput.plus(us_ptr2len_cc(@reginput)))))
                            (ร BREAK)
                        )

                        ((ร CASE) NDIGIT)
                        (ยง
                            (if (or (== c NUL) (ri_digit c))
                                ((ร status =) RA_NOMATCH)
                                (reset! reginput (ยง @reginput.plus(us_ptr2len_cc(@reginput)))))
                            (ร BREAK)
                        )

                        ((ร CASE) HEX)
                        (ยง
                            (if (not (ri_hex c))
                                ((ร status =) RA_NOMATCH)
                                (reset! reginput (ยง @reginput.plus(us_ptr2len_cc(@reginput)))))
                            (ร BREAK)
                        )

                        ((ร CASE) NHEX)
                        (ยง
                            (if (or (== c NUL) (ri_hex c))
                                ((ร status =) RA_NOMATCH)
                                (reset! reginput (ยง @reginput.plus(us_ptr2len_cc(@reginput)))))
                            (ร BREAK)
                        )

                        ((ร CASE) OCTAL)
                        (ยง
                            (if (not (ri_octal c))
                                ((ร status =) RA_NOMATCH)
                                (reset! reginput (ยง @reginput.plus(us_ptr2len_cc(@reginput)))))
                            (ร BREAK)
                        )

                        ((ร CASE) NOCTAL)
                        (ยง
                            (if (or (== c NUL) (ri_octal c))
                                ((ร status =) RA_NOMATCH)
                                (reset! reginput (ยง @reginput.plus(us_ptr2len_cc(@reginput)))))
                            (ร BREAK)
                        )

                        ((ร CASE) WORD)
                        (ยง
                            (if (not (ri_word c))
                                ((ร status =) RA_NOMATCH)
                                (reset! reginput (ยง @reginput.plus(us_ptr2len_cc(@reginput)))))
                            (ร BREAK)
                        )

                        ((ร CASE) NWORD)
                        (ยง
                            (if (or (== c NUL) (ri_word c))
                                ((ร status =) RA_NOMATCH)
                                (reset! reginput (ยง @reginput.plus(us_ptr2len_cc(@reginput)))))
                            (ร BREAK)
                        )

                        ((ร CASE) HEAD)
                        (ยง
                            (if (not (ri_head c))
                                ((ร status =) RA_NOMATCH)
                                (reset! reginput (ยง @reginput.plus(us_ptr2len_cc(@reginput)))))
                            (ร BREAK)
                        )

                        ((ร CASE) NHEAD)
                        (ยง
                            (if (or (== c NUL) (ri_head c))
                                ((ร status =) RA_NOMATCH)
                                (reset! reginput (ยง @reginput.plus(us_ptr2len_cc(@reginput)))))
                            (ร BREAK)
                        )

                        ((ร CASE) ALPHA)
                        (ยง
                            (if (not (ri_alpha c))
                                ((ร status =) RA_NOMATCH)
                                (reset! reginput (ยง @reginput.plus(us_ptr2len_cc(@reginput)))))
                            (ร BREAK)
                        )

                        ((ร CASE) NALPHA)
                        (ยง
                            (if (or (== c NUL) (ri_alpha c))
                                ((ร status =) RA_NOMATCH)
                                (reset! reginput (ยง @reginput.plus(us_ptr2len_cc(@reginput)))))
                            (ร BREAK)
                        )

                        ((ร CASE) LOWER)
                        (ยง
                            (if (not (ri_lower c))
                                ((ร status =) RA_NOMATCH)
                                (reset! reginput (ยง @reginput.plus(us_ptr2len_cc(@reginput)))))
                            (ร BREAK)
                        )

                        ((ร CASE) NLOWER)
                        (ยง
                            (if (or (== c NUL) (ri_lower c))
                                ((ร status =) RA_NOMATCH)
                                (reset! reginput (ยง @reginput.plus(us_ptr2len_cc(@reginput)))))
                            (ร BREAK)
                        )

                        ((ร CASE) UPPER)
                        (ยง
                            (if (not (ri_upper c))
                                ((ร status =) RA_NOMATCH)
                                (reset! reginput (ยง @reginput.plus(us_ptr2len_cc(@reginput)))))
                            (ร BREAK)
                        )

                        ((ร CASE) NUPPER)
                        (ยง
                            (if (or (== c NUL) (ri_upper c))
                                ((ร status =) RA_NOMATCH)
                                (reset! reginput (ยง @reginput.plus(us_ptr2len_cc(@reginput)))))
                            (ร BREAK)
                        )

                        ((ร CASE) EXACTLY)
                        (ยง
                            ((ร Bytes opnd =) (operand scan))
                            ;; Inline the first byte, for speed.
                            (cond (and (!= (.at opnd 0) (.at @reginput 0)) (not @ireg_ic))
                            (ยง
                                ((ร status =) RA_NOMATCH)
                            )
                            (eos? opnd)
                            (ยง
                                ;; match empty string always works; happens when "~" is empty.
                            )
                            :else
                            (ยง
                                ((ร int[] len =) (ยง new int[1]))
                                (cond (and (eos? opnd 1) (not @ireg_ic))
                                (ยง
                                    ((ร len[0] =) 1)        ;; matched a single byte above
                                )
                                :else
                                (ยง
                                    ;; Need to match first byte again for multi-byte.
                                    ((ร len[0] =) (STRLEN opnd))
                                    (if (non-zero? (cstrncmp opnd, @reginput, len))
                                        ((ร status =) RA_NOMATCH)
                                    )
                                ))
                                ;; Check for following composing character, unless %C
                                ;; follows (skips over all composing chars).
                                (when (and (!= status RA_NOMATCH) (utf_iscomposing (us_ptr2char (ยง @reginput.plus(len[0])))) (not @ireg_icombine) (!= (re_op next) RE_COMPOSING))
                                    ;; This code makes a composing character get ignored,
                                    ;; which is the correct behavior (sometimes)
                                    ;; for voweled Hebrew texts.
                                    ((ร status =) RA_NOMATCH)
                                )
                                (if (!= status RA_NOMATCH)
                                    (reset! reginput (.plus @reginput (ยง len[0]))))
                            ))
                            (ร BREAK)
                        )

                        ((ร CASE) ANYOF)
                        ((ร CASE) ANYBUT)
                        (ยง
                            (cond (== c NUL)
                            (ยง
                                ((ร status =) RA_NOMATCH)
                            )
                            (== (nil? (cstrchr (operand scan), c)) (== op ANYOF))
                            (ยง
                                ((ร status =) RA_NOMATCH)
                            )
                            :else
                            (ยง
                                (reset! reginput (ยง @reginput.plus(us_ptr2len_cc(@reginput))))
                            ))
                            (ร BREAK)
                        )

                        ((ร CASE) MULTIBYTECODE)
                        (ยง
                            ((ร Bytes opnd =) (operand scan))
                            ;; Safety check (just in case 'encoding' was changed since compiling the program).
                            ((ร int len =) (us_ptr2len_cc opnd))
                            (when (< len 2)
                                ((ร status =) RA_NOMATCH)
                                (ร BREAK)
                            )
                            ((ร int opndc =) (us_ptr2char opnd))
                            (cond (utf_iscomposing opndc)
                            (ยง
                                ;; When only a composing char is given match at any
                                ;; position where that composing char appears.
                                ((ร status =) RA_NOMATCH)
                                ((ร FOR) (ร (ยง int i = 0) (ยง @reginput.at(i) != NUL) (ยง i += us_ptr2len(@reginput.plus(i))))
                                    ((ร int inpc =) (ยง us_ptr2char(@reginput.plus(i))))
                                    (cond (not (utf_iscomposing inpc))
                                    (ยง
                                        (if (< 0 i)
                                            (ร BREAK)
                                        )
                                    )
                                    (== opndc inpc)
                                    (ยง
                                        ;; Include all following composing chars.
                                        ((ร len =) (ยง i + us_ptr2len_cc(@reginput.plus(i))))
                                        ((ร status =) RA_MATCH)
                                        (ร BREAK)
                                    ))
                                )
                            )
                            :else
                            (ยง
                                ((ร FOR) (ร (ยง int i = 0) (< i len) (ยง i++))
                                    (when (!= (.at opnd i) (.at @reginput i))
                                        ((ร status =) RA_NOMATCH)
                                        (ร BREAK)
                                    )
                                )
                            ))

                            (reset! reginput (.plus @reginput len))
                            (ร BREAK)
                        )

                        ((ร CASE) RE_COMPOSING)
                        (ยง
                            ;; Skip composing characters.
                            (while (ยง utf_iscomposing(us_ptr2char(@reginput)))
                                (reset! reginput (ยง @reginput.plus(us_ptr2len(@reginput))))
                            )
                            (ร BREAK)
                        )

                        ((ร CASE) NOTHING)
                        (ยง
                            (ร BREAK)
                        )

                        ((ร CASE) BACK)
                        (ยง
                            ;; When we run into BACK we need to check if we don't keep
                            ;; looping without matching any input.  The second and later
                            ;; times a BACK is encountered it fails if the input is still
                            ;; at the same position as the previous time.
                            ;; The positions are stored in "backpos" and found by the
                            ;; current value of "scan", the position in the RE program.

                            ((ร backpos_C[] bpp =) (. @backpos ga_data))

                            (ร int i)
                            ((ร FOR) (ร (ยง i = 0) (ยง i < @backpos.ga_len) (ยง i++))
                                (if (BEQ (ยง bpp[i].bp_scan), scan)
                                    (ร BREAK)
                                )
                            )
                            (cond (== i (. @backpos ga_len))
                            (ยง
                                ;; First time at this BACK, make room to store the pos.
                                ((ร bpp =) (ยง @backpos.ga_grow(1)))
                                ((ร bpp[i] =) (ยง ยง_backpos_C()))
                                ((ร bpp[i].bp_scan =) scan)
                                (ยง @backpos.ga_len++)
                            )
                            (reg_save_equal (ยง bpp[i].bp_pos))
                            (ยง
                                ;; Still at same position as last time, fail.
                                ((ร status =) RA_NOMATCH)
                            ))

                            (if (and (!= status RA_FAIL) (!= status RA_NOMATCH))
                                (reg_save (ยง bpp[i].bp_pos), @backpos))

                            (ร BREAK)
                        )

                        ((ร CASE) (+ MOPEN 0))     ;; Match start: \zs
                        ((ร CASE) (+ MOPEN 1))     ;; \(
                        ((ร CASE) (+ MOPEN 2))
                        ((ร CASE) (+ MOPEN 3))
                        ((ร CASE) (+ MOPEN 4))
                        ((ร CASE) (+ MOPEN 5))
                        ((ร CASE) (+ MOPEN 6))
                        ((ร CASE) (+ MOPEN 7))
                        ((ร CASE) (+ MOPEN 8))
                        ((ร CASE) (+ MOPEN 9))
                        (ยง
                            ((ร int no =) (- op MOPEN))
                            (cleanup_subexpr)
                            ((ร regitem_C rip =) (push_regitem RS_MOPEN, scan))
                            (cond (nil? rip)
                            (ยง
                                ((ร status =) RA_FAIL)
                            )
                            :else
                            (ยง
                                ((ร rip.rs_no =) no)
                                ((ร @reg_startp[no] =) (ยง save_se(rip.rs_sesave, @reg_startpos[no], @reg_startp[no])))
                                ;; We simply continue and handle the result when done.
                            ))
                            (ร BREAK)
                        )

                        ((ร CASE) NOPEN)         ;; \%(
                        ((ร CASE) NCLOSE)        ;; \) after \%(
                        (ยง
                            (if (nil? (push_regitem RS_NOPEN, scan))
                                ((ร status =) RA_FAIL)
                            )
                            ;; We simply continue and handle the result when done.
                            (ร BREAK)
                        )

                        ((ร CASE) (+ ZOPEN 1))
                        ((ร CASE) (+ ZOPEN 2))
                        ((ร CASE) (+ ZOPEN 3))
                        ((ร CASE) (+ ZOPEN 4))
                        ((ร CASE) (+ ZOPEN 5))
                        ((ร CASE) (+ ZOPEN 6))
                        ((ร CASE) (+ ZOPEN 7))
                        ((ร CASE) (+ ZOPEN 8))
                        ((ร CASE) (+ ZOPEN 9))
                        (ยง
                            ((ร int no =) (- op ZOPEN))
                            (cleanup_zsubexpr)
                            ((ร regitem_C rip =) (push_regitem RS_ZOPEN, scan))
                            (cond (nil? rip)
                            (ยง
                                ((ร status =) RA_FAIL)
                            )
                            :else
                            (ยง
                                ((ร rip.rs_no =) no)
                                ((ร reg_startzp[no] =) (ยง save_se(rip.rs_sesave, reg_startzpos[no], reg_startzp[no])))
                                ;; We simply continue and handle the result when done.
                            ))
                            (ร BREAK)
                        )

                        ((ร CASE) (+ MCLOSE 0))    ;; Match end: \ze
                        ((ร CASE) (+ MCLOSE 1))    ;; \)
                        ((ร CASE) (+ MCLOSE 2))
                        ((ร CASE) (+ MCLOSE 3))
                        ((ร CASE) (+ MCLOSE 4))
                        ((ร CASE) (+ MCLOSE 5))
                        ((ร CASE) (+ MCLOSE 6))
                        ((ร CASE) (+ MCLOSE 7))
                        ((ร CASE) (+ MCLOSE 8))
                        ((ร CASE) (+ MCLOSE 9))
                        (ยง
                            ((ร int no =) (- op MCLOSE))
                            (cleanup_subexpr)
                            ((ร regitem_C rip =) (push_regitem RS_MCLOSE, scan))
                            (cond (nil? rip)
                            (ยง
                                ((ร status =) RA_FAIL)
                            )
                            :else
                            (ยง
                                ((ร rip.rs_no =) no)
                                ((ร @reg_endp[no] =) (ยง save_se(rip.rs_sesave, @reg_endpos[no], @reg_endp[no])))
                                ;; We simply continue and handle the result when done.
                            ))
                            (ร BREAK)
                        )

                        ((ร CASE) (+ ZCLOSE 1))    ;; \) after \z(
                        ((ร CASE) (+ ZCLOSE 2))
                        ((ร CASE) (+ ZCLOSE 3))
                        ((ร CASE) (+ ZCLOSE 4))
                        ((ร CASE) (+ ZCLOSE 5))
                        ((ร CASE) (+ ZCLOSE 6))
                        ((ร CASE) (+ ZCLOSE 7))
                        ((ร CASE) (+ ZCLOSE 8))
                        ((ร CASE) (+ ZCLOSE 9))
                        (ยง
                            ((ร int no =) (- op ZCLOSE))
                            (cleanup_zsubexpr)
                            ((ร regitem_C rip =) (push_regitem RS_ZCLOSE, scan))
                            (cond (nil? rip)
                            (ยง
                                ((ร status =) RA_FAIL)
                            )
                            :else
                            (ยง
                                ((ร rip.rs_no =) no)
                                ((ร reg_endzp[no] =) (ยง save_se(rip.rs_sesave, reg_endzpos[no], reg_endzp[no])))
                                ;; We simply continue and handle the result when done.
                            ))
                            (ร BREAK)
                        )

                        ((ร CASE) (+ BACKREF 1))
                        ((ร CASE) (+ BACKREF 2))
                        ((ร CASE) (+ BACKREF 3))
                        ((ร CASE) (+ BACKREF 4))
                        ((ร CASE) (+ BACKREF 5))
                        ((ร CASE) (+ BACKREF 6))
                        ((ร CASE) (+ BACKREF 7))
                        ((ร CASE) (+ BACKREF 8))
                        ((ร CASE) (+ BACKREF 9))
                        (ยง
                            ((ร int[] len =) (ยง new int[1]))

                            ((ร int no =) (- op BACKREF))
                            (cleanup_subexpr)
                            (cond (non-nil? @reg_match)       ;; Single-line regexp
                            (ยง
                                (cond (or (nil? (ยง @reg_startp[no])) (nil? (ยง @reg_endp[no])))
                                (ยง
                                    ;; Backref was not set: Match an empty string.
                                    ((ร len[0] =) 0)
                                )
                                :else
                                (ยง
                                    ;; Compare current input with back-ref in the same line.
                                    ((ร len[0] =) (ยง BDIFF(@reg_endp[no], @reg_startp[no])))
                                    (if (non-zero? (ยง cstrncmp(@reg_startp[no], @reginput, len)))
                                        ((ร status =) RA_NOMATCH)
                                    )
                                ))
                            )
                            :else                            ;; Multi-line regexp
                            (ยง
                                (cond (or (< (ยง @reg_startpos[no].lnum) 0) (< (ยง @reg_endpos[no].lnum) 0))
                                (ยง
                                    ;; Backref was not set: Match an empty string.
                                    ((ร len[0] =) 0)
                                )
                                :else
                                (ยง
                                    (cond (and (== (ยง @reg_startpos[no].lnum) @reglnum) (== (ยง @reg_endpos[no].lnum) @reglnum))
                                    (ยง
                                        ;; Compare back-ref within the current line.
                                        ((ร len[0] =) (ยง @reg_endpos[no].col - @reg_startpos[no].col))
                                        (if (non-zero? (ยง cstrncmp(@regline.plus(@reg_startpos[no].col), @reginput, len)))
                                            ((ร status =) RA_NOMATCH)
                                        )
                                    )
                                    :else
                                    (ยง
                                        ;; Messy situation: Need to compare between two lines.
                                        ((ร int r =) (ยง match_with_backref(@reg_startpos[no].lnum, @reg_startpos[no].col, @reg_endpos[no].lnum, @reg_endpos[no].col, len)))

                                        (if (!= r RA_MATCH)
                                            ((ร status =) r)
                                        )
                                    ))
                                ))
                            ))

                            ;; Matched the backref, skip over it.
                            (reset! reginput (.plus @reginput (ยง len[0])))
                            (ร BREAK)
                        )

                        ((ร CASE) (+ ZREF 1))
                        ((ร CASE) (+ ZREF 2))
                        ((ร CASE) (+ ZREF 3))
                        ((ร CASE) (+ ZREF 4))
                        ((ร CASE) (+ ZREF 5))
                        ((ร CASE) (+ ZREF 6))
                        ((ร CASE) (+ ZREF 7))
                        ((ร CASE) (+ ZREF 8))
                        ((ร CASE) (+ ZREF 9))
                        (ยง
                            (cleanup_zsubexpr)
                            ((ร int no =) (- op ZREF))
                            (cond (and (non-nil? @re_extmatch_in) (!= (ยง @re_extmatch_in.matches[no]) null))
                            (ยง
; %%                            ((ร int[] len =) (ยง { STRLEN(@re_extmatch_in.matches[no]) }))
                                (if (non-zero? (ยง cstrncmp(@re_extmatch_in.matches[no], @reginput, len)))
                                    ((ร status =) RA_NOMATCH)
                                    (reset! reginput (.plus @reginput (ยง len[0]))))
                            )
                            :else
                            (ยง
                                ;; Backref was not set: Match an empty string.
                            ))
                            (ร BREAK)
                        )

                        ((ร CASE) BRANCH)
                        (ยง
                            (cond (!= (re_op next) BRANCH) ;; No choice.
                            (ยง
                                ((ร next =) (operand scan))       ;; Avoid recursion.
                            )
                            :else
                            (ยง
                                ((ร regitem_C rip =) (push_regitem RS_BRANCH, scan))
                                (if (nil? rip)
                                    ((ร status =) RA_FAIL)
                                    ((ร status =) RA_BREAK)      ;; rest is below
                                )
                            ))
                            (ร BREAK)
                        )

                        ((ร CASE) BRACE_LIMITS)
                        (ยง
                            (cond (== (re_op next) BRACE_SIMPLE)
                            (ยง
                                (reset! bl_minval (operand_min scan))
                                (reset! bl_maxval (operand_max scan))
                            )
                            (and (<= BRACE_COMPLEX (re_op next)) (< (re_op next) (+ BRACE_COMPLEX 10)))
                            (ยง
                                ((ร int no =) (ยง re_op(next) - BRACE_COMPLEX))
                                ((ร @brace_min[no] =) (operand_min scan))
                                ((ร @brace_max[no] =) (operand_max scan))
                                ((ร @brace_count[no] =) 0)
                            )
                            :else
                            (ยง
                                (emsg e_internal)       ;; Shouldn't happen.
                                ((ร status =) RA_FAIL)
                            ))
                            (ร BREAK)
                        )

                        ((ร CASE) (+ BRACE_COMPLEX 0))
                        ((ร CASE) (+ BRACE_COMPLEX 1))
                        ((ร CASE) (+ BRACE_COMPLEX 2))
                        ((ร CASE) (+ BRACE_COMPLEX 3))
                        ((ร CASE) (+ BRACE_COMPLEX 4))
                        ((ร CASE) (+ BRACE_COMPLEX 5))
                        ((ร CASE) (+ BRACE_COMPLEX 6))
                        ((ร CASE) (+ BRACE_COMPLEX 7))
                        ((ร CASE) (+ BRACE_COMPLEX 8))
                        ((ร CASE) (+ BRACE_COMPLEX 9))
                        (ยง
                            ((ร int no =) (- op BRACE_COMPLEX))
                            (ยง ++@brace_count[no])

                            ;; If not matched enough times yet, try one more.
                            (when (<= (ยง @brace_count[no]) (if (<= (ยง @brace_min[no]) (ยง @brace_max[no])) (ยง @brace_min[no]) (ยง @brace_max[no])))
                                ((ร regitem_C rip =) (push_regitem RS_BRCPLX_MORE, scan))
                                (cond (nil? rip)
                                (ยง
                                    ((ร status =) RA_FAIL)
                                )
                                :else
                                (ยง
                                    ((ร rip.rs_no =) no)
                                    (reg_save (. rip rs_regsave), @backpos)
                                    ((ร next =) (operand scan))
                                    ;; We continue and handle the result when done.
                                ))
                                (ร BREAK)
                            )

                            ;; If matched enough times, may try matching some more.
                            (cond (<= (ยง @brace_min[no]) (ยง @brace_max[no]))
                            (ยง
                                ;; Range is the normal way around, use longest match.
                                (when (<= (ยง @brace_count[no]) (ยง @brace_max[no]))
                                    ((ร regitem_C rip =) (push_regitem RS_BRCPLX_LONG, scan))
                                    (cond (nil? rip)
                                    (ยง
                                        ((ร status =) RA_FAIL)
                                    )
                                    :else
                                    (ยง
                                        ((ร rip.rs_no =) no)
                                        (reg_save (. rip rs_regsave), @backpos)
                                        ((ร next =) (operand scan))
                                        ;; We continue and handle the result when done.
                                    ))
                                )
                            )
                            :else
                            (ยง
                                ;; Range is backwards, use shortest match first.
                                (when (<= (ยง @brace_count[no]) (ยง @brace_min[no]))
                                    ((ร regitem_C rip =) (push_regitem RS_BRCPLX_SHORT, scan))
                                    (cond (nil? rip)
                                    (ยง
                                        ((ร status =) RA_FAIL)
                                    )
                                    :else
                                    (ยง
                                        (reg_save (. rip rs_regsave), @backpos)
                                        ;; We continue and handle the result when done.
                                    ))
                                )
                            ))
                            (ร BREAK)
                        )

                        ((ร CASE) BRACE_SIMPLE)
                        ((ร CASE) STAR)
                        ((ร CASE) PLUS)
                        (ยง
                            ((ร regstar_C rst =) (ยง ยง_regstar_C()))

                            ;; Lookahead to avoid useless match attempts when we know
                            ;; what character comes next.

                            (cond (== (re_op next) EXACTLY)
                            (ยง
                                ((ร rst.nextb =) (ยง operand(next).at(0)))
                                (cond @ireg_ic
                                (ยง
                                    (if (utf_isupper (. rst nextb))
                                        ((ร rst.nextb_ic =) (ยง utf_tolower(rst.nextb)))
                                        ((ร rst.nextb_ic =) (ยง utf_toupper(rst.nextb)))
                                    )
                                )
                                :else
                                (ยง
                                    ((ร rst.nextb_ic =) (. rst nextb))
                                ))
                            )
                            :else
                            (ยง
                                ((ร rst.nextb =) NUL)
                                ((ร rst.nextb_ic =) NUL)
                            ))

                            (cond (!= op BRACE_SIMPLE)
                            (ยง
                                ((ร rst.minval =) (if (== op STAR) 0 1))
                                ((ร rst.maxval =) MAX_LIMIT)
                            )
                            :else
                            (ยง
                                ((ร rst.minval =) @bl_minval)
                                ((ร rst.maxval =) @bl_maxval)
                            ))

                            ;; When maxval > minval, try matching as much as possible, up to maxval.
                            ;; When maxval < minval, try matching at least the minimal number
                            ;; (since the range is backwards, that's also maxval!).

                            ((ร rst.count =) (ยง regrepeat(operand(scan), rst.maxval)))
                            (when @got_int
                                ((ร status =) RA_FAIL)
                                (ร BREAK)
                            )

                            (cond (if (<= (. rst minval) (. rst maxval)) (<= (. rst minval) (. rst count)) (<= (. rst maxval) (. rst count)))
                            (ยง
                                ;; It could match.  Prepare for trying to match
                                ;; what follows.  The code is below.  Parameters
                                ;; are stored in a regstar_C on the regstack.
                                (cond (<= @p_mmp (ยง (@regstack.ga_len >>> 10)))
                                (ยง
                                    (emsg e_maxmempat)
                                    ((ร status =) RA_FAIL)
                                )
                                :else
                                (ยง
                                    (ยง @regstack.ga_grow(1))
                                    ((ร @regstack.ga_data[@regstack.ga_len++] =) rst)
                                    ((ร rst =) null)

                                    ((ร regitem_C rip =) (push_regitem (if (<= (. rst minval) (. rst maxval)) RS_STAR_LONG RS_STAR_SHORT), scan))
                                    (if (nil? rip)
                                        ((ร status =) RA_FAIL)
                                        ((ร status =) RA_BREAK)      ;; skip the restore bits
                                    )
                                ))
                            )
                            :else
                            (ยง
                                ((ร status =) RA_NOMATCH)
                            ))

                            (ร BREAK)
                        )

                        ((ร CASE) NOMATCH)
                        ((ร CASE) MATCH)
                        ((ร CASE) SUBPAT)
                        (ยง
                            ((ร regitem_C rip =) (push_regitem RS_NOMATCH, scan))
                            (cond (nil? rip)
                            (ยง
                                ((ร status =) RA_FAIL)
                            )
                            :else
                            (ยง
                                ((ร rip.rs_no =) op)
                                (reg_save (. rip rs_regsave), @backpos)
                                ((ร next =) (operand scan))
                                ;; We continue and handle the result when done.
                            ))
                            (ร BREAK)
                        )

                        ((ร CASE) BEHIND)
                        ((ร CASE) NOBEHIND)
                        (ยง
                            ;; Need a bit of room to store extra positions.
                            (cond (<= @p_mmp (ยง (@regstack.ga_len >>> 10)))
                            (ยง
                                (emsg e_maxmempat)
                                ((ร status =) RA_FAIL)
                            )
                            :else
                            (ยง
                                ((ร regbehind_C rbp =) (ยง ยง_regbehind_C()))

                                (ยง @regstack.ga_grow(1))
                                ((ร @regstack.ga_data[@regstack.ga_len++] =) rbp)

                                ((ร regitem_C rip =) (push_regitem RS_BEHIND1, scan))
                                (cond (nil? rip)
                                (ยง
                                    ((ร status =) RA_FAIL)
                                )
                                :else
                                (ยง
                                    ;; Need to save the subexpr to be able to restore them
                                    ;; when there is a match but we don't use it.
                                    (save_subexpr rbp)

                                    ((ร rip.rs_no =) op)
                                    (reg_save (. rip rs_regsave), @backpos)
                                    ;; First try if what follows matches.
                                    ;; If it does, then we check the behind match by looping.
                                ))
                            ))
                            (ร BREAK)
                        )

                        ((ร CASE) BHPOS)
                        (ยง
                            (cond (nil? @reg_match)
                            (ยง
                                (when (or (!= (.. @behind_pos rs_pos col) (BDIFF @reginput, @regline)) (!= (.. @behind_pos rs_pos lnum) @reglnum))
                                    ((ร status =) RA_NOMATCH)
                                )
                            )
                            (BNE (. @behind_pos rs_ptr), @reginput)
                            (ยง
                                ((ร status =) RA_NOMATCH)
                            ))
                            (ร BREAK)
                        )

                        ((ร CASE) NEWL)
                        (ยง
                            (cond (and (or (!= c NUL) (non-nil? @reg_match) (< @reg_maxline @reglnum) @reg_line_lbr) (or (!= c (byte \newline)) (not @reg_line_lbr)))
                            (ยง
                                ((ร status =) RA_NOMATCH)
                            )
                            @reg_line_lbr
                            (ยง
                                (reset! reginput (ยง @reginput.plus(us_ptr2len_cc(@reginput))))
                            )
                            :else
                            (ยง
                                (reg_nextline)
                            ))
                            (ร BREAK)
                        )

                        ((ร CASE) END)
                        (ยง
                            ((ร status =) RA_MATCH)  ;; Success!
                            (ร BREAK)
                        )

                        (ร DEFAULT)
                        (ยง
                            (emsg e_re_corr)
                            ((ร status =) RA_FAIL)
                            (ร BREAK)
                        )
                    )
                ))

                ;; If we can't continue sequentially, break the inner loop.
                (if (!= status RA_CONT)
                    (ร BREAK)
                )

                ;; Continue in inner loop, advance to next item.
                ((ร scan =) next)
            )

            ;; If there is something on the regstack, execute the code for the state.
            ;; If the state is popped then loop and use the older state.

            (while (ยง 0 < @regstack.ga_len && status != RA_FAIL)
                ((ร Object vip =) (if (< 1 (. @regstack ga_len)) (ยง @regstack.ga_data[@regstack.ga_len - 2]) null))
                ((ร regitem_C rip =) (ยง (regitem_C)@regstack.ga_data[@regstack.ga_len - 1]))

                ((ร SWITCH) (. rip rs_state)
                    ((ร CASE) RS_NOPEN)
                    (ยง
                        ;; Result is passed on as-is, simply pop the state.
                        ((ร scan =) (pop_regitem))
                        (ร BREAK)
                    )

                    ((ร CASE) RS_MOPEN)
                    (ยง
                        ;; Pop the state.  Restore pointers when there is no match.
                        (when (== status RA_NOMATCH)
                            ((ร @reg_startp[rip.rs_no] =) (ยง restore_se(rip.rs_sesave, @reg_startpos[rip.rs_no], @reg_startp[rip.rs_no])))
                        )
                        ((ร scan =) (pop_regitem))
                        (ร BREAK)
                    )

                    ((ร CASE) RS_ZOPEN)
                    (ยง
                        ;; Pop the state.  Restore pointers when there is no match.
                        (when (== status RA_NOMATCH)
                            ((ร reg_startzp[rip.rs_no] =) (ยง restore_se(rip.rs_sesave, reg_startzpos[rip.rs_no], reg_startzp[rip.rs_no])))
                        )
                        ((ร scan =) (pop_regitem))
                        (ร BREAK)
                    )

                    ((ร CASE) RS_MCLOSE)
                    (ยง
                        ;; Pop the state.  Restore pointers when there is no match.
                        (when (== status RA_NOMATCH)
                            ((ร @reg_endp[rip.rs_no] =) (ยง restore_se(rip.rs_sesave, @reg_endpos[rip.rs_no], @reg_endp[rip.rs_no])))
                        )
                        ((ร scan =) (pop_regitem))
                        (ร BREAK)
                    )

                    ((ร CASE) RS_ZCLOSE)
                    (ยง
                        ;; Pop the state.  Restore pointers when there is no match.
                        (when (== status RA_NOMATCH)
                            ((ร reg_endzp[rip.rs_no] =) (ยง restore_se(rip.rs_sesave, reg_endzpos[rip.rs_no], reg_endzp[rip.rs_no])))
                        )
                        ((ร scan =) (pop_regitem))
                        (ร BREAK)
                    )

                    ((ร CASE) RS_BRANCH)
                    (ยง
                        (cond (== status RA_MATCH)
                        (ยง
                            ;; this branch matched, use it
                            ((ร scan =) (pop_regitem))
                        )
                        :else
                        (ยง
                            (when (!= status RA_BREAK)
                                ;; After a non-matching branch: try next one.
                                (reg_restore (. rip rs_regsave), @backpos)
                                ((ร scan =) (. rip rs_scan))
                            )
                            (cond (or (nil? scan) (!= (re_op scan) BRANCH))
                            (ยง
                                ;; no more branches, didn't find a match
                                ((ร status =) RA_NOMATCH)
                                ((ร scan =) (pop_regitem))
                            )
                            :else
                            (ยง
                                ;; Prepare to try a branch.
                                ((ร rip.rs_scan =) (regnext scan))
                                (reg_save (. rip rs_regsave), @backpos)
                                ((ร scan =) (operand scan))
                            ))
                        ))
                        (ร BREAK)
                    )

                    ((ร CASE) RS_BRCPLX_MORE)
                    (ยง
                        ;; Pop the state.  Restore pointers when there is no match.
                        (when (== status RA_NOMATCH)
                            (reg_restore (. rip rs_regsave), @backpos)
                            (ยง --@brace_count[rip.rs_no])       ;; decrement match count
                        )
                        ((ร scan =) (pop_regitem))
                        (ร BREAK)
                    )

                    ((ร CASE) RS_BRCPLX_LONG)
                    (ยง
                        ;; Pop the state.  Restore pointers when there is no match.
                        (when (== status RA_NOMATCH)
                            ;; There was no match, but we did find enough matches.
                            (reg_restore (. rip rs_regsave), @backpos)
                            (ยง --@brace_count[rip.rs_no])
                            ;; continue with the items after "\{}"
                            ((ร status =) RA_CONT)
                        )
                        ((ร scan =) (pop_regitem))
                        (if (== status RA_CONT)
                            ((ร scan =) (regnext scan))
                        )
                        (ร BREAK)
                    )

                    ((ร CASE) RS_BRCPLX_SHORT)
                    (ยง
                        ;; Pop the state.  Restore pointers when there is no match.
                        (when (== status RA_NOMATCH)
                            ;; There was no match, try to match one more item.
                            (reg_restore (. rip rs_regsave), @backpos)
                        )
                        ((ร scan =) (pop_regitem))
                        (when (== status RA_NOMATCH)
                            ((ร scan =) (operand scan))
                            ((ร status =) RA_CONT)
                        )
                        (ร BREAK)
                    )

                    ((ร CASE) RS_NOMATCH)
                    (ยง
                        ;; Pop the state.  If the operand matches for NOMATCH or
                        ;; doesn't match for MATCH/SUBPAT, we fail.  Otherwise backup,
                        ;; except for SUBPAT, and continue with the next item.
                        (cond (== status (if (== (. rip rs_no) NOMATCH) RA_MATCH RA_NOMATCH))
                        (ยง
                            ((ร status =) RA_NOMATCH)
                        )
                        :else
                        (ยง
                            ((ร status =) RA_CONT)
                            (if (!= (. rip rs_no) SUBPAT)        ;; zero-width
                                (reg_restore (. rip rs_regsave), @backpos))
                        ))
                        ((ร scan =) (pop_regitem))
                        (if (== status RA_CONT)
                            ((ร scan =) (regnext scan))
                        )
                        (ร BREAK)
                    )

                    ((ร CASE) RS_BEHIND1)
                    (ยง
                        (cond (== status RA_NOMATCH)
                        (ยง
                            ((ร scan =) (pop_regitem))
                            (drop_regbehind)
                        )
                        :else
                        (ยง
                            ;; The stuff after BEHIND/NOBEHIND matches.
                            ;; Now try if the behind part does (not) match before the current
                            ;; position in the input.  This must be done at every position in the
                            ;; input and checking if the match ends at the current position.

                            ;; save the position after the found match for next
                            (reg_save (ยง ((regbehind_C)vip).save_after, @backpos))

                            ;; Start looking for a match with operand at the current position.
                            ;; Go back one character until we find the result, hitting the start
                            ;; of the line or the previous line (for multi-line matching).
                            ;; Set behind_pos to where the match should end, BHPOS will match it.
                            ;; Save the current value.
                            (COPY_regsave (ยง ((regbehind_C)vip).save_behind, @behind_pos))
                            (COPY_regsave @behind_pos, (. rip rs_regsave))

                            ((ร rip.rs_state =) RS_BEHIND2)

                            (reg_restore (. rip rs_regsave), @backpos)
                            ((ร scan =) (ยง operand(rip.rs_scan).plus(4)))
                        ))
                        (ร BREAK)
                    )

                    ((ร CASE) RS_BEHIND2)
                    (ยง
                        ;; Looping for BEHIND / NOBEHIND match.

                        (cond (and (== status RA_MATCH) (reg_save_equal @behind_pos))
                        (ยง
                            ;; found a match that ends where "next" started
                            (COPY_regsave @behind_pos, (ยง ((regbehind_C)vip).save_behind))
                            (cond (== (. rip rs_no) BEHIND)
                            (ยง
                                (reg_restore (ยง ((regbehind_C)vip).save_after, @backpos))
                            )
                            :else
                            (ยง
                                ;; But we didn't want a match.  Need to restore the subexpr,
                                ;; because what follows matched, so they have been set.
                                ((ร status =) RA_NOMATCH)
                                (restore_subexpr (ยง (regbehind_C)vip))
                            ))
                            ((ร scan =) (pop_regitem))
                            (drop_regbehind)
                        )
                        :else
                        (ยง
                            ;; No match or a match that doesn't end where we want it:
                            ;; go back one character.  May go to previous line once.
                            ((ร boolean no =) true)
                            ((ร long limit =) (ยง operand_min(rip.rs_scan)))
                            (cond (nil? @reg_match)
                            (ยง
                                (cond (and (< 0 limit) (<= limit (- (if (< (.. rip rs_regsave rs_pos lnum) (.. @behind_pos rs_pos lnum)) (STRLEN @regline) (.. @behind_pos rs_pos col)) (.. rip rs_regsave rs_pos col))))
                                (ยง
                                    ((ร no =) false)
                                )
                                (zero? (.. rip rs_regsave rs_pos col))
                                (ยง
                                    (cond (or (< (.. rip rs_regsave rs_pos lnum) (.. @behind_pos rs_pos lnum)) (== (reg_getline (ยง --rip.rs_regsave.rs_pos.lnum)) null))
                                    (ยง
                                        ((ร no =) false)
                                    )
                                    :else
                                    (ยง
                                        (reg_restore (. rip rs_regsave), @backpos)
                                        ((ร rip.rs_regsave.rs_pos.col =) (STRLEN @regline))
                                    ))
                                )
                                :else
                                (ยง
                                    ((ร rip.rs_regsave.rs_pos.col -=) (ยง us_head_off(@regline, @regline.plus(rip.rs_regsave.rs_pos.col - 1)) + 1))
                                ))
                            )
                            :else
                            (ยง
                                (cond (BEQ (.. rip rs_regsave rs_ptr), @regline)
                                (ยง
                                    ((ร no =) false)
                                )
                                :else
                                (ยง
                                    ((ร rip.rs_regsave.rs_ptr =) (ยง rip.rs_regsave.rs_ptr.minus(us_ptr_back(@regline, rip.rs_regsave.rs_ptr))))
                                    (if (and (< 0 limit) (< limit (BDIFF (. @behind_pos rs_ptr), (.. rip rs_regsave rs_ptr))))
                                        ((ร no =) false)
                                    )
                                ))
                            ))
                            (cond no
                            (ยง
                                ;; Advanced, prepare for finding match again.
                                (reg_restore (. rip rs_regsave), @backpos)
                                ((ร scan =) (ยง operand(rip.rs_scan).plus(4)))
                                (when (== status RA_MATCH)
                                    ;; We did match, so subexpr may have been changed,
                                    ;; need to restore them for the next try.
                                    ((ร status =) RA_NOMATCH)
                                    (restore_subexpr (ยง (regbehind_C)vip))
                                )
                            )
                            :else
                            (ยง
                                ;; Can't advance.  For NOBEHIND that's a match.
                                (COPY_regsave @behind_pos, (ยง ((regbehind_C)vip).save_behind))
                                (cond (== (. rip rs_no) NOBEHIND)
                                (ยง
                                    (reg_restore (ยง ((regbehind_C)vip).save_after, @backpos))
                                    ((ร status =) RA_MATCH)
                                )
                                :else
                                (ยง
                                    ;; We do want a proper match.  Need to restore the subexpr
                                    ;; if we had a match, because they may have been set.
                                    (when (== status RA_MATCH)
                                        ((ร status =) RA_NOMATCH)
                                        (restore_subexpr (ยง (regbehind_C)vip))
                                    )
                                ))
                                ((ร scan =) (pop_regitem))
                                (drop_regbehind)
                            ))
                        ))
                        (ร BREAK)
                    )

                    ((ร CASE) RS_STAR_LONG)
                    ((ร CASE) RS_STAR_SHORT)
                    (ยง
                        ((ร regstar_C rst =) (ยง (regstar_C)vip))

                        (when (== status RA_MATCH)
                            ((ร scan =) (pop_regitem))
                            (drop_regstar)
                            (ร BREAK)
                        )

                        ;; Tried once already, restore input pointers.
                        (if (!= status RA_BREAK)
                            (reg_restore (. rip rs_regsave), @backpos))

                        ;; Repeat until we found a position where it could match.
                        (while true
                            (cond (!= status RA_BREAK)
                            (ยง
                                ;; Tried first position already, advance.
                                (cond (== (. rip rs_state) RS_STAR_LONG)
                                (ยง
                                    ;; Trying for longest match, but couldn't
                                    ;; or didn't match -- back up one char.
                                    (if (< (ยง --rst.count) (. rst minval))
                                        (ร BREAK)
                                    )
                                    (cond (BEQ @reginput, @regline)
                                    (ยง
                                        ;; backup to last char of previous line
                                        (swap! reglnum dec)
                                        (reset! regline (reg_getline @reglnum))
                                        ;; Just in case regrepeat() didn't count right.
                                        (if (nil? @regline)
                                            (ร BREAK)
                                        )
                                        (reset! reginput (ยง @regline.plus(STRLEN(@regline))))
                                        (fast_breakcheck)
                                    )
                                    :else
                                    (ยง
                                        (reset! reginput (ยง @reginput.minus(us_ptr_back(@regline, @reginput))))
                                    ))
                                )
                                :else
                                (ยง
                                    ;; Range is backwards, use shortest match first.
                                    ;; Careful: maxval and minval are exchanged!
                                    ;; Couldn't or didn't match: try advancing one char.
                                    (if (or (== (. rst count) (. rst minval)) (zero? (ยง regrepeat(operand(rip.rs_scan), 1))))
                                        (ร BREAK)
                                    )
                                    (ยง rst.count++)
                                ))
                                (if @got_int
                                    (ร BREAK)
                                )
                            )
                            :else
                            (ยง
                                ((ร status =) RA_NOMATCH)
                            ))

                            ;; If it could match, try it.
                            (when (or (== (. rst nextb) NUL) (== (.at @reginput 0) (. rst nextb)) (== (.at @reginput 0) (. rst nextb_ic)))
                                (reg_save (. rip rs_regsave), @backpos)
                                ((ร scan =) (ยง regnext(rip.rs_scan)))
                                ((ร status =) RA_CONT)
                                (ร BREAK)
                            )
                        )
                        (when (!= status RA_CONT)
                            ;; Failed.
                            ((ร scan =) (pop_regitem))
                            (drop_regstar)
                            ((ร status =) RA_NOMATCH)
                        )
                    )
                    (ร BREAK)
                )

                ;; If we want to continue the inner loop or didn't pop a state continue matching loop.
                (if (or (== status RA_CONT) (== rip (ยง (regitem_C)@regstack.ga_data[@regstack.ga_len - 1])))
                    (ร BREAK)
                )
            )

            ;; May need to continue with the inner loop, starting at "scan".
            (if (== status RA_CONT)
                (ร CONTINUE)
            )

            ;; If the regstack is empty or something failed we are done.

            (when (or (zero? (. @regstack ga_len)) (== status RA_FAIL))
                (when (nil? scan)
                    ;; We get here only if there's trouble -- normally
                    ;; "case END" is the terminating point.

                    (emsg e_re_corr)
                )
                (if (== status RA_FAIL)
                    (reset! got_int true))
                ((ร RETURN) (ยง (status == RA_MATCH)))
            )
        )

        ;; NOTREACHED
    ))

;; Push an item onto the regstack.
;; Returns pointer to new item.  Returns null when out of memory.

(defn- #_regitem_C push_regitem [#_int state, #_Bytes scan]
    (ยง
        (when (<= @p_mmp (ยง (@regstack.ga_len >>> 10)))
            (emsg e_maxmempat)
            ((ร RETURN) null)
        )

        ((ร regitem_C rip =) (ยง ยง_regitem_C()))

        (ยง @regstack.ga_grow(1))
        ((ร @regstack.ga_data[@regstack.ga_len++] =) rip)

        ((ร rip.rs_state =) state)
        ((ร rip.rs_scan =) scan)

        rip
    ))

;; Pop an item from the regstack.

(defn- #_Bytes pop_regitem []
    (ยง
        ((ร regitem_C rip =) (ยง (regitem_C)@regstack.ga_data[--@regstack.ga_len]))
        ((ร @regstack.ga_data[@regstack.ga_len] =) null)

        (. rip rs_scan)
    ))

(defn- #_void drop_regbehind []
    (ยง
        ((ร @regstack.ga_data[--@regstack.ga_len] =) null)
    ))

(defn- #_void drop_regstar []
    (ยง
        ((ร @regstack.ga_data[--@regstack.ga_len] =) null)
    ))

;; regrepeat - repeatedly match something simple, return how many.
;; Advances reginput (and reglnum) to just after the matched chars.

(defn- #_int regrepeat [#_Bytes p, #_long maxcount]
    ;; maxcount: maximum number of matches allowed
    (ยง
        ((ร long count =) 0)
        ((ร int testval =) 0)
        (ร int mask)

        ((ร Bytes scan =) @reginput)     ;; Make local copy of reginput for speed.
        ((ร Bytes opnd =) (operand p))

;       do_class:
;       {
            ((ร SWITCH) (re_op p)
                ((ร CASE) ANY)
                ((ร CASE) (+ ANY ADD_NL))
                (ยง
                    (while (< count maxcount)
                        ;; Matching anything means we continue until end-of-line (or
                        ;; end-of-file for ANY + ADD_NL), only limited by maxcount.
                        (while (ยง scan.at(0) != NUL && count < maxcount)
                            (ยง count++)
                            ((ร scan =) (ยง scan.plus(us_ptr2len_cc(scan))))
                        )
                        (if (or (non-nil? @reg_match) (not (with_nl (re_op p))) (< @reg_maxline @reglnum) @reg_line_lbr (== count maxcount))
                            (ร BREAK)
                        )
                        (ยง count++)                ;; count the line-break
                        (reg_nextline)
                        ((ร scan =) @reginput)
                        (if @got_int
                            (ร BREAK)
                        )
                    )
                    (ร BREAK do_class)
                )

                ((ร CASE) IDENT)
                ((ร CASE) (+ IDENT ADD_NL))
                (ยง
                    ((ร testval =) TRUE)
                    (ร FALLTHROUGH)
                )
                ((ร CASE) SIDENT)
                ((ร CASE) (+ SIDENT ADD_NL))
                (ยง
                    (while (< count maxcount)
                        (cond (and (vim_isIDc (us_ptr2char scan)) (or (non-zero? testval) (not (asc_isdigit (ยง scan.at(0))))))
                        (ยง
                            ((ร scan =) (ยง scan.plus(us_ptr2len_cc(scan))))
                        )
                        (eos? scan)
                        (ยง
                            (if (or (non-nil? @reg_match) (not (with_nl (re_op p))) (< @reg_maxline @reglnum) @reg_line_lbr)
                                (ร BREAK)
                            )
                            (reg_nextline)
                            ((ร scan =) @reginput)
                            (if @got_int
                                (ร BREAK)
                            )
                        )
                        (and @reg_line_lbr (== (.at scan 0) (byte \newline)) (with_nl (re_op p)))
                        (ยง
                            ((ร scan =) (ยง scan.plus(1)))
                        )
                        :else
                        (ยง
                            (ร BREAK)
                        ))
                        (ยง count++)
                    )
                    (ร BREAK do_class)
                )

                ((ร CASE) KWORD)
                ((ร CASE) (+ KWORD ADD_NL))
                (ยง
                    ((ร testval =) TRUE)
                    (ร FALLTHROUGH)
                )
                ((ร CASE) SKWORD)
                ((ร CASE) (+ SKWORD ADD_NL))
                (ยง
                    (while (< count maxcount)
                        (cond (and (us_iswordp scan, @reg_buf) (or (non-zero? testval) (not (asc_isdigit (ยง scan.at(0))))))
                        (ยง
                            ((ร scan =) (ยง scan.plus(us_ptr2len_cc(scan))))
                        )
                        (eos? scan)
                        (ยง
                            (if (or (non-nil? @reg_match) (not (with_nl (re_op p))) (< @reg_maxline @reglnum) @reg_line_lbr)
                                (ร BREAK)
                            )
                            (reg_nextline)
                            ((ร scan =) @reginput)
                            (if @got_int
                                (ร BREAK)
                            )
                        )
                        (and @reg_line_lbr (== (.at scan 0) (byte \newline)) (with_nl (re_op p)))
                        (ยง
                            ((ร scan =) (ยง scan.plus(1)))
                        )
                        :else
                        (ยง
                            (ร BREAK)
                        ))
                        (ยง count++)
                    )
                    (ร BREAK do_class)
                )

                ((ร CASE) FNAME)
                ((ร CASE) (+ FNAME ADD_NL))
                (ยง
                    ((ร testval =) TRUE)
                    (ร FALLTHROUGH)
                )
                ((ร CASE) SFNAME)
                ((ร CASE) (+ SFNAME ADD_NL))
                (ยง
                    (while (< count maxcount)
                        (cond (and (vim_isfilec (us_ptr2char scan)) (or (non-zero? testval) (not (asc_isdigit (ยง scan.at(0))))))
                        (ยง
                            ((ร scan =) (ยง scan.plus(us_ptr2len_cc(scan))))
                        )
                        (eos? scan)
                        (ยง
                            (if (or (non-nil? @reg_match) (not (with_nl (re_op p))) (< @reg_maxline @reglnum) @reg_line_lbr)
                                (ร BREAK)
                            )
                            (reg_nextline)
                            ((ร scan =) @reginput)
                            (if @got_int
                                (ร BREAK)
                            )
                        )
                        (and @reg_line_lbr (== (.at scan 0) (byte \newline)) (with_nl (re_op p)))
                        (ยง
                            ((ร scan =) (ยง scan.plus(1)))
                        )
                        :else
                        (ยง
                            (ร BREAK)
                        ))
                        (ยง count++)
                    )
                    (ร BREAK do_class)
                )

                ((ร CASE) PRINT)
                ((ร CASE) (+ PRINT ADD_NL))
                (ยง
                    ((ร testval =) TRUE)
                    (ร FALLTHROUGH)
                )
                ((ร CASE) SPRINT)
                ((ร CASE) (+ SPRINT ADD_NL))
                (ยง
                    (while (< count maxcount)
                        (cond (eos? scan)
                        (ยง
                            (if (or (non-nil? @reg_match) (not (with_nl (re_op p))) (< @reg_maxline @reglnum) @reg_line_lbr)
                                (ร BREAK)
                            )
                            (reg_nextline)
                            ((ร scan =) @reginput)
                            (if @got_int
                                (ร BREAK)
                            )
                        )
                        (and (vim_isprintc (us_ptr2char scan)) (or (non-zero? testval) (not (asc_isdigit (ยง scan.at(0))))))
                        (ยง
                            ((ร scan =) (ยง scan.plus(us_ptr2len_cc(scan))))
                        )
                        (and @reg_line_lbr (== (.at scan 0) (byte \newline)) (with_nl (re_op p)))
                        (ยง
                            ((ร scan =) (ยง scan.plus(1)))
                        )
                        :else
                        (ยง
                            (ร BREAK)
                        ))
                        (ยง count++)
                    )
                    (ร BREAK do_class)
                )

                ((ร CASE) WHITE)
                ((ร CASE) (+ WHITE ADD_NL))
                (ยง
                    ((ร testval =) (ยง mask = RI_WHITE))
                    (ร BREAK)
                )

                ((ร CASE) NWHITE)
                ((ร CASE) (+ NWHITE ADD_NL))
                (ยง
                    ((ร mask =) RI_WHITE)
                    (ร BREAK)
                )

                ((ร CASE) DIGIT)
                ((ร CASE) (+ DIGIT ADD_NL))
                (ยง
                    ((ร testval =) (ยง mask = RI_DIGIT))
                    (ร BREAK)
                )

                ((ร CASE) NDIGIT)
                ((ร CASE) (+ NDIGIT ADD_NL))
                (ยง
                    ((ร mask =) RI_DIGIT)
                    (ร BREAK)
                )

                ((ร CASE) HEX)
                ((ร CASE) (+ HEX ADD_NL))
                (ยง
                    ((ร testval =) (ยง mask = RI_HEX))
                    (ร BREAK)
                )

                ((ร CASE) NHEX)
                ((ร CASE) (+ NHEX ADD_NL))
                (ยง
                    ((ร mask =) RI_HEX)
                    (ร BREAK)
                )

                ((ร CASE) OCTAL)
                ((ร CASE) (+ OCTAL ADD_NL))
                (ยง
                    ((ร testval =) (ยง mask = RI_OCTAL))
                    (ร BREAK)
                )

                ((ร CASE) NOCTAL)
                ((ร CASE) (+ NOCTAL ADD_NL))
                (ยง
                    ((ร mask =) RI_OCTAL)
                    (ร BREAK)
                )

                ((ร CASE) WORD)
                ((ร CASE) (+ WORD ADD_NL))
                (ยง
                    ((ร testval =) (ยง mask = RI_WORD))
                    (ร BREAK)
                )

                ((ร CASE) NWORD)
                ((ร CASE) (+ NWORD ADD_NL))
                (ยง
                    ((ร mask =) RI_WORD)
                    (ร BREAK)
                )

                ((ร CASE) HEAD)
                ((ร CASE) (+ HEAD ADD_NL))
                (ยง
                    ((ร testval =) (ยง mask = RI_HEAD))
                    (ร BREAK)
                )

                ((ร CASE) NHEAD)
                ((ร CASE) (+ NHEAD ADD_NL))
                (ยง
                    ((ร mask =) RI_HEAD)
                    (ร BREAK)
                )

                ((ร CASE) ALPHA)
                ((ร CASE) (+ ALPHA ADD_NL))
                (ยง
                    ((ร testval =) (ยง mask = RI_ALPHA))
                    (ร BREAK)
                )

                ((ร CASE) NALPHA)
                ((ร CASE) (+ NALPHA ADD_NL))
                (ยง
                    ((ร mask =) RI_ALPHA)
                    (ร BREAK)
                )

                ((ร CASE) LOWER)
                ((ร CASE) (+ LOWER ADD_NL))
                (ยง
                    ((ร testval =) (ยง mask = RI_LOWER))
                    (ร BREAK)
                )

                ((ร CASE) NLOWER)
                ((ร CASE) (+ NLOWER ADD_NL))
                (ยง
                    ((ร mask =) RI_LOWER)
                    (ร BREAK)
                )

                ((ร CASE) UPPER)
                ((ร CASE) (+ UPPER ADD_NL))
                (ยง
                    ((ร testval =) (ยง mask = RI_UPPER))
                    (ร BREAK)
                )

                ((ร CASE) NUPPER)
                ((ร CASE) (+ NUPPER ADD_NL))
                (ยง
                    ((ร mask =) RI_UPPER)
                    (ร BREAK)
                )

                ((ร CASE) EXACTLY)
                (ยง
                    ;; This doesn't do a multi-byte character, because a MULTIBYTECODE would have
                    ;; been used for it.  It does handle single-byte characters, such as latin1.
                    (cond @ireg_ic
                    (ยง
                        ((ร int cu =) (ยง utf_toupper(opnd.at(0))))
                        ((ร int cl =) (ยง utf_tolower(opnd.at(0))))
                        (while (ยง count < maxcount && (scan.at(0) == cu || scan.at(0) == cl))
                            (ยง count++)
                            ((ร scan =) (ยง scan.plus(1)))
                        )
                    )
                    :else
                    (ยง
                        ((ร int cu =) (ยง opnd.at(0)))
                        (while (ยง count < maxcount && scan.at(0) == cu)
                            (ยง count++)
                            ((ร scan =) (ยง scan.plus(1)))
                        )
                    ))
                    (ร BREAK do_class)
                )

                ((ร CASE) MULTIBYTECODE)
                (ยง
                    ;; Safety check (just in case 'encoding' was changed since compiling the program).
                    ((ร int len =) (us_ptr2len_cc opnd))
                    (when (< 1 len)
                        ((ร int cf =) 0)
                        (if @ireg_ic
                            ((ร cf =) (ยง utf_fold(us_ptr2char(opnd))))
                        )
                        (while (< count maxcount)
                            (ร int i)
                            ((ร FOR) (ร (ยง i = 0) (< i len) (ยง i++))
                                (if (!= (.at opnd i) (.at scan i))
                                    (ร BREAK)
                                )
                            )
                            (if (and (< i len) (or (not @ireg_ic) (!= (utf_fold (us_ptr2char scan)) cf)))
                                (ร BREAK)
                            )
                            ((ร scan =) (ยง scan.plus(len)))
                            (ยง count++)
                        )
                    )
                    (ร BREAK do_class)
                )

                ((ร CASE) ANYOF)
                ((ร CASE) (+ ANYOF ADD_NL))
                (ยง
                    ((ร testval =) TRUE)
                    (ร FALLTHROUGH)
                )
                ((ร CASE) ANYBUT)
                ((ร CASE) (+ ANYBUT ADD_NL))
                (ยง
                    (while (< count maxcount)
                        (ร int len)
                        (cond (eos? scan)
                        (ยง
                            (if (or (non-nil? @reg_match) (not (with_nl (re_op p))) (< @reg_maxline @reglnum) @reg_line_lbr)
                                (ร BREAK)
                            )
                            (reg_nextline)
                            ((ร scan =) @reginput)
                            (if @got_int
                                (ร BREAK)
                            )
                        )
                        (and @reg_line_lbr (== (.at scan 0) (byte \newline)) (with_nl (re_op p)))
                        (ยง
                            ((ร scan =) (ยง scan.plus(1)))
                        )
                        (< 1 (ยง (len = us_ptr2len_cc(scan))))
                        (ยง
                            (if (== (nil? (cstrchr opnd, (us_ptr2char scan))) (non-zero? testval))
                                (ร BREAK)
                            )
                            ((ร scan =) (ยง scan.plus(len)))
                        )
                        :else
                        (ยง
                            (if (== (nil? (cstrchr opnd, (.at scan 0))) (non-zero? testval))
                                (ร BREAK)
                            )
                            ((ร scan =) (ยง scan.plus(1)))
                        ))
                        (ยง count++)
                    )
                    (ร BREAK do_class)
                )

                ((ร CASE) NEWL)
                (ยง
                    (while (ยง count < maxcount && ((scan.at(0) == NUL && @reglnum <= @reg_maxline && !@reg_line_lbr && @reg_match == null) || (scan.at(0) == (byte \newline) && @reg_line_lbr)))
                        (ยง count++)
                        (if @reg_line_lbr
                            (reset! reginput (ยง @reginput.plus(us_ptr2len_cc(@reginput))))
                            (reg_nextline))
                        ((ร scan =) @reginput)
                        (if @got_int
                            (ร BREAK)
                        )
                    )
                    (ร BREAK do_class)
                )

                (ร DEFAULT)                ;; Oh dear.  Called inappropriately.
                (ยง
                    (emsg e_re_corr)
                    (ร BREAK do_class)
                )
            )

            (while (< count maxcount)
                (ร int l)
                (cond (eos? scan)
                (ยง
                    (if (or (non-nil? @reg_match) (not (with_nl (re_op p))) (< @reg_maxline @reglnum) @reg_line_lbr)
                        (ร BREAK)
                    )
                    (reg_nextline)
                    ((ร scan =) @reginput)
                    (if @got_int
                        (ร BREAK)
                    )
                )
                (< 1 (ยง (l = us_ptr2len_cc(scan))))
                (ยง
                    (if (non-zero? testval)
                        (ร BREAK)
                    )
                    ((ร scan =) (ยง scan.plus(l)))
                )
                (== (& (ยง @class_tab[char_u(scan.at(0))]) mask) testval)
                (ยง
                    ((ร scan =) (ยง scan.plus(1)))
                )
                (and @reg_line_lbr (== (.at scan 0) (byte \newline)) (with_nl (re_op p)))
                (ยง
                    ((ร scan =) (ยง scan.plus(1)))
                )
                :else
                (ยง
                    (ร BREAK)
                ))
                (ยง count++)
            )
;       }

        (reset! reginput scan)

        (int count)
    ))

;; Dig the "next" pointer out of a node.
;; Returns null when calculating size, when there is no next item and when there is an error.

(defn- #_Bytes regnext [#_Bytes p]
    (ยง
        (if (or (== p JUST_CALC_SIZE) @reg_toolong)
            ((ร RETURN) null)
        )

        ((ร int offset =) (re_next p))
        (if (zero? offset)
            ((ร RETURN) null)
        )

        (if (== (re_op p) BACK)
            ((ร RETURN) (ยง p.minus(offset)))
            ((ร RETURN) (ยง p.plus(offset)))
        )
    ))

;; Check the regexp program for its magic number.
;; Return true if it's wrong.

(defn- #_boolean prog_magic_wrong []
    (ยง
        ((ร regprog_C prog =) (if (nil? @reg_match) (. @reg_mmatch regprog) (. @reg_match regprog)))
        (when (== (. prog engine) nfa_regengine)
            ;; For NFA matcher we don't check the magic.
            ((ร RETURN) false)
        )

        (when (!= (ยง ((bt_regprog_C)prog).program.at(0)) REGMAGIC)
            (emsg e_re_corr)
            ((ร RETURN) true)
        )

        false
    ))

;; Cleanup the subexpressions, if this wasn't done yet.
;; This construction is used to clear the subexpressions
;; only when they are used (to increase speed).

(defn- #_void cleanup_subexpr []
    (ยง
        (when @need_clear_subexpr
            (cond (nil? @reg_match)
            (ยง
                ((ร FOR) (ร (ยง int i = 0) (< i NSUBEXP) (ยง i++))
                    ;; Use 0xff to set lnum to -1.
                    (MIN1_lpos (ยง @reg_startpos[i]))
                    (MIN1_lpos (ยง @reg_endpos[i]))
                )
            )
            :else
            (ยง
                ((ร FOR) (ร (ยง int i = 0) (< i NSUBEXP) (ยง i++))
                    ((ร @reg_startp[i] =) null)
                    ((ร @reg_endp[i] =) null)
                )
            ))
            (reset! need_clear_subexpr false)
        )
    ))

(defn- #_void cleanup_zsubexpr []
    (ยง
        (when @need_clear_zsubexpr
            (cond (nil? @reg_match)
            (ยง
                ((ร FOR) (ร (ยง int i = 0) (< i NSUBEXP) (ยง i++))
                    ;; Use 0xff to set lnum to -1.
                    (MIN1_lpos (ยง reg_startzpos[i]))
                    (MIN1_lpos (ยง reg_endzpos[i]))
                )
            )
            :else
            (ยง
                ((ร FOR) (ร (ยง int i = 0) (< i NSUBEXP) (ยง i++))
                    ((ร reg_startzp[i] =) null)
                    ((ร reg_endzp[i] =) null)
                )
            ))
            (reset! need_clear_zsubexpr false)
        )
    ))

;; Save the current subexpr to "bp", so that they can be restored later by restore_subexpr().

(defn- #_void save_subexpr [#_regbehind_C bp]
    (ยง
        ;; When "need_clear_subexpr" is set we don't need to save the values,
        ;; only remember that this flag needs to be set again when restoring.
        ((ร bp.save_need_clear_subexpr =) @need_clear_subexpr)
        (when (not @need_clear_subexpr)
            ((ร FOR) (ร (ยง int i = 0) (< i NSUBEXP) (ยง i++))
                (cond (nil? @reg_match)
                (ยง
                    (COPY_lpos (ยง bp.save_start[i].se_pos), (ยง @reg_startpos[i]))
                    (COPY_lpos (ยง bp.save_end[i].se_pos), (ยง @reg_endpos[i]))
                )
                :else
                (ยง
                    ((ร bp.save_start[i].se_ptr =) (ยง @reg_startp[i]))
                    ((ร bp.save_end[i].se_ptr =) (ยง @reg_endp[i]))
                ))
            )
        )
    ))

;; Restore the subexpr from "bp".

(defn- #_void restore_subexpr [#_regbehind_C bp]
    (ยง
        ;; Only need to restore saved values when they are not to be cleared.
        (reset! need_clear_subexpr (. bp save_need_clear_subexpr))
        (when (not @need_clear_subexpr)
            ((ร FOR) (ร (ยง int i = 0) (< i NSUBEXP) (ยง i++))
                (cond (nil? @reg_match)
                (ยง
                    (COPY_lpos (ยง @reg_startpos[i]), (ยง bp.save_start[i].se_pos))
                    (COPY_lpos (ยง @reg_endpos[i]), (ยง bp.save_end[i].se_pos))
                )
                :else
                (ยง
                    ((ร @reg_startp[i] =) (ยง bp.save_start[i].se_ptr))
                    ((ร @reg_endp[i] =) (ยง bp.save_end[i].se_ptr))
                ))
            )
        )
    ))

;; Advance "reglnum", "regline" and "reginput" to the next line.

(defn- #_void reg_nextline []
    (ยง
        (reset! regline (reg_getline (ยง ++@reglnum)))
        (reset! reginput @regline)
        (fast_breakcheck)
    ))

;; Save the input line and position in a regsave_C.

(defn- #_void reg_save [#_regsave_C save, #_backpos_C* gap]
    (ยง
        (cond (nil? @reg_match)
        (ยง
            ((ร save.rs_pos.col =) (BDIFF @reginput, @regline))
            ((ร save.rs_pos.lnum =) @reglnum)
        )
        :else
        (ยง
            ((ร save.rs_ptr =) @reginput)
        ))
        ((ร save.rs_len =) (. gap ga_len))
    ))

;; Restore the input line and position from a regsave_C.

(defn- #_void reg_restore [#_regsave_C save, #_backpos_C* gap]
    (ยง
        (cond (nil? @reg_match)
        (ยง
            (when (!= @reglnum (.. save rs_pos lnum))
                ;; only call reg_getline() when the line number changed to save a bit of time
                (reset! reglnum (.. save rs_pos lnum))
                (reset! regline (reg_getline @reglnum))
            )
            (reset! reginput (.plus @regline (.. save rs_pos col)))
        )
        :else
        (ยง
            (reset! reginput (. save rs_ptr))
        ))
        ((ร gap.ga_len =) (. save rs_len))
    ))

;; Return true if current position is equal to saved position.

(defn- #_boolean reg_save_equal [#_regsave_C save]
    (ยง
        (if (nil? @reg_match)
            ((ร RETURN) (ยง (@reglnum == save.rs_pos.lnum && BEQ(@reginput, @regline.plus(save.rs_pos.col)))))
        )

        (BEQ @reginput, (. save rs_ptr))
    ))

;; Tentatively set the sub-expression start to the current position (after calling regmatch()
;; they will have changed).  Need to save the existing values for when there is no match.
;; Use se_save() to use pointer (save_se_multi()) or position (save_se_one()),
;; depending on REG_MULTI.

(defn- #_void save_se_multi [#_save_se_C savep, #_lpos_C posp]
    (ยง
        (COPY_lpos (. savep se_pos), posp)
        ((ร posp.lnum =) @reglnum)
        ((ร posp.col =) (BDIFF @reginput, @regline))
    ))

(defn- #_Bytes save_se_one [#_save_se_C savep, #_Bytes pp]
    (ยง
        ((ร savep.se_ptr =) pp)
        ((ร pp =) @reginput)
        pp
    ))

;; Save the sub-expressions before attempting a match.
(defn- #_Bytes save_se [#_save_se_C savep, #_lpos_C posp, #_Bytes pp]
    (ยง
        (if (nil? @reg_match)
            (save_se_multi savep, posp)
            ((ร pp =) (save_se_one savep, pp))
        )

        pp
    ))

;; After a failed match restore the sub-expressions.
(defn- #_Bytes restore_se [#_save_se_C savep, #_lpos_C posp, #_Bytes pp]
    (ยง
        (if (nil? @reg_match)
            (COPY_lpos posp, (. savep se_pos))
            ((ร pp =) (. savep se_ptr))
        )

        pp
    ))

;; Compare a number with the operand of RE_LNUM, RE_COL or RE_VCOL.

(defn- #_boolean re_num_cmp [#_long val, #_Bytes scan]
    (ยง
        ((ร long n =) (operand_min scan))

        (if (== (operand_cmp scan) (byte \>))
            ((ร RETURN) (ยง (val > n)))
        )
        (if (== (operand_cmp scan) (byte \<))
            ((ร RETURN) (ยง (val < n)))
        )

        (== val n)
    ))

;; Check whether a backreference matches.
;; Returns RA_FAIL, RA_NOMATCH or RA_MATCH.
;; If "bytelen" is not null, it is set to the byte length of the match in the last line.

(defn- #_int match_with_backref [#_long start_lnum, #_int start_col, #_long end_lnum, #_int end_col, #_int* bytelen]
    (ยง
        ((ร long clnum =) start_lnum)
        ((ร int ccol =) start_col)

        (if (non-nil? bytelen)
            ((ร bytelen[0] =) 0)
        )

        (while true
            ;; Since getting one line may invalidate the other, need to make copy.
            ;; Slow!
            (when (BNE @regline, @reg_tofree)
                ((ร int len =) (STRLEN @regline))
                (when (or (nil? @reg_tofree) (<= @reg_tofree_len len))
                    ((ร len +=) 50)                              ;; get some extra
                    (reset! reg_tofree (ยง new Bytes(len)))
                    (reset! reg_tofree_len len)
                )
                (STRCPY @reg_tofree, @regline)
                (reset! reginput (ยง @reg_tofree.plus(BDIFF(@reginput, @regline))))
                (reset! regline @reg_tofree)
            )

            ;; Get the line to compare with.
            ((ร Bytes p =) (reg_getline clnum))
            ((ร int[] len =) (ยง new int[1]))
            (if (== clnum end_lnum)
                ((ร len[0] =) (- end_col ccol))
                ((ร len[0] =) (STRLEN p, ccol))
            )

            (if (non-zero? (ยง cstrncmp(p.plus(ccol), @reginput, len)))
                ((ร RETURN) RA_NOMATCH)                          ;; doesn't match
            )
            (if (non-nil? bytelen)
                ((ร bytelen[0] +=) (ยง len[0]))
            )
            (if (== clnum end_lnum)
                (ร BREAK)                                      ;; match and at end!
            )
            (if (<= @reg_maxline @reglnum)
                ((ร RETURN) RA_NOMATCH)                          ;; text too short
            )

            ;; Advance to next line.
            (reg_nextline)
            (if (non-nil? bytelen)
                ((ร bytelen[0] =) 0)
            )
            (ยง clnum++)
            ((ร ccol =) 0)
            (if @got_int
                ((ร RETURN) RA_FAIL)
            )
        )

        ;; Found a match!
        ;; Note that regline may now point to a copy of the line, that should not matter.
        RA_MATCH
    ))

;; Used in a place where no * or \+ can follow.

(defn- #_boolean re_mult_next [#_Bytes what]
    (ยง
        (when (== (re_multi_type (peekchr)) MULTI_MULT)
            (emsg2 (u8 "E888: (NFA regexp) cannot repeat %s"), what)
            (reset! rc_did_emsg true)
            ((ร RETURN) false)
        )
        true
    ))

(class! #_final decomp_C
    [
        (field int a) (field int b) (field int c)
    ])

;; 0xfb20 - 0xfb4f
(final decomp_C* decomp_table
    [
        (->decomp_C  0x5e2,     0,     0)   ;; 0xfb20   alt ayin
        (->decomp_C  0x5d0,     0,     0)   ;; 0xfb21   alt alef
        (->decomp_C  0x5d3,     0,     0)   ;; 0xfb22   alt dalet
        (->decomp_C  0x5d4,     0,     0)   ;; 0xfb23   alt he
        (->decomp_C  0x5db,     0,     0)   ;; 0xfb24   alt kaf
        (->decomp_C  0x5dc,     0,     0)   ;; 0xfb25   alt lamed
        (->decomp_C  0x5dd,     0,     0)   ;; 0xfb26   alt mem-sofit
        (->decomp_C  0x5e8,     0,     0)   ;; 0xfb27   alt resh
        (->decomp_C  0x5ea,     0,     0)   ;; 0xfb28   alt tav
        (->decomp_C (int \+),   0,     0)   ;; 0xfb29   alt plus
        (->decomp_C  0x5e9, 0x5c1,     0)   ;; 0xfb2a   shin+shin-dot
        (->decomp_C  0x5e9, 0x5c2,     0)   ;; 0xfb2b   shin+sin-dot
        (->decomp_C  0x5e9, 0x5c1, 0x5bc)   ;; 0xfb2c   shin+shin-dot+dagesh
        (->decomp_C  0x5e9, 0x5c2, 0x5bc)   ;; 0xfb2d   shin+sin-dot+dagesh
        (->decomp_C  0x5d0, 0x5b7,     0)   ;; 0xfb2e   alef+patah
        (->decomp_C  0x5d0, 0x5b8,     0)   ;; 0xfb2f   alef+qamats
        (->decomp_C  0x5d0, 0x5b4,     0)   ;; 0xfb30   alef+hiriq
        (->decomp_C  0x5d1, 0x5bc,     0)   ;; 0xfb31   bet+dagesh
        (->decomp_C  0x5d2, 0x5bc,     0)   ;; 0xfb32   gimel+dagesh
        (->decomp_C  0x5d3, 0x5bc,     0)   ;; 0xfb33   dalet+dagesh
        (->decomp_C  0x5d4, 0x5bc,     0)   ;; 0xfb34   he+dagesh
        (->decomp_C  0x5d5, 0x5bc,     0)   ;; 0xfb35   vav+dagesh
        (->decomp_C  0x5d6, 0x5bc,     0)   ;; 0xfb36   zayin+dagesh
        (->decomp_C 0xfb37,     0,     0)   ;; 0xfb37 - UNUSED
        (->decomp_C  0x5d8, 0x5bc,     0)   ;; 0xfb38   tet+dagesh
        (->decomp_C  0x5d9, 0x5bc,     0)   ;; 0xfb39   yud+dagesh
        (->decomp_C  0x5da, 0x5bc,     0)   ;; 0xfb3a   kaf sofit+dagesh
        (->decomp_C  0x5db, 0x5bc,     0)   ;; 0xfb3b   kaf+dagesh
        (->decomp_C  0x5dc, 0x5bc,     0)   ;; 0xfb3c   lamed+dagesh
        (->decomp_C 0xfb3d,     0,     0)   ;; 0xfb3d - UNUSED
        (->decomp_C  0x5de, 0x5bc,     0)   ;; 0xfb3e   mem+dagesh
        (->decomp_C 0xfb3f,     0,     0)   ;; 0xfb3f - UNUSED
        (->decomp_C  0x5e0, 0x5bc,     0)   ;; 0xfb40   nun+dagesh
        (->decomp_C  0x5e1, 0x5bc,     0)   ;; 0xfb41   samech+dagesh
        (->decomp_C 0xfb42,     0,     0)   ;; 0xfb42 - UNUSED
        (->decomp_C  0x5e3, 0x5bc,     0)   ;; 0xfb43   pe sofit+dagesh
        (->decomp_C  0x5e4, 0x5bc,     0)   ;; 0xfb44   pe+dagesh
        (->decomp_C 0xfb45,     0,     0)   ;; 0xfb45 - UNUSED
        (->decomp_C  0x5e6, 0x5bc,     0)   ;; 0xfb46   tsadi+dagesh
        (->decomp_C  0x5e7, 0x5bc,     0)   ;; 0xfb47   qof+dagesh
        (->decomp_C  0x5e8, 0x5bc,     0)   ;; 0xfb48   resh+dagesh
        (->decomp_C  0x5e9, 0x5bc,     0)   ;; 0xfb49   shin+dagesh
        (->decomp_C  0x5ea, 0x5bc,     0)   ;; 0xfb4a   tav+dagesh
        (->decomp_C  0x5d5, 0x5b9,     0)   ;; 0xfb4b   vav+holam
        (->decomp_C  0x5d1, 0x5bf,     0)   ;; 0xfb4c   bet+rafe
        (->decomp_C  0x5db, 0x5bf,     0)   ;; 0xfb4d   kaf+rafe
        (->decomp_C  0x5e4, 0x5bf,     0)   ;; 0xfb4e   pe+rafe
        (->decomp_C  0x5d0, 0x5dc,     0)   ;; 0xfb4f   alef-lamed
    ])

(defn- #_void mb_decompose [#_int c, #_int* c1, #_int* c2, #_int* c3]
    (ยง
        (cond (and (<= 0xfb20 c) (<= c 0xfb4f))
        (ยง
            ((ร decomp_C d =) (ยง decomp_table[c - 0xfb20]))
            ((ร c1[0] =) (. d a))
            ((ร c2[0] =) (. d b))
            ((ร c3[0] =) (. d c))
        )
        :else
        (ยง
            ((ร c1[0] =) c)
            ((ร c2[0] =) (ยง c3[0] = 0))
        ))
    ))

;; Compare two strings, ignore case if ireg_ic set.
;; Return 0 if strings match, non-zero otherwise.
;; Correct the length "*n" when composing characters are ignored.

(defn- #_int cstrncmp [#_Bytes s1, #_Bytes s2, #_int* n]
    (ยง
        (ร int result)

        (if (not @ireg_ic)
            ((ร result =) (ยง STRNCMP(s1, s2, n[0])))
            ((ร result =) (ยง us_strnicmp(s1, s2, n[0])))
        )

        ;; if it failed and it's utf8 and we want to combineignore
        (when (and (non-zero? result) @ireg_icombine)
; %%        ((ร Bytes[] str1 =) (ยง { s1 }))
; %%        ((ร Bytes[] str2 =) (ยง { s2 }))
            ((ร int c1 =) (ยง 0, c2 = 0))

            ;; We have to handle the strcmp() ourselves, since it is necessary
            ;; to deal with the composing characters by ignoring them.
            (while (ยง BDIFF(str1[0], s1) < n[0])
                ((ร c1 =) (us_ptr2char_adv str1, true))
                ((ร c2 =) (us_ptr2char_adv str2, true))

                ;; Decompose the character if necessary into 'base' characters,
                ;; because I don't care about Arabic, I will hard-code the Hebrew
                ;; which I *do* care about!  So sue me...
                (when (and (!= c1 c2) (or (not @ireg_ic) (!= (utf_fold c1) (utf_fold c2))))
                    ((ร int[] c11 =) (ยง new int[1]))
                    ((ร int[] c12 =) (ยง new int[1]))
                    ((ร int[] junk =) (ยง new int[1]))

                    ;; decomposition necessary?
                    (mb_decompose c1, c11, junk, junk)
                    (mb_decompose c2, c12, junk, junk)
                    ((ร c1 =) (ยง c11[0]))
                    ((ร c2 =) (ยง c12[0]))
                    (if (and (!= (ยง c11[0]) (ยง c12[0])) (or (not @ireg_ic) (!= (utf_fold (ยง c11[0])) (utf_fold (ยง c12[0])))))
                        (ร BREAK)
                    )
                )
            )
            ((ร result =) (- c2 c1))
            (if (zero? result)
                ((ร n[0] =) (ยง BDIFF(str2[0], s2)))
            )
        )

        result
    ))

;; This function is used a lot for simple searches, keep it fast!

(defn- #_Bytes cstrchr [#_Bytes s, #_int c]
    (ยง
        (if (not @ireg_ic)
            ((ร RETURN) (vim_strchr s, c))
        )

        (ร int cc)
        (cond (< 0x80 c)
        (ยง
            ((ร cc =) (utf_fold c))
        )
        (utf_isupper c)
        (ยง
            ((ร cc =) (utf_tolower c))
        )
        (utf_islower c)
        (ยง
            ((ร cc =) (utf_toupper c))
        )
        :else
        (ยง
            ((ร RETURN) (vim_strchr s, c))
        ))

        ((ร FOR) (ร (ยง Bytes p = s) (ยง p.at(0) != NUL) (ยง p = p.plus(us_ptr2len_cc(p))))
            (cond (< 0x80 c)
            (ยง
                (if (== (utf_fold (us_ptr2char p)) cc)
                    ((ร RETURN) p)
                )
            )
            (or (== (.at p 0) c) (== (.at p 0) cc))
            (ยง
                ((ร RETURN) p)
            ))
        )

        null
    ))

;; regsub stuff

;; We should define ftpr as a pointer to a function returning
;; a pointer to a function returning a pointer to a function ...
;; This is impossible, so we declare a pointer to a function
;; returning a pointer to a function returning void.

(ยง
;   static abstract class fptr_C
    (ยง
;       public abstract fptr_C flip(int[] d, int c);
    ))

;   static final fptr_C do_upper = new fptr_C()
;   {
;       public fptr_C flip(int[] d, int c) { d[0] = utf_toupper(c); return null; }
;   };

;   static final fptr_C do_Upper = new fptr_C()
;   {
;       public fptr_C flip(int[] d, int c) { d[0] = utf_toupper(c); return this; }
;   };

;   static final fptr_C do_lower = new fptr_C()
;   {
;       public fptr_C flip(int[] d, int c) { d[0] = utf_tolower(c); return null; }
;   };

;   static final fptr_C do_Lower = new fptr_C()
;   {
;       public fptr_C flip(int[] d, int c) { d[0] = utf_tolower(c); return this; }
;   };

;; regtilde(): Replace tildes in the pattern by the old pattern.
;;
;; Short explanation of the tilde: It stands for the previous replacement pattern.
;; If that previous pattern also contains a ~ we should go back a step further...
;; But we insert the previous pattern into the current one and remember that.
;; This still does not handle the case where "magic" changes.  So require the
;; user to keep his hands off of "magic".
;;
;; The tildes are parsed once before the first call to vim_regsub().

(defn- #_Bytes regtilde [#_Bytes source, #_boolean magic]
    (ยง
        ((ร Bytes newsub =) source)

        ((ร FOR) (ร (ยง Bytes p = newsub) (ยง p.at(0) != NUL) (ยง p = p.plus(1)))
            (cond (or (and (== (.at p 0) (byte \~)) magic) (and (== (.at p 0) (byte \\)) (== (.at p 1) (byte \~)) (not magic)))
            (ยง
                (cond (non-nil? @reg_prev_sub)
                (ยง
                    ;; length = len(newsub) - 1 + len(prev_sub) + 1
                    ((ร int prevlen =) (STRLEN @reg_prev_sub))
                    ((ร Bytes tmpsub =) (ยง new Bytes(STRLEN(newsub) + prevlen)))

                    ;; copy prefix
                    ((ร int len =) (BDIFF p, newsub))            ;; not including ~
                    (BCOPY tmpsub, newsub, len)
                    ;; interpret tilde
                    (BCOPY tmpsub, len, @reg_prev_sub, 0, prevlen)
                    ;; copy postfix
                    (if (not magic)
                        ((ร p =) (ยง p.plus(1)))                                ;; back off \
                    )
                    (STRCPY (.plus tmpsub (+ len prevlen)), (.plus p 1))

                    ((ร newsub =) tmpsub)
                    ((ร p =) (ยง newsub.plus(len + prevlen)))
                )
                magic
                (ยง
                    (BCOPY p, 0, p, 1, (+ (STRLEN p, 1) 1))   ;; remove '~'
                )
                :else
                (ยง
                    (BCOPY p, 0, p, 2, (+ (STRLEN p, 2) 1))   ;; remove '\~'
                ))
                ((ร p =) (ยง p.minus(1)))
            )
            :else
            (ยง
                (if (and (== (.at p 0) (byte \\)) (non-eos? p 1))        ;; skip escaped characters
                    ((ร p =) (ยง p.plus(1)))
                )
                ((ร p =) (ยง p.plus(us_ptr2len_cc(p) - 1)))
            ))
        )

        (if (BNE newsub, source)
            (reset! reg_prev_sub newsub)                    ;; "newsub" was allocated, just keep it
            (reset! reg_prev_sub (STRDUP newsub)))           ;; no ~ found, need to save "newsub"

        newsub
    ))

(atom! boolean can_f_submatch)          ;; true when submatch() can be used

;; These pointers are used instead of reg_match and reg_mmatch for reg_submatch().
;; Needed when the substitution string is an expression
;; that contains a call to substitute() and submatch().

(atom! regmatch_C       submatch_match)
(atom! regmmatch_C      submatch_mmatch)
(atom! long             submatch_firstlnum)
(atom! long             submatch_maxline)
(atom! boolean          submatch_line_lbr)

;; vim_regsub() - perform substitutions after a vim_regexec() or vim_regexec_multi() match.
;;
;; If "copy" is true really copy into "dest".
;; If "copy" is false nothing is copied, this is just to find out the length of the result.
;;
;; If "backslash" is true, a backslash will be removed later, need to double them to keep them,
;; and insert a backslash before a CR to avoid it being replaced with a line break later.
;;
;; Note: The matched text must not change between the call of vim_regexec()/vim_regexec_multi()
;; and vim_regsub()!  It would make the back references invalid!
;;
;; Returns the size of the replacement, including terminating NUL.

(defn- #_int vim_regsub [#_regmatch_C rmp, #_Bytes source, #_Bytes dest, #_boolean copy, #_boolean magic, #_boolean backslash]
    (ยง
        (reset! reg_match rmp)
        (reset! reg_mmatch null)
        (reset! reg_maxline 0)
        (reset! reg_buf @curbuf)
        (reset! reg_line_lbr true)

        (vim_regsub_both source, dest, copy, magic, backslash)
    ))

(defn- #_int vim_regsub_multi [#_regmmatch_C rmp, #_long lnum, #_Bytes source, #_Bytes dest, #_boolean copy, #_boolean magic, #_boolean backslash]
    (ยง
        (reset! reg_match null)
        (reset! reg_mmatch rmp)
        (reset! reg_buf @curbuf)           ;; always works on the current buffer!
        (reset! reg_firstlnum lnum)
        (reset! reg_maxline (- (.. @curbuf b_ml ml_line_count) lnum))
        (reset! reg_line_lbr false)

        (vim_regsub_both source, dest, copy, magic, backslash)
    ))

(atom! Bytes eval_result)

(defn- #_int vim_regsub_both [#_Bytes source, #_Bytes dest, #_boolean copy, #_boolean magic, #_boolean backslash]
    (ยง
        ;; Be paranoid...
        (when (or (nil? source) (nil? dest))
            (emsg e_null)
            ((ร RETURN) 0)
        )
        (if (prog_magic_wrong)
            ((ร RETURN) 0)
        )

        ((ร Bytes dst =) dest)

        ;; When the substitute part starts with "\=" evaluate it as an expression.

        (cond (and (== (.at source 0) (byte \\)) (== (.at source 1) (byte \=)) (not @can_f_submatch))   ;; can't do this recursively
        (ยง
            ;; To make sure that the length doesn't change between checking the length
            ;; and copying the string, and to speed up things, the resulting string is saved
            ;; from the call with "copy" == false to the call with "copy" == true.
            (cond copy
            (ยง
                (when (non-nil? @eval_result)
                    (STRCPY dest, @eval_result)
                    ((ร dst =) (ยง dst.plus(STRLEN(@eval_result))))
                    (reset! eval_result null)
                )
            )
            :else
            (ยง
                ;; The expression may contain substitute(), which calls us recursively.
                ;; Make sure submatch() gets the text from the first level.
                ;; Don't need to save "reg_buf", because vim_regexec_multi() can't be called recursively.

                (reset! submatch_match @reg_match)
                (reset! submatch_mmatch @reg_mmatch)
                (reset! submatch_firstlnum @reg_firstlnum)
                (reset! submatch_maxline @reg_maxline)
                (reset! submatch_line_lbr @reg_line_lbr)

                ((ร window_C save_reg_win =) @reg_win)
                ((ร boolean save_ireg_ic =) @ireg_ic)
                (reset! can_f_submatch true)

                (reset! eval_result (eval_to_string (.plus source 2), null))
                (when (non-nil? @eval_result)
                    ((ร boolean had_backslash =) false)

                    ((ร FOR) (ร (ยง Bytes s = @eval_result) (ยง s.at(0) != NUL) (ยง s = s.plus(us_ptr2len_cc(s))))
                        ;; Change NL to CR, so that it becomes a line break,
                        ;; unless called from vim_regexec_nl().
                        ;; Skip over a backslashed character.
                        (cond (and (== (.at s 0) NL) (not @submatch_line_lbr))
                        (ยง
                            (.be s 0, CAR)
                        )
                        (and (== (.at s 0) (byte \\)) (non-eos? s 1))
                        (ยง
                            ((ร s =) (ยง s.plus(1)))
                            ;; Change NL to CR here too, so that this works:
                            ;; :s/abc\\\ndef/\="aaa\\\nbbb"/  on text:
                            ;;   abc\
                            ;;   def
                            ;; Not when called from vim_regexec_nl().

                            (if (and (== (.at s 0) NL) (not @submatch_line_lbr))
                                (.be s 0, CAR)
                            )
                            ((ร had_backslash =) true)
                        ))
                    )
                    (when (and had_backslash backslash)
                        ;; Backslashes will be consumed, need to double them.
                        (reset! eval_result (vim_strsave_escaped @eval_result, (u8 "\\")))
                    )

                    ((ร dst =) (ยง dst.plus(STRLEN(@eval_result))))
                )

                (reset! reg_match @submatch_match)
                (reset! reg_mmatch @submatch_mmatch)
                (reset! reg_firstlnum @submatch_firstlnum)
                (reset! reg_maxline @submatch_maxline)
                (reset! reg_line_lbr @submatch_line_lbr)
                (reset! reg_win save_reg_win)
                (reset! ireg_ic save_ireg_ic)
                (reset! can_f_submatch false)
            ))
        )
        :else
        (ยง
            ((ร fptr_C func_one =) null)
            ((ร fptr_C func_all =) null)

            ((ร int no =) -1)
            ((ร long clnum =) 0)
            ((ร int len =) 0)

            ((ร Bytes src =) source)

            ((ร FOR) (ร (ยง byte b) (ยง (b = (src = src.plus(1)).at(-1)) != NUL) nil)
                (cond (and (== b (byte \&)) magic)
                (ยง
                    ((ร no =) 0)
                )
                (and (== b (byte \\)) (non-eos? src))
                (ยง
                    (cond (and (== (.at src 0) (byte \&)) (not magic))
                    (ยง
                        ((ร src =) (ยง src.plus(1)))
                        ((ร no =) 0)
                    )
                    (and (<= (byte \0) (.at src 0)) (<= (.at src 0) (byte \9)))
                    (ยง
                        ((ร no =) (ยง (src = src.plus(1)).at(-1) - (byte \0)))
                    )
                    (non-nil? (vim_strbyte (u8 "uUlLeE"), (.at src 0)))
                    (ยง
                        ((ร SWITCH) (ยง (src = src.plus(1)).at(-1))
                            ((ร CASE) (byte \u))
                            (ยง
                                ((ร func_one =) do_upper)
                                (ร CONTINUE)
                            )
                            ((ร CASE) (byte \U))
                            (ยง
                                ((ร func_all =) do_Upper)
                                (ร CONTINUE)
                            )
                            ((ร CASE) (byte \l))
                            (ยง
                                ((ร func_one =) do_lower)
                                (ร CONTINUE)
                            )
                            ((ร CASE) (byte \L))
                            (ยง
                                ((ร func_all =) do_Lower)
                                (ร CONTINUE)
                            )
                            ((ร CASE) (byte \e))
                            ((ร CASE) (byte \E))
                            (ยง
                                ((ร func_one =) null)
                                ((ร func_all =) null)
                                (ร CONTINUE)
                            )
                        )
                    ))
                ))
                (cond (< no 0)             ;; Ordinary character.
                (ยง
                    (when (and (== b KB_SPECIAL) (non-eos? src) (non-eos? src 1))
                        ;; Copy a special key as-is.
                        (cond copy
                        (ยง
                            (ยง (dst = dst.plus(1)).be(-1, b))
                            (ยง (dst = dst.plus(1)).be(-1, (src = src.plus(1)).at(-1)))
                            (ยง (dst = dst.plus(1)).be(-1, (src = src.plus(1)).at(-1)))
                        )
                        :else
                        (ยง
                            ((ร dst =) (ยง dst.plus(3)))
                            ((ร src =) (ยง src.plus(2)))
                        ))
                        (ร CONTINUE)
                    )

                    (ร int c)
                    (cond (and (== b (byte \\)) (non-eos? src))
                    (ยง
                        ;; Check for abbreviations.
                        ((ร SWITCH) (ยง src.at(0))
                            ((ร CASE) (byte \r))
                            (ยง
                                ((ร b =) CAR)
                                ((ร src =) (ยง src.plus(1)))
                                (ร BREAK)
                            )
                            ((ร CASE) (byte \n))
                            (ยง
                                ((ร b =) NL)
                                ((ร src =) (ยง src.plus(1)))
                                (ร BREAK)
                            )
                            ((ร CASE) (byte \t))
                            (ยง
                                ((ร b =) TAB)
                                ((ร src =) (ยง src.plus(1)))
                                (ร BREAK)
                            )
                         ;; case (byte \e):     ;; Oh no!  \e already has meaning in subst pat.
                         ;; {
                         ;;     b = ESC;
                         ;;     src = src.plus(1);
                         ;;     break;
                         ;; }
                            ((ร CASE) (byte \b))
                            (ยง
                                ((ร b =) Ctrl_H)
                                ((ร src =) (ยง src.plus(1)))
                                (ร BREAK)
                            )

                            ;; If "backslash" is true the backslash will be removed later.
                            ;; Used to insert a literal CR.
                            (ร DEFAULT)
                            (ยง
                                (when backslash
                                    (if copy
                                        (.be dst 0, (byte \\))
                                    )
                                    ((ร dst =) (ยง dst.plus(1)))
                                )
                                ((ร b =) (ยง (src = src.plus(1)).at(-1)))
                                (ร BREAK)
                            )
                        )
                        ((ร c =) (char_u b))
                    )
                    :else
                    (ยง
                        ((ร c =) (ยง us_ptr2char(src.minus(1))))
                    ))

                    ;; Write to buffer, if copy is set.
                    ((ร int[] cc =) (ยง new int[1]))
                    (cond (non-nil? func_one)
                    (ยง
                        ((ร func_one =) (ยง func_one.flip(cc, c)))
                    )
                    (non-nil? func_all)
                    (ยง
                        ((ร func_all =) (ยง func_all.flip(cc, c)))
                    )
                    :else ;; just copy
                    (ยง
                        ((ร cc[0] =) c)
                    ))

                    ((ร int totlen =) (ยง us_ptr2len_cc(src.minus(1))))

                    (if copy
                        (utf_char2bytes (ยง cc[0]), dst))
                    ((ร dst =) (ยง dst.plus(utf_char2len(cc[0]) - 1)))

                    ((ร int clen =) (ยง us_ptr2len(src.minus(1))))

                    ;; If the character length is shorter than "totlen",
                    ;; there are composing characters; copy them as-is.
                    (when (< clen totlen)
                        (if copy
                            (BCOPY dst, 1, src, (+ -1 clen), (- totlen clen)))
                        ((ร dst =) (ยง dst.plus(totlen - clen)))
                    )

                    ((ร src =) (ยง src.plus(totlen - 1)))

                    ((ร dst =) (ยง dst.plus(1)))
                )
                :else
                (ยง
                    (ร Bytes s)
                    (cond (nil? @reg_match)
                    (ยง
                        ((ร clnum =) (ยง @reg_mmatch.startpos[no].lnum))
                        (cond (or (< clnum 0) (< (ยง @reg_mmatch.endpos[no].lnum) 0))
                        (ยง
                            ((ร s =) null)
                        )
                        :else
                        (ยง
                            ((ร s =) (ยง reg_getline(clnum).plus(@reg_mmatch.startpos[no].col)))
                            (if (== (ยง @reg_mmatch.endpos[no].lnum) clnum)
                                ((ร len =) (ยง @reg_mmatch.endpos[no].col - @reg_mmatch.startpos[no].col))
                                ((ร len =) (STRLEN s))
                            )
                        ))
                    )
                    :else
                    (ยง
                        ((ร s =) (ยง @reg_match.startp[no]))
                        (if (nil? (ยง @reg_match.endp[no]))
                            ((ร s =) null)
                            ((ร len =) (ยง BDIFF(@reg_match.endp[no], s)))
                        )
                    ))
                    (when (non-nil? s)
                        (while true
                            (cond (zero? len)
                            (ยง
                                (cond (nil? @reg_match)
                                (ยง
                                    (if (== (ยง @reg_mmatch.endpos[no].lnum) clnum)
                                        (ร BREAK)
                                    )
                                    (if copy
                                        (.be dst 0, CAR)
                                    )
                                    ((ร dst =) (ยง dst.plus(1)))
                                    ((ร s =) (ยง reg_getline(++clnum)))
                                    (if (== (ยง @reg_mmatch.endpos[no].lnum) clnum)
                                        ((ร len =) (ยง @reg_mmatch.endpos[no].col))
                                        ((ร len =) (STRLEN s))
                                    )
                                )
                                :else
                                (ยง
                                    (ร BREAK)
                                ))
                            )
                            (eos? s)
                            (ยง
                                (if copy
                                    (emsg e_re_damg))
                                ((ร RETURN) (ยง BDIFF(dst, dest) + 1))
                            )
                            :else
                            (ยง
                                (cond (and backslash (or (== (.at s 0) CAR) (== (.at s 0) (byte \\))))
                                (ยง
                                    ;; Insert a backslash in front of a CR,
                                    ;; otherwise it will be replaced by a line break.
                                    ;; Number of backslashes will be halved later, double them here.

                                    (when copy
                                        (.be dst 0, (byte \\))
                                        (.be dst 1, (ยง s.at(0)))
                                    )
                                    ((ร dst =) (ยง dst.plus(2)))
                                )
                                :else
                                (ยง
                                    ((ร int c =) (us_ptr2char s))

                                    ((ร int[] cc =) (ยง new int[1]))
                                    (cond (non-nil? func_one)
                                    (ยง
                                        ((ร func_one =) (ยง func_one.flip(cc, c)))
                                    )
                                    (non-nil? func_all)
                                    (ยง
                                        ((ร func_all =) (ยง func_all.flip(cc, c)))
                                    )
                                    :else ;; just copy
                                    (ยง
                                        ((ร cc[0] =) c)
                                    ))

                                    ;; Copy composing characters separately, one at a time.
                                    ((ร int l =) (ยง us_ptr2len(s) - 1))

                                    ((ร s =) (ยง s.plus(l)))
                                    ((ร len -=) l)
                                    (if copy
                                        (utf_char2bytes (ยง cc[0]), dst))
                                    ((ร dst =) (ยง dst.plus(utf_char2len(cc[0]) - 1)))

                                    ((ร dst =) (ยง dst.plus(1)))
                                ))

                                ((ร s =) (ยง s.plus(1)))
                                (ยง --len)
                            ))
                        )
                    )
                    ((ร no =) -1)
                ))
            )
        ))

        (if copy
            (.be dst 0, NUL)
        )

        (+ (BDIFF dst, dest) 1)
    ))

;;; ============================================================================================== VimO

;; NFA regular expression implementation.

;; Added to NFA_ANY - NFA_NUPPER_IC to include a NL.
(final int NFA_ADD_NL 31)

(final int
    NFA_SPLIT -1024,
    NFA_MATCH -1023,
    NFA_EMPTY -1022,                      ;; matches 0-length

    NFA_START_COLL -1021,                 ;; [abc] start
    NFA_END_COLL -1020,                   ;; [abc] end
    NFA_START_NEG_COLL -1019,             ;; [^abc] start
    NFA_END_NEG_COLL -1018,               ;; [^abc] end (postfix only)
    NFA_RANGE -1017,                      ;; range of the two previous items (postfix only)
    NFA_RANGE_MIN -1016,                  ;; low end of a range
    NFA_RANGE_MAX -1015,                  ;; high end of a range

    NFA_CONCAT -1014,                     ;; concatenate two previous items (postfix only)
    NFA_OR -1013,                         ;; \| (postfix only)
    NFA_STAR -1012,                       ;; greedy * (posfix only)
    NFA_STAR_NONGREEDY -1011,             ;; non-greedy * (postfix only)
    NFA_QUEST -1010,                      ;; greedy \? (postfix only)
    NFA_QUEST_NONGREEDY -1009,            ;; non-greedy \? (postfix only)

    NFA_BOL -1008,                        ;; ^    Begin line
    NFA_EOL -1007,                        ;; $    End line
    NFA_BOW -1006,                        ;; \<   Begin word
    NFA_EOW -1005,                        ;; \>   End word
    NFA_BOF -1004,                        ;; \%^  Begin file
    NFA_EOF -1003,                        ;; \%$  End file
    NFA_NEWL -1002,
    NFA_ZSTART -1001,                     ;; Used for \zs
    NFA_ZEND -1000,                       ;; Used for \ze
    NFA_NOPEN -999,                       ;; Start of subexpression marked with \%(
    NFA_NCLOSE -998,                      ;; End of subexpr. marked with \%( ... \)
    NFA_START_INVISIBLE -997,
    NFA_START_INVISIBLE_FIRST -996,
    NFA_START_INVISIBLE_NEG -995,
    NFA_START_INVISIBLE_NEG_FIRST -994,
    NFA_START_INVISIBLE_BEFORE -993,
    NFA_START_INVISIBLE_BEFORE_FIRST -992,
    NFA_START_INVISIBLE_BEFORE_NEG -991,
    NFA_START_INVISIBLE_BEFORE_NEG_FIRST -990,
    NFA_START_PATTERN -989,
    NFA_END_INVISIBLE -988,
    NFA_END_INVISIBLE_NEG -987,
    NFA_END_PATTERN -986,
    NFA_COMPOSING -985,                   ;; Next nodes in NFA are part of the composing multibyte char
    NFA_END_COMPOSING -984,               ;; End of a composing char in the NFA
    NFA_ANY_COMPOSING -983,               ;; \%C: Any composing characters.
    NFA_OPT_CHARS -982,                   ;; \%[abc]

    ;; The following are used only in the postfix form, not in the NFA.
    NFA_PREV_ATOM_NO_WIDTH -981,          ;; Used for \@=
    NFA_PREV_ATOM_NO_WIDTH_NEG -980,      ;; Used for \@!
    NFA_PREV_ATOM_JUST_BEFORE -979,       ;; Used for \@<=
    NFA_PREV_ATOM_JUST_BEFORE_NEG -978,   ;; Used for \@<!
    NFA_PREV_ATOM_LIKE_PATTERN -977,      ;; Used for \@>

    NFA_BACKREF1 -976,                    ;; \1
    NFA_BACKREF2 -975,                    ;; \2
    NFA_BACKREF3 -974,                    ;; \3
    NFA_BACKREF4 -973,                    ;; \4
    NFA_BACKREF5 -972,                    ;; \5
    NFA_BACKREF6 -971,                    ;; \6
    NFA_BACKREF7 -970,                    ;; \7
    NFA_BACKREF8 -969,                    ;; \8
    NFA_BACKREF9 -968,                    ;; \9
    NFA_ZREF1 -967,                       ;; \z1
    NFA_ZREF2 -966,                       ;; \z2
    NFA_ZREF3 -965,                       ;; \z3
    NFA_ZREF4 -964,                       ;; \z4
    NFA_ZREF5 -963,                       ;; \z5
    NFA_ZREF6 -962,                       ;; \z6
    NFA_ZREF7 -961,                       ;; \z7
    NFA_ZREF8 -960,                       ;; \z8
    NFA_ZREF9 -959,                       ;; \z9
    NFA_SKIP -958,                        ;; Skip characters

    NFA_MOPEN -957,
    NFA_MOPEN1 -956,
    NFA_MOPEN2 -955,
    NFA_MOPEN3 -954,
    NFA_MOPEN4 -953,
    NFA_MOPEN5 -952,
    NFA_MOPEN6 -951,
    NFA_MOPEN7 -950,
    NFA_MOPEN8 -949,
    NFA_MOPEN9 -948,

    NFA_MCLOSE -947,
    NFA_MCLOSE1 -946,
    NFA_MCLOSE2 -945,
    NFA_MCLOSE3 -944,
    NFA_MCLOSE4 -943,
    NFA_MCLOSE5 -942,
    NFA_MCLOSE6 -941,
    NFA_MCLOSE7 -940,
    NFA_MCLOSE8 -939,
    NFA_MCLOSE9 -938,

    NFA_ZOPEN -937,
    NFA_ZOPEN1 -936,
    NFA_ZOPEN2 -935,
    NFA_ZOPEN3 -934,
    NFA_ZOPEN4 -933,
    NFA_ZOPEN5 -932,
    NFA_ZOPEN6 -931,
    NFA_ZOPEN7 -930,
    NFA_ZOPEN8 -929,
    NFA_ZOPEN9 -928,

    NFA_ZCLOSE -927,
    NFA_ZCLOSE1 -926,
    NFA_ZCLOSE2 -925,
    NFA_ZCLOSE3 -924,
    NFA_ZCLOSE4 -923,
    NFA_ZCLOSE5 -922,
    NFA_ZCLOSE6 -921,
    NFA_ZCLOSE7 -920,
    NFA_ZCLOSE8 -919,
    NFA_ZCLOSE9 -918,

    ;; NFA_FIRST_NL
    NFA_ANY -917,                        ;; Match any one character.
    NFA_IDENT -916,                      ;; Match identifier char
    NFA_SIDENT -915,                     ;; Match identifier char but no digit
    NFA_KWORD -914,                      ;; Match keyword char
    NFA_SKWORD -913,                     ;; Match word char but no digit
    NFA_FNAME -912,                      ;; Match file name char
    NFA_SFNAME -911,                     ;; Match file name char but no digit
    NFA_PRINT -910,                      ;; Match printable char
    NFA_SPRINT -909,                     ;; Match printable char but no digit
    NFA_WHITE -908,                      ;; Match whitespace char
    NFA_NWHITE -907,                     ;; Match non-whitespace char
    NFA_DIGIT -906,                      ;; Match digit char
    NFA_NDIGIT -905,                     ;; Match non-digit char
    NFA_HEX -904,                        ;; Match hex char
    NFA_NHEX -903,                       ;; Match non-hex char
    NFA_OCTAL -902,                      ;; Match octal char
    NFA_NOCTAL -901,                     ;; Match non-octal char
    NFA_WORD -900,                       ;; Match word char
    NFA_NWORD -899,                      ;; Match non-word char
    NFA_HEAD -898,                       ;; Match head char
    NFA_NHEAD -897,                      ;; Match non-head char
    NFA_ALPHA -896,                      ;; Match alpha char
    NFA_NALPHA -895,                     ;; Match non-alpha char
    NFA_LOWER -894,                      ;; Match lowercase char
    NFA_NLOWER -893,                     ;; Match non-lowercase char
    NFA_UPPER -892,                      ;; Match uppercase char
    NFA_NUPPER -891,                     ;; Match non-uppercase char
    NFA_LOWER_IC -890,                   ;; Match [a-z]
    NFA_NLOWER_IC -889,                  ;; Match [^a-z]
    NFA_UPPER_IC -888,                   ;; Match [A-Z]
    NFA_NUPPER_IC -887,                  ;; Match [^A-Z]

    NFA_FIRST_NL (+ NFA_ANY NFA_ADD_NL),
    NFA_LAST_NL (+ NFA_NUPPER_IC NFA_ADD_NL),

    NFA_CURSOR -855,                     ;; Match cursor pos
    NFA_LNUM -854,                       ;; Match line number
    NFA_LNUM_GT -853,                    ;; Match > line number
    NFA_LNUM_LT -852,                    ;; Match < line number
    NFA_COL -851,                        ;; Match cursor column
    NFA_COL_GT -850,                     ;; Match > cursor column
    NFA_COL_LT -849,                     ;; Match < cursor column
    NFA_VCOL -848,                       ;; Match cursor virtual column
    NFA_VCOL_GT -847,                    ;; Match > cursor virtual column
    NFA_VCOL_LT -846,                    ;; Match < cursor virtual column
    NFA_MARK -845,                       ;; Match mark
    NFA_MARK_GT -844,                    ;; Match > mark
    NFA_MARK_LT -843,                    ;; Match < mark
    NFA_VISUAL -842,                     ;; Match Visual area

    ;; Character classes [:alnum:] etc.
    NFA_CLASS_ALNUM -841,
    NFA_CLASS_ALPHA -840,
    NFA_CLASS_BLANK -839,
    NFA_CLASS_CNTRL -838,
    NFA_CLASS_DIGIT -837,
    NFA_CLASS_GRAPH -836,
    NFA_CLASS_LOWER -835,
    NFA_CLASS_PRINT -834,
    NFA_CLASS_PUNCT -833,
    NFA_CLASS_SPACE -832,
    NFA_CLASS_UPPER -831,
    NFA_CLASS_XDIGIT -830,
    NFA_CLASS_TAB -829,
    NFA_CLASS_RETURN -828,
    NFA_CLASS_BACKSPACE -827,
    NFA_CLASS_ESCAPE -826)

;; Keep in sync with "classchars".
(final int* nfa_classcodes
    [
        NFA_ANY, NFA_IDENT, NFA_SIDENT, NFA_KWORD, NFA_SKWORD,
        NFA_FNAME, NFA_SFNAME, NFA_PRINT, NFA_SPRINT,
        NFA_WHITE, NFA_NWHITE, NFA_DIGIT, NFA_NDIGIT,
        NFA_HEX, NFA_NHEX, NFA_OCTAL, NFA_NOCTAL,
        NFA_WORD, NFA_NWORD, NFA_HEAD, NFA_NHEAD,
        NFA_ALPHA, NFA_NALPHA, NFA_LOWER, NFA_NLOWER,
        NFA_UPPER, NFA_NUPPER
    ])

(final Bytes e_nul_found       (u8 "E865: (NFA) Regexp end encountered prematurely"))
(final Bytes e_misplaced       (u8 "E866: (NFA regexp) Misplaced %c"))
(final Bytes e_ill_char_class  (u8 "E877: (NFA regexp) Invalid character class: %ld"))

;; re_flags passed to nfa_regcomp()
(atom! int nfa_re_flags)

;; NFA regexp \ze operator encountered.
(atom! boolean nfa_has_zend)

;; NFA regexp \1 .. \9 encountered.
(atom! boolean nfa_has_backref)

;; NFA regexp has \z( ), set zsubexpr.
(atom! boolean nfa_has_zsubexpr)

;; Number of sub expressions actually being used during execution.
;; 1 if only the whole match (subexpr 0) is used.

(atom! int nfa_nsubexpr)

(atom! int* post_array)    ;; holds the postfix form of r.e.
(atom! int post_index)

;; If not null match must end at this position.
(atom! save_se_C nfa_endp)

;; 'listid' is global, so that it increases on recursive calls to nfa_regmatch(),
;; which means we don't have to clear the lastlist field of all the states.

(atom! int nfa_listid)
(atom! int nfa_alt_listid)

;; 0 for first call to nfa_regmatch(), 1 for recursive call.
(atom! int nfa_ll_index)

;; Initialize internal variables before NFA compilation.
;; Return true on success, false otherwise.

(defn- #_void nfa_regcomp_start [#_Bytes expr, #_int re_flags]
    ;; re_flags: see vim_regcomp()
    (ยง
        ;; A reasonable estimation for maximum size.
        ((ร int nstate_max =) (ยง (STRLEN(expr) + 1) * 25))

        ;; Some items blow up in size, such as [A-z].  Add more space for that.
        ;; When it is still not enough grow_post_array() will be used.
        ((ร nstate_max +=) 1000)

        (reset! post_array (ยง new int[nstate_max]))
        (reset! post_index 0)

        (reset! nfa_has_zend false)
        (reset! nfa_has_backref false)

        ;; shared with BT engine
        (regcomp_start expr, re_flags)
    ))

;; Figure out if the NFA state list starts with an anchor, must match at start of the line.

(defn- #_boolean nfa_get_reganch [#_nfa_state_C start, #_int depth]
    (ยง
        (if (< 4 depth)
            ((ร RETURN) false)
        )

        ((ร FOR) (ร (ยง nfa_state_C p = start) (!= p null) nil)
            ((ร SWITCH) (. p c)
                ((ร CASE) NFA_BOL)
                ((ร CASE) NFA_BOF)
                (ยง
                    ((ร RETURN) true) ;; yes!
                )

                ((ร CASE) NFA_ZSTART)
                ((ร CASE) NFA_ZEND)
                ((ร CASE) NFA_CURSOR)
                ((ร CASE) NFA_VISUAL)

                ((ร CASE) NFA_MOPEN)
                ((ร CASE) NFA_MOPEN1)
                ((ร CASE) NFA_MOPEN2)
                ((ร CASE) NFA_MOPEN3)
                ((ร CASE) NFA_MOPEN4)
                ((ร CASE) NFA_MOPEN5)
                ((ร CASE) NFA_MOPEN6)
                ((ร CASE) NFA_MOPEN7)
                ((ร CASE) NFA_MOPEN8)
                ((ร CASE) NFA_MOPEN9)
                ((ร CASE) NFA_NOPEN)
                ((ร CASE) NFA_ZOPEN)
                ((ร CASE) NFA_ZOPEN1)
                ((ร CASE) NFA_ZOPEN2)
                ((ร CASE) NFA_ZOPEN3)
                ((ร CASE) NFA_ZOPEN4)
                ((ร CASE) NFA_ZOPEN5)
                ((ร CASE) NFA_ZOPEN6)
                ((ร CASE) NFA_ZOPEN7)
                ((ร CASE) NFA_ZOPEN8)
                ((ร CASE) NFA_ZOPEN9)
                (ยง
                    ((ร p =) (ยง p.out0()))
                    (ร BREAK)
                )

                ((ร CASE) NFA_SPLIT)
                (ยง
                    ((ร RETURN) (ยง nfa_get_reganch(p.out0(), depth + 1) && nfa_get_reganch(p.out1(), depth + 1)))
                )

                (ร DEFAULT)
                (ยง
                    ((ร RETURN) false) ;; noooo!
                )
            )
        )

        false
    ))

;; Figure out if the NFA state list starts with a character which must match at start of the match.

(defn- #_int nfa_get_regstart [#_nfa_state_C start, #_int depth]
    (ยง
        (if (< 4 depth)
            ((ร RETURN) 0)
        )

        ((ร FOR) (ร (ยง nfa_state_C p = start) (!= p null) nil)
            ((ร SWITCH) (. p c)
                ;; all kinds of zero-width matches
                ((ร CASE) NFA_BOL)
                ((ร CASE) NFA_BOF)
                ((ร CASE) NFA_BOW)
                ((ร CASE) NFA_EOW)
                ((ร CASE) NFA_ZSTART)
                ((ร CASE) NFA_ZEND)
                ((ร CASE) NFA_CURSOR)
                ((ร CASE) NFA_VISUAL)
                ((ร CASE) NFA_LNUM)
                ((ร CASE) NFA_LNUM_GT)
                ((ร CASE) NFA_LNUM_LT)
                ((ร CASE) NFA_COL)
                ((ร CASE) NFA_COL_GT)
                ((ร CASE) NFA_COL_LT)
                ((ร CASE) NFA_VCOL)
                ((ร CASE) NFA_VCOL_GT)
                ((ร CASE) NFA_VCOL_LT)
                ((ร CASE) NFA_MARK)
                ((ร CASE) NFA_MARK_GT)
                ((ร CASE) NFA_MARK_LT)

                ((ร CASE) NFA_MOPEN)
                ((ร CASE) NFA_MOPEN1)
                ((ร CASE) NFA_MOPEN2)
                ((ร CASE) NFA_MOPEN3)
                ((ร CASE) NFA_MOPEN4)
                ((ร CASE) NFA_MOPEN5)
                ((ร CASE) NFA_MOPEN6)
                ((ร CASE) NFA_MOPEN7)
                ((ร CASE) NFA_MOPEN8)
                ((ร CASE) NFA_MOPEN9)
                ((ร CASE) NFA_NOPEN)
                ((ร CASE) NFA_ZOPEN)
                ((ร CASE) NFA_ZOPEN1)
                ((ร CASE) NFA_ZOPEN2)
                ((ร CASE) NFA_ZOPEN3)
                ((ร CASE) NFA_ZOPEN4)
                ((ร CASE) NFA_ZOPEN5)
                ((ร CASE) NFA_ZOPEN6)
                ((ร CASE) NFA_ZOPEN7)
                ((ร CASE) NFA_ZOPEN8)
                ((ร CASE) NFA_ZOPEN9)
                (ยง
                    ((ร p =) (ยง p.out0()))
                    (ร BREAK)
                )

                ((ร CASE) NFA_SPLIT)
                (ยง
                    ((ร int c1 =) (ยง nfa_get_regstart(p.out0(), depth + 1)))
                    ((ร int c2 =) (ยง nfa_get_regstart(p.out1(), depth + 1)))

                    (if (== c1 c2)
                        ((ร RETURN) c1)      ;; yes!
                        ((ร RETURN) 0)
                    )
                )

                (ร DEFAULT)
                (ยง
                    (if (< 0 (. p c))
                        ((ร RETURN) (. p c))     ;; yes!
                        ((ร RETURN) 0)
                    )
                )
            )
        )

        0
    ))

;; Figure out if the NFA state list contains just literal text and nothing else.
;; If so return a string in allocated memory with what must match after regstart.
;; Otherwise return null.

(defn- #_Bytes nfa_get_match_text [#_nfa_state_C start]
    (ยง
        ((ร nfa_state_C p =) start)
        (if (!= (. p c) NFA_MOPEN)
            ((ร RETURN) null)                ;; just in case
        )
        ((ร p =) (ยง p.out0()))

        ((ร int len =) 0)
        (while (ยง 0 < p.c)
            ((ร len +=) (ยง utf_char2len(p.c)))
            ((ร p =) (ยง p.out0()))
        )

        (if (or (!= (. p c) NFA_MCLOSE) (!= (ยง p.out0().c) NFA_MATCH))
            ((ร RETURN) null)
        )

        ((ร Bytes ret =) (ยง new Bytes(len)))

        ((ร p =) (ยง start.out0().out0()))    ;; skip first char, it goes into regstart
        ((ร Bytes s =) ret)
        (while (ยง 0 < p.c)
            ((ร s =) (ยง s.plus(utf_char2bytes(p.c, s))))
            ((ร p =) (ยง p.out0()))
        )
        (.be s 0, NUL)

        ret
    ))

;; Allocate more space for post_array.
;; Called when running above the estimated number of states.

(defn- #_void grow_post_array [#_int more]
    (ยง
        (reset! post_array (ยง Arrays.copyOf(@post_array, @post_array.length + more)))
    ))

;; Search between "start" and "end" and try to recognize a character class in expanded form.
;; For example [0-9].
;; On success, return the id the character class to be emitted.
;; On failure, return 0 (=false).
;; Start points to the first char of the range, while end should point to the closing brace.
;; Keep in mind that 'ignorecase' applies at execution time,
;; thus [a-z] may need to be interpreted as [a-zA-Z].

(final int
    CLASS_not        0x80,
    CLASS_af         0x40,
    CLASS_AF         0x20,
    CLASS_az         0x10,
    CLASS_AZ         0x08,
    CLASS_o7         0x04,
    CLASS_o9         0x02,
    CLASS_underscore 0x01)

(defn- #_int nfa_recognize_char_class [#_Bytes start, #_Bytes end, #_boolean newl]
    (ยง
        ((ร int config =) 0)

        (if (!= (.at end 0) (byte \]))
            ((ร RETURN) 0)
        )

        ((ร Bytes p =) start)
        (when (== (.at p 0) (byte \^))
            ((ร config |=) CLASS_not)
            ((ร p =) (ยง p.plus(1)))
        )

        (while (BLT p, end)
            (cond (and (BLT (.plus p 2), end) (== (.at p 1) (byte \-)))
            (ยง
                ((ร SWITCH) (ยง p.at(0))
                    ((ร CASE) (byte \0))
                    (ยง
                        (cond (== (.at p 2) (byte \9))
                        (ยง
                            ((ร config |=) CLASS_o9)
                            (ร BREAK)
                        )
                        (== (.at p 2) (byte \7))
                        (ยง
                            ((ร config |=) CLASS_o7)
                            (ร BREAK)
                        ))
                        (ร FALLTHROUGH)
                    )
                    ((ร CASE) (byte \a))
                    (ยง
                        (cond (== (.at p 2) (byte \z))
                        (ยง
                            ((ร config |=) CLASS_az)
                            (ร BREAK)
                        )
                        (== (.at p 2) (byte \f))
                        (ยง
                            ((ร config |=) CLASS_af)
                            (ร BREAK)
                        ))
                        (ร FALLTHROUGH)
                    )
                    ((ร CASE) (byte \A))
                    (ยง
                        (cond (== (.at p 2) (byte \Z))
                        (ยง
                            ((ร config |=) CLASS_AZ)
                            (ร BREAK)
                        )
                        (== (.at p 2) (byte \F))
                        (ยง
                            ((ร config |=) CLASS_AF)
                            (ร BREAK)
                        ))
                        (ร FALLTHROUGH)
                    )
                    (ร DEFAULT)
                    (ยง
                        ((ร RETURN) 0)
                    )
                )
                ((ร p =) (ยง p.plus(3)))
            )
            (and (BLT (.plus p 1), end) (== (.at p 0) (byte \\)) (== (.at p 1) (byte \n)))
            (ยง
                ((ร newl =) true)
                ((ร p =) (ยง p.plus(2)))
            )
            (== (.at p 0) (byte \_))
            (ยง
                ((ร config |=) CLASS_underscore)
                ((ร p =) (ยง p.plus(1)))
            )
            (== (.at p 0) (byte \newline))
            (ยง
                ((ร newl =) true)
                ((ร p =) (ยง p.plus(1)))
            )
            :else
            (ยง
                ((ร RETURN) 0)
            ))
        )

        (if (BNE p, end)
            ((ร RETURN) 0)
        )

        ((ร int nfa_add_nl =) (if newl NFA_ADD_NL 0))

        ((ร SWITCH) config
            ((ร CASE) CLASS_o9)
            (ยง
                ((ร RETURN) (+ nfa_add_nl NFA_DIGIT))
            )
            ((ร CASE) (| CLASS_not CLASS_o9))
            (ยง
                ((ร RETURN) (+ nfa_add_nl NFA_NDIGIT))
            )
            ((ร CASE) (ยง CLASS_af | CLASS_AF | CLASS_o9))
            (ยง
                ((ร RETURN) (+ nfa_add_nl NFA_HEX))
            )
            ((ร CASE) (ยง CLASS_not | CLASS_af | CLASS_AF | CLASS_o9))
            (ยง
                ((ร RETURN) (+ nfa_add_nl NFA_NHEX))
            )
            ((ร CASE) CLASS_o7)
            (ยง
                ((ร RETURN) (+ nfa_add_nl NFA_OCTAL))
            )
            ((ร CASE) (| CLASS_not CLASS_o7))
            (ยง
                ((ร RETURN) (+ nfa_add_nl NFA_NOCTAL))
            )
            ((ร CASE) (ยง CLASS_az | CLASS_AZ | CLASS_o9 | CLASS_underscore))
            (ยง
                ((ร RETURN) (+ nfa_add_nl NFA_WORD))
            )
            ((ร CASE) (ยง CLASS_not | CLASS_az | CLASS_AZ | CLASS_o9 | CLASS_underscore))
            (ยง
                ((ร RETURN) (+ nfa_add_nl NFA_NWORD))
            )
            ((ร CASE) (ยง CLASS_az | CLASS_AZ | CLASS_underscore))
            (ยง
                ((ร RETURN) (+ nfa_add_nl NFA_HEAD))
            )
            ((ร CASE) (ยง CLASS_not | CLASS_az | CLASS_AZ | CLASS_underscore))
            (ยง
                ((ร RETURN) (+ nfa_add_nl NFA_NHEAD))
            )
            ((ร CASE) (| CLASS_az CLASS_AZ))
            (ยง
                ((ร RETURN) (+ nfa_add_nl NFA_ALPHA))
            )
            ((ร CASE) (ยง CLASS_not | CLASS_az | CLASS_AZ))
            (ยง
                ((ร RETURN) (+ nfa_add_nl NFA_NALPHA))
            )
            ((ร CASE) CLASS_az)
            (ยง
                ((ร RETURN) (+ nfa_add_nl NFA_LOWER_IC))
            )
            ((ร CASE) (| CLASS_not CLASS_az))
            (ยง
                ((ร RETURN) (+ nfa_add_nl NFA_NLOWER_IC))
            )
            ((ร CASE) CLASS_AZ)
            (ยง
                ((ร RETURN) (+ nfa_add_nl NFA_UPPER_IC))
            )
            ((ร CASE) (| CLASS_not CLASS_AZ))
            (ยง
                ((ร RETURN) (+ nfa_add_nl NFA_NUPPER_IC))
            )
        )

        0
    ))

;; helper functions used when doing re2post() ... regatom() parsing

(defn- #_boolean emc1 [#_int c]
    (ยง
        (if (<= (. @post_array length) @post_index)
            (grow_post_array 1000))

        ((ร @post_array[@post_index++] =) c)

        true
    ))

(defn- #_boolean emc2 [#_int c]
    (and (emc1 c) (emc1 NFA_CONCAT)))

;; Produce the bytes for equivalence class "c".
;; Currently only handles latin1, latin9 and utf-8.
;; Emits bytes in postfix notation: 'a,b,NFA_OR,c,NFA_OR' is equivalent to 'a OR b OR c'.
;;
;; NOTE! When changing this function, also update reg_equi_class()

(defn- #_boolean nfa_emit_equi_class [#_int c]
    (ยง
        ((ร SWITCH) c
            ((ร CASE) (byte \A))
            ((ร CASE) 0xc0) ((ร CASE) 0xc1) ((ร CASE) 0xc2)
            ((ร CASE) 0xc3) ((ร CASE) 0xc4) ((ร CASE) 0xc5)
            ((ร CASE) 0x100) ((ร CASE) 0x102) ((ร CASE) 0x104)
            ((ร CASE) 0x1cd) ((ร CASE) 0x1de) ((ร CASE) 0x1e0)
            ((ร CASE) 0x1ea2)
            (ยง
                ((ร RETURN) (and (emc2 (byte \A))
                    (emc2 0xc0) (emc2 0xc1) (emc2 0xc2)
                    (emc2 0xc3) (emc2 0xc4) (emc2 0xc5)
                    (emc2 0x100) (emc2 0x102) (emc2 0x104)
                    (emc2 0x1cd) (emc2 0x1de) (emc2 0x1e0)
                    (emc2 0x1ea2)))
            )
            ((ร CASE) (byte \a))
            ((ร CASE) 0xe0) ((ร CASE) 0xe1) ((ร CASE) 0xe2)
            ((ร CASE) 0xe3) ((ร CASE) 0xe4) ((ร CASE) 0xe5)
            ((ร CASE) 0x101) ((ร CASE) 0x103) ((ร CASE) 0x105)
            ((ร CASE) 0x1ce) ((ร CASE) 0x1df) ((ร CASE) 0x1e1)
            ((ร CASE) 0x1ea3)
            (ยง
                ((ร RETURN) (and (emc2 (byte \a))
                    (emc2 0xe0) (emc2 0xe1) (emc2 0xe2)
                    (emc2 0xe3) (emc2 0xe4) (emc2 0xe5)
                    (emc2 0x101) (emc2 0x103) (emc2 0x105)
                    (emc2 0x1ce) (emc2 0x1df) (emc2 0x1e1)
                    (emc2 0x1ea3)))
            )

            ((ร CASE) (byte \B))
            ((ร CASE) 0x1e02) ((ร CASE) 0x1e06)
            (ยง
                ((ร RETURN) (and (emc2 (byte \B))
                    (emc2 0x1e02) (emc2 0x1e06)))
            )
            ((ร CASE) (byte \b))
            ((ร CASE) 0x1e03) ((ร CASE) 0x1e07)
            (ยง
                ((ร RETURN) (and (emc2 (byte \b))
                    (emc2 0x1e03) (emc2 0x1e07)))
            )

            ((ร CASE) (byte \C))
            ((ร CASE) 0xc7)
            ((ร CASE) 0x106) ((ร CASE) 0x108) ((ร CASE) 0x10a) ((ร CASE) 0x10c)
            (ยง
                ((ร RETURN) (and (emc2 (byte \C))
                    (emc2 0xc7)
                    (emc2 0x106) (emc2 0x108) (emc2 0x10a) (emc2 0x10c)))
            )
            ((ร CASE) (byte \c))
            ((ร CASE) 0xe7)
            ((ร CASE) 0x107) ((ร CASE) 0x109) ((ร CASE) 0x10b) ((ร CASE) 0x10d)
            (ยง
                ((ร RETURN) (and (emc2 (byte \c))
                    (emc2 0xe7)
                    (emc2 0x107) (emc2 0x109) (emc2 0x10b) (emc2 0x10d)))
            )

            ((ร CASE) (byte \D))
            ((ร CASE) 0x10e) ((ร CASE) 0x110)
            ((ร CASE) 0x1e0a) ((ร CASE) 0x1e0c) ((ร CASE) 0x1e0e) ((ร CASE) 0x1e10) ((ร CASE) 0x1e12)
            (ยง
                ((ร RETURN) (and (emc2 (byte \D))
                    (emc2 0x10e) (emc2 0x110)
                    (emc2 0x1e0a) (emc2 0x1e0c) (emc2 0x1e0e) (emc2 0x1e10) (emc2 0x1e12)))
            )
            ((ร CASE) (byte \d))
            ((ร CASE) 0x10f) ((ร CASE) 0x111)
            ((ร CASE) 0x1e0b) ((ร CASE) 0x1e0d) ((ร CASE) 0x1e0f) ((ร CASE) 0x1e11) ((ร CASE) 0x1e13)
            (ยง
                ((ร RETURN) (and (emc2 (byte \d))
                    (emc2 0x10f) (emc2 0x111)
                    (emc2 0x1e0b) (emc2 0x1e0d) (emc2 0x1e0f) (emc2 0x1e11) (emc2 0x1e13)))
            )

            ((ร CASE) (byte \E))
            ((ร CASE) 0xc8) ((ร CASE) 0xc9) ((ร CASE) 0xca) ((ร CASE) 0xcb)
            ((ร CASE) 0x112) ((ร CASE) 0x114) ((ร CASE) 0x116) ((ร CASE) 0x118) ((ร CASE) 0x11a)
            ((ร CASE) 0x1eba) ((ร CASE) 0x1ebc)
            (ยง
                ((ร RETURN) (and (emc2 (byte \E))
                    (emc2 0xc8) (emc2 0xc9) (emc2 0xca) (emc2 0xcb)
                    (emc2 0x112) (emc2 0x114) (emc2 0x116) (emc2 0x118) (emc2 0x11a)
                    (emc2 0x1eba) (emc2 0x1ebc)))
            )
            ((ร CASE) (byte \e))
            ((ร CASE) 0xe8) ((ร CASE) 0xe9) ((ร CASE) 0xea) ((ร CASE) 0xeb)
            ((ร CASE) 0x113) ((ร CASE) 0x115) ((ร CASE) 0x117) ((ร CASE) 0x119) ((ร CASE) 0x11b)
            ((ร CASE) 0x1ebb) ((ร CASE) 0x1ebd)
            (ยง
                ((ร RETURN) (and (emc2 (byte \e))
                    (emc2 0xe8) (emc2 0xe9) (emc2 0xea) (emc2 0xeb)
                    (emc2 0x113) (emc2 0x115) (emc2 0x117) (emc2 0x119) (emc2 0x11b)
                    (emc2 0x1ebb) (emc2 0x1ebd)))
            )

            ((ร CASE) (byte \F))
            ((ร CASE) 0x1e1e)
            (ยง
                ((ร RETURN) (and (emc2 (byte \F))
                    (emc2 0x1e1e)))
            )
            ((ร CASE) (byte \f))
            ((ร CASE) 0x1e1f)
            (ยง
                ((ร RETURN) (and (emc2 (byte \f))
                    (emc2 0x1e1f)))
            )

            ((ร CASE) (byte \G))
            ((ร CASE) 0x11c) ((ร CASE) 0x11e) ((ร CASE) 0x120) ((ร CASE) 0x122)
            ((ร CASE) 0x1e4) ((ร CASE) 0x1e6) ((ร CASE) 0x1f4)
            ((ร CASE) 0x1e20)
            (ยง
                ((ร RETURN) (and (emc2 (byte \G))
                    (emc2 0x11c) (emc2 0x11e) (emc2 0x120) (emc2 0x122)
                    (emc2 0x1e4) (emc2 0x1e6) (emc2 0x1f4)
                    (emc2 0x1e20)))
            )
            ((ร CASE) (byte \g))
            ((ร CASE) 0x11d) ((ร CASE) 0x11f) ((ร CASE) 0x121) ((ร CASE) 0x123)
            ((ร CASE) 0x1e5) ((ร CASE) 0x1e7) ((ร CASE) 0x1f5)
            ((ร CASE) 0x1e21)
            (ยง
                ((ร RETURN) (and (emc2 (byte \g))
                    (emc2 0x11d) (emc2 0x11f) (emc2 0x121) (emc2 0x123)
                    (emc2 0x1e5) (emc2 0x1e7) (emc2 0x1f5)
                    (emc2 0x1e21)))
            )

            ((ร CASE) (byte \H))
            ((ร CASE) 0x124) ((ร CASE) 0x126)
            ((ร CASE) 0x1e22) ((ร CASE) 0x1e26) ((ร CASE) 0x1e28)
            (ยง
                ((ร RETURN) (and (emc2 (byte \H))
                    (emc2 0x124) (emc2 0x126)
                    (emc2 0x1e22) (emc2 0x1e26) (emc2 0x1e28)))
            )
            ((ร CASE) (byte \h))
            ((ร CASE) 0x125) ((ร CASE) 0x127)
            ((ร CASE) 0x1e23) ((ร CASE) 0x1e27) ((ร CASE) 0x1e29) ((ร CASE) 0x1e96)
            (ยง
                ((ร RETURN) (and (emc2 (byte \h))
                    (emc2 0x125) (emc2 0x127)
                    (emc2 0x1e23) (emc2 0x1e27) (emc2 0x1e29) (emc2 0x1e96)))
            )

            ((ร CASE) (byte \I))
            ((ร CASE) 0xcc) ((ร CASE) 0xcd) ((ร CASE) 0xce) ((ร CASE) 0xcf)
            ((ร CASE) 0x128) ((ร CASE) 0x12a) ((ร CASE) 0x12c) ((ร CASE) 0x12e) ((ร CASE) 0x130)
            ((ร CASE) 0x1cf)
            ((ร CASE) 0x1ec8)
            (ยง
                ((ร RETURN) (and (emc2 (byte \I))
                    (emc2 0xcc) (emc2 0xcd) (emc2 0xce) (emc2 0xcf)
                    (emc2 0x128) (emc2 0x12a) (emc2 0x12c) (emc2 0x12e) (emc2 0x130)
                    (emc2 0x1cf)
                    (emc2 0x1ec8)))
            )
            ((ร CASE) (byte \i))
            ((ร CASE) 0xec) ((ร CASE) 0xed) ((ร CASE) 0xee) ((ร CASE) 0xef)
            ((ร CASE) 0x129) ((ร CASE) 0x12b) ((ร CASE) 0x12d) ((ร CASE) 0x12f) ((ร CASE) 0x131)
            ((ร CASE) 0x1d0)
            ((ร CASE) 0x1ec9)
            (ยง
                ((ร RETURN) (and (emc2 (byte \i))
                    (emc2 0xec) (emc2 0xed) (emc2 0xee) (emc2 0xef)
                    (emc2 0x129) (emc2 0x12b) (emc2 0x12d) (emc2 0x12f) (emc2 0x131)
                    (emc2 0x1d0)
                    (emc2 0x1ec9)))
            )

            ((ร CASE) (byte \J))
            ((ร CASE) 0x134)
            (ยง
                ((ร RETURN) (and (emc2 (byte \J))
                    (emc2 0x134)))
            )
            ((ร CASE) (byte \j))
            ((ร CASE) 0x135) ((ร CASE) 0x1f0)
            (ยง
                ((ร RETURN) (and (emc2 (byte \j))
                    (emc2 0x135) (emc2 0x1f0)))
            )

            ((ร CASE) (byte \K))
            ((ร CASE) 0x136) ((ร CASE) 0x1e8)
            ((ร CASE) 0x1e30) ((ร CASE) 0x1e34)
            (ยง
                ((ร RETURN) (and (emc2 (byte \K))
                    (emc2 0x136) (emc2 0x1e8)
                    (emc2 0x1e30) (emc2 0x1e34)))
            )
            ((ร CASE) (byte \k))
            ((ร CASE) 0x137) ((ร CASE) 0x1e9)
            ((ร CASE) 0x1e31) ((ร CASE) 0x1e35)
            (ยง
                ((ร RETURN) (and (emc2 (byte \k))
                    (emc2 0x137) (emc2 0x1e9)
                    (emc2 0x1e31) (emc2 0x1e35)))
            )

            ((ร CASE) (byte \L))
            ((ร CASE) 0x139) ((ร CASE) 0x13b) ((ร CASE) 0x13d) ((ร CASE) 0x13f) ((ร CASE) 0x141)
            ((ร CASE) 0x1e3a)
            (ยง
                ((ร RETURN) (and (emc2 (byte \L))
                    (emc2 0x139) (emc2 0x13b) (emc2 0x13d) (emc2 0x13f) (emc2 0x141)
                    (emc2 0x1e3a)))
            )
            ((ร CASE) (byte \l))
            ((ร CASE) 0x13a) ((ร CASE) 0x13c) ((ร CASE) 0x13e) ((ร CASE) 0x140) ((ร CASE) 0x142)
            ((ร CASE) 0x1e3b)
            (ยง
                ((ร RETURN) (and (emc2 (byte \l))
                    (emc2 0x13a) (emc2 0x13c) (emc2 0x13e) (emc2 0x140) (emc2 0x142)
                    (emc2 0x1e3b)))
            )

            ((ร CASE) (byte \M))
            ((ร CASE) 0x1e3e) ((ร CASE) 0x1e40)
            (ยง
                ((ร RETURN) (and (emc2 (byte \M))
                    (emc2 0x1e3e) (emc2 0x1e40)))
            )
            ((ร CASE) (byte \m))
            ((ร CASE) 0x1e3f) ((ร CASE) 0x1e41)
            (ยง
                ((ร RETURN) (and (emc2 (byte \m))
                    (emc2 0x1e3f) (emc2 0x1e41)))
            )

            ((ร CASE) (byte \N))
            ((ร CASE) 0xd1)
            ((ร CASE) 0x143) ((ร CASE) 0x145) ((ร CASE) 0x147)
            ((ร CASE) 0x1e44) ((ร CASE) 0x1e48)
            (ยง
                ((ร RETURN) (and (emc2 (byte \N))
                    (emc2 0xd1)
                    (emc2 0x143) (emc2 0x145) (emc2 0x147)
                    (emc2 0x1e44) (emc2 0x1e48)))
            )
            ((ร CASE) (byte \n))
            ((ร CASE) 0xf1)
            ((ร CASE) 0x144) ((ร CASE) 0x146) ((ร CASE) 0x148) ((ร CASE) 0x149)
            ((ร CASE) 0x1e45) ((ร CASE) 0x1e49)
            (ยง
                ((ร RETURN) (and (emc2 (byte \n))
                    (emc2 0xf1)
                    (emc2 0x144) (emc2 0x146) (emc2 0x148) (emc2 0x149)
                    (emc2 0x1e45) (emc2 0x1e49)))
            )

            ((ร CASE) (byte \O))
            ((ร CASE) 0xd2) ((ร CASE) 0xd3) ((ร CASE) 0xd4)
            ((ร CASE) 0xd5) ((ร CASE) 0xd6) ((ร CASE) 0xd8)
            ((ร CASE) 0x14c) ((ร CASE) 0x14e) ((ร CASE) 0x150)
            ((ร CASE) 0x1a0) ((ร CASE) 0x1d1) ((ร CASE) 0x1ea) ((ร CASE) 0x1ec)
            ((ร CASE) 0x1ece)
            (ยง
                ((ร RETURN) (and (emc2 (byte \O))
                    (emc2 0xd2) (emc2 0xd3) (emc2 0xd4)
                    (emc2 0xd5) (emc2 0xd6) (emc2 0xd8)
                    (emc2 0x14c) (emc2 0x14e) (emc2 0x150)
                    (emc2 0x1a0) (emc2 0x1d1) (emc2 0x1ea) (emc2 0x1ec)
                    (emc2 0x1ece)))
            )
            ((ร CASE) (byte \o))
            ((ร CASE) 0xf2) ((ร CASE) 0xf3) ((ร CASE) 0xf4)
            ((ร CASE) 0xf5) ((ร CASE) 0xf6) ((ร CASE) 0xf8)
            ((ร CASE) 0x14d) ((ร CASE) 0x14f) ((ร CASE) 0x151)
            ((ร CASE) 0x1a1) ((ร CASE) 0x1d2) ((ร CASE) 0x1eb) ((ร CASE) 0x1ed)
            ((ร CASE) 0x1ecf)
            (ยง
                ((ร RETURN) (and (emc2 (byte \o))
                    (emc2 0xf2) (emc2 0xf3) (emc2 0xf4)
                    (emc2 0xf5) (emc2 0xf6) (emc2 0xf8)
                    (emc2 0x14d) (emc2 0x14f) (emc2 0x151)
                    (emc2 0x1a1) (emc2 0x1d2) (emc2 0x1eb) (emc2 0x1ed)
                    (emc2 0x1ecf)))
            )

            ((ร CASE) (byte \P))
            ((ร CASE) 0x1e54) ((ร CASE) 0x1e56)
            (ยง
                ((ร RETURN) (and (emc2 (byte \P))
                    (emc2 0x1e54) (emc2 0x1e56)))
            )
            ((ร CASE) (byte \p))
            ((ร CASE) 0x1e55) ((ร CASE) 0x1e57)
            (ยง
                ((ร RETURN) (and (emc2 (byte \p))
                    (emc2 0x1e55) (emc2 0x1e57)))
            )

            ((ร CASE) (byte \R))
            ((ร CASE) 0x154) ((ร CASE) 0x156) ((ร CASE) 0x158)
            ((ร CASE) 0x1e58) ((ร CASE) 0x1e5e)
            (ยง
                ((ร RETURN) (and (emc2 (byte \R))
                    (emc2 0x154) (emc2 0x156) (emc2 0x158)
                    (emc2 0x1e58) (emc2 0x1e5e)))
            )
            ((ร CASE) (byte \r))
            ((ร CASE) 0x155) ((ร CASE) 0x157) ((ร CASE) 0x159)
            ((ร CASE) 0x1e59) ((ร CASE) 0x1e5f)
            (ยง
                ((ร RETURN) (and (emc2 (byte \r))
                    (emc2 0x155) (emc2 0x157) (emc2 0x159)
                    (emc2 0x1e59) (emc2 0x1e5f)))
            )

            ((ร CASE) (byte \S))
            ((ร CASE) 0x15a) ((ร CASE) 0x15c) ((ร CASE) 0x15e) ((ร CASE) 0x160)
            ((ร CASE) 0x1e60)
            (ยง
                ((ร RETURN) (and (emc2 (byte \S))
                    (emc2 0x15a) (emc2 0x15c) (emc2 0x15e) (emc2 0x160)
                    (emc2 0x1e60)))
            )
            ((ร CASE) (byte \s))
            ((ร CASE) 0x15b) ((ร CASE) 0x15d) ((ร CASE) 0x15f) ((ร CASE) 0x161)
            ((ร CASE) 0x1e61)
            (ยง
                ((ร RETURN) (and (emc2 (byte \s))
                    (emc2 0x15b) (emc2 0x15d) (emc2 0x15f) (emc2 0x161)
                    (emc2 0x1e61)))
            )

            ((ร CASE) (byte \T))
            ((ร CASE) 0x162) ((ร CASE) 0x164) ((ร CASE) 0x166)
            ((ร CASE) 0x1e6a) ((ร CASE) 0x1e6e)
            (ยง
                ((ร RETURN) (and (emc2 (byte \T))
                    (emc2 0x162) (emc2 0x164) (emc2 0x166)
                    (emc2 0x1e6a) (emc2 0x1e6e)))
            )
            ((ร CASE) (byte \t))
            ((ร CASE) 0x163) ((ร CASE) 0x165) ((ร CASE) 0x167)
            ((ร CASE) 0x1e6b) ((ร CASE) 0x1e6f) ((ร CASE) 0x1e97)
            (ยง
                ((ร RETURN) (and (emc2 (byte \t))
                    (emc2 0x163) (emc2 0x165) (emc2 0x167)
                    (emc2 0x1e6b) (emc2 0x1e6f) (emc2 0x1e97)))
            )

            ((ร CASE) (byte \U))
            ((ร CASE) 0xd9) ((ร CASE) 0xda) ((ร CASE) 0xdb) ((ร CASE) 0xdc)
            ((ร CASE) 0x168) ((ร CASE) 0x16a) ((ร CASE) 0x16c) ((ร CASE) 0x16e)
            ((ร CASE) 0x170) ((ร CASE) 0x172) ((ร CASE) 0x1af) ((ร CASE) 0x1d3)
            ((ร CASE) 0x1ee6)
            (ยง
                ((ร RETURN) (and (emc2 (byte \U))
                    (emc2 0xd9) (emc2 0xda) (emc2 0xdb) (emc2 0xdc)
                    (emc2 0x168) (emc2 0x16a) (emc2 0x16c) (emc2 0x16e)
                    (emc2 0x170) (emc2 0x172) (emc2 0x1af) (emc2 0x1d3)
                    (emc2 0x1ee6)))
            )
            ((ร CASE) (byte \u))
            ((ร CASE) 0xf9) ((ร CASE) 0xfa) ((ร CASE) 0xfb) ((ร CASE) 0xfc)
            ((ร CASE) 0x169) ((ร CASE) 0x16b) ((ร CASE) 0x16d) ((ร CASE) 0x16f)
            ((ร CASE) 0x171) ((ร CASE) 0x173) ((ร CASE) 0x1b0) ((ร CASE) 0x1d4)
            ((ร CASE) 0x1ee7)
            (ยง
                ((ร RETURN) (and (emc2 (byte \u))
                    (emc2 0xf9) (emc2 0xfa) (emc2 0xfb) (emc2 0xfc)
                    (emc2 0x169) (emc2 0x16b) (emc2 0x16d) (emc2 0x16f)
                    (emc2 0x171) (emc2 0x173) (emc2 0x1b0) (emc2 0x1d4)
                    (emc2 0x1ee7)))
            )

            ((ร CASE) (byte \V))
            ((ร CASE) 0x1e7c)
            (ยง
                ((ร RETURN) (and (emc2 (byte \V))
                    (emc2 0x1e7c)))
            )
            ((ร CASE) (byte \v))
            ((ร CASE) 0x1e7d)
            (ยง
                ((ร RETURN) (and (emc2 (byte \v))
                    (emc2 0x1e7d)))
            )

            ((ร CASE) (byte \W))
            ((ร CASE) 0x174)
            ((ร CASE) 0x1e80) ((ร CASE) 0x1e82) ((ร CASE) 0x1e84) ((ร CASE) 0x1e86)
            (ยง
                ((ร RETURN) (and (emc2 (byte \W))
                    (emc2 0x174)
                    (emc2 0x1e80) (emc2 0x1e82) (emc2 0x1e84) (emc2 0x1e86)))
            )
            ((ร CASE) (byte \w))
            ((ร CASE) 0x175)
            ((ร CASE) 0x1e81) ((ร CASE) 0x1e83) ((ร CASE) 0x1e85) ((ร CASE) 0x1e87) ((ร CASE) 0x1e98)
            (ยง
                ((ร RETURN) (and (emc2 (byte \w))
                    (emc2 0x175)
                    (emc2 0x1e81) (emc2 0x1e83) (emc2 0x1e85) (emc2 0x1e87) (emc2 0x1e98)))
            )

            ((ร CASE) (byte \X))
            ((ร CASE) 0x1e8a) ((ร CASE) 0x1e8c)
            (ยง
                ((ร RETURN) (and (emc2 (byte \X))
                    (emc2 0x1e8a) (emc2 0x1e8c)))
            )
            ((ร CASE) (byte \x))
            ((ร CASE) 0x1e8b) ((ร CASE) 0x1e8d)
            (ยง
                ((ร RETURN) (and (emc2 (byte \x))
                    (emc2 0x1e8b) (emc2 0x1e8d)))
            )

            ((ร CASE) (byte \Y))
            ((ร CASE) 0xdd)
            ((ร CASE) 0x176) ((ร CASE) 0x178)
            ((ร CASE) 0x1e8e) ((ร CASE) 0x1ef2) ((ร CASE) 0x1ef6) ((ร CASE) 0x1ef8)
            (ยง
                ((ร RETURN) (and (emc2 (byte \Y))
                    (emc2 0xdd)
                    (emc2 0x176) (emc2 0x178)
                    (emc2 0x1e8e) (emc2 0x1ef2) (emc2 0x1ef6) (emc2 0x1ef8)))
            )
            ((ร CASE) (byte \y))
            ((ร CASE) 0xfd) ((ร CASE) 0xff)
            ((ร CASE) 0x177)
            ((ร CASE) 0x1e8f) ((ร CASE) 0x1e99) ((ร CASE) 0x1ef3) ((ร CASE) 0x1ef7) ((ร CASE) 0x1ef9)
            (ยง
                ((ร RETURN) (and (emc2 (byte \y))
                    (emc2 0xfd) (emc2 0xff)
                    (emc2 0x177)
                    (emc2 0x1e8f) (emc2 0x1e99) (emc2 0x1ef3) (emc2 0x1ef7) (emc2 0x1ef9)))
            )

            ((ร CASE) (byte \Z))
            ((ร CASE) 0x179) ((ร CASE) 0x17b) ((ร CASE) 0x17d) ((ร CASE) 0x1b5)
            ((ร CASE) 0x1e90) ((ร CASE) 0x1e94)
            (ยง
                ((ร RETURN) (and (emc2 (byte \Z))
                    (emc2 0x179) (emc2 0x17b) (emc2 0x17d) (emc2 0x1b5)
                    (emc2 0x1e90) (emc2 0x1e94)))
            )
            ((ร CASE) (byte \z))
            ((ร CASE) 0x17a) ((ร CASE) 0x17c) ((ร CASE) 0x17e) ((ร CASE) 0x1b6)
            ((ร CASE) 0x1e91) ((ร CASE) 0x1e95)
            (ยง
                ((ร RETURN) (and (emc2 (byte \z))
                    (emc2 0x17a) (emc2 0x17c) (emc2 0x17e) (emc2 0x1b6)
                    (emc2 0x1e91) (emc2 0x1e95)))
            )

            ;; default: character itself
        )

        (emc2 c)
    ))

;; Code to parse regular expression.
;;
;; We try to reuse parsing functions in regexp.c to
;; minimize surprise and keep the syntax consistent.

;; Parse the lowest level.
;;
;; An atom can be one of a long list of items.  Many atoms match one character
;; in the text.  It is often an ordinary character or a character class.
;; Braces can be used to make a pattern into an atom.  The "\z(\)" construct
;; is only for syntax highlighting.
;;
;; atom    ::=     ordinary-atom
;;     or  \( pattern \)
;;     or  \%( pattern \)
;;     or  \z( pattern \)

(defn- #_boolean nfa_regatom []
    (ยง
        ((ร Bytes old_regparse =) @regparse)
        ((ร int extra =) 0)
        ((ร int startc =) -1)
        ((ร int endc =) -1)
        ((ร int oldstartc =) -1)

        ((ร int c =) (getchr))

;       collection:
;       {
            ((ร SWITCH) c
                ((ร CASE) NUL)
                (ยง
                    (emsg e_nul_found)
                    (reset! rc_did_emsg true)
                    ((ร RETURN) false)
                )

                ((ร CASE) (Magic (byte \^)))
                (ยง
                    (emc1 NFA_BOL)
                    (ร BREAK)
                )

                ((ร CASE) (Magic (byte \$)))
                (ยง
                    (emc1 NFA_EOL)
                    (ร BREAK)
                )

                ((ร CASE) (Magic (byte \<)))
                (ยง
                    (emc1 NFA_BOW)
                    (ร BREAK)
                )

                ((ร CASE) (Magic (byte \>)))
                (ยง
                    (emc1 NFA_EOW)
                    (ร BREAK)
                )

                ((ร CASE) (Magic (byte \_)))
                (ยง
                    ((ร c =) (ยง no_Magic(getchr())))
                    (when (== c NUL)
                        (emsg e_nul_found)
                        (reset! rc_did_emsg true)
                        ((ร RETURN) false)
                    )

                    (when (== c (byte \^))       ;; "\_^" is start-of-line
                        (emc1 NFA_BOL)
                        (ร BREAK)
                    )
                    (when (== c (byte \$))       ;; "\_$" is end-of-line
                        (emc1 NFA_EOL)
                        (ร BREAK)
                    )

                    ((ร extra =) NFA_ADD_NL)

                    ;; "\_[" is collection plus newline
                    (if (== c (byte \[))
                        (ร BREAK collection)
                    )

                    ;; "\_x" is character class plus newline
                    (ร FALLTHROUGH)
                )

                ;; Character classes.

                ((ร CASE) (Magic (byte \.)))
                ((ร CASE) (Magic (byte \i)))
                ((ร CASE) (Magic (byte \I)))
                ((ร CASE) (Magic (byte \k)))
                ((ร CASE) (Magic (byte \K)))
                ((ร CASE) (Magic (byte \f)))
                ((ร CASE) (Magic (byte \F)))
                ((ร CASE) (Magic (byte \p)))
                ((ร CASE) (Magic (byte \P)))
                ((ร CASE) (Magic (byte \s)))
                ((ร CASE) (Magic (byte \S)))
                ((ร CASE) (Magic (byte \d)))
                ((ร CASE) (Magic (byte \D)))
                ((ร CASE) (Magic (byte \x)))
                ((ร CASE) (Magic (byte \X)))
                ((ร CASE) (Magic (byte \o)))
                ((ร CASE) (Magic (byte \O)))
                ((ร CASE) (Magic (byte \w)))
                ((ร CASE) (Magic (byte \W)))
                ((ร CASE) (Magic (byte \h)))
                ((ร CASE) (Magic (byte \H)))
                ((ร CASE) (Magic (byte \a)))
                ((ร CASE) (Magic (byte \A)))
                ((ร CASE) (Magic (byte \l)))
                ((ร CASE) (Magic (byte \L)))
                ((ร CASE) (Magic (byte \u)))
                ((ร CASE) (Magic (byte \U)))
                (ยง
                    ((ร Bytes p =) (ยง vim_strchr(classchars, no_Magic(c))))
                    (when (nil? p)
                        (when (== extra NFA_ADD_NL)
                            (emsgn e_ill_char_class, (long c))
                            (reset! rc_did_emsg true)
                            ((ร RETURN) false)
                        )
                        (emsgn (u8 "INTERNAL: Unknown character class char: %ld"), (long c))
                        ((ร RETURN) false)
                    )
                    ;; When '.' is followed by a composing char ignore the dot,
                    ;; so that the composing char is matched here.
                    (when (and (== c (Magic (byte \.))) (utf_iscomposing (peekchr)))
                        ((ร old_regparse =) @regparse)
                        ((ร c =) (getchr))
                        ((ร RETURN) (nfa_do_multibyte c, old_regparse))
                    )
                    (emc1 (ยง nfa_classcodes[BDIFF(p, classchars)]))
                    (when (== extra NFA_ADD_NL)
                        (emc1 NFA_NEWL)
                        (emc1 NFA_OR)
                        ((ร @regflags |=) RF_HASNL)
                    )
                    (ร BREAK)
                )

                ((ร CASE) (Magic (byte \n)))
                (ยง
                    (cond @reg_string
                    (ยง
                        ;; In a string "\n" matches a newline character.
                        (emc1 NL)
                    )
                    :else
                    (ยง
                        ;; In buffer text "\n" matches the end of a line.
                        (emc1 NFA_NEWL)
                        ((ร @regflags |=) RF_HASNL)
                    ))
                    (ร BREAK)
                )

                ((ร CASE) (Magic (byte \()))
                (ยง
                    (if (not (nfa_reg REG_PAREN))
                        ((ร RETURN) false)           ;; cascaded error
                    )
                    (ร BREAK)
                )

                ((ร CASE) (Magic (byte \|)))
                ((ร CASE) (Magic (byte \&)))
                ((ร CASE) (Magic (byte \))))
                (ยง
                    (emsgn e_misplaced, (ยง (long)no_Magic(c)))
                    ((ร RETURN) false)
                )

                ((ร CASE) (Magic (byte \=)))
                ((ร CASE) (Magic (byte \?)))
                ((ร CASE) (Magic (byte \+)))
                ((ร CASE) (Magic (byte \@)))
                ((ร CASE) (Magic (byte \*)))
                ((ร CASE) (Magic (byte \{)))
                (ยง
                    ;; these should follow an atom, not form an atom
                    (emsgn e_misplaced, (ยง (long)no_Magic(c)))
                    ((ร RETURN) false)
                )

                ((ร CASE) (Magic (byte \~)))
                (ยง
                    ;; Previous substitute pattern.
                    ;; Generated as "\%(pattern\)".
                    (when (nil? @reg_prev_sub)
                        (emsg e_nopresub)
                        ((ร RETURN) false)
                    )
                    ((ร FOR) (ร (ยง Bytes lp = @reg_prev_sub) (ยง lp.at(0) != NUL) (ยง lp = lp.plus(us_ptr2len(lp))))
                        (emc1 (us_ptr2char lp))
                        (if (BNE lp, @reg_prev_sub)
                            (emc1 NFA_CONCAT))
                    )
                    (emc1 NFA_NOPEN)
                    (ร BREAK)
                )

                ((ร CASE) (Magic (byte \1)))
                ((ร CASE) (Magic (byte \2)))
                ((ร CASE) (Magic (byte \3)))
                ((ร CASE) (Magic (byte \4)))
                ((ร CASE) (Magic (byte \5)))
                ((ร CASE) (Magic (byte \6)))
                ((ร CASE) (Magic (byte \7)))
                ((ร CASE) (Magic (byte \8)))
                ((ร CASE) (Magic (byte \9)))
                (ยง
                    (emc1 (+ NFA_BACKREF1 (- (no_Magic c) (byte \1))))
                    (reset! nfa_has_backref true)
                    (ร BREAK)
                )

                ((ร CASE) (Magic (byte \z)))
                (ยง
                    ((ร c =) (ยง no_Magic(getchr())))
                    ((ร SWITCH) c
                        ((ร CASE) (byte \s))
                        (ยง
                            (emc1 NFA_ZSTART)
                            (if (not (re_mult_next (u8 "\\zs")))
                                ((ร RETURN) false)
                            )
                            (ร BREAK)
                        )

                        ((ร CASE) (byte \e))
                        (ยง
                            (emc1 NFA_ZEND)
                            (reset! nfa_has_zend true)
                            (if (not (re_mult_next (u8 "\\ze")))
                                ((ร RETURN) false)
                            )
                            (ร BREAK)
                        )

                        ((ร CASE) (byte \1))
                        ((ร CASE) (byte \2))
                        ((ร CASE) (byte \3))
                        ((ร CASE) (byte \4))
                        ((ร CASE) (byte \5))
                        ((ร CASE) (byte \6))
                        ((ร CASE) (byte \7))
                        ((ร CASE) (byte \8))
                        ((ร CASE) (byte \9))
                        (ยง
                            ;; \z1...\z9
                            (when (!= @reg_do_extmatch REX_USE)
                                (emsg e_z1_not_allowed)
                                (reset! rc_did_emsg true)
                                ((ร RETURN) false)
                            )
                            (emc1 (+ NFA_ZREF1 (- (no_Magic c) (byte \1))))
                            ;; No need to set nfa_has_backref, the sub-matches
                            ;; don't change when \z1 .. \z9 matches or not.
                            (reset! re_has_z REX_USE)
                            (ร BREAK)
                        )

                        ((ร CASE) (byte \())
                        (ยง
                            ;; \z(
                            (when (!= @reg_do_extmatch REX_SET)
                                (emsg e_z_not_allowed)
                                (reset! rc_did_emsg true)
                                ((ร RETURN) false)
                            )
                            (if (not (nfa_reg REG_ZPAREN))
                                ((ร RETURN) false)           ;; cascaded error
                            )
                            (reset! re_has_z REX_SET)
                            (ร BREAK)
                        )

                        (ร DEFAULT)
                        (ยง
                            (emsgn (u8 "E867: (NFA) Unknown operator '\\z%c'"), (long (no_Magic c)))
                            ((ร RETURN) false)
                        )
                    )
                    (ร BREAK)
                )

                ((ร CASE) (Magic (byte \%)))
                (ยง
                    ((ร c =) (ยง no_Magic(getchr())))
                    ((ร SWITCH) c
                        ;; () without a back reference
                        ((ร CASE) (byte \())
                        (ยง
                            (if (not (nfa_reg REG_NPAREN))
                                ((ร RETURN) false)
                            )
                            (emc1 NFA_NOPEN)
                            (ร BREAK)
                        )

                        ((ร CASE) (byte \d))   ;; %d123 decimal
                        ((ร CASE) (byte \o))   ;; %o123 octal
                        ((ร CASE) (byte \x))   ;; %xab hex 2
                        ((ร CASE) (byte \u))   ;; %uabcd hex 4
                        ((ร CASE) (byte \U))   ;; %U1234abcd hex 8
                        (ยง
                            (ร int nr)

                            ((ร SWITCH) c
                                ((ร CASE) (byte \d))
                                (ยง
                                    ((ร nr =) (getdecchrs))
                                    (ร BREAK)
                                )
                                ((ร CASE) (byte \o))
                                (ยง
                                    ((ร nr =) (getoctchrs))
                                    (ร BREAK)
                                )
                                ((ร CASE) (byte \x))
                                (ยง
                                    ((ร nr =) (gethexchrs 2))
                                    (ร BREAK)
                                )
                                ((ร CASE) (byte \u))
                                (ยง
                                    ((ร nr =) (gethexchrs 4))
                                    (ร BREAK)
                                )
                                ((ร CASE) (byte \U))
                                (ยง
                                    ((ร nr =) (gethexchrs 8))
                                    (ร BREAK)
                                )
                                (ร DEFAULT)
                                (ยง
                                    ((ร nr =) -1)
                                    (ร BREAK)
                                )
                            )

                            (when (< nr 0)
                                (emsg2 (u8 "E678: Invalid character after %s%%[dxouU]"), (if (== @reg_magic MAGIC_ALL) (u8 "") (u8 "\\")))
                                (reset! rc_did_emsg true)
                                ((ร RETURN) false)
                            )
                            ;; A NUL is stored in the text as NL.
                            ;; TODO: what if a composing character follows?
                            (emc1 (if (zero? nr) 0x0a nr))
                            (ร BREAK)
                        )

                        ;; Catch \%^ and \%$ regardless of where they appear in the
                        ;; pattern -- regardless of whether or not it makes sense.
                        ((ร CASE) (byte \^))
                        (ยง
                            (emc1 NFA_BOF)
                            (ร BREAK)
                        )

                        ((ร CASE) (byte \$))
                        (ยง
                            (emc1 NFA_EOF)
                            (ร BREAK)
                        )

                        ((ร CASE) (byte \#))
                        (ยง
                            (emc1 NFA_CURSOR)
                            (ร BREAK)
                        )

                        ((ร CASE) (byte \V))
                        (ยง
                            (emc1 NFA_VISUAL)
                            (ร BREAK)
                        )

                        ((ร CASE) (byte \C))
                        (ยง
                            (emc1 NFA_ANY_COMPOSING)
                            (ร BREAK)
                        )

                        ((ร CASE) (byte \[))
                        (ยง
                            (ร int n)

                            ;; \%[abc]
                            ((ร FOR) (ร (ยง n = 0) (ยง (c = peekchr()) != (byte \])) (ยง n++))
                                (when (== c NUL)
                                    (emsg2 e_missing_sb, (if (== @reg_magic MAGIC_ALL) (u8 "") (u8 "\\")))
                                    (reset! rc_did_emsg true)
                                    ((ร RETURN) false)
                                )
                                ;; recursive call!
                                (if (not (nfa_regatom))
                                    ((ร RETURN) false)
                                )
                            )
                            (getchr)       ;; get the ]
                            (when (zero? n)
                                (emsg2 e_empty_sb, (if (== @reg_magic MAGIC_ALL) (u8 "") (u8 "\\")))
                                (reset! rc_did_emsg true)
                                ((ร RETURN) false)
                            )
                            (emc1 NFA_OPT_CHARS)
                            (emc1 n)

                            ;; Emit as "\%(\%[abc]\)" to be able to handle "\%[abc]*" which would
                            ;; cause the empty string to be matched an unlimited number of times.
                            ;; NFA_NOPEN is added only once at a position, while NFA_SPLIT is added
                            ;; multiple times.  This is more efficient than not allowing NFA_SPLIT
                            ;; multiple times, it is used a lot.

                            (emc1 NFA_NOPEN)
                            (ร BREAK)
                        )

                        (ร DEFAULT)
                        (ยง
                            ((ร int n =) 0)
                            ((ร int cmp =) c)

                            (if (or (== c (byte \<)) (== c (byte \>)))
                                ((ร c =) (getchr))
                            )
                            (while (asc_isdigit c)
                                ((ร n =) (ยง n * 10 + (c - (byte \0))))
                                ((ร c =) (getchr))
                            )
                            (cond (or (== c (byte \l)) (== c (byte \c)) (== c (byte \v)))
                            (ยง
                                (cond (== c (byte \l))
                                (ยง
                                    ;; \%{n}l  \%{n}<l  \%{n}>l
                                    (emc1 (cond (== cmp (byte \<)) NFA_LNUM_LT (== cmp (byte \>)) NFA_LNUM_GT :else NFA_LNUM))
                                )
                                (== c (byte \c))
                                (ยง
                                    ;; \%{n}c  \%{n}<c  \%{n}>c
                                    (emc1 (cond (== cmp (byte \<)) NFA_COL_LT (== cmp (byte \>)) NFA_COL_GT :else NFA_COL))
                                )
                                :else
                                (ยง
                                    ;; \%{n}v  \%{n}<v  \%{n}>v
                                    (emc1 (cond (== cmp (byte \<)) NFA_VCOL_LT (== cmp (byte \>)) NFA_VCOL_GT :else NFA_VCOL))
                                ))
                                (emc1 n)
                                (ร BREAK)
                            )
                            (and (== c (byte \')) (zero? n))
                            (ยง
                                ;; \%'m  \%<'m  \%>'m
                                (emc1 (cond (== cmp (byte \<)) NFA_MARK_LT (== cmp (byte \>)) NFA_MARK_GT :else NFA_MARK))
                                (emc1 (getchr))
                                (ร BREAK)
                            ))
                            (emsgn (u8 "E867: (NFA) Unknown operator '\\%%%c'"), (long (no_Magic c)))
                            ((ร RETURN) false)
                        )
                    )
                    (ร BREAK)
                )

                ((ร CASE) (Magic (byte \[)))
                (ยง
                    (ร BREAK collection)
                )

                (ร DEFAULT)
                (ยง
                    ((ร RETURN) (nfa_do_multibyte c, old_regparse))
                )
            )

            ((ร RETURN) true)
;       }

        ;; [abc]  uses NFA_START_COLL - NFA_END_COLL
        ;; [^abc] uses NFA_START_NEG_COLL - NFA_END_NEG_COLL
        ;; Each character is produced as a regular state,
        ;; using NFA_CONCAT to bind them together.
        ;; Besides normal characters there can be:
        ;; - character classes  NFA_CLASS_*
        ;; - ranges, two characters followed by NFA_RANGE.

        ((ร Bytes p =) @regparse)
        ((ร Bytes endp =) (skip_anyof p))

        (when (== (.at endp 0) (byte \]))
            ;; Try to reverse engineer character classes.  For example,
            ;; recognize that [0-9] stands for \d and [A-Za-z_] for \h,
            ;; and perform the necessary substitutions in the NFA.

            ((ร int result =) (ยง nfa_recognize_char_class(@regparse, endp, extra == NFA_ADD_NL)))
            (when (non-zero? result)
                (cond (and (<= NFA_FIRST_NL result) (<= result NFA_LAST_NL))
                (ยง
                    (emc1 (- result NFA_ADD_NL))
                    (emc1 NFA_NEWL)
                    (emc1 NFA_OR)
                )
                :else
                (ยง
                    (emc1 result)
                ))
                (reset! regparse endp)
                (reset! regparse (ยง @regparse.plus(us_ptr2len_cc(@regparse))))
                ((ร RETURN) true)
            )

            ;; Failed to recognize a character class.
            ;; Use the simple version that turns [abc] into 'a' OR 'b' OR 'c'.

            ((ร startc =) (ยง endc = oldstartc = -1))
            ((ร boolean negated =) false)
            (cond (== (.at @regparse 0) (byte \^))                   ;; negated range
            (ยง
                ((ร negated =) true)
                (reset! regparse (ยง @regparse.plus(us_ptr2len_cc(@regparse))))
                (emc1 NFA_START_NEG_COLL)
            )
            :else
            (ยง
                (emc1 NFA_START_COLL)
            ))
            (when (== (.at @regparse 0) (byte \-))
                ((ร startc =) (byte \-))
                (emc1 startc)
                (emc1 NFA_CONCAT)
                (reset! regparse (ยง @regparse.plus(us_ptr2len_cc(@regparse))))
            )
            ;; Emit the OR branches for each character in the [].
            ((ร boolean emit_range =) false)
            (while (BLT @regparse, endp)
                ((ร oldstartc =) startc)
                ((ร startc =) -1)
                ((ร boolean got_coll_char =) false)
                (when (== (.at @regparse 0) (byte \[))
                    ;; Check for [: :], [= =], [. .].
                    (ร int charclass, equiclass = 0, collclass = 0)
;                   { Bytes[] __ = { @regparse }; charclass = get_char_class(__); @regparse = __[0]; }
                    (when (== charclass CLASS_NONE)
;                       { Bytes[] __ = { @regparse }; equiclass = get_equi_class(__); @regparse = __[0]; }
                        (when (zero? equiclass)
;                           { Bytes[] __ = { @regparse }; collclass = get_coll_element(__); @regparse = __[0]; }
                        )
                    )

                    ;; Character class like [:alpha:].
                    (when (!= charclass CLASS_NONE)
                        ((ร SWITCH) charclass
                            ((ร CASE) CLASS_ALNUM)
                            (ยง
                                (emc1 NFA_CLASS_ALNUM)
                                (ร BREAK)
                            )
                            ((ร CASE) CLASS_ALPHA)
                            (ยง
                                (emc1 NFA_CLASS_ALPHA)
                                (ร BREAK)
                            )
                            ((ร CASE) CLASS_BLANK)
                            (ยง
                                (emc1 NFA_CLASS_BLANK)
                                (ร BREAK)
                            )
                            ((ร CASE) CLASS_CNTRL)
                            (ยง
                                (emc1 NFA_CLASS_CNTRL)
                                (ร BREAK)
                            )
                            ((ร CASE) CLASS_DIGIT)
                            (ยง
                                (emc1 NFA_CLASS_DIGIT)
                                (ร BREAK)
                            )
                            ((ร CASE) CLASS_GRAPH)
                            (ยง
                                (emc1 NFA_CLASS_GRAPH)
                                (ร BREAK)
                            )
                            ((ร CASE) CLASS_LOWER)
                            (ยง
                                (emc1 NFA_CLASS_LOWER)
                                (ร BREAK)
                            )
                            ((ร CASE) CLASS_PRINT)
                            (ยง
                                (emc1 NFA_CLASS_PRINT)
                                (ร BREAK)
                            )
                            ((ร CASE) CLASS_PUNCT)
                            (ยง
                                (emc1 NFA_CLASS_PUNCT)
                                (ร BREAK)
                            )
                            ((ร CASE) CLASS_SPACE)
                            (ยง
                                (emc1 NFA_CLASS_SPACE)
                                (ร BREAK)
                            )
                            ((ร CASE) CLASS_UPPER)
                            (ยง
                                (emc1 NFA_CLASS_UPPER)
                                (ร BREAK)
                            )
                            ((ร CASE) CLASS_XDIGIT)
                            (ยง
                                (emc1 NFA_CLASS_XDIGIT)
                                (ร BREAK)
                            )
                            ((ร CASE) CLASS_TAB)
                            (ยง
                                (emc1 NFA_CLASS_TAB)
                                (ร BREAK)
                            )
                            ((ร CASE) CLASS_RETURN)
                            (ยง
                                (emc1 NFA_CLASS_RETURN)
                                (ร BREAK)
                            )
                            ((ร CASE) CLASS_BACKSPACE)
                            (ยง
                                (emc1 NFA_CLASS_BACKSPACE)
                                (ร BREAK)
                            )
                            ((ร CASE) CLASS_ESCAPE)
                            (ยง
                                (emc1 NFA_CLASS_ESCAPE)
                                (ร BREAK)
                            )
                        )
                        (emc1 NFA_CONCAT)
                        (ร CONTINUE)
                    )
                    ;; Try equivalence class [=a=] and the like.
                    (when (non-zero? equiclass)
                        (when (not (nfa_emit_equi_class equiclass))
                            ;; should never happen
                            (emsg (u8 "E868: Error building NFA with equivalence class!"))
                            (reset! rc_did_emsg true)
                            ((ร RETURN) false)
                        )
                        (ร CONTINUE)
                    )
                    ;; Try collating class like [. .].
                    (when (non-zero? collclass)
                        ((ร startc =) collclass)     ;; allow [.a.]-x as a range
                        ;; Will emit the proper atom at the end of the while loop.
                    )
                )
                ;; Try a range like 'a-x' or '\t-z'.  Also allows '-' as a start character.
                (when (and (== (.at @regparse 0) (byte \-)) (!= oldstartc -1))
                    ((ร emit_range =) true)
                    ((ร startc =) oldstartc)
                    (reset! regparse (ยง @regparse.plus(us_ptr2len_cc(@regparse))))
                    (ร CONTINUE)           ;; reading the end of the range
                )

                ;; Now handle simple and escaped characters.
                ;; Only "\]", "\^", "\]" and "\\" are special in Vi.
                ;; Vim accepts "\t", "\e", etc., but only when the 'l' flag in 'cpoptions' is not included.
                ;; Posix doesn't recognize backslash at all.

                (when (and (== (.at @regparse 0) (byte \\)) (not @reg_cpo_bsl) (BLE (.plus @regparse 1), endp) (or (non-nil? (ยง vim_strchr(REGEXP_INRANGE, @regparse.at(1)))) (and (not @reg_cpo_lit) (non-nil? (ยง vim_strchr(REGEXP_ABBR, @regparse.at(1)))))))
                    (reset! regparse (ยง @regparse.plus(us_ptr2len_cc(@regparse))))

                    (cond (== (.at @regparse 0) (byte \n))
                    (ยง
                        ((ร startc =) (if @reg_string NL NFA_NEWL))
                    )
                    (or (== (.at @regparse 0) (byte \d)) (== (.at @regparse 0) (byte \o)) (== (.at @regparse 0) (byte \x)) (== (.at @regparse 0) (byte \u)) (== (.at @regparse 0) (byte \U)))
                    (ยง
                        ;; TODO(RE) This needs more testing.
                        ((ร startc =) (coll_get_char))
                        ((ร got_coll_char =) true)
                        (reset! regparse (ยง @regparse.minus(us_ptr_back(old_regparse, @regparse))))
                    )
                    :else
                    (ยง
                        ;; \r,\t,\e,\b
                        ((ร startc =) (ยง backslash_trans(@regparse.at(0))))
                    ))
                )

                ;; Normal printable char.
                (if (== startc -1)
                    ((ร startc =) (us_ptr2char @regparse))
                )

                ;; Previous char was '-', so this char is end of range.
                (cond emit_range
                (ยง
                    ((ร endc =) startc)
                    ((ร startc =) oldstartc)
                    (when (< endc startc)
                        (emsg e_invrange)
                        (reset! rc_did_emsg true)
                        ((ร RETURN) false)
                    )

                    (cond (< (+ startc 2) endc)
                    (ยง
                        ;; Emit a range instead of the sequence of individual characters.
                        (cond (zero? startc)
                        (ยง
                            ;; \x00 is translated to \x0a, start at \x01.
                            (emc1 1)
                        )
                        :else
                        (ยง
                            (swap! post_index dec) ;; remove NFA_CONCAT
                        ))
                        (emc1 endc)
                        (emc1 NFA_RANGE)
                        (emc1 NFA_CONCAT)
                    )
                    (or (< 1 (utf_char2len startc)) (< 1 (utf_char2len endc)))
                    (ยง
                        ;; Emit the characters in the range.
                        ;; "startc" was already emitted, so skip it.

                        ((ร FOR) (ร (ยง c = startc + 1) (<= c endc) (ยง c++))
                            (emc1 c)
                            (emc1 NFA_CONCAT)
                        )
                    )
                    :else
                    (ยง
                        ;; Emit the range. "startc" was already emitted, so skip it.
                        ((ร FOR) (ร (ยง c = startc + 1) (<= c endc) (ยง c++))
                            (emc1 c)
                            (emc1 NFA_CONCAT)
                        )
                    ))
                    ((ร emit_range =) false)
                    ((ร startc =) -1)
                )
                :else
                (ยง
                    ;; This char (startc) is not part of a range.  Just emit it.
                    ;; Normally, simply emit startc.  But if we get char
                    ;; code=0 from a collating char, then replace it with 0x0a.
                    ;; This is needed to completely mimic the behaviour of
                    ;; the backtracking engine.
                    (cond (== startc NFA_NEWL)
                    (ยง
                        ;; Line break can't be matched as part of the collection,
                        ;; add an OR below.  But not for negated range.
                        (if (not negated)
                            ((ร extra =) NFA_ADD_NL)
                        )
                    )
                    :else
                    (ยง
                        (if (and got_coll_char (zero? startc))
                            (emc1 0x0a)
                            (emc1 startc))
                        (emc1 NFA_CONCAT)
                    ))
                ))

                (reset! regparse (ยง @regparse.plus(us_ptr2len_cc(@regparse))))
            )

            (reset! regparse (ยง @regparse.minus(us_ptr_back(old_regparse, @regparse))))
            (when (== (.at @regparse 0) (byte \-))       ;; if last, '-' is just a char
                (emc1 (byte \-))
                (emc1 NFA_CONCAT)
            )

            ;; skip the trailing ]
            (reset! regparse endp)
            (reset! regparse (ยง @regparse.plus(us_ptr2len_cc(@regparse))))

            ;; Mark end of the collection.
            (if negated
                (emc1 NFA_END_NEG_COLL)
                (emc1 NFA_END_COLL))

            ;; \_[] also matches \n but it's not negated
            (when (== extra NFA_ADD_NL)
                (emc1 (if @reg_string NL NFA_NEWL))
                (emc1 NFA_OR)
            )

            ((ร RETURN) true)
        )

        (when @reg_strict
            (emsg e_missingbracket)
            (reset! rc_did_emsg true)
            ((ร RETURN) false)
        )

        (nfa_do_multibyte c, old_regparse)
    ))

(defn- #_final #_boolean nfa_do_multibyte [#_int c, #_Bytes old_regparse]
    (ยง
        (ร int plen)

        ;; plen is length of current char with composing chars
        (cond (or (!= (utf_char2len c) (ยง plen = us_ptr2len_cc(old_regparse))) (utf_iscomposing c))
        (ยง
            ((ร int i =) 0)

            ;; A base character plus composing characters, or just one or more
            ;; composing characters.  This requires creating a separate atom
            ;; as if enclosing the characters in (), where NFA_COMPOSING is
            ;; the ( and NFA_END_COMPOSING is the ).
            ;; Note that right now we are building the postfix form, not the
            ;; NFA itself; a composing char could be: a, b, c, NFA_COMPOSING
            ;; where 'b' and 'c' are chars with codes > 256.
            (while true
                (emc1 c)
                (if (< 0 i)
                    (emc1 NFA_CONCAT))
                (if (<= plen (ยง (i += utf_char2len(c))))
                    (ร BREAK)
                )
                ((ร c =) (ยง us_ptr2char(old_regparse.plus(i))))
            )
            (emc1 NFA_COMPOSING)
            (reset! regparse (.plus old_regparse plen))
        )
        :else
        (ยง
            ((ร c =) (no_Magic c))
            (emc1 c)
        ))

        true
    ))

;; Parse something followed by possible [*+=].
;;
;; A piece is an atom, possibly followed by a multi, an indication of how many
;; times the atom can be matched.  Example: "a*" matches any sequence of "a"
;; characters: "", "a", "aa", etc.
;;
;; piece   ::=      atom
;;      or  atom  multi

(defn- #_boolean nfa_regpiece []
    (ยง
        ;; Save the current parse state, so that we can use it if <atom>{m,n} is next.
        ((ร parse_state_C old_state =) (ยง ยง_parse_state_C()))
        (save_parse_state old_state)

        ;; store current pos in the postfix form, for \{m,n} involving 0s
        ((ร int my_post_start =) @post_index)

        ((ร boolean ret =) (nfa_regatom))
        (if (not ret)
            ((ร RETURN) false)           ;; cascaded error
        )

        ((ร int op =) (peekchr))
        (if (== (re_multi_type op) NOT_MULTI)
            ((ร RETURN) true)
        )

        (skipchr)
        ((ร SWITCH) op
            ((ร CASE) (Magic (byte \*)))
            (ยง
                (emc1 NFA_STAR)
                (ร BREAK)
            )

            ((ร CASE) (Magic (byte \+)))
            (ยง
                ;; Trick: Normally, (a*)\+ would match the whole input "aaa".  The first and
                ;; only submatch would be "aaa".  But the backtracking engine interprets the
                ;; plus as "try matching one more time", and a* matches a second time at the
                ;; end of the input, the empty string.  The submatch will be the empty string.
                ;;
                ;; In order to be consistent with the old engine,
                ;; we replace <atom>+ with <atom><atom>*

                (restore_parse_state old_state)
                (reset! curchr -1)
                (if (not (nfa_regatom))
                    ((ร RETURN) false)
                )
                (emc1 NFA_STAR)
                (emc1 NFA_CONCAT)
                (skipchr)          ;; skip the \+
                (ร BREAK)
            )

            ((ร CASE) (Magic (byte \@)))
            (ยง
                ((ร int c2 =) (getdecchrs))
                ((ร op =) (ยง no_Magic(getchr())))
                ((ร int i =) 0)
                ((ร SWITCH) op
                    ((ร CASE) (byte \=))
                    (ยง
                        ;; \@=
                        ((ร i =) NFA_PREV_ATOM_NO_WIDTH)
                        (ร BREAK)
                    )
                    ((ร CASE) (byte \!))
                    (ยง
                        ;; \@!
                        ((ร i =) NFA_PREV_ATOM_NO_WIDTH_NEG)
                        (ร BREAK)
                    )
                    ((ร CASE) (byte \<))
                    (ยง
                        ((ร op =) (ยง no_Magic(getchr())))
                        (cond (== op (byte \=))
                        (ยง
                            ;; \@<=
                            ((ร i =) NFA_PREV_ATOM_JUST_BEFORE)
                        )
                        (== op (byte \!))
                        (ยง
                            ;; \@<!
                            ((ร i =) NFA_PREV_ATOM_JUST_BEFORE_NEG)
                        ))
                        (ร BREAK)
                    )
                    ((ร CASE) (byte \>))
                    (ยง
                        ;; \@>
                        ((ร i =) NFA_PREV_ATOM_LIKE_PATTERN)
                        (ร BREAK)
                    )
                )
                (when (zero? i)
                    (emsgn (u8 "E869: (NFA) Unknown operator '\\@%c'"), (long op))
                    ((ร RETURN) false)
                )
                (emc1 i)
                (if (or (== i NFA_PREV_ATOM_JUST_BEFORE) (== i NFA_PREV_ATOM_JUST_BEFORE_NEG))
                    (emc1 c2))
                (ร BREAK)
            )

            ((ร CASE) (Magic (byte \?)))
            ((ร CASE) (Magic (byte \=)))
            (ยง
                (emc1 NFA_QUEST)
                (ร BREAK)
            )

            ((ร CASE) (Magic (byte \{)))
            (ยง
                ;; a{2,5} will expand to 'aaa?a?a?'
                ;; a{-1,3} will expand to 'aa??a??', where ?? is the nongreedy version of '?'
                ;; \v(ab){2,3} will expand to '(ab)(ab)(ab)?', where all the parenthesis have the same id

                ((ร boolean greedy =) true)      ;; Braces are prefixed with '-' ?
                ((ร int c2 =) (peekchr))
                (when (or (== c2 (byte \-)) (== c2 (Magic (byte \-))))
                    (skipchr)
                    ((ร greedy =) false)
                )
                ((ร long[] minval =) (ยง new long[1]))
                ((ร long[] maxval =) (ยง new long[1]))
                (when (not (read_limits minval, maxval))
                    (emsg (u8 "E870: (NFA regexp) Error reading repetition limits"))
                    (reset! rc_did_emsg true)
                    ((ร RETURN) false)
                )

                ;;  <atom>{0,inf}, <atom>{0,} and <atom>{}  are equivalent to <atom>*
                (when (and (zero? (ยง minval[0])) (== (ยง maxval[0]) MAX_LIMIT))
                    (cond greedy            ;; { { (match the braces)
                    (ยง
                        ;; \{}, \{0,}
                        (emc1 NFA_STAR)
                    )
                    :else                   ;; { { (match the braces)
                    (ยง
                        ;; \{-}, \{-0,}
                        (emc1 NFA_STAR_NONGREEDY)
                    ))
                    (ร BREAK)
                )

                ;; Special case: x{0} or x{-0}.
                (when (zero? (ยง maxval[0]))
                    ;; Ignore result of previous call to nfa_regatom().
                    (reset! post_index my_post_start)
                    ;; NFA_EMPTY is 0-length and works everywhere.
                    (emc1 NFA_EMPTY)
                    ((ร RETURN) true)
                )

                ;; The engine is very inefficient (uses too many states) when the
                ;; maximum is much larger than the minimum and when the maximum is
                ;; large.  Bail out if we can use the other engine.
                (if (and (non-zero? (& @nfa_re_flags RE_AUTO)) (or (ยง minval[0] + 200 < maxval[0]) (< 500 (ยง maxval[0]))))
                    ((ร RETURN) false)
                )

                ;; Ignore previous call to nfa_regatom().
                (reset! post_index my_post_start)
                ;; Save parse state after the repeated atom and the \{}.
                ((ร parse_state_C new_state =) (ยง ยง_parse_state_C()))
                (save_parse_state new_state)

                ((ร int quest =) (if greedy NFA_QUEST NFA_QUEST_NONGREEDY))
                ((ร FOR) (ร (ยง int i = 0) (ยง i < maxval[0]) (ยง i++))
                    ;; Goto beginning of the repeated atom.
                    (restore_parse_state old_state)
                    ((ร int old_post_pos =) @post_index)
                    (if (not (nfa_regatom))
                        ((ร RETURN) false)
                    )

                    ;; after "minval" times, atoms are optional
                    (when (< (ยง minval[0]) (+ i 1))
                        (cond (== (ยง maxval[0]) MAX_LIMIT)
                        (ยง
                            (if greedy
                                (emc1 NFA_STAR)
                                (emc1 NFA_STAR_NONGREEDY))
                        )
                        :else
                        (ยง
                            (emc1 quest)
                        ))
                    )
                    (if (!= old_post_pos my_post_start)
                        (emc1 NFA_CONCAT))
                    (if (and (< (ยง minval[0]) (+ i 1)) (== (ยง maxval[0]) MAX_LIMIT))
                        (ร BREAK)
                    )
                )

                ;; Go to just after the repeated atom and the \{}.
                (restore_parse_state new_state)
                (reset! curchr -1)
                (ร BREAK)
            )

            (ร DEFAULT)
            (ยง
                (ร BREAK)
            )
        )

        (when (!= (re_multi_type (peekchr)) NOT_MULTI)
            (emsg (u8 "E871: (NFA regexp) Can't have a multi follow a multi !"))
            (reset! rc_did_emsg true)
            ((ร RETURN) false)
        )

        true
    ))

;; Parse one or more pieces, concatenated.  It matches a match for the
;; first piece, followed by a match for the second piece, etc.  Example:
;; "f[0-9]b", first matches "f", then a digit and then "b".
;;
;; concat  ::=      piece
;;      or  piece piece
;;      or  piece piece piece
;;      etc.

(defn- #_boolean nfa_regconcat []
    (ยง
        ((ร boolean cont =) true)
        ((ร boolean first =) true)

        (while cont
            ((ร SWITCH) (peekchr)
                ((ร CASE) NUL)
                ((ร CASE) (Magic (byte \|)))
                ((ร CASE) (Magic (byte \&)))
                ((ร CASE) (Magic (byte \))))
                (ยง
                    ((ร cont =) false)
                    (ร BREAK)
                )

                ((ร CASE) (Magic (byte \Z)))
                (ยง
                    ((ร @regflags |=) RF_ICOMBINE)
                    (skipchr_keepstart)
                    (ร BREAK)
                )

                ((ร CASE) (Magic (byte \c)))
                (ยง
                    ((ร @regflags |=) RF_ICASE)
                    (skipchr_keepstart)
                    (ร BREAK)
                )

                ((ร CASE) (Magic (byte \C)))
                (ยง
                    ((ร @regflags |=) RF_NOICASE)
                    (skipchr_keepstart)
                    (ร BREAK)
                )

                ((ร CASE) (Magic (byte \v)))
                (ยง
                    (reset! reg_magic MAGIC_ALL)
                    (skipchr_keepstart)
                    (reset! curchr -1)
                    (ร BREAK)
                )

                ((ร CASE) (Magic (byte \m)))
                (ยง
                    (reset! reg_magic MAGIC_ON)
                    (skipchr_keepstart)
                    (reset! curchr -1)
                    (ร BREAK)
                )

                ((ร CASE) (Magic (byte \M)))
                (ยง
                    (reset! reg_magic MAGIC_OFF)
                    (skipchr_keepstart)
                    (reset! curchr -1)
                    (ร BREAK)
                )

                ((ร CASE) (Magic (byte \V)))
                (ยง
                    (reset! reg_magic MAGIC_NONE)
                    (skipchr_keepstart)
                    (reset! curchr -1)
                    (ร BREAK)
                )

                (ร DEFAULT)
                (ยง
                    (if (not (nfa_regpiece))
                        ((ร RETURN) false)
                    )
                    (if (not first)
                        (emc1 NFA_CONCAT)
                        ((ร first =) false)
                    )
                    (ร BREAK)
                )
            )
        )

        true
    ))

;; Parse a branch, one or more concats, separated by "\&".  It matches the
;; last concat, but only if all the preceding concats also match at the same
;; position.  Examples:
;;      "foobeep\&..." matches "foo" in "foobeep".
;;      ".*Peter\&.*Bob" matches in a line containing both "Peter" and "Bob"
;;
;; branch ::=       concat
;;              or  concat \& concat
;;              or  concat \& concat \& concat
;;              etc.

(defn- #_boolean nfa_regbranch []
    (ยง
        ((ร int old_post_pos =) @post_index)

        ;; First branch, possibly the only one.
        (if (not (nfa_regconcat))
            ((ร RETURN) false)
        )

        ((ร int ch =) (peekchr))
        ;; Try next concats.
        (while (ยง ch == Magic((byte \&)))
            (skipchr)
            (emc1 NFA_NOPEN)
            (emc1 NFA_PREV_ATOM_NO_WIDTH)
            ((ร old_post_pos =) @post_index)
            (if (not (nfa_regconcat))
                ((ร RETURN) false)
            )
            ;; if concat is empty do emit a node
            (if (== old_post_pos @post_index)
                (emc1 NFA_EMPTY))
            (emc1 NFA_CONCAT)
            ((ร ch =) (peekchr))
        )

        ;; if a branch is empty, emit one node for it
        (if (== old_post_pos @post_index)
            (emc1 NFA_EMPTY))

        true
    ))

;; Parse a pattern, one or more branches, separated by "\|".
;; It matches anything that matches one of the branches.
;; Example: "foo\|beep" matches "foo" and matches "beep".
;; If more than one branch matches, the first one is used.
;;
;; pattern ::=     branch
;;     or  branch \| branch
;;     or  branch \| branch \| branch
;;     etc.

(defn- #_boolean nfa_reg [#_int paren]
    ;; paren: REG_NOPAREN, REG_PAREN, REG_NPAREN or REG_ZPAREN
    (ยง
        ((ร int parno =) 0)

        (cond (== paren REG_PAREN)
        (ยง
            (when (<= NSUBEXP @regnpar)
                (emsg (u8 "E872: (NFA regexp) Too many '('"))
                (reset! rc_did_emsg true)
                ((ร RETURN) false)
            )
            ((ร parno =) (ยง @regnpar++))
        )
        (== paren REG_ZPAREN)
        (ยง
            ;; Make a ZOPEN node.
            (when (<= NSUBEXP @regnzpar)
                (emsg (u8 "E879: (NFA regexp) Too many \\z("))
                (reset! rc_did_emsg true)
                ((ร RETURN) false)
            )
            ((ร parno =) (ยง @regnzpar++))
        ))

        (if (not (nfa_regbranch))
            ((ร RETURN) false)                   ;; cascaded error
        )

        (while (ยง peekchr() == Magic((byte \|)))
            (skipchr)
            (if (not (nfa_regbranch))
                ((ร RETURN) false)               ;; cascaded error
            )
            (emc1 NFA_OR)
        )

        ;; Check for proper termination.
        (cond (and (!= paren REG_NOPAREN) (!= (getchr) (Magic (byte \)))))
        (ยง
            (if (== paren REG_NPAREN)
                (emsg2 e_unmatchedpp, (if (== @reg_magic MAGIC_ALL) (u8 "") (u8 "\\")))
                (emsg2 e_unmatchedp, (if (== @reg_magic MAGIC_ALL) (u8 "") (u8 "\\"))))
            (reset! rc_did_emsg true)
            ((ร RETURN) false)
        )
        (and (== paren REG_NOPAREN) (!= (peekchr) NUL))
        (ยง
            (if (== (peekchr) (Magic (byte \))))
                (emsg2 e_unmatchedpar, (if (== @reg_magic MAGIC_ALL) (u8 "") (u8 "\\")))
                (emsg (u8 "E873: (NFA regexp) proper termination error")))
            (reset! rc_did_emsg true)
            ((ร RETURN) false)
        ))

        ;; Here we set the flag allowing back references to this set of parentheses.

        (cond (== paren REG_PAREN)
        (ยง
            ((ร @had_endbrace[parno] =) true)     ;; have seen the close paren
            (emc1 (+ NFA_MOPEN parno))
        )
        (== paren REG_ZPAREN)
        (ยง
            (emc1 (+ NFA_ZOPEN parno))
        ))

        true
    ))

;; Parse r.e. @expr and convert it into postfix form.
;; Return the postfix string on success, null otherwise.

(defn- #_int* re2post []
    (ยง
        (if (not (nfa_reg REG_NOPAREN))
            ((ร RETURN) null)
        )

        (emc1 NFA_MOPEN)
        @post_array
    ))

;; Represents an NFA state plus zero or one or two arrows exiting.
;; if c == MATCH, no arrows out; matching state.
;; If c == SPLIT, unlabeled arrows to out0 and out1 (if != null).
;; If c < 256, labeled arrow with character c to out0.

(atom! nfa_state_C* nfa_states) ;; points to nfa_prog.states

;; Allocate and initialize nfa_state_C.

(defn- #_nfa_state_C alloc_state [#_nfa_regprog_C prog, #_int c, #_nfa_state_C out0, #_nfa_state_C out1]
    (ยง
        (if (<= (. prog nstate) (. prog istate))
            ((ร RETURN) null)
        )

        ((ร nfa_state_C state =) (ยง @nfa_states[prog.istate++] = ยง_nfa_state_C()))

        ((ร state.c =) c)
        (ยง state.out0(out0))
        (ยง state.out1(out1))
        ((ร state.val =) 0)

        ((ร state.id =) (. prog istate))
        ((ร state.lastlist[0] =) 0)
        ((ร state.lastlist[1] =) 0)

        state
    ))

;; Estimate the maximum byte length of anything matching "state".
;; When unknown or unlimited return -1.

(defn- #_int nfa_max_width [#_nfa_state_C startstate, #_int depth]
    (ยง
        ;; detect looping in a NFA_SPLIT
        (if (< 4 depth)
            ((ร RETURN) -1)
        )

        ((ร int len =) 0)

        ((ร FOR) (ร (ยง nfa_state_C state = startstate) (!= state null) nil)
            ((ร SWITCH) (. state c)
                ((ร CASE) NFA_END_INVISIBLE)
                ((ร CASE) NFA_END_INVISIBLE_NEG)
                (ยง
                    ;; the end, return what we have
                    ((ร RETURN) len)
                )

                ((ร CASE) NFA_SPLIT)
                (ยง
                    ;; two alternatives, use the maximum
                    ((ร int l =) (ยง nfa_max_width(state.out0(), depth + 1)))
                    ((ร int r =) (ยง nfa_max_width(state.out1(), depth + 1)))
                    (if (or (< l 0) (< r 0))
                        ((ร RETURN) -1)
                    )

                    ((ร RETURN) (+ len (if (< r l) l r)))
                )

                ((ร CASE) NFA_ANY)
                ((ร CASE) NFA_START_COLL)
                ((ร CASE) NFA_START_NEG_COLL)
                (ยง
                    ;; matches some character, including composing chars
                    ((ร len +=) MB_MAXBYTES)
                    (when (!= (. state c) NFA_ANY)
                        ;; skip over the characters
                        ((ร state =) (ยง state.out1().out0()))
                        (ร CONTINUE)
                    )
                    (ร BREAK)
                )

                ((ร CASE) NFA_DIGIT)
                ((ร CASE) NFA_WHITE)
                ((ร CASE) NFA_HEX)
                ((ร CASE) NFA_OCTAL)
                (ยง
                    ;; ascii
                    (ยง len++)
                    (ร BREAK)
                )

                ((ร CASE) NFA_IDENT)
                ((ร CASE) NFA_SIDENT)
                ((ร CASE) NFA_KWORD)
                ((ร CASE) NFA_SKWORD)
                ((ร CASE) NFA_FNAME)
                ((ร CASE) NFA_SFNAME)
                ((ร CASE) NFA_PRINT)
                ((ร CASE) NFA_SPRINT)
                ((ร CASE) NFA_NWHITE)
                ((ร CASE) NFA_NDIGIT)
                ((ร CASE) NFA_NHEX)
                ((ร CASE) NFA_NOCTAL)
                ((ร CASE) NFA_WORD)
                ((ร CASE) NFA_NWORD)
                ((ร CASE) NFA_HEAD)
                ((ร CASE) NFA_NHEAD)
                ((ร CASE) NFA_ALPHA)
                ((ร CASE) NFA_NALPHA)
                ((ร CASE) NFA_LOWER)
                ((ร CASE) NFA_NLOWER)
                ((ร CASE) NFA_UPPER)
                ((ร CASE) NFA_NUPPER)
                ((ร CASE) NFA_LOWER_IC)
                ((ร CASE) NFA_NLOWER_IC)
                ((ร CASE) NFA_UPPER_IC)
                ((ร CASE) NFA_NUPPER_IC)
                ((ร CASE) NFA_ANY_COMPOSING)
                (ยง
                    ;; possibly non-ascii
                    ((ร len +=) 3)
                    (ร BREAK)
                )

                ((ร CASE) NFA_START_INVISIBLE)
                ((ร CASE) NFA_START_INVISIBLE_NEG)
                ((ร CASE) NFA_START_INVISIBLE_BEFORE)
                ((ร CASE) NFA_START_INVISIBLE_BEFORE_NEG)
                (ยง
                    ;; zero-width, out1 points to the END state
                    ((ร state =) (ยง state.out1().out0()))
                    (ร CONTINUE)
                )

                ((ร CASE) NFA_BACKREF1)
                ((ร CASE) NFA_BACKREF2)
                ((ร CASE) NFA_BACKREF3)
                ((ร CASE) NFA_BACKREF4)
                ((ร CASE) NFA_BACKREF5)
                ((ร CASE) NFA_BACKREF6)
                ((ร CASE) NFA_BACKREF7)
                ((ร CASE) NFA_BACKREF8)
                ((ร CASE) NFA_BACKREF9)
                ((ร CASE) NFA_ZREF1)
                ((ร CASE) NFA_ZREF2)
                ((ร CASE) NFA_ZREF3)
                ((ร CASE) NFA_ZREF4)
                ((ร CASE) NFA_ZREF5)
                ((ร CASE) NFA_ZREF6)
                ((ร CASE) NFA_ZREF7)
                ((ร CASE) NFA_ZREF8)
                ((ร CASE) NFA_ZREF9)
                ((ร CASE) NFA_NEWL)
                ((ร CASE) NFA_SKIP)
                (ยง
                    ;; unknown width
                    ((ร RETURN) -1)
                )

                ((ร CASE) NFA_BOL)
                ((ร CASE) NFA_EOL)
                ((ร CASE) NFA_BOF)
                ((ร CASE) NFA_EOF)
                ((ร CASE) NFA_BOW)
                ((ร CASE) NFA_EOW)
                ((ร CASE) NFA_MOPEN)
                ((ร CASE) NFA_MOPEN1)
                ((ร CASE) NFA_MOPEN2)
                ((ร CASE) NFA_MOPEN3)
                ((ร CASE) NFA_MOPEN4)
                ((ร CASE) NFA_MOPEN5)
                ((ร CASE) NFA_MOPEN6)
                ((ร CASE) NFA_MOPEN7)
                ((ร CASE) NFA_MOPEN8)
                ((ร CASE) NFA_MOPEN9)
                ((ร CASE) NFA_ZOPEN)
                ((ร CASE) NFA_ZOPEN1)
                ((ร CASE) NFA_ZOPEN2)
                ((ร CASE) NFA_ZOPEN3)
                ((ร CASE) NFA_ZOPEN4)
                ((ร CASE) NFA_ZOPEN5)
                ((ร CASE) NFA_ZOPEN6)
                ((ร CASE) NFA_ZOPEN7)
                ((ร CASE) NFA_ZOPEN8)
                ((ร CASE) NFA_ZOPEN9)
                ((ร CASE) NFA_ZCLOSE)
                ((ร CASE) NFA_ZCLOSE1)
                ((ร CASE) NFA_ZCLOSE2)
                ((ร CASE) NFA_ZCLOSE3)
                ((ร CASE) NFA_ZCLOSE4)
                ((ร CASE) NFA_ZCLOSE5)
                ((ร CASE) NFA_ZCLOSE6)
                ((ร CASE) NFA_ZCLOSE7)
                ((ร CASE) NFA_ZCLOSE8)
                ((ร CASE) NFA_ZCLOSE9)
                ((ร CASE) NFA_MCLOSE)
                ((ร CASE) NFA_MCLOSE1)
                ((ร CASE) NFA_MCLOSE2)
                ((ร CASE) NFA_MCLOSE3)
                ((ร CASE) NFA_MCLOSE4)
                ((ร CASE) NFA_MCLOSE5)
                ((ร CASE) NFA_MCLOSE6)
                ((ร CASE) NFA_MCLOSE7)
                ((ร CASE) NFA_MCLOSE8)
                ((ร CASE) NFA_MCLOSE9)
                ((ร CASE) NFA_NOPEN)
                ((ร CASE) NFA_NCLOSE)

                ((ร CASE) NFA_LNUM_GT)
                ((ร CASE) NFA_LNUM_LT)
                ((ร CASE) NFA_COL_GT)
                ((ร CASE) NFA_COL_LT)
                ((ร CASE) NFA_VCOL_GT)
                ((ร CASE) NFA_VCOL_LT)
                ((ร CASE) NFA_MARK_GT)
                ((ร CASE) NFA_MARK_LT)
                ((ร CASE) NFA_VISUAL)
                ((ร CASE) NFA_LNUM)
                ((ร CASE) NFA_CURSOR)
                ((ร CASE) NFA_COL)
                ((ร CASE) NFA_VCOL)
                ((ร CASE) NFA_MARK)

                ((ร CASE) NFA_ZSTART)
                ((ร CASE) NFA_ZEND)
                ((ร CASE) NFA_OPT_CHARS)
                ((ร CASE) NFA_EMPTY)
                ((ร CASE) NFA_START_PATTERN)
                ((ร CASE) NFA_END_PATTERN)
                ((ร CASE) NFA_COMPOSING)
                ((ร CASE) NFA_END_COMPOSING)
                (ยง
                    ;; zero-width
                    (ร BREAK)
                )

                (ร DEFAULT)
                (ยง
                    (when (< (. state c) 0)
                        ;; don't know what this is
                        ((ร RETURN) -1)
                    )
                    ;; normal character
                    ((ร len +=) (ยง utf_char2len(state.c)))
                    (ร BREAK)
                )
            )

            ;; normal way to continue
            ((ร state =) (ยง state.out0()))
        )

        ;; unrecognized, "cannot happen"
        -1
    ))

;; A partially built NFA without the matching state filled in.
;; frag_C.fr_start points at the start state.
;; frag_C.fr_out is a list of places that need to be set to the next state for this fragment.

;; Since the out pointers in the list are always uninitialized,
;; we use the pointers themselves as storage for the fragnode_C.

(class! #_final fragnode_C
    [
        (field #_"/*fragnode_C*/"Object     fn_next)
    ])

(class! #_final frag_C
    [
        (field nfa_state_C  fr_start)
        (field fragnode_C   fr_out)
    ])

(defn- #_void COPY_frag [#_frag_C fr1, #_frag_C fr0]
    (ยง
        ((ร fr1.fr_start =) (. fr0 fr_start))
        ((ร fr1.fr_out =) (. fr0 fr_out))
    ))

;; Initialize a frag_C struct and return it.

(defn- #_frag_C alloc_frag [#_nfa_state_C start, #_fragnode_C out]
    (ยง
        ((ร frag_C frag =) (ยง ยง_frag_C()))

        ((ร frag.fr_start =) start)
        ((ร frag.fr_out =) out)

        frag
    ))

;; Create singleton list containing just outp.

(defn- #_fragnode_C fr_single [#_fragnode_C node]
    (ยง
        ((ร node.fn_next =) null)
        node
    ))

;; Patch the list of states at out to point to start.

(defn- #_void fr_patch [#_fragnode_C node, #_nfa_state_C start]
    (ยง
        ((ร FOR) (ร (ยง fragnode_C next) (!= node null) (ยง node = next))
            ((ร next =) (ยง (fragnode_C)node.fn_next))
            ((ร node.fn_next =) start)
        )
    ))

;; Join the two lists returning the concatenation.

(defn- #_fragnode_C fr_append [#_fragnode_C head, #_fragnode_C tail]
    (ยง
        ((ร fragnode_C list =) head)

        (while (ยง head.fn_next != null)
            ((ร head =) (ยง (fragnode_C)head.fn_next))
        )
        ((ร head.fn_next =) tail)

        list
    ))

;; Stack used for transforming postfix form into NFA.

(class! #_final nfa_stack_C
    [
        (field frag_C*      st_base)
        (field int          st_next)
        (field int          st_over)
    ])

(defn- #_nfa_stack_C new_nfa_stack [#_int n]
    (->nfa_stack_C (frag_C* n) 0 n))

;; Push an item onto the stack.

(defn- #_boolean st_push [#_nfa_stack_C stack, #_frag_C frag]
    (ยง
        (when (< (. stack st_next) (. stack st_over))
            ((ร stack.st_base[stack.st_next++] =) frag)
            ((ร RETURN) true)
        )

        false
    ))

;; Pop an item from the stack.

(defn- #_frag_C st_pop [#_nfa_stack_C stack]
    (ยง
        (if (< (ยง --stack.st_next) 0)
            ((ร RETURN) null)
        )

        ((ร frag_C frag =) (ยง stack.st_base[stack.st_next]))
        ((ร stack.st_base[stack.st_next] =) null)
        frag
    ))

(defn- #_nfa_state_C st_error [#_int* _postfix, #_int _i, #_int _over]
    (ยง
        (emsg (u8 "E874: (NFA) Could not pop the stack !"))
        null
    ))

;; Convert a postfix form into its equivalent NFA.
;; Return the NFA start state on success, null otherwise.

(defn- #_nfa_state_C post2nfa [#_int* postfix, #_int over, #_nfa_regprog_C prog, #_boolean nfa_calc_size]
    (ยง
        (if (nil? postfix)
            ((ร RETURN) null)
        )

        ((ร nfa_stack_C stack =) (if nfa_calc_size null (new_nfa_stack (+ (. prog nstate) 1))))

        (ร int i)
        ((ร FOR) (ร (ยง i = 0) (< i over) (ยง i++))
            ((ร SWITCH) (ยง postfix[i])
                ((ร CASE) NFA_CONCAT)
                (ยง
                    ;; Concatenation.
                    ;; Pay attention: this operator does not exist in the r.e. itself (it is implicit, really).
                    ;; It is added when r.e. is translated to postfix form in re2post().
                    (when nfa_calc_size
                        ;; prog.nstate += 0;
                        (ร BREAK)
                    )

                    ((ร frag_C e2 =) (st_pop stack))
                    (if (nil? e2)
                        ((ร RETURN) (st_error postfix, i, over))
                    )
                    ((ร frag_C e1 =) (st_pop stack))
                    (if (nil? e1)
                        ((ร RETURN) (st_error postfix, i, over))
                    )
                    (fr_patch (. e1 fr_out), (. e2 fr_start))
                    (st_push stack, (alloc_frag (. e1 fr_start), (. e2 fr_out)))
                    (ร BREAK)
                )

                ((ร CASE) NFA_OR)
                (ยง
                    ;; Alternation.
                    (when nfa_calc_size
                        (ยง prog.nstate++)
                        (ร BREAK)
                    )

                    ((ร frag_C e2 =) (st_pop stack))
                    (if (nil? e2)
                        ((ร RETURN) (st_error postfix, i, over))
                    )
                    ((ร frag_C e1 =) (st_pop stack))
                    (if (nil? e1)
                        ((ร RETURN) (st_error postfix, i, over))
                    )
                    ((ร nfa_state_C s0 =) (ยง alloc_state(prog, NFA_SPLIT, e1.fr_start, e2.fr_start)))
                    (if (nil? s0)
                        ((ร RETURN) null)
                    )
                    (st_push stack, (alloc_frag s0, (fr_append (. e1 fr_out), (. e2 fr_out))))
                    (ร BREAK)
                )

                ((ร CASE) NFA_STAR)
                (ยง
                    ;; Zero or more, prefer more.
                    (when nfa_calc_size
                        (ยง prog.nstate++)
                        (ร BREAK)
                    )

                    ((ร frag_C e0 =) (st_pop stack))
                    (if (nil? e0)
                        ((ร RETURN) (st_error postfix, i, over))
                    )
                    ((ร nfa_state_C s0 =) (ยง alloc_state(prog, NFA_SPLIT, e0.fr_start, null)))
                    (if (nil? s0)
                        ((ร RETURN) null)
                    )
                    (fr_patch (. e0 fr_out), s0)
                    (st_push stack, (alloc_frag s0, (fr_single (. s0 out1))))
                    (ร BREAK)
                )

                ((ร CASE) NFA_STAR_NONGREEDY)
                (ยง
                    ;; Zero or more, prefer zero.
                    (when nfa_calc_size
                        (ยง prog.nstate++)
                        (ร BREAK)
                    )

                    ((ร frag_C e0 =) (st_pop stack))
                    (if (nil? e0)
                        ((ร RETURN) (st_error postfix, i, over))
                    )
                    ((ร nfa_state_C s0 =) (ยง alloc_state(prog, NFA_SPLIT, null, e0.fr_start)))
                    (if (nil? s0)
                        ((ร RETURN) null)
                    )
                    (fr_patch (. e0 fr_out), s0)
                    (st_push stack, (alloc_frag s0, (fr_single (. s0 out0))))
                    (ร BREAK)
                )

                ((ร CASE) NFA_QUEST)
                (ยง
                    ;; one or zero atoms=> greedy match
                    (when nfa_calc_size
                        (ยง prog.nstate++)
                        (ร BREAK)
                    )

                    ((ร frag_C e0 =) (st_pop stack))
                    (if (nil? e0)
                        ((ร RETURN) (st_error postfix, i, over))
                    )
                    ((ร nfa_state_C s0 =) (ยง alloc_state(prog, NFA_SPLIT, e0.fr_start, null)))
                    (if (nil? s0)
                        ((ร RETURN) null)
                    )
                    (st_push stack, (alloc_frag s0, (fr_append (. e0 fr_out), (fr_single (. s0 out1)))))
                    (ร BREAK)
                )

                ((ร CASE) NFA_QUEST_NONGREEDY)
                (ยง
                    ;; zero or one atoms => non-greedy match
                    (when nfa_calc_size
                        (ยง prog.nstate++)
                        (ร BREAK)
                    )

                    ((ร frag_C e0 =) (st_pop stack))
                    (if (nil? e0)
                        ((ร RETURN) (st_error postfix, i, over))
                    )
                    ((ร nfa_state_C s0 =) (ยง alloc_state(prog, NFA_SPLIT, null, e0.fr_start)))
                    (if (nil? s0)
                        ((ร RETURN) null)
                    )
                    (st_push stack, (alloc_frag s0, (fr_append (. e0 fr_out), (fr_single (. s0 out0)))))
                    (ร BREAK)
                )

                ((ร CASE) NFA_END_COLL)
                ((ร CASE) NFA_END_NEG_COLL)
                (ยง
                    ;; On the stack is the sequence starting with NFA_START_COLL or
                    ;; NFA_START_NEG_COLL and all possible characters.  Patch it to
                    ;; add the output to the start.
                    (when nfa_calc_size
                        (ยง prog.nstate++)
                        (ร BREAK)
                    )

                    ((ร frag_C e0 =) (st_pop stack))
                    (if (nil? e0)
                        ((ร RETURN) (st_error postfix, i, over))
                    )
                    ((ร nfa_state_C s0 =) (alloc_state prog, NFA_END_COLL, null, null))
                    (if (nil? s0)
                        ((ร RETURN) null)
                    )
                    (fr_patch (. e0 fr_out), s0)
;                   e0.fr_start.out1(s0);
                    (st_push stack, (alloc_frag (. e0 fr_start), (fr_single (. s0 out0))))
                    (ร BREAK)
                )

                ((ร CASE) NFA_RANGE)
                (ยง
                    ;; Before this are two characters, the low and high end of a range.
                    ;; Turn them into two states with MIN and MAX.
                    (when nfa_calc_size
                        ;; prog.nstate += 0;
                        (ร BREAK)
                    )

                    ((ร frag_C e2 =) (st_pop stack))
                    (if (nil? e2)
                        ((ร RETURN) (st_error postfix, i, over))
                    )
                    ((ร frag_C e1 =) (st_pop stack))
                    (if (nil? e1)
                        ((ร RETURN) (st_error postfix, i, over))
                    )
                    ((ร e2.fr_start.val =) (.. e2 fr_start c))
                    ((ร e2.fr_start.c =) NFA_RANGE_MAX)
                    ((ร e1.fr_start.val =) (.. e1 fr_start c))
                    ((ร e1.fr_start.c =) NFA_RANGE_MIN)
                    (fr_patch (. e1 fr_out), (. e2 fr_start))
                    (st_push stack, (alloc_frag (. e1 fr_start), (. e2 fr_out)))
                    (ร BREAK)
                )

                ((ร CASE) NFA_EMPTY)
                (ยง
                    ;; 0-length, used in a repetition with max/min count of 0
                    (when nfa_calc_size
                        (ยง prog.nstate++)
                        (ร BREAK)
                    )

                    ((ร nfa_state_C s0 =) (alloc_state prog, NFA_EMPTY, null, null))
                    (if (nil? s0)
                        ((ร RETURN) null)
                    )
                    (st_push stack, (alloc_frag s0, (fr_single (. s0 out0))))
                    (ร BREAK)
                )

                ((ร CASE) NFA_OPT_CHARS)
                (ยง
                    ;; \%[abc] implemented as:
                    ;;    NFA_SPLIT
                    ;;    +-CHAR(a)
                    ;;    | +-NFA_SPLIT
                    ;;    |   +-CHAR(b)
                    ;;    |   | +-NFA_SPLIT
                    ;;    |   |   +-CHAR(c)
                    ;;    |   |   | +-next
                    ;;    |   |   +- next
                    ;;    |   +- next
                    ;;    +- next

                    ((ร int n =) (ยง postfix[++i]))                           ;; get number of characters
                    (when nfa_calc_size
                        ((ร prog.nstate +=) n)
                        (ร BREAK)
                    )

                    ((ร frag_C e1 =) (alloc_frag null, null))     ;; e1.fr_out: stores list with out1's
                    ((ร nfa_state_C s0 =) null)
                    ((ร FOR) (ร (ยง nfa_state_C s1 = null) (ยง 0 < n--) (ยง s1 = s0))  ;; s1: previous NFA_SPLIT to connect to
                        ((ร frag_C e0 =) (st_pop stack))          ;; get character
                        (if (nil? e0)
                            ((ร RETURN) (st_error postfix, i, over))
                        )
                        ((ร s0 =) (ยง alloc_state(prog, NFA_SPLIT, e0.fr_start, null)))
                        (if (nil? s0)
                            ((ร RETURN) null)
                        )
                        (if (nil? (. e1 fr_out))
                            (COPY_frag e1, e0))
                        (fr_patch (. e0 fr_out), s1)
                        (fr_append (. e1 fr_out), (fr_single (. s0 out1)))
                    )
                    (st_push stack, (alloc_frag s0, (. e1 fr_out)))
                    (ร BREAK)
                )

                ((ร CASE) NFA_PREV_ATOM_NO_WIDTH)
                ((ร CASE) NFA_PREV_ATOM_NO_WIDTH_NEG)
                ((ร CASE) NFA_PREV_ATOM_JUST_BEFORE)
                ((ร CASE) NFA_PREV_ATOM_JUST_BEFORE_NEG)
                ((ร CASE) NFA_PREV_ATOM_LIKE_PATTERN)
                (ยง
                    ((ร boolean before =) (ยง (postfix[i] == NFA_PREV_ATOM_JUST_BEFORE || postfix[i] == NFA_PREV_ATOM_JUST_BEFORE_NEG)))
                    ((ร boolean pattern =) (ยง (postfix[i] == NFA_PREV_ATOM_LIKE_PATTERN)))

                    (ร int start_state, end_state)
                    ((ร SWITCH) (ยง postfix[i])
                        ((ร CASE) NFA_PREV_ATOM_NO_WIDTH)
                        (ยง
                            ((ร start_state =) NFA_START_INVISIBLE)
                            ((ร end_state =) NFA_END_INVISIBLE)
                            (ร BREAK)
                        )
                        ((ร CASE) NFA_PREV_ATOM_NO_WIDTH_NEG)
                        (ยง
                            ((ร start_state =) NFA_START_INVISIBLE_NEG)
                            ((ร end_state =) NFA_END_INVISIBLE_NEG)
                            (ร BREAK)
                        )
                        ((ร CASE) NFA_PREV_ATOM_JUST_BEFORE)
                        (ยง
                            ((ร start_state =) NFA_START_INVISIBLE_BEFORE)
                            ((ร end_state =) NFA_END_INVISIBLE)
                            (ร BREAK)
                        )
                        ((ร CASE) NFA_PREV_ATOM_JUST_BEFORE_NEG)
                        (ยง
                            ((ร start_state =) NFA_START_INVISIBLE_BEFORE_NEG)
                            ((ร end_state =) NFA_END_INVISIBLE_NEG)
                            (ร BREAK)
                        )
                        (ร DEFAULT) ;; NFA_PREV_ATOM_LIKE_PATTERN:
                        (ยง
                            ((ร start_state =) NFA_START_PATTERN)
                            ((ร end_state =) NFA_END_PATTERN)
                            (ร BREAK)
                        )
                    )

                    ((ร int n =) (if before (ยง postfix[++i]) 0))    ;; get the count

                    ;; The \@= operator: match the preceding atom with zero width.
                    ;; The \@! operator: no match for the preceding atom.
                    ;; The \@<= operator: match for the preceding atom.
                    ;; The \@<! operator: no match for the preceding atom.
                    ;; Surrounds the preceding atom with START_INVISIBLE and END_INVISIBLE, similarly to MOPEN.

                    (when nfa_calc_size
                        ((ร prog.nstate +=) (if pattern 4 2))
                        (ร BREAK)
                    )

                    ((ร frag_C e0 =) (st_pop stack))
                    (if (nil? e0)
                        ((ร RETURN) (st_error postfix, i, over))
                    )

                    ((ร nfa_state_C s1 =) (alloc_state prog, end_state, null, null))
                    (if (nil? s1)
                        ((ร RETURN) null)
                    )

                    ((ร nfa_state_C s0 =) (ยง alloc_state(prog, start_state, e0.fr_start, s1)))
                    (if (nil? s0)
                        ((ร RETURN) null)
                    )

                    (cond pattern
                    (ยง
                        ;; NFA_ZEND -> NFA_END_PATTERN -> NFA_SKIP -> what follows.
                        ((ร nfa_state_C skip =) (alloc_state prog, NFA_SKIP, null, null))
                        ((ร nfa_state_C zend =) (alloc_state prog, NFA_ZEND, s1, null))
                        (ยง s1.out0(skip))
                        (fr_patch (. e0 fr_out), zend)
                        (st_push stack, (alloc_frag s0, (fr_single (. skip out0))))
                    )
                    :else
                    (ยง
                        (fr_patch (. e0 fr_out), s1)
                        (st_push stack, (alloc_frag s0, (fr_single (. s1 out0))))
                        (when before
                            ;; See if we can guess the maximum width, it avoids a lot of pointless tries.
                            (if (<= n 0)
                                ((ร n =) (ยง nfa_max_width(e0.fr_start, 0)))
                            )
                            ((ร s0.val =) n) ;; store the count
                        )
                    ))
                    (ร BREAK)
                )

                ((ร CASE) NFA_COMPOSING)     ;; char with composing char
                (ยง
                    (when (non-zero? (& @regflags RF_ICOMBINE))
                        ;; TODO: use the base character only
                    )
                    (ร FALLTHROUGH)
                )

                ((ร CASE) NFA_MOPEN) ;; \( \) Submatch
                ((ร CASE) NFA_MOPEN1)
                ((ร CASE) NFA_MOPEN2)
                ((ร CASE) NFA_MOPEN3)
                ((ร CASE) NFA_MOPEN4)
                ((ร CASE) NFA_MOPEN5)
                ((ร CASE) NFA_MOPEN6)
                ((ร CASE) NFA_MOPEN7)
                ((ร CASE) NFA_MOPEN8)
                ((ร CASE) NFA_MOPEN9)
                ((ร CASE) NFA_ZOPEN) ;; \z( \) Submatch
                ((ร CASE) NFA_ZOPEN1)
                ((ร CASE) NFA_ZOPEN2)
                ((ร CASE) NFA_ZOPEN3)
                ((ร CASE) NFA_ZOPEN4)
                ((ร CASE) NFA_ZOPEN5)
                ((ร CASE) NFA_ZOPEN6)
                ((ร CASE) NFA_ZOPEN7)
                ((ร CASE) NFA_ZOPEN8)
                ((ร CASE) NFA_ZOPEN9)
                ((ร CASE) NFA_NOPEN) ;; \%( \) "Invisible Submatch"
                (ยง
                    (when nfa_calc_size
                        ((ร prog.nstate +=) 2)
                        (ร BREAK)
                    )

                    ((ร int mopen =) (ยง postfix[i], mclose))
                    ((ร SWITCH) (ยง postfix[i])
                        ((ร CASE) NFA_NOPEN)
                        (ยง
                            ((ร mclose =) NFA_NCLOSE)
                            (ร BREAK)
                        )
                        ((ร CASE) NFA_ZOPEN)
                        (ยง
                            ((ร mclose =) NFA_ZCLOSE)
                            (ร BREAK)
                        )
                        ((ร CASE) NFA_ZOPEN1)
                        (ยง
                            ((ร mclose =) NFA_ZCLOSE1)
                            (ร BREAK)
                        )
                        ((ร CASE) NFA_ZOPEN2)
                        (ยง
                            ((ร mclose =) NFA_ZCLOSE2)
                            (ร BREAK)
                        )
                        ((ร CASE) NFA_ZOPEN3)
                        (ยง
                            ((ร mclose =) NFA_ZCLOSE3)
                            (ร BREAK)
                        )
                        ((ร CASE) NFA_ZOPEN4)
                        (ยง
                            ((ร mclose =) NFA_ZCLOSE4)
                            (ร BREAK)
                        )
                        ((ร CASE) NFA_ZOPEN5)
                        (ยง
                            ((ร mclose =) NFA_ZCLOSE5)
                            (ร BREAK)
                        )
                        ((ร CASE) NFA_ZOPEN6)
                        (ยง
                            ((ร mclose =) NFA_ZCLOSE6)
                            (ร BREAK)
                        )
                        ((ร CASE) NFA_ZOPEN7)
                        (ยง
                            ((ร mclose =) NFA_ZCLOSE7)
                            (ร BREAK)
                        )
                        ((ร CASE) NFA_ZOPEN8)
                        (ยง
                            ((ร mclose =) NFA_ZCLOSE8)
                            (ร BREAK)
                        )
                        ((ร CASE) NFA_ZOPEN9)
                        (ยง
                            ((ร mclose =) NFA_ZCLOSE9)
                            (ร BREAK)
                        )
                        ((ร CASE) NFA_COMPOSING)
                        (ยง
                            ((ร mclose =) NFA_END_COMPOSING)
                            (ร BREAK)
                        )
                        (ร DEFAULT)
                        (ยง
                            ;; NFA_MOPEN, NFA_MOPEN1 .. NFA_MOPEN9
                            ((ร mclose =) (ยง postfix[i] + NSUBEXP))
                            (ร BREAK)
                        )
                    )

                    ;; Allow "NFA_MOPEN" as a valid postfix representation for the empty regexp "".
                    ;; In this case, the NFA will be NFA_MOPEN -> NFA_MCLOSE.  Note that this also
                    ;; allows empty groups of parenthesis, and empty mbyte chars.
                    (when (zero? (. stack st_next))
                        ((ร nfa_state_C s0 =) (alloc_state prog, mopen, null, null))
                        (if (nil? s0)
                            ((ร RETURN) null)
                        )
                        ((ร nfa_state_C s1 =) (alloc_state prog, mclose, null, null))
                        (if (nil? s1)
                            ((ร RETURN) null)
                        )
                        (fr_patch (fr_single (. s0 out0)), s1)
                        (st_push stack, (alloc_frag s0, (fr_single (. s1 out0))))
                        (ร BREAK)
                    )

                    ;; At least one node was emitted before NFA_MOPEN, so
                    ;; at least one node will be between NFA_MOPEN and NFA_MCLOSE.
                    ((ร frag_C e0 =) (st_pop stack))
                    (if (nil? e0)
                        ((ร RETURN) (st_error postfix, i, over))
                    )
                    ((ร nfa_state_C s0 =) (ยง alloc_state(prog, mopen, e0.fr_start, null)))   ;; `('
                    (if (nil? s0)
                        ((ร RETURN) null)
                    )

                    ((ร nfa_state_C s1 =) (alloc_state prog, mclose, null, null))         ;; `)'
                    (if (nil? s1)
                        ((ร RETURN) null)
                    )
                    (fr_patch (. e0 fr_out), s1)

                    (when (== mopen NFA_COMPOSING)
                        ;; COMPOSING.out1 = END_COMPOSING
                        (fr_patch (fr_single (. s0 out1)), s1)
                    )

                    (st_push stack, (alloc_frag s0, (fr_single (. s1 out0))))
                    (ร BREAK)
                )

                ((ร CASE) NFA_BACKREF1)
                ((ร CASE) NFA_BACKREF2)
                ((ร CASE) NFA_BACKREF3)
                ((ร CASE) NFA_BACKREF4)
                ((ร CASE) NFA_BACKREF5)
                ((ร CASE) NFA_BACKREF6)
                ((ร CASE) NFA_BACKREF7)
                ((ร CASE) NFA_BACKREF8)
                ((ร CASE) NFA_BACKREF9)
                ((ร CASE) NFA_ZREF1)
                ((ร CASE) NFA_ZREF2)
                ((ร CASE) NFA_ZREF3)
                ((ร CASE) NFA_ZREF4)
                ((ร CASE) NFA_ZREF5)
                ((ร CASE) NFA_ZREF6)
                ((ร CASE) NFA_ZREF7)
                ((ร CASE) NFA_ZREF8)
                ((ร CASE) NFA_ZREF9)
                (ยง
                    (when nfa_calc_size
                        ((ร prog.nstate +=) 2)
                        (ร BREAK)
                    )

                    ((ร nfa_state_C s0 =) (ยง alloc_state(prog, postfix[i], null, null)))
                    (if (nil? s0)
                        ((ร RETURN) null)
                    )
                    ((ร nfa_state_C s1 =) (alloc_state prog, NFA_SKIP, null, null))
                    (if (nil? s1)
                        ((ร RETURN) null)
                    )
                    (fr_patch (fr_single (. s0 out0)), s1)
                    (st_push stack, (alloc_frag s0, (fr_single (. s1 out0))))
                    (ร BREAK)
                )

                ((ร CASE) NFA_LNUM)
                ((ร CASE) NFA_LNUM_GT)
                ((ร CASE) NFA_LNUM_LT)
                ((ร CASE) NFA_VCOL)
                ((ร CASE) NFA_VCOL_GT)
                ((ร CASE) NFA_VCOL_LT)
                ((ร CASE) NFA_COL)
                ((ร CASE) NFA_COL_GT)
                ((ร CASE) NFA_COL_LT)
                ((ร CASE) NFA_MARK)
                ((ร CASE) NFA_MARK_GT)
                ((ร CASE) NFA_MARK_LT)
                (ยง
                    ((ร int n =) (ยง postfix[++i])) ;; lnum, col or mark name

                    (when nfa_calc_size
                        ((ร prog.nstate +=) 1)
                        (ร BREAK)
                    )

                    ((ร nfa_state_C s0 =) (ยง alloc_state(prog, postfix[i - 1], null, null)))
                    (if (nil? s0)
                        ((ร RETURN) null)
                    )
                    ((ร s0.val =) n)
                    (st_push stack, (alloc_frag s0, (fr_single (. s0 out0))))
                    (ร BREAK)
                )

                ((ร CASE) NFA_ZSTART)
                ((ร CASE) NFA_ZEND)
                (ร DEFAULT)
                (ยง
                    ;; Operands.
                    (when nfa_calc_size
                        (ยง prog.nstate++)
                        (ร BREAK)
                    )

                    ((ร nfa_state_C s0 =) (ยง alloc_state(prog, postfix[i], null, null)))
                    (if (nil? s0)
                        ((ร RETURN) null)
                    )
                    (st_push stack, (alloc_frag s0, (fr_single (. s0 out0))))
                    (ร BREAK)
                )
            )
        )

        (when nfa_calc_size
            (ยง prog.nstate++)
            ((ร RETURN) null)  ;; Return value when counting size is ignored anyway.
        )

        ((ร frag_C e0 =) (st_pop stack))
        (if (nil? e0)
            ((ร RETURN) (st_error postfix, i, over))
        )
        (when (< 0 (. stack st_next))
            (emsg (u8 "E875: (NFA regexp) (While converting from postfix to NFA), too many states left on stack"))
            (reset! rc_did_emsg true)
            ((ร RETURN) null)
        )

        (when (<= (. prog nstate) (. prog istate))
            (emsg (u8 "E876: (NFA regexp) Not enough space to store the whole NFA"))
            (reset! rc_did_emsg true)
            ((ร RETURN) null)
        )

        ((ร nfa_state_C state =) (ยง @nfa_states[prog.istate++] = ยง_nfa_state_C()))
        ((ร state.c =) NFA_MATCH)
        (ยง state.out0(null))
        (ยง state.out1(null))
        ((ร state.id =) 0)

        (fr_patch (. e0 fr_out), state)
        (. e0 fr_start)
    ))

;; After building the NFA program, inspect it to add optimization hints.

(defn- #_void nfa_postprocess [#_nfa_regprog_C prog]
    (ยง
        ((ร FOR) (ร (ยง int i = 0) (ยง i < prog.nstate) (ยง i++))
            ((ร nfa_state_C state =) (ยง prog.states[i]))
            (if (nil? state)
                (ร CONTINUE)
            )

            ((ร int c =) (. state c))
            (when (or (== c NFA_START_INVISIBLE) (== c NFA_START_INVISIBLE_NEG) (== c NFA_START_INVISIBLE_BEFORE) (== c NFA_START_INVISIBLE_BEFORE_NEG))
                (ร boolean directly)

                ;; Do it directly when what follows is possibly the end of the match.
                (cond (match_follows (ยง state.out1().out0()), 0)
                (ยง
                    ((ร directly =) true)
                )
                :else
                (ยง
                    ((ร int ch_invisible =) (ยง failure_chance(state.out0(), 0)))
                    ((ร int ch_follows =) (ยง failure_chance(state.out1().out0(), 0)))

                    ;; Postpone when the invisible match is expensive or has a lower chance of failing.
                    (cond (or (== c NFA_START_INVISIBLE_BEFORE) (== c NFA_START_INVISIBLE_BEFORE_NEG))
                    (ยง
                        ;; "before" matches are very expensive when unbounded,
                        ;; always prefer what follows then, unless what follows will always match.
                        ;; Otherwise strongly prefer what follows.
                        (if (and (<= (. state val) 0) (< 0 ch_follows))
                            ((ร directly =) false)
                            ((ร directly =) (ยง (ch_follows * 10 < ch_invisible)))
                        )
                    )
                    :else
                    (ยง
                        ;; normal invisible, first do the one with the highest failure chance
                        ((ร directly =) (ยง (ch_follows < ch_invisible)))
                    ))
                ))
                (when directly
                    ;; switch to the _FIRST state
                    (ยง state.c++)
                )
            )
        )
    ))

;; NFA execution code.

(class! #_final multipos_C
    [
        (field long         start_lnum)
        (field long         end_lnum)
        (field int          start_col)
        (field int          end_col)
    ])

(defn- #_void MIN1_multipos [#_multipos_C mp]
    (ยง
        ((ร mp.start_lnum =) -1)
        ((ร mp.end_lnum =) -1)
        ((ร mp.start_col =) -1)
        ((ร mp.end_col =) -1)
    ))

(defn- #_void COPY_multipos [#_multipos_C mp1, #_multipos_C mp0]
    (ยง
        ((ร mp1.start_lnum =) (. mp0 start_lnum))
        ((ร mp1.end_lnum =) (. mp0 end_lnum))
        ((ร mp1.start_col =) (. mp0 start_col))
        ((ร mp1.end_col =) (. mp0 end_col))
    ))

(defn- #_multipos_C* ARRAY_multipos [#_int n]
    (vec (repeatedly n ยง_multipos_C)))

(defn- #_void COPY__multipos [#_multipos_C* a1, #_multipos_C* a0, #_int n]
    (ยง
        ((ร FOR) (ร (ยง int i = 0) (< i n) (ยง i++))
            (COPY_multipos (ยง a1[i]), (ยง a0[i]))
        )
    ))

(class! #_final linepos_C
    [
        (field Bytes        start)
        (field Bytes        end)
    ])

(defn- #_void ZER0_linepos [#_linepos_C lp]
    (ยง
        ((ร lp.start =) null)
        ((ร lp.end =) null)
    ))

(defn- #_void COPY_linepos [#_linepos_C lp1, #_linepos_C lp0]
    (ยง
        ((ร lp1.start =) (. lp0 start))
        ((ร lp1.end =) (. lp0 end))
    ))

(defn- #_linepos_C* ARRAY_linepos [#_int n]
    (vec (repeatedly n ยง_linepos_C)))

(defn- #_void COPY__linepos [#_linepos_C* a1, #_linepos_C* a0, #_int n]
    (ยง
        ((ร FOR) (ร (ยง int i = 0) (< i n) (ยง i++))
            (COPY_linepos (ยง a1[i]), (ยง a0[i]))
        )
    ))

(class! #_final regsub_C
    [
        (field int          in_use)         ;; number of subexpr with useful info

        (field multipos_C*  rs_multi    (ARRAY_multipos NSUBEXP))   ;; union: when reg_match == null
        (field linepos_C*   rs_line     (ARRAY_linepos NSUBEXP))    ;; union: when reg_match != null
    ])

(defn- #_void COPY_regsub [#_regsub_C rs1, #_regsub_C rs0]
    (ยง
        ((ร rs1.in_use =) (. rs0 in_use))

        (COPY__multipos (. rs1 rs_multi), (. rs0 rs_multi), NSUBEXP)
        (COPY__linepos (. rs1 rs_line), (. rs0 rs_line), NSUBEXP)
    ))

(class! #_final regsubs_C
    [
        (field regsub_C     rs_norm     (ยง_regsub_C))   ;; \( .. \) matches
        (field regsub_C     rs_synt     (ยง_regsub_C))   ;; \z( .. \) matches
    ])

(defn- #_void COPY_regsubs [#_regsubs_C rs1, #_regsubs_C rs0]
    (ยง
        (COPY_regsub (. rs1 rs_norm), (. rs0 rs_norm))
        (COPY_regsub (. rs1 rs_synt), (. rs0 rs_synt))
    ))

;; nfa_pim_C stores a Postponed Invisible Match.
(class! #_final nfa_pim_C
    [
        (field int          result)         ;; NFA_PIM_*, see below
        (field nfa_state_C  state)          ;; the invisible match start state
        (field regsubs_C    np_subs     (ยง_regsubs_C))  ;; submatch info, only party used

        (field lpos_C       end_pos     (ยง_lpos_C))     ;; union upon reg_match: where the match must end
        (field Bytes        end_ptr)        ;; union upon reg_match: where the match must end
    ])

(defn- #_void COPY_nfa_pim [#_nfa_pim_C np1, #_nfa_pim_C np0]
    (ยง
        ((ร np1.result =) (. np0 result))
        ((ร np1.state =) (. np0 state))
        (COPY_regsubs (. np1 np_subs), (. np0 np_subs))

        (COPY_lpos (. np1 end_pos), (. np0 end_pos))
        ((ร np1.end_ptr =) (. np0 end_ptr))
    ))

;; Values for done in nfa_pim_C.
(final int NFA_PIM_UNUSED   0)      ;; pim not used
(final int NFA_PIM_TODO     1)      ;; pim not done yet
(final int NFA_PIM_MATCH    2)      ;; pim executed, matches
(final int NFA_PIM_NOMATCH  3)      ;; pim executed, no match

;; nfa_thread_C contains execution information of a NFA state
(class! #_final nfa_thread_C
    [
        (field nfa_state_C  state)
        (field int          count)
        (field nfa_pim_C    th_pim      (ยง_nfa_pim_C))  ;; if pim.result != NFA_PIM_UNUSED: postponed invisible match
        (field regsubs_C    th_subs     (ยง_regsubs_C))  ;; submatch info, only party used
    ])

(defn- #_void COPY_nfa_thread [#_nfa_thread_C th1, #_nfa_thread_C th0]
    (ยง
        ((ร th1.state =) (. th0 state))
        ((ร th1.count =) (. th0 count))
        (COPY_nfa_pim (. th1 th_pim), (. th0 th_pim))
        (COPY_regsubs (. th1 th_subs), (. th0 th_subs))
    ))

(defn- #_nfa_thread_C* ARRAY_nfa_thread [#_int n]
    (vec (repeatedly n ยง_nfa_thread_C)))

;; nfa_list_C contains the alternative NFA execution states.
(class! #_final nfa_list_C
    [
        (field nfa_thread_C*    threads)        ;; allocated array of states
        (field int              n)              ;; nr of states currently in "t"
        (field int              len)            ;; max nr of states in "t"
        (field int              id)             ;; ID of the list
        (field boolean          has_pim)        ;; true when any state has a PIM
    ])

(defn- #_nfa_list_C* ARRAY_nfa_list [#_int n]
    (vec (repeatedly n ยง_nfa_list_C)))

;; Used during execution: whether a match has been found.
(atom! int nfa_match)
(atom! long nfa_time_limit)
(atom! int nfa_time_count)

;; Copy postponed invisible match info from "from" to "to".

(defn- #_void copy_pim [#_nfa_pim_C to, #_nfa_pim_C from]
    (ยง
        ((ร to.result =) (. from result))
        ((ร to.state =) (. from state))
        (copy_sub (.. to np_subs rs_norm), (.. from np_subs rs_norm))
        (if @nfa_has_zsubexpr
            (copy_sub (.. to np_subs rs_synt), (.. from np_subs rs_synt)))
        (COPY_lpos (. to end_pos), (. from end_pos))
        ((ร to.end_ptr =) (. from end_ptr))
    ))

(defn- #_void clear_sub [#_regsub_C sub]
    (ยง
        (cond (nil? @reg_match)
        (ยง
            ;; Use 0xff to set lnum to -1.
            ((ร FOR) (ร (ยง int i = 0) (< i @nfa_nsubexpr) (ยง i++))
                (MIN1_multipos (ยง sub.rs_multi[i]))
            )
        )
        :else
        (ยง
            ((ร FOR) (ร (ยง int i = 0) (< i @nfa_nsubexpr) (ยง i++))
                (ZER0_linepos (ยง sub.rs_line[i]))
            )
        ))
        ((ร sub.in_use =) 0)
    ))

;; Copy the submatches from "from" to "to".

(defn- #_void copy_sub [#_regsub_C to, #_regsub_C from]
    (ยง
        ((ร to.in_use =) (. from in_use))
        (when (< 0 (. from in_use))
            ;; Copy the match start and end positions.
            (cond (nil? @reg_match)
            (ยง
                ((ร FOR) (ร (ยง int i = 0) (ยง i < from.in_use) (ยง i++))
                    (COPY_multipos (ยง to.rs_multi[i]), (ยง from.rs_multi[i]))
                )
            )
            :else
            (ยง
                ((ร FOR) (ร (ยง int i = 0) (ยง i < from.in_use) (ยง i++))
                    (COPY_linepos (ยง to.rs_line[i]), (ยง from.rs_line[i]))
                )
            ))
        )
    ))

;; Like copy_sub() but exclude the main match.

(defn- #_void copy_sub_off [#_regsub_C to, #_regsub_C from]
    (ยง
        (if (< (. to in_use) (. from in_use))
            ((ร to.in_use =) (. from in_use))
        )
        (when (< 1 (. from in_use))
            ;; Copy the match start and end positions.
            (cond (nil? @reg_match)
            (ยง
                ((ร FOR) (ร (ยง int i = 1) (ยง i < from.in_use) (ยง i++))
                    (COPY_multipos (ยง to.rs_multi[i]), (ยง from.rs_multi[i]))
                )
            )
            :else
            (ยง
                ((ร FOR) (ร (ยง int i = 1) (ยง i < from.in_use) (ยง i++))
                    (COPY_linepos (ยง to.rs_line[i]), (ยง from.rs_line[i]))
                )
            ))
        )
    ))

;; Like copy_sub() but only do the end of the main match if \ze is present.

(defn- #_void copy_ze_off [#_regsub_C to, #_regsub_C from]
    (ยง
        (when @nfa_has_zend
            (cond (nil? @reg_match)
            (ยง
                (when (<= 0 (ยง from.rs_multi[0].end_lnum))
                    ((ร to.rs_multi[0].end_lnum =) (ยง from.rs_multi[0].end_lnum))
                    ((ร to.rs_multi[0].end_col =) (ยง from.rs_multi[0].end_col))
                )
            )
            :else
            (ยง
                (if (!= (ยง from.rs_line[0].end) null)
                    ((ร to.rs_line[0].end =) (ยง from.rs_line[0].end))
                )
            ))
        )
    ))

;; Return true if "sub1" and "sub2" have the same start positions.
;; When using back-references also check the end position.

(defn- #_boolean sub_equal [#_regsub_C sub1, #_regsub_C sub2]
    (ยง
        ((ร int todo =) (if (< (. sub2 in_use) (. sub1 in_use)) (. sub1 in_use) (. sub2 in_use)))

        (cond (nil? @reg_match)
        (ยง
            ((ร FOR) (ร (ยง int i = 0) (< i todo) (ยง i++))
                (ร long s1, s2)

                (if (< i (. sub1 in_use))
                    ((ร s1 =) (ยง sub1.rs_multi[i].start_lnum))
                    ((ร s1 =) -1)
                )
                (if (< i (. sub2 in_use))
                    ((ร s2 =) (ยง sub2.rs_multi[i].start_lnum))
                    ((ร s2 =) -1)
                )
                (if (!= s1 s2)
                    ((ร RETURN) false)
                )
                (if (and (!= s1 -1) (!= (ยง sub1.rs_multi[i].start_col) (ยง sub2.rs_multi[i].start_col)))
                    ((ร RETURN) false)
                )

                (when @nfa_has_backref
                    (if (< i (. sub1 in_use))
                        ((ร s1 =) (ยง sub1.rs_multi[i].end_lnum))
                        ((ร s1 =) -1)
                    )
                    (if (< i (. sub2 in_use))
                        ((ร s2 =) (ยง sub2.rs_multi[i].end_lnum))
                        ((ร s2 =) -1)
                    )
                    (if (!= s1 s2)
                        ((ร RETURN) false)
                    )
                    (if (and (!= s1 -1) (!= (ยง sub1.rs_multi[i].end_col) (ยง sub2.rs_multi[i].end_col)))
                        ((ร RETURN) false)
                    )
                )
            )
        )
        :else
        (ยง
            ((ร FOR) (ร (ยง int i = 0) (< i todo) (ยง i++))
                (ร Bytes sp1, sp2)

                (if (< i (. sub1 in_use))
                    ((ร sp1 =) (ยง sub1.rs_line[i].start))
                    ((ร sp1 =) null)
                )
                (if (< i (. sub2 in_use))
                    ((ร sp2 =) (ยง sub2.rs_line[i].start))
                    ((ร sp2 =) null)
                )
                (if (BNE sp1, sp2)
                    ((ร RETURN) false)
                )
                (when @nfa_has_backref
                    (if (< i (. sub1 in_use))
                        ((ร sp1 =) (ยง sub1.rs_line[i].end))
                        ((ร sp1 =) null)
                    )
                    (if (< i (. sub2 in_use))
                        ((ร sp2 =) (ยง sub2.rs_line[i].end))
                        ((ร sp2 =) null)
                    )
                    (if (BNE sp1, sp2)
                        ((ร RETURN) false)
                    )
                )
            )
        ))

        true
    ))

;; Return true if the same state is already in list "nfl" with the same positions as "subs".

(defn- #_boolean has_state_with_pos [#_nfa_list_C nfl, #_nfa_state_C state, #_regsubs_C subs, #_nfa_pim_C pim]
    ;; nfl: runtime state list
    ;; state: state to update
    ;; subs: pointers to subexpressions
    ;; pim: postponed match or null
    (ยง
        ((ร FOR) (ร (ยง int i = 0) (ยง i < nfl.n) (ยง i++))
            ((ร nfa_thread_C thread =) (ยง nfl.threads[i]))

            (when (and (== (.. thread state id) (. state id)) (sub_equal (.. thread th_subs rs_norm), (. subs rs_norm)) (or (not @nfa_has_zsubexpr) (sub_equal (.. thread th_subs rs_synt), (. subs rs_synt))) (pim_equal (. thread th_pim), pim))
                ((ร RETURN) true)
            )
        )

        false
    ))

;; Return true if "one" and "two" are equal.  That includes when both are not set.

(defn- #_boolean pim_equal [#_nfa_pim_C one, #_nfa_pim_C two]
    (ยง
        ((ร boolean one_unused =) (ยง (one == null || one.result == NFA_PIM_UNUSED)))
        ((ร boolean two_unused =) (ยง (two == null || two.result == NFA_PIM_UNUSED)))

        (when one_unused
            ;; one is unused: equal when two is also unused
            ((ร RETURN) two_unused)
        )
        (when two_unused
            ;; one is used and two is not: not equal
            ((ร RETURN) false)
        )
        ;; compare the state id
        (if (!= (.. one state id) (.. two state id))
            ((ร RETURN) false)
        )
        ;; compare the position
        (if (nil? @reg_match)
            ((ร RETURN) (ยง (one.end_pos.lnum == two.end_pos.lnum && one.end_pos.col == two.end_pos.col)))
        )

        (BEQ (. one end_ptr), (. two end_ptr))
    ))

;; Return true if "state" leads to a NFA_MATCH without advancing the input.

(defn- #_boolean match_follows [#_nfa_state_C startstate, #_int depth]
    (ยง
        ;; avoid too much recursion
        (if (< 10 depth)
            ((ร RETURN) false)
        )

        ((ร FOR) (ร (ยง nfa_state_C state = startstate) (!= state null) nil)
            ((ร SWITCH) (. state c)
                ((ร CASE) NFA_MATCH)
                ((ร CASE) NFA_MCLOSE)
                ((ร CASE) NFA_END_INVISIBLE)
                ((ร CASE) NFA_END_INVISIBLE_NEG)
                ((ร CASE) NFA_END_PATTERN)
                (ยง
                    ((ร RETURN) true)
                )

                ((ร CASE) NFA_SPLIT)
                (ยง
                    ((ร RETURN) (ยง match_follows(state.out0(), depth + 1) || match_follows(state.out1(), depth + 1)))
                )

                ((ร CASE) NFA_START_INVISIBLE)
                ((ร CASE) NFA_START_INVISIBLE_FIRST)
                ((ร CASE) NFA_START_INVISIBLE_BEFORE)
                ((ร CASE) NFA_START_INVISIBLE_BEFORE_FIRST)
                ((ร CASE) NFA_START_INVISIBLE_NEG)
                ((ร CASE) NFA_START_INVISIBLE_NEG_FIRST)
                ((ร CASE) NFA_START_INVISIBLE_BEFORE_NEG)
                ((ร CASE) NFA_START_INVISIBLE_BEFORE_NEG_FIRST)
                ((ร CASE) NFA_COMPOSING)
                (ยง
                    ;; skip ahead to next state
                    ((ร state =) (ยง state.out1().out0()))
                    (ร CONTINUE)
                )

                ((ร CASE) NFA_ANY)
                ((ร CASE) NFA_ANY_COMPOSING)
                ((ร CASE) NFA_IDENT)
                ((ร CASE) NFA_SIDENT)
                ((ร CASE) NFA_KWORD)
                ((ร CASE) NFA_SKWORD)
                ((ร CASE) NFA_FNAME)
                ((ร CASE) NFA_SFNAME)
                ((ร CASE) NFA_PRINT)
                ((ร CASE) NFA_SPRINT)
                ((ร CASE) NFA_WHITE)
                ((ร CASE) NFA_NWHITE)
                ((ร CASE) NFA_DIGIT)
                ((ร CASE) NFA_NDIGIT)
                ((ร CASE) NFA_HEX)
                ((ร CASE) NFA_NHEX)
                ((ร CASE) NFA_OCTAL)
                ((ร CASE) NFA_NOCTAL)
                ((ร CASE) NFA_WORD)
                ((ร CASE) NFA_NWORD)
                ((ร CASE) NFA_HEAD)
                ((ร CASE) NFA_NHEAD)
                ((ร CASE) NFA_ALPHA)
                ((ร CASE) NFA_NALPHA)
                ((ร CASE) NFA_LOWER)
                ((ร CASE) NFA_NLOWER)
                ((ร CASE) NFA_UPPER)
                ((ร CASE) NFA_NUPPER)
                ((ร CASE) NFA_LOWER_IC)
                ((ร CASE) NFA_NLOWER_IC)
                ((ร CASE) NFA_UPPER_IC)
                ((ร CASE) NFA_NUPPER_IC)
                ((ร CASE) NFA_START_COLL)
                ((ร CASE) NFA_START_NEG_COLL)
                ((ร CASE) NFA_NEWL)
                (ยง
                    ;; state will advance input
                    ((ร RETURN) false)
                )

                (ร DEFAULT)
                (ยง
                    (when (< 0 (. state c))
                        ;; state will advance input
                        ((ร RETURN) false)
                    )

                    ;; Others: zero-width or possibly zero-width,
                    ;; might still find a match at the same position, keep looking.
                    (ร BREAK)
                )
            )
            ((ร state =) (ยง state.out0()))
        )

        false
    ))

;; Return true if "state" is already in list "nfl".

(defn- #_boolean state_in_list [#_nfa_list_C nfl, #_nfa_state_C state, #_regsubs_C subs]
    ;; nfl: runtime state list
    ;; state: state to update
    ;; subs: pointers to subexpressions
    (ยง
        (when (== (ยง state.lastlist[@nfa_ll_index]) (. nfl id))
            (if (or (not @nfa_has_backref) (has_state_with_pos nfl, state, subs, null))
                ((ร RETURN) true)
            )
        )

        false
    ))

(atom! regsubs_C temp_subs  (ยง_regsubs_C))

;; Add "state" and possibly what follows to state list ".".
;; Returns "subs_arg", possibly copied into temp_subs.

(defn- #_regsubs_C addstate [#_nfa_list_C nfl, #_nfa_state_C state, #_regsubs_C subs_arg, #_nfa_pim_C pim, #_int off]
    ;; nfl: runtime state list
    ;; state: state to update
    ;; subs_arg: pointers to subexpressions
    ;; pim: postponed look-behind match
    ;; off: byte offset, when -1 go to next line
    (ยง
        ((ร regsubs_C subs =) subs_arg)

        ((ร SWITCH) (. state c)
            ((ร CASE) NFA_NCLOSE)
            ((ร CASE) NFA_MCLOSE)
            ((ร CASE) NFA_MCLOSE1)
            ((ร CASE) NFA_MCLOSE2)
            ((ร CASE) NFA_MCLOSE3)
            ((ร CASE) NFA_MCLOSE4)
            ((ร CASE) NFA_MCLOSE5)
            ((ร CASE) NFA_MCLOSE6)
            ((ร CASE) NFA_MCLOSE7)
            ((ร CASE) NFA_MCLOSE8)
            ((ร CASE) NFA_MCLOSE9)
            ((ร CASE) NFA_ZCLOSE)
            ((ร CASE) NFA_ZCLOSE1)
            ((ร CASE) NFA_ZCLOSE2)
            ((ร CASE) NFA_ZCLOSE3)
            ((ร CASE) NFA_ZCLOSE4)
            ((ร CASE) NFA_ZCLOSE5)
            ((ร CASE) NFA_ZCLOSE6)
            ((ร CASE) NFA_ZCLOSE7)
            ((ร CASE) NFA_ZCLOSE8)
            ((ร CASE) NFA_ZCLOSE9)
            ((ร CASE) NFA_MOPEN)
            ((ร CASE) NFA_ZEND)
            ((ร CASE) NFA_SPLIT)
            ((ร CASE) NFA_EMPTY)
            (ยง
                ;; These nodes are not added themselves
                ;; but their "out0" and/or "out1" may be added below.
                (ร BREAK)
            )

            ((ร CASE) NFA_BOL)
            ((ร CASE) NFA_BOF)
            (ยง
                ;; "^" won't match past end-of-line, don't bother trying.
                ;; Except when at the end of the line, or when we are going
                ;; to the next line for a look-behind match.
                (when (and (BLT @regline, @reginput) (non-eos? @reginput) (or (nil? @nfa_endp) (non-nil? @reg_match) (== @reglnum (.. @nfa_endp se_pos lnum))))
                    ((ร RETURN) subs)
                )
                (ร FALLTHROUGH)
            )

            ((ร CASE) NFA_MOPEN1)
            ((ร CASE) NFA_MOPEN2)
            ((ร CASE) NFA_MOPEN3)
            ((ร CASE) NFA_MOPEN4)
            ((ร CASE) NFA_MOPEN5)
            ((ร CASE) NFA_MOPEN6)
            ((ร CASE) NFA_MOPEN7)
            ((ร CASE) NFA_MOPEN8)
            ((ร CASE) NFA_MOPEN9)
            ((ร CASE) NFA_ZOPEN)
            ((ร CASE) NFA_ZOPEN1)
            ((ร CASE) NFA_ZOPEN2)
            ((ร CASE) NFA_ZOPEN3)
            ((ร CASE) NFA_ZOPEN4)
            ((ร CASE) NFA_ZOPEN5)
            ((ร CASE) NFA_ZOPEN6)
            ((ร CASE) NFA_ZOPEN7)
            ((ร CASE) NFA_ZOPEN8)
            ((ร CASE) NFA_ZOPEN9)
            ((ร CASE) NFA_NOPEN)
            ((ร CASE) NFA_ZSTART)

                ;; These nodes need to be added so that we can bail out
                ;; when it was added to this list before at the same
                ;; position to avoid an endless loop for "\(\)*"

            (ร DEFAULT)
            (ยง
                (when (and (== (ยง state.lastlist[@nfa_ll_index]) (. nfl id)) (!= (. state c) NFA_SKIP))
                    ;; This state is already in the list, don't add it again,
                    ;; unless it is an MOPEN that is used for a backreference or
                    ;; when there is a PIM.  For NFA_MATCH check the position,
                    ;; lower position is preferred.
                    (if (and (not @nfa_has_backref) (nil? pim) (not (. nfl has_pim)) (!= (. state c) NFA_MATCH))
                        ((ร RETURN) subs)
                    )

                    ;; Do not add the state again when it exists with the same positions.
                    (if (has_state_with_pos nfl, state, subs, pim)
                        ((ร RETURN) subs)
                    )
                )

                ;; When there are backreferences or PIMs,
                ;; the number of states may be (a lot) bigger than anticipated.
                (when (== (. nfl n) (. nfl len))
                    (when (!= subs @temp_subs)
                        ;; "subs" may point into the current array,
                        ;; need to make a copy before it becomes invalid.
                        (copy_sub (. @temp_subs rs_norm), (. subs rs_norm))
                        (if @nfa_has_zsubexpr
                            (copy_sub (. @temp_subs rs_synt), (. subs rs_synt)))
                        ((ร subs =) @temp_subs)
                    )

                    ((ร int newlen =) (ยง nfl.len * 3 / 2 + 50))
                    ((ร nfa_thread_C[] a =) (ARRAY_nfa_thread newlen))
                    ((ร FOR) (ร (ยง int i = 0) (ยง i < nfl.n) (ยง i++))
                        (COPY_nfa_thread (ยง a[i]), (ยง nfl.threads[i]))
                    )
                    ((ร nfl.threads =) a)
                    ((ร nfl.len =) newlen)
                )

                ;; add the state to the list
                ((ร state.lastlist[@nfa_ll_index] =) (. nfl id))
                ((ร nfa_thread_C thread =) (ยง nfl.threads[nfl.n++]))
                ((ร thread.state =) state)
                (cond (nil? pim)
                (ยง
                    ((ร thread.th_pim.result =) NFA_PIM_UNUSED)
                )
                :else
                (ยง
                    (copy_pim (. thread th_pim), pim)
                    ((ร nfl.has_pim =) true)
                ))
                (copy_sub (.. thread th_subs rs_norm), (. subs rs_norm))
                (if @nfa_has_zsubexpr
                    (copy_sub (.. thread th_subs rs_synt), (. subs rs_synt)))

                (ร BREAK)
            )
        )

        ((ร SWITCH) (. state c)
            ((ร CASE) NFA_MATCH)
            (ยง
                (ร BREAK)
            )

            ((ร CASE) NFA_SPLIT)
            (ยง
                ;; order matters here
                ((ร subs =) (ยง addstate(nfl, state.out0(), subs, pim, off)))
                ((ร subs =) (ยง addstate(nfl, state.out1(), subs, pim, off)))
                (ร BREAK)
            )

            ((ร CASE) NFA_EMPTY)
            ((ร CASE) NFA_NOPEN)
            ((ร CASE) NFA_NCLOSE)
            (ยง
                ((ร subs =) (ยง addstate(nfl, state.out0(), subs, pim, off)))
                (ร BREAK)
            )

            ((ร CASE) NFA_MOPEN)
            ((ร CASE) NFA_MOPEN1)
            ((ร CASE) NFA_MOPEN2)
            ((ร CASE) NFA_MOPEN3)
            ((ร CASE) NFA_MOPEN4)
            ((ร CASE) NFA_MOPEN5)
            ((ร CASE) NFA_MOPEN6)
            ((ร CASE) NFA_MOPEN7)
            ((ร CASE) NFA_MOPEN8)
            ((ร CASE) NFA_MOPEN9)
            ((ร CASE) NFA_ZOPEN)
            ((ร CASE) NFA_ZOPEN1)
            ((ร CASE) NFA_ZOPEN2)
            ((ร CASE) NFA_ZOPEN3)
            ((ร CASE) NFA_ZOPEN4)
            ((ร CASE) NFA_ZOPEN5)
            ((ร CASE) NFA_ZOPEN6)
            ((ร CASE) NFA_ZOPEN7)
            ((ร CASE) NFA_ZOPEN8)
            ((ร CASE) NFA_ZOPEN9)
            ((ร CASE) NFA_ZSTART)
            (ยง
                (ร int subidx)
                (ร regsub_C sub)
                (cond (== (. state c) NFA_ZSTART)
                (ยง
                    ((ร subidx =) 0)
                    ((ร sub =) (. subs rs_norm))
                )
                (and (<= NFA_ZOPEN (. state c)) (<= (. state c) NFA_ZOPEN9))
                (ยง
                    ((ร subidx =) (ยง state.c - NFA_ZOPEN))
                    ((ร sub =) (. subs rs_synt))
                )
                :else
                (ยง
                    ((ร subidx =) (ยง state.c - NFA_MOPEN))
                    ((ร sub =) (. subs rs_norm))
                ))

                ((ร lpos_C save_lpos =) (ยง ยง_lpos_C()))
                ((ร save_lpos.lnum =) 0)
                ((ร save_lpos.col =) 0)
                ((ร Bytes save_ptr =) null)

                (ร int save_in_use)
                ;; Set the position (with "off" added) in the subexpression.
                ;; Save and restore it when it was in use.
                ;; Otherwise fill any gap.
                (cond (nil? @reg_match)
                (ยง
                    (cond (< subidx (. sub in_use))
                    (ยง
                        ((ร save_lpos.lnum =) (ยง sub.rs_multi[subidx].start_lnum))
                        ((ร save_lpos.col =) (ยง sub.rs_multi[subidx].start_col))
                        ((ร save_in_use =) -1)
                    )
                    :else
                    (ยง
                        ((ร save_in_use =) (. sub in_use))
                        ((ร FOR) (ร (ยง int i = sub.in_use) (< i subidx) (ยง i++))
                            ((ร sub.rs_multi[i].start_lnum =) -1)
                            ((ร sub.rs_multi[i].end_lnum =) -1)
                        )
                        ((ร sub.in_use =) (+ subidx 1))
                    ))
                    (cond (== off -1)
                    (ยง
                        ((ร sub.rs_multi[subidx].start_lnum =) (+ @reglnum 1))
                        ((ร sub.rs_multi[subidx].start_col =) 0)
                    )
                    :else
                    (ยง
                        ((ร sub.rs_multi[subidx].start_lnum =) @reglnum)
                        ((ร sub.rs_multi[subidx].start_col =) (ยง BDIFF(@reginput, @regline) + off))
                    ))
                )
                :else
                (ยง
                    (cond (< subidx (. sub in_use))
                    (ยง
                        ((ร save_ptr =) (ยง sub.rs_line[subidx].start))
                        ((ร save_in_use =) -1)
                    )
                    :else
                    (ยง
                        ((ร save_in_use =) (. sub in_use))
                        ((ร FOR) (ร (ยง int i = sub.in_use) (< i subidx) (ยง i++))
                            ((ร sub.rs_line[i].start =) null)
                            ((ร sub.rs_line[i].end =) null)
                        )
                        ((ร sub.in_use =) (+ subidx 1))
                    ))
                    ((ร sub.rs_line[subidx].start =) (ยง @reginput.plus(off)))
                ))

                ((ร subs =) (ยง addstate(nfl, state.out0(), subs, pim, off)))
                ;; "subs" may have changed, need to set "sub" again
                (if (and (<= NFA_ZOPEN (. state c)) (<= (. state c) NFA_ZOPEN9))
                    ((ร sub =) (. subs rs_synt))
                    ((ร sub =) (. subs rs_norm))
                )

                (cond (== save_in_use -1)
                (ยง
                    (cond (nil? @reg_match)
                    (ยง
                        ((ร sub.rs_multi[subidx].start_lnum =) (. save_lpos lnum))
                        ((ร sub.rs_multi[subidx].start_col =) (. save_lpos col))
                    )
                    :else
                    (ยง
                        ((ร sub.rs_line[subidx].start =) save_ptr)
                    ))
                )
                :else
                (ยง
                    ((ร sub.in_use =) save_in_use)
                ))

                (ร BREAK)
            )

            ((ร CASE) NFA_MCLOSE)
            (ยง
                (when (and @nfa_has_zend (if (nil? @reg_match)) (<= 0 (ยง subs.rs_norm.rs_multi[0].end_lnum)) (!= (ยง subs.rs_norm.rs_line[0].end) null))
                    ;; Do not overwrite the position set by \ze.
                    ((ร subs =) (ยง addstate(nfl, state.out0(), subs, pim, off)))
                    (ร BREAK)
                )
            )
            ((ร CASE) NFA_MCLOSE1)
            ((ร CASE) NFA_MCLOSE2)
            ((ร CASE) NFA_MCLOSE3)
            ((ร CASE) NFA_MCLOSE4)
            ((ร CASE) NFA_MCLOSE5)
            ((ร CASE) NFA_MCLOSE6)
            ((ร CASE) NFA_MCLOSE7)
            ((ร CASE) NFA_MCLOSE8)
            ((ร CASE) NFA_MCLOSE9)
            ((ร CASE) NFA_ZCLOSE)
            ((ร CASE) NFA_ZCLOSE1)
            ((ร CASE) NFA_ZCLOSE2)
            ((ร CASE) NFA_ZCLOSE3)
            ((ร CASE) NFA_ZCLOSE4)
            ((ร CASE) NFA_ZCLOSE5)
            ((ร CASE) NFA_ZCLOSE6)
            ((ร CASE) NFA_ZCLOSE7)
            ((ร CASE) NFA_ZCLOSE8)
            ((ร CASE) NFA_ZCLOSE9)
            ((ร CASE) NFA_ZEND)
            (ยง
                (ร int subidx)
                (ร regsub_C sub)
                (cond (== (. state c) NFA_ZEND)
                (ยง
                    ((ร subidx =) 0)
                    ((ร sub =) (. subs rs_norm))
                )
                (and (<= NFA_ZCLOSE (. state c)) (<= (. state c) NFA_ZCLOSE9))
                (ยง
                    ((ร subidx =) (ยง state.c - NFA_ZCLOSE))
                    ((ร sub =) (. subs rs_synt))
                )
                :else
                (ยง
                    ((ร subidx =) (ยง state.c - NFA_MCLOSE))
                    ((ร sub =) (. subs rs_norm))
                ))

                ((ร lpos_C save_lpos =) (ยง ยง_lpos_C()))
                (ร Bytes save_ptr)

                ;; We don't fill in gaps here, there must have been an MOPEN that has done that.
                ((ร int save_in_use =) (. sub in_use))
                (if (<= (. sub in_use) subidx)
                    ((ร sub.in_use =) (+ subidx 1))
                )
                (cond (nil? @reg_match)
                (ยง
                    ((ร save_lpos.lnum =) (ยง sub.rs_multi[subidx].end_lnum))
                    ((ร save_lpos.col =) (ยง sub.rs_multi[subidx].end_col))
                    (cond (== off -1)
                    (ยง
                        ((ร sub.rs_multi[subidx].end_lnum =) (+ @reglnum 1))
                        ((ร sub.rs_multi[subidx].end_col =) 0)
                    )
                    :else
                    (ยง
                        ((ร sub.rs_multi[subidx].end_lnum =) @reglnum)
                        ((ร sub.rs_multi[subidx].end_col =) (ยง BDIFF(@reginput, @regline) + off))
                    ))
                    ((ร save_ptr =) null)
                )
                :else
                (ยง
                    ((ร save_ptr =) (ยง sub.rs_line[subidx].end))
                    ((ร sub.rs_line[subidx].end =) (ยง @reginput.plus(off)))

                    ((ร save_lpos.lnum =) 0)
                    ((ร save_lpos.col =) 0)
                ))

                ((ร subs =) (ยง addstate(nfl, state.out0(), subs, pim, off)))
                ;; "subs" may have changed, need to set "sub" again
                (if (and (<= NFA_ZCLOSE (. state c)) (<= (. state c) NFA_ZCLOSE9))
                    ((ร sub =) (. subs rs_synt))
                    ((ร sub =) (. subs rs_norm))
                )

                (cond (nil? @reg_match)
                (ยง
                    ((ร sub.rs_multi[subidx].end_lnum =) (. save_lpos lnum))
                    ((ร sub.rs_multi[subidx].end_col =) (. save_lpos col))
                )
                :else
                (ยง
                    ((ร sub.rs_line[subidx].end =) save_ptr)
                ))
                ((ร sub.in_use =) save_in_use)

                (ร BREAK)
            )
        )

        subs
    ))

;; Like addstate(), but the new state(s) are put at position "*ip".
;; Used for zero-width matches, next state to use is the added one.
;; This makes sure the order of states to be tried does not change,
;; which matters for alternatives.

(defn- #_void addstate_here [#_nfa_list_C nfl, #_nfa_state_C state, #_regsubs_C subs, #_nfa_pim_C pim, #_int* ip]
    ;; nfl: runtime state list
    ;; state: state to update
    ;; subs: pointers to subexpressions
    ;; pim: postponed look-behind match
    (ยง
        ((ร int tlen =) (. nfl n))
        ((ร int lidx =) (ยง ip[0]))

        ;; first add the state(s) at the end, so that we know how many there are
        (addstate nfl, state, subs, pim, 0)

        ;; when "*ip" was at the end of the list, nothing to do
        (if (== (+ lidx 1) tlen)
            (ร RETURN)
        )

        ;; re-order to put the new state at the current position
        ((ร int count =) (ยง nfl.n - tlen))
        (if (zero? count)
            (ร RETURN) ;; no state got added
        )

        (cond (== count 1)
        (ยง
            ;; overwrite the current state
            (COPY_nfa_thread (ยง nfl.threads[lidx]), (ยง nfl.threads[nfl.n - 1]))
        )
        (< 1 count)
        (ยง
            (cond (<= (. nfl len) (ยง nfl.n + count - 1))
            (ยง
                ;; not enough space to move the new states,
                ;; reallocate the list and move the states to the right position
                ((ร int newlen =) (ยง nfl.len * 3 / 2 + 50))
                ((ร nfa_thread_C[] a =) (ARRAY_nfa_thread newlen))
                ((ร FOR) (ร (ยง int i = 0) (< i lidx) (ยง i++))
                    (COPY_nfa_thread (ยง a[i]), (ยง nfl.threads[i]))
                )
                ((ร FOR) (ร (ยง int i = 0) (< i count) (ยง i++))
                    (COPY_nfa_thread (ยง a[lidx + i]), (ยง nfl.threads[nfl.n - count + i]))
                )
                ((ร FOR) (ร (ยง int i = 0) (ยง i < nfl.n - count - lidx - 1) (ยง i++))
                    (COPY_nfa_thread (ยง a[lidx + count + i]), (ยง nfl.threads[lidx + 1 + i]))
                )
                ((ร nfl.threads =) a)
                ((ร nfl.len =) newlen)
            )
            :else
            (ยง
                ;; make space for new states, then move them from the end to the current position
                ((ร FOR) (ร (ยง int i = nfl.n) (ยง lidx + 1 <= --i) nil)
                    (COPY_nfa_thread (ยง nfl.threads[i + count - 1]), (ยง nfl.threads[i]))
                )
                ((ร FOR) (ร (ยง int i = 0) (< i count) (ยง i++))
                    (COPY_nfa_thread (ยง nfl.threads[lidx + i]), (ยง nfl.threads[nfl.n - 1 + i]))
                )
            ))
        ))

        (ยง --nfl.n)
        ((ร ip[0] =) (- lidx 1))
    ))

;; Check character class "class" against current character c.

(defn- #_boolean check_char_class [#_int klass, #_int c]
    (ยง
        ((ร SWITCH) klass
            ((ร CASE) NFA_CLASS_ALNUM)
            (ยง
                (if (and (<= 1 c) (<= c 255) (asc_isalnum c))
                    ((ร RETURN) true)
                )
                (ร BREAK)
            )

            ((ร CASE) NFA_CLASS_ALPHA)
            (ยง
                (if (and (<= 1 c) (<= c 255) (asc_isalpha c))
                    ((ร RETURN) true)
                )
                (ร BREAK)
            )

            ((ร CASE) NFA_CLASS_BLANK)
            (ยง
                (if (or (== c (byte \space)) (== c (byte \tab)))
                    ((ร RETURN) true)
                )
                (ร BREAK)
            )

            ((ร CASE) NFA_CLASS_CNTRL)
            (ยง
                (if (and (<= 1 c) (<= c 255) (asc_iscntrl c))
                    ((ร RETURN) true)
                )
                (ร BREAK)
            )

            ((ร CASE) NFA_CLASS_DIGIT)
            (ยง
                (if (asc_isdigit c)
                    ((ร RETURN) true)
                )
                (ร BREAK)
            )

            ((ร CASE) NFA_CLASS_GRAPH)
            (ยง
                (if (and (<= 1 c) (<= c 255) (asc_isgraph c))
                    ((ร RETURN) true)
                )
                (ร BREAK)
            )

            ((ร CASE) NFA_CLASS_LOWER)
            (ยง
                (if (utf_islower c)
                    ((ร RETURN) true)
                )
                (ร BREAK)
            )

            ((ร CASE) NFA_CLASS_PRINT)
            (ยง
                (if (vim_isprintc c)
                    ((ร RETURN) true)
                )
                (ร BREAK)
            )

            ((ร CASE) NFA_CLASS_PUNCT)
            (ยง
                (if (and (<= 1 c) (<= c 255) (asc_ispunct c))
                    ((ร RETURN) true)
                )
                (ร BREAK)
            )

            ((ร CASE) NFA_CLASS_SPACE)
            (ยง
                (if (or (and (<= 9 c) (<= c 13)) (== c (byte \space)))
                    ((ร RETURN) true)
                )
                (ร BREAK)
            )

            ((ร CASE) NFA_CLASS_UPPER)
            (ยง
                (if (utf_isupper c)
                    ((ร RETURN) true)
                )
                (ร BREAK)
            )

            ((ร CASE) NFA_CLASS_XDIGIT)
            (ยง
                (if (asc_isxdigit c)
                    ((ร RETURN) true)
                )
                (ร BREAK)
            )

            ((ร CASE) NFA_CLASS_TAB)
            (ยง
                (if (== c (byte \tab))
                    ((ร RETURN) true)
                )
                (ร BREAK)
            )

            ((ร CASE) NFA_CLASS_RETURN)
            (ยง
                (if (== c (byte \return))
                    ((ร RETURN) true)
                )
                (ร BREAK)
            )

            ((ร CASE) NFA_CLASS_BACKSPACE)
            (ยง
                (if (== c (byte \backspace))
                    ((ร RETURN) true)
                )
                (ร BREAK)
            )

            ((ร CASE) NFA_CLASS_ESCAPE)
            (ยง
                (if (== c ESC)
                    ((ร RETURN) true)
                )
                (ร BREAK)
            )

            (ร DEFAULT)
            (ยง
                ;; should not be here :P
                (emsgn e_ill_char_class, (long klass))
                ((ร RETURN) false)
            )
        )

        false
    ))

;; Check for a match with subexpression "subidx".
;; Return true if it matches.

(defn- #_boolean match_backref [#_regsub_C sub, #_int subidx, #_int* bytelen]
    ;; sub: pointers to subexpressions
    ;; bytelen: out: length of match in bytes
    (ยง
        (when (<= (. sub in_use) subidx)
            ;; backref was not set, match an empty string
            ((ร bytelen[0] =) 0)
            ((ร RETURN) true)
        )

        (cond (nil? @reg_match)
        (ยง
            (when (or (< (ยง sub.rs_multi[subidx].start_lnum) 0) (< (ยง sub.rs_multi[subidx].end_lnum) 0))
                ;; backref was not set, match an empty string
                ((ร bytelen[0] =) 0)
                ((ร RETURN) true)
            )
            (cond (and (== (ยง sub.rs_multi[subidx].start_lnum) @reglnum) (== (ยง sub.rs_multi[subidx].end_lnum) @reglnum))
            (ยง
; %%            ((ร int[] len =) (ยง { sub.rs_multi[subidx].end_col - sub.rs_multi[subidx].start_col }))
                (when (zero? (ยง cstrncmp(@regline.plus(sub.rs_multi[subidx].start_col), @reginput, len)))
                    ((ร bytelen[0] =) (ยง len[0]))
                    ((ร RETURN) true)
                )
            )
            :else
            (ยง
                (when (ยง (match_with_backref(sub.rs_multi[subidx].start_lnum, sub.rs_multi[subidx].start_col, sub.rs_multi[subidx].end_lnum, sub.rs_multi[subidx].end_col, bytelen)) == RA_MATCH)
                    ((ร RETURN) true)
                )
            ))
        )
        :else
        (ยง
            (when (or (nil? (ยง sub.rs_line[subidx].start)) (nil? (ยง sub.rs_line[subidx].end)))
                ;; backref was not set, match an empty string
                ((ร bytelen[0] =) 0)
                ((ร RETURN) true)
            )
; %%        ((ร int[] len =) (ยง { BDIFF(sub.rs_line[subidx].end, sub.rs_line[subidx].start) }))
            (when (zero? (ยง cstrncmp(sub.rs_line[subidx].start, @reginput, len)))
                ((ร bytelen[0] =) (ยง len[0]))
                ((ร RETURN) true)
            )
        ))

        false
    ))

;; Check for a match with \z subexpression "subidx".
;; Return true if it matches.

(defn- #_boolean match_zref [#_int subidx, #_int* bytelen]
    ;; bytelen: out: length of match in bytes
    (ยง
        (cleanup_zsubexpr)

        (when (or (nil? @re_extmatch_in) (nil? (ยง @re_extmatch_in.matches[subidx])))
            ;; backref was not set, match an empty string
            ((ร bytelen[0] =) 0)
            ((ร RETURN) true)
        )

; %%    ((ร int[] len =) (ยง { STRLEN(@re_extmatch_in.matches[subidx]) }))
        (when (zero? (ยง cstrncmp(@re_extmatch_in.matches[subidx], @reginput, len)))
            ((ร bytelen[0] =) (ยง len[0]))
            ((ร RETURN) true)
        )

        false
    ))

;; Save list IDs for all NFA states of "prog" into "list".
;; Also reset the IDs to zero.
;; Only used for the recursive value lastlist[1].

(defn- #_void nfa_save_listids [#_nfa_regprog_C prog, #_int* list]
    (ยง
        ;; Order in the list is reverse, it's a bit faster that way.
        ((ร FOR) (ร (ยง int i = 0, n = prog.nstate) (ยง 0 <= --n) (ยง i++))
            ((ร nfa_state_C state =) (ยง prog.states[i]))
            (when (nil? state)
                ((ร list[n] =) 0)
                (ร CONTINUE)
            )

            ((ร list[n] =) (ยง state.lastlist[1]))
            ((ร state.lastlist[1] =) 0)
        )
    ))

;; Restore list IDs from "list" to all NFA states.

(defn- #_void nfa_restore_listids [#_nfa_regprog_C prog, #_int* list]
    (ยง
        ((ร FOR) (ร (ยง int i = 0, n = prog.nstate) (ยง 0 <= --n) (ยง i++))
            ((ร nfa_state_C state =) (ยง prog.states[i]))
            (if (nil? state)
                (ร CONTINUE)
            )

            ((ร state.lastlist[1] =) (ยง list[n]))
        )
    ))

(defn- #_boolean nfa_re_num_cmp [#_long val, #_int op, #_long pos]
    (ยง
        (if (== op 1)
            ((ร RETURN) (ยง (val < pos)))
        )
        (if (== op 2)
            ((ร RETURN) (ยง (pos < val)))
        )

        (== val pos)
    ))

;; Recursively call nfa_regmatch()
;; "pim" is null or contains info about a Postponed Invisible Match (start position).

(defn- #_int recursive_regmatch [#_nfa_state_C state, #_nfa_pim_C pim, #_nfa_regprog_C prog, #_regsubs_C submatch, #_regsubs_C m, #_int** listids]
    (ยง
        ((ร int save_reginput_col =) (BDIFF @reginput, @regline))
        ((ร long save_reglnum =) @reglnum)
        ((ร int save_nfa_match =) @nfa_match)
        ((ร int save_nfa_listid =) @nfa_listid)
        ((ร save_se_C save_nfa_endp =) @nfa_endp)
        ((ร save_se_C endpos =) (ยง ยง_save_se_C()))
        ((ร save_se_C endposp =) null)
        ((ร boolean need_restore =) false)

        (when (non-nil? pim)
            ;; start at the position where the postponed match was
            (if (nil? @reg_match)
                (reset! reginput (.plus @regline (.. pim end_pos col)))
                (reset! reginput (. pim end_ptr)))
        )

        (when (or (== (. state c) NFA_START_INVISIBLE_BEFORE) (== (. state c) NFA_START_INVISIBLE_BEFORE_FIRST) (== (. state c) NFA_START_INVISIBLE_BEFORE_NEG) (== (. state c) NFA_START_INVISIBLE_BEFORE_NEG_FIRST))
            ;; The recursive match must end at the current position.
            ;; When "pim" is not null it specifies the current position.
            ((ร endposp =) endpos)
            (cond (nil? @reg_match)
            (ยง
                (cond (nil? pim)
                (ยง
                    ((ร endpos.se_pos.col =) (BDIFF @reginput, @regline))
                    ((ร endpos.se_pos.lnum =) @reglnum)
                )
                :else
                (ยง
                    (COPY_lpos (. endpos se_pos), (. pim end_pos))
                ))
            )
            :else
            (ยง
                (if (nil? pim)
                    ((ร endpos.se_ptr =) @reginput)
                    ((ร endpos.se_ptr =) (. pim end_ptr))
                )
            ))

            ;; Go back the specified number of bytes, or as far as the start of
            ;; the previous line, to try matching "\@<=" or not matching "\@<!".
            ;; This is very inefficient, limit the number of bytes if possible.

            (cond (<= (. state val) 0)
            (ยง
                (when (nil? @reg_match)
                    (reset! regline (reg_getline (ยง --@reglnum)))
                    (when (nil? @regline)
                        ;; can't go before the first line
                        (reset! regline (reg_getline (ยง ++@reglnum)))
                    )
                )
                (reset! reginput @regline)
            )
            :else
            (ยง
                (when (and (nil? @reg_match) (ยง (BDIFF(@reginput, @regline)) < state.val))
                    ;; Not enough bytes in this line, go to end of previous line.
                    (reset! regline (reg_getline (ยง --@reglnum)))
                    (cond (nil? @regline)
                    (ยง
                        ;; can't go before the first line
                        (reset! regline (reg_getline (ยง ++@reglnum)))
                        (reset! reginput @regline)
                    )
                    :else
                    (ยง
                        (reset! reginput (ยง @regline.plus(STRLEN(@regline))))
                    ))
                )
                (cond (<= (. state val) (BDIFF @reginput, @regline))
                (ยง
                    (reset! reginput (.minus @reginput (. state val)))
                    (reset! reginput (ยง @reginput.minus(us_head_off(@regline, @reginput))))
                )
                :else
                (ยง
                    (reset! reginput @regline)
                ))
            ))
        )

        ;; Have to clear the lastlist field of the NFA nodes, so that
        ;; nfa_regmatch() and addstate() can run properly after recursion.
        (cond (== @nfa_ll_index 1)
        (ยง
            ;; Already calling nfa_regmatch() recursively.
            ;; Save the lastlist[1] values and clear them.
            (if (nil? (ยง listids[0]))
                ((ร listids[0] =) (ยง new int[prog.nstate]))
            )
            (nfa_save_listids prog, (ยง listids[0]))
            ((ร need_restore =) true)
            ;; any value of nfa_listid will do
        )
        :else
        (ยง
            ;; First recursive nfa_regmatch() call, switch to the second lastlist entry.
            ;; Make sure nfa_listid is different from a previous recursive call,
            ;; because some states may still have this ID.
            (swap! nfa_ll_index inc)
            (if (<= @nfa_listid @nfa_alt_listid)
                (reset! nfa_listid @nfa_alt_listid))
        ))

        ;; Call nfa_regmatch() to check if the current concat matches at this position.
        ;; The concat ends with the node NFA_END_INVISIBLE.
        (reset! nfa_endp endposp)
        ((ร int result =) (ยง nfa_regmatch(prog, state.out0(), submatch, m)))

        (cond need_restore
        (ยง
            (nfa_restore_listids prog, (ยง listids[0]))
        )
        :else
        (ยง
            (swap! nfa_ll_index dec)
            (reset! nfa_alt_listid @nfa_listid)
        ))

        ;; restore position in input text
        (reset! reglnum save_reglnum)
        (if (nil? @reg_match)
            (reset! regline (reg_getline @reglnum)))
        (reset! reginput (.plus @regline save_reginput_col))
        (reset! nfa_match save_nfa_match)
        (reset! nfa_endp save_nfa_endp)
        (reset! nfa_listid save_nfa_listid)

        result
    ))

;; Estimate the chance of a match with "state" failing.
;; empty match: 0
;; NFA_ANY: 1
;; specific character: 99

(defn- #_int failure_chance [#_nfa_state_C state, #_int depth]
    (ยง
        ;; detect looping
        (if (< 4 depth)
            ((ร RETURN) 1)
        )

        ((ร int c =) (. state c))

        ((ร SWITCH) c
            ((ร CASE) NFA_SPLIT)
            (ยง
                (when (or (== (ยง state.out0().c) NFA_SPLIT) (== (ยง state.out1().c) NFA_SPLIT))
                    ;; avoid recursive stuff
                    ((ร RETURN) 1)
                )

                ;; two alternatives, use the lowest failure chance
                ((ร int l =) (ยง failure_chance(state.out0(), depth + 1)))
                ((ร int r =) (ยง failure_chance(state.out1(), depth + 1)))
                ((ร RETURN) (if (< l r) l r))
            )

            ((ร CASE) NFA_ANY)
            (ยง
                ;; matches anything, unlikely to fail
                ((ร RETURN) 1)
            )

            ((ร CASE) NFA_MATCH)
            ((ร CASE) NFA_MCLOSE)
            ((ร CASE) NFA_ANY_COMPOSING)
            (ยง
                ;; empty match works always
                ((ร RETURN) 0)
            )

            ((ร CASE) NFA_START_INVISIBLE)
            ((ร CASE) NFA_START_INVISIBLE_FIRST)
            ((ร CASE) NFA_START_INVISIBLE_NEG)
            ((ร CASE) NFA_START_INVISIBLE_NEG_FIRST)
            ((ร CASE) NFA_START_INVISIBLE_BEFORE)
            ((ร CASE) NFA_START_INVISIBLE_BEFORE_FIRST)
            ((ร CASE) NFA_START_INVISIBLE_BEFORE_NEG)
            ((ร CASE) NFA_START_INVISIBLE_BEFORE_NEG_FIRST)
            ((ร CASE) NFA_START_PATTERN)
            (ยง
                ;; recursive regmatch is expensive, use low failure chance
                ((ร RETURN) 5)
            )

            ((ร CASE) NFA_BOL)
            ((ร CASE) NFA_EOL)
            ((ร CASE) NFA_BOF)
            ((ร CASE) NFA_EOF)
            ((ร CASE) NFA_NEWL)
            (ยง
                ((ร RETURN) 99)
            )

            ((ร CASE) NFA_BOW)
            ((ร CASE) NFA_EOW)
            (ยง
                ((ร RETURN) 90)
            )

            ((ร CASE) NFA_MOPEN)
            ((ร CASE) NFA_MOPEN1)
            ((ร CASE) NFA_MOPEN2)
            ((ร CASE) NFA_MOPEN3)
            ((ร CASE) NFA_MOPEN4)
            ((ร CASE) NFA_MOPEN5)
            ((ร CASE) NFA_MOPEN6)
            ((ร CASE) NFA_MOPEN7)
            ((ร CASE) NFA_MOPEN8)
            ((ร CASE) NFA_MOPEN9)
            ((ร CASE) NFA_ZOPEN)
            ((ร CASE) NFA_ZOPEN1)
            ((ร CASE) NFA_ZOPEN2)
            ((ร CASE) NFA_ZOPEN3)
            ((ร CASE) NFA_ZOPEN4)
            ((ร CASE) NFA_ZOPEN5)
            ((ร CASE) NFA_ZOPEN6)
            ((ร CASE) NFA_ZOPEN7)
            ((ร CASE) NFA_ZOPEN8)
            ((ร CASE) NFA_ZOPEN9)
            ((ร CASE) NFA_ZCLOSE)
            ((ร CASE) NFA_ZCLOSE1)
            ((ร CASE) NFA_ZCLOSE2)
            ((ร CASE) NFA_ZCLOSE3)
            ((ร CASE) NFA_ZCLOSE4)
            ((ร CASE) NFA_ZCLOSE5)
            ((ร CASE) NFA_ZCLOSE6)
            ((ร CASE) NFA_ZCLOSE7)
            ((ร CASE) NFA_ZCLOSE8)
            ((ร CASE) NFA_ZCLOSE9)
            ((ร CASE) NFA_NOPEN)
            ((ร CASE) NFA_MCLOSE1)
            ((ร CASE) NFA_MCLOSE2)
            ((ร CASE) NFA_MCLOSE3)
            ((ร CASE) NFA_MCLOSE4)
            ((ร CASE) NFA_MCLOSE5)
            ((ร CASE) NFA_MCLOSE6)
            ((ร CASE) NFA_MCLOSE7)
            ((ร CASE) NFA_MCLOSE8)
            ((ร CASE) NFA_MCLOSE9)
            ((ร CASE) NFA_NCLOSE)
            (ยง
                ((ร RETURN) (ยง failure_chance(state.out0(), depth + 1)))
            )

            ((ร CASE) NFA_BACKREF1)
            ((ร CASE) NFA_BACKREF2)
            ((ร CASE) NFA_BACKREF3)
            ((ร CASE) NFA_BACKREF4)
            ((ร CASE) NFA_BACKREF5)
            ((ร CASE) NFA_BACKREF6)
            ((ร CASE) NFA_BACKREF7)
            ((ร CASE) NFA_BACKREF8)
            ((ร CASE) NFA_BACKREF9)
            ((ร CASE) NFA_ZREF1)
            ((ร CASE) NFA_ZREF2)
            ((ร CASE) NFA_ZREF3)
            ((ร CASE) NFA_ZREF4)
            ((ร CASE) NFA_ZREF5)
            ((ร CASE) NFA_ZREF6)
            ((ร CASE) NFA_ZREF7)
            ((ร CASE) NFA_ZREF8)
            ((ร CASE) NFA_ZREF9)
            (ยง
                ;; backreferences don't match in many places
                ((ร RETURN) 94)
            )

            ((ร CASE) NFA_LNUM_GT)
            ((ร CASE) NFA_LNUM_LT)
            ((ร CASE) NFA_COL_GT)
            ((ร CASE) NFA_COL_LT)
            ((ร CASE) NFA_VCOL_GT)
            ((ร CASE) NFA_VCOL_LT)
            ((ร CASE) NFA_MARK_GT)
            ((ร CASE) NFA_MARK_LT)
            ((ร CASE) NFA_VISUAL)
            (ยง
                ;; before/after positions don't match very often
                ((ร RETURN) 85)
            )

            ((ร CASE) NFA_LNUM)
            (ยง
                ((ร RETURN) 90)
            )

            ((ร CASE) NFA_CURSOR)
            ((ร CASE) NFA_COL)
            ((ร CASE) NFA_VCOL)
            ((ร CASE) NFA_MARK)
            (ยง
                ;; specific positions rarely match
                ((ร RETURN) 98)
            )

            ((ร CASE) NFA_COMPOSING)
            (ยง
                ((ร RETURN) 95)
            )

            (ร DEFAULT)
            (ยง
                (when (< 0 c)
                    ;; character match fails often
                    ((ร RETURN) 95)
                )
            )
        )

        ;; something else, includes character classes
        50
    ))

;; Skip until the char "c" we know a match must start with.

(defn- #_boolean skip_to_start [#_int c, #_int* colp]
    (ยง
        ;; Used often, do some work to avoid call overhead.
        ((ร Bytes s =) (ยง cstrchr(@regline.plus(colp[0]), c)))
        (if (nil? s)
            ((ร RETURN) false)
        )

        ((ร colp[0] =) (BDIFF s, @regline))
        true
    ))

;; Check for a match with match_text.
;; Called after skip_to_start() has found regstart.
;; Returns zero for no match, 1 for a match.

(defn- #_long find_match_text [#_int startcol, #_int regstart, #_Bytes match_text]
    (ยง
; %%    ((ร FOR) (ร (ยง int[] col = { startcol }) true nil)
            ((ร boolean match =) true)
            ((ร int len2 =) (utf_char2len regstart))                      ;; skip regstart

            (ร int c1, c2)
            ((ร FOR) (ร (ยง int len1 = 0) (ยง match_text.at(len1) != NUL) (ยง len1 += utf_char2len(c1)))
                ((ร c1 =) (ยง us_ptr2char(match_text.plus(len1))))
                ((ร c2 =) (ยง us_ptr2char(@regline.plus(col[0] + len2))))
                (when (and (!= c1 c2) (or (not @ireg_ic) (!= (utf_tolower c1) (utf_tolower c2))))
                    ((ร match =) false)
                    (ร BREAK)
                )
                ((ร len2 +=) (utf_char2len c2))
            )

            ;; check that no composing char follows
            (when (and match (not (utf_iscomposing (us_ptr2char (.plus @regline (+ (ยง col[0]) len2))))))
                (cleanup_subexpr)
                (cond (nil? @reg_match)
                (ยง
                    ((ร @reg_startpos[0].lnum =) @reglnum)
                    ((ร @reg_startpos[0].col =) (ยง col[0]))
                    ((ร @reg_endpos[0].lnum =) @reglnum)
                    ((ร @reg_endpos[0].col =) (ยง col[0] + len2))
                )
                :else
                (ยง
                    ((ร @reg_startp[0] =) (ยง @regline.plus(col[0])))
                    ((ร @reg_endp[0] =) (ยง @regline.plus(col[0] + len2)))
                ))
                ((ร RETURN) 1)
            )

            ;; Try finding regstart after the current match.
            ((ร col[0] +=) (utf_char2len regstart))                          ;; skip regstart
            (if (not (skip_to_start regstart, col))
                (ร BREAK)
            )
; %%    )

        0
    ))

;; Main matching routine.
;;
;; Run NFA to determine whether it matches reginput.
;;
;; When "nfa_endp" is not null it is a required end-of-match position.
;;
;; Return true if there is a match, false otherwise.
;; When there is a match "submatch" contains the positions.
;; Note: Caller must ensure that: start != null.

(defn- #_int nfa_regmatch [#_nfa_regprog_C prog, #_nfa_state_C start, #_regsubs_C submatch, #_regsubs_C m]
    (ยง
        ((ร boolean toplevel =) (ยง (start.c == NFA_MOPEN)))

        ;; Some patterns may take a long time to match, especially when using recursive_regmatch().
        ;; Allow interrupting them with CTRL-C.
        (fast_breakcheck)
        (if @got_int
            ((ร RETURN) FALSE)
        )
        (if (and (non-zero? @nfa_time_limit) (profile_passed_limit @nfa_time_limit))
            ((ร RETURN) FALSE)
        )

        (reset! nfa_match FALSE)

        ((ร nfa_list_C[] list =) (ARRAY_nfa_list 2))
        ((ร list[0].threads =) (ยง ARRAY_nfa_thread(list[0].len = prog.nstate + 1)))
        ((ร list[1].threads =) (ยง ARRAY_nfa_thread(list[1].len = prog.nstate + 1)))

        ((ร nfa_list_C thislist =) (ยง list[0]))
        ((ร thislist.n =) 0)
        ((ร thislist.has_pim =) false)
        ((ร nfa_list_C nextlist =) (ยง list[1]))
        ((ร nextlist.n =) 0)
        ((ร nextlist.has_pim =) false)
        ((ร thislist.id =) (+ @nfa_listid 1))

        ;; Inline optimized code for addstate(thislist, start, m, 0) if we know it's the first MOPEN.
        (cond toplevel
        (ยง
            (cond (nil? @reg_match)
            (ยง
                ((ร m.rs_norm.rs_multi[0].start_lnum =) @reglnum)
                ((ร m.rs_norm.rs_multi[0].start_col =) (BDIFF @reginput, @regline))
            )
            :else
            (ยง
                ((ร m.rs_norm.rs_line[0].start =) @reginput)
            ))
            ((ร m.rs_norm.in_use =) 1)
            (addstate thislist, (ยง start.out0()), m, null, 0)
        )
        :else
        (ยง
            (addstate thislist, start, m, null, 0)
        ))

        ((ร boolean go_to_nextline =) false)
        ((ร int flag =) 0)
; %%    ((ร int[][] listids =) (ยง { null }))
        ((ร int add_off =) 0)

        ;; Run for each character.

        (while true
            ((ร int curc =) (us_ptr2char @reginput))
            ((ร int clen =) (us_ptr2len_cc @reginput))
            (when (== curc NUL)
                ((ร clen =) 0)
                ((ร go_to_nextline =) false)
            )

            ;; swap lists
            ((ร thislist =) (ยง list[flag]))
; %%        ((ร nextlist =) (ยง list[flag ^= 1]))
            ((ร nextlist.n =) 0)                 ;; clear nextlist
            ((ร nextlist.has_pim =) false)
            (swap! nfa_listid inc)
            (when (and (== (. prog re_engine) AUTOMATIC_ENGINE) (<= NFA_MAX_STATES @nfa_listid))
                ;; too many states, retry with old engine
                (reset! nfa_match NFA_TOO_EXPENSIVE)
                ((ร RETURN) @nfa_match)
            )

            ((ร thislist.id =) @nfa_listid)
            ((ร nextlist.id =) (+ @nfa_listid 1))

            ;; If the state lists are empty we can stop.

            (if (zero? (. thislist n))
                (ร BREAK)
            )

;           nextchar:
;           {
                ;; compute nextlist
; %%            ((ร FOR) (ร (ยง int[] lidx = { 0 }) (ยง lidx[0] < thislist.n) (ยง lidx[0]++))
                    ((ร nfa_thread_C thread =) (ยง thislist.threads[lidx[0]]))

                    ;; Handle the possible codes of the current state.
                    ;; The most important is NFA_MATCH.

                    ((ร nfa_state_C add_state =) null)
                    ((ร boolean add_here =) false)
                    ((ร int add_count =) 0)

                    ((ร SWITCH) (.. thread state c)
                        ((ร CASE) NFA_MATCH)
                        (ยง
                            ;; If the match ends before a composing characters and
                            ;; ireg_icombine is not set, that is not really a match.
                            (if (and (not @ireg_icombine) (utf_iscomposing curc))
                                (ร BREAK)
                            )
                            (reset! nfa_match TRUE)
                            (copy_sub (. submatch rs_norm), (.. thread th_subs rs_norm))
                            (if @nfa_has_zsubexpr
                                (copy_sub (. submatch rs_synt), (.. thread th_subs rs_synt)))
                            ;; Found the left-most longest match, do not look at any other states
                            ;; at this position.  When the list of states is going to be empty
                            ;; quit without advancing, so that "reginput" is correct.
                            (if (zero? (. nextlist n))
                                ((ร clen =) 0)
                            )
                            (ร BREAK nextchar)
                        )

                        ((ร CASE) NFA_END_INVISIBLE)
                        ((ร CASE) NFA_END_INVISIBLE_NEG)
                        ((ร CASE) NFA_END_PATTERN)
                        (ยง
                            ;; This is only encountered after a NFA_START_INVISIBLE or
                            ;; NFA_START_INVISIBLE_BEFORE node.
                            ;; They surround a zero-width group, used with "\@=", "\&",
                            ;; "\@!", "\@<=" and "\@<!".
                            ;; If we got here, it means that the current "invisible" group
                            ;; finished successfully, so return control to the parent
                            ;; nfa_regmatch().  For a look-behind match only when it ends
                            ;; in the position in "nfa_endp".
                            ;; Submatches are stored in *m, and used in the parent call.

                            ;; If "nfa_endp" is set it's only a match if it ends at "nfa_endp".
                            (if (and (non-nil? @nfa_endp) (if (nil? @reg_match) (or (!= @reglnum (.. @nfa_endp se_pos lnum)) (ยง (BDIFF(@reginput, @regline)) != @nfa_endp.se_pos.col)) (BNE @reginput, (. @nfa_endp se_ptr))))
                                (ร BREAK)
                            )

                            ;; do not set submatches for \@!
                            (when (!= (.. thread state c) NFA_END_INVISIBLE_NEG)
                                (copy_sub (. m rs_norm), (.. thread th_subs rs_norm))
                                (if @nfa_has_zsubexpr
                                    (copy_sub (. m rs_synt), (.. thread th_subs rs_synt)))
                            )
                            (reset! nfa_match TRUE)
                            ;; See comment above at "goto nextchar".
                            (if (zero? (. nextlist n))
                                ((ร clen =) 0)
                            )
                            (ร BREAK nextchar)
                        )

                        ((ร CASE) NFA_START_INVISIBLE)
                        ((ร CASE) NFA_START_INVISIBLE_FIRST)
                        ((ร CASE) NFA_START_INVISIBLE_NEG)
                        ((ร CASE) NFA_START_INVISIBLE_NEG_FIRST)
                        ((ร CASE) NFA_START_INVISIBLE_BEFORE)
                        ((ร CASE) NFA_START_INVISIBLE_BEFORE_FIRST)
                        ((ร CASE) NFA_START_INVISIBLE_BEFORE_NEG)
                        ((ร CASE) NFA_START_INVISIBLE_BEFORE_NEG_FIRST)
                        (ยง
                            ;; Do it directly if there already is a PIM or when
                            ;; nfa_postprocess() detected it will work better.
                            (cond (or (!= (.. thread th_pim result) NFA_PIM_UNUSED) (== (.. thread state c) NFA_START_INVISIBLE_FIRST) (== (.. thread state c) NFA_START_INVISIBLE_NEG_FIRST) (== (.. thread state c) NFA_START_INVISIBLE_BEFORE_FIRST) (== (.. thread state c) NFA_START_INVISIBLE_BEFORE_NEG_FIRST))
                            (ยง
                                ((ร int in_use =) (.. m rs_norm in_use))

                                ;; Copy submatch info for the recursive call,
                                ;; opposite of what happens on success below.
                                (copy_sub_off (. m rs_norm), (.. thread th_subs rs_norm))
                                (if @nfa_has_zsubexpr
                                    (copy_sub_off (. m rs_synt), (.. thread th_subs rs_synt)))

                                ;; First try matching the invisible match, then what follows.

                                ((ร int result =) (ยง recursive_regmatch(thread.state, null, prog, submatch, m, listids)))
                                (when (== result NFA_TOO_EXPENSIVE)
                                    (reset! nfa_match result)
                                    ((ร RETURN) @nfa_match)
                                )

                                ;; for \@! and \@<! it is a match when the result is false
                                (when (!= (!= result FALSE) (or (== (.. thread state c) NFA_START_INVISIBLE_NEG) (== (.. thread state c) NFA_START_INVISIBLE_NEG_FIRST) (== (.. thread state c) NFA_START_INVISIBLE_BEFORE_NEG) (== (.. thread state c) NFA_START_INVISIBLE_BEFORE_NEG_FIRST)))
                                    ;; Copy submatch info from the recursive call.
                                    (copy_sub_off (.. thread th_subs rs_norm), (. m rs_norm))
                                    (if @nfa_has_zsubexpr
                                        (copy_sub_off (.. thread th_subs rs_synt), (. m rs_synt)))
                                    ;; If the pattern has \ze and it matched in the sub pattern, use it.
                                    (copy_ze_off (.. thread th_subs rs_norm), (. m rs_norm))

                                    ;; thread.state.out1 is the corresponding END_INVISIBLE node.
                                    ;; Add its out0 to the current list (zero-width match).
                                    ((ร add_here =) true)
                                    ((ร add_state =) (ยง thread.state.out1().out0()))
                                )
                                ((ร m.rs_norm.in_use =) in_use)
                            )
                            :else
                            (ยง
                                ((ร nfa_pim_C pim =) (ยง ยง_nfa_pim_C()))

                                ;; First try matching what follows.  Only if a match
                                ;; is found verify the invisible match matches.  Add a
                                ;; nfa_pim_C to the following states, it contains info
                                ;; about the invisible match.

                                ((ร pim.state =) (. thread state))
                                ((ร pim.result =) NFA_PIM_TODO)
                                ((ร pim.np_subs.rs_norm.in_use =) 0)
                                ((ร pim.np_subs.rs_synt.in_use =) 0)
                                (cond (nil? @reg_match)
                                (ยง
                                    ((ร pim.end_pos.col =) (BDIFF @reginput, @regline))
                                    ((ร pim.end_pos.lnum =) @reglnum)
                                )
                                :else
                                (ยง
                                    ((ร pim.end_ptr =) @reginput)
                                ))

                                ;; thread.state.out1 is the corresponding END_INVISIBLE node.
                                ;; Add its out0 to the current list (zero-width match).
                                (addstate_here thislist, (ยง thread.state.out1().out0(), thread.th_subs, pim, lidx))
                            ))
                            (ร BREAK)
                        )

                        ((ร CASE) NFA_START_PATTERN)
                        (ยง
                            ((ร nfa_state_C skip =) null)

                            ;; There is no point in trying to match the pattern
                            ;; if the output state is not going to be added to the list.
                            (cond (state_in_list nextlist, (ยง thread.state.out1().out0()), (. thread th_subs))
                            (ยง
                                ((ร skip =) (ยง thread.state.out1().out0()))
                            )
                            (state_in_list nextlist, (ยง thread.state.out1().out0().out0()), (. thread th_subs))
                            (ยง
                                ((ร skip =) (ยง thread.state.out1().out0().out0()))
                            )
                            (state_in_list thislist, (ยง thread.state.out1().out0().out0()), (. thread th_subs))
                            (ยง
                                ((ร skip =) (ยง thread.state.out1().out0().out0()))
                            ))

                            (if (non-nil? skip)
                                (ร BREAK)
                            )

                            ;; Copy submatch info to the recursive call, opposite of what happens afterwards.
                            (copy_sub_off (. m rs_norm), (.. thread th_subs rs_norm))
                            (if @nfa_has_zsubexpr
                                (copy_sub_off (. m rs_synt), (.. thread th_subs rs_synt)))

                            ;; First try matching the pattern.
                            ((ร int result =) (ยง recursive_regmatch(thread.state, null, prog, submatch, m, listids)))
                            (when (== result NFA_TOO_EXPENSIVE)
                                (reset! nfa_match result)
                                ((ร RETURN) @nfa_match)
                            )
                            (when (!= result FALSE)
                                (ร int bytelen)

                                ;; Copy submatch info from the recursive call.
                                (copy_sub_off (.. thread th_subs rs_norm), (. m rs_norm))
                                (if @nfa_has_zsubexpr
                                    (copy_sub_off (.. thread th_subs rs_synt), (. m rs_synt)))
                                ;; Now we need to skip over the matched text and
                                ;; then continue with what follows.
                                (cond (nil? @reg_match)
                                (ยง
                                    ;; TODO: multi-line match
                                    ((ร bytelen =) (ยง m.rs_norm.rs_multi[0].end_col - BDIFF(@reginput, @regline)))
                                )
                                :else
                                (ยง
                                    ((ร bytelen =) (ยง BDIFF(m.rs_norm.rs_line[0].end, @reginput)))
                                ))

                                (cond (zero? bytelen)
                                (ยง
                                    ;; Empty match: output of corresponding NFA_END_PATTERN/NFA_SKIP
                                    ;; to be used at current position.
                                    ((ร add_here =) true)
                                    ((ร add_state =) (ยง thread.state.out1().out0().out0()))
                                )
                                (<= bytelen clen)
                                (ยง
                                    ;; Match current character, output of corresponding
                                    ;; NFA_END_PATTERN to be used at next position.
                                    ((ร add_state =) (ยง thread.state.out1().out0().out0()))
                                    ((ร add_off =) clen)
                                )
                                :else
                                (ยง
                                    ;; Skip over the matched characters, set character count in NFA_SKIP.
                                    ((ร add_state =) (ยง thread.state.out1().out0()))
                                    ((ร add_off =) bytelen)
                                    ((ร add_count =) (- bytelen clen))
                                ))
                            )
                            (ร BREAK)
                        )

                        ((ร CASE) NFA_BOL)
                        (ยง
                            (when (BEQ @reginput, @regline)
                                ((ร add_here =) true)
                                ((ร add_state =) (ยง thread.state.out0()))
                            )
                            (ร BREAK)
                        )

                        ((ร CASE) NFA_EOL)
                        (ยง
                            (when (== curc NUL)
                                ((ร add_here =) true)
                                ((ร add_state =) (ยง thread.state.out0()))
                            )
                            (ร BREAK)
                        )

                        ((ร CASE) NFA_BOW)
                        (ยง
                            ((ร boolean result =) true)
                            (cond (== curc NUL)
                            (ยง
                                ((ร result =) false)
                            )
                            :else
                            (ยง
                                (ร int this_class)

                                ;; Get class of current and previous char (if it exists).
                                ((ร this_class =) (us_get_class @reginput, @reg_buf))
                                (cond (<= this_class 1)
                                (ยง
                                    ((ร result =) false)
                                )
                                (== (reg_prev_class) this_class)
                                (ยง
                                    ((ร result =) false)
                                ))
                            ))
                            (when result
                                ((ร add_here =) true)
                                ((ร add_state =) (ยง thread.state.out0()))
                            )
                            (ร BREAK)
                        )

                        ((ร CASE) NFA_EOW)
                        (ยง
                            ((ร boolean result =) true)
                            (cond (BEQ @reginput, @regline)
                            (ยง
                                ((ร result =) false)
                            )
                            :else
                            (ยง
                                (ร int this_class, prev_class)

                                ;; Get class of current and previous char (if it exists).
                                ((ร this_class =) (us_get_class @reginput, @reg_buf))
                                ((ร prev_class =) (reg_prev_class))
                                (if (or (== this_class prev_class) (zero? prev_class) (== prev_class 1))
                                    ((ร result =) false)
                                )
                            ))
                            (when result
                                ((ร add_here =) true)
                                ((ร add_state =) (ยง thread.state.out0()))
                            )
                            (ร BREAK)
                        )

                        ((ร CASE) NFA_BOF)
                        (ยง
                            (when (and (zero? @reglnum) (BEQ @reginput, @regline) (or (non-nil? @reg_match) (== @reg_firstlnum 1)))
                                ((ร add_here =) true)
                                ((ร add_state =) (ยง thread.state.out0()))
                            )
                            (ร BREAK)
                        )

                        ((ร CASE) NFA_EOF)
                        (ยง
                            (when (and (== @reglnum @reg_maxline) (== curc NUL))
                                ((ร add_here =) true)
                                ((ร add_state =) (ยง thread.state.out0()))
                            )
                            (ร BREAK)
                        )

                        ((ร CASE) NFA_COMPOSING)
                        (ยง
                            ((ร int mc =) curc)
                            ((ร int[] cchars =) (ยง new int[MAX_MCO]))
                            ((ร int ccount =) 0)

                            ((ร nfa_state_C sta =) (ยง thread.state.out0()))
                            ((ร int len =) 0)
                            (when (utf_iscomposing (. sta c))
                                ;; Only match composing character(s), ignore base character.
                                ;; Used for ".{composing}" and "{composing}" (no preceding character).
                                ((ร len +=) (utf_char2len mc))
                            )

                            (ร boolean result)
                            (cond (and @ireg_icombine (zero? len))
                            (ยง
                                ;; If \Z was present, then ignore composing characters.
                                ;; When ignoring the base character this always matches.
                                (if (and (zero? len) (!= (. sta c) curc))
                                    ((ร result =) false)
                                    ((ร result =) true)
                                )
                                (while (ยง sta.c != NFA_END_COMPOSING)
                                    ((ร sta =) (ยง sta.out0()))
                                )
                            )
                            ;; Check base character matches first, unless ignored.
                            (or (< 0 len) (== mc (. sta c)))
                            (ยง
                                (when (zero? len)
                                    ((ร len +=) (utf_char2len mc))
                                    ((ร sta =) (ยง sta.out0()))
                                )

                                ;; We don't care about the order of composing characters.
                                ;; Get them into cchars[] first.
                                (while (< len clen)
                                    ((ร mc =) (ยง us_ptr2char(@reginput.plus(len))))
                                    ((ร cchars[ccount++] =) mc)
                                    ((ร len +=) (utf_char2len mc))
                                    (if (== ccount MAX_MCO)
                                        (ร BREAK)
                                    )
                                )

                                ;; Check that each composing char in the pattern matches
                                ;; a composing char in the text.
                                ;; We do not check if all composing chars are matched.
                                ((ร result =) true)
                                (while (ยง sta.c != NFA_END_COMPOSING)
                                    (ร int j)
                                    ((ร FOR) (ร (ยง j = 0) (< j ccount) (ยง j++))
                                        (if (== (ยง cchars[j]) (. sta c))
                                            (ร BREAK)
                                        )
                                    )
                                    (when (== j ccount)
                                        ((ร result =) false)
                                        (ร BREAK)
                                    )
                                    ((ร sta =) (ยง sta.out0()))
                                )
                            )
                            :else
                            (ยง
                                ((ร result =) false)
                            ))

                            ((ร nfa_state_C end =) (ยง thread.state.out1()))    ;; NFA_END_COMPOSING

                            (when result
                                ((ร add_state =) (ยง end.out0()))
                                ((ร add_off =) clen)
                            )
                            (ร BREAK)
                        )

                        ((ร CASE) NFA_NEWL)
                        (ยง
                            (cond (and (== curc NUL) (not @reg_line_lbr) (nil? @reg_match) (<= @reglnum @reg_maxline))
                            (ยง
                                ((ร go_to_nextline =) true)
                                ;; Pass -1 for the offset, which means
                                ;; taking the position at the start of the next line.
                                ((ร add_state =) (ยง thread.state.out0()))
                                ((ร add_off =) -1)
                            )
                            (and (== curc (byte \newline)) @reg_line_lbr)
                            (ยง
                                ;; match \n as if it is an ordinary character
                                ((ร add_state =) (ยง thread.state.out0()))
                                ((ร add_off =) 1)
                            ))
                            (ร BREAK)
                        )

                        ((ร CASE) NFA_START_COLL)
                        ((ร CASE) NFA_START_NEG_COLL)
                        (ยง
                            ;; What follows is a list of characters, until NFA_END_COLL.
                            ;; One of them must match or none of them must match.

                            ;; Never match EOL.
                            ;; If it's part of the collection it is added as a separate state with an OR.
                            (if (== curc NUL)
                                (ร BREAK)
                            )

                            ((ร boolean result_if_matched =) (ยง (thread.state.c == NFA_START_COLL)))

;                           boolean result = false;	// %% anno dunno
                            ((ร FOR) (ร (ยง nfa_state_C state = thread.state.out0()) true (ยง state = state.out0()))
                                (when (== (. state c) NFA_END_COLL)
                                    ((ร result =) (ยง !result_if_matched))
                                    (ร BREAK)
                                )
                                (cond (== (. state c) NFA_RANGE_MIN)
                                (ยง
                                    ((ร int c1 =) (. state val))
                                    ((ร state =) (ยง state.out0())) ;; advance to NFA_RANGE_MAX
                                    ((ร int c2 =) (. state val))
                                    (when (and (<= c1 curc) (<= curc c2))
                                        ((ร result =) result_if_matched)
                                        (ร BREAK)
                                    )
                                    (when @ireg_ic
                                        ((ร int curc_low =) (utf_tolower curc))
                                        ((ร boolean done =) false)

                                        ((ร FOR) (ร (ยง  ) (<= c1 c2) (ยง ++c1))
                                            (when (== (utf_tolower c1) curc_low)
                                                ((ร result =) result_if_matched)
                                                ((ร done =) true)
                                                (ร BREAK)
                                            )
                                        )
                                        (if done
                                            (ร BREAK)
                                        )
                                    )
                                )
                                (if (< (. state c) 0) (check_char_class (. state c), curc) (or (== curc (. state c)) (and @ireg_ic (== (utf_tolower curc) (utf_tolower (. state c))))))
                                (ยง
                                    ((ร result =) result_if_matched)
                                    (ร BREAK)
                                ))
                            )
                            (when result
                                ;; next state is in out of the NFA_END_COLL,
                                ;; out1 of START points to the END state
                                ((ร add_state =) (ยง thread.state.out1().out0()))
                                ((ร add_off =) clen)
                            )
                            (ร BREAK)
                        )

                        ((ร CASE) NFA_ANY)
                        (ยง
                            ;; Any char except NUL, (end of input) does not match.
                            (when (< 0 curc)
                                ((ร add_state =) (ยง thread.state.out0()))
                                ((ร add_off =) clen)
                            )
                            (ร BREAK)
                        )

                        ((ร CASE) NFA_ANY_COMPOSING)
                        (ยง
                            ;; On a composing character skip over it.
                            ;; Otherwise do nothing.
                            ;; Always matches.
                            (cond (utf_iscomposing curc)
                            (ยง
                                ((ร add_off =) clen)
                            )
                            :else
                            (ยง
                                ((ร add_here =) true)
                                ((ร add_off =) 0)
                            ))
                            ((ร add_state =) (ยง thread.state.out0()))
                            (ร BREAK)
                        )

                        ;; Character classes like \a for alpha, \d for digit etc.

                        ((ร CASE) NFA_IDENT)     ;;  \i
                        (ยง
                            ((ร boolean result =) (vim_isIDc curc))
                            (when result
                                ((ร add_state =) (ยง thread.state.out0()))
                                ((ร add_off =) clen)
                            )
                            (ร BREAK)
                        )

                        ((ร CASE) NFA_SIDENT)    ;;  \I
                        (ยง
                            ((ร boolean result =) (ยง !asc_isdigit(curc) && vim_isIDc(curc)))
                            (when result
                                ((ร add_state =) (ยง thread.state.out0()))
                                ((ร add_off =) clen)
                            )
                            (ร BREAK)
                        )

                        ((ร CASE) NFA_KWORD)     ;;  \k
                        (ยง
                            ((ร boolean result =) (us_iswordp @reginput, @reg_buf))
                            (when result
                                ((ร add_state =) (ยง thread.state.out0()))
                                ((ร add_off =) clen)
                            )
                            (ร BREAK)
                        )

                        ((ร CASE) NFA_SKWORD)    ;;  \K
                        (ยง
                            ((ร boolean result =) (ยง !asc_isdigit(curc) && us_iswordp(@reginput, @reg_buf)))
                            (when result
                                ((ร add_state =) (ยง thread.state.out0()))
                                ((ร add_off =) clen)
                            )
                            (ร BREAK)
                        )

                        ((ร CASE) NFA_FNAME)     ;;  \f
                        (ยง
                            ((ร boolean result =) (vim_isfilec curc))
                            (when result
                                ((ร add_state =) (ยง thread.state.out0()))
                                ((ร add_off =) clen)
                            )
                            (ร BREAK)
                        )

                        ((ร CASE) NFA_SFNAME)    ;;  \F
                        (ยง
                            ((ร boolean result =) (ยง !asc_isdigit(curc) && vim_isfilec(curc)))
                            (when result
                                ((ร add_state =) (ยง thread.state.out0()))
                                ((ร add_off =) clen)
                            )
                            (ร BREAK)
                        )

                        ((ร CASE) NFA_PRINT)     ;;  \p
                        (ยง
                            ((ร boolean result =) (ยง vim_isprintc(us_ptr2char(@reginput))))
                            (when result
                                ((ร add_state =) (ยง thread.state.out0()))
                                ((ร add_off =) clen)
                            )
                            (ร BREAK)
                        )

                        ((ร CASE) NFA_SPRINT)    ;;  \P
                        (ยง
                            ((ร boolean result =) (ยง !asc_isdigit(curc) && vim_isprintc(us_ptr2char(@reginput))))
                            (when result
                                ((ร add_state =) (ยง thread.state.out0()))
                                ((ร add_off =) clen)
                            )
                            (ร BREAK)
                        )

                        ((ร CASE) NFA_WHITE)     ;;  \s
                        (ยง
                            ((ร boolean result =) (vim_iswhite curc))
                            (when result
                                ((ร add_state =) (ยง thread.state.out0()))
                                ((ร add_off =) clen)
                            )
                            (ร BREAK)
                        )

                        ((ร CASE) NFA_NWHITE)    ;;  \S
                        (ยง
                            ((ร boolean result =) (ยง (curc != NUL) && !vim_iswhite(curc)))
                            (when result
                                ((ร add_state =) (ยง thread.state.out0()))
                                ((ร add_off =) clen)
                            )
                            (ร BREAK)
                        )

                        ((ร CASE) NFA_DIGIT)     ;;  \d
                        (ยง
                            ((ร boolean result =) (ri_digit curc))
                            (when result
                                ((ร add_state =) (ยง thread.state.out0()))
                                ((ร add_off =) clen)
                            )
                            (ร BREAK)
                        )

                        ((ร CASE) NFA_NDIGIT)    ;;  \D
                        (ยง
                            ((ร boolean result =) (ยง (curc != NUL) && !ri_digit(curc)))
                            (when result
                                ((ร add_state =) (ยง thread.state.out0()))
                                ((ร add_off =) clen)
                            )
                            (ร BREAK)
                        )

                        ((ร CASE) NFA_HEX)       ;;  \x
                        (ยง
                            ((ร boolean result =) (ri_hex curc))
                            (when result
                                ((ร add_state =) (ยง thread.state.out0()))
                                ((ร add_off =) clen)
                            )
                            (ร BREAK)
                        )

                        ((ร CASE) NFA_NHEX)      ;;  \X
                        (ยง
                            ((ร boolean result =) (ยง (curc != NUL) && !ri_hex(curc)))
                            (when result
                                ((ร add_state =) (ยง thread.state.out0()))
                                ((ร add_off =) clen)
                            )
                            (ร BREAK)
                        )

                        ((ร CASE) NFA_OCTAL)     ;;  \o
                        (ยง
                            ((ร boolean result =) (ri_octal curc))
                            (when result
                                ((ร add_state =) (ยง thread.state.out0()))
                                ((ร add_off =) clen)
                            )
                            (ร BREAK)
                        )

                        ((ร CASE) NFA_NOCTAL)    ;;  \O
                        (ยง
                            ((ร boolean result =) (ยง (curc != NUL) && !ri_octal(curc)))
                            (when result
                                ((ร add_state =) (ยง thread.state.out0()))
                                ((ร add_off =) clen)
                            )
                            (ร BREAK)
                        )

                        ((ร CASE) NFA_WORD)      ;;  \w
                        (ยง
                            ((ร boolean result =) (ri_word curc))
                            (when result
                                ((ร add_state =) (ยง thread.state.out0()))
                                ((ร add_off =) clen)
                            )
                            (ร BREAK)
                        )

                        ((ร CASE) NFA_NWORD)     ;;  \W
                        (ยง
                            ((ร boolean result =) (ยง (curc != NUL) && !ri_word(curc)))
                            (when result
                                ((ร add_state =) (ยง thread.state.out0()))
                                ((ร add_off =) clen)
                            )
                            (ร BREAK)
                        )

                        ((ร CASE) NFA_HEAD)      ;;  \h
                        (ยง
                            ((ร boolean result =) (ri_head curc))
                            (when result
                                ((ร add_state =) (ยง thread.state.out0()))
                                ((ร add_off =) clen)
                            )
                            (ร BREAK)
                        )

                        ((ร CASE) NFA_NHEAD)     ;;  \H
                        (ยง
                            ((ร boolean result =) (ยง (curc != NUL) && !ri_head(curc)))
                            (when result
                                ((ร add_state =) (ยง thread.state.out0()))
                                ((ร add_off =) clen)
                            )
                            (ร BREAK)
                        )

                        ((ร CASE) NFA_ALPHA)     ;;  \a
                        (ยง
                            ((ร boolean result =) (ri_alpha curc))
                            (when result
                                ((ร add_state =) (ยง thread.state.out0()))
                                ((ร add_off =) clen)
                            )
                            (ร BREAK)
                        )

                        ((ร CASE) NFA_NALPHA)    ;;  \A
                        (ยง
                            ((ร boolean result =) (ยง (curc != NUL) && !ri_alpha(curc)))
                            (when result
                                ((ร add_state =) (ยง thread.state.out0()))
                                ((ร add_off =) clen)
                            )
                            (ร BREAK)
                        )

                        ((ร CASE) NFA_LOWER)     ;;  \l
                        (ยง
                            ((ร boolean result =) (ri_lower curc))
                            (when result
                                ((ร add_state =) (ยง thread.state.out0()))
                                ((ร add_off =) clen)
                            )
                            (ร BREAK)
                        )

                        ((ร CASE) NFA_NLOWER)    ;;  \L
                        (ยง
                            ((ร boolean result =) (ยง (curc != NUL) && !ri_lower(curc)))
                            (when result
                                ((ร add_state =) (ยง thread.state.out0()))
                                ((ร add_off =) clen)
                            )
                            (ร BREAK)
                        )

                        ((ร CASE) NFA_UPPER)     ;;  \\u (sic!)
                        (ยง
                            ((ร boolean result =) (ri_upper curc))
                            (when result
                                ((ร add_state =) (ยง thread.state.out0()))
                                ((ร add_off =) clen)
                            )
                            (ร BREAK)
                        )

                        ((ร CASE) NFA_NUPPER)    ;;  \U
                        (ยง
                            ((ร boolean result =) (ยง (curc != NUL) && !ri_upper(curc)))
                            (when result
                                ((ร add_state =) (ยง thread.state.out0()))
                                ((ร add_off =) clen)
                            )
                            (ร BREAK)
                        )

                        ((ร CASE) NFA_LOWER_IC)  ;; [a-z]
                        (ยง
                            ((ร boolean result =) (ยง ri_lower(curc) || (@ireg_ic && ri_upper(curc))))
                            (when result
                                ((ร add_state =) (ยง thread.state.out0()))
                                ((ร add_off =) clen)
                            )
                            (ร BREAK)
                        )

                        ((ร CASE) NFA_NLOWER_IC) ;; [^a-z]
                        (ยง
                            ((ร boolean result =) (ยง (curc != NUL) && !(ri_lower(curc) || (@ireg_ic && ri_upper(curc)))))
                            (when result
                                ((ร add_state =) (ยง thread.state.out0()))
                                ((ร add_off =) clen)
                            )
                            (ร BREAK)
                        )

                        ((ร CASE) NFA_UPPER_IC)  ;; [A-Z]
                        (ยง
                            ((ร boolean result =) (ยง ri_upper(curc) || (@ireg_ic && ri_lower(curc))))
                            (when result
                                ((ร add_state =) (ยง thread.state.out0()))
                                ((ร add_off =) clen)
                            )
                            (ร BREAK)
                        )

                        ((ร CASE) NFA_NUPPER_IC) ;; ^[A-Z]
                        (ยง
                            ((ร boolean result =) (ยง (curc != NUL) && !(ri_upper(curc) || (@ireg_ic && ri_lower(curc)))))
                            (when result
                                ((ร add_state =) (ยง thread.state.out0()))
                                ((ร add_off =) clen)
                            )
                            (ร BREAK)
                        )

                        ((ร CASE) NFA_BACKREF1)
                        ((ร CASE) NFA_BACKREF2)
                        ((ร CASE) NFA_BACKREF3)
                        ((ร CASE) NFA_BACKREF4)
                        ((ร CASE) NFA_BACKREF5)
                        ((ร CASE) NFA_BACKREF6)
                        ((ร CASE) NFA_BACKREF7)
                        ((ร CASE) NFA_BACKREF8)
                        ((ร CASE) NFA_BACKREF9)
                        ((ร CASE) NFA_ZREF1)
                        ((ร CASE) NFA_ZREF2)
                        ((ร CASE) NFA_ZREF3)
                        ((ร CASE) NFA_ZREF4)
                        ((ร CASE) NFA_ZREF5)
                        ((ร CASE) NFA_ZREF6)
                        ((ร CASE) NFA_ZREF7)
                        ((ร CASE) NFA_ZREF8)
                        ((ร CASE) NFA_ZREF9) ;; \1 .. \9  \z1 .. \z9
                        (ยง
                            (ร int subidx)
                            ((ร int[] bytelen =) (ยง new int[1]))

                            (ร boolean result)
                            (cond (<= (.. thread state c) NFA_BACKREF9)
                            (ยง
                                ((ร subidx =) (ยง thread.state.c - NFA_BACKREF1 + 1))
                                ((ร result =) (ยง match_backref(thread.th_subs.rs_norm, subidx, bytelen)))
                            )
                            :else
                            (ยง
                                ((ร subidx =) (ยง thread.state.c - NFA_ZREF1 + 1))
                                ((ร result =) (match_zref subidx, bytelen))
                            ))

                            (when result
                                (cond (zero? (ยง bytelen[0]))
                                (ยง
                                    ;; Empty match always works, output of NFA_SKIP to be used next.
                                    ((ร add_here =) true)
                                    ((ร add_state =) (ยง thread.state.out0().out0()))
                                )
                                (<= (ยง bytelen[0]) clen)
                                (ยง
                                    ;; Match current character, jump ahead to out of NFA_SKIP.
                                    ((ร add_state =) (ยง thread.state.out0().out0()))
                                    ((ร add_off =) clen)
                                )
                                :else
                                (ยง
                                    ;; Skip over the matched characters, set character count in NFA_SKIP.
                                    ((ร add_state =) (ยง thread.state.out0()))
                                    ((ร add_off =) (ยง bytelen[0]))
                                    ((ร add_count =) (ยง bytelen[0] - clen))
                                ))
                            )
                            (ร BREAK)
                        )

                        ((ร CASE) NFA_SKIP)
                        (ยง
                            ;; character of previous matching \1 .. \9  or \@>
                            (cond (ยง thread.count - clen <= 0)
                            (ยง
                                ;; end of match, go to what follows
                                ((ร add_state =) (ยง thread.state.out0()))
                                ((ร add_off =) clen)
                            )
                            :else
                            (ยง
                                ;; add state again with decremented count
                                ((ร add_state =) (. thread state))
                                ((ร add_off =) 0)
                                ((ร add_count =) (ยง thread.count - clen))
                            ))
                            (ร BREAK)
                        )

                        ((ร CASE) NFA_LNUM)
                        ((ร CASE) NFA_LNUM_GT)
                        ((ร CASE) NFA_LNUM_LT)
                        (ยง
                            ((ร boolean result =) (ยง (@reg_match == null && nfa_re_num_cmp(thread.state.val, thread.state.c - NFA_LNUM, @reglnum + @reg_firstlnum))))
                            (when result
                                ((ร add_here =) true)
                                ((ร add_state =) (ยง thread.state.out0()))
                            )
                            (ร BREAK)
                        )

                        ((ร CASE) NFA_COL)
                        ((ร CASE) NFA_COL_GT)
                        ((ร CASE) NFA_COL_LT)
                        (ยง
                            ((ร boolean result =) (ยง nfa_re_num_cmp(thread.state.val, thread.state.c - NFA_COL, BDIFF(@reginput, @regline) + 1)))
                            (when result
                                ((ร add_here =) true)
                                ((ร add_state =) (ยง thread.state.out0()))
                            )
                            (ร BREAK)
                        )

                        ((ร CASE) NFA_VCOL)
                        ((ร CASE) NFA_VCOL_GT)
                        ((ร CASE) NFA_VCOL_LT)
                        (ยง
                            ((ร int op =) (ยง thread.state.c - NFA_VCOL))
                            ((ร int col =) (BDIFF @reginput, @regline))
                            ((ร window_C wp =) (if (nil? @reg_win) @curwin @reg_win))

                            ;; Bail out quickly when there can't be a match,
                            ;; avoid the overhead of win_linetabsize() on long lines.
                            (if (and (!= op 1) (ยง thread.state.val * MB_MAXBYTES < col))
                                (ร BREAK)
                            )

                            ((ร boolean result =) false)
                            (when (and (== op 1) (< (.. thread state val) (- col 1)) (< 100 col))
                                ((ร int ts =) (ยง (int)@curbuf.@b_p_ts))

                                ;; Guess that a character won't use more columns than 'tabstop',
                                ;; with a minimum of 4.
                                (if (< ts 4)
                                    ((ร ts =) 4)
                                )
                                ((ร result =) (ยง (thread.state.val * ts < col)))
                            )
                            (if (not result)
                                ((ร result =) (ยง nfa_re_num_cmp(thread.state.val, op, (long)win_linetabsize(wp, @regline, col) + 1)))
                            )
                            (when result
                                ((ร add_here =) true)
                                ((ร add_state =) (ยง thread.state.out0()))
                            )
                            (ร BREAK)
                        )

                        ((ร CASE) NFA_MARK)
                        ((ร CASE) NFA_MARK_GT)
                        ((ร CASE) NFA_MARK_LT)
                        (ยง
                            ((ร pos_C pos =) (ยง getmark_buf(@reg_buf, thread.state.val, false)))

                            ;; Compare the mark position to the match position.
                                                                    ;; mark doesn't exist
                                                                    ;; mark isn't set in reg_buf
                            ((ร boolean result =) (and (!= pos null) (< 0 (. pos lnum)) (if (== (. pos lnum) (+ @reglnum @reg_firstlnum)) (if (== (. pos col) (BDIFF @reginput, @regline)) (== (.. thread state c) NFA_MARK) (if (< (. pos col) (BDIFF @reginput, @regline)) (== (.. thread state c) NFA_MARK_GT) (== (.. thread state c) NFA_MARK_LT))) (if (< (. pos lnum) (+ @reglnum @reg_firstlnum)) (== (.. thread state c) NFA_MARK_GT) (== (.. thread state c) NFA_MARK_LT)))))
                            (when result
                                ((ร add_here =) true)
                                ((ร add_state =) (ยง thread.state.out0()))
                            )
                            (ร BREAK)
                        )

                        ((ร CASE) NFA_CURSOR)
                        (ยง
                            ((ร boolean result =) (ยง (@reg_win != null && @reglnum + @reg_firstlnum == @reg_win.w_cursor.lnum && BDIFF(@reginput, @regline) == @reg_win.w_cursor.col)))
                            (when result
                                ((ร add_here =) true)
                                ((ร add_state =) (ยง thread.state.out0()))
                            )
                            (ร BREAK)
                        )

                        ((ร CASE) NFA_VISUAL)
                        (ยง
                            ((ร boolean result =) (reg_match_visual))
                            (when result
                                ((ร add_here =) true)
                                ((ร add_state =) (ยง thread.state.out0()))
                            )
                            (ร BREAK)
                        )

                        ((ร CASE) NFA_MOPEN1)
                        ((ร CASE) NFA_MOPEN2)
                        ((ร CASE) NFA_MOPEN3)
                        ((ร CASE) NFA_MOPEN4)
                        ((ร CASE) NFA_MOPEN5)
                        ((ร CASE) NFA_MOPEN6)
                        ((ร CASE) NFA_MOPEN7)
                        ((ร CASE) NFA_MOPEN8)
                        ((ร CASE) NFA_MOPEN9)
                        ((ร CASE) NFA_ZOPEN)
                        ((ร CASE) NFA_ZOPEN1)
                        ((ร CASE) NFA_ZOPEN2)
                        ((ร CASE) NFA_ZOPEN3)
                        ((ร CASE) NFA_ZOPEN4)
                        ((ร CASE) NFA_ZOPEN5)
                        ((ร CASE) NFA_ZOPEN6)
                        ((ร CASE) NFA_ZOPEN7)
                        ((ร CASE) NFA_ZOPEN8)
                        ((ร CASE) NFA_ZOPEN9)
                        ((ร CASE) NFA_NOPEN)
                        ((ร CASE) NFA_ZSTART)
                        (ยง
                            ;; These states are only added to be able to bail out when
                            ;; they are added again, nothing is to be done.
                            (ร BREAK)
                        )

                        (ร DEFAULT)    ;; regular character
                        (ยง
                            ((ร int c =) (.. thread state c))

                            ((ร boolean result =) (ยง (c == curc)))
                            (if (and (not result) @ireg_ic)
                                ((ร result =) (ยง (utf_tolower(c) == utf_tolower(curc))))
                            )

                            ;; If ireg_icombine is not set only skip over the character itself.
                            ;; When it is set skip over composing characters.
                            (if (and result (not @ireg_icombine))
                                ((ร clen =) (utf_char2len curc))
                            )

                            (when result
                                ((ร add_state =) (ยง thread.state.out0()))
                                ((ร add_off =) clen)
                            )
                            (ร BREAK)
                        )
                    )

                    (when (non-nil? add_state)
                        ((ร nfa_pim_C pim =) (if (!= (.. thread th_pim result) NFA_PIM_UNUSED) (. thread th_pim) null))

                        ;; Handle the postponed invisible match if the match might end
                        ;; without advancing and before the end of the line.
                        (when (and (non-nil? pim) (or (zero? clen) (match_follows add_state, 0)))
                            (ร int result)
                            (cond (== (. pim result) NFA_PIM_TODO)
                            (ยง
                                ((ร result =) (ยง recursive_regmatch(pim.state, pim, prog, submatch, m, listids)))
                                ((ร pim.result =) (if (!= result FALSE) NFA_PIM_MATCH NFA_PIM_NOMATCH))
                                ;; for \@! and \@<! it is a match when the result is false
                                (when (ยง (result != FALSE) != (pim.state.c == NFA_START_INVISIBLE_NEG || pim.state.c == NFA_START_INVISIBLE_NEG_FIRST || pim.state.c == NFA_START_INVISIBLE_BEFORE_NEG || pim.state.c == NFA_START_INVISIBLE_BEFORE_NEG_FIRST))
                                    ;; Copy submatch info from the recursive call.
                                    (copy_sub_off (.. pim np_subs rs_norm), (. m rs_norm))
                                    (if @nfa_has_zsubexpr
                                        (copy_sub_off (.. pim np_subs rs_synt), (. m rs_synt)))
                                )
                            )
                            :else
                            (ยง
                                ((ร result =) (if (== (. pim result) NFA_PIM_MATCH) TRUE FALSE))
                            ))

                            ;; for \@! and \@<! it is a match when result is false
                            (cond (ยง (result != FALSE) != (pim.state.c == NFA_START_INVISIBLE_NEG || pim.state.c == NFA_START_INVISIBLE_NEG_FIRST || pim.state.c == NFA_START_INVISIBLE_BEFORE_NEG || pim.state.c == NFA_START_INVISIBLE_BEFORE_NEG_FIRST))
                            (ยง
                                ;; Copy submatch info from the recursive call.
                                (copy_sub_off (.. thread th_subs rs_norm), (.. pim np_subs rs_norm))
                                (if @nfa_has_zsubexpr
                                    (copy_sub_off (.. thread th_subs rs_synt), (.. pim np_subs rs_synt)))
                            )
                            :else
                            (ยง
                                ;; look-behind match failed, don't add the state
                                (ร CONTINUE)
                            ))

                            ;; Postponed invisible match was handled, don't add it to following states.
                            ((ร pim =) null)
                        )

                        ((ร nfa_pim_C pim_copy =) (ยง ยง_nfa_pim_C()))

                        ;; If "pim" points into nfl.threads,
                        ;; it will become invalid when adding the state causes the list to be reallocated.
                        ;; Make a local copy to avoid that.
                        (when (== pim (. thread th_pim))
                            (copy_pim pim_copy, pim)
                            ((ร pim =) pim_copy)
                        )

                        (cond add_here
                        (ยง
                            (addstate_here thislist, add_state, (. thread th_subs), pim, lidx)
                        )
                        :else
                        (ยง
                            (addstate nextlist, add_state, (. thread th_subs), pim, add_off)
                            (if (< 0 add_count)
                                ((ร nextlist.threads[nextlist.n - 1].count =) add_count)
                            )
                        ))
                    )
; %%            )

                ;; Look for the start of a match in the current position
                ;; by adding the start state to the list of states.
                ;; The first found match is the leftmost one, thus the order of states matters!
                ;; Do not add the start state in recursive calls of nfa_regmatch(),
                ;; because recursive calls should only start in the first position.
                ;; Unless "nfa_endp" is not null, then we match the end position.
                ;; Also don't start a match past the first line.

                (when (and (== @nfa_match FALSE) (or (and toplevel (== @reglnum 0) (!= clen 0) (or (== @ireg_maxcol 0) (< (BDIFF @reginput, @regline) @ireg_maxcol))) (and (!= @nfa_endp null) (if (== @reg_match null) (or (< @reglnum (.. @nfa_endp se_pos lnum)) (and (== @reglnum (.. @nfa_endp se_pos lnum)) (< (BDIFF @reginput, @regline) (.. @nfa_endp se_pos col)))) (BLT @reginput, (. @nfa_endp se_ptr))))))
                    ;; Inline optimized code for addstate() if we know the state is the first MOPEN.
                    (cond toplevel
                    (ยง
                        ((ร boolean add =) true)

                        (when (and (!= (. prog regstart) NUL) (non-zero? clen))
                            (cond (zero? (. nextlist n))
                            (ยง
; %%                            ((ร int[] col =) (ยง { BDIFF(@reginput, @regline) + clen }))

                                ;; Nextlist is empty, we can skip ahead to the
                                ;; character that must appear at the start.
                                (if (not (skip_to_start (. prog regstart), col))
                                    (ร BREAK)
                                )
                                (reset! reginput (.plus @regline (- (ยง col[0]) clen)))
                            )
                            :else
                            (ยง
                                ;; Checking if the required start character matches is
                                ;; cheaper than adding a state that won't match.
                                ((ร int c =) (ยง us_ptr2char(@reginput.plus(clen))))
                                (when (and (!= c (. prog regstart)) (or (not @ireg_ic) (!= (utf_tolower c) (utf_tolower (. prog regstart)))))
                                    ((ร add =) false)
                                )
                            ))
                        )

                        (when add
                            (if (nil? @reg_match)
                                ((ร m.rs_norm.rs_multi[0].start_col =) (ยง BDIFF(@reginput, @regline) + clen))
                                ((ร m.rs_norm.rs_line[0].start =) (ยง @reginput.plus(clen)))
                            )
                            (addstate nextlist, (ยง start.out0()), m, null, clen)
                        )
                    )
                    :else
                    (ยง
                        (addstate nextlist, start, m, null, clen)
                    ))
                )
;           }

            ;; Advance to the next character, or advance to the next line, or finish.
            (cond (non-zero? clen)
            (ยง
                (reset! reginput (.plus @reginput clen))
            )
            (or go_to_nextline (and (non-nil? @nfa_endp) (nil? @reg_match) (< @reglnum (.. @nfa_endp se_pos lnum))))
            (ยง
                (reg_nextline)
            )
            :else
            (ยง
                (ร BREAK)
            ))

            ;; Allow interrupting with CTRL-C.
            (line_breakcheck)
            (if @got_int
                (ร BREAK)
            )

            ;; Check for timeout once in a twenty times to avoid overhead.
            (when (and (non-zero? @nfa_time_limit) (== (ยง ++@nfa_time_count) 20))
                (reset! nfa_time_count 0)
                (if (profile_passed_limit @nfa_time_limit)
                    (ร BREAK)
                )
            )
        )

        @nfa_match
    ))

;; Try match of "prog" with at regline[col].
;; Returns <= 0 for failure, number of lines contained in the match otherwise.

(defn- #_long nfa_regtry [#_nfa_regprog_C prog, #_int col, #_long nsec]
    ;; nsec: timeout limit or 0
    (ยง
        ((ร regsubs_C subs =) (ยง ยง_regsubs_C()))
        ((ร regsubs_C m =) (ยง ยง_regsubs_C()))
        ((ร nfa_state_C start =) (. prog start))

        (reset! reginput (.plus @regline col))
        (reset! nfa_time_limit nsec)
        (reset! nfa_time_count 0)

        (clear_sub (. subs rs_norm))
        (clear_sub (. m rs_norm))
        (clear_sub (. subs rs_synt))
        (clear_sub (. m rs_synt))

        ((ร int result =) (nfa_regmatch prog, start, subs, m))
        (cond (== result FALSE)
        (ยง
            ((ร RETURN) 0)
        )
        (== result NFA_TOO_EXPENSIVE)
        (ยง
            ((ร RETURN) result)
        ))

        (cleanup_subexpr)
        (cond (nil? @reg_match)
        (ยง
            ((ร FOR) (ร (ยง int i = 0) (ยง i < subs.rs_norm.in_use) (ยง i++))
                ((ร @reg_startpos[i].lnum =) (ยง subs.rs_norm.rs_multi[i].start_lnum))
                ((ร @reg_startpos[i].col =) (ยง subs.rs_norm.rs_multi[i].start_col))

                ((ร @reg_endpos[i].lnum =) (ยง subs.rs_norm.rs_multi[i].end_lnum))
                ((ร @reg_endpos[i].col =) (ยง subs.rs_norm.rs_multi[i].end_col))
            )

            (when (< (ยง @reg_startpos[0].lnum) 0)
                ((ร @reg_startpos[0].lnum =) 0)
                ((ร @reg_startpos[0].col =) col)
            )
            (cond (< (ยง @reg_endpos[0].lnum) 0)
            (ยง
                ;; pattern has a \ze but it didn't match, use current end
                ((ร @reg_endpos[0].lnum =) @reglnum)
                ((ร @reg_endpos[0].col =) (BDIFF @reginput, @regline))
            )
            :else
            (ยง
                ;; Use line number of "\ze".
                (reset! reglnum (ยง @reg_endpos[0].lnum))
            ))
        )
        :else
        (ยง
            ((ร FOR) (ร (ยง int i = 0) (ยง i < subs.rs_norm.in_use) (ยง i++))
                ((ร @reg_startp[i] =) (ยง subs.rs_norm.rs_line[i].start))
                ((ร @reg_endp[i] =) (ยง subs.rs_norm.rs_line[i].end))
            )

            (if (nil? (ยง @reg_startp[0]))
                ((ร @reg_startp[0] =) (ยง @regline.plus(col)))
            )
            (if (nil? (ยง @reg_endp[0]))
                ((ร @reg_endp[0] =) @reginput)
            )
        ))

        ;; Package any found \z(...\) matches for export.  Default is none.
        (reset! re_extmatch_out null)

        (when (== (. prog reghasz) REX_SET)
            (cleanup_zsubexpr)
            (reset! re_extmatch_out (make_extmatch))
            ((ร FOR) (ร (ยง int i = 0) (ยง i < subs.rs_synt.in_use) (ยง i++))
                (cond (nil? @reg_match)
                (ยง
                    ((ร multipos_C mp =) (ยง subs.rs_synt.rs_multi[i]))

                    ;; Only accept single line matches that are valid.
                    (if (and (<= 0 (. mp start_lnum)) (== (. mp start_lnum) (. mp end_lnum)) (<= (. mp start_col) (. mp end_col)))
                        ((ร @re_extmatch_out.matches[i] =) (ยง STRNDUP(reg_getline(mp.start_lnum).plus(mp.start_col), mp.end_col - mp.start_col)))
                    )
                )
                :else
                (ยง
                    ((ร linepos_C lp =) (ยง subs.rs_synt.rs_line[i]))

                    (if (and (!= (. lp start) null) (!= (. lp end) null))
                        ((ร @re_extmatch_out.matches[i] =) (ยง STRNDUP(lp.start, BDIFF(lp.end, lp.start))))
                    )
                ))
            )
        )

        (+ 1 @reglnum)
    ))

;; Match a regexp against
;;  a string ("line" points to the string)
;;  or multiple lines ("line" is null, use reg_getline()).
;;
;; Returns <= 0 for failure, number of lines contained in the match otherwise.

(defn- #_long nfa_regexec_both [#_Bytes line, #_int startcol, #_long nsec]
    ;; startcol: column to start looking for match
    ;; nsec: timeout limit or 0
    (ยง
; %%    ((ร int[] col =) (ยง { startcol }))

        (ร nfa_regprog_C prog)
        (cond (nil? @reg_match)
        (ยง
            ((ร prog =) (ยง (nfa_regprog_C)@reg_mmatch.regprog))
            ((ร line =) (reg_getline 0))              ;; relative to the cursor
            (reset! reg_startpos (. @reg_mmatch startpos))
            (reset! reg_endpos (. @reg_mmatch endpos))
        )
        :else
        (ยง
            ((ร prog =) (ยง (nfa_regprog_C)@reg_match.regprog))
            (reset! reg_startp (. @reg_match startp))
            (reset! reg_endp (. @reg_match endp))
        ))

        ;; Be paranoid...
        (when (or (nil? prog) (nil? line))
            (emsg e_null)
            ((ร RETURN) 0)
        )

        ;; If pattern contains "\c" or "\C": overrule value of ireg_ic.
        (cond (non-zero? (& (. prog regflags) RF_ICASE))
        (ยง
            (reset! ireg_ic true)
        )
        (non-zero? (& (. prog regflags) RF_NOICASE))
        (ยง
            (reset! ireg_ic false)
        ))

        ;; If pattern contains "\Z" overrule value of ireg_icombine.
        (if (non-zero? (& (. prog regflags) RF_ICOMBINE))
            (reset! ireg_icombine true))

        (reset! regline line)
        (reset! reglnum 0)    ;; relative to line

        (reset! nfa_has_zend (. prog has_zend))
        (reset! nfa_has_backref (. prog has_backref))
        (reset! nfa_nsubexpr (. prog nsubexp))
        (reset! nfa_listid 1)
        (reset! nfa_alt_listid 2)
        ((ร nfa_regengine.expr =) (. prog pattern))

        (if (and (!= (. prog reganch) 0) (< 0 (ยง col[0])))
            ((ร RETURN) 0)
        )

        (reset! need_clear_subexpr true)
        ;; Clear the external match subpointers if necessary.
        (cond (== (. prog reghasz) REX_SET)
        (ยง
            (reset! nfa_has_zsubexpr true)
            (reset! need_clear_zsubexpr true)
        )
        :else
        (ยง
            (reset! nfa_has_zsubexpr false)
        ))

        (when (!= (. prog regstart) NUL)
            ;; Skip ahead until a character we know the match must start with.
            ;; When there is none there is no match.
            (if (not (skip_to_start (. prog regstart), col))
                ((ร RETURN) 0)
            )

            ;; If match_text is set, it contains the full text that must match.
            ;; Nothing else to try.  Doesn't handle combining chars well.
            (if (and (!= (. prog match_text) null) (not @ireg_icombine))
                ((ร RETURN) (ยง find_match_text(col[0], prog.regstart, prog.match_text)))
            )
        )

        ;; If the start column is past the maximum column: no need to try.
        (if (and (< 0 @ireg_maxcol) (<= @ireg_maxcol (ยง col[0])))
            ((ร RETURN) 0)
        )

        ((ร FOR) (ร (ยง int i = 0) (ยง i < prog.nstate) (ยง i++))
            ((ร nfa_state_C state =) (ยง prog.states[i]))
            (if (nil? state)
                (ร CONTINUE)
            )

            ((ร state.id =) i)
            ((ร state.lastlist[0] =) 0)
            ((ร state.lastlist[1] =) 0)
        )

        ((ร long retval =) (ยง nfa_regtry(prog, col[0], nsec)))

        ((ร nfa_regengine.expr =) null)

        retval
    ))

;; Compile a regular expression into internal code for the NFA matcher.
;; Returns the program in allocated space.  Returns null for an error.

(defn- #_regprog_C nfa_regcomp [#_Bytes expr, #_int re_flags]
    (ยง
        (if (nil? expr)
            ((ร RETURN) null)
        )

        (ร nfa_regprog_C prog)

        ((ร nfa_regengine.expr =) expr)
        (reset! nfa_re_flags re_flags)

        (init_class_tab)

        (nfa_regcomp_start expr, re_flags)

;       theend:
;       {
;           fail:
;           {
                ;; Build postfix form of the regexp.  Needed to build the NFA (and count its size).
                ((ร int[] postfix =) (re2post))
                (when (nil? postfix)
                    ;; TODO: only give this error for debugging?
                    (if (<= (. @post_array length) @post_index)
                        (emsgn (u8 "Internal error: estimated max number of states insufficient: %d"), (. @post_array length)))
                    (ร BREAK fail)         ;; cascaded (syntax?) error
                )

                ;; In order to build the NFA, we parse the input regexp twice:
                ;; 1. first pass to count size (so we can allocate space)
                ;; 2. second to emit code

                ((ร prog =) (ยง new nfa_regprog_C()))
                ((ร prog.nstate =) 0)

                ;; PASS 1
                ;; Count number of NFA states in "prog.nstate".  Do not build the NFA.

                (post2nfa postfix, @post_index, prog, true)

                ;; allocate space for the compiled regexp
                (reset! nfa_states (ยง prog.states = new nfa_state_C[prog.nstate]))
                ((ร prog.istate =) 0)

                ;; PASS 2
                ;; Build the NFA

                ((ร prog.start =) (post2nfa postfix, @post_index, prog, false))
                (if (nil? (. prog start))
                    (ร BREAK fail)
                )

                ((ร prog.regflags =) @regflags)
                ((ร prog.engine =) nfa_regengine)
                ((ร prog.has_zend =) @nfa_has_zend)
                ((ร prog.has_backref =) @nfa_has_backref)
                ((ร prog.nsubexp =) @regnpar)

                (nfa_postprocess prog)

                ((ร prog.reganch =) (if (nfa_get_reganch (. prog start), 0) 1 0))
                ((ร prog.regstart =) (nfa_get_regstart (. prog start), 0))
                ((ร prog.match_text =) (nfa_get_match_text (. prog start)))

                ;; Remember whether this pattern has any \z specials in it.
                ((ร prog.reghasz =) @re_has_z)
                ((ร prog.pattern =) (STRDUP expr))
                ((ร nfa_regengine.expr =) null)
                (ร BREAK theend)
;           }

            ((ร prog =) null)
            ((ร nfa_regengine.expr =) null)
;       }

        (reset! post_array null)
        (reset! post_index 0)
        (reset! nfa_states null)

        (ยง (regprog_C)prog)
    ))

;; Match a regexp against a string.
;; "rmp.regprog" is a compiled regexp as returned by nfa_regcomp().
;; Uses curbuf for line count and 'iskeyword'.
;; If "line_lbr" is true, consider a "\n" in "line" to be a line break.
;;
;; Returns <= 0 for failure, number of lines contained in the match otherwise.

(defn- #_long nfa_regexec_nl [#_regmatch_C rmp, #_Bytes line, #_int col, #_boolean line_lbr]
    ;; line: string to match against
    ;; col: column to start looking for match
    (ยง
        (reset! reg_match rmp)
        (reset! reg_mmatch null)
        (reset! reg_maxline 0)
        (reset! reg_line_lbr line_lbr)
        (reset! reg_buf @curbuf)
        (reset! reg_win null)
        (reset! ireg_ic (. rmp rm_ic))
        (reset! ireg_icombine false)
        (reset! ireg_maxcol 0)

        (nfa_regexec_both line, col, null)
    ))

;; Match a regexp against multiple lines.
;; "rmp.regprog" is a compiled regexp as returned by vim_regcomp().
;; Uses curbuf for line count and 'iskeyword'.
;;
;; Return <= 0 if there is no match.  Return number of lines contained in the match otherwise.
;;
;; Note: the body is the same as bt_regexec() except for nfa_regexec_both()
;;
;; ! Also NOTE : match may actually be in another line. e.g.:
;; when r.e. is \nc, cursor is at 'a' and the text buffer looks like
;;
;; +-------------------------+
;; |a                        |
;; |b                        |
;; |c                        |
;; |                         |
;; +-------------------------+
;;
;; then nfa_regexec_multi() returns 3. while the original
;; vim_regexec_multi() returns 0 and a second call at line 2 will return 2.
;;
;; FIXME if this behavior is not compatible.

(defn- #_long nfa_regexec_multi [#_regmmatch_C rmp, #_window_C win, #_buffer_C buf, #_long lnum, #_int col, #_long nsec]
    ;; win: window in which to search or null
    ;; buf: buffer in which to search
    ;; lnum: nr of line to start looking for match
    ;; col: column to start looking for match
    ;; nsec: timeout limit or 0
    (ยง
        (reset! reg_match null)
        (reset! reg_mmatch rmp)
        (reset! reg_buf buf)
        (reset! reg_win win)
        (reset! reg_firstlnum lnum)
        (reset! reg_maxline (- (.. @reg_buf b_ml ml_line_count) lnum))
        (reset! reg_line_lbr false)
        (reset! ireg_ic (. rmp rmm_ic))
        (reset! ireg_icombine false)
        (reset! ireg_maxcol (. rmp rmm_maxcol))

        (nfa_regexec_both null, col, nsec)
    ))

;; ----------------------------------------------------------------------- ;;

;; Which regexp engine to use?  Needed for vim_regcomp().
;; Must match with 'regexpengine'.

(atom! int regexp_engine)

;; Compile a regular expression into internal code.
;; Returns the program in allocated memory.
;; Returns null for an error.

(defn- #_regprog_C vim_regcomp [#_Bytes expr_arg, #_int re_flags]
    (ยง
        ((ร regprog_C prog =) null)
        ((ร Bytes expr =) expr_arg)

        (reset! regexp_engine (int @p_re))

        ;; Check for prefix "\%#=", that sets the regexp engine.
        (when (zero? (STRNCMP expr, (u8 "\\%#="), 4))
            ((ร int newengine =) (ยง expr.at(4) - (byte \0)))

            (cond (or (== newengine AUTOMATIC_ENGINE) (== newengine BACKTRACKING_ENGINE) (== newengine NFA_ENGINE))
            (ยง
                (reset! regexp_engine (- (.at expr 4) (byte \0)))
                ((ร expr =) (ยง expr.plus(5)))
            )
            :else
            (ยง
                (emsg (u8 "E864: \\%#= can only be followed by 0, 1, or 2. The automatic engine will be used."))
                (reset! regexp_engine AUTOMATIC_ENGINE)
            ))
        )

        ((ร bt_regengine.expr =) expr)
        ((ร nfa_regengine.expr =) expr)

        ;; First try the NFA engine, unless backtracking was requested.

        (if (!= @regexp_engine BACKTRACKING_ENGINE)
            ((ร prog =) (.regcomp nfa_regengine expr, (+ re_flags (if (== @regexp_engine AUTOMATIC_ENGINE) RE_AUTO 0))))
            ((ร prog =) (.regcomp bt_regengine expr, re_flags))
        )

        ;; Check for error compiling regexp with initial engine.
        (when (nil? prog)
            ;; If the NFA engine failed, try the backtracking engine.
            ;; The NFA engine also fails for patterns that it can't handle well
            ;; but are still valid patterns, thus a retry should work.

            (when (== @regexp_engine AUTOMATIC_ENGINE)
                (reset! regexp_engine BACKTRACKING_ENGINE)
                ((ร prog =) (.regcomp bt_regengine expr, re_flags))
            )
        )

        (when (non-nil? prog)
            ;; Store the info needed to call regcomp() again when
            ;; the engine turns out to be very slow executing it.
            ((ร prog.re_engine =) @regexp_engine)
            ((ร prog.re_flags =) re_flags)
        )

        prog
    ))

(defn- #_void report_re_switch [#_Bytes pat]
    (ยง
        (when (< 0 @p_verbose)
            (msg_puts (u8 "Switching to backtracking RE engine for pattern: "))
            (msg_puts pat)
        )
    ))

;; Match a regexp against a string.
;; "rmp.regprog" is a compiled regexp as returned by vim_regcomp().
;; Note: "rmp.regprog" may be freed and changed.
;; Uses curbuf for line count and 'iskeyword'.
;; When "nl" is true, consider a "\n" in "line" to be a line break.
;;
;; Return true if there is a match, false if not.

(defn- #_boolean vim_regexec_both [#_regmatch_C rmp, #_Bytes line, #_int col, #_boolean nl]
    ;; line: string to match against
    ;; col: column to start looking for match
    (ยง
        ((ร long result =) (ยง rmp.regprog.engine.regexec_nl(rmp, line, col, nl)))

        ;; NFA engine aborted because it's very slow.
        (when (and (== (.. rmp regprog re_engine) AUTOMATIC_ENGINE) (== result NFA_TOO_EXPENSIVE))
            ((ร long save_p_re =) @p_re)
            ((ร int re_flags =) (.. rmp regprog re_flags))
            ((ร Bytes pat =) (ยง STRDUP(((nfa_regprog_C)rmp.regprog).pattern)))

            (reset! p_re BACKTRACKING_ENGINE)
            ((ร rmp.regprog =) null)
            (when (non-nil? pat)
                (report_re_switch pat)
                ((ร rmp.regprog =) (vim_regcomp pat, re_flags))
                (if (!= (. rmp regprog) null)
                    ((ร result =) (ยง rmp.regprog.engine.regexec_nl(rmp, line, col, nl)))
                )
            )
            (reset! p_re save_p_re)
        )

        (< 0 result)
    ))

;; Note: "*prog" may be freed and changed.
;; Return true if there is a match, false if not.

(defn- #_boolean vim_regexec_prog [#_regprog_C* prog, #_boolean ignore_case, #_Bytes line, #_int col]
    (ยง
        ((ร regmatch_C regmatch =) (ยง ยง_regmatch_C()))
        ((ร regmatch.regprog =) (ยง prog[0]))
        ((ร regmatch.rm_ic =) ignore_case)

        ((ร boolean r =) (vim_regexec_both regmatch, line, col, false))

        ((ร prog[0] =) (. regmatch regprog))
        r
    ))

;; Note: "rmp.regprog" may be freed and changed.
;; Return true if there is a match, false if not.

(defn- #_boolean vim_regexec [#_regmatch_C rmp, #_Bytes line, #_int col]
    (vim_regexec_both rmp, line, col, false))

;; Like vim_regexec(), but consider a "\n" in "line" to be a line break.
;; Note: "rmp.regprog" may be freed and changed.
;; Return true if there is a match, false if not.

(defn- #_boolean vim_regexec_nl [#_regmatch_C rmp, #_Bytes line, #_int col]
    (vim_regexec_both rmp, line, col, true))

;; Match a regexp against multiple lines.
;; "rmp.regprog" is a compiled regexp as returned by vim_regcomp().
;; Note: "rmp.regprog" may be freed and changed.
;; Uses curbuf for line count and 'iskeyword'.
;;
;; Return zero if there is no match.  Return number of lines contained in the match otherwise.

(defn- #_long vim_regexec_multi [#_regmmatch_C rmp, #_window_C win, #_buffer_C buf, #_long lnum, #_int col, #_long nsec]
    ;; win: window in which to search or null
    ;; buf: buffer in which to search
    ;; lnum: nr of line to start looking for match
    ;; col: column to start looking for match
    ;; nsec: timeout limit or 0
    (ยง
        ((ร long result =) (ยง rmp.regprog.engine.regexec_multi(rmp, win, buf, lnum, col, nsec)))

        ;; NFA engine aborted because it's very slow.
        (when (and (== (.. rmp regprog re_engine) AUTOMATIC_ENGINE) (== result NFA_TOO_EXPENSIVE))
            ((ร long save_p_re =) @p_re)
            ((ร int re_flags =) (.. rmp regprog re_flags))
            ((ร Bytes pat =) (ยง STRDUP(((nfa_regprog_C)rmp.regprog).pattern)))

            (reset! p_re BACKTRACKING_ENGINE)
            ((ร rmp.regprog =) null)
            (when (non-nil? pat)
                (report_re_switch pat)
                ((ร rmp.regprog =) (vim_regcomp pat, re_flags))
                (if (!= (. rmp regprog) null)
                    ((ร result =) (ยง rmp.regprog.engine.regexec_multi(rmp, win, buf, lnum, col, nsec)))
                )
            )
            (reset! p_re save_p_re)
        )

        (ยง Math.max(0, result))
    ))

;;; ============================================================================================== VimP

;; search.c: code for normal mode searching commands ----------------------------------------------

;; This file contains various searching-related routines.  These fall into
;; three groups:
;; 1. string searches (for /, ?, n, and N)
;; 2. character searches within a single line (for f, F, t, T, etc)
;; 3. "other" kinds of searches like the '%' command, and 'word' searches.

;; String searches
;;
;; The string search functions are divided into two levels:
;; lowest:  searchit(); uses an pos_C for starting position and found match.
;; Highest: do_search(); uses curwin.w_cursor; calls searchit().
;;
;; The last search pattern is remembered for repeating the same search.
;; This pattern is shared between the :g, :s, ? and / commands.
;; This is in search_regcomp().
;;
;; The actual string matching is done using a heavily modified version of
;; Henry Spencer's regular expression library.  See regexp.c.

;; The offset for a search command is store in a soff struct.
;; Note: only spats[0].sp_off is really used.
(class! #_final soffset_C
    [
        (field byte         dir)            ;; search direction, '/' or '?'
        (field boolean      line)           ;; search has line offset
        (field boolean      end)            ;; search set cursor at end
        (field long         off)            ;; line or char offset
    ])

(defn- #_void COPY_soffset [#_soffset_C so1, #_soffset_C so0]
    (ยง
        ((ร so1.dir =) (. so0 dir))
        ((ร so1.line =) (. so0 line))
        ((ร so1.end =) (. so0 end))
        ((ร so1.off =) (. so0 off))
    ))

;; A search pattern and its attributes are stored in a spat struct.
(class! #_final spat_C
    [
        (field Bytes        pat)            ;; the pattern (in allocated memory) or null
        (field boolean      magic)          ;; magicness of the pattern
        (field boolean      no_scs)         ;; no smartcase for this pattern
        (field soffset_C    sp_off      (ยง_soffset_C))
    ])

(defn- #_spat_C new_spat []
    (ยง
        ((ร spat_C sp =) (ยง ยง_spat_C()))

        ((ร sp.magic =) true)
        ((ร sp.sp_off.dir =) (byte \/))

        sp
    ))

;; Two search patterns are remembered: one for the :substitute command and one for other searches.
;; last_idx points to the one that was used the last time.

(atom! spat_C* #_"/*[2]*/" spats
    [
        new_spat(),                     ;; last used search pat
        new_spat()                      ;; last used substitute pat
    ])
(atom! int last_idx)        ;; index in spats[] for RE_LAST

(atom! Bytes mr_pattern)   ;; pattern used by search_regcomp()

;; translate search pattern for vim_regcomp()
;;
;; pat_save == RE_SEARCH: save pat in spats[RE_SEARCH].pat (normal search cmd)
;; pat_save == RE_SUBST: save pat in spats[RE_SUBST].pat (:substitute command)
;; pat_save == RE_BOTH: save pat in both patterns (:global command)
;; pat_use  == RE_SEARCH: use previous search pattern if "pat" is null
;; pat_use  == RE_SUBST: use previous substitute pattern if "pat" is null
;; pat_use  == RE_LAST: use last used pattern if "pat" is null
;; options & SEARCH_HIS: put search string in history
;; options & SEARCH_KEEP: keep previous search pattern
;;
;; returns false if failed, true otherwise.

(defn- #_boolean search_regcomp [#_Bytes pat, #_int pat_save, #_int pat_use, #_int options, #_regmmatch_C regmatch]
    ;; regmatch: return: pattern and ignore-case flag
    (ยง
        (reset! rc_did_emsg false)
        ((ร boolean magic =) @p_magic)

        ;; If no pattern given, use a previously defined pattern.

        (cond (or (nil? pat) (eos? pat))
        (ยง
            (ร int i)
            (if (== pat_use RE_LAST)
                ((ร i =) @last_idx)
                ((ร i =) pat_use)
            )
            (when (nil? (ยง @spats[i].pat))           ;; pattern was never defined
                (if (== pat_use RE_SUBST)
                    (emsg e_nopresub)
                    (emsg e_noprevre))
                (reset! rc_did_emsg true)
                ((ร RETURN) false)
            )
            ((ร pat =) (ยง @spats[i].pat))
            ((ร magic =) (ยง @spats[i].magic))
            (reset! no_smartcase (ยง @spats[i].no_scs))
        )
        (non-zero? (& options SEARCH_HIS))   ;; put new pattern in history
        (ยง
            (add_to_history HIST_SEARCH, pat, NUL)
        ))

        (reset! mr_pattern pat)

        ;; Save the currently used pattern in the appropriate place,
        ;; unless the pattern should not be remembered.

        (when (zero? (& options SEARCH_KEEP))
            ;; search or global command
            (if (or (== pat_save RE_SEARCH) (== pat_save RE_BOTH))
                (save_re_pat RE_SEARCH, pat, magic))
            ;; substitute or global command
            (if (or (== pat_save RE_SUBST) (== pat_save RE_BOTH))
                (save_re_pat RE_SUBST, pat, magic))
        )

        ((ร regmatch.rmm_ic =) (ignorecase pat))
        ((ร regmatch.rmm_maxcol =) 0)
        ((ร regmatch.regprog =) (vim_regcomp pat, (if magic RE_MAGIC 0)))

        (!= (. regmatch regprog) null)
    ))

;; Get search pattern used by search_regcomp().

(defn- #_Bytes get_search_pat []
    @mr_pattern)

(defn- #_void save_re_pat [#_int idx, #_Bytes pat, #_boolean magic]
    (ยง
        (when (BNE (ยง @spats[idx].pat), pat)
            ((ร @spats[idx].pat =) (STRDUP pat))
            ((ร @spats[idx].magic =) magic)
            ((ร @spats[idx].no_scs =) @no_smartcase)
            (reset! last_idx idx)
            ;; If 'hlsearch' set and search 'pat' changed: need redraw.
            (if @p_hls
                (redraw_all_later SOME_VALID))
            (reset! no_hlsearch false)
        )
    ))

;; Return true when case should be ignored for search pattern "pat".
;; Uses the 'ignorecase' and 'smartcase' options.

(defn- #_boolean ignorecase [#_Bytes pat]
    (ยง
        ((ร boolean ic =) @p_ic)

        (if (and ic (not @no_smartcase) @p_scs)
            ((ร ic =) (ยง !pat_has_uppercase(pat)))
        )
        (reset! no_smartcase false)

        ic
    ))

;; Return true if patter "pat" has an uppercase character.

(defn- #_boolean pat_has_uppercase [#_Bytes pat]
    (ยง
        ((ร Bytes p =) pat)

        (while (ยง p.at(0) != NUL)
            ((ร int len =) (us_ptr2len_cc p))
            (cond (< 1 len)
            (ยง
                (if (utf_isupper (us_ptr2char p))
                    ((ร RETURN) true)
                )
                ((ร p =) (ยง p.plus(len)))
            )
            (== (.at p 0) (byte \\))
            (ยง
                (cond (and (== (.at p 1) (byte \_)) (non-eos? p 2))         ;; skip "\_X"
                (ยง
                    ((ร p =) (ยง p.plus(3)))
                )
                (and (== (.at p 1) (byte \%)) (non-eos? p 2))    ;; skip "\%X"
                (ยง
                    ((ร p =) (ยง p.plus(3)))
                )
                (non-eos? p 1)                   ;; skip "\X"
                (ยง
                    ((ร p =) (ยง p.plus(2)))
                )
                :else
                (ยง
                    ((ร p =) (ยง p.plus(1)))
                ))
            )
            (utf_isupper (ยง p.at(0)))
            (ยง
                ((ร RETURN) true)
            )
            :else
            (ยง
                ((ร p =) (ยง p.plus(1)))
            ))
        )
        false
    ))

(defn- #_Bytes last_search_pat []
    (ยง
        (ยง @spats[@last_idx].pat)
    ))

;; Get a regexp program for the last used search pattern.
;; This is used for highlighting all matches in a window.
;; Values returned in regmatch.regprog and regmatch.rmm_ic.

(defn- #_void last_pat_prog [#_regmmatch_C regmatch]
    (ยง
        (when (nil? (ยง @spats[@last_idx].pat))
            ((ร regmatch.regprog =) null)
            (ร RETURN)
        )

        (swap! emsg_off inc)         ;; So it doesn't beep if bad expr
        (search_regcomp (u8 ""), 0, @last_idx, SEARCH_KEEP, regmatch)
        (swap! emsg_off dec)
    ))

(final Bytes top_bot_msg (u8 "search hit TOP, continuing at BOTTOM"))
(final Bytes bot_top_msg (u8 "search hit BOTTOM, continuing at TOP"))

;; Lowest level search function.
;; Search for 'count'th occurrence of pattern 'pat' in direction 'dir'.
;; Start at position 'pos' and return the found position in 'pos'.
;;
;; if (options & SEARCH_MSG) == 0 don't give any messages
;; if (options & SEARCH_MSG) == SEARCH_NFMSG don't give 'notfound' messages
;; if (options & SEARCH_MSG) == SEARCH_MSG give all messages
;; if (options & SEARCH_HIS) put search pattern in history
;; if (options & SEARCH_END) return position at end of match
;; if (options & SEARCH_START) accept match at pos itself
;; if (options & SEARCH_KEEP) keep previous search pattern
;; if (options & SEARCH_FOLD) match only once in a closed fold
;; if (options & SEARCH_PEEK) check for typed char, cancel search
;;
;; Return false (zero) for failure, non-zero for success.
;; When FEAT_EVAL is defined, returns the index of the first matching
;; subpattern plus one; one if there was none.

(defn- #_int searchit [#_window_C win, #_buffer_C buf, #_pos_C pos, #_int dir, #_Bytes pat, #_long count, #_int options, #_int pat_use, #_long stop_lnum, #_long nsec]
    ;; win: window to search in; can be null for a buffer without a window!
    ;; pat_use: which pattern to use when "pat" is empty
    ;; stop_lnum: stop after this line number when != 0
    ;; nsec: timeout limit or 0
    (ยง
        ((ร int submatch =) 0)

        ((ร boolean first_match =) true)
        ((ร boolean save_called_emsg =) @called_emsg)
        ((ร boolean break_loop =) false)

        ((ร regmmatch_C regmatch =) (ยง ยง_regmmatch_C()))
        (when (not (search_regcomp pat, RE_SEARCH, pat_use, (& options (+ SEARCH_HIS SEARCH_KEEP)), regmatch))
            (if (and (non-zero? (& options SEARCH_MSG)) (not @rc_did_emsg))
                (emsg2 (u8 "E383: Invalid search string: %s"), @mr_pattern))
            ((ร RETURN) 0)
        )

        (ร boolean found)
        (ร long lnum)

        ((ร pos_C start_pos =) (ยง ยง_pos_C()))
        ((ร lpos_C matchpos =) (ยง ยง_lpos_C()))
        ((ร lpos_C endpos =) (ยง ยง_lpos_C()))

        ;; find the string

        (reset! called_emsg false)
;       do  ;; loop for count
;       {
            ;; When not accepting a match at the start position, set "extra_col" to a non-zero value.
            ;; Don't do that when starting at MAXCOL, since MAXCOL + 1 is zero.
            (ร int extra_col)
            (cond (or (non-zero? (& options SEARCH_START)) (== (. pos col) MAXCOL))
            (ยง
                ((ร extra_col =) 0)
            )
            ;; Watch out for the "col" being MAXCOL - 2, used in a closed fold.
            (and (!= dir BACKWARD) (<= 1 (. pos lnum)) (<= (. pos lnum) (.. buf b_ml ml_line_count)) (< (. pos col) (- MAXCOL 2)))
            (ยง
                ((ร Bytes ptr =) (ยง ml_get_buf(buf, pos.lnum).plus(pos.col)))
                (if (eos? ptr)
                    ((ร extra_col =) 1)
                    ((ร extra_col =) (us_ptr2len_cc ptr))
                )
            )
            :else
            (ยง
                ((ร extra_col =) 1)
            ))

            (COPY_pos start_pos, pos)       ;; remember start pos for detecting no match
            ((ร found =) false)                  ;; default: not found
            ((ร boolean at_first_line =) true)   ;; default: start in first line
            (when (zero? (. pos lnum))              ;; correct lnum for when starting in line 0
                ((ร pos.lnum =) 1)
                ((ร pos.col =) 0)
                ((ร at_first_line =) false)      ;; not in first line now
            )

            ;; Start searching in current line, unless searching backwards and we're in column 0.
            ;; If we are searching backwards, in column 0, and not including the
            ;; current position, gain some efficiency by skipping back a line.
            ;; Otherwise begin the search in the current line.

            (cond (and (== dir BACKWARD) (zero? (. start_pos col)) (zero? (& options SEARCH_START)))
            (ยง
                ((ร lnum =) (ยง pos.lnum - 1))
                ((ร at_first_line =) false)
            )
            :else
            (ยง
                ((ร lnum =) (. pos lnum))
            ))

            ((ร FOR) (ร (ยง int loop = 0) (<= loop 1) (ยง loop++))   ;; loop twice if 'wrapscan' set
                ((ร FOR) (ร (ยง  ) (ยง 0 < lnum && lnum <= buf.b_ml.ml_line_count) (ยง lnum += dir, at_first_line = false))
                    ;; Stop after checking "stop_lnum", if it's set.
                    (if (and (non-zero? stop_lnum) (if (== dir FORWARD) (< stop_lnum lnum) (< lnum stop_lnum)))
                        (ร BREAK)
                    )
                    ;; Stop after passing the 'nsec' time limit.
                    (if (and (non-zero? nsec) (profile_passed_limit nsec))
                        (ร BREAK)
                    )

                    ;; Look for a match somewhere in line "lnum".

                    ((ร long nmatched =) (vim_regexec_multi regmatch, win, buf, lnum, 0, nsec))
                    ;; Abort searching on an error (e.g., out of stack).
                    (if @called_emsg
                        (ร BREAK)
                    )
                    (when (< 0 nmatched)
                        ;; match may actually be in another line when using \zs
                        (COPY_lpos matchpos, (ยง regmatch.startpos[0]))
                        (COPY_lpos endpos, (ยง regmatch.endpos[0]))
                        ((ร submatch =) (first_submatch regmatch))
                        ;; "lnum" may be past end of buffer for "\n\zs".
                        (ร Bytes ptr)
                        (if (< (.. buf b_ml ml_line_count) (+ lnum (. matchpos lnum)))
                            ((ร ptr =) (u8 ""))
                            ((ร ptr =) (ยง ml_get_buf(buf, lnum + matchpos.lnum)))
                        )

                        ;; Forward search in the first line: match should be after
                        ;; the start position.  If not, continue at the end of the
                        ;; match (this is vi compatible) or on the next char.

                        (when (and (== dir FORWARD) at_first_line)
                            ((ร boolean match_ok =) true)

                            ;; When the match starts in a next line it's certainly
                            ;; past the start position.
                            ;; When match lands on a NUL the cursor will be put
                            ;; one back afterwards, compare with that position,
                            ;; otherwise "/$" will get stuck on end of line.

                            (while (and (== (. matchpos lnum) 0) (if (and (!= (& options SEARCH_END) 0) first_match) (and (== nmatched 1) (< (- (. endpos col) 1) (+ (. start_pos col) extra_col))) (< (- (. matchpos col) (if (== (.at ptr (. matchpos col)) NUL) 1 0)) (+ (. start_pos col) extra_col))))
                                ;; If vi-compatible searching, continue at the end
                                ;; of the match, otherwise continue one position forward.

                                (ร int matchcol)
                                (cond (non-nil? (vim_strbyte @p_cpo, CPO_SEARCH))
                                (ยง
                                    (when (< 1 nmatched)
                                        ;; end is in next line, thus no match in this line
                                        ((ร match_ok =) false)
                                        (ร BREAK)
                                    )
                                    ((ร matchcol =) (. endpos col))
                                    ;; for empty match: advance one char
                                    (if (and (== matchcol (. matchpos col)) (non-eos? ptr matchcol))
                                        ((ร matchcol +=) (ยง us_ptr2len_cc(ptr.plus(matchcol))))
                                    )
                                )
                                :else
                                (ยง
                                    ((ร matchcol =) (. matchpos col))
                                    (if (non-eos? ptr matchcol)
                                        ((ร matchcol +=) (ยง us_ptr2len_cc(ptr.plus(matchcol))))
                                    )
                                ))
                                (if (and (zero? matchcol) (non-zero? (& options SEARCH_START)))
                                    (ร BREAK)
                                )
                                (when (or (eos? ptr matchcol) (zero? (ยง nmatched = vim_regexec_multi(regmatch, win, buf, lnum + matchpos.lnum, matchcol, nsec))))
                                    ((ร match_ok =) false)
                                    (ร BREAK)
                                )
                                (COPY_lpos matchpos, (ยง regmatch.startpos[0]))
                                (COPY_lpos endpos, (ยง regmatch.endpos[0]))
                                ((ร submatch =) (first_submatch regmatch))

                                ;; Need to get the line pointer again,
                                ;; a multi-line search may have made it invalid.
                                ((ร ptr =) (ยง ml_get_buf(buf, lnum + matchpos.lnum)))
                            )
                            (if (not match_ok)
                                (ร CONTINUE)
                            )
                        )
                        (when (== dir BACKWARD)
                            ;; Now, if there are multiple matches on this line,
                            ;; we have to get the last one.  Or the last one before
                            ;; the cursor, if we're on that line.
                            ;; When putting the new cursor at the end, compare
                            ;; relative to the end of the match.

                            ((ร boolean match_ok =) false)
                            (while true
                                ;; Remember a position that is before the start
                                ;; position, we use it if it's the last match in
                                ;; the line.  Always accept a position after
                                ;; wrapping around.
                                (cond (or (!= loop 0) (if (!= (& options SEARCH_END) 0) (or (< (+ lnum (ยง regmatch.endpos[0].lnum)) (. start_pos lnum)) (and (== (+ lnum (ยง regmatch.endpos[0].lnum)) (. start_pos lnum)) (<= (+ (- (ยง regmatch.endpos[0].col) 1) extra_col) (. start_pos col)))) (or (< (+ lnum (ยง regmatch.startpos[0].lnum)) (. start_pos lnum)) (and (== (+ lnum (ยง regmatch.startpos[0].lnum)) (. start_pos lnum)) (<= (+ (ยง regmatch.startpos[0].col) extra_col) (. start_pos col))))))
                                (ยง
                                    ((ร match_ok =) true)
                                    (COPY_lpos matchpos, (ยง regmatch.startpos[0]))
                                    (COPY_lpos endpos, (ยง regmatch.endpos[0]))
                                    ((ร submatch =) (first_submatch regmatch))
                                )
                                :else
                                (ยง
                                    (ร BREAK)
                                ))

                                ;; We found a valid match, now check if there is another one after it.
                                ;; If vi-compatible searching, continue at the end of the match,
                                ;; otherwise continue one position forward.

                                (ร int matchcol)
                                (cond (non-nil? (vim_strbyte @p_cpo, CPO_SEARCH))
                                (ยง
                                    (if (< 1 nmatched)
                                        (ร BREAK)
                                    )
                                    ((ร matchcol =) (. endpos col))
                                    ;; for empty match: advance one char
                                    (if (and (== matchcol (. matchpos col)) (non-eos? ptr matchcol))
                                        ((ร matchcol +=) (ยง us_ptr2len_cc(ptr.plus(matchcol))))
                                    )
                                )
                                :else
                                (ยง
                                    ;; Stop when the match is in a next line.
                                    (if (< 0 (. matchpos lnum))
                                        (ร BREAK)
                                    )
                                    ((ร matchcol =) (. matchpos col))
                                    (if (non-eos? ptr matchcol)
                                        ((ร matchcol +=) (ยง us_ptr2len_cc(ptr.plus(matchcol))))
                                    )
                                ))
                                (when (or (eos? ptr matchcol) (zero? (ยง nmatched = vim_regexec_multi(regmatch, win, buf, lnum + matchpos.lnum, matchcol, nsec))))
                                    (ร BREAK)
                                )

                                ;; Need to get the line pointer again,
                                ;; a multi-line search may have made it invalid.
                                ((ร ptr =) (ยง ml_get_buf(buf, lnum + matchpos.lnum)))
                            )

                            ;; If there is only a match after the cursor, skip this match.

                            (if (not match_ok)
                                (ร CONTINUE)
                            )
                        )

                        ;; With the SEARCH_END option move to the last character of the match.
                        ;; Don't do it for an empty match, end should be same as start then.
                        (cond (and (non-zero? (& options SEARCH_END)) (zero? (& options SEARCH_NOOF)) (or (!= (. matchpos lnum) (. endpos lnum)) (!= (. matchpos col) (. endpos col))))
                        (ยง
                            ;; For a match in the first column,
                            ;; set the position on the NUL in the previous line.
                            ((ร pos.lnum =) (ยง lnum + endpos.lnum))
                            ((ร pos.col =) (. endpos col))
                            (cond (zero? (. endpos col))
                            (ยง
                                (when (< 1 (. pos lnum))   ;; just in case
                                    (ยง --pos.lnum)
                                    ((ร pos.col =) (ยง STRLEN(ml_get_buf(buf, pos.lnum))))
                                )
                            )
                            :else
                            (ยง
                                (ยง --pos.col)
                                (when (<= (. pos lnum) (.. buf b_ml ml_line_count))
                                    ((ร ptr =) (ยง ml_get_buf(buf, pos.lnum)))
                                    ((ร pos.col -=) (ยง us_head_off(ptr, ptr.plus(pos.col))))
                                )
                            ))
                        )
                        :else
                        (ยง
                            ((ร pos.lnum =) (ยง lnum + matchpos.lnum))
                            ((ร pos.col =) (. matchpos col))
                        ))
                        ((ร pos.coladd =) 0)
                        ((ร found =) true)
                        ((ร first_match =) false)

                        ;; Set variables used for 'incsearch' highlighting.
                        (reset! search_match_lines (- (. endpos lnum) (. matchpos lnum)))
                        (reset! search_match_endcol (. endpos col))
                        (ร BREAK)
                    )
                    (line_breakcheck)      ;; stop if ctrl-C typed
                    (if @got_int
                        (ร BREAK)
                    )

                    ;; Cancel searching if a character was typed.  Used for 'incsearch'.
                    ;; Don't check too often, that would slowdown searching too much.
                    (when (and (non-zero? (& options SEARCH_PEEK)) (zero? (ยง (lnum - pos.lnum) & 0x3f)) (char_avail))
                        ((ร break_loop =) true)
                        (ร BREAK)
                    )

                    (if (and (non-zero? loop) (== lnum (. start_pos lnum)))
                        (ร BREAK)              ;; if second loop, stop where started
                    )
                )
                ((ร at_first_line =) false)

                ;; Stop the search if wrapscan isn't set, "stop_lnum" is specified,
                ;; after an interrupt, after a match and after looping twice.

                (if (or (not @p_ws) (non-zero? stop_lnum) @got_int @called_emsg break_loop found (non-zero? loop))
                    (ร BREAK)
                )

                ;; If 'wrapscan' is set we continue at the other end of the file.
                ;; This message is also remembered in "keep_msg" for when the screen is redrawn.
                ;; The "keep_msg" is cleared whenever another message is written.

                (if (== dir BACKWARD)    ;; start second loop at the other end
                    ((ร lnum =) (.. buf b_ml ml_line_count))
                    ((ร lnum =) 1)
                )
                (if (non-zero? (& options SEARCH_MSG))
                    (give_warning (if (== dir BACKWARD) top_bot_msg bot_top_msg), true))
            )
            (if (or @got_int @called_emsg break_loop)
                (ร BREAK)
            )
;       } while (0 < --count && found);     ;; stop after count matches or no match

        ((ร @called_emsg |=) save_called_emsg)

        (when (not found)             ;; did not find it
            (cond @got_int
            (ยง
                (emsg e_interr)
            )
            (ยง (options & SEARCH_MSG) == SEARCH_MSG)
            (ยง
                (cond @p_ws
                (ยง
                    (emsg2 e_patnotf2, @mr_pattern)
                )
                (zero? lnum)
                (ยง
                    (emsg2 (u8 "E384: search hit TOP without match for: %s"), @mr_pattern)
                )
                :else
                (ยง
                    (emsg2 (u8 "E385: search hit BOTTOM without match for: %s"), @mr_pattern)
                ))
            ))
            ((ร RETURN) 0)
        )

        ;; A pattern like "\n\zs" may go past the last line.
        (when (> (. pos lnum) (.. buf b_ml ml_line_count))
            ((ร pos.lnum =) (.. buf b_ml ml_line_count))
            ((ร pos.col =) (ยง STRLEN(ml_get_buf(buf, pos.lnum))))
            (if (< 0 (. pos col))
                (ยง --pos.col)
            )
        )

        (+ 1 submatch)
    ))

;; Return the number of the first subpat that matched.

(defn- #_int first_submatch [#_regmmatch_C rp]
    (ยง
        (ร int submatch)

        ((ร FOR) (ร (ยง submatch = 1) true (ยง submatch++))
            (if (<= 0 (ยง rp.startpos[submatch].lnum))
                (ร BREAK)
            )
            (when (== submatch 9)
                ((ร submatch =) 0)
                (ร BREAK)
            )
        )

        submatch
    ))

;; Highest level string search function.
;; Search for the 'count'th occurrence of pattern 'pat' in direction 'dirc'
;;                If 'dirc' is 0: use previous dir.
;;    If 'pat' is null or empty : use previous string.
;;    If 'options & SEARCH_REV' : go in reverse of previous dir.
;;    If 'options & SEARCH_ECHO': echo the search command and handle options
;;    If 'options & SEARCH_MSG' : may give error message
;;    If 'options & SEARCH_OPT' : interpret optional flags
;;    If 'options & SEARCH_HIS' : put search pattern in history
;;    If 'options & SEARCH_NOOF': don't add offset to position
;;    If 'options & SEARCH_MARK': set previous context mark
;;    If 'options & SEARCH_KEEP': keep previous search pattern
;;    If 'options & SEARCH_START': accept match at curpos itself
;;    If 'options & SEARCH_PEEK': check for typed char, cancel search
;;
;; Careful: If spats[0].sp_off.line == true and spats[0].sp_off.off == 0,
;; this makes the movement linewise without moving the match position.
;;
;; Return 0 for failure, 1 for found, 2 for found and line offset added.

(defn- #_int do_search [#_oparg_C oap, #_byte dirc, #_Bytes pat, #_long count, #_int options, #_long nsec]
    ;; oap: can be null
    ;; dirc: '/' or '?'
    ;; nsec: timeout limit or 0
    (ยง
        (ร int retval)

        ;; A line offset is not remembered, this is vi compatible.

        (when (and (ยง @spats[0].sp_off.line) (non-nil? (vim_strbyte @p_cpo, CPO_LINEOFF)))
            ((ร @spats[0].sp_off.line =) false)
            ((ร @spats[0].sp_off.off =) 0)
        )

        ;; Save the values for when (options & SEARCH_KEEP) is used.
        ;; (there is no "if ()" around this because gcc wants them initialized)

        ((ร soffset_C old_off =) (ยง ยง_soffset_C()))
        (COPY_soffset old_off, (ยง @spats[0].sp_off))

        ;; position of the last match
        ((ร pos_C pos =) (ยง ยง_pos_C()))
        (COPY_pos pos, (. @curwin w_cursor)) ;; start searching at the cursor position

        ;; Find out the direction of the search.

        (if (zero? dirc)
            ((ร dirc =) (ยง @spats[0].sp_off.dir))
            ((ร @spats[0].sp_off.dir =) dirc)
        )

        (when (non-zero? (& options SEARCH_REV))
            (if (== dirc (byte \/))
                ((ร dirc =) (byte \?))
                ((ร dirc =) (byte \/))
            )
        )

        ;; Turn 'hlsearch' highlighting back on.

        (when (and @no_hlsearch (zero? (& options SEARCH_KEEP)))
            (redraw_all_later SOME_VALID)
            (reset! no_hlsearch false)
        )

;       end_do_search:
;       {
; %%        ((ร Bytes[] strcopy =) (ยง { null }))

            ;; Repeat the search when pattern followed by ';', e.g. "/foo/;?bar".

            (while true
                ((ร Bytes searchstr =) pat)                     ;; use previous pattern
                ((ร Bytes dircp =) null)

                (when (or (nil? pat) (eos? pat) (== (.at pat 0) dirc))
                    (cond (nil? (ยง @spats[RE_SEARCH].pat))       ;; no previous pattern
                    (ยง
                        ((ร pat =) (ยง @spats[RE_SUBST].pat))
                        (when (nil? pat)
                            (emsg e_noprevre)
                            ((ร retval =) 0)
                            (ร BREAK end_do_search)
                        )
                        ((ร searchstr =) pat)
                    )
                    :else
                    (ยง
                        ;; make search_regcomp() use spats[RE_SEARCH].pat
                        ((ร searchstr =) (u8 ""))
                    ))
                )

                (when (and (non-nil? pat) (non-eos? pat))            ;; look for (new) offset
                    ;; Find end of regular expression.
                    ;; If there is a matching '/' or '?', toss it.

                    ((ร Bytes ps =) (ยง strcopy[0]))
                    ((ร Bytes p =) (skip_regexp pat, dirc, @p_magic, strcopy))
                    (when (BNE (ยง strcopy[0]), ps)
                        ;; made a copy of "pat" to change "\?" to "?"
                        ((ร @searchcmdlen +=) (ยง STRLEN(pat) - STRLEN(strcopy[0])))
                        ((ร pat =) (ยง strcopy[0]))
                        ((ร searchstr =) (ยง strcopy[0]))
                    )
                    (when (== (.at p 0) dirc)
                        ((ร dircp =) p)                  ;; remember where we put the NUL
                        (ยง (p = p.plus(1)).be(-1, NUL))
                    )
                    ((ร @spats[0].sp_off.line =) false)
                    ((ร @spats[0].sp_off.end =) false)
                    ((ร @spats[0].sp_off.off =) 0)

                    ;; Check for a line offset or a character offset.
                    ;; For get_address (echo off) we don't check for a character offset,
                    ;; because it is meaningless and the 's' could be a substitute command.

                    (cond (or (== (.at p 0) (byte \+)) (== (.at p 0) (byte \-)) (asc_isdigit (ยง p.at(0))))
                    (ยง
                        ((ร @spats[0].sp_off.line =) true)
                    )
                    (and (non-zero? (& options SEARCH_OPT)) (or (== (.at p 0) (byte \e)) (== (.at p 0) (byte \s)) (== (.at p 0) (byte \b))))
                    (ยง
                        (if (== (.at p 0) (byte \e))                           ;; end
                            ((ร @spats[0].sp_off.end =) (ยง (SEARCH_END != 0)))
                        )
                        ((ร p =) (ยง p.plus(1)))
                    ))
                    (when (or (asc_isdigit (ยง p.at(0))) (== (.at p 0) (byte \+)) (== (.at p 0) (byte \-)))      ;; got an offset
                        (cond (or (asc_isdigit (ยง p.at(0))) (asc_isdigit (ยง p.at(1))))   ;; 'nr' or '+nr' or '-nr'
                        (ยง
                            ((ร @spats[0].sp_off.off =) (ยง libC.atol(p)))
                        )
                        (== (.at p 0) (byte \-))                      ;; single '-'
                        (ยง
                            ((ร @spats[0].sp_off.off =) -1)
                        )
                        :else                                                ;; single '+'
                        (ยง
                            ((ร @spats[0].sp_off.off =) 1)
                        ))
                        ((ร p =) (ยง p.plus(1)))
                        (while (ยง asc_isdigit(p.at(0)))                        ;; skip number
                            ((ร p =) (ยง p.plus(1)))
                        )
                    )

                    ;; compute length of search command for get_address()
                    ((ร @searchcmdlen +=) (BDIFF p, pat))

                    ((ร pat =) p)                        ;; put "pat" after search command
                )

                (when (and (non-zero? (& options SEARCH_ECHO)) (messaging))
                    (ร Bytes p)
                    (if (eos? searchstr)
                        ((ร p =) (ยง @spats[@last_idx].pat))
                        ((ร p =) searchstr)
                    )

                    ((ร Bytes msgbuf =) (ยง new Bytes(STRLEN(p) + 40)))

                    (.be msgbuf 0, dirc)
                    (cond (utf_iscomposing (us_ptr2char p))
                    (ยง
                        ;; Use a space to draw the composing char on.
                        (ยง msgbuf.be(1, (byte \space)))
                        (STRCPY (.plus msgbuf 2), p)
                    )
                    :else
                    (ยง
                        (STRCPY (.plus msgbuf 1), p)
                    ))

                    (when (or (ยง @spats[0].sp_off.line) (ยง @spats[0].sp_off.end) (!= (ยง @spats[0].sp_off.off) 0))
                        ((ร p =) (ยง msgbuf.plus(STRLEN(msgbuf))))
                        (ยง (p = p.plus(1)).be(-1, dirc))
                        (cond (ยง @spats[0].sp_off.end)
                        (ยง
                            (ยง (p = p.plus(1)).be(-1, (byte \e)))
                        )
                        (not (ยง @spats[0].sp_off.line))
                        (ยง
                            (ยง (p = p.plus(1)).be(-1, (byte \s)))
                        ))
                        (if (or (< 0 (ยง @spats[0].sp_off.off)) (ยง @spats[0].sp_off.line))
                            (ยง (p = p.plus(1)).be(-1, (byte \+)))
                        )
                        (if (or (!= (ยง @spats[0].sp_off.off) 0) (ยง @spats[0].sp_off.line))
                            (ยง libC.sprintf(p, (u8 "%ld"), @spats[0].sp_off.off))
                            (.be p 0, NUL)
                        )
                    )

                    (msg_start)
                    ((ร Bytes trunc =) (msg_strtrunc msgbuf, false))

                    (if (non-nil? trunc)
                        (msg_outtrans trunc)
                        (msg_outtrans msgbuf))
                    (msg_clr_eos)
                    (msg_check)

                    (gotocmdline false)
                    (out_flush)
                    (reset! msg_nowait true)              ;; don't wait for this message
                )

                ;; If there is a character offset, subtract it from the current
                ;; position, so we don't get stuck at "?pat?e+2" or "/pat/s-2".
                ;; Skip this if pos.col is near MAXCOL (closed fold).
                ;; This is not done for a line offset, because then we would not be vi compatible.

                (when (and (not (ยง @spats[0].sp_off.line)) (!= (ยง @spats[0].sp_off.off) 0) (< (. pos col) (- MAXCOL 2)))
                    (cond (< 0 (ยง @spats[0].sp_off.off))
                    (ยง
                        (ร long c)
                        ((ร FOR) (ร (ยง c = @spats[0].sp_off.off) (!= c 0) (ยง --c))
                            (if (== (decl pos) -1)
                                (ร BREAK)
                            )
                        )
                        (when (non-zero? c)                 ;; at start of buffer
                            ((ร pos.lnum =) 0)           ;; allow lnum == 0 here
                            ((ร pos.col =) MAXCOL)
                        )
                    )
                    :else
                    (ยง
                        (ร long c)
                        ((ร FOR) (ร (ยง c = @spats[0].sp_off.off) (!= c 0) (ยง c++))
                            (if (== (incl pos) -1)
                                (ร BREAK)
                            )
                        )
                        (when (non-zero? c)                 ;; at end of buffer
                            ((ร pos.lnum =) (ยง @curbuf.b_ml.ml_line_count + 1))
                            ((ร pos.col =) 0)
                        )
                    ))
                )

                ((ร int i =) (searchit @curwin, @curbuf, pos, (if (== dirc (byte \/)) FORWARD BACKWARD), searchstr, count, (+ (if (ยง @spats[0].sp_off.end) SEARCH_REV 0) (& options (+ SEARCH_KEEP SEARCH_PEEK SEARCH_HIS SEARCH_MSG SEARCH_START (if (and (!= pat null) (== (.at pat 0) (byte \;))) 0 SEARCH_NOOF)))), RE_LAST, 0, nsec))

                (if (non-nil? dircp)
                    (.be dircp 0, dirc)          ;; restore second '/' or '?' for normal_cmd()
                )
                (when (zero? i)
                    ((ร retval =) 0)
                    (ร BREAK end_do_search)
                )
                (if (and (ยง @spats[0].sp_off.end) (non-nil? oap))
                    ((ร oap.inclusive =) true)           ;; 'e' includes last character
                )

                ((ร retval =) 1)                         ;; pattern found

                ;; Add character and/or line offset

                (when (or (zero? (& options SEARCH_NOOF)) (and (non-nil? pat) (== (.at pat 0) (byte \;))))
                    (cond (ยง @spats[0].sp_off.line)       ;; add the offset to the line number
                    (ยง
                        ((ร long c =) (ยง pos.lnum + @spats[0].sp_off.off))
                        (cond (< c 1)
                        (ยง
                            ((ร pos.lnum =) 1)
                        )
                        (< (.. @curbuf b_ml ml_line_count) c)
                        (ยง
                            ((ร pos.lnum =) (.. @curbuf b_ml ml_line_count))
                        )
                        :else
                        (ยง
                            ((ร pos.lnum =) c)
                        ))
                        ((ร pos.col =) 0)

                        ((ร retval =) 2)                 ;; pattern found, line offset added
                    )
                    (< (. pos col) (- MAXCOL 2)) ;; just in case
                    (ยง
                        ((ร long c =) (ยง @spats[0].sp_off.off))
                        (cond (< 0 c)                  ;; to the right, check for end of file
                        (ยง
                            (while (ยง 0 < c--)
                                (if (== (incl pos) -1)
                                    (ร BREAK)
                                )
                            )
                        )
                        :else                        ;; to the left, check for start of file
                        (ยง
                            (while (ยง c++ < 0)
                                (if (== (decl pos) -1)
                                    (ร BREAK)
                                )
                            )
                        ))
                    ))
                )

                ;; The search command can be followed by a ';' to do another search.
                ;; For example: "/pat/;/foo/+3;?bar"
                ;; This is like doing another search command, except:
                ;; - The remembered direction '/' or '?' is from the first search.
                ;; - When an error happens the cursor isn't moved at all.
                ;; Don't do this when called by get_address() (it handles ';' itself).

                (if (or (zero? (& options SEARCH_OPT)) (nil? pat) (!= (.at pat 0) (byte \;)))
                    (ร BREAK)
                )

                ((ร dirc =) (ยง (pat = pat.plus(1)).at(0)))
                (when (and (!= dirc (byte \?)) (!= dirc (byte \/)))
                    ((ร retval =) 0)
                    (emsg (u8 "E386: Expected '?' or '/'  after ';'"))
                    (ร BREAK end_do_search)
                )
                ((ร pat =) (ยง pat.plus(1)))
            )

            (if (non-zero? (& options SEARCH_MARK))
                (setpcmark))
            (COPY_pos (. @curwin w_cursor), pos)
            ((ร @curwin.w_set_curswant =) true)
;       }

        (if (non-zero? (& options SEARCH_KEEP))
            (COPY_soffset (ยง @spats[0].sp_off), old_off))

        retval
    ))

;; Character Searches

(atom! int sc__lastc NUL)         ;; last character searched for
(atom! int sc__lastcdir)            ;; last direction of character search
(atom! boolean sc__last_t_cmd)      ;; last search t_cmd

(final Bytes sc__bytes (Bytes. (inc MB_MAXBYTES)))
(atom! int sc__bytelen 1)         ;; >1 for multi-byte char

;; Search for a character in a line.  If "t_cmd" is false, move to the
;; position of the character, otherwise move to just before the char.
;; Do this "cap.count1" times.
;; Return false or true.

(defn- #_boolean searchc [#_cmdarg_C cap, #_boolean t_cmd]
    (ยง
        ((ร int c =) @(. cap nchar))                      ;; char to search for
        ((ร int dir =) (. cap arg))                      ;; true for searching forward
        ((ร long count =) (. cap count1))                ;; repeat count

        ((ร boolean stop =) true)

        (cond (!= c NUL)                           ;; normal search: remember args for repeat
        (ยง
            (when (not @keyStuffed)                    ;; don't remember when redoing
                (reset! sc__lastc c)
                (reset! sc__lastcdir dir)
                (reset! sc__last_t_cmd t_cmd)
                (reset! sc__bytelen (utf_char2bytes c, sc__bytes))
                (when (!= (. cap ncharC1) 0)
                    ((ร @sc__bytelen +=) (ยง utf_char2bytes(cap.ncharC1, sc__bytes.plus(@sc__bytelen))))
                    (if (!= (. cap ncharC2) 0)
                        ((ร @sc__bytelen +=) (ยง utf_char2bytes(cap.ncharC2, sc__bytes.plus(@sc__bytelen))))
                    )
                )
            )
        )
        :else                                    ;; repeat previous search
        (ยง
            (if (== @sc__lastc NUL)
                ((ร RETURN) false)
            )
            (if (non-zero? dir)                       ;; repeat in opposite direction
                ((ร dir =) (ยง -@sc__lastcdir))
                ((ร dir =) @sc__lastcdir)
            )
            ((ร t_cmd =) @sc__last_t_cmd)
            ((ร c =) @sc__lastc)

            ;; For multi-byte re-use last sc__bytes[] and sc__bytelen.

            ;; Force a move of at least one char, so ";" and "," will move the cursor,
            ;; even if the cursor is right in front of char we are looking at.
            (if (and (nil? (vim_strbyte @p_cpo, CPO_SCOLON)) (== count 1) t_cmd)
                ((ร stop =) false)
            )
        ))

        (if (== dir BACKWARD)
            ((ร cap.oap.inclusive =) false)
            ((ร cap.oap.inclusive =) true)
        )

        ((ร Bytes p =) (ml_get_curline))
        ((ร int col =) (.. @curwin w_cursor col))
        ((ร int len =) (STRLEN p))

        (while (ยง 0 < count--)
            (while true
                (cond (< 0 dir)
                (ยง
                    ((ร col +=) (ยง us_ptr2len_cc(p.plus(col))))
                    (if (<= len col)
                        ((ร RETURN) false)
                    )
                )
                :else
                (ยง
                    (if (zero? col)
                        ((ร RETURN) false)
                    )
                    ((ร col -=) (ยง us_head_off(p, p.plus(col - 1)) + 1))
                ))
                (cond (== @sc__bytelen 1)
                (ยง
                    (if (and (== (.at p col) c) stop)
                        (ร BREAK)
                    )
                )
                :else
                (ยง
                    (if (and (zero? (ยง MEMCMP(p.plus(col), sc__bytes, @sc__bytelen))) stop)
                        (ร BREAK)
                    )
                ))
                ((ร stop =) true)
            )
        )

        (when t_cmd
            ;; backup to before the character (possibly double-byte)
            ((ร col -=) dir)

            (cond (< dir 0)
            (ยง
                ;; Landed on the search char which is sc__bytelen long.
                ((ร col +=) (- @sc__bytelen 1))
            )
            :else
            (ยง
                ;; To previous char, which may be multi-byte.
                ((ร col -=) (ยง us_head_off(p, p.plus(col))))
            ))
        )
        ((ร @curwin.w_cursor.col =) col)

        true
    ))

;; "Other" Searches

;; findmatch - find the matching paren or brace
;;
;; Improvement over vi: Braces inside quotes are ignored.

(defn- #_pos_C findmatch [#_oparg_C oap, #_int initc]
    (findmatchlimit oap, initc, 0, 0))

;; Return true if the character before "linep[col]" equals "ch".
;; Return false if "col" is zero.
;; Update "*prevcol" to the column of the previous character, unless "prevcol" is null.
;; Handles multibyte string correctly.

(defn- #_boolean check_prevcol [#_Bytes linep, #_int col, #_int ch, #_int* prevcol]
    (ยง
        (ยง --col)
        (if (< 0 col)
            ((ร col -=) (ยง us_head_off(linep, linep.plus(col))))
        )
        (if (non-nil? prevcol)
            ((ร prevcol[0] =) col)
        )
        (and (<= 0 col) (== (.at linep col) ch))
    ))

(atom! pos_C _2_pos (ยง_pos_C)) ;; current search position

;; findmatchlimit -- find the matching paren or brace, if it exists within
;; maxtravel lines of here.  A maxtravel of 0 means search until falling off
;; the edge of the file.
;;
;; "initc" is the character to find a match for.  NUL means to find the
;; character at or after the cursor.
;;
;; flags: FM_BACKWARD   search backwards (when initc is '/', '*' or '#')
;;        FM_FORWARD    search forwards (when initc is '/', '*' or '#')
;;        FM_BLOCKSTOP  stop at start/end of block ({ or } in column 0)
;;
;; "oap" is only used to set oap.motion_type for a linewise motion, it be null

(defn- #_pos_C findmatchlimit [#_oparg_C oap, #_int _initc, #_int flags, #_int maxtravel]
    (ยง
; %%    ((ร int[] initc =) (ยง { _initc }))
; %%    ((ร int[] findc =) (ยง { 0 }))                    ;; matching brace
        ((ร int count =) 0)                          ;; cumulative number of braces
; %%    ((ร boolean[] backwards =) (ยง { false }))
        ((ร boolean inquote =) false)                ;; true when inside quotes
        ((ร int hash_dir =) 0)                       ;; Direction searched for # things
        ((ร int comment_dir =) 0)                    ;; Direction searched for comments
        ((ร int traveled =) 0)                       ;; how far we've searched so far
        ((ร boolean ignore_cend =) false)            ;; ignore comment end
        ((ร int match_escaped =) 0)                  ;; search for escaped match
        ((ร int comment_col =) MAXCOL)               ;; start of / / comment

        (COPY_pos @_2_pos, (. @curwin w_cursor))
        ((ร @_2_pos.coladd =) 0)
        ((ร Bytes linep =) (ยง ml_get(@_2_pos.lnum))) ;; pointer to current line

        ((ร boolean cpo_match =) (ยง (vim_strbyte(@p_cpo, CPO_MATCH) != null)))    ;; vi compatible matching
        ((ร boolean cpo_bsl =) (ยง (vim_strbyte(@p_cpo, CPO_MATCHBSL) != null)))   ;; don't recognize backslashes

        ;; Direction to search when initc is '/', '*' or '#'.
        (ร int dir)
        (cond (non-zero? (& flags FM_BACKWARD))
        (ยง
            ((ร dir =) BACKWARD)
        )
        (non-zero? (& flags FM_FORWARD))
        (ยง
            ((ร dir =) FORWARD)
        )
        :else
        (ยง
            ((ร dir =) 0)
        ))

        ;; if initc given, look in the table for the matching character
        ;; '/' and '*' are special cases: look for start or end of comment.
        ;; When '/' is used, we ignore running backwards into an star-slash,
        ;; for "[*" command, we just want to find any comment.

        (cond (or (== (ยง initc[0]) (byte \/)) (== (ยง initc[0]) (byte \*)))
        (ยง
            ((ร comment_dir =) dir)
            (if (== (ยง initc[0]) (byte \/))
                ((ร ignore_cend =) true)
            )
            ((ร backwards[0] =) (ยง (dir != FORWARD)))
            ((ร initc[0] =) NUL)
        )
        (and (!= (ยง initc[0]) (byte \#)) (!= (ยง initc[0]) NUL))
        (ยง
            (find_mps_values initc, findc, backwards, true)
            (if (== (ยง findc[0]) NUL)
                ((ร RETURN) null)
            )
        )
        :else ;; Either initc is '#', or no initc was given and we need to look under the cursor.
        (ยง
            (cond (== (ยง initc[0]) (byte \#))
            (ยง
                ((ร hash_dir =) dir)
            )
            :else
            (ยง
                ;; initc was not given, must look for something to match under or near the cursor.
                ;; Only check for special things when 'cpo' doesn't have '%'.

                (when (not cpo_match)
                    ;; Are we before or at #if, #else etc.?
                    ((ร Bytes p =) (skipwhite linep))
                    (cond (and (== (.at p 0) (byte \#)) (<= (. @_2_pos col) (BDIFF p, linep)))
                    (ยง
                        ((ร p =) (ยง skipwhite(p.plus(1))))
                        (if (or (zero? (STRNCMP p, (u8 "if"), 2)) (zero? (STRNCMP p, (u8 "endif"), 5)) (zero? (STRNCMP p, (u8 "el"), 2)))
                            ((ร hash_dir =) 1)
                        )
                    )
                    ;; Are we on a comment?
                    (== (.at linep (. @_2_pos col)) (byte \/))
                    (ยง
                        (cond (== (.at linep (+ (. @_2_pos col) 1)) (byte \*))
                        (ยง
                            ((ร comment_dir =) FORWARD)
                            ((ร backwards[0] =) false)
                            (ยง @_2_pos.col++)
                        )
                        (and (< 0 (. @_2_pos col)) (== (.at linep (- (. @_2_pos col) 1)) (byte \*)))
                        (ยง
                            ((ร comment_dir =) BACKWARD)
                            ((ร backwards[0] =) true)
                            (ยง @_2_pos.col--)
                        ))
                    )
                    (== (.at linep (. @_2_pos col)) (byte \*))
                    (ยง
                        (cond (== (.at linep (+ (. @_2_pos col) 1)) (byte \/))
                        (ยง
                            ((ร comment_dir =) BACKWARD)
                            ((ร backwards[0] =) true)
                        )
                        (and (< 0 (. @_2_pos col)) (== (.at linep (- (. @_2_pos col) 1)) (byte \/)))
                        (ยง
                            ((ร comment_dir =) FORWARD)
                            ((ร backwards[0] =) false)
                        ))
                    ))
                )

                ;; If we are not on a comment or the # at the start of a line,
                ;; then look for brace anywhere on this line after the cursor.

                (when (and (zero? hash_dir) (zero? comment_dir))
                    ;; Find the brace under or after the cursor.
                    ;; If beyond the end of the line, use the last character in the line.

                    (if (and (== (.at linep (. @_2_pos col)) NUL) (!= (. @_2_pos col) 0))
                        (ยง --@_2_pos.col)
                    )
                    (while true
                        ((ร initc[0] =) (ยง us_ptr2char(linep.plus(@_2_pos.col))))
                        (if (== (ยง initc[0]) NUL)
                            (ร BREAK)
                        )

                        (find_mps_values initc, findc, backwards, false)
                        (if (!= (ยง findc[0]) NUL)
                            (ร BREAK)
                        )
                        ((ร @_2_pos.col +=) (ยง us_ptr2len_cc(linep.plus(@_2_pos.col))))
                    )
                    (cond (== (ยง findc[0]) NUL)
                    (ยง
                        ;; no brace in the line, maybe use "  #if" then
                        (if (and (not cpo_match) (== (.at (skipwhite linep) 0) (byte \#)))
                            ((ร hash_dir =) 1)
                            ((ร RETURN) null)
                        )
                    )
                    (not cpo_bsl)
                    (ยง
                        ((ร int bslcnt =) 0)

                        ;; Set "match_escaped" if there are an odd number of backslashes.
; %%                    ((ร FOR) (ร (ยง int[] col = { @_2_pos.col }) (ยง check_prevcol(linep, col[0], (byte \\), col)) nil)
                            (ยง bslcnt++)
; %%                    )
                        ((ร match_escaped =) (ยง (bslcnt & 1)))
                    ))
                )
            ))

            (when (non-zero? hash_dir)
                ;; Look for matching #if, #else, #elif, or #endif

                (if (non-nil? oap)
                    ((ร oap.motion_type =) MLINE)    ;; linewise for this case only
                )
                (when (!= (ยง initc[0]) (byte \#))
                    ((ร Bytes p =) (ยง skipwhite(skipwhite(linep).plus(1))))
                    (cond (or (zero? (STRNCMP p, (u8 "if"), 2)) (zero? (STRNCMP p, (u8 "el"), 2)))
                    (ยง
                        ((ร hash_dir =) 1)
                    )
                    (zero? (STRNCMP p, (u8 "endif"), 5))
                    (ยง
                        ((ร hash_dir =) -1)
                    )
                    :else
                    (ยง
                        ((ร RETURN) null)
                    ))
                )
                ((ร @_2_pos.col =) 0)
                (while (ยง !@got_int)
                    (cond (< 0 hash_dir)
                    (ยง
                        (if (== (. @_2_pos lnum) (.. @curbuf b_ml ml_line_count))
                            (ร BREAK)
                        )
                    )
                    (== (. @_2_pos lnum) 1)
                    (ยง
                        (ร BREAK)
                    ))
                    ((ร @_2_pos.lnum +=) hash_dir)
                    ((ร linep =) (ยง ml_get(@_2_pos.lnum)))
                    (line_breakcheck)          ;; check for CTRL-C typed
                    ((ร Bytes p =) (skipwhite linep))
                    (if (!= (.at p 0) (byte \#))
                        (ร CONTINUE)
                    )
                    ((ร @_2_pos.col =) (BDIFF p, linep))
                    ((ร p =) (ยง skipwhite(p.plus(1))))
                    (cond (< 0 hash_dir)
                    (ยง
                        (cond (zero? (STRNCMP p, (u8 "if"), 2))
                        (ยง
                            (ยง count++)
                        )
                        (zero? (STRNCMP p, (u8 "el"), 2))
                        (ยง
                            (if (zero? count)
                                ((ร RETURN) @_2_pos)
                            )
                        )
                        (zero? (STRNCMP p, (u8 "endif"), 5))
                        (ยง
                            (if (zero? count)
                                ((ร RETURN) @_2_pos)
                            )
                            (ยง count--)
                        ))
                    )
                    :else
                    (ยง
                        (cond (zero? (STRNCMP p, (u8 "if"), 2))
                        (ยง
                            (if (zero? count)
                                ((ร RETURN) @_2_pos)
                            )
                            (ยง count--)
                        )
                        (and (== (ยง initc[0]) (byte \#)) (zero? (STRNCMP p, (u8 "el"), 2)))
                        (ยง
                            (if (zero? count)
                                ((ร RETURN) @_2_pos)
                            )
                        )
                        (zero? (STRNCMP p, (u8 "endif"), 5))
                        (ยง
                            (ยง count++)
                        ))
                    ))
                )
                ((ร RETURN) null)
            )
        ))

        ((ร int do_quotes =) -1)                 ;; check for quotes in current line
        ((ร maybean start_in_quotes =) MAYBE)    ;; start position is in quotes
        ((ร pos_C match_pos =) (ยง ยง_pos_C()))      ;; where last slash-star was found

        ;; backward search: Check if this line contains a single-line comment
        (if (and (ยง backwards[0]) (non-zero? comment_dir))
            ((ร comment_col =) (check_linecomment linep))
        )

        (while (ยง !@got_int)
            ;; Go to the next position, forward or backward.
            ;; We could use incp() and decp() here, but that is much slower.

            (cond (ยง backwards[0])
            (ยง
                (cond (zero? (. @_2_pos col))                    ;; at start of line, go to prev. one
                (ยง
                    (if (== (. @_2_pos lnum) 1)               ;; start of file
                        (ร BREAK)
                    )
                    (ยง --@_2_pos.lnum)

                    (if (and (< 0 maxtravel) (< maxtravel (ยง ++traveled)))
                        (ร BREAK)
                    )

                    ((ร linep =) (ยง ml_get(@_2_pos.lnum)))
                    ((ร @_2_pos.col =) (STRLEN linep))    ;; _2_pos.col on trailing NUL
                    ((ร do_quotes =) -1)
                    (line_breakcheck)

                    ;; Check if this line contains a single-line comment.
                    (if (non-zero? comment_dir)
                        ((ร comment_col =) (check_linecomment linep))
                    )
                )
                :else
                (ยง
                    (ยง --@_2_pos.col)
                    ((ร @_2_pos.col -=) (ยง us_head_off(linep, linep.plus(@_2_pos.col))))
                ))
            )
            :else                            ;; forward search
            (ยง
                (cond (== (.at linep (. @_2_pos col)) NUL)
                (ยง
                    (if (== (. @_2_pos lnum) (.. @curbuf b_ml ml_line_count))    ;; end of file
                        (ร BREAK)
                    )
                    (ยง @_2_pos.lnum++)

                    (if (and (non-zero? maxtravel) (< maxtravel (ยง traveled++)))
                        (ร BREAK)
                    )

                    ((ร linep =) (ยง ml_get(@_2_pos.lnum)))
                    ((ร @_2_pos.col =) 0)
                    ((ร do_quotes =) -1)
                    (line_breakcheck)
                )
                :else
                (ยง
                    ((ร @_2_pos.col +=) (ยง us_ptr2len_cc(linep.plus(@_2_pos.col))))
                ))
            ))

            ;; If FM_BLOCKSTOP given, stop at a '{' or '}' in column 0.

            (when (and (zero? (. @_2_pos col)) (non-zero? (& flags FM_BLOCKSTOP)) (or (== (.at linep 0) (byte \{)) (== (.at linep 0) (byte \}))))
                (if (and (== (.at linep 0) (ยง findc[0])) (zero? count))        ;; match!
                    ((ร RETURN) @_2_pos)
                )
                (ร BREAK)                                      ;; out of scope
            )

            (when (non-zero? comment_dir)
                ;; Note: comments do not nest, and we ignore quotes in them.
                ;; TODO: ignore comment brackets inside strings.
                (cond (== comment_dir FORWARD)
                (ยง
                    (when (and (== (.at linep (. @_2_pos col)) (byte \*)) (== (.at linep (+ (. @_2_pos col) 1)) (byte \/)))
                        (ยง @_2_pos.col++)
                        ((ร RETURN) @_2_pos)
                    )
                )
                :else    ;; searching backwards
                (ยง
                    ;; A comment may contain / * or / /, it may also start or end
                    ;; with / * /.  Ignore a / * after / /.

                    (cond (zero? (. @_2_pos col))
                    (ยง
                        (ร CONTINUE)
                    )
                    (and (== (.at linep (- (. @_2_pos col) 1)) (byte \/)) (== (.at linep (. @_2_pos col)) (byte \*)) (< (. @_2_pos col) comment_col))
                    (ยง
                        (ยง count++)
                        (COPY_pos match_pos, @_2_pos)
                        (ยง match_pos.col--)
                    )
                    (and (== (.at linep (- (. @_2_pos col) 1)) (byte \*)) (== (.at linep (. @_2_pos col)) (byte \/)))
                    (ยง
                        (cond (< 0 count)
                        (ยง
                            (COPY_pos @_2_pos, match_pos)
                        )
                        (and (< 1 (. @_2_pos col)) (== (.at linep (- (. @_2_pos col) 2)) (byte \/)) (<= (. @_2_pos col) comment_col))
                        (ยง
                            ((ร @_2_pos.col -=) 2)
                        )
                        ignore_cend
                        (ยง
                            (ร CONTINUE)
                        )
                        :else
                        (ยง
                            ((ร RETURN) null)
                        ))

                        ((ร RETURN) @_2_pos)
                    ))
                ))
                (ร CONTINUE)
            )

            ;; If smart matching ('cpoptions' does not contain '%'), braces inside
            ;; of quotes are ignored, but only if there is an even number of
            ;; quotes in the line.

            (cond cpo_match
            (ยง
                ((ร do_quotes =) 0)
            )
            (== do_quotes -1)
            (ยง
                ;; Count the number of quotes in the line, skipping \" and '"'.
                ;; Watch out for "\\".

                ((ร int @at_start =) do_quotes)       ;; do_quotes value at start position
                (ร Bytes p)
                ((ร FOR) (ร (ยง p = linep) (ยง p.at(0) != NUL) (ยง p = p.plus(1)))
                    (if (BEQ p, (.plus linep (+ (. @_2_pos col) (if (ยง backwards[0]) 1 0))))
                        (reset! at_start (& do_quotes 1)))
                    (if (and (== (.at p 0) (byte \")) (or (BEQ p, linep) (!= (.at p -1) (byte \')) (!= (.at p 1) (byte \'))))   ;; """
                        (ยง do_quotes++)
                    )
                    (if (and (== (.at p 0) (byte \\)) (non-eos? p 1))
                        ((ร p =) (ยง p.plus(1)))
                    )
                )
                ((ร do_quotes &=) 1)                 ;; result is 1 with even number of quotes

                ;; If we find an uneven count, check current line and previous one for a '\' at the end.

                (when (zero? do_quotes)
                    ((ร inquote =) false)
                    (when (== (.at p -1) (byte \\))
                        ((ร do_quotes =) 1)
                        (cond (== start_in_quotes MAYBE)
                        (ยง
                            ;; Do we need to use at_start here?
                            ((ร inquote =) true)
                            ((ร start_in_quotes =) TRUE)
                        )
                        (ยง backwards[0])
                        (ยง
                            ((ร inquote =) true)
                        ))
                    )
                    (when (< 1 (. @_2_pos lnum))
                        ((ร p =) (ยง ml_get(@_2_pos.lnum - 1)))
                        (when (and (non-eos? p) (== (ยง p.at(STRLEN(p) - 1)) (byte \\)))
                            ((ร do_quotes =) 1)
                            (cond (== start_in_quotes MAYBE)
                            (ยง
                                ((ร inquote =) (ยง (@at_start != 0)))
                                (if inquote
                                    ((ร start_in_quotes =) TRUE)
                                )
                            )
                            (not (ยง backwards[0]))
                            (ยง
                                ((ร inquote =) true)
                            ))
                        )

                        ;; ml_get() only keeps one line, need to get "linep" again
                        ((ร linep =) (ยง ml_get(@_2_pos.lnum)))
                    )
                )
            ))
            (when (== start_in_quotes MAYBE)
                ((ร start_in_quotes =) FALSE)
            )

            ;; If 'smartmatch' is set:
            ;;   Things inside quotes are ignored by setting 'inquote'.
            ;;   If we find a quote without a preceding '\' invert 'inquote'.
            ;;   At the end of a line not ending in '\' we reset 'inquote'.
            ;;
            ;;   In lines with an uneven number of quotes (without preceding '\')
            ;;   we do not know which part to ignore.  Therefore we only set
            ;;   inquote if the number of quotes in a line is even, unless this
            ;;   line or the previous one ends in a '\'.  Complicated, isn't it?

            ((ร int c =) (ยง us_ptr2char(linep.plus(@_2_pos.col))))
            ((ร SWITCH) c
                ((ร CASE) NUL)
                (ยง
                    ;; at end of line without trailing backslash, reset inquote
                    (when (or (zero? (. @_2_pos col)) (!= (.at linep (- (. @_2_pos col) 1)) (byte \\)))
                        ((ร inquote =) false)
                        ((ร start_in_quotes =) FALSE)
                    )
                    (ร BREAK)
                )

                ((ร CASE) (byte \"))  ;; """
                (ยง
                    ;; a quote that is preceded with an odd number of backslashes is ignored
                    (when (non-zero? do_quotes)
                        (ร int col)

                        ((ร FOR) (ร (ยง col = @_2_pos.col - 1) (<= 0 col) (ยง --col))
                            (if (!= (.at linep col) (byte \\))
                                (ร BREAK)
                            )
                        )
                        (when (zero? (ยง (@_2_pos.col - 1 - col) & 1))
                            ((ร inquote =) (ยง !inquote))
                            ((ร start_in_quotes =) FALSE)
                        )
                    )
                    (ร BREAK)
                )

                ;; If smart matching ('cpoptions' does not contain '%'):
                ;;   Skip things in single quotes: 'x' or '\x'.  Be careful for single
                ;;   single quotes, e.g. jon's.  Things like '\233' or '\x3f' are not
                ;;   skipped, there is never a brace in them.
                ;;   Ignore this when finding matches for `'.

                ((ร CASE) (byte \'))
                (ยง
                    (when (and (not cpo_match) (!= (ยง initc[0]) (byte \')) (!= (ยง findc[0]) (byte \')))
                        (cond (ยง backwards[0])
                        (ยง
                            (when (< 1 (. @_2_pos col))
                                (cond (== (.at linep (- (. @_2_pos col) 2)) (byte \'))
                                (ยง
                                    ((ร @_2_pos.col -=) 2)
                                    (ร BREAK)
                                )
                                (and (== (.at linep (- (. @_2_pos col) 2)) (byte \\)) (< 2 (. @_2_pos col)) (== (.at linep (- (. @_2_pos col) 3)) (byte \')))
                                (ยง
                                    ((ร @_2_pos.col -=) 3)
                                    (ร BREAK)
                                ))
                            )
                        )
                        (ยง linep.at(@_2_pos.col + 1) != NUL) ;; forward search
                        (ยง
                            (cond (and (== (.at linep (+ (. @_2_pos col) 1)) (byte \\)) (ยง linep.at(@_2_pos.col + 2) != NUL) (== (.at linep (+ (. @_2_pos col) 3)) (byte \')))
                            (ยง
                                ((ร @_2_pos.col +=) 3)
                                (ร BREAK)
                            )
                            (== (.at linep (+ (. @_2_pos col) 2)) (byte \'))
                            (ยง
                                ((ร @_2_pos.col +=) 2)
                                (ร BREAK)
                            ))
                        ))
                    )
                    (ร FALLTHROUGH)
                )

                (ร DEFAULT)
                (ยง
                    ;; Check for match outside of quotes, and inside of
                    ;; quotes when the start is also inside of quotes.

                    (when (and (or (not inquote) (== start_in_quotes TRUE)) (or (== c (ยง initc[0])) (== c (ยง findc[0]))))
                        ((ร int bslcnt =) 0)

                        (when (not cpo_bsl)
; %%                        ((ร FOR) (ร (ยง int[] col = { @_2_pos.col }) (ยง check_prevcol(linep, col[0], (byte \\), col)) nil)
                                (ยง bslcnt++)
; %%                        )
                        )
                        ;; Only accept a match when 'M' is in 'cpo'
                        ;; or when escaping is what we expect.
                        (when (or cpo_bsl (ยง (bslcnt & 1) == match_escaped))
                            (cond (== c (ยง initc[0]))
                            (ยง
                                (ยง count++)
                            )
                            :else
                            (ยง
                                (if (zero? count)
                                    ((ร RETURN) @_2_pos)
                                )
                                (ยง count--)
                            ))
                        )
                    )
                    (ร BREAK)
                )
            )
        )

        (when (and (== comment_dir BACKWARD) (< 0 count))
            (COPY_pos @_2_pos, match_pos)
            ((ร RETURN) @_2_pos)
        )

        null    ;; never found it
    ))

;; Check if line[] contains a / / comment.
;; Return MAXCOL if not, otherwise return the column.
;; TODO: skip strings.

(defn- #_int check_linecomment [#_Bytes line]
    (ยง
        ((ร Bytes p =) line)

        (while (ยง (p = vim_strchr(p, (byte \/))) != null)
            ;; Accept a double /, unless it's preceded with * and followed by *,
            ;; because * / / * is an end and start of a C comment.
            (if (and (== (.at p 1) (byte \/)) (or (BEQ p, line) (!= (.at p -1) (byte \*)) (!= (.at p 2) (byte \*))))
                (ร BREAK)
            )
            ((ร p =) (ยง p.plus(1)))
        )

        (if (nil? p)
            ((ร RETURN) MAXCOL)
        )

        (BDIFF p, line)
    ))

;; Move cursor briefly to character matching the one under the cursor.
;; Used for Insert mode and "r" command.
;; Show the match only if it is visible on the screen.
;; If there isn't a match, then beep.

(defn- #_void showmatch [#_int c]
    ;; c: char to show match for
    (ยง
        ;; Only show match for chars in the 'matchpairs' option.

        ;; 'matchpairs' is "x:y,x:y"
        ((ร FOR) (ร (ยง Bytes p = @curbuf.@b_p_mps) (ยง p.at(0) != NUL) (ยง p = p.plus(1)))
            ((ร p =) (ยง p.plus(us_ptr2len_cc(p) + 1)))
            (if (== (us_ptr2char p) c)
                (ร BREAK)
            )
            ((ร p =) (ยง p.plus(us_ptr2len_cc(p))))
            (if (eos? p)
                (ร RETURN)
            )
        )

        ((ร pos_C lpos =) (findmatch null, NUL))
        (cond (nil? lpos)                   ;; no match, so beep
        (ยง
            (vim_beep)
        )
        (and (<= (. @curwin w_topline) (. lpos lnum)) (< (. lpos lnum) (. @curwin w_botline)))
        (ยง
            ((ร int[] vcol =) (ยง new int[1]))
            (if (not @(.. @curwin w_options wo_wrap))
                (getvcol @curwin, lpos, null, vcol, null))
            (when (or @(.. @curwin w_options wo_wrap) (and (<= (. @curwin w_leftcol) (ยง vcol[0])) (< (ยง vcol[0]) (+ (. @curwin w_leftcol) (. @curwin w_width)))))
                ((ร pos_C save_cursor =) (ยง ยง_pos_C()))
                ((ร pos_C mpos =) (ยง ยง_pos_C()))

                (COPY_pos mpos, lpos)               ;; save the pos, update_screen() may change it
                (COPY_pos save_cursor, (. @curwin w_cursor))
                ((ร long save_so =) @p_so)
                ((ร long save_siso =) @p_siso)
                (ยง @curwin.w_virtcol++)                 ;; do display ')' just before "$"
                (update_screen VALID)               ;; show the new char first

                ((ร int save_state =) @State)
                (reset! State SHOWMATCH)
                (ui_cursor_shape)                  ;; may show different cursor shape
                (COPY_pos (. @curwin w_cursor), mpos)    ;; move to matching char
                (reset! p_so 0)                        ;; don't use 'scrolloff' here
                (reset! p_siso 0)                      ;; don't use 'sidescrolloff' here
                (showruler false)
                (setcursor)
                (cursor_on)                        ;; make sure that the cursor is shown
                (out_flush)

                ;; brief pause, unless 'm' is present in 'cpo' and a character is available

                (cond (non-nil? (vim_strbyte @p_cpo, CPO_SHOWMATCH))
                (ยง
                    (ui_delay (* @p_mat 100), true)
                )
                (not (char_avail))
                (ยง
                    (ui_delay (* @p_mat 100), false)
                ))

                (COPY_pos (. @curwin w_cursor), save_cursor) ;; restore cursor position
                (reset! p_so save_so)
                (reset! p_siso save_siso)
                (reset! State save_state)
                (ui_cursor_shape)          ;; may show different cursor shape
            )
        ))
    ))

;; The following routines do the word searches performed
;; by the 'w', 'W', 'b', 'B', 'e', and 'E' commands.

;; To perform these searches, characters are placed into one of three
;; classes, and transitions between classes determine word boundaries.
;;
;; The classes are:
;;
;; 0 - white space
;; 1 - punctuation
;; 2 or higher - keyword characters (letters, digits and underscore)

(atom! boolean cls_bigword)     ;; true for "W", "B" or "E"

;; cls() - returns the class of character at curwin.w_cursor
;;
;; If a 'W', 'B', or 'E' motion is being done (cls_bigword == true),
;; chars from class 2 and higher are reported as class 1 since only
;; white space boundaries are of interest.

(defn- #_int cls []
    (ยง
        ((ร int c =) (gchar_cursor))
        (if (or (== c (byte \space)) (== c (byte \tab)) (== c NUL))
            ((ร RETURN) 0)
        )

        ((ร c =) (utf_class c))
        (if (and (non-zero? c) @cls_bigword)
            ((ร RETURN) 1)
        )

        c
    ))

;; fwd_word(count, type, eol) - move forward one word
;;
;; Returns false if the cursor was already at the end of the file.
;; If eol is true, last word stops at end of line (for operators).

(defn- #_boolean fwd_word [#_long count, #_boolean bigword, #_boolean eol]
    ;; bigword: "W", "E" or "B"
    (ยง
        ((ร @curwin.w_cursor.coladd =) 0)
        (reset! cls_bigword bigword)

        (while (ยง 0 < count--)
            ((ร int sclass =) (cls))         ;; starting class

            ;; We always move at least one character,
            ;; unless on the last character in the buffer.

            ((ร boolean last_line =) (ยง (@curwin.w_cursor.lnum == @curbuf.b_ml.ml_line_count)))
            ((ร int i =) (inc_cursor))
            (if (or (== i -1) (and (<= 1 i) last_line))   ;; started at last char in file
                ((ร RETURN) false)
            )
            (if (and (<= 1 i) eol (zero? count))        ;; started at last char in line
                ((ร RETURN) true)
            )

            ;; Go one char past end of current word (if any).

            (when (non-zero? sclass)
                (while (ยง cls() == sclass)
                    ((ร i =) (inc_cursor))
                    (if (or (== i -1) (and (<= 1 i) eol (zero? count)))
                        ((ร RETURN) true)
                    )
                )
            )

            ;; go to next non-white

            (while (ยง cls() == 0)
                ;; We'll stop if we land on a blank line

                (if (and (zero? (.. @curwin w_cursor col)) (== (.at (ml_get_curline) 0) NUL))
                    (ร BREAK)
                )

                ((ร i =) (inc_cursor))
                (if (or (== i -1) (and (<= 1 i) eol (zero? count)))
                    ((ร RETURN) true)
                )
            )
        )

        true
    ))

;; bck_word() - move backward 'count' words
;;
;; If stop is true and we are already on the start of a word, move one less.
;;
;; Returns false if top of the file was reached.

(defn- #_boolean bck_word [#_long count, #_boolean bigword, #_boolean stop]
    (ยง
        ((ร @curwin.w_cursor.coladd =) 0)
        (reset! cls_bigword bigword)

        (while (ยง 0 < count--)
            ((ร int sclass =) (cls))             ;; starting class

            (if (== (dec_cursor) -1)         ;; started at start of file
                ((ร RETURN) false)
            )

;           finished:
;           {
                (when (or (not stop) (== sclass (cls)) (zero? sclass))
                    ;; Skip white space before the word.
                    ;; Stop on an empty line.

                    (while (ยง cls() == 0)
                        (if (and (zero? (.. @curwin w_cursor col)) (lineempty (.. @curwin w_cursor lnum)))
                            (ร BREAK finished)
                        )
                        (if (== (dec_cursor) -1) ;; hit start of file, stop here
                            ((ร RETURN) true)
                        )
                    )

                    ;; Move backward to start of this word.

                    (if (skip_chars (cls), BACKWARD)
                        ((ร RETURN) true)
                    )
                )

                (inc_cursor)                   ;; overshot - forward one
;           }

            ((ร stop =) false)
        )

        true
    ))

;; end_word() - move to the end of the word
;;
;; There is an apparent bug in the 'e' motion of the real vi.  At least on the
;; System V Release 3 version for the 80386.  Unlike 'b' and 'w', the 'e'
;; motion crosses blank lines.  When the real vi crosses a blank line in an
;; 'e' motion, the cursor is placed on the FIRST character of the next
;; non-blank line. The 'E' command, however, works correctly.  Since this
;; appears to be a bug, I have not duplicated it here.
;;
;; Returns false if end of the file was reached.
;;
;; If stop is true and we are already on the end of a word, move one less.
;; If empty is true stop on an empty line.

(defn- #_boolean end_word [#_long count, #_boolean bigword, #_boolean stop, #_boolean empty]
    (ยง
        ((ร @curwin.w_cursor.coladd =) 0)
        (reset! cls_bigword bigword)

        (while (ยง 0 < count--)
            ((ร int sclass =) (cls))         ;; starting class

            (if (== (inc_cursor) -1)
                ((ร RETURN) false)
            )

;           finished:
;           {
                ;; If we're in the middle of a word, we just have to move to the end of it.

                (cond (and (== (cls) sclass) (non-zero? sclass))
                (ยง
                    ;; Move forward to end of the current word

                    (if (skip_chars sclass, FORWARD)
                        ((ร RETURN) false)
                    )
                )
                (or (not stop) (zero? sclass))
                (ยง
                    ;; We were at the end of a word.  Go to the end of the next word.
                    ;; First skip white space, if 'empty' is true, stop at empty line.

                    (while (ยง cls() == 0)
                        (if (and empty (zero? (.. @curwin w_cursor col)) (lineempty (.. @curwin w_cursor lnum)))
                            (ร BREAK finished)
                        )
                        (if (== (inc_cursor) -1)     ;; hit end of file, stop here
                            ((ร RETURN) false)
                        )
                    )

                    ;; Move forward to the end of this word.

                    (if (skip_chars (cls), FORWARD)
                        ((ร RETURN) false)
                    )
                ))
                (dec_cursor)                   ;; overshot - one char backward
;           }

            ((ร stop =) false)                   ;; we move only one word less
        )

        true
    ))

;; Move back to the end of the word.
;;
;; Returns false if start of the file was reached.

(defn- #_boolean bckend_word [#_long count, #_boolean bigword, #_boolean eol]
    ;; bigword: true for "B"
    ;; eol: true: stop at end of line.
    (ยง
        ((ร @curwin.w_cursor.coladd =) 0)
        (reset! cls_bigword bigword)

        (while (ยง 0 < count--)
            ((ร int sclass =) (cls))         ;; starting class

            ((ร int i =) (dec_cursor))
            (if (== i -1)
                ((ร RETURN) false)
            )
            (if (and eol (== i 1))
                ((ร RETURN) true)
            )

            ;; Move backward to before the start of this word.

            (when (non-zero? sclass)
                (while (ยง cls() == sclass)
                    (if (or (ยง (i = dec_cursor()) == -1) (and eol (== i 1)))
                        ((ร RETURN) true)
                    )
                )
            )

            ;; Move backward to end of the previous word

            (while (ยง cls() == 0)
                (if (and (zero? (.. @curwin w_cursor col)) (lineempty (.. @curwin w_cursor lnum)))
                    (ร BREAK)
                )
                (if (or (ยง (i = dec_cursor()) == -1) (and eol (== i 1)))
                    ((ร RETURN) true)
                )
            )
        )

        true
    ))

;; Skip a row of characters of the same class.
;; Return true when end-of-file reached, false otherwise.

(defn- #_boolean skip_chars [#_int cclass, #_int dir]
    (ยง
        (while (ยง cls() == cclass)
            (if (== (if (== dir FORWARD) (inc_cursor) (dec_cursor)) -1)
                ((ร RETURN) true)
            )
        )

        false
    ))

;; Go back to the start of the word or the start of white space

(defn- #_void back_in_line []
    (ยง
        ((ร int sclass =) (cls))                     ;; starting class

        (while true
            (if (zero? (.. @curwin w_cursor col))       ;; stop at start of line
                (ร BREAK)
            )
            (dec_cursor)
            (when (!= (cls) sclass)                ;; stop at start of word
                (inc_cursor)
                (ร BREAK)
            )
        )
    ))

;; Find word under cursor, cursor at end.
;; Used while an operator is pending, and in Visual mode.

(defn- #_boolean current_word [#_oparg_C oap, #_long count, #_boolean include, #_boolean bigword]
    ;; include: true: include word and white space
    ;; bigword: false == word, true == WORD
    (ยง
        ((ร boolean inclusive =) true)
        ((ร boolean include_white =) false)

        (reset! cls_bigword bigword)

        ((ร pos_C start_pos =) (ยง ยง_pos_C()))

        ;; Correct cursor when 'selection' is exclusive.
        (if (and @VIsual_active (== (.at @p_sel 0) (byte \e)) (ltpos @VIsual, (. @curwin w_cursor)))
            (dec_cursor))

        ;; When Visual mode is not active, or when the VIsual area is only one
        ;; character, select the word and/or white space under the cursor.

        (when (or (not @VIsual_active) (eqpos (. @curwin w_cursor), @VIsual))
            ;; Go to start of current word or white space.

            (back_in_line)
            (COPY_pos start_pos, (. @curwin w_cursor))

            ;; If the start is on white space, and white space should be included
            ;; ("   word"), or start is not on white space, and white space should
            ;; not be included ("word"), find end of word.

            (cond (== (zero? (cls)) include)
            (ยง
                (if (not (end_word 1, bigword, true, true))
                    ((ร RETURN) false)
                )
            )
            :else
            (ยง
                ;; If the start is not on white space, and white space should be included ("word   "),
                ;; or start is on white space and white space should not be included ("   "),
                ;; find start of word.
                ;; If we end up in the first column of the next line (single char word)
                ;; back up to end of the line.

                (fwd_word 1, bigword, true)
                (if (zero? (.. @curwin w_cursor col))
                    (decl (. @curwin w_cursor))
                    (oneleft))

                (if include
                    ((ร include_white =) true)
                )
            ))

            (cond @VIsual_active
            (ยง
                ;; should do something when inclusive == false !
                (COPY_pos @VIsual, start_pos)
                (redraw_curbuf_later INVERTED)      ;; update the inversion
            )
            :else
            (ยง
                (COPY_pos (. oap op_start), start_pos)
                ((ร oap.motion_type =) MCHAR)
            ))
            (ยง --count)
        )

        ;; When count is still > 0, extend with more objects.

        (while (< 0 count)
            ((ร inclusive =) true)
            (cond (and @VIsual_active (ltpos (. @curwin w_cursor), @VIsual))
            (ยง
                ;; In Visual mode, with cursor at start: move cursor back.

                (if (== (decl (. @curwin w_cursor)) -1)
                    ((ร RETURN) false)
                )

                (cond (!= include ((ยง != (cls()) 0)))
                (ยง
                    (if (not (bck_word 1, bigword, true))
                        ((ร RETURN) false)
                    )
                )
                :else
                (ยง
                    (if (not (bckend_word 1, bigword, true))
                        ((ร RETURN) false)
                    )
                    (incl (. @curwin w_cursor))
                ))
            )
            :else
            (ยง
                ;; Move cursor forward one word and/or white area.

                (if (== (incl (. @curwin w_cursor)) -1)
                    ((ร RETURN) false)
                )

                (cond (!= include ((ยง == (cls()) 0)))
                (ยง
                    (if (and (not (fwd_word 1, bigword, true)) (< 1 count))
                        ((ร RETURN) false)
                    )

                    ;; If end is just past a new-line,
                    ;; we don't want to include the first character on the line.
                    ;; Put cursor on last char of white.

                    (if (not (oneleft))
                        ((ร inclusive =) false)
                    )
                )
                :else
                (ยง
                    (if (not (end_word 1, bigword, true, true))
                        ((ร RETURN) false)
                    )
                ))
            ))
            (ยง --count)
        )

        (when (and include_white (or (non-zero? (cls)) (and (zero? (.. @curwin w_cursor col)) (not inclusive))))
            ;; If we don't include white space at the end, move the start to include
            ;; some white space there.  This makes "daw" work better on the last word in
            ;; a sentence (and "2daw" on last-but-one word).  Also when "2daw" deletes
            ;; "word." at the end of the line (cursor is at start of next line).
            ;; But don't delete white space at start of line (indent).

            ((ร pos_C pos =) (ยง ยง_pos_C()))
            (COPY_pos pos, (. @curwin w_cursor)) ;; save cursor position
            (COPY_pos (. @curwin w_cursor), start_pos)
            (when (oneleft)
                (back_in_line)
                (when (and (zero? (cls)) (< 0 (.. @curwin w_cursor col)))
                    (if @VIsual_active
                        (COPY_pos @VIsual, (. @curwin w_cursor))
                        (COPY_pos (. oap op_start), (. @curwin w_cursor)))
                )
            )
            (COPY_pos (. @curwin w_cursor), pos) ;; put cursor back at end
        )

        (cond @VIsual_active
        (ยง
            (if (and (== (.at @p_sel 0) (byte \e)) inclusive (ltoreq @VIsual, (. @curwin w_cursor)))
                (inc_cursor))
            (when (== @VIsual_mode (byte \V))
                (reset! VIsual_mode (byte \v))
                (reset! redraw_cmdline true)              ;; show mode later
            )
        )
        :else
        (ยง
            ((ร oap.inclusive =) inclusive)
        ))

        true
    ))

;; Find block under the cursor, cursor at end.
;; "what" and "other" are two matching parenthesis/brace/etc.

(defn- #_boolean current_block [#_oparg_C oap, #_long count, #_boolean include, #_int what, #_int other]
    ;; include: true == include white space
    ;; what: '(', '{', etc.
    ;; other: ')', '}', etc.
    (ยง
        ((ร pos_C pos =) null)
        ((ร pos_C start_pos =) (ยง ยง_pos_C()))
        (ร pos_C end_pos)
        ((ร boolean sol =) false)                    ;; '{' at start of line

        ((ร pos_C old_pos =) (ยง ยง_pos_C()))
        (COPY_pos old_pos, (. @curwin w_cursor))
        ((ร pos_C old_end =) (ยง ยง_pos_C()))
        (COPY_pos old_end, (. @curwin w_cursor))     ;; remember where we started
        ((ร pos_C old_start =) (ยง ยง_pos_C()))
        (COPY_pos old_start, old_end)

        ;; If we start on '(', '{', ')', '}', etc., use the whole block inclusive.

        (cond (or (not @VIsual_active) (eqpos @VIsual, (. @curwin w_cursor)))
        (ยง
            (setpcmark)
            (when (== what (byte \{))                    ;; ignore indent
                (while (inindent 1)
                    (if (non-zero? (inc_cursor))
                        (ร BREAK)
                    )
                )
            )
            (when (== (gchar_cursor) what)
                ;; cursor on '(' or '{', move cursor just after it
                (ยง @curwin.w_cursor.col++)
            )
        )
        (ltpos @VIsual, (. @curwin w_cursor))
        (ยง
            (COPY_pos old_start, @VIsual)
            (COPY_pos (. @curwin w_cursor), @VIsual) ;; cursor at low end of Visual
        )
        :else
        (ยง
            (COPY_pos old_end, @VIsual)
        ))

        ;; Search backwards for unclosed '(', '{', etc..
        ;; Put this position in start_pos.
        ;; Ignore quotes here.  Keep the "M" flag in 'cpo', as that is what the user wants.

        ((ร Bytes save_cpo =) @p_cpo)
        (reset! p_cpo (if (non-nil? (vim_strbyte @p_cpo, CPO_MATCHBSL)) (u8 "%M") (u8 "%")))
        (while (ยง 0 < count--)
            (if (nil? (ยง pos = findmatch(null, what)))
                (ร BREAK)
            )
            (COPY_pos (. @curwin w_cursor), pos)
            (COPY_pos start_pos, pos) ;; the findmatch for end_pos will overwrite *pos
        )
        (reset! p_cpo save_cpo)

        ;; Search for matching ')', '}', etc.
        ;; Put this position in curwin.w_cursor.

        (when (or (nil? pos) (nil? (ยง end_pos = findmatch(null, other))))
            (COPY_pos (. @curwin w_cursor), old_pos)
            ((ร RETURN) false)
        )
        (COPY_pos (. @curwin w_cursor), end_pos)

        ;; Try to exclude the '(', '{', ')', '}', etc. when "include" is false.
        ;; If the ending '}', ')' or ']' is only preceded by indent, skip that indent.
        ;; But only if the resulting area is not smaller than what we started with.

        (while (ยง !include)
            (incl start_pos)
            ((ร sol =) (ยง (@curwin.w_cursor.col == 0)))
            (decl (. @curwin w_cursor))
            (while (inindent 1)
                ((ร sol =) true)
                (if (!= (decl (. @curwin w_cursor)) 0)
                    (ร BREAK)
                )
            )

            ;; In Visual mode, when the resulting area is not bigger than what we
            ;; started with, extend it to the next block, and then exclude again.

            (cond (and (not (ltpos start_pos, old_start)) (not (ltpos old_end, (. @curwin w_cursor))) @VIsual_active)
            (ยง
                (COPY_pos (. @curwin w_cursor), old_start)
                (decl (. @curwin w_cursor))
                (when (nil? (ยง pos = findmatch(null, what)))
                    (COPY_pos (. @curwin w_cursor), old_pos)
                    ((ร RETURN) false)
                )
                (COPY_pos start_pos, pos)
                (COPY_pos (. @curwin w_cursor), pos)
                (when (nil? (ยง end_pos = findmatch(null, other)))
                    (COPY_pos (. @curwin w_cursor), old_pos)
                    ((ร RETURN) false)
                )
                (COPY_pos (. @curwin w_cursor), end_pos)
            )
            :else
            (ยง
                (ร BREAK)
            ))
        )

        (cond @VIsual_active
        (ยง
            (if (== (.at @p_sel 0) (byte \e))
                (ยง @curwin.w_cursor.col++)
            )
            (if (and sol (!= (gchar_cursor) NUL))
                (incp (. @curwin w_cursor)))               ;; include the line break
            (COPY_pos @VIsual, start_pos)
            (reset! VIsual_mode (byte \v))
            (redraw_curbuf_later INVERTED)          ;; update the inversion
            (showmode)
        )
        :else
        (ยง
            (COPY_pos (. oap op_start), start_pos)
            ((ร oap.motion_type =) MCHAR)
            ((ร oap.inclusive =) false)
            (cond sol
            (ยง
                (incl (. @curwin w_cursor))
            )
            (ltoreq start_pos, (. @curwin w_cursor))
            (ยง
                ;; Include the character under the cursor.
                ((ร oap.inclusive =) true)
            )
            :else
            (ยง
                ;; End is before the start (no text in between <>, [], etc.): don't operate on any text.
                (COPY_pos (. @curwin w_cursor), start_pos)
            ))
        ))

        true
    ))

;; Search quote char from string line[col].
;; Quote character escaped by one of the characters in "escape" is not counted as a quote.
;; Returns column number of "quotechar" or -1 when not found.

(defn- #_int find_next_quote [#_Bytes line, #_int col, #_int quotechar, #_Bytes escape]
    ;; escape: escape characters, can be null
    (ยง
        (while true
            ((ร int c =) (ยง line.at(col)))
            (cond (== c NUL)
            (ยง
                ((ร RETURN) -1)
            )
            (and (non-nil? escape) (non-nil? (vim_strchr escape, c)))
            (ยง
                (ยง col++)
            )
            (== c quotechar)
            (ยง
                (ร BREAK)
            ))
            ((ร col +=) (ยง us_ptr2len_cc(line.plus(col))))
        )
        col
    ))

;; Search backwards in "line" from column "col_start" to find "quotechar".
;; Quote character escaped by one of the characters in "escape" is not counted as a quote.
;; Return the found column or zero.

(defn- #_int find_prev_quote [#_Bytes line, #_int col_start, #_int quotechar, #_Bytes escape]
    ;; escape: escape characters, can be null
    (ยง
        (ร int n)

        (while (< 0 col_start)
            (ยง --col_start)
            ((ร col_start -=) (ยง us_head_off(line, line.plus(col_start))))
            ((ร n =) 0)
            (when (non-nil? escape)
                (while (ยง 0 < col_start - n && vim_strchr(escape, line.at(col_start - n - 1)) != null)
                    (ยง n++)
                )
            )
            (cond (non-zero? (& n 1))
            (ยง
                ((ร col_start -=) n)     ;; uneven number of escape chars, skip it
            )
            (== (.at line col_start) quotechar)
            (ยง
                (ร BREAK)
            ))
        )
        col_start
    ))

;; Find quote under the cursor, cursor at end.
;; Returns true if found, else false.

(defn- #_boolean current_quote [#_oparg_C oap, #_long count, #_boolean include, #_int quotechar]
    ;; include: true == include quote char
    ;; quotechar: Quote character
    (ยง
        ((ร Bytes line =) (ml_get_curline))
        (ร int col_end)
        ((ร int col_start =) (.. @curwin w_cursor col))

        ((ร boolean inclusive =) false)
        ((ร boolean vis_empty =) true)           ;; Visual selection <= 1 char
        ((ร boolean vis_bef_curs =) false)       ;; Visual starts before cursor
        ((ร boolean inside_quotes =) false)      ;; Looks like "i'" done before
        ((ร boolean selected_quote =) false)     ;; Has quote inside selection

        ;; Correct cursor when 'selection' is exclusive.
        (when @VIsual_active
            ((ร vis_bef_curs =) (ยง ltpos(@VIsual, @curwin.w_cursor)))
            (if (and (== (.at @p_sel 0) (byte \e)) vis_bef_curs)
                (dec_cursor))
            ((ร vis_empty =) (ยง eqpos(@VIsual, @curwin.w_cursor)))
        )

        (when (not vis_empty)
            (ร int i)
            ;; Check if the existing selection exactly spans the text inside quotes.
            (cond vis_bef_curs
            (ยง
                ((ร inside_quotes =) (ยง 0 < @VIsual.col && line.at(@VIsual.col - 1) == quotechar && line.at(@curwin.w_cursor.col) != NUL && line.at(@curwin.w_cursor.col + 1) == quotechar))
                ((ร i =) (. @VIsual col))
                ((ร col_end =) (.. @curwin w_cursor col))
            )
            :else
            (ยง
                ((ร inside_quotes =) (ยง 0 < @curwin.w_cursor.col && line.at(@curwin.w_cursor.col - 1) == quotechar && line.at(@VIsual.col) != NUL && line.at(@VIsual.col + 1) == quotechar))
                ((ร i =) (.. @curwin w_cursor col))
                ((ร col_end =) (. @VIsual col))
            ))

            ;; Find out if we have a quote in the selection.
            (while (<= i col_end)
                (when (== (.at line (ยง i++)) quotechar)
                    ((ร selected_quote =) true)
                    (ร BREAK)
                )
            )
        )

        (cond (and (not vis_empty) (== (.at line col_start) quotechar))
        (ยง
            ;; Already selecting something and on a quote character.
            ;; Find the next quoted string.
            (cond vis_bef_curs
            (ยง
                ;; Assume we are on a closing quote: move to after the next opening quote.
                ((ร col_start =) (ยง find_next_quote(line, col_start + 1, quotechar, null)))
                (if (< col_start 0)
                    ((ร RETURN) false)
                )
                ((ร col_end =) (ยง find_next_quote(line, col_start + 1, quotechar, @curbuf.@b_p_qe)))
                (when (< col_end 0)
                    ;; We were on a starting quote perhaps?
                    ((ร col_end =) col_start)
                    ((ร col_start =) (.. @curwin w_cursor col))
                )
            )
            :else
            (ยง
                ((ร col_end =) (find_prev_quote line, col_start, quotechar, null))
                (if (!= (.at line col_end) quotechar)
                    ((ร RETURN) false)
                )
                ((ร col_start =) (ยง find_prev_quote(line, col_end, quotechar, @curbuf.@b_p_qe)))
                (when (!= (.at line col_start) quotechar)
                    ;; We were on an ending quote perhaps?
                    ((ร col_start =) col_end)
                    ((ร col_end =) (.. @curwin w_cursor col))
                )
            ))
        )
        (or (== (.at line col_start) quotechar) (not vis_empty))
        (ยง
            ((ร int first_col =) col_start)

            (when (not vis_empty)
                (if vis_bef_curs
                    ((ร first_col =) (find_next_quote line, col_start, quotechar, null))
                    ((ร first_col =) (find_prev_quote line, col_start, quotechar, null))
                )
            )

            ;; The cursor is on a quote, we don't know if it's the opening or
            ;; closing quote.  Search from the start of the line to find out.
            ;; Also do this when there is a Visual area, a' may leave the cursor
            ;; in between two strings.
            ((ร col_start =) 0)
            (while true
                ;; Find open quote character.
                ((ร col_start =) (find_next_quote line, col_start, quotechar, null))
                (if (or (< col_start 0) (< first_col col_start))
                    ((ร RETURN) false)
                )
                ;; Find close quote character.
                ((ร col_end =) (ยง find_next_quote(line, col_start + 1, quotechar, @curbuf.@b_p_qe)))
                (if (< col_end 0)
                    ((ร RETURN) false)
                )
                ;; If is cursor between start and end quote character,
                ;; it is target text object.
                (if (and (<= col_start first_col) (<= first_col col_end))
                    (ร BREAK)
                )
                ((ร col_start =) (+ col_end 1))
            )
        )
        :else
        (ยง
            ;; Search backward for a starting quote.
            ((ร col_start =) (ยง find_prev_quote(line, col_start, quotechar, @curbuf.@b_p_qe)))
            (when (!= (.at line col_start) quotechar)
                ;; No quote before the cursor, look after the cursor.
                ((ร col_start =) (find_next_quote line, col_start, quotechar, null))
                (if (< col_start 0)
                    ((ร RETURN) false)
                )
            )

            ;; Find close quote character.
            ((ร col_end =) (ยง find_next_quote(line, col_start + 1, quotechar, @curbuf.@b_p_qe)))
            (if (< col_end 0)
                ((ร RETURN) false)
            )
        ))

        ;; When "include" is true,
        ;; include spaces after closing quote or before the starting quote.
        (when include
            (cond (vim_iswhite (.at line (+ col_end 1)))
            (ยง
                (while (ยง vim_iswhite(line.at(col_end + 1)))
                    (ยง col_end++)
                )
            )
            :else
            (ยง
                (while (ยง 0 < col_start && vim_iswhite(line.at(col_start - 1)))
                    (ยง --col_start)
                )
            ))
        )

        ;; Set start position.  After vi" another i" must include the ".
        ;; For v2i" include the quotes.
        (if (and (not include) (< count 2) (or vis_empty (not inside_quotes)))
            (ยง col_start++)
        )
        ((ร @curwin.w_cursor.col =) col_start)
        (cond @VIsual_active
        (ยง
            ;; Set the start of the Visual area when the Visual area was empty, we
            ;; were just inside quotes or the Visual area didn't start at a quote
            ;; and didn't include a quote.

            (when (or vis_empty (and vis_bef_curs (not selected_quote) (or inside_quotes (and (!= (.at line (. @VIsual col)) quotechar) (or (zero? (. @VIsual col)) (ยง line.at(@VIsual.col - 1) != quotechar))))))
                (COPY_pos @VIsual, (. @curwin w_cursor))
                (redraw_curbuf_later INVERTED)
            )
        )
        :else
        (ยง
            (COPY_pos (. oap op_start), (. @curwin w_cursor))
            ((ร oap.motion_type =) MCHAR)
        ))

        ;; Set end position.
        ((ร @curwin.w_cursor.col =) col_end)
        ;; After vi" another i" must include the ".
        (if (and (or include (< 1 count) (and (not vis_empty) inside_quotes)) (== (inc_cursor) 2))
            ((ร inclusive =) true)
        )
        (cond @VIsual_active
        (ยง
            (cond (or vis_empty vis_bef_curs)
            (ยง
                ;; decrement cursor when 'selection' is not exclusive
                (if (!= (.at @p_sel 0) (byte \e))
                    (dec_cursor))
            )
            :else
            (ยง
                ;; Cursor is at start of Visual area.  Set the end of the Visual area
                ;; when it was just inside quotes or it didn't end at a quote.
                (when (or inside_quotes (and (not selected_quote) (!= (.at line (. @VIsual col)) quotechar) (or (== (.at line (. @VIsual col)) NUL) (ยง line.at(@VIsual.col + 1) != quotechar))))
                    (dec_cursor)
                    (COPY_pos @VIsual, (. @curwin w_cursor))
                )
                ((ร @curwin.w_cursor.col =) col_start)
            ))
            (when (== @VIsual_mode (byte \V))
                (reset! VIsual_mode (byte \v))
                (reset! redraw_cmdline true)              ;; show mode later
            )
        )
        :else
        (ยง
            ;; Set inclusive and other oap's flags.
            ((ร oap.inclusive =) inclusive)
        ))

        true
    ))

;; Find next search match under cursor, cursor at end.
;; Used while an operator is pending, and in Visual mode.

(defn- #_boolean current_search [#_long count, #_boolean forward]
    ;; forward: move forward or backwards
    (ยง
        ((ร pos_C save_VIsual =) (ยง ยง_pos_C()))
        (COPY_pos save_VIsual, @VIsual)

        ;; wrapping should not occur
        ((ร boolean old_p_ws =) @p_ws)
        (reset! p_ws false)

        ;; Correct cursor when 'selection' is exclusive.
        (if (and @VIsual_active (== (.at @p_sel 0) (byte \e)) (ltpos @VIsual, (. @curwin w_cursor)))
            (dec_cursor))

        ((ร pos_C orig_pos =) (ยง ยง_pos_C()))       ;; position of the cursor at beginning
        (COPY_pos orig_pos, (. @curwin w_cursor))
        ((ร pos_C pos =) (ยง ยง_pos_C()))            ;; position after the pattern
        (COPY_pos pos, (. @curwin w_cursor))
        ((ร pos_C start_pos =) (ยง ยง_pos_C()))      ;; position before the pattern
        (COPY_pos start_pos, (. @curwin w_cursor))

        (when @VIsual_active
            (COPY_pos start_pos, @VIsual)

            ;; make sure, searching further will extend the match
            (when @VIsual_active
                (if forward
                    (incl pos)
                    (decl pos))
            )
        )

        ;; Is the pattern is zero-width?
        ((ร int one_char =) (ยง is_one_char(@spats[@last_idx].pat, true)))
        (when (== one_char -1)
            (reset! p_ws old_p_ws)
            ((ร RETURN) false)                   ;; pattern not found
        )

        ;; The trick is to first search backwards and then search forward again,
        ;; so that a match at the current cursor position will be correctly captured.

        ((ร FOR) (ร (ยง int round = 0) (< round 2) (ยง round++))
            ((ร boolean dir =) (if forward (!= round 0) (== round 0)))

            ((ร int flags =) 0)
            (if (and (not dir) (zero? one_char))
                ((ร flags =) SEARCH_END)
            )

            ((ร int result =) (searchit @curwin, @curbuf, pos, (if dir FORWARD BACKWARD), (ยง @spats[@last_idx].pat), (if (!= round 0) count 1), (| flags SEARCH_KEEP), RE_SEARCH, 0, null))

            ;; First search may fail, but then start searching from the beginning of
            ;; the file (cursor might be on the search match) except when Visual mode
            ;; is active, so that extending the visual selection works.
            (when (zero? result)
                (when (non-zero? round)     ;; not found, abort
                    (COPY_pos (. @curwin w_cursor), orig_pos)
                    (if @VIsual_active
                        (COPY_pos @VIsual, save_VIsual))
                    (reset! p_ws old_p_ws)
                    ((ร RETURN) false)
                )

                (cond forward        ;; try again from start of buffer
                (ยง
                    (clearpos pos)
                )
                :else                ;; try again from end of buffer
                (ยง
                    ;; searching backwards, so set pos to last line and col
                    ((ร pos.lnum =) (.. @curbuf b_ml ml_line_count))
                    ((ร pos.col =) (ยง STRLEN(ml_get(@curbuf.b_ml.ml_line_count))))
                ))
            )
            (reset! p_ws old_p_ws)
        )

        (COPY_pos start_pos, pos)
        ((ร int flags =) (if forward SEARCH_END 0))

        ;; Check again from the current cursor position,
        ;; since the next match might actually be only one char wide.
        ((ร one_char =) (ยง is_one_char(@spats[@last_idx].pat, false)))

        ;; Move to match, except for zero-width matches,
        ;; in which case, we are already on the next match.
        (if (zero? one_char)
            (searchit @curwin, @curbuf, pos, (if forward FORWARD BACKWARD), (ยง @spats[@last_idx].pat), 0, (| flags SEARCH_KEEP), RE_SEARCH, 0, null)
        )

        (if (not @VIsual_active)
            (COPY_pos @VIsual, start_pos))

        (COPY_pos (. @curwin w_cursor), pos)
        (reset! VIsual_active true)
        (reset! VIsual_mode (byte \v))

        (when @VIsual_active
            (redraw_curbuf_later INVERTED)  ;; update the inversion
            (when (== (.at @p_sel 0) (byte \e))
                ;; Correction for exclusive selection depends on the direction.
                (cond (and forward (ltoreq @VIsual, (. @curwin w_cursor)))
                (ยง
                    (inc_cursor)
                )
                (and (not forward) (ltoreq (. @curwin w_cursor), @VIsual))
                (ยง
                    (incp @VIsual)
                ))
            )
        )

        (may_start_select (byte \c))

        (redraw_curbuf_later INVERTED)
        (showmode)

        true
    ))

;; Check if the pattern is one character or zero-width.
;; If move is true, check from the beginning of the buffer, else from the current cursor position.
;; Returns true, false or -1 for failure.

(defn- #_int is_one_char [#_Bytes pattern, #_boolean move]
    (ยง
        ((ร int result =) -1)

        ((ร boolean save_called_emsg =) @called_emsg)

        ((ร regmmatch_C regmatch =) (ยง ยง_regmmatch_C()))
        (if (not (search_regcomp pattern, RE_SEARCH, RE_SEARCH, SEARCH_KEEP, regmatch))
            ((ร RETURN) -1)
        )

        ((ร pos_C pos =) (ยง ยง_pos_C()))
        ((ร int flag =) 0)
        ;; move to match
        (when (not move)
            (COPY_pos pos, (. @curwin w_cursor))
            ;; accept a match at the cursor position
            ((ร flag =) SEARCH_START)
        )

        (when (non-zero? (ยง searchit(@curwin, @curbuf, pos, FORWARD, @spats[@last_idx].pat, 1, SEARCH_KEEP + flag, RE_SEARCH, 0, null)))
            ;; Zero-width pattern should match somewhere,
            ;; then we can check if start and end are in the same position.
            (reset! called_emsg false)
            ((ร long nmatched =) (ยง vim_regexec_multi(regmatch, @curwin, @curbuf, pos.lnum, 0, null)))

            (when (not @called_emsg)
                ((ร result =) (if (ยง nmatched != 0 && regmatch.startpos[0].lnum == regmatch.endpos[0].lnum && regmatch.startpos[0].col == regmatch.endpos[0].col) TRUE FALSE))
            )

            (if (and (== result FALSE) (<= 0 (incp pos)) (== (. pos col) (ยง regmatch.endpos[0].col)))
                ((ร result =) TRUE)
            )
        )

        ((ร @called_emsg |=) save_called_emsg)

        result
    ))

;; return true if line 'lnum' is empty or has white chars only.

(defn- #_boolean linewhite [#_long lnum]
    (ยง
        ((ร Bytes p =) (ยง skipwhite(ml_get(lnum))))
        (eos? p)
    ))

;; memline.c: Contains the functions for appending, deleting and changing the text lines.

;; Open a new memline.

(defn- #_memline_C ml_open []
    (ยง
        ((ร memline_C ml =) (ยง ยง_memline_C()))

        ((ร ml.ml_flags =) ML_EMPTY)
        ((ร ml.ml_line_count =) 1)

        ;; Create an empty line 1.

;       %% insert @0 (u8 "")

        ml
    ))

;; Return a pointer to a (read-only copy of a) line.
;;
;; On failure an error message is given and ioBuff is returned
;; (to avoid having to check for error everywhere).

(defn- #_Bytes ml_get [#_long lnum]
    (ml_get_buf @curbuf, lnum))

;; Return pointer to position "pos".

(defn- #_Bytes ml_get_pos [#_pos_C pos]
    (ยง
        (.plus (ml_get_buf @curbuf, (. pos lnum)) (. pos col))
    ))

;; Return pointer to cursor line.

(defn- #_Bytes ml_get_curline []
    (ยง
        (ml_get_buf @curbuf, (.. @curwin w_cursor lnum))
    ))

;; Return pointer to cursor position.

(defn- #_Bytes ml_get_cursor []
    (ยง
        (.plus (ml_get_buf @curbuf, (.. @curwin w_cursor lnum)) (.. @curwin w_cursor col))
    ))

;; Return a pointer to a line in a specific buffer

(defn- #_Bytes ml_get_buf [#_buffer_C buf, #_long lnum]
    (ยง
        (when (< (.. buf b_ml ml_line_count) lnum)  ;; invalid line number
            (emsgn (u8 "E315: ml_get: invalid lnum: %ld"), lnum)

            (STRCPY @ioBuff, (u8 "???"))
            ((ร RETURN) @ioBuff)
        )

        (if (<= lnum 0)                      ;; pretend line 0 is line 1
            ((ร lnum =) 1)
        )

;       %% return @(lnum - 1)
    ))

;; Append a line after lnum (may be 0 to insert a line in front of the file).
;; "line" does not need to be allocated, but can't be another line in a buffer,
;; unlocking may make it invalid.
;;
;; Check: The caller of this function should probably also call appended_lines().
;;
;; return false for failure, true otherwise

(defn- #_boolean ml_append [#_long lnum, #_Bytes line]
    ;; lnum: append after this line (can be 0)
    ;; line: text of the new line
    (ยง
        (if (< (.. @curbuf b_ml ml_line_count) lnum) ;; lnum out of range
            ((ร RETURN) false)
        )

;       %% insert @lnum STRDUP(line)

        (ยง @curbuf.b_ml.ml_line_count++)
        ((ร @curbuf.b_ml.ml_flags &=) (ยง ~ML_EMPTY))

        true
    ))

;; Replace line lnum in current buffer.
;;
;; Check: The caller of this function should probably also call
;; changed_lines(), unless update_screen(NOT_VALID) is used.
;;
;; return false for failure, true otherwise

(defn- #_boolean ml_replace [#_long lnum, #_Bytes line]
    (ยง
        (if (or (zero? lnum) (nil? line))           ;; just checking...
            ((ร RETURN) false)
        )

;       %% replace @(lnum - 1) STRDUP(line)

        ((ร @curbuf.b_ml.ml_flags &=) (ยง ~ML_EMPTY))

        true
    ))

;; Delete line 'lnum' in the current buffer.
;;
;; Check: The caller of this function should probably also call
;; deleted_lines() after this.
;;
;; return false for failure, true otherwise

(defn- #_boolean ml_delete [#_long lnum, #_boolean message]
    (ยง
        (if (or (< lnum 1) (< (.. @curbuf b_ml ml_line_count) lnum))
            ((ร RETURN) false)
        )

        ;; If the file becomes empty the last line is replaced by an empty line.

        (when (== (.. @curbuf b_ml ml_line_count) 1)    ;; file becomes empty
            (if message
                (set_keep_msg no_lines_msg, 0))

;           %% replace @0 (u8 "")

            ((ร @curbuf.b_ml.ml_flags |=) ML_EMPTY)

            ((ร RETURN) true)
        )

;       %% delete @(lnum - 1)

        (ยง --@curbuf.b_ml.ml_line_count)

        true
    ))

;; buffer.c: functions for dealing with the buffer structure --------------------------------------

;; The buffer list is a double linked list of all buffers.
;; Each buffer can be in one of these states:
;;       hidden: b_nwindows == 0, loaded but not displayed in a window
;;       normal: loaded and displayed in a window

;; Close the link to a buffer.

(defn- #_void close_buffer [#_window_C win]
    (ยง
        ((ร buffer_C buf =) @curbuf)

        ;; Set b_last_cursor when closing the last window for the buffer.
        ;; Remember the last cursor position and window options of the buffer.
        ;; This used to be only for the current window, but then options like
        ;; 'foldmethod' may be lost with a ":only" command.

        (if (== (. buf b_nwindows) 1)
            (set_last_cursor win))

        ;; decrease the link count from windows (unless not in any window)
        (when (< 0 (. buf b_nwindows))
            (ยง --buf.b_nwindows)
        )
    ))

;; This is the ONLY way to create a new buffer.

(defn- #_buffer_C newBuffer []
    (ยง
        ((ร buffer_C buf =) (ยง ยง_buffer_C()))

        ((ร buf.b_ml =) (ml_open))

        ((ร @curwin.w_nrwidth_line_count =) 0)

        ((ร buf.b_namedm =) (ARRAY_pos NMARKS))
        ((ร buf.b_visual =) (ยง ยง_visualinfo_C()))
        ((ร buf.b_last_cursor =) (ยง ยง_pos_C()))
        ((ร buf.b_last_insert =) (ยง ยง_pos_C()))
        ((ร buf.b_last_change =) (ยง ยง_pos_C()))
        ((ร buf.b_changelist =) (ARRAY_pos JUMPLISTSIZE))
        ((ร buf.b_chartab =) (ยง new int[8]))
        ((ร buf.b_op_start =) (ยง ยง_pos_C()))
        ((ร buf.b_op_start_orig =) (ยง ยง_pos_C()))
        ((ร buf.b_op_end =) (ยง ยง_pos_C()))

        (buf_init_chartab buf, false)

        ((ร buf.b_u_synced =) true)

        (unchanged buf)
        (clrallmarks buf)

        buf
    ))

;; Print info about the current buffer.

(defn- #_void fileinfo [#_int _fullname, #_boolean dont_truncate]
    (ยง
        ((ร Bytes buffer =) (ยง new Bytes(IOSIZE)))

        ((ร Bytes p =) buffer)

        (ยง (p = p.plus(1)).be(-1, (byte \")))
        (vim_strncpy p, (buf_spname @curbuf), (ยง IOSIZE - BDIFF(p, buffer) - 1))

        (vim_snprintf_add buffer, IOSIZE, (u8 "\"%s"), (if @(. @curbuf b_changed) (u8 " [Modified] ") (u8 " ")))

        ((ร int n =) (ยง (int)((@curwin.w_cursor.lnum * 100) / @curbuf.b_ml.ml_line_count)))

        (cond (non-zero? (& (.. @curbuf b_ml ml_flags) ML_EMPTY))
        (ยง
            (ยง vim_snprintf_add(buffer, IOSIZE, (u8 "%s"), no_lines_msg))
        )
        @p_ru
        (ยง
            ;; Current line and column are already on the screen.
            (if (== (.. @curbuf b_ml ml_line_count) 1)
                (ยง vim_snprintf_add(buffer, IOSIZE, (u8 "1 line --%d%%--"), n))
                (ยง vim_snprintf_add(buffer, IOSIZE, (u8 "%ld lines --%d%%--"), @curbuf.b_ml.ml_line_count, n))
            )
        )
        :else
        (ยง
            (ยง vim_snprintf_add(buffer, IOSIZE, (u8 "line %ld of %ld --%d%%-- col "), @curwin.w_cursor.lnum, @curbuf.b_ml.ml_line_count, n))
            (validate_virtcol)
            ((ร int len =) (STRLEN buffer))
            (col_print (.plus buffer len), (- IOSIZE len), (+ (.. @curwin w_cursor col) 1), (+ (. @curwin w_virtcol) 1))
        ))

        (cond dont_truncate
        (ยง
            ;; Temporarily set msg_scroll to avoid the message being truncated.
            ;; First call msg_start() to get the message in the right place.
            (msg_start)
            ((ร boolean m =) @msg_scroll)
            (reset! msg_scroll true)
            (msg buffer)
            (reset! msg_scroll m)
        )
        :else
        (ยง
            ((ร p =) (msg_trunc_attr buffer, false, 0))
            (when (or (non-zero? @restart_edit) (and (non-zero? @msg_scrolled) (not @need_wait_return)))
                ;; Need to repeat the message after redrawing when:
                ;; - When restart_edit is set (otherwise there will be a delay before redrawing).
                ;; - When the screen was scrolled but there is no wait-return prompt.
                (set_keep_msg p, 0)
            )
        ))
    ))

(defn- #_void col_print [#_Bytes buf, #_int buflen, #_int col, #_int vcol]
    (ยง
        (if (== col vcol)
            (ยง vim_snprintf(buf, buflen, (u8 "%d"), col))
            (ยง vim_snprintf(buf, buflen, (u8 "%d-%d"), col, vcol))
        )
    ))

;; Get relative cursor position in window into "buf[buflen]", in the form 99%,
;; using "Top", "Bot" or "All" when appropriate.

(defn- #_void get_rel_pos [#_window_C wp, #_Bytes buf, #_int buflen]
    (ยง
        (if (< buflen 3) ;; need at least 3 chars for writing
            (ร RETURN)
        )

        ;; number of lines above/below window
        ((ร long above =) (ยง wp.w_topline - 1))
        ((ร long below =) (ยง @curbuf.b_ml.ml_line_count - wp.w_botline + 1))

        (cond (<= below 0)
        (ยง
            (vim_strncpy buf, (if (zero? above) (u8 "All") (u8 "Bot")), (- buflen 1))
        )
        (<= above 0)
        (ยง
            (vim_strncpy buf, (u8 "Top"), (- buflen 1))
        )
        :else
        (ยง
            ((ร int cent =) (if (< 1000000 above) (int (/ above (/ (+ above below) 100))) (int (/ (* above 100) (+ above below)))))
            (ยง vim_snprintf(buf, buflen, (u8 "%2d%%"), cent))
        ))
    ))

;; Return special buffer name.

(defn- #_Bytes buf_spname [#_buffer_C buf]
    (ยง
        (u8 "[No Name]")
    ))

;;; ============================================================================================== VimQ

;; charset.c --------------------------------------------------------------------------------------

(atom! boolean chartab_initialized)

;; b_chartab[] is an array of 8 ints, each bit representing one of the characters 0-255.
(defn- #_void set_chartab [#_buffer_C buf, #_int c]
    (ยง
        ((ร buf.b_chartab[c >>> 5] |=) (ยง (1 << (c & 0x1f))))
    ))

(defn- #_void reset_chartab [#_buffer_C buf, #_int c]
    (ยง
        ((ร buf.b_chartab[c >>> 5] &=) (ยง ~(1 << (c & 0x1f))))
    ))

(defn- #_int get_chartab [#_buffer_C buf, #_int c]
    (ยง
        (ยง buf.b_chartab[c >>> 5] & (1 << (c & 0x1f)))
    ))

;; Fill chartab[].  Also fills curbuf.b_chartab[] with flags for keyword
;; characters for current buffer.
;;
;; Depends on the option settings 'iskeyword', 'isident', 'isfname',
;; 'isprint' and 'encoding'.
;;
;; The index in chartab[] depends on 'encoding':
;; - For non-multi-byte index with the byte (same as the character).
;; - For UTF-8 index with the character (when first byte is up to 0x80 it is
;;   the same as the character, if the first byte is 0x80 and above it depends
;;   on further bytes).
;;
;; The contents of chartab[]:
;; - The lower two bits, masked by CT_CELL_MASK, give the number of display
;;   cells the character occupies (1 or 2).  Not valid for UTF-8 above 0x80.
;; - CT_PRINT_CHAR bit is set when the character is printable (no need to
;;   translate the character before displaying it).
;; - CT_FNAME_CHAR bit is set when the character can be in a file name.
;; - CT_ID_CHAR bit is set when the character can be in an identifier.
;;
;; Return false if 'iskeyword', 'isident', 'isfname' or 'isprint' option has
;; an error, true otherwise.

(defn- #_boolean init_chartab []
    (buf_init_chartab @curbuf, true))

(defn- #_boolean buf_init_chartab [#_buffer_C buf, #_boolean global]
    ;; global: false: only set buf.b_chartab[]
    (ยง
        (when global
            ;; Set the default size for printable characters:
            ;; From <Space> to '~' is 1 (printable), others are 2 (not printable).
            ;; This also inits all 'isident' and 'isfname' flags to false.

            ((ร int c =) 0)
            (while (ยง c < (byte \space))
                ((ร chartab[c++] =) (if (non-zero? (& @dy_flags DY_UHEX)) (byte 4) (byte 2)))
            )
            (while (ยง c <= (byte \~))
                ((ร chartab[c++] =) (+ 1 CT_PRINT_CHAR))
            )
            (while (< c 256)
                ;; UTF-8: bytes 0xa0 - 0xff are printable (latin1).
                (cond (<= 0xa0 c)
                (ยง
                    ((ร chartab[c++] =) (+ CT_PRINT_CHAR 1))
                )
                :else
                (ยง
                    ;; the rest is unprintable by default
                    ((ร chartab[c++] =) (if (non-zero? (& @dy_flags DY_UHEX)) (byte 4) (byte 2)))
                ))
            )

            ;; Assume that every multi-byte char is a filename character.
            ((ร FOR) (ร (ยง c = 1) (< c 256) (ยง c++))
                (if (<= 0xa0 c)
                    ((ร chartab[c] |=) CT_FNAME_CHAR)
                )
            )
        )

        ;; Init word char flags all to false.

        (AFILL (. buf b_chartab), 0)

        ;; Walk through the 'isident', 'iskeyword', 'isfname' and 'isprint' options.
        ;; Each option is a list of characters, character numbers or ranges,
        ;; separated by commas, e.g.: "200-210,x,#-178,-"

        ((ร FOR) (ร ((ร int i =) (if global 0 3)) (<= i 3) (ยง i++))
            (ร Bytes p)
            (cond (zero? i)
            (ยง
                ((ร p =) @p_isi)          ;; first round: 'isident'
            )
            (== i 1)
            (ยง
                ((ร p =) @p_isp)          ;; second round: 'isprint'
            )
            (== i 2)
            (ยง
                ((ร p =) @p_isf)          ;; third round: 'isfname'
            )
            :else    ;; i == 3
            (ยง
                ((ร p =) @(. buf b_p_isk))    ;; fourth round: 'iskeyword'
            ))

            (while (ยง p.at(0) != NUL)
                ((ร boolean tilde =) false)
                ((ร boolean do_isalpha =) false)
                (when (and (== (.at p 0) (byte \^)) (non-eos? p 1))
                    ((ร tilde =) true)
                    ((ร p =) (ยง p.plus(1)))
                )
                (ร int c)
                (cond (asc_isdigit (ยง p.at(0)))
                (ยง
;                   Bytes[] __ = { p }; c = (int)getdigits(__); p = __[0];
                )
                :else
                (ยง
;                   Bytes[] __ = { p }; c = us_ptr2char_adv(__, true); p = __[0];
                ))
                ((ร int c2 =) -1)
                (when (and (== (.at p 0) (byte \-)) (non-eos? p 1))
                    ((ร p =) (ยง p.plus(1)))
                    (cond (asc_isdigit (ยง p.at(0)))
                    (ยง
;                       Bytes[] __ = { p }; c2 = (int)getdigits(__); p = __[0];
                    )
                    :else
                    (ยง
;                       Bytes[] __ = { p }; c2 = us_ptr2char_adv(__, true); p = __[0];
                    ))
                )
                (if (or (<= c 0) (<= 256 c) (and (< c2 c) (!= c2 -1)) (<= 256 c2) (not (or (eos? p) (== (.at p 0) (byte \,)))))
                    ((ร RETURN) false)
                )

                (when (== c2 -1)       ;; not a range
                    ;; A single '@' (not "@-@"):
                    ;; Decide on letters being ID/printable/keyword chars with
                    ;; standard function isalpha().  This takes care of locale
                    ;; for single-byte characters.

                    (cond (== c (byte \@))
                    (ยง
                        ((ร do_isalpha =) true)
                        ((ร c =) 1)
                        ((ร c2 =) 255)
                    )
                    :else
                    (ยง
                        ((ร c2 =) c)
                    ))
                )
                (while (<= c c2)
                    ;; Use the MB_ functions here, because isalpha() doesn't work properly
                    ;; when 'encoding' is "latin1" and the locale is "C".
                    (when (or (not do_isalpha) (utf_islower c) (utf_isupper c))
                        (cond (zero? i)                 ;; (re)set ID flag
                        (ยง
                            (if tilde
                                ((ร chartab[c] &=) (ยง ~CT_ID_CHAR))
                                ((ร chartab[c] |=) CT_ID_CHAR)
                            )
                        )
                        (== i 1)            ;; (re)set printable
                        (ยง
                            (when (or (< c (byte \space)) (< (byte \~) c))
                                (cond tilde
                                (ยง
                                    ((ร chartab[c] =) (byte (+ (& (ยง chartab[c]) (ยง ~CT_CELL_MASK)) (if (!= (& @dy_flags DY_UHEX) 0) 4 2))))
                                    ((ร chartab[c] &=) (ยง ~CT_PRINT_CHAR))
                                )
                                :else
                                (ยง
                                    ((ร chartab[c] =) (byte (+ (& (ยง chartab[c]) (ยง ~CT_CELL_MASK)) 1)))
                                    ((ร chartab[c] |=) CT_PRINT_CHAR)
                                ))
                            )
                        )
                        (== i 2)            ;; (re)set fname flag
                        (ยง
                            (if tilde
                                ((ร chartab[c] &=) (ยง ~CT_FNAME_CHAR))
                                ((ร chartab[c] |=) CT_FNAME_CHAR)
                            )
                        )
                        :else #_"/* i == 3 */"           ;; (re)set keyword flag
                        (ยง
                            (if tilde
                                (reset_chartab buf, c)
                                (set_chartab buf, c))
                        ))
                    )
                    (ยง c++)
                )

                ((ร c =) (ยง p.at(0)))
                ((ร p =) (skip_to_option_part p))
                (when (and (== c (byte \,)) (eos? p))
                    ;; Trailing comma is not allowed.
                    ((ร RETURN) false)
                )
            )
        )

        (reset! chartab_initialized true)
        true
    ))

;; Translate any special characters in buf[bufsize] in-place.
;; The result is a string with only printable characters, but if there is not
;; enough room, not all characters will be translated.

(defn- #_void trans_characters [#_Bytes buf, #_int bufsize]
    (ยง
        ((ร int len =) (STRLEN buf))
        ((ร int room =) (- bufsize len))                           ;; room in buffer after string

        (while (ยง buf.at(0) != 0)
            ((ร int trs_len =) (us_ptr2len_cc buf))

            ;; Assume a multi-byte character doesn't need translation.
            (cond (< 1 trs_len)
            (ยง
                ((ร len -=) trs_len)
            )
            :else
            (ยง
                ((ร Bytes trs =) (ยง transchar_byte(buf.at(0))))          ;; translated character
                ((ร trs_len =) (STRLEN trs))
                (when (< 1 trs_len)
                    ((ร room -=) (- trs_len 1))
                    (if (<= room 0)
                        (ร RETURN)
                    )
                    (BCOPY buf, trs_len, buf, 1, len)
                )
                (BCOPY buf, trs, trs_len)
                (ยง --len)
            ))

            ((ร buf =) (ยง buf.plus(trs_len)))
        )
    ))

;; Catch 22: chartab[] can't be initialized before the options are initialized,
;; and initializing options may cause transchar() to be called!
;; When !chartab_initialized, don't use chartab[].
;; Does NOT work for multi-byte characters, c must be <= 255.
;; Also doesn't work for the first byte of a multi-byte, "c" must be a character!

(final Bytes transchar_buf (Bytes. 7))

(defn- #_Bytes transchar [#_int c]
    (ยง
        ((ร int i =) 0)

        (when (is_special c)      ;; special key code, display as ~@ char
            (.be transchar_buf 0, (byte \~))
            (.be transchar_buf 1, (byte \@))
            ((ร i =) 2)
            ((ร c =) (ยง char_u(KB_SECOND(c))))
        )

        (cond (or (and (not @chartab_initialized) (<= (byte \space) c) (<= c (byte \~))) (and (< c 256) (vim_isprintc c)))
        (ยง
            ;; printable character
            (.be transchar_buf i, c)
            (ยง transchar_buf.be(i + 1, NUL))
        )
        :else
        (ยง
            (transchar_nonprint (.plus transchar_buf i), c)
        ))

        transchar_buf
    ))

;; Like transchar(), but called with a byte instead of a character.
;; Checks for an illegal UTF-8 byte.

(defn- #_Bytes transchar_byte [#_byte b]
    (ยง
        (when (<= 0x80 (char_u b))
            (transchar_nonprint transchar_buf, (char_u b))
            ((ร RETURN) transchar_buf)
        )
        (transchar (char_u b))
    ))

;; Convert non-printable character to two or more printable characters in "buf[]".
;; "buf" needs to be able to hold five bytes.
;; Does NOT work for multi-byte characters, c must be <= 255.

(defn- #_void transchar_nonprint [#_Bytes buf, #_int c]
    (ยง
        (if (== c NL)
            ((ร c =) NUL)                                    ;; we use newline in place of a NUL
        )

        (cond (non-zero? (& @dy_flags DY_UHEX))                  ;; 'display' has "uhex"
        (ยง
            (transchar_hex buf, c)
        )
        (<= c 0x7f)                             ;; 0x00 - 0x1f and 0x7f
        (ยง
            (.be buf 0, (byte \^))
; %%        (ยง buf.be(1, (byte)(c ^ 0x40)))                          ;; DEL displayed as ^?

            (.be buf 2, NUL)
        )
        (<= 0x80 c)
        (ยง
            (transchar_hex buf, c)
        )
        (and (<= (+ (byte \space) 0x80) c) (<= c (+ (byte \~) 0x80)))    ;; 0xa0 - 0xfe
        (ยง
            (.be buf 0, (byte \|))
            (ยง buf.be(1, (byte)(c - 0x80)))
            (.be buf 2, NUL)
        )
        :else                                            ;; 0x80 - 0x9f and 0xff
        (ยง
            (.be buf 0, (byte \~))
; %%        (ยง buf.be(1, (byte)((c - 0x80) ^ 0x40)))                 ;; 0xff displayed as ~?
            (.be buf 2, NUL)
        ))
    ))

(defn- #_void transchar_hex [#_Bytes buf, #_int c]
    (ยง
        ((ร int i =) 0)

        (.be buf i, (byte \<))
        (when (< 0xff c)
            (ยง buf.be(++i, nr2hex(c >>> 12)))
            (ยง buf.be(++i, nr2hex(c >>> 8)))
        )
        (ยง buf.be(++i, nr2hex(c >>> 4)))
        (.be buf (ยง ++i), (nr2hex c))
        (.be buf (ยง ++i), (byte \>))
        (.be buf (ยง ++i), NUL)
    ))

;; Convert the lower 4 bits of byte "c" to its hex character.
;; Lower case letters are used to avoid the confusion of <F1> being 0xf1 or function key 1.

(defn- #_int nr2hex [#_int c]
    (let [n (& c 0xf)]
        (if (< n 10) (+ (byte \0) n) (+ (byte \a) (- n 10)))
    ))

;; Return number of display cells occupied by byte "b".
;; For multi-byte mode "b" must be the first byte of a character.
;; A TAB is counted as two cells: "^I".
;; For UTF-8 mode this will return 0 for bytes >= 0x80, because the number of cells depends on further bytes.

(defn- #_int mb_byte2cells [#_byte b]
    (let [i (char_u b)]
        (if (< i 0x80) (& (ยง chartab[i]) CT_CELL_MASK) 0)
    ))

;; Return number of display cells occupied by character "c".
;; "c" can be a special key (negative number) in which case 3 or 4 is returned.
;; A TAB is counted as two cells: "^I" or four: "<09>".

(defn- #_int mb_char2cells [#_int c]
    (ยง
        (if (is_special c)
            ((ร RETURN) (ยง mb_char2cells(char_u(KB_SECOND(c))) + 2))
        )

        ;; UTF-8: above 0x80 need to check the value.
        (if (<= 0x80 c)
            ((ร RETURN) (utf_char2cells c))
        )

        (ยง chartab[c & 0xff] & CT_CELL_MASK)
    ))

;; Return number of display cells occupied by character at "*p".
;; A TAB is counted as two cells: "^I" or four: "<09>".

(defn- #_int mb_ptr2cells [#_Bytes p]
    (ยง
        ;; For UTF-8 we need to look at more bytes if the first byte is >= 0x80.
        (if (<= 0x80 (char_u (ยง p.at(0))))
            ((ร RETURN) (us_ptr2cells p))
        )

        (ยง chartab[char_u(p.at(0))] & CT_CELL_MASK)
    ))

;; Return the number of character cells string "s[len]" will take on the screen,
;; counting TABs as two characters: "^I".

(defn- #_int mb_string2cells [#_Bytes p, #_int len]
    (ยง
        ((ร int cells =) 0)

        ((ร FOR) (ร (ยง int i = 0) (ยง (len < 0 || i < len) && p.at(i) != NUL) (ยง i += us_ptr2len_cc(p.plus(i))))
            ((ร cells +=) (ยง mb_ptr2cells(p.plus(i))))
        )

        cells
    ))

;; Return the number of characters 'c' will take on the screen,
;; taking into account the size of a tab.
;; Use a define to make it fast, this is used very often!!!
;; Also see getvcol() below.

(defn- #_int win_buf_chartabsize [#_window_C wp, #_buffer_C buf, #_Bytes p, #_int col]
    (ยง
        (when (== (.at p 0) TAB)
            ((ร int ts =) (ยง (int)buf.@b_p_ts))
            ((ร RETURN) (ยง ts - (col % ts)))
        )

        (mb_ptr2cells p)
    ))

(defn- #_int chartabsize [#_Bytes p, #_int col]
    (win_buf_chartabsize @curwin, @curbuf, p, col))

;; Return the number of characters the string 's' will take on the screen,
;; taking into account the size of a tab.

(defn- #_int linetabsize [#_Bytes s]
    (linetabsize_col s, 0))

;; Like linetabsize(), but starting at column "startcol".

(defn- #_int linetabsize_col [#_Bytes _s, #_int startcol]
    (ยง
; %%    ((ร Bytes[] s =) (ยง { _s }))

        ((ร int col =) startcol)

        ((ร Bytes line =) (ยง s[0]))        ;; pointer to start of line, for breakindent
        (while (ยง s[0].at(0) != NUL)
            ((ร col +=) (lbr_chartabsize_adv line, s, col))
        )

        col
    ))

;; Like linetabsize(), but for a given window instead of the current one.

(defn- #_int win_linetabsize [#_window_C wp, #_Bytes line, #_int len]
    (ยง
        ((ร int col =) 0)

        ((ร FOR) (ร (ยง Bytes s = line) (ยง s.at(0) != NUL && (len == MAXCOL || BLT(s, line.plus(len)))) (ยง s = s.plus(us_ptr2len_cc(s))))
            ((ร col +=) (win_lbr_chartabsize wp, line, s, col, null))
        )

        col
    ))

;; Return true if 'c' is a normal identifier character:
;; Letters and characters from the 'isident' option.

(defn- #_boolean vim_isIDc [#_int c]
    (ยง
        (and (< 0 c) (< c 0x100) (non-zero? (& (ยง chartab[c]) CT_ID_CHAR)))
    ))

;; Return true if 'c' is a keyword character:
;; Letters and characters from 'iskeyword' option for current buffer.
;; For multi-byte characters us_get_class() is used (builtin rules).

(defn- #_boolean vim_iswordc [#_int c, #_buffer_C buf]
    (ยง
        (if (<= 0x100 c)
            ((ร RETURN) (ยง (2 <= utf_class(c))))
        )

        (and (< 0 c) (< c 0x100) (non-zero? (get_chartab buf, c)))
    ))

(defn- #_boolean us_iswordb [#_byte b, #_buffer_C buf]
    (ยง
        (and (non-zero? b) (non-zero? (ยง get_chartab(buf, char_u(b)))))
    ))

(defn- #_boolean us_iswordp [#_Bytes p, #_buffer_C buf]
    (ยง
        (if (< 1 (us_byte2len (.at p 0), false))
            ((ร RETURN) (ยง (2 <= us_get_class(p, buf))))
        )

        (us_iswordb (.at p 0), buf)
    ))

;; Return true if 'c' is a valid file-name character.
;; Assume characters above 0x100 are valid (multi-byte).

(defn- #_boolean vim_isfilec [#_int c]
    (ยง
        (or (<= 0x100 c) (and (< 0 c) (non-zero? (& (ยง chartab[c]) CT_FNAME_CHAR))))
    ))

;; return true if 'c' is a printable character
;; Assume characters above 0x100 are printable (multi-byte), except for Unicode.

(defn- #_boolean vim_isprintc [#_int c]
    (ยง
        (if (<= 0x100 c)
            ((ร RETURN) (utf_printable c))
        )

        (or (<= 0x100 c) (and (< 0 c) (non-zero? (& (ยง chartab[c]) CT_PRINT_CHAR))))
    ))

;; like chartabsize(), but also check for line breaks on the screen

(defn- #_int lbr_chartabsize [#_Bytes line, #_Bytes s, #_int col]
    ;; line: start of the line
    (ยง
        (when (and (not @(.. @curwin w_options wo_lbr)) (eos? @p_sbr) (not @(.. @curwin w_options wo_bri)))
            (if @(.. @curwin w_options wo_wrap)
                ((ร RETURN) (win_nolbr_chartabsize @curwin, s, col, null))
            )

            ((ร RETURN) (win_buf_chartabsize @curwin, @curbuf, s, col))
        )
        (win_lbr_chartabsize @curwin, (if (nil? line) s line), s, col, null)
    ))

;; Call lbr_chartabsize() and advance the pointer.

(defn- #_int lbr_chartabsize_adv [#_Bytes line, #_Bytes* s, #_int col]
    ;; line: start of the line
    (ยง
        ((ร int retval =) (ยง lbr_chartabsize(line, s[0], col)))
        ((ร s[0] =) (ยง s[0].plus(us_ptr2len_cc(s[0]))))
        retval
    ))

;; This function is used very often, keep it fast!!!!
;;
;; If "headp" not null, set "*headp" to the size of what we for 'showbreak' string at start of line.
;; Warning: "*headp" is only set if it's a non-zero value, init to 0 before calling.

(defn- #_int win_lbr_chartabsize [#_window_C wp, #_Bytes line, #_Bytes s, #_int col, #_int* headp]
    ;; line: start of the line
    (ยง
        ((ร int col_adj =) 0)                ;; col + screen size of tab
        ((ร int mb_added =) 0)
        ((ร boolean tab_corr =) (ยง (s.at(0) == TAB)))

        ;; No 'linebreak', 'showbreak' and 'breakindent': return quickly.

        (when (and (not @(.. wp w_options wo_lbr)) (not @(.. wp w_options wo_bri)) (eos? @p_sbr))
            (if @(.. wp w_options wo_wrap)
                ((ร RETURN) (win_nolbr_chartabsize wp, s, col, headp))
            )

            ((ร RETURN) (win_buf_chartabsize wp, @curbuf, s, col))
        )

        ;; First get normal size, without 'linebreak'.

        ((ร int size =) (win_buf_chartabsize wp, @curbuf, s, col))
        ((ร byte c =) (ยง s.at(0)))
        (if tab_corr
            ((ร col_adj =) (- size 1))
        )

        ;; If 'linebreak' set check at a blank before a non-blank if the line needs a break here.

        (cond (and @(.. wp w_options wo_lbr) (ยง @breakat_flags[char_u(c)]) (not (ยง @breakat_flags[char_u(s.at(1))])) @(.. wp w_options wo_wrap) (!= (. wp w_width) 0))
        (ยง
            ;; Count all characters from first non-blank after a blank up to next non-blank after a blank.

            ((ร int numberextra =) (win_col_off wp))
            ((ร int col2 =) col)
            ((ร int colmax =) (ยง wp.w_width - numberextra - col_adj))
            (when (<= colmax col)
                ((ร colmax +=) col_adj)
                ((ร int n =) (ยง colmax +  win_col_off2(wp)))
                (if (< 0 n)
                    ((ร colmax +=) (ยง (((col - colmax) / n) + 1) * n - col_adj))
                )
            )

            (while true
                ((ร Bytes ps =) s)
                ((ร s =) (ยง s.plus(us_ptr2len_cc(s))))
                ((ร c =) (ยง s.at(0)))
                (when (not (and (!= c NUL) (or (ยง @breakat_flags[char_u(c)]) (and (not (ยง @breakat_flags[char_u(c)])) (or (== col2 col) (not (ยง @breakat_flags[char_u(ps.at(0))])))))))
                    (ร BREAK)
                )

                ((ร col2 +=) (win_buf_chartabsize wp, @curbuf, s, col2))
                (when (<= colmax col2)         ;; doesn't fit
                    ((ร size =) (ยง colmax - col + col_adj))
                    ((ร tab_corr =) false)
                    (ร BREAK)
                )
            )
        )
        (and (== size 2) (< 1 (us_byte2len (.at s 0), false)) @(.. wp w_options wo_wrap) (in_win_border wp, col))
        (ยง
            (ยง size++)         ;; Count the ">" in the last column.
            ((ร mb_added =) 1)
        ))

        ;; May have to add something for 'breakindent' and/or 'showbreak' string at start of line.
        ;; Set "*headp" to the size of what we add.

        ((ร int added =) 0)
        (when (and (or (non-eos? @p_sbr) @(.. wp w_options wo_bri)) (and @(.. wp w_options wo_wrap) (non-zero? col)))
            ((ร int sbrlen =) 0)
            ((ร int numberwidth =) (win_col_off wp))

            ((ร int numberextra =) numberwidth)
            ((ร col +=) (+ numberextra mb_added))
            (when (<= (. wp w_width) col)
                ((ร col -=) (. wp w_width))
                ((ร numberextra =) (ยง wp.w_width - (numberextra - win_col_off2(wp))))
                (if (and (>= col numberextra) (< 0 numberextra))
                    ((ร col %=) numberextra)
                )
                (when (non-eos? @p_sbr)
                    ((ร sbrlen =) (us_charlen @p_sbr))
                    (if (<= sbrlen col)
                        ((ร col -=) sbrlen)
                    )
                )
                (cond (and (>= col numberextra) (< 0 numberextra))
                (ยง
                    ((ร col %=) numberextra)
                )
                (and (< 0 col) (< 0 numberextra))
                (ยง
                    ((ร col +=) (ยง numberwidth - win_col_off2(wp)))
                ))

                ((ร numberwidth -=) (win_col_off2 wp))
            )
            (when (or (zero? col) (< (. wp w_width) (ยง col + size + sbrlen)))
                ((ร added =) 0)
                (when (non-eos? @p_sbr)
                    (cond (< (. wp w_width) (ยง size + sbrlen + numberwidth))
                    (ยง
                        ;; calculate effective window width
                        ((ร int width =) (ยง wp.w_width - sbrlen - numberwidth))
                        ((ร int prev_width =) (if (!= col 0) (- (. wp w_width) (+ sbrlen col)) 0))
                        (if (zero? width)
                            ((ร width =) (. wp w_width))
                        )
                        ((ร added +=) (ยง ((size - prev_width) / width) * mb_string2cells(@p_sbr, -1)))
                        (when (non-zero? (% (- size prev_width) width))
                            ;; wrapped, add another length of 'sbr'
                            ((ร added +=) (mb_string2cells @p_sbr, -1))
                        )
                    )
                    :else
                    (ยง
                        ((ร added +=) (mb_string2cells @p_sbr, -1))
                    ))
                )
                (if @(.. wp w_options wo_bri)
                    ((ร added +=) (get_breakindent_win wp, line))
                )

                ((ร size +=) added)
                (if (non-zero? col)
                    ((ร added =) 0)
                )
            )
        )
        (if (non-nil? headp)
            ((ร headp[0] =) (+ added mb_added))
        )

        size
    ))

;; Like win_lbr_chartabsize(), except that we know 'linebreak' is off and 'wrap' is on.
;; This means we need to check for a double-byte character that doesn't fit
;; at the end of the screen line.

(defn- #_int win_nolbr_chartabsize [#_window_C wp, #_Bytes p, #_int col, #_int* headp]
    (ยง
        (when (== (.at p 0) TAB)
            ((ร int ts =) (ยง (int)@curbuf.@b_p_ts))
            ((ร RETURN) (ยง ts - (col % ts)))
        )

        ((ร int n =) (mb_ptr2cells p))
        ;; Add one cell for a double-width character in the last column of the window,
        ;; displayed with a ">".
        (when (and (== n 2) (< 1 (us_byte2len (.at p 0), false)) (in_win_border wp, col))
            (if (non-nil? headp)
                ((ร headp[0] =) 1)
            )
            ((ร RETURN) 3)
        )
        n
    ))

;; Return true if virtual column "vcol" is in the rightmost column of window "wp".

(defn- #_boolean in_win_border [#_window_C wp, #_int vcol]
    (ยง
        (if (zero? (. wp w_width))                            ;; there is no border
            ((ร RETURN) false)
        )
        ((ร int width1 =) (ยง wp.w_width - win_col_off(wp)))      ;; width of first line (after line number)
        (if (< vcol (- width1 1))
            ((ร RETURN) false)
        )
        (if (== vcol (- width1 1))
            ((ร RETURN) true)
        )
        ((ร int width2 =) (ยง width1 + win_col_off2(wp)))         ;; width of further lines
        (if (<= width2 0)
            ((ร RETURN) false)
        )

        (ยง (vcol - width1) % width2 == width2 - 1)
    ))

;; Get virtual column number of pos.
;;  start: on the first position of this character (TAB, ctrl)
;; cursor: where the cursor is on this character (first char, except for TAB)
;;    end: on the last position of this character (TAB, ctrl)
;;
;; This is used very often, keep it fast!

(defn- #_void getvcol [#_window_C wp, #_pos_C pos, #_int* start, #_int* cursor, #_int* end]
    (ยง
        ((ร Bytes p =) (ยง ml_get_buf(@curbuf, pos.lnum)))    ;; points to current char
        ((ร Bytes line =) p)                                        ;; start of the line
        (ร Bytes posptr)                                          ;; points to char at pos.col
        (if (== (. pos col) MAXCOL)
            ((ร posptr =) null)                                      ;; continue until the NUL
            ((ร posptr =) (ยง p.plus(pos.col)))
        )

        ((ร int vcol =) 0)
        ((ร int ts =) (ยง (int)@curbuf.@b_p_ts))

        ((ร int[] head =) (ยง new int[1]))
        (ร int incr)

        ;; This function is used very often, do some speed optimizations.
        ;; When 'list', 'linebreak', 'showbreak' and 'breakindent' are not set use a simple loop.
        ;; Also use this when 'list' is set but tabs take their normal size.

        (cond (and (not @(.. wp w_options wo_lbr)) (eos? @p_sbr) (not @(.. wp w_options wo_bri)))
        (ยง
            ((ร FOR) (ร nil true (ยง p = p.plus(us_ptr2len_cc(p))))
                ((ร head[0] =) 0)
                ;; make sure we don't go past the end of the line
                (when (eos? p)
                    ((ร incr =) 1)       ;; NUL at end of line only takes one column
                    (ร BREAK)
                )
                ;; A tab gets expanded, depending on the current column.
                (cond (== (.at p 0) TAB)
                (ยง
                    ((ร incr =) (ยง ts - (vcol % ts)))
                )
                :else
                (ยง
                    ((ร incr =) (mb_ptr2cells p))

                    ;; If a double-cell char doesn't fit at the end of a line,
                    ;; it wraps to the next line, it's like this char is three cells wide.
                    (when (and (== incr 2) @(.. wp w_options wo_wrap) (< 1 (us_byte2len (.at p 0), false)) (in_win_border wp, vcol))
                        (ยง incr++)
                        ((ร head[0] =) 1)
                    )
                ))

                (if (and (non-nil? posptr) (BLE posptr, p))  ;; character at pos.col
                    (ร BREAK)
                )

                ((ร vcol +=) incr)
            )
        )
        :else
        (ยง
            ((ร FOR) (ร nil true (ยง p = p.plus(us_ptr2len_cc(p))))
                ;; A tab gets expanded, depending on the current column.
                ((ร head[0] =) 0)
                ((ร incr =) (win_lbr_chartabsize wp, line, p, vcol, head))
                ;; make sure we don't go past the end of the line
                (when (eos? p)
                    ((ร incr =) 1)       ;; NUL at end of line only takes one column
                    (ร BREAK)
                )

                (if (and (non-nil? posptr) (BLE posptr, p))  ;; character at pos.col
                    (ร BREAK)
                )

                ((ร vcol +=) incr)
            )
        ))
        (if (non-nil? start)
            ((ร start[0] =) (ยง vcol + head[0]))
        )
        (if (non-nil? end)
            ((ร end[0] =) (ยง vcol + incr - 1))
        )
        (when (non-nil? cursor)
            (cond (and (== (.at p 0) TAB) (non-zero? (& @State NORMAL)) (not (virtual_active)) (not (and @VIsual_active (or (== (.at @p_sel 0) (byte \e)) (ltoreq pos, @VIsual)))))
            (ยง
                ((ร cursor[0] =) (ยง vcol + incr - 1))        ;; cursor at end
            )
            :else
            (ยง
                ((ร cursor[0] =) (ยง vcol + head[0]))         ;; cursor at start
            ))
        )
    ))

;; Get virtual cursor column in the current window, pretending 'list' is off.

(defn- #_int getvcol_nolist [#_pos_C posp]
    (ยง
        ((ร int[] vcol =) (ยง new int[1]))
        (getvcol @curwin, posp, null, vcol, null)
        (ยง vcol[0])
    ))

;; Get virtual column in virtual mode.

(defn- #_void getvvcol [#_window_C wp, #_pos_C pos, #_int* start, #_int* cursor, #_int* end]
    (ยง
        (cond (virtual_active)
        (ยง
            ;; For virtual mode, only want one value.
            ((ร int[] col =) (ยง new int[1]))
            (getvcol wp, pos, col, null, null)
            ((ร int coladd =) (. pos coladd))
            ((ร int endadd =) 0)

            ;; Cannot put the cursor on part of a wide character.
            ((ร Bytes ptr =) (ยง ml_get_buf(@curbuf, pos.lnum)))
            (when (< (. pos col) (STRLEN ptr))
                ((ร int c =) (ยง us_ptr2char(ptr.plus(pos.col))))

                (when (and (!= c TAB) (vim_isprintc c))
                    ((ร endadd =) (ยง mb_char2cells(c) - 1))
                    (if (< endadd coladd)    ;; past end of line
                        ((ร endadd =) 0)
                        ((ร coladd =) 0)
                    )
                )
            )
            ((ร col[0] +=) coladd)
            (if (non-nil? start)
                ((ร start[0] =) (ยง col[0]))
            )
            (if (non-nil? cursor)
                ((ร cursor[0] =) (ยง col[0]))
            )
            (if (non-nil? end)
                ((ร end[0] =) (ยง col[0] + endadd))
            )
        )
        :else
        (ยง
            (getvcol wp, pos, start, cursor, end)
        ))
    ))

;; Get the leftmost and rightmost virtual column of pos1 and pos2.
;; Used for Visual block mode.

(defn- #_void getvcols [#_window_C wp, #_pos_C pos1, #_pos_C pos2, #_int* left, #_int* right]
    (ยง
        ((ร int[] from1 =) (ยง new int[1]))
        ((ร int[] from2 =) (ยง new int[1]))
        ((ร int[] to1 =) (ยง new int[1]))
        ((ร int[] to2 =) (ยง new int[1]))

        (cond (ltpos pos1, pos2)
        (ยง
            (getvvcol wp, pos1, from1, null, to1)
            (getvvcol wp, pos2, from2, null, to2)
        )
        :else
        (ยง
            (getvvcol wp, pos2, from1, null, to1)
            (getvvcol wp, pos1, from2, null, to2)
        ))
        (if (< (ยง from2[0]) (ยง from1[0]))
            ((ร left[0] =) (ยง from2[0]))
            ((ร left[0] =) (ยง from1[0]))
        )
        (cond (< (ยง to1[0]) (ยง to2[0]))
        (ยง
            (if (and (== (.at @p_sel 0) (byte \e)) (<= (ยง to1[0]) (- (ยง from2[0]) 1)))
                ((ร right[0] =) (ยง from2[0] - 1))
                ((ร right[0] =) (ยง to2[0]))
            )
        )
        :else
        (ยง
            ((ร right[0] =) (ยง to1[0]))
        ))
    ))

;; Skip over ' ' and '\t'.

(defn- #_Bytes skipwhite [#_Bytes q]
    (ยง
        ((ร Bytes p =) q)

        (while (ยง vim_iswhite(p.at(0)))
            ((ร p =) (ยง p.plus(1)))
        )    ;; skip to next non-white
        p
    ))

;; skip over digits

(defn- #_Bytes skipdigits [#_Bytes q]
    (ยง
        ((ร Bytes p =) q)

        (while (ยง asc_isdigit(p.at(0)))
            ((ร p =) (ยง p.plus(1)))
        )    ;; skip to next non-digit
        p
    ))

;; Variant of isdigit() that can handle characters > 0x100.
;; We don't use isdigit() here, because on some systems it also considers
;; superscript 1 to be a digit.

(defn- #_boolean asc_isdigit [#_int c]
    (and (<= (byte \0) c) (<= c (byte \9))))

(defn- #_boolean asc_isodigit [#_int c]
    (and (<= (byte \0) c) (<= c (byte \7))))

;; Variant of isxdigit() that can handle characters > 0x100.
;; We don't use isxdigit() here, because on some systems it also considers
;; superscript 1 to be a digit.

(defn- #_boolean asc_isxdigit [#_int c]
    (ยง
        (ยง ((byte \0) <= c && c <= (byte \9)) || ((byte \a) <= c && c <= (byte \f)) || ((byte \A) <= c && c <= (byte \F)))
    ))

;; Getdigits: Get a number from a string and skip over it.
;; Note: the argument is a pointer to a byte pointer!

(defn- #_long getdigits [#_Bytes* pp]
    (ยง
        ((ร Bytes p =) (ยง pp[0]))
        ((ร long retval =) (ยง libC.atol(p)))
        (if (== (.at p 0) (byte \-))                  ;; skip negative sign
            ((ร p =) (ยง p.plus(1)))
        )
        ((ร p =) (skipdigits p))              ;; skip to next non-digit
        ((ร pp[0] =) p)

        retval
    ))

;; Convert a string into a long and/or unsigned long, taking care of
;; hexadecimal and octal numbers.  Accepts a '-' sign.
;; If "hexp" is not null, returns a flag to indicate the type of the number:
;;  0       decimal
;;  '0'     octal
;;  'X'     hex
;;  'x'     hex
;; If "len" is not null, the length of the number in characters is returned.
;; If "nptr" is not null, the signed result is returned in it.
;; If "unptr" is not null, the unsigned result is returned in it.
;; If "dooct" is non-zero recognize octal numbers, when > 1 always assume octal number.
;; If "dohex" is non-zero recognize hex numbers, when > 1 always assume hex number.

(defn- #_void vim_str2nr [#_Bytes start, #_int* hexp, #_int* len, #_int dooct, #_int dohex, #_long* nptr]
    ;; hexp: return: type of number 0 = decimal, 'x' or 'X' is hex, '0' = octal
    ;; len: return: detected length of number
    ;; dooct: recognize octal number
    ;; dohex: recognize hex number
    ;; nptr: return: signed result
    (ยง
        ((ร Bytes ptr =) start)

        ((ร boolean negative =) false)
        (when (== (.at ptr 0) (byte \-))
            ((ร negative =) true)
            ((ร ptr =) (ยง ptr.plus(1)))
        )

        ((ร int hex =) 0)                        ;; default is decimal

        ;; Recognize hex and octal.
        (when (and (== (.at ptr 0) (byte \0)) (!= (.at ptr 1) (byte \8)) (!= (.at ptr 1) (byte \9)))
            ((ร hex =) (ยง ptr.at(1)))
            (cond (and (non-zero? dohex) (or (== hex (byte \X)) (== hex (byte \x))) (asc_isxdigit (ยง ptr.at(2))))
            (ยง
                ((ร ptr =) (ยง ptr.plus(2)))          ;; hexadecimal
            )
            :else
            (ยง
                ((ร hex =) 0)                    ;; default is decimal
                (when (non-zero? dooct)
                    ;; Don't interpret "0", "08" or "0129" as octal.
                    ((ร FOR) (ร (ยง int n = 1) (ยง asc_isdigit(ptr.at(n))) (ยง n++))
                        (when (< (byte \7) (.at ptr n))
                            ((ร hex =) 0)        ;; can't be octal
                            (ร BREAK)
                        )
                        (if (<= (byte \0) (.at ptr n))
                            ((ร hex =) (byte \0))      ;; assume octal
                        )
                    )
                )
            ))
        )

        ((ร long nr =) 0)

        ;; Do the string-to-numeric conversion "manually" to avoid sscanf quirks.

        (cond (or (== hex (byte \0)) (< 1 dooct))
        (ยง
            ((ร FOR) (ร (ยง  ) (ยง asc_isodigit(ptr.at(0))) (ยง ptr = ptr.plus(1)))         ;; octal
                ((ร long l =) (ยง 8 * nr + (long)(ptr.at(0) - (byte \0))))
                (if (< l nr)
                    (ร BREAK)
                )
                ((ร nr =) l)
            )
        )
        (or (non-zero? hex) (< 1 dohex))
        (ยง
            ((ร FOR) (ร (ยง  ) (ยง asc_isxdigit(ptr.at(0))) (ยง ptr = ptr.plus(1)))         ;; hex
                ((ร long l =) (ยง 16 * nr + (long)hex2nr(ptr.at(0))))
                (if (< l nr)
                    (ร BREAK)
                )
                ((ร nr =) l)
            )
        )
        :else
        (ยง
            ((ร FOR) (ร (ยง  ) (ยง asc_isdigit(ptr.at(0))) (ยง ptr = ptr.plus(1)))          ;; decimal
                ((ร long l =) (ยง 10 * nr + (long)(ptr.at(0) - (byte \0))))
                (if (< l nr)
                    (ร BREAK)
                )
                ((ร nr =) l)
            )
        ))

        (if (non-nil? hexp)
            ((ร hexp[0] =) hex)
        )
        (if (non-nil? len)
            ((ร len[0] =) (BDIFF ptr, start))
        )
        (when (non-nil? nptr)
            (if negative               ;; account for leading '-' for decimal numbers
                ((ร nptr[0] =) (ยง -nr))
                ((ร nptr[0] =) nr)
            )
        )
    ))

;; Return the value of a single hex character.
;; Only valid when the argument is '0' - '9', 'A' - 'F' or 'a' - 'f'.

(defn- #_int hex2nr [#_int c]
    (ยง
        (if (and (<= (byte \a) c) (<= c (byte \f)))
            ((ร RETURN) (ยง c - (byte \a) + 10))
        )
        (if (and (<= (byte \A) c) (<= c (byte \F)))
            ((ร RETURN) (ยง c - (byte \A) + 10))
        )

        (- c (byte \0))
    ))

;;; ============================================================================================== VimR

;; digraph.c: code for digraphs -------------------------------------------------------------------

(class! #_final digr_C
    [
        (field byte     char1)
        (field byte     char2)
        (field int      result)
    ])

(defn- #_final #_digr_C digr [#_"/*byte*/char" char1, #_"/*byte*/char" char2, #_int result]
    (ยง
        (ยง new digr_C((byte)char1, (byte)char2, result))
    ))

;; digraphs for Unicode from RFC1345 (also work for ISO-8859-1 aka latin1)
(final digr_C* digraphdefault
    [
        (digr \N, \U, 0x0a),       ;; LF for NUL
        (digr \S, \H, 0x01),
        (digr \S, \X, 0x02),
        (digr \E, \X, 0x03),
        (digr \E, \T, 0x04),
        (digr \E, \Q, 0x05),
        (digr \A, \K, 0x06),
        (digr \B, \L, 0x07),
        (digr \B, \S, 0x08),
        (digr \H, \T, 0x09),
        (digr \L, \F, 0x0a),
        (digr \V, \T, 0x0b),
        (digr \F, \F, 0x0c),
        (digr \C, \R, 0x0d),
        (digr \S, \O, 0x0e),
        (digr \S, \I, 0x0f),
        (digr \D, \L, 0x10),
        (digr \D, \1, 0x11),
        (digr \D, \2, 0x12),
        (digr \D, \3, 0x13),
        (digr \D, \4, 0x14),
        (digr \N, \K, 0x15),
        (digr \S, \Y, 0x16),
        (digr \E, \B, 0x17),
        (digr \C, \N, 0x18),
        (digr \E, \M, 0x19),
        (digr \S, \B, 0x1a),
        (digr \E, \C, 0x1b),
        (digr \F, \S, 0x1c),
        (digr \G, \S, 0x1d),
        (digr \R, \S, 0x1e),
        (digr \U, \S, 0x1f),
        (digr \S, \P, 0x20),
        (digr \N, \b, 0x23),
        (digr \D, \O, 0x24),
        (digr \A, \t, 0x40),
        (digr \<, \(, 0x5b),
        (digr \/, \/, 0x5c),
        (digr \), \>, 0x5d),
        (digr \', \>, 0x5e),
        (digr \', \!, 0x60),
        (digr \(, \!, 0x7b),
        (digr \!, \!, 0x7c),
        (digr \!, \), 0x7d),
        (digr \', \?, 0x7e),
        (digr \D, \T, 0x7f),
        (digr \P, \A, 0x80),
        (digr \H, \O, 0x81),
        (digr \B, \H, 0x82),
        (digr \N, \H, 0x83),
        (digr \I, \N, 0x84),
        (digr \N, \L, 0x85),
        (digr \S, \A, 0x86),
        (digr \E, \S, 0x87),
        (digr \H, \S, 0x88),
        (digr \H, \J, 0x89),
        (digr \V, \S, 0x8a),
        (digr \P, \D, 0x8b),
        (digr \P, \U, 0x8c),
        (digr \R, \I, 0x8d),
        (digr \S, \2, 0x8e),
        (digr \S, \3, 0x8f),
        (digr \D, \C, 0x90),
        (digr \P, \1, 0x91),
        (digr \P, \2, 0x92),
        (digr \T, \S, 0x93),
        (digr \C, \C, 0x94),
        (digr \M, \W, 0x95),
        (digr \S, \G, 0x96),
        (digr \E, \G, 0x97),
        (digr \S, \S, 0x98),
        (digr \G, \C, 0x99),
        (digr \S, \C, 0x9a),
        (digr \C, \I, 0x9b),
        (digr \S, \T, 0x9c),
        (digr \O, \C, 0x9d),
        (digr \P, \M, 0x9e),
        (digr \A, \C, 0x9f),
        (digr \N, \S, 0xa0),
        (digr \!, \I, 0xa1),
        (digr \C, \t, 0xa2),
        (digr \P, \d, 0xa3),
        (digr \C, \u, 0xa4),
        (digr \Y, \e, 0xa5),
        (digr \B, \B, 0xa6),
        (digr \S, \E, 0xa7),
        (digr \', \:, 0xa8),
        (digr \C, \o, 0xa9),
        (digr \-, \a, 0xaa),
        (digr \<, \<, 0xab),
        (digr \N, \O, 0xac),
        (digr \-, \-, 0xad),
        (digr \R, \g, 0xae),
        (digr \', \m, 0xaf),
        (digr \D, \G, 0xb0),
        (digr \+, \-, 0xb1),
        (digr \2, \S, 0xb2),
        (digr \3, \S, 0xb3),
        (digr \', \', 0xb4),
        (digr \M, \y, 0xb5),
        (digr \P, \I, 0xb6),
        (digr \., \M, 0xb7),
        (digr \', \,, 0xb8),
        (digr \1, \S, 0xb9),
        (digr \-, \o, 0xba),
        (digr \>, \>, 0xbb),
        (digr \1, \4, 0xbc),
        (digr \1, \2, 0xbd),
        (digr \3, \4, 0xbe),
        (digr \?, \I, 0xbf),
        (digr \A, \!, 0xc0),
        (digr \A, \', 0xc1),
        (digr \A, \>, 0xc2),
        (digr \A, \?, 0xc3),
        (digr \A, \:, 0xc4),
        (digr \A, \A, 0xc5),
        (digr \A, \E, 0xc6),
        (digr \C, \,, 0xc7),
        (digr \E, \!, 0xc8),
        (digr \E, \', 0xc9),
        (digr \E, \>, 0xca),
        (digr \E, \:, 0xcb),
        (digr \I, \!, 0xcc),
        (digr \I, \', 0xcd),
        (digr \I, \>, 0xce),
        (digr \I, \:, 0xcf),
        (digr \D, \-, 0xd0),
        (digr \N, \?, 0xd1),
        (digr \O, \!, 0xd2),
        (digr \O, \', 0xd3),
        (digr \O, \>, 0xd4),
        (digr \O, \?, 0xd5),
        (digr \O, \:, 0xd6),
        (digr \*, \X, 0xd7),
        (digr \O, \/, 0xd8),
        (digr \U, \!, 0xd9),
        (digr \U, \', 0xda),
        (digr \U, \>, 0xdb),
        (digr \U, \:, 0xdc),
        (digr \Y, \', 0xdd),
        (digr \T, \H, 0xde),
        (digr \s, \s, 0xdf),
        (digr \a, \!, 0xe0),
        (digr \a, \', 0xe1),
        (digr \a, \>, 0xe2),
        (digr \a, \?, 0xe3),
        (digr \a, \:, 0xe4),
        (digr \a, \a, 0xe5),
        (digr \a, \e, 0xe6),
        (digr \c, \,, 0xe7),
        (digr \e, \!, 0xe8),
        (digr \e, \', 0xe9),
        (digr \e, \>, 0xea),
        (digr \e, \:, 0xeb),
        (digr \i, \!, 0xec),
        (digr \i, \', 0xed),
        (digr \i, \>, 0xee),
        (digr \i, \:, 0xef),
        (digr \d, \-, 0xf0),
        (digr \n, \?, 0xf1),
        (digr \o, \!, 0xf2),
        (digr \o, \', 0xf3),
        (digr \o, \>, 0xf4),
        (digr \o, \?, 0xf5),
        (digr \o, \:, 0xf6),
        (digr \-, \:, 0xf7),
        (digr \o, \/, 0xf8),
        (digr \u, \!, 0xf9),
        (digr \u, \', 0xfa),
        (digr \u, \>, 0xfb),
        (digr \u, \:, 0xfc),
        (digr \y, \', 0xfd),
        (digr \t, \h, 0xfe),
        (digr \y, \:, 0xff),

        (digr \A, \-, 0x0100),
        (digr \a, \-, 0x0101),
        (digr \A, \(, 0x0102),
        (digr \a, \(, 0x0103),
        (digr \A, \;, 0x0104),
        (digr \a, \;, 0x0105),
        (digr \C, \', 0x0106),
        (digr \c, \', 0x0107),
        (digr \C, \>, 0x0108),
        (digr \c, \>, 0x0109),
        (digr \C, \., 0x010a),
        (digr \c, \., 0x010b),
        (digr \C, \<, 0x010c),
        (digr \c, \<, 0x010d),
        (digr \D, \<, 0x010e),
        (digr \d, \<, 0x010f),
        (digr \D, \/, 0x0110),
        (digr \d, \/, 0x0111),
        (digr \E, \-, 0x0112),
        (digr \e, \-, 0x0113),
        (digr \E, \(, 0x0114),
        (digr \e, \(, 0x0115),
        (digr \E, \., 0x0116),
        (digr \e, \., 0x0117),
        (digr \E, \;, 0x0118),
        (digr \e, \;, 0x0119),
        (digr \E, \<, 0x011a),
        (digr \e, \<, 0x011b),
        (digr \G, \>, 0x011c),
        (digr \g, \>, 0x011d),
        (digr \G, \(, 0x011e),
        (digr \g, \(, 0x011f),
        (digr \G, \., 0x0120),
        (digr \g, \., 0x0121),
        (digr \G, \,, 0x0122),
        (digr \g, \,, 0x0123),
        (digr \H, \>, 0x0124),
        (digr \h, \>, 0x0125),
        (digr \H, \/, 0x0126),
        (digr \h, \/, 0x0127),
        (digr \I, \?, 0x0128),
        (digr \i, \?, 0x0129),
        (digr \I, \-, 0x012a),
        (digr \i, \-, 0x012b),
        (digr \I, \(, 0x012c),
        (digr \i, \(, 0x012d),
        (digr \I, \;, 0x012e),
        (digr \i, \;, 0x012f),
        (digr \I, \., 0x0130),
        (digr \i, \., 0x0131),
        (digr \I, \J, 0x0132),
        (digr \i, \j, 0x0133),
        (digr \J, \>, 0x0134),
        (digr \j, \>, 0x0135),
        (digr \K, \,, 0x0136),
        (digr \k, \,, 0x0137),
        (digr \k, \k, 0x0138),
        (digr \L, \', 0x0139),
        (digr \l, \', 0x013a),
        (digr \L, \,, 0x013b),
        (digr \l, \,, 0x013c),
        (digr \L, \<, 0x013d),
        (digr \l, \<, 0x013e),
        (digr \L, \., 0x013f),
        (digr \l, \., 0x0140),
        (digr \L, \/, 0x0141),
        (digr \l, \/, 0x0142),
        (digr \N, \', 0x0143),
        (digr \n, \', 0x0144),
        (digr \N, \,, 0x0145),
        (digr \n, \,, 0x0146),
        (digr \N, \<, 0x0147),
        (digr \n, \<, 0x0148),
        (digr \', \n, 0x0149),
        (digr \N, \G, 0x014a),
        (digr \n, \g, 0x014b),
        (digr \O, \-, 0x014c),
        (digr \o, \-, 0x014d),
        (digr \O, \(, 0x014e),
        (digr \o, \(, 0x014f),
        (digr \O, \", 0x0150),  ;; """
        (digr \o, \", 0x0151),  ;; """
        (digr \O, \E, 0x0152),
        (digr \o, \e, 0x0153),
        (digr \R, \', 0x0154),
        (digr \r, \', 0x0155),
        (digr \R, \,, 0x0156),
        (digr \r, \,, 0x0157),
        (digr \R, \<, 0x0158),
        (digr \r, \<, 0x0159),
        (digr \S, \', 0x015a),
        (digr \s, \', 0x015b),
        (digr \S, \>, 0x015c),
        (digr \s, \>, 0x015d),
        (digr \S, \,, 0x015e),
        (digr \s, \,, 0x015f),
        (digr \S, \<, 0x0160),
        (digr \s, \<, 0x0161),
        (digr \T, \,, 0x0162),
        (digr \t, \,, 0x0163),
        (digr \T, \<, 0x0164),
        (digr \t, \<, 0x0165),
        (digr \T, \/, 0x0166),
        (digr \t, \/, 0x0167),
        (digr \U, \?, 0x0168),
        (digr \u, \?, 0x0169),
        (digr \U, \-, 0x016a),
        (digr \u, \-, 0x016b),
        (digr \U, \(, 0x016c),
        (digr \u, \(, 0x016d),
        (digr \U, \0, 0x016e),
        (digr \u, \0, 0x016f),
        (digr \U, \", 0x0170),  ;; """
        (digr \u, \", 0x0171),  ;; """
        (digr \U, \;, 0x0172),
        (digr \u, \;, 0x0173),
        (digr \W, \>, 0x0174),
        (digr \w, \>, 0x0175),
        (digr \Y, \>, 0x0176),
        (digr \y, \>, 0x0177),
        (digr \Y, \:, 0x0178),
        (digr \Z, \', 0x0179),
        (digr \z, \', 0x017a),
        (digr \Z, \., 0x017b),
        (digr \z, \., 0x017c),
        (digr \Z, \<, 0x017d),
        (digr \z, \<, 0x017e),
        (digr \O, \9, 0x01a0),
        (digr \o, \9, 0x01a1),
        (digr \O, \I, 0x01a2),
        (digr \o, \i, 0x01a3),
        (digr \y, \r, 0x01a6),
        (digr \U, \9, 0x01af),
        (digr \u, \9, 0x01b0),
        (digr \Z, \/, 0x01b5),
        (digr \z, \/, 0x01b6),
        (digr \E, \D, 0x01b7),
        (digr \A, \<, 0x01cd),
        (digr \a, \<, 0x01ce),
        (digr \I, \<, 0x01cf),
        (digr \i, \<, 0x01d0),
        (digr \O, \<, 0x01d1),
        (digr \o, \<, 0x01d2),
        (digr \U, \<, 0x01d3),
        (digr \u, \<, 0x01d4),
        (digr \A, \1, 0x01de),
        (digr \a, \1, 0x01df),
        (digr \A, \7, 0x01e0),
        (digr \a, \7, 0x01e1),
        (digr \A, \3, 0x01e2),
        (digr \a, \3, 0x01e3),
        (digr \G, \/, 0x01e4),
        (digr \g, \/, 0x01e5),
        (digr \G, \<, 0x01e6),
        (digr \g, \<, 0x01e7),
        (digr \K, \<, 0x01e8),
        (digr \k, \<, 0x01e9),
        (digr \O, \;, 0x01ea),
        (digr \o, \;, 0x01eb),
        (digr \O, \1, 0x01ec),
        (digr \o, \1, 0x01ed),
        (digr \E, \Z, 0x01ee),
        (digr \e, \z, 0x01ef),
        (digr \j, \<, 0x01f0),
        (digr \G, \', 0x01f4),
        (digr \g, \', 0x01f5),
        (digr \;, \S, 0x02bf),
        (digr \', \<, 0x02c7),
        (digr \', \(, 0x02d8),
        (digr \', \., 0x02d9),
        (digr \', \0, 0x02da),
        (digr \', \;, 0x02db),
        (digr \', \", 0x02dd),  ;; """
        (digr \A, \%, 0x0386),
        (digr \E, \%, 0x0388),
        (digr \Y, \%, 0x0389),
        (digr \I, \%, 0x038a),
        (digr \O, \%, 0x038c),
        (digr \U, \%, 0x038e),
        (digr \W, \%, 0x038f),
        (digr \i, \3, 0x0390),
        (digr \A, \*, 0x0391),
        (digr \B, \*, 0x0392),
        (digr \G, \*, 0x0393),
        (digr \D, \*, 0x0394),
        (digr \E, \*, 0x0395),
        (digr \Z, \*, 0x0396),
        (digr \Y, \*, 0x0397),
        (digr \H, \*, 0x0398),
        (digr \I, \*, 0x0399),
        (digr \K, \*, 0x039a),
        (digr \L, \*, 0x039b),
        (digr \M, \*, 0x039c),
        (digr \N, \*, 0x039d),
        (digr \C, \*, 0x039e),
        (digr \O, \*, 0x039f),
        (digr \P, \*, 0x03a0),
        (digr \R, \*, 0x03a1),
        (digr \S, \*, 0x03a3),
        (digr \T, \*, 0x03a4),
        (digr \U, \*, 0x03a5),
        (digr \F, \*, 0x03a6),
        (digr \X, \*, 0x03a7),
        (digr \Q, \*, 0x03a8),
        (digr \W, \*, 0x03a9),
        (digr \J, \*, 0x03aa),
        (digr \V, \*, 0x03ab),
        (digr \a, \%, 0x03ac),
        (digr \e, \%, 0x03ad),
        (digr \y, \%, 0x03ae),
        (digr \i, \%, 0x03af),
        (digr \u, \3, 0x03b0),
        (digr \a, \*, 0x03b1),
        (digr \b, \*, 0x03b2),
        (digr \g, \*, 0x03b3),
        (digr \d, \*, 0x03b4),
        (digr \e, \*, 0x03b5),
        (digr \z, \*, 0x03b6),
        (digr \y, \*, 0x03b7),
        (digr \h, \*, 0x03b8),
        (digr \i, \*, 0x03b9),
        (digr \k, \*, 0x03ba),
        (digr \l, \*, 0x03bb),
        (digr \m, \*, 0x03bc),
        (digr \n, \*, 0x03bd),
        (digr \c, \*, 0x03be),
        (digr \o, \*, 0x03bf),
        (digr \p, \*, 0x03c0),
        (digr \r, \*, 0x03c1),
        (digr \*, \s, 0x03c2),
        (digr \s, \*, 0x03c3),
        (digr \t, \*, 0x03c4),
        (digr \u, \*, 0x03c5),
        (digr \f, \*, 0x03c6),
        (digr \x, \*, 0x03c7),
        (digr \q, \*, 0x03c8),
        (digr \w, \*, 0x03c9),
        (digr \j, \*, 0x03ca),
        (digr \v, \*, 0x03cb),
        (digr \o, \%, 0x03cc),
        (digr \u, \%, 0x03cd),
        (digr \w, \%, 0x03ce),
        (digr \', \G, 0x03d8),
        (digr \,, \G, 0x03d9),
        (digr \T, \3, 0x03da),
        (digr \t, \3, 0x03db),
        (digr \M, \3, 0x03dc),
        (digr \m, \3, 0x03dd),
        (digr \K, \3, 0x03de),
        (digr \k, \3, 0x03df),
        (digr \P, \3, 0x03e0),
        (digr \p, \3, 0x03e1),
        (digr \', \%, 0x03f4),
        (digr \j, \3, 0x03f5),
        (digr \I, \O, 0x0401),
        (digr \D, \%, 0x0402),
        (digr \G, \%, 0x0403),
        (digr \I, \E, 0x0404),
        (digr \D, \S, 0x0405),
        (digr \I, \I, 0x0406),
        (digr \Y, \I, 0x0407),
        (digr \J, \%, 0x0408),
        (digr \L, \J, 0x0409),
        (digr \N, \J, 0x040a),
        (digr \T, \s, 0x040b),
        (digr \K, \J, 0x040c),
        (digr \V, \%, 0x040e),
        (digr \D, \Z, 0x040f),
        (digr \A, \=, 0x0410),
        (digr \B, \=, 0x0411),
        (digr \V, \=, 0x0412),
        (digr \G, \=, 0x0413),
        (digr \D, \=, 0x0414),
        (digr \E, \=, 0x0415),
        (digr \Z, \%, 0x0416),
        (digr \Z, \=, 0x0417),
        (digr \I, \=, 0x0418),
        (digr \J, \=, 0x0419),
        (digr \K, \=, 0x041a),
        (digr \L, \=, 0x041b),
        (digr \M, \=, 0x041c),
        (digr \N, \=, 0x041d),
        (digr \O, \=, 0x041e),
        (digr \P, \=, 0x041f),
        (digr \R, \=, 0x0420),
        (digr \S, \=, 0x0421),
        (digr \T, \=, 0x0422),
        (digr \U, \=, 0x0423),
        (digr \F, \=, 0x0424),
        (digr \H, \=, 0x0425),
        (digr \C, \=, 0x0426),
        (digr \C, \%, 0x0427),
        (digr \S, \%, 0x0428),
        (digr \S, \c, 0x0429),
        (digr \=, \", 0x042a),  ;; """
        (digr \Y, \=, 0x042b),
        (digr \%, \", 0x042c),  ;; """
        (digr \J, \E, 0x042d),
        (digr \J, \U, 0x042e),
        (digr \J, \A, 0x042f),
        (digr \a, \=, 0x0430),
        (digr \b, \=, 0x0431),
        (digr \v, \=, 0x0432),
        (digr \g, \=, 0x0433),
        (digr \d, \=, 0x0434),
        (digr \e, \=, 0x0435),
        (digr \z, \%, 0x0436),
        (digr \z, \=, 0x0437),
        (digr \i, \=, 0x0438),
        (digr \j, \=, 0x0439),
        (digr \k, \=, 0x043a),
        (digr \l, \=, 0x043b),
        (digr \m, \=, 0x043c),
        (digr \n, \=, 0x043d),
        (digr \o, \=, 0x043e),
        (digr \p, \=, 0x043f),
        (digr \r, \=, 0x0440),
        (digr \s, \=, 0x0441),
        (digr \t, \=, 0x0442),
        (digr \u, \=, 0x0443),
        (digr \f, \=, 0x0444),
        (digr \h, \=, 0x0445),
        (digr \c, \=, 0x0446),
        (digr \c, \%, 0x0447),
        (digr \s, \%, 0x0448),
        (digr \s, \c, 0x0449),
        (digr \=, \', 0x044a),
        (digr \y, \=, 0x044b),
        (digr \%, \', 0x044c),
        (digr \j, \e, 0x044d),
        (digr \j, \u, 0x044e),
        (digr \j, \a, 0x044f),
        (digr \i, \o, 0x0451),
        (digr \d, \%, 0x0452),
        (digr \g, \%, 0x0453),
        (digr \i, \e, 0x0454),
        (digr \d, \s, 0x0455),
        (digr \i, \i, 0x0456),
        (digr \y, \i, 0x0457),
        (digr \j, \%, 0x0458),
        (digr \l, \j, 0x0459),
        (digr \n, \j, 0x045a),
        (digr \t, \s, 0x045b),
        (digr \k, \j, 0x045c),
        (digr \v, \%, 0x045e),
        (digr \d, \z, 0x045f),
        (digr \Y, \3, 0x0462),
        (digr \y, \3, 0x0463),
        (digr \O, \3, 0x046a),
        (digr \o, \3, 0x046b),
        (digr \F, \3, 0x0472),
        (digr \f, \3, 0x0473),
        (digr \V, \3, 0x0474),
        (digr \v, \3, 0x0475),
        (digr \C, \3, 0x0480),
        (digr \c, \3, 0x0481),
        (digr \G, \3, 0x0490),
        (digr \g, \3, 0x0491),
        (digr \A, \+, 0x05d0),
        (digr \B, \+, 0x05d1),
        (digr \G, \+, 0x05d2),
        (digr \D, \+, 0x05d3),
        (digr \H, \+, 0x05d4),
        (digr \W, \+, 0x05d5),
        (digr \Z, \+, 0x05d6),
        (digr \X, \+, 0x05d7),
        (digr \T, \j, 0x05d8),
        (digr \J, \+, 0x05d9),
        (digr \K, \%, 0x05da),
        (digr \K, \+, 0x05db),
        (digr \L, \+, 0x05dc),
        (digr \M, \%, 0x05dd),
        (digr \M, \+, 0x05de),
        (digr \N, \%, 0x05df),
        (digr \N, \+, 0x05e0),
        (digr \S, \+, 0x05e1),
        (digr \E, \+, 0x05e2),
        (digr \P, \%, 0x05e3),
        (digr \P, \+, 0x05e4),
        (digr \Z, \j, 0x05e5),
        (digr \Z, \J, 0x05e6),
        (digr \Q, \+, 0x05e7),
        (digr \R, \+, 0x05e8),
        (digr \S, \h, 0x05e9),
        (digr \T, \+, 0x05ea),
        (digr \,, \+, 0x060c),
        (digr \;, \+, 0x061b),
        (digr \?, \+, 0x061f),
        (digr \H, \', 0x0621),
        (digr \a, \M, 0x0622),
        (digr \a, \H, 0x0623),
        (digr \w, \H, 0x0624),
        (digr \a, \h, 0x0625),
        (digr \y, \H, 0x0626),
        (digr \a, \+, 0x0627),
        (digr \b, \+, 0x0628),
        (digr \t, \m, 0x0629),
        (digr \t, \+, 0x062a),
        (digr \t, \k, 0x062b),
        (digr \g, \+, 0x062c),
        (digr \h, \k, 0x062d),
        (digr \x, \+, 0x062e),
        (digr \d, \+, 0x062f),
        (digr \d, \k, 0x0630),
        (digr \r, \+, 0x0631),
        (digr \z, \+, 0x0632),
        (digr \s, \+, 0x0633),
        (digr \s, \n, 0x0634),
        (digr \c, \+, 0x0635),
        (digr \d, \d, 0x0636),
        (digr \t, \j, 0x0637),
        (digr \z, \H, 0x0638),
        (digr \e, \+, 0x0639),
        (digr \i, \+, 0x063a),
        (digr \+, \+, 0x0640),
        (digr \f, \+, 0x0641),
        (digr \q, \+, 0x0642),
        (digr \k, \+, 0x0643),
        (digr \l, \+, 0x0644),
        (digr \m, \+, 0x0645),
        (digr \n, \+, 0x0646),
        (digr \h, \+, 0x0647),
        (digr \w, \+, 0x0648),
        (digr \j, \+, 0x0649),
        (digr \y, \+, 0x064a),
        (digr \:, \+, 0x064b),
        (digr \", \+, 0x064c),  ;; """
        (digr \=, \+, 0x064d),
        (digr \/, \+, 0x064e),
        (digr \', \+, 0x064f),
        (digr \1, \+, 0x0650),
        (digr \3, \+, 0x0651),
        (digr \0, \+, 0x0652),
        (digr \a, \S, 0x0670),
        (digr \p, \+, 0x067e),
        (digr \v, \+, 0x06a4),
        (digr \g, \f, 0x06af),
        (digr \0, \a, 0x06f0),
        (digr \1, \a, 0x06f1),
        (digr \2, \a, 0x06f2),
        (digr \3, \a, 0x06f3),
        (digr \4, \a, 0x06f4),
        (digr \5, \a, 0x06f5),
        (digr \6, \a, 0x06f6),
        (digr \7, \a, 0x06f7),
        (digr \8, \a, 0x06f8),
        (digr \9, \a, 0x06f9),
        (digr \B, \., 0x1e02),
        (digr \b, \., 0x1e03),
        (digr \B, \_, 0x1e06),
        (digr \b, \_, 0x1e07),
        (digr \D, \., 0x1e0a),
        (digr \d, \., 0x1e0b),
        (digr \D, \_, 0x1e0e),
        (digr \d, \_, 0x1e0f),
        (digr \D, \,, 0x1e10),
        (digr \d, \,, 0x1e11),
        (digr \F, \., 0x1e1e),
        (digr \f, \., 0x1e1f),
        (digr \G, \-, 0x1e20),
        (digr \g, \-, 0x1e21),
        (digr \H, \., 0x1e22),
        (digr \h, \., 0x1e23),
        (digr \H, \:, 0x1e26),
        (digr \h, \:, 0x1e27),
        (digr \H, \,, 0x1e28),
        (digr \h, \,, 0x1e29),
        (digr \K, \', 0x1e30),
        (digr \k, \', 0x1e31),
        (digr \K, \_, 0x1e34),
        (digr \k, \_, 0x1e35),
        (digr \L, \_, 0x1e3a),
        (digr \l, \_, 0x1e3b),
        (digr \M, \', 0x1e3e),
        (digr \m, \', 0x1e3f),
        (digr \M, \., 0x1e40),
        (digr \m, \., 0x1e41),
        (digr \N, \., 0x1e44),
        (digr \n, \., 0x1e45),
        (digr \N, \_, 0x1e48),
        (digr \n, \_, 0x1e49),
        (digr \P, \', 0x1e54),
        (digr \p, \', 0x1e55),
        (digr \P, \., 0x1e56),
        (digr \p, \., 0x1e57),
        (digr \R, \., 0x1e58),
        (digr \r, \., 0x1e59),
        (digr \R, \_, 0x1e5e),
        (digr \r, \_, 0x1e5f),
        (digr \S, \., 0x1e60),
        (digr \s, \., 0x1e61),
        (digr \T, \., 0x1e6a),
        (digr \t, \., 0x1e6b),
        (digr \T, \_, 0x1e6e),
        (digr \t, \_, 0x1e6f),
        (digr \V, \?, 0x1e7c),
        (digr \v, \?, 0x1e7d),
        (digr \W, \!, 0x1e80),
        (digr \w, \!, 0x1e81),
        (digr \W, \', 0x1e82),
        (digr \w, \', 0x1e83),
        (digr \W, \:, 0x1e84),
        (digr \w, \:, 0x1e85),
        (digr \W, \., 0x1e86),
        (digr \w, \., 0x1e87),
        (digr \X, \., 0x1e8a),
        (digr \x, \., 0x1e8b),
        (digr \X, \:, 0x1e8c),
        (digr \x, \:, 0x1e8d),
        (digr \Y, \., 0x1e8e),
        (digr \y, \., 0x1e8f),
        (digr \Z, \>, 0x1e90),
        (digr \z, \>, 0x1e91),
        (digr \Z, \_, 0x1e94),
        (digr \z, \_, 0x1e95),
        (digr \h, \_, 0x1e96),
        (digr \t, \:, 0x1e97),
        (digr \w, \0, 0x1e98),
        (digr \y, \0, 0x1e99),
        (digr \A, \2, 0x1ea2),
        (digr \a, \2, 0x1ea3),
        (digr \E, \2, 0x1eba),
        (digr \e, \2, 0x1ebb),
        (digr \E, \?, 0x1ebc),
        (digr \e, \?, 0x1ebd),
        (digr \I, \2, 0x1ec8),
        (digr \i, \2, 0x1ec9),
        (digr \O, \2, 0x1ece),
        (digr \o, \2, 0x1ecf),
        (digr \U, \2, 0x1ee6),
        (digr \u, \2, 0x1ee7),
        (digr \Y, \!, 0x1ef2),
        (digr \y, \!, 0x1ef3),
        (digr \Y, \2, 0x1ef6),
        (digr \y, \2, 0x1ef7),
        (digr \Y, \?, 0x1ef8),
        (digr \y, \?, 0x1ef9),
        (digr \;, \', 0x1f00),
        (digr \,, \', 0x1f01),
        (digr \;, \!, 0x1f02),
        (digr \,, \!, 0x1f03),
        (digr \?, \;, 0x1f04),
        (digr \?, \,, 0x1f05),
        (digr \!, \:, 0x1f06),
        (digr \?, \:, 0x1f07),
        (digr \1, \N, 0x2002),
        (digr \1, \M, 0x2003),
        (digr \3, \M, 0x2004),
        (digr \4, \M, 0x2005),
        (digr \6, \M, 0x2006),
        (digr \1, \T, 0x2009),
        (digr \1, \H, 0x200a),
        (digr \-, \1, 0x2010),
        (digr \-, \N, 0x2013),
        (digr \-, \M, 0x2014),
        (digr \-, \3, 0x2015),
        (digr \!, \2, 0x2016),
        (digr \=, \2, 0x2017),
        (digr \', \6, 0x2018),
        (digr \', \9, 0x2019),
        (digr \., \9, 0x201a),
        (digr \9, \', 0x201b),
        (digr \", \6, 0x201c),  ;; """
        (digr \", \9, 0x201d),  ;; """
        (digr \:, \9, 0x201e),
        (digr \9, \", 0x201f),  ;; """
        (digr \/, \-, 0x2020),
        (digr \/, \=, 0x2021),
        (digr \., \., 0x2025),
        (digr \%, \0, 0x2030),
        (digr \1, \', 0x2032),
        (digr \2, \', 0x2033),
        (digr \3, \', 0x2034),
        (digr \1, \", 0x2035),  ;; """
        (digr \2, \", 0x2036),  ;; """
        (digr \3, \", 0x2037),  ;; """
        (digr \C, \a, 0x2038),
        (digr \<, \1, 0x2039),
        (digr \>, \1, 0x203a),
        (digr \:, \X, 0x203b),
        (digr \', \-, 0x203e),
        (digr \/, \f, 0x2044),
        (digr \0, \S, 0x2070),
        (digr \4, \S, 0x2074),
        (digr \5, \S, 0x2075),
        (digr \6, \S, 0x2076),
        (digr \7, \S, 0x2077),
        (digr \8, \S, 0x2078),
        (digr \9, \S, 0x2079),
        (digr \+, \S, 0x207a),
        (digr \-, \S, 0x207b),
        (digr \=, \S, 0x207c),
        (digr \(, \S, 0x207d),
        (digr \), \S, 0x207e),
        (digr \n, \S, 0x207f),
        (digr \0, \s, 0x2080),
        (digr \1, \s, 0x2081),
        (digr \2, \s, 0x2082),
        (digr \3, \s, 0x2083),
        (digr \4, \s, 0x2084),
        (digr \5, \s, 0x2085),
        (digr \6, \s, 0x2086),
        (digr \7, \s, 0x2087),
        (digr \8, \s, 0x2088),
        (digr \9, \s, 0x2089),
        (digr \+, \s, 0x208a),
        (digr \-, \s, 0x208b),
        (digr \=, \s, 0x208c),
        (digr \(, \s, 0x208d),
        (digr \), \s, 0x208e),
        (digr \L, \i, 0x20a4),
        (digr \P, \t, 0x20a7),
        (digr \W, \=, 0x20a9),
        (digr \=, \e, 0x20ac), ;; euro
        (digr \E, \u, 0x20ac), ;; euro
        (digr \=, \R, 0x20bd), ;; rouble
        (digr \=, \P, 0x20bd), ;; rouble
        (digr \o, \C, 0x2103),
        (digr \c, \o, 0x2105),
        (digr \o, \F, 0x2109),
        (digr \N, \0, 0x2116),
        (digr \P, \O, 0x2117),
        (digr \R, \x, 0x211e),
        (digr \S, \M, 0x2120),
        (digr \T, \M, 0x2122),
        (digr \O, \m, 0x2126),
        (digr \A, \O, 0x212b),
        (digr \1, \3, 0x2153),
        (digr \2, \3, 0x2154),
        (digr \1, \5, 0x2155),
        (digr \2, \5, 0x2156),
        (digr \3, \5, 0x2157),
        (digr \4, \5, 0x2158),
        (digr \1, \6, 0x2159),
        (digr \5, \6, 0x215a),
        (digr \1, \8, 0x215b),
        (digr \3, \8, 0x215c),
        (digr \5, \8, 0x215d),
        (digr \7, \8, 0x215e),
        (digr \1, \R, 0x2160),
        (digr \2, \R, 0x2161),
        (digr \3, \R, 0x2162),
        (digr \4, \R, 0x2163),
        (digr \5, \R, 0x2164),
        (digr \6, \R, 0x2165),
        (digr \7, \R, 0x2166),
        (digr \8, \R, 0x2167),
        (digr \9, \R, 0x2168),
        (digr \a, \R, 0x2169),
        (digr \b, \R, 0x216a),
        (digr \c, \R, 0x216b),
        (digr \1, \r, 0x2170),
        (digr \2, \r, 0x2171),
        (digr \3, \r, 0x2172),
        (digr \4, \r, 0x2173),
        (digr \5, \r, 0x2174),
        (digr \6, \r, 0x2175),
        (digr \7, \r, 0x2176),
        (digr \8, \r, 0x2177),
        (digr \9, \r, 0x2178),
        (digr \a, \r, 0x2179),
        (digr \b, \r, 0x217a),
        (digr \c, \r, 0x217b),
        (digr \<, \-, 0x2190),
        (digr \-, \!, 0x2191),
        (digr \-, \>, 0x2192),
        (digr \-, \v, 0x2193),
        (digr \<, \>, 0x2194),
        (digr \U, \D, 0x2195),
        (digr \<, \=, 0x21d0),
        (digr \=, \>, 0x21d2),
        (digr \=, \=, 0x21d4),
        (digr \F, \A, 0x2200),
        (digr \d, \P, 0x2202),
        (digr \T, \E, 0x2203),
        (digr \/, \0, 0x2205),
        (digr \D, \E, 0x2206),
        (digr \N, \B, 0x2207),
        (digr \(, \-, 0x2208),
        (digr \-, \), 0x220b),
        (digr \*, \P, 0x220f),
        (digr \+, \Z, 0x2211),
        (digr \-, \2, 0x2212),
        (digr \-, \+, 0x2213),
        (digr \*, \-, 0x2217),
        (digr \O, \b, 0x2218),
        (digr \S, \b, 0x2219),
        (digr \R, \T, 0x221a),
        (digr \0, \(, 0x221d),
        (digr \0, \0, 0x221e),
        (digr \-, \L, 0x221f),
        (digr \-, \V, 0x2220),
        (digr \P, \P, 0x2225),
        (digr \A, \N, 0x2227),
        (digr \O, \R, 0x2228),
        (digr \(, \U, 0x2229),
        (digr \), \U, 0x222a),
        (digr \I, \n, 0x222b),
        (digr \D, \I, 0x222c),
        (digr \I, \o, 0x222e),
        (digr \., \:, 0x2234),
        (digr \:, \., 0x2235),
        (digr \:, \R, 0x2236),
        (digr \:, \:, 0x2237),
        (digr \?, \1, 0x223c),
        (digr \C, \G, 0x223e),
        (digr \?, \-, 0x2243),
        (digr \?, \=, 0x2245),
        (digr \?, \2, 0x2248),
        (digr \=, \?, 0x224c),
        (digr \H, \I, 0x2253),
        (digr \!, \=, 0x2260),
        (digr \=, \3, 0x2261),
        (digr \=, \<, 0x2264),
        (digr \>, \=, 0x2265),
        (digr \<, \*, 0x226a),
        (digr \*, \>, 0x226b),
        (digr \!, \<, 0x226e),
        (digr \!, \>, 0x226f),
        (digr \(, \C, 0x2282),
        (digr \), \C, 0x2283),
        (digr \(, \_, 0x2286),
        (digr \), \_, 0x2287),
        (digr \0, \., 0x2299),
        (digr \0, \2, 0x229a),
        (digr \-, \T, 0x22a5),
        (digr \., \P, 0x22c5),
        (digr \:, \3, 0x22ee),
        (digr \., \3, 0x22ef),
        (digr \E, \h, 0x2302),
        (digr \<, \7, 0x2308),
        (digr \>, \7, 0x2309),
        (digr \7, \<, 0x230a),
        (digr \7, \>, 0x230b),
        (digr \N, \I, 0x2310),
        (digr \(, \A, 0x2312),
        (digr \T, \R, 0x2315),
        (digr \I, \u, 0x2320),
        (digr \I, \l, 0x2321),
        (digr \<, \/, 0x2329),
        (digr \/, \>, 0x232a),
        (digr \V, \s, 0x2423),
        (digr \1, \h, 0x2440),
        (digr \3, \h, 0x2441),
        (digr \2, \h, 0x2442),
        (digr \4, \h, 0x2443),
        (digr \1, \j, 0x2446),
        (digr \2, \j, 0x2447),
        (digr \3, \j, 0x2448),
        (digr \4, \j, 0x2449),
        (digr \1, \., 0x2488),
        (digr \2, \., 0x2489),
        (digr \3, \., 0x248a),
        (digr \4, \., 0x248b),
        (digr \5, \., 0x248c),
        (digr \6, \., 0x248d),
        (digr \7, \., 0x248e),
        (digr \8, \., 0x248f),
        (digr \9, \., 0x2490),
        (digr \h, \h, 0x2500),
        (digr \H, \H, 0x2501),
        (digr \v, \v, 0x2502),
        (digr \V, \V, 0x2503),
        (digr \3, \-, 0x2504),
        (digr \3, \_, 0x2505),
        (digr \3, \!, 0x2506),
        (digr \3, \/, 0x2507),
        (digr \4, \-, 0x2508),
        (digr \4, \_, 0x2509),
        (digr \4, \!, 0x250a),
        (digr \4, \/, 0x250b),
        (digr \d, \r, 0x250c),
        (digr \d, \R, 0x250d),
        (digr \D, \r, 0x250e),
        (digr \D, \R, 0x250f),
        (digr \d, \l, 0x2510),
        (digr \d, \L, 0x2511),
        (digr \D, \l, 0x2512),
        (digr \L, \D, 0x2513),
        (digr \u, \r, 0x2514),
        (digr \u, \R, 0x2515),
        (digr \U, \r, 0x2516),
        (digr \U, \R, 0x2517),
        (digr \u, \l, 0x2518),
        (digr \u, \L, 0x2519),
        (digr \U, \l, 0x251a),
        (digr \U, \L, 0x251b),
        (digr \v, \r, 0x251c),
        (digr \v, \R, 0x251d),
        (digr \V, \r, 0x2520),
        (digr \V, \R, 0x2523),
        (digr \v, \l, 0x2524),
        (digr \v, \L, 0x2525),
        (digr \V, \l, 0x2528),
        (digr \V, \L, 0x252b),
        (digr \d, \h, 0x252c),
        (digr \d, \H, 0x252f),
        (digr \D, \h, 0x2530),
        (digr \D, \H, 0x2533),
        (digr \u, \h, 0x2534),
        (digr \u, \H, 0x2537),
        (digr \U, \h, 0x2538),
        (digr \U, \H, 0x253b),
        (digr \v, \h, 0x253c),
        (digr \v, \H, 0x253f),
        (digr \V, \h, 0x2542),
        (digr \V, \H, 0x254b),
        (digr \F, \D, 0x2571),
        (digr \B, \D, 0x2572),
        (digr \T, \B, 0x2580),
        (digr \L, \B, 0x2584),
        (digr \F, \B, 0x2588),
        (digr \l, \B, 0x258c),
        (digr \R, \B, 0x2590),
        (digr \., \S, 0x2591),
        (digr \:, \S, 0x2592),
        (digr \?, \S, 0x2593),
        (digr \f, \S, 0x25a0),
        (digr \O, \S, 0x25a1),
        (digr \R, \O, 0x25a2),
        (digr \R, \r, 0x25a3),
        (digr \R, \F, 0x25a4),
        (digr \R, \Y, 0x25a5),
        (digr \R, \H, 0x25a6),
        (digr \R, \Z, 0x25a7),
        (digr \R, \K, 0x25a8),
        (digr \R, \X, 0x25a9),
        (digr \s, \B, 0x25aa),
        (digr \S, \R, 0x25ac),
        (digr \O, \r, 0x25ad),
        (digr \U, \T, 0x25b2),
        (digr \u, \T, 0x25b3),
        (digr \P, \R, 0x25b6),
        (digr \T, \r, 0x25b7),
        (digr \D, \t, 0x25bc),
        (digr \d, \T, 0x25bd),
        (digr \P, \L, 0x25c0),
        (digr \T, \l, 0x25c1),
        (digr \D, \b, 0x25c6),
        (digr \D, \w, 0x25c7),
        (digr \L, \Z, 0x25ca),
        (digr \0, \m, 0x25cb),
        (digr \0, \o, 0x25ce),
        (digr \0, \M, 0x25cf),
        (digr \0, \L, 0x25d0),
        (digr \0, \R, 0x25d1),
        (digr \S, \n, 0x25d8),
        (digr \I, \c, 0x25d9),
        (digr \F, \d, 0x25e2),
        (digr \B, \d, 0x25e3),
        (digr \*, \2, 0x2605),
        (digr \*, \1, 0x2606),
        (digr \<, \H, 0x261c),
        (digr \>, \H, 0x261e),
        (digr \0, \u, 0x263a),
        (digr \0, \U, 0x263b),
        (digr \S, \U, 0x263c),
        (digr \F, \m, 0x2640),
        (digr \M, \l, 0x2642),
        (digr \c, \S, 0x2660),
        (digr \c, \H, 0x2661),
        (digr \c, \D, 0x2662),
        (digr \c, \C, 0x2663),
        (digr \M, \d, 0x2669),
        (digr \M, \8, 0x266a),
        (digr \M, \2, 0x266b),
        (digr \M, \b, 0x266d),
        (digr \M, \x, 0x266e),
        (digr \M, \X, 0x266f),
        (digr \O, \K, 0x2713),
        (digr \X, \X, 0x2717),
        (digr \-, \X, 0x2720),
        (digr \I, \S, 0x3000),
        (digr \,, \_, 0x3001),
        (digr \., \_, 0x3002),
        (digr \+, \", 0x3003),  ;; """
        (digr \+, \_, 0x3004),
        (digr \*, \_, 0x3005),
        (digr \;, \_, 0x3006),
        (digr \0, \_, 0x3007),
        (digr \<, \+, 0x300a),
        (digr \>, \+, 0x300b),
        (digr \<, \', 0x300c),
        (digr \>, \', 0x300d),
        (digr \<, \", 0x300e),  ;; """
        (digr \>, \", 0x300f),  ;; """
        (digr \(, \", 0x3010),  ;; """
        (digr \), \", 0x3011),  ;; """
        (digr \=, \T, 0x3012),
        (digr \=, \_, 0x3013),
        (digr \(, \', 0x3014),
        (digr \), \', 0x3015),
        (digr \(, \I, 0x3016),
        (digr \), \I, 0x3017),
        (digr \-, \?, 0x301c),
        (digr \A, \5, 0x3041),
        (digr \a, \5, 0x3042),
        (digr \I, \5, 0x3043),
        (digr \i, \5, 0x3044),
        (digr \U, \5, 0x3045),
        (digr \u, \5, 0x3046),
        (digr \E, \5, 0x3047),
        (digr \e, \5, 0x3048),
        (digr \O, \5, 0x3049),
        (digr \o, \5, 0x304a),
        (digr \k, \a, 0x304b),
        (digr \g, \a, 0x304c),
        (digr \k, \i, 0x304d),
        (digr \g, \i, 0x304e),
        (digr \k, \u, 0x304f),
        (digr \g, \u, 0x3050),
        (digr \k, \e, 0x3051),
        (digr \g, \e, 0x3052),
        (digr \k, \o, 0x3053),
        (digr \g, \o, 0x3054),
        (digr \s, \a, 0x3055),
        (digr \z, \a, 0x3056),
        (digr \s, \i, 0x3057),
        (digr \z, \i, 0x3058),
        (digr \s, \u, 0x3059),
        (digr \z, \u, 0x305a),
        (digr \s, \e, 0x305b),
        (digr \z, \e, 0x305c),
        (digr \s, \o, 0x305d),
        (digr \z, \o, 0x305e),
        (digr \t, \a, 0x305f),
        (digr \d, \a, 0x3060),
        (digr \t, \i, 0x3061),
        (digr \d, \i, 0x3062),
        (digr \t, \U, 0x3063),
        (digr \t, \u, 0x3064),
        (digr \d, \u, 0x3065),
        (digr \t, \e, 0x3066),
        (digr \d, \e, 0x3067),
        (digr \t, \o, 0x3068),
        (digr \d, \o, 0x3069),
        (digr \n, \a, 0x306a),
        (digr \n, \i, 0x306b),
        (digr \n, \u, 0x306c),
        (digr \n, \e, 0x306d),
        (digr \n, \o, 0x306e),
        (digr \h, \a, 0x306f),
        (digr \b, \a, 0x3070),
        (digr \p, \a, 0x3071),
        (digr \h, \i, 0x3072),
        (digr \b, \i, 0x3073),
        (digr \p, \i, 0x3074),
        (digr \h, \u, 0x3075),
        (digr \b, \u, 0x3076),
        (digr \p, \u, 0x3077),
        (digr \h, \e, 0x3078),
        (digr \b, \e, 0x3079),
        (digr \p, \e, 0x307a),
        (digr \h, \o, 0x307b),
        (digr \b, \o, 0x307c),
        (digr \p, \o, 0x307d),
        (digr \m, \a, 0x307e),
        (digr \m, \i, 0x307f),
        (digr \m, \u, 0x3080),
        (digr \m, \e, 0x3081),
        (digr \m, \o, 0x3082),
        (digr \y, \A, 0x3083),
        (digr \y, \a, 0x3084),
        (digr \y, \U, 0x3085),
        (digr \y, \u, 0x3086),
        (digr \y, \O, 0x3087),
        (digr \y, \o, 0x3088),
        (digr \r, \a, 0x3089),
        (digr \r, \i, 0x308a),
        (digr \r, \u, 0x308b),
        (digr \r, \e, 0x308c),
        (digr \r, \o, 0x308d),
        (digr \w, \A, 0x308e),
        (digr \w, \a, 0x308f),
        (digr \w, \i, 0x3090),
        (digr \w, \e, 0x3091),
        (digr \w, \o, 0x3092),
        (digr \n, \5, 0x3093),
        (digr \v, \u, 0x3094),
        (digr \", \5, 0x309b),  ;; """
        (digr \0, \5, 0x309c),
        (digr \*, \5, 0x309d),
        (digr \+, \5, 0x309e),
        (digr \a, \6, 0x30a1),
        (digr \A, \6, 0x30a2),
        (digr \i, \6, 0x30a3),
        (digr \I, \6, 0x30a4),
        (digr \u, \6, 0x30a5),
        (digr \U, \6, 0x30a6),
        (digr \e, \6, 0x30a7),
        (digr \E, \6, 0x30a8),
        (digr \o, \6, 0x30a9),
        (digr \O, \6, 0x30aa),
        (digr \K, \a, 0x30ab),
        (digr \G, \a, 0x30ac),
        (digr \K, \i, 0x30ad),
        (digr \G, \i, 0x30ae),
        (digr \K, \u, 0x30af),
        (digr \G, \u, 0x30b0),
        (digr \K, \e, 0x30b1),
        (digr \G, \e, 0x30b2),
        (digr \K, \o, 0x30b3),
        (digr \G, \o, 0x30b4),
        (digr \S, \a, 0x30b5),
        (digr \Z, \a, 0x30b6),
        (digr \S, \i, 0x30b7),
        (digr \Z, \i, 0x30b8),
        (digr \S, \u, 0x30b9),
        (digr \Z, \u, 0x30ba),
        (digr \S, \e, 0x30bb),
        (digr \Z, \e, 0x30bc),
        (digr \S, \o, 0x30bd),
        (digr \Z, \o, 0x30be),
        (digr \T, \a, 0x30bf),
        (digr \D, \a, 0x30c0),
        (digr \T, \i, 0x30c1),
        (digr \D, \i, 0x30c2),
        (digr \T, \U, 0x30c3),
        (digr \T, \u, 0x30c4),
        (digr \D, \u, 0x30c5),
        (digr \T, \e, 0x30c6),
        (digr \D, \e, 0x30c7),
        (digr \T, \o, 0x30c8),
        (digr \D, \o, 0x30c9),
        (digr \N, \a, 0x30ca),
        (digr \N, \i, 0x30cb),
        (digr \N, \u, 0x30cc),
        (digr \N, \e, 0x30cd),
        (digr \N, \o, 0x30ce),
        (digr \H, \a, 0x30cf),
        (digr \B, \a, 0x30d0),
        (digr \P, \a, 0x30d1),
        (digr \H, \i, 0x30d2),
        (digr \B, \i, 0x30d3),
        (digr \P, \i, 0x30d4),
        (digr \H, \u, 0x30d5),
        (digr \B, \u, 0x30d6),
        (digr \P, \u, 0x30d7),
        (digr \H, \e, 0x30d8),
        (digr \B, \e, 0x30d9),
        (digr \P, \e, 0x30da),
        (digr \H, \o, 0x30db),
        (digr \B, \o, 0x30dc),
        (digr \P, \o, 0x30dd),
        (digr \M, \a, 0x30de),
        (digr \M, \i, 0x30df),
        (digr \M, \u, 0x30e0),
        (digr \M, \e, 0x30e1),
        (digr \M, \o, 0x30e2),
        (digr \Y, \A, 0x30e3),
        (digr \Y, \a, 0x30e4),
        (digr \Y, \U, 0x30e5),
        (digr \Y, \u, 0x30e6),
        (digr \Y, \O, 0x30e7),
        (digr \Y, \o, 0x30e8),
        (digr \R, \a, 0x30e9),
        (digr \R, \i, 0x30ea),
        (digr \R, \u, 0x30eb),
        (digr \R, \e, 0x30ec),
        (digr \R, \o, 0x30ed),
        (digr \W, \A, 0x30ee),
        (digr \W, \a, 0x30ef),
        (digr \W, \i, 0x30f0),
        (digr \W, \e, 0x30f1),
        (digr \W, \o, 0x30f2),
        (digr \N, \6, 0x30f3),
        (digr \V, \u, 0x30f4),
        (digr \K, \A, 0x30f5),
        (digr \K, \E, 0x30f6),
        (digr \V, \a, 0x30f7),
        (digr \V, \i, 0x30f8),
        (digr \V, \e, 0x30f9),
        (digr \V, \o, 0x30fa),
        (digr \., \6, 0x30fb),
        (digr \-, \6, 0x30fc),
        (digr \*, \6, 0x30fd),
        (digr \+, \6, 0x30fe),
        (digr \b, \4, 0x3105),
        (digr \p, \4, 0x3106),
        (digr \m, \4, 0x3107),
        (digr \f, \4, 0x3108),
        (digr \d, \4, 0x3109),
        (digr \t, \4, 0x310a),
        (digr \n, \4, 0x310b),
        (digr \l, \4, 0x310c),
        (digr \g, \4, 0x310d),
        (digr \k, \4, 0x310e),
        (digr \h, \4, 0x310f),
        (digr \j, \4, 0x3110),
        (digr \q, \4, 0x3111),
        (digr \x, \4, 0x3112),
        (digr \z, \h, 0x3113),
        (digr \c, \h, 0x3114),
        (digr \s, \h, 0x3115),
        (digr \r, \4, 0x3116),
        (digr \z, \4, 0x3117),
        (digr \c, \4, 0x3118),
        (digr \s, \4, 0x3119),
        (digr \a, \4, 0x311a),
        (digr \o, \4, 0x311b),
        (digr \e, \4, 0x311c),
        (digr \a, \i, 0x311e),
        (digr \e, \i, 0x311f),
        (digr \a, \u, 0x3120),
        (digr \o, \u, 0x3121),
        (digr \a, \n, 0x3122),
        (digr \e, \n, 0x3123),
        (digr \a, \N, 0x3124),
        (digr \e, \N, 0x3125),
        (digr \e, \r, 0x3126),
        (digr \i, \4, 0x3127),
        (digr \u, \4, 0x3128),
        (digr \i, \u, 0x3129),
        (digr \v, \4, 0x312a),
        (digr \n, \G, 0x312b),
        (digr \g, \n, 0x312c),
        (digr \1, \c, 0x3220),
        (digr \2, \c, 0x3221),
        (digr \3, \c, 0x3222),
        (digr \4, \c, 0x3223),
        (digr \5, \c, 0x3224),
        (digr \6, \c, 0x3225),
        (digr \7, \c, 0x3226),
        (digr \8, \c, 0x3227),
        (digr \9, \c, 0x3228),
        ;; Code points 0xe000 - 0xefff excluded;
        ;; they have no assigned characters, only used in proposals.
        (digr \f, \f, 0xfb00),
        (digr \f, \i, 0xfb01),
        (digr \f, \l, 0xfb02),
        (digr \f, \t, 0xfb05),
        (digr \s, \t, 0xfb06),

        ;; Vim 5.x compatible digraphs that don't conflict with the above.
        (digr \~, \!, 161),
        (digr \c, \|, 162),
        (digr \$, \$, 163),
        (digr \o, \x, 164),
        (digr \Y, \-, 165),
        (digr \|, \|, 166),
        (digr \c, \O, 169),
        (digr \-, \,, 172),
        (digr \-, \=, 175),
        (digr \~, \o, 176),
        (digr \2, \2, 178),
        (digr \3, \3, 179),
        (digr \p, \p, 182),
        (digr \~, \., 183),
        (digr \1, \1, 185),
        (digr \~, \?, 191),
        (digr \A, \`, 192),
        (digr \A, \^, 194),
        (digr \A, \~, 195),
        (digr \A, \", 196), ;; """
        (digr \A, \@, 197),
        (digr \E, \`, 200),
        (digr \E, \^, 202),
        (digr \E, \", 203), ;; """
        (digr \I, \`, 204),
        (digr \I, \^, 206),
        (digr \I, \", 207), ;; """
        (digr \N, \~, 209),
        (digr \O, \`, 210),
        (digr \O, \^, 212),
        (digr \O, \~, 213),
        (digr \/, \\, 215),
        (digr \U, \`, 217),
        (digr \U, \^, 219),
        (digr \I, \p, 222),
        (digr \a, \`, 224),
        (digr \a, \^, 226),
        (digr \a, \~, 227),
        (digr \a, \", 228), ;; """
        (digr \a, \@, 229),
        (digr \e, \`, 232),
        (digr \e, \^, 234),
        (digr \e, \", 235), ;; """
        (digr \i, \`, 236),
        (digr \i, \^, 238),
        (digr \n, \~, 241),
        (digr \o, \`, 242),
        (digr \o, \^, 244),
        (digr \o, \~, 245),
        (digr \u, \`, 249),
        (digr \u, \^, 251),
        (digr \y, \", 255)  ;; """
    ])

(atom! int backspaced)  ;; character before K_BS
(atom! int lastchar)    ;; last typed character

;; handle digraphs after typing a character

(defn- #_int do_digraph [#_int c]
    (ยง
        (cond (== c -1)                ;; init values
        (ยง
            (reset! backspaced -1)
        )
        @p_dg
        (ยง
            (if (<= 0 @backspaced)
                ((ร c =) (getdigraph @backspaced, c, false))
            )
            (reset! backspaced -1)
            (if (and (or (== c K_BS) (== c Ctrl_H)) (<= 0 @lastchar))
                (reset! backspaced @lastchar))
        ))
        (reset! lastchar c)
        c
    ))

;; Get a digraph.  Used after typing CTRL-K on the command line or in normal mode.
;; Returns composed character, or NUL when ESC was used.

(defn- #_int get_digraph [#_boolean cmdline]
    ;; cmdline: true when called from the cmdline
    (ยง
        (ร int c, cc)

        (swap! no_mapping inc)
        (swap! allow_keys inc)
        ((ร c =) (plain_vgetc))
        (swap! no_mapping dec)
        (swap! allow_keys dec)
        (when (!= c ESC)               ;; ESC cancels CTRL-K
            (if (is_special c)      ;; insert special key code
                ((ร RETURN) c)
            )
            (cond cmdline
            (ยง
                (if (and (== (mb_char2cells c) 1) (zero? @cmdline_star))
                    (putcmdline c, true))
            )
            :else
            (ยง
                (add_to_showcmd c)
            ))
            (swap! no_mapping inc)
            (swap! allow_keys inc)
            ((ร cc =) (plain_vgetc))
            (swap! no_mapping dec)
            (swap! allow_keys dec)
            (if (!= cc ESC)      ;; ESC cancels CTRL-K
                ((ร RETURN) (getdigraph c, cc, true))
            )
        )
        NUL
    ))

;; Lookup the pair "char1", "char2" in the digraph tables.
;; If no match, return "char2".
;; If "meta_char" is true and "char1" is a space, return "char2" | 0x80.

(defn- #_int getexactdigraph [#_int char1, #_int char2, #_boolean meta_char]
    (ยง
        ((ร int retval =) 0)

        (if (or (is_special char1) (is_special char2))
            ((ร RETURN) char2)
        )

        ((ร digr_C[] dgs =) digraphdefault)
        ((ร FOR) (ร (ยง int i = 0) (ยง i < dgs.length) (ยง i++))
            (when (and (== (int (ยง dgs[i].char1)) char1) (== (int (ยง dgs[i].char2)) char2))
                ((ร retval =) (ยง dgs[i].result))
                (ร BREAK)
            )
        )

        (when (zero? retval)            ;; digraph deleted or not found
            (if (and (== char1 (byte \space)) meta_char)  ;; <space> <char> --> meta-char
                ((ร RETURN) (ยง (char2 | 0x80)))
            )

            ((ร RETURN) char2)
        )

        retval
    ))

;; Get digraph.
;; Allow for both char1-char2 and char2-char1

(defn- #_int getdigraph [#_int char1, #_int char2, #_boolean meta_char]
    (ยง
        (ร int retval)

        (when (and (ยง (retval = getexactdigraph(char1, char2, meta_char)) == char2) (!= char1 char2) (ยง (retval = getexactdigraph(char2, char1, meta_char)) == char1))
            ((ร RETURN) char2)
        )

        retval
    ))

;; mbyte.c: Code specifically for handling multi-byte characters.
;;
;; "enc_utf8"   Use Unicode characters in UTF-8 encoding.
;;              The cell width on the display needs to be determined from the character value.
;;              Recognizing bytes is easy: 0xxx.xxxx is a single-byte char, 10xx.xxxx is a
;;              trailing byte, 11xx.xxxx is a leading byte of a multi-byte character.
;;              To make things complicated, up to six composing characters are allowed.
;;              These are drawn on top of the first char.
;;              For most editing the sequence of bytes with composing
;;              characters included is considered to be one character.
;;
;; 'encoding' specifies the encoding used in the core.  This is in registers,
;; text manipulation, buffers, etc.  Conversion has to be done when characters
;; in another encoding are received or send:
;;
;;                     clipboard
;;                         ^
;;                         | (2)
;;                         V
;;                 +---------------+
;;            (1)  |               | (3)
;;  keyboard ----->|     core      |-----> display
;;                 |               |
;;                 +---------------+
;;                         ^
;;                         | (4)
;;                         V
;;                       file
;;
;; (1) Typed characters arrive in the current locale.  Conversion is to be
;;     done when 'encoding' is different from 'termencoding'.
;; (2) Text will be made available with the encoding specified with
;;     'encoding'.  If this is not sufficient, system-specific conversion
;;     might be required.
;; (3) For the GUI the correct font must be selected, no conversion done.
;;     Otherwise, conversion is to be done when 'encoding' differs from
;;     'termencoding'.
;; (4) The encoding of the file is specified with 'fileencoding'.  Conversion
;;     is to be done when it's different from 'encoding'.

;; Lookup table to quickly get the length in bytes of a UTF-8 sequence from the first byte.
;; Bytes which are illegal when used as the first byte have a 0.
;; The NUL byte has length 1.

(final byte* #_"[/*256*/]" utf8len_tab_zero
    [
        1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
        1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
        1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
        1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
        2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
        3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,4,4,4,4,4,4,4,4,5,5,5,5,6,6,0,0
    ])

;; Returns the length of a UTF-8 sequence, obtained from the first byte.
;; For an invalid first byte returns zero ? 0 : 1.

(defn- #_int us_byte2len [#_byte b, #_boolean zero]
    (ยง
        ((ร int len =) (ยง utf8len_tab_zero[char_u(b)]))
        (if (or zero (< 0 len)) len 1)
    ))

;; Return byte length of character that starts with byte "b".
;; Returns 1 for a single-byte character.
;; mb_byte2len() can be used to count a special key as one byte.

(defn- #_int mb_byte2len [#_int b]
    (ยง
        (if (or (< b 0) (< 0xff b)) 1 (us_byte2len (byte b), false))
    ))

;; Get class of pointer:
;;  0 for blank or NUL
;;  1 for punctuation
;;  2 for an (ASCII) word character
;; >2 for other word characters

(defn- #_int us_get_class [#_Bytes p, #_buffer_C buf]
    (ยง
        (when (ยง (us_byte2len(p.at(0), false)) == 1)
            (if (or (eos? p) (vim_iswhite (ยง p.at(0))))
                ((ร RETURN) 0)
            )
            (if (us_iswordb (.at p 0), buf)
                ((ร RETURN) 2)
            )

            ((ร RETURN) 1)
        )
        (utf_class (us_ptr2char p))
    ))

(defn- #_boolean intable [#_int* table, #_int c]
    (ยง
        ;; first quick check for Latin1 etc. characters
        (if (< c (ยง table[0]))
            ((ร RETURN) false)
        )

        ;; binary search in table
        ((ร FOR) (ร (ยง int bot = 0, top = table.length / 2 - 1) (<= bot top) nil)
            ((ร int mid =) (ยง (bot + top) / 2))
            (cond (ยง table[2 * mid + 1] < c)
            (ยง
                ((ร bot =) (+ mid 1))
            )
            (< c (ยง table[2 * mid]))
            (ยง
                ((ร top =) (- mid 1))
            )
            :else
            (ยง
                ((ร RETURN) true)
            ))
        )

        false
    ))

;; Sorted list of non-overlapping intervals of East Asian double width characters,
;; generated with tools/unicode.vim.

(final int* doublewidth
    [
        0x1100, 0x115f,
        0x2329, 0x232a,
        0x2e80, 0x2e99,
        0x2e9b, 0x2ef3,
        0x2f00, 0x2fd5,
        0x2ff0, 0x2ffb,
        0x3000, 0x303e,
        0x3041, 0x3096,
        0x3099, 0x30ff,
        0x3105, 0x312d,
        0x3131, 0x318e,
        0x3190, 0x31ba,
        0x31c0, 0x31e3,
        0x31f0, 0x321e,
        0x3220, 0x3247,
        0x3250, 0x32fe,
        0x3300, 0x4dbf,
        0x4e00, 0xa48c,
        0xa490, 0xa4c6,
        0xa960, 0xa97c,
        0xac00, 0xd7a3,
        0xf900, 0xfaff,
        0xfe10, 0xfe19,
        0xfe30, 0xfe52,
        0xfe54, 0xfe66,
        0xfe68, 0xfe6b,
        0xff01, 0xff60,
        0xffe0, 0xffe6,
        0x1b000, 0x1b001,
        0x1f200, 0x1f202,
        0x1f210, 0x1f23a,
        0x1f240, 0x1f248,
        0x1f250, 0x1f251,
        0x20000, 0x2fffd,
        0x30000, 0x3fffd
    ])

;; Sorted list of non-overlapping intervals of East Asian Ambiguous characters,
;; generated with tools/unicode.vim.

(final int* ambiguous
    [
        0x00a1, 0x00a1,
        0x00a4, 0x00a4,
        0x00a7, 0x00a8,
        0x00aa, 0x00aa,
        0x00ad, 0x00ae,
        0x00b0, 0x00b4,
        0x00b6, 0x00ba,
        0x00bc, 0x00bf,
        0x00c6, 0x00c6,
        0x00d0, 0x00d0,
        0x00d7, 0x00d8,
        0x00de, 0x00e1,
        0x00e6, 0x00e6,
        0x00e8, 0x00ea,
        0x00ec, 0x00ed,
        0x00f0, 0x00f0,
        0x00f2, 0x00f3,
        0x00f7, 0x00fa,
        0x00fc, 0x00fc,
        0x00fe, 0x00fe,
        0x0101, 0x0101,
        0x0111, 0x0111,
        0x0113, 0x0113,
        0x011b, 0x011b,
        0x0126, 0x0127,
        0x012b, 0x012b,
        0x0131, 0x0133,
        0x0138, 0x0138,
        0x013f, 0x0142,
        0x0144, 0x0144,
        0x0148, 0x014b,
        0x014d, 0x014d,
        0x0152, 0x0153,
        0x0166, 0x0167,
        0x016b, 0x016b,
        0x01ce, 0x01ce,
        0x01d0, 0x01d0,
        0x01d2, 0x01d2,
        0x01d4, 0x01d4,
        0x01d6, 0x01d6,
        0x01d8, 0x01d8,
        0x01da, 0x01da,
        0x01dc, 0x01dc,
        0x0251, 0x0251,
        0x0261, 0x0261,
        0x02c4, 0x02c4,
        0x02c7, 0x02c7,
        0x02c9, 0x02cb,
        0x02cd, 0x02cd,
        0x02d0, 0x02d0,
        0x02d8, 0x02db,
        0x02dd, 0x02dd,
        0x02df, 0x02df,
        0x0300, 0x036f,
        0x0391, 0x03a1,
        0x03a3, 0x03a9,
        0x03b1, 0x03c1,
        0x03c3, 0x03c9,
        0x0401, 0x0401,
        0x0410, 0x044f,
        0x0451, 0x0451,
        0x2010, 0x2010,
        0x2013, 0x2016,
        0x2018, 0x2019,
        0x201c, 0x201d,
        0x2020, 0x2022,
        0x2024, 0x2027,
        0x2030, 0x2030,
        0x2032, 0x2033,
        0x2035, 0x2035,
        0x203b, 0x203b,
        0x203e, 0x203e,
        0x2074, 0x2074,
        0x207f, 0x207f,
        0x2081, 0x2084,
        0x20ac, 0x20ac,
        0x2103, 0x2103,
        0x2105, 0x2105,
        0x2109, 0x2109,
        0x2113, 0x2113,
        0x2116, 0x2116,
        0x2121, 0x2122,
        0x2126, 0x2126,
        0x212b, 0x212b,
        0x2153, 0x2154,
        0x215b, 0x215e,
        0x2160, 0x216b,
        0x2170, 0x2179,
        0x2189, 0x2189,
        0x2190, 0x2199,
        0x21b8, 0x21b9,
        0x21d2, 0x21d2,
        0x21d4, 0x21d4,
        0x21e7, 0x21e7,
        0x2200, 0x2200,
        0x2202, 0x2203,
        0x2207, 0x2208,
        0x220b, 0x220b,
        0x220f, 0x220f,
        0x2211, 0x2211,
        0x2215, 0x2215,
        0x221a, 0x221a,
        0x221d, 0x2220,
        0x2223, 0x2223,
        0x2225, 0x2225,
        0x2227, 0x222c,
        0x222e, 0x222e,
        0x2234, 0x2237,
        0x223c, 0x223d,
        0x2248, 0x2248,
        0x224c, 0x224c,
        0x2252, 0x2252,
        0x2260, 0x2261,
        0x2264, 0x2267,
        0x226a, 0x226b,
        0x226e, 0x226f,
        0x2282, 0x2283,
        0x2286, 0x2287,
        0x2295, 0x2295,
        0x2299, 0x2299,
        0x22a5, 0x22a5,
        0x22bf, 0x22bf,
        0x2312, 0x2312,
        0x2460, 0x24e9,
        0x24eb, 0x254b,
        0x2550, 0x2573,
        0x2580, 0x258f,
        0x2592, 0x2595,
        0x25a0, 0x25a1,
        0x25a3, 0x25a9,
        0x25b2, 0x25b3,
        0x25b6, 0x25b7,
        0x25bc, 0x25bd,
        0x25c0, 0x25c1,
        0x25c6, 0x25c8,
        0x25cb, 0x25cb,
        0x25ce, 0x25d1,
        0x25e2, 0x25e5,
        0x25ef, 0x25ef,
        0x2605, 0x2606,
        0x2609, 0x2609,
        0x260e, 0x260f,
        0x2614, 0x2615,
        0x261c, 0x261c,
        0x261e, 0x261e,
        0x2640, 0x2640,
        0x2642, 0x2642,
        0x2660, 0x2661,
        0x2663, 0x2665,
        0x2667, 0x266a,
        0x266c, 0x266d,
        0x266f, 0x266f,
        0x269e, 0x269f,
        0x26be, 0x26bf,
        0x26c4, 0x26cd,
        0x26cf, 0x26e1,
        0x26e3, 0x26e3,
        0x26e8, 0x26ff,
        0x273d, 0x273d,
        0x2757, 0x2757,
        0x2776, 0x277f,
        0x2b55, 0x2b59,
        0x3248, 0x324f,
        0xe000, 0xf8ff,
        0xfe00, 0xfe0f,
        0xfffd, 0xfffd,
        0x1f100, 0x1f10a,
        0x1f110, 0x1f12d,
        0x1f130, 0x1f169,
        0x1f170, 0x1f19a,
        0xe0100, 0xe01ef,
        0xf0000, 0xffffd,
        0x100000, 0x10fffd
    ])

;; For UTF-8 character "c" return 2 for a double-width character, 1 for others.
;; Returns 4 or 6 for an unprintable character.
;; Is only correct for characters >= 0x80.

(defn- #_int utf_char2cells [#_int c]
    (ยง
        (when (<= 0x80 c)
            ;; Characters below 0x100 are influenced by 'isprint' option.
            (cond (< c 0x100)
            (ยง
                (if (not (vim_isprintc c))
                    ((ร RETURN) 4)                           ;; unprintable, displays <xx>
                )
            )
            :else
            (ยง
                (if (not (utf_printable c))
                    ((ร RETURN) 6)                           ;; unprintable, displays <xxxx>
                )
                (if (intable doublewidth, c)
                    ((ร RETURN) 2)
                )
            ))

            (if (and (ยง hamis) (intable ambiguous, c))
                ((ร RETURN) 2)
            )
        )

        1
    ))

(defn- #_int us_ptr2cells [#_Bytes p]
    (ยง
        ;; Need to convert to a wide character.
        (when (<= 0x80 (char_u (ยง p.at(0))))
            ((ร int c =) (us_ptr2char p))
            ;; An illegal byte is displayed as <xx>.
            (if (or (== (us_ptr2len p) 1) (== c NUL))
                ((ร RETURN) 4)
            )
            ;; If the char is ASCII it must be an overlong sequence.
            (if (< c 0x80)
                ((ร RETURN) (mb_char2cells c))
            )

            ((ร RETURN) (utf_char2cells c))
        )
        1
    ))

;; Return the number of cells occupied by string "p".
;; Stop at a NUL character.  When "len" >= 0 stop at character "p[len]".

(defn- #_int us_string2cells [#_Bytes p, #_int len]
    (ยง
        ((ร int cells =) 0)

        ((ร FOR) (ร (ยง int i = 0) (ยง (len < 0 || i < len) && p.at(i) != NUL) (ยง i += us_ptr2len_cc(p.plus(i))))
            ((ร cells +=) (ยง us_ptr2cells(p.plus(i))))
        )

        cells
    ))

(defn- #_int utf_off2cells [#_int off, #_int max_off]
    (ยง
        (if (and (< (+ off 1) max_off) (ยง @screenLines.at(off + 1) == 0)) 2 1)
    ))

;; Convert a UTF-8 byte sequence to a wide character.
;; If the sequence is illegal or truncated by a NUL the first byte is returned.
;; Does not include composing characters, of course.

(defn- #_int us_ptr2char [#_Bytes p]
    (ยง
        (if (< (char_u (ยง p.at(0))) 0x80)    ;; be quick for ASCII
            ((ร RETURN) (ยง p.at(0)))
        )

        ((ร int len =) (ยง us_byte2len(p.at(0), true)))
        (when (and (< 1 len) (ยง (char_u(p.at(1)) & 0xc0) == 0x80))
            (if (== len 2)
                ((ร RETURN) (ยง ((p.at(0) & 0x1f) << 6) + (p.at(1) & 0x3f)))
            )

            (when (ยง (char_u(p.at(2)) & 0xc0) == 0x80)
                (if (== len 3)
                    ((ร RETURN) (ยง ((p.at(0) & 0x0f) << 12) + ((p.at(1) & 0x3f) << 6) + (p.at(2) & 0x3f)))
                )

                (when (ยง (char_u(p.at(3)) & 0xc0) == 0x80)
                    (when (== len 4)
                        ((ร RETURN) (ยง ((p.at(0) & 0x07) << 18) + ((p.at(1) & 0x3f) << 12) + ((p.at(2) & 0x3f) << 6) + (p.at(3) & 0x3f)))
                    )

                    (when (ยง (char_u(p.at(4)) & 0xc0) == 0x80)
                        (when (== len 5)
                            ((ร RETURN) (ยง ((p.at(0) & 0x03) << 24) + ((p.at(1) & 0x3f) << 18) + ((p.at(2) & 0x3f) << 12) + ((p.at(3) & 0x3f) << 6) + (p.at(4) & 0x3f)))
                        )

                        (when (and (ยง (char_u(p.at(5)) & 0xc0) == 0x80) (== len 6))
                            ((ร RETURN) (ยง ((p.at(0) & 0x01) << 30) + ((p.at(1) & 0x3f) << 24) + ((p.at(2) & 0x3f) << 18) + ((p.at(3) & 0x3f) << 12) + ((p.at(4) & 0x3f) << 6) + (p.at(5) & 0x3f)))
                        )
                    )
                )
            )
        )

        ;; Illegal value, just return the first byte.
        (char_u (.at p 0))
    ))

;; Convert a UTF-8 byte sequence to a wide character.
;; String is assumed to be terminated by NUL or after "n" bytes, whichever comes first.
;; The function is safe in the sense that it never accesses memory beyond the first "n" bytes of "s".
;;
;; On success, returns decoded codepoint,
;; advances "s" to the beginning of next character and decreases "n" accordingly.
;;
;; If end of string was reached, returns 0 and, if "n" > 0, advances "s" past NUL byte.
;;
;; If byte sequence is illegal or incomplete, returns -1 and does not advance "s".

(defn- #_int us_safe_read_char_adv [#_Bytes* s, #_int* n]
    (ยง
        (if (zero? (ยง n[0]))    ;; end of buffer
            ((ร RETURN) 0)
        )

        ((ร int k =) (ยง us_byte2len(s[0].at(0), true)))

        (when (== k 1)     ;; ASCII character or NUL
            (ยง n[0]--)
            ((ร RETURN) (ยง (s[0] = s[0].plus(1)).at(-1)))
        )

        (when (<= k (ยง n[0]))
            ;; We have a multibyte sequence and it isn't truncated by buffer
            ;; limits so us_ptr2char() is safe to use.  Or the first byte is
            ;; illegal (k=0), and it's also safe to use us_ptr2char().
            ((ร int c =) (ยง us_ptr2char(s[0])))

            ;; On failure, us_ptr2char() returns the first byte, so here we
            ;; check equality with the first byte.  The only non-ASCII character
            ;; which equals the first byte of its own UTF-8 representation is
            ;; U+00C3 (UTF-8: 0xC3 0x83), so need to check that special case too.
            ;; It's safe even if n=1, else we would have k=2 > n.
            (when (or (!= c (char_u (.at (ยง s[0]) 0))) (and (== c 0xc3) (== (char_u (.at (ยง s[0]) 1)) 0x83)))
                ;; byte sequence was successfully decoded
                ((ร s[0] =) (ยง s[0].plus(k)))
                ((ร n[0] -=) k)
                ((ร RETURN) c)
            )
        )

        ;; byte sequence is incomplete or illegal
        -1
    ))

;; Get character at **pp and advance *pp to the next character.
;; skip: composing characters are skipped!
;; !skip: composing characters are returned as separate characters.

(defn- #_int us_ptr2char_adv [#_Bytes* pp, #_boolean skip]
    (ยง
        ((ร int c =) (ยง us_ptr2char(pp[0])))
        ((ร pp[0] =) (.plus (ยง pp[0]) (if skip (us_ptr2len_cc (ยง pp[0])) (us_ptr2len (ยง pp[0])))))
        c
    ))

;; Convert a UTF-8 byte string to a wide character.
;; Also get up to MAX_MCO composing characters.

(defn- #_int us_ptr2char_cc [#_Bytes p, #_int* pcc]
    ;; pcc: return: composing chars, last one is 0
    (ยง
        ((ร int j =) 0)

        ;; Only accept a composing char when the first char isn't illegal.
        ((ร int i =) (us_ptr2len p))
        (when (or (< 1 i) (< (char_u (ยง p.at(0))) 0x80))
            ((ร FOR) (ร (ยง int cc) (ยง 0x80 <= char_u(p.at(i)) && utf_iscomposing(cc = us_ptr2char(p.plus(i)))) (ยง i += us_ptr2len(p.plus(i))))
                ((ร pcc[j++] =) cc)
                (if (== j MAX_MCO)
                    (ร BREAK)
                )
            )
        )

        (if (< j MAX_MCO)    ;; last composing char must be 0
            ((ร pcc[j] =) 0)
        )

        (us_ptr2char p)
    ))

;; Convert a UTF-8 byte string to a wide character.
;; Also get up to MAX_MCO composing characters.
;; Use no more than p[maxlen].

(defn- #_int us_ptr2char_cc_len [#_Bytes p, #_int* pcc, #_int maxlen]
    ;; pcc: return: composing chars, last one is 0
    (ยง
        ((ร int j =) 0)

        ;; Only accept a composing char when the first char isn't illegal.
        ((ร int i =) (us_ptr2len_len p, maxlen))
        (when (or (< 1 i) (< (char_u (ยง p.at(0))) 0x80))
            ((ร FOR) (ร (ยง int cc) (ยง i < maxlen && 0x80 <= char_u(p.at(i)) && utf_iscomposing(cc = us_ptr2char(p.plus(i)))) (ยง i += us_ptr2len_len(p.plus(i), maxlen - i)))
                ((ร pcc[j++] =) cc)
                (if (== j MAX_MCO)
                    (ร BREAK)
                )
            )
        )

        (if (< j MAX_MCO)    ;; last composing char must be 0
            ((ร pcc[j] =) 0)
        )

        (us_ptr2char p)
    ))

;; Convert the character at screen position "off" to a sequence of bytes.
;; Includes the composing characters.
;; "buf" must at least have the length MB_MAXBYTES + 1.
;; Only to be used when screenLinesUC[off] != 0.
;; Returns the produced number of bytes.

(defn- #_int utfc_char2bytes [#_int off, #_Bytes buf]
    (ยง
        ((ร int len =) (ยง utf_char2bytes(@screenLinesUC[off], buf)))
        ((ร FOR) (ร (ยง int i = 0) (< i @screen_mco) (ยง i++))
            (if (zero? (ยง @screenLinesC[i][off]))
                (ร BREAK)
            )
            ((ร len +=) (ยง utf_char2bytes(@screenLinesC[i][off], buf.plus(len))))
        )
        len
    ))

;; Get the length of a UTF-8 byte sequence, not including any following composing characters.
;; Returns 0 for "".
;; Returns 1 for an illegal byte sequence.

(defn- #_int us_ptr2len [#_Bytes p]
    (ยง
        (if (eos? p)
            ((ร RETURN) 0)
        )

        ((ร int len =) (ยง us_byte2len(p.at(0), false)))
        ((ร FOR) (ร (ยง int i = 1) (< i len) (ยง i++))
            (if (ยง (char_u(p.at(i)) & 0xc0) != 0x80)
                ((ร RETURN) 1)
            )
        )

        len
    ))

;; Get the length of UTF-8 byte sequence "p[size]".
;; Does not include any following composing characters.
;; Returns 1 for "".
;; Returns 1 for an illegal byte sequence (also in incomplete byte seq.).
;; Returns number > "size" for an incomplete byte sequence.
;; Never returns zero.

(defn- #_int us_ptr2len_len [#_Bytes p, #_int size]
    (ยง
        ((ร int len =) (ยง us_byte2len(p.at(0), false)))
        (if (== len 1)
            ((ร RETURN) 1)       ;; NUL, ASCII or illegal lead byte
        )

        ((ร int m =) (if (< size len) size len))  ;; incomplete byte sequence?
        ((ร FOR) (ร (ยง int i = 1) (< i m) (ยง i++))
            (if (ยง (char_u(p.at(i)) & 0xc0) != 0x80)
                ((ร RETURN) 1)
            )
        )

        len
    ))

;; Return the number of bytes the UTF-8 encoding of the character at "p" takes.
;; This includes following composing characters.

(defn- #_int us_ptr2len_cc [#_Bytes p]
    (ยง
        (if (eos? p)
            ((ร RETURN) 0)
        )
        (if (and (< (char_u (ยง p.at(0))) 0x80) (< (char_u (ยง p.at(1))) 0x80))     ;; be quick for ASCII
            ((ร RETURN) 1)
        )

        ;; Skip over first UTF-8 char, stopping at a NUL byte.
        ((ร int len =) (us_ptr2len p))

        ;; Check for illegal byte.
        (if (and (== len 1) (<= 0x80 (char_u (ยง p.at(0)))))
            ((ร RETURN) 1)
        )

        ;; Check for composing characters.  We can handle only the first six,
        ;; but skip all of them (otherwise the cursor would get stuck).

        (while (ยง 0x80 <= char_u(p.at(len)) && utf_iscomposing(us_ptr2char(p.plus(len))))
            ;; Skip over composing char.
            ((ร len +=) (ยง us_ptr2len(p.plus(len))))
        )

        len
    ))

;; Return the number of bytes the UTF-8 encoding of the character at "p[size]" takes.
;; This includes following composing characters.
;; Returns 0 for an empty string.
;; Returns 1 for an illegal char or an incomplete byte sequence.

(defn- #_int us_ptr2len_cc_len [#_Bytes p, #_int size]
    (ยง
        (if (or (< size 1) (eos? p))
            ((ร RETURN) 0)
        )
        (if (and (< (char_u (ยง p.at(0))) 0x80) (or (== size 1) (< (char_u (ยง p.at(1))) 0x80)))    ;; be quick for ASCII
            ((ร RETURN) 1)
        )

        ;; Skip over first UTF-8 char, stopping at a NUL byte.
        ((ร int len =) (us_ptr2len_len p, size))

        ;; Check for illegal byte and incomplete byte sequence.
        (if (or (and (== len 1) (<= 0x80 (char_u (ยง p.at(0))))) (< size len))
            ((ร RETURN) 1)
        )

        ;; Check for composing characters.  We can handle only the first six,
        ;; but skip all of them (otherwise the cursor would get stuck).

        (while (ยง len < size && 0x80 <= char_u(p.at(len)))
            ;; Next character length should not go beyond size to ensure
            ;; that UTF_COMPOSINGLIKE(...) does not read beyond size.

            ((ร int len_next_char =) (ยง us_ptr2len_len(p.plus(len), size - len)))
            (if (< (- size len) len_next_char)
                (ร BREAK)
            )

            (if (not (utf_iscomposing (us_ptr2char (ยง p.plus(len)))))
                (ร BREAK)
            )

            ;; Skip over composing char.
            ((ร len +=) len_next_char)
        )

        len
    ))

;; Return the number of bytes the UTF-8 encoding of character "c" takes.
;; This does not include composing characters.

(defn- #_int utf_char2len [#_int c]
    (ยง
        (if (< c 0x80)
            ((ร RETURN) 1)
        )
        (if (< c 0x800)
            ((ร RETURN) 2)
        )
        (if (< c 0x10000)
            ((ร RETURN) 3)
        )
        (if (< c 0x200000)
            ((ร RETURN) 4)
        )
        (if (< c 0x4000000)
            ((ร RETURN) 5)
        )

        6
    ))

;; Convert Unicode character "c" to UTF-8 string in "buf[]".
;; Returns the number of bytes.
;; This does not include composing characters.

(defn- #_int utf_char2bytes [#_int c, #_Bytes buf]
    (ยง
        (when (< c 0x80)               ;; 7 bits
            (.be buf 0, c)
            ((ร RETURN) 1)
        )

        (when (< c 0x800)              ;; 11 bits
            (ยง buf.be(0, 0xc0 + (c >>> 6)))
            (ยง buf.be(1, 0x80 + (c & 0x3f)))
            ((ร RETURN) 2)
        )

        (when (< c 0x10000)            ;; 16 bits
            (ยง buf.be(0, 0xe0 + (c >>> 12)))
            (ยง buf.be(1, 0x80 + ((c >>> 6) & 0x3f)))
            (ยง buf.be(2, 0x80 + (c & 0x3f)))
            ((ร RETURN) 3)
        )

        (when (< c 0x200000)           ;; 21 bits
            (ยง buf.be(0, 0xf0 + (c >>> 18)))
            (ยง buf.be(1, 0x80 + ((c >>> 12) & 0x3f)))
            (ยง buf.be(2, 0x80 + ((c >>> 6) & 0x3f)))
            (ยง buf.be(3, 0x80 + (c & 0x3f)))
            ((ร RETURN) 4)
        )

        (when (< c 0x4000000)          ;; 26 bits
            (ยง buf.be(0, 0xf8 + (c >>> 24)))
            (ยง buf.be(1, 0x80 + ((c >>> 18) & 0x3f)))
            (ยง buf.be(2, 0x80 + ((c >>> 12) & 0x3f)))
            (ยง buf.be(3, 0x80 + ((c >>> 6) & 0x3f)))
            (ยง buf.be(4, 0x80 + (c & 0x3f)))
            ((ร RETURN) 5)
        )

                                    ;; 31 bits
;       {
            (ยง buf.be(0, 0xfc + (c >>> 30)))
            (ยง buf.be(1, 0x80 + ((c >>> 24) & 0x3f)))
            (ยง buf.be(2, 0x80 + ((c >>> 18) & 0x3f)))
            (ยง buf.be(3, 0x80 + ((c >>> 12) & 0x3f)))
            (ยง buf.be(4, 0x80 + ((c >>> 6) & 0x3f)))
            (ยง buf.be(5, 0x80 + (c & 0x3f)))
            ((ร RETURN) 6)
;       }
    ))

;; Sorted list of non-overlapping intervals.
;; Generated by tools/unicode.vim.

(final int* combining
    [
        0x0300, 0x036f,
        0x0483, 0x0489,
        0x0591, 0x05bd,
        0x05bf, 0x05bf,
        0x05c1, 0x05c2,
        0x05c4, 0x05c5,
        0x05c7, 0x05c7,
        0x0610, 0x061a,
        0x064b, 0x065f,
        0x0670, 0x0670,
        0x06d6, 0x06dc,
        0x06df, 0x06e4,
        0x06e7, 0x06e8,
        0x06ea, 0x06ed,
        0x0711, 0x0711,
        0x0730, 0x074a,
        0x07a6, 0x07b0,
        0x07eb, 0x07f3,
        0x0816, 0x0819,
        0x081b, 0x0823,
        0x0825, 0x0827,
        0x0829, 0x082d,
        0x0859, 0x085b,
        0x08e4, 0x0903,
        0x093a, 0x093c,
        0x093e, 0x094f,
        0x0951, 0x0957,
        0x0962, 0x0963,
        0x0981, 0x0983,
        0x09bc, 0x09bc,
        0x09be, 0x09c4,
        0x09c7, 0x09c8,
        0x09cb, 0x09cd,
        0x09d7, 0x09d7,
        0x09e2, 0x09e3,
        0x0a01, 0x0a03,
        0x0a3c, 0x0a3c,
        0x0a3e, 0x0a42,
        0x0a47, 0x0a48,
        0x0a4b, 0x0a4d,
        0x0a51, 0x0a51,
        0x0a70, 0x0a71,
        0x0a75, 0x0a75,
        0x0a81, 0x0a83,
        0x0abc, 0x0abc,
        0x0abe, 0x0ac5,
        0x0ac7, 0x0ac9,
        0x0acb, 0x0acd,
        0x0ae2, 0x0ae3,
        0x0b01, 0x0b03,
        0x0b3c, 0x0b3c,
        0x0b3e, 0x0b44,
        0x0b47, 0x0b48,
        0x0b4b, 0x0b4d,
        0x0b56, 0x0b57,
        0x0b62, 0x0b63,
        0x0b82, 0x0b82,
        0x0bbe, 0x0bc2,
        0x0bc6, 0x0bc8,
        0x0bca, 0x0bcd,
        0x0bd7, 0x0bd7,
        0x0c00, 0x0c03,
        0x0c3e, 0x0c44,
        0x0c46, 0x0c48,
        0x0c4a, 0x0c4d,
        0x0c55, 0x0c56,
        0x0c62, 0x0c63,
        0x0c81, 0x0c83,
        0x0cbc, 0x0cbc,
        0x0cbe, 0x0cc4,
        0x0cc6, 0x0cc8,
        0x0cca, 0x0ccd,
        0x0cd5, 0x0cd6,
        0x0ce2, 0x0ce3,
        0x0d01, 0x0d03,
        0x0d3e, 0x0d44,
        0x0d46, 0x0d48,
        0x0d4a, 0x0d4d,
        0x0d57, 0x0d57,
        0x0d62, 0x0d63,
        0x0d82, 0x0d83,
        0x0dca, 0x0dca,
        0x0dcf, 0x0dd4,
        0x0dd6, 0x0dd6,
        0x0dd8, 0x0ddf,
        0x0df2, 0x0df3,
        0x0e31, 0x0e31,
        0x0e34, 0x0e3a,
        0x0e47, 0x0e4e,
        0x0eb1, 0x0eb1,
        0x0eb4, 0x0eb9,
        0x0ebb, 0x0ebc,
        0x0ec8, 0x0ecd,
        0x0f18, 0x0f19,
        0x0f35, 0x0f35,
        0x0f37, 0x0f37,
        0x0f39, 0x0f39,
        0x0f3e, 0x0f3f,
        0x0f71, 0x0f84,
        0x0f86, 0x0f87,
        0x0f8d, 0x0f97,
        0x0f99, 0x0fbc,
        0x0fc6, 0x0fc6,
        0x102b, 0x103e,
        0x1056, 0x1059,
        0x105e, 0x1060,
        0x1062, 0x1064,
        0x1067, 0x106d,
        0x1071, 0x1074,
        0x1082, 0x108d,
        0x108f, 0x108f,
        0x109a, 0x109d,
        0x135d, 0x135f,
        0x1712, 0x1714,
        0x1732, 0x1734,
        0x1752, 0x1753,
        0x1772, 0x1773,
        0x17b4, 0x17d3,
        0x17dd, 0x17dd,
        0x180b, 0x180d,
        0x18a9, 0x18a9,
        0x1920, 0x192b,
        0x1930, 0x193b,
        0x19b0, 0x19c0,
        0x19c8, 0x19c9,
        0x1a17, 0x1a1b,
        0x1a55, 0x1a5e,
        0x1a60, 0x1a7c,
        0x1a7f, 0x1a7f,
        0x1ab0, 0x1abe,
        0x1b00, 0x1b04,
        0x1b34, 0x1b44,
        0x1b6b, 0x1b73,
        0x1b80, 0x1b82,
        0x1ba1, 0x1bad,
        0x1be6, 0x1bf3,
        0x1c24, 0x1c37,
        0x1cd0, 0x1cd2,
        0x1cd4, 0x1ce8,
        0x1ced, 0x1ced,
        0x1cf2, 0x1cf4,
        0x1cf8, 0x1cf9,
        0x1dc0, 0x1df5,
        0x1dfc, 0x1dff,
        0x20d0, 0x20f0,
        0x2cef, 0x2cf1,
        0x2d7f, 0x2d7f,
        0x2de0, 0x2dff,
        0x302a, 0x302f,
        0x3099, 0x309a,
        0xa66f, 0xa672,
        0xa674, 0xa67d,
        0xa69f, 0xa69f,
        0xa6f0, 0xa6f1,
        0xa802, 0xa802,
        0xa806, 0xa806,
        0xa80b, 0xa80b,
        0xa823, 0xa827,
        0xa880, 0xa881,
        0xa8b4, 0xa8c4,
        0xa8e0, 0xa8f1,
        0xa926, 0xa92d,
        0xa947, 0xa953,
        0xa980, 0xa983,
        0xa9b3, 0xa9c0,
        0xa9e5, 0xa9e5,
        0xaa29, 0xaa36,
        0xaa43, 0xaa43,
        0xaa4c, 0xaa4d,
        0xaa7b, 0xaa7d,
        0xaab0, 0xaab0,
        0xaab2, 0xaab4,
        0xaab7, 0xaab8,
        0xaabe, 0xaabf,
        0xaac1, 0xaac1,
        0xaaeb, 0xaaef,
        0xaaf5, 0xaaf6,
        0xabe3, 0xabea,
        0xabec, 0xabed,
        0xfb1e, 0xfb1e,
        0xfe00, 0xfe0f,
        0xfe20, 0xfe2d,
        0x101fd, 0x101fd,
        0x102e0, 0x102e0,
        0x10376, 0x1037a,
        0x10a01, 0x10a03,
        0x10a05, 0x10a06,
        0x10a0c, 0x10a0f,
        0x10a38, 0x10a3a,
        0x10a3f, 0x10a3f,
        0x10ae5, 0x10ae6,
        0x11000, 0x11002,
        0x11038, 0x11046,
        0x1107f, 0x11082,
        0x110b0, 0x110ba,
        0x11100, 0x11102,
        0x11127, 0x11134,
        0x11173, 0x11173,
        0x11180, 0x11182,
        0x111b3, 0x111c0,
        0x1122c, 0x11237,
        0x112df, 0x112ea,
        0x11301, 0x11303,
        0x1133c, 0x1133c,
        0x1133e, 0x11344,
        0x11347, 0x11348,
        0x1134b, 0x1134d,
        0x11357, 0x11357,
        0x11362, 0x11363,
        0x11366, 0x1136c,
        0x11370, 0x11374,
        0x114b0, 0x114c3,
        0x115af, 0x115b5,
        0x115b8, 0x115c0,
        0x11630, 0x11640,
        0x116ab, 0x116b7,
        0x16af0, 0x16af4,
        0x16b30, 0x16b36,
        0x16f51, 0x16f7e,
        0x16f8f, 0x16f92,
        0x1bc9d, 0x1bc9e,
        0x1d165, 0x1d169,
        0x1d16d, 0x1d172,
        0x1d17b, 0x1d182,
        0x1d185, 0x1d18b,
        0x1d1aa, 0x1d1ad,
        0x1d242, 0x1d244,
        0x1e8d0, 0x1e8d6,
        0xe0100, 0xe01ef
    ])

;; Return true if "c" is a composing UTF-8 character.
;; This means it will be drawn on top of the preceding character.

(defn- #_boolean utf_iscomposing [#_int c]
    (intable combining, c))

;; Sorted list of non-overlapping intervals.
;; 0xd800-0xdfff is reserved for UTF-16, actually illegal.

(final int* nonprint
    [
        0x070f, 0x070f,
        0x180b, 0x180e,
        0x200b, 0x200f,
        0x202a, 0x202e,
        0x206a, 0x206f,
        0xd800, 0xdfff,
        0xfeff, 0xfeff,
        0xfff9, 0xfffb,
        0xfffe, 0xffff
    ])

;; Return true for characters that can be displayed in a normal way.
;; Only for characters of 0x100 and above!

(defn- #_boolean utf_printable [#_int c]
    (not (intable nonprint, c)))

;; sorted list of non-overlapping intervals
(final int* classes
    [
        0x037e, 0x037e, 1,          ;; Greek question mark
        0x0387, 0x0387, 1,          ;; Greek ano teleia
        0x055a, 0x055f, 1,          ;; Armenian punctuation
        0x0589, 0x0589, 1,          ;; Armenian full stop
        0x05be, 0x05be, 1,
        0x05c0, 0x05c0, 1,
        0x05c3, 0x05c3, 1,
        0x05f3, 0x05f4, 1,
        0x060c, 0x060c, 1,
        0x061b, 0x061b, 1,
        0x061f, 0x061f, 1,
        0x066a, 0x066d, 1,
        0x06d4, 0x06d4, 1,
        0x0700, 0x070d, 1,          ;; Syriac punctuation
        0x0964, 0x0965, 1,
        0x0970, 0x0970, 1,
        0x0df4, 0x0df4, 1,
        0x0e4f, 0x0e4f, 1,
        0x0e5a, 0x0e5b, 1,
        0x0f04, 0x0f12, 1,
        0x0f3a, 0x0f3d, 1,
        0x0f85, 0x0f85, 1,
        0x104a, 0x104f, 1,          ;; Myanmar punctuation
        0x10fb, 0x10fb, 1,          ;; Georgian punctuation
        0x1361, 0x1368, 1,          ;; Ethiopic punctuation
        0x166d, 0x166e, 1,          ;; Canadian Syl. punctuation
        0x1680, 0x1680, 0,
        0x169b, 0x169c, 1,
        0x16eb, 0x16ed, 1,
        0x1735, 0x1736, 1,
        0x17d4, 0x17dc, 1,          ;; Khmer punctuation
        0x1800, 0x180a, 1,          ;; Mongolian punctuation
        0x2000, 0x200b, 0,          ;; spaces
        0x200c, 0x2027, 1,          ;; punctuation and symbols
        0x2028, 0x2029, 0,
        0x202a, 0x202e, 1,          ;; punctuation and symbols
        0x202f, 0x202f, 0,
        0x2030, 0x205e, 1,          ;; punctuation and symbols
        0x205f, 0x205f, 0,
        0x2060, 0x27ff, 1,          ;; punctuation and symbols
        0x2070, 0x207f, 0x2070,     ;; superscript
        0x2080, 0x2094, 0x2080,     ;; subscript
        0x20a0, 0x27ff, 1,          ;; all kinds of symbols
        0x2800, 0x28ff, 0x2800,     ;; braille
        0x2900, 0x2998, 1,          ;; arrows, brackets, etc.
        0x29d8, 0x29db, 1,
        0x29fc, 0x29fd, 1,
        0x2e00, 0x2e7f, 1,          ;; supplemental punctuation
        0x3000, 0x3000, 0,          ;; ideographic space
        0x3001, 0x3020, 1,          ;; ideographic punctuation
        0x3030, 0x3030, 1,
        0x303d, 0x303d, 1,
        0x3040, 0x309f, 0x3040,     ;; Hiragana
        0x30a0, 0x30ff, 0x30a0,     ;; Katakana
        0x3300, 0x9fff, 0x4e00,     ;; CJK Ideographs
        0xac00, 0xd7a3, 0xac00,     ;; Hangul Syllables
        0xf900, 0xfaff, 0x4e00,     ;; CJK Ideographs
        0xfd3e, 0xfd3f, 1,
        0xfe30, 0xfe6b, 1,          ;; punctuation forms
        0xff00, 0xff0f, 1,          ;; half/fullwidth ASCII
        0xff1a, 0xff20, 1,          ;; half/fullwidth ASCII
        0xff3b, 0xff40, 1,          ;; half/fullwidth ASCII
        0xff5b, 0xff65, 1,          ;; half/fullwidth ASCII
        0x20000, 0x2a6df, 0x4e00,   ;; CJK Ideographs
        0x2a700, 0x2b73f, 0x4e00,   ;; CJK Ideographs
        0x2b740, 0x2b81f, 0x4e00,   ;; CJK Ideographs
        0x2f800, 0x2fa1f, 0x4e00    ;; CJK Ideographs
    ])

;; Get class of a Unicode character.
;;  0: white space
;;  1: punctuation
;;  2 or bigger: some class of word character.

(defn- #_int utf_class [#_int c]
    (ยง
        ;; First quick check for Latin1 characters, use 'iskeyword'.
        (when (< c 0x100)
            (if (or (== c (byte \space)) (== c (byte \tab)) (== c NUL) (== c 0xa0))
                ((ร RETURN) 0)       ;; blank
            )
            (if (vim_iswordc c, @curbuf)
                ((ร RETURN) 2)       ;; word character
            )

            ((ร RETURN) 1)           ;; punctuation
        )

        ;; binary search in table
        ((ร FOR) (ร (ยง int bot = 0, top = classes.length / 3 - 1) (<= bot top) nil)
            ((ร int mid =) (ยง (bot + top) / 2))
            (cond (ยง classes[3 * mid + 1] < c)
            (ยง
                ((ร bot =) (+ mid 1))
            )
            (< c (ยง classes[3 * mid]))
            (ยง
                ((ร top =) (- mid 1))
            )
            :else
            (ยง
                ((ร RETURN) (ยง classes[3 * mid + 2]))
            ))
        )

        ;; most other characters are "word" characters
        2
    ))

;; Code for Unicode case-dependent operations.  Based on notes in
;; http://www.unicode.org/Public/UNIDATA/CaseFolding.txt
;; This code uses simple case folding, not full case folding.
;; Last updated for Unicode 5.2.

;; Generic conversion function for case operations.
;; Return the converted equivalent of "c", which is a UCS-4 character.
;; Use the given conversion "table".
;; Uses binary search on "table".

(defn- #_int utf_convert [#_int c, #_int* table]
    (ยง
        ((ร int start =) (ยง 0, entries = table.length / 4))

        ((ร FOR) (ร (ยง int end = entries) (< start end) nil)
            ;; need to search further
            ((ร int mid =) (ยง (start + end) / 2))
            (if (ยง table[4 * mid + 1] < c)
                ((ร start =) (+ mid 1))
                ((ร end =) mid)
            )
        )

        (when (< start entries)
            ((ร int i =) (* 4 start))
            (if (and (<= (ยง table[i]) c) (<= c (ยง table[i + 1])) (zero? (% (- c (ยง table[i])) (ยง table[i + 2]))))
                ((ร RETURN) (ยง c + table[i + 3]))
            )
        )

        c
    ))

;; The following tables are built by tools/unicode.vim.
;; They must be in numeric order, because we use binary search.
;; An entry such as {0x41,0x5a,1,32} means that Unicode characters in the
;; range from 0x41 to 0x5a inclusive, stepping by 1, are changed to
;; folded/upper/lower by adding 32.

(final int* foldCase
    [
        0x41, 0x5a, 1, 32,
        0xb5, 0xb5,-1, 775,
        0xc0, 0xd6, 1, 32,
        0xd8, 0xde, 1, 32,
        0x100, 0x12e, 2, 1,
        0x132, 0x136, 2, 1,
        0x139, 0x147, 2, 1,
        0x14a, 0x176, 2, 1,
        0x178, 0x178,-1,-121,
        0x179, 0x17d, 2, 1,
        0x17f, 0x17f,-1,-268,
        0x181, 0x181,-1, 210,
        0x182, 0x184, 2, 1,
        0x186, 0x186,-1, 206,
        0x187, 0x187,-1, 1,
        0x189, 0x18a, 1, 205,
        0x18b, 0x18b,-1, 1,
        0x18e, 0x18e,-1, 79,
        0x18f, 0x18f,-1, 202,
        0x190, 0x190,-1, 203,
        0x191, 0x191,-1, 1,
        0x193, 0x193,-1, 205,
        0x194, 0x194,-1, 207,
        0x196, 0x196,-1, 211,
        0x197, 0x197,-1, 209,
        0x198, 0x198,-1, 1,
        0x19c, 0x19c,-1, 211,
        0x19d, 0x19d,-1, 213,
        0x19f, 0x19f,-1, 214,
        0x1a0, 0x1a4, 2, 1,
        0x1a6, 0x1a6,-1, 218,
        0x1a7, 0x1a7,-1, 1,
        0x1a9, 0x1a9,-1, 218,
        0x1ac, 0x1ac,-1, 1,
        0x1ae, 0x1ae,-1, 218,
        0x1af, 0x1af,-1, 1,
        0x1b1, 0x1b2, 1, 217,
        0x1b3, 0x1b5, 2, 1,
        0x1b7, 0x1b7,-1, 219,
        0x1b8, 0x1bc, 4, 1,
        0x1c4, 0x1c4,-1, 2,
        0x1c5, 0x1c5,-1, 1,
        0x1c7, 0x1c7,-1, 2,
        0x1c8, 0x1c8,-1, 1,
        0x1ca, 0x1ca,-1, 2,
        0x1cb, 0x1db, 2, 1,
        0x1de, 0x1ee, 2, 1,
        0x1f1, 0x1f1,-1, 2,
        0x1f2, 0x1f4, 2, 1,
        0x1f6, 0x1f6,-1,-97,
        0x1f7, 0x1f7,-1,-56,
        0x1f8, 0x21e, 2, 1,
        0x220, 0x220,-1,-130,
        0x222, 0x232, 2, 1,
        0x23a, 0x23a,-1, 10795,
        0x23b, 0x23b,-1, 1,
        0x23d, 0x23d,-1,-163,
        0x23e, 0x23e,-1, 10792,
        0x241, 0x241,-1, 1,
        0x243, 0x243,-1,-195,
        0x244, 0x244,-1, 69,
        0x245, 0x245,-1, 71,
        0x246, 0x24e, 2, 1,
        0x345, 0x345,-1, 116,
        0x370, 0x372, 2, 1,
        0x376, 0x376,-1, 1,
        0x37f, 0x37f,-1, 116,
        0x386, 0x386,-1, 38,
        0x388, 0x38a, 1, 37,
        0x38c, 0x38c,-1, 64,
        0x38e, 0x38f, 1, 63,
        0x391, 0x3a1, 1, 32,
        0x3a3, 0x3ab, 1, 32,
        0x3c2, 0x3c2,-1, 1,
        0x3cf, 0x3cf,-1, 8,
        0x3d0, 0x3d0,-1,-30,
        0x3d1, 0x3d1,-1,-25,
        0x3d5, 0x3d5,-1,-15,
        0x3d6, 0x3d6,-1,-22,
        0x3d8, 0x3ee, 2, 1,
        0x3f0, 0x3f0,-1,-54,
        0x3f1, 0x3f1,-1,-48,
        0x3f4, 0x3f4,-1,-60,
        0x3f5, 0x3f5,-1,-64,
        0x3f7, 0x3f7,-1, 1,
        0x3f9, 0x3f9,-1,-7,
        0x3fa, 0x3fa,-1, 1,
        0x3fd, 0x3ff, 1,-130,
        0x400, 0x40f, 1, 80,
        0x410, 0x42f, 1, 32,
        0x460, 0x480, 2, 1,
        0x48a, 0x4be, 2, 1,
        0x4c0, 0x4c0,-1, 15,
        0x4c1, 0x4cd, 2, 1,
        0x4d0, 0x52e, 2, 1,
        0x531, 0x556, 1, 48,
        0x10a0, 0x10c5, 1, 7264,
        0x10c7, 0x10cd, 6, 7264,
        0x1e00, 0x1e94, 2, 1,
        0x1e9b, 0x1e9b,-1,-58,
        0x1e9e, 0x1e9e,-1,-7615,
        0x1ea0, 0x1efe, 2, 1,
        0x1f08, 0x1f0f, 1,-8,
        0x1f18, 0x1f1d, 1,-8,
        0x1f28, 0x1f2f, 1,-8,
        0x1f38, 0x1f3f, 1,-8,
        0x1f48, 0x1f4d, 1,-8,
        0x1f59, 0x1f5f, 2,-8,
        0x1f68, 0x1f6f, 1,-8,
        0x1f88, 0x1f8f, 1,-8,
        0x1f98, 0x1f9f, 1,-8,
        0x1fa8, 0x1faf, 1,-8,
        0x1fb8, 0x1fb9, 1,-8,
        0x1fba, 0x1fbb, 1,-74,
        0x1fbc, 0x1fbc,-1,-9,
        0x1fbe, 0x1fbe,-1,-7173,
        0x1fc8, 0x1fcb, 1,-86,
        0x1fcc, 0x1fcc,-1,-9,
        0x1fd8, 0x1fd9, 1,-8,
        0x1fda, 0x1fdb, 1,-100,
        0x1fe8, 0x1fe9, 1,-8,
        0x1fea, 0x1feb, 1,-112,
        0x1fec, 0x1fec,-1,-7,
        0x1ff8, 0x1ff9, 1,-128,
        0x1ffa, 0x1ffb, 1,-126,
        0x1ffc, 0x1ffc,-1,-9,
        0x2126, 0x2126,-1,-7517,
        0x212a, 0x212a,-1,-8383,
        0x212b, 0x212b,-1,-8262,
        0x2132, 0x2132,-1, 28,
        0x2160, 0x216f, 1, 16,
        0x2183, 0x2183,-1, 1,
        0x24b6, 0x24cf, 1, 26,
        0x2c00, 0x2c2e, 1, 48,
        0x2c60, 0x2c60,-1, 1,
        0x2c62, 0x2c62,-1,-10743,
        0x2c63, 0x2c63,-1,-3814,
        0x2c64, 0x2c64,-1,-10727,
        0x2c67, 0x2c6b, 2, 1,
        0x2c6d, 0x2c6d,-1,-10780,
        0x2c6e, 0x2c6e,-1,-10749,
        0x2c6f, 0x2c6f,-1,-10783,
        0x2c70, 0x2c70,-1,-10782,
        0x2c72, 0x2c75, 3, 1,
        0x2c7e, 0x2c7f, 1,-10815,
        0x2c80, 0x2ce2, 2, 1,
        0x2ceb, 0x2ced, 2, 1,
        0x2cf2, 0xa640, 31054, 1,
        0xa642, 0xa66c, 2, 1,
        0xa680, 0xa69a, 2, 1,
        0xa722, 0xa72e, 2, 1,
        0xa732, 0xa76e, 2, 1,
        0xa779, 0xa77b, 2, 1,
        0xa77d, 0xa77d,-1,-35332,
        0xa77e, 0xa786, 2, 1,
        0xa78b, 0xa78b,-1, 1,
        0xa78d, 0xa78d,-1,-42280,
        0xa790, 0xa792, 2, 1,
        0xa796, 0xa7a8, 2, 1,
        0xa7aa, 0xa7aa,-1,-42308,
        0xa7ab, 0xa7ab,-1,-42319,
        0xa7ac, 0xa7ac,-1,-42315,
        0xa7ad, 0xa7ad,-1,-42305,
        0xa7b0, 0xa7b0,-1,-42258,
        0xa7b1, 0xa7b1,-1,-42282,
        0xff21, 0xff3a, 1, 32,
        0x10400, 0x10427, 1, 40,
        0x118a0, 0x118bf, 1, 32
    ])

;; Return the folded-case equivalent of "c", which is a UCS-4 character.  Uses simple case folding.

(defn- #_int utf_fold [#_int c]
    (utf_convert c, foldCase))

(final int* toLower
    [
        0x41, 0x5a, 1, 32,
        0xc0, 0xd6, 1, 32,
        0xd8, 0xde, 1, 32,
        0x100, 0x12e, 2, 1,
        0x130, 0x130,-1,-199,
        0x132, 0x136, 2, 1,
        0x139, 0x147, 2, 1,
        0x14a, 0x176, 2, 1,
        0x178, 0x178,-1,-121,
        0x179, 0x17d, 2, 1,
        0x181, 0x181,-1, 210,
        0x182, 0x184, 2, 1,
        0x186, 0x186,-1, 206,
        0x187, 0x187,-1, 1,
        0x189, 0x18a, 1, 205,
        0x18b, 0x18b,-1, 1,
        0x18e, 0x18e,-1, 79,
        0x18f, 0x18f,-1, 202,
        0x190, 0x190,-1, 203,
        0x191, 0x191,-1, 1,
        0x193, 0x193,-1, 205,
        0x194, 0x194,-1, 207,
        0x196, 0x196,-1, 211,
        0x197, 0x197,-1, 209,
        0x198, 0x198,-1, 1,
        0x19c, 0x19c,-1, 211,
        0x19d, 0x19d,-1, 213,
        0x19f, 0x19f,-1, 214,
        0x1a0, 0x1a4, 2, 1,
        0x1a6, 0x1a6,-1, 218,
        0x1a7, 0x1a7,-1, 1,
        0x1a9, 0x1a9,-1, 218,
        0x1ac, 0x1ac,-1, 1,
        0x1ae, 0x1ae,-1, 218,
        0x1af, 0x1af,-1, 1,
        0x1b1, 0x1b2, 1, 217,
        0x1b3, 0x1b5, 2, 1,
        0x1b7, 0x1b7,-1, 219,
        0x1b8, 0x1bc, 4, 1,
        0x1c4, 0x1c4,-1, 2,
        0x1c5, 0x1c5,-1, 1,
        0x1c7, 0x1c7,-1, 2,
        0x1c8, 0x1c8,-1, 1,
        0x1ca, 0x1ca,-1, 2,
        0x1cb, 0x1db, 2, 1,
        0x1de, 0x1ee, 2, 1,
        0x1f1, 0x1f1,-1, 2,
        0x1f2, 0x1f4, 2, 1,
        0x1f6, 0x1f6,-1,-97,
        0x1f7, 0x1f7,-1,-56,
        0x1f8, 0x21e, 2, 1,
        0x220, 0x220,-1,-130,
        0x222, 0x232, 2, 1,
        0x23a, 0x23a,-1, 10795,
        0x23b, 0x23b,-1, 1,
        0x23d, 0x23d,-1,-163,
        0x23e, 0x23e,-1, 10792,
        0x241, 0x241,-1, 1,
        0x243, 0x243,-1,-195,
        0x244, 0x244,-1, 69,
        0x245, 0x245,-1, 71,
        0x246, 0x24e, 2, 1,
        0x370, 0x372, 2, 1,
        0x376, 0x376,-1, 1,
        0x37f, 0x37f,-1, 116,
        0x386, 0x386,-1, 38,
        0x388, 0x38a, 1, 37,
        0x38c, 0x38c,-1, 64,
        0x38e, 0x38f, 1, 63,
        0x391, 0x3a1, 1, 32,
        0x3a3, 0x3ab, 1, 32,
        0x3cf, 0x3cf,-1, 8,
        0x3d8, 0x3ee, 2, 1,
        0x3f4, 0x3f4,-1,-60,
        0x3f7, 0x3f7,-1, 1,
        0x3f9, 0x3f9,-1,-7,
        0x3fa, 0x3fa,-1, 1,
        0x3fd, 0x3ff, 1,-130,
        0x400, 0x40f, 1, 80,
        0x410, 0x42f, 1, 32,
        0x460, 0x480, 2, 1,
        0x48a, 0x4be, 2, 1,
        0x4c0, 0x4c0,-1, 15,
        0x4c1, 0x4cd, 2, 1,
        0x4d0, 0x52e, 2, 1,
        0x531, 0x556, 1, 48,
        0x10a0, 0x10c5, 1, 7264,
        0x10c7, 0x10cd, 6, 7264,
        0x1e00, 0x1e94, 2, 1,
        0x1e9e, 0x1e9e,-1,-7615,
        0x1ea0, 0x1efe, 2, 1,
        0x1f08, 0x1f0f, 1,-8,
        0x1f18, 0x1f1d, 1,-8,
        0x1f28, 0x1f2f, 1,-8,
        0x1f38, 0x1f3f, 1,-8,
        0x1f48, 0x1f4d, 1,-8,
        0x1f59, 0x1f5f, 2,-8,
        0x1f68, 0x1f6f, 1,-8,
        0x1f88, 0x1f8f, 1,-8,
        0x1f98, 0x1f9f, 1,-8,
        0x1fa8, 0x1faf, 1,-8,
        0x1fb8, 0x1fb9, 1,-8,
        0x1fba, 0x1fbb, 1,-74,
        0x1fbc, 0x1fbc,-1,-9,
        0x1fc8, 0x1fcb, 1,-86,
        0x1fcc, 0x1fcc,-1,-9,
        0x1fd8, 0x1fd9, 1,-8,
        0x1fda, 0x1fdb, 1,-100,
        0x1fe8, 0x1fe9, 1,-8,
        0x1fea, 0x1feb, 1,-112,
        0x1fec, 0x1fec,-1,-7,
        0x1ff8, 0x1ff9, 1,-128,
        0x1ffa, 0x1ffb, 1,-126,
        0x1ffc, 0x1ffc,-1,-9,
        0x2126, 0x2126,-1,-7517,
        0x212a, 0x212a,-1,-8383,
        0x212b, 0x212b,-1,-8262,
        0x2132, 0x2132,-1, 28,
        0x2160, 0x216f, 1, 16,
        0x2183, 0x2183,-1, 1,
        0x24b6, 0x24cf, 1, 26,
        0x2c00, 0x2c2e, 1, 48,
        0x2c60, 0x2c60,-1, 1,
        0x2c62, 0x2c62,-1,-10743,
        0x2c63, 0x2c63,-1,-3814,
        0x2c64, 0x2c64,-1,-10727,
        0x2c67, 0x2c6b, 2, 1,
        0x2c6d, 0x2c6d,-1,-10780,
        0x2c6e, 0x2c6e,-1,-10749,
        0x2c6f, 0x2c6f,-1,-10783,
        0x2c70, 0x2c70,-1,-10782,
        0x2c72, 0x2c75, 3, 1,
        0x2c7e, 0x2c7f, 1,-10815,
        0x2c80, 0x2ce2, 2, 1,
        0x2ceb, 0x2ced, 2, 1,
        0x2cf2, 0xa640, 31054, 1,
        0xa642, 0xa66c, 2, 1,
        0xa680, 0xa69a, 2, 1,
        0xa722, 0xa72e, 2, 1,
        0xa732, 0xa76e, 2, 1,
        0xa779, 0xa77b, 2, 1,
        0xa77d, 0xa77d,-1,-35332,
        0xa77e, 0xa786, 2, 1,
        0xa78b, 0xa78b,-1, 1,
        0xa78d, 0xa78d,-1,-42280,
        0xa790, 0xa792, 2, 1,
        0xa796, 0xa7a8, 2, 1,
        0xa7aa, 0xa7aa,-1,-42308,
        0xa7ab, 0xa7ab,-1,-42319,
        0xa7ac, 0xa7ac,-1,-42315,
        0xa7ad, 0xa7ad,-1,-42305,
        0xa7b0, 0xa7b0,-1,-42258,
        0xa7b1, 0xa7b1,-1,-42282,
        0xff21, 0xff3a, 1, 32,
        0x10400, 0x10427, 1, 40,
        0x118a0, 0x118bf, 1, 32
    ])

(final int* toUpper
    [
        0x61, 0x7a, 1,-32,
        0xb5, 0xb5,-1, 743,
        0xe0, 0xf6, 1,-32,
        0xf8, 0xfe, 1,-32,
        0xff, 0xff,-1, 121,
        0x101, 0x12f, 2,-1,
        0x131, 0x131,-1,-232,
        0x133, 0x137, 2,-1,
        0x13a, 0x148, 2,-1,
        0x14b, 0x177, 2,-1,
        0x17a, 0x17e, 2,-1,
        0x17f, 0x17f,-1,-300,
        0x180, 0x180,-1, 195,
        0x183, 0x185, 2,-1,
        0x188, 0x18c, 4,-1,
        0x192, 0x192,-1,-1,
        0x195, 0x195,-1, 97,
        0x199, 0x199,-1,-1,
        0x19a, 0x19a,-1, 163,
        0x19e, 0x19e,-1, 130,
        0x1a1, 0x1a5, 2,-1,
        0x1a8, 0x1ad, 5,-1,
        0x1b0, 0x1b4, 4,-1,
        0x1b6, 0x1b9, 3,-1,
        0x1bd, 0x1bd,-1,-1,
        0x1bf, 0x1bf,-1, 56,
        0x1c5, 0x1c5,-1,-1,
        0x1c6, 0x1c6,-1,-2,
        0x1c8, 0x1c8,-1,-1,
        0x1c9, 0x1c9,-1,-2,
        0x1cb, 0x1cb,-1,-1,
        0x1cc, 0x1cc,-1,-2,
        0x1ce, 0x1dc, 2,-1,
        0x1dd, 0x1dd,-1,-79,
        0x1df, 0x1ef, 2,-1,
        0x1f2, 0x1f2,-1,-1,
        0x1f3, 0x1f3,-1,-2,
        0x1f5, 0x1f9, 4,-1,
        0x1fb, 0x21f, 2,-1,
        0x223, 0x233, 2,-1,
        0x23c, 0x23c,-1,-1,
        0x23f, 0x240, 1, 10815,
        0x242, 0x247, 5,-1,
        0x249, 0x24f, 2,-1,
        0x250, 0x250,-1, 10783,
        0x251, 0x251,-1, 10780,
        0x252, 0x252,-1, 10782,
        0x253, 0x253,-1,-210,
        0x254, 0x254,-1,-206,
        0x256, 0x257, 1,-205,
        0x259, 0x259,-1,-202,
        0x25b, 0x25b,-1,-203,
        0x25c, 0x25c,-1, 42319,
        0x260, 0x260,-1,-205,
        0x261, 0x261,-1, 42315,
        0x263, 0x263,-1,-207,
        0x265, 0x265,-1, 42280,
        0x266, 0x266,-1, 42308,
        0x268, 0x268,-1,-209,
        0x269, 0x269,-1,-211,
        0x26b, 0x26b,-1, 10743,
        0x26c, 0x26c,-1, 42305,
        0x26f, 0x26f,-1,-211,
        0x271, 0x271,-1, 10749,
        0x272, 0x272,-1,-213,
        0x275, 0x275,-1,-214,
        0x27d, 0x27d,-1, 10727,
        0x280, 0x283, 3,-218,
        0x287, 0x287,-1, 42282,
        0x288, 0x288,-1,-218,
        0x289, 0x289,-1,-69,
        0x28a, 0x28b, 1,-217,
        0x28c, 0x28c,-1,-71,
        0x292, 0x292,-1,-219,
        0x29e, 0x29e,-1, 42258,
        0x345, 0x345,-1, 84,
        0x371, 0x373, 2,-1,
        0x377, 0x377,-1,-1,
        0x37b, 0x37d, 1, 130,
        0x3ac, 0x3ac,-1,-38,
        0x3ad, 0x3af, 1,-37,
        0x3b1, 0x3c1, 1,-32,
        0x3c2, 0x3c2,-1,-31,
        0x3c3, 0x3cb, 1,-32,
        0x3cc, 0x3cc,-1,-64,
        0x3cd, 0x3ce, 1,-63,
        0x3d0, 0x3d0,-1,-62,
        0x3d1, 0x3d1,-1,-57,
        0x3d5, 0x3d5,-1,-47,
        0x3d6, 0x3d6,-1,-54,
        0x3d7, 0x3d7,-1,-8,
        0x3d9, 0x3ef, 2,-1,
        0x3f0, 0x3f0,-1,-86,
        0x3f1, 0x3f1,-1,-80,
        0x3f2, 0x3f2,-1, 7,
        0x3f3, 0x3f3,-1,-116,
        0x3f5, 0x3f5,-1,-96,
        0x3f8, 0x3fb, 3,-1,
        0x430, 0x44f, 1,-32,
        0x450, 0x45f, 1,-80,
        0x461, 0x481, 2,-1,
        0x48b, 0x4bf, 2,-1,
        0x4c2, 0x4ce, 2,-1,
        0x4cf, 0x4cf,-1,-15,
        0x4d1, 0x52f, 2,-1,
        0x561, 0x586, 1,-48,
        0x1d79, 0x1d79,-1, 35332,
        0x1d7d, 0x1d7d,-1, 3814,
        0x1e01, 0x1e95, 2,-1,
        0x1e9b, 0x1e9b,-1,-59,
        0x1ea1, 0x1eff, 2,-1,
        0x1f00, 0x1f07, 1, 8,
        0x1f10, 0x1f15, 1, 8,
        0x1f20, 0x1f27, 1, 8,
        0x1f30, 0x1f37, 1, 8,
        0x1f40, 0x1f45, 1, 8,
        0x1f51, 0x1f57, 2, 8,
        0x1f60, 0x1f67, 1, 8,
        0x1f70, 0x1f71, 1, 74,
        0x1f72, 0x1f75, 1, 86,
        0x1f76, 0x1f77, 1, 100,
        0x1f78, 0x1f79, 1, 128,
        0x1f7a, 0x1f7b, 1, 112,
        0x1f7c, 0x1f7d, 1, 126,
        0x1f80, 0x1f87, 1, 8,
        0x1f90, 0x1f97, 1, 8,
        0x1fa0, 0x1fa7, 1, 8,
        0x1fb0, 0x1fb1, 1, 8,
        0x1fb3, 0x1fb3,-1, 9,
        0x1fbe, 0x1fbe,-1,-7205,
        0x1fc3, 0x1fc3,-1, 9,
        0x1fd0, 0x1fd1, 1, 8,
        0x1fe0, 0x1fe1, 1, 8,
        0x1fe5, 0x1fe5,-1, 7,
        0x1ff3, 0x1ff3,-1, 9,
        0x214e, 0x214e,-1,-28,
        0x2170, 0x217f, 1,-16,
        0x2184, 0x2184,-1,-1,
        0x24d0, 0x24e9, 1,-26,
        0x2c30, 0x2c5e, 1,-48,
        0x2c61, 0x2c61,-1,-1,
        0x2c65, 0x2c65,-1,-10795,
        0x2c66, 0x2c66,-1,-10792,
        0x2c68, 0x2c6c, 2,-1,
        0x2c73, 0x2c76, 3,-1,
        0x2c81, 0x2ce3, 2,-1,
        0x2cec, 0x2cee, 2,-1,
        0x2cf3, 0x2cf3,-1,-1,
        0x2d00, 0x2d25, 1,-7264,
        0x2d27, 0x2d2d, 6,-7264,
        0xa641, 0xa66d, 2,-1,
        0xa681, 0xa69b, 2,-1,
        0xa723, 0xa72f, 2,-1,
        0xa733, 0xa76f, 2,-1,
        0xa77a, 0xa77c, 2,-1,
        0xa77f, 0xa787, 2,-1,
        0xa78c, 0xa791, 5,-1,
        0xa793, 0xa797, 4,-1,
        0xa799, 0xa7a9, 2,-1,
        0xff41, 0xff5a, 1,-32,
        0x10428, 0x1044f, 1,-40,
        0x118c0, 0x118df, 1,-32
    ])

;; Return the lower-case equivalent of "c", which is a UCS-4 character.  Use simple case folding.

(defn- #_int utf_tolower [#_int c]
    (ยง
        (if (< c 0x80)
            ((ร RETURN) (asc_tolower c))
        )

        (utf_convert c, toLower)
    ))

;; Return the upper-case equivalent of "c", which is a UCS-4 character.  Use simple case folding.

(defn- #_int utf_toupper [#_int c]
    (ยง
        (if (< c 0x80)
            ((ร RETURN) (asc_toupper c))
        )

        (utf_convert c, toUpper)
    ))

(defn- #_boolean utf_islower [#_int c]
    (ยง
        (if (< c 0x80)
            ((ร RETURN) (asc_islower c))
        )

        ;; German sharp s is lower case but has no upper case equivalent.
        (or (!= (utf_toupper c) c) (== c 0xdf))
    ))

(defn- #_boolean utf_isupper [#_int c]
    (ยง
        (if (< c 0x80)
            ((ร RETURN) (asc_isupper c))
        )

        (!= (utf_tolower c) c)
    ))

(defn- #_int us__strnicmp [#_Bytes _s1, #_Bytes _s2, #_int _n1, #_int _n2]
    (ยง
        (ร int c1, c2)
; %%    ((ร Bytes[] s1 =) (ยง { _s1 }, s2 = { _s2 }))
; %%    ((ร int[] n1 =) (ยง { _n1 }, n2 = { _n2 }))

        (while true
            ((ร c1 =) (us_safe_read_char_adv s1, n1))
            ((ร c2 =) (us_safe_read_char_adv s2, n2))

            (if (or (<= c1 0) (<= c2 0))
                (ร BREAK)
            )

            (if (== c1 c2)
                (ร CONTINUE)
            )

            ((ร int cmp =) (ยง utf_fold(c1) - utf_fold(c2)))
            (if (non-zero? cmp)
                ((ร RETURN) cmp)
            )
        )

        ;; some string ended or has an incomplete/illegal character sequence

        (when (or (zero? c1) (zero? c2))
            ;; some string ended. shorter string is smaller
            (if (and (zero? c1) (zero? c2))
                ((ร RETURN) 0)
            )

            ((ร RETURN) (if (== c1 0) -1 1))
        )

        ;; Continue with bytewise comparison to produce some result that
        ;; would make comparison operations involving this function transitive.
        ;;
        ;; If only one string had an error, comparison should be made with
        ;; folded version of the other string.  In this case it is enough
        ;; to fold just one character to determine the result of comparison.

        ((ร Bytes buffer =) (ยง new Bytes(6)))

        (cond (and (!= c1 -1) (== c2 -1))
        (ยง
            ((ร n1[0] =) (ยง utf_char2bytes(utf_fold(c1), buffer)))
            ((ร s1[0] =) buffer)
        )
        (and (!= c2 -1) (== c1 -1))
        (ยง
            ((ร n2[0] =) (ยง utf_char2bytes(utf_fold(c2), buffer)))
            ((ร s2[0] =) buffer)
        ))

        (while (ยง 0 < n1[0] && 0 < n2[0] && s1[0].at(0) != NUL && s2[0].at(0) != NUL)
            ((ร int cmp =) (ยง (int)s1[0].at(0) - (int)s2[0].at(0)))
            (if (non-zero? cmp)
                ((ร RETURN) cmp)
            )

            ((ร s1[0] =) (ยง s1[0].plus(1)))
            ((ร s2[0] =) (ยง s2[0].plus(1)))
            (ยง n1[0]--)
            (ยง n2[0]--)
        )

        (if (and (< 0 (ยง n1[0])) (== (ยง s1[0].at(0)) NUL))
            ((ร n1[0] =) 0)
        )
        (if (and (< 0 (ยง n2[0])) (== (ยง s2[0].at(0)) NUL))
            ((ร n2[0] =) 0)
        )

        (if (and (zero? (ยง n1[0])) (zero? (ยง n2[0])))
            ((ร RETURN) 0)
        )

        (if (zero? (ยง n1[0])) -1 1)
    ))

;; Version of strnicmp() that handles multi-byte characters.
;; Needed for Big5, Shift-JIS and UTF-8 encoding.
;; Returns zero if s1 and s2 are equal (ignoring case),
;; the difference between two characters otherwise.

(defn- #_int us_strnicmp [#_Bytes s1, #_Bytes s2, #_int nn]
    (us__strnicmp s1, s2, nn, nn))

;; "g8": show bytes of the UTF-8 char under the cursor.
;; Doesn't matter what 'encoding' has been set to.

(defn- #_void show_utf8 []
    (ยง
        ((ร Bytes p =) (ml_get_cursor))

        ;; Get the byte length of the char under the cursor, including composing characters.
        ((ร int len =) (us_ptr2len_cc p))
        (when (zero? len)
            (msg (u8 "NUL"))
            (ร RETURN)
        )

        ((ร int clen =) (ยง 0, rlen = 0))

        ((ร FOR) (ร (ยง int i = 0) (< i len) (ยง i++))
            (when (zero? clen)
                ;; start of (composing) character, get its length
                (when (< 0 i)
                    (STRCPY (.plus @ioBuff rlen), (u8 "+ "))
                    ((ร rlen +=) 2)
                )
                ((ร clen =) (ยง us_ptr2len(p.plus(i))))
            )
            ;; NUL is stored as NL
            (.sprintf libC (.plus @ioBuff rlen), (u8 "%02x "), (if (== (.at p i) NL) NUL (.at p i)))
            (ยง --clen)
            ((ร rlen +=) (STRLEN @ioBuff, rlen))
            (if (< (- IOSIZE 20) rlen)
                (ร BREAK)
            )
        )

        (msg @ioBuff)
    ))

(defn- #_int us_head_off [#_Bytes base, #_Bytes p]
    (ยง
        (if (< (char_u (ยง p.at(0))) 0x80)        ;; be quick for ASCII
            ((ร RETURN) 0)
        )

        (ร Bytes q)

        ;; Skip backwards over trailing bytes: 10xx.xxxx
        ;; Skip backwards again if on a composing char.
        ((ร FOR) (ร (ยง q = p) true (ยง q = q.minus(1)))
            (ร Bytes s)
            ;; Move 's' to the last byte of this char.
            ((ร FOR) (ร (ยง s = q) (ยง (char_u(s.at(1)) & 0xc0) == 0x80) (ยง s = s.plus(1)))
                ;
            )
            ;; Move 'q' to the first byte of this char.
            (while (ยง BLT(base, q) && (char_u(q.at(0)) & 0xc0) == 0x80)
                ((ร q =) (ยง q.minus(1)))
            )
            ;; Check for illegal sequence.  Do allow an illegal byte after where we started.
            ((ร int len =) (ยง us_byte2len(q.at(0), false)))
            (if (and (!= len (+ (BDIFF s, q) 1)) (!= len (+ (BDIFF p, q) 1)))
                ((ร RETURN) 0)
            )

            (if (or (BLE q, base) (not (utf_iscomposing (us_ptr2char q))))
                (ร BREAK)
            )
        )

        (BDIFF p, q)
    ))

;; Return the offset from "p" to the first byte of a character.  When "p" is
;; at the start of a character 0 is returned, otherwise the offset to the next
;; character.  Can start anywhere in a stream of bytes.

(defn- #_int us_off_next [#_Bytes base, #_Bytes p]
    (ยง
        (if (< (char_u (ยง p.at(0))) 0x80)        ;; be quick for ASCII
            ((ร RETURN) 0)
        )

        ;; Find the next character that isn't 10xx.xxxx.
        (ร int i)
        ((ร FOR) (ร (ยง i = 0) (ยง (char_u(p.at(i)) & 0xc0) == 0x80) (ยง i++))
            ;
        )
        (when (< 0 i)
            ;; Check for illegal sequence.
            (ร int j)
            ((ร FOR) (ร (ยง j = 0) (ยง BLT(base, p.minus(j))) (ยง j++))
                (if (ยง (char_u(p.at(-j)) & 0xc0) != 0x80)
                    (ร BREAK)
                )
            )
            (if (ยง (us_byte2len(p.at(-j), false)) != i + j)
                ((ร RETURN) 0)
            )
        )
        i
    ))

;; Return the offset from "p" to the last byte of the character it points into.
;; Can start anywhere in a stream of bytes.

(defn- #_int us_tail_off [#_Bytes base, #_Bytes p]
    (ยง
        (if (eos? p)
            ((ร RETURN) 0)
        )

        (ร int i, j)

        ;; Find the last character that is 10xx.xxxx.
        ((ร FOR) (ร (ยง i = 0) (ยง (char_u(p.at(i + 1)) & 0xc0) == 0x80) (ยง i++))
            ;
        )

        ;; Check for illegal sequence.
        ((ร FOR) (ร (ยง j = 0) (ยง BLT(base, p.minus(j))) (ยง j++))
            (if (ยง (char_u(p.at(-j)) & 0xc0) != 0x80)
                (ร BREAK)
            )
        )

        (if (ยง (us_byte2len(p.at(-j), false)) != i + j + 1)
            ((ร RETURN) 0)
        )

        i
    ))

;; Find the next illegal byte sequence.

(defn- #_void utf_find_illegal []
    (ยง
        ((ร pos_C cursor =) (. @curwin w_cursor))
        ((ร pos_C save_pos =) (ยง ยง_pos_C()))
        (COPY_pos save_pos, cursor)

        ((ร FOR) (ร (ยง cursor.coladd = 0) true (ยง cursor.lnum++, cursor.col = 0))
            ((ร FOR) (ร (ยง Bytes p = ml_get_cursor()) (ยง p.at(0) != NUL) nil)
                ;; Illegal means that there are not enough trail bytes (checked
                ;; by us_ptr2len()) or too many of them (overlong sequence).
                ((ร int len =) (us_ptr2len p))
                (when (and (<= 0x80 (char_u (ยง p.at(0)))) (or (== len 1) (!= (utf_char2len (us_ptr2char p)) len)))
                    ((ร cursor.col +=) (ยง BDIFF(p, ml_get_cursor())))
                    (ร RETURN)
                )
                ((ร p =) (ยง p.plus(len)))
            )

            (if (== (. cursor lnum) (.. @curbuf b_ml ml_line_count))
                (ร BREAK)
            )
        )

        ;; didn't find it: don't move and beep
        (COPY_pos cursor, save_pos)
        (beep_flush)
    ))

;; Adjust position "*posp" to point to the first byte of a multi-byte character.
;; If it points to a tail byte it's moved backwards to the head byte.

(defn- #_void mb_adjust_pos [#_buffer_C buf, #_pos_C posp]
    (ยง
        (when (or (< 0 (. posp col)) (< 1 (. posp coladd)))
            ((ร Bytes p =) (ยง ml_get_buf(buf, posp.lnum)))
            ((ร posp.col -=) (ยง us_head_off(p, p.plus(posp.col))))
            ;; Reset "coladd" when the cursor would be on the right half of a double-wide character.
            (when (and (== (. posp coladd) 1) (!= (.at p (. posp col)) TAB) (vim_isprintc (us_ptr2char (ยง p.plus(posp.col)))) (< 1 (mb_ptr2cells (ยง p.plus(posp.col)))))
                ((ร posp.coladd =) 0)
            )
        )
    ))

;; Backup multi-byte pointer.  Only use with "base" < "p" !
(defn- #_int us_ptr_back [#_Bytes base, #_Bytes p]
    (ยง
        (+ (us_head_off base, (.minus p 1)) 1)
    ))

;; Return a pointer to the character before "*p", if there is one.

(defn- #_Bytes us_prevptr [#_Bytes base, #_Bytes p]
    ;; base: start of the string
    (ยง
        (if (BLT base, p)
            ((ร p =) (ยง p.minus(us_ptr_back(base, p))))
        )
        p
    ))

;; Return the character length of "p".
;; Each multi-byte character (with following composing characters) counts as one.

(defn- #_int us_charlen [#_Bytes p]
    (ยง
        ((ร int count =) 0)

        (when (non-nil? p)
            ((ร FOR) (ร (ยง  ) (ยง p.at(0) != NUL) (ยง p = p.plus(us_ptr2len_cc(p))))
                (ยง count++)
            )
        )

        count
    ))

;; Return true if the character at "row"/"col" on the screen
;; is the left side of a double-width character.
;; Caller must make sure "row" and "col" are not invalid!

(defn- #_boolean mb_lefthalve [#_int row, #_int col]
    (ยง
        (< 1 (utf_off2cells (+ (ยง @lineOffset[row]) col), (+ (ยง @lineOffset[row]) @screenColumns)))
    ))

;; Correct a position on the screen,
;; if it's the right half of a double-wide char move it to the left half.
;; Returns the corrected column.

(defn- #_int mb_fix_col [#_int col, #_int row]
    (ยง
        ((ร col =) (check_col col))
        ((ร row =) (check_row row))

        (if (and (non-nil? @screenLines) (< 0 col) (ยง @screenLines.at(@lineOffset[row] + col) == 0))
            ((ร RETURN) (- col 1))
        )

        col
    ))

;; misc.c: functions that didn't seem to fit elsewhere --------------------------------------------

;; Count the size (in window cells) of the indent in the current line.

(defn- #_int get_indent []
    (ยง
        (get_indent_str (ml_get_curline), (int @(. @curbuf b_p_ts)))
    ))

;; count the size (in window cells) of the indent in line "ptr", with 'tabstop' at "ts"

(defn- #_int get_indent_str [#_Bytes ptr, #_int ts]
    (ยง
        ((ร int count =) 0)

        ((ร FOR) (ร (ยง  ) (ยง ptr.at(0) != NUL) (ยง ptr = ptr.plus(1)))
            (cond (== (.at ptr 0) TAB)
            (ยง
                ((ร count +=) (ยง ts - (count % ts)))         ;; count a tab for what it is worth
            )
            (== (.at ptr 0) (byte \space))
            (ยง
                (ยง count++)                            ;; count a space for one
            )
            :else
            (ยง
                (ร BREAK)
            ))
        )

        count
    ))

;; Set the indent of the current line.
;; Leaves the cursor on the first non-blank in the line.
;; Caller must take care of undo.
;; "flags":
;;      SIN_CHANGED:    call changed_bytes() if the line was changed.
;;      SIN_INSERT:     insert the indent in front of the line.
;;      SIN_UNDO:       save line for undo before changing it.
;; Returns true if the line was changed.

(defn- #_boolean set_indent [#_int size, #_int flags]
    ;; size: measured in spaces
    (ยง
        ((ร boolean doit =) false)
        ((ร int ind_done =) 0)                       ;; measured in spaces
        ((ร boolean retval =) false)
        ((ร int orig_char_len =) -1)                 ;; number of initial whitespace chars
                                                ;; when 'et' and 'pi' are both set

        ;; First check if there is anything to do and compute
        ;; the number of characters needed for the indent.

        ((ร int todo =) size)
        ((ร int ind_len =) 0)                        ;; measured in characters
        ((ร Bytes oldline =) (ml_get_curline))
        ((ร Bytes p =) oldline)

        ;; Calculate the buffer size for the new indent and check if it isn't already set.

        ;; If 'expandtab' isn't set: use TABs; if both 'expandtab' and
        ;; 'preserveindent' are set: count the number of characters at
        ;; the beginning of the line to be copied.
        (when (or (not @(. @curbuf b_p_et)) (and (zero? (& flags SIN_INSERT)) @(. @curbuf b_p_pi)))
            ;; If 'preserveindent' is set, then reuse as much as possible
            ;; of the existing indent structure for the new indent.
            (when (and (zero? (& flags SIN_INSERT)) @(. @curbuf b_p_pi))
                ((ร ind_done =) 0)

                ;; count as many characters as we can use
                (while (ยง 0 < todo && vim_iswhite(p.at(0)))
                    (cond (== (.at p 0) TAB)
                    (ยง
                        ((ร int tab_pad =) (ยง (int)@curbuf.@b_p_ts - (ind_done % (int)@curbuf.@b_p_ts)))
                        ;; stop if this tab will overshoot the target
                        (if (< todo tab_pad)
                            (ร BREAK)
                        )
                        ((ร todo -=) tab_pad)
                        (ยง ind_len++)
                        ((ร ind_done +=) tab_pad)
                    )
                    :else
                    (ยง
                        (ยง --todo)
                        (ยง ind_len++)
                        (ยง ind_done++)
                    ))
                    ((ร p =) (ยง p.plus(1)))
                )

                ;; Set initial number of whitespace chars to copy
                ;; if we are preserving indent but expandtab is set.
                (if @(. @curbuf b_p_et)
                    ((ร orig_char_len =) ind_len)
                )

                ;; Fill to next tabstop with a tab, if possible.
                ((ร int tab_pad =) (ยง (int)@curbuf.@b_p_ts - (ind_done % (int)@curbuf.@b_p_ts)))
                (when (and (<= tab_pad todo) (== orig_char_len -1))
                    ((ร doit =) true)
                    ((ร todo -=) tab_pad)
                    (ยง ind_len++)
                    ;; ind_done += tab_pad;
                )
            )

            ;; count tabs required for indent
            (while (ยง (int)@curbuf.@b_p_ts <= todo)
                (if (!= (.at p 0) TAB)
                    ((ร doit =) true)
                    ((ร p =) (ยง p.plus(1)))
                )
                ((ร todo -=) (ยง (int)@curbuf.@b_p_ts))
                (ยง ind_len++)
                ;; ind_done += (int)curbuf.b_p_ts[0];
            )
        )
        ;; count spaces required for indent
        (while (< 0 todo)
            (if (!= (.at p 0) (byte \space))
                ((ร doit =) true)
                ((ร p =) (ยง p.plus(1)))
            )
            (ยง --todo)
            (ยง ind_len++)
            ;; ++ind_done;
        )

        ;; Return if the indent is OK already.
        (if (and (not doit) (not (vim_iswhite (ยง p.at(0)))) (zero? (& flags SIN_INSERT)))
            ((ร RETURN) false)
        )

        ;; Allocate memory for the new line.
        (if (non-zero? (& flags SIN_INSERT))
            ((ร p =) oldline)
            ((ร p =) (skipwhite p))
        )
        ((ร int line_len =) (ยง STRLEN(p) + 1))

        ;; If 'preserveindent' and 'expandtab' are both set keep the original
        ;; characters and allocate accordingly.  We will fill the rest with spaces
        ;; after the if (!curbuf.b_p_et) below.
        (ร Bytes newline)
        (ร Bytes s)
        (cond (!= orig_char_len -1)
        (ยง
            ((ร newline =) (ยง new Bytes(orig_char_len + size - ind_done + line_len)))

            ((ร todo =) (- size ind_done))
            ((ร ind_len =) (+ orig_char_len todo))     ;; Set total length of indent in characters,
                                                ;; which may have been undercounted until now
            ((ร p =) oldline)
            ((ร s =) newline)
            (while (< 0 orig_char_len)
                (ยง (s = s.plus(1)).be(-1, (p = p.plus(1)).at(-1)))
                (ยง orig_char_len--)
            )

            ;; Skip over any additional white space (useful when newindent is less than old).
            (while (ยง vim_iswhite(p.at(0)))
                ((ร p =) (ยง p.plus(1)))
            )
        )
        :else
        (ยง
            ((ร todo =) size)
            ((ร newline =) (ยง new Bytes(ind_len + line_len)))
            ((ร s =) newline)
        ))

        ;; Put the characters in the new line.
        ;; If 'expandtab' isn't set: use TABs.
        (when (not @(. @curbuf b_p_et))
            ;; If 'preserveindent' is set, then reuse as much as possible
            ;; of the existing indent structure for the new indent.
            (when (and (zero? (& flags SIN_INSERT)) @(. @curbuf b_p_pi))
                ((ร p =) oldline)
                ((ร ind_done =) 0)

                (while (ยง 0 < todo && vim_iswhite(p.at(0)))
                    (cond (== (.at p 0) TAB)
                    (ยง
                        ((ร int tab_pad =) (ยง (int)@curbuf.@b_p_ts - (ind_done % (int)@curbuf.@b_p_ts)))
                        ;; stop if this tab will overshoot the target
                        (if (< todo tab_pad)
                            (ร BREAK)
                        )
                        ((ร todo -=) tab_pad)
                        ((ร ind_done +=) tab_pad)
                    )
                    :else
                    (ยง
                        (ยง --todo)
                        (ยง ind_done++)
                    ))
                    (ยง (s = s.plus(1)).be(-1, (p = p.plus(1)).at(-1)))
                )

                ;; Fill to next tabstop with a tab, if possible.
                ((ร int tab_pad =) (ยง (int)@curbuf.@b_p_ts - (ind_done % (int)@curbuf.@b_p_ts)))
                (when (<= tab_pad todo)
                    (ยง (s = s.plus(1)).be(-1, TAB))
                    ((ร todo -=) tab_pad)
                )

                ((ร p =) (skipwhite p))
            )

            (while (ยง (int)@curbuf.@b_p_ts <= todo)
                (ยง (s = s.plus(1)).be(-1, TAB))
                ((ร todo -=) (ยง (int)@curbuf.@b_p_ts))
            )
        )
        (while (< 0 todo)
            (ยง (s = s.plus(1)).be(-1, (byte \space)))
            (ยง --todo)
        )
        (BCOPY s, p, line_len)

        ;; Replace the line (unless undo fails).
        (when (or (zero? (& flags SIN_UNDO)) (u_savesub (.. @curwin w_cursor lnum)))
            (ml_replace (.. @curwin w_cursor lnum), newline)
            (if (non-zero? (& flags SIN_CHANGED))
                (changed_bytes (.. @curwin w_cursor lnum), 0))
            ;; Correct saved cursor position if it is in this line.
            (when (== (. @saved_cursor lnum) (.. @curwin w_cursor lnum))
                (cond (ยง (BDIFF(p, oldline)) <= @saved_cursor.col)
                (ยง
                    ;; cursor was after the indent, adjust for the number of bytes added/removed
                    ((ร @saved_cursor.col +=) (ยง ind_len - BDIFF(p, oldline)))
                )
                (ยง (BDIFF(s, newline)) <= @saved_cursor.col)
                (ยง
                    ;; cursor was in the indent and is now after it; put it back
                    ;; at the start of the indent (replacing spaces with TAB)
                    ((ร @saved_cursor.col =) (BDIFF s, newline))
                ))
            )
            ((ร retval =) true)
        )

        ((ร @curwin.w_cursor.col =) ind_len)
        retval
    ))

;; Copy the indent from ptr to the current line (and fill to size)
;; Leaves the cursor on the first non-blank in the line.
;; Returns true if the line was changed.

(defn- #_boolean copy_indent [#_int size, #_Bytes src]
    (ยง
        ((ร Bytes p =) null)
        ((ร Bytes line =) null)
;       int ind_len = 0;	// %% red.
        ((ร int line_len =) 0)

        ;; Round 1: compute the number of characters needed for the indent.
        ;; Round 2: copy the characters.
        ((ร FOR) (ร (ยง int round = 1) (<= round 2) (ยง round++))
            ((ร int todo =) size)
            ((ร ind_len =) 0)
            ((ร int ind_done =) 0)
            ((ร Bytes s =) src)

            ;; Count/copy the usable portion of the source line.
            (while (ยง 0 < todo && vim_iswhite(s.at(0)))
                (cond (== (.at s 0) TAB)
                (ยง
                    ((ร int tab_pad =) (ยง (int)@curbuf.@b_p_ts - (ind_done % (int)@curbuf.@b_p_ts)))
                    ;; Stop if this tab will overshoot the target.
                    (if (< todo tab_pad)
                        (ร BREAK)
                    )
                    ((ร todo -=) tab_pad)
                    ((ร ind_done +=) tab_pad)
                )
                :else
                (ยง
                    (ยง --todo)
                    (ยง ind_done++)
                ))
                (ยง ind_len++)
                (if (non-nil? p)
                    (ยง (p = p.plus(1)).be(-1, s.at(0)))
                )
                ((ร s =) (ยง s.plus(1)))
            )

            ;; Fill to next tabstop with a tab, if possible.
            ((ร int tab_pad =) (ยง (int)@curbuf.@b_p_ts - (ind_done % (int)@curbuf.@b_p_ts)))
            (when (and (<= tab_pad todo) (not @(. @curbuf b_p_et)))
                ((ร todo -=) tab_pad)
                (ยง ind_len++)
                (if (non-nil? p)
                    (ยง (p = p.plus(1)).be(-1, TAB))
                )
            )

            ;; Add tabs required for indent.
            (while (ยง (int)@curbuf.@b_p_ts <= todo && !@curbuf.@b_p_et)
                ((ร todo -=) (ยง (int)@curbuf.@b_p_ts))
                (ยง ind_len++)
                (if (non-nil? p)
                    (ยง (p = p.plus(1)).be(-1, TAB))
                )
            )

            ;; Count/add spaces required for indent.
            (while (< 0 todo)
                (ยง --todo)
                (ยง ind_len++)
                (if (non-nil? p)
                    (ยง (p = p.plus(1)).be(-1, (byte \space)))
                )
            )

            (when (nil? p)
                ;; Allocate memory for the result:
                ;; the copied indent, new indent and the rest of the line.
                ((ร line_len =) (ยง STRLEN(ml_get_curline()) + 1))
                ((ร line =) (ยง new Bytes(ind_len + line_len)))
                ((ร p =) line)
            )
        )

        ;; Append the original line.
        (BCOPY p, (ml_get_curline), line_len)

        ;; Replace the line.
        (ml_replace (.. @curwin w_cursor lnum), line)

        ;; Put the cursor after the indent.
        ((ร @curwin.w_cursor.col =) ind_len)
        true
    ))

(atom! int      bri_prev_indent)    ;; cached indent value
(atom! long     bri_prev_ts)        ;; cached tabstop value
(atom! Bytes    bri_prev_line)      ;; cached pointer to line
(atom! int      bri_prev_tick)      ;; changedtick of cached value

;; Return appropriate space number for breakindent, taking influencing
;; parameters into account.  Window must be specified, since it is not
;; necessarily always the current one.

(defn- #_int get_breakindent_win [#_window_C wp, #_Bytes line]
    ;; line: start of the line
    (ยง
        ((ร int bri =) 0)
        ;; window width minus window margin space, i.e. what rests for text
        ((ร int eff_wwidth =) (- (. wp w_width) (if (and (or @(.. wp w_options wo_nu) @(.. wp w_options wo_rnu)) (nil? (vim_strbyte @p_cpo, CPO_NUMCOL))) (+ (number_width wp) 1) 0)))

        ;; used cached indent, unless pointer or 'tabstop' changed
        (when (or (BNE @bri_prev_line, line) (!= @bri_prev_ts @(. @curbuf b_p_ts)) (!= @bri_prev_tick (. @curbuf b_changedtick)))
            (reset! bri_prev_line line)
            (reset! bri_prev_ts @(. @curbuf b_p_ts))
            (reset! bri_prev_tick (. @curbuf b_changedtick))
            (reset! bri_prev_indent (get_indent_str line, (int @(. @curbuf b_p_ts))))
        )
        ((ร bri =) (ยง @bri_prev_indent + wp.w_p_brishift))

        ;; indent minus the length of the showbreak string
        (if (. wp w_p_brisbr)
            ((ร bri -=) (mb_string2cells @p_sbr, -1))
        )

        ;; add offset for number column, if 'n' is in 'cpoptions'
        ((ร bri +=) (win_col_off2 wp))

        ;; never indent past left window margin
        (cond (< bri 0)
        (ยง
            ((ร bri =) 0)
        )
        ;; always leave at least bri_min characters on the left, if text width is sufficient
        (ยง eff_wwidth - wp.w_p_brimin < bri)
        (ยง
            ((ร bri =) (if (< (- eff_wwidth (. wp w_p_brimin)) 0) 0 (- eff_wwidth (. wp w_p_brimin))))
        ))

        bri
    ))

;; Return true if the string "line" starts with a word from 'cinwords'.

(defn- #_boolean cin_is_cinword [#_Bytes line]
    (ยง
        ((ร boolean retval =) false)

        ((ร int cinw_len =) (ยง STRLEN(@curbuf.@b_p_cinw) + 1))
        ((ร Bytes cinw_buf =) (ยง new Bytes(cinw_len)))

        ((ร line =) (skipwhite line))

; %%    ((ร FOR) (ร (ยง Bytes[] cinw = { @curbuf.@b_p_cinw }) (ยง cinw[0].at(0) != NUL) nil)
            ((ร int len =) (ยง copy_option_part(cinw, cinw_buf, cinw_len, (u8 ","))))
            (when (and (zero? (STRNCMP line, cinw_buf, len)) (or (not (us_iswordb (.at line len), @curbuf)) (not (us_iswordb (.at line (- len 1)), @curbuf))))
                ((ร retval =) true)
                (ร BREAK)
            )
; %%    )

        retval
    ))

;; open_line: Add a new line below or above the current line.
;;
;; For VREPLACE mode, we only add a new line when we get to the end of the
;; file, otherwise we just start replacing the next line.
;;
;; Caller must take care of undo.  Since VREPLACE may affect any number of
;; lines however, it may call u_save_cursor() again when starting to change a new line.
;;
;; "second_line_indent": indent for after ^^D in Insert mode
;;
;; Return true for success, false for failure

(defn- #_boolean open_line [#_int dir, #_int flags, #_int second_line_indent]
    ;; dir: FORWARD or BACKWARD
    (ยง
        ((ร boolean retval =) false)             ;; return value, default is FAIL

        ((ร boolean do_si =) (ยง (!@p_paste && @curbuf.@b_p_si)))
        ((ร boolean no_si =) false)              ;; reset did_si afterwards
        ((ร boolean saved_pi =) @(. @curbuf b_p_pi))       ;; copy of preserveindent setting

        ;; make a copy of the current line so we can mess with it

        ((ร Bytes saved_line =) (ยง STRDUP(ml_get_curline())))
        ((ร Bytes next_line =) null)            ;; copy of the next line

        (when (non-zero? (& @State VREPLACE_FLAG))
            ;; With VREPLACE we make a copy of the next line, which we will be starting to replace.
            ;; First make the new line empty and let vim play with the indenting and comment leader
            ;; to its heart's content.  Then we grab what it ended up putting on the new line, put
            ;; back the original line, and call ins_char() to put each new character onto the line,
            ;; replacing what was there before and pushing the right stuff onto the replace stack.

            (if (< (.. @curwin w_cursor lnum) @orig_line_count)
                ((ร next_line =) (STRDUP (ml_get (+ (.. @curwin w_cursor lnum) 1))))
                ((ร next_line =) (STRDUP (u8 "")))
            )

            ;; In VREPLACE mode, a NL replaces the rest of the line, and starts replacing the next line,
            ;; so push all of the characters left on the line onto the replace stack.  We'll push any other
            ;; characters that might be replaced at the start of the next line (due to autoindent, etc.)
            ;; a bit later.

            (replace_push NUL)      ;; call twice because BS over NL expects it
            (replace_push NUL)
            ((ร FOR) (ร (ยง Bytes s = saved_line.plus(@curwin.w_cursor.col)) (ยง s.at(0) != NUL) nil)
                ((ร s =) (ยง s.plus(replace_push_mb(s))))
            )
            (.be saved_line (.. @curwin w_cursor col), NUL)
        )

        ((ร Bytes p_extra =) null)              ;; what goes to next line
        ((ร int first_char =) NUL)
        ((ร int extra_len =) 0)                  ;; length of "p_extra" string
        ((ร int saved_char =) NUL)

        (when (and (non-zero? (& @State INSERT)) (zero? (& @State VREPLACE_FLAG)))
            ((ร p_extra =) (ยง saved_line.plus(@curwin.w_cursor.col)))
            (when do_si              ;; need first char after new line break
                ((ร Bytes p =) (skipwhite p_extra))
                ((ร first_char =) (ยง p.at(0)))
            )
            ((ร extra_len =) (STRLEN p_extra))
            ((ร saved_char =) (ยง p_extra.at(0)))
            (.be p_extra 0, NUL)
        )

        (u_clearline)              ;; cannot do "U" command when adding lines
        (reset! did_si false)
        (reset! ai_col 0)

        ;; If we just did an auto-indent, then we didn't type anything on the
        ;; prior line, and it should be truncated.  Do this even if 'ai' is not set
        ;; because automatically inserting a comment leader also sets did_ai.

        ((ร boolean trunc_line =) false)         ;; truncate current line afterwards
        (if (and (== dir FORWARD) @did_ai)
            ((ร trunc_line =) true)
        )

        ((ร pos_C old_cursor =) (ยง ยง_pos_C()))     ;; old cursor position

        ((ร int newindent =) 0)                  ;; auto-indent of the new line

        ;; If 'autoindent' and/or 'smartindent' is set, try to figure out what
        ;; indent to use for the new line.

        (when (or @(. @curbuf b_p_ai) do_si)
            ;; count white space on current line

            ((ร newindent =) (ยง get_indent_str(saved_line, (int)@curbuf.@b_p_ts)))
            (if (zero? newindent)
                ((ร newindent =) second_line_indent) ;; for ^^D command in insert mode
            )

            ;; Do smart indenting.
            ;; In insert/replace mode (only when dir == FORWARD)
            ;; we may move some text to the next line.  If it starts with '{'
            ;; don't add an indent.  Fixes inserting a NL before '{' in line
            ;;      "if (condition) {"

            (when (and (not trunc_line) do_si (non-eos? saved_line) (or (nil? p_extra) (!= first_char (byte \{))))
                (COPY_pos old_cursor, (. @curwin w_cursor))

                ((ร Bytes s =) saved_line)

                (cond (== dir FORWARD)
                (ยง
                    ;; Skip preprocessor directives, unless they are recognised as comments.

                    (when (== (.at s 0) (byte \#))
                        (while (ยง s.at(0) == (byte \#) && 1 < @curwin.w_cursor.lnum)
                            ((ร s =) (ยง ml_get(--@curwin.w_cursor.lnum)))
                        )
                        ((ร newindent =) (get_indent))
                    )

                    ;; Find last non-blank in line.
                    ((ร Bytes p =) (ยง s.plus(STRLEN(s) - 1)))
                    (while (ยง BLT(s, p) && vim_iswhite(p.at(0)))
                        ((ร p =) (ยง p.minus(1)))
                    )
                    ((ร byte last_char =) (ยง p.at(0)))

                    ;; find the character just before the '{' or ';'

                    (when (or (== last_char (byte \{)) (== last_char (byte \;)))
                        (if (BLT s, p)
                            ((ร p =) (ยง p.minus(1)))
                        )
                        (while (ยง BLT(s, p) && vim_iswhite(p.at(0)))
                            ((ร p =) (ยง p.minus(1)))
                        )
                    )

                    ;; Try to catch lines that are split over multiple
                    ;; lines.  eg:
                    ;;      if (condition &&
                    ;;                  condition) {
                    ;;          Should line up here!
                    ;;      }

                    (when (== (.at p 0) (byte \)))
                        ((ร @curwin.w_cursor.col =) (BDIFF p, s))
                        ((ร pos_C pos =) (ยง findmatch(null, (byte \())))
                        (when (non-nil? pos)
                            ((ร @curwin.w_cursor.lnum =) (. pos lnum))
                            ((ร newindent =) (get_indent))
                            ((ร s =) (ml_get_curline))
                        )
                    )

                    ;; If last character is '{' do indent, without checking for "if" and the like.

                    (cond (== last_char (byte \{))
                    (ยง
                        (reset! did_si true)  ;; do indent
                        ((ร no_si =) true)   ;; don't delete it when '{' typed
                    )

                    ;; Look for "if" and the like, use 'cinwords'.
                    ;; Don't do this if the previous line ended in ';' or '}'.

                    (and (!= last_char (byte \;)) (!= last_char (byte \})) (cin_is_cinword s))
                    (ยง
                        (reset! did_si true)
                    ))
                )
                :else ;; dir == BACKWARD
                (ยง
                    ;; Skip preprocessor directives, unless they are recognised as comments.

                    (when (== (.at s 0) (byte \#))
                        ((ร boolean was_backslashed =) false)

                        (while (ยง (s.at(0) == (byte \#) || was_backslashed) && @curwin.w_cursor.lnum < @curbuf.b_ml.ml_line_count)
                            ((ร was_backslashed =) (ยง (s.at(0) != NUL && s.at(STRLEN(s) - 1) == (byte \\))))
                            ((ร s =) (ยง ml_get(++@curwin.w_cursor.lnum)))
                        )
                        (if was_backslashed
                            ((ร newindent =) 0)              ;; got to end of file
                            ((ร newindent =) (get_indent))
                        )
                    )

                    ((ร Bytes p =) (skipwhite s))
                    (if (== (.at p 0) (byte \}))
                        (reset! did_si true)                ;; if line starts with '}': do indent
                        (reset! can_si_back true))           ;; can delete indent when '{' typed
                ))

                (COPY_pos (. @curwin w_cursor), old_cursor)
            )
            (if do_si
                (reset! can_si true))

            (reset! did_ai true)
        )

        ((ร Bytes allocated =) null)            ;; allocated memory

        ((ร Bytes[] lead_flags =) (ยง new Bytes[1]))                  ;; position in 'comments' for comment leader
        ((ร Bytes leader =) null)               ;; copy of comment leader

        ((ร int newcol =) 0)                     ;; new cursor column

        ((ร int less_cols_off =) 0)              ;; columns to skip for mark adjust
        ((ร int less_cols =) 0)                  ;; less columns for mark in new line

        ;; (State == INSERT || State == REPLACE), only when dir == FORWARD
        (when (non-nil? p_extra)
            (.be p_extra 0, saved_char)          ;; restore char that NUL replaced

            ;; When 'ai' set, skip to the first non-blank.
            ;;
            ;; When in REPLACE mode, put the deleted blanks on the replace stack,
            ;; preceded by a NUL, so they can be put back when a BS is entered.

            (if (and (non-zero? (& @State REPLACE_FLAG)) (zero? (& @State VREPLACE_FLAG)))
                (replace_push NUL))      ;; end of extra blanks
            (when @(. @curbuf b_p_ai)
                (while (ยง (p_extra.at(0) == (byte \space) || p_extra.at(0) == (byte \tab)) && !utf_iscomposing(us_ptr2char(p_extra.plus(1))))
                    (if (and (non-zero? (& @State REPLACE_FLAG)) (zero? (& @State VREPLACE_FLAG)))
                        (replace_push (.at p_extra 0)))
                    ((ร p_extra =) (ยง p_extra.plus(1)))
                    (ยง less_cols_off++)
                )
            )
            (if (non-eos? p_extra)
                (reset! did_ai false))             ;; append some text, don't truncate now

            ;; columns for marks adjusted for removed columns
            ((ร less_cols =) (BDIFF p_extra, saved_line))
        )

        (if (nil? p_extra)
            ((ร p_extra =) (u8 ""))                   ;; append empty line
        )

        (COPY_pos old_cursor, (. @curwin w_cursor))
        (if (== dir BACKWARD)
            (ยง --@curwin.w_cursor.lnum)
        )

;       theend:
;       {
            (ร boolean did_append)
            (cond (or (zero? (& @State VREPLACE_FLAG)) (<= @orig_line_count (. old_cursor lnum)))
            (ยง
                (if (not (ml_append (.. @curwin w_cursor lnum), p_extra))
                    (ร BREAK theend)
                )
                ;; Postpone calling changed_lines(), because it would mess up folding with markers.
                (mark_adjust (+ (.. @curwin w_cursor lnum) 1), MAXLNUM, 1, 0)
                ((ร did_append =) true)
            )
            :else
            (ยง
                ;; In VREPLACE mode we are starting to replace the next line.

                (ยง @curwin.w_cursor.lnum++)
                (when (ยง @insStart.lnum + @vr_lines_changed <= @curwin.w_cursor.lnum)
                    ;; In case we NL to a new line, BS to the previous one, and NL
                    ;; again, we don't want to save the new line for undo twice.

                    (u_save_cursor)            ;; errors are ignored!
                    (swap! vr_lines_changed inc)
                )
                (ml_replace (.. @curwin w_cursor lnum), p_extra)
                (changed_bytes (.. @curwin w_cursor lnum), 0)
                (ยง --@curwin.w_cursor.lnum)
                ((ร did_append =) false)
            ))

            (when (or (non-zero? newindent) @did_si)
                (ยง @curwin.w_cursor.lnum++)
                (when @did_si
                    ((ร int sw =) (ยง (int)get_sw_value(@curbuf)))

                    (if @p_sr
                        ((ร newindent -=) (% newindent sw))
                    )
                    ((ร newindent +=) sw)
                )
                ;; Copy the indent.
                (cond @(. @curbuf b_p_ci)
                (ยง
                    (copy_indent newindent, saved_line)

                    ;; Set the 'preserveindent' option so that any further screwing
                    ;; with the line doesn't entirely destroy our efforts to preserve it.
                    ;; It gets restored at the function end.

                    ((ร @curbuf.@b_p_pi =) true)
                )
                :else
                (ยง
                    (set_indent newindent, SIN_INSERT)
                ))
                ((ร less_cols -=) (.. @curwin w_cursor col))

                (reset! ai_col (.. @curwin w_cursor col))

                ;; In REPLACE mode, for each character in the new indent, there must
                ;; be a NUL on the replace stack, for when it is deleted with BS.

                (when (and (non-zero? (& @State REPLACE_FLAG)) (zero? (& @State VREPLACE_FLAG)))
                    ((ร FOR) (ร (ยง int n = 0) (ยง n < @curwin.w_cursor.col) (ยง n++))
                        (replace_push NUL)
                    )
                )
                ((ร newcol +=) (.. @curwin w_cursor col))
                (if no_si
                    (reset! did_si false))
            )

            (COPY_pos (. @curwin w_cursor), old_cursor)

            (when (== dir FORWARD)
                (when (or trunc_line (non-zero? (& @State INSERT)))
                    ;; truncate current line at cursor
                    (.be saved_line (.. @curwin w_cursor col), NUL)
                    ;; Remove trailing white space.
                    (if trunc_line
                        (truncate_spaces saved_line))
                    (ml_replace (.. @curwin w_cursor lnum), saved_line)
                    ((ร saved_line =) null)
                    (cond did_append
                    (ยง
                        (changed_lines (.. @curwin w_cursor lnum), (.. @curwin w_cursor col), (+ (.. @curwin w_cursor lnum) 1), 1)
                        ((ร did_append =) false)
                    )
                    :else
                    (ยง
                        (changed_bytes (.. @curwin w_cursor lnum), (.. @curwin w_cursor col))
                    ))
                )

                ;; Put the cursor on the new line.
                ;; Careful: the scrollup() above may have moved w_cursor, we must use old_cursor.

                ((ร @curwin.w_cursor.lnum =) (ยง old_cursor.lnum + 1))
            )
            (if did_append
                (changed_lines (.. @curwin w_cursor lnum), 0, (.. @curwin w_cursor lnum), 1))

            ((ร @curwin.w_cursor.col =) newcol)
            ((ร @curwin.w_cursor.coladd =) 0)

            ;; In VREPLACE mode, we are handling the replace stack ourselves,
            ;; so stop fixthisline() from doing it (via change_indent()) by
            ;; telling it we're in normal INSERT mode.

            (ร int vreplace_mode)
            (cond (non-zero? (& @State VREPLACE_FLAG))
            (ยง
                ((ร vreplace_mode =) @State)          ;; so we know to put things right later
                (reset! State INSERT)
            )
            :else
            (ยง
                ((ร vreplace_mode =) 0)
            ))

            (if (non-zero? vreplace_mode)
                (reset! State vreplace_mode))

            ;; Finally, VREPLACE gets the stuff on the new line, then puts back the
            ;; original line, and inserts the new stuff char by char, pushing old stuff
            ;; onto the replace stack (via ins_char()).

            (when (non-zero? (& @State VREPLACE_FLAG))
                ;; Put new line in "p_extra".
                ((ร p_extra =) (ยง STRDUP(ml_get_curline())))

                ;; Put back original line.
                (ml_replace (.. @curwin w_cursor lnum), next_line)

                ;; Insert new stuff into line again.
                ((ร @curwin.w_cursor.col =) 0)
                ((ร @curwin.w_cursor.coladd =) 0)
                (ins_bytes p_extra)             ;; will call changed_bytes()
                ((ร next_line =) null)
            )

            ((ร retval =) true)              ;; success!
;       }

        ((ร @curbuf.@b_p_pi =) saved_pi)
        retval
    ))

;; Return the number of window lines occupied by buffer line "lnum".

(defn- #_int plines [#_long lnum]
    (plines_win @curwin, lnum, true))

(defn- #_int plines_win [#_window_C wp, #_long lnum, #_boolean winheight]
    ;; winheight: when true limit to window height
    (ยง
        (if (not @(.. wp w_options wo_wrap))
            ((ร RETURN) 1)
        )

        (if (zero? (. wp w_width))
            ((ร RETURN) 1)
        )

        ((ร int lines =) (plines_win_nofold wp, lnum))
        (if (and winheight (< (. wp w_height) lines))
            ((ร RETURN) (. wp w_height))
        )

        lines
    ))

;; Return number of window lines physical line "lnum" will occupy in window "wp".
;; Does not care about folding, 'wrap' or 'diff'.

(defn- #_int plines_win_nofold [#_window_C wp, #_long lnum]
    (ยง
        ((ร Bytes s =) (ml_get_buf @curbuf, lnum))
        (if (eos? s)     ;; empty line
            ((ร RETURN) 1)
        )

        ((ร int col =) (win_linetabsize wp, s, MAXCOL))

        ;; Add column offset for 'number', 'relativenumber' and 'foldcolumn'.

        ((ร int width =) (ยง wp.w_width - win_col_off(wp)))
        (if (<= width 0)
            ((ร RETURN) 32000)
        )

        (if (<= col width)
            ((ร RETURN) 1)
        )

        ((ร col -=) width)
        ((ร width +=) (win_col_off2 wp))
        (ยง (col + (width - 1)) / width + 1)
    ))

;; Like plines_win(), but only reports the number of physical screen lines
;; used from the start of the line to the given column number.

(defn- #_int plines_win_col [#_window_C wp, #_long lnum, #_long column]
    (ยง
        ((ร int lines =) 0)

        (if (not @(.. wp w_options wo_wrap))
            ((ร RETURN) (+ lines 1))
        )

        (if (zero? (. wp w_width))
            ((ร RETURN) (+ lines 1))
        )

        ((ร Bytes line =) (ml_get_buf @curbuf, lnum))
        ((ร Bytes s =) line)

        ((ร long col =) 0)
        (while (ยง s.at(0) != NUL && 0 <= --column)
            ((ร col +=) (ยง win_lbr_chartabsize(wp, line, s, (int)col, null)))
            ((ร s =) (ยง s.plus(us_ptr2len_cc(s))))
        )

        ;; If s[0] is a TAB, and the TAB is not displayed as ^I, and we're not in INSERT mode,
        ;; then col must be adjusted so that it represents the last screen position of the TAB.
        ;; This only fixes an error when the TAB wraps from one screen line to the next
        ;; (when 'columns' is not a multiple of 'ts').

        (if (and (== (.at s 0) TAB) (non-zero? (& @State NORMAL)))
            ((ร col +=) (ยง win_lbr_chartabsize(wp, line, s, (int)col, null) - 1))
        )

        ;; Add column offset for 'number', 'relativenumber', 'foldcolumn', etc.

        ((ร int width =) (ยง wp.w_width - win_col_off(wp)))
        (if (<= width 0)
            ((ร RETURN) 9999)
        )

        ((ร lines +=) 1)
        (if (< width col)
            ((ร lines +=) (ยง (col - width) / (width + win_col_off2(wp)) + 1))
        )
        lines
    ))

(defn- #_int plines_m_win [#_window_C wp, #_long first, #_long last]
    (ยง
        ((ร int count =) 0)

        (while (<= first last)
            ((ร count +=) (plines_win wp, first, true))
            (ยง first++)
        )

        count
    ))

;; Insert string "p" at the cursor position.  Stops at a NUL byte.
;; Handles Replace mode and multi-byte characters.

(defn- #_void ins_bytes [#_Bytes p]
    (ins_bytes_len p, (STRLEN p)))

;; Insert string "p" with length "len" at the cursor position.
;; Handles Replace mode and multi-byte characters.

(defn- #_void ins_bytes_len [#_Bytes p, #_int len]
    (ยง
        ((ร FOR) (ร (ยง int i = 0, n) (< i len) (ยง i += n))
            ;; avoid reading past p[len]
            ((ร n =) (ยง us_ptr2len_cc_len(p.plus(i), len - i)))
            (ins_char_bytes (.plus p i), n)
        )
    ))

;; Insert or replace a single character at the cursor position.
;; When in REPLACE or VREPLACE mode, replace any existing character.
;; Caller must have prepared for undo.
;; For multi-byte characters we get the whole character,
;; the caller must convert bytes to a character.

(defn- #_void ins_char [#_int c]
    (ยง
        ((ร Bytes buf =) (ยง new Bytes(MB_MAXBYTES + 1)))
        ((ร int n =) (utf_char2bytes c, buf))

        ;; When "c" is 0x100, 0x200, etc. we don't want to insert a NUL byte.
        ;; Happens for CTRL-Vu9900.
        (if (== (.at buf 0) 0)
            (.be buf 0, (ยง (byte \newline)))
        )

        (ins_char_bytes buf, n)
    ))

(defn- #_void ins_char_bytes [#_Bytes buf, #_int charlen]
    (ยง
        ((ร long lnum =) (.. @curwin w_cursor lnum))

        ;; Break tabs if needed.
        (if (and (virtual_active) (< 0 (.. @curwin w_cursor coladd)))
            (coladvance_force (getviscol)))

        ((ร int col =) (.. @curwin w_cursor col))
        ((ร Bytes oldp =) (ml_get lnum))
        ((ร int linelen =) (ยง STRLEN(oldp) + 1))        ;; length of old line including NUL

        ;; The lengths default to the values for when not replacing.
        ((ร int oldlen =) 0)                             ;; nr of bytes deleted (0 when not replacing)
        ((ร int newlen =) charlen)                       ;; nr of bytes inserted

        (when (non-zero? (& @State REPLACE_FLAG))
            (cond (non-zero? (& @State VREPLACE_FLAG))
            (ยง
                ;; In virtual replace mode each character may replace one or more
                ;; characters (zero if it's a TAB).  Count the number of bytes to
                ;; be deleted to make room for the new character, counting screen
                ;; cells.  May result in adding spaces to fill a gap.

                ((ร int[] vcol =) (ยง new int[1]))
                (getvcol @curwin, (. @curwin w_cursor), null, vcol, null)

                ((ร int new_vcol =) (ยง vcol[0] + chartabsize(buf, vcol[0])))
                (while (ยง oldp.at(col + oldlen) != NUL && vcol[0] < new_vcol)
                    ((ร vcol[0] +=) (ยง chartabsize(oldp.plus(col + oldlen), vcol[0])))
                    ;; Don't need to remove a TAB that takes us to the right position.
                    (if (and (< new_vcol (ยง vcol[0])) (ยง oldp.at(col + oldlen) == TAB))
                        (ร BREAK)
                    )
                    ((ร oldlen +=) (ยง us_ptr2len_cc(oldp.plus(col + oldlen))))
                    ;; Deleted a bit too much, insert spaces.
                    (if (< new_vcol (ยง vcol[0]))
                        ((ร newlen +=) (ยง vcol[0] - new_vcol))
                    )
                )
            )
            (non-eos? oldp col)
            (ยง
                ;; normal replace
                ((ร oldlen =) (ยง us_ptr2len_cc(oldp.plus(col))))
            ))

            ;; Push the replaced bytes onto the replace stack, so that they can be
            ;; put back when BS is used.  The bytes of a multi-byte character are
            ;; done the other way around, so that the first byte is popped off
            ;; first (it tells the byte length of the character).
            (replace_push NUL)
            ((ร FOR) (ร (ยง int i = 0) (< i oldlen) (ยง i++))
                ((ร i +=) (ยง replace_push_mb(oldp.plus(col + i)) - 1))
            )
        )

        ((ร Bytes newp =) (ยง new Bytes(linelen + newlen - oldlen)))

        ;; Copy bytes before the cursor.
        (if (< 0 col)
            (BCOPY newp, oldp, col))

        ;; Copy bytes after the changed character(s).
        ((ร Bytes p =) (ยง newp.plus(col)))
        (BCOPY p, newlen, oldp, (+ col oldlen), (ยง linelen - col - oldlen))

        ;; Insert or overwrite the new character.
        (BCOPY p, buf, charlen)
        ((ร int i =) charlen)

        ;; Fill with spaces when necessary.
        (while (< i newlen)
            (ยง p.be(i++, (byte \space)))
        )

        ;; Replace the line in the buffer.
        (ml_replace lnum, newp)

        ;; mark the buffer as changed and prepare for displaying
        (changed_bytes lnum, col)

        ;; If we're in Insert or Replace mode and 'showmatch' is set,
        ;; then briefly show the match for right parens and braces.

        (when (and @p_sm (non-zero? (& @State INSERT)))
            (showmatch (us_ptr2char buf))
        )

        ;; Normal insert: move cursor right.
        ((ร @curwin.w_cursor.col +=) charlen)

        ;; TODO: should try to update w_row here, to avoid recomputing it later.

    ))

;; Insert a string at the cursor position.
;; Note: Does NOT handle Replace mode.
;; Caller must have prepared for undo.

(defn- #_void ins_str [#_Bytes s]
    (ยง
        ((ร int newlen =) (STRLEN s))
        ((ร long lnum =) (.. @curwin w_cursor lnum))

        (if (and (virtual_active) (< 0 (.. @curwin w_cursor coladd)))
            (coladvance_force (getviscol)))

        ((ร int col =) (.. @curwin w_cursor col))
        ((ร Bytes oldp =) (ml_get lnum))
        ((ร int oldlen =) (STRLEN oldp))

        ((ร Bytes newp =) (ยง new Bytes(oldlen + newlen + 1)))

        (if (< 0 col)
            (BCOPY newp, oldp, col))
        (BCOPY newp, col, s, 0, newlen)
        (BCOPY newp, (+ col newlen), oldp, col, (ยง oldlen - col + 1))
        (ml_replace lnum, newp)
        (changed_bytes lnum, col)
        ((ร @curwin.w_cursor.col +=) newlen)
    ))

;; Delete one character under the cursor.
;; If "fixpos" is true, don't leave the cursor on the NUL after the line.
;; Caller must have prepared for undo.
;;
;; Return false for failure, true otherwise.

(defn- #_boolean del_char [#_boolean fixpos]
    (ยง
        ;; Make sure the cursor is at the start of a character.
        (mb_adjust_pos @curbuf, (. @curwin w_cursor))
        (if (== (.at (ml_get_cursor) 0) NUL)
            ((ร RETURN) false)
        )

        (del_chars 1, fixpos)
    ))

;; Like del_bytes(), but delete characters instead of bytes.

(defn- #_boolean del_chars [#_int count, #_boolean fixpos]
    (ยง
        ((ร int bytes =) 0)

        ((ร Bytes p =) (ml_get_cursor))
        ((ร FOR) (ร (ยง int i = 0) (ยง i < count && p.at(0) != NUL) (ยง i++))
            ((ร int l =) (us_ptr2len_cc p))
            ((ร bytes +=) l)
            ((ร p =) (ยง p.plus(l)))
        )

        (del_bytes bytes, fixpos, true)
    ))

;; Delete "count" bytes under the cursor.
;; If "fixpos" is true, don't leave the cursor on the NUL after the line.
;; Caller must have prepared for undo.
;;
;; return false for failure, true otherwise

(defn- #_boolean del_bytes [#_int count, #_boolean fixpos, #_boolean use_delcombine]
    ;; use_delcombine: 'delcombine' option applies
    (ยง
        ((ร long lnum =) (.. @curwin w_cursor lnum))
        ((ร int col =) (.. @curwin w_cursor col))

        ((ร Bytes oldp =) (ml_get lnum))
        ((ร int oldlen =) (STRLEN oldp))

        ;; Can't do anything when the cursor is on the NUL after the line.

        (if (<= oldlen col)
            ((ร RETURN) false)
        )

        ;; If 'delcombine' is set and deleting (less than) one character,
        ;; only delete the last combining character.
        (when (and @p_deco use_delcombine (<= count (us_ptr2len_cc (ยง oldp.plus(col)))))
            ((ร int[] cc =) (ยง new int[MAX_MCO]))

            (us_ptr2char_cc (.plus oldp col), cc)
            (when (!= (ยง cc[0]) NUL)
                ;; Find the last composing char, there can be several.
                ((ร int n =) col)
;               do
;               {
                    ((ร col =) n)
                    ((ร count =) (ยง us_ptr2len(oldp.plus(n))))
                    ((ร n +=) count)
;               } while (utf_iscomposing(us_ptr2char(oldp.plus(n))));
                ((ร fixpos =) false)
            )
        )

        ;; When count is too big, reduce it.

        ((ร int movelen =) (ยง oldlen - col - count + 1)) ;; includes trailing NUL
        (when (<= movelen 1)
            ;; If we just took off the last character of a non-blank line, and
            ;; fixpos is true, we don't want to end up positioned at the NUL,
            ;; unless "restart_edit" is set or 'virtualedit' contains "onemore".

            (when (and (< 0 col) fixpos (zero? @restart_edit) (zero? (& @ve_flags VE_ONEMORE)))
                (ยง --@curwin.w_cursor.col)
                ((ร @curwin.w_cursor.coladd =) 0)
                ((ร @curwin.w_cursor.col -=) (ยง us_head_off(oldp, oldp.plus(@curwin.w_cursor.col))))
            )
            ((ร count =) (- oldlen col))
            ((ร movelen =) 1)
        )

        ((ร Bytes newp =) (ยง new Bytes(oldlen + 1 - count)))
        (BCOPY newp, oldp, col)
        (BCOPY newp, col, oldp, (+ col count), movelen)
        (ml_replace lnum, newp)

        ;; mark the buffer as changed and prepare for displaying
        (changed_bytes lnum, (.. @curwin w_cursor col))

        true
    ))

;; Delete from cursor to end of line.
;; Caller must have prepared for undo.

(defn- #_void truncate_line [#_boolean fixpos]
    ;; fixpos: if true fix the cursor position when done
    (ยง
        ((ร long lnum =) (.. @curwin w_cursor lnum))
        ((ร int col =) (.. @curwin w_cursor col))

        (ร Bytes newp)
        (if (zero? col)
            ((ร newp =) (STRDUP (u8 "")))
            ((ร newp =) (STRNDUP (ml_get lnum), col))
        )

        (ml_replace lnum, newp)

        ;; mark the buffer as changed and prepare for displaying
        (changed_bytes lnum, (.. @curwin w_cursor col))

        ;; If "fixpos" is true we don't want to end up positioned at the NUL.

        (when (and fixpos (< 0 (.. @curwin w_cursor col)))
            (ยง --@curwin.w_cursor.col)
        )
    ))

;; Delete "nlines" lines at the cursor.
;; Saves the lines for undo first if "undo" is true.

(defn- #_void del_lines [#_long nlines, #_boolean undo]
    ;; nlines: number of lines to delete
    ;; undo: if true, prepare for undo
    (ยง
        ((ร long first =) (.. @curwin w_cursor lnum))

        (if (<= nlines 0)
            (ร RETURN)
        )

        ;; save the deleted lines for undo
        (if (and undo (not (u_savedel first, nlines)))
            (ร RETURN)
        )

        (ร long n)
        ((ร FOR) (ร (ยง n = 0) (< n nlines) nil)
            (if (non-zero? (& (.. @curbuf b_ml ml_flags) ML_EMPTY)) ;; nothing to delete
                (ร BREAK)
            )

            (ml_delete first, true)
            (ยง n++)

            ;; If we delete the last line in the file, stop.
            (if (< (.. @curbuf b_ml ml_line_count) first)
                (ร BREAK)
            )
        )

        ;; Correct the cursor position before calling deleted_lines_mark(),
        ;; it may trigger a callback to display the cursor.
        ((ร @curwin.w_cursor.col =) 0)
        (check_cursor_lnum)

        ;; Adjust marks, mark the buffer as changed and prepare for displaying.
        (deleted_lines_mark first, n)
    ))

(defn- #_int gchar_pos [#_pos_C pos]
    (ยง
        ((ร Bytes ptr =) (ml_get_pos pos))

        (us_ptr2char ptr)
    ))

(defn- #_int gchar_cursor []
    (us_ptr2char (ml_get_cursor)))

;; When extra == 0: Return true if the cursor is before or on the first non-blank in the line.
;; When extra == 1: Return true if the cursor is before the first non-blank in the line.

(defn- #_boolean inindent [#_int extra]
    (ยง
        ((ร int col =) 0)

        ((ร FOR) (ร (ยง Bytes p = ml_get_curline()) (ยง vim_iswhite(p.at(0))) (ยง col++))
            ((ร p =) (ยง p.plus(1)))
        )

        (ยง @curwin.w_cursor.col + extra <= col)
    ))

;; Skip to next part of an option argument: Skip space and comma.

(defn- #_Bytes skip_to_option_part [#_Bytes p]
    (ยง
        (if (== (.at p 0) (byte \,))
            ((ร p =) (ยง p.plus(1)))
        )
        (while (ยง p.at(0) == (byte \space))
            ((ร p =) (ยง p.plus(1)))
        )
        p
    ))

;; Call this function when something in the current buffer is changed.
;;
;; Most often called through changed_bytes() and changed_lines(),
;; which also mark the area of the display to be redrawn.

(defn- #_void changed []
    (ยง
        (when (not @(. @curbuf b_changed))
            ((ร @curbuf.@b_changed =) true)
            (check_status @curbuf)
        )
        (ยง @curbuf.b_changedtick++)
    ))

;; Changed bytes within a single line for the current buffer.
;; - marks the windows on this buffer to be redisplayed
;; - marks the buffer changed by calling changed()
;; - invalidates cached values

(defn- #_void changed_bytes [#_long lnum, #_int col]
    (ยง
        (changed_one_line @curbuf, lnum)
        (changed_common lnum, col, (+ lnum 1), 0)
    ))

(defn- #_void changed_one_line [#_buffer_C buf, #_long lnum]
    (ยง
        (cond (. buf b_mod_set)
        (ยง
            ;; find the maximum area that must be redisplayed
            (cond (< lnum (. buf b_mod_top))
            (ยง
                ((ร buf.b_mod_top =) lnum)
            )
            (<= (. buf b_mod_bot) lnum)
            (ยง
                ((ร buf.b_mod_bot =) (+ lnum 1))
            ))
        )
        :else
        (ยง
            ;; set the area that must be redisplayed to one line
            ((ร buf.b_mod_set =) true)
            ((ร buf.b_mod_top =) lnum)
            ((ร buf.b_mod_bot =) (+ lnum 1))
            ((ร buf.b_mod_xlines =) 0)
        ))
    ))

;; Appended "count" lines below line "lnum" in the current buffer.
;; Must be called AFTER the change and after mark_adjust().
;; Takes care of marking the buffer to be redrawn and sets the changed flag.

(defn- #_void appended_lines [#_long lnum, #_long count]
    (changed_lines (+ lnum 1), 0, (+ lnum 1), count))

;; Like appended_lines(), but adjust marks first.

(defn- #_void appended_lines_mark [#_long lnum, #_long count]
    (ยง
        (mark_adjust (+ lnum 1), MAXLNUM, count, 0)
        (changed_lines (+ lnum 1), 0, (+ lnum 1), count)
    ))

;; Deleted "count" lines at line "lnum" in the current buffer.
;; Must be called AFTER the change and after mark_adjust().
;; Takes care of marking the buffer to be redrawn and sets the changed flag.

(defn- #_void deleted_lines [#_long lnum, #_long count]
    (ยง
        (changed_lines lnum, 0, (+ lnum count), (- count))
    ))

;; Like deleted_lines(), but adjust marks first.
;; Make sure the cursor is on a valid line before calling,
;; a GUI callback may be triggered to display the cursor.

(defn- #_void deleted_lines_mark [#_long lnum, #_long count]
    (ยง
        (mark_adjust lnum, (ยง lnum + count - 1), MAXLNUM, (- count))
        (changed_lines lnum, 0, (+ lnum count), (- count))
    ))

;; Changed lines for the current buffer.
;; Must be called AFTER the change and after mark_adjust().
;; - mark the buffer changed by calling changed()
;; - mark the windows on this buffer to be redisplayed
;; - invalidate cached values
;; "lnum" is the first line that needs displaying,
;; "lnume" the first line below the changed lines (BEFORE the change).
;; When only inserting lines, "lnum" and "lnume" are equal.
;; Takes care of calling changed() and updating b_mod_*.

(defn- #_void changed_lines [#_long lnum, #_int col, #_long lnume, #_long xtra]
    ;; lnum: first line with change
    ;; col: column in first line with change
    ;; lnume: line below last changed line
    ;; xtra: number of extra lines (negative when deleting)
    (ยง
        (changed_lines_buf @curbuf, lnum, lnume, xtra)

        (changed_common lnum, col, lnume, xtra)
    ))

(defn- #_void changed_lines_buf [#_buffer_C buf, #_long lnum, #_long lnume, #_long xtra]
    ;; lnum: first line with change
    ;; lnume: line below last changed line
    ;; xtra: number of extra lines (negative when deleting)
    (ยง
        (cond (. buf b_mod_set)
        (ยง
            ;; find the maximum area that must be redisplayed
            (if (< lnum (. buf b_mod_top))
                ((ร buf.b_mod_top =) lnum)
            )
            (when (< lnum (. buf b_mod_bot))
                ;; adjust old bot position for xtra lines
                ((ร buf.b_mod_bot +=) xtra)
                (if (< (. buf b_mod_bot) lnum)
                    ((ร buf.b_mod_bot =) lnum)
                )
            )
            (if (< (. buf b_mod_bot) (+ lnume xtra))
                ((ร buf.b_mod_bot =) (+ lnume xtra))
            )
            ((ร buf.b_mod_xlines +=) xtra)
        )
        :else
        (ยง
            ;; set the area that must be redisplayed
            ((ร buf.b_mod_set =) true)
            ((ร buf.b_mod_top =) lnum)
            ((ร buf.b_mod_bot =) (+ lnume xtra))
            ((ร buf.b_mod_xlines =) xtra)
        ))
    ))

;; Common code for when a change is was made.
;; See changed_lines() for the arguments.

(defn- #_void changed_common [#_long lnum, #_int col, #_long lnume, #_long xtra]
    (ยง
        ;; mark the buffer as modified
        (changed)

        ;; set the '. mark
;       {
            ((ร @curbuf.b_last_change.lnum =) lnum)
            ((ร @curbuf.b_last_change.col =) col)

            ;; Create a new entry if a new undo-able change was started
            ;; or we don't have an entry yet.
            (when (or (. @curbuf b_new_change) (zero? (. @curbuf b_changelistlen)))
                (ร boolean add)
                (cond (zero? (. @curbuf b_changelistlen))
                (ยง
                    ((ร add =) true)
                )
                :else
                (ยง
                    ;; Don't create a new entry when the line number is the
                    ;; same as the last one and the column is not too far away.
                    ;; Avoids creating many entries for typing "xxxxx".
                    ((ร pos_C p =) (ยง @curbuf.b_changelist[@curbuf.b_changelistlen - 1]))
                    (cond (!= (. p lnum) lnum)
                    (ยง
                        ((ร add =) true)
                    )
                    :else
                    (ยง
                        ((ร int cols =) 79)
                        ((ร add =) (ยง (p.col + cols < col || col + cols < p.col)))
                    ))
                ))

                (when add
                    ;; This is the first of a new sequence of undo-able changes
                    ;; and it's at some distance of the last change.  Use a new
                    ;; position in the changelist.
                    ((ร @curbuf.b_new_change =) false)

                    (when (== (. @curbuf b_changelistlen) JUMPLISTSIZE)
                        ;; changelist is full: remove oldest entry
                        ((ร @curbuf.b_changelistlen =) (- JUMPLISTSIZE 1))
                        ((ร FOR) (ร (ยง int i = 0) (ยง i < JUMPLISTSIZE - 1) (ยง i++))
                            (COPY_pos (ยง @curbuf.b_changelist[i]), (ยง @curbuf.b_changelist[i + 1]))
                        )
                        ((ร FOR) (ร (ยง window_C wp = @firstwin) (!= wp null) (ยง wp = wp.w_next))
                            ;; Correct position in changelist for other windows on this buffer.
                            (if (< 0 (. wp w_changelistidx))
                                (ยง --wp.w_changelistidx)
                            )
                        )
                    )

                    ((ร FOR) (ร (ยง window_C wp = @firstwin) (!= wp null) (ยง wp = wp.w_next))
                        ;; For other windows, if the position in the changelist is at the end,
                        ;; it stays at the end.
                        (if (== (. wp w_changelistidx) (. @curbuf b_changelistlen))
                            (ยง wp.w_changelistidx++)
                        )
                    )

                    (ยง @curbuf.b_changelistlen++)
                )
            )
            (COPY_pos (ยง @curbuf.b_changelist[@curbuf.b_changelistlen - 1]), (. @curbuf b_last_change))
            ;; The current window is always after the last change, so that "g," takes you back to it.
            ((ร @curwin.w_changelistidx =) (. @curbuf b_changelistlen))
;       }

        ((ร FOR) (ร (ยง window_C wp = @firstwin) (!= wp null) (ยง wp = wp.w_next))
            ;; Mark this window to be redrawn later.
            (if (< (. wp w_redr_type) VALID)
                ((ร wp.w_redr_type =) VALID)
            )

            ;; Check if a change in the buffer has invalidated the cached values for the cursor.
            (cond (< lnum (.. wp w_cursor lnum))
            (ยง
                (changed_line_abv_curs_win wp)
            )
            (and (== (.. wp w_cursor lnum) lnum) (<= col (.. wp w_cursor col)))
            (ยง
                (changed_cline_bef_curs_win wp)
            ))

            (when (<= lnum (. wp w_botline))
                ;; Assume that botline doesn't change
                ;; (inserted lines make other lines scroll down below botline).
                (approximate_botline_win wp)
            )

            ;; Check if any w_lines[] entries have become invalid.
            ;; For entries below the change: Correct the lnums for inserted/deleted lines.
            ;; Makes it possible to stop displaying after the change.
            ((ร FOR) (ร (ยง int i = 0) (ยง i < wp.w_lines_valid) (ยง i++))
                (when (and (ยง wp.w_lines[i].wl_valid) (<= lnum (ยง wp.w_lines[i].wl_lnum)))
                    (cond (< (ยง wp.w_lines[i].wl_lnum) lnume)
                    (ยง
                        ;; line included in change
                        ((ร wp.w_lines[i].wl_valid =) false)
                    )
                    (non-zero? xtra)
                    (ยง
                        ;; line below change
                        ((ร wp.w_lines[i].wl_lnum +=) xtra)
                    ))
                )
            )

            ;; relative numbering may require updating more
            (if @(.. wp w_options wo_rnu)
                (redraw_win_later wp, SOME_VALID))
        )

        ;; Call update_screen() later, which checks out what needs to be redrawn,
        ;; since it notices b_mod_set and then uses b_mod_*.
        (if (< @must_redraw VALID)
            (reset! must_redraw VALID))

        ;; When the cursor line is changed, always trigger CursorMoved.
        (when (and (<= lnum (.. @curwin w_cursor lnum)) (< (.. @curwin w_cursor lnum) (+ lnume (if (< xtra 0) (- xtra) xtra))))
            ((ร @last_cursormoved.lnum =) 0)
        )
    ))

;; called when the changed flag must be reset for buffer 'buf'

(defn- #_void unchanged [#_buffer_C buf]
    (ยง
        (when @(. buf b_changed)
            ((ร buf.@b_changed =) false)
            (check_status buf)
        )
        (ยง buf.b_changedtick++)
    ))

;; called when the status bars for buffer 'buf' need to be updated

(defn- #_void check_status [#_buffer_C buf]
    (ยง
        ((ร FOR) (ร (ยง window_C wp = @firstwin) (!= wp null) (ยง wp = wp.w_next))
            (when (and (== @curbuf buf) (!= (. wp w_status_height) 0))
                ((ร wp.w_redr_status =) true)
                (if (< @must_redraw VALID)
                    (reset! must_redraw VALID))
            )
        )
    ))

;; Ask for a reply from the user, a 'y' or a 'n'.
;; No other characters are accepted, the message is repeated
;; until a valid reply is entered or CTRL-C is hit.
;; If direct is true, don't use vgetc() but ui_inchar(),
;; don't get characters from any buffers but directly from the user.
;;
;; Answer 'y' or 'n'.

(defn- #_int ask_yesno [#_Bytes q, #_boolean direct]
    (ยง
        ((ร int c =) (byte \space))

        ((ร int save_State =) @State)

        (if @exiting                ;; put terminal in raw mode for this question
            (settmode TMODE_RAW))

        (swap! no_wait_return inc)
        (reset! State CONFIRM)            ;; mouse behaves like with :confirm
        (swap! no_mapping inc)
        (swap! allow_keys inc)               ;; no mapping here, but recognize keys

        (while (ยง c != (byte \y) && c != (byte \n))
            ;; same highlighting as for wait_return
            (smsg_attr (hl_attr HLF_R), (u8 "%s (y/n)?"), q)

            ((ร c =) (if direct (get_keystroke) (plain_vgetc)))
            (if (or (== c Ctrl_C) (== c ESC))
                ((ร c =) (byte \n))
            )

            (msg_putchar c)         ;; show what you typed
            (out_flush)
        )

        (swap! no_wait_return dec)
        (reset! State save_State)
        (swap! no_mapping dec)
        (swap! allow_keys dec)

        c
    ))

;; Get a key stroke directly from the user.
;; Ignores mouse clicks and scrollbar events, except a click for the left button (used at the more prompt).
;; Doesn't use vgetc(), because it syncs undo and eats mapped characters.
;; Disadvantage: typeahead is ignored.
;; Translates the interrupt character for unix to ESC.

(defn- #_int get_keystroke []
    (ยง
        (ร int c)

        ((ร Bytes buf =) null)

        ((ร int buflen =) 150)
; %%    ((ร int[] len =) (ยง { 0 }))
        ((ร int waited =) 0)

        (while true
            (cursor_on)
            (out_flush)

            ;; Leave some room for check_termcode() to insert a key code into (max 5 chars plus NUL).
            ;; And fix_input_buffer() can triple the number of bytes.
            ((ร int maxlen =) (ยง (buflen - 6 - len[0]) / 3))
            (cond (nil? buf)
            (ยง
                ((ร buf =) (ยง new Bytes(buflen)))
            )
            (< maxlen 10)
            (ยง
                ;; Need some more space.
                ;; This might happen when receiving a long escape sequence.
                ((ร buflen +=) 100)
                ((ร Bytes p =) (ยง new Bytes(buflen)))
                (BCOPY p, buf, (ยง len[0]))
                ((ร buf =) p)
                ((ร maxlen =) (ยง (buflen - 6 - len[0]) / 3))
            ))

            ;; First time: blocking wait.
            ;; Second time: wait up to 100ms for a terminal code to complete.
            ((ร int n =) (ui_inchar (.plus buf (ยง len[0])), maxlen, (if (== (ยง len[0]) 0) -1 100), 0))
            (cond (< 0 n)
            (ยง
                ;; Replace zero by a special key code.
                ((ร n =) (ยง fix_input_buffer(buf.plus(len[0]), n)))
                ((ร len[0] +=) n)
                ((ร waited =) 0)
            )
            (< 0 (ยง len[0]))
            (ยง
                (ยง waited++)                   ;; keep track of the waiting time
            ))

            ;; Incomplete termcode and not timed out yet: get more characters.
            ((ร n =) (check_termcode buf, buflen, len))
            (if (and (< n 0) (or (not @p_ttimeout) (< (* waited 100) (if (< @p_ttm 0) @p_tm @p_ttm))))
                (ร CONTINUE)
            )

            (when (== n KEYLEN_REMOVED)        ;; key code removed
                (when (and (non-zero? @must_redraw) (not @need_wait_return) (zero? (& @State CMDLINE)))
                    ;; Redrawing was postponed, do it now.
                    (update_screen 0)
                    (setcursor)            ;; put cursor back where it belongs
                )
                (ร CONTINUE)
            )
            (if (< 0 n)                      ;; found a termcode: adjust length
                ((ร len[0] =) n)
            )
            (if (zero? (ยง len[0]))                   ;; nothing typed yet
                (ร CONTINUE)
            )

            ;; Handle modifier and/or special key code.
            (when (== (.at buf 0) KB_SPECIAL)
                ((ร c =) (ยง toSpecial(buf.at(1), buf.at(2))))
                (when (or (== (.at buf 1) KS_MODIFIER) (== c K_IGNORE))
                    (if (== (.at buf 1) KS_MODIFIER)
                        (reset! mod_mask (char_u (ยง buf.at(2)))))
                    ((ร len[0] -=) 3)
                    (if (< 0 (ยง len[0]))
                        (BCOPY buf, 0, buf, 3, (ยง len[0])))
                    (ร CONTINUE)
                )
                (ร BREAK)
            )

            (if (< (ยง len[0]) (mb_byte2len (char_u (.at buf 0))))
                (ร CONTINUE)                   ;; more bytes to get
            )

            (.be buf (if (<= buflen (ยง len[0])) (- buflen 1) (ยง len[0])), NUL)
            ((ร c =) (us_ptr2char buf))

            (if (== c @intr_char)
                ((ร c =) ESC)
            )
            (ร BREAK)
        )

        c
    ))

(defn- #_void msgmore [#_long n]
    (ยง
        (if (not (messaging))        ;; 'lazyredraw' set, don't do messages now
            (ร RETURN)
        )

        ;; We don't want to overwrite another important message, but do overwrite
        ;; a previous "more lines" or "fewer lines" message, so that "5dd" and
        ;; then "put" reports the last action.

        (if (and (non-nil? @keep_msg) (not @keep_msg_more))
            (ร RETURN)
        )

        (ร long pn)
        (if (< 0 n)
            ((ร pn =) n)
            ((ร pn =) (ยง -n))
        )

        (when (< @p_report pn)
            ((ร Bytes msg_buf =) (ยง new Bytes(MSG_BUF_LEN)))
            (cond (== pn 1)
            (ยง
                (if (< 0 n)
                    (vim_strncpy msg_buf, (u8 "1 more line"), (- MSG_BUF_LEN 1))
                    (vim_strncpy msg_buf, (u8 "1 line less"), (- MSG_BUF_LEN 1)))
            )
            :else
            (ยง
                (if (< 0 n)
                    (ยง vim_snprintf(msg_buf, MSG_BUF_LEN, (u8 "%ld more lines"), pn))
                    (ยง vim_snprintf(msg_buf, MSG_BUF_LEN, (u8 "%ld fewer lines"), pn))
                )
            ))
            (if @got_int
                (vim_strcat msg_buf, (u8 " (Interrupted)"), MSG_BUF_LEN))
            (when (msg msg_buf)
                (set_keep_msg msg_buf, 0)
                (reset! keep_msg_more true)
            )
        )
    ))

;; flush map and typeahead buffers and give a warning for an error

(defn- #_void beep_flush []
    (ยง
        (flush_buffers false)
        (vim_beep)
    ))

;; give a warning for an error

(defn- #_void vim_beep []
    (ยง
        (if @p_vb
            (out_str @T_VB)
            (out_char BELL))
    ))

(defn- #_void prepare_to_exit []
    (ยง
        ;; Ignore SIGHUP, because a dropped connection causes a read error, which
        ;; makes Vim exit and then handling SIGHUP causes various reentrance problems.

        (ยง libC.sigset(SIGHUP, #_"/*SIG_IGN*/"null))

        (windgoto (- (int @Rows) 1), 0)

        ;; Switch terminal mode back now, so messages end up on the "normal"
        ;; screen (if there are two screens).

        (settmode TMODE_COOK)
        (stoptermcap)
        (out_flush)
    ))

;; Preserve files and exit.
;; When called ioBuff must contain a message.
;; NOTE: This may be called from deathtrap() in a signal handler,
;; avoid unsafe functions, such as allocating memory.

(defn- #_void preserve_exit []
    (ยง
        (prepare_to_exit)

        (out_str @ioBuff)
        (screen_start)                 ;; don't know where cursor is now
        (out_flush)

        (out_str (u8 "Vim: Finished.\n"))

        (getout 1)
    ))

;; Check for CTRL-C pressed, but only once in a while.
;; Should be used instead of ui_breakcheck() for functions that check for each line in the file.
;; Calling ui_breakcheck() each time takes too much time, because it can be a system call.

(final int BREAKCHECK_SKIP 32)

(atom! int      breakcheck_count)

(defn- #_void line_breakcheck []
    (ยง
        (when (<= BREAKCHECK_SKIP (ยง ++@breakcheck_count))
            (reset! breakcheck_count 0)
            (ui_breakcheck)
        )
    ))

;; Like line_breakcheck() but check 10 times less often.

(defn- #_void fast_breakcheck []
    (ยง
        (when (ยง BREAKCHECK_SKIP * 10 <= ++@breakcheck_count)
            (reset! breakcheck_count 0)
            (ui_breakcheck)
        )
    ))

;; Return true when need to go to Insert mode because of 'insertmode'.
;; Don't do this when still processing a command or a mapping.
;; Don't do this when inside a ":normal" command.

(defn- #_boolean goto_im []
    (and @p_im (stuff_empty)))

;; Return true if in the current mode we need to use virtual.

(defn- #_boolean virtual_active []
    (ยง
        ;; While an operator is being executed we return "virtual_op",
        ;; because VIsual_active has already been reset,
        ;; thus we can't check for "block" being used.
        (if (!= @virtual_op MAYBE)
            (ยง (@virtual_op != FALSE))
            (ยง @ve_flags == VE_ALL || ((@ve_flags & VE_BLOCK) != 0 && @VIsual_active && @VIsual_mode == Ctrl_V) || ((@ve_flags & VE_INSERT) != 0 && (@State & INSERT) != 0))
        )
    ))

;; Get the screen position of the cursor.

(defn- #_int getviscol []
    (ยง
        ((ร int[] x =) (ยง new int[1]))
        (getvvcol @curwin, (. @curwin w_cursor), x, null, null)
        (ยง x[0])
    ))

;; Get the screen position of character col with a coladd in the cursor line.

(defn- #_int getviscol2 [#_int col, #_int coladd]
    (ยง
        ((ร pos_C pos =) (ยง ยง_pos_C()))
        ((ร pos.lnum =) (.. @curwin w_cursor lnum))
        ((ร pos.col =) col)
        ((ร pos.coladd =) coladd)

        ((ร int[] x =) (ยง new int[1]))
        (getvvcol @curwin, pos, x, null, null)
        (ยง x[0])
    ))

;; Go to column "wcol", and add/insert white space as necessary to get the
;; cursor in that column.
;; The caller must have saved the cursor line for undo!

(defn- #_boolean coladvance_force [#_int wcol]
    (ยง
        ((ร boolean rc =) (ยง coladvance2(@curwin.w_cursor, true, false, wcol)))

        (cond (== wcol MAXCOL)
        (ยง
            ((ร @curwin.w_valid &=) (ยง ~VALID_VIRTCOL))
        )
        :else
        (ยง
            ;; Virtcol is valid.
            ((ร @curwin.w_valid |=) VALID_VIRTCOL)
            ((ร @curwin.w_virtcol =) wcol)
        ))
        rc
    ))

;; Try to advance the Cursor to the specified screen column.
;; If virtual editing: fine tune the cursor position.
;; Note that all virtual positions off the end of a line should share
;; a curwin.w_cursor.col value (n.b. this is equal to STRLEN(line)),
;; beginning at coladd 0.
;;
;; return true if desired column is reached, false if not

(defn- #_boolean coladvance [#_int wcol]
    (ยง
        ((ร boolean rc =) (ยง getvpos(@curwin.w_cursor, wcol)))

        (cond (or (== wcol MAXCOL) (not rc))
        (ยง
            ((ร @curwin.w_valid &=) (ยง ~VALID_VIRTCOL))
        )
        (!= (.at (ml_get_cursor) 0) TAB)
        (ยง
            ;; Virtcol is valid when not on a TAB.
            ((ร @curwin.w_valid |=) VALID_VIRTCOL)
            ((ร @curwin.w_virtcol =) wcol)
        ))
        rc
    ))

;; Return in "pos" the position of the cursor advanced to screen column "wcol".
;; return true if desired column is reached, false if not

(defn- #_boolean getvpos [#_pos_C pos, #_int wcol]
    (coladvance2 pos, false, (virtual_active), wcol))

(defn- #_boolean coladvance2 [#_pos_C pos, #_boolean addspaces, #_boolean finetune, #_int wcol]
    ;; addspaces: change the text to achieve our goal?
    ;; finetune: change char offset for the exact column
    ;; wcol: column to move to
    (ยง
        ((ร int col =) 0)
        ((ร int csize =) 0)
; %%    ((ร int[] head =) (ยง { 0 }))

        ((ร boolean one_more =) (ยง (@State & INSERT) != 0 || @restart_edit != NUL || (@VIsual_active && @p_sel.at(0) != (byte \o)) || ((@ve_flags & VE_ONEMORE) != 0 && wcol < MAXCOL)))

        ((ร Bytes line =) (ยง ml_get_buf(@curbuf, pos.lnum)))

        (ร int idx)
        (cond (<= MAXCOL wcol)
        (ยง
            ((ร idx =) (+ (- (STRLEN line) 1) (if one_more 1 0)))
            ((ร col =) wcol)

            (when (and (or addspaces finetune) (not @VIsual_active))
                ((ร @curwin.w_curswant =) (+ (linetabsize line) (if one_more 1 0)))
                (if (< 0 (. @curwin w_curswant))
                    (ยง --@curwin.w_curswant)
                )
            )
        )
        :else
        (ยง
            ((ร int width =) (ยง @curwin.w_width - win_col_off(@curwin)))

            (when (and finetune @(.. @curwin w_options wo_wrap) (!= (. @curwin w_width) 0) (<= width wcol))
                ((ร csize =) (linetabsize line))
                (if (< 0 csize)
                    (ยง csize--)
                )

                (when (and (ยง csize / width < wcol / width) (or (zero? (& @State INSERT)) (< (+ csize 1) wcol)))
                    ;; In case of line wrapping don't move the cursor beyond the
                    ;; right screen edge.  In Insert mode allow going just beyond
                    ;; the last character (like what happens when typing and
                    ;; reaching the right window edge).
                    ((ร wcol =) (ยง (csize / width + 1) * width - 1))
                )
            )

            ((ร Bytes ptr =) line)
            (while (ยง col <= wcol && ptr.at(0) != NUL)
                ;; Count a tab for what it's worth (if list mode not on).
                ((ร csize =) (win_lbr_chartabsize @curwin, line, ptr, col, head))
                ((ร ptr =) (ยง ptr.plus(us_ptr2len_cc(ptr))))
                ((ร col +=) csize)
            )
            ((ร idx =) (BDIFF ptr, line))

            ;; Handle all the special cases.  The virtual_active() check
            ;; is needed to ensure that a virtual position off the end of
            ;; a line has the correct indexing.  The one_more comparison
            ;; replaces an explicit add of one_more later on.

            (when (or (< wcol col) (and (not (virtual_active)) (not one_more)))
                ((ร idx -=) 1)
                ;; Don't count the chars from 'showbreak'.
                ((ร csize -=) (ยง head[0]))
                ((ร col -=) csize)
            )

            (when (and (virtual_active) addspaces (or (and (!= col wcol) (!= col (+ wcol 1))) (< 1 csize)))
                ;; 'virtualedit' is set: The difference between wcol and col is filled with spaces.

                (cond (eos? line idx)
                (ยง
                    ;; Append spaces.
                    ((ร int correct =) (- wcol col))
                    ((ร Bytes newline =) (ยง new Bytes(idx + correct + 1)))

                    ((ร FOR) (ร (ยง int t = 0) (< t idx) (ยง t++))
                        (.be newline t, (ยง line.at(t)))
                    )

                    ((ร FOR) (ร (ยง int t = 0) (< t correct) (ยง t++))
                        (ยง newline.be(t + idx, (byte \space)))
                    )

                    (ยง newline.be(idx + correct, NUL))

                    (ml_replace (. pos lnum), newline)
                    (changed_bytes (. pos lnum), idx)
                    ((ร idx +=) correct)
                    ((ร col =) wcol)
                )
                :else
                (ยง
                    ;; Break a tab.
                    ((ร int linelen =) (STRLEN line))
                    ((ร int correct =) (ยง wcol - col - csize + 1)) ;; negative!!

                    (if (< csize (- correct))
                        ((ร RETURN) false)
                    )

                    ((ร Bytes newline =) (ยง new Bytes(linelen + csize)))

                    ((ร int s =) 0)
                    ((ร FOR) (ร (ยง int t = 0) (< t linelen) (ยง t++))
                        (cond (!= t idx)
                        (ยง
                            (.be newline (ยง s++), (ยง line.at(t)))
                        )
                        :else
                        (ยง
                            ((ร FOR) (ร (ยง int v = 0) (< v csize) (ยง v++))
                                (ยง newline.be(s++, (byte \space)))
                            )
                        ))
                    )

                    (ยง newline.be(linelen + csize - 1, NUL))

                    (ml_replace (. pos lnum), newline)
                    (changed_bytes (. pos lnum), idx)
                    ((ร idx +=) (ยง (csize - 1 + correct)))
                    ((ร col +=) correct)
                ))
            )
        ))

        (if (< idx 0)
            ((ร pos.col =) 0)
            ((ร pos.col =) idx)
        )

        ((ร pos.coladd =) 0)

        (when finetune
            (cond (== wcol MAXCOL)
            (ยง
                ;; The width of the last character is used to set coladd.
                (when (not one_more)
                    ((ร int[] scol =) (ยง new int[1]))
                    ((ร int[] ecol =) (ยง new int[1]))

                    (getvcol @curwin, pos, scol, null, ecol)
                    ((ร pos.coladd =) (ยง ecol[0] - scol[0]))
                )
            )
            :else
            (ยง
                ((ร int b =) (- wcol col))

                ;; The difference between wcol and col is used to set coladd.
                (if (and (< 0 b) (< b (ยง (MAXCOL - 2 * @curwin.w_width))))
                    ((ร pos.coladd =) b)
                )

                ((ร col +=) b)
            ))
        )

        ;; prevent from moving onto a trail byte
        (mb_adjust_pos @curbuf, pos)

        (if (< col wcol)
            ((ร RETURN) false)
        )

        true
    ))

;; Increment the cursor position.  See incp() for return values.

(defn- #_int inc_cursor []
    (ยง
        (incp (. @curwin w_cursor))
    ))

;; Increment the line pointer "lp" crossing line boundaries as necessary.
;; Return 1 when going to the next line.
;; Return 2 when moving forward onto a NUL at the end of the line.
;; Return -1 when at the end of file.
;; Return 0 otherwise.

(defn- #_int incp [#_pos_C lp]
    (ยง
        ((ร Bytes p =) (ml_get_pos lp))

        (when (non-eos? p)     ;; still within line, move to next char (may be NUL)
            ((ร int l =) (us_ptr2len_cc p))

            ((ร lp.col +=) l)
            ((ร RETURN) (if (!= (.at p l) NUL) 0 2))
        )
        (when (!= (. lp lnum) (.. @curbuf b_ml ml_line_count))   ;; there is a next line
            ((ร lp.col =) 0)
            (ยง lp.lnum++)
            ((ร lp.coladd =) 0)
            ((ร RETURN) 1)
        )
        -1
    ))

;; incl(lp): same as incp(), but skip the NUL at the end of non-empty lines

(defn- #_int incl [#_pos_C lp]
    (ยง
        ((ร int r =) (incp lp))

        (if (and (<= 1 r) (!= (. lp col) 0))
            ((ร r =) (incp lp))
        )

        r
    ))

;; decp(p)
;;
;; Decrement the line pointer 'p' crossing line boundaries as necessary.
;; Return 1 when crossing a line, -1 when at start of file, 0 otherwise.

(defn- #_int dec_cursor []
    (ยง
        (decp (. @curwin w_cursor))
    ))

(defn- #_int decp [#_pos_C lp]
    (ยง
        ((ร lp.coladd =) 0)

        (when (< 0 (. lp col))         ;; still within line
            (ยง lp.col--)
            ((ร Bytes p =) (ยง ml_get(lp.lnum)))
            ((ร lp.col -=) (ยง us_head_off(p, p.plus(lp.col))))
            ((ร RETURN) 0)
        )

        (when (< 1 (. lp lnum))        ;; there is a prior line
            (ยง lp.lnum--)
            ((ร Bytes p =) (ยง ml_get(lp.lnum)))
            ((ร lp.col =) (STRLEN p))
            ((ร lp.col -=) (ยง us_head_off(p, p.plus(lp.col))))
            ((ร RETURN) 1)
        )

        -1                  ;; at start of file
    ))

;; decl(lp): same as decp(), but skip the NUL at the end of non-empty lines

(defn- #_int decl [#_pos_C lp]
    (ยง
        ((ร int r =) (decp lp))

        (if (and (== r 1) (!= (. lp col) 0))
            ((ร r =) (decp lp))
        )

        r
    ))

;; Get the line number relative to the current cursor position,
;; i.e. the difference between line number and cursor position.
;; Only look for lines that can be visible, folded lines don't count.

(defn- #_long get_cursor_rel_lnum [#_window_C wp, #_long lnum]
    ;; lnum: line number to get the result for
    (ยง
        (- lnum (.. wp w_cursor lnum))
    ))

;; Make sure curwin.w_cursor.lnum is valid.

(defn- #_void check_cursor_lnum []
    (ยง
        (if (> (.. @curwin w_cursor lnum) (.. @curbuf b_ml ml_line_count))
            ((ร @curwin.w_cursor.lnum =) (.. @curbuf b_ml ml_line_count))
        )

        (when (<= (.. @curwin w_cursor lnum) 0)
            ((ร @curwin.w_cursor.lnum =) 1)
        )
    ))

;; Make sure curwin.w_cursor.col is valid.

(defn- #_void check_cursor_col []
    (check_cursor_col_win @curwin))

;; Make sure win.w_cursor.col is valid.

(defn- #_void check_cursor_col_win [#_window_C win]
    (ยง
        ((ร int oldcol =) (.. win w_cursor col))
        ((ร int oldcoladd =) (ยง win.w_cursor.col + win.w_cursor.coladd))

        ((ร int len =) (ยง STRLEN(ml_get_buf(@curbuf, win.w_cursor.lnum))))
        (cond (zero? len)
        (ยง
            ((ร win.w_cursor.col =) 0)
        )
        (<= len (.. win w_cursor col))
        (ยง
            ;; Allow cursor past end-of-line when:
            ;; - in Insert mode or restarting Insert mode
            ;; - in Visual mode and 'selection' isn't "old"
            ;; - 'virtualedit' is set
            (cond (or (non-zero? (& @State INSERT)) (non-zero? @restart_edit) (and @VIsual_active (!= (.at @p_sel 0) (byte \o))) (non-zero? (& @ve_flags VE_ONEMORE)) (virtual_active))
            (ยง
                ((ร win.w_cursor.col =) len)
            )
            :else
            (ยง
                ((ร win.w_cursor.col =) (- len 1))
                ;; Move the cursor to the head byte.
                (mb_adjust_pos @curbuf, (. win w_cursor))
            ))
        )
        (< (.. win w_cursor col) 0)
        (ยง
            ((ร win.w_cursor.col =) 0)
        ))

        ;; If virtual editing is on, we can leave the cursor on the old position,
        ;; only we must set it to virtual.  But don't do it when at the end of the line.
        (cond (== oldcol MAXCOL)
        (ยง
            ((ร win.w_cursor.coladd =) 0)
        )
        (== @ve_flags VE_ALL)
        (ยง
            (cond (< (.. win w_cursor col) oldcoladd)
            (ยง
                ((ร win.w_cursor.coladd =) (ยง oldcoladd - win.w_cursor.col))
            )
            :else
            (ยง
                ;; avoid weird number when there is a miscalculation or overflow
                ((ร win.w_cursor.coladd =) 0)
            ))
        ))
    ))

;; make sure curwin.w_cursor in on a valid character

(defn- #_void check_cursor []
    (ยง
        (check_cursor_lnum)
        (check_cursor_col)
    ))

;; Make sure curwin.w_cursor is not on the NUL at the end of the line.
;; Allow it when in Visual mode and 'selection' is not "old".

(defn- #_void adjust_cursor_col []
    (ยง
        (when (and (< 0 (.. @curwin w_cursor col)) (or (not @VIsual_active) (== (.at @p_sel 0) (byte \o))) (== (gchar_cursor) NUL))
            (ยง --@curwin.w_cursor.col)
        )
    ))

;; When curwin.w_leftcol has changed, adjust the cursor position.
;; Return true if the cursor was moved.

(defn- #_boolean leftcol_changed []
    (ยง
        ((ร boolean retval =) false)

        (changed_cline_bef_curs)
        ((ร long lastcol =) (ยง @curwin.w_leftcol + @curwin.w_width - curwin_col_off() - 1))
        (validate_virtcol)

        ;; If the cursor is right or left of the screen, move it to last or first character.

        (cond (ยง (int)(lastcol - @p_siso) < @curwin.w_virtcol)
        (ยง
            ((ร retval =) true)
            (coladvance (ยง (int)(lastcol - @p_siso)))
        )
        (< (. @curwin w_virtcol) (+ (. @curwin w_leftcol) @p_siso))
        (ยง
            ((ร retval =) true)
            (coladvance (ยง (int)(@curwin.w_leftcol + @p_siso)))
        ))

        ;; If the start of the character under the cursor is not on the screen,
        ;; advance the cursor one more char.  If this fails (last char of the line),
        ;; adjust the scrolling.

        ((ร int[] s =) (ยง new int[1]))
        ((ร int[] e =) (ยง new int[1]))
        (getvvcol @curwin, (. @curwin w_cursor), s, null, e)
        (cond (< (int lastcol) (ยง e[0]))
        (ยง
            ((ร retval =) true)
            (coladvance (- (ยง s[0]) 1))
        )
        (< (ยง s[0]) (. @curwin w_leftcol))
        (ยง
            ((ร retval =) true)
            (when (not (coladvance (+ (ยง e[0]) 1)))     ;; there isn't another character
                ((ร @curwin.w_leftcol =) (ยง s[0]))           ;; adjust w_leftcol instead
                (changed_cline_bef_curs)
            )
        ))

        (if retval
            ((ร @curwin.w_set_curswant =) true)
        )
        (redraw_later NOT_VALID)
        retval
    ))

;; Various routines dealing with allocation and deallocation of memory.

;; Copy "string" into newly allocated memory.

(defn- #_Bytes STRDUP [#_Bytes string]
    (ยง
        ((ร int len =) (ยง STRLEN(string) + 1))
        ((ร Bytes s =) (ยง new Bytes(len)))
        (BCOPY s, string, len)
        s
    ))

;; Copy up to "len" bytes of "string" into newly allocated memory and terminate with a NUL.
;; The allocated memory always has size "len + 1", also when "string" is shorter.

(defn- #_Bytes STRNDUP [#_Bytes string, #_int len]
    (ยง
        ((ร Bytes s =) (ยง new Bytes(len + 1)))
        (STRNCPY s, string, len)
        (.be s len, NUL)
        s
    ))

;; Same as STRDUP(), but any characters found in esc_chars are preceded by a backslash.

(defn- #_Bytes vim_strsave_escaped [#_Bytes string, #_Bytes esc_chars]
    (vim_strsave_escaped_ext string, esc_chars, (byte \\)))

;; Same as vim_strsave_escaped().
;; Escape the characters with "cc".

(defn- #_Bytes vim_strsave_escaped_ext [#_Bytes string, #_Bytes esc_chars, #_int cc]
    (ยง
        ;; First count the number of backslashes required.
        ;; Then allocate the memory and insert them.

        ((ร int length =) 1)                         ;; count the trailing NUL
        ((ร FOR) (ร (ยง Bytes p = string) (ยง p.at(0) != NUL) (ยง p = p.plus(1)))
            ((ร int l =) (us_ptr2len_cc p))
            (when (< 1 l)
                ((ร length +=) l)                    ;; count a multibyte char
                ((ร p =) (ยง p.plus(l - 1)))
                (ร CONTINUE)
            )
            (if (non-nil? (ยง vim_strchr(esc_chars, p.at(0))))
                (ยง length++)                       ;; count a backslash
            )
            (ยง length++)                           ;; count an ordinary char
        )

        ((ร Bytes escaped_string =) (ยง new Bytes(length)))

        ((ร Bytes p2 =) escaped_string)
        ((ร FOR) (ร (ยง Bytes p = string) (ยง p.at(0) != NUL) (ยง p = p.plus(1)))
            ((ร int l =) (us_ptr2len_cc p))
            (when (< 1 l)
                (BCOPY p2, p, l)
                ((ร p2 =) (ยง p2.plus(l)))
                ((ร p =) (ยง p.plus(l - 1)))                     ;; skip multibyte char
                (ร CONTINUE)
            )
            (if (non-nil? (ยง vim_strchr(esc_chars, p.at(0))))
                (ยง (p2 = p2.plus(1)).be(-1, cc))
            )
            (ยง (p2 = p2.plus(1)).be(-1, p.at(0)))
        )
        (.be p2 0, NUL)

        escaped_string
    ))

;; ASCII lower-to-upper case translation, language independent.

(defn- #_void vim_strup [#_Bytes p]
    (ยง
        (when (non-nil? p)
            ((ร FOR) (ร (ยง int c) (ยง (c = p.at(0)) != NUL) nil)
                (.be ((ร p =) (.plus p 1)) -1, (if (or (< c (byte \a)) (< (byte \z) c)) c (- c 0x20)))
            )
        )
    ))

;; Like STRDUP(), but make all characters uppercase.
;; This uses ASCII lower-to-upper case translation, language independent.

(defn- #_Bytes vim_strsave_up [#_Bytes string]
    (ยง
        ((ร Bytes p =) (STRDUP string))
        (vim_strup p)
        p
    ))

;; copy a space a number of times

(defn- #_void copy_spaces [#_Bytes s, #_int n]
    (ยง
        ((ร FOR) (ร (ยง int i = 0) (< i n) (ยง i++))
            (ยง s.be(i, (byte \space)))
        )
    ))

;; Copy a character a number of times.
;; Does not work for multi-byte characters!

(defn- #_void copy_chars [#_Bytes s, #_int n, #_int c]
    (ยง
        ((ร FOR) (ร (ยง int i = 0) (< i n) (ยง i++))
            (.be s i, c)
        )
    ))

;; Like strncpy(), but always terminate the result with one NUL.
;; "dst" must be "len + 1" long!

(defn- #_void vim_strncpy [#_Bytes dst, #_Bytes src, #_int len]
    (ยง
        (STRNCPY dst, src, len)
        (.be dst len, NUL)
    ))

;; Like strcat(), but make sure the result fits in "size" bytes
;; and is always NUL terminated.

(defn- #_void vim_strcat [#_Bytes dst, #_Bytes src, #_int size]
    (ยง
        ((ร int dlen =) (ยง STRLEN(dst), slen = STRLEN(src)))

        (cond (< size (ยง dlen + slen + 1))
        (ยง
            (BCOPY dst, dlen, src, 0, (ยง size - dlen - 1))
            (ยง dst.be(size - 1, NUL))
        )
        :else
        (ยง
            (STRCPY (.plus dst dlen), src)
        ))
    ))

;; Isolate one part of a string option where parts are separated with "sep_chars".
;; The part is copied into "buf[maxlen]".
;; "*option" is advanced to the next part.
;; The length is returned.

(defn- #_int copy_option_part [#_Bytes* option, #_Bytes buf, #_int maxlen, #_Bytes sep_chars]
    (ยง
        ((ร int len =) 0)
        ((ร Bytes p =) (ยง option[0]))

        ;; skip '.' at start of option part, for 'suffixes'
        (if (== (.at p 0) (byte \.))
            (ยง buf.be(len++, (p = p.plus(1)).at(-1)))
        )
        (while (ยง p.at(0) != NUL && vim_strchr(sep_chars, p.at(0)) == null)
            ;; Skip backslash before a separator character and space.

            (if (and (== (.at p 0) (byte \\)) (non-nil? (ยง vim_strchr(sep_chars, p.at(1)))))
                ((ร p =) (ยง p.plus(1)))
            )
            (if (< len (- maxlen 1))
                (.be buf (ยง len++), (ยง p.at(0)))
            )
            ((ร p =) (ยง p.plus(1)))
        )
        (.be buf len, NUL)

        (if (and (non-eos? p) (!= (.at p 0) (byte \,))) ;; skip non-standard separator
            ((ร p =) (ยง p.plus(1)))
        )
        ((ร p =) (skip_to_option_part p)) ;; "p" points to next file name

        ((ร option[0] =) p)
        len
    ))

;; Version of strchr() and strrchr() that handle unsigned char strings
;; with characters from 128 to 255 correctly.  It also doesn't return
;; a pointer to the NUL at the end of the string.

(defn- #_Bytes vim_strchr [#_Bytes string, #_int c]
    (ยง
        ((ร FOR) (ร (ยง Bytes p = string) (ยง p.at(0) != NUL) (ยง p = p.plus(us_ptr2len_cc(p))))
            (if (== (us_ptr2char p) c)
                ((ร RETURN) p)
            )
        )

        null
    ))

;; Version of strchr() that only works for bytes and handles unsigned char
;; strings with characters above 128 correctly.  It also doesn't return a
;; pointer to the NUL at the end of the string.

(defn- #_Bytes vim_strbyte [#_Bytes string, #_byte b]
    (ยง
        ((ร FOR) (ร (ยง Bytes p = string) (ยง p.at(0) != NUL) (ยง p = p.plus(1)))
            (if (== (.at p 0) b)
                ((ร RETURN) p)
            )
        )

        null
    ))

;; Search for last occurrence of "b" in "string".
;; Return null if not found.
;; Does not handle multi-byte char for "b"!

(defn- #_Bytes vim_strrchr [#_Bytes string, #_byte b]
    (ยง
        ((ร Bytes q =) null)

        ((ร FOR) (ร (ยง Bytes p = string) (ยง p.at(0) != NUL) (ยง p = p.plus(us_ptr2len_cc(p))))
            (if (== (.at p 0) b)
                ((ร q =) p)
            )
        )

        q
    ))

;; Vim has its own isspace() function, because on some machines isspace()
;; can't handle characters above 128.

(defn- #_boolean vim_isspace [#_int x]
    (or (and (<= 9 x) (<= x 13)) (== x (byte \space))))

;; Some useful tables.

(class! #_final modmasktable_C
    [
        (field int      mod_mask)       ;; bit-mask for particular key modifier
        (field int      mod_flag)       ;; bit(s) for particular key modifier
        (field byte     name)           ;; single letter name of modifier
    ])

(final modmasktable_C* mod_mask_table
    [
        (->modmasktable_C MOD_MASK_ALT,         MOD_MASK_ALT,    (byte \M)),
        (->modmasktable_C MOD_MASK_META,        MOD_MASK_META,   (byte \T)),
        (->modmasktable_C MOD_MASK_CTRL,        MOD_MASK_CTRL,   (byte \C)),
        (->modmasktable_C MOD_MASK_SHIFT,       MOD_MASK_SHIFT,  (byte \S)),
        (->modmasktable_C MOD_MASK_MULTI_CLICK, MOD_MASK_2CLICK, (byte \2)),
        (->modmasktable_C MOD_MASK_MULTI_CLICK, MOD_MASK_3CLICK, (byte \3)),
        (->modmasktable_C MOD_MASK_MULTI_CLICK, MOD_MASK_4CLICK, (byte \4)),
        ;; 'A' must be the last one
        (->modmasktable_C MOD_MASK_ALT,         MOD_MASK_ALT,    (byte \A))
    ])

;; Shifted key terminal codes and their unshifted equivalent.

(final int MOD_KEYS_ENTRY_SIZE 5)

(final byte* modifier_keys_table
    [
     ;; mod mask            with modifier           without modifier
        MOD_MASK_SHIFT,     (byte \&), (byte \9),   (byte \@), (byte \1),   ;; begin
        MOD_MASK_SHIFT,     (byte \&), (byte \0),   (byte \@), (byte \2),   ;; cancel
        MOD_MASK_SHIFT,     (byte \*), (byte \1),   (byte \@), (byte \4),   ;; command
        MOD_MASK_SHIFT,     (byte \*), (byte \2),   (byte \@), (byte \5),   ;; copy
        MOD_MASK_SHIFT,     (byte \*), (byte \3),   (byte \@), (byte \6),   ;; create
        MOD_MASK_SHIFT,     (byte \*), (byte \4),   (byte \k), (byte \D),   ;; delete char
        MOD_MASK_SHIFT,     (byte \*), (byte \5),   (byte \k), (byte \L),   ;; delete line
        MOD_MASK_SHIFT,     (byte \*), (byte \7),   (byte \@), (byte \7),   ;; end
        MOD_MASK_CTRL,      KS_EXTRA, KE_C_END,     (byte \@), (byte \7),   ;; end
        MOD_MASK_SHIFT,     (byte \*), (byte \9),   (byte \@), (byte \9),   ;; exit
        MOD_MASK_SHIFT,     (byte \*), (byte \0),   (byte \@), (byte \0),   ;; find
        MOD_MASK_SHIFT,     (byte \#), (byte \1),   (byte \%), (byte \1),   ;; help
        MOD_MASK_SHIFT,     (byte \#), (byte \2),   (byte \k), (byte \h),   ;; home
        MOD_MASK_CTRL,      KS_EXTRA, KE_C_HOME,    (byte \k), (byte \h),   ;; home
        MOD_MASK_SHIFT,     (byte \#), (byte \3),   (byte \k), (byte \I),   ;; insert
        MOD_MASK_SHIFT,     (byte \#), (byte \4),   (byte \k), (byte \l),   ;; left arrow
        MOD_MASK_CTRL,      KS_EXTRA, KE_C_LEFT,    (byte \k), (byte \l),   ;; left arrow
        MOD_MASK_SHIFT,     (byte \%), (byte \a),   (byte \%), (byte \3),   ;; message
        MOD_MASK_SHIFT,     (byte \%), (byte \b),   (byte \%), (byte \4),   ;; move
        MOD_MASK_SHIFT,     (byte \%), (byte \c),   (byte \%), (byte \5),   ;; next
        MOD_MASK_SHIFT,     (byte \%), (byte \d),   (byte \%), (byte \7),   ;; options
        MOD_MASK_SHIFT,     (byte \%), (byte \e),   (byte \%), (byte \8),   ;; previous
        MOD_MASK_SHIFT,     (byte \%), (byte \f),   (byte \%), (byte \9),   ;; print
        MOD_MASK_SHIFT,     (byte \%), (byte \g),   (byte \%), (byte \0),   ;; redo
        MOD_MASK_SHIFT,     (byte \%), (byte \h),   (byte \&), (byte \3),   ;; replace
        MOD_MASK_SHIFT,     (byte \%), (byte \i),   (byte \k), (byte \r),   ;; right arrow
        MOD_MASK_CTRL,      KS_EXTRA, KE_C_RIGHT,   (byte \k), (byte \r),   ;; right arrow
        MOD_MASK_SHIFT,     (byte \%), (byte \j),   (byte \&), (byte \5),   ;; resume
        MOD_MASK_SHIFT,     (byte \!), (byte \1),   (byte \&), (byte \6),   ;; save
        MOD_MASK_SHIFT,     (byte \!), (byte \2),   (byte \&), (byte \7),   ;; suspend
        MOD_MASK_SHIFT,     (byte \!), (byte \3),   (byte \&), (byte \8),   ;; undo
        MOD_MASK_SHIFT,     KS_EXTRA, KE_S_UP,      (byte \k), (byte \u),   ;; up arrow
        MOD_MASK_SHIFT,     KS_EXTRA, KE_S_DOWN,    (byte \k), (byte \d),   ;; down arrow

                                                                            ;; vt100 F1
        MOD_MASK_SHIFT,     KS_EXTRA, KE_S_XF1,     KS_EXTRA, KE_XF1,
        MOD_MASK_SHIFT,     KS_EXTRA, KE_S_XF2,     KS_EXTRA, KE_XF2,
        MOD_MASK_SHIFT,     KS_EXTRA, KE_S_XF3,     KS_EXTRA, KE_XF3,
        MOD_MASK_SHIFT,     KS_EXTRA, KE_S_XF4,     KS_EXTRA, KE_XF4,

        MOD_MASK_SHIFT,     KS_EXTRA, KE_S_F1,      (byte \k), (byte \1),   ;; F1
        MOD_MASK_SHIFT,     KS_EXTRA, KE_S_F2,      (byte \k), (byte \2),
        MOD_MASK_SHIFT,     KS_EXTRA, KE_S_F3,      (byte \k), (byte \3),
        MOD_MASK_SHIFT,     KS_EXTRA, KE_S_F4,      (byte \k), (byte \4),
        MOD_MASK_SHIFT,     KS_EXTRA, KE_S_F5,      (byte \k), (byte \5),
        MOD_MASK_SHIFT,     KS_EXTRA, KE_S_F6,      (byte \k), (byte \6),
        MOD_MASK_SHIFT,     KS_EXTRA, KE_S_F7,      (byte \k), (byte \7),
        MOD_MASK_SHIFT,     KS_EXTRA, KE_S_F8,      (byte \k), (byte \8),
        MOD_MASK_SHIFT,     KS_EXTRA, KE_S_F9,      (byte \k), (byte \9),
        MOD_MASK_SHIFT,     KS_EXTRA, KE_S_F10,     (byte \k), (byte \;),   ;; F10

        MOD_MASK_SHIFT,     KS_EXTRA, KE_S_F11,     (byte \F), (byte \1),
        MOD_MASK_SHIFT,     KS_EXTRA, KE_S_F12,     (byte \F), (byte \2),

        MOD_MASK_SHIFT,     (byte \k), (byte \B),   KS_EXTRA, KE_TAB,       ;; TAB pseudo code

        NUL
    ])

(class! #_final key_name_C
    [
        (field int      key)        ;; special key code or ascii value
        (field Bytes    name)       ;; name of key
    ])

(final key_name_C* key_names_table
    [
        (->key_name_C (int \space),     (u8 "Space")           ),
        (->key_name_C TAB,              (u8 "Tab")             ),
        (->key_name_C K_TAB,            (u8 "Tab")             ),
        (->key_name_C NL,               (u8 "NL")              ),
        (->key_name_C NL,               (u8 "NewLine")         ),  ;; alternative name
        (->key_name_C NL,               (u8 "LineFeed")        ),  ;; alternative name
        (->key_name_C NL,               (u8 "LF")              ),  ;; alternative name
        (->key_name_C CAR,              (u8 "CR")              ),
        (->key_name_C CAR,              (u8 "Return")          ),  ;; alternative name
        (->key_name_C CAR,              (u8 "Enter")           ),  ;; alternative name
        (->key_name_C K_BS,             (u8 "BS")              ),
        (->key_name_C K_BS,             (u8 "BackSpace")       ),  ;; alternative name
        (->key_name_C ESC,              (u8 "Esc")             ),
        (->key_name_C (int \|),         (u8 "Bar")             ),
        (->key_name_C (int \\),         (u8 "Bslash")          ),
        (->key_name_C K_DEL,            (u8 "Del")             ),
        (->key_name_C K_DEL,            (u8 "Delete")          ),  ;; alternative name
        (->key_name_C K_KDEL,           (u8 "kDel")            ),
        (->key_name_C K_UP,             (u8 "Up")              ),
        (->key_name_C K_DOWN,           (u8 "Down")            ),
        (->key_name_C K_LEFT,           (u8 "Left")            ),
        (->key_name_C K_RIGHT,          (u8 "Right")           ),
        (->key_name_C K_XUP,            (u8 "xUp")             ),
        (->key_name_C K_XDOWN,          (u8 "xDown")           ),
        (->key_name_C K_XLEFT,          (u8 "xLeft")           ),
        (->key_name_C K_XRIGHT,         (u8 "xRight")          ),

        (->key_name_C K_F1,             (u8 "F1")              ),
        (->key_name_C K_F2,             (u8 "F2")              ),
        (->key_name_C K_F3,             (u8 "F3")              ),
        (->key_name_C K_F4,             (u8 "F4")              ),
        (->key_name_C K_F5,             (u8 "F5")              ),
        (->key_name_C K_F6,             (u8 "F6")              ),
        (->key_name_C K_F7,             (u8 "F7")              ),
        (->key_name_C K_F8,             (u8 "F8")              ),
        (->key_name_C K_F9,             (u8 "F9")              ),
        (->key_name_C K_F10,            (u8 "F10")             ),

        (->key_name_C K_F11,            (u8 "F11")             ),
        (->key_name_C K_F12,            (u8 "F12")             ),

        (->key_name_C K_XF1,            (u8 "xF1")             ),
        (->key_name_C K_XF2,            (u8 "xF2")             ),
        (->key_name_C K_XF3,            (u8 "xF3")             ),
        (->key_name_C K_XF4,            (u8 "xF4")             ),

        (->key_name_C K_HELP,           (u8 "Help")            ),
        (->key_name_C K_UNDO,           (u8 "Undo")            ),
        (->key_name_C K_INS,            (u8 "Insert")          ),
        (->key_name_C K_INS,            (u8 "Ins")             ),  ;; alternative name
        (->key_name_C K_KINS,           (u8 "kInsert")         ),
        (->key_name_C K_HOME,           (u8 "Home")            ),
        (->key_name_C K_KHOME,          (u8 "kHome")           ),
        (->key_name_C K_XHOME,          (u8 "xHome")           ),
        (->key_name_C K_ZHOME,          (u8 "zHome")           ),
        (->key_name_C K_END,            (u8 "End")             ),
        (->key_name_C K_KEND,           (u8 "kEnd")            ),
        (->key_name_C K_XEND,           (u8 "xEnd")            ),
        (->key_name_C K_ZEND,           (u8 "zEnd")            ),
        (->key_name_C K_PAGEUP,         (u8 "PageUp")          ),
        (->key_name_C K_PAGEDOWN,       (u8 "PageDown")        ),
        (->key_name_C K_KPAGEUP,        (u8 "kPageUp")         ),
        (->key_name_C K_KPAGEDOWN,      (u8 "kPageDown")       ),

        (->key_name_C K_KPLUS,          (u8 "kPlus")           ),
        (->key_name_C K_KMINUS,         (u8 "kMinus")          ),
        (->key_name_C K_KDIVIDE,        (u8 "kDivide")         ),
        (->key_name_C K_KMULTIPLY,      (u8 "kMultiply")       ),
        (->key_name_C K_KENTER,         (u8 "kEnter")          ),
        (->key_name_C K_KPOINT,         (u8 "kPoint")          ),

        (->key_name_C K_K0,             (u8 "k0")              ),
        (->key_name_C K_K1,             (u8 "k1")              ),
        (->key_name_C K_K2,             (u8 "k2")              ),
        (->key_name_C K_K3,             (u8 "k3")              ),
        (->key_name_C K_K4,             (u8 "k4")              ),
        (->key_name_C K_K5,             (u8 "k5")              ),
        (->key_name_C K_K6,             (u8 "k6")              ),
        (->key_name_C K_K7,             (u8 "k7")              ),
        (->key_name_C K_K8,             (u8 "k8")              ),
        (->key_name_C K_K9,             (u8 "k9")              ),

        (->key_name_C (int \<),         (u8 "lt")              ),

        (->key_name_C K_DROP,           (u8 "Drop")            ),
        (->key_name_C K_ZERO,           (u8 "Nul")             ),

        (->key_name_C K_CURSORHOLD,     (u8 "CursorHold")      ),
    ])

;; Check if if there is a special key code for "key" that includes the modifiers specified.

(defn- #_int simplify_key [#_int key, #_int* modifiers]
    (ยง
        (when (non-zero? (ยง modifiers[0] & (MOD_MASK_SHIFT | MOD_MASK_CTRL | MOD_MASK_ALT)))
            ;; TAB is a special case.
            (when (and (== key TAB) (non-zero? (& (ยง modifiers[0]) MOD_MASK_SHIFT)))
                ((ร modifiers[0] &=) (ยง ~MOD_MASK_SHIFT))
                ((ร RETURN) K_S_TAB)
            )

            ((ร byte[] mkt =) modifier_keys_table)
            ((ร byte key0 =) (ยง KEY2TERMCAP0(key), key1 = KEY2TERMCAP1(key)))

            ((ร FOR) (ร (ยง int i = 0) (ยง mkt[i] != NUL) (ยง i += MOD_KEYS_ENTRY_SIZE))
                (when (and (== key0 (ยง mkt[i + 3])) (== key1 (ยง mkt[i + 4])) (non-zero? (ยง modifiers[0] & char_u(mkt[i]))))
                    ((ร modifiers[0] &=) (ยง ~char_u(mkt[i])))
                    ((ร RETURN) (ยง TERMCAP2KEY(mkt[i + 1], mkt[i + 2])))
                )
            )
        )

        key
    ))

;; Change <xHome> to <Home>, <xUp> to <Up>, etc.

(defn- #_int handle_x_keys [#_int key]
    (ยง
        ((ร SWITCH) key
            ((ร CASE) K_XUP)
            (ยง
                ((ร RETURN) K_UP)
            )
            ((ร CASE) K_XDOWN)
            (ยง
                ((ร RETURN) K_DOWN)
            )
            ((ร CASE) K_XLEFT)
            (ยง
                ((ร RETURN) K_LEFT)
            )
            ((ร CASE) K_XRIGHT)
            (ยง
                ((ร RETURN) K_RIGHT)
            )
            ((ร CASE) K_XHOME)
            (ยง
                ((ร RETURN) K_HOME)
            )
            ((ร CASE) K_ZHOME)
            (ยง
                ((ร RETURN) K_HOME)
            )
            ((ร CASE) K_XEND)
            (ยง
                ((ร RETURN) K_END)
            )
            ((ร CASE) K_ZEND)
            (ยง
                ((ร RETURN) K_END)
            )
            ((ร CASE) K_XF1)
            (ยง
                ((ร RETURN) K_F1)
            )
            ((ร CASE) K_XF2)
            (ยง
                ((ร RETURN) K_F2)
            )
            ((ร CASE) K_XF3)
            (ยง
                ((ร RETURN) K_F3)
            )
            ((ร CASE) K_XF4)
            (ยง
                ((ร RETURN) K_F4)
            )
            ((ร CASE) K_S_XF1)
            (ยง
                ((ร RETURN) K_S_F1)
            )
            ((ร CASE) K_S_XF2)
            (ยง
                ((ร RETURN) K_S_F2)
            )
            ((ร CASE) K_S_XF3)
            (ยง
                ((ร RETURN) K_S_F3)
            )
            ((ร CASE) K_S_XF4)
            (ยง
                ((ร RETURN) K_S_F4)
            )
        )
        key
    ))

;; Return a string which contains the name of the given key when the given modifiers are down.

(defn- #_Bytes get_special_key_name [#_int c, #_int modifiers]
    (ยง
        ;; Key that stands for a normal character.
        (if (and (is_special c) (== (KEY2TERMCAP0 c) KS_KEY))
            ((ร c =) (ยง char_u(KEY2TERMCAP1(c))))
        )

        ;; Translate shifted special keys into unshifted keys and set modifier.
        ;; Same for CTRL and ALT modifiers.

        (when (is_special c)
            ((ร byte[] mkt =) modifier_keys_table)
            ((ร byte key0 =) (ยง KEY2TERMCAP0(c), key1 = KEY2TERMCAP1(c)))

            ((ร FOR) (ร (ยง int i = 0) (ยง mkt[i] != NUL) (ยง i += MOD_KEYS_ENTRY_SIZE))
                (when (and (== key0 (ยง mkt[i + 1])) (== key1 (ยง mkt[i + 2])))
                    ((ร modifiers |=) (ยง char_u(mkt[i])))
                    ((ร c =) (ยง TERMCAP2KEY(mkt[i + 3], mkt[i + 4])))
                    (ร BREAK)
                )
            )
        )

        ;; try to find the key in the special key table
        ((ร int table_idx =) (find_special_key_in_table c))

        ;; When not a known special key, and not a printable character, try to extract modifiers.

        (when (and (< 0 c) (== (utf_char2len c) 1))
            (when (and (< table_idx 0) (or (not (vim_isprintc c)) (== (& c 0x7f) (byte \space))) (!= (& c 0x80) NUL))
                ((ร c &=) 0x7f)
                ((ร modifiers |=) MOD_MASK_ALT)
                ;; try again, to find the un-alted key in the special key table
                ((ร table_idx =) (find_special_key_in_table c))
            )
            (when (and (< table_idx 0) (not (vim_isprintc c)) (< c (byte \space)))
                ((ร c +=) (byte \@))
                ((ร modifiers |=) MOD_MASK_CTRL)
            )
        )

        ((ร Bytes key__name =) (ยง new Bytes(MAX_KEY_NAME_LEN + 1)))
        ((ร int idx =) 0)

        (.be key__name (ยง idx++), (byte \<))

        ;; translate the modifier into a string
        ((ร FOR) (ร (ยง int i = 0) (ยง i < mod_mask_table.length && mod_mask_table[i].name != (byte \A)) (ยง i++))
            (when (ยง (modifiers & mod_mask_table[i].mod_mask) == mod_mask_table[i].mod_flag)
                (.be key__name (ยง idx++), (ยง mod_mask_table[i].name))
                (.be key__name (ยง idx++), (byte \-))
            )
        )

        (cond (< table_idx 0)          ;; unknown special key, may output t_xx
        (ยง
            (cond (is_special c)
            (ยง
                (.be key__name (ยง idx++), (byte \t))
                (.be key__name (ยง idx++), (byte \_))
                (.be key__name (ยง idx++), (KEY2TERMCAP0 c))
                (.be key__name (ยง idx++), (KEY2TERMCAP1 c))
            )
            ;; Not a special key, only modifiers, output directly.
            :else
            (ยง
                (cond (< 1 (utf_char2len c))
                (ยง
                    ((ร idx +=) (ยง utf_char2bytes(c, key__name.plus(idx))))
                )
                (vim_isprintc c)
                (ยง
                    (.be key__name (ยง idx++), c)
                )
                :else
                (ยง
                    ((ร Bytes s =) (transchar c))
                    (while (ยง s.at(0) != NUL)
                        (ยง key__name.be(idx++, (s = s.plus(1)).at(-1)))
                    )
                ))
            ))
        )
        :else                        ;; use name of special key
        (ยง
            (STRCPY (.plus key__name idx), (ยง key_names_table[table_idx].name))
            ((ร idx =) (STRLEN key__name))
        ))

        (.be key__name (ยง idx++), (byte \>))
        (.be key__name idx, NUL)

        key__name
    ))

;; Try to find key "c" in the special key table.
;; Return the index when found, -1 when not found.

(defn- #_int find_special_key_in_table [#_int c]
    (ยง
        ((ร FOR) (ร (ยง int i = 0) (ยง i < key_names_table.length) (ยง i++))
            (if (== (ยง key_names_table[i].key) c)
                ((ร RETURN) i)
            )
        )

        -1
    ))

;; VISUAL, SELECTMODE and OP_PENDING State are never set, they are equal to
;; NORMAL State with a condition.  This function returns the real State.

(defn- #_int get_real_state []
    (ยง
        (when (non-zero? (& @State NORMAL))
            (cond @VIsual_active
            (ยง
                (if @VIsual_select
                    ((ร RETURN) SELECTMODE)
                )

                ((ร RETURN) VISUAL)
            )
            @finish_op
            (ยง
                ((ร RETURN) OP_PENDING)
            ))
        )
        @State
    ))

;; Print an error message with one or two "%s" and one or two string arguments.
;; This is not in message.c to avoid a warning for prototypes.

(defn- #_boolean emsg3 [#_Bytes s, #_Bytes a1, #_Bytes a2]
    (ยง
        (if (emsg_not_now)
            ((ร RETURN) true)            ;; no error messages at the moment
        )

        (ยง vim_snprintf(@ioBuff, IOSIZE, s, a1, a2))
        (emsg @ioBuff)
    ))

;; Print an error message with one "%ld" and one long int argument.
;; This is not in message.c to avoid a warning for prototypes.

(defn- #_boolean emsgn [#_Bytes s, #_long n]
    (ยง
        (if (emsg_not_now)
            ((ร RETURN) true)            ;; no error messages at the moment
        )

        (ยง vim_snprintf(@ioBuff, IOSIZE, s, n))
        (emsg @ioBuff)
    ))

;;; ============================================================================================== VimT

;; Return true if the CursorHold event can be triggered.

(defn- #_boolean trigger_cursorhold []
    (ยง
        (when (and (not @did_cursorhold) (ยง hamis) (not @Recording) (zero? (. @typebuf tb_len)))
            ((ร int state =) (get_real_state))
            (if (or (== state NORMAL_BUSY) (non-zero? (& state INSERT)))
                ((ร RETURN) true)
            )
        )
        false
    ))

;;; ============================================================================================== VimU

;; undo.c: multi level undo facility
;;
;; The saved lines are stored in a list of lists (one for each buffer):
;;
;; b_u_oldhead------------------------------------------------+
;;                                                            |
;;                                                            V
;;                +--------------+    +--------------+    +--------------+
;; b_u_newhead--->| u_header     |    | u_header     |    | u_header     |
;;                |     uh_next------>|     uh_next------>|     uh_next---->null
;;         null<--------uh_prev  |<---------uh_prev  |<---------uh_prev  |
;;                |     uh_entry |    |     uh_entry |    |     uh_entry |
;;                +--------|-----+    +--------|-----+    +--------|-----+
;;                         |                   |                   |
;;                         V                   V                   V
;;                +--------------+    +--------------+    +--------------+
;;                | u_entry      |    | u_entry      |    | u_entry      |
;;                |     ue_next  |    |     ue_next  |    |     ue_next  |
;;                +--------|-----+    +--------|-----+    +--------|-----+
;;                         |                   |                   |
;;                         V                   V                   V
;;                +--------------+            null                null
;;                | u_entry      |
;;                |     ue_next  |
;;                +--------|-----+
;;                         |
;;                         V
;;                        etc.
;;
;; Each u_entry list contains the information for one undo or redo.
;; curbuf.b_u_curhead points to the header of the last undo (the next redo),
;; or is null if nothing has been undone (end of the branch).
;;
;; For keeping alternate undo/redo branches the uh_alt field is used.  Thus at
;; each point in the list a branch may appear for an alternate to redo.  The
;; uh_seq field is numbered sequentially to be able to find a newer or older
;; branch.
;;
;;                 +---------------+    +---------------+
;; b_u_oldhead --->| u_header      |    | u_header      |
;;                 |   uh_alt_next ---->|   uh_alt_next ----> null
;;         null <----- uh_alt_prev |<------ uh_alt_prev |
;;                 |   uh_prev     |    |   uh_prev     |
;;                 +-----|---------+    +-----|---------+
;;                       |                    |
;;                       V                    V
;;                 +---------------+    +---------------+
;;                 | u_header      |    | u_header      |
;;                 |   uh_alt_next |    |   uh_alt_next |
;; b_u_newhead --->|   uh_alt_prev |    |   uh_alt_prev |
;;                 |   uh_prev     |    |   uh_prev     |
;;                 +-----|---------+    +-----|---------+
;;                       |                    |
;;                       V                    V
;;                     null             +---------------+    +---------------+
;;                                      | u_header      |    | u_header      |
;;                                      |   uh_alt_next ---->|   uh_alt_next |
;;                                      |   uh_alt_prev |<------ uh_alt_prev |
;;                                      |   uh_prev     |    |   uh_prev     |
;;                                      +-----|---------+    +-----|---------+
;;                                            |                    |
;;                                           etc.                 etc.
;;
;; All data is allocated and will all be freed when the buffer is unloaded.

;; used in undo_end() to report number of added and deleted lines
(atom! long     u_newcount)
(atom! long     u_oldcount)

;; When 'u' flag included in 'cpoptions', we behave like vi.
;; Need to remember the action that "u" should do.

(atom! boolean  undo_undoes)

(atom! int      lastmark)

;; Save the current line for both the "u" and "U" command.
;; Returns true or false.

(defn- #_boolean u_save_cursor []
    (ยง
        (u_save (- (.. @curwin w_cursor lnum) 1), (+ (.. @curwin w_cursor lnum) 1))
    ))

;; Save the lines between "top" and "bot" for both the "u" and "U" command.
;; "top" may be 0 and bot may be curbuf.b_ml.ml_line_count + 1.
;; Returns false when lines could not be saved, true otherwise.

(defn- #_boolean u_save [#_long top, #_long bot]
    (ยง
        (if (or (< (.. @curbuf b_ml ml_line_count) top) (<= bot top) (ยง @curbuf.b_ml.ml_line_count + 1 < bot))
            ((ร RETURN) false)   ;; rely on caller to do error messages
        )

        (if (== (+ top 2) bot)
            (u_saveline (+ top 1)))

        (u_savecommon top, bot, 0, false)
    ))

;; Save the line "lnum" (used by ":s" and "~" command).
;; The line is replaced, so the new bottom line is lnum + 1.
;; Returns false when lines could not be saved, true otherwise.

(defn- #_boolean u_savesub [#_long lnum]
    (u_savecommon (- lnum 1), (+ lnum 1), (+ lnum 1), false))

;; A new line is inserted before line "lnum" (used by :s command).
;; The line is inserted, so the new bottom line is lnum + 1.
;; Returns false when lines could not be saved, true otherwise.

(defn- #_boolean u_inssub [#_long lnum]
    (u_savecommon (- lnum 1), lnum, (+ lnum 1), false))

;; Save the lines "lnum" - "lnum" + nlines (used by delete command).
;; The lines are deleted, so the new bottom line is lnum, unless the buffer becomes empty.
;; Returns false when lines could not be saved, true otherwise.

(defn- #_boolean u_savedel [#_long lnum, #_long nlines]
    (ยง
        (u_savecommon (- lnum 1), (+ lnum nlines), (if (== nlines (.. @curbuf b_ml ml_line_count)) 2 lnum), false)
    ))

;; Return true when undo is allowed.
;; Otherwise give an error message and return false.

(defn- #_boolean undo_allowed []
    (ยง
        ;; Don't allow changes in the buffer while editing the cmdline.
        ;; The caller of getcmdline() may get confused.
        (when (non-zero? @textlock)
            (emsg e_secure)
            ((ร RETURN) false)
        )

        true
    ))

;; Get the undolevle value for the current buffer.

(defn- #_long get_undolevel []
    (ยง
        @(. @curbuf b_p_ul)
    ))

;; Common code for various ways to save text before a change.
;; "top" is the line above the first changed line.
;; "bot" is the line below the last changed line.
;; "newbot" is the new bottom line.  Use zero when not known.
;; "reload" is true when saving for a buffer reload.
;; Returns false when lines could not be saved, true otherwise.

(defn- #_boolean u_savecommon [#_long top, #_long bot, #_long newbot, #_boolean reload]
    (ยง
        (when (not reload)
            ;; When making changes is not allowed, return false.
            ;; It's a crude way to make all change commands fail.
            (if (not (undo_allowed))
                ((ร RETURN) false)
            )

            (when (ยง @curbuf.b_ml.ml_line_count + 1 < bot)
                ;; This happens when the FileChangedRO autocommand changes
                ;; the file in a way it becomes shorter.
                (emsg (u8 "E881: Line count changed unexpectedly"))
                ((ร RETURN) false)
            )
        )

        ((ร long size =) (ยง bot - top - 1))

        ;; If curbuf.b_u_synced == true make a new header.

        (cond (. @curbuf b_u_synced)
        (ยง
            ;; Need to create new entry in b_changelist.
            ((ร @curbuf.b_new_change =) true)

            (ร u_header_C uhp)
            (if (<= 0 (get_undolevel))
                ((ร uhp =) (ยง ยง_u_header_C()))
                ((ร uhp =) null)
            )

            ;; If we undid more than we redid, move the entry lists before
            ;; and including curbuf.b_u_curhead to an alternate branch.

; %%        ((ร u_header_C[] old_curhead =) (ยง { @curbuf.b_u_curhead }))
            (when (!= (ยง old_curhead[0]) null)
                ((ร @curbuf.b_u_newhead =) (ยง old_curhead[0].uh_next.ptr))
                ((ร @curbuf.b_u_curhead =) null)
            )

            ;; free headers to keep the size right

            (while (ยง get_undolevel() < @curbuf.b_u_numhead && @curbuf.b_u_oldhead != null)
                ((ร u_header_C uhfree =) (. @curbuf b_u_oldhead))

                (cond (== uhfree (ยง old_curhead[0]))
                (ยง
                    ;; Can't reconnect the branch, delete all of it.
                    (u_freebranch @curbuf, uhfree, old_curhead)
                )
                (nil? (.. uhfree uh_alt_next ptr))
                (ยง
                    ;; There is no branch, only free one header.
                    (u_freeheader @curbuf, uhfree, old_curhead)
                )
                :else
                (ยง
                    ;; Free the oldest alternate branch as a whole.
                    (while (ยง uhfree.uh_alt_next.ptr != null)
                        ((ร uhfree =) (.. uhfree uh_alt_next ptr))
                    )
                    (u_freebranch @curbuf, uhfree, old_curhead)
                ))
            )

            (when (nil? uhp)                ;; no undo at all
                (if (!= (ยง old_curhead[0]) null)
                    (u_freebranch @curbuf, (ยง old_curhead[0]), null))
                ((ร @curbuf.b_u_synced =) false)
                ((ร RETURN) true)
            )

            ((ร uhp.uh_prev.ptr =) null)
            ((ร uhp.uh_next.ptr =) (. @curbuf b_u_newhead))
            ((ร uhp.uh_alt_next.ptr =) (ยง old_curhead[0]))
            (cond (!= (ยง old_curhead[0]) null)
            (ยง
                ((ร uhp.uh_alt_prev.ptr =) (ยง old_curhead[0].uh_alt_prev.ptr))
                (if (!= (.. uhp uh_alt_prev ptr) null)
                    ((ร uhp.uh_alt_prev.ptr.uh_alt_next.ptr =) uhp)
                )
                ((ร old_curhead[0].uh_alt_prev.ptr =) uhp)
                (if (== (. @curbuf b_u_oldhead) (ยง old_curhead[0]))
                    ((ร @curbuf.b_u_oldhead =) uhp)
                )
            )
            :else
            (ยง
                ((ร uhp.uh_alt_prev.ptr =) null)
            ))
            (if (!= (. @curbuf b_u_newhead) null)
                ((ร @curbuf.b_u_newhead.uh_prev.ptr =) uhp)
            )

            ((ร uhp.uh_seq =) (ยง ++@curbuf.b_u_seq_last))
            ((ร @curbuf.b_u_seq_cur =) (. uhp uh_seq))
            ((ร uhp.uh_time =) (ยง libC._time()))
            ((ร @curbuf.b_u_time_cur =) (ยง uhp.uh_time + 1))

            ((ร uhp.uh_walk =) 0)
            ((ร uhp.uh_entry =) null)
            ((ร uhp.uh_getbot_entry =) null)
            (COPY_pos (. uhp uh_cursor), (. @curwin w_cursor)) ;; save cursor pos. for undo
            (if (and (virtual_active) (< 0 (.. @curwin w_cursor coladd)))
                ((ร uhp.uh_cursor_vcol =) (getviscol))
                ((ร uhp.uh_cursor_vcol =) -1)
            )

            ;; save changed and buffer empty flag for undo
            ((ร uhp.uh_flags =) (+ (if @(. @curbuf b_changed) UH_CHANGED 0) (if (!= (& (.. @curbuf b_ml ml_flags) ML_EMPTY) 0) UH_EMPTYBUF 0)))

            ;; save named marks and Visual marks for undo
            ((ร FOR) (ร (ยง int i = 0) (< i NMARKS) (ยง i++))
                (COPY_pos (ยง uhp.uh_namedm[i]), (ยง @curbuf.b_namedm[i]))
            )
            (COPY_visualinfo (. uhp uh_visual), (. @curbuf b_visual))

            ((ร @curbuf.b_u_newhead =) uhp)
            (if (nil? (. @curbuf b_u_oldhead))
                ((ร @curbuf.b_u_oldhead =) uhp)
            )
            (ยง @curbuf.b_u_numhead++)
        )
        :else
        (ยง
            (if (< (get_undolevel) 0)        ;; no undo at all
                ((ร RETURN) true)
            )

            ;; When saving a single line, and it has been saved just before, it
            ;; doesn't make sense saving it again.  Saves a lot of memory when
            ;; making lots of changes inside the same line.
            ;; This is only possible if the previous change didn't increase or
            ;; decrease the number of lines.
            ;; Check the ten last changes.  More doesn't make sense and takes too long.

            (when (== size 1)
                ((ร u_entry_C uep =) (u_get_headentry))
                ((ร u_entry_C prev_uep =) null)
                ((ร FOR) (ร (ยง int i = 0) (< i 10) (ยง i++))
                    (if (nil? uep)
                        (ร BREAK)
                    )

                    ;; If lines have been inserted/deleted we give up.
                    ;; Also when the line was included in a multi-line save.
                    (if (or (if (!= (.. @curbuf b_u_newhead uh_getbot_entry) uep) (!= (+ (. uep ue_top) (. uep ue_size) 1) (if (== (. uep ue_bot) 0) (+ (.. @curbuf b_ml ml_line_count) 1) (. uep ue_bot))) (!= (. uep ue_lcount) (.. @curbuf b_ml ml_line_count))) (and (< 1 (. uep ue_size)) (<= (. uep ue_top) top) (<= (+ top 2) (+ (. uep ue_top) (. uep ue_size) 1))))
                        (ร BREAK)
                    )

                    ;; If it's the same line we can skip saving it again.
                    (when (and (== (. uep ue_size) 1) (== (. uep ue_top) top))
                        (when (< 0 i)
                            ;; It's not the last entry: get ue_bot for the last entry now.
                            ;; Following deleted/inserted lines go to the re-used entry.
                            (u_getbot)
                            ((ร @curbuf.b_u_synced =) false)

                            ;; Move the found entry to become the last entry.
                            ;; The order of undo/redo doesn't matter for the entries we move it over,
                            ;; since they don't change the line count and don't include this line.
                            ;; It does matter for the found entry if the line count is changed
                            ;; by the executed command.
                            ((ร prev_uep.ue_next =) (. uep ue_next))
                            ((ร uep.ue_next =) (.. @curbuf b_u_newhead uh_entry))
                            ((ร @curbuf.b_u_newhead.uh_entry =) uep)
                        )

                        ;; The executed command may change the line count.
                        (cond (non-zero? newbot)
                        (ยง
                            ((ร uep.ue_bot =) newbot)
                        )
                        (< (.. @curbuf b_ml ml_line_count) bot)
                        (ยง
                            ((ร uep.ue_bot =) 0)
                        )
                        :else
                        (ยง
                            ((ร uep.ue_lcount =) (.. @curbuf b_ml ml_line_count))
                            ((ร @curbuf.b_u_newhead.uh_getbot_entry =) uep)
                        ))
                        ((ร RETURN) true)
                    )
                    ((ร prev_uep =) uep)
                    ((ร uep =) (. uep ue_next))
                )
            )

            ;; find line number for ue_bot for previous u_save()
            (u_getbot)
        ))

        ;; add lines in front of entry list

        ((ร u_entry_C uep =) (ยง ยง_u_entry_C()))

        ((ร uep.ue_size =) size)
        ((ร uep.ue_top =) top)
        (cond (non-zero? newbot)
        (ยง
            ((ร uep.ue_bot =) newbot)
        )

        ;; Use 0 for ue_bot if bot is below last line.
        ;; Otherwise we have to compute ue_bot later.

        (< (.. @curbuf b_ml ml_line_count) bot)
        (ยง
            ((ร uep.ue_bot =) 0)
        )
        :else
        (ยง
            ((ร uep.ue_lcount =) (.. @curbuf b_ml ml_line_count))
            ((ร @curbuf.b_u_newhead.uh_getbot_entry =) uep)
        ))

        (cond (< 0 size)
        (ยง
            ((ร uep.ue_array =) (ยง new Bytes[(int)size]))
            ((ร long lnum =) (+ top 1))
            ((ร FOR) (ร (ยง int i = 0) (< i size) (ยง i++))
                (fast_breakcheck)
                (if @got_int
                    ((ร RETURN) false)
                )
                ((ร uep.ue_array[i] =) (ยง STRDUP(ml_get(lnum++))))
            )
        )
        :else
        (ยง
            ((ร uep.ue_array =) null)
        ))
        ((ร uep.ue_next =) (.. @curbuf b_u_newhead uh_entry))
        ((ร @curbuf.b_u_newhead.uh_entry =) uep)
        ((ร @curbuf.b_u_synced =) false)
        (reset! undo_undoes false)

        true
    ))

;; If 'cpoptions' contains 'u': Undo the previous undo or redo (vi compatible).
;; If 'cpoptions' does not contain 'u': Always undo.

(defn- #_void u_undo [#_int count]
    (ยง
        ;; If we get an undo command while executing a macro, we behave like the original vi.
        ;; If this happens twice in one macro the result will not be compatible.

        (when (not (. @curbuf b_u_synced))
            (u_sync true)
            ((ร count =) 1)
        )

        (if (nil? (vim_strbyte @p_cpo, CPO_UNDO))
            (reset! undo_undoes true)
            (reset! undo_undoes (not @undo_undoes)))

        (u_doit count)
    ))

;; If 'cpoptions' contains 'u': Repeat the previous undo or redo.
;; If 'cpoptions' does not contain 'u': Always redo.

(defn- #_void u_redo [#_int count]
    (ยง
        (if (nil? (vim_strbyte @p_cpo, CPO_UNDO))
            (reset! undo_undoes false))

        (u_doit count)
    ))

;; Undo or redo, depending on 'undo_undoes', 'count' times.

(defn- #_void u_doit [#_int startcount]
    (ยง
        (if (not (undo_allowed))
            (ร RETURN)
        )

        (reset! u_newcount 0)
        (reset! u_oldcount 0)
        (if (non-zero? (& (.. @curbuf b_ml ml_flags) ML_EMPTY))
            (reset! u_oldcount -1))

        ((ร FOR) (ร (ยง int count = startcount) (ยง 0 < count--) nil)
            (cond @undo_undoes
            (ยง
                (cond (nil? (. @curbuf b_u_curhead))             ;; first undo
                (ยง
                    ((ร @curbuf.b_u_curhead =) (. @curbuf b_u_newhead))
                )
                (< 0 (get_undolevel))               ;; multi level undo
                (ยง
                    ;; get next undo
                    ((ร @curbuf.b_u_curhead =) (.. @curbuf b_u_curhead uh_next ptr))
                ))
                ;; nothing to undo
                (when (or (zero? (. @curbuf b_u_numhead)) (nil? (. @curbuf b_u_curhead)))
                    ;; stick curbuf.b_u_curhead at end
                    ((ร @curbuf.b_u_curhead =) (. @curbuf b_u_oldhead))
                    (beep_flush)
                    (when (== count (- startcount 1))
                        (msg (u8 "Already at oldest change"))
                        (ร RETURN)
                    )
                    (ร BREAK)
                )

                (u_undoredo true)
            )
            :else
            (ยง
                (when (or (nil? (. @curbuf b_u_curhead)) (<= (get_undolevel) 0))
                    (beep_flush)   ;; nothing to redo
                    (when (== count (- startcount 1))
                        (msg (u8 "Already at newest change"))
                        (ร RETURN)
                    )
                    (ร BREAK)
                )

                (u_undoredo false)

                ;; Advance for next redo.
                ;; Set "newhead" when at the end of the redoable changes.
                (if (nil? (.. @curbuf b_u_curhead uh_prev ptr))
                    ((ร @curbuf.b_u_newhead =) (. @curbuf b_u_curhead))
                )
                ((ร @curbuf.b_u_curhead =) (.. @curbuf b_u_curhead uh_prev ptr))
            ))
        )

        (u_undo_end @undo_undoes, false)
    ))

;; Undo or redo over the timeline.
;; When "step" is negative go back in time, otherwise goes forward in time.
;; When "sec" is false make "step" steps, when "sec" is true use "step" as seconds.
;; When "absolute" is true use "step" as the sequence number to jump to.
;; "sec" must be false then.

(defn- #_void undo_time [#_long step, #_boolean sec, #_boolean absolute]
    (ยง
        ((ร boolean dosec =) sec)
        ((ร boolean above =) false)
        ((ร boolean did_undo =) true)

        ;; First make sure the current undoable change is synced.
        (if (not (. @curbuf b_u_synced))
            (u_sync true))

        (reset! u_newcount 0)
        (reset! u_oldcount 0)
        (if (non-zero? (& (.. @curbuf b_ml ml_flags) ML_EMPTY))
            (reset! u_oldcount -1))

;       u_header_C uhp = null;	// %% anno dunno

        (ร long target)
        (ร long closest)
        ;; "target" is the node below which we want to be.
        ;; Init "closest" to a value we can't reach.
        (cond absolute
        (ยง
            ((ร target =) step)
            ((ร closest =) -1)
        )
        :else
        (ยง
            ;; When doing computations with time_t subtract starttime, because
            ;; time_t converted to a long may result in a wrong number.
            (if dosec
                ((ร target =) (ยง @curbuf.b_u_time_cur - @starttime + step))
                ((ร target =) (ยง @curbuf.b_u_seq_cur + step))
            )
            (cond (< step 0)
            (ยง
                (if (< target 0)
                    ((ร target =) 0)
                )
                ((ร closest =) -1)
            )
            :else
            (ยง
                (if dosec
                    ((ร closest =) (ยง libC._time() - @starttime + 1))
                    ((ร closest =) (ยง @curbuf.b_u_seq_last + 2))
                )
                (if (<= closest target)
                    ((ร target =) (- closest 1))
                )
            ))
        ))
        ((ร long closest_start =) closest)
        ((ร long closest_seq =) (. @curbuf b_u_seq_cur))

;       int mark = 0, nomark = 0;	// %% anno dunno

        ;; May do this twice:
        ;; 1. Search for "target", update "closest" to the best match found.
        ;; 2. If "target" not found search for "closest".
        ;;
        ;; When using the closest time we use the sequence number in the second
        ;; round, because there may be several entries with the same time.

        ((ร FOR) (ร (ยง int round = 1) (<= round 2) (ยง round++))
            ;; Find the path from the current state to where we want to go.  The
            ;; desired state can be anywhere in the undo tree, need to go all over
            ;; it.  We put "nomark" in uh_walk where we have been without success,
            ;; "mark" where it could possibly be.
            ((ร mark =) (ยง ++@lastmark))
            ((ร nomark =) (ยง ++@lastmark))

            (if (nil? (. @curbuf b_u_curhead))     ;; at leaf of the tree
                ((ร uhp =) (. @curbuf b_u_newhead))
                ((ร uhp =) (. @curbuf b_u_curhead))
            )

            (while (!= uhp null)
                ((ร uhp.uh_walk =) mark)
                (ร long val)
                (if dosec
                    ((ร val =) (ยง uhp.uh_time - @starttime))
                    ((ร val =) (. uhp uh_seq))
                )

                (when (== round 1)
                    ;; Remember the header that is closest to the target.
                    ;; It must be at least in the right direction (checked with "b_u_seq_cur").
                    ;; When the timestamp is equal find the highest/lowest sequence number.
                    (when (and (if (< step 0) (<= (. uhp uh_seq) (. @curbuf b_u_seq_cur)) (> (. uhp uh_seq) (. @curbuf b_u_seq_cur))) (if (and dosec (== val closest)) (if (< step 0) (< (. uhp uh_seq) closest_seq) (> (. uhp uh_seq) closest_seq)) (or (== closest closest_start) (if (< target val) (if (< target closest) (<= (- val target) (- closest target)) (<= (- val target) (- target closest))) (if (< target closest) (<= (- target val) (- closest target)) (<= (- target val) (- target closest)))))))
                        ((ร closest =) val)
                        ((ร closest_seq =) (. uhp uh_seq))
                    )
                )

                ;; Quit searching when we found a match.  But when searching for a time,
                ;; we need to continue looking for the best uh_seq.
                (when (and (== target val) (not dosec))
                    ((ร target =) (. uhp uh_seq))
                    (ร BREAK)
                )

                ;; go down in the tree if we haven't been there
                (cond (and (!= (.. uhp uh_prev ptr) null) (!= (.. uhp uh_prev ptr uh_walk) nomark) (!= (.. uhp uh_prev ptr uh_walk) mark))
                (ยง
                    ((ร uhp =) (.. uhp uh_prev ptr))
                )
                ;; go to alternate branch if we haven't been there
                (and (!= (.. uhp uh_alt_next ptr) null) (!= (.. uhp uh_alt_next ptr uh_walk) nomark) (!= (.. uhp uh_alt_next ptr uh_walk) mark))
                (ยง
                    ((ร uhp =) (.. uhp uh_alt_next ptr))
                )
                ;; go up in the tree if we haven't been there and we are at the start of alternate branches
                (and (!= (.. uhp uh_next ptr) null) (nil? (.. uhp uh_alt_prev ptr)) (!= (.. uhp uh_next ptr uh_walk) nomark) (!= (.. uhp uh_next ptr uh_walk) mark))
                (ยง
                    ;; If still at the start we don't go through this change.
                    (if (== uhp (. @curbuf b_u_curhead))
                        ((ร uhp.uh_walk =) nomark)
                    )
                    ((ร uhp =) (.. uhp uh_next ptr))
                )
                :else
                (ยง
                    ;; need to backtrack; mark this node as useless
                    ((ร uhp.uh_walk =) nomark)
                    (if (!= (.. uhp uh_alt_prev ptr) null)
                        ((ร uhp =) (.. uhp uh_alt_prev ptr))
                        ((ร uhp =) (.. uhp uh_next ptr))
                    )
                ))
            )

            (if (non-nil? uhp)    ;; found it
                (ร BREAK)
            )

            (when absolute
                (emsgn (u8 "E830: Undo number %ld not found"), step)
                (ร RETURN)
            )

            (when (== closest closest_start)
                (if (< step 0)
                    (msg (u8 "Already at oldest change"))
                    (msg (u8 "Already at newest change")))
                (ร RETURN)
            )

            ((ร target =) closest_seq)
            ((ร dosec =) false)
            (if (< step 0)
                ((ร above =) true)       ;; stop above the header
            )
        )

        ;; If we found it: Follow the path to go to where we want to be.
        (when (non-nil? uhp)
            ;; First go up the tree as much as needed.

            (while (ยง !@got_int)
                ((ร uhp =) (. @curbuf b_u_curhead))
                (if (nil? uhp)
                    ((ร uhp =) (. @curbuf b_u_newhead))
                    ((ร uhp =) (.. uhp uh_next ptr))
                )
                (if (or (nil? uhp) (!= (. uhp uh_walk) mark) (and (== (. uhp uh_seq) target) (not above)))
                    (ร BREAK)
                )
                ((ร @curbuf.b_u_curhead =) uhp)
                (u_undoredo true)
                ((ร uhp.uh_walk =) nomark)   ;; don't go back down here
            )

            ;; And now go down the tree (redo), branching off where needed.

            (while (ยง !@got_int)
                ((ร uhp =) (. @curbuf b_u_curhead))
                (if (nil? uhp)
                    (ร BREAK)
                )

                ;; Go back to the first branch with a mark.
                (while (ยง uhp.uh_alt_prev.ptr != null && uhp.uh_alt_prev.ptr.uh_walk == mark)
                    ((ร uhp =) (.. uhp uh_alt_prev ptr))
                )

                ;; Find the last branch with a mark, that's the one.
                ((ร u_header_C last =) uhp)
                (while (ยง last.uh_alt_next.ptr != null && last.uh_alt_next.ptr.uh_walk == mark)
                    ((ร last =) (.. last uh_alt_next ptr))
                )
                (when (!= last uhp)
                    ;; Make the used branch the first entry in the list of
                    ;; alternatives to make "u" and CTRL-R take this branch.
                    (while (ยง uhp.uh_alt_prev.ptr != null)
                        ((ร uhp =) (.. uhp uh_alt_prev ptr))
                    )
                    (if (!= (.. last uh_alt_next ptr) null)
                        ((ร last.uh_alt_next.ptr.uh_alt_prev.ptr =) (.. last uh_alt_prev ptr))
                    )
                    ((ร last.uh_alt_prev.ptr.uh_alt_next.ptr =) (.. last uh_alt_next ptr))
                    ((ร last.uh_alt_prev.ptr =) null)
                    ((ร last.uh_alt_next.ptr =) uhp)
                    ((ร uhp.uh_alt_prev.ptr =) last)

                    (if (== (. @curbuf b_u_oldhead) uhp)
                        ((ร @curbuf.b_u_oldhead =) last)
                    )
                    ((ร uhp =) last)
                    (if (!= (.. uhp uh_next ptr) null)
                        ((ร uhp.uh_next.ptr.uh_prev.ptr =) uhp)
                    )
                )
                ((ร @curbuf.b_u_curhead =) uhp)

                (if (!= (. uhp uh_walk) mark)
                    (ร BREAK)      ;; must have reached the target
                )

                ;; Stop when going backwards in time and didn't find
                ;; the exact header we were looking for.
                (when (and (== (. uhp uh_seq) target) above)
                    ((ร @curbuf.b_u_seq_cur =) (- target 1))
                    (ร BREAK)
                )

                (u_undoredo false)

                ;; Advance "curhead" to below the header we last used.
                ;; If it becomes null, then we need to set "newhead" to this leaf.
                (if (nil? (.. uhp uh_prev ptr))
                    ((ร @curbuf.b_u_newhead =) uhp)
                )
                ((ร @curbuf.b_u_curhead =) (.. uhp uh_prev ptr))
                ((ร did_undo =) false)

                (if (== (. uhp uh_seq) target)   ;; found it!
                    (ร BREAK)
                )

                ((ร uhp =) (.. uhp uh_prev ptr))
                (when (or (nil? uhp) (!= (. uhp uh_walk) mark))
                    ;; Need to redo more but can't find it...
                    (emsg2 e_intern2, (u8 "undo_time()"))
                    (ร BREAK)
                )
            )
        )

        (u_undo_end did_undo, absolute)
    ))

;; u_undoredo: common code for undo and redo
;;
;; The lines in the file are replaced by the lines in the entry list at
;; curbuf.b_u_curhead.  The replaced lines in the file are saved in the entry
;; list for the next undo/redo.
;;
;; When "undo" is true we go up in the tree, when false we go down.

(defn- #_void u_undoredo [#_boolean undo]
    (ยง
        ((ร Bytes[] newarray =) null)
        ((ร long newlnum =) MAXLNUM)
        ((ร u_entry_C newlist =) null)
        ((ร u_header_C curhead =) (. @curbuf b_u_curhead))

        ((ร int old_flags =) (. curhead uh_flags))
        ((ร int new_flags =) (+ (if @(. @curbuf b_changed) UH_CHANGED 0) (if (!= (& (.. @curbuf b_ml ml_flags) ML_EMPTY) 0) UH_EMPTYBUF 0)))
        (setpcmark)

        ;; save marks before undo/redo

        ((ร pos_C[] namedm =) (ARRAY_pos NMARKS))
        ((ร FOR) (ร (ยง int i = 0) (< i NMARKS) (ยง i++))
            (COPY_pos (ยง namedm[i]), (ยง @curbuf.b_namedm[i]))
        )

        ((ร visualinfo_C visualinfo =) (ยง ยง_visualinfo_C()))
        (COPY_visualinfo visualinfo, (. @curbuf b_visual))

        ((ร @curbuf.b_op_start.lnum =) (.. @curbuf b_ml ml_line_count))
        ((ร @curbuf.b_op_start.col =) 0)
        ((ร @curbuf.b_op_end.lnum =) 0)
        ((ร @curbuf.b_op_end.col =) 0)

        ((ร FOR) (ร (ยง u_entry_C uep = curhead.uh_entry, nuep) (!= uep null) (ยง uep = nuep))
            ((ร long top =) (. uep ue_top))
            ((ร long bot =) (. uep ue_bot))
            (if (zero? bot)
                ((ร bot =) (ยง @curbuf.b_ml.ml_line_count + 1))
            )
            (when (or (> top (.. @curbuf b_ml ml_line_count)) (<= bot top) (> bot (+ (.. @curbuf b_ml ml_line_count) 1)))
                (emsg (u8 "E438: u_undo: line numbers wrong"))
                (changed)          ;; don't want UNCHANGED now
                (ร RETURN)
            )

            ((ร int oldsize =) (ยง (int)(bot - top - 1)))       ;; number of lines before undo
            ((ร int newsize =) (ยง (int)uep.ue_size))         ;; number of lines after undo

            (when (< top newlnum)
                ;; If the saved cursor is somewhere in this undo block,
                ;; move it to the remembered position.
                ;; Makes "gwap" put the cursor back where it was.
                ((ร long lnum =) (.. curhead uh_cursor lnum))
                (cond (and (<= top lnum) (<= lnum (ยง top + newsize + 1)))
                (ยง
                    (COPY_pos (. @curwin w_cursor), (. curhead uh_cursor))
                    ((ร newlnum =) (ยง @curwin.w_cursor.lnum - 1))
                )
                :else
                (ยง
                    ;; Use the first line that actually changed.
                    ;; Avoids that undoing auto-formatting puts the cursor in the previous line.
                    (ร int i)
                    ((ร FOR) (ร (ยง i = 0) (ยง i < newsize && i < oldsize) (ยง i++))
                        (if (non-zero? (ยง STRCMP(uep.ue_array[i], ml_get(top + 1 + i))))
                            (ร BREAK)
                        )
                    )
                    (cond (and (== i newsize) (== newlnum MAXLNUM) (nil? (. uep ue_next)))
                    (ยง
                        ((ร newlnum =) top)
                        ((ร @curwin.w_cursor.lnum =) (+ newlnum 1))
                    )
                    (< i newsize)
                    (ยง
                        ((ร newlnum =) (+ top i))
                        ((ร @curwin.w_cursor.lnum =) (+ newlnum 1))
                    ))
                ))
            )

            ((ร boolean empty_buffer =) false)   ;; buffer became empty

            ;; delete the lines between top and bot and save them in "newarray"
            (cond (< 0 oldsize)
            (ยง
                ((ร newarray =) (ยง new Bytes[oldsize]))

                ;; delete backwards, it goes faster in most cases
                ((ร long lnum =) (- bot 1))
                ((ร FOR) (ร (ยง int i = oldsize) (ยง 0 < i--) (ยง lnum--))
                    ((ร newarray[i] =) (ยง STRDUP(ml_get(lnum))))
                    ;; remember we deleted the last line in the buffer,
                    ;; and a dummy empty line will be inserted
                    (if (== (.. @curbuf b_ml ml_line_count) 1)
                        ((ร empty_buffer =) true)
                    )
                    (ml_delete lnum, false)
                )
            )
            :else
            (ยง
                ((ร newarray =) null)
            ))

            ;; insert the lines in u_array between top and bot
            ((ร long lnum =) top)
            ((ร FOR) (ร (ยง int i = 0) (< i newsize) (ยง i++, lnum++))
                ;; If the file is empty, there is an empty line 1 that we
                ;; should get rid of, by replacing it with the new line.

                (if (and empty_buffer (zero? lnum))
                    (ml_replace 1, (ยง uep.ue_array[i]))
                    (ml_append lnum, (ยง uep.ue_array[i])))
            )

            ;; adjust marks
            (when (!= oldsize newsize)
                (mark_adjust (+ top 1), (+ top oldsize), MAXLNUM, (- newsize oldsize))
                (if (> (.. @curbuf b_op_start lnum) (+ top oldsize))
                    ((ร @curbuf.b_op_start.lnum +=) (- newsize oldsize))
                )
                (if (> (.. @curbuf b_op_end lnum) (+ top oldsize))
                    ((ร @curbuf.b_op_end.lnum +=) (- newsize oldsize))
                )
            )

            (changed_lines (+ top 1), 0, bot, (- newsize oldsize))

            ;; set '[ and '] mark
            (if (ยง top + 1 < @curbuf.b_op_start.lnum)
                ((ร @curbuf.b_op_start.lnum =) (+ top 1))
            )
            (cond (and (zero? newsize) (< (.. @curbuf b_op_end lnum) (+ top 1)))
            (ยง
                ((ร @curbuf.b_op_end.lnum =) (+ top 1))
            )
            (< (.. @curbuf b_op_end lnum) (+ top newsize))
            (ยง
                ((ร @curbuf.b_op_end.lnum =) (+ top newsize))
            ))

            ((ร @u_newcount +=) newsize)
            ((ร @u_oldcount +=) oldsize)
            ((ร uep.ue_size =) oldsize)
            ((ร uep.ue_array =) newarray)
            ((ร uep.ue_bot =) (ยง top + newsize + 1))

            ;; insert this entry in front of the new entry list

            ((ร nuep =) (. uep ue_next))
            ((ร uep.ue_next =) newlist)
            ((ร newlist =) uep)
        )

        ((ร curhead.uh_entry =) newlist)
        ((ร curhead.uh_flags =) new_flags)
        (if (and (non-zero? (& old_flags UH_EMPTYBUF)) (bufempty))
            ((ร @curbuf.b_ml.ml_flags |=) ML_EMPTY)
        )
        (if (non-zero? (& old_flags UH_CHANGED))
            (changed)
            (unchanged @curbuf))

        ;; restore marks from before undo/redo

        ((ร FOR) (ร (ยง int i = 0) (< i NMARKS) (ยง i++))
            (if (!= (ยง curhead.uh_namedm[i].lnum) 0)
                (COPY_pos (ยง @curbuf.b_namedm[i]), (ยง curhead.uh_namedm[i])))
            (if (!= (ยง namedm[i].lnum) 0)
                (COPY_pos (ยง curhead.uh_namedm[i]), (ยง namedm[i]))
                ((ร curhead.uh_namedm[i].lnum =) 0)
            )
        )
        (when (!= (.. curhead uh_visual vi_start lnum) 0)
            (COPY_visualinfo (. @curbuf b_visual), (. curhead uh_visual))
            (COPY_visualinfo (. curhead uh_visual), visualinfo)
        )

        ;; If the cursor is only off by one line,
        ;; put it at the same position as before starting the change (for the "o" command).
        ;; Otherwise the cursor should go to the first undone line.

        (if (and (ยง curhead.uh_cursor.lnum + 1 == @curwin.w_cursor.lnum) (< 1 (.. @curwin w_cursor lnum)))
            (ยง --@curwin.w_cursor.lnum)
        )
        (cond (<= (.. @curwin w_cursor lnum) (.. @curbuf b_ml ml_line_count))
        (ยง
            (cond (== (.. curhead uh_cursor lnum) (.. @curwin w_cursor lnum))
            (ยง
                ((ร @curwin.w_cursor.col =) (.. curhead uh_cursor col))
                (if (and (virtual_active) (<= 0 (. curhead uh_cursor_vcol)))
                    (coladvance (int (. curhead uh_cursor_vcol)))
                    ((ร @curwin.w_cursor.coladd =) 0)
                )
            )
            :else
            (ยง
                (beginline (| BL_SOL BL_FIX))
            ))
        )
        :else
        (ยง
            ;; We get here with the current cursor line being past the end (eg
            ;; after adding lines at the end of the file, and then undoing it).
            ;; check_cursor() will move the cursor to the last line.  Move it to
            ;; the first column here.
            ((ร @curwin.w_cursor.col =) 0)
            ((ร @curwin.w_cursor.coladd =) 0)
        ))

        ;; Make sure the cursor is on an existing line and column.
        (check_cursor)

        ;; Remember where we are for "g-" and ":earlier 10s".
        ((ร @curbuf.b_u_seq_cur =) (. curhead uh_seq))
        (when undo
            ;; We are below the previous undo.  However, to make ":earlier 1s"
            ;; work we compute this as being just above the just undone change.
            (ยง --@curbuf.b_u_seq_cur)
        )

        ;; The timestamp can be the same for multiple changes,
        ;; just use the one of the undone/redone change.
        ((ร @curbuf.b_u_time_cur =) (. curhead uh_time))
    ))

;; If we deleted or added lines, report the number of less/more lines.
;; Otherwise, report the number of changes
;; (this may be incorrect in some cases, but it's better than nothing).

(defn- #_void u_undo_end [#_boolean did_undo, #_boolean absolute]
    ;; did_undo: just did an undo
    ;; absolute: used ":undo N"
    (ยง
        (if (not (messaging))        ;; 'lazyredraw' set, don't do messages now
            (ร RETURN)
        )

        (if (non-zero? (& (.. @curbuf b_ml ml_flags) ML_EMPTY))
            (swap! u_newcount dec))

        ((ร @u_oldcount -=) @u_newcount)

        (ร Bytes msgstr)
        (cond (== @u_oldcount -1)
        (ยง
            ((ร msgstr =) (u8 "more line"))
        )
        (< @u_oldcount 0)
        (ยง
            ((ร msgstr =) (u8 "more lines"))
        )
        (== @u_oldcount 1)
        (ยง
            ((ร msgstr =) (u8 "line less"))
        )
        (< 1 @u_oldcount)
        (ยง
            ((ร msgstr =) (u8 "fewer lines"))
        )
        :else
        (ยง
            (reset! u_oldcount @u_newcount)

            (if (== @u_newcount 1)
                ((ร msgstr =) (u8 "change"))
                ((ร msgstr =) (u8 "changes"))
            )
        ))

        (ร u_header_C uhp)
        (cond (!= (. @curbuf b_u_curhead) null)
        (ยง
            ;; For ":undo N" we prefer a "after #N" message.
            (cond (and absolute (!= (.. @curbuf b_u_curhead uh_next ptr) null))
            (ยง
                ((ร uhp =) (.. @curbuf b_u_curhead uh_next ptr))
                ((ร did_undo =) false)
            )
            did_undo
            (ยง
                ((ร uhp =) (. @curbuf b_u_curhead))
            )
            :else
            (ยง
                ((ร uhp =) (.. @curbuf b_u_curhead uh_next ptr))
            ))
        )
        :else
        (ยง
            ((ร uhp =) (. @curbuf b_u_newhead))
        ))

        ((ร Bytes msgbuf =) (ยง new Bytes(80)))
        (if (nil? uhp)
            (.be msgbuf 0, NUL)
            (u_add_time msgbuf, (ยง msgbuf.size()), (. uhp uh_time)))

        ((ร FOR) (ร (ยง window_C wp = @firstwin) (!= wp null) (ยง wp = wp.w_next))
            (if (< 0 @(.. wp w_options wo_cole))
                (redraw_win_later wp, NOT_VALID))
        )

        (smsg (u8 "%ld %s; %s #%ld  %s"), (if (< @u_oldcount 0) (- @u_oldcount) @u_oldcount), msgstr, (if did_undo (u8 "before") (u8 "after")), (if (== uhp null) 0 (. uhp uh_seq)), msgbuf)
    ))

;; u_sync: stop adding to the current entry list

(defn- #_void u_sync [#_boolean force]
    ;; force: Also sync when no_u_sync is set.
    (ยง
        ;; Skip it when already synced or syncing is disabled.
        (if (or (. @curbuf b_u_synced) (and (not force) (< 0 @no_u_sync)))
            (ร RETURN)
        )

        (cond (< (get_undolevel) 0)
        (ยง
            ((ร @curbuf.b_u_synced =) true)   ;; no entries, nothing to do
        )
        :else
        (ยง
            (u_getbot)                 ;; compute ue_bot of previous u_save()
            ((ร @curbuf.b_u_curhead =) null)
        ))
    ))

;; Put the timestamp of an undo header in "buf[buflen]" in a nice format.

(defn- #_void u_add_time [#_Bytes buf, #_int buflen, #_long seconds]
    (ยง
        (cond (<= 100 (ยง libC._time() - seconds))
        (ยง
            ((ร tm_C curtime =) (ยง libC._localtime(seconds)))
            (cond (ยง libC._time() - seconds < (60 * 60 * 12))
            (ยง
                ;; within 12 hours
                (ยง libC.strftime(buf, buflen, (u8 "%H:%M:%S"), curtime))
            )
            :else
            (ยง
                ;; longer ago
                (ยง libC.strftime(buf, buflen, (u8 "%Y/%m/%d %H:%M:%S"), curtime))
            ))
        )
        :else
        (ยง
            (ยง vim_snprintf(buf, buflen, (u8 "%ld seconds ago"), libC._time() - seconds))
        ))
    ))

;; Get pointer to last added entry.
;; If it's not valid, give an error message and return null.

(defn- #_u_entry_C u_get_headentry []
    (ยง
        (when (or (nil? (. @curbuf b_u_newhead)) (nil? (.. @curbuf b_u_newhead uh_entry)))
            (emsg (u8 "E439: undo list corrupt"))
            ((ร RETURN) null)
        )
        (.. @curbuf b_u_newhead uh_entry)
    ))

;; u_getbot(): compute the line number of the previous u_save()
;;              It is called only when b_u_synced is false.

(defn- #_void u_getbot []
    (ยง
        ((ร u_entry_C uep =) (u_get_headentry)) ;; check for corrupt undo list
        (if (nil? uep)
            (ร RETURN)
        )

        ((ร uep =) (.. @curbuf b_u_newhead uh_getbot_entry))
        (when (non-nil? uep)
            ;; the new ue_bot is computed from the number of lines that has been
            ;; inserted (0 - deleted) since calling u_save().  This is equal to the
            ;; old line count subtracted from the current line count.

            ((ร long extra =) (ยง @curbuf.b_ml.ml_line_count - uep.ue_lcount))
            ((ร uep.ue_bot =) (ยง uep.ue_top + uep.ue_size + 1 + extra))
            (when (or (< (. uep ue_bot) 1) (< (.. @curbuf b_ml ml_line_count) (. uep ue_bot)))
                (emsg (u8 "E440: undo line missing"))
                ((ร uep.ue_bot =) (ยง uep.ue_top + 1))    ;; assume all lines deleted, will
                                                ;; get all the old lines back
                                                ;; without deleting the current ones
            )

            ((ร @curbuf.b_u_newhead.uh_getbot_entry =) null)
        )

        ((ร @curbuf.b_u_synced =) true)
    ))

;; Free one header "uhp" and its entry list and adjust the pointers.

(defn- #_void u_freeheader [#_buffer_C buf, #_u_header_C uhp, #_u_header_C* uhpp]
    ;; uhpp: if not null reset when freeing this header
    (ยง
        ;; When there is an alternate redo list free that branch completely,
        ;; because we can never go there.
        (if (!= (.. uhp uh_alt_next ptr) null)
            (u_freebranch buf, (.. uhp uh_alt_next ptr), uhpp))

        (if (!= (.. uhp uh_alt_prev ptr) null)
            ((ร uhp.uh_alt_prev.ptr.uh_alt_next.ptr =) null)
        )

        ;; Update the links in the list to remove the header.
        (if (nil? (.. uhp uh_next ptr))
            ((ร buf.b_u_oldhead =) (.. uhp uh_prev ptr))
            ((ร uhp.uh_next.ptr.uh_prev.ptr =) (.. uhp uh_prev ptr))
        )

        (cond (nil? (.. uhp uh_prev ptr))
        (ยง
            ((ร buf.b_u_newhead =) (.. uhp uh_next ptr))
        )
        :else
        (ยง
            ((ร FOR) (ร (ยง u_header_C uhap = uhp.uh_prev.ptr) (!= uhap null) (ยง uhap = uhap.uh_alt_next.ptr))
                ((ร uhap.uh_next.ptr =) (.. uhp uh_next ptr))
            )
        ))

        (u_freeentries buf, uhp, uhpp)
    ))

;; Free an alternate branch and any following alternate branches.

(defn- #_void u_freebranch [#_buffer_C buf, #_u_header_C uhp, #_u_header_C* uhpp]
    ;; uhpp: if not null reset when freeing this header
    (ยง
        ;; If this is the top branch we may need to use u_freeheader() to update all the pointers.
        (when (== uhp (. buf b_u_oldhead))
            (while (ยง buf.b_u_oldhead != null)
                (u_freeheader buf, (. buf b_u_oldhead), uhpp)
            )
            (ร RETURN)
        )

        (if (!= (.. uhp uh_alt_prev ptr) null)
            ((ร uhp.uh_alt_prev.ptr.uh_alt_next.ptr =) null)
        )

        ((ร FOR) (ร (ยง u_header_C next = uhp) (!= next null) nil)
            ((ร u_header_C tofree =) next)
            (if (!= (.. tofree uh_alt_next ptr) null)
                (u_freebranch buf, (.. tofree uh_alt_next ptr), uhpp))    ;; recursive
            ((ร next =) (.. tofree uh_prev ptr))
            (u_freeentries buf, tofree, uhpp)
        )
    ))

;; Free all the undo entries for one header and the header itself.
;; This means that "uhp" is invalid when returning.

(defn- #_void u_freeentries [#_buffer_C buf, #_u_header_C uhp, #_u_header_C* uhpp]
    ;; uhpp: if not null reset when freeing this header
    (ยง
        ;; Check for pointers to the header that become invalid now.
        (if (== (. buf b_u_curhead) uhp)
            ((ร buf.b_u_curhead =) null)
        )
        (if (== (. buf b_u_newhead) uhp)
            ((ร buf.b_u_newhead =) null)         ;; freeing the newest entry
        )
        (if (and (non-nil? uhpp) (== uhp (ยง uhpp[0])))
            ((ร uhpp[0] =) null)
        )

        (ยง --buf.b_u_numhead)
    ))

;; save the line "lnum" for the "U" command

(defn- #_void u_saveline [#_long lnum]
    (ยง
        (if (== lnum (. @curbuf b_u_line_lnum))                   ;; line is already saved
            (ร RETURN)
        )
        (if (or (< lnum 1) (< (.. @curbuf b_ml ml_line_count) lnum))   ;; should never happen
            (ร RETURN)
        )

        (u_clearline)

        ((ร @curbuf.b_u_line_lnum =) lnum)
        (if (== (.. @curwin w_cursor lnum) lnum)
            ((ร @curbuf.b_u_line_colnr =) (.. @curwin w_cursor col))
            ((ร @curbuf.b_u_line_colnr =) 0)
        )
        ((ร @curbuf.b_u_line_ptr =) (ยง STRDUP(ml_get(lnum))))
    ))

;; clear the line saved for the "U" command
;; (this is used externally for crossing a line while in insert mode)

(defn- #_void u_clearline []
    (ยง
        (when (!= (. @curbuf b_u_line_ptr) null)
            ((ร @curbuf.b_u_line_ptr =) null)
            ((ร @curbuf.b_u_line_lnum =) 0)
        )
    ))

;; Implementation of the "U" command.
;; Differentiation from vi: "U" can be undone with the next "U".
;; We also allow the cursor to be in another line.

(defn- #_void u_undoline []
    (ยง
        (when (or (nil? (. @curbuf b_u_line_ptr)) (< (.. @curbuf b_ml ml_line_count) (. @curbuf b_u_line_lnum)))
            (beep_flush)
            (ร RETURN)
        )

        ;; first save the line for the 'u' command
        (if (not (u_savecommon (- (. @curbuf b_u_line_lnum) 1), (+ (. @curbuf b_u_line_lnum) 1), 0, false))
            (ร RETURN)
        )

        ((ร Bytes oldp =) (ยง STRDUP(ml_get(@curbuf.b_u_line_lnum))))

        (ml_replace (. @curbuf b_u_line_lnum), (. @curbuf b_u_line_ptr))
        (changed_bytes (. @curbuf b_u_line_lnum), 0)
        ((ร @curbuf.b_u_line_ptr =) oldp)

        ((ร int t =) (. @curbuf b_u_line_colnr))
        (if (== (.. @curwin w_cursor lnum) (. @curbuf b_u_line_lnum))
            ((ร @curbuf.b_u_line_colnr =) (.. @curwin w_cursor col))
        )
        ((ร @curwin.w_cursor.col =) t)
        ((ร @curwin.w_cursor.lnum =) (. @curbuf b_u_line_lnum))
        (check_cursor_col)
    ))

;;; ============================================================================================== VimV

;; term.c: functions for controlling the terminal -------------------------------------------------

;; Each termcap is a list of btcap_C structures.
;; 'bt_key' is either a KS_xxx code (>= 0), or a K_xxx code.

(class! #_final btcap_C
    [
        (field int      bt_key)
        (field Bytes    bt_seq)
    ])

(final btcap_C* xterm_tcaps
    [
        (->btcap_C KS_NAME,      (u8 "xterm")                ),

        (->btcap_C KS_CE,        (u8 "\033[K")               ),
        (->btcap_C KS_AL,        (u8 "\033[L")               ),
        (->btcap_C KS_CAL,       (u8 "\033[%p1%dL")          ),
        (->btcap_C KS_DL,        (u8 "\033[M")               ),
        (->btcap_C KS_CDL,       (u8 "\033[%p1%dM")          ),
        (->btcap_C KS_CS,        (u8 "\033[%i%p1%d;%p2%dr")  ),
        (->btcap_C KS_CL,        (u8 "\033[H\033[2J")        ),
        (->btcap_C KS_CD,        (u8 "\033[J")               ),
        (->btcap_C KS_ME,        (u8 "\033[m")               ),
        (->btcap_C KS_MR,        (u8 "\033[7m")              ),
        (->btcap_C KS_MD,        (u8 "\033[1m")              ),
        (->btcap_C KS_UE,        (u8 "\033[m")               ),
        (->btcap_C KS_US,        (u8 "\033[4m")              ),
        (->btcap_C KS_MS,        (u8 "y")                    ),
        (->btcap_C KS_UT,        (u8 "y")                    ),
        (->btcap_C KS_LE,        (u8 "\b")                   ),
        (->btcap_C KS_CM,        (u8 "\033[%i%p1%d;%p2%dH")  ),
        (->btcap_C KS_SR,        (u8 "\033M")                ),
        (->btcap_C KS_CRI,       (u8 "\033[%p1%dC")          ),
        (->btcap_C KS_KS,        (u8 "\033[?1h\033=")        ),
        (->btcap_C KS_KE,        (u8 "\033[?1l\033>")        ),
        (->btcap_C KS_TI,        (u8 "\0337\033[?47h")       ),
        (->btcap_C KS_TE,        (u8 "\033[2J\033[?47l\0338")),
        (->btcap_C KS_CWS,       (u8 "\033[8;%p1%d;%p2%dt")  ),

        (->btcap_C K_UP,         (u8 "\033O*A")              ),
        (->btcap_C K_DOWN,       (u8 "\033O*B")              ),
        (->btcap_C K_RIGHT,      (u8 "\033O*C")              ),
        (->btcap_C K_LEFT,       (u8 "\033O*D")              ),
        ;; An extra set of cursor keys for vt100 mode.
        (->btcap_C K_XUP,        (u8 "\033[1;*A")            ),
        (->btcap_C K_XDOWN,      (u8 "\033[1;*B")            ),
        (->btcap_C K_XRIGHT,     (u8 "\033[1;*C")            ),
        (->btcap_C K_XLEFT,      (u8 "\033[1;*D")            ),
        ;; An extra set of function keys for vt100 mode.
        (->btcap_C K_XF1,        (u8 "\033O*P")              ),
        (->btcap_C K_XF2,        (u8 "\033O*Q")              ),
        (->btcap_C K_XF3,        (u8 "\033O*R")              ),
        (->btcap_C K_XF4,        (u8 "\033O*S")              ),
        (->btcap_C K_F1,         (u8 "\033[11;*~")           ),
        (->btcap_C K_F2,         (u8 "\033[12;*~")           ),
        (->btcap_C K_F3,         (u8 "\033[13;*~")           ),
        (->btcap_C K_F4,         (u8 "\033[14;*~")           ),
        (->btcap_C K_F5,         (u8 "\033[15;*~")           ),
        (->btcap_C K_F6,         (u8 "\033[17;*~")           ),
        (->btcap_C K_F7,         (u8 "\033[18;*~")           ),
        (->btcap_C K_F8,         (u8 "\033[19;*~")           ),
        (->btcap_C K_F9,         (u8 "\033[20;*~")           ),
        (->btcap_C K_F10,        (u8 "\033[21;*~")           ),
        (->btcap_C K_F11,        (u8 "\033[23;*~")           ),
        (->btcap_C K_F12,        (u8 "\033[24;*~")           ),
        (->btcap_C K_S_TAB,      (u8 "\033[Z")               ),
        (->btcap_C K_HELP,       (u8 "\033[28;*~")           ),
        (->btcap_C K_UNDO,       (u8 "\033[26;*~")           ),
        (->btcap_C K_INS,        (u8 "\033[2;*~")            ),
        (->btcap_C K_HOME,       (u8 "\033[1;*H")            ),
     ;; (->btcap_C K_S_HOME,     (u8 "\033O2H")              ),
     ;; (->btcap_C K_C_HOME,     (u8 "\033O5H")              ),
        (->btcap_C K_KHOME,      (u8 "\033[1;*~")            ),
        (->btcap_C K_XHOME,      (u8 "\033O*H")              ),      ;; other Home
        (->btcap_C K_ZHOME,      (u8 "\033[7;*~")            ),      ;; other Home
        (->btcap_C K_END,        (u8 "\033[1;*F")            ),
     ;; (->btcap_C K_S_END,      (u8 "\033O2F")              ),
     ;; (->btcap_C K_C_END,      (u8 "\033O5F")              ),
        (->btcap_C K_KEND,       (u8 "\033[4;*~")            ),
        (->btcap_C K_XEND,       (u8 "\033O*F")              ),      ;; other End
        (->btcap_C K_ZEND,       (u8 "\033[8;*~")            ),
        (->btcap_C K_PAGEUP,     (u8 "\033[5;*~")            ),
        (->btcap_C K_PAGEDOWN,   (u8 "\033[6;*~")            ),
        (->btcap_C K_KPLUS,      (u8 "\033O*k")              ),      ;; keypad plus
        (->btcap_C K_KMINUS,     (u8 "\033O*m")              ),      ;; keypad minus
        (->btcap_C K_KDIVIDE,    (u8 "\033O*o")              ),      ;; keypad /
        (->btcap_C K_KMULTIPLY,  (u8 "\033O*j")              ),      ;; keypad *
        (->btcap_C K_KENTER,     (u8 "\033O*M")              ),      ;; keypad Enter
        (->btcap_C K_KPOINT,     (u8 "\033O*n")              ),      ;; keypad .
        (->btcap_C K_KDEL,       (u8 "\033[3;*~")            ),      ;; keypad Del
    ])

(atom! boolean need_gather)                     ;; need to fill termleader[]
(final Bytes termleader (Bytes. (inc 256)))     ;; for check_termcode()

;; Parsing of the builtin termcap entries.

(defn- #_void parse_builtin_tcap []
    (ยง
        ((ร btcap_C[] tcaps =) xterm_tcaps)

        ((ร FOR) (ร (ยง int i = 1) (ยง i < tcaps.length) (ยง i++))
            ((ร int k =) (ยง tcaps[i].bt_key))
            (cond (< k 0)
            (ยง
                ((ร Bytes name =) (ยง new Bytes(2)))
                (.be name 0, (KEY2TERMCAP0 k))
                (.be name 1, (KEY2TERMCAP1 k))

                (if (nil? (find_termcode name))
                    (add_termcode name, (ยง tcaps[i].bt_seq)))
            )
            :else ;; KS_xx entry
            (ยง
                ;; Only set the value if it wasn't set yet.
                (when (or (nil? (ยง term_strings[k][0])) (== (ยง term_strings[k][0]) EMPTY_OPTION))
                    ((ร term_strings[k][0] =) (ยง tcaps[i].bt_seq))
                )
            ))
        )
    ))

;; Set terminal options.
;;
;; While doing this, until ttest(), some options may be null, be careful.

(defn- #_void set_term []
    (ยง
        (out_flush)

        ;; Reset a few things before clearing the old options.  This may cause
        ;; outputting a few things that the terminal doesn't understand, but the
        ;; screen will be cleared later, so this is OK.

        (stoptermcap)                  ;; stop termcap mode

        (clear_termcodes)
        (parse_builtin_tcap)

        ;; Any "stty" settings override the default for t_kb from the termcap.

        (get_stty)

        ;; If the termcap has no entry for 'bs' and/or 'del' and the ioctl()
        ;; also didn't work, use the default CTRL-H.
        ;; The default for t_kD is DEL, unless t_kb is DEL.

        ((ร Bytes bs_p =) (find_termcode (u8 "kb")))
        (if (or (nil? bs_p) (eos? bs_p))
            (add_termcode (u8 "kb"), (ยง (bs_p = CTRL_H_STR))))

        ((ร Bytes del_p =) (find_termcode (u8 "kD")))
        (if (and (or (nil? del_p) (eos? del_p)) (or (nil? bs_p) (!= (.at bs_p 0) DEL)))
            (add_termcode (u8 "kD"), DEL_STR))

        (ttest true)                ;; make sure we have a valid set of terminal codes

        (reset! full_screen true)             ;; we can use termcap codes from now on

        ;; Initialize the terminal with the appropriate termcap codes.

        (when (!= @starting NO_SCREEN)
            (starttermcap)             ;; may change terminal mode
        )

        (set_shellsize 80, 24, false)    ;; may change Rows

        (when (!= @starting NO_SCREEN)
            (if @scroll_region
                (scroll_region_reset))          ;; in case Rows changed
        )
    ))

;; the number of calls to ui_write is reduced by using the buffer "out_buf"

(final int OUT_SIZE      2047)

(final Bytes out_buf (Bytes. (inc OUT_SIZE)))
(atom! int out_pos)         ;; number of chars in "out_buf"

;; out_flush(): flush the output buffer

(defn- #_void out_flush []
    (ยง
        (when (non-zero? @out_pos)
            ;; set out_pos to 0 before ui_write, to avoid recursiveness
            ((ร int len =) @out_pos)
            (reset! out_pos 0)
            (ui_write out_buf, len)
        )
    ))

;; Sometimes a byte out of a multi-byte character is written with out_char().
;; To avoid flushing half of the character, call this function first.

(defn- #_void out_flush_check []
    (ยง
    ))

;; out_char(c): put a byte into the output buffer.
;;              Flush it if it becomes full.
;; This should not be used for outputting text on the screen
;; (use functions like msg_puts() and screen_putchar() for that).

(defn- #_void out_char [#_byte c]
    (ยง
        (if (== c (byte \newline))      ;; turn LF into CR-LF (CRMOD doesn't seem to do this)
            (out_char (byte \return)))

        (.be out_buf (ยง @out_pos++), c)

        ;; For testing we flush each time.
        (when (or (<= OUT_SIZE @out_pos) (non-zero? @p_wd))
            (out_flush)
        )
    ))

;; out_char_nf(c): like out_char(), but don't flush when "p_wd" is set

(defn- #_void out_char_nf [#_byte c]
    (ยง
        (if (== c (byte \newline))      ;; turn LF into CR-LF (CRMOD doesn't seem to do this)
            (out_char_nf (byte \return)))

        (.be out_buf (ยง @out_pos++), c)

        (when (<= OUT_SIZE @out_pos)
            (out_flush)
        )
    ))

(defn- #_Bytes _addfmt [#_Bytes buf, #_Bytes fmt, #_int val]
    (ยง
        (ยง libC.sprintf(buf, fmt, val))
        (while (ยง buf.at(0) != NUL)
            ((ร buf =) (ยง buf.plus(1)))
        )
        buf
    ))

(final Bytes tgoto_UP)	;; %% nada!
(final Bytes tgoto_BC)	;; %% nada!
(final Bytes tgoto_buffer (Bytes. 32))

;; Decode cm cursor motion string.
;; cm is cursor motion string, row and col are the desired destination.
;; Returns a pointer to the decoded string, or "OOPS" if it cannot be decoded.
;;
;; Accepted escapes are:
;;      %d       as in printf, 0 origin.
;;      %2, %3   like %02d, %03d in printf.
;;      %.       like %c
;;      %+x      adds <x> to value, then %.
;;      %>xy     if value > x, adds y. No output.
;;      %i       increments row & col. No output.
;;      %r       reverses order of row & col. No output.
;;      %%       prints as a single %.
;;      %n       exclusive or row & col with 0140.
;;      %B       BCD, no output.
;;      %D       reverse coding (x-2*(x%16)), no output.

(defn- #_Bytes _tgoto [#_Bytes cm, #_int col, #_int row]
    ;; cm: string, from termcap
    ;; col: x position
    ;; row: y position
    (ยง
        (if (nil? cm)
            ((ร RETURN) (u8 "OOPS"))                          ;; kludge, but standard
        )

        ((ร boolean reverse =) false)                    ;; reverse flag
        ((ร boolean addup =) false)                      ;; add upline
        ((ร boolean addbak =) false)                     ;; add backup

        ((ร Bytes p =) tgoto_buffer)                    ;; pointer in returned string

        (while (ยง cm.at(0) != NUL)
            ((ร byte b =) (ยง (cm = cm.plus(1)).at(-1)))
            (when (!= b (byte \%))                           ;; normal char
                (ยง (p = p.plus(1)).be(-1, b))
                (ร CONTINUE)
            )

            ((ร b =) (ยง (cm = cm.plus(1)).at(-1)))
            ((ร SWITCH) b                              ;; % escape
                ((ร CASE) (byte \d))                           ;; decimal
                (ยง
                    ((ร p =) (ยง _addfmt(p, (u8 "%d"), row)))
                    ((ร row =) col)
                    (ร BREAK)
                )

                ((ร CASE) (byte \2))                           ;; 2 digit decimal
                (ยง
                    ((ร p =) (ยง _addfmt(p, (u8 "%02d"), row)))
                    ((ร row =) col)
                    (ร BREAK)
                )

                ((ร CASE) (byte \3))                           ;; 3 digit decimal
                (ยง
                    ((ร p =) (ยง _addfmt(p, (u8 "%03d"), row)))
                    ((ร row =) col)
                    (ร BREAK)
                )

                ((ร CASE) (byte \>))                           ;; %>xy: if >x, add y
                (ยง
                    ((ร byte x =) (ยง (cm = cm.plus(1)).at(-1), y = (cm = cm.plus(1)).at(-1)))
                    (if (> col x)
                        ((ร col +=) y)
                    )
                    (if (> row x)
                        ((ร row +=) y)
                    )
                    (ร BREAK)
                )

                ((ร CASE) (byte \+))                           ;; %+c: add c
                (ยง
                    ((ร row +=) (ยง (cm = cm.plus(1)).at(-1)))
                )

                ((ร CASE) (byte \.))                           ;; print x/y
                (ยง
                                                          ;; these are chars that UNIX hates
                    (when (ยง row == (byte \tab) || row == (byte \newline) || row == (byte \u0004) || row == (byte \u0000))
                        (ยง row++)                      ;; so go to next pos
                        (if (== reverse (== row col))
                            ((ร addup =) true)           ;; and mark UP
                            ((ร addbak =) true)          ;; or BC
                        )
                    )
                    (ยง (p = p.plus(1)).be(-1, row))
                    ((ร row =) col)
                    (ร BREAK)
                )

                ((ร CASE) (byte \r))                           ;; r: reverse
                (ยง
                    ((ร int r =) row)
                    ((ร row =) col)
                    ((ร col =) r)
                    ((ร reverse =) true)
                    (ร BREAK)
                )

                ((ร CASE) (byte \i))                           ;; increment (1-origin screen)
                (ยง
                    (ยง col++)
                    (ยง row++)
                    (ร BREAK)
                )

                ((ร CASE) (byte \%))                           ;; %%=% literally
                (ยง
                    (ยง (p = p.plus(1)).be(-1, (byte \%)))
                    (ร BREAK)
                )

                ((ร CASE) (byte \n))                           ;; magic DM2500 code
                (ยง
; %%                ((ร row ^=) 0140)
; %%                ((ร col ^=) 0140)
                    (ร BREAK)
                )

                ((ร CASE) (byte \B))                           ;; bcd encoding
                (ยง
                    ((ร row =) (ยง ((row / 10) << 4) + (row % 10)))
                    ((ร col =) (ยง ((col / 10) << 4) + (col % 10)))
                    (ร BREAK)
                )

                ((ร CASE) (byte \D))                           ;; magic Delta Data code
                (ยง
                    ((ร row -=) (ยง 2 * (row & 15)))
                    ((ร col -=) (ยง 2 * (col & 15)))
                    (ร BREAK)
                )

                ((ร CASE) (byte \p))                           ;; so, what?
                (ยง
                    ((ร byte d =) (ยง (cm = cm.plus(1)).at(-1)))
                    (if (or (== d (byte \1)) (== d (byte \2)))       ;; ignore %p1 and %p2
                        (ร BREAK)
                    )
                    (ร FALLTHROUGH)
                )

                (ร DEFAULT)                            ;; unknown escape
                (ยง
                    ((ร RETURN) (u8 "OOPS"))
                )
            )
        )

        (when addup                                  ;; add upline
            (when (non-nil? tgoto_UP)
                ((ร cm =) tgoto_UP)
                (while (ยง asc_isdigit(cm.at(0)) || cm.at(0) == (byte \.))
                    ((ร cm =) (ยง cm.plus(1)))
                )
                (if (== (.at cm 0) (byte \*))
                    ((ร cm =) (ยง cm.plus(1)))
                )
                (while (ยง cm.at(0) != NUL)
                    (ยง (p = p.plus(1)).be(-1, (cm = cm.plus(1)).at(-1)))
                )
            )
        )

        (when addbak                                 ;; add backspace
            (cond (non-nil? tgoto_BC)
            (ยง
                ((ร cm =) tgoto_BC)
                (while (ยง asc_isdigit(cm.at(0)) || cm.at(0) == (byte \.))
                    ((ร cm =) (ยง cm.plus(1)))
                )
                (if (== (.at cm 0) (byte \*))
                    ((ร cm =) (ยง cm.plus(1)))
                )
                (while (ยง cm.at(0) != NUL)
                    (ยง (p = p.plus(1)).be(-1, (cm = cm.plus(1)).at(-1)))
                )
            )
            :else
            (ยง
                (ยง (p = p.plus(1)).be(-1, (byte \backspace)))
            ))
        )

        (.be p 0, NUL)

        tgoto_buffer
    ))

;; Note: "s" may have padding information ahead of it, in the form of nnnTEXT or nnn*TEXT.
;;  nnn is the number of milliseconds to delay, and may be a decimal fraction (nnn.mmm).
;;  In case an asterisk is given, the delay is to be multiplied by "_affcnt".

(defn- #_int _tputs [#_Bytes s, #_int _affcnt]
    ;; s: string to print
    ;; affcnt: number of lines affected
    (ยง
        ((ร int i =) 0)

        (when (asc_isdigit (ยง s.at(i)))
            (while (ยง asc_isdigit(s.at(++i)))
                ;
            )
            (when (== (.at s i) (byte \.))
                (while (ยง asc_isdigit(s.at(++i)))
                    ;
                )
            )
            (if (== (.at s i) (byte \*))
                (ยง i++)
            )
        )

        (while (ยง s.at(i) != NUL)
            (out_char_nf (.at s (ยง i++)))
        )

        0
    ))

;; A never-padding out_str:
;; use this whenever you don't want to run the string through tputs.
;; tputs above is harmless,
;; but tputs from the termcap library is likely to strip off leading digits,
;; that it mistakes for padding information, and "%i", "%d", etc.
;; This should only be used for writing terminal codes, not for outputting
;; normal text: use functions like msg_puts() and screen_putchar() for that.

(defn- #_void out_str_nf [#_Bytes s]
    (ยง
        (if (< (- OUT_SIZE 20) @out_pos)    ;; avoid terminal strings being split up
            (out_flush))

        ((ร FOR) (ร (ยง int i = 0) (ยง s.at(i) != NUL) nil)
            (out_char_nf (.at s (ยง i++)))
        )

        ;; For testing we write one string at a time.
        (when (non-zero? @p_wd)
            (out_flush)
        )
    ))

;; out_str(s): Put a character string a byte at a time into the output buffer.
;; This should only be used for writing terminal codes, not for outputting
;; normal text: use functions like msg_puts() and screen_putchar() for that.

(defn- #_void out_str [#_Bytes s]
    (ยง
        (when (and (non-nil? s) (non-eos? s))
            ;; avoid terminal strings being split up
            (if (< (- OUT_SIZE 20) @out_pos)
                (out_flush))

            (_tputs s, 1)

            ;; For testing we write one string at a time.
            (if (non-zero? @p_wd)
                (out_flush))
        )
    ))

;; cursor positioning using termcap parser

(defn- #_void term_windgoto [#_int row, #_int col]
    (ยง
        (ยง out_str(_tgoto(@T_CM, col, row)))
    ))

(defn- #_void term_cursor_right [#_int i]
    (ยง
        (ยง out_str(_tgoto(@T_CRI, 0, i)))
    ))

(defn- #_void term_append_lines [#_int line_count]
    (ยง
        (ยง out_str(_tgoto(@T_CAL, 0, line_count)))
    ))

(defn- #_void term_delete_lines [#_int line_count]
    (ยง
        (ยง out_str(_tgoto(@T_CDL, 0, line_count)))
    ))

(defn- #_void term_set_winsize [#_int width, #_int height]
    (ยง
        (ยง out_str(_tgoto(@T_CWS, height, width)))
    ))

(defn- #_void term_fg_color [#_int n]
    (ยง
        ;; Use "AF" termcap entry if present, "Sf" entry otherwise.
        (cond (non-eos? @T_CAF)
        (ยง
            (term_color @T_CAF, n)
        )
        (non-eos? @T_CSF)
        (ยง
            (term_color @T_CSF, n)
        ))
    ))

(defn- #_void term_bg_color [#_int n]
    (ยง
        ;; Use "AB" termcap entry if present, "Sb" entry otherwise.
        (cond (non-eos? @T_CAB)
        (ยง
            (term_color @T_CAB, n)
        )
        (non-eos? @T_CSB)
        (ยง
            (term_color @T_CSB, n)
        ))
    ))

(defn- #_void term_color [#_Bytes s, #_int n]
    (ยง
        ((ร int i =) 2)  ;; index in s just after <Esc>[

        ;; Special handling of 16 colors, because termcap can't handle it.
        ;; Also accept "\e[3%dm" for TERMINFO, it is sometimes used.
        (when (ยง 8 <= n && 16 <= @t_colors && s.at(0) == ESC && s.at(1) == (byte \[) && s.at(i) != NUL && (STRCMP(s.plus(i + 1), (u8 "%p1%dm")) == 0 || STRCMP(s.plus(i + 1), (u8 "%dm")) == 0) && (s.at(i) == (byte \3) || s.at(i) == (byte \4)))
            ((ร Bytes buf =) (ยง new Bytes(20)))
            (.sprintf libC buf, (u8 "%s%s%%p1%%dm"), (if (== i 2) (u8 "\033[") (u8 "\233")), (if (== (.at s i) (byte \3)) (if (<= 16 n) (u8 "38;5;") (u8 "9")) (if (<= 16 n) (u8 "48;5;") (u8 "10"))))
            ((ร s =) buf)
            ((ร n =) (if (<= 16 n) n (- n 8)))
        )

        (ยง out_str(_tgoto(s, 0, n)))
    ))

;; Make sure we have a valid set or terminal options.
;; Replace all entries that are null by EMPTY_OPTION.

(defn- #_void ttest [#_boolean pairs]
    (ยง
        (check_options)            ;; make sure no options are null

        ;; MUST have "cm": cursor motion.

        (if (eos? @T_CM)
            (emsg (u8 "E437: terminal capability \"cm\" required")))

        ;; If "cs" defined, use a scroll region, it's faster.

        (reset! scroll_region (non-eos? @T_CS))

        ;; optional pairs

        (when pairs
            ;; TP goes to normal mode for TI (invert) and TB (bold).
            (if (eos? @T_ME)
                (reset! T_ME (ยง @T_MR = @T_MD = EMPTY_OPTION)))
            (if (or (eos? @T_SO) (eos? @T_SE))
                (reset! T_SO (ยง @T_SE = EMPTY_OPTION)))
            (if (or (eos? @T_US) (eos? @T_UE))
                (reset! T_US (ยง @T_UE = EMPTY_OPTION)))
            (if (or (eos? @T_CZH) (eos? @T_CZR))
                (reset! T_CZH (ยง @T_CZR = EMPTY_OPTION)))

            ;; T_VE is needed even though T_VI is not defined.
            (if (eos? @T_VE)
                (reset! T_VI EMPTY_OPTION))

            ;; If 'mr' or 'me' is not defined use 'so' and 'se'.
            (when (eos? @T_ME)
                (reset! T_ME @T_SE)
                (reset! T_MR (ยง @T_MD = @T_SO))
            )

            ;; If 'so' or 'se' is not defined use 'mr' and 'me'.
            (when (eos? @T_SO)
                (reset! T_SE @T_ME)
                (reset! T_SO (if (eos? @T_MR) @T_MD @T_MR))
            )

            ;; If 'ZH' or 'ZR' is not defined use 'mr' and 'me'.
            (when (eos? @T_CZH)
                (reset! T_CZR @T_ME)
                (reset! T_CZH (if (eos? @T_MR) @T_MD @T_MR))
            )

            ;; "Sb" and "Sf" come in pairs.
            (when (or (eos? @T_CSB) (eos? @T_CSF))
                (reset! T_CSB EMPTY_OPTION)
                (reset! T_CSF EMPTY_OPTION)
            )

            ;; "AB" and "AF" come in pairs.
            (when (or (eos? @T_CAB) (eos? @T_CAF))
                (reset! T_CAB EMPTY_OPTION)
                (reset! T_CAF EMPTY_OPTION)
            )

            ;; If 'Sb' and 'AB' are not defined, reset "Co".
            (if (and (eos? @T_CSB) (eos? @T_CAB))
                (reset! T_CCO EMPTY_OPTION))
        )

        (reset! need_gather true)

        (reset! t_colors (ยง libC.atoi(@T_CCO)))
    ))

;; Check if the new shell size is valid, correct it if it's too small or way too big.

(defn- #_void check_shellsize []
    (ยง
        ((ร int min =) (min_rows))
        (if (< @Rows min)         ;; need room for one window and command line
            (reset! Rows min))
        (limit_screen_size)
    ))

;; Limit Rows and Columns to avoid an overflow in Rows * Columns.

(defn- #_void limit_screen_size []
    (ยง
        (cond (< @Columns MIN_COLUMNS)
        (ยง
            (reset! Columns MIN_COLUMNS)
        )
        (< 10000 @Columns)
        (ยง
            (reset! Columns 10000)
        ))

        (when (< 1000 @Rows)
            (reset! Rows 1000)
        )
    ))

(atom! long old__Rows)
(atom! long old__Columns)

;; Invoked just before the screen structures are going to be (re)allocated.

(defn- #_void win_new_shellsize []
    (ยง
        (if (or (!= @old__Rows @Rows) (!= @old__Columns @Columns))
            (ui_new_shellsize))
        (when (!= @old__Rows @Rows)
            (reset! old__Rows @Rows)
            (shell_new_rows)       ;; update window sizes
        )
        (when (!= @old__Columns @Columns)
            (reset! old__Columns @Columns)
            (shell_new_columns)    ;; update window sizes
        )
    ))

;; Call this function when the Vim shell has been resized in any way.
;; Will obtain the current size and redraw (also when size didn't change).

(defn- #_void shell_resized []
    (set_shellsize 0, 0, false))

(atom! int _2_busy)

;; Set size of the Vim shell.
;; If 'mustset' is true, we must set Rows and Columns,
;; do not get the real window size (this is used for the :win command).
;; If 'mustset' is false, we may try to get the real window size
;; and if it fails, use 'width' and 'height'.

(defn- #_void set_shellsize [#_int width, #_int height, #_boolean mustset]
    (ยง
        ;; Avoid recursiveness, can happen when setting the window size causes
        ;; another window-changed signal.

        (if (non-zero? @_2_busy)
            (ร RETURN)
        )

        (if (or (< width 0) (< height 0))    ;; just checking...
            (ร RETURN)
        )

        (when (or (== @State HITRETURN) (== @State SETWSIZE))
            ;; postpone the resizing
            (reset! State SETWSIZE)
            (ร RETURN)
        )

        (swap! _2_busy inc)

        (cond (or mustset (and (not (ui_get_shellsize)) (non-zero? height)))
        (ยง
            (reset! Rows height)
            (reset! Columns width)
            (check_shellsize)
            (ui_set_shellsize mustset)
        )
        :else
        (ยง
            (check_shellsize)
        ))

        ;; The window layout used to be adjusted here, but it now happens in
        ;; screenalloc() (also invoked from screenclear()).  That is because
        ;; the "_2_busy" check above may skip this, but not screenalloc().

        (if (and (!= @State ASKMORE) (!= @State CONFIRM))
            (screenclear)
            (screen_start))     ;; don't know where cursor is now

        (when (!= @starting NO_SCREEN)
            (changed_line_abv_curs)
            (invalidate_botline)

            ;; We only redraw when it's needed:
            ;; - While at the more prompt or executing an external command, don't
            ;;   redraw, but position the cursor.
            ;; - While editing the command line, only redraw that.
            ;; - Otherwise, redraw right now, and position the cursor.
            ;; Always need to call update_screen() or screenalloc(), to make
            ;; sure Rows/Columns and the size of screenLines[] is correct!

            (cond (or (== @State ASKMORE) (== @State CONFIRM))
            (ยง
                (screenalloc false)
                (repeat_message)
            )
            :else
            (ยง
                (if @(.. @curwin w_options wo_scb)
                    (do_check_scrollbind true))
                (cond (non-zero? (& @State CMDLINE))
                (ยง
                    (update_screen NOT_VALID)
                    (redrawcmdline)
                )
                :else
                (ยง
                    (update_topline)
                    (update_screen NOT_VALID)
                    (if (redrawing)
                        (setcursor))
                ))
            ))
            (cursor_on)        ;; redrawing may have switched it off
        )

        (out_flush)

        (swap! _2_busy dec)
    ))

;; Set the terminal to TMODE_RAW (for Normal mode)
;; or TMODE_COOK (for external commands and Ex mode).

(defn- #_void settmode [#_int tmode]
    (ยง
        (when @full_screen
            ;; When returning after calling a shell we want to really set the
            ;; terminal to raw mode, even though we think it already is, because
            ;; the shell program may have reset the terminal mode.
            ;; When we think the terminal is normal, don't try to set it to
            ;; normal again, because that causes problems (logout!) on some machines.

            (when (or (!= tmode TMODE_COOK) (!= @cur_tmode TMODE_COOK))
                (out_flush)
                (mch_settmode tmode)                ;; machine specific function
                (reset! cur_tmode tmode)
                (out_flush)
            )
        )
    ))

(defn- #_void starttermcap []
    (ยง
        (when (and @full_screen (not @termcap_active))
            (out_str @T_TI)                  ;; start termcap mode
            (out_str @T_KS)                  ;; start "keypad transmit" mode
            (out_flush)
            (reset! termcap_active true)
            (screen_start)                 ;; don't know where cursor is now
        )
    ))

(defn- #_void stoptermcap []
    (ยง
        (screen_stop_highlight)
        (reset_cterm_colors)
        (when @termcap_active
            (out_str @T_KE)                  ;; stop "keypad transmit" mode
            (out_flush)
            (reset! termcap_active false)
            (cursor_on)                    ;; just in case it is still off
            (out_str @T_TE)                  ;; stop termcap mode
            (screen_start)                 ;; don't know where cursor is now
            (out_flush)
        )
    ))

;; Return true when saving and restoring the screen.

(defn- #_boolean swapping_screen []
    (ยง
        (and @full_screen (non-eos? @T_TI))
    ))

;; By outputting the 'cursor very visible' termcap code, for some windowed
;; terminals this makes the screen scrolled to the correct position.
;; Used when starting Vim or returning from a shell.

(defn- #_void scroll_start []
    (ยง
        (when (non-eos? @T_VS)
            (out_str @T_VS)
            (out_str @T_VE)
            (screen_start)                 ;; don't know where cursor is now
        )
    ))

(atom! boolean cursor_is_off)

;; Enable the cursor.

(defn- #_void cursor_on []
    (ยง
        (when @cursor_is_off
            (out_str @T_VE)
            (reset! cursor_is_off false)
        )
    ))

;; Disable the cursor.

(defn- #_void cursor_off []
    (ยง
        (when @full_screen
            (if (not @cursor_is_off)
                (out_str @T_VI))          ;; disable cursor
            (reset! cursor_is_off true)
        )
    ))

(atom! int showing_mode NORMAL)

;; Set cursor shape to match Insert or Replace mode.

(defn- #_void term_cursor_shape []
    (ยง
        ;; Only do something when redrawing the screen and we can restore the mode.
        (if (or (not @full_screen) (eos? @T_CEI))
            (ร RETURN)
        )

        (cond (ยง (@State & REPLACE) == REPLACE)
        (ยง
            (when (!= @showing_mode REPLACE)
                (ร Bytes p)
                (if (non-eos? @T_CSR)
                    ((ร p =) @T_CSR)                  ;; Replace mode cursor
                    ((ร p =) @T_CSI)                  ;; fall back to Insert mode cursor
                )
                (when (non-eos? p)
                    (out_str p)
                    (reset! showing_mode REPLACE)
                )
            )
        )
        (non-zero? (& @State INSERT))
        (ยง
            (when (and (!= @showing_mode INSERT) (non-eos? @T_CSI))
                (out_str @T_CSI)                 ;; Insert mode cursor
                (reset! showing_mode INSERT)
            )
        )
        (!= @showing_mode NORMAL)
        (ยง
            (out_str @T_CEI)                     ;; non-Insert mode cursor
            (reset! showing_mode NORMAL)
        ))
    ))

;; Set scrolling region for window 'wp'.
;; The region starts 'off' lines from the start of the window.
;; Also set the vertical scroll region for a vertically split window.
;; Always the full width of the window, excluding the vertical separator.

(defn- #_void scroll_region_set [#_window_C wp, #_int off]
    (ยง
        (ยง out_str(_tgoto(@T_CS, wp.w_winrow + wp.w_height - 1, wp.w_winrow + off)))

        (if (and (non-eos? @T_CSV) (!= (. wp w_width) (int @Columns)))
            (ยง out_str(_tgoto(@T_CSV, wp.w_wincol + wp.w_width - 1, wp.w_wincol)))
        )

        (screen_start)                 ;; don't know where cursor is now
    ))

;; Reset scrolling region to the whole screen.

(defn- #_void scroll_region_reset []
    (ยง
        (ยง out_str(_tgoto(@T_CS, (int)@Rows - 1, 0)))

        (if (non-eos? @T_CSV)
            (ยง out_str(_tgoto(@T_CSV, (int)@Columns - 1, 0)))
        )

        (screen_start)                 ;; don't know where cursor is now
    ))

;; List of terminal codes that are currently recognized.

(class! #_final termcode_C
    [
        (field Bytes    name    (Bytes. 2))     ;; termcap name of entry
        (field Bytes    code)                   ;; terminal code (in allocated memory)
        (field int      len)                    ;; STRLEN(code)
        (field int      modlen)                 ;; length of part before ";*~".
    ])

(defn- #_void COPY_termcode [#_termcode_C tc1, #_termcode_C tc0]
    (ยง
        (BCOPY (. tc1 name), (. tc0 name), 2)
        ((ร tc1.code =) (. tc0 code))
        ((ร tc1.len =) (. tc0 len))
        ((ร tc1.modlen =) (. tc0 modlen))
    ))

(defn- #_termcode_C* ARRAY_termcode [#_int n]
    (vec (repeatedly n ยง_termcode_C)))

(atom! termcode_C* termcodes)

(atom! int tc_max_len)  ;; number of entries that termcodes[] can hold
(atom! int tc_len)      ;; current number of entries in termcodes[]

(defn- #_void clear_termcodes []
    (ยง
        (reset! tc_len 0)
        (reset! tc_max_len 0)
        (reset! termcodes null)

        (reset! need_gather true)         ;; need to fill termleader[]
    ))

;; Add a new entry to the list of terminal codes.
;; The list is kept alphabetical for ":set termcap"

(defn- #_void add_termcode [#_Bytes name, #_Bytes string]
    (ยง
        (when (or (nil? string) (eos? string))
            (del_termcode name)
            (ร RETURN)
        )

        ((ร Bytes code =) (STRDUP string))

        ((ร int len =) (STRLEN code))

        (reset! need_gather true)         ;; need to fill termleader[]

        ;; need to make space for more entries

        (when (== @tc_len @tc_max_len)
            ((ร @tc_max_len +=) 20)
            ((ร termcode_C[] new_tc =) (ARRAY_termcode @tc_max_len))
            ((ร FOR) (ร (ยง int i = 0) (< i @tc_len) (ยง i++))
                (COPY_termcode (ยง new_tc[i]), (ยง @termcodes[i]))
            )
            (reset! termcodes new_tc)
        )

        ;; Look for existing entry with the same name, it is replaced.
        ;; Look for an existing entry that is alphabetical higher, the new entry is inserted in front of it.

        (ร int i)
        ((ร FOR) (ร (ยง i = 0) (< i @tc_len) (ยง i++))
            (if (< (char_u (ยง @termcodes[i].name.at(0))) (char_u (ยง name.at(0))))
                (ร CONTINUE)
            )
            (when (== (ยง @termcodes[i].name.at(0)) (ยง name.at(0)))
                (if (< (char_u (ยง @termcodes[i].name.at(1))) (char_u (ยง name.at(1))))
                    (ร CONTINUE)
                )

                ;; Exact match: May replace old code.

                (when (== (ยง @termcodes[i].name.at(1)) (ยง name.at(1)))
                    ;; Replace old code.
                    ((ร @termcodes[i].code =) null)
                    (swap! tc_len dec)
                    (ร BREAK)
                )
            )

            ;; Found alphabetical larger entry, move rest to insert new entry

            ((ร FOR) (ร (ยง int j = @tc_len) (< i j) (ยง --j))
                (COPY_termcode (ยง @termcodes[j]), (ยง @termcodes[j - 1]))
            )
            (ร BREAK)
        )

;       @termcodes[i].name.be(0, name.at(0));
;       @termcodes[i].name.be(1, name.at(1));
        ((ร @termcodes[i].code =) code)
        ((ร @termcodes[i].len =) len)

        ;; For xterm we recognize special codes like "ESC[42;*X" and "ESC O*X" that accept modifiers.
        ((ร @termcodes[i].modlen =) 0)
        ((ร int j =) (termcode_star code, len))
        (if (< 0 j)
            ((ร @termcodes[i].modlen =) (ยง len - 1 - j))
        )
        (swap! tc_len inc)
    ))

;; Check termcode "code[len]" for ending in ;*X, <Esc>O*X or <M-O>*X.
;; The "X" can be any character.
;; Return 0 if not found, 2 for ;*X and 1 for O*X and <M-O>*X.

(defn- #_int termcode_star [#_Bytes code, #_int len]
    (ยง
        ;; Shortest is <M-O>*X.  With ; shortest is <CSI>1;*X.
        (when (and (<= 3 len) (== (.at code (- len 2)) (byte \*)))
            (if (and (<= 5 len) (== (.at code (- len 3)) (byte \;)))
                ((ร RETURN) 2)
            )
            (if (or (and (<= 4 len) (== (.at code (- len 3)) (byte \O))) (== (char_u (.at code (- len 3))) (+ (byte \O) 0x80)))
                ((ร RETURN) 1)
            )
        )
        0
    ))

(defn- #_Bytes find_termcode [#_Bytes name]
    (ยง
        ((ร FOR) (ร (ยง int i = 0) (< i @tc_len) (ยง i++))
            (if (and (== (ยง @termcodes[i].name.at(0)) (ยง name.at(0))) (== (ยง @termcodes[i].name.at(1)) (ยง name.at(1))))
                ((ร RETURN) (ยง @termcodes[i].code))
            )
        )

        null
    ))

(defn- #_void del_termcode [#_Bytes name]
    (ยง
        (if (nil? @termcodes)      ;; nothing there yet
            (ร RETURN)
        )

        (reset! need_gather true)         ;; need to fill termleader[]

        ((ร FOR) (ร (ยง int i = 0) (< i @tc_len) (ยง i++))
            (when (and (== (ยง @termcodes[i].name.at(0)) (ยง name.at(0))) (== (ยง @termcodes[i].name.at(1)) (ยง name.at(1))))
                (del_termcode_idx i)
                (ร RETURN)
            )
        )
        ;; Not found.  Give error message?
    ))

(defn- #_void del_termcode_idx [#_int idx]
    (ยง
        ((ร @termcodes[idx].code =) null)
        (swap! tc_len dec)
        ((ร FOR) (ร (ยง int i = idx) (< i @tc_len) (ยง i++))
            (COPY_termcode (ยง @termcodes[i]), (ยง @termcodes[i + 1]))
        )
    ))

;; Check if typebuf.tb_buf[] contains a terminal key code.
;; Check at typebuf.tb_buf[typebuf.tb_off].
;; Return 0 for no match, -1 for partial match, > 0 for full match.
;; Return KEYLEN_REMOVED when a key code was deleted.
;; With a match, the match is removed, the replacement code is inserted in
;; typebuf.tb_buf[] and the number of characters in typebuf.tb_buf[] is returned.
;; When "buf" is not null, buf[bufsize] is used instead of typebuf.tb_buf[].
;; "buflen" is then the length of the string in buf[] and is updated for inserts and deletes.

(defn- #_int check_termcode [#_Bytes buf, #_int bufsize, #_int* buflen]
    (ยง
        ;; Speed up the checks for terminal codes by gathering all first bytes used in termleader[].
        ;; Often this is just a single <Esc>.

        (if @need_gather
            (gather_termleader))

        (ร Bytes tp)
        (ร int len)

        (cond (nil? buf)
        (ยง
            (if (<= (. @typebuf tb_len) 0)
                ((ร RETURN) 0)
            )
            ((ร tp =) (ยง @typebuf.tb_buf.plus(@typebuf.tb_off)))
            ((ร len =) (. @typebuf tb_len))      ;; length of the input
        )
        :else
        (ยง
            (if (<= (ยง buflen[0]) 0)
                ((ร RETURN) 0)
            )
            ((ร tp =) buf)
            ((ร len =) (ยง buflen[0]))
        ))

        ;; Don't check characters after KB_SPECIAL, those are already
        ;; translated terminal chars (avoid translating ~@^Hx).

        (if (== (.at tp 0) KB_SPECIAL)        ;; there are always 2 extra characters
            ((ร RETURN) 0)
        )

        ;; Skip this position if the character does not appear as the first character in 'term_strings'.
        ;; This speeds up a lot, since most termcodes start with the same character (ESC).

        (ร Bytes q)
        ((ร FOR) (ร (ยง q = termleader) (ยง q.at(0) != NUL && q.at(0) != tp.at(0)) (ยง q = q.plus(1)))
            ;
        )
        (if (eos? q)
            ((ร RETURN) 0)
        )

        ;; Skip this position if "p_ek" is not set and *tp is an ESC and we are in Insert mode.

        (if (and (== (.at tp 0) ESC) (not @p_ek) (non-zero? (& @State INSERT)))
            ((ร RETURN) 0)
        )

        ((ร Bytes key_name =) (ยง new Bytes(2)))
; %%    ((ร int[] modifiers =) (ยง { 0 }))      ;; no modifiers yet

        ((ร int slen =) 0)

        ((ร FOR) (ร (ยง int idx = 0) (< idx @tc_len) (ยง idx++))
            ((ร slen =) (ยง @termcodes[idx].len))

            (when (== (STRNCMP (ยง @termcodes[idx].code), tp, (if (< len slen) len slen)) 0)
                (if (< len slen)             ;; got a partial sequence
                    ((ร RETURN) -1)              ;; need to get more chars
                )

                ;; When found a keypad key, check if there is another key that matches and use that one.
                ;; This makes <Home> to be found instead of <kHome> when they produce the same key code.

                (when (and (== (ยง @termcodes[idx].name.at(0)) (byte \K)) (asc_isdigit (ยง @termcodes[idx].name.at(1))))
                    ((ร FOR) (ร (ยง int j = idx + 1) (< j @tc_len) (ยง j++))
                        (when (and (== (ยง @termcodes[j].len) slen) (zero? (ยง STRNCMP(@termcodes[idx].code, @termcodes[j].code, slen))))
                            ((ร idx =) j)
                            (ร BREAK)
                        )
                    )
                )

                (.be key_name 0, (ยง @termcodes[idx].name.at(0)))
                (.be key_name 1, (ยง @termcodes[idx].name.at(1)))
                (ร BREAK)
            )

            ;; Check for code with modifier, like xterm uses:
            ;; <Esc>[123;*X (modslen == slen - 3), also <Esc>O*X and <M-O>*X (modslen == slen - 2).
            ;; When there is a modifier the * matches a number.
            ;; When there is no modifier the ;* or * is omitted.

            (when (< 0 (ยง @termcodes[idx].modlen))
                ((ร int modslen =) (ยง @termcodes[idx].modlen))

                (when (== (STRNCMP (ยง @termcodes[idx].code), tp, (if (< len modslen) len modslen)) 0)
                    (if (<= len modslen)     ;; got a partial sequence
                        ((ร RETURN) -1)          ;; need to get more chars
                    )

                    (cond (== (.at tp modslen) (.at (ยง @termcodes[idx].code) (- slen 1)))
                    (ยง
                        ((ร slen =) (+ modslen 1)) ;; no modifiers
                    )
                    (and (!= (.at tp modslen) (byte \;)) (== modslen (- slen 3)))
                    (ยง
                        (ร CONTINUE)   ;; no match
                    )
                    :else
                    (ยง
                        ;; Skip over the digits, the final char must follow.
                        (ร int j)
                        ((ร FOR) (ร (ยง j = slen - 2) (ยง j < len && asc_isdigit(tp.at(j))) (ยง j++))
                            ;
                        )
                        (ยง j++)
                        (if (< len j)        ;; got a partial sequence
                            ((ร RETURN) -1)      ;; need to get more chars
                        )
                        (if (!= (.at tp (- j 1)) (.at (ยง @termcodes[idx].code) (- slen 1)))
                            (ร CONTINUE)       ;; no match
                        )

                        ;; Match!  Convert modifier bits.
                        ((ร int n =) (ยง libC.atoi(tp.plus(slen - 2)) - 1))
                        (if (non-zero? (& n 1))
                            ((ร modifiers[0] |=) MOD_MASK_SHIFT)
                        )
                        (if (non-zero? (& n 2))
                            ((ร modifiers[0] |=) MOD_MASK_ALT)
                        )
                        (if (non-zero? (& n 4))
                            ((ร modifiers[0] |=) MOD_MASK_CTRL)
                        )
                        (if (non-zero? (& n 8))
                            ((ร modifiers[0] |=) MOD_MASK_META)
                        )

                        ((ร slen =) j)
                    ))

                    (.be key_name 0, (ยง @termcodes[idx].name.at(0)))
                    (.be key_name 1, (ยง @termcodes[idx].name.at(1)))
                    (ร BREAK)
                )
            )
        )

        (when (eos? key_name)
            ((ร RETURN) 0)               ;; no match found
        )

        ;; We only get here when we have a complete termcode match.

        ;; Change <xHome> to <Home>, <xUp> to <Up>, etc.

        ((ร int key =) (ยง handle_x_keys(TERMCAP2KEY(key_name.at(0), key_name.at(1)))))

        ((ร Bytes string =) (ยง new Bytes(MAX_KEY_CODE_LEN + 1)))

        ;; Add any modifier codes to our string.

        ((ร int new_slen =) 0)           ;; length of what will replace the termcode
        (when (!= (ยง modifiers[0]) 0)
            ;; Some keys have the modifier included.
            ;; Need to handle that here to make mappings work.
            ((ร key =) (simplify_key key, modifiers))
            (when (!= (ยง modifiers[0]) 0)
                (.be string (ยง new_slen++), KB_SPECIAL)
                (.be string (ยง new_slen++), KS_MODIFIER)
                (.be string (ยง new_slen++), (ยง modifiers[0]))
            )
        )

        ((ร int retval =) 0)

        ;; Finally, add the special key code to our string.
        (.be key_name 0, (KEY2TERMCAP0 key))
        (.be key_name 1, (KEY2TERMCAP1 key))
        (cond (== (.at key_name 0) KS_KEY)
        (ยง
            ;; from ":set <M-b>=xx"
            ((ร new_slen +=) (ยง utf_char2bytes(char_u(key_name.at(1)), string.plus(new_slen))))
        )
        (and (zero? new_slen) (== (.at key_name 0) KS_EXTRA) (== (.at key_name 1) KE_IGNORE))
        (ยง
            ;; Do not put K_IGNORE into the buffer, do return KEYLEN_REMOVED to indicate what happened.
            ((ร retval =) KEYLEN_REMOVED)
        )
        :else
        (ยง
            (.be string (ยง new_slen++), KB_SPECIAL)
            (.be string (ยง new_slen++), (ยง key_name.at(0)))
            (.be string (ยง new_slen++), (ยง key_name.at(1)))
        ))
        (.be string new_slen, NUL)

        ((ร int extra =) (- new_slen slen))
        (cond (nil? buf)
        (ยง
            (cond (< extra 0)
            (ยง
                ;; remove matched chars, taking care of noremap
                (del_typebuf (- extra))
            )
            (< 0 extra)
            (ยง
                ;; insert the extra space we need
                (ins_typebuf (.plus string slen))
            ))

            (BCOPY (. @typebuf tb_buf), (. @typebuf tb_off), string, 0, new_slen)
        )
        :else
        (ยง
            (cond (< extra 0)
            (ยง
                ;; remove matched characters
                (BCOPY buf, 0, buf, (- extra), (+ (ยง buflen[0]) extra))
            )
            (< 0 extra)
            (ยง
                ;; Insert the extra space we need.  If there is insufficient space return -1.
                (if (<= bufsize (ยง buflen[0] + extra + new_slen))
                    ((ร RETURN) -1)
                )
                (BCOPY buf, extra, buf, 0, (ยง buflen[0]))
            ))

            (BCOPY buf, 0, string, 0, new_slen)
            ((ร buflen[0] +=) (+ extra new_slen))
        ))

        (if (non-zero? retval) retval (+ len extra))
    ))

;; Gather the first characters in the terminal key codes into a string.
;; Used to speed up check_termcode().

(defn- #_void gather_termleader []
    (ยง
        ((ร int len =) 0)

        (.be termleader len, NUL)

        ((ร FOR) (ร (ยง int i = 0) (< i @tc_len) (ยง i++))
            (when (nil? (ยง vim_strchr(termleader, @termcodes[i].code.at(0))))
                (.be termleader (ยง len++), (ยง @termcodes[i].code.at(0)))
                (.be termleader len, NUL)
            )
        )

        (reset! need_gather false)
    ))

;; ui.c: functions that handle the user interface.
;; 1. Keyboard input stuff, and a bit of windowing stuff.  These are called
;;    before the machine specific stuff (mch_*) so that we can call the GUI
;;    stuff instead if the GUI is running.
;; 2. Clipboard stuff.
;; 3. Input buffer stuff.

(defn- #_void ui_write [#_Bytes s, #_int len]
    (mch_write s, len))

;; ui_inchar(): low level input function.
;; Get characters from the keyboard.
;; Return the number of characters that are available.
;; If "wtime" == 0 do not wait for characters.
;; If "wtime" == -1 wait forever for characters.
;; If "wtime" > 0 wait "wtime" milliseconds for a character.
;;
;; "tb_change_cnt" is the value of typebuf.tb_change_cnt if "buf" points into it.
;; When typebuf.tb_change_cnt changes (e.g., when a message is received from a remote client)
;; "buf" can no longer be used.  "tb_change_cnt" is null otherwise.

(defn- #_int ui_inchar [#_Bytes buf, #_int maxlen, #_long wtime, #_int tb_change_cnt]
    ;; wtime: don't use "time", MIPS cannot handle it
    (ยง
        ;; If we are going to wait for some time or block...
        (when (or (== wtime -1) (< 100 wtime))
            ;; ... allow signals to kill us.
            (vim_handle_signal SIGNAL_UNBLOCK)
        )

        ((ร int len =) (mch_inchar buf, maxlen, wtime, tb_change_cnt))

        (when (or (== wtime -1) (< 100 wtime))
            ;; block SIGHUP et al.
            (vim_handle_signal SIGNAL_BLOCK)
        )

        len
    ))

;; Delay for the given number of milliseconds.
;; If ignoreinput is false then we cancel the delay if a key is hit.

(defn- #_void ui_delay [#_long msec, #_boolean ignoreinput]
    (mch_delay msec, ignoreinput))

;; If the machine has job control, use it to suspend the program,
;; otherwise fake it by starting a new shell.
;; When running the GUI iconify the window.

(defn- #_void ui_suspend []
    (mch_suspend))

;; Try to get the current Vim shell size.
;; Put the result in Rows and Columns.
;; Use the new sizes as defaults for 'columns' and 'lines'.
;; Return true when size could be determined, false otherwise.

(defn- #_boolean ui_get_shellsize []
    (ยง
        ((ร boolean got =) (mch_get_shellsize))

        (check_shellsize)

        got
    ))

;; Set the size of the Vim shell according to Rows and Columns, if possible.
;; The gui_set_shellsize() or mch_set_shellsize() function will try to set the new size.
;; If this is not possible, it will adjust Rows and Columns.

(defn- #_void ui_set_shellsize [#_boolean _mustset]
    ;; mustset: set by the user
    (mch_set_shellsize))

;; Called when Rows and/or Columns changed.

(defn- #_void ui_new_shellsize []
    (ยง
        (when (and @full_screen (not @exiting))
            (mch_new_shellsize)
        )
    ))

(defn- #_void ui_breakcheck []
    (mch_breakcheck))

;; Functions that handle the input buffer.
;; This is used for any GUI version, and the unix terminal version.
;;
;; For Unix, the input characters are buffered to be able to check for a CTRL-C.
;; This should be done with signals, but I don't know how to do that in a portable way
;; for a tty in RAW mode.
;;
;; For the client-server code in the console the received keys are put in the input buffer.

;; Internal typeahead buffer.
;; Includes extra space for long key code descriptions which would otherwise overflow.
;; The buffer is considered full when only this extra space (or part of it) remains.

(final int INBUFLEN 250)

(final Bytes    inbuf (Bytes. (+ INBUFLEN MAX_KEY_CODE_LEN)))
(atom! int      inbufcount)     ;; number of chars in inbuf[]

(defn- #_boolean is_input_buf_full []
    (<= INBUFLEN @inbufcount))

(defn- #_boolean is_input_buf_empty []
    (zero? @inbufcount))

;; Read as much data from the input buffer as possible up to maxlen, and store it in buf.
;; Note: this function used to be Read() in unix.c

(defn- #_int read_from_input_buf [#_Bytes buf, #_int maxlen]
    (ยง
        (if (zero? @inbufcount)            ;; if the buffer is empty, fill it
            (fill_input_buf true))
        (if (< @inbufcount maxlen)
            ((ร maxlen =) @inbufcount)
        )
        (BCOPY buf, inbuf, maxlen)
        ((ร @inbufcount -=) maxlen)
        (if (non-zero? @inbufcount)
            (BCOPY inbuf, 0, inbuf, maxlen, @inbufcount))
        maxlen
    ))

(atom! boolean did_read_something)
(atom! Bytes fib__rest)    ;; unconverted rest of previous read
(atom! int fib__restlen)

(defn- #_void fill_input_buf [#_boolean exit_on_error]
    (ยง
        (if (is_input_buf_full)
            (ร RETURN)
        )

        ;; Fill_input_buf() is only called when we really need a character.
        ;; If we can't get any, but there is some in the buffer, just return.
        ;; If we can't get any, and there isn't any in the buffer, we give up and exit Vim.

        (ร int unconverted)

        (cond (non-nil? @fib__rest)
        (ยง
            ;; Use remainder of previous call, starts with an invalid character
            ;; that may become valid when reading more.
            (if (> @fib__restlen (- INBUFLEN @inbufcount))
                ((ร unconverted =) (- INBUFLEN @inbufcount))
                ((ร unconverted =) @fib__restlen)
            )
            (BCOPY inbuf, @inbufcount, @fib__rest, 0, unconverted)
            (cond (== unconverted @fib__restlen)
            (ยง
                (reset! fib__rest null)
            )
            :else
            (ยง
                ((ร @fib__restlen -=) unconverted)
                (BCOPY @fib__rest, 0, @fib__rest, unconverted, @fib__restlen)
            ))
            ((ร @inbufcount +=) unconverted)
        )
        :else
        (ยง
            ((ร unconverted =) 0)
        ))

        ((ร int len =) 0)

        ((ร FOR) (ร (ยง int round = 0) (< round 100) (ยง round++))
            ((ร len =) (ยง (int)libC.read(@read_cmd_fd, inbuf.plus(@inbufcount), INBUFLEN - @inbufcount)))

            (if (or (< 0 len) @got_int)
                (ร BREAK)
            )

            ;; If reading stdin results in an error, continue reading stderr.
            ;; This helps when using "foo | xargs vim".

            (when (and (not @did_read_something) (== (ยง libc.isatty(@read_cmd_fd)) 0) (zero? @read_cmd_fd))
                ((ร int m =) @cur_tmode)

                ;; We probably set the wrong file descriptor to raw mode.
                ;; Switch back to cooked mode, use another descriptor
                ;; and set the mode to what it was.
                (settmode TMODE_COOK)
                ;; Use stderr for stdin, also works for shell commands.
                (ยง libc.close(0))
                (ยง libc.dup(2))
                (settmode m)
            )
            (if (not exit_on_error)
                (ร RETURN)
            )
        )

        (when (and (<= len 0) (not @got_int))
            (STRCPY @ioBuff, (u8 "Vim: Error reading input, exiting...\n"))
            (preserve_exit)
        )

        (if (< 0 len)
            (reset! did_read_something true))
        (cond @got_int
        (ยง
            ;; Interrupted, pretend a CTRL-C was typed.
            (.be inbuf 0, 3)
            (reset! inbufcount 1)
        )
        :else
        (ยง
            ;; May perform conversion on the input characters.
            ;; Include the unconverted rest of the previous call.
            ;; If there is an incomplete char at the end it is kept for the next
            ;; time, reading more bytes should make conversion possible.
            ;; Don't do this in the unlikely event that the input buffer is too
            ;; small ("fib__rest" still contains more bytes).

            (while (ยง 0 < len--)
                ;; if a CTRL-C was typed, remove it from the buffer and set got_int

                (when (== (.at inbuf @inbufcount) 3)
                    ;; remove everything typed before the CTRL-C
                    (BCOPY inbuf, 0, inbuf, @inbufcount, (+ len 1))
                    (reset! inbufcount 0)
                    (reset! got_int true)
                )
                (swap! inbufcount inc)
            )
        ))
    ))

;; May update the shape of the cursor.

(defn- #_void ui_cursor_shape []
    (ยง
        (term_cursor_shape)

        (conceal_check_cursor_line)
    ))

;; Check bounds for column number

(defn- #_int check_col [#_int col]
    (ยง
        (if (< col 0)
            ((ร RETURN) 0)
        )
        (if (>= col @screenColumns)
            ((ร RETURN) (- @screenColumns 1))
        )

        col
    ))

;; Check bounds for row number

(defn- #_int check_row [#_int row]
    (ยง
        (if (< row 0)
            ((ร RETURN) 0)
        )
        (if (>= row @screenRows)
            ((ร RETURN) (- @screenRows 1))
        )

        row
    ))

;; screen.c: code for displaying on the screen
;;
;; Output to the screen (console, terminal emulator or GUI window) is minimized
;; by remembering what is already on the screen, and only updating the parts
;; that changed.
;;
;; screenLines[off]  Contains a copy of the whole screen, as it is currently
;;                   displayed (excluding text written by external commands).
;; screenAttrs[off]  Contains the associated attributes.
;; lineOffset[row]   Contains the offset into screenLines*[] and screenAttrs[]
;;                   for each line.
;; lineWraps[row]    Flag for each line whether it wraps to the next line.
;;
;; For double-byte characters, two consecutive bytes in screenLines[] can form one character
;; which occupies two display cells.  For UTF-8 a multi-byte character is converted to Unicode
;; and stored in screenLinesUC[].  screenLines[] contains the first byte only.  For an ASCII
;; character without composing chars screenLinesUC[] will be 0 and screenLinesC[][] is not used.
;; When the character occupies two display cells the next byte in screenLines[] is 0.
;; screenLinesC[][] contain up to 'maxcombine' composing characters
;; (drawn on top of the first character).  There is 0 after the last one used.
;;
;; The screen_*() functions write to the screen and handle updating screenLines[].
;;
;; update_screen() is the function that updates all windows and status lines.
;; It is called form the main loop when must_redraw is non-zero.  It may be
;; called from other places when an immediate screen update is needed.
;;
;; The part of the buffer that is displayed in a window is set with:
;; - w_topline (first buffer line in window)
;; - w_topfill (filler lines above the first line)
;; - w_leftcol (leftmost window cell in window),
;; - w_skipcol (skipped window cells of first line)
;;
;; Commands that only move the cursor around in a window, do not need to take
;; action to update the display.  The main loop will check if w_topline is
;; valid and update it (scroll the window) when needed.
;;
;; Commands that scroll a window change w_topline and must call
;; check_cursor() to move the cursor into the visible part of the window, and
;; call redraw_later(VALID) to have the window displayed by update_screen() later.
;;
;; Commands that change text in the buffer must call changed_bytes() or
;; changed_lines() to mark the area that changed and will require updating
;; later.  The main loop will call update_screen(), which will update each
;; window that shows the changed buffer.  This assumes text above the change
;; can remain displayed as it is.  Text after the change may need updating for
;; scrolling, folding and syntax highlighting.
;;
;; Commands that change how a window is displayed (e.g., setting 'list') or
;; invalidate the contents of a window in another way (e.g., change fold
;; settings), must call redraw_later(NOT_VALID) to have the whole window
;; redisplayed by update_screen() later.
;;
;; Commands that change how a buffer is displayed (e.g., setting 'tabstop')
;; must call redraw_curbuf_later(NOT_VALID) to have all the windows for the
;; buffer redisplayed by update_screen() later.
;;
;; Commands that change highlighting and possibly cause a scroll too must call
;; redraw_later(SOME_VALID) to update the whole window but still use scrolling
;; to avoid redrawing everything.  But the length of displayed lines must not
;; change, use NOT_VALID then.
;;
;; Commands that move the window position must call redraw_later(NOT_VALID).
;; TODO: should minimize redrawing by scrolling when possible.
;;
;; Commands that change everything (e.g., resizing the screen) must call
;; redraw_all_later(NOT_VALID) or redraw_all_later(CLEAR).
;;
;; Things that are handled indirectly:
;; - When messages scroll the screen up, msg_scrolled will be set and
;;   update_screen() called to redraw.

(final byte MB_FILLER_CHAR \<)     ;; character used when a double-width character doesn't fit.

;; The attributes that are actually active for writing to the screen.

(atom! int screen_attr)

;; Positioning the cursor is reduced by remembering the last position.
;; Mostly used by windgoto() and screen_char().

;; last known cursor position
(atom! int screen_cur_row)
(atom! int screen_cur_col)

(atom! match_C search_hl    (ยง_match_C))   ;; used for 'hlsearch' highlight matching

;; Buffer for one screen line (characters and attributes).

(atom! Bytes current_ScreenLine)

(final int SEARCH_HL_PRIORITY 0)

;; Ugly global: overrule attribute used by screen_char().
(atom! int screen_char_attr)

;; Redraw the current window later, with update_screen(type).
;; Set must_redraw only if not already set to a higher value.
;; e.g. if must_redraw is CLEAR, type NOT_VALID will do nothing.

(defn- #_void redraw_later [#_int type]
    (redraw_win_later @curwin, type))

(defn- #_void redraw_win_later [#_window_C wp, #_int type]
    (ยง
        (when (< (. wp w_redr_type) type)
            ((ร wp.w_redr_type =) type)
            (if (<= NOT_VALID type)
                ((ร wp.w_lines_valid =) 0)
            )
            (if (< @must_redraw type) ;; must_redraw is the maximum of all windows
                (reset! must_redraw type))
        )
    ))

;; Force a complete redraw later.  Also resets the highlighting.
;; To be used after executing a shell command that messes up the screen.

(defn- #_void redraw_later_clear []
    (ยง
        (redraw_all_later CLEAR)
        ;; Use attributes that is very unlikely to appear in text.
        (reset! screen_attr (ยง HL_BOLD | HL_UNDERLINE | HL_INVERSE))
    ))

;; Mark all windows to be redrawn later.

(defn- #_void redraw_all_later [#_int type]
    (ยง
        ((ร FOR) (ร (ยง window_C wp = @firstwin) (!= wp null) (ยง wp = wp.w_next))
            (redraw_win_later wp, type)
        )
    ))

;; Mark all windows that are editing the current buffer to be updated later.

(defn- #_void redraw_curbuf_later [#_int type]
    (redraw_buf_later @curbuf, type))

(defn- #_void redraw_buf_later [#_buffer_C buf, #_int type]
    (ยง
        ((ร FOR) (ร (ยง window_C wp = @firstwin) (!= wp null) (ยง wp = wp.w_next))
            (when (== @curbuf buf)
                (redraw_win_later wp, type)
            )
        )
    ))

;; Changed something in the current window, at buffer line "lnum", that
;; requires that line and possibly other lines to be redrawn.
;; Used when entering/leaving Insert mode with the cursor on a folded line.
;; Used to remove the "$" from a change command.
;; Note that when also inserting/deleting lines w_redraw_top and w_redraw_bot
;; may become invalid and the whole window will have to be redrawn.

(defn- #_void redrawWinline [#_long lnum]
    (ยง
        (if (or (zero? (. @curwin w_redraw_top)) (> (. @curwin w_redraw_top) lnum))
            ((ร @curwin.w_redraw_top =) lnum)
        )
        (if (or (zero? (. @curwin w_redraw_bot)) (< (. @curwin w_redraw_bot) lnum))
            ((ร @curwin.w_redraw_bot =) lnum)
        )

        (redraw_later VALID)
    ))

;; update all windows that are editing the current buffer

(defn- #_void update_curbuf [#_int type]
    (ยง
        (redraw_curbuf_later type)
        (update_screen type)
    ))

;; update_screen()
;;
;; Based on the current value of curwin.w_topline, transfer a screenfull
;; of stuff from Filemem to screenLines[], and update curwin.w_botline.

(defn- #_void update_screen [#_int type]
    (ยง
        ;; Don't do anything if the screen structures are (not yet) valid.
        (if (not (screen_valid true))
            (ร RETURN)
        )

        (when (non-zero? @must_redraw)
            (if (< type @must_redraw)             ;; use maximal type
                ((ร type =) @must_redraw)
            )

            ;; must_redraw is reset here, so that when we run into some weird
            ;; reason to redraw while busy redrawing (e.g., asynchronous
            ;; scrolling), or update_topline() in win_update() will cause a
            ;; scroll, the screen will be redrawn later or in win_update().
            (reset! must_redraw 0)
        )

        ;; Need to update w_lines[].
        (if (and (zero? (. @curwin w_lines_valid)) (< type NOT_VALID))
            ((ร type =) NOT_VALID)
        )

        ;; Postpone the redrawing when it's not needed and when being called recursively.
        (when (or (not (redrawing)) @updating_screen)
            (redraw_later type)                 ;; remember type for next time
            (reset! must_redraw type)
            (if (< INVERTED_ALL type)
                ((ร @curwin.w_lines_valid =) 0)       ;; don't use w_lines[].wl_size now
            )
            (ร RETURN)
        )

        (reset! updating_screen true)

        ;; if the screen was scrolled up when displaying a message, scroll it down

        (when (non-zero? @msg_scrolled)
            (reset! clear_cmdline true)
            (cond (< (- @Rows 5) @msg_scrolled)        ;; clearing is faster
            (ยง
                ((ร type =) CLEAR)
            )
            (!= type CLEAR)
            (ยง
                (check_for_delay false)
                (if (not (screen_ins_lines 0, 0, @msg_scrolled, (int @Rows), null))
                    ((ร type =) CLEAR)
                )
                ((ร FOR) (ร (ยง window_C wp = @firstwin) (!= wp null) (ยง wp = wp.w_next))
                    (when (< (. wp w_winrow) @msg_scrolled)
                        (cond (and (< @msg_scrolled (+ (. wp w_winrow) (. wp w_height))) (< (. wp w_redr_type) REDRAW_TOP) (< 0 (. wp w_lines_valid)) (== (. wp w_topline) (ยง wp.w_lines[0].wl_lnum)))
                        (ยง
                            ((ร wp.w_upd_rows =) (ยง @msg_scrolled - wp.w_winrow))
                            ((ร wp.w_redr_type =) REDRAW_TOP)
                        )
                        :else
                        (ยง
                            ((ร wp.w_redr_type =) NOT_VALID)
                            (if (ยง wp.w_winrow + wp.w_height + wp.w_status_height <= @msg_scrolled)
                                ((ร wp.w_redr_status =) true)
                            )
                        ))
                    )
                )
                (reset! redraw_cmdline true)
            ))
            (reset! msg_scrolled 0)
            (reset! need_wait_return false)
        )

        ;; reset cmdline_row now (may have been changed temporarily)
        (compute_cmdrow)

        ;; Check for changed highlighting.
        (if @need_highlight_changed
            (highlight_changed))

        (when (== type CLEAR)              ;; first clear screen
            (screenclear)              ;; will reset clear_cmdline
            ((ร type =) NOT_VALID)
        )

        (if @clear_cmdline              ;; going to clear cmdline (done below)
            (check_for_delay false))

        ;; Force redraw when width of 'number' or 'relativenumber' column changes.
        (when (and (< (. @curwin w_redr_type) NOT_VALID) (!= (. @curwin w_nrwidth) (if (or @(.. @curwin w_options wo_nu) @(.. @curwin w_options wo_rnu)) (number_width @curwin) 0)))
            ((ร @curwin.w_redr_type =) NOT_VALID)
        )

        ;; Only start redrawing if there is really something to do.

        (if (== type INVERTED)
            (update_curswant))
        (if (and (< (. @curwin w_redr_type) type) (not (or (and (== type VALID) (ยง @curwin.w_lines[0].wl_valid) (== (. @curwin w_topline) (ยง @curwin.w_lines[0].wl_lnum))) (and (== type INVERTED) @VIsual_active (== (. @curwin w_old_cursor_lnum) (.. @curwin w_cursor lnum)) (== (. @curwin w_old_visual_mode) @VIsual_mode) (non-zero? (& (. @curwin w_valid) VALID_VIRTCOL)) (== (. @curwin w_old_curswant) (. @curwin w_curswant))))))
            ((ร @curwin.w_redr_type =) type)
        )

        ;; Go from top to bottom through the windows, redrawing the ones that need it.

        ((ร boolean did_one =) false)
        ((ร @search_hl.rmm.regprog =) null)

        ((ร FOR) (ร (ยง window_C wp = @firstwin) (!= wp null) (ยง wp = wp.w_next))
            (when (!= (. wp w_redr_type) 0)
                (cursor_off)
                (when (not did_one)
                    ((ร did_one =) true)
                    (start_search_hl)
                )
                (win_update wp)
            )

            ;; redraw status line after the window to minimize cursor movement
            (when (. wp w_redr_status)
                (cursor_off)
                (win_redr_status wp)
            )
        )
        (end_search_hl)

        ;; Reset b_mod_set flags.  Going through all windows is probably faster
        ;; than going through all buffers (there could be many buffers).
        ((ร FOR) (ร (ยง window_C wp = @firstwin) (!= wp null) (ยง wp = wp.w_next))
            ((ร @curbuf.b_mod_set =) false)
        )

        (reset! updating_screen false)

        ;; Clear or redraw the command line.
        ;; Done last, because scrolling may mess up the command line.
        (when (or @clear_cmdline @redraw_cmdline)
            (showmode)
        )
    ))

;; Return true if the cursor line in window "wp" may be concealed, according
;; to the 'concealcursor' option.

(defn- #_boolean conceal_cursor_line [#_window_C wp]
    (ยง
        (if (== (.at @(.. wp w_options wo_cocu) 0) NUL)
            ((ร RETURN) false)
        )

        (ร int c)
        (cond (non-zero? (ยง get_real_state() & VISUAL))
        (ยง
            ((ร c =) (byte \v))
        )
        (non-zero? (& @State INSERT))
        (ยง
            ((ร c =) (byte \i))
        )
        (non-zero? (& @State NORMAL))
        (ยง
            ((ร c =) (byte \n))
        )
        (non-zero? (& @State CMDLINE))
        (ยง
            ((ร c =) (byte \c))
        )
        :else
        (ยง
            ((ร RETURN) false)
        ))

        (non-nil? (vim_strchr @(.. wp w_options wo_cocu), c))
    ))

;; Check if the cursor line needs to be redrawn because of 'concealcursor'.

(defn- #_void conceal_check_cursor_line []
    (ยง
        (when (and (< 0 @(.. @curwin w_options wo_cole)) (conceal_cursor_line @curwin))
            (reset! need_cursor_line_redraw true)
            ;; Need to recompute cursor column, e.g., when starting Visual mode without concealing.
            (curs_columns true)
        )
    ))

(defn- #_void update_single_line [#_window_C wp, #_long lnum]
    (ยง
        (when (and (<= (. wp w_topline) lnum) (< lnum (. wp w_botline)))
            ((ร int row =) 0)
            ((ร FOR) (ร (ยง int j = 0) (ยง j < wp.w_lines_valid) (ยง j++))
                (when (== lnum (ยง wp.w_lines[j].wl_lnum))
                    (screen_start) ;; not sure of screen cursor
                    (init_search_hl wp)
                    (start_search_hl)
                    (prepare_search_hl wp, lnum)
                    (win_line wp, lnum, row, (+ row (ยง wp.w_lines[j].wl_size)), false)
                    (end_search_hl)
                    (ร BREAK)
                )
                ((ร row +=) (ยง wp.w_lines[j].wl_size))
            )
        )

        (reset! need_cursor_line_redraw false)
    ))

(atom! boolean _2_recursive)    ;; being called recursively

;; Update a single window.
;;
;; This may cause the windows below it also to be redrawn (when clearing the
;; screen or scrolling lines).
;;
;; How the window is redrawn depends on wp.w_redr_type.  Each type also
;; implies the one below it.
;; NOT_VALID    redraw the whole window
;; SOME_VALID   redraw the whole window but do scroll when possible
;; REDRAW_TOP   redraw the top w_upd_rows window lines, otherwise like VALID
;; INVERTED     redraw the changed part of the Visual area
;; INVERTED_ALL redraw the whole Visual area
;; VALID        1. scroll up/down to adjust for a changed w_topline
;;              2. update lines at the top when scrolled down
;;              3. redraw changed text:
;;                 - if @curbuf.b_mod_set set, update lines between
;;                   b_mod_top and b_mod_bot.
;;                 - if wp.w_redraw_top non-zero, redraw lines between
;;                   wp.w_redraw_top and wp.w_redr_bot.
;;                 - continue redrawing when syntax status is invalid.
;;              4. if scrolled up, update lines at the bottom.
;; This results in three areas that may need updating:
;; top: from first row to top_end (when scrolled down)
;; mid: from mid_start to mid_end (update inversion or changed text)
;; bot: from bot_start to last row (when scrolled up)

(final int
    DID_NONE 1,     ;; didn't update a line
    DID_LINE 2,     ;; updated a normal line
    DID_FOLD 3)     ;; updated a folded line

(defn- #_void win_update [#_window_C wp]
    (ยง
        ((ร buffer_C buf =) @curbuf)

        ((ร int top_end =) 0)                    ;; Below last row of the top area that needs updating.  0 when no top area updating.
        ((ร int mid_start =) 999)                ;; First row of the mid area that needs updating.     999 when no mid area updating.
        ((ร int mid_end =) 0)                    ;; Below last row of the mid area that needs updating.  0 when no mid area updating.
        ((ร int bot_start =) 999)                ;; First row of the bot area that needs updating.     999 when no bot area updating.

        ((ร boolean scrolled_down =) false)      ;; true when scrolled down when w_topline got smaller a bit
        ((ร boolean top_to_mod =) false)         ;; redraw above mod_top

        ((ร boolean eof =) false)                ;; if true, we hit the end of the file
        ((ร boolean didline =) false)            ;; if true, we finished the last line

        ((ร long old_botline =) (. wp w_botline))

        ;; remember what happened to the previous line,
        ;; to know if check_visual_highlight() can be used

        ((ร int did_update =) DID_NONE)

        ((ร long mod_top =) 0)
        ((ร long mod_bot =) 0)

        ((ร int type =) (. wp w_redr_type))

        (when (== type NOT_VALID)
            ((ร wp.w_redr_status =) true)
            ((ร wp.w_lines_valid =) 0)
        )

        ;; Window is zero-height: nothing to draw.
        (when (zero? (. wp w_height))
            ((ร wp.w_redr_type =) 0)
            (ร RETURN)
        )

        ;; Window is zero-width: Only need to draw the separator.
        (when (zero? (. wp w_width))
            ;; draw the vertical separator right of this window
            (draw_vsep_win wp, 0)
            ((ร wp.w_redr_type =) 0)
            (ร RETURN)
        )

        (init_search_hl wp)

        ;; Force redraw when width of 'number' or 'relativenumber' column changes.
        ((ร int i =) (if (or @(.. wp w_options wo_nu) @(.. wp w_options wo_rnu)) (number_width wp) 0))
        (cond (!= (. wp w_nrwidth) i)
        (ยง
            ((ร type =) NOT_VALID)
            ((ร wp.w_nrwidth =) i)
        )
        (and (. buf b_mod_set) (!= (. buf b_mod_xlines) 0) (!= (. wp w_redraw_top) 0))
        (ยง
            ;; When there are both inserted/deleted lines and specific lines to be
            ;; redrawn, w_redraw_top and w_redraw_bot may be invalid, just redraw
            ;; everything (only happens when redrawing is off for while).

            ((ร type =) NOT_VALID)
        )
        :else
        (ยง
            ;; Set mod_top to the first line that needs displaying because of changes.
            ;; Set mod_bot to the first line after the changes.

            ((ร mod_top =) (. wp w_redraw_top))
            (if (!= (. wp w_redraw_bot) 0)
                ((ร mod_bot =) (ยง wp.w_redraw_bot + 1))
                ((ร mod_bot =) 0)
            )
            ((ร wp.w_redraw_top =) 0)    ;; reset for next time
            ((ร wp.w_redraw_bot =) 0)
            (when (. buf b_mod_set)
                (if (or (zero? mod_top) (< (. buf b_mod_top) mod_top))
                    ((ร mod_top =) (. buf b_mod_top))
                )
                (if (or (zero? mod_bot) (< mod_bot (. buf b_mod_bot)))
                    ((ร mod_bot =) (. buf b_mod_bot))
                )

                ;; When 'hlsearch' is on and using a multi-line search pattern,
                ;; a change in one line may make the Search highlighting in a previous line invalid.
                ;; Simple solution: redraw all visible lines above the change.
                ;; Same for a match pattern.

                (cond (and (!= (.. @search_hl rmm regprog) null) (re_multiline (.. @search_hl rmm regprog)))
                (ยง
                    ((ร top_to_mod =) true)
                )
                :else
                (ยง
                    ((ร FOR) (ร (ยง matchitem_C mi = wp.w_match_head) (!= mi null) (ยง mi = mi.next))
                        (when (and (!= (.. mi mi_match regprog) null) (re_multiline (.. mi mi_match regprog)))
                            ((ร top_to_mod =) true)
                            (ร BREAK)
                        )
                    )
                ))
            )

            ;; When a change starts above w_topline and the end is below w_topline,
            ;; start redrawing at w_topline.
            ;; If the end of the change is above w_topline: do like no change was made,
            ;; but redraw the first line to find changes in syntax.
            (when (and (non-zero? mod_top) (< mod_top (. wp w_topline)))
                (if (> mod_bot (. wp w_topline))
                    ((ร mod_top =) (. wp w_topline))
                )
            )

            ;; When line numbers are displayed, need to redraw all lines below
            ;; inserted/deleted lines.
            (if (and (non-zero? mod_top) (!= (. buf b_mod_xlines) 0) @(.. wp w_options wo_nu))
                ((ร mod_bot =) MAXLNUM)
            )
        ))

        ;; When only displaying the lines at the top, set top_end.
        ;; Used when window has scrolled down for msg_scrolled.

        (when (== type REDRAW_TOP)
            ((ร int j =) 0)
            ((ร FOR) (ร (ยง i = 0) (ยง i < wp.w_lines_valid) (ยง i++))
                ((ร j +=) (ยง wp.w_lines[i].wl_size))
                (when (<= (. wp w_upd_rows) j)
                    ((ร top_end =) j)
                    (ร BREAK)
                )
            )
            (cond (zero? top_end)
            (ยง
                ;; not found (cannot happen?): redraw everything
                ((ร type =) NOT_VALID)
            )
            :else
            (ยง
                ;; top area defined, the rest is VALID
                ((ร type =) VALID)
            ))
        )

        ;; Trick: we want to avoid clearing the screen twice.  screenclear() will set
        ;; "screen_cleared" to true.  The special value MAYBE (which is still non-zero
        ;; and thus not false) will indicate that screenclear() was not called.
        (if (!= @screen_cleared FALSE)
            (reset! screen_cleared MAYBE))

        ;; If there are no changes on the screen that require a complete redraw,
        ;; handle three cases:
        ;; 1: we are off the top of the screen by a few lines: scroll down
        ;; 2: wp.w_topline is below wp.w_lines[0].wl_lnum: may scroll up
        ;; 3: wp.w_topline is wp.w_lines[0].wl_lnum: find first entry in w_lines[] that needs updating.

        (cond (or (== type VALID) (== type SOME_VALID) (== type INVERTED) (== type INVERTED_ALL))
        (ยง
            (cond (and (non-zero? mod_top) (== (. wp w_topline) mod_top))
            (ยง
                ;; w_topline is the first changed line, the scrolling will be done further down.
            )
            (and (ยง wp.w_lines[0].wl_valid) (< (. wp w_topline) (ยง wp.w_lines[0].wl_lnum)))
            (ยง
                ;; New topline is above old topline: may scroll down.
                ((ร int j =) (ยง (int)(wp.w_lines[0].wl_lnum - wp.w_topline)))

                (cond (< j (- (. wp w_height) 2))        ;; not too far off
                (ยง
                    ((ร i =) (ยง plines_m_win(wp, wp.w_topline, wp.w_lines[0].wl_lnum - 1)))

                    (cond (< i (- (. wp w_height) 2))    ;; less than a screen off
                    (ยง
                        ;; Try to insert the correct number of lines.
                        ;; If not the last window, delete the lines at the bottom.
                        ;; win_ins_lines may fail when the terminal can't do it.

                        (if (< 0 i)
                            (check_for_delay false))
                        (cond (win_ins_lines wp, 0, i, false, (== wp @firstwin))
                        (ยง
                            (when (!= (. wp w_lines_valid) 0)
                                ;; Need to update rows that are new,
                                ;; stop at the first one that scrolled down.
                                ((ร top_end =) i)
                                ((ร scrolled_down =) true)

                                ;; Move the entries that were scrolled,
                                ;; disable the entries for the lines to be redrawn.
                                (if (ยง (wp.w_lines_valid += j) > wp.w_height)
                                    ((ร wp.w_lines_valid =) (. wp w_height))
                                )
                                (ร int idx)
                                ((ร FOR) (ร (ยง idx = wp.w_lines_valid) (ยง 0 <= idx - j) (ยง --idx))
                                    (COPY_wline (ยง wp.w_lines[idx]), (ยง wp.w_lines[idx - j]))
                                )
                                (while (<= 0 idx)
                                    ((ร wp.w_lines[idx--].wl_valid =) false)
                                )
                            )
                        )
                        :else
                        (ยง
                            ((ร mid_start =) 0)          ;; redraw all lines
                        ))
                    )
                    :else
                    (ยง
                        ((ร mid_start =) 0)              ;; redraw all lines
                    ))
                )
                :else
                (ยง
                    ((ร mid_start =) 0)                  ;; redraw all lines
                ))
            )
            :else
            (ยง
                ;; New topline is at or below old topline: May scroll up.
                ;; When topline didn't change, find first entry in w_lines[] that needs updating.

                ;; try to find wp.w_topline in wp.w_lines[].wl_lnum
                ((ร int j =) -1)
                ((ร int row =) 0)
                ((ร FOR) (ร (ยง i = 0) (ยง i < wp.w_lines_valid) (ยง i++))
                    (when (and (ยง wp.w_lines[i].wl_valid) (== (ยง wp.w_lines[i].wl_lnum) (. wp w_topline)))
                        ((ร j =) i)
                        (ร BREAK)
                    )
                    ((ร row +=) (ยง wp.w_lines[i].wl_size))
                )
                (cond (== j -1)
                (ยง
                    ;; if wp.w_topline is not in wp.w_lines[].wl_lnum redraw all lines
                    ((ร mid_start =) 0)
                )
                :else
                (ยง
                    ;; Try to delete the correct number of lines.
                    ;; wp.w_topline is at wp.w_lines[i].wl_lnum.

                    (when (< 0 row)
                        (check_for_delay false)
                        (if (win_del_lines wp, 0, row, false, (== wp @firstwin))
                            ((ร bot_start =) (ยง wp.w_height - row))
                            ((ร mid_start =) 0)          ;; redraw all lines
                        )
                    )
                    (when (and (or (zero? row) (< bot_start 999)) (!= (. wp w_lines_valid) 0))
                        ;; Skip the lines (below the deleted lines) that are still valid and
                        ;; don't need redrawing.  Copy their info upwards, to compensate for the
                        ;; deleted lines.  Set bot_start to the first row that needs redrawing.

                        ((ร bot_start =) 0)
                        ((ร int idx =) 0)                ;; current index in w_lines[]
                        (while true
                            (COPY_wline (ยง wp.w_lines[idx]), (ยง wp.w_lines[j]))
                            ;; stop at line that didn't fit,
                            ;; unless it is still valid (no lines deleted)
                            (when (and (< 0 row) (< (. wp w_height) (ยง bot_start + row + wp.w_lines[j].wl_size)))
                                ((ร wp.w_lines_valid =) (+ idx 1))
                                (ร BREAK)
                            )
                            ((ร bot_start +=) (ยง wp.w_lines[idx++].wl_size))

                            ;; stop at the last valid entry in w_lines[].wl_size
                            (when (<= (. wp w_lines_valid) (ยง ++j))
                                ((ร wp.w_lines_valid =) idx)
                                (ร BREAK)
                            )
                        )
                    )
                ))
            ))

            ;; When starting redraw in the first line, redraw all lines.
            ;; When there is only one window it's probably faster to clear the screen first.
            (when (zero? mid_start)
                ((ร mid_end =) (. wp w_height))
                (when (== @lastwin @firstwin)
                    ;; Clear the screen when it was not done by win_del_lines() or
                    ;; win_ins_lines() above, "screen_cleared" is false or MAYBE then.
                    (if (!= @screen_cleared TRUE)
                        (screenclear))
                )
            )

            ;; When win_del_lines() or win_ins_lines() caused the screen to be
            ;; cleared (only happens for the first window) or when screenclear()
            ;; was called directly above, "must_redraw" will have been set to
            ;; NOT_VALID, need to reset it here to avoid redrawing twice.
            (if (== @screen_cleared TRUE)
                (reset! must_redraw 0))
        )
        :else
        (ยง
            ;; Not VALID or INVERTED: redraw all lines.
            ((ร mid_start =) 0)
            ((ร mid_end =) (. wp w_height))
        ))

        (when (== type SOME_VALID)
            ;; SOME_VALID: redraw all lines.
            ((ร mid_start =) 0)
            ((ร mid_end =) (. wp w_height))
            ((ร type =) NOT_VALID)
        )

        ;; check if we are updating or removing the inverted part
        (when (or @VIsual_active (and (!= (. wp w_old_cursor_lnum) 0) (!= type NOT_VALID)))
            (ร long from, to)

            (cond @VIsual_active
            (ยง
                (cond (and @VIsual_active (or (!= @VIsual_mode (. wp w_old_visual_mode)) (== type INVERTED_ALL)))
                (ยง
                    ;; If the type of Visual selection changed, redraw the whole selection.
                    ;; Also when the ownership of the X selection is gained or lost.

                    (cond (< (.. @curwin w_cursor lnum) (. @VIsual lnum))
                    (ยง
                        ((ร from =) (.. @curwin w_cursor lnum))
                        ((ร to =) (. @VIsual lnum))
                    )
                    :else
                    (ยง
                        ((ร from =) (. @VIsual lnum))
                        ((ร to =) (.. @curwin w_cursor lnum))
                    ))
                    ;; redraw more when the cursor moved as well
                    (if (< (. wp w_old_cursor_lnum) from)
                        ((ร from =) (. wp w_old_cursor_lnum))
                    )
                    (if (< to (. wp w_old_cursor_lnum))
                        ((ร to =) (. wp w_old_cursor_lnum))
                    )
                    (if (< (. wp w_old_visual_lnum) from)
                        ((ร from =) (. wp w_old_visual_lnum))
                    )
                    (if (< to (. wp w_old_visual_lnum))
                        ((ร to =) (. wp w_old_visual_lnum))
                    )
                )
                :else
                (ยง
                    ;; Find the line numbers that need to be updated: The lines
                    ;; between the old cursor position and the current cursor
                    ;; position.  Also check if the Visual position changed.

                    (cond (< (.. @curwin w_cursor lnum) (. wp w_old_cursor_lnum))
                    (ยง
                        ((ร from =) (.. @curwin w_cursor lnum))
                        ((ร to =) (. wp w_old_cursor_lnum))
                    )
                    :else
                    (ยง
                        ((ร from =) (. wp w_old_cursor_lnum))
                        ((ร to =) (.. @curwin w_cursor lnum))
                        (if (zero? from)              ;; Visual mode just started
                            ((ร from =) to)
                        )
                    ))

                    (when (or (!= (. @VIsual lnum) (. wp w_old_visual_lnum)) (!= (. @VIsual col) (. wp w_old_visual_col)))
                        (if (and (< (. wp w_old_visual_lnum) from) (!= (. wp w_old_visual_lnum) 0))
                            ((ร from =) (. wp w_old_visual_lnum))
                        )
                        (if (< to (. wp w_old_visual_lnum))
                            ((ร to =) (. wp w_old_visual_lnum))
                        )
                        (if (< (. @VIsual lnum) from)
                            ((ร from =) (. @VIsual lnum))
                        )
                        (if (< to (. @VIsual lnum))
                            ((ร to =) (. @VIsual lnum))
                        )
                    )
                ))

                ;; If in block mode and changed column or curwin.w_curswant: update all lines.
                ;; First compute the actual start and end column.

                (when (== @VIsual_mode Ctrl_V)
                    ((ร int[] fromc =) (ยง new int[1]))
                    ((ร int[] toc =) (ยง new int[1]))
                    ((ร int save_ve_flags =) @ve_flags)

                    (if @(.. @curwin w_options wo_lbr)
                        (reset! ve_flags VE_ALL))
                    (getvcols wp, @VIsual, (. @curwin w_cursor), fromc, toc)
                    (reset! ve_flags save_ve_flags)
                    (ยง toc[0]++)
                    (if (== (. @curwin w_curswant) MAXCOL)
                        ((ร toc[0] =) MAXCOL)
                    )

                    (when (or (!= (ยง fromc[0]) (. wp w_old_cursor_fcol)) (!= (ยง toc[0]) (. wp w_old_cursor_lcol)))
                        (if (< (. @VIsual lnum) from)
                            ((ร from =) (. @VIsual lnum))
                        )
                        (if (< to (. @VIsual lnum))
                            ((ร to =) (. @VIsual lnum))
                        )
                    )
                    ((ร wp.w_old_cursor_fcol =) (ยง fromc[0]))
                    ((ร wp.w_old_cursor_lcol =) (ยง toc[0]))
                )
            )
            :else
            (ยง
                ;; Use the line numbers of the old Visual area.
                (cond (< (. wp w_old_cursor_lnum) (. wp w_old_visual_lnum))
                (ยง
                    ((ร from =) (. wp w_old_cursor_lnum))
                    ((ร to =) (. wp w_old_visual_lnum))
                )
                :else
                (ยง
                    ((ร from =) (. wp w_old_visual_lnum))
                    ((ร to =) (. wp w_old_cursor_lnum))
                ))
            ))

            ;; There is no need to update lines above the top of the window.

            (if (< from (. wp w_topline))
                ((ร from =) (. wp w_topline))
            )

            ;; If we know the value of w_botline,
            ;; use it to restrict the update to the lines that are visible in the window.

            (when (non-zero? (& (. wp w_valid) VALID_BOTLINE))
                (if (>= from (. wp w_botline))
                    ((ร from =) (ยง wp.w_botline - 1))
                )
                (if (>= to (. wp w_botline))
                    ((ร to =) (ยง wp.w_botline - 1))
                )
            )

            ;; Find the minimal part to be updated.
            ;; Watch out for scrolling that made entries in w_lines[] invalid.
            ;; E.g., CTRL-U makes the first half of w_lines[] invalid and sets top_end;
            ;; need to redraw from top_end to the "to" line.
            ;; A middle mouse click with a Visual selection may change the text above
            ;; the Visual area and reset wl_valid, do count these for mid_end (in srow).

            (when (< 0 mid_start)
                ((ร long lnum =) (. wp w_topline))       ;; current buffer lnum to display
                ((ร int idx =) 0)                    ;; current index in w_lines[]
                ((ร int srow =) 0)                   ;; starting row of the current line
                (if scrolled_down
                    ((ร mid_start =) top_end)
                    ((ร mid_start =) 0)
                )
                (while (ยง lnum < from && idx < wp.w_lines_valid)   ;; find start
                    (cond (ยง wp.w_lines[idx].wl_valid)
                    (ยง
                        ((ร mid_start +=) (ยง wp.w_lines[idx].wl_size))
                    )
                    (not scrolled_down)
                    (ยง
                        ((ร srow +=) (ยง wp.w_lines[idx].wl_size))
                    ))
                    (ยง idx++)
                    (ยง lnum++)
                )
                ((ร srow +=) mid_start)
                ((ร mid_end =) (. wp w_height))
                ((ร FOR) (ร (ยง  ) (ยง idx < wp.w_lines_valid) (ยง idx++))          ;; find end
                    (when (and (ยง wp.w_lines[idx].wl_valid) (ยง to + 1 <= wp.w_lines[idx].wl_lnum))
                        ;; Only update until first row of this line.
                        ((ร mid_end =) srow)
                        (ร BREAK)
                    )
                    ((ร srow +=) (ยง wp.w_lines[idx].wl_size))
                )
            )
        )

        (cond @VIsual_active
        (ยง
            ((ร wp.w_old_visual_mode =) @VIsual_mode)
            ((ร wp.w_old_cursor_lnum =) (.. @curwin w_cursor lnum))
            ((ร wp.w_old_visual_lnum =) (. @VIsual lnum))
            ((ร wp.w_old_visual_col =) (. @VIsual col))
            ((ร wp.w_old_curswant =) (. @curwin w_curswant))
        )
        :else
        (ยง
            ((ร wp.w_old_visual_mode =) 0)
            ((ร wp.w_old_cursor_lnum =) 0)
            ((ร wp.w_old_visual_lnum =) 0)
            ((ร wp.w_old_visual_col =) 0)
        ))

        ;; reset got_int, otherwise regexp won't work
        ((ร boolean save_got_int =) @got_int)
        (reset! got_int false)

        ;; Update all the window rows.

        ((ร int idx =) 0)                    ;; first entry in w_lines[].wl_size
        ((ร int row =) 0)                    ;; current window row to display
        ((ร int srow =) 0)                   ;; starting row of the current line
        ((ร long lnum =) (. wp w_topline))       ;; first line shown in window
        (while true
            ;; stop updating when reached the end of the window
            ;; (check for _past_ the end of the window is at the end of the loop)
            (when (== row (. wp w_height))
                ((ร didline =) true)
                (ร BREAK)
            )

            ;; stop updating when hit the end of the file
            (when (< (.. buf b_ml ml_line_count) lnum)
                ((ร eof =) true)
                (ร BREAK)
            )

            ;; Remember the starting row of the line that is going to be dealt with.
            ;; It is used further down when the line doesn't fit.
            ((ร srow =) row)

            ;; Update a line when it is in an area that needs updating,
            ;; when it has changes or w_lines[idx] is invalid.
            ;; bot_start may be halfway a wrapped line after using win_del_lines(),
            ;; check if the current line includes it.
            ;; When syntax folding is being used, the saved syntax states will
            ;; already have been updated, we can't see where the syntax state is
            ;; the same again, just update until the end of the window.

                                    ;; match in fixed position might need redraw
                                    ;; if lines were inserted or deleted
            (cond (ยง row < top_end || (mid_start <= row && row < mid_end) || top_to_mod || wp.w_lines_valid <= idx || (bot_start < row + wp.w_lines[idx].wl_size) || (mod_top != 0 && (lnum == mod_top || (mod_top <= lnum && (lnum < mod_bot || did_update == DID_FOLD || (wp.w_match_head != null && buf.b_mod_xlines != 0))))))
            (ยง
                (if (== lnum mod_top)
                    ((ร top_to_mod =) false)
                )

                ;; When at start of changed lines:
                ;; may scroll following lines up or down to minimize redrawing.
                ;; Don't do this when the change continues until the end.

                (when (and (== lnum mod_top) (!= mod_bot MAXLNUM))
                    ((ร int old_rows =) 0)
                    ((ร int new_rows =) 0)
                    (ร int xtra_rows)
                    (ร long l)

                    ;; Count the old number of window rows, using w_lines[], which should
                    ;; still contain the sizes for the lines as they are currently displayed.

                    ((ร FOR) (ร (ยง i = idx) (ยง i < wp.w_lines_valid) (ยง i++))
                        ;; Only valid lines have a meaningful wl_lnum.
                        ;; Invalid lines are part of the changed area.
                        (if (and (ยง wp.w_lines[i].wl_valid) (== (ยง wp.w_lines[i].wl_lnum) mod_bot))
                            (ร BREAK)
                        )
                        ((ร old_rows +=) (ยง wp.w_lines[i].wl_size))
                    )

                    (cond (<= (. wp w_lines_valid) i)
                    (ยง
                        ;; We can't find a valid line below the changed lines,
                        ;; need to redraw until the end of the window.
                        ;; Inserting/deleting lines has no use.
                        ((ร bot_start =) 0)
                    )
                    :else
                    (ยง
                        ;; Able to count old number of rows:
                        ;; count new window rows, and may insert/delete lines.
                        ((ร int j =) idx)
                        ((ร FOR) (ร (ยง l = lnum) (< l mod_bot) (ยง l++))
                            ((ร new_rows +=) (plines_win wp, l, true))
                            (ยง j++)
                            (when (ยง wp.w_height - row - 2 < new_rows)
                                ;; it's getting too much, must redraw the rest
                                ((ร new_rows =) 9999)
                                (ร BREAK)
                            )
                        )
                        ((ร xtra_rows =) (- new_rows old_rows))
                        (cond (< xtra_rows 0)
                        (ยง
                            ;; May scroll text up.
                            ;; If there is not enough remaining text or scrolling fails,
                            ;; must redraw the rest.
                            ;; If scrolling works,
                            ;; must redraw the text below the scrolled text.
                            (cond (ยง wp.w_height - 2 <= row - xtra_rows)
                            (ยง
                                ((ร mod_bot =) MAXLNUM)
                            )
                            :else
                            (ยง
                                (check_for_delay false)
                                (if (not (win_del_lines wp, row, (- xtra_rows), false, false))
                                    ((ร mod_bot =) MAXLNUM)
                                    ((ร bot_start =) (ยง wp.w_height + xtra_rows))
                                )
                            ))
                        )
                        (< 0 xtra_rows)
                        (ยง
                            ;; May scroll text down.
                            ;; If there is not enough remaining text of scrolling fails,
                            ;; must redraw the rest.
                            (cond (ยง wp.w_height - 2 <= row + xtra_rows)
                            (ยง
                                ((ร mod_bot =) MAXLNUM)
                            )
                            :else
                            (ยง
                                (check_for_delay false)
                                (cond (not (win_ins_lines wp, (+ row old_rows), xtra_rows, false, false))
                                (ยง
                                    ((ร mod_bot =) MAXLNUM)
                                )
                                (< (+ row old_rows) top_end)
                                (ยง
                                    ;; Scrolled the part at the top that requires updating down.
                                    ((ร top_end +=) xtra_rows)
                                ))
                            ))
                        ))

                        ;; When not updating the rest, may need to move w_lines[] entries.
                        (when (and (!= mod_bot MAXLNUM) (!= i j))
                            (cond (< j i)
                            (ยง
                                ((ร int x =) (+ row new_rows))

                                ;; move entries in w_lines[] upwards
                                (while true
                                    ;; stop at last valid entry in w_lines[]
                                    (when (<= (. wp w_lines_valid) i)
                                        ((ร wp.w_lines_valid =) j)
                                        (ร BREAK)
                                    )
                                    (COPY_wline (ยง wp.w_lines[j]), (ยง wp.w_lines[i]))
                                    ;; stop at a line that won't fit
                                    (when (< (. wp w_height) (+ x (ยง wp.w_lines[j].wl_size)))
                                        ((ร wp.w_lines_valid =) (+ j 1))
                                        (ร BREAK)
                                    )
                                    ((ร x +=) (ยง wp.w_lines[j++].wl_size))
                                    (ยง i++)
                                )
                                (if (< x bot_start)
                                    ((ร bot_start =) x)
                                )
                            )
                            :else ;; j > i
                            (ยง
                                ;; move entries in w_lines[] downwards
                                ((ร j -=) i)
                                ((ร wp.w_lines_valid +=) j)
                                (if (> (. wp w_lines_valid) (. wp w_height))
                                    ((ร wp.w_lines_valid =) (. wp w_height))
                                )
                                ((ร FOR) (ร (ยง i = wp.w_lines_valid) (ยง idx <= i - j) (ยง --i))
                                    (COPY_wline (ยง wp.w_lines[i]), (ยง wp.w_lines[i - j]))
                                )

                                ;; The w_lines[] entries for inserted lines are now invalid,
                                ;; but wl_size may be used above.
                                ;; Reset to zero.
                                (while (<= idx i)
                                    ((ร wp.w_lines[i].wl_size =) 0)
                                    ((ร wp.w_lines[i--].wl_valid =) false)
                                )
                            ))
                        )
                    ))
                )

                (cond (ยง idx < wp.w_lines_valid && wp.w_lines[idx].wl_valid && wp.w_lines[idx].wl_lnum == lnum && wp.w_topline < lnum && (@dy_flags & DY_LASTLINE) == 0 && wp.w_height < srow + wp.w_lines[idx].wl_size)
                (ยง
                    ;; This line is not going to fit.
                    ;; Don't draw anything here, will draw "@  " lines below.
                    ((ร row =) (ยง wp.w_height + 1))
                )
                :else
                (ยง
                    (prepare_search_hl wp, lnum)

                    ;; Display one line.

                    ((ร row =) (ยง win_line(wp, lnum, srow, wp.w_height, mod_top == 0)))

                    ((ร did_update =) DID_LINE)
                ))

                ((ร wp.w_lines[idx].wl_lnum =) lnum)
                ((ร wp.w_lines[idx].wl_valid =) true)
                (when (< (. wp w_height) row)              ;; past end of screen
                    ;; we may need the size of that too long line later on
                    ((ร wp.w_lines[idx].wl_size =) (plines_win wp, lnum, true))
                    (ยง idx++)
                    (ร BREAK)
                )
                ((ร wp.w_lines[idx].wl_size =) (- row srow))
                (ยง idx++)
                (ยง lnum++)
            )
            :else
            (ยง
                ;; This line does not need updating, advance to the next one.
                ((ร row +=) (ยง wp.w_lines[idx++].wl_size))
                (if (< (. wp w_height) row)              ;; past end of screen
                    (ร BREAK)
                )
                (ยง lnum++)
                ((ร did_update =) DID_NONE)
            ))

            (when (< (.. buf b_ml ml_line_count) lnum)
                ((ร eof =) true)
                (ร BREAK)
            )
        )

        ;; End of loop over all window lines.

        (if (< (. wp w_lines_valid) idx)
            ((ร wp.w_lines_valid =) idx)
        )

        ;; If we didn't hit the end of the file, and we didn't finish the last
        ;; line we were working on, then the line didn't fit.

        ((ร wp.w_empty_rows =) 0)
        (cond (and (not eof) (not didline))
        (ยง
            (cond (== lnum (. wp w_topline))
            (ยง
                ;; Single line that does not fit!
                ;; Don't overwrite it, it can be edited.

                ((ร wp.w_botline =) (+ lnum 1))
            )
            (non-zero? (& @dy_flags DY_LASTLINE))     ;; 'display' has "lastline"
            (ยง
                ;; Last line isn't finished: Display "@@@" at the end.

                (ยง screen_fill(wp.w_winrow + wp.w_height - 1, wp.w_winrow + wp.w_height, wp.w_wincol + wp.w_width - 3, wp.w_wincol + wp.w_width, (byte \@), (byte \@), hl_attr(HLF_AT)))
                (set_empty_rows wp, srow)
                ((ร wp.w_botline =) lnum)
            )
            :else
            (ยง
                (win_draw_end wp, (byte \@), (byte \space), srow, (. wp w_height), HLF_AT)
                ((ร wp.w_botline =) lnum)
            ))
        )
        :else
        (ยง
            (draw_vsep_win wp, row)
            (cond eof                                ;; we hit the end of the file
            (ยง
                ((ร wp.w_botline =) (ยง buf.b_ml.ml_line_count + 1))
            )
            :else
            (ยง
                ((ร wp.w_botline =) lnum)
            ))

            ;; Make sure the rest of the screen is blank,
            ;; put '~'s on rows that aren't part of the file.
            (win_draw_end wp, (byte \~), (byte \space), row, (. wp w_height), HLF_AT)
        ))

        ;; Reset the type of redrawing required, the window has been updated.
        ((ร wp.w_redr_type =) 0)

        ;; There is a trick with w_botline.  If we invalidate it on each
        ;; change that might modify it, this will cause a lot of expensive
        ;; calls to plines() in update_topline() each time.  Therefore the
        ;; value of w_botline is often approximated, and this value is used to
        ;; compute the value of w_topline.  If the value of w_botline was
        ;; wrong, check that the value of w_topline is correct (cursor is on
        ;; the visible part of the text).  If it's not, we need to redraw
        ;; again.  Mostly this just means scrolling up a few lines, so it
        ;; doesn't look too bad.  Only do this for the current window (where
        ;; changes are relevant).

        ((ร wp.w_valid |=) VALID_BOTLINE)
        (when (and (== wp @curwin) (!= (. wp w_botline) old_botline) (not @_2_recursive))
            (reset! _2_recursive true)
            ((ร @curwin.w_valid &=) (ยง ~VALID_TOPLINE))
            (update_topline)   ;; may invalidate w_botline again
            (when (non-zero? @must_redraw)
                ;; Don't update for changes in buffer again.
                ((ร boolean b =) (. @curbuf b_mod_set))
                ((ร @curbuf.b_mod_set =) false)
                (win_update @curwin)
                (reset! must_redraw 0)
                ((ร @curbuf.b_mod_set =) b)
            )
            (reset! _2_recursive false)
        )

        ;; restore got_int, unless CTRL-C was hit while redrawing
        (when (not @got_int)
            (reset! got_int save_got_int)
        )
    ))

;; Clear the rest of the window and mark the unused lines with "c1".
;; Use "c2" as the filler character.

(defn- #_void win_draw_end [#_window_C wp, #_int c1, #_int c2, #_int row, #_int endrow, #_int hl]
    (ยง
        ((ร int n =) 0)

        (when (and (non-zero? @cmdwin_type) (== wp @curwin))
            ;; draw the cmdline character in the leftmost column
            ((ร n =) 1)
            (if (> n (. wp w_width))
                ((ร n =) (. wp w_width))
            )
            (screen_fill (+ (. wp w_winrow) row), (+ (. wp w_winrow) endrow), (. wp w_wincol), (+ (. wp w_wincol) n), @cmdwin_type, (byte \space), (hl_attr HLF_AT))
        )
        (screen_fill (+ (. wp w_winrow) row), (+ (. wp w_winrow) endrow), (+ (. wp w_wincol) n), (+ (. wp w_wincol) (. wp w_width)), c1, c2, (hl_attr hl))

        (set_empty_rows wp, row)
    ))

;; Advance **color_cols and return true when there are columns to draw.

(defn- #_boolean advance_color_col [#_int vcol, #_int* color_cols, #_int* cci]
    (ยง
        (while (ยง 0 <= color_cols[cci[0]] && color_cols[cci[0]] < vcol)
            (ยง cci[0]++)
        )

        (<= 0 (ยง color_cols[cci[0]]))
    ))

;; used for p_extra when displaying lcs_eol at end-of-line
(final Bytes at_end_str (u8 ""))

;; draw_state: items that are drawn in sequence:
(final int
    WL_START   0,   ;; nothing done yet
    WL_CMDLINE 1,   ;; cmdline window column
    WL_NR      2,   ;; line number
    WL_BRI     3,   ;; 'breakindent'
    WL_SBR     4,   ;; 'showbreak' or 'diff'
    WL_LINE    5)   ;; text in the line

;; Display line "lnum" of window 'wp' on the screen.
;; Start at row "startrow", stop when "endrow" is reached.
;; wp.w_virtcol needs to be valid.
;;
;; Return the number of last row the line occupies.

(defn- #_int win_line [#_window_C wp, #_long lnum, #_int startrow, #_int endrow, #_boolean _nochange]
    ;; nochange: not updating for changed text
    (ยง
        ((ร int c =) 0)
        ((ร int vcol =) 0)                          ;; virtual column (for tabs)
        ((ร int vcol_sbr =) -1)                     ;; virtual column after showbreak
        ((ร int vcol_prev =) -1)                    ;; "vcol" of previous character

        ((ร Bytes extra =) (ยง new Bytes(18)))            ;; "%ld" and 'fdc' must fit in here
        ((ร int n_extra =) 0)                        ;; number of extra chars
        ((ร Bytes p_extra =) null)                  ;; string of extra chars, plus NUL
        ((ร Bytes p_extra_free =) null)             ;; "p_extra" needs to be freed
        ((ร int c_extra =) NUL)                      ;; extra chars, all the same
        ((ร int extra_attr =) 0)                     ;; attributes when n_extra != 0

        ((ร int lcs_eol_one =) @lcs_eol)              ;; lcs_eol until it's been used

        ((ร int saved_n_extra =) 0)  ;; saved "extra" items for when draw_state becomes WL_LINE (again)
        ((ร Bytes saved_p_extra =) null)
        ((ร int saved_c_extra =) 0)
        ((ร int saved_char_attr =) 0)

        ((ร int n_attr =) 0)                         ;; chars with special attr
        ((ร int saved_attr2 =) 0)                    ;; char_attr saved for n_attr
        ((ร int n_attr3 =) 0)                        ;; chars with overruling special attr
        ((ร int saved_attr3 =) 0)                    ;; char_attr saved for n_attr3

        ((ร int n_skip =) 0)                         ;; nr of chars to skip for 'nowrap'

        ((ร int fromcol_prev =) -2)                  ;; start of inverting after cursor
        ((ร boolean noinvcur =) false)               ;; don't invert the cursor
        (ร pos_C top, bot)
        ((ร boolean lnum_in_visual_area =) false)

        ((ร int char_attr =) 0)                      ;; attributes for next character
        ((ร boolean attr_pri =) false)               ;; char_attr has priority
        ((ร boolean area_highlighting =) false)      ;; Visual or incsearch highlighting in this line
        ((ร int attr =) 0)                           ;; attributes for area highlighting
        ((ร int area_attr =) 0)                      ;; attributes desired by highlighting
        ((ร int search_attr =) 0)                    ;; attributes desired by 'hlsearch'
        ((ร int vcol_save_attr =) 0)                 ;; saved attr for 'cursorcolumn'
        ((ร int syntax_attr =) 0)                    ;; attributes desired by syntax
        ((ร int eol_hl_off =) 0)                     ;; 1 if highlighted char after EOL
        ((ร int multi_attr =) 0)                     ;; attributes desired by multibyte
        ((ร int mb_l =) 1)                           ;; multi-byte byte length
        ((ร int mb_c =) 0)                           ;; decoded multi-byte character
        ((ร boolean mb_utf8 =) false)                ;; screen char is UTF-8 char
        ((ร int[] u8cc =) (ยง new int[MAX_MCO]))          ;; composing UTF-8 chars
        ((ร int trailcol =) MAXCOL)                  ;; start of trailing spaces
        ((ร boolean need_showbreak =) false)

        ((ร int line_attr =) 0)                      ;; attribute for the whole line
        ((ร int did_line_attr =) 0)

        ((ร int draw_state =) WL_START)              ;; what to draw next

        ((ร int syntax_flags =) 0)
; %%    ((ร int[] syntax_seqnr =) (ยง { 0 }))
        ((ร int prev_syntax_id =) 0)
        ((ร int conceal_attr =) (hl_attr HLF_CONCEAL))
        ((ร boolean is_concealing =) false)
        ((ร int boguscols =) 0)                      ;; nonexistent columns added to force wrapping
        ((ร int vcol_off =) 0)                       ;; offset for concealed characters
        ((ร boolean did_wcol =) false)
        ((ร int old_boguscols =) 0)

        (if (< endrow startrow)                  ;; past the end already!
            ((ร RETURN) startrow)
        )

        ((ร int row =) startrow)                     ;; row in the window, excl w_winrow
        ((ร int screen_row =) (ยง row + wp.w_winrow))     ;; row on the screen, incl w_winrow

        ;; To speed up the loop below, set extra_check when there is linebreak,
        ;; trailing white space and/or syntax processing to be done.

        ((ร boolean extra_check =) @(.. wp w_options wo_lbr))  ;; has syntax or linebreak

        ;; Check for columns to display for 'colorcolumn'.
; %%    ((ร int[] color_cols =) (ยง wp.w_p_cc_cols, cci = { 0 }))         ;; pointer to according columns array
        ((ร boolean draw_color_col =) false)                         ;; highlight colorcolumn
        (if (non-nil? color_cols)
            ((ร draw_color_col =) (ยง advance_color_col(vcol - vcol_off, color_cols, cci)))
        )

        ;; handle visual active in this window

; %%    ((ร int[] fromcol =) (ยง { -10 }, tocol = { MAXCOL }))            ;; start/end of inverting
        (cond @VIsual_active
        (ยง
            (cond (ltoreq (. @curwin w_cursor), @VIsual)                ;; Visual is after curwin.w_cursor
            (ยง
                ((ร top =) (. @curwin w_cursor))
                ((ร bot =) @VIsual)
            )
            :else                                                ;; Visual is before curwin.w_cursor
            (ยง
                ((ร top =) @VIsual)
                ((ร bot =) (. @curwin w_cursor))
            ))

            ((ร lnum_in_visual_area =) (ยง (top.lnum <= lnum && lnum <= bot.lnum)))

            (cond (== @VIsual_mode Ctrl_V)                          ;; block mode
            (ยง
                (when lnum_in_visual_area
                    ((ร fromcol[0] =) (. wp w_old_cursor_fcol))
                    ((ร tocol[0] =) (. wp w_old_cursor_lcol))
                )
            )
            :else                                        ;; non-block mode
            (ยง
                (cond (and (< (. top lnum) lnum) (<= lnum (. bot lnum)))
                (ยง
                    ((ร fromcol[0] =) 0)
                )
                (== lnum (. top lnum))
                (ยง
                    (cond (== @VIsual_mode (byte \V))             ;; linewise
                    (ยง
                        ((ร fromcol[0] =) 0)
                    )
                    :else
                    (ยง
                        (getvvcol wp, top, fromcol, null, null)
                        (if (== (gchar_pos top) NUL)
                            ((ร tocol[0] =) (ยง fromcol[0] + 1))
                        )
                    ))
                ))
                (when (and (!= @VIsual_mode (byte \V)) (== lnum (. bot lnum)))
                    (cond (and (== (.at @p_sel 0) (byte \e)) (zero? (. bot col)) (zero? (. bot coladd)))
                    (ยง
                        ((ร fromcol[0] =) -10)
                        ((ร tocol[0] =) MAXCOL)
                    )
                    (== (. bot col) MAXCOL)
                    (ยง
                        ((ร tocol[0] =) MAXCOL)
                    )
                    :else
                    (ยง
                        ((ร pos_C pos =) (ยง ยง_pos_C()))
                        (COPY_pos pos, bot)
                        (cond (== (.at @p_sel 0) (byte \e))
                        (ยง
                            (getvvcol wp, pos, tocol, null, null)
                        )
                        :else
                        (ยง
                            (getvvcol wp, pos, null, null, tocol)
                            (ยง tocol[0]++)
                        ))
                    ))
                )
            ))

            ;; Check if the character under the cursor should not be inverted.
            (if (and (not @highlight_match) (== lnum (.. @curwin w_cursor lnum)) (== wp @curwin))
                ((ร noinvcur =) true)
            )

            ;; if inverting in this line set area_highlighting
            (when (<= 0 (ยง fromcol[0]))
                ((ร area_highlighting =) true)
                ((ร attr =) (hl_attr HLF_V))
            )
        )

        ;; handle 'incsearch' and ":s///c" highlighting

        (and @highlight_match (== wp @curwin) (<= (.. @curwin w_cursor lnum) lnum) (<= lnum (+ (.. @curwin w_cursor lnum) @search_match_lines)))
        (ยง
            (if (== lnum (.. @curwin w_cursor lnum))
                (getvcol @curwin, (. @curwin w_cursor), fromcol, null, null)
                ((ร fromcol[0] =) 0)
            )
            (cond (== lnum (+ (.. @curwin w_cursor lnum) @search_match_lines))
            (ยง
                ((ร pos_C pos =) (ยง ยง_pos_C()))
                ((ร pos.lnum =) lnum)
                ((ร pos.col =) @search_match_endcol)

                (getvcol @curwin, pos, tocol, null, null)
            )
            :else
            (ยง
                ((ร tocol[0] =) MAXCOL)
            ))
            ;; do at least one character; happens when past end of line
            (if (== (ยง fromcol[0]) (ยง tocol[0]))
                ((ร tocol[0] =) (ยง fromcol[0] + 1))
            )
            ((ร area_highlighting =) true)
            ((ร attr =) (hl_attr HLF_I))
        ))

        (if (non-zero? line_attr)
            ((ร area_highlighting =) true)
        )

        ((ร Bytes line =) (ml_get_buf @curbuf, lnum)) ;; current line
        ((ร Bytes ptr =) line)                                  ;; current position in "line"

        ;; 'nowrap' or 'wrap' and a single line that doesn't fit:
        ;; advance to the first character to be displayed.

        (ร int v)
        (if @(.. wp w_options wo_wrap)
            ((ร v =) (. wp w_skipcol))
            ((ร v =) (. wp w_leftcol))
        )
        (when (< 0 v)
            ((ร Bytes prev_ptr =) ptr)
            (while (ยง vcol < v && ptr.at(0) != NUL)
                ((ร c =) (win_lbr_chartabsize wp, line, ptr, vcol, null))
                ((ร vcol +=) c)
                ((ร prev_ptr =) ptr)
                ((ร ptr =) (ยง ptr.plus(us_ptr2len_cc(ptr))))
            )

            ;; When:
            ;; - 'cuc' is set, or
            ;; - 'colorcolumn' is set, or
            ;; - 'virtualedit' is set, or
            ;; - the visual mode is active,
            ;; the end of the line may be before the start of the displayed part.

            (when (and (< vcol v) (or @(.. wp w_options wo_cuc) draw_color_col (virtual_active) @VIsual_active))
                ((ร vcol =) v)
            )

            ;; Handle a character that's not completely on the screen:
            ;; put 'ptr' at that character, but skip the first few screen characters.
            (when (< v vcol)
                ((ร vcol -=) c)
                ((ร ptr =) prev_ptr)
                ((ร n_skip =) (- v vcol))
            )

            ;; Adjust for when the inverted text is before the screen,
            ;; and when the start of the inverted text is before the screen.

            (cond (<= (ยง tocol[0]) vcol)
            (ยง
                ((ร fromcol[0] =) 0)
            )
            (and (<= 0 (ยง fromcol[0])) (< (ยง fromcol[0]) vcol))
            (ยง
                ((ร fromcol[0] =) vcol)
            ))

            ;; When w_skipcol is non-zero, first line needs 'showbreak'.
            (if @(.. wp w_options wo_wrap)
                ((ร need_showbreak =) true)
            )
        )

        ;; Correct highlighting for cursor that can't be disabled.
        ;; Avoids having to check this for each character.

        (when (<= 0 (ยง fromcol[0]))
            (when noinvcur
                (cond (== (ยง fromcol[0]) (. wp w_virtcol))
                (ยง
                    ;; highlighting starts at cursor, let it start just after the cursor
                    ((ร fromcol_prev =) (ยง fromcol[0]))
                    ((ร fromcol[0] =) -1)
                )
                (< (ยง fromcol[0]) (. wp w_virtcol))
                (ยง
                    ;; restart highlighting after the cursor
                    ((ร fromcol_prev =) (. wp w_virtcol))
                ))
            )
            (if (<= (ยง tocol[0]) (ยง fromcol[0]))
                ((ร fromcol[0] =) -1)
            )
        )

        ;; Handle highlighting the last used search pattern and matches.
        ;; Do this for both search_hl and the match list.

        ((ร matchitem_C mi =) (. wp w_match_head))   ;; points to the match list
        ((ร boolean shl_flag =) false)           ;; whether search_hl has been processed
        (while (ยง mi != null || !shl_flag)
            (ร match_C shl)                    ;; points to search_hl or a match
            (cond (not shl_flag)
            (ยง
                ((ร shl =) @search_hl)
                ((ร shl_flag =) true)
            )
            :else
            (ยง
                ((ร shl =) (. mi mi_hl))
            ))
            ((ร shl.startcol =) MAXCOL)
            ((ร shl.endcol =) MAXCOL)
            ((ร shl.attr_cur =) 0)
            ((ร v =) (BDIFF ptr, line))
            (if (non-nil? mi)
                ((ร mi.mi_pos.cur =) 0)
            )
            (next_search_hl wp, shl, lnum, v, mi)

            ;; Need to get the line again, a multi-line regexp may have made it invalid.
            ((ร line =) (ml_get_buf @curbuf, lnum))
            ((ร ptr =) (ยง line.plus(v)))

            (when (and (!= (. shl lnum) 0) (<= (. shl lnum) lnum))
                (if (== (. shl lnum) lnum)
                    ((ร shl.startcol =) (ยง shl.rmm.startpos[0].col))
                    ((ร shl.startcol =) 0)
                )
                (if (== lnum (ยง shl.lnum + shl.rmm.endpos[0].lnum - shl.rmm.startpos[0].lnum))
                    ((ร shl.endcol =) (ยง shl.rmm.endpos[0].col))
                    ((ร shl.endcol =) MAXCOL)
                )
                ;; Highlight one character for an empty match.
                (when (== (. shl startcol) (. shl endcol))
                    (if (!= (.at line (. shl endcol)) NUL)
                        ((ร shl.endcol +=) (ยง us_ptr2len_cc(line.plus(shl.endcol))))
                        (ยง shl.endcol++)
                    )
                )
                (when (< (long (. shl startcol)) v) ;; match at leftcol
                    ((ร shl.attr_cur =) (. shl attr))
                    ((ร search_attr =) (. shl attr))
                )
                ((ร area_highlighting =) true)
            )
            (if (and (!= shl @search_hl) (non-nil? mi))
                ((ร mi =) (. mi next))
            )
        )

        ;; Cursor line highlighting for 'cursorline' in the current window.
        ;; Not when Visual mode is active, because it's not clear what is selected then.
        (when (and @(.. wp w_options wo_cul) (== lnum (.. wp w_cursor lnum)) (not (and (== wp @curwin) @VIsual_active)))
            ((ร line_attr =) (hl_attr HLF_CUL))
            ((ร area_highlighting =) true)
        )

        ((ร int col =) 0)                                        ;; visual column on screen
        ((ร int off =) (BDIFF @current_ScreenLine, @screenLines))  ;; offset in screenLines/screenAttrs

        ;; Repeat for the whole displayed line.

        (while true
            ;; Skip this quickly when working on the text.
            (when (!= draw_state WL_LINE)
                (when (and (== draw_state (- WL_CMDLINE 1)) (zero? n_extra))
                    ((ร draw_state =) WL_CMDLINE)
                    (when (and (non-zero? @cmdwin_type) (== wp @curwin))
                        ;; Draw the cmdline character.
                        ((ร n_extra =) 1)
                        ((ร c_extra =) @cmdwin_type)
                        ((ร char_attr =) (hl_attr HLF_AT))
                    )
                )

                (when (and (== draw_state (- WL_NR 1)) (zero? n_extra))
                    ((ร draw_state =) WL_NR)
                    ;; Display the absolute or relative line number.
                    ;; After the first fill with blanks when the 'n' flag isn't in 'cpo'.
                    (when (and (or @(.. wp w_options wo_nu) @(.. wp w_options wo_rnu)) (or (== row startrow) (nil? (vim_strbyte @p_cpo, CPO_NUMCOL))))
                        ;; Draw the line number (empty space after wrapping).
                        (cond (== row startrow)
                        (ยง
                            (ร long num)
                            ((ร Bytes fmt =) (u8 "%*ld "))

                            (cond (and @(.. wp w_options wo_nu) (not @(.. wp w_options wo_rnu)))
                            (ยง
                                ;; 'number' + 'norelativenumber'
                                ((ร num =) lnum)
                            )
                            :else
                            (ยง
                                ;; 'relativenumber', don't use negative numbers
                                ((ร num =) (ยง Math.abs(get_cursor_rel_lnum(wp, lnum))))
                                (when (and (zero? num) @(.. wp w_options wo_nu) @(.. wp w_options wo_rnu))
                                    ;; 'number' + 'relativenumber'
                                    ((ร num =) lnum)
                                    ((ร fmt =) (u8 "%-*ld "))
                                )
                            ))

                            (ยง libC.sprintf(extra, fmt, number_width(wp), num))
                            (when (< 0 (. wp w_skipcol))
                                ((ร FOR) (ร (ยง p_extra = extra) (ยง p_extra.at(0) == (byte \space)) (ยง p_extra = p_extra.plus(1)))
                                    (.be p_extra 0, (byte \-))
                                )
                            )
                            ((ร p_extra =) extra)
                            ((ร c_extra =) NUL)
                        )
                        :else
                        (ยง
                            ((ร c_extra =) (byte \space))
                        ))
                        ((ร n_extra =) (ยง number_width(wp) + 1))
                        ((ร char_attr =) (hl_attr HLF_N))
                        ;; When 'cursorline' is set, highlight the line number of the current line differently.
                        ;; TODO: Can we use CursorLine instead of CursorLineNr when CursorLineNr isn't set?
                        (if (and (or @(.. wp w_options wo_cul) @(.. wp w_options wo_rnu)) (== lnum (.. wp w_cursor lnum)))
                            ((ร char_attr =) (hl_attr HLF_CLN))
                        )
                    )
                )

                (cond (and (. wp w_p_brisbr) (== draw_state (- WL_BRI 1)) (zero? n_extra) (non-eos? @p_sbr))
                (ยง
                    ;; draw indent after showbreak value
                    ((ร draw_state =) WL_BRI)
                )
                (and (. wp w_p_brisbr) (== draw_state WL_SBR) (zero? n_extra))
                (ยง
                    ;; After the showbreak, draw the breakindent.
                    ((ร draw_state =) (- WL_BRI 1))
                ))

                ;; draw 'breakindent': indent wrapped text accordingly
                (when (and (== draw_state (- WL_BRI 1)) (zero? n_extra))
                    ((ร draw_state =) WL_BRI)
                    (when (and @(.. wp w_options wo_bri) (zero? n_extra) (!= row startrow))
                        ((ร char_attr =) 0) ;; was: hl_attr(HLF_AT);
                        ((ร p_extra =) null)
                        ((ร c_extra =) (byte \space))
                        ((ร n_extra =) (ยง get_breakindent_win(wp, ml_get_buf(@curbuf, lnum))))
                        ;; Correct end of highlighted area for 'breakindent',
                        ;; required when 'linebreak' is also set.
                        (if (== (ยง tocol[0]) vcol)
                            ((ร tocol[0] +=) n_extra)
                        )
                    )
                )

                (when (and (== draw_state (- WL_SBR 1)) (zero? n_extra))
                    ((ร draw_state =) WL_SBR)
                    (when (and (non-eos? @p_sbr) need_showbreak)
                        ;; Draw 'showbreak' at the start of each broken line.
                        ((ร p_extra =) @p_sbr)
                        ((ร c_extra =) NUL)
                        ((ร n_extra =) (STRLEN @p_sbr))
                        ((ร char_attr =) (hl_attr HLF_AT))
                        ((ร need_showbreak =) false)
                        ((ร vcol_sbr =) (ยง vcol + us_charlen(@p_sbr)))
                        ;; Correct end of highlighted area for 'showbreak',
                        ;; required when 'linebreak' is also set.
                        (if (== (ยง tocol[0]) vcol)
                            ((ร tocol[0] +=) n_extra)
                        )
                        ;; combine 'showbreak' with 'cursorline'
                        (if (and @(.. wp w_options wo_cul) (== lnum (.. wp w_cursor lnum)))
                            ((ร char_attr =) (ยง hl_combine_attr(char_attr, hl_attr(HLF_CUL))))
                        )
                    )
                )

                (when (and (== draw_state (- WL_LINE 1)) (zero? n_extra))
                    ((ร draw_state =) WL_LINE)
                    (cond (non-zero? saved_n_extra)
                    (ยง
                        ;; Continue item from end of wrapped line.
                        ((ร n_extra =) saved_n_extra)
                        ((ร c_extra =) saved_c_extra)
                        ((ร p_extra =) saved_p_extra)
                        ((ร char_attr =) saved_char_attr)
                    )
                    :else
                    (ยง
                        ((ร char_attr =) 0)
                    ))
                )
            )

            (when (and (== draw_state WL_LINE) area_highlighting)
                ;; handle Visual or match highlighting in this line
                                                            ;; not at margin
                (cond (ยง vcol == fromcol[0] || (vcol + 1 == fromcol[0] && n_extra == 0 && 1 < us_ptr2cells(ptr)) || (vcol_prev == fromcol_prev && vcol_prev < vcol && vcol < tocol[0]))
                (ยง
                    ((ร area_attr =) attr)                       ;; start highlighting
                )
                (ยง area_attr != 0 && (vcol == tocol[0] || (noinvcur && vcol == wp.w_virtcol)))
                (ยง
                    ((ร area_attr =) 0)                          ;; stop highlighting
                ))

                (when (zero? n_extra)
                    ;; Check for start/end of search pattern match.
                    ;; After end, check for start/end of next match.
                    ;; When another match, have to check for start again.
                    ;; Watch out for matching an empty string!
                    ;; Do this for 'search_hl' and the match list (ordered by priority).

                    ((ร v =) (BDIFF ptr, line))
                    ((ร mi =) (. wp w_match_head))
                    ((ร shl_flag =) false)
                    (while (ยง mi != null || !shl_flag)
                        (ร match_C shl)        ;; points to search_hl or a match
                        (cond (and (not shl_flag) (or (and (non-nil? mi) (< SEARCH_HL_PRIORITY (. mi priority))) (nil? mi)))
                        (ยง
                            ((ร shl =) @search_hl)
                            ((ร shl_flag =) true)
                        )
                        :else
                        (ยง
                            ((ร shl =) (. mi mi_hl))
                        ))
                        (if (non-nil? mi)
                            ((ร mi.mi_pos.cur =) 0)
                        )
                        ;; marks that position match search is in progress
                        ((ร boolean pos_inprogress =) true)
                        (while (ยง shl.rmm.regprog != null || (mi != null && pos_inprogress))
                            (cond (and (!= (. shl startcol) MAXCOL) (<= (. shl startcol) v) (< v (. shl endcol)))
                            (ยง
                                ((ร int tmp_col =) (ยง v + us_ptr2len_cc(ptr)))

                                (if (< (. shl endcol) tmp_col)
                                    ((ร shl.endcol =) tmp_col)
                                )
                                ((ร shl.attr_cur =) (. shl attr))
                            )
                            (== v (. shl endcol))
                            (ยง
                                ((ร shl.attr_cur =) 0)
                                (next_search_hl wp, shl, lnum, v, mi)
                                ((ร pos_inprogress =) (ยง (mi != null && mi.mi_pos.cur != 0)))

                                ;; Need to get the line again, a multi-line regexp may have made it invalid.
                                ((ร line =) (ml_get_buf @curbuf, lnum))
                                ((ร ptr =) (ยง line.plus(v)))

                                (when (== (. shl lnum) lnum)
                                    ((ร shl.startcol =) (ยง shl.rmm.startpos[0].col))
                                    (if (zero? (ยง shl.rmm.endpos[0].lnum))
                                        ((ร shl.endcol =) (ยง shl.rmm.endpos[0].col))
                                        ((ร shl.endcol =) MAXCOL)
                                    )

                                    (when (== (. shl startcol) (. shl endcol))
                                        ;; highlight empty match, try again after it
                                        ((ร shl.endcol +=) (ยง us_ptr2len_cc(line.plus(shl.endcol))))
                                    )

                                    ;; Loop to check if the match starts at the current position.
                                    (ร CONTINUE)
                                )
                            ))
                            (ร BREAK)
                        )
                        (if (and (!= shl @search_hl) (non-nil? mi))
                            ((ร mi =) (. mi next))
                        )
                    )

                    ;; Use attributes from match with highest priority
                    ;; among 'search_hl' and the match list.
                    ((ร search_attr =) (. @search_hl attr_cur))
                    ((ร mi =) (. wp w_match_head))
                    ((ร shl_flag =) false)
                    (while (ยง mi != null || !shl_flag)
                        (ร match_C shl)        ;; points to search_hl or a match
                        (cond (and (not shl_flag) (or (and (non-nil? mi) (< SEARCH_HL_PRIORITY (. mi priority))) (nil? mi)))
                        (ยง
                            ((ร shl =) @search_hl)
                            ((ร shl_flag =) true)
                        )
                        :else
                        (ยง
                            ((ร shl =) (. mi mi_hl))
                        ))
                        (if (!= (. shl attr_cur) 0)
                            ((ร search_attr =) (. shl attr_cur))
                        )
                        (if (and (!= shl @search_hl) (non-nil? mi))
                            ((ร mi =) (. mi next))
                        )
                    )
                )

                ;; Decide which of the highlight attributes to use.
                ((ร attr_pri =) true)

                (cond (non-zero? area_attr)
                (ยง
                    ((ร char_attr =) (hl_combine_attr line_attr, area_attr))
                )
                (non-zero? search_attr)
                (ยง
                    ((ร char_attr =) (hl_combine_attr line_attr, search_attr))
                )
                ;; Use line_attr when not in the Visual or 'incsearch' area
                ;; (area_attr may be 0 when "noinvcur" is set).
                (and (non-zero? line_attr) (or (and (== (ยง fromcol[0]) -10) (== (ยง tocol[0]) MAXCOL)) (< vcol (ยง fromcol[0])) (< vcol_prev fromcol_prev) (<= (ยง tocol[0]) vcol)))
                (ยง
                    ((ร char_attr =) line_attr)
                )
                :else
                (ยง
                    ((ร attr_pri =) false)
                    ((ร char_attr =) 0)
                ))
            )

            ;; Get the next character to put on the screen.

            ;; The "p_extra" points to the extra stuff that is inserted to represent
            ;; special characters (non-printable stuff) and other things.
            ;; When all characters are the same, c_extra is used.
            ;; "p_extra" must end in a NUL to avoid us_ptr2len_cc() reads past "p_extra[n_extra]".
            ;; For the '$' of the 'list' option, n_extra == 1, p_extra == "".

            (cond (< 0 n_extra)
            (ยง
                (cond (!= c_extra NUL)
                (ยง
                    ((ร c =) c_extra)
                    ((ร mb_c =) c)       ;; doesn't handle non-utf-8 multi-byte!
                    (cond (< 1 (utf_char2len c))
                    (ยง
                        ((ร mb_utf8 =) true)
                        ((ร u8cc[0] =) 0)
                        ((ร c =) 0xc0)
                    )
                    :else
                    (ยง
                        ((ร mb_utf8 =) false)
                    ))
                )
                :else
                (ยง
                    ((ร c =) (ยง p_extra.at(0)))

                    ((ร mb_c =) c)

                    ;; If the UTF-8 character is more than one byte, decode it into "mb_c".
                    ((ร mb_l =) (us_ptr2len_cc p_extra))
                    ((ร mb_utf8 =) false)
                    (cond (< n_extra mb_l)
                    (ยง
                        ((ร mb_l =) 1)
                    )
                    (< 1 mb_l)
                    (ยง
                        ((ร mb_c =) (us_ptr2char_cc p_extra, u8cc))
                        ((ร mb_utf8 =) true)
                        ((ร c =) 0xc0)
                    ))

                    (if (zero? mb_l)  ;; at the NUL at end-of-line
                        ((ร mb_l =) 1)
                    )

                    ;; If a double-width char doesn't fit display a '>' in the last column.
                    (cond (and (ยง wp.w_width - 1 <= col) (== (utf_char2cells mb_c) 2))
                    (ยง
                        ((ร c =) (byte \>))
                        ((ร mb_c =) c)
                        ((ร mb_l =) 1)
                        ((ร mb_utf8 =) false)
                        ((ร multi_attr =) (hl_attr HLF_AT))
                        ;; put the pointer back to output the double-width
                        ;; character at the start of the next line
                        (ยง n_extra++)
                        ((ร p_extra =) (ยง p_extra.minus(1)))
                    )
                    :else
                    (ยง
                        ((ร n_extra -=) (- mb_l 1))
                        ((ร p_extra =) (ยง p_extra.plus(mb_l - 1)))
                    ))

                    ((ร p_extra =) (ยง p_extra.plus(1)))
                ))
                (ยง --n_extra)
            )
            :else
            (ยง
                (if (non-nil? p_extra_free)
                    ((ร p_extra_free =) null)
                )

                ;; Get a character from the line itself.

                ((ร c =) (ยง ptr.at(0)))

                ((ร mb_c =) c)

                ;; If the UTF-8 character is more than one byte, decode it into "mb_c".
                ((ร mb_l =) (us_ptr2len_cc ptr))
                ((ร mb_utf8 =) false)
                (when (< 1 mb_l)
                    ((ร mb_c =) (us_ptr2char_cc ptr, u8cc))
                    ;; Overlong encoded ASCII or ASCII with composing char
                    ;; is displayed normally, except a NUL.
                    (if (< mb_c 0x80)
                        ((ร c =) mb_c)
                    )
                    ((ร mb_utf8 =) true)

                    ;; At start of the line we can have a composing char.
                    ;; Draw it as a space with a composing char.
                    (when (utf_iscomposing mb_c)
                        ((ร FOR) (ร (ยง int i = @screen_mco - 1) (< 0 i) (ยง --i))
                            ((ร u8cc[i] =) (ยง u8cc[i - 1]))
                        )
                        ((ร u8cc[0] =) mb_c)
                        ((ร mb_c =) (byte \space))
                    )
                )

                (cond (or (and (== mb_l 1) (<= 0x80 c)) (and (<= 1 mb_l) (zero? mb_c)) (and (< 1 mb_l) (not (vim_isprintc mb_c))))
                (ยง
                    ;; Illegal UTF-8 byte: display as <xx>.
                    ;; Non-BMP character : display as ? or fullwidth ?.

                    (transchar_hex extra, mb_c)

                    ((ร p_extra =) extra)
                    ((ร c =) (ยง p_extra.at(0)))
;                   { Bytes[] __ = { p_extra }; mb_c = us_ptr2char_adv(__, true); p_extra = __[0]; }
                    ((ร mb_utf8 =) (ยง (0x80 <= c)))
                    ((ร n_extra =) (STRLEN p_extra))
                    ((ร c_extra =) NUL)
                    (when (and (zero? area_attr) (zero? search_attr))
                        ((ร n_attr =) (+ n_extra 1))
                        ((ร extra_attr =) (hl_attr HLF_8))
                        ((ร saved_attr2 =) char_attr)    ;; save current attr
                    )
                )
                (zero? mb_l)                 ;; at the NUL at end-of-line
                (ยง
                    ((ร mb_l =) 1)
                ))

                ;; If a double-width char doesn't fit, display a '>' in the last column;
                ;; the character is displayed at the start of the next line.
                (cond (and (ยง wp.w_width - 1 <= col) (== (utf_char2cells mb_c) 2))
                (ยง
                    ((ร c =) (byte \>))
                    ((ร mb_c =) c)
                    ((ร mb_utf8 =) false)
                    ((ร mb_l =) 1)
                    ((ร multi_attr =) (hl_attr HLF_AT))
                    ;; Put pointer back so that the character will be
                    ;; displayed at the start of the next line.
                    ((ร ptr =) (ยง ptr.minus(1)))
                )
                (non-eos? ptr)
                (ยง
                    ((ร ptr =) (ยง ptr.plus(mb_l - 1)))
                ))

                ;; If a double-width char doesn't fit at the left side, display a '<'
                ;; in the first column.  Don't do this for unprintable characters.
                (when (and (< 0 n_skip) (< 1 mb_l) (zero? n_extra))
                    ((ร n_extra =) 1)
                    ((ร c_extra =) MB_FILLER_CHAR)
                    ((ร c =) (byte \space))
                    (when (and (zero? area_attr) (zero? search_attr))
                        ((ร n_attr =) (+ n_extra 1))
                        ((ร extra_attr =) (hl_attr HLF_AT))
                        ((ร saved_attr2 =) char_attr)    ;; save current attr
                    )
                    ((ร mb_c =) c)
                    ((ร mb_utf8 =) false)
                    ((ร mb_l =) 1)
                )

                ((ร ptr =) (ยง ptr.plus(1)))

                (when extra_check
                    ;; Get syntax attribute, unless still at the start of the line
                    ;; (double-wide char that doesn't fit).
                    ((ร v =) (BDIFF ptr, line))

                    ;; Found last space before word: check for line break.

                    (when (and @(.. wp w_options wo_lbr) (ยง @breakat_flags[char_u((byte)c)]) (not (ยง @breakat_flags[char_u(ptr.at(0))])))
                        ((ร int mb_off =) (ยง us_head_off(line, ptr.minus(1))))
                        ((ร Bytes p =) (ยง ptr.minus(mb_off + 1)))

                        ;; TODO: is passing 'p' for start of the line OK?
                        ((ร n_extra =) (ยง win_lbr_chartabsize(wp, line, p, vcol, null) - 1))
                        (if (and (== c TAB) (< (. wp w_width) (+ n_extra col)))
                            ((ร n_extra =) (ยง (int)@curbuf.@b_p_ts - vcol % (int)@curbuf.@b_p_ts - 1))
                        )

                        ((ร c_extra =) (if (< 0 mb_off) MB_FILLER_CHAR (byte \space)))
                        (when (vim_iswhite c)
                            (when (== c TAB)       ;; See "Tab alignment" below.
                                ((ร n_extra +=) vcol_off)
                                ((ร vcol -=) vcol_off)
                                ((ร vcol_off =) 0)
                                ((ร col -=) boguscols)
                                ((ร old_boguscols =) boguscols)
                                ((ร boguscols =) 0)
                            )
                            ((ร c =) (byte \space))
                        )
                    )

                    (when (and (!= trailcol MAXCOL) (BLT (.plus line trailcol), ptr) (== c (byte \space)))
                        ((ร c =) @lcs_trail)
                        (when (not attr_pri)
                            ((ร n_attr =) 1)
                            ((ร extra_attr =) (hl_attr HLF_8))
                            ((ร saved_attr2 =) char_attr)    ;; save current attr
                        )
                        ((ร mb_c =) c)
                        (cond (< 1 (utf_char2len c))
                        (ยง
                            ((ร mb_utf8 =) true)
                            ((ร u8cc[0] =) 0)
                            ((ร c =) 0xc0)
                        )
                        :else
                        (ยง
                            ((ร mb_utf8 =) false)
                        ))
                    )
                )

                ;; Handling of non-printable characters.

                (when (zero? (ยง chartab[c & 0xff] & CT_PRINT_CHAR))
                    ;; When getting a character from the file, we may have to turn it
                    ;; into something else on the way to putting it into "screenLines".

                    (cond (== c TAB)
                    (ยง
                        ((ร int tab_len =) 0)
                        ((ร int vcol_adjusted =) vcol) ;; removed showbreak length
                        ;; Only adjust the "tab_len" when at the first column
                        ;; after the showbreak value was drawn.
                        (if (and (non-eos? @p_sbr) (== vcol vcol_sbr) @(.. wp w_options wo_wrap))
                            ((ร vcol_adjusted =) (ยง vcol - us_charlen(@p_sbr)))
                        )
                        ;; tab amount depends on current column
                        ((ร tab_len =) (ยง (int)@curbuf.@b_p_ts - vcol_adjusted % (int)@curbuf.@b_p_ts - 1))

                        ;; tab amount depends on current column
                        ((ร n_extra =) tab_len)

                        ;; Tab alignment should be identical regardless of
                        ;; 'conceallevel' value.  So tab compensates of all
                        ;; previous concealed characters, and thus resets
                        ;; vcol_off and boguscols accumulated so far in the
                        ;; line.  Note that the tab can be longer than
                        ;; 'tabstop' when there are concealed characters.

                        ((ร n_extra +=) vcol_off)
                        ((ร vcol -=) vcol_off)
                        ((ร vcol_off =) 0)
                        ((ร col -=) boguscols)
                        ((ร old_boguscols =) boguscols)
                        ((ร boguscols =) 0)

                        ((ร mb_utf8 =) false)                    ;; don't draw as UTF-8

                        ((ร c_extra =) (byte \space))
                        ((ร c =) (byte \space))
                    )
                    (ยง c == NUL && ((0 <= fromcol[0] || 0 <= fromcol_prev) && vcol < tocol[0] && @VIsual_mode != Ctrl_V && col < wp.w_width && !(noinvcur && lnum == wp.w_cursor.lnum && vcol == wp.w_virtcol)) && 0 <= lcs_eol_one)
                    (ยง
                        ;; Display a '$' after the line or highlight an extra character if the line break is included.

                        ;; For a diff line the highlighting continues after the "$".
                        (when (zero? line_attr)
                            ;; In virtualedit, visual selections may extend beyond end of line.
                            (cond (and area_highlighting (virtual_active) (!= (ยง tocol[0]) MAXCOL) (< vcol (ยง tocol[0])))
                            (ยง
                                ((ร n_extra =) 0)
                            )
                            :else
                            (ยง
                                ((ร p_extra =) at_end_str)
                                ((ร n_extra =) 1)
                                ((ร c_extra =) NUL)
                            ))
                        )
                        ((ร c =) (byte \space))
                        ((ร lcs_eol_one =) -1)
                        ((ร ptr =) (ยง ptr.minus(1)))                 ;; put it back at the NUL
                        (when (not attr_pri)
                            ((ร extra_attr =) (hl_attr HLF_AT))
                            ((ร n_attr =) 1)
                        )
                        ((ร mb_c =) c)
                        (cond (< 1 (utf_char2len c))
                        (ยง
                            ((ร mb_utf8 =) true)
                            ((ร u8cc[0] =) 0)
                            ((ร c =) 0xc0)
                        )
                        :else
                        (ยง
                            ((ร mb_utf8 =) false)                ;; don't draw as UTF-8
                        ))
                    )
                    (!= c NUL)
                    (ยง
                        ((ร p_extra =) (transchar c))
                        (if (zero? n_extra)
                            ((ร n_extra =) (ยง mb_byte2cells((byte)c) - 1))
                        )
                        ((ร c_extra =) NUL)
                        (cond @(.. wp w_options wo_lbr)
                        (ยง
                            (ร Bytes p)

                            ((ร c =) (ยง p_extra.at(0)))
                            ((ร p =) (ยง new Bytes(n_extra + 1)))
                            (BFILL p, 0, (byte \space), n_extra)
                            (STRNCPY p, (.plus p_extra 1), (- (STRLEN p_extra) 1))
                            (.be p n_extra, NUL)
                            ((ร p_extra_free =) (ยง p_extra = p))
                        )
                        :else
                        (ยง
                            ((ร n_extra =) (ยง mb_byte2cells((byte)c) - 1))
                            ((ร c =) (ยง (p_extra = p_extra.plus(1)).at(-1)))
                        ))
                        (when (not attr_pri)
                            ((ร n_attr =) (+ n_extra 1))
                            ((ร extra_attr =) (hl_attr HLF_8))
                            ((ร saved_attr2 =) char_attr)        ;; save current attr
                        )
                        ((ร mb_utf8 =) false)                    ;; don't draw as UTF-8
                    )
                    (ยง @VIsual_active && (@VIsual_mode == Ctrl_V || @VIsual_mode == (byte \v)) && virtual_active() && tocol[0] != MAXCOL && vcol < tocol[0] && col < wp.w_width)
                    (ยง
                        ((ร c =) (byte \space))
                        ((ร ptr =) (ยง ptr.minus(1)))                             ;; put it back at the NUL
                    )
                    (ยง line_attr != 0 && col - boguscols < wp.w_width)
                    (ยง
                        ;; Highlight until the right side of the window.
                        ((ร c =) (byte \space))
                        ((ร ptr =) (ยง ptr.minus(1)))                             ;; put it back at the NUL

                        ;; Remember we do the char for line highlighting.
                        (ยง did_line_attr++)

                        ;; don't do search HL for the rest of the line
                        (if (and (non-zero? line_attr) (== char_attr search_attr) (< 0 col))
                            ((ร char_attr =) line_attr)
                        )
                    ))
                )

                (cond (ยง 0 < wp.w_options.@wo_cole && (wp != @curwin || lnum != wp.w_cursor.lnum || conceal_cursor_line(wp)) && (syntax_flags & HL_CONCEAL) != 0 && !(lnum_in_visual_area && vim_strchr(wp.w_options.@wo_cocu, (byte \v)) == null))
                (ยง
                    ((ร char_attr =) conceal_attr)
                    (cond (and (!= prev_syntax_id (ยง syntax_seqnr[0])) (or (!= (syn_get_sub_char) NUL) (== @(.. wp w_options wo_cole) 1)) (!= @(.. wp w_options wo_cole) 3))
                    (ยง
                        ;; First time at this concealed item: display one character.
                        (cond (!= (syn_get_sub_char) NUL)
                        (ยง
                            ((ร c =) (syn_get_sub_char))
                        )
                        (!= @lcs_conceal NUL)
                        (ยง
                            ((ร c =) @lcs_conceal)
                        )
                        :else
                        (ยง
                            ((ร c =) (byte \space))
                        ))

                        ((ร prev_syntax_id =) (ยง syntax_seqnr[0]))

                        (if (< 0 n_extra)
                            ((ร vcol_off +=) n_extra)
                        )
                        ((ร vcol +=) n_extra)
                        (when (and @(.. wp w_options wo_wrap) (< 0 n_extra))
                            ((ร boguscols +=) n_extra)
                            ((ร col +=) n_extra)
                        )
                        ((ร n_extra =) 0)
                        ((ร n_attr =) 0)
                    )
                    (zero? n_skip)
                    (ยง
                        ((ร is_concealing =) true)
                        ((ร n_skip =) 1)
                    ))
                    ((ร mb_c =) c)
                    (cond (< 1 (utf_char2len c))
                    (ยง
                        ((ร mb_utf8 =) true)
                        ((ร u8cc[0] =) 0)
                        ((ร c =) 0xc0)
                    )
                    :else
                    (ยง
                        ((ร mb_utf8 =) false)    ;; don't draw as UTF-8
                    ))
                )
                :else
                (ยง
                    ((ร prev_syntax_id =) 0)
                    ((ร is_concealing =) false)
                ))
            ))

            ;; In the cursor line and we may be concealing characters:
            ;; correct the cursor column when we reach its position.
            (when (and (not did_wcol) (== draw_state WL_LINE) (== wp @curwin) (== lnum (.. wp w_cursor lnum)) (conceal_cursor_line wp) (<= (. wp w_virtcol) (+ vcol n_skip)))
                ((ร wp.w_wcol =) (- col boguscols))
                ((ร wp.w_wrow =) row)
                ((ร did_wcol =) true)
            )

            ;; Don't override visual selection highlighting.
            (when (and (< 0 n_attr) (== draw_state WL_LINE) (not attr_pri))
                ((ร char_attr =) extra_attr)
            )

            ;; At end of the text line or just after the last character.

            (when (or (== c NUL) (== did_line_attr 1))
                ((ร long prevcol =) (- (BDIFF ptr, line) (if (== c NUL) 1 0)))

                ;; we're not really at that column when skipping some text
                (if (< prevcol (long (if @(.. wp w_options wo_wrap) (. wp w_skipcol) (. wp w_leftcol))))
                    (ยง prevcol++)
                )

                ;; Invert at least one char, used for Visual and empty line or highlight
                ;; match at end of line.  If it's beyond the last char on the screen,
                ;; just overwrite that one (tricky!)
                ;; Not needed when a '$' was displayed for 'list'.

                ((ร boolean prevcol_hl_flag =) false)                ;; whether prevcol equals startcol of
                                                                ;; search_hl or one of the matches
                (cond (== prevcol (long (. @search_hl startcol)))
                (ยง
                    ((ร prevcol_hl_flag =) true)
                )
                :else
                (ยง
                    ((ร FOR) (ร (ยง mi = wp.w_match_head) (!= mi null) (ยง mi = mi.next))
                        (when (== prevcol (long (.. mi mi_hl startcol)))
                            ((ร prevcol_hl_flag =) true)
                            (ร BREAK)
                        )
                    )
                ))
                                ;; highlight 'hlsearch' match at end of line
                (when (ยง @lcs_eol == lcs_eol_one && ((area_attr != 0 && vcol == fromcol[0] && (@VIsual_mode != Ctrl_V || lnum == @VIsual.lnum || lnum == @curwin.w_cursor.lnum) && c == NUL) || (prevcol_hl_flag && did_line_attr <= 1)))
                    ((ร int n =) 0)

                    (if (<= (. wp w_width) col)
                        ((ร n =) -1)
                    )

                    (cond (non-zero? n)
                    (ยง
                        ;; At the window boundary, highlight the last character
                        ;; instead (better than nothing).
                        ((ร off +=) n)
                        ((ร col +=) n)
                    )
                    :else
                    (ยง
                        ;; Add a blank character to highlight.
                        (ยง @screenLines.be(off, (byte \space)))
                        ((ร @screenLinesUC[off] =) 0)
                    ))
                    (when (zero? area_attr)
                        ;; Use attributes from match with highest priority
                        ;; among 'search_hl' and the match list.
                        ((ร char_attr =) (. @search_hl attr))
                        ((ร mi =) (. wp w_match_head))
                        ((ร shl_flag =) false)
                        (while (ยง mi != null || !shl_flag)
                            (ร match_C shl)        ;; points to search_hl or a match
                            (cond (and (not shl_flag) (or (and (non-nil? mi) (< SEARCH_HL_PRIORITY (. mi priority))) (nil? mi)))
                            (ยง
                                ((ร shl =) @search_hl)
                                ((ร shl_flag =) true)
                            )
                            :else
                            (ยง
                                ((ร shl =) (. mi mi_hl))
                            ))
                            (if (ยง (BDIFF(ptr, line)) - 1 == shl.startcol)
                                ((ร char_attr =) (. shl attr))
                            )
                            (if (and (!= shl @search_hl) (non-nil? mi))
                                ((ร mi =) (. mi next))
                            )
                        )
                    )
                    ((ร @screenAttrs[off] =) char_attr)
                    (ยง col++)
                    (ยง off++)
                    (ยง vcol++)
                    ((ร eol_hl_off =) 1)
                )
            )

            ;; At end of the text line.

            (when (== c NUL)
                (when (and (< 0 eol_hl_off) (ยง vcol - eol_hl_off == wp.w_virtcol) (== lnum (.. wp w_cursor lnum)))
                    ;; highlight last char after line
                    (ยง --col)
                    (ยง --off)
                    (ยง --vcol)
                )

                ;; Highlight 'cursorcolumn' & 'colorcolumn' past end of the line.
                (if @(.. wp w_options wo_wrap)
                    ((ร v =) (. wp w_skipcol))
                    ((ร v =) (. wp w_leftcol))
                )

                ;; check if line ends before left margin
                (if (< vcol (ยง v + col - win_col_off(wp)))
                    ((ร vcol =) (ยง v + col - win_col_off(wp)))
                )
                ;; Get rid of the boguscols now,
                ;; we want to draw until the right edge for 'cursorcolumn'.
                ((ร col -=) boguscols)
                ((ร boguscols =) 0)

                (if draw_color_col
                    ((ร draw_color_col =) (ยง advance_color_col(vcol - vcol_off, color_cols, cci)))
                )

                (when (ยง (wp.w_options.@wo_cuc && vcol - vcol_off - eol_hl_off <= wp.w_virtcol && wp.w_virtcol < wp.w_width * (row - startrow + 1) + v && lnum != wp.w_cursor.lnum) || draw_color_col)
                    ((ร int rightmost_vcol =) 0)

                    (if @(.. wp w_options wo_cuc)
                        ((ร rightmost_vcol =) (. wp w_virtcol))
                    )
                    (when draw_color_col
                        ;; determine rightmost colorcolumn to possibly draw
                        ((ร FOR) (ร (ยง int i = 0) (ยง 0 <= color_cols[cci[0] + i]) (ยง i++))
                            (if (< rightmost_vcol (ยง color_cols[cci[0] + i]))
                                ((ร rightmost_vcol =) (ยง color_cols[cci[0] + i]))
                            )
                        )
                    )

                    (while (ยง col < wp.w_width)
                        (ยง @screenLines.be(off, (byte \space)))
                        ((ร @screenLinesUC[off] =) 0)
                        (ยง col++)
                        (if draw_color_col
                            ((ร draw_color_col =) (ยง advance_color_col(vcol - vcol_off, color_cols, cci)))
                        )

                        (cond (and @(.. wp w_options wo_cuc) (ยง vcol - vcol_off == wp.w_virtcol))
                        (ยง
                            ((ร @screenAttrs[off++] =) (hl_attr HLF_CUC))
                        )
                        (and draw_color_col (ยง vcol - vcol_off == color_cols[cci[0]]))
                        (ยง
                            ((ร @screenAttrs[off++] =) (hl_attr HLF_MC))
                        )
                        :else
                        (ยง
                            ((ร @screenAttrs[off++] =) 0)
                        ))

                        (if (<= rightmost_vcol (- vcol vcol_off))
                            (ร BREAK)
                        )

                        (ยง vcol++)
                    )
                )

                (screen_line screen_row, (. wp w_wincol), col, (. wp w_width), false)
                (ยง row++)

                ;; Update w_cline_height and w_cline_folded if the cursor line was
                ;; updated (saves a call to plines() later).

                (when (and (== wp @curwin) (== lnum (.. @curwin w_cursor lnum)))
                    ((ร @curwin.w_cline_row =) startrow)
                    ((ร @curwin.w_cline_height =) (- row startrow))
                    ((ร @curwin.w_valid |=) (ยง (VALID_CHEIGHT|VALID_CROW)))
                )

                (ร BREAK)
            )

            ;; line continues beyond line end
            (when (and (!= @lcs_ext NUL) (not @(.. wp w_options wo_wrap)) (== col (- (. wp w_width) 1)) (or (non-eos? ptr) (and (non-zero? n_extra) (or (!= c_extra NUL) (non-eos? p_extra)))))
                ((ร c =) @lcs_ext)
                ((ร char_attr =) (hl_attr HLF_AT))
                ((ร mb_c =) c)
                (cond (< 1 (utf_char2len c))
                (ยง
                    ((ร mb_utf8 =) true)
                    ((ร u8cc[0] =) 0)
                    ((ร c =) 0xc0)
                )
                :else
                (ยง
                    ((ร mb_utf8 =) false)
                ))
            )

            ;; advance to the next 'colorcolumn'
            (if draw_color_col
                ((ร draw_color_col =) (ยง advance_color_col(vcol - vcol_off, color_cols, cci)))
            )

            ;; Highlight the cursor column if 'cursorcolumn' is set.
            ;; But don't highlight the cursor position itself.
            ;; Also highlight the 'colorcolumn' if it is different than 'cursorcolumn'.
            ((ร vcol_save_attr =) -1)
            (when (and (== draw_state WL_LINE) (not lnum_in_visual_area))
                (cond (and @(.. wp w_options wo_cuc) (ยง vcol - vcol_off == wp.w_virtcol) (!= lnum (.. wp w_cursor lnum)))
                (ยง
                    ((ร vcol_save_attr =) char_attr)
                    ((ร char_attr =) (ยง hl_combine_attr(char_attr, hl_attr(HLF_CUC))))
                )
                (and draw_color_col (ยง vcol - vcol_off == color_cols[cci[0]]))
                (ยง
                    ((ร vcol_save_attr =) char_attr)
                    ((ร char_attr =) (ยง hl_combine_attr(char_attr, hl_attr(HLF_MC))))
                ))
            )

            ;; Store character to be displayed.
            ;; Skip characters that are left of the screen for 'nowrap'.

            ((ร vcol_prev =) vcol)
            (cond (or (< draw_state WL_LINE) (<= n_skip 0))
            (ยง
                ;; Store the character.

                (.be @screenLines off, c)
                (cond mb_utf8
                (ยง
                    ((ร @screenLinesUC[off] =) mb_c)
                    (if (zero? (& c 0xff))
                        (.be @screenLines off, 0x80)    ;; avoid storing zero
                    )
                    ((ร FOR) (ร (ยง int i = 0) (< i @screen_mco) (ยง i++))
                        ((ร @screenLinesC[i][off] =) (ยง u8cc[i]))
                        (if (zero? (ยง u8cc[i]))
                            (ร BREAK)
                        )
                    )
                )
                :else
                (ยง
                    ((ร @screenLinesUC[off] =) 0)
                ))
                (cond (non-zero? multi_attr)
                (ยง
                    ((ร @screenAttrs[off] =) multi_attr)
                    ((ร multi_attr =) 0)
                )
                :else
                (ยง
                    ((ร @screenAttrs[off] =) char_attr)
                ))

                (when (< 1 (utf_char2cells mb_c))
                    ;; Need to fill two screen columns.
                    (ยง off++)
                    (ยง col++)
                    ;; UTF-8: Put a 0 in the second screen char.
                    (.be @screenLines off, NUL)
                    (ยง vcol++)
                    ;; When "tocol" is halfway a character, set it to the end
                    ;; of the character, otherwise highlighting won't stop.
                    (if (== (ยง tocol[0]) vcol)
                        (ยง tocol[0]++)
                    )
                )
                (ยง off++)
                (ยง col++)
            )
            (and (< 0 @(.. wp w_options wo_cole)) is_concealing)
            (ยง
                (ยง --n_skip)
                (ยง vcol_off++)
                (if (< 0 n_extra)
                    ((ร vcol_off +=) n_extra)
                )
                (cond @(.. wp w_options wo_wrap)
                (ยง
                    ;; Special voodoo required if 'wrap' is on.
                    ;;
                    ;; Advance the column indicator to force the line drawing to wrap early.
                    ;; This will make the line take up the same screen space when parts are concealed,
                    ;; so that cursor line computations aren't messed up.
                    ;;
                    ;; To avoid the fictitious advance of 'col' causing trailing junk to be written
                    ;; out of the screen line we are building, 'boguscols' keeps track of the number
                    ;; of bad columns we have advanced.

                    (when (< 0 n_extra)
                        ((ร vcol +=) n_extra)
                        ((ร col +=) n_extra)
                        ((ร boguscols +=) n_extra)
                        ((ร n_extra =) 0)
                        ((ร n_attr =) 0)
                    )

                    (when (< 1 (utf_char2cells mb_c))
                        ;; Need to fill two screen columns.
                        (ยง boguscols++)
                        (ยง col++)
                    )

                    (ยง boguscols++)
                    (ยง col++)
                )
                :else
                (ยง
                    (when (< 0 n_extra)
                        ((ร vcol +=) n_extra)
                        ((ร n_extra =) 0)
                        ((ร n_attr =) 0)
                    )
                ))
            )
            :else
            (ยง
                (ยง --n_skip)
            ))

            ;; Only advance the "vcol" when after the 'number' or 'relativenumber' column.
            (if (< WL_NR draw_state)
                (ยง vcol++)
            )

            (if (<= 0 vcol_save_attr)
                ((ร char_attr =) vcol_save_attr)
            )

            ;; restore attributes after "predeces" in 'listchars'
            (if (and (< WL_NR draw_state) (< 0 n_attr3) (zero? (ยง --n_attr3)))
                ((ร char_attr =) saved_attr3)
            )

            ;; restore attributes after last 'listchars' or 'number' char
            (if (and (< 0 n_attr) (== draw_state WL_LINE) (zero? (ยง --n_attr)))
                ((ร char_attr =) saved_attr2)
            )

            ;; At end of screen line and there is more to come:
            ;; display the line so far.
            ;; If there is no more to display it is caught above.

            (when (and (<= (. wp w_width) col) (or (non-eos? ptr) (and (non-zero? n_extra) (or (!= c_extra NUL) (non-eos? p_extra)))))
                (screen_line screen_row, (. wp w_wincol), (- col boguscols), (. wp w_width), false)
                ((ร boguscols =) 0)
                (ยง row++)
                (ยง screen_row++)

                ;; When not wrapping and finished diff lines, or when displayed
                ;; '$' and highlighting until last column, break here.
                (if (or (not @(.. wp w_options wo_wrap)) (== lcs_eol_one -1))
                    (ร BREAK)
                )

                ;; When the window is too narrow draw all "@" lines.
                (when (!= draw_state WL_LINE)
                    (win_draw_end wp, (byte \@), (byte \space), row, (. wp w_height), HLF_AT)
                    (draw_vsep_win wp, row)
                    ((ร row =) endrow)
                )

                ;; When line got too long for screen break here.
                (when (== row endrow)
                    (ยง row++)
                    (ร BREAK)
                )

                (when (and (== @screen_cur_row (- screen_row 1)) (== (. wp w_width) (int @Columns)))
                    ;; Remember that the line wraps, used for modeless copy.
                    ((ร @lineWraps[screen_row - 1] =) true)

                    ;; Special trick to make copy/paste of wrapped lines work with xterm/screen:
                    ;; write an extra character beyond the end of the line.
                    ;; This will work with all terminal types (regardless of the xn,am settings).
                    ;; Only do this if the cursor is on the current line (something has been written in it).
                    ;; Don't do this for the GUI.
                    ;; Don't do this for double-width characters.
                    ;; Don't do this for a window not at the right screen border.

                    (when (not (or (ยง (utf_off2cells(@lineOffset[screen_row], @lineOffset[screen_row] + @screenColumns)) == 2) (ยง (utf_off2cells(@lineOffset[screen_row - 1] + ((int)@Columns - 2), @lineOffset[screen_row] + @screenColumns)) == 2)))
                        ((ร int eoff =) (ยง @lineOffset[screen_row - 1] + ((int)@Columns - 1)))

                        ;; First make sure we are at the end of the screen line,
                        ;; then output the same character again to let the terminal know about the wrap.
                        ;; If the terminal doesn't auto-wrap, we overwrite the character.
                        (if (!= @screen_cur_col (. wp w_width))
                            (screen_char eoff, (- screen_row 1), (ยง ((int)@Columns - 1))))

                        ;; When there is a multi-byte character,
                        ;; just output a space to keep it simple.
                        (if (< 1 (us_byte2len (.at @screenLines eoff), false))
                            (out_char (byte \space))
                            (out_char (.at @screenLines eoff)))
                        ;; force a redraw of the first char on the next line
                        ((ร @screenAttrs[@lineOffset[screen_row]] =) -1)
                        (screen_start)     ;; don't know where cursor is now
                    )
                )

                ((ร col =) 0)
                ((ร off =) (BDIFF @current_ScreenLine, @screenLines))

                ;; reset the drawing state for the start of a wrapped line
                ((ร draw_state =) WL_START)
                ((ร saved_n_extra =) n_extra)
                ((ร saved_p_extra =) p_extra)
                ((ร saved_c_extra =) c_extra)
                ((ร saved_char_attr =) char_attr)
                ((ร n_extra =) 0)
                ((ร need_showbreak =) true)
            )
        )

        row
    ))

;; Return if the composing characters at "off_from" and "off_to" differ.
;; Only to be used when screenLinesUC[off_from] != 0.

(defn- #_boolean comp_char_differs [#_int off_from, #_int off_to]
    (ยง
        ((ร FOR) (ร (ยง int i = 0) (< i @screen_mco) (ยง i++))
            (if (!= (ยง @screenLinesC[i][off_from]) (ยง @screenLinesC[i][off_to]))
                ((ร RETURN) true)
            )
            (if (zero? (ยง @screenLinesC[i][off_from]))
                (ร BREAK)
            )
        )
        false
    ))

;; Check whether the given character needs redrawing:
;; - the (first byte of the) character is different
;; - the attributes are different
;; - the character is multi-byte and the next byte is different
;; - the character is two cells wide and the second cell differs.

(defn- #_boolean char_needs_redraw [#_int from, #_int to, #_int cols]
    (ยง
        (ยง 0 < cols && ((@screenLines.at(from) != @screenLines.at(to) || @screenAttrs[from] != @screenAttrs[to]) || (@screenLinesUC[from] != @screenLinesUC[to] || (@screenLinesUC[from] != 0 && comp_char_differs(from, to)) || (1 < utf_off2cells(from, from + cols) && @screenLines.at(from + 1) != @screenLines.at(to + 1)))))
    ))

;; Move one "cooked" screen line to the screen, but only the characters that
;; have actually changed.  Handle insert/delete character.
;; "coloff" gives the first column on the screen for this line.
;; "endcol" gives the columns where valid characters are.
;; "clear_width" is the width of the window.  It's > 0 if the rest of the line
;; needs to be cleared, negative otherwise.
;; "rlflag" is true in a rightleft window:
;;    When true and "clear_width" > 0, clear columns 0 to "endcol"
;;    When false and "clear_width" > 0, clear columns "endcol" to "clear_width"

(defn- #_void screen_line [#_int row, #_int coloff, #_int endcol, #_int clear_width, #_boolean rlflag]
    (ยง
        ((ร int col =) 0)
        ((ร boolean force =) false)              ;; force update rest of the line
        ((ร boolean clear_next =) false)

        ;; Check for illegal row and col, just in case.
        (if (<= @Rows row)
            ((ร row =) (ยง (int)@Rows - 1))
        )
        (if (< @Columns endcol)
            ((ร endcol =) (ยง (int)@Columns))
        )

        ((ร int off_from =) (BDIFF @current_ScreenLine, @screenLines))
        ((ร int off_to =) (ยง @lineOffset[row] + coloff))
        ((ร int max_off_from =) (+ off_from @screenColumns))
        ((ร int max_off_to =) (ยง @lineOffset[row] + @screenColumns))

        (when rlflag
            ;; Clear rest first, because it's left of the text.
            (when (< 0 clear_width)
                (while (ยง col <= endcol && @screenLines.at(off_to) == (byte \space) && @screenAttrs[off_to] == 0 && @screenLinesUC[off_to] == 0)
                    (ยง off_to++)
                    (ยง col++)
                )
                (if (<= col endcol)
                    (screen_fill row, (+ row 1), (+ col coloff), (ยง endcol + coloff + 1), (byte \space), (byte \space), 0))
            )
            ((ร col =) (+ endcol 1))
            ((ร off_to =) (ยง @lineOffset[row] + col + coloff))
            ((ร off_from +=) col)
            ((ร endcol =) (if (< 0 clear_width) clear_width (- clear_width)))
        )

        ((ร boolean redraw_next =) (ยง char_needs_redraw(off_from, off_to, endcol - col)))

        (while (< col endcol)
            (ร int char_cells)             ;; 1: normal char; 2: occupies two display cells
            (if (< (+ col 1) endcol)
                ((ร char_cells =) (utf_off2cells off_from, max_off_from))
                ((ร char_cells =) 1)
            )

            ;; bool: does character need redraw?
            ((ร boolean redraw_this =) redraw_next)
            ;; redraw_this for next character
            ((ร redraw_next =) (ยง force || char_needs_redraw(off_from + char_cells, off_to + char_cells, endcol - col - char_cells)))

            (when redraw_this
                ;; When writing a single-width character over a double-width
                ;; character and at the end of the redrawn text, need to clear out
                ;; the right halve of the old character.
                ;; Also required when writing the right halve of a double-width
                ;; char over the left halve of an existing one.
                (if (ยง col + char_cells == endcol && ((char_cells == 1 && 1 < utf_off2cells(off_to, max_off_to)) || (char_cells == 2 && utf_off2cells(off_to, max_off_to) == 1 && 1 < utf_off2cells(off_to + 1, max_off_to))))
                    ((ร clear_next =) true)
                )

                (.be @screenLines off_to, (ยง @screenLines.at(off_from)))
                ((ร @screenLinesUC[off_to] =) (ยง @screenLinesUC[off_from]))
                (when (!= (ยง @screenLinesUC[off_from]) 0)
                    ((ร FOR) (ร (ยง int i = 0) (< i @screen_mco) (ยง i++))
                        ((ร @screenLinesC[i][off_to] =) (ยง @screenLinesC[i][off_from]))
                    )
                )
                (if (== char_cells 2)
                    (ยง @screenLines.be(off_to + 1, @screenLines.at(off_from + 1)))
                )

                ;; The bold trick makes a single column of pixels appear in the
                ;; next character.  When a bold character is removed, the next
                ;; character should be redrawn too.  This happens for our own GUI
                ;; and for some xterms.
                (when @term_is_xterm
                    ((ร int hl =) (ยง @screenAttrs[off_to]))
                    (if (< HL_ALL hl)
                        ((ร hl =) (syn_attr2attr hl))
                    )
                    (if (non-zero? (& hl HL_BOLD))
                        ((ร redraw_next =) true)
                    )
                )
                ((ร @screenAttrs[off_to] =) (ยง @screenAttrs[off_from]))
                ;; For simplicity, set the attributes of second half
                ;; of a double-wide character equal to the first half.
                (if (== char_cells 2)
                    ((ร @screenAttrs[off_to + 1] =) (ยง @screenAttrs[off_from]))
                )

                (screen_char off_to, row, (+ col coloff))
            )

            ((ร off_to +=) char_cells)
            ((ร off_from +=) char_cells)
            ((ร col +=) char_cells)
        )

        (when clear_next
            ;; Clear the second half of a double-wide character of which
            ;; the left half was overwritten with a single-wide character.
            (ยง @screenLines.be(off_to, (byte \space)))
            ((ร @screenLinesUC[off_to] =) 0)
            (screen_char off_to, row, (+ col coloff))
        )

        (when (and (< 0 clear_width) (not rlflag))
            ;; blank out the rest of the line
            (while (ยง col < clear_width && @screenLines.at(off_to) == (byte \space) && @screenAttrs[off_to] == 0 && @screenLinesUC[off_to] == 0)
                (ยง off_to++)
                (ยง col++)
            )
            (when (< col clear_width)
                (screen_fill row, (+ row 1), (+ col coloff), (+ clear_width coloff), (byte \space), (byte \space), 0)
                ((ร off_to +=) (- clear_width col))
                ((ร col =) clear_width)
            )
        )

        (when (< 0 clear_width)
            ;; For a window that's left of another, draw the separator char.
            (cond (< (+ col coloff) (int @Columns))
            (ยง
                ((ร int[] hl =) (ยง new int[1]))
                ((ร int c =) (fillchar_vsep hl))
                (when (or (!= (.at @screenLines off_to) c) (!= (ยง @screenLinesUC[off_to]) (if (<= 0x80 c) c 0)) (!= (ยง @screenAttrs[off_to]) (ยง hl[0])))
                    (.be @screenLines off_to, c)
                    ((ร @screenAttrs[off_to] =) (ยง hl[0]))
                    (cond (<= 0x80 c)
                    (ยง
                        ((ร @screenLinesUC[off_to] =) c)
                        ((ร @screenLinesC[0][off_to] =) 0)
                    )
                    :else
                    (ยง
                        ((ร @screenLinesUC[off_to] =) 0)
                    ))
                    (screen_char off_to, row, (+ col coloff))
                )
            )
            :else
            (ยง
                ((ร @lineWraps[row] =) false)
            ))
        )
    ))

;; mark all status lines for redraw

(defn- #_void status_redraw_all []
    (ยง
        ((ร FOR) (ร (ยง window_C wp = @firstwin) (!= wp null) (ยง wp = wp.w_next))
            (when (!= (. wp w_status_height) 0)
                ((ร wp.w_redr_status =) true)
                (redraw_later VALID)
            )
        )
    ))

;; Redraw all status lines that need to be redrawn.

(defn- #_void redraw_statuslines []
    (ยง
        ((ร FOR) (ร (ยง window_C wp = @firstwin) (!= wp null) (ยง wp = wp.w_next))
            (when (. wp w_redr_status)
                (win_redr_status wp)
            )
        )
    ))

;; Draw the verticap separator right of window "wp" starting with line "row".

(defn- #_void draw_vsep_win [#_window_C wp, #_int row]
    (ยง
        (when (!= (. wp w_vsep_width) 0)
            ;; draw the vertical separator right of this window
            ((ร int[] hl =) (ยง new int[1]))
            ((ร int c =) (fillchar_vsep hl))
            (ยง screen_fill(wp.w_winrow + row, wp.w_winrow + wp.w_height, wp.w_wincol + wp.w_width, wp.w_wincol + wp.w_width + 1, c, (byte \space), hl[0]))
        )
    ))

(atom! boolean _3_busy)

;; Redraw the status line of window wp.
;;
;; If inversion is possible we use it.  Else '=' characters are used.

(defn- #_void win_redr_status [#_window_C wp]
    (ยง
        ;; It's possible to get here recursively when 'statusline' (indirectly)
        ;; invokes ":redrawstatus".  Simply ignore the call then.
        (if @_3_busy
            (ร RETURN)
        )
        (reset! _3_busy true)

        ((ร wp.w_redr_status =) false)
        (cond (zero? (. wp w_status_height))
        (ยง
            ;; no status line, can only be last window
            (reset! redraw_cmdline true)
        )
        (not (redrawing))
        (ยง
            ;; Don't redraw right now, do it later.
            ((ร wp.w_redr_status =) true)
        )
        :else
        (ยง
            ((ร int[] attr =) (ยง new int[1]))
            ((ร int fillchar =) (ยง fillchar_status(attr, wp == @curwin)))

            (get_trans_bufname @curbuf)
            ((ร Bytes p =) @nameBuff)
            ((ร int len =) (STRLEN p))

            (when @(. @curbuf b_changed)
                (ยง p.be(len++, (byte \space)))
                (STRCPY (.plus p len), (u8 "[+]"))
                ((ร len +=) 3)
            )

            ((ร int this_ru_col =) (ยง @ru_col - ((int)@Columns - wp.w_width)))
            (if (< this_ru_col (ยง (wp.w_width + 1) / 2))
                ((ร this_ru_col =) (ยง (wp.w_width + 1) / 2))
            )
            (cond (<= this_ru_col 1)
            (ยง
                ((ร p =) (u8 "<"))                    ;; No room for file name!
                ((ร len =) 1)
            )
            :else
            (ยง
                ;; Count total number of display cells.
                ((ร len =) (us_string2cells p, -1))

                ;; Find first character that will fit.
                ;; Going from start to end is much faster for DBCS.
                (ร int i)
                ((ร FOR) (ร (ยง i = 0) (ยง p.at(i) != NUL && this_ru_col - 1 <= len) (ยง i += us_ptr2len_cc(p.plus(i))))
                    ((ร len -=) (ยง us_ptr2cells(p.plus(i))))
                )
                (when (< 0 i)
                    ((ร p =) (ยง p.plus(i - 1)))
                    (.be p 0, (byte \<))
                    (ยง len++)
                )
            ))

            ((ร int row =) (ยง wp.w_winrow + wp.w_height))
            (screen_puts p, row, (. wp w_wincol), (ยง attr[0]))
            (screen_fill row, (+ row 1), (+ len (. wp w_wincol)), (+ this_ru_col (. wp w_wincol)), fillchar, fillchar, (ยง attr[0]))

            (win_redr_ruler wp, true)
        ))

        ;; May need to draw the character below the vertical separator.

        (when (and (!= (. wp w_vsep_width) 0) (!= (. wp w_status_height) 0) (redrawing))
            (ร int fillchar)
            ((ร int[] attr =) (ยง new int[1]))
            (if (stl_connected wp)
                ((ร fillchar =) (ยง fillchar_status(attr, wp == @curwin)))
                ((ร fillchar =) (fillchar_vsep attr))
            )
            (screen_putchar fillchar, (+ (. wp w_winrow) (. wp w_height)), (+ (. wp w_wincol) (. wp w_width)), (ยง attr[0]))
        )
        (reset! _3_busy false)
    ))

;; Return true if the status line of window "wp" is connected to the status
;; line of the window right of it.  If not, then it's a vertical separator.
;; Only call if (wp.w_vsep_width != 0).

(defn- #_boolean stl_connected [#_window_C wp]
    (ยง
        ((ร FOR) (ร (ยง frame_C fr = wp.w_frame) (ยง fr.fr_parent != null) (ยง fr = fr.fr_parent))
            (cond (== (.. fr fr_parent fr_layout) FR_COL)
            (ยง
                (if (!= (. fr fr_next) null)
                    (ร BREAK)
                )
            )
            :else
            (ยง
                (if (!= (. fr fr_next) null)
                    ((ร RETURN) true)
                )
            ))
        )
        false
    ))

;; Output a single character directly to the screen and update "screenLines".

(defn- #_void screen_putchar [#_int c, #_int row, #_int col, #_int attr]
    (ยง
        ((ร Bytes buf =) (ยง new Bytes(MB_MAXBYTES + 1)))

        (ยง buf.be(utf_char2bytes(c, buf), NUL))
        (screen_puts buf, row, col, attr)
    ))

;; Get a single character directly from "screenLines" into "bytes[]".
;; Also return its attribute in "*attrp".

(defn- #_void screen_getbytes [#_int row, #_int col, #_Bytes bytes, #_int* attrp]
    (ยง
        ;; safety check
        (when (and (non-nil? @screenLines) (< row @screenRows) (< col @screenColumns))
            ((ร int off =) (ยง @lineOffset[row] + col))

            ((ร attrp[0] =) (ยง @screenAttrs[off]))
            (.be bytes 0, (ยง @screenLines.at(off)))
            (.be bytes 1, NUL)

            (if (!= (ยง @screenLinesUC[off]) 0)
                (ยง bytes.be(utfc_char2bytes(off, bytes), NUL))
            )
        )
    ))

;; Return true if composing characters for screen posn "off"
;; differs from composing characters in "u8cc".
;; Only to be used when screenLinesUC[off] != 0.

(defn- #_boolean screen_comp_differs [#_int off, #_int* u8cc]
    (ยง
        ((ร FOR) (ร (ยง int i = 0) (< i @screen_mco) (ยง i++))
            (if (!= (ยง @screenLinesC[i][off]) (ยง u8cc[i]))
                ((ร RETURN) true)
            )
            (if (zero? (ยง u8cc[i]))
                (ร BREAK)
            )
        )
        false
    ))

;; Put string '*text' on the screen at position 'row' and 'col', with
;; attributes 'attr', and update screenLines[] and screenAttrs[].
;; Note: only outputs within one row, message is truncated at screen boundary!
;; Note: if screenLines[], row and/or col is invalid, nothing is done.

(defn- #_void screen_puts [#_Bytes text, #_int row, #_int col, #_int attr]
    (screen_puts_len text, -1, row, col, attr))

;; Like screen_puts(), but output "text[len]".  When "len" is -1 output up to a NUL.

(defn- #_void screen_puts_len [#_Bytes text, #_int textlen, #_int row, #_int col, #_int attr]
    (ยง
        ((ร boolean clear_next_cell =) false)
        ((ร boolean force_redraw_next =) false)

        (if (or (nil? @screenLines) (<= @screenRows row))       ;; safety check
            (ร RETURN)
        )

        ((ร int off =) (ยง @lineOffset[row] + col))

        ;; When drawing over the right halve of a double-wide char clear out the left halve.
        ;; Only needed in a terminal.
        (when (and (< 0 col) (< col @screenColumns) (ยง (mb_fix_col(col, row)) != col))
            (ยง @screenLines.be(off - 1, (byte \space)))
            ((ร @screenAttrs[off - 1] =) 0)
            ((ร @screenLinesUC[off - 1] =) 0)
            ((ร @screenLinesC[0][off - 1] =) 0)
            ;; redraw the previous cell, make it empty
            (screen_char (- off 1), row, (- col 1))
            ;; force the cell at "col" to be redrawn
            ((ร force_redraw_next =) true)
        )

        ((ร Bytes ptr =) text)
        ((ร int len =) textlen)
        ((ร int[] u8cc =) (ยง new int[MAX_MCO]))

        ((ร int max_off =) (ยง @lineOffset[row] + @screenColumns))
        (while (ยง col < @screenColumns && (len < 0 || BDIFF(ptr, text) < len) && ptr.at(0) != NUL)
            ((ร byte c =) (ยง ptr.at(0)))

            (ร int mbyte_blen)
            ;; check if this is the first byte of a multibyte
            (if (< 0 len)
                ((ร mbyte_blen =) (ยง us_ptr2len_cc_len(ptr, BDIFF(text.plus(len), ptr))))
                ((ร mbyte_blen =) (us_ptr2len_cc ptr))
            )

            (ร int u8c)
            (if (<= 0 len)
                ((ร u8c =) (ยง us_ptr2char_cc_len(ptr, u8cc, BDIFF(text.plus(len), ptr))))
                ((ร u8c =) (us_ptr2char_cc ptr, u8cc))
            )

            ((ร int mbyte_cells =) (utf_char2cells u8c))

            (when (< @screenColumns (+ col mbyte_cells))
                ;; Only 1 cell left, but character requires 2 cells:
                ;; display a '>' in the last column to avoid wrapping.
                ((ร c =) (byte \>))
                ((ร mbyte_cells =) 1)
            )

            ((ร boolean force_redraw_this =) force_redraw_next)
            ((ร force_redraw_next =) false)

            ((ร boolean need_redraw =) (or (!= (.at @screenLines off) c) (and (== mbyte_cells 2) (!= (.at @screenLines (+ off 1)) 0)) (or (!= (ยง @screenLinesUC[off]) (if (and (< (char_u c) 0x80) (== (ยง u8cc[0]) 0)) 0 u8c)) (and (!= (ยง @screenLinesUC[off]) 0) (screen_comp_differs off, u8cc))) (!= (ยง @screenAttrs[off]) attr)))

            (when (or need_redraw force_redraw_this)
                ;; The bold trick makes a single row of pixels appear in the next character.
                ;; When a bold character is removed, the next character should be redrawn too.
                ;; This happens for our own GUI and for some xterms.
                (when (and need_redraw (!= (.at @screenLines off) (byte \space)) @term_is_xterm)
                    ((ร int n =) (ยง @screenAttrs[off]))

                    (if (< HL_ALL n)
                        ((ร n =) (syn_attr2attr n))
                    )
                    (if (non-zero? (& n HL_BOLD))
                        ((ร force_redraw_next =) true)
                    )
                )
                ;; When at the end of the text and overwriting a two-cell character with
                ;; a one-cell character, need to clear the next cell.  Also when overwriting
                ;; the left halve of a two-cell char with the right halve of a two-cell char.
                ;; Do this only once (utf_off2cells() may return 2 on the right halve).
                (cond clear_next_cell
                (ยง
                    ((ร clear_next_cell =) false)
                )
                (and (if (< len 0) (== (.at ptr mbyte_blen) NUL) (BLE (.plus text len), (.plus ptr mbyte_blen))) (or (and (== mbyte_cells 1) (< 1 (utf_off2cells off, max_off))) (and (== mbyte_cells 2) (== (utf_off2cells off, max_off) 1) (< 1 (utf_off2cells (+ off 1), max_off)))))
                (ยง
                    ((ร clear_next_cell =) true)
                ))

                (.be @screenLines off, c)
                ((ร @screenAttrs[off] =) attr)

                (cond (and (< (char_u c) 0x80) (zero? (ยง u8cc[0])))
                (ยง
                    ((ร @screenLinesUC[off] =) 0)
                )
                :else
                (ยง
                    ((ร @screenLinesUC[off] =) u8c)
                    ((ร FOR) (ร (ยง int i = 0) (< i @screen_mco) (ยง i++))
                        ((ร @screenLinesC[i][off] =) (ยง u8cc[i]))
                        (if (zero? (ยง u8cc[i]))
                            (ร BREAK)
                        )
                    )
                ))
                (when (== mbyte_cells 2)
                    (ยง @screenLines.be(off + 1, NUL))
                    ((ร @screenAttrs[off + 1] =) attr)
                )
                (screen_char off, row, col)
            )

            ((ร off +=) mbyte_cells)
            ((ร col +=) mbyte_cells)
            ((ร ptr =) (ยง ptr.plus(mbyte_blen)))
            (when clear_next_cell
                ;; This only happens at the end, display one space next.
                ((ร ptr =) (u8 " "))
                ((ร len =) -1)
            )
        )

        ;; If we detected the next character needs to be redrawn,
        ;; but the text doesn't extend up to there, update the character here.
        (when (and force_redraw_next (< col @screenColumns))
            (screen_char off, row, col)
        )
    ))

;; Prepare for 'hlsearch' highlighting.

(defn- #_void start_search_hl []
    (ยง
        (when (and @p_hls (not @no_hlsearch))
            (last_pat_prog (. @search_hl rmm))
            ((ร @search_hl.attr =) (hl_attr HLF_L))
            ;; Set the time limit to 'redrawtime'.
            ((ร @search_hl.nsec =) (profile_setlimit @p_rdt))
        )
    ))

;; Clean up for 'hlsearch' highlighting.

(defn- #_void end_search_hl []
    (ยง
        (when (!= (.. @search_hl rmm regprog) null)
            ((ร @search_hl.rmm.regprog =) null)
        )
    ))

;; Init for calling prepare_search_hl().

(defn- #_void init_search_hl [#_window_C wp]
    (ยง
        ;; Setup for match and 'hlsearch' highlighting.  Disable any previous match.
        ((ร FOR) (ร (ยง matchitem_C mi = wp.w_match_head) (!= mi null) (ยง mi = mi.next))
            (COPY_regmmatch (.. mi mi_hl rmm), (. mi mi_match))
            ((ร mi.mi_hl.attr =) (if (!= (. mi hlg_id) 0) (syn_id2attr (. mi hlg_id)) 0))
            ((ร mi.mi_hl.buf =) @curbuf)
            ((ร mi.mi_hl.lnum =) 0)
            ((ร mi.mi_hl.first_lnum =) 0)
            ;; Set the time limit to 'redrawtime'.
            ((ร mi.mi_hl.nsec =) (profile_setlimit @p_rdt))
        )
        ((ร @search_hl.buf =) @curbuf)
        ((ร @search_hl.lnum =) 0)
        ((ร @search_hl.first_lnum =) 0)
        ;; time limit is set at the toplevel, for all windows
    ))

;; Advance to the match in window "wp" line "lnum" or past it.

(defn- #_void prepare_search_hl [#_window_C wp, #_long lnum]
    (ยง
        ;; When using a multi-line pattern, start searching at the top
        ;; of the window or just after a closed fold.
        ;; Do this both for search_hl and the match list.

        ((ร matchitem_C mi =) (. wp w_match_head))
        ((ร boolean shl_flag =) false)               ;; whether search_hl has been processed
        (while (ยง mi != null || !shl_flag)
            (ร match_C shl)                        ;; points to search_hl or a match
            (cond (not shl_flag)
            (ยง
                ((ร shl =) @search_hl)
                ((ร shl_flag =) true)
            )
            :else
            (ยง
                ((ร shl =) (. mi mi_hl))
            ))
            (when (and (!= (.. shl rmm regprog) null) (zero? (. shl lnum)) (re_multiline (.. shl rmm regprog)))
                (if (zero? (. shl first_lnum))
                    ((ร shl.first_lnum =) (. wp w_topline))
                )
                (if (non-nil? mi)
                    ((ร mi.mi_pos.cur =) 0)
                )
                ((ร boolean pos_inprogress =) true)  ;; marks that position match search is in progress
                ((ร int n =) 0)
                (while (ยง shl.first_lnum < lnum && (shl.rmm.regprog != null || (mi != null && pos_inprogress)))
                    (next_search_hl wp, shl, (. shl first_lnum), n, mi)
                    ((ร pos_inprogress =) (ยง (mi != null && mi.mi_pos.cur != 0)))
                    (cond (!= (. shl lnum) 0)
                    (ยง
                        ((ร shl.first_lnum =) (ยง shl.lnum + shl.rmm.endpos[0].lnum - shl.rmm.startpos[0].lnum))
                        ((ร n =) (ยง shl.rmm.endpos[0].col))
                    )
                    :else
                    (ยง
                        (ยง shl.first_lnum++)
                        ((ร n =) 0)
                    ))
                )
            )
            (if (and (!= shl @search_hl) (non-nil? mi))
                ((ร mi =) (. mi next))
            )
        )
    ))

;; Search for a next 'hlsearch' or match.
;; Uses shl.buf.
;; Sets shl.lnum and shl.rmm contents.
;; Note: Assumes a previous match is always before "lnum", unless shl.lnum is zero.
;; Careful: Any pointers for buffer lines will become invalid.

(defn- #_void next_search_hl [#_window_C win, #_match_C shl, #_long lnum, #_int mincol, #_matchitem_C mi]
    ;; shl: points to search_hl or a match
    ;; mincol: minimal column for a match
    ;; mi: to retrieve match positions if any
    (ยง
        (when (!= (. shl lnum) 0)
            ;; Check for three situations:
            ;; 1. If the "lnum" is below a previous match, start a new search.
            ;; 2. If the previous match includes "mincol", use it.
            ;; 3. Continue after the previous match.

            ((ร long l =) (ยง shl.lnum + shl.rmm.endpos[0].lnum - shl.rmm.startpos[0].lnum))
            (cond (< l lnum)
            (ยง
                ((ร shl.lnum =) 0)
            )
            (or (< lnum l) (< mincol (ยง shl.rmm.endpos[0].col)))
            (ยง
                (ร RETURN)
            ))
        )

        ;; Repeat searching for a match until one is found that includes "mincol"
        ;; or none is found in this line.

        (reset! called_emsg false)
        (while true
            ;; Stop searching after passing the time limit.
            (when (profile_passed_limit (. shl nsec))
                ((ร shl.lnum =) 0)   ;; no match found in time
                (ร BREAK)
            )
            ;; Three situations:
            ;; 1. No useful previous match: search from start of line.
            ;; 2. Not Vi compatible or empty match: continue at next character.
            ;;    Break the loop if this is beyond the end of the line.
            ;; 3. Vi compatible searching: continue at end of previous match.

            (ร int matchcol)
            (cond (zero? (. shl lnum))
            (ยง
                ((ร matchcol =) 0)
            )
            (or (nil? (vim_strbyte @p_cpo, CPO_SEARCH)) (and (zero? (ยง shl.rmm.endpos[0].lnum)) (<= (ยง shl.rmm.endpos[0].col) (ยง shl.rmm.startpos[0].col))))
            (ยง
                ((ร matchcol =) (ยง shl.rmm.startpos[0].col))
                ((ร Bytes ml =) (ยง ml_get_buf(shl.buf, lnum).plus(matchcol)))
                (when (eos? ml)
                    (ยง matchcol++)
                    ((ร shl.lnum =) 0)
                    (ร BREAK)
                )
                ((ร matchcol +=) (us_ptr2len_cc ml))
            )
            :else
            (ยง
                ((ร matchcol =) (ยง shl.rmm.endpos[0].col))
            ))

            (ร long nmatched)

            ((ร shl.lnum =) lnum)
            (cond (!= (.. shl rmm regprog) null)
            (ยง
                ;; Remember whether shl.rmm is using a copy of the regprog in mi.mi_match.
                ((ร boolean regprog_is_copy =) (ยง (shl != @search_hl && mi != null && shl == mi.mi_hl && mi.mi_match.regprog == mi.mi_hl.rmm.regprog)))

                ((ร nmatched =) (ยง vim_regexec_multi(shl.rmm, win, shl.buf, lnum, matchcol, shl.nsec)))
                ;; Copy the regprog, in case it got freed and recompiled.
                (if regprog_is_copy
                    ((ร mi.mi_match.regprog =) (.. mi mi_hl rmm regprog))
                )

                (when (or @called_emsg @got_int)
                    ;; Error while handling regexp: stop using this regexp.
                    (when (== shl @search_hl)
                        (reset! no_hlsearch true)
                    )
                    ((ร shl.rmm.regprog =) null)
                    ((ร shl.lnum =) 0)
                    (reset! got_int false)    ;; avoid the "Type :quit to exit Vim" message
                    (ร BREAK)
                )
            )
            (non-nil? mi)
            (ยง
                ((ร nmatched =) (if (next_search_hl_pos shl, lnum, (. mi mi_pos), matchcol) 1 0))
            )
            :else
            (ยง
                ((ร nmatched =) 0)
            ))
            (when (zero? nmatched)
                ((ร shl.lnum =) 0)           ;; no match found
                (ร BREAK)
            )
            (when (or (< 0 (ยง shl.rmm.startpos[0].lnum)) (<= mincol (ยง shl.rmm.startpos[0].col)) (< 1 nmatched) (< mincol (ยง shl.rmm.endpos[0].col)))
                ((ร shl.lnum +=) (ยง shl.rmm.startpos[0].lnum))
                (ร BREAK)                  ;; useful match found
            )
        )
    ))

(defn- #_boolean next_search_hl_pos [#_match_C shl, #_long lnum, #_posmatch_C posmatch, #_int mincol]
    ;; shl: points to a match
    ;; posmatch: match positions
    ;; mincol: minimal column for a match
    (ยง
        ((ร int bot =) -1)

        ((ร llpos_C tmp =) (ยง ยง_llpos_C()))

        ((ร shl.lnum =) 0)
        ((ร FOR) (ร (ยง int i = posmatch.cur) (< i MAXPOSMATCH) (ยง i++))
            (if (zero? (ยง posmatch.pm_pos[i].lnum))
                (ร BREAK)
            )
            (if (< (ยง posmatch.pm_pos[i].col) mincol)
                (ร CONTINUE)
            )
            (when (== (ยง posmatch.pm_pos[i].lnum) lnum)
                (cond (== (. shl lnum) lnum)
                (ยง
                    ;; partially sort positions by column numbers on the same line
                    (when (< (ยง posmatch.pm_pos[i].col) (ยง posmatch.pm_pos[bot].col))
                        (COPY_llpos tmp, (ยง posmatch.pm_pos[i]))
                        (COPY_llpos (ยง posmatch.pm_pos[i]), (ยง posmatch.pm_pos[bot]))
                        (COPY_llpos (ยง posmatch.pm_pos[bot]), tmp)
                    )
                )
                :else
                (ยง
                    ((ร bot =) i)
                    ((ร shl.lnum =) lnum)
                ))
            )
        )
        ((ร posmatch.cur =) 0)

        (when (== (. shl lnum) lnum)
            ((ร int start =) (if (== (ยง posmatch.pm_pos[bot].col) 0) 0 (- (ยง posmatch.pm_pos[bot].col) 1)))
            ((ร int end =) (if (== (ยง posmatch.pm_pos[bot].col) 0) MAXCOL (+ start (ยง posmatch.pm_pos[bot].len))))

            ((ร shl.rmm.startpos[0].lnum =) 0)
            ((ร shl.rmm.startpos[0].col =) start)
            ((ร shl.rmm.endpos[0].lnum =) 0)
            ((ร shl.rmm.endpos[0].col =) end)
            ((ร posmatch.cur =) (+ bot 1))

            ((ร RETURN) true)
        )

        false
    ))

(defn- #_void screen_start_highlight [#_int attr]
    (ยง
        ((ร attrentry_C aep =) null)

        (reset! screen_attr attr)
        (when @full_screen
            (when (< HL_ALL attr)                                  ;; special HL attr.
                (if (< 1 @t_colors)
                    ((ร aep =) (syn_cterm_attr2entry attr))
                    ((ร aep =) (syn_term_attr2entry attr))
                )
                (if (nil? aep)                                ;; did ":syntax clear"
                    ((ร attr =) 0)
                    ((ร attr =) (. aep ae_attr))
                )
            )
            (cond (and (non-zero? (& attr HL_BOLD)) (non-nil? @T_MD))          ;; bold
            (ยง
                (out_str @T_MD)
            )
            (and (non-nil? aep) (< 1 @t_colors) (!= (. aep ae_fg_color) 0) (non-zero? @cterm_normal_fg_bold))
            (ยง
                ;; If the Normal FG color has BOLD attribute
                ;; and the new HL has a FG color defined, clear BOLD.
                (out_str @T_ME)
            ))
            (if (and (non-zero? (& attr HL_STANDOUT)) (non-nil? @T_SO))      ;; standout
                (out_str @T_SO))
            (if (and (non-zero? (ยง attr & (HL_UNDERLINE | HL_UNDERCURL))) (non-nil? @T_US)) ;; underline or undercurl
                (out_str @T_US))
            (if (and (non-zero? (& attr HL_ITALIC)) (non-nil? @T_CZH))       ;; italic
                (out_str @T_CZH))
            (if (and (non-zero? (& attr HL_INVERSE)) (non-nil? @T_MR))       ;; inverse (reverse)
                (out_str @T_MR))

            ;; Output the color or start string after bold etc.,
            ;; in case the bold etc. override the color setting.

            (when (non-nil? aep)
                (cond (< 1 @t_colors)
                (ยง
                    (if (!= (. aep ae_fg_color) 0)
                        (term_fg_color (- (. aep ae_fg_color) 1)))
                    (if (!= (. aep ae_bg_color) 0)
                        (term_bg_color (- (. aep ae_bg_color) 1)))
                )
                :else
                (ยง
                    (if (!= (. aep ae_esc_start) null)
                        (out_str (. aep ae_esc_start)))
                ))
            )
        )
    ))

(defn- #_void screen_stop_highlight []
    (ยง
        ((ร boolean do_ME =) false)                          ;; output T_ME code

        (when (non-zero? @screen_attr)
            (when (< HL_ALL @screen_attr)                   ;; special HL attr.
                (ร attrentry_C aep)

                (cond (< 1 @t_colors)
                (ยง
                    ;; Assume that t_me restores the original colors!

                    ((ร aep =) (syn_cterm_attr2entry @screen_attr))
                    (if (and (non-nil? aep) (or (!= (. aep ae_fg_color) 0) (!= (. aep ae_bg_color) 0)))
                        ((ร do_ME =) true)
                    )
                )
                :else
                (ยง
                    ((ร aep =) (syn_term_attr2entry @screen_attr))
                    (when (and (non-nil? aep) (!= (. aep ae_esc_stop) null))
                        (if (zero? (ยง STRCMP(aep.ae_esc_stop, @T_ME)))
                            ((ร do_ME =) true)
                            (out_str (. aep ae_esc_stop)))
                    )
                ))
                (if (nil? aep)                        ;; did ":syntax clear"
                    (reset! screen_attr 0)
                    (reset! screen_attr (. aep ae_attr)))
            )

            ;; Often all ending-codes are equal to T_ME.
            ;; Avoid outputting the same sequence several times.

            (when (non-zero? (& @screen_attr HL_STANDOUT))
                (if (zero? (STRCMP @T_SE, @T_ME))
                    ((ร do_ME =) true)
                    (out_str @T_SE))
            )
            (when (non-zero? (ยง @screen_attr & (HL_UNDERLINE | HL_UNDERCURL)))
                (if (zero? (STRCMP @T_UE, @T_ME))
                    ((ร do_ME =) true)
                    (out_str @T_UE))
            )
            (when (non-zero? (& @screen_attr HL_ITALIC))
                (if (zero? (STRCMP @T_CZR, @T_ME))
                    ((ร do_ME =) true)
                    (out_str @T_CZR))
            )
            (if (or do_ME (non-zero? (ยง @screen_attr & (HL_BOLD | HL_INVERSE))))
                (out_str @T_ME))

            (when (< 1 @t_colors)
                ;; set Normal cterm colors
                (if (non-zero? @cterm_normal_fg_color)
                    (term_fg_color (- @cterm_normal_fg_color 1)))
                (if (non-zero? @cterm_normal_bg_color)
                    (term_bg_color (- @cterm_normal_bg_color 1)))
                (if (non-zero? @cterm_normal_fg_bold)
                    (out_str @T_MD))
            )
        )
        (reset! screen_attr 0)
    ))

;; Reset the colors for a cterm.  Used when leaving Vim.
;; The machine specific code may override this again.

(defn- #_void reset_cterm_colors []
    (ยง
        (when (< 1 @t_colors)
            ;; set Normal cterm colors
            (when (or (< 0 @cterm_normal_fg_color) (< 0 @cterm_normal_bg_color))
                (out_str @T_OP)
                (reset! screen_attr -1)
            )
            (when (non-zero? @cterm_normal_fg_bold)
                (out_str @T_ME)
                (reset! screen_attr -1)
            )
        )
    ))

;; Put character screenLines["off"] on the screen at position "row" and "col",
;; using the attributes from screenAttrs["off"].

(defn- #_void screen_char [#_int off, #_int row, #_int col]
    (ยง
        ;; Check for illegal values, just in case (could happen just after resizing).
        (if (or (<= @screenRows row) (<= @screenColumns col))
            (ร RETURN)
        )

        ;; Outputting a character in the last cell on the screen may scroll the
        ;; screen up.  Only do it when the "xn" termcap property is set, otherwise
        ;; mark the character invalid (update it when scrolled up).
        (when (and (eos? @T_XN) (== row (- @screenRows 1)) (== col (- @screenColumns 1)))
            ((ร @screenAttrs[off] =) -1)
            (ร RETURN)
        )

        ;; Stop highlighting first, so it's easier to move the cursor.

        (ร int attr)
        (if (non-zero? @screen_char_attr)
            ((ร attr =) @screen_char_attr)
            ((ร attr =) (ยง @screenAttrs[off]))
        )
        (if (!= @screen_attr attr)
            (screen_stop_highlight))

        (windgoto row, col)

        (if (!= @screen_attr attr)
            (screen_start_highlight attr))

        (cond (!= (ยง @screenLinesUC[off]) 0)
        (ยง
            ((ร Bytes buf =) (ยง new Bytes(MB_MAXBYTES + 1)))

            ;; Convert UTF-8 character to bytes and write it.
            (ยง buf.be(utfc_char2bytes(off, buf), NUL))

            (out_str buf)
            (if (< 1 (utf_char2cells (ยง @screenLinesUC[off])))
                (swap! screen_cur_col inc))
        )
        :else
        (ยง
            (out_flush_check)
            (out_char (.at @screenLines off))
        ))

        (swap! screen_cur_col inc)
    ))

;; Draw a rectangle of the screen, inverted when "invert" is true.
;; This uses the contents of screenLines[] and doesn't change it.

(defn- #_void screen_draw_rectangle [#_int row, #_int col, #_int height, #_int width, #_boolean invert]
    (ยง
        ;; Can't use "screenLines" unless initialized.
        (if (nil? @screenLines)
            (ร RETURN)
        )

        (if invert
            (reset! screen_char_attr HL_INVERSE))
        ((ร FOR) (ร (ยง int r = row) (ยง r < row + height) (ยง r++))
            ((ร int off =) (ยง @lineOffset[r]))
            ((ร int max_off =) (+ off @screenColumns))
            ((ร FOR) (ร (ยง int c = col) (ยง c < col + width) (ยง c++))
                (screen_char (+ off c), r, c)
                (if (< 1 (utf_off2cells (+ off c), max_off))
                    (ยง c++)
                )
            )
        )
        (reset! screen_char_attr 0)
    ))

;; Redraw the characters for a vertically split window.

(defn- #_void redraw_block [#_int row, #_int end, #_window_C wp]
    (ยง
        (ร int col)
        (ร int width)

        (cond (nil? wp)
        (ยง
            ((ร col =) 0)
            ((ร width =) (ยง (int)@Columns))
        )
        :else
        (ยง
            ((ร col =) (. wp w_wincol))
            ((ร width =) (. wp w_width))
        ))

        (screen_draw_rectangle row, col, (- end row), width, false)
    ))

;; Fill the screen from 'start_row' to 'end_row', from 'start_col' to 'end_col'
;; with character 'c1' in first column followed by 'c2' in the other columns.
;; Use attributes 'attr'.

(defn- #_void screen_fill [#_int start_row, #_int end_row, #_int start_col, #_int end_col, #_int c1, #_int c2, #_int attr]
    (ยง
        ((ร boolean force_next =) false)

        (if (< @screenRows end_row)               ;; safety check
            ((ร end_row =) @screenRows)
        )
        (if (< @screenColumns end_col)            ;; safety check
            ((ร end_col =) @screenColumns)
        )
        (when (or (nil? @screenLines) (<= end_row start_row) (<= end_col start_col))        ;; nothing to do
            (ร RETURN)
        )

        ;; it's a "normal" terminal when not in a GUI or cterm
        ((ร boolean norm_term =) (ยง (@t_colors <= 1)))

        ((ร FOR) (ร (ยง int row = start_row) (< row end_row) (ยง row++))
            ;; When drawing over the right halve of a double-wide char clear out the left halve.
            ;; When drawing over the left halve of a double wide-char clear out the right halve.
            ;; Only needed in a terminal.
            (if (and (< 0 start_col) (ยง (mb_fix_col(start_col, row)) != start_col))
                (screen_puts_len (u8 " "), 1, row, (- start_col 1), 0))
            (if (and (< end_col @screenColumns) (ยง (mb_fix_col(end_col, row)) != end_col))
                (screen_puts_len (u8 " "), 1, row, end_col, 0))

            ;; Try to use delete-line termcap code, when no attributes or in a
            ;; "normal" terminal, where a bold/italic space is just a space.

            ((ร boolean did_delete =) false)
            (when (and (== c2 (byte \space)) (== end_col (int @Columns)) (can_clear @T_CE) (or (zero? attr) (and norm_term (<= attr HL_ALL) (zero? (ยง attr & ~(HL_BOLD | HL_ITALIC))))))
                ;; check if we really need to clear something

                ((ร int col =) start_col)
                (if (!= c1 (byte \space))                      ;; don't clear first char
                    (ยง col++)
                )

                ((ร int off =) (ยง @lineOffset[row] + col))
                ((ร int end_off =) (ยง @lineOffset[row] + end_col))

                ;; skip blanks (used often, keep it fast!)
                (while (ยง off < end_off && @screenLines.at(off) == (byte \space) && @screenAttrs[off] == 0 && @screenLinesUC[off] == 0)
                    (ยง off++)
                )
                (when (< off end_off)                  ;; something to be cleared
                    ((ร col =) (ยง off - @lineOffset[row]))
                    (screen_stop_highlight)
                    (term_windgoto row, col)        ;; clear rest of this screen line
                    (out_str @T_CE)
                    (screen_start)                 ;; don't know where cursor is now
                    ((ร col =) (- end_col col))
                    (while (ยง 0 < col--)                   ;; clear chars in "screenLines"
                        (ยง @screenLines.be(off, (byte \space)))
                        ((ร @screenLinesUC[off] =) 0)
                        ((ร @screenAttrs[off] =) 0)
                        (ยง off++)
                    )
                )
                ((ร did_delete =) true)                  ;; the chars are cleared now
            )

            ((ร int off =) (ยง @lineOffset[row] + start_col))
            ((ร int c =) c1)
            ((ร FOR) (ร (ยง int col = start_col) (< col end_col) (ยง col++))
                (when (or (!= (.at @screenLines off) c) (!= (ยง @screenLinesUC[off]) (if (<= 0x80 c) c 0)) (!= (ยง @screenAttrs[off]) attr) force_next)
                    ;; The bold trick may make a single row of pixels appear in
                    ;; the next character.  When a bold character is removed, the
                    ;; next character should be redrawn too.  This happens for our
                    ;; own GUI and for some xterms.
                    (when @term_is_xterm
                        (cond (and (!= (.at @screenLines off) (byte \space)) (or (< HL_ALL (ยง @screenAttrs[off])) (non-zero? (& (ยง @screenAttrs[off]) HL_BOLD))))
                        (ยง
                            ((ร force_next =) true)
                        )
                        :else
                        (ยง
                            ((ร force_next =) false)
                        ))
                    )
                    (.be @screenLines off, c)
                    (cond (<= 0x80 c)
                    (ยง
                        ((ร @screenLinesUC[off] =) c)
                        ((ร @screenLinesC[0][off] =) 0)
                    )
                    :else
                    (ยง
                        ((ร @screenLinesUC[off] =) 0)
                    ))
                    ((ร @screenAttrs[off] =) attr)
                    (if (or (not did_delete) (!= c (byte \space)))
                        (screen_char off, row, col))
                )
                (ยง off++)
                (when (== col start_col)
                    (if did_delete
                        (ร BREAK)
                    )
                    ((ร c =) c2)
                )
            )
            (if (== end_col (int @Columns))
                ((ร @lineWraps[row] =) false)
            )
            (when (== row (- (int @Rows) 1))                ;; overwritten the command line
                (reset! redraw_cmdline true)
                (if (and (== c1 (byte \space)) (== c2 (byte \space)))
                    (reset! clear_cmdline false))      ;; command line has been cleared
                (if (zero? start_col)
                    (reset! mode_displayed false))     ;; mode cleared or overwritten
            )
        )
    ))

;; Check if there should be a delay.
;; Used before clearing or redrawing the screen or the command line.

(defn- #_void check_for_delay [#_boolean check_msg_scroll]
    (ยง
        (when (and (or @emsg_on_display (and check_msg_scroll @msg_scroll)) (not @did_wait_return))
            (out_flush)
            (ui_delay 1000, true)
            (reset! emsg_on_display false)
            (if check_msg_scroll
                (reset! msg_scroll false))
        )
    ))

;; screen_valid -  allocate screen buffers if size changed
;;   If "doclear" is true: clear screen if it has been resized.
;;      Returns true if there is a valid screen to write to.
;;      Returns false when starting up and screen not initialized yet.

(defn- #_boolean screen_valid [#_boolean doclear]
    (ยง
        (screenalloc doclear)           ;; allocate screen buffers if size changed

        (non-nil? @screenLines)
    ))

(atom! boolean _4_entered)  ;; avoid recursiveness

;; Resize the shell to Rows and Columns.
;; Allocate screenLines[] and associated items.
;;
;; There may be some time between setting Rows and Columns and (re)allocating
;; screenLines[].  This happens when starting up and when (manually) changing
;; the shell size.  Always use screenRows and screenColumns to access items
;; in screenLines[].  Use Rows and Columns for positioning text etc. where the
;; final size of the shell is needed.

(defn- #_void screenalloc [#_boolean doclear]
    (ยง
        ((ร int[][] smco =) (ยง new int[MAX_MCO][]))

        ((ร int retry_count =) 0)

;       retry:
        (while true
            ;; Allocation of the screen buffers is done only when the size changes and
            ;; when Rows and Columns have been set and we have started doing full screen stuff.

            (if (ยง (@screenLines != null && (int)@Rows == @screenRows && (int)@Columns == @screenColumns && @screenLinesUC != null && @p_mco == @screen_mco) || (int)@Rows == 0 || (int)@Columns == 0 || (!@full_screen && @screenLines == null))
                (ร RETURN)
            )

            ;; It's possible that we produce an out-of-memory message below, which
            ;; will cause this function to be called again.  To break the loop, just return here.

            (if @_4_entered
                (ร RETURN)
            )
            (reset! _4_entered true)

            ;; Note that the window sizes are updated before reallocating the arrays,
            ;; thus we must not redraw here!

            (swap! redrawingDisabled inc)

            (win_new_shellsize)    ;; fit the windows in the new sized shell

            (comp_col)             ;; recompute columns for shown command and ruler

            ;; We're changing the size of the screen.
            ;; - Allocate new arrays for "screenLines" and "screenAttrs".
            ;; - Move lines from the old arrays into the new arrays, clear extra
            ;;   lines (unless the screen is going to be cleared).
            ;; - Free the old arrays.
            ;;
            ;; If anything fails, make "screenLines" null, so we don't do anything!
            ;; Continuing with the old "screenLines" may result in a crash, because the size is wrong.

            ((ร FOR) (ร (ยง window_C wp = @firstwin) (!= wp null) (ยง wp = wp.w_next))
                (win_free_lines wp)
            )

            ((ร Bytes slis =) (ยง new Bytes((int)(@Rows + 1) * (int)@Columns)))
            ((ร FOR) (ร (ยง int i = 0) (< i MAX_MCO) (ยง i++))
                ((ร smco[i] =) null)
            )
            ((ร int[] sluc =) (ยง new int[(int)(@Rows + 1) * (int)@Columns]))
            ((ร FOR) (ร (ยง int i = 0) (< i @p_mco) (ยง i++))
                ((ร smco[i] =) (ยง new int[(int)(@Rows + 1) * (int)@Columns]))
            )

            ((ร int[] sats =) (ยง new int[(int)(@Rows + 1) * (int)@Columns]))
            ((ร int[] lofs =) (ยง new int[(int)@Rows]))
            ((ร boolean[] lwrs =) (ยง new boolean[(int)@Rows]))

            ((ร FOR) (ร (ยง window_C wp = @firstwin) (!= wp null) (ยง wp = wp.w_next))
                (win_alloc_lines wp)
            )

            ((ร FOR) (ร (ยง int r = 0) (< r @Rows) (ยง r++))
                ((ร lofs[r] =) (ยง r * (int)@Columns))
                ((ร lwrs[r] =) false)

                ;; If the screen is not going to be cleared, copy as much as
                ;; possible from the old screen to the new one and clear the rest
                ;; (used when resizing the window at the "--more--" prompt or
                ;; when executing an external command, for the GUI).

                (when (not doclear)
                    (BFILL slis, (ยง lofs[r]), (byte \space), (int @Columns))
                    (AFILL sluc, (ยง lofs[r]), 0, (int @Columns))
                    ((ร FOR) (ร (ยง int i = 0) (< i @p_mco) (ยง i++))
                        (AFILL (ยง smco[i]), (ยง lofs[r]), 0, (int @Columns))
                    )
                    (AFILL sats, (ยง lofs[r]), 0, (int @Columns))

                    ((ร int r0 =) (ยง r + (@screenRows - (int)@Rows)))
                    (when (and (<= 0 r0) (non-nil? @screenLines))
                        ((ร int off =) (ยง @lineOffset[r0]))
                        ((ร int len =) (if (< @screenColumns (int @Columns)) @screenColumns (int @Columns)))

                        ;; When switching to utf-8 don't copy characters, they
                        ;; may be invalid now.  Also when "p_mco" changes.
                        (when (and (non-nil? @screenLinesUC) (== @p_mco @screen_mco))
                            (BCOPY slis, (ยง lofs[r]), @screenLines, off, len)
                            (ACOPY sluc, (ยง lofs[r]), @screenLinesUC, off, len)
                            ((ร FOR) (ร (ยง int i = 0) (< i @p_mco) (ยง i++))
                                (ACOPY (ยง smco[i]), (ยง lofs[r]), (ยง @screenLinesC[i]), off, len)
                            )
                        )
                        (ACOPY sats, (ยง lofs[r]), @screenAttrs, off, len)
                    )
                )
            )

            ;; Use the last line of the screen for the current line.
            (reset! current_ScreenLine (ยง slis.plus((int)@Rows * (int)@Columns)))

            (reset! screenLines slis)
            (reset! screenLinesUC sluc)
            ((ร FOR) (ร (ยง int i = 0) (< i @p_mco) (ยง i++))
                ((ร @screenLinesC[i] =) (ยง smco[i]))
            )
            (reset! screen_mco (int @p_mco))
            (reset! screenAttrs sats)
            (reset! lineOffset lofs)
            (reset! lineWraps lwrs)

            ;; It's important that screenRows and screenColumns reflect the actual
            ;; size of screenLines[].  Set them before calling anything.
            (reset! screenRows (int @Rows))
            (reset! screenColumns (int @Columns))

            (reset! must_redraw CLEAR)        ;; need to clear the screen later
            (if doclear
                (screenclear2)
            )

            (reset! _4_entered false)
            (swap! redrawingDisabled dec)

            ;; Do not apply autocommands more than 3 times to avoid an endless loop
            ;; in case applying autocommands always changes Rows or Columns.

            (when (and (zero? @starting) (<= (ยง ++retry_count) 3))
                ;; In rare cases, autocommands may have altered Rows or Columns,
                ;; jump back to check if we need to allocate the screen again.
                (ร CONTINUE retry)
            )

            (ร BREAK)
        )
    ))

(defn- #_void screenclear []
    (ยง
        (check_for_delay false)
        (screenalloc false)             ;; allocate screen buffers if size changed
        (screenclear2)                 ;; clear the screen
    ))

(defn- #_void screenclear2 []
    (ยง
        (if (or (== @starting NO_SCREEN) (nil? @screenLines))
            (ร RETURN)
        )

        (reset! screen_attr -1)               ;; force setting the Normal colors
        (screen_stop_highlight)        ;; don't want highlighting here

        ;; blank out "screenLines"
        ((ร FOR) (ร (ยง int i = 0) (< i @Rows) (ยง i++))
            (lineclear (ยง @lineOffset[i]), (int @Columns))
            ((ร @lineWraps[i] =) false)
        )

        (cond (can_clear @T_CL)
        (ยง
            (out_str @T_CL)              ;; clear the display
            (reset! clear_cmdline false)
            (reset! mode_displayed false)
        )
        :else
        (ยง
            ;; can't clear the screen, mark all chars with invalid attributes
            ((ร FOR) (ร (ยง int i = 0) (< i @Rows) (ยง i++))
                (lineinvalid (ยง @lineOffset[i]), (int @Columns))
            )
            (reset! clear_cmdline true)
        ))

        (reset! screen_cleared TRUE)          ;; can use contents of "screenLines" now

        (win_rest_invalid @firstwin)
        (reset! redraw_cmdline true)
        (if (== @must_redraw CLEAR)       ;; no need to clear again
            (reset! must_redraw NOT_VALID))
        (compute_cmdrow)
        (reset! msg_row @cmdline_row)          ;; put cursor on last line for messages
        (reset! msg_col 0)
        (screen_start)                 ;; don't know where cursor is now
        (reset! msg_scrolled 0)               ;; can't scroll back
        (reset! msg_didany false)
        (reset! msg_didout false)
    ))

;; Clear one line in "screenLines".

(defn- #_void lineclear [#_int off, #_int width]
    (ยง
        (BFILL @screenLines, off, (byte \space), width)
        (AFILL @screenLinesUC, off, 0, width)
        (AFILL @screenAttrs, off, 0, width)
    ))

;; Mark one line in "screenLines" invalid by setting the attributes to an invalid value.

(defn- #_void lineinvalid [#_int off, #_int width]
    (AFILL @screenAttrs, off, -1, width))

;; Copy part of a Screenline for vertically split window "wp".

(defn- #_void linecopy [#_int to, #_int from, #_window_C wp]
    (ยง
        ((ร int off_to =) (ยง @lineOffset[to] + wp.w_wincol))
        ((ร int off_from =) (ยง @lineOffset[from] + wp.w_wincol))

        (BCOPY @screenLines, off_to, @screenLines, off_from, (. wp w_width))
        (ACOPY @screenLinesUC, off_to, @screenLinesUC, off_from, (. wp w_width))
        ((ร FOR) (ร (ยง int i = 0) (< i @p_mco) (ยง i++))
            (ACOPY (ยง @screenLinesC[i]), off_to, (ยง @screenLinesC[i]), off_from, (. wp w_width))
        )
        (ACOPY @screenAttrs, off_to, @screenAttrs, off_from, (. wp w_width))
    ))

;; Return true if clearing with term string "p" would work.
;; It can't work when the string is empty or it won't set the right background.

(defn- #_boolean can_clear [#_Bytes p]
    (ยง
        (and (non-eos? p) (or (<= @t_colors 1) (zero? @cterm_normal_bg_color) (non-eos? @T_UT)))
    ))

;; Reset cursor position.  Use whenever cursor was moved because of outputting
;; something directly to the screen (shell commands) or a terminal control code.

(defn- #_void screen_start []
    (ยง
        (reset! screen_cur_row (ยง @screen_cur_col = 9999))
    ))

;; Move the cursor to position "row","col" in the screen.
;; This tries to find the most efficient way to move, minimizing the number of
;; characters sent to the terminal.

(final int
    GOTO_COST  7,   ;; assume a term_windgoto() takes about 7 chars
    HIGHL_COST 5)   ;; assume unhighlight takes 5 chars

(final int
    PLAN_LE    1,
    PLAN_CR    2,
    PLAN_NL    3,
    PLAN_WRITE 4)

(defn- #_void windgoto [#_int row, #_int col]
    (ยง
        ;; Can't use "screenLines" unless initialized.
        (if (nil? @screenLines)
            (ร RETURN)
        )

        (when (or (!= col @screen_cur_col) (!= row @screen_cur_row))
            (ร int cost)

            ;; Check for valid position.
            (if (< row 0)    ;; window without text lines?
                ((ร row =) 0)
            )
            (if (<= @screenRows row)
                ((ร row =) (- @screenRows 1))
            )
            (if (<= @screenColumns col)
                ((ร col =) (- @screenColumns 1))
            )

            ;; check if no cursor movement is allowed in highlight mode
            (ร int noinvcurs)
            (if (and (non-zero? @screen_attr) (eos? @T_MS))
                ((ร noinvcurs =) HIGHL_COST)
                ((ร noinvcurs =) 0)
            )
            ((ร int goto_cost =) (+ GOTO_COST noinvcurs))

            ;; Plan how to do the positioning:
            ;;
            ;; 1. Use CR to move it to column 0, same row.
            ;; 2. Use T_LE to move it a few columns to the left.
            ;; 3. Use NL to move a few lines down, column 0.
            ;; 4. Move a few columns to the right with T_ND or by writing chars.
            ;;
            ;; Don't do this if the cursor went beyond the last column,
            ;; the cursor position is unknown then (some terminals wrap, some don't).
            ;;
            ;; First check if the highlighting attributes allow us to write
            ;; characters to move the cursor to the right.

            (cond (and (<= @screen_cur_row row) (< @screen_cur_col (int @Columns)))
            (ยง
                (ร int plan)
                (ร int wouldbe_col)

                ;; If the cursor is in the same row, bigger col, we can use CR or T_LE.

                ((ร Bytes bs =) null)
                ((ร int attr =) @screen_attr)
                (cond (and (== row @screen_cur_row) (< col @screen_cur_col))
                (ยง
                    ;; "le" is preferred over "bc", because "bc" is obsolete
                    (if (non-eos? @T_LE)
                        ((ร bs =) @T_LE)              ;; "cursor left"
                        ((ร bs =) @T_BC)              ;; "backspace character (old)
                    )
                    (if (non-eos? bs)
                        ((ร cost =) (ยง (@screen_cur_col - col) * STRLEN(bs)))
                        ((ร cost =) 999)
                    )
                    (cond (< (+ col 1) cost)             ;; using CR is less characters
                    (ยง
                        ((ร plan =) PLAN_CR)
                        ((ร wouldbe_col =) 0)
                        ((ร cost =) 1)                   ;; CR is just one character
                    )
                    :else
                    (ยง
                        ((ร plan =) PLAN_LE)
                        ((ร wouldbe_col =) col)
                    ))
                    (when (non-zero? noinvcurs)             ;; will stop highlighting
                        ((ร cost +=) noinvcurs)
                        ((ร attr =) 0)
                    )
                )

                ;; If the cursor is above where we want to be, we can use CR LF.

                (< @screen_cur_row row)
                (ยง
                    ((ร plan =) PLAN_NL)
                    ((ร wouldbe_col =) 0)
                    ((ร cost =) (ยง (row - @screen_cur_row) * 2))  ;; CR LF
                    (when (non-zero? noinvcurs)                 ;; will stop highlighting
                        ((ร cost +=) noinvcurs)
                        ((ร attr =) 0)
                    )
                )

                ;; If the cursor is in the same row, smaller col, just use write.

                :else
                (ยง
                    ((ร plan =) PLAN_WRITE)
                    ((ร wouldbe_col =) @screen_cur_col)
                    ((ร cost =) 0)
                ))

                ;; Check if any characters that need to be written have the
                ;; correct attributes.  Also avoid UTF-8 characters.

                ((ร int i =) (- col wouldbe_col))
                (if (< 0 i)
                    ((ร cost +=) i)
                )
                (when (and (< cost goto_cost) (< 0 i))
                    ;; Check if the attributes are correct without additionally
                    ;; stopping highlighting.

                    ((ร int ai =) (ยง @lineOffset[row] + wouldbe_col))
                    (while (ยง i != 0 && @screenAttrs[ai++] == attr)
                        (ยง --i)
                    )
                    (when (non-zero? i)
                        ;; Try if it works when highlighting is stopped here.

                        (when (zero? (ยง @screenAttrs[--ai]))
                            ((ร cost +=) noinvcurs)
                            (while (ยง i != 0 && @screenAttrs[ai++] == 0)
                                (ยง --i)
                            )
                        )
                        (if (non-zero? i)
                            ((ร cost =) 999)     ;; different attributes, don't do it
                        )
                    )

                    ;; Don't use an UTF-8 char for positioning, it's slow.
                    ((ร FOR) (ร (ยง i = wouldbe_col) (< i col) (ยง i++))
                        (when (ยง @screenLinesUC[@lineOffset[row] + i] != 0)
                            ((ร cost =) 999)
                            (ร BREAK)
                        )
                    )
                )

                ;; We can do it without term_windgoto()!

                (when (< cost goto_cost)
                    (cond (== plan PLAN_LE)
                    (ยง
                        (if (non-zero? noinvcurs)
                            (screen_stop_highlight))
                        (while (< col @screen_cur_col)
                            (out_str bs)
                            (swap! screen_cur_col dec)
                        )
                    )
                    (== plan PLAN_CR)
                    (ยง
                        (if (non-zero? noinvcurs)
                            (screen_stop_highlight))
                        (out_char (byte \return))
                        (reset! screen_cur_col 0)
                    )
                    (== plan PLAN_NL)
                    (ยง
                        (if (non-zero? noinvcurs)
                            (screen_stop_highlight))
                        (while (< @screen_cur_row row)
                            (out_char (byte \newline))
                            (swap! screen_cur_row inc)
                        )
                        (reset! screen_cur_col 0)
                    ))

                    ((ร i =) (- col @screen_cur_col))
                    (when (< 0 i)
                        ;; Use cursor-right if it's one character only.
                        ;; Avoids removing a line of pixels from the last bold char,
                        ;; when using the bold trick in the GUI.

                        (cond (and (non-eos? @T_ND) (eos? @T_ND 1))
                        (ยง
                            (while (ยง 0 < i--)
                                (out_char (.at @T_ND 0))
                            )
                        )
                        :else
                        (ยง
                            ((ร int off =) (ยง @lineOffset[row] + @screen_cur_col))

                            (while (ยง 0 < i--)
                                (if (!= (ยง @screenAttrs[off]) @screen_attr)
                                    (screen_stop_highlight))
                                (out_flush_check)
                                (out_char (.at @screenLines off))
                                (ยง off++)
                            )
                        ))
                    )
                )
            )
            :else
            (ยง
                ((ร cost =) 999)
            ))

            (when (<= goto_cost cost)
                (if (non-zero? noinvcurs)
                    (screen_stop_highlight))
                (if (and (== row @screen_cur_row) (< @screen_cur_col col) (non-eos? @T_CRI))
                    (term_cursor_right (- col @screen_cur_col))
                    (term_windgoto row, col))
            )
            (reset! screen_cur_row row)
            (reset! screen_cur_col col)
        )
    ))

;; Set cursor to its position in the current window.

(defn- #_void setcursor []
    (ยง
        (when (redrawing)
            (validate_cursor)

            (windgoto (+ (. @curwin w_winrow) (. @curwin w_wrow)), (+ (. @curwin w_wincol) (. @curwin w_wcol)))
        )
    ))

;; insert 'line_count' lines at 'row' in window 'wp'
;; if 'invalid' is true the wp.w_lines[].wl_lnum is invalidated.
;; if 'mayclear' is true the screen will be cleared if it is faster than scrolling.
;; Returns false if the lines are not inserted, true for success.

(defn- #_boolean win_ins_lines [#_window_C wp, #_int row, #_int line_count, #_boolean invalid, #_boolean mayclear]
    (ยง
        (if invalid
            ((ร wp.w_lines_valid =) 0)
        )

        (if (< (. wp w_height) 5)
            ((ร RETURN) false)
        )

        (if (> line_count (- (. wp w_height) row))
            ((ร line_count =) (ยง wp.w_height - row))
        )

        ((ร maybean maybe =) (win_do_lines wp, row, line_count, mayclear, false))
        (if (!= maybe MAYBE)
            ((ร RETURN) (ยง (maybe != FALSE)))
        )

        ;; If there is a next window or a status line, we first try to delete the
        ;; lines at the bottom to avoid messing what is after the window.
        ;; If this fails and there are following windows, don't do anything to avoid
        ;; messing up those windows, better just redraw.

        ((ร boolean did_delete =) false)
        (when (or (!= (. wp w_next) null) (!= (. wp w_status_height) 0))
            (cond (screen_del_lines 0, (- (+ (. wp w_winrow) (. wp w_height)) line_count), line_count, (int @Rows), false, null)
            (ยง
                ((ร did_delete =) true)
            )
            (!= (. wp w_next) null)
            (ยง
                ((ร RETURN) false)
            ))
        )

        ;; if no lines deleted, blank the lines that will end up below the window

        (when (not did_delete)
            ((ร wp.w_redr_status =) true)
            (reset! redraw_cmdline true)
            ((ร int nextrow =) (ยง wp.w_winrow + wp.w_height + wp.w_status_height))
            ((ร int lastrow =) (+ nextrow line_count))
            (if (< @Rows lastrow)
                ((ร lastrow =) (ยง (int)@Rows))
            )
            (screen_fill (- nextrow line_count), (- lastrow line_count), (. wp w_wincol), (+ (. wp w_wincol) (. wp w_width)), (byte \space), (byte \space), 0)
        )

        (when (not (screen_ins_lines 0, (+ (. wp w_winrow) row), line_count, (int @Rows), null))
            ;; deletion will have messed up other windows
            (when did_delete
                ((ร wp.w_redr_status =) true)
                (win_rest_invalid (. wp w_next))
            )
            ((ร RETURN) false)
        )

        true
    ))

;; delete "line_count" window lines at "row" in window "wp"
;; If "invalid" is true curwin.w_lines[] is invalidated.
;; If "mayclear" is true the screen will be cleared if it is faster than scrolling
;; Return true for success, false if the lines are not deleted.

(defn- #_boolean win_del_lines [#_window_C wp, #_int row, #_int line_count, #_boolean invalid, #_boolean mayclear]
    (ยง
        (if invalid
            ((ร wp.w_lines_valid =) 0)
        )

        (if (> line_count (- (. wp w_height) row))
            ((ร line_count =) (ยง wp.w_height - row))
        )

        ((ร maybean maybe =) (win_do_lines wp, row, line_count, mayclear, true))
        (if (!= maybe MAYBE)
            ((ร RETURN) (ยง (maybe != FALSE)))
        )

        (if (not (screen_del_lines 0, (+ (. wp w_winrow) row), line_count, (int @Rows), false, null))
            ((ร RETURN) false)
        )

        ;; If there are windows or status lines below, try to put them at the
        ;; correct place.  If we can't do that, they have to be redrawn.

        (cond (or (!= (. wp w_next) null) (!= (. wp w_status_height) 0) (< @cmdline_row (- @Rows 1)))
        (ยง
            (when (not (screen_ins_lines 0, (- (+ (. wp w_winrow) (. wp w_height)) line_count), line_count, (int @Rows), null))
                ((ร wp.w_redr_status =) true)
                (win_rest_invalid (. wp w_next))
            )
        )
        ;; If this is the last window and there is no status line, redraw the command line later.
        :else
        (ยง
            (reset! redraw_cmdline true)
        ))

        true
    ))

;; Common code for win_ins_lines() and win_del_lines().
;; Returns true or false when the work has been done.
;; Returns MAYBE when not finished yet.

(defn- #_maybean win_do_lines [#_window_C wp, #_int row, #_int line_count, #_boolean mayclear, #_boolean del]
    (ยง
        (if (or (not (redrawing)) (<= line_count 0))
            ((ร RETURN) FALSE)
        )

        ;; only a few lines left: redraw is faster
        (when (and mayclear (< (- @Rows line_count) 5) (== (. wp w_width) (int @Columns)))
            (screenclear)      ;; will set wp.w_lines_valid to 0
            ((ร RETURN) FALSE)
        )

        ;; Delete all remaining lines

        (when (<= (. wp w_height) (+ row line_count))
            (screen_fill (+ (. wp w_winrow) row), (+ (. wp w_winrow) (. wp w_height)), (. wp w_wincol), (+ (. wp w_wincol) (. wp w_width)), (byte \space), (byte \space), 0)
            ((ร RETURN) TRUE)
        )

        ;; when scrolling, the message on the command line should be cleared,
        ;; otherwise it will stay there forever.

        (reset! clear_cmdline true)

        ;; If the terminal can set a scroll region, use that.
        ;; Always do this in a vertically split window.  This will redraw from
        ;; screenLines[] when t_CV isn't defined.  That's faster than using win_line().
        ;; Don't use a scroll region when we are going to redraw the text.

        (when (or @scroll_region (!= (. wp w_width) (int @Columns)))
            (if (and @scroll_region (or (== (. wp w_width) (int @Columns)) (non-eos? @T_CSV)))
                (scroll_region_set wp, row))

            (ร boolean r)
            (if del
                ((ร r =) (ยง screen_del_lines(wp.w_winrow + row, 0, line_count, wp.w_height - row, false, wp)))
                ((ร r =) (ยง screen_ins_lines(wp.w_winrow + row, 0, line_count, wp.w_height - row, wp)))
            )

            (if (and @scroll_region (or (== (. wp w_width) (int @Columns)) (non-eos? @T_CSV)))
                (scroll_region_reset))

            ((ร RETURN) (if r TRUE FALSE))
        )

        (if (!= (. wp w_next) null)
            ((ร RETURN) FALSE)
        )

        MAYBE
    ))

;; window 'wp' and everything after it is messed up, mark it for redraw

(defn- #_void win_rest_invalid [#_window_C wp]
    (ยง
        (while (!= wp null)
            (redraw_win_later wp, NOT_VALID)
            ((ร wp.w_redr_status =) true)
            ((ร wp =) (. wp w_next))
        )
        (reset! redraw_cmdline true)
    ))

;; The rest of the routines in this file perform screen manipulations.
;; The given operation is performed physically on the screen.
;; The corresponding change is also made to the internal screen image.
;; In this way, the editor anticipates the effect of editing changes
;; on the appearance of the screen.
;; That way, when we call screenupdate a complete redraw isn't usually necessary.
;; Another advantage is that we can keep adding code to anticipate screen changes,
;; and in the meantime, everything still works.

;; types for inserting or deleting lines

(final int USE_T_CAL   1)
(final int USE_T_CDL   2)
(final int USE_T_AL    3)
(final int USE_T_CE    4)
(final int USE_T_DL    5)
(final int USE_T_SR    6)
(final int USE_NL      7)
(final int USE_T_CD    8)
(final int USE_REDRAW  9)

;; insert lines on the screen and update screenLines[]
;; 'end' is the line after the scrolled part.  Normally it is Rows.
;; When scrolling region used 'off' is the offset from the top for the region.
;; 'row' and 'end' are relative to the start of the region.
;;
;; return false for failure, true for success.

(defn- #_boolean screen_ins_lines [#_int off, #_int row, #_int line_count, #_int end, #_window_C wp]
    ;; wp: null or window to use width from
    (ยง
        ((ร boolean can_ce =) (can_clear @T_CE))

        ;; FAIL if
        ;; - there is no valid screen
        ;; - the screen has to be redrawn completely
        ;; - the line count is less than one
        ;; - the line count is more than 'ttyscroll'

        (when (or (not (screen_valid true)) (<= line_count 0) (< @p_ttyscroll line_count))
            ((ร RETURN) false)
        )

        ;; There are seven ways to insert lines:
        ;;
        ;; 0. When in a vertically split window and t_CV isn't set, redraw the characters from screenLines[].
        ;; 1. Use T_CD (clear to end of display) if it exists and the result of the insert is just empty lines.
        ;; 2. Use T_CAL (insert multiple lines) if it exists and T_AL is not present or line_count > 1.
        ;;    It looks better if we do all the inserts at once.
        ;; 3. Use T_CDL (delete multiple lines) if it exists and the result of the
        ;;    insert is just empty lines and T_CE is not present or line_count > 1.
        ;; 4. Use T_AL (insert line) if it exists.
        ;; 5. Use T_CE (erase line) if it exists and the result of the insert is just empty lines.
        ;; 6. Use T_DL (delete line) if it exists and the result of the insert is just empty lines.
        ;; 7. Use T_SR (scroll reverse) if it exists and inserting at row 0
        ;;    and the 'da' flag is not set or we have clear line capability.
        ;; 8. Redraw the characters from screenLines[].
        ;;
        ;; Careful: In a hpterm scroll reverse doesn't work as expected, it moves
        ;; the scrollbar for the window.  It does have insert line, use that if it exists.

        ((ร boolean result_empty =) (ยง (end <= row + line_count)))

        (ร int type)
        (cond (and (non-nil? wp) (!= (. wp w_width) (int @Columns)) (eos? @T_CSV))
        (ยง
            ((ร type =) USE_REDRAW)
        )
        (and (can_clear @T_CD) result_empty)
        (ยง
            ((ร type =) USE_T_CD)
        )
        (and (non-eos? @T_CAL) (or (< 1 line_count) (eos? @T_AL)))
        (ยง
            ((ร type =) USE_T_CAL)
        )
        (and (non-eos? @T_CDL) result_empty (or (< 1 line_count) (not can_ce)))
        (ยง
            ((ร type =) USE_T_CDL)
        )
        (non-eos? @T_AL)
        (ยง
            ((ร type =) USE_T_AL)
        )
        (and can_ce result_empty)
        (ยง
            ((ร type =) USE_T_CE)
        )
        (and (non-eos? @T_DL) result_empty)
        (ยง
            ((ร type =) USE_T_DL)
        )
        (and (non-eos? @T_SR) (zero? row) (or (eos? @T_DA) can_ce))
        (ยง
            ((ร type =) USE_T_SR)
        )
        :else
        (ยง
            ((ร RETURN) false)
        ))

        ;; For clearing the lines screen_del_lines() is used.  This will also take
        ;; care of t_db if necessary.

        (if (or (== type USE_T_CD) (== type USE_T_CDL) (== type USE_T_CE) (== type USE_T_DL))
            ((ร RETURN) (screen_del_lines off, row, line_count, end, false, wp))
        )

        ;; If text is retained below the screen, first clear or delete as many
        ;; lines at the bottom of the window as are about to be inserted so that
        ;; the deleted lines won't later surface during a screen_del_lines.

        (if (non-eos? @T_DB)
            (screen_del_lines off, (- end line_count), line_count, end, false, wp))

        ((ร int cursor_row =) (+ row off))

        ;; Shift lineOffset[] line_count down to reflect the inserted lines.
        ;; Clear the inserted lines in screenLines[].

        ((ร row +=) off)
        ((ร end +=) off)
        ((ร FOR) (ร (ยง int i = 0) (< i line_count) (ยง i++))
            (cond (and (non-nil? wp) (!= (. wp w_width) (int @Columns)))
            (ยง
                ;; need to copy part of a line
                ((ร int j =) (ยง end - 1 - i))
                (while (ยง row <= (j -= line_count))
                    (linecopy (+ j line_count), j, wp)
                )
                ((ร j +=) line_count)
                (if (can_clear (u8 " "))
                    (lineclear (+ (ยง @lineOffset[j]) (. wp w_wincol)), (. wp w_width))
                    (lineinvalid (+ (ยง @lineOffset[j]) (. wp w_wincol)), (. wp w_width)))
                ((ร @lineWraps[j] =) false)
            )
            :else
            (ยง
                ((ร int j =) (ยง end - 1 - i))
                ((ร int temp =) (ยง @lineOffset[j]))
                (while (ยง row <= (j -= line_count))
                    ((ร @lineOffset[j + line_count] =) (ยง @lineOffset[j]))
                    ((ร @lineWraps[j + line_count] =) (ยง @lineWraps[j]))
                )
                ((ร @lineOffset[j + line_count] =) temp)
                ((ร @lineWraps[j + line_count] =) false)
                (if (can_clear (u8 " "))
                    (lineclear temp, (int @Columns))
                    (lineinvalid temp, (int @Columns)))
            ))
        )

        (screen_stop_highlight)
        (windgoto cursor_row, 0)

        ;; redraw the characters
        (cond (== type USE_REDRAW)
        (ยง
            (redraw_block row, end, wp)
        )
        (== type USE_T_CAL)
        (ยง
            (term_append_lines line_count)
            (screen_start)         ;; don't know where cursor is now
        )
        :else
        (ยง
            ((ร FOR) (ร (ยง int i = 0) (< i line_count) (ยง i++))
                (cond (== type USE_T_AL)
                (ยง
                    (if (and (non-zero? i) (non-zero? cursor_row))
                        (windgoto cursor_row, 0))
                    (out_str @T_AL)
                )
                :else ;; type == USE_T_SR
                (ยง
                    (out_str @T_SR)
                ))
                (screen_start)         ;; don't know where cursor is now
            )
        ))

        ;; With scroll-reverse and 'da' flag set we need to clear the lines that
        ;; have been scrolled down into the region.

        (when (and (== type USE_T_SR) (non-eos? @T_DA))
            ((ร FOR) (ร (ยง int i = 0) (< i line_count) (ยง i++))
                (windgoto (+ off i), 0)
                (out_str @T_CE)
                (screen_start)         ;; don't know where cursor is now
            )
        )

        true
    ))

;; delete lines on the screen and update screenLines[]
;; 'end' is the line after the scrolled part.  Normally it is Rows.
;; When scrolling region used 'off' is the offset from the top for the region.
;; 'row' and 'end' are relative to the start of the region.
;;
;; Return true for success, false if the lines are not deleted.

(defn- #_boolean screen_del_lines [#_int off, #_int row, #_int line_count, #_int end, #_boolean force, #_window_C wp]
    ;; force: even when line_count > p_ttyscroll
    ;; wp: null or window to use width from
    (ยง
        ;; FAIL if
        ;; - there is no valid screen
        ;; - the screen has to be redrawn completely
        ;; - the line count is less than one
        ;; - the line count is more than 'ttyscroll'

        (if (or (not (screen_valid true)) (<= line_count 0) (and (not force) (< @p_ttyscroll line_count)))
            ((ร RETURN) false)
        )

        ;; Check if the rest of the current region will become empty.

        ((ร boolean result_empty =) (ยง (end <= row + line_count)))

        ;; We can delete lines only when 'db' flag not set or when 'ce' option available.

        ((ร boolean can_delete =) (ยง (@T_DB.at(0) == NUL || can_clear(@T_CE))))

        (ร int type)

        ;; There are six ways to delete lines:
        ;;
        ;; 0. When in a vertically split window and t_CV isn't set, redraw the characters from screenLines[].
        ;; 1. Use T_CD if it exists and the result is empty.
        ;; 2. Use newlines if row == 0 and count == 1 or T_CDL does not exist.
        ;; 3. Use T_CDL (delete multiple lines) if it exists and line_count > 1 or none of the other ways work.
        ;; 4. Use T_CE (erase line) if the result is empty.
        ;; 5. Use T_DL (delete line) if it exists.
        ;; 6. Redraw the characters from screenLines[].

        (cond (and (non-nil? wp) (!= (. wp w_width) (int @Columns)) (eos? @T_CSV))
        (ยง
            ((ร type =) USE_REDRAW)
        )
        (and (can_clear @T_CD) result_empty)
        (ยง
            ((ร type =) USE_T_CD)
        )
        (and (zero? row) (or (== line_count 1) (eos? @T_CDL)))
        (ยง
            ((ร type =) USE_NL)
        )
        (and (non-eos? @T_CDL) (< 1 line_count) can_delete)
        (ยง
            ((ร type =) USE_T_CDL)
        )
        (and (can_clear @T_CE) result_empty (or (nil? wp) (== (. wp w_width) (int @Columns))))
        (ยง
            ((ร type =) USE_T_CE)
        )
        (and (non-eos? @T_DL) can_delete)
        (ยง
            ((ร type =) USE_T_DL)
        )
        (and (non-eos? @T_CDL) can_delete)
        (ยง
            ((ร type =) USE_T_CDL)
        )
        :else
        (ยง
            ((ร RETURN) false)
        ))

        ((ร int cursor_row =) (+ row off))
        ((ร int cursor_end =) (+ end off))

        ;; Now shift lineOffset[] line_count up to reflect the deleted lines.
        ;; Clear the inserted lines in screenLines[].

        ((ร row +=) off)
        ((ร end +=) off)
        ((ร FOR) (ร (ยง int i = 0) (< i line_count) (ยง i++))
            (cond (and (non-nil? wp) (!= (. wp w_width) (int @Columns)))
            (ยง
                ;; need to copy part of a line
                ((ร int j =) (+ row i))
                (while (ยง (j += line_count) <= end - 1)
                    (linecopy (- j line_count), j, wp)
                )
                ((ร j -=) line_count)
                (if (can_clear (u8 " "))
                    (lineclear (+ (ยง @lineOffset[j]) (. wp w_wincol)), (. wp w_width))
                    (lineinvalid (+ (ยง @lineOffset[j]) (. wp w_wincol)), (. wp w_width)))
                ((ร @lineWraps[j] =) false)
            )
            :else
            (ยง
                ;; whole width, moving the line pointers is faster
                ((ร int j =) (+ row i))
                ((ร int temp =) (ยง @lineOffset[j]))
                (while (ยง (j += line_count) <= end - 1)
                    ((ร @lineOffset[j - line_count] =) (ยง @lineOffset[j]))
                    ((ร @lineWraps[j - line_count] =) (ยง @lineWraps[j]))
                )
                ((ร @lineOffset[j - line_count] =) temp)
                ((ร @lineWraps[j - line_count] =) false)
                (if (can_clear (u8 " "))
                    (lineclear temp, (int @Columns))
                    (lineinvalid temp, (int @Columns)))
            ))
        )

        (screen_stop_highlight)

        (cond (== type USE_REDRAW)                 ;; redraw the characters
        (ยง
            (redraw_block row, end, wp)
        )
        (== type USE_T_CD)              ;; delete the lines
        (ยง
            (windgoto cursor_row, 0)
            (out_str @T_CD)
            (screen_start)                      ;; don't know where cursor is now
        )
        (== type USE_T_CDL)
        (ยง
            (windgoto cursor_row, 0)
            (term_delete_lines line_count)
            (screen_start)                      ;; don't know where cursor is now
        )

        ;; Deleting lines at top of the screen or scroll region: Just scroll
        ;; the whole screen (scroll region) up by outputting newlines on the last line.

        (== type USE_NL)
        (ยง
            (windgoto (- cursor_end 1), 0)
            ((ร FOR) (ร (ยง int i = line_count) (ยง 0 <= --i) nil)
                (out_char (byte \newline))           ;; cursor will remain on same line
            )
        )
        :else
        (ยง
            ((ร FOR) (ร (ยง int i = line_count) (ยง 0 <= --i) nil)
                (cond (== type USE_T_DL)
                (ยง
                    (windgoto cursor_row, 0)
                    (out_str @T_DL)             ;; delete a line
                )
                :else ;; type == USE_T_CE
                (ยง
                    (windgoto (+ cursor_row i), 0)
                    (out_str @T_CE)             ;; erase a line
                ))
                (screen_start)                  ;; don't know where cursor is now
            )
        ))

        ;; If the 'db' flag is set, we need to clear the lines that have been
        ;; scrolled up at the bottom of the region.

        (when (and (non-eos? @T_DB) (or (== type USE_T_DL) (== type USE_T_CDL)))
            ((ร FOR) (ร (ยง int i = line_count) (< 0 i) (ยง --i))
                (windgoto (- cursor_end i), 0)
                (out_str @T_CE)                 ;; erase a line
                (screen_start)                  ;; don't know where cursor is now
            )
        )

        true
    ))

;; show the current mode and ruler
;;
;; If clear_cmdline is true, clear the rest of the cmdline.
;; If clear_cmdline is false there may be a message there that needs to be
;; cleared only if a mode is shown.
;; Return the length of the message (0 if no message).

(defn- #_int showmode []
    (ยง
        ((ร int length =) 0)

        ((ร boolean do_mode =) (ยง (@p_smd && ((@State & INSERT) != 0 || @restart_edit != 0 || @VIsual_active))))
        (cond (or do_mode @Recording)
        (ยง
            ;; Don't show mode right now, when not redrawing or inside a mapping.
            ;; Call char_avail() only when we are going to show something, because
            ;; it takes a bit of time.

            (when (or (not (redrawing)) (and (char_avail) (not @keyTyped)))
                (reset! redraw_cmdline true)              ;; show mode later
                ((ร RETURN) 0)
            )

            ((ร boolean nwr_save =) @need_wait_return)

            ;; wait a bit before overwriting an important message
            (check_for_delay false)

            ;; if the cmdline is more than one line high, erase top lines
            ((ร boolean need_clear =) @clear_cmdline)
            (if (and @clear_cmdline (< @cmdline_row (- @Rows 1)))
                (msg_clr_cmdline))                  ;; will reset clear_cmdline

            ;; Position on the last line in the window, column 0.
            (msg_pos_mode)
            (cursor_off)
            ((ร int attr =) (hl_attr HLF_CM))                 ;; Highlight mode
            (when do_mode
                (msg_puts_attr (u8 "--"), attr)

                (cond (non-zero? (& @State VREPLACE_FLAG))
                (ยง
                    (msg_puts_attr (u8 " VREPLACE"), attr)
                )
                (non-zero? (& @State REPLACE_FLAG))
                (ยง
                    (msg_puts_attr (u8 " REPLACE"), attr)
                )
                (non-zero? (& @State INSERT))
                (ยง
                    (msg_puts_attr (u8 " INSERT"), attr)
                )
                (== @restart_edit (byte \I))
                (ยง
                    (msg_puts_attr (u8 " (insert)"), attr)
                )
                (== @restart_edit (byte \R))
                (ยง
                    (msg_puts_attr (u8 " (replace)"), attr)
                )
                (== @restart_edit (byte \V))
                (ยง
                    (msg_puts_attr (u8 " (vreplace)"), attr)
                ))

                (if (and (non-zero? (& @State INSERT)) @p_paste)
                    (msg_puts_attr (u8 " (paste)"), attr))

                (when @VIsual_active
                    (ร Bytes p)

                    ;; Don't concatenate separate words to avoid translation problems.
                    ((ร SWITCH) (+ (if @VIsual_select 4 0) (if (== @VIsual_mode Ctrl_V) 2 0) (if (== @VIsual_mode (byte \V)) 1 0))
                        ((ร CASE) 0)
                        (ยง
                            ((ร p =) (u8 " VISUAL"))
                            (ร BREAK)
                        )
                        ((ร CASE) 1)
                        (ยง
                            ((ร p =) (u8 " VISUAL LINE"))
                            (ร BREAK)
                        )
                        ((ร CASE) 2)
                        (ยง
                            ((ร p =) (u8 " VISUAL BLOCK"))
                            (ร BREAK)
                        )
                        ((ร CASE) 4)
                        (ยง
                            ((ร p =) (u8 " SELECT"))
                            (ร BREAK)
                        )
                        ((ร CASE) 5)
                        (ยง
                            ((ร p =) (u8 " SELECT LINE"))
                            (ร BREAK)
                        )
                        (ร DEFAULT)
                        (ยง
                            ((ร p =) (u8 " SELECT BLOCK"))
                            (ร BREAK)
                        )
                    )
                    (msg_puts_attr p, attr)
                )
                (msg_puts_attr (u8 " --"), attr)

                ((ร need_clear =) true)
            )
            (when @Recording
                (msg_puts_attr (u8 "recording"), attr)
                ((ร need_clear =) true)
            )

            (reset! mode_displayed true)
            (if (or need_clear @clear_cmdline)
                (msg_clr_eos))
            (reset! msg_didout false)             ;; overwrite this message
            ((ร length =) @msg_col)
            (reset! msg_col 0)
            (reset! need_wait_return nwr_save)    ;; never ask for hit-return for this
        )
        @clear_cmdline
        (ยง
            ;; Clear the whole command line.  Will reset "clear_cmdline".
            (msg_clr_cmdline)
        ))

        ;; In Visual mode the size of the selected area must be redrawn.
        (if @VIsual_active
            (clear_showcmd))

        ;; If the last window has no status line,
        ;; the ruler is after the mode message and must be redrawn.
        (if (and (redrawing) (zero? (. @lastwin w_status_height)))
            (win_redr_ruler @lastwin, true))
        (reset! redraw_cmdline false)
        (reset! clear_cmdline false)

        length
    ))

;; Position for a mode message.

(defn- #_void msg_pos_mode []
    (ยง
        (reset! msg_col 0)
        (reset! msg_row (- (int @Rows) 1))
    ))

;; Delete mode message.  Used when ESC is typed which is expected to end
;; Insert mode (but Insert mode didn't end yet!).
;; Caller should check "mode_displayed".

(defn- #_void unshowmode [#_boolean force]
    (ยง
        ;; Don't delete it right now, when not redrawing or inside a mapping.

        (cond (or (not (redrawing)) (and (not force) (char_avail) (not @keyTyped)))
        (ยง
            (reset! redraw_cmdline true)          ;; delete mode later
        )
        :else
        (ยง
            (msg_pos_mode)
            (if @Recording
                (msg_puts_attr (u8 "recording"), (hl_attr HLF_CM)))
            (msg_clr_eos)
        ))
    ))

;; Get buffer name for "buf" into nameBuff[].
;; Takes care of special buffer names and translates special characters.

(defn- #_void get_trans_bufname [#_buffer_C buf]
    (ยง
        (vim_strncpy @nameBuff, (buf_spname buf), (- MAXPATHL 1))
        (trans_characters @nameBuff, MAXPATHL)
    ))

;; Get the character to use in a status line.  Get its attributes in "*attr".

(defn- #_int fillchar_status [#_int* attr, #_boolean is_curwin]
    (ยง
        (ร int fill)
        (cond is_curwin
        (ยง
            ((ร attr[0] =) (hl_attr HLF_S))
            ((ร fill =) @fill_stl)
        )
        :else
        (ยง
            ((ร attr[0] =) (hl_attr HLF_SNC))
            ((ร fill =) @fill_stlnc)
        ))

        ;; Use fill when there is highlighting, and highlighting of current window differs,
        ;; or the fillchars differ, or this is not the current window.
        (if (and (!= (ยง attr[0]) 0) (or (!= (hl_attr HLF_S) (hl_attr HLF_SNC)) (not is_curwin) (== @firstwin @lastwin) (!= @fill_stl @fill_stlnc)))
            ((ร RETURN) fill)
        )
        (if is_curwin
            ((ร RETURN) (byte \^))
        )

        (byte \=)
    ))

;; Get the character to use in a separator between vertically split windows.
;; Get its attributes in "*attr".

(defn- #_int fillchar_vsep [#_int* attr]
    (ยง
        ((ร attr[0] =) (hl_attr HLF_C))
        (if (and (zero? (ยง attr[0])) (== @fill_vert (byte \space)))
            ((ร RETURN) (byte \|))
            ((ร RETURN) @fill_vert)
        )
    ))

;; Return true if redrawing should currently be done.

(defn- #_boolean redrawing []
    (and (zero? @redrawingDisabled) (not (and @p_lz (char_avail) (not @keyTyped) (not @do_redraw)))))

;; Return true if printing messages should currently be done.

(defn- #_boolean messaging []
    (not (and @p_lz (char_avail) (not @keyTyped))))

;; Show current status info in ruler and various other places.
;; If always is false, only show ruler if position has changed.

(defn- #_void showruler [#_boolean always]
    (ยง
        (if (and (not always) (not (redrawing)))
            (ร RETURN)
        )

        (win_redr_ruler @curwin, always)
    ))

(defn- #_void win_redr_ruler [#_window_C wp, #_boolean always]
    (ยง
        ;; If 'ruler' off or redrawing disabled, don't do anything.
        (if (not @p_ru)
            (ร RETURN)
        )

        ;; Check if cursor.lnum is valid, since win_redr_ruler() may be called
        ;; after deleting lines, before cursor.lnum is corrected.

        (if (< (.. @curbuf b_ml ml_line_count) (.. wp w_cursor lnum))
            (ร RETURN)
        )

        ;; Check if not in Insert mode and the line is empty (will show "0-1").

        ((ร boolean empty_line =) false)
        (if (and (zero? (& @State INSERT)) (== (.at (ml_get_buf @curbuf, (.. wp w_cursor lnum)) 0) NUL))
            ((ร empty_line =) true)
        )

        ;; Only draw the ruler when something changed.

        (validate_virtcol_win wp)
        (when (ยง @redraw_cmdline || always || wp.w_cursor.lnum != wp.w_ru_cursor.lnum || wp.w_cursor.col != wp.w_ru_cursor.col || wp.w_virtcol != wp.w_ru_virtcol || wp.w_cursor.coladd != wp.w_ru_cursor.coladd || wp.w_topline != wp.w_ru_topline || @curbuf.b_ml.ml_line_count != wp.w_ru_line_count || empty_line != wp.w_ru_empty)
            (cursor_off)

            (ร int row, fillchar, off, width)
            ((ร int[] attr =) (ยง new int[1]))
            (cond (!= (. wp w_status_height) 0)
            (ยง
                ((ร row =) (ยง wp.w_winrow + wp.w_height))
                ((ร fillchar =) (ยง fillchar_status(attr, wp == @curwin)))
                ((ร off =) (. wp w_wincol))
                ((ร width =) (. wp w_width))
            )
            :else
            (ยง
                ((ร row =) (ยง (int)@Rows - 1))
                ((ร fillchar =) (byte \space))
                ((ร attr[0] =) 0)
                ((ร off =) 0)
                ((ร width =) (ยง (int)@Columns))
            ))

            ((ร final int RULER_BUF_LEN =) 70)
            ((ร Bytes buffer =) (ยง new Bytes(RULER_BUF_LEN)))

            ;; Some sprintfs return the length, some return a pointer.
            ;; To avoid portability problems we use STRLEN() here.

            (vim_snprintf buffer, RULER_BUF_LEN, (u8 "%ld,"), (if (!= (& (.. @curbuf b_ml ml_flags) ML_EMPTY) 0) 0 (.. wp w_cursor lnum)))
            ((ร int len =) (STRLEN buffer))
            (col_print (.plus buffer len), (- RULER_BUF_LEN len), (if empty_line 0 (+ (.. wp w_cursor col) 1)), (+ (. wp w_virtcol) 1))

            ;; Add a "50%" if there is room for it.
            ;; On the last line, don't print in the last column
            ;; (scrolls the screen up on some terminals).

            ((ร int ii =) (STRLEN buffer))
            (get_rel_pos wp, (.plus buffer (+ ii 1)), (ยง RULER_BUF_LEN - ii - 1))
            ((ร int oo =) (ยง ii + mb_string2cells(buffer.plus(ii + 1), -1)))
            (if (zero? (. wp w_status_height))    ;; can't use last char of screen
                (ยง oo++)
            )
            ((ร int this_ru_col =) (ยง @ru_col - ((int)@Columns - width)))
            (if (< this_ru_col 0)
                ((ร this_ru_col =) 0)
            )
            ;; Never use more than half the window/screen width,
            ;; leave the other half for the filename.
            (if (< this_ru_col (ยง (width + 1) / 2))
                ((ร this_ru_col =) (ยง (width + 1) / 2))
            )
            (when (< (+ this_ru_col oo) width)
                ;; need at least 3 chars left for get_rel_pos() + NUL
                (while (ยง this_ru_col + oo < width && ii + 4 < RULER_BUF_LEN)
                    ((ร ii +=) (ยง utf_char2bytes(fillchar, buffer.plus(ii))))
                    (ยง oo++)
                )
                (get_rel_pos wp, (.plus buffer ii), (- RULER_BUF_LEN ii))
            )

            ;; Truncate at window boundary.
            ((ร int ooo =) 0)
            ((ร FOR) (ร (ยง int i = 0) (ยง buffer.at(i) != NUL) (ยง i += us_ptr2len_cc(buffer.plus(i))))
                ((ร ooo +=) (ยง us_ptr2cells(buffer.plus(i))))
                (when (< width (+ this_ru_col ooo))
                    (.be buffer i, NUL)
                    (ร BREAK)
                )
            )

            (screen_puts buffer, row, (+ this_ru_col off), (ยง attr[0]))
            ((ร boolean iii =) @redraw_cmdline)
            (ยง screen_fill(row, row + 1, this_ru_col + off + STRLEN(buffer), off + width, fillchar, fillchar, attr[0]))
            ;; don't redraw the cmdline because of showing the ruler
            (reset! redraw_cmdline iii)
            (COPY_pos (. wp w_ru_cursor), (. wp w_cursor))
            ((ร wp.w_ru_virtcol =) (. wp w_virtcol))
            ((ร wp.w_ru_empty =) empty_line)
            ((ร wp.w_ru_topline =) (. wp w_topline))
            ((ร wp.w_ru_line_count =) (.. @curbuf b_ml ml_line_count))
        )
    ))

;; Return the width of the 'number' and 'relativenumber' column.
;; Caller may need to check if 'number' or 'relativenumber' is set.
;; Otherwise it depends on 'numberwidth' and the line count.

(defn- #_int number_width [#_window_C wp]
    (ยง
        (ร long lnum)
        (cond (and @(.. wp w_options wo_rnu) (not @(.. wp w_options wo_nu)))
        (ยง
            ;; cursor line shows "0"
            ((ร lnum =) (. wp w_height))
        )
        :else
        (ยง
            ;; cursor line shows absolute line number
            ((ร lnum =) (.. @curbuf b_ml ml_line_count))
        ))

        (if (and (== lnum (. wp w_nrwidth_line_count)) (== (. wp w_nuw_cached) @(.. wp w_options wo_nuw)))
            ((ร RETURN) (. wp w_nrwidth_width))
        )

        ((ร wp.w_nrwidth_line_count =) lnum)

        ((ร int n =) 0)
;       do
;       {
; %%        ((ร lnum /=) 10)
            (ยง n++)
;       } while (0 < lnum);

        ;; 'numberwidth' gives the minimal width plus one
        (if (< n (- @(.. wp w_options wo_nuw) 1))
            ((ร n =) (ยง (int)wp.w_options.@wo_nuw - 1))
        )

        ((ร wp.w_nrwidth_width =) n)
        ((ร wp.w_nuw_cached =) @(.. wp w_options wo_nuw))
        n
    ))

;; Return the current cursor column.  This is the actual position on the screen.
;; First column is 0.

(defn- #_int screen_screencol []
    @screen_cur_col)

;; Return the current cursor row.  This is the actual position on the screen.
;; First row is 0.

(defn- #_int screen_screenrow []
    @screen_cur_row)

;;; ============================================================================================== VimW

;; window.c ---------------------------------------------------------------------------------------

(final window_C NOWIN (ยง_window_C))         ;; non-existing window

(final Bytes m_onlyone (u8 "Already only one window"))

;; all CTRL-W window commands are handled here, called from normal_cmd().

(defn- #_void do_window [#_int nchar, #_long Prenum, #_int xchar]
    ;; xchar: extra char from ":wincmd gx" or NUL
    (ยง
        ((ร Bytes cbuf =) (ยง new Bytes(40)))

        ((ร long Prenum1 =) (if (== Prenum 0) 1 Prenum))

        ((ร SWITCH) nchar
            ;; split current window in two parts, horizontally
            ((ร CASE) (byte \S))
            ((ร CASE) Ctrl_S)
            ((ร CASE) (byte \s))
            (ยง
                (when (non-zero? @cmdwin_type)
                    (emsg e_cmdwin)
                    (ร BREAK)
                )
                (reset_VIsual_and_resel)
                (win_split (int Prenum), 0)
                (ร BREAK)
            )

            ;; split current window in two parts, vertically
            ((ร CASE) Ctrl_V)
            ((ร CASE) (byte \v))
            (ยง
                (when (non-zero? @cmdwin_type)
                    (emsg e_cmdwin)
                    (ร BREAK)
                )
                (reset_VIsual_and_resel)
                (win_split (int Prenum), WSP_VERT)
                (ร BREAK)
            )

            ;; quit current window
            ((ร CASE) Ctrl_Q)
            ((ร CASE) (byte \q))
            (ยง
                (reset_VIsual_and_resel)
                (cmd_with_count (u8 "quit"), cbuf, (ยง cbuf.size()), Prenum)
                (do_cmdline_cmd cbuf)
                (ร BREAK)
            )

            ;; close current window
            ((ร CASE) Ctrl_C)
            ((ร CASE) (byte \c))
            (ยง
                (reset_VIsual_and_resel)
                (cmd_with_count (u8 "close"), cbuf, (ยง cbuf.size()), Prenum)
                (do_cmdline_cmd cbuf)
                (ร BREAK)
            )

            ;; close all but current window
            ((ร CASE) Ctrl_O)
            ((ร CASE) (byte \o))
            (ยง
                (when (non-zero? @cmdwin_type)
                    (emsg e_cmdwin)
                    (ร BREAK)
                )
                (reset_VIsual_and_resel)
                (cmd_with_count (u8 "only"), cbuf, (ยง cbuf.size()), Prenum)
                (do_cmdline_cmd cbuf)
                (ร BREAK)
            )

            ;; cursor to next window with wrap around
            ((ร CASE) Ctrl_W)
            ((ร CASE) (byte \w))
            ;; cursor to previous window with wrap around
            ((ร CASE) (byte \W))
            (ยง
                (when (non-zero? @cmdwin_type)
                    (emsg e_cmdwin)
                    (ร BREAK)
                )
                (cond (and (== @firstwin @lastwin) (!= Prenum 1)) ;; just one window
                (ยง
                    (beep_flush)
                )
                :else
                (ยง
                    (ร window_C wp)
                    (cond (non-zero? Prenum)                    ;; go to specified window
                    (ยง
                        ((ร FOR) (ร (ยง wp = @firstwin) (ยง 0 < --Prenum) nil)
                            (if (nil? (. wp w_next))
                                (ร BREAK)
                                ((ร wp =) (. wp w_next))
                            )
                        )
                    )
                    :else
                    (ยง
                        (cond (== nchar (byte \W))           ;; go to previous window
                        (ยง
                            ((ร wp =) (. @curwin w_prev))
                            (if (nil? wp)
                                ((ร wp =) @lastwin)       ;; wrap around
                            )
                        )
                        :else                        ;; go to next window
                        (ยง
                            ((ร wp =) (. @curwin w_next))
                            (if (nil? wp)
                                ((ร wp =) @firstwin)      ;; wrap around
                            )
                        ))
                    ))
                    (win_goto wp)
                ))
                (ร BREAK)
            )

            ;; cursor to window below
            ((ร CASE) (byte \j))
            ((ร CASE) K_DOWN)
            ((ร CASE) Ctrl_J)
            (ยง
                (when (non-zero? @cmdwin_type)
                    (emsg e_cmdwin)
                    (ร BREAK)
                )
                (win_goto_ver false, Prenum1)
                (ร BREAK)
            )

            ;; cursor to window above
            ((ร CASE) (byte \k))
            ((ร CASE) K_UP)
            ((ร CASE) Ctrl_K)
            (ยง
                (when (non-zero? @cmdwin_type)
                    (emsg e_cmdwin)
                    (ร BREAK)
                )
                (win_goto_ver true, Prenum1)
                (ร BREAK)
            )

            ;; cursor to left window
            ((ร CASE) (byte \h))
            ((ร CASE) K_LEFT)
            ((ร CASE) Ctrl_H)
            ((ร CASE) K_BS)
            (ยง
                (when (non-zero? @cmdwin_type)
                    (emsg e_cmdwin)
                    (ร BREAK)
                )
                (win_goto_hor true, Prenum1)
                (ร BREAK)
            )

            ;; cursor to right window
            ((ร CASE) (byte \l))
            ((ร CASE) K_RIGHT)
            ((ร CASE) Ctrl_L)
            (ยง
                (when (non-zero? @cmdwin_type)
                    (emsg e_cmdwin)
                    (ร BREAK)
                )
                (win_goto_hor false, Prenum1)
                (ร BREAK)
            )

            ;; cursor to top-left window
            ((ร CASE) (byte \t))
            ((ร CASE) Ctrl_T)
            (ยง
                (win_goto @firstwin)
                (ร BREAK)
            )

            ;; cursor to bottom-right window
            ((ร CASE) (byte \b))
            ((ร CASE) Ctrl_B)
            (ยง
                (win_goto @lastwin)
                (ร BREAK)
            )

            ;; cursor to last accessed (previous) window
            ((ร CASE) (byte \p))
            ((ร CASE) Ctrl_P)
            (ยง
                (if (nil? @prevwin)
                    (beep_flush)
                    (win_goto @prevwin))
                (ร BREAK)
            )

            ;; exchange current and next window
            ((ร CASE) (byte \x))
            ((ร CASE) Ctrl_X)
            (ยง
                (when (non-zero? @cmdwin_type)
                    (emsg e_cmdwin)
                    (ร BREAK)
                )
                (win_exchange Prenum)
                (ร BREAK)
            )

            ;; rotate windows downwards
            ((ร CASE) Ctrl_R)
            ((ร CASE) (byte \r))
            (ยง
                (when (non-zero? @cmdwin_type)
                    (emsg e_cmdwin)
                    (ร BREAK)
                )
                (reset_VIsual_and_resel)
                (win_rotate false, (int Prenum1))
                (ร BREAK)
            )

            ;; rotate windows upwards
            ((ร CASE) (byte \R))
            (ยง
                (when (non-zero? @cmdwin_type)
                    (emsg e_cmdwin)
                    (ร BREAK)
                )
                (reset_VIsual_and_resel)
                (win_rotate true, (int Prenum1))
                (ร BREAK)
            )

            ;; move window to the very top/bottom/left/right
            ((ร CASE) (byte \K))
            ((ร CASE) (byte \J))
            ((ร CASE) (byte \H))
            ((ร CASE) (byte \L))
            (ยง
                (when (non-zero? @cmdwin_type)
                    (emsg e_cmdwin)
                    (ร BREAK)
                )
                (win_totop (int Prenum), (| (if (or (== nchar (byte \H)) (== nchar (byte \L))) WSP_VERT 0) (if (or (== nchar (byte \H)) (== nchar (byte \K))) WSP_TOP WSP_BOT)))
                (ร BREAK)
            )

            ;; make all windows the same height
            ((ร CASE) (byte \=))
            (ยง
                (win_equal null, false, (byte \b))
                (ร BREAK)
            )

            ;; increase current window height
            ((ร CASE) (byte \+))
            (ยง
                (win_setheight (ยง @curwin.w_height + (int)Prenum1))
                (ร BREAK)
            )

            ;; decrease current window height
            ((ร CASE) (byte \-))
            (ยง
                (win_setheight (ยง @curwin.w_height - (int)Prenum1))
                (ร BREAK)
            )

            ;; set current window height
            ((ร CASE) Ctrl__)
            ((ร CASE) (byte \_))
            (ยง
                (win_setheight (if (non-zero? Prenum) (int Prenum) 9999))
                (ร BREAK)
            )

            ;; increase current window width
            ((ร CASE) (byte \>))
            (ยง
                (win_setwidth (ยง @curwin.w_width + (int)Prenum1))
                (ร BREAK)
            )

            ;; decrease current window width
            ((ร CASE) (byte \<))
            (ยง
                (win_setwidth (ยง @curwin.w_width - (int)Prenum1))
                (ร BREAK)
            )

            ;; set current window width
            ((ร CASE) (byte \|))
            (ยง
                (win_setwidth (if (non-zero? Prenum) (int Prenum) 9999))
                (ร BREAK)
            )

            ;; jump to tag and split window if tag exists (in preview window)
            ((ร CASE) (byte \]))
            ((ร CASE) Ctrl_RSB)
            (ยง
                (when (non-zero? @cmdwin_type)
                    (emsg e_cmdwin)
                    (ร BREAK)
                )
                ;; keep Visual mode, can select words to use as a tag
                (if (non-zero? Prenum)
                    (reset! postponed_split (int Prenum))
                    (reset! postponed_split -1))

                ;; Execute the command right here,
                ;; required when "wincmd ]" was used in a function.
                (do_nv_ident Ctrl_RSB, NUL)
                (ร BREAK)
            )

            ((ร CASE) K_KENTER)
            ((ร CASE) CAR)
            (ยง
                (ร BREAK)
            )

            ;; CTRL-W g extended commands.
            ((ร CASE) (byte \g))
            ((ร CASE) Ctrl_G)
            (ยง
                (when (non-zero? @cmdwin_type)
                    (emsg e_cmdwin)
                    (ร BREAK)
                )
                (swap! no_mapping inc)
                (swap! allow_keys inc)       ;; no mapping for xchar, but allow key codes
                (if (== xchar NUL)
                    ((ร xchar =) (plain_vgetc))
                )
                (swap! no_mapping dec)
                (swap! allow_keys dec)
                (add_to_showcmd xchar)
                ((ร SWITCH) xchar
                    ((ร CASE) (byte \]))
                    ((ร CASE) Ctrl_RSB)
                    (ยง
                        ;; keep Visual mode, can select words to use as a tag
                        (if (non-zero? Prenum)
                            (reset! postponed_split (int Prenum))
                            (reset! postponed_split -1))

                        ;; Execute the command right here,
                        ;; required when "wincmd g}" was used in a function.
                        (do_nv_ident (byte \g), xchar)
                        (ร BREAK)
                    )

                    (ร DEFAULT)
                    (ยง
                        (beep_flush)
                        (ร BREAK)
                    )
                )
                (ร BREAK)
            )

            (ร DEFAULT)
            (ยง
                (beep_flush)
                (ร BREAK)
            )
        )
    ))

(defn- #_void cmd_with_count [#_Bytes cmd, #_Bytes bufp, #_int bufsize, #_long Prenum]
    (ยง
        ((ร int len =) (STRLEN cmd))

        (STRCPY bufp, cmd)
        (when (< 0 Prenum)
            (ยง vim_snprintf(bufp.plus(len), bufsize - len, (u8 "%ld"), Prenum))
        )
    ))

;; split the current window, implements CTRL-W s and :split
;;
;; "size" is the height or width for the new window, 0 to use half of current height or width.
;;
;; "flags":
;; WSP_VERT: vertical split.
;; WSP_TOP:  open window at the top-left of the shell (help window).
;; WSP_BOT:  open window at the bottom-right of the shell (quickfix window).
;;
;; return false for failure, true otherwise

(defn- #_boolean win_split [#_int size, #_int flags]
    (ยง
        (when (and (non-zero? (& flags WSP_TOP)) (non-zero? (& flags WSP_BOT)))
            (emsg (u8 "E442: Can't split topleft and botright at the same time"))
            ((ร RETURN) false)
        )

        (win_split_ins size, flags, null, 0)
    ))

;; When "new_wp" is null: split the current window in two.
;; When "new_wp" is not null: insert this window at the far top/left/right/bottom.
;; return false for failure, true otherwise

(defn- #_boolean win_split_ins [#_int size, #_int flags, #_window_C new_wp, #_int dir]
    (ยง
        ((ร int new_size =) size)
        ((ร boolean do_equal =) false)
        ((ร int oldwin_height =) 0)

        (ร window_C oldwin)
        (cond (non-zero? (& flags WSP_TOP))
        (ยง
            ((ร oldwin =) @firstwin)
        )
        (non-zero? (& flags WSP_BOT))
        (ยง
            ((ร oldwin =) @lastwin)
        )
        :else
        (ยง
            ((ร oldwin =) @curwin)
        ))

        ((ร int need_status =) 0)
        ;; add a status line when p_ls == 1 and splitting the first window
        (when (and (== @lastwin @firstwin) (== @p_ls 1) (zero? (. oldwin w_status_height)))
            (when (and (<= (. oldwin w_height) @p_wmh) (nil? new_wp))
                (emsg e_noroom)
                ((ร RETURN) false)
            )
            ((ร need_status =) STATUS_HEIGHT)
        )

        (ร byte layout)
        (cond (non-zero? (& flags WSP_VERT))
        (ยง
            ((ร layout =) FR_ROW)

            ;; Check if we are able to split the current window and compute its width.

            ;; Current window requires at least 1 space.
            ((ร int wmw1 =) (if (== @p_wmw 0) 1 (int @p_wmw)))
            ((ร int needed =) (+ wmw1 1))
            (ร int minwidth)
            (ร int available)
            (cond (non-zero? (ยง flags & (WSP_BOT | WSP_TOP)))
            (ยง
                ((ร minwidth =) (frame_minwidth @topframe, NOWIN))
                ((ร available =) (. @topframe fr_width))
                ((ร needed +=) minwidth)
            )
            @p_ea
            (ยง
                ((ร minwidth =) (ยง frame_minwidth(oldwin.w_frame, NOWIN)))
                ((ร frame_C prevfrp =) (. oldwin w_frame))
                ((ร FOR) (ร (ยง frame_C frp = oldwin.w_frame.fr_parent) (!= frp null) (ยง frp = frp.fr_parent))
                    (when (== (. frp fr_layout) FR_ROW)
                        ((ร FOR) (ร (ยง frame_C frp2 = frp.fr_child) (!= frp2 null) (ยง frp2 = frp2.fr_next))
                            (if (!= frp2 prevfrp)
                                ((ร minwidth +=) (frame_minwidth frp2, NOWIN))
                            )
                        )
                    )
                    ((ร prevfrp =) frp)
                )
                ((ร available =) (. @topframe fr_width))
                ((ร needed +=) minwidth)
            )
            :else
            (ยง
                ((ร minwidth =) (ยง frame_minwidth(oldwin.w_frame, NOWIN)))
                ((ร available =) (.. oldwin w_frame fr_width))
                ((ร needed +=) minwidth)
            ))
            (when (and (< available needed) (nil? new_wp))
                (emsg e_noroom)
                ((ร RETURN) false)
            )
            (if (zero? new_size)
                ((ร new_size =) (ยง oldwin.w_width / 2))
            )
            (if (> new_size (ยง available - minwidth - 1))
                ((ร new_size =) (ยง available - minwidth - 1))
            )
            (if (< new_size wmw1)
                ((ร new_size =) wmw1)
            )

            ;; if it doesn't fit in the current window, need win_equal()
            (if (ยง oldwin.w_width - new_size - 1 < @p_wmw)
                ((ร do_equal =) true)
            )

            ;; We don't like to take lines for the new window from a 'winfixwidth' window.
            ;; Take them from a window to the left or right instead, if possible.
            (if @(.. oldwin w_options wo_wfw)
                (win_setwidth_win (+ (. oldwin w_width) new_size), oldwin))

            ;; Only make all windows the same width if one of them (except oldwin)
            ;; is wider than one of the split windows.
            (when (and (not do_equal) @p_ea (zero? size) (!= (.at @p_ead 0) (byte \v)) (!= (.. oldwin w_frame fr_parent) null))
                ((ร frame_C frp =) (.. oldwin w_frame fr_parent fr_child))
                (while (!= frp null)
                    (when (and (!= (. frp fr_win) oldwin) (!= (. frp fr_win) null) (or (< new_size (.. frp fr_win w_width)) (ยง oldwin.w_width - new_size - 1 < frp.fr_win.w_width)))
                        ((ร do_equal =) true)
                        (ร BREAK)
                    )
                    ((ร frp =) (. frp fr_next))
                )
            )
        )
        :else
        (ยง
            ((ร layout =) FR_COL)

            ;; Check if we are able to split the current window and compute its height.

            ;; Current window requires at least 1 space.
            ((ร int wmh1 =) (if (== @p_wmh 0) 1 (int @p_wmh)))
            ((ร int needed =) (+ wmh1 STATUS_HEIGHT))
            (ร int minheight)
            (ร int available)
            (cond (non-zero? (ยง flags & (WSP_BOT | WSP_TOP)))
            (ยง
                ((ร minheight =) (ยง frame_minheight(@topframe, NOWIN) + need_status))
                ((ร available =) (. @topframe fr_height))
                ((ร needed +=) minheight)
            )
            @p_ea
            (ยง
                ((ร minheight =) (ยง frame_minheight(oldwin.w_frame, NOWIN) + need_status))
                ((ร frame_C prevfrp =) (. oldwin w_frame))
                ((ร FOR) (ร (ยง frame_C frp = oldwin.w_frame.fr_parent) (!= frp null) (ยง frp = frp.fr_parent))
                    (when (== (. frp fr_layout) FR_COL)
                        ((ร FOR) (ร (ยง frame_C frp2 = frp.fr_child) (!= frp2 null) (ยง frp2 = frp2.fr_next))
                            (if (!= frp2 prevfrp)
                                ((ร minheight +=) (frame_minheight frp2, NOWIN))
                            )
                        )
                    )
                    ((ร prevfrp =) frp)
                )
                ((ร available =) (. @topframe fr_height))
                ((ร needed +=) minheight)
            )
            :else
            (ยง
                ((ร minheight =) (ยง frame_minheight(oldwin.w_frame, NOWIN) + need_status))
                ((ร available =) (.. oldwin w_frame fr_height))
                ((ร needed +=) minheight)
            ))
            (when (and (< available needed) (nil? new_wp))
                (emsg e_noroom)
                ((ร RETURN) false)
            )
            ((ร oldwin_height =) (. oldwin w_height))
            (when (non-zero? need_status)
                ((ร oldwin.w_status_height =) STATUS_HEIGHT)
                ((ร oldwin_height -=) STATUS_HEIGHT)
            )
            (if (zero? new_size)
                ((ร new_size =) (/ oldwin_height 2))
            )
            (if (> new_size (ยง available - minheight - STATUS_HEIGHT))
                ((ร new_size =) (ยง available - minheight - STATUS_HEIGHT))
            )
            (if (< new_size wmh1)
                ((ร new_size =) wmh1)
            )

            ;; if it doesn't fit in the current window, need win_equal()
            (if (ยง oldwin_height - new_size - STATUS_HEIGHT < @p_wmh)
                ((ร do_equal =) true)
            )

            ;; We don't like to take lines for the new window from a 'winfixheight' window.
            ;; Take them from a window above or below instead, if possible.
            (when @(.. oldwin w_options wo_wfh)
                (win_setheight_win (ยง oldwin.w_height + new_size + STATUS_HEIGHT), oldwin)
                ((ร oldwin_height =) (. oldwin w_height))
                (if (non-zero? need_status)
                    ((ร oldwin_height -=) STATUS_HEIGHT)
                )
            )

            ;; Only make all windows the same height if one of them (except oldwin)
            ;; is higher than one of the split windows.
            (when (and (not do_equal) @p_ea (zero? size) (!= (.at @p_ead 0) (byte \h)) (!= (.. oldwin w_frame fr_parent) null))
                ((ร frame_C frp =) (.. oldwin w_frame fr_parent fr_child))
                (while (!= frp null)
                    (when (and (!= (. frp fr_win) oldwin) (!= (. frp fr_win) null) (or (< new_size (.. frp fr_win w_height)) (ยง oldwin_height - new_size - STATUS_HEIGHT < frp.fr_win.w_height)))
                        ((ร do_equal =) true)
                        (ร BREAK)
                    )
                    ((ร frp =) (. frp fr_next))
                )
            )
        ))

        ((ร window_C wp =) new_wp)

        ;; allocate new window structure and link it in the window list

        (cond (and (zero? (& flags WSP_TOP)) (or (non-zero? (& flags WSP_BOT)) (non-zero? (& flags WSP_BELOW)) (and (zero? (& flags WSP_ABOVE)) (if (non-zero? (& flags WSP_VERT)) @p_spr @p_sb))))
        (ยง
            ;; new window below/right of current one
            (if (nil? new_wp)
                ((ร wp =) (newWindow oldwin))
                (win_append oldwin, wp))
        )
        :else
        (ยง
            (if (nil? new_wp)
                ((ร wp =) (ยง newWindow(oldwin.w_prev)))
                (win_append (. oldwin w_prev), wp))
        ))

        (when (nil? new_wp)
            (if (nil? wp)
                ((ร RETURN) false)
            )

            ((ร wp.w_frame =) (newFrame wp))

            ;; make the contents of the new window the same as the current one
            (win_init wp, @curwin)
        )

        ;; Reorganise the tree of frames to insert the new window.

        (ร frame_C curfrp)
        (ร boolean before)
        (cond (non-zero? (ยง flags & (WSP_TOP | WSP_BOT)))
        (ยง
            (cond (or (and (== (. @topframe fr_layout) FR_COL) (zero? (& flags WSP_VERT))) (and (== (. @topframe fr_layout) FR_ROW) (non-zero? (& flags WSP_VERT))))
            (ยง
                ((ร curfrp =) (. @topframe fr_child))
                (when (non-zero? (& flags WSP_BOT))
                    (while (ยง curfrp.fr_next != null)
                        ((ร curfrp =) (. curfrp fr_next))
                    )
                )
            )
            :else
            (ยง
                ((ร curfrp =) @topframe)
            ))
            ((ร before =) (ยง ((flags & WSP_TOP) != 0)))
        )
        :else
        (ยง
            ((ร curfrp =) (. oldwin w_frame))
            (cond (non-zero? (& flags WSP_BELOW))
            (ยง
                ((ร before =) false)
            )
            (non-zero? (& flags WSP_ABOVE))
            (ยง
                ((ร before =) true)
            )
            (non-zero? (& flags WSP_VERT))
            (ยง
                ((ร before =) (ยง !@p_spr))
            )
            :else
            (ยง
                ((ร before =) (ยง !@p_sb))
            ))
        ))

        (when (or (nil? (. curfrp fr_parent)) (!= (.. curfrp fr_parent fr_layout) layout))
            ;; Need to create a new frame in the tree to make a branch.
            ((ร frame_C frp =) (ยง ยง_frame_C()))
            (COPY_frame frp, curfrp)
            ((ร curfrp.fr_layout =) layout)
            ((ร frp.fr_parent =) curfrp)
            ((ร frp.fr_next =) null)
            ((ร frp.fr_prev =) null)
            ((ร curfrp.fr_child =) frp)
            ((ร curfrp.fr_win =) null)
            ((ร curfrp =) frp)
            (cond (!= (. frp fr_win) null)
            (ยง
                ((ร oldwin.w_frame =) frp)
            )
            :else
            (ยง
                ((ร FOR) (ร (ยง frp = frp.fr_child) (!= frp null) (ยง frp = frp.fr_next))
                    ((ร frp.fr_parent =) curfrp)
                )
            ))
        )

        (ร frame_C frp)
        (if (nil? new_wp)
            ((ร frp =) (. wp w_frame))
            ((ร frp =) (. new_wp w_frame))
        )
        ((ร frp.fr_parent =) (. curfrp fr_parent))

        ;; Insert the new frame at the right place in the frame list.
        (if before
            (frame_insert curfrp, frp)
            (frame_append curfrp, frp))

        ;; Set w_fraction now so that the cursor keeps the same relative vertical position.
        (if (< 0 (. oldwin w_height))
            (set_fraction oldwin))
        ((ร wp.w_fraction =) (. oldwin w_fraction))

        (cond (non-zero? (& flags WSP_VERT))
        (ยง
            ((ร wp.w_options.@wo_scr =) @(.. @curwin w_options wo_scr))

            (when (non-zero? need_status)
                (win_new_height oldwin, (- (. oldwin w_height) 1))
                ((ร oldwin.w_status_height =) need_status)
            )
            (cond (non-zero? (ยง flags & (WSP_TOP | WSP_BOT)))
            (ยง
                ;; set height and row of new window to full height
                ((ร wp.w_winrow =) 0)
                (win_new_height wp, (- (. curfrp fr_height) (if (< 0 @p_ls) 1 0)))
                ((ร wp.w_status_height =) (if (< 0 @p_ls) 1 0))
            )
            :else
            (ยง
                ;; height and row of new window is same as current window
                ((ร wp.w_winrow =) (. oldwin w_winrow))
                (win_new_height wp, (. oldwin w_height))
                ((ร wp.w_status_height =) (. oldwin w_status_height))
            ))
            ((ร frp.fr_height =) (. curfrp fr_height))

            ;; "new_size" of the current window goes to the new window,
            ;; use one column for the vertical separator
            (win_new_width wp, new_size)
            (cond before
            (ยง
                ((ร wp.w_vsep_width =) 1)
            )
            :else
            (ยง
                ((ร wp.w_vsep_width =) (. oldwin w_vsep_width))
                ((ร oldwin.w_vsep_width =) 1)
            ))
            (cond (non-zero? (ยง flags & (WSP_TOP | WSP_BOT)))
            (ยง
                (if (non-zero? (& flags WSP_BOT))
                    (frame_add_vsep curfrp))
                ;; Set width of neighbor frame.
                (frame_new_width curfrp, (- (. curfrp fr_width) (+ new_size (if (non-zero? (& flags WSP_TOP)) 1 0))), (non-zero? (& flags WSP_TOP)), false)
            )
            :else
            (ยง
                (win_new_width oldwin, (ยง oldwin.w_width - (new_size + 1)))
            ))
            (cond before     ;; new window left of current one
            (ยง
                ((ร wp.w_wincol =) (. oldwin w_wincol))
                ((ร oldwin.w_wincol +=) (+ new_size 1))
            )
            :else            ;; new window right of current one
            (ยง
                ((ร wp.w_wincol =) (ยง oldwin.w_wincol + oldwin.w_width + 1))
            ))
            (frame_fix_width oldwin)
            (frame_fix_width wp)
        )
        :else
        (ยง
            ;; width and column of new window is same as current window
            (cond (non-zero? (ยง flags & (WSP_TOP | WSP_BOT)))
            (ยง
                ((ร wp.w_wincol =) 0)
                (win_new_width wp, (int @Columns))
                ((ร wp.w_vsep_width =) 0)
            )
            :else
            (ยง
                ((ร wp.w_wincol =) (. oldwin w_wincol))
                (win_new_width wp, (. oldwin w_width))
                ((ร wp.w_vsep_width =) (. oldwin w_vsep_width))
            ))
            ((ร frp.fr_width =) (. curfrp fr_width))

            ;; "new_size" of the current window goes to the new window,
            ;; use one row for the status line
            (win_new_height wp, new_size)
            (if (non-zero? (ยง flags & (WSP_TOP | WSP_BOT)))
                (frame_new_height curfrp, (ยง curfrp.fr_height - (new_size + STATUS_HEIGHT)), (non-zero? (& flags WSP_TOP)), false)
                (win_new_height oldwin, (ยง oldwin_height - (new_size + STATUS_HEIGHT))))
            (cond before     ;; new window above current one
            (ยง
                ((ร wp.w_winrow =) (. oldwin w_winrow))
                ((ร wp.w_status_height =) STATUS_HEIGHT)
                ((ร oldwin.w_winrow +=) (ยง wp.w_height + STATUS_HEIGHT))
            )
            :else            ;; new window below current one
            (ยง
                ((ร wp.w_winrow =) (ยง oldwin.w_winrow + oldwin.w_height + STATUS_HEIGHT))
                ((ร wp.w_status_height =) (. oldwin w_status_height))
                ((ร oldwin.w_status_height =) STATUS_HEIGHT)
            ))
            (if (non-zero? (& flags WSP_BOT))
                (frame_add_statusline curfrp))
            (frame_fix_height wp)
            (frame_fix_height oldwin)
        ))

        (if (non-zero? (ยง flags & (WSP_TOP | WSP_BOT)))
            (win_comp_pos))

        ;; Both windows need redrawing

        (redraw_win_later wp, NOT_VALID)
        ((ร wp.w_redr_status =) true)
        (redraw_win_later oldwin, NOT_VALID)
        ((ร oldwin.w_redr_status =) true)

        (when (non-zero? need_status)
            (reset! msg_row (- (int @Rows) 1))
            (reset! msg_col @sc_col)
            (msg_clr_eos_force)    ;; old command/ruler may still be there
            (comp_col)
            (reset! msg_row (- (int @Rows) 1))
            (reset! msg_col 0)            ;; put position back at start of line
        )

        ;; equalize the window sizes.

        (if (or do_equal (non-zero? dir))
            (win_equal wp, true, (if (non-zero? (& flags WSP_VERT)) (if (== dir (byte \v)) (byte \b) (byte \h)) (if (== dir (byte \h)) (byte \b) (byte \v)))))

        ;; Don't change the window height/width to 'winheight' / 'winwidth' if a size was given.
        (ร int i)
        (cond (non-zero? (& flags WSP_VERT))
        (ยง
            ((ร i =) (ยง (int)@p_wiw))
            (if (non-zero? size)
                (reset! p_wiw size))
        )
        :else
        (ยง
            ((ร i =) (ยง (int)@p_wh))
            (if (non-zero? size)
                (reset! p_wh size))
        ))

        ;; Keep same changelist position in new window.
        ((ร wp.w_changelistidx =) (. oldwin w_changelistidx))

        ;; make the new window the current window

        (win_enter wp)
        (if (non-zero? (& flags WSP_VERT))
            (reset! p_wiw i)
            (reset! p_wh i))

        true
    ))

;; Initialize window "newp" from window "oldp".
;; Used when splitting a window and when creating a new tab page.
;; The windows will both edit the same buffer.

(defn- #_void win_init [#_window_C newp, #_window_C oldp]
    (ยง
        (ยง @curbuf.b_nwindows++)

        (COPY_pos (. newp w_cursor), (. oldp w_cursor))
        ((ร newp.w_valid =) 0)
        ((ร newp.w_curswant =) (. oldp w_curswant))
        ((ร newp.w_set_curswant =) (. oldp w_set_curswant))
        ((ร newp.w_topline =) (. oldp w_topline))
        ((ร newp.w_leftcol =) (. oldp w_leftcol))
        (COPY_pos (. newp w_pcmark), (. oldp w_pcmark))
        (COPY_pos (. newp w_prev_pcmark), (. oldp w_prev_pcmark))
        ((ร newp.w_wrow =) (. oldp w_wrow))
        ((ร newp.w_fraction =) (. oldp w_fraction))
        ((ร newp.w_prev_fraction_row =) (. oldp w_prev_fraction_row))
        (copy_jumplist oldp, newp)

        ;; copy options from existing window
        (win_copy_options oldp, newp)

        (check_colorcolumn newp)
    ))

;; Check if "win" is a pointer to an existing window.

(defn- #_boolean win_valid [#_window_C win]
    (ยง
        (if (nil? win)
            ((ร RETURN) false)
        )

        ((ร FOR) (ร (ยง window_C wp = @firstwin) (!= wp null) (ยง wp = wp.w_next))
            (if (== wp win)
                ((ร RETURN) true)
            )
        )

        false
    ))

;; Exchange current and next window

(defn- #_void win_exchange [#_long Prenum]
    (ยง
        (when (== @lastwin @firstwin)        ;; just one window
            (beep_flush)
            (ร RETURN)
        )

        (ร frame_C frp)

        ;; find window to exchange with

        (cond (non-zero? Prenum)
        (ยง
            ((ร frp =) (.. @curwin w_frame fr_parent fr_child))
            (while (ยง frp != null && 0 < --Prenum)
                ((ร frp =) (. frp fr_next))
            )
        )
        (!= (.. @curwin w_frame fr_next) null)    ;; Swap with next.
        (ยง
            ((ร frp =) (.. @curwin w_frame fr_next))
        )
        :else    ;; Swap last window in row/col with previous.
        (ยง
            ((ร frp =) (.. @curwin w_frame fr_prev))
        ))

        ;; We can only exchange a window with another window, not with a frame containing windows.
        (if (or (nil? frp) (nil? (. frp fr_win)) (== (. frp fr_win) @curwin))
            (ร RETURN)
        )

        ((ร window_C wp =) (. frp fr_win))

        ;; 1. remove curwin from the list.  Remember after which window it was in wp2
        ;; 2. insert curwin before wp in the list
        ;; if wp != wp2
        ;;    3. remove wp from the list
        ;;    4. insert wp after wp2
        ;; 5. exchange the status line height and vsep width.

        ((ร window_C wp2 =) (. @curwin w_prev))
        ((ร frame_C frp2 =) (.. @curwin w_frame fr_prev))
        (when (!= (. wp w_prev) @curwin)
            (win_remove @curwin)
            (frame_remove (. @curwin w_frame))
            (win_append (. wp w_prev), @curwin)
            (frame_insert frp, (. @curwin w_frame))
        )
        (when (!= wp wp2)
            (win_remove wp)
            (frame_remove (. wp w_frame))
            (win_append wp2, wp)
            (if (nil? frp2)
                (frame_insert (.. wp w_frame fr_parent fr_child), (. wp w_frame))
                (frame_append frp2, (. wp w_frame)))
        )

        ((ร int temp =) (. @curwin w_status_height))
        ((ร @curwin.w_status_height =) (. wp w_status_height))
        ((ร wp.w_status_height =) temp)
        ((ร temp =) (. @curwin w_vsep_width))
        ((ร @curwin.w_vsep_width =) (. wp w_vsep_width))
        ((ร wp.w_vsep_width =) temp)

        ;; If the windows are not in the same frame, exchange the sizes to avoid
        ;; messing up the window layout.  Otherwise fix the frame sizes.
        (cond (!= (.. @curwin w_frame fr_parent) (.. wp w_frame fr_parent))
        (ยง
            ((ร temp =) (. @curwin w_height))
            ((ร @curwin.w_height =) (. wp w_height))
            ((ร wp.w_height =) temp)
            ((ร temp =) (. @curwin w_width))
            ((ร @curwin.w_width =) (. wp w_width))
            ((ร wp.w_width =) temp)
        )
        :else
        (ยง
            (frame_fix_height @curwin)
            (frame_fix_height wp)
            (frame_fix_width @curwin)
            (frame_fix_width wp)
        ))

        (win_comp_pos)                 ;; recompute window positions

        (win_enter wp)
        (redraw_later CLEAR)
    ))

;; rotate windows: if upwards true the second window becomes the first one
;;                 if upwards false the first window becomes the second one

(defn- #_void win_rotate [#_boolean upwards, #_int count]
    (ยง
        (when (== @firstwin @lastwin)            ;; nothing to do
            (beep_flush)
            (ร RETURN)
        )

        (ร frame_C frp)
        ;; Check if all frames in this row/col have one window.
        ((ร FOR) (ร (ยง frp = @curwin.w_frame.fr_parent.fr_child) (!= frp null) (ยง frp = frp.fr_next))
            (when (nil? (. frp fr_win))
                (emsg (u8 "E443: Cannot rotate when another window is split"))
                (ร RETURN)
            )
        )

        (while (ยง 0 < count--)
            (ร window_C wp1, wp2)

            (cond upwards            ;; first window becomes last window
            (ยง
                ;; remove first window/frame from the list
                ((ร frp =) (.. @curwin w_frame fr_parent fr_child))
                ((ร wp1 =) (. frp fr_win))
                (win_remove wp1)
                (frame_remove frp)

                ;; find last frame and append removed window/frame after it
                ((ร FOR) (ร (ยง  ) (ยง frp.fr_next != null) (ยง frp = frp.fr_next))
                    ;
                )
                (win_append (. frp fr_win), wp1)
                (frame_append frp, (. wp1 w_frame))

                ((ร wp2 =) (. frp fr_win))   ;; previously last window
            )
            :else                    ;; last window becomes first window
            (ยง
                ;; find last window/frame in the list and remove it
                ((ร FOR) (ร (ยง frp = @curwin.w_frame) (ยง frp.fr_next != null) (ยง frp = frp.fr_next))
                    ;
                )
                ((ร wp1 =) (. frp fr_win))
                ((ร wp2 =) (. wp1 w_prev))   ;; will become last window
                (win_remove wp1)
                (frame_remove frp)

                ;; append the removed window/frame before the first in the list
                (win_append (.. frp fr_parent fr_child fr_win w_prev), wp1)
                (frame_insert (.. frp fr_parent fr_child), frp)
            ))

            ;; exchange status height and vsep width of old and new last window
            ((ร int n =) (. wp2 w_status_height))
            ((ร wp2.w_status_height =) (. wp1 w_status_height))
            ((ร wp1.w_status_height =) n)
            (frame_fix_height wp1)
            (frame_fix_height wp2)

            ((ร n =) (. wp2 w_vsep_width))
            ((ร wp2.w_vsep_width =) (. wp1 w_vsep_width))
            ((ร wp1.w_vsep_width =) n)
            (frame_fix_width wp1)
            (frame_fix_width wp2)

            ;; recompute w_winrow and w_wincol for all windows
            (win_comp_pos)
        )

        (redraw_later CLEAR)
    ))

;; Move the current window to the very top/bottom/left/right of the screen.

(defn- #_void win_totop [#_int size, #_int flags]
    (ยง
        ((ร int height =) (. @curwin w_height))

        (when (== @lastwin @firstwin)
            (beep_flush)
            (ร RETURN)
        )

        ;; Remove the window and frame from the tree of frames.
        ((ร int[] dir =) (ยง new int[1]))
        (winframe_remove @curwin, dir)
        (win_remove @curwin)
        (last_status false)             ;; may need to remove last status line
        (win_comp_pos)                 ;; recompute window positions

        ;; Split a window on the desired side and put the window there.
        (win_split_ins size, flags, @curwin, (ยง dir[0]))
        (when (zero? (& flags WSP_VERT))
            (win_setheight height)
            (if @p_ea
                (win_equal @curwin, true, (byte \v)))
        )
    ))

;; Make all windows the same height.
;; 'next_curwin' will soon be the current window, make sure it has enough rows.

(defn- #_void win_equal [#_window_C next_curwin, #_boolean current, #_int dir]
    ;; next_curwin: pointer to current window to be or null
    ;; current: do only frame with current window
    ;; dir: 'v' for vertically, 'h' for horizontally, 'b' for both, 0 for using "p_ead"
    (ยง
        (if (zero? dir)
            ((ร dir =) (ยง @p_ead.at(0)))
        )
        (win_equal_rec (if (nil? next_curwin) @curwin next_curwin), current, @topframe, dir, 0, 0, (int @Columns), (. @topframe fr_height))
    ))

;; Set a frame to a new position and height, spreading the available room
;; equally over contained frames.
;; The window "next_curwin" (if not null) should at least get the size from
;; 'winheight' and 'winwidth' if possible.

(defn- #_void win_equal_rec [#_window_C next_curwin, #_boolean current, #_frame_C topfr, #_int dir, #_int col, #_int row, #_int width, #_int height]
    ;; next_curwin: pointer to current window to be or null
    ;; current: do only frame with current window
    ;; topfr: frame to set size off
    ;; dir: 'v', 'h' or 'b', see win_equal()
    ;; col: horizontal position for frame
    ;; row: vertical position for frame
    ;; width: new width of frame
    ;; height: new height of frame
    (ยง
        ((ร int extra_sep =) 0)
        (ร int wincount, totwincount = 0)
        ((ร int next_curwin_size =) 0)
        ((ร int room =) 0)
        ((ร boolean has_next_curwin =) false)

        (cond (== (. topfr fr_layout) FR_LEAF)
        (ยง
            ;; Set the width/height of this frame.
            ;; Redraw when size or position changes
            (when (or (!= (. topfr fr_height) height) (!= (.. topfr fr_win w_winrow) row) (!= (. topfr fr_width) width) (!= (.. topfr fr_win w_wincol) col))
                ((ร topfr.fr_win.w_winrow =) row)
                (frame_new_height topfr, height, false, false)
                ((ร topfr.fr_win.w_wincol =) col)
                (frame_new_width topfr, width, false, false)
                (redraw_all_later CLEAR)
            )
        )
        (== (. topfr fr_layout) FR_ROW)
        (ยง
            ((ร topfr.fr_width =) width)
            ((ร topfr.fr_height =) height)

            (when (!= dir (byte \v))                 ;; equalize frame widths
                ;; Compute the maximum number of windows horizontally in this frame.
                ((ร int n =) (frame_minwidth topfr, NOWIN))
                ;; add one for the rightmost window, it doesn't have a separator
                (if (ยง col + width == (int)@Columns)
                    ((ร extra_sep =) 1)
                    ((ร extra_sep =) 0)
                )
                ((ร totwincount =) (ยง (n + extra_sep) / ((int)@p_wmw + 1)))
                ((ร has_next_curwin =) (frame_has_win topfr, next_curwin))

                ;; Compute width for "next_curwin" window and room available for other windows.
                ;; "m" is the minimal width when counting "p_wiw" for "next_curwin".

                ((ร int m =) (frame_minwidth topfr, next_curwin))
                ((ร room =) (- width m))
                (cond (< room 0)
                (ยง
                    ((ร next_curwin_size =) (ยง (int)@p_wiw + room))
                    ((ร room =) 0)
                )
                :else
                (ยง
                    ((ร next_curwin_size =) -1)
                    ((ร FOR) (ร (ยง frame_C fr = topfr.fr_child) (!= fr null) (ยง fr = fr.fr_next))
                        ;; If 'winfixwidth' set keep the window width if possible.
                        ;; Watch out for this window being the next_curwin.
                        (when (frame_fixed_width fr)
                            ((ร n =) (frame_minwidth fr, NOWIN))
                            ((ร int new_size =) (. fr fr_width))
                            (cond (frame_has_win fr, next_curwin)
                            (ยง
                                ((ร room +=) (- @p_wiw @p_wmw))
                                ((ร next_curwin_size =) 0)
                                (if (< new_size @p_wiw)
                                    ((ร new_size =) (ยง (int)@p_wiw))
                                )
                            )
                            :else
                            (ยง
                                ;; These windows don't use up room.
                                ((ร totwincount -=) (/ (+ n (if (== (. fr fr_next) null) extra_sep 0)) (+ @p_wmw 1)))
                            ))
                            ((ร room -=) (- new_size n))
                            (when (< room 0)
                                ((ร new_size +=) room)
                                ((ร room =) 0)
                            )
                            ((ร fr.fr_newwidth =) new_size)
                        )
                    )
                    (when (== next_curwin_size -1)
                        (cond (not has_next_curwin)
                        (ยง
                            ((ร next_curwin_size =) 0)
                        )
                        (and (< 1 totwincount) (< @p_wiw (ยง (room + (totwincount - 2)) / (totwincount - 1))))
                        (ยง
                            ;; Can make all windows wider than 'winwidth', spread the room equally.
                            ((ร next_curwin_size =) (ยง (room + (int)@p_wiw + (totwincount - 1) * (int)@p_wmw + (totwincount - 1)) / totwincount))
                            ((ร room -=) (- next_curwin_size @p_wiw))
                        )
                        :else
                        (ยง
                            ((ร next_curwin_size =) (ยง (int)@p_wiw))
                        ))
                    )
                ))

                (if has_next_curwin
                    (ยง --totwincount)          ;; don't count curwin
                )
            )

            ((ร FOR) (ร (ยง frame_C fr = topfr.fr_child) (!= fr null) (ยง fr = fr.fr_next))
                ((ร wincount =) 1)
                (ร int new_size)
                (cond (nil? (. fr fr_next))
                (ยง
                    ;; last frame gets all that remains (avoid roundoff error)
                    ((ร new_size =) width)
                )
                (== dir (byte \v))
                (ยง
                    ((ร new_size =) (. fr fr_width))
                )
                (frame_fixed_width fr)
                (ยง
                    ((ร new_size =) (. fr fr_newwidth))
                    ((ร wincount =) 0)       ;; doesn't count as a sizeable window
                )
                :else
                (ยง
                    ;; Compute the maximum number of windows horiz. in "fr".
                    ((ร int n =) (frame_minwidth fr, NOWIN))
                    ((ร wincount =) (/ (+ n (if (== (. fr fr_next) null) extra_sep 0)) (+ (int @p_wmw) 1)))
                    ((ร int m =) (frame_minwidth fr, next_curwin))
                    (ร boolean hnc)
                    (if has_next_curwin
                        ((ร hnc =) (frame_has_win fr, next_curwin))
                        ((ร hnc =) false)
                    )
                    (if hnc            ;; don't count next_curwin
                        (ยง --wincount)
                    )
                    (if (zero? totwincount)
                        ((ร new_size =) room)
                        ((ร new_size =) (ยง (wincount * room + (totwincount >>> 1)) / totwincount))
                    )
                    (cond hnc            ;; add next_curwin size
                    (ยง
                        ((ร next_curwin_size -=) (ยง @p_wiw - (m - n)))
                        ((ร new_size +=) next_curwin_size)
                        ((ร room -=) (- new_size next_curwin_size))
                    )
                    :else
                    (ยง
                        ((ร room -=) new_size)
                    ))
                    ((ร new_size +=) n)
                ))

                ;; Skip frame that is full width when splitting or closing a window,
                ;; unless equalizing all frames.
                (if (or (not current) (!= dir (byte \v)) (!= (. topfr fr_parent) null) (!= new_size (. fr fr_width)) (frame_has_win fr, next_curwin))
                    (win_equal_rec next_curwin, current, fr, dir, col, row, new_size, height))
                ((ร col +=) new_size)
                ((ร width -=) new_size)
                ((ร totwincount -=) wincount)
            )
        )
        :else ;; topfr.fr_layout == FR_COL
        (ยง
            ((ร topfr.fr_width =) width)
            ((ร topfr.fr_height =) height)

            (when (!= dir (byte \h))                 ;; equalize frame heights
                ;; Compute maximum number of windows vertically in this frame.
                ((ร int n =) (frame_minheight topfr, NOWIN))
                ;; add one for the bottom window if it doesn't have a statusline
                (if (and (== (+ row height) @cmdline_row) (zero? @p_ls))
                    ((ร extra_sep =) 1)
                    ((ร extra_sep =) 0)
                )
                ((ร totwincount =) (ยง (n + extra_sep) / ((int)@p_wmh + 1)))
                ((ร has_next_curwin =) (frame_has_win topfr, next_curwin))

                ;; Compute height for "next_curwin" window and room available for other windows.
                ;; "m" is the minimal height when counting "p_wh" for "next_curwin".

                ((ร int m =) (frame_minheight topfr, next_curwin))
                ((ร room =) (- height m))
                (cond (< room 0)
                (ยง
                    ;; The room is less then 'winheight', use all space for the current window.
                    ((ร next_curwin_size =) (ยง (int)@p_wh + room))
                    ((ร room =) 0)
                )
                :else
                (ยง
                    ((ร next_curwin_size =) -1)
                    ((ร FOR) (ร (ยง frame_C fr = topfr.fr_child) (!= fr null) (ยง fr = fr.fr_next))
                        ;; If 'winfixheight' set keep the window height if possible.
                        ;; Watch out for this window being the next_curwin.
                        (when (frame_fixed_height fr)
                            ((ร n =) (frame_minheight fr, NOWIN))
                            ((ร int new_size =) (. fr fr_height))
                            (cond (frame_has_win fr, next_curwin)
                            (ยง
                                ((ร room +=) (- @p_wh @p_wmh))
                                ((ร next_curwin_size =) 0)
                                (if (< new_size @p_wh)
                                    ((ร new_size =) (ยง (int)@p_wh))
                                )
                            )
                            :else
                            (ยง
                                ;; These windows don't use up room.
                                ((ร totwincount -=) (/ (+ n (if (== (. fr fr_next) null) extra_sep 0)) (+ @p_wmh 1)))
                            ))
                            ((ร room -=) (- new_size n))
                            (when (< room 0)
                                ((ร new_size +=) room)
                                ((ร room =) 0)
                            )
                            ((ร fr.fr_newheight =) new_size)
                        )
                    )
                    (when (== next_curwin_size -1)
                        (cond (not has_next_curwin)
                        (ยง
                            ((ร next_curwin_size =) 0)
                        )
                        (and (< 1 totwincount) (< @p_wh (ยง (room + (totwincount - 2)) / (totwincount - 1))))
                        (ยง
                            ;; Can make all windows higher than 'winheight', spread the room equally.
                            ((ร next_curwin_size =) (ยง (room + (int)@p_wh + (totwincount - 1) * (int)@p_wmh + (totwincount - 1)) / totwincount))
                            ((ร room -=) (- next_curwin_size @p_wh))
                        )
                        :else
                        (ยง
                            ((ร next_curwin_size =) (ยง (int)@p_wh))
                        ))
                    )
                ))

                (if has_next_curwin
                    (ยง --totwincount)          ;; don't count curwin
                )
            )

            ((ร FOR) (ร (ยง frame_C fr = topfr.fr_child) (!= fr null) (ยง fr = fr.fr_next))
                ((ร wincount =) 1)
                (ร int new_size)
                (cond (nil? (. fr fr_next))
                (ยง
                    ;; last frame gets all that remains (avoid roundoff error)
                    ((ร new_size =) height)
                )
                (== dir (byte \h))
                (ยง
                    ((ร new_size =) (. fr fr_height))
                )
                (frame_fixed_height fr)
                (ยง
                    ((ร new_size =) (. fr fr_newheight))
                    ((ร wincount =) 0)       ;; doesn't count as a sizeable window
                )
                :else
                (ยง
                    ;; Compute the maximum number of windows vert. in "fr".
                    ((ร int n =) (frame_minheight fr, NOWIN))
                    ((ร wincount =) (/ (+ n (if (== (. fr fr_next) null) extra_sep 0)) (+ (int @p_wmh) 1)))
                    ((ร int m =) (frame_minheight fr, next_curwin))
                    (ร boolean hnc)
                    (if has_next_curwin
                        ((ร hnc =) (frame_has_win fr, next_curwin))
                        ((ร hnc =) false)
                    )
                    (if hnc            ;; don't count next_curwin
                        (ยง --wincount)
                    )
                    (if (zero? totwincount)
                        ((ร new_size =) room)
                        ((ร new_size =) (ยง (wincount * room + (totwincount >>> 1)) / totwincount))
                    )
                    (cond hnc            ;; add next_curwin size
                    (ยง
                        ((ร next_curwin_size -=) (ยง @p_wh - (m - n)))
                        ((ร new_size +=) next_curwin_size)
                        ((ร room -=) (- new_size next_curwin_size))
                    )
                    :else
                    (ยง
                        ((ร room -=) new_size)
                    ))
                    ((ร new_size +=) n)
                ))
                ;; Skip frame that is full width when splitting or closing a window,
                ;; unless equalizing all frames.
                (when (or (not current) (!= dir (byte \h)) (!= (. topfr fr_parent) null) (!= new_size (. fr fr_height)) (frame_has_win fr, next_curwin))
                    (win_equal_rec next_curwin, current, fr, dir, col, row, width, new_size)
                )
                ((ร row +=) new_size)
                ((ร height -=) new_size)
                ((ร totwincount -=) wincount)
            )
        ))
    ))

;; Return true if there is only one window.

(defn- #_boolean one_window []
    (ยง
        ((ร boolean seen_one =) false)

        ((ร FOR) (ร (ยง window_C wp = @firstwin) (!= wp null) (ยง wp = wp.w_next))
            (if seen_one
                ((ร RETURN) false)
            )
            ((ร seen_one =) true)
        )

        true
    ))

;; Close window "win".  Only works for the current tab page.
;; If "_unload" is true related buffer may be unloaded.
;;
;; Returns false when the window was not closed.

(defn- #_boolean win_close [#_window_C win, #_boolean _unload]
    (ยง
        (when (one_window)
            (emsg (u8 "E444: Cannot close last window"))
            ((ร RETURN) false)
        )

        (if (== @firstwin @lastwin)
            ((ร RETURN) false)
        )

        ;; Close the link to the buffer.

        (close_buffer win)

        ;; Free the memory used for the window and get the window that received the screen space.
        ((ร int[] dir =) (ยง new int[1]))
        ((ร window_C wp =) (win_free_mem win, dir))

        ((ร boolean close_curwin =) false)

        ;; Make sure curwin isn't invalid.
        ;; It can cause severe trouble when printing an error message.
        ;; For win_equal() curbuf needs to be valid too.
        (when (== win @curwin)
            (reset! curwin wp)
            ((ร close_curwin =) true)
        )

        (if (and @p_ea (or (== (.at @p_ead 0) (byte \b)) (== (.at @p_ead 0) (ยง dir[0]))))
            (win_equal @curwin, true, (ยง dir[0]))
            (win_comp_pos))

        (if close_curwin
            (win_enter_ext wp, true))

        ;; If last window has a status line now and we don't want one,
        ;; remove the status line.

        (last_status false)

        (redraw_all_later NOT_VALID)
        true
    ))

;; Free the memory used for a window.
;; Returns a pointer to the window that got the freed up space.

(defn- #_window_C win_free_mem [#_window_C win, #_int* dirp]
    ;; dirp: set to 'v' or 'h' for direction if 'ea'
    (ยง
        ;; Remove the window and its frame from the tree of frames.
        ((ร window_C wp =) (winframe_remove win, dirp))
        (win_free win)

        wp
    ))

;; Remove a window and its frame from the tree of frames.
;; Returns a pointer to the window that got the freed up space.

(defn- #_window_C winframe_remove [#_window_C win, #_int* dirp]
    ;; dirp: set to 'v' or 'h' for direction if 'ea'
    (ยง
        ((ร frame_C frp_close =) (. win w_frame))

        ;; If there is only one window there is nothing to remove.

        (if (== @firstwin @lastwin)
            ((ร RETURN) null)
        )

        ;; Remove the window from its frame.

        ((ร frame_C frp2 =) (win_altframe win))
        ((ร window_C wp =) (frame2win frp2))

        ;; Remove this frame from the list of frames.
        (frame_remove frp_close)

        (cond (== (.. frp_close fr_parent fr_layout) FR_COL)
        (ยง
            ;; When 'winfixheight' is set, try to find another frame in the column
            ;; (as close to the closed frame as possible) to distribute the height to.
            (when (and (!= (. frp2 fr_win) null) @(.. frp2 fr_win w_options wo_wfh))
                ((ร frame_C frp =) (. frp_close fr_prev))
                ((ร frame_C frp3 =) (. frp_close fr_next))
                (while (ยง frp != null || frp3 != null)
                    (when (non-nil? frp)
                        (when (and (!= (. frp fr_win) null) (not @(.. frp fr_win w_options wo_wfh)))
                            ((ร frp2 =) frp)
                            ((ร wp =) (. frp fr_win))
                            (ร BREAK)
                        )
                        ((ร frp =) (. frp fr_prev))
                    )
                    (when (non-nil? frp3)
                        (when (and (!= (. frp3 fr_win) null) (not @(.. frp3 fr_win w_options wo_wfh)))
                            ((ร frp2 =) frp3)
                            ((ร wp =) (. frp3 fr_win))
                            (ร BREAK)
                        )
                        ((ร frp3 =) (. frp3 fr_next))
                    )
                )
            )
            (frame_new_height frp2, (ยง frp2.fr_height + frp_close.fr_height), (ยง frp2 == frp_close.fr_next), false)
            ((ร dirp[0] =) (byte \v))
        )
        :else
        (ยง
            ;; When 'winfixwidth' is set, try to find another frame in the column
            ;; (as close to the closed frame as possible) to distribute the width to.
            (when (and (!= (. frp2 fr_win) null) @(.. frp2 fr_win w_options wo_wfw))
                ((ร frame_C frp =) (. frp_close fr_prev))
                ((ร frame_C frp3 =) (. frp_close fr_next))
                (while (ยง frp != null || frp3 != null)
                    (when (non-nil? frp)
                        (when (and (!= (. frp fr_win) null) (not @(.. frp fr_win w_options wo_wfw)))
                            ((ร frp2 =) frp)
                            ((ร wp =) (. frp fr_win))
                            (ร BREAK)
                        )
                        ((ร frp =) (. frp fr_prev))
                    )
                    (when (non-nil? frp3)
                        (when (and (!= (. frp3 fr_win) null) (not @(.. frp3 fr_win w_options wo_wfw)))
                            ((ร frp2 =) frp3)
                            ((ร wp =) (. frp3 fr_win))
                            (ร BREAK)
                        )
                        ((ร frp3 =) (. frp3 fr_next))
                    )
                )
            )
            (frame_new_width frp2, (+ (. frp2 fr_width) (. frp_close fr_width)), (== frp2 (. frp_close fr_next)), false)
            ((ร dirp[0] =) (byte \h))
        ))

        ;; If rows/columns go to a window below/right its positions need to be updated.
        ;; Can only be done after the sizes have been updated.
        (when (== frp2 (. frp_close fr_next))
; %%        ((ร int[] row =) (ยง { win.w_winrow }))
; %%        ((ร int[] col =) (ยง { win.w_wincol }))

            (frame_comp_pos frp2, row, col)
        )

        (when (and (nil? (. frp2 fr_next)) (nil? (. frp2 fr_prev)))
            ;; There is no other frame in this list, move its info to the parent and remove it.
            ((ร frp2.fr_parent.fr_layout =) (. frp2 fr_layout))
            ((ร frp2.fr_parent.fr_child =) (. frp2 fr_child))
            ((ร FOR) (ร (ยง frame_C frp = frp2.fr_child) (!= frp null) (ยง frp = frp.fr_next))
                ((ร frp.fr_parent =) (. frp2 fr_parent))
            )
            ((ร frp2.fr_parent.fr_win =) (. frp2 fr_win))
            (if (!= (. frp2 fr_win) null)
                ((ร frp2.fr_win.w_frame =) (. frp2 fr_parent))
            )
            ((ร frame_C frp =) (. frp2 fr_parent))

            ((ร frp2 =) (. frp fr_parent))
            (when (and (non-nil? frp2) (== (. frp2 fr_layout) (. frp fr_layout)))
                ;; The frame above the parent has the same layout,
                ;; have to merge the frames into this list.
                (if (== (. frp2 fr_child) frp)
                    ((ร frp2.fr_child =) (. frp fr_child))
                )
                ((ร frp.fr_child.fr_prev =) (. frp fr_prev))
                (if (!= (. frp fr_prev) null)
                    ((ร frp.fr_prev.fr_next =) (. frp fr_child))
                )
                ((ร FOR) (ร (ยง frame_C frp3 = frp.fr_child) true (ยง frp3 = frp3.fr_next))
                    ((ร frp3.fr_parent =) frp2)
                    (when (nil? (. frp3 fr_next))
                        ((ร frp3.fr_next =) (. frp fr_next))
                        (if (!= (. frp fr_next) null)
                            ((ร frp.fr_next.fr_prev =) frp3)
                        )
                        (ร BREAK)
                    )
                )
            )
        )

        wp
    ))

;; Find out which frame is going to get the freed up space when "win" is closed.
;; if 'splitbelow'/'splitleft' the space goes to the window above/left.
;; if 'nosplitbelow'/'nosplitleft' the space goes to the window below/right.
;; This makes opening a window and closing it immediately keep the same window layout.

(defn- #_frame_C win_altframe [#_window_C win]
    (ยง
        (if (== @firstwin @lastwin)
            ((ร RETURN) (. @curwin w_frame))
        )

        ((ร frame_C frp =) (. win w_frame))
        ((ร boolean b =) (if (and (!= (. frp fr_parent) null) (== (.. frp fr_parent fr_layout) FR_ROW)) @p_spr @p_sb))
        (if (or (and (not b) (!= (. frp fr_next) null)) (nil? (. frp fr_prev)))
            ((ร RETURN) (. frp fr_next))
        )

        (. frp fr_prev)
    ))

;; Find the left-upper window in frame "frp".

(defn- #_window_C frame2win [#_frame_C frp]
    (ยง
        (while (ยง frp.fr_win == null)
            ((ร frp =) (. frp fr_child))
        )
        (. frp fr_win)
    ))

;; Return true if frame "frp" contains window "wp".

(defn- #_boolean frame_has_win [#_frame_C frp, #_window_C wp]
    (ยง
        (if (== (. frp fr_layout) FR_LEAF)
            ((ร RETURN) (ยง (frp.fr_win == wp)))
        )

        ((ร FOR) (ร (ยง frame_C p = frp.fr_child) (!= p null) (ยง p = p.fr_next))
            (if (frame_has_win p, wp)
                ((ร RETURN) true)
            )
        )

        false
    ))

;; Set a new height for a frame.  Recursively sets the height for contained
;; frames and windows.  Caller must take care of positions.

(defn- #_void frame_new_height [#_frame_C topfrp, #_int height, #_boolean topfirst, #_boolean wfh]
    ;; topfirst: resize topmost contained frame first
    ;; wfh: obey 'winfixheight' when there is a choice; may cause the height not to be set
    (ยง
        (cond (!= (. topfrp fr_win) null)
        (ยง
            ;; Simple case: just one window.
            (win_new_height (. topfrp fr_win), (- height (.. topfrp fr_win w_status_height)))
        )
        (== (. topfrp fr_layout) FR_ROW)
        (ยง
            (ร frame_C frp)
;           do
;           {
                ;; All frames in this row get the same new height.
                ((ร FOR) (ร (ยง frp = topfrp.fr_child) (!= frp null) (ยง frp = frp.fr_next))
                    (frame_new_height frp, height, topfirst, wfh)
                    (when (< height (. frp fr_height))
                        ;; Could not fit the windows, make the whole row higher.
                        ((ร height =) (. frp fr_height))
                        (ร BREAK)
                    )
                )
;           } while (frp != null);
        )
        :else    ;; fr_layout == FR_COL
        (ยง
            ;; Complicated case: resize a column of frames.
            ;; Resize the bottom frame first, frames above that when needed.

            ((ร frame_C frp =) (. topfrp fr_child))
            (when wfh
                ;; Advance past frames with one window with 'wfh' set.
                (while (frame_fixed_height frp)
                    ((ร frp =) (. frp fr_next))
                    (if (nil? frp)
                        (ร RETURN)         ;; no frame without 'wfh', give up
                    )
                )
            )
            (when (not topfirst)
                ;; Find the bottom frame of this column.
                (while (ยง frp.fr_next != null)
                    ((ร frp =) (. frp fr_next))
                )
                (when wfh
                    ;; Advance back for frames with one window with 'wfh' set.
                    (while (frame_fixed_height frp)
                        ((ร frp =) (. frp fr_prev))
                    )
                )
            )

            ((ร int extra_lines =) (ยง height - topfrp.fr_height))
            (cond (< extra_lines 0)
            (ยง
                ;; reduce height of contained frames, bottom or top frame first
                (while (!= frp null)
                    ((ร int h =) (frame_minheight frp, null))
                    (cond (ยง frp.fr_height + extra_lines < h)
                    (ยง
                        ((ร extra_lines +=) (ยง frp.fr_height - h))
                        (frame_new_height frp, h, topfirst, wfh)
                    )
                    :else
                    (ยง
                        (frame_new_height frp, (+ (. frp fr_height) extra_lines), topfirst, wfh)
                        (ร BREAK)
                    ))
                    (cond topfirst
                    (ยง
;                       do
;                       {
                            ((ร frp =) (. frp fr_next))
;                       } while (wfh && frp != null && frame_fixed_height(frp));
                    )
                    :else
                    (ยง
;                       do
;                       {
                            ((ร frp =) (. frp fr_prev))
;                       } while (wfh && frp != null && frame_fixed_height(frp));
                    ))
                    ;; Increase "height" if we could not reduce enough frames.
                    (if (nil? frp)
                        ((ร height -=) extra_lines)
                    )
                )
            )
            (< 0 extra_lines)
            (ยง
                ;; increase height of bottom or top frame
                (frame_new_height frp, (+ (. frp fr_height) extra_lines), topfirst, wfh)
            ))
        ))
        ((ร topfrp.fr_height =) height)
    ))

;; Return true if height of frame "frp" should not be changed because of
;; the 'winfixheight' option.

(defn- #_boolean frame_fixed_height [#_frame_C frp]
    (ยง
        ;; frame with one window: fixed height if 'winfixheight' set.
        (if (!= (. frp fr_win) null)
            ((ร RETURN) @(.. frp fr_win w_options wo_wfh))
        )

        (when (== (. frp fr_layout) FR_ROW)
            ;; The frame is fixed height if one of the frames in the row is fixed height.
            ((ร FOR) (ร (ยง frp = frp.fr_child) (!= frp null) (ยง frp = frp.fr_next))
                (if (frame_fixed_height frp)
                    ((ร RETURN) true)
                )
            )

            ((ร RETURN) false)
        )

        ;; frp.fr_layout == FR_COL: the frame is fixed height
        ;; if all of the frames in the row are fixed height.
        ((ร FOR) (ร (ยง frp = frp.fr_child) (!= frp null) (ยง frp = frp.fr_next))
            (if (not (frame_fixed_height frp))
                ((ร RETURN) false)
            )
        )

        true
    ))

;; Return true if width of frame "frp" should not be changed
;; because of the 'winfixwidth' option.

(defn- #_boolean frame_fixed_width [#_frame_C frp]
    (ยง
        ;; frame with one window: fixed width if 'winfixwidth' set.
        (if (!= (. frp fr_win) null)
            ((ร RETURN) @(.. frp fr_win w_options wo_wfw))
        )

        (when (== (. frp fr_layout) FR_COL)
            ;; The frame is fixed width if one of the frames in the row is fixed width.
            ((ร FOR) (ร (ยง frp = frp.fr_child) (!= frp null) (ยง frp = frp.fr_next))
                (if (frame_fixed_width frp)
                    ((ร RETURN) true)
                )
            )

            ((ร RETURN) false)
        )

        ;; frp.fr_layout == FR_ROW: the frame is fixed width
        ;; if all of the frames in the row are fixed width.
        ((ร FOR) (ร (ยง frp = frp.fr_child) (!= frp null) (ยง frp = frp.fr_next))
            (if (not (frame_fixed_width frp))
                ((ร RETURN) false)
            )
        )

        true
    ))

;; Add a status line to windows at the bottom of "frp".
;; Note: Does not check if there is room!

(defn- #_void frame_add_statusline [#_frame_C frp]
    (ยง
        (cond (== (. frp fr_layout) FR_LEAF)
        (ยง
            ((ร window_C wp =) (. frp fr_win))
            (when (zero? (. wp w_status_height))
                (if (< 0 (. wp w_height))    ;; don't make it negative
                    (ยง --wp.w_height)
                )
                ((ร wp.w_status_height =) STATUS_HEIGHT)
            )
        )
        (== (. frp fr_layout) FR_ROW)
        (ยง
            ;; Handle all the frames in the row.
            ((ร FOR) (ร (ยง frp = frp.fr_child) (!= frp null) (ยง frp = frp.fr_next))
                (frame_add_statusline frp)
            )
        )
        :else ;; frp.fr_layout == FR_COL
        (ยง
            ;; Only need to handle the last frame in the column.
            ((ร FOR) (ร (ยง frp = frp.fr_child) (ยง frp.fr_next != null) (ยง frp = frp.fr_next))
                ;
            )
            (frame_add_statusline frp)
        ))
    ))

;; Set width of a frame.  Handles recursively going through contained frames.
;; May remove separator line for windows at the right side (for win_close()).

(defn- #_void frame_new_width [#_frame_C topfrp, #_int width, #_boolean leftfirst, #_boolean wfw]
    ;; leftfirst: resize leftmost contained frame first
    ;; wfw: obey 'winfixwidth' when there is a choice; may cause the width not to be set
    (ยง
        (cond (== (. topfrp fr_layout) FR_LEAF)
        (ยง
            ;; Simple case: just one window.
            ((ร window_C wp =) (. topfrp fr_win))
            ;; Find out if there are any windows right of this one.
            (ร frame_C frp)
            ((ร FOR) (ร (ยง frp = topfrp) (ยง frp.fr_parent != null) (ยง frp = frp.fr_parent))
                (if (and (== (.. frp fr_parent fr_layout) FR_ROW) (!= (. frp fr_next) null))
                    (ร BREAK)
                )
            )
            (if (nil? (. frp fr_parent))
                ((ร wp.w_vsep_width =) 0)
            )
            (win_new_width wp, (- width (. wp w_vsep_width)))
        )
        (== (. topfrp fr_layout) FR_COL)
        (ยง
            (ร frame_C frp)
;           do
;           {
                ;; All frames in this column get the same new width.
                ((ร FOR) (ร (ยง frp = topfrp.fr_child) (!= frp null) (ยง frp = frp.fr_next))
                    (frame_new_width frp, width, leftfirst, wfw)
                    (when (< width (. frp fr_width))
                        ;; Could not fit the windows, make whole column wider.
                        ((ร width =) (. frp fr_width))
                        (ร BREAK)
                    )
                )
;           } while (frp != null);
        )
        :else    ;; fr_layout == FR_ROW
        (ยง
            ;; Complicated case: resize a row of frames.
            ;; Resize the rightmost frame first, frames left of it when needed.

            ((ร frame_C frp =) (. topfrp fr_child))
            (when wfw
                ;; Advance past frames with one window with 'wfw' set.
                (while (frame_fixed_width frp)
                    ((ร frp =) (. frp fr_next))
                    (if (nil? frp)
                        (ร RETURN)         ;; no frame without 'wfw', give up
                    )
                )
            )
            (when (not leftfirst)
                ;; Find the rightmost frame of this row.
                (while (ยง frp.fr_next != null)
                    ((ร frp =) (. frp fr_next))
                )
                (when wfw
                    ;; Advance back for frames with one window with 'wfw' set.
                    (while (frame_fixed_width frp)
                        ((ร frp =) (. frp fr_prev))
                    )
                )
            )

            ((ร int extra_cols =) (ยง width - topfrp.fr_width))
            (cond (< extra_cols 0)
            (ยง
                ;; reduce frame width, rightmost frame first
                (while (!= frp null)
                    ((ร int w =) (frame_minwidth frp, null))
                    (cond (ยง frp.fr_width + extra_cols < w)
                    (ยง
                        ((ร extra_cols +=) (ยง frp.fr_width - w))
                        (frame_new_width frp, w, leftfirst, wfw)
                    )
                    :else
                    (ยง
                        (frame_new_width frp, (+ (. frp fr_width) extra_cols), leftfirst, wfw)
                        (ร BREAK)
                    ))
                    (cond leftfirst
                    (ยง
;                       do
;                       {
                            ((ร frp =) (. frp fr_next))
;                       } while (wfw && frp != null && frame_fixed_width(frp));
                    )
                    :else
                    (ยง
;                       do
;                       {
                            ((ร frp =) (. frp fr_prev))
;                       } while (wfw && frp != null && frame_fixed_width(frp));
                    ))
                    ;; Increase "width" if we could not reduce enough frames.
                    (if (nil? frp)
                        ((ร width -=) extra_cols)
                    )
                )
            )
            (< 0 extra_cols)
            (ยง
                ;; increase width of rightmost frame
                (frame_new_width frp, (+ (. frp fr_width) extra_cols), leftfirst, wfw)
            ))
        ))
        ((ร topfrp.fr_width =) width)
    ))

;; Add the vertical separator to windows at the right side of "frp".
;; Note: Does not check if there is room!

(defn- #_void frame_add_vsep [#_frame_C frp]
    (ยง
        (cond (== (. frp fr_layout) FR_LEAF)
        (ยง
            ((ร window_C wp =) (. frp fr_win))
            (when (zero? (. wp w_vsep_width))
                (if (< 0 (. wp w_width))     ;; don't make it negative
                    (ยง --wp.w_width)
                )
                ((ร wp.w_vsep_width =) 1)
            )
        )
        (== (. frp fr_layout) FR_COL)
        (ยง
            ;; Handle all the frames in the column.
            ((ร FOR) (ร (ยง frp = frp.fr_child) (!= frp null) (ยง frp = frp.fr_next))
                (frame_add_vsep frp)
            )
        )
        :else ;; frp.fr_layout == FR_ROW
        (ยง
            ;; Only need to handle the last frame in the row.
            ((ร frp =) (. frp fr_child))
            (while (ยง frp.fr_next != null)
                ((ร frp =) (. frp fr_next))
            )
            (frame_add_vsep frp)
        ))
    ))

;; Set frame width from the window it contains.

(defn- #_void frame_fix_width [#_window_C wp]
    (ยง
        ((ร wp.w_frame.fr_width =) (ยง wp.w_width + wp.w_vsep_width))
    ))

;; Set frame height from the window it contains.

(defn- #_void frame_fix_height [#_window_C wp]
    (ยง
        ((ร wp.w_frame.fr_height =) (ยง wp.w_height + wp.w_status_height))
    ))

;; Compute the minimal height for frame "topfrp".
;; Uses the 'winminheight' option.
;; When "next_curwin" isn't null, use "p_wh" for this window.
;; When "next_curwin" is NOWIN, don't use at least one line for the current window.

(defn- #_int frame_minheight [#_frame_C topfrp, #_window_C next_curwin]
    (ยง
        (ร int m)

        (cond (!= (. topfrp fr_win) null)
        (ยง
            (cond (== (. topfrp fr_win) next_curwin)
            (ยง
                ((ร m =) (ยง (int)@p_wh + topfrp.fr_win.w_status_height))
            )
            :else
            (ยง
                ;; window: minimal height of the window plus status line
                ((ร m =) (ยง (int)@p_wmh + topfrp.fr_win.w_status_height))
                ;; Current window is minimal one line high.
                (if (and (zero? @p_wmh) (== (. topfrp fr_win) @curwin) (nil? next_curwin))
                    (ยง m++)
                )
            ))
        )
        (== (. topfrp fr_layout) FR_ROW)
        (ยง
            ;; get the minimal height from each frame in this row
            ((ร m =) 0)
            ((ร FOR) (ร (ยง frame_C frp = topfrp.fr_child) (!= frp null) (ยง frp = frp.fr_next))
                ((ร int n =) (frame_minheight frp, next_curwin))
                (if (< m n)
                    ((ร m =) n)
                )
            )
        )
        :else
        (ยง
            ;; Add up the minimal heights for all frames in this column.
            ((ร m =) 0)
            ((ร FOR) (ร (ยง frame_C frp = topfrp.fr_child) (!= frp null) (ยง frp = frp.fr_next))
                ((ร m +=) (frame_minheight frp, next_curwin))
            )
        ))

        m
    ))

;; Compute the minimal width for frame "topfrp".
;; When "next_curwin" isn't null, use "p_wiw" for this window.
;; When "next_curwin" is NOWIN, don't use at least one column for the current window.

(defn- #_int frame_minwidth [#_frame_C topfrp, #_window_C next_curwin]
    ;; next_curwin: use "p_wh" and "p_wiw" for next_curwin
    (ยง
        (ร int m)

        (cond (!= (. topfrp fr_win) null)
        (ยง
            (cond (== (. topfrp fr_win) next_curwin)
            (ยง
                ((ร m =) (ยง (int)@p_wiw + topfrp.fr_win.w_vsep_width))
            )
            :else
            (ยง
                ;; window: minimal width of the window plus separator column
                ((ร m =) (ยง (int)@p_wmw + topfrp.fr_win.w_vsep_width))
                ;; Current window is minimal one column wide.
                (if (and (zero? @p_wmw) (== (. topfrp fr_win) @curwin) (nil? next_curwin))
                    (ยง m++)
                )
            ))
        )
        (== (. topfrp fr_layout) FR_COL)
        (ยง
            ;; get the minimal width from each frame in this column
            ((ร m =) 0)
            ((ร FOR) (ร (ยง frame_C frp = topfrp.fr_child) (!= frp null) (ยง frp = frp.fr_next))
                ((ร int n =) (frame_minwidth frp, next_curwin))
                (if (< m n)
                    ((ร m =) n)
                )
            )
        )
        :else
        (ยง
            ;; Add up the minimal widths for all frames in this row.
            ((ร m =) 0)
            ((ร FOR) (ร (ยง frame_C frp = topfrp.fr_child) (!= frp null) (ยง frp = frp.fr_next))
                ((ร m +=) (frame_minwidth frp, next_curwin))
            )
        ))

        m
    ))

;; Try to close all windows except current one.
;; Buffers in the other windows become hidden if 'hidden' is set,
;; or '!' is used and the buffer was modified.

(defn- #_void close_others [#_boolean message, #_boolean forceit]
    ;; forceit: always hide all other windows
    (ยง
        (when (one_window)
            (if message
                (msg m_onlyone))
            (ร RETURN)
        )

        ;; Be very careful here: autocommands may change the window layout.
        ((ร FOR) (ร (ยง window_C wp = @firstwin, nextwp) (win_valid wp) (ยง wp = nextwp))
            ((ร nextwp =) (. wp w_next))
            (when (!= wp @curwin)               ;; don't close current window
                ;; Check if it's allowed to abandon this window.
                ((ร boolean r =) (can_abandon @curbuf, forceit))
                (when (not (win_valid wp))         ;; autocommands messed wp up
                    ((ร nextwp =) @firstwin)
                    (ร CONTINUE)
                )
                (when (not r)
                    (if @(. @curbuf b_changed)
                        (ร CONTINUE)
                    )
                )
                (win_close wp, (not @(. @curbuf b_changed)))
            )
        )

        (when (and message (!= @lastwin @firstwin))
            (emsg (u8 "E445: Other window contains changes"))
        )
    ))

(defn- #_void win_init_empty [#_window_C wp]
    (ยง
        (redraw_win_later wp, NOT_VALID)

        ((ร wp.w_lines_valid =) 0)
        ((ร wp.w_cursor.lnum =) 1)
        ((ร wp.w_curswant =) (ยง wp.w_cursor.col = 0))
        ((ร wp.w_cursor.coladd =) 0)
        ((ร wp.w_pcmark.lnum =) 1)       ;; pcmark not cleared but set to line 1
        ((ร wp.w_pcmark.col =) 0)
        ((ร wp.w_prev_pcmark.lnum =) 0)
        ((ร wp.w_prev_pcmark.col =) 0)
        ((ร wp.w_topline =) 1)
        ((ร wp.w_botline =) 2)
    ))

;; Allocate the first window and put an empty buffer in it.
;; Called from main().

(defn- #_void win_alloc_first []
    (ยง
        (reset! curwin (newWindow null))

        (reset! curbuf (newBuffer))

        ((ร @curbuf.b_nwindows =) 1)          ;; there is one window

        ;; mark cursor position as being invalid
        ((ร @curwin.w_valid =) 0)

        ;; need to set w_topline
        ((ร @curwin.w_topline =) 1)

        (win_init_empty @curwin)

        ((ร @curwin.w_frame =) (newFrame @curwin))

        (reset! topframe (. @curwin w_frame))
        ((ร @topframe.fr_width =) (ยง (int)@Columns))
        ((ร @topframe.fr_height =) (ยง (int)(@Rows - @p_ch)))
        ((ร @topframe.fr_win =) @curwin)

        (reset! ch_used @p_ch)
    ))

;; Create a frame for window "wp".

(defn- #_frame_C newFrame [#_window_C wp]
    (ยง
        ((ร frame_C frp =) (ยง ยง_frame_C()))

        ((ร frp.fr_layout =) FR_LEAF)
        ((ร frp.fr_win =) wp)

        frp
    ))

;; Initialize the window and frame size to the maximum.

(defn- #_void win_init_size []
    (ยง
        ((ร long rows_avail =) (- @Rows @p_ch))

        ((ร @firstwin.w_height =) (ยง (int)rows_avail))
        ((ร @topframe.fr_height =) (ยง (int)rows_avail))
        ((ร @firstwin.w_width =) (ยง (int)@Columns))
        ((ร @topframe.fr_width =) (ยง (int)@Columns))
    ))

;; Go to another window.
;; When jumping to another buffer, stop Visual mode.  Do this before
;; changing windows so we can yank the selection into the '*' register.
;; When jumping to another window on the same buffer, adjust its cursor
;; position to keep the same Visual area.

(defn- #_void win_goto [#_window_C wp]
    (ยง
        ((ร window_C owp =) @curwin)

        (when (text_locked)
            (beep_flush)
            (text_locked_msg)
            (ร RETURN)
        )

        (if @VIsual_active
            (COPY_pos (. wp w_cursor), (. @curwin w_cursor)))

        (win_enter wp)

        ;; Conceal cursor line in previous window, unconceal in current window.
        (if (and (win_valid owp) (< 0 @(.. owp w_options wo_cole)) (zero? @msg_scrolled))
            (update_single_line owp, (.. owp w_cursor lnum)))
        (when (and (< 0 @(.. @curwin w_options wo_cole)) (zero? @msg_scrolled))
            (reset! need_cursor_line_redraw true)
        )
    ))

;; Move to window above or below "count" times.

(defn- #_void win_goto_ver [#_boolean up, #_long count]
    ;; up: true to go to win above
    (ยง
        ((ร frame_C foundfr =) (. @curwin w_frame))

;       end:
        (while (ยง 0 < count--)
            (ร frame_C nfr)

            ;; First go upwards in the tree of frames until we find a upwards or downwards neighbor.

            ((ร FOR) (ร (ยง frame_C fr = foundfr) true (ยง fr = fr.fr_parent))
                (if (== fr @topframe)
                    (ร BREAK end)
                )
                (if up
                    ((ร nfr =) (. fr fr_prev))
                    ((ร nfr =) (. fr fr_next))
                )
                (if (and (== (.. fr fr_parent fr_layout) FR_COL) (non-nil? nfr))
                    (ร BREAK)
                )
            )

            ;; Now go downwards to find the bottom or top frame in it.

            (while true
                (when (== (. nfr fr_layout) FR_LEAF)
                    ((ร foundfr =) nfr)
                    (ร BREAK)
                )
                ((ร frame_C fr =) (. nfr fr_child))
                (when (== (. nfr fr_layout) FR_ROW)
                    ;; Find the frame at the cursor row.
                    (while (ยง fr.fr_next != null && frame2win(fr).w_wincol + fr.fr_width <= @curwin.w_wincol + @curwin.w_wcol)
                        ((ร fr =) (. fr fr_next))
                    )
                )
                (when (and (== (. nfr fr_layout) FR_COL) up)
                    (while (ยง fr.fr_next != null)
                        ((ร fr =) (. fr fr_next))
                    )
                )
                ((ร nfr =) fr)
            )
        )

        (when (non-nil? foundfr)
            (win_goto (. foundfr fr_win))
        )
    ))

;; Move to left or right window.

(defn- #_void win_goto_hor [#_boolean left, #_long count]
    ;; left: true to go to left win
    (ยง
        ((ร frame_C foundfr =) (. @curwin w_frame))

;       end:
        (while (ยง 0 < count--)
            (ร frame_C nfr)

            ;; First go upwards in the tree of frames until we find a left or right neighbor.

            ((ร FOR) (ร (ยง frame_C fr = foundfr) true (ยง fr = fr.fr_parent))
                (if (== fr @topframe)
                    (ร BREAK end)
                )
                (if left
                    ((ร nfr =) (. fr fr_prev))
                    ((ร nfr =) (. fr fr_next))
                )
                (if (and (== (.. fr fr_parent fr_layout) FR_ROW) (non-nil? nfr))
                    (ร BREAK)
                )
            )

            ;; Now go downwards to find the leftmost or rightmost frame in it.

            (while true
                (when (== (. nfr fr_layout) FR_LEAF)
                    ((ร foundfr =) nfr)
                    (ร BREAK)
                )
                ((ร frame_C fr =) (. nfr fr_child))
                (when (== (. nfr fr_layout) FR_COL)
                    ;; Find the frame at the cursor row.
                    (while (ยง fr.fr_next != null && frame2win(fr).w_winrow + fr.fr_height <= @curwin.w_winrow + @curwin.w_wrow)
                        ((ร fr =) (. fr fr_next))
                    )
                )
                (when (and (== (. nfr fr_layout) FR_ROW) left)
                    (while (ยง fr.fr_next != null)
                        ((ร fr =) (. fr fr_next))
                    )
                )
                ((ร nfr =) fr)
            )
        )

        (when (non-nil? foundfr)
            (win_goto (. foundfr fr_win))
        )
    ))

;; Make window "wp" the current window.

(defn- #_void win_enter [#_window_C wp]
    (win_enter_ext wp, false))

;; Make window wp the current window.
;; Can be called with "curwin_invalid" true, which means that curwin has just
;; been closed and isn't valid.

(defn- #_void win_enter_ext [#_window_C wp, #_boolean curwin_invalid]
    (ยง
        (if (and (== wp @curwin) (not curwin_invalid))        ;; nothing to do
            (ร RETURN)
        )

        ;; Might need to scroll the old window before switching, e.g., when the cursor was moved.
        (update_topline)

        (when (not curwin_invalid)
            (reset! prevwin @curwin)       ;; remember for CTRL-W p
            ((ร @curwin.w_redr_status =) true)
        )
        (reset! curwin wp)
        (check_cursor)
        (if (not (virtual_active))
            ((ร @curwin.w_cursor.coladd =) 0)
        )
        (changed_line_abv_curs)    ;; assume cursor position needs updating

        ((ร @curwin.w_redr_status =) true)
        (if (non-zero? @restart_edit)
            (redraw_later VALID))    ;; causes status line redraw

        ;; set window height to desired minimal value
        (cond (and (< (. @curwin w_height) @p_wh) (not @(.. @curwin w_options wo_wfh)))
        (ยง
            (win_setheight (int @p_wh))
        )
        (zero? (. @curwin w_height))
        (ยง
            (win_setheight 1)
        ))

        ;; set window width to desired minimal value
        (when (and (< (. @curwin w_width) @p_wiw) (not @(.. @curwin w_options wo_wfw)))
            (win_setwidth (int @p_wiw))
        )
    ))

;; Allocate a window structure and link it in the window list.

(defn- #_window_C newWindow [#_window_C after]
    (ยง
        ;; allocate window structure and linesizes arrays
        ((ร window_C wp =) (ยง ยง_window_C()))

        (win_alloc_lines wp)

        ;; link the window in the window list
        (win_append after, wp)
        ((ร wp.w_wincol =) 0)
        ((ร wp.w_width =) (ยง (int)@Columns))

        ;; position the display and the cursor at the top of the file
        ((ร wp.w_topline =) 1)
        ((ร wp.w_botline =) 2)
        ((ร wp.w_cursor.lnum =) 1)
        ((ร wp.w_scbind_pos =) 1)

        ;; We won't calculate w_fraction until resizing the window.
        ((ร wp.w_fraction =) 0)
        ((ร wp.w_prev_fraction_row =) -1)

        ((ร wp.w_match_head =) null)
        ((ร wp.w_next_match_id =) 4)

        wp
    ))

;; Remove window 'wp' from the window list and free the structure.

(defn- #_void win_free [#_window_C wp]
    (ยง
        (clear_winopt (. wp w_options))

        (if (== @prevwin wp)
            (reset! prevwin null))

        (win_free_lines wp)

        (clear_matches wp)

        ((ร wp.w_p_cc_cols =) null)

        (win_remove wp)
    ))

;; Append window "wp" in the window list after window "after".

(defn- #_void win_append [#_window_C after, #_window_C wp]
    (ยง
        (ร window_C before)
        (if (nil? after)      ;; after null is in front of the first
            ((ร before =) @firstwin)
            ((ร before =) (. after w_next))
        )

        ((ร wp.w_next =) before)
        ((ร wp.w_prev =) after)
        (if (nil? after)
            (reset! firstwin wp)
            ((ร after.w_next =) wp)
        )
        (if (nil? before)
            (reset! lastwin wp)
            ((ร before.w_prev =) wp)
        )
    ))

;; Remove a window from the window list.

(defn- #_void win_remove [#_window_C wp]
    (ยง
        (if (!= (. wp w_prev) null)
            ((ร wp.w_prev.w_next =) (. wp w_next))
            (reset! firstwin (. wp w_next)))

        (if (!= (. wp w_next) null)
            ((ร wp.w_next.w_prev =) (. wp w_prev))
            (reset! lastwin (. wp w_prev)))
    ))

;; Append frame "frp" in a frame list after frame "after".

(defn- #_void frame_append [#_frame_C after, #_frame_C frp]
    (ยง
        ((ร frp.fr_next =) (. after fr_next))
        ((ร after.fr_next =) frp)
        (if (!= (. frp fr_next) null)
            ((ร frp.fr_next.fr_prev =) frp)
        )
        ((ร frp.fr_prev =) after)
    ))

;; Insert frame "frp" in a frame list before frame "before".

(defn- #_void frame_insert [#_frame_C before, #_frame_C frp]
    (ยง
        ((ร frp.fr_next =) before)
        ((ร frp.fr_prev =) (. before fr_prev))
        ((ร before.fr_prev =) frp)
        (if (!= (. frp fr_prev) null)
            ((ร frp.fr_prev.fr_next =) frp)
            ((ร frp.fr_parent.fr_child =) frp)
        )
    ))

;; Remove a frame from a frame list.

(defn- #_void frame_remove [#_frame_C frp]
    (ยง
        (if (!= (. frp fr_prev) null)
            ((ร frp.fr_prev.fr_next =) (. frp fr_next))
            ((ร frp.fr_parent.fr_child =) (. frp fr_next))
        )
        (when (!= (. frp fr_next) null)
            ((ร frp.fr_next.fr_prev =) (. frp fr_prev))
        )
    ))

;; Allocate w_lines[] for window "wp".

(defn- #_void win_alloc_lines [#_window_C wp]
    (ยง
        ((ร wp.w_lines_valid =) 0)
        ((ร wp.w_lines_len =) (ยง (int)@Rows))
        ((ร wp.w_lines =) (ยง ARRAY_wline(wp.w_lines_len)))
    ))

;; Free w_lines[] for window "wp".

(defn- #_void win_free_lines [#_window_C wp]
    (ยง
        ((ร wp.w_lines_len =) 0)
        ((ร wp.w_lines =) null)
    ))

;; Called from win_new_shellsize() after Rows changed.
;; This only does the current tab page, others must be done when made active.

(defn- #_void shell_new_rows []
    (ยง
        ((ร long rows_avail =) (- @Rows @p_ch))

        ((ร int h =) (ยง (int)rows_avail))

        (if (nil? @firstwin)           ;; not initialized yet
            (ร RETURN)
        )
        (if (< h (frame_minheight @topframe, null))
            ((ร h =) (frame_minheight @topframe, null))
        )

        ;; First try setting the heights of windows with 'winfixheight'.
        ;; If that doesn't result in the right height, forget about that option.
        (frame_new_height @topframe, h, false, true)
        (if (not (frame_check_height @topframe, h))
            (frame_new_height @topframe, h, false, false))

        (win_comp_pos)                 ;; recompute w_winrow and w_wincol
        (compute_cmdrow)
        (reset! ch_used @p_ch)
    ))

;; Called from win_new_shellsize() after Columns changed.

(defn- #_void shell_new_columns []
    (ยง
        (if (nil? @firstwin)           ;; not initialized yet
            (ร RETURN)
        )

        ;; First try setting the widths of windows with 'winfixwidth'.
        ;; If that doesn't result in the right width, forget about that option.
        (frame_new_width @topframe, (int @Columns), false, true)
        (if (not (frame_check_width @topframe, (int @Columns)))
            (frame_new_width @topframe, (int @Columns), false, false))

        (win_comp_pos)                 ;; recompute w_winrow and w_wincol
    ))

;; Update the position for all windows, using the width and height of the frames.
;; Returns the row just after the last window.

(defn- #_int win_comp_pos []
    (ยง
; %%    ((ร int[] row =) (ยง { 0 }))
; %%    ((ร int[] col =) (ยง { 0 }))

        (frame_comp_pos @topframe, row, col)
        (ยง row[0])
    ))

;; Update the position of the windows in frame "topfrp",
;; using the width and height of the frames.
;; "*row" and "*col" are the top-left position of the frame.
;; They are updated to the bottom-right position plus one.

(defn- #_void frame_comp_pos [#_frame_C topfrp, #_int* row, #_int* col]
    (ยง
        ((ร window_C wp =) (. topfrp fr_win))
        (cond (non-nil? wp)
        (ยง
            (when (or (!= (. wp w_winrow) (ยง row[0])) (!= (. wp w_wincol) (ยง col[0])))
                ;; position changed, redraw
                ((ร wp.w_winrow =) (ยง row[0]))
                ((ร wp.w_wincol =) (ยง col[0]))
                (redraw_win_later wp, NOT_VALID)
                ((ร wp.w_redr_status =) true)
            )
            ((ร row[0] +=) (ยง wp.w_height + wp.w_status_height))
            ((ร col[0] +=) (ยง wp.w_width + wp.w_vsep_width))
        )
        :else
        (ยง
            ((ร int startrow =) (ยง row[0]))
            ((ร int startcol =) (ยง col[0]))
            ((ร FOR) (ร (ยง frame_C frp = topfrp.fr_child) (!= frp null) (ยง frp = frp.fr_next))
                (if (== (. topfrp fr_layout) FR_ROW)
                    ((ร row[0] =) startrow)        ;; all frames are at the same row
                    ((ร col[0] =) startcol)        ;; all frames are at the same col
                )
                (frame_comp_pos frp, row, col)
            )
        ))
    ))

;; Set current window height and take care of repositioning other windows to fit around it.

(defn- #_void win_setheight [#_int height]
    (win_setheight_win height, @curwin))

;; Set the window height of window "win" and take care of repositioning other windows to fit around it.

(defn- #_void win_setheight_win [#_int height, #_window_C win]
    (ยง
        (when (== win @curwin)
            ;; Always keep current window at least one line high, even when 'winminheight' is zero.
            (if (< height @p_wmh)
                ((ร height =) (ยง (int)@p_wmh))
            )
            (if (zero? height)
                ((ร height =) 1)
            )
        )

        (frame_setheight (. win w_frame), (+ height (. win w_status_height)))

        ;; recompute the window positions
        ((ร int row =) (win_comp_pos))

        ;; If there is extra space created between the last window and the command line, clear it.

        (if (and @full_screen (zero? @msg_scrolled) (< row @cmdline_row))
            (screen_fill row, @cmdline_row, 0, (int @Columns), (byte \space), (byte \space), 0))
        (reset! cmdline_row row)
        (reset! msg_row row)
        (reset! msg_col 0)

        (redraw_all_later NOT_VALID)
    ))

;; Set the height of a frame to "height" and take care that all frames and
;; windows inside it are resized.  Also resize frames on the left and right
;; if the are in the same FR_ROW frame.
;;
;; Strategy:
;; If the frame is part of a FR_COL frame, try fitting the frame in that frame.
;; If that doesn't work (the FR_COL frame is too small), recursively go to
;; containing frames to resize them and make room.
;; If the frame is part of a FR_ROW frame, all frames must be resized as well.
;; Check for the minimal height of the FR_ROW frame.
;; At the top level we can also use change the command line height.

(defn- #_void frame_setheight [#_frame_C curfrp, #_int height]
    (ยง
        ;; If the height already is the desired value, nothing to do.
        (if (== (. curfrp fr_height) height)
            (ร RETURN)
        )

        (cond (nil? (. curfrp fr_parent))
        (ยง
            ((ร long rows_avail =) (- @Rows @p_ch))

            ;; topframe: can only change the command line
            (if (< rows_avail height)
                ((ร height =) (ยง (int)rows_avail))
            )
            (if (< 0 height)
                (frame_new_height curfrp, height, false, false))
        )
        (== (.. curfrp fr_parent fr_layout) FR_ROW)
        (ยง
            ;; Row of frames: also need to resize frames left and right of this one.
            ;; First check for the minimal height of these.
            ((ร int h =) (ยง frame_minheight(curfrp.fr_parent, null)))
            (if (< height h)
                ((ร height =) h)
            )
            (frame_setheight (. curfrp fr_parent), height)
        )
        :else
        (ยง
;           // %% red. 3x
            ((ร int room =) 0)                       ;; total number of lines available
            ((ร int room_reserved =) 0)
            ((ร int room_cmdline =) 0)               ;; lines available from cmdline

            ;; Column of frames: try to change only frames in this column.
            ;; Do this twice:
            ;; 1: compute room available, if it's not enough try resizing the containing frame.
            ;; 2: compute the room available and adjust the height to it.
            ;; Try not to reduce the height of a window with 'winfixheight' set.

            ((ร FOR) (ร (ยง int run = 1) (<= run 2) (ยง run++))
                ((ร room =) 0)                   ;; total number of lines available
                ((ร room_reserved =) 0)

                ((ร FOR) (ร (ยง frame_C frp = curfrp.fr_parent.fr_child) (!= frp null) (ยง frp = frp.fr_next))
                    (if (and (!= frp curfrp) (!= (. frp fr_win) null) @(.. frp fr_win w_options wo_wfh))
                        ((ร room_reserved +=) (. frp fr_height))
                    )
                    ((ร room +=) (. frp fr_height))
                    (if (!= frp curfrp)
                        ((ร room -=) (frame_minheight frp, null))
                    )
                )
                (cond (!= (. curfrp fr_width) (int @Columns))
                (ยง
                    ((ร room_cmdline =) 0)
                )
                :else
                (ยง
                    ((ร room_cmdline =) (ยง (int)(@Rows - @p_ch) - (@lastwin.w_winrow + @lastwin.w_height + @lastwin.w_status_height)))
                    (if (< room_cmdline 0)
                        ((ร room_cmdline =) 0)
                    )
                ))

                (if (<= height (+ room room_cmdline))
                    (ร BREAK)
                )
                (when (or (== run 2) (== (. curfrp fr_width) (int @Columns)))
                    (if (> height (+ room room_cmdline))
                        ((ร height =) (+ room room_cmdline))
                    )
                    (ร BREAK)
                )

                (ยง frame_setheight(curfrp.fr_parent, height + frame_minheight(curfrp.fr_parent, NOWIN) - (int)@p_wmh - 1))
            )

            ;; Compute the number of lines we will take from others frames (can be negative!).

            ((ร int take =) (ยง height - curfrp.fr_height))

            ;; If there is not enough room,
            ;; also reduce the height of a window with 'winfixheight' set.

            (if (ยง room + room_cmdline - room_reserved < height)
                ((ร room_reserved =) (ยง room + room_cmdline - height))
            )

            ;; If there is only a 'winfixheight' window and making the window smaller,
            ;; need to make the other window taller.

            (if (and (< take 0) (ยง room - curfrp.fr_height < room_reserved))
                ((ร room_reserved =) 0)
            )

            (when (and (< 0 take) (< 0 room_cmdline))
                ;; use lines from cmdline first
                (if (< take room_cmdline)
                    ((ร room_cmdline =) take)
                )
                ((ร take -=) room_cmdline)
                ((ร @topframe.fr_height +=) room_cmdline)
            )

            ;; set the current frame to the new height

            (frame_new_height curfrp, height, false, false)

            ;; First take lines from the frames after the current frame.
            ;; If that is not enough, takes lines from frames above the current frame.

            ((ร FOR) (ร (ยง int run = 0) (< run 2) (ยง run++))
                (ร frame_C frp)
                (if (zero? run)
                    ((ร frp =) (. curfrp fr_next))   ;; 1st run: start with next window
                    ((ร frp =) (. curfrp fr_prev))   ;; 2nd run: start with prev window
                )
                (while (ยง frp != null && take != 0)
                    ((ร int h =) (frame_minheight frp, null))
                    (cond (and (< 0 room_reserved) (!= (. frp fr_win) null) @(.. frp fr_win w_options wo_wfh))
                    (ยง
                        (cond (>= room_reserved (. frp fr_height))
                        (ยง
                            ((ร room_reserved -=) (. frp fr_height))
                        )
                        :else
                        (ยง
                            (if (< take (- (. frp fr_height) room_reserved))
                                ((ร room_reserved =) (ยง frp.fr_height - take))
                            )
                            ((ร take -=) (ยง frp.fr_height - room_reserved))
                            (frame_new_height frp, room_reserved, false, false)
                            ((ร room_reserved =) 0)
                        ))
                    )
                    :else
                    (ยง
                        (cond (ยง frp.fr_height - take < h)
                        (ยง
                            ((ร take -=) (ยง frp.fr_height - h))
                            (frame_new_height frp, h, false, false)
                        )
                        :else
                        (ยง
                            (frame_new_height frp, (- (. frp fr_height) take), false, false)
                            ((ร take =) 0)
                        ))
                    ))
                    (if (zero? run)
                        ((ร frp =) (. frp fr_next))
                        ((ร frp =) (. frp fr_prev))
                    )
                )
            )
        ))
    ))

;; Set current window width and take care of repositioning other windows to fit around it.

(defn- #_void win_setwidth [#_int width]
    (win_setwidth_win width, @curwin))

(defn- #_void win_setwidth_win [#_int width, #_window_C win]
    (ยง
        ;; Always keep current window at least one column wide, even when 'winminwidth' is zero.
        (when (== win @curwin)
            (if (< width @p_wmw)
                ((ร width =) (ยง (int)@p_wmw))
            )
            (if (zero? width)
                ((ร width =) 1)
            )
        )

        (frame_setwidth (. win w_frame), (+ width (. win w_vsep_width)))

        ;; recompute the window positions
        (win_comp_pos)

        (redraw_all_later NOT_VALID)
    ))

;; Set the width of a frame to "width"
;; and take care that all frames and windows inside it are resized.
;; Also resize frames above and below if the are in the same FR_ROW frame.
;;
;; Strategy is similar to frame_setheight().

(defn- #_void frame_setwidth [#_frame_C curfrp, #_int width]
    (ยง
        ;; If the width already is the desired value, nothing to do.
        (if (== (. curfrp fr_width) width)
            (ร RETURN)
        )

        (when (nil? (. curfrp fr_parent))
            ;; topframe: can't change width
            (ร RETURN)
        )

        (cond (== (.. curfrp fr_parent fr_layout) FR_COL)
        (ยง
            ;; Column of frames: also need to resize frames above and below of this one.
            ;; First check for the minimal width of these.
            ((ร int w =) (ยง frame_minwidth(curfrp.fr_parent, null)))
            (if (< width w)
                ((ร width =) w)
            )
            (frame_setwidth (. curfrp fr_parent), width)
        )
        :else
        (ยง
;           // %% red. 2x
            ((ร int room =) 0)                       ;; total number of lines available
            ((ร int room_reserved =) 0)

            ;; Row of frames: try to change only frames in this row.
            ;; Do this twice:
            ;; 1: compute room available, if it's not enough try resizing the containing frame.
            ;; 2: compute the room available and adjust the width to it.

            ((ร FOR) (ร (ยง int run = 1) (<= run 2) (ยง run++))
                ((ร room =) 0)
                ((ร room_reserved =) 0)

                ((ร FOR) (ร (ยง frame_C frp = curfrp.fr_parent.fr_child) (!= frp null) (ยง frp = frp.fr_next))
                    (if (and (!= frp curfrp) (!= (. frp fr_win) null) @(.. frp fr_win w_options wo_wfw))
                        ((ร room_reserved +=) (. frp fr_width))
                    )
                    ((ร room +=) (. frp fr_width))
                    (if (!= frp curfrp)
                        ((ร room -=) (frame_minwidth frp, null))
                    )
                )

                (if (<= width room)
                    (ร BREAK)
                )

                ((ร long rows_avail =) (- @Rows @p_ch))

                (when (or (== run 2) (<= rows_avail (. curfrp fr_height)))
                    (if (< room width)
                        ((ร width =) room)
                    )
                    (ร BREAK)
                )

                (ยง frame_setwidth(curfrp.fr_parent, width + frame_minwidth(curfrp.fr_parent, NOWIN) - (int)@p_wmw - 1))
            )

            ;; Compute the number of lines we will take from others frames (can be negative!).

            ((ร int take =) (ยง width - curfrp.fr_width))

            ;; If there is not enough room,
            ;; also reduce the width of a window with 'winfixwidth' set.

            (if (< (- room room_reserved) width)
                ((ร room_reserved =) (- room width))
            )

            ;; If there is only a 'winfixwidth' window and making the window smaller,
            ;; need to make the other window narrower.

            (if (and (< take 0) (ยง room - curfrp.fr_width < room_reserved))
                ((ร room_reserved =) 0)
            )

            ;; set the current frame to the new width

            (frame_new_width curfrp, width, false, false)

            ;; First take lines from the frames right of the current frame.
            ;; If that is not enough, takes lines from frames left of the current frame.

            ((ร FOR) (ร (ยง int run = 0) (< run 2) (ยง run++))
                (ร frame_C frp)
                (if (zero? run)
                    ((ร frp =) (. curfrp fr_next))   ;; 1st run: start with next window
                    ((ร frp =) (. curfrp fr_prev))   ;; 2nd run: start with prev window
                )
                (while (ยง frp != null && take != 0)
                    ((ร int w =) (frame_minwidth frp, null))
                    (cond (and (< 0 room_reserved) (!= (. frp fr_win) null) @(.. frp fr_win w_options wo_wfw))
                    (ยง
                        (cond (>= room_reserved (. frp fr_width))
                        (ยง
                            ((ร room_reserved -=) (. frp fr_width))
                        )
                        :else
                        (ยง
                            (if (< take (- (. frp fr_width) room_reserved))
                                ((ร room_reserved =) (ยง frp.fr_width - take))
                            )
                            ((ร take -=) (ยง frp.fr_width - room_reserved))
                            (frame_new_width frp, room_reserved, false, false)
                            ((ร room_reserved =) 0)
                        ))
                    )
                    :else
                    (ยง
                        (cond (ยง frp.fr_width - take < w)
                        (ยง
                            ((ร take -=) (ยง frp.fr_width - w))
                            (frame_new_width frp, w, false, false)
                        )
                        :else
                        (ยง
                            (frame_new_width frp, (- (. frp fr_width) take), false, false)
                            ((ร take =) 0)
                        ))
                    ))
                    (if (zero? run)
                        ((ร frp =) (. frp fr_next))
                        ((ร frp =) (. frp fr_prev))
                    )
                )
            )
        ))
    ))

;; Check 'winminheight' for a valid value.

(defn- #_void win_setminheight []
    (ยง
        ((ร boolean first =) true)

        ;; loop until there is a 'winminheight' that is possible
        (while (< 0 @p_wmh)
            ;; TODO: handle vertical splits
            ((ร int room =) (ยง (int)-@p_wh))
            ((ร FOR) (ร (ยง window_C wp = @firstwin) (!= wp null) (ยง wp = wp.w_next))
                ((ร room +=) (ยง wp.w_height - @p_wmh))
            )
            (if (<= 0 room)
                (ร BREAK)
            )
            (swap! p_wmh dec)
            (when first
                (emsg e_noroom)
                ((ร first =) false)
            )
        )
    ))

(final long FRACTION_MULT 16384)

;; Set wp.w_fraction for the current w_wrow and w_height.

(defn- #_void set_fraction [#_window_C wp]
    (ยง
        ((ร wp.w_fraction =) (ยง (int)(((long)wp.w_wrow * FRACTION_MULT + (long)wp.w_height / 2) / (long)wp.w_height)))
    ))

;; Set the height of a window.
;; This takes care of the things inside the window, not what happens to the
;; window position, the frame or to other windows.

(defn- #_void win_new_height [#_window_C wp, #_int height]
    (ยง
        ((ร int prev_height =) (. wp w_height))

        ;; Don't want a negative height.  Happens when splitting a tiny window.
        ;; Will equalize heights soon to fix it.
        (if (< height 0)
            ((ร height =) 0)
        )
        (if (== (. wp w_height) height)
            (ร RETURN)                             ;; nothing to do
        )

        (when (< 0 (. wp w_height))
            (when (== wp @curwin)
                ;; w_wrow needs to be valid.  When setting 'laststatus' this may
                ;; call win_new_height() recursively.
                (validate_cursor)
            )

            (if (!= (. wp w_height) prev_height)
                (ร RETURN)                         ;; Recursive call already changed the size,
            )
                                                ;; bail out here to avoid the following to mess things up.

            (if (!= (. wp w_wrow) (. wp w_prev_fraction_row))
                (set_fraction wp))
        )

        ((ร wp.w_height =) height)
        ((ร wp.w_skipcol =) 0)

        ;; Don't change w_topline when height is zero.  Don't set w_topline
        ;; when 'scrollbind' is set and this isn't the current window.
        (when (and (< 0 height) (or (not @(.. wp w_options wo_scb)) (== wp @curwin)))
            ;; Find a value for w_topline that shows the cursor at the same
            ;; relative position in the window as before (more or less).

            ((ร long lnum =) (.. wp w_cursor lnum))
            (if (< lnum 1)           ;; can happen when starting up
                ((ร lnum =) 1)
            )
            ((ร wp.w_wrow =) (ยง (int)(((long)wp.w_fraction * (long)height - 1 + FRACTION_MULT / 2) / FRACTION_MULT)))
            ((ร int line_size =) (ยง plines_win_col(wp, lnum, (long)wp.w_cursor.col) - 1))
            ((ร int sline =) (ยง wp.w_wrow - line_size))

            (when (<= 0 sline)
                ;; Make sure the whole cursor line is visible, if possible.
                ((ร int rows =) (plines_win wp, lnum, false))

                (when (> sline (- (. wp w_height) rows))
                    ((ร sline =) (ยง wp.w_height - rows))
                    ((ร wp.w_wrow -=) (- rows line_size))
                )
            )

            (cond (< sline 0)
            (ยง
                ;; Cursor line would go off top of screen if w_wrow was this high.
                ;; Make cursor line the first line in the window.  If not enough
                ;; room use w_skipcol;

                ((ร wp.w_wrow =) line_size)
                (when (and (<= (. wp w_height) (. wp w_wrow)) (< 0 (ยง wp.w_width - win_col_off(wp))))
                    ((ร wp.w_skipcol +=) (ยง wp.w_width - win_col_off(wp)))
                    (ยง --wp.w_wrow)
                    (while (ยง wp.w_height <= wp.w_wrow)
                        ((ร wp.w_skipcol +=) (ยง wp.w_width - win_col_off(wp) + win_col_off2(wp)))
                        (ยง --wp.w_wrow)
                    )
                )
                (set_topline wp, lnum)
            )
            (< 0 sline)
            (ยง
                (while (ยง 0 < sline && 1 < lnum)
                    (ยง --lnum)
                        ((ร line_size =) (plines_win wp, lnum, true))
                    ((ร sline -=) line_size)
                )

                (cond (< sline 0)
                (ยง
                    ;; Line we want at top would go off top of screen.  Use next line instead.

                    (ยง lnum++)
                    ((ร wp.w_wrow -=) (+ line_size sline))
                )
                (< 0 sline)
                (ยง
                    ;; First line of file reached, use that as topline.
                    ((ร lnum =) 1)
                    ((ร wp.w_wrow -=) sline)
                ))

                (set_topline wp, lnum)
            ))
        )

        (when (== wp @curwin)
            (if (non-zero? @p_so)
                (update_topline))
            (curs_columns false)    ;; validate w_wrow
        )
        (if (< 0 prev_height)
            ((ร wp.w_prev_fraction_row =) (. wp w_wrow))
        )

        (win_comp_scroll wp)
        (redraw_win_later wp, SOME_VALID)
        ((ร wp.w_redr_status =) true)
        (invalidate_botline_win wp)
    ))

;; Set the width of a window.

(defn- #_void win_new_width [#_window_C wp, #_int width]
    (ยง
        ((ร wp.w_width =) width)
        ((ร wp.w_lines_valid =) 0)
        (changed_line_abv_curs_win wp)
        (invalidate_botline_win wp)
        (when (== wp @curwin)
            (update_topline)
            (curs_columns true)     ;; validate w_wrow
        )
        (redraw_win_later wp, NOT_VALID)
        ((ร wp.w_redr_status =) true)
    ))

(defn- #_void win_comp_scroll [#_window_C wp]
    (ยง
        ((ร wp.w_options.@wo_scr =) (ยง (wp.w_height >>> 1)))
        (when (zero? @(.. wp w_options wo_scr))
            ((ร wp.w_options.@wo_scr =) 1)
        )
    ))

;; command_height: called whenever "p_ch" has been changed

(defn- #_void command_height []
    (ยง
        ((ร long old_p_ch =) @ch_used)

        ;; Use the value of "p_ch" that we remembered.  This is needed for when the
        ;; GUI starts up, we can't be sure in what order things happen.  And when
        ;; "p_ch" was changed in another tab page.
        (reset! ch_used @p_ch)

        ;; Find bottom frame with width of screen.
        ((ร frame_C frp =) (. @lastwin w_frame))
        (while (ยง frp.fr_width != (int)@Columns && frp.fr_parent != null)
            ((ร frp =) (. frp fr_parent))
        )

        ;; Avoid changing the height of a window with 'winfixheight' set.
        (while (ยง frp.fr_prev != null && frp.fr_layout == FR_LEAF && frp.fr_win.w_options.@wo_wfh)
            ((ร frp =) (. frp fr_prev))
        )

        (when (!= @starting NO_SCREEN)
            (reset! cmdline_row (ยง (int)(@Rows - @p_ch)))

            (when (< old_p_ch @p_ch)                ;; "p_ch" got bigger
                (while (< old_p_ch @p_ch)
                    (when (nil? frp)
                        (emsg e_noroom)
                        (reset! p_ch old_p_ch)
                        (reset! ch_used @p_ch)
                        (reset! cmdline_row (ยง (int)(@Rows - @p_ch)))
                        (ร BREAK)
                    )
                    ((ร int h =) (ยง frp.fr_height - frame_minheight(frp, null)))
                    (if (> h (- @p_ch old_p_ch))
                        ((ร h =) (ยง (int)(@p_ch - old_p_ch)))
                    )
                    ((ร old_p_ch +=) h)
                    (frame_add_height frp, (- h))
                    ((ร frp =) (. frp fr_prev))
                )

                ;; Recompute window positions.
                (win_comp_pos)

                ;; clear the lines added to cmdline
                (if @full_screen
                    (screen_fill @cmdline_row, (int @Rows), 0, (int @Columns), (byte \space), (byte \space), 0))
                (reset! msg_row @cmdline_row)
                (reset! redraw_cmdline true)
                (ร RETURN)
            )

            (if (< @msg_row @cmdline_row)
                (reset! msg_row @cmdline_row))
            (reset! redraw_cmdline true)
        )
        (frame_add_height frp, (ยง (int)(old_p_ch - @p_ch)))

        ;; Recompute window positions.
        (when (!= frp (. @lastwin w_frame))
            (win_comp_pos)
        )
    ))

;; Resize frame "frp" to be "n" lines higher (negative for less high).
;; Also resize the frames it is contained in.

(defn- #_void frame_add_height [#_frame_C frp, #_int n]
    (ยง
        (frame_new_height frp, (+ (. frp fr_height) n), false, false)
        (while true
            ((ร frp =) (. frp fr_parent))
            (if (nil? frp)
                (ร BREAK)
            )
            ((ร frp.fr_height +=) n)
        )
    ))

;; Add or remove a status line for the bottom window(s), according to the
;; value of 'laststatus'.

(defn- #_void last_status [#_boolean morewin]
    ;; morewin: pretend there are two or more windows
    (ยง
        ;; Don't make a difference between horizontal or vertical split.
        (last_status_rec @topframe, (or (== @p_ls 2) (and (== @p_ls 1) (or morewin (!= @lastwin @firstwin)))))
    ))

(defn- #_void last_status_rec [#_frame_C fr, #_boolean statusline]
    (ยง
        (cond (== (. fr fr_layout) FR_LEAF)
        (ยง
            ((ร window_C wp =) (. fr fr_win))
            (cond (and (!= (. wp w_status_height) 0) (not statusline))
            (ยง
                ;; remove status line
                (win_new_height wp, (+ (. wp w_height) 1))
                ((ร wp.w_status_height =) 0)
                (comp_col)
            )
            (and (zero? (. wp w_status_height)) statusline)
            (ยง
                ;; Find a frame to take a line from.
                ((ร frame_C fp =) fr)
                (while (ยง fp.fr_height <= frame_minheight(fp, null))
                    (when (== fp @topframe)
                        (emsg e_noroom)
                        (ร RETURN)
                    )
                    ;; In a column of frames: go to frame above.
                    ;; If already at the top or in a row of frames: go to parent.
                    (if (and (== (.. fp fr_parent fr_layout) FR_COL) (!= (. fp fr_prev) null))
                        ((ร fp =) (. fp fr_prev))
                        ((ร fp =) (. fp fr_parent))
                    )
                )
                ((ร wp.w_status_height =) 1)
                (cond (!= fp fr)
                (ยง
                    (frame_new_height fp, (- (. fp fr_height) 1), false, false)
                    (frame_fix_height wp)
                    (win_comp_pos)
                )
                :else
                (ยง
                    (win_new_height wp, (- (. wp w_height) 1))
                ))
                (comp_col)
                (redraw_all_later SOME_VALID)
            ))
        )
        (== (. fr fr_layout) FR_ROW)
        (ยง
            ;; vertically split windows, set status line for each one
            ((ร FOR) (ร (ยง frame_C fp = fr.fr_child) (!= fp null) (ยง fp = fp.fr_next))
                (last_status_rec fp, statusline)
            )
        )
        :else
        (ยง
            ;; horizontally split window, set status line for last one
            (ร frame_C fp)
            ((ร FOR) (ร (ยง fp = fr.fr_child) (ยง fp.fr_next != null) (ยง fp = fp.fr_next))
                ;
            )
            (last_status_rec fp, statusline)
        ))
    ))

;; Return the minimal number of rows that is needed on the screen to display
;; the current number of windows.

(defn- #_int min_rows []
    (ยง
        (if (nil? @firstwin)       ;; not initialized yet
            ((ร RETURN) MIN_LINES)
        )

        ((ร int total =) 0)

        ((ร int n =) (frame_minheight @topframe, null))
        (if (< total n)
            ((ร total =) n)
        )

        ((ร total +=) 1)         ;; count the room for the command line

        total
    ))

;; Delete all matches in the match list of window 'wp'.

(defn- #_void clear_matches [#_window_C wp]
    (ยง
        (while (ยง wp.w_match_head != null)
            ((ร matchitem_C mi =) (.. wp w_match_head next))
            ((ร wp.w_match_head.mi_match.regprog =) null)
            ((ร wp.w_match_head =) mi)
        )

        (redraw_later SOME_VALID)
    ))

;; Return true if "topfrp" and its children are at the right height.

(defn- #_boolean frame_check_height [#_frame_C topfrp, #_int height]
    (ยง
        (if (!= (. topfrp fr_height) height)
            ((ร RETURN) false)
        )

        (when (== (. topfrp fr_layout) FR_ROW)
            ((ร FOR) (ร (ยง frame_C frp = topfrp.fr_child) (!= frp null) (ยง frp = frp.fr_next))
                (if (!= (. frp fr_height) height)
                    ((ร RETURN) false)
                )
            )
        )

        true
    ))

;; Return true if "topfrp" and its children are at the right width.

(defn- #_boolean frame_check_width [#_frame_C topfrp, #_int width]
    (ยง
        (if (!= (. topfrp fr_width) width)
            ((ร RETURN) false)
        )

        (when (== (. topfrp fr_layout) FR_COL)
            ((ร FOR) (ร (ยง frame_C frp = topfrp.fr_child) (!= frp null) (ยง frp = frp.fr_next))
                (if (!= (. frp fr_width) width)
                    ((ร RETURN) false)
                )
            )
        )

        true
    ))

;; move.c: Functions for moving the cursor and scrolling text.
;;
;; There are two ways to move the cursor:
;; 1. Move the cursor directly, the text is scrolled to keep the cursor in the window.
;; 2. Scroll the text, the cursor is moved into the text visible in the window.
;; The 'scrolloff' option makes this a bit complicated.

(class! #_final lineoff_C
    [
        (field long     lnum)       ;; line number
        (field int      height)     ;; height of added line
    ])

(defn- #_void COPY_lineoff [#_lineoff_C lo1, #_lineoff_C lo0]
    (ยง
        ((ร lo1.lnum =) (. lo0 lnum))
        ((ร lo1.height =) (. lo0 height))
    ))

;; Compute wp.w_botline for the current wp.w_topline.
;; Can be called after wp.w_topline changed.

(defn- #_void comp_botline [#_window_C wp]
    (ยง
        (ร long lnum)
        (ร int done)

        ;; If w_cline_row is valid, start there.
        ;; Otherwise have to start at w_topline.

        (check_cursor_moved wp)
        (cond (non-zero? (& (. wp w_valid) VALID_CROW))
        (ยง
            ((ร lnum =) (.. wp w_cursor lnum))
            ((ร done =) (. wp w_cline_row))
        )
        :else
        (ยง
            ((ร lnum =) (. wp w_topline))
            ((ร done =) 0)
        ))

        ((ร FOR) (ร (ยง  ) (ยง lnum <= @curbuf.b_ml.ml_line_count) (ยง lnum++))
            ((ร int n =) (plines_win wp, lnum, true))
            (when (== lnum (.. wp w_cursor lnum))
                ((ร wp.w_cline_row =) done)
                ((ร wp.w_cline_height =) n)
                (redraw_for_cursorline wp)
                ((ร wp.w_valid |=) (ยง (VALID_CROW|VALID_CHEIGHT)))
            )
            (if (< (. wp w_height) (+ done n))
                (ร BREAK)
            )
            ((ร done +=) n)
        )

        ;; wp.w_botline is the line that is just below the window
        ((ร wp.w_botline =) lnum)
        ((ร wp.w_valid |=) (ยง VALID_BOTLINE|VALID_BOTLINE_AP))

        (set_empty_rows wp, done)
    ))

;; Redraw when w_cline_row changes and 'relativenumber' or 'cursorline' is set.

(defn- #_void redraw_for_cursorline [#_window_C wp]
    (ยง
        (when (and (or @(.. wp w_options wo_rnu) @(.. wp w_options wo_cul)) (zero? (& (. wp w_valid) VALID_CROW)))
            (redraw_win_later wp, SOME_VALID)
        )
    ))

;; Update curwin.w_topline and redraw if necessary.
;; Used to update the screen before printing a message.

(defn- #_void update_topline_redraw []
    (ยง
        (update_topline)
        (when (non-zero? @must_redraw)
            (update_screen 0)
        )
    ))

;; Update curwin.w_topline to move the cursor onto the screen.

(defn- #_void update_topline []
    (ยง
        ((ร boolean check_topline =) false)
        ((ร boolean check_botline =) false)
        ((ร long save_so =) @p_so)

        (if (not (screen_valid true))
            (ร RETURN)
        )

        ;; If the window height is zero just use the cursor line.
        (when (zero? (. @curwin w_height))
            ((ร @curwin.w_topline =) (.. @curwin w_cursor lnum))
            ((ร @curwin.w_botline =) (. @curwin w_topline))
            ((ร @curwin.w_valid |=) (ยง VALID_BOTLINE|VALID_BOTLINE_AP))
            ((ร @curwin.w_scbind_pos =) 1)
            (ร RETURN)
        )

        (check_cursor_moved @curwin)
        (if (non-zero? (& (. @curwin w_valid) VALID_TOPLINE))
            (ร RETURN)
        )

        ((ร long old_topline =) (. @curwin w_topline))

        ;; If the buffer is empty, always set topline to 1.

        (cond (bufempty)             ;; special case - file is empty
        (ยง
            (if (!= (. @curwin w_topline) 1)
                (redraw_later NOT_VALID))
            ((ร @curwin.w_topline =) 1)
            ((ร @curwin.w_botline =) 2)
            ((ร @curwin.w_valid |=) (ยง VALID_BOTLINE|VALID_BOTLINE_AP))
            ((ร @curwin.w_scbind_pos =) 1)
        )

        ;; If the cursor is above or near the top of the window, scroll the window
        ;; to show the line the cursor is in, with 'scrolloff' context.

        :else
        (ยง
            (when (< 1 (. @curwin w_topline))
                ;; If the cursor is above topline, scrolling is always needed.
                ;; If the cursor is far below topline and there is no folding,
                ;; scrolling down is never needed.
                (cond (< (.. @curwin w_cursor lnum) (. @curwin w_topline))
                (ยง
                    ((ร check_topline =) true)
                )
                (check_top_offset)
                (ยง
                    ((ร check_topline =) true)
                ))
            )

            (cond check_topline
            (ยง
                ((ร int halfheight =) (ยง @curwin.w_height / 2 - 1))
                (if (< halfheight 2)
                    ((ร halfheight =) 2)
                )

                ((ร int n =) (ยง (int)(@curwin.w_topline + @p_so - @curwin.w_cursor.lnum)))

                ;; If we weren't very close to begin with, we scroll to put the
                ;; cursor in the middle of the window.  Otherwise put the cursor
                ;; near the top of the window.
                (cond (<= halfheight n)
                (ยง
                    (scroll_cursor_halfway false)
                )
                :else
                (ยง
                    (scroll_cursor_top (scrolljump_value), false)
                    ((ร check_botline =) true)
                ))
            )
            :else
            (ยง
                ((ร check_botline =) true)
            ))
        ))

        ;; If the cursor is below the bottom of the window, scroll the window
        ;; to put the cursor on the window.
        ;; When w_botline is invalid, recompute it first, to avoid a redraw later.
        ;; If w_botline was approximated, we might need a redraw later in a few
        ;; cases, but we don't want to spend (a lot of) time recomputing w_botline
        ;; for every small change.

        (when check_botline
            (if (zero? (& (. @curwin w_valid) VALID_BOTLINE_AP))
                (validate_botline))

            (when (<= (. @curwin w_botline) (.. @curbuf b_ml ml_line_count))
                (when (< (.. @curwin w_cursor lnum) (. @curwin w_botline))
                    (cond (ยง @curwin.w_botline - @p_so <= @curwin.w_cursor.lnum)
                    (ยง
                        ;; Cursor is (a few lines) above botline,
                        ;; check if there are 'scrolloff' window lines below the cursor.
                        ;; If not, need to scroll.
                        ((ร int n =) (. @curwin w_empty_rows))
                        ((ร lineoff_C loff =) (ยง ยง_lineoff_C()))
                        ((ร loff.lnum =) (.. @curwin w_cursor lnum))
                        ((ร loff.height =) 0)
                        (while (ยง loff.lnum < @curwin.w_botline)
                            ((ร n +=) (. loff height))
                            (if (<= @p_so n)
                                (ร BREAK)
                            )
                            (botline_forw loff)
                        )
                        (when (<= @p_so n)
                            ;; sufficient context, no need to scroll
                            ((ร check_botline =) false)
                        )
                    )
                    :else
                    (ยง
                        ;; sufficient context, no need to scroll
                        ((ร check_botline =) false)
                    ))
                )
                (when check_botline
                    ((ร long line_count =) (ยง @curwin.w_cursor.lnum - @curwin.w_botline + 1 + @p_so))
                    (if (<= line_count (+ (. @curwin w_height) 1))
                        (scroll_cursor_bot (scrolljump_value), false)
                        (scroll_cursor_halfway false))
                )
            )
        )
        ((ร @curwin.w_valid |=) VALID_TOPLINE)

        ;; Need to redraw when topline changed.

        (when (!= (. @curwin w_topline) old_topline)
            (cond (!= (. @curwin w_skipcol) 0)
            (ยง
                ((ร @curwin.w_skipcol =) 0)
                (redraw_later NOT_VALID)
            )
            :else
            (ยง
                (redraw_later VALID)
            ))
            ;; May need to set w_skipcol when cursor in w_topline.
            (if (== (.. @curwin w_cursor lnum) (. @curwin w_topline))
                (validate_cursor))
        )

        (reset! p_so save_so)
    ))

;; Return the scrolljump value to use for the current window.
;; When 'scrolljump' is positive use it as-is.
;; When 'scrolljump' is negative use it as a percentage of the window height.

(defn- #_int scrolljump_value []
    (ยง
        (if (<= 0 @p_sj)
            ((ร RETURN) (ยง (int)@p_sj))
        )

        (ยง (@curwin.w_height * (int)-@p_sj) / 100)
    ))

;; Return true when there are not 'scrolloff' lines above the cursor for the current window.

(defn- #_boolean check_top_offset []
    (ยง
        (when (< (.. @curwin w_cursor lnum) (+ (. @curwin w_topline) @p_so))
            ((ร lineoff_C loff =) (ยง ยง_lineoff_C()))
            ((ร loff.lnum =) (.. @curwin w_cursor lnum))

            ((ร int n =) 0)
            ;; Count the visible screen lines above the cursor line.
            ((ร FOR) (ร (ยง  ) (< n @p_so) (ยง n += loff.height))
                (topline_back loff)
                ;; Stop when included a line above the window.
                (if (< (. loff lnum) (. @curwin w_topline))
                    (ร BREAK)
                )
            )

            (if (< n @p_so)
                ((ร RETURN) true)
            )
        )

        false
    ))

(defn- #_void update_curswant []
    (ยง
        (when (. @curwin w_set_curswant)
            (validate_virtcol)
            ((ร @curwin.w_curswant =) (. @curwin w_virtcol))
            ((ร @curwin.w_set_curswant =) false)
        )
    ))

;; Check if the cursor has moved.  Set the w_valid flag accordingly.

(defn- #_void check_cursor_moved [#_window_C wp]
    (ยง
        (cond (!= (.. wp w_cursor lnum) (.. wp w_valid_cursor lnum))
        (ยง
            ((ร wp.w_valid &=) (ยง ~(VALID_WROW|VALID_WCOL|VALID_VIRTCOL|VALID_CHEIGHT|VALID_CROW|VALID_TOPLINE)))
            (COPY_pos (. wp w_valid_cursor), (. wp w_cursor))
            ((ร wp.w_valid_leftcol =) (. wp w_leftcol))
        )
        (or (!= (.. wp w_cursor col) (.. wp w_valid_cursor col)) (!= (. wp w_leftcol) (. wp w_valid_leftcol)) (!= (.. wp w_cursor coladd) (.. wp w_valid_cursor coladd)))
        (ยง
            ((ร wp.w_valid &=) (ยง ~(VALID_WROW|VALID_WCOL|VALID_VIRTCOL)))
            ((ร wp.w_valid_cursor.col =) (.. wp w_cursor col))
            ((ร wp.w_valid_leftcol =) (. wp w_leftcol))
            ((ร wp.w_valid_cursor.coladd =) (.. wp w_cursor coladd))
        ))
    ))

;; Call this function when some window settings have changed, which require
;; the cursor position, botline and topline to be recomputed and the window
;; to be redrawn.  E.g, when changing the 'wrap' option or folding.

(defn- #_void changed_window_setting []
    (changed_window_setting_win @curwin))

(defn- #_void changed_window_setting_win [#_window_C wp]
    (ยง
        ((ร wp.w_lines_valid =) 0)
        (changed_line_abv_curs_win wp)
        ((ร wp.w_valid &=) (ยง ~(VALID_BOTLINE|VALID_BOTLINE_AP|VALID_TOPLINE)))
        (redraw_win_later wp, NOT_VALID)
    ))

;; Set wp.w_topline to a certain number.

(defn- #_void set_topline [#_window_C wp, #_long lnum]
    (ยง
        ;; Approximate the value of w_botline.
        ((ร wp.w_botline +=) (ยง lnum - wp.w_topline))
        ((ร wp.w_topline =) lnum)
        ((ร wp.w_topline_was_set =) true)
        ((ร wp.w_valid &=) (ยง ~(VALID_WROW|VALID_CROW|VALID_BOTLINE|VALID_TOPLINE)))
        ;; Don't set VALID_TOPLINE here, 'scrolloff' needs to be checked.
        (redraw_later VALID)
    ))

;; Call this function when the length of the cursor line (in screen
;; characters) has changed, and the change is before the cursor.
;; Need to take care of w_botline separately!

(defn- #_void changed_cline_bef_curs []
    (ยง
        ((ร @curwin.w_valid &=) (ยง ~(VALID_WROW|VALID_WCOL|VALID_VIRTCOL|VALID_CHEIGHT|VALID_TOPLINE)))
    ))

(defn- #_void changed_cline_bef_curs_win [#_window_C wp]
    (ยง
        ((ร wp.w_valid &=) (ยง ~(VALID_WROW|VALID_WCOL|VALID_VIRTCOL|VALID_CHEIGHT|VALID_TOPLINE)))
    ))

;; Call this function when the length of a line (in screen characters) above
;; the cursor have changed.
;; Need to take care of w_botline separately!

(defn- #_void changed_line_abv_curs []
    (ยง
        ((ร @curwin.w_valid &=) (ยง ~(VALID_WROW|VALID_WCOL|VALID_VIRTCOL|VALID_CROW|VALID_CHEIGHT|VALID_TOPLINE)))
    ))

(defn- #_void changed_line_abv_curs_win [#_window_C wp]
    (ยง
        ((ร wp.w_valid &=) (ยง ~(VALID_WROW|VALID_WCOL|VALID_VIRTCOL|VALID_CROW|VALID_CHEIGHT|VALID_TOPLINE)))
    ))

;; Make sure the value of curwin.w_botline is valid.

(defn- #_void validate_botline []
    (ยง
        (when (zero? (& (. @curwin w_valid) VALID_BOTLINE))
            (comp_botline @curwin)
        )
    ))

;; Mark curwin.w_botline as invalid (because of some change in the buffer).

(defn- #_void invalidate_botline []
    (ยง
        ((ร @curwin.w_valid &=) (ยง ~(VALID_BOTLINE|VALID_BOTLINE_AP)))
    ))

(defn- #_void invalidate_botline_win [#_window_C wp]
    (ยง
        ((ร wp.w_valid &=) (ยง ~(VALID_BOTLINE|VALID_BOTLINE_AP)))
    ))

(defn- #_void approximate_botline_win [#_window_C wp]
    (ยง
        ((ร wp.w_valid &=) (ยง ~VALID_BOTLINE))
    ))

;; Return true if curwin.w_wrow and curwin.w_wcol are valid.

(defn- #_boolean cursor_valid []
    (ยง
        (check_cursor_moved @curwin)
        (ยง (@curwin.w_valid & (VALID_WROW|VALID_WCOL)) == (VALID_WROW|VALID_WCOL))
    ))

;; Validate cursor position.  Makes sure w_wrow and w_wcol are valid.
;; w_topline must be valid, you may need to call update_topline() first!

(defn- #_void validate_cursor []
    (ยง
        (check_cursor_moved @curwin)
        (when (ยง (@curwin.w_valid & (VALID_WCOL|VALID_WROW)) != (VALID_WCOL|VALID_WROW))
            (curs_columns true)
        )
    ))

;; Compute wp.w_cline_row and wp.w_cline_height, based on the current value of wp.w_topline.

(defn- #_void curs_rows [#_window_C wp]
    (ยง
        ;; check if wp.w_lines[].wl_size is invalid
        ((ร boolean all_invalid =) (ยง (!redrawing() || wp.w_lines_valid == 0 || wp.w_topline < wp.w_lines[0].wl_lnum)))
        ((ร int i =) 0)
        ((ร wp.w_cline_row =) 0)
        ((ร FOR) (ร (ยง long lnum = wp.w_topline) (ยง lnum < wp.w_cursor.lnum) (ยง i++))
            ((ร boolean valid =) false)
            (when (and (not all_invalid) (< i (. wp w_lines_valid)))
                (if (or (< (ยง wp.w_lines[i].wl_lnum) lnum) (not (ยง wp.w_lines[i].wl_valid)))
                    (ร CONTINUE)               ;; skip changed or deleted lines
                )
                (cond (== (ยง wp.w_lines[i].wl_lnum) lnum)
                (ยง
                    ((ร valid =) true)
                )
                (< lnum (ยง wp.w_lines[i].wl_lnum))
                (ยง
                    (ยง --i)                    ;; hold at inserted lines
                ))
            )
            (cond valid
            (ยง
                (ยง lnum++)
                ((ร wp.w_cline_row +=) (ยง wp.w_lines[i].wl_size))
            )
            :else
            (ยง
                ((ร wp.w_cline_row +=) (ยง plines_win(wp, lnum++, true)))
            ))
        )

        (check_cursor_moved wp)
        (when (zero? (& (. wp w_valid) VALID_CHEIGHT))
            (cond (or all_invalid (== i (. wp w_lines_valid)) (and (< i (. wp w_lines_valid)) (or (not (ยง wp.w_lines[i].wl_valid)) (!= (ยง wp.w_lines[i].wl_lnum) (.. wp w_cursor lnum)))))
            (ยง
                ((ร wp.w_cline_height =) (ยง plines_win(wp, wp.w_cursor.lnum, true)))
            )
            (< (. wp w_lines_valid) i)
            (ยง
                ;; a line that is too long to fit on the last screen line
                ((ร wp.w_cline_height =) 0)
            )
            :else
            (ยง
                ((ร wp.w_cline_height =) (ยง wp.w_lines[i].wl_size))
            ))
        )

        (redraw_for_cursorline @curwin)
        ((ร wp.w_valid |=) (ยง VALID_CROW|VALID_CHEIGHT))
    ))

;; Validate curwin.w_virtcol only.

(defn- #_void validate_virtcol []
    (validate_virtcol_win @curwin))

;; Validate wp.w_virtcol only.

(defn- #_void validate_virtcol_win [#_window_C wp]
    (ยง
        (check_cursor_moved wp)
        (when (zero? (& (. wp w_valid) VALID_VIRTCOL))
; %%        ((ร int[] vcol =) (ยง { wp.w_virtcol }))
            (getvvcol wp, (. wp w_cursor), null, vcol, null)
            ((ร wp.w_virtcol =) (ยง vcol[0]))
            ((ร wp.w_valid |=) VALID_VIRTCOL)
            (if @(.. wp w_options wo_cuc)
                (redraw_win_later wp, SOME_VALID))
        )
    ))

;; Validate curwin.w_cline_height only.

(defn- #_void validate_cheight []
    (ยง
        (check_cursor_moved @curwin)
        (when (zero? (& (. @curwin w_valid) VALID_CHEIGHT))
            ((ร @curwin.w_cline_height =) (ยง plines(@curwin.w_cursor.lnum)))
            ((ร @curwin.w_valid |=) VALID_CHEIGHT)
        )
    ))

;; Validate w_wcol and w_virtcol only.

(defn- #_void validate_cursor_col []
    (ยง
        (validate_virtcol)
        (when (zero? (& (. @curwin w_valid) VALID_WCOL))
            ((ร int col =) (. @curwin w_virtcol))
            ((ร int off =) (curwin_col_off))
            ((ร col +=) off)
            ((ร int width =) (ยง @curwin.w_width - off + curwin_col_off2()))

            ;; long line wrapping, adjust curwin.w_wrow
            (when (and @(.. @curwin w_options wo_wrap) (<= (. @curwin w_width) col) (< 0 width))
                ;; use same formula as what is used in curs_columns()
                ((ร col -=) (ยง ((col - @curwin.w_width) / width + 1) * width))
            )
            (if (< (. @curwin w_leftcol) col)
                ((ร col -=) (. @curwin w_leftcol))
                ((ร col =) 0)
            )
            ((ร @curwin.w_wcol =) col)

            ((ร @curwin.w_valid |=) VALID_WCOL)
        )
    ))

;; Compute offset of a window, occupied by absolute or relative line number,
;; fold column and sign column (these don't move when scrolling horizontally).

(defn- #_int win_col_off [#_window_C wp]
    (ยง
        (+ (if (or @(.. wp w_options wo_nu) @(.. wp w_options wo_rnu)) (+ (number_width wp) 1) 0) (if (or (zero? @cmdwin_type) (!= wp @curwin)) 0 1))
    ))

(defn- #_int curwin_col_off []
    (win_col_off @curwin))

;; Return the difference in column offset for the second screen line of a wrapped line.
;; It's 8 if 'number' or 'relativenumber' is on and 'n' is in 'cpoptions'.

(defn- #_int win_col_off2 [#_window_C wp]
    (ยง
        (if (and (or @(.. wp w_options wo_nu) @(.. wp w_options wo_rnu)) (non-nil? (vim_strbyte @p_cpo, CPO_NUMCOL)))
            ((ร RETURN) (ยง number_width(wp) + 1))
        )

        0
    ))

(defn- #_int curwin_col_off2 []
    (win_col_off2 @curwin))

;; compute curwin.w_wcol and curwin.w_virtcol.
;; Also updates curwin.w_wrow and curwin.w_cline_row.
;; Also updates curwin.w_leftcol.

(defn- #_void curs_columns [#_boolean may_scroll]
    ;; may_scroll: when true, may scroll horizontally
    (ยง
        ;; First make sure that w_topline is valid (after moving the cursor).

        (update_topline)

        ;; Next make sure that w_cline_row is valid.

        (if (zero? (& (. @curwin w_valid) VALID_CROW))
            (curs_rows @curwin))

        ;; Compute the number of virtual columns.

        ((ร int[] startcol =) (ยง new int[1]))
; %%    ((ร int[] vcol =) (ยง { @curwin.w_virtcol }))
        ((ร int[] endcol =) (ยง new int[1]))
        (getvvcol @curwin, (. @curwin w_cursor), startcol, vcol, endcol)
        ((ร @curwin.w_virtcol =) (ยง vcol[0]))

        ;; offset for first screen line
        ((ร int extra =) (curwin_col_off))
        ((ร @curwin.w_wcol =) (ยง @curwin.w_virtcol + extra))
        ((ร endcol[0] +=) extra)

        ;; Now compute w_wrow, counting screen lines from w_cline_row.

        ((ร @curwin.w_wrow =) (. @curwin w_cline_row))

        ((ร int width =) 0)

        ((ร int textwidth =) (ยง @curwin.w_width - extra))
        (cond (<= textwidth 0)
        (ยง
            ;; No room for text, put cursor in last char of window.
            ((ร @curwin.w_wcol =) (ยง @curwin.w_width - 1))
            ((ร @curwin.w_wrow =) (ยง @curwin.w_height - 1))
        )
        (and @(.. @curwin w_options wo_wrap) (!= (. @curwin w_width) 0))
        (ยง
            ((ร width =) (ยง textwidth + curwin_col_off2()))

            ;; long line wrapping, adjust curwin.w_wrow
            (when (<= (. @curwin w_width) (. @curwin w_wcol))
                ;; this same formula is used in validate_cursor_col()
                ((ร int n =) (ยง (@curwin.w_wcol - @curwin.w_width) / width + 1))
                ((ร @curwin.w_wcol -=) (* n width))
                ((ร @curwin.w_wrow +=) n)

                ;; When cursor wraps to first char of next line in Insert mode,
                ;; the 'showbreak' string isn't shown, backup to first column.
                (if (and (non-eos? @p_sbr) (== (.at (ml_get_cursor) 0) NUL) (== (. @curwin w_wcol) (mb_string2cells @p_sbr, -1)))
                    ((ร @curwin.w_wcol =) 0)
                )
            )
        )
        ;; No line wrapping: compute curwin.w_leftcol if scrolling is on and line is not folded.
        ;; If scrolling is off, curwin.w_leftcol is assumed to be 0.
        may_scroll
        (ยง
            ;; If Cursor is left of the screen, scroll rightwards.
            ;; If Cursor is right of the screen, scroll leftwards.
            ;; If we get closer to the edge than 'sidescrolloff', scroll a little extra.

            ((ร int off_left =) (ยง startcol[0] - @curwin.w_leftcol - (int)@p_siso))
            ((ร int off_right =) (ยง endcol[0] - (@curwin.w_leftcol + @curwin.w_width - (int)@p_siso) + 1))
            (when (or (< off_left 0) (< 0 off_right))
                (ร int diff)
                (if (< off_left 0)
                    ((ร diff =) (ยง -off_left))
                    ((ร diff =) off_right)
                )

                ;; When far off or not enough room on either side, put cursor in middle of window.
                (ร int new_leftcol)
                (cond (or (zero? @p_ss) (<= (/ textwidth 2) diff) (<= off_left off_right))
                (ยง
                    ((ร new_leftcol =) (ยง @curwin.w_wcol - extra - textwidth / 2))
                )
                :else
                (ยง
                    (if (< diff @p_ss)
                        ((ร diff =) (ยง (int)@p_ss))
                    )
                    (if (< off_left 0)
                        ((ร new_leftcol =) (ยง @curwin.w_leftcol - diff))
                        ((ร new_leftcol =) (ยง @curwin.w_leftcol + diff))
                    )
                ))
                (if (< new_leftcol 0)
                    ((ร new_leftcol =) 0)
                )
                (when (!= new_leftcol (. @curwin w_leftcol))
                    ((ร @curwin.w_leftcol =) new_leftcol)
                    ;; screen has to be redrawn with new curwin.w_leftcol
                    (redraw_later NOT_VALID)
                )
            )
            ((ร @curwin.w_wcol -=) (. @curwin w_leftcol))
        )
        (< (. @curwin w_leftcol) (. @curwin w_wcol))
        (ยง
            ((ร @curwin.w_wcol -=) (. @curwin w_leftcol))
        )
        :else
        (ยง
            ((ร @curwin.w_wcol =) 0)
        ))

        ((ร int prev_skipcol =) (. @curwin w_skipcol))

        ((ร int p_lines =) 0)
        (cond (ยง (@curwin.w_height <= @curwin.w_wrow || ((0 < prev_skipcol || @curwin.w_height <= @curwin.w_wrow + @p_so) && @curwin.w_height <= (p_lines = plines_win(@curwin, @curwin.w_cursor.lnum, false)) - 1)) && @curwin.w_height != 0 && @curwin.w_cursor.lnum == @curwin.w_topline && 0 < width && @curwin.w_width != 0)
        (ยง
            ;; Cursor past end of screen.  Happens with a single line that does
            ;; not fit on screen.  Find a skipcol to show the text around the
            ;; cursor.  Avoid scrolling all the time. compute value of "extra":
            ;; 1: less than "p_so" lines above
            ;; 2: less than "p_so" lines below
            ;; 3: both of them
            ((ร extra =) 0)
            (if (< (. @curwin w_virtcol) (ยง @curwin.w_skipcol + @p_so * width))
                ((ร extra =) 1)
            )
            ;; Compute last display line of the buffer line that we want at the bottom of the window.
            (if (zero? p_lines)
                ((ร p_lines =) (ยง plines_win(@curwin, @curwin.w_cursor.lnum, false)))
            )
            (ยง --p_lines)
            (ร int n)
            (if (ยง @curwin.w_wrow + @p_so < p_lines)
                ((ร n =) (ยง @curwin.w_wrow + (int)@p_so))
                ((ร n =) p_lines)
            )
            (if (ยง @curwin.w_height + @curwin.w_skipcol / width <= n)
                ((ร extra +=) 2)
            )

            (cond (or (== extra 3) (< p_lines (* @p_so 2)))
            (ยง
                ;; not enough room for 'scrolloff', put cursor in the middle
                ((ร n =) (ยง @curwin.w_virtcol / width))
                (if (ยง @curwin.w_height / 2 < n)
                    ((ร n -=) (ยง @curwin.w_height / 2))
                    ((ร n =) 0)
                )
                ;; don't skip more than necessary
                (if (> n (ยง p_lines - @curwin.w_height + 1))
                    ((ร n =) (ยง p_lines - @curwin.w_height + 1))
                )
                ((ร @curwin.w_skipcol =) (* n width))
            )
            (== extra 1)
            (ยง
                ;; less then 'scrolloff' lines above, decrease skipcol
                ((ร extra =) (ยง (@curwin.w_skipcol + (int)@p_so * width - @curwin.w_virtcol + width - 1) / width))
                (when (< 0 extra)
                    (if (< (. @curwin w_skipcol) (* extra width))
                        ((ร extra =) (ยง @curwin.w_skipcol / width))
                    )
                    ((ร @curwin.w_skipcol -=) (* extra width))
                )
            )
            (== extra 2)
            (ยง
                ;; less then 'scrolloff' lines below, increase skipcol
                ((ร endcol[0] =) (ยง (n - @curwin.w_height + 1) * width))
                (while (ยง @curwin.w_virtcol < endcol[0])
                    ((ร endcol[0] -=) width)
                )
                (if (< (. @curwin w_skipcol) (ยง endcol[0]))
                    ((ร @curwin.w_skipcol =) (ยง endcol[0]))
                )
            ))

            ((ร @curwin.w_wrow -=) (ยง @curwin.w_skipcol / width))
            (when (<= (. @curwin w_height) (. @curwin w_wrow))
                ;; small window, make sure cursor is in it
                ((ร extra =) (ยง @curwin.w_wrow - @curwin.w_height + 1))
                ((ร @curwin.w_skipcol +=) (* extra width))
                ((ร @curwin.w_wrow -=) extra)
            )

            ((ร extra =) (ยง (prev_skipcol - @curwin.w_skipcol) / width))
            (cond (< 0 extra)
            (ยง
                (win_ins_lines @curwin, 0, extra, false, false)
            )
            (< extra 0)
            (ยง
                (win_del_lines @curwin, 0, (- extra), false, false)
            ))
        )
        :else
        (ยง
            ((ร @curwin.w_skipcol =) 0)
        ))
        (if (!= prev_skipcol (. @curwin w_skipcol))
            (redraw_later NOT_VALID))

        ;; Redraw when w_virtcol changes and 'cursorcolumn' is set.
        (if (and @(.. @curwin w_options wo_cuc) (zero? (& (. @curwin w_valid) VALID_VIRTCOL)))
            (redraw_later SOME_VALID))

        ((ร @curwin.w_valid |=) (ยง VALID_WCOL|VALID_WROW|VALID_VIRTCOL))
    ))

;; Scroll the current window down by "line_count" logical lines.  "CTRL-Y"

(defn- #_void scrolldown [#_long line_count]
    (ยง
        ((ร long done =) 0)              ;; total # of physical lines done
        ((ร boolean moved =) false)

        (validate_cursor)          ;; w_wrow needs to be valid
        (while (ยง 0 < line_count--)
            (if (== (. @curwin w_topline) 1)
                (ร BREAK)
            )
            (ยง --@curwin.w_topline)
            ((ร done +=) (ยง plines(@curwin.w_topline)))

            (ยง --@curwin.w_botline)         ;; approximate w_botline
            (invalidate_botline)
        )
        ((ร @curwin.w_wrow +=) done)          ;; keep w_wrow updated
        ((ร @curwin.w_cline_row +=) done)     ;; keep w_cline_row updated

        ;; Compute the row number of the last row of the cursor line
        ;; and move the cursor onto the displayed part of the window.

        ((ร int wrow =) (. @curwin w_wrow))
        (when (and @(.. @curwin w_options wo_wrap) (!= (. @curwin w_width) 0))
            (validate_virtcol)
            (validate_cheight)
            ((ร wrow +=) (ยง @curwin.w_cline_height - 1 - @curwin.w_virtcol / @curwin.w_width))
        )
        (while (ยง @curwin.w_height <= wrow && 1 < @curwin.w_cursor.lnum)
            ((ร wrow -=) (ยง plines(@curwin.w_cursor.lnum--)))
            ((ร @curwin.w_valid &=) (ยง ~(VALID_WROW|VALID_WCOL|VALID_CHEIGHT|VALID_CROW|VALID_VIRTCOL)))
            ((ร moved =) true)
        )
        (when moved
            (coladvance (. @curwin w_curswant))
        )
    ))

;; Scroll the current window up by "line_count" logical lines.  "CTRL-E"

(defn- #_void scrollup [#_long line_count]
    (ยง
        ((ร @curwin.w_topline +=) line_count)
        ((ร @curwin.w_botline +=) line_count)     ;; approximate w_botline

        (if (> (. @curwin w_topline) (.. @curbuf b_ml ml_line_count))
            ((ร @curwin.w_topline =) (.. @curbuf b_ml ml_line_count))
        )
        (if (> (. @curwin w_botline) (+ (.. @curbuf b_ml ml_line_count) 1))
            ((ร @curwin.w_botline =) (ยง @curbuf.b_ml.ml_line_count + 1))
        )

        ((ร @curwin.w_valid &=) (ยง ~(VALID_WROW|VALID_CROW|VALID_BOTLINE)))
        (when (< (.. @curwin w_cursor lnum) (. @curwin w_topline))
            ((ร @curwin.w_cursor.lnum =) (. @curwin w_topline))
            ((ร @curwin.w_valid &=) (ยง ~(VALID_WROW|VALID_WCOL|VALID_CHEIGHT|VALID_CROW|VALID_VIRTCOL)))
            (coladvance (. @curwin w_curswant))
        )
    ))

;; Add one line above "lp.lnum".  This can be a filler line, a closed fold or
;; a (wrapped) text line.  Uses and sets "lp.fill".
;; Returns the height of the added line in "lp.height".
;; Lines above the first one are incredibly high: MAXCOL.

(defn- #_void topline_back [#_lineoff_C lp]
    (ยง
        (ยง --lp.lnum)
        (cond (< (. lp lnum) 1)
        (ยง
            ((ร lp.height =) MAXCOL)
        )
        :else
        (ยง
            ((ร lp.height =) (ยง plines(lp.lnum)))
        ))
    ))

;; Add one line below "lp.lnum".
;; This can be a filler line, a closed fold or a (wrapped) text line.
;; Uses and sets "lp.fill".
;; Returns the height of the added line in "lp.height".
;; Lines below the last one are incredibly high.

(defn- #_void botline_forw [#_lineoff_C lp]
    (ยง
        (ยง lp.lnum++)
        (if (< (.. @curbuf b_ml ml_line_count) (. lp lnum))
            ((ร lp.height =) MAXCOL)
            ((ร lp.height =) (ยง plines(lp.lnum)))
        )
    ))

;; Recompute topline to put the cursor at the top of the window.
;; Scroll at least "min_scroll" lines.
;; If "always" is true, always set topline (for "zt").

(defn- #_void scroll_cursor_top [#_int min_scroll, #_boolean always]
    (ยง
        ((ร int scrolled =) 0)
        ((ร int extra =) 0)
        ((ร long old_topline =) (. @curwin w_topline))

        ((ร int off =) (ยง (int)@p_so))

        ;; Decrease topline until:
        ;; - it has become 1
        ;; - (part of) the cursor line is moved off the screen or
        ;; - moved at least 'scrolljump' lines and
        ;; - at least 'scrolloff' lines above and below the cursor

        (validate_cheight)
        ((ร int used =) (. @curwin w_cline_height))
        (if (< (.. @curwin w_cursor lnum) (. @curwin w_topline))
            ((ร scrolled =) used)
        )

        ((ร long top =) (ยง @curwin.w_cursor.lnum - 1))    ;; just above displayed lines
        ((ร long bot =) (ยง @curwin.w_cursor.lnum + 1))    ;; just below displayed lines
        ((ร long new_topline =) (+ top 1))

        ;; Check if the lines from "top" to "bot" fit in the window.  If they do,
        ;; set new_topline and advance "top" and "bot" to include more lines.

        (while (< 0 top)
            ((ร int i =) (plines top))
            ((ร used +=) i)
            (when (and (<= (+ extra i) off) (< bot (.. @curbuf b_ml ml_line_count)))
                ((ร used +=) (plines bot))
            )
            (if (< (. @curwin w_height) used)
                (ร BREAK)
            )
            (if (< top (. @curwin w_topline))
                ((ร scrolled +=) i)
            )

            ;; If scrolling is needed, scroll at least 'sj' lines.

            (if (and (or (<= (. @curwin w_topline) new_topline) (< min_scroll scrolled)) (<= off extra))
                (ร BREAK)
            )

            ((ร extra +=) i)
            ((ร new_topline =) top)
            (ยง --top)
            (ยง bot++)
        )

        ;; If we don't have enough space, put cursor in the middle.
        ;; This makes sure we get the same position when using "k" and "j" in a small window.

        (cond (< (. @curwin w_height) used)
        (ยง
            (scroll_cursor_halfway false)
        )
        :else
        (ยง
            ;; If "always" is false, only adjust topline to a lower value, higher
            ;; value may happen with wrapping lines

            (if (or (< new_topline (. @curwin w_topline)) always)
                ((ร @curwin.w_topline =) new_topline)
            )
            (if (> (. @curwin w_topline) (.. @curwin w_cursor lnum))
                ((ร @curwin.w_topline =) (.. @curwin w_cursor lnum))
            )
            (if (!= (. @curwin w_topline) old_topline)
                ((ร @curwin.w_valid &=) (ยง ~(VALID_WROW|VALID_CROW|VALID_BOTLINE|VALID_BOTLINE_AP)))
            )
            ((ร @curwin.w_valid |=) VALID_TOPLINE)
        ))
    ))

;; Set w_empty_rows and w_filler_rows for window "wp", having used up "used"
;; screen lines for text lines.

(defn- #_void set_empty_rows [#_window_C wp, #_int used]
    (ยง
        (if (zero? used)
            ((ร wp.w_empty_rows =) 0)    ;; single line that doesn't fit
            ((ร wp.w_empty_rows =) (ยง wp.w_height - used))
        )
    ))

;; Recompute topline to put the cursor at the bottom of the window.
;; Scroll at least "min_scroll" lines.
;; If "set_topbot" is true, set topline and botline first (for "zb").
;; This is messy stuff!!!

(defn- #_void scroll_cursor_bot [#_int min_scroll, #_boolean set_topbot]
    (ยง
        ((ร int scrolled =) 0)
        ((ร int extra =) 0)
        ((ร long old_topline =) (. @curwin w_topline))
        ((ร long old_botline =) (. @curwin w_botline))
        ((ร int old_valid =) (. @curwin w_valid))
        ((ร int old_empty_rows =) (. @curwin w_empty_rows))

        ((ร lineoff_C loff =) (ยง ยง_lineoff_C()))
        ((ร lineoff_C boff =) (ยง ยง_lineoff_C()))

        ((ร long cln =) (.. @curwin w_cursor lnum))            ;; Cursor Line Number
        (cond set_topbot
        (ยง
            ((ร int used =) 0)
            ((ร @curwin.w_botline =) (+ cln 1))
            ((ร FOR) (ร (ยง @curwin.w_topline = @curwin.w_botline) (ยง 1 < @curwin.w_topline) (ยง @curwin.w_topline = loff.lnum))
                ((ร loff.lnum =) (. @curwin w_topline))
                (topline_back loff)
                (if (or (== (. loff height) MAXCOL) (< (. @curwin w_height) (+ used (. loff height))))
                    (ร BREAK)
                )
                ((ร used +=) (. loff height))
            )
            (set_empty_rows @curwin, used)
            ((ร @curwin.w_valid |=) (ยง VALID_BOTLINE|VALID_BOTLINE_AP))
            (if (!= (. @curwin w_topline) old_topline)
                ((ร @curwin.w_valid &=) (ยง ~(VALID_WROW|VALID_CROW)))
            )
        )
        :else
        (ยง
            (validate_botline)
        ))

        ;; The lines of the cursor line itself are always used.
        (validate_cheight)
        ((ร int used =) (. @curwin w_cline_height))

        ;; If the cursor is below botline, we will at least scroll by the height of the cursor line.
        ;; Correct for empty lines, which are really part of botline.
        (when (<= (. @curwin w_botline) cln)
            ((ร scrolled =) used)
            (if (== cln (. @curwin w_botline))
                ((ร scrolled -=) (. @curwin w_empty_rows))
            )
        )

        ;; Stop counting lines to scroll when
        ;; - hitting start of the file
        ;; - scrolled nothing or at least 'sj' lines
        ;; - at least 'so' lines below the cursor
        ;; - lines between botline and cursor have been counted

        ((ร loff.lnum =) cln)
        ((ร boff.lnum =) cln)

        (while (ยง 1 < loff.lnum)
            ;; Stop when scrolled nothing or at least "min_scroll", found "extra"
            ;; context for 'scrolloff' and counted all lines below the window.
            (when (and (or (and (or (<= scrolled 0) (<= min_scroll scrolled)) (<= @p_so extra)) (< (.. @curbuf b_ml ml_line_count) (+ (. boff lnum) 1))) (<= (. loff lnum) (. @curwin w_botline)))
                (ร BREAK)
            )

            ;; Add one line above.
            (topline_back loff)
            (if (== (. loff height) MAXCOL)
                ((ร used =) MAXCOL)
                ((ร used +=) (. loff height))
            )
            (if (< (. @curwin w_height) used)
                (ร BREAK)
            )
            (when (<= (. @curwin w_botline) (. loff lnum))
                ;; Count screen lines that are below the window.
                ((ร scrolled +=) (. loff height))
                (if (== (. loff lnum) (. @curwin w_botline))
                    ((ร scrolled -=) (. @curwin w_empty_rows))
                )
            )

            (when (< (. boff lnum) (.. @curbuf b_ml ml_line_count))
                ;; Add one line below.
                (botline_forw boff)
                ((ร used +=) (. boff height))
                (if (< (. @curwin w_height) used)
                    (ร BREAK)
                )
                (when (or (< extra @p_so) (< scrolled min_scroll))
                    ((ร extra +=) (. boff height))
                    (when (<= (. @curwin w_botline) (. boff lnum))
                        ;; Count screen lines that are below the window.
                        ((ร scrolled +=) (. boff height))
                        (if (== (. boff lnum) (. @curwin w_botline))
                            ((ร scrolled -=) (. @curwin w_empty_rows))
                        )
                    )
                )
            )
        )

        (ร long line_count)
        ;; curwin.w_empty_rows is larger, no need to scroll
        (cond (<= scrolled 0)
        (ยง
            ((ร line_count =) 0)
        )
        ;; more than a screenfull, don't scroll but redraw
        (< (. @curwin w_height) used)
        (ยง
            ((ร line_count =) used)
        )
        ;; scroll minimal number of lines
        :else
        (ยง
            ((ร line_count =) 0)
            ((ร boff.lnum =) (ยง @curwin.w_topline - 1))
            (ร int i)
            ((ร FOR) (ร (ยง i = 0) (ยง i < scrolled && boff.lnum < @curwin.w_botline) nil)
                (botline_forw boff)
                ((ร i +=) (. boff height))
                (ยง line_count++)
            )
            (if (< i scrolled)       ;; below curwin.w_botline, don't scroll
                ((ร line_count =) 9999)
            )
        ))

        ;; Scroll up if the cursor is off the bottom of the screen a bit.
        ;; Otherwise put it at 1/2 of the screen.

        (if (and (<= (. @curwin w_height) line_count) (< min_scroll line_count))
            (scroll_cursor_halfway false)
            (scrollup line_count))

        ;; If topline didn't change we need to restore w_botline and w_empty_rows (we changed them).
        ;; If topline did change, update_screen() will set botline.

        (when (and (== (. @curwin w_topline) old_topline) set_topbot)
            ((ร @curwin.w_botline =) old_botline)
            ((ร @curwin.w_empty_rows =) old_empty_rows)
            ((ร @curwin.w_valid =) old_valid)
        )
        ((ร @curwin.w_valid |=) VALID_TOPLINE)
    ))

;; Recompute topline to put the cursor halfway the window
;; If "atend" is true, also put it halfway at the end of the file.

(defn- #_void scroll_cursor_halfway [#_boolean atend]
    (ยง
        ((ร lineoff_C loff =) (ยง ยง_lineoff_C()))
        ((ร lineoff_C boff =) (ยง ยง_lineoff_C()))

        ((ร loff.lnum =) (ยง boff.lnum = @curwin.w_cursor.lnum))
        ((ร int used =) (ยง plines(loff.lnum)))
        ((ร long topline =) (. loff lnum))

        ((ร FOR) (ร (ยง int above = 0, below = 0) (< 1 topline) nil)
            (when (<= below above)         ;; add a line below the cursor first
                (cond (< (. boff lnum) (.. @curbuf b_ml ml_line_count))
                (ยง
                    (botline_forw boff)
                    ((ร used +=) (. boff height))
                    (if (< (. @curwin w_height) used)
                        (ร BREAK)
                    )
                    ((ร below +=) (. boff height))
                )
                :else
                (ยง
                    (ยง below++)            ;; count a "~" line
                    (if atend
                        (ยง used++)
                    )
                ))
            )

            (when (< above below)          ;; add a line above the cursor
                (topline_back loff)
                (if (== (. loff height) MAXCOL)
                    ((ร used =) MAXCOL)
                    ((ร used +=) (. loff height))
                )
                (if (< (. @curwin w_height) used)
                    (ร BREAK)
                )
                ((ร above +=) (. loff height))
                ((ร topline =) (. loff lnum))
            )
        )

        ((ร @curwin.w_topline =) topline)
        ((ร @curwin.w_valid &=) (ยง ~(VALID_WROW|VALID_CROW|VALID_BOTLINE|VALID_BOTLINE_AP)))
        ((ร @curwin.w_valid |=) VALID_TOPLINE)
    ))

;; Correct the cursor position so that it is in a part of the screen at least
;; 'so' lines from the top and bottom, if possible.
;; If not possible, put it at the same position as scroll_cursor_halfway().
;; When called topline must be valid!

(defn- #_void cursor_correct []
    (ยง
        ;; How many lines we would like to have above/below the cursor depends on
        ;; whether the first/last line of the file is on screen.

        ((ร int above_wanted =) (ยง (int)@p_so))
        ((ร int below_wanted =) (ยง (int)@p_so))
        (when (== (. @curwin w_topline) 1)
            ((ร above_wanted =) 0)
            ((ร int max_off =) (ยง @curwin.w_height / 2))
            (if (< max_off below_wanted)
                ((ร below_wanted =) max_off)
            )
        )
        (validate_botline)
        (when (== (. @curwin w_botline) (+ (.. @curbuf b_ml ml_line_count) 1))
            ((ร below_wanted =) 0)
            ((ร int max_off =) (ยง (@curwin.w_height - 1) / 2))
            (if (< max_off above_wanted)
                ((ร above_wanted =) max_off)
            )
        )

        ;; If there are sufficient file-lines above and below the cursor, we can return now.

        ((ร long cln =) (.. @curwin w_cursor lnum))    ;; Cursor Line Number
        (if (and (ยง @curwin.w_topline + above_wanted <= cln) (< cln (- (. @curwin w_botline) below_wanted)))
            (ร RETURN)
        )

        ((ร int above =) 0)          ;; screen lines above topline
        ((ร int below =) 0)          ;; screen lines below botline

        ;; Narrow down the area where the cursor can be put by taking lines from
        ;; the top and the bottom until:
        ;; - the desired context lines are found
        ;; - the lines from the top is past the lines from the bottom

        ((ร long topline =) (. @curwin w_topline))
        ((ร long botline =) (ยง @curwin.w_botline - 1))
        (while (ยง (above < above_wanted || below < below_wanted) && topline < botline)
            (when (and (< below below_wanted) (or (<= below above) (<= above_wanted above)))
                ((ร below +=) (plines botline))
                (ยง --botline)
            )
            (when (and (< above above_wanted) (or (< above below) (<= below_wanted below)))
                ((ร above +=) (plines topline))
                (ยง topline++)
            )
        )
        (cond (or (== topline botline) (zero? botline))
        (ยง
            ((ร @curwin.w_cursor.lnum =) topline)
        )
        (< botline topline)
        (ยง
            ((ร @curwin.w_cursor.lnum =) botline)
        )
        :else
        (ยง
            (when (and (< cln topline) (< 1 (. @curwin w_topline)))
                ((ร @curwin.w_cursor.lnum =) topline)
                ((ร @curwin.w_valid &=) (ยง ~(VALID_WROW|VALID_WCOL|VALID_CHEIGHT|VALID_CROW)))
            )
            (when (and (< botline cln) (<= (. @curwin w_botline) (.. @curbuf b_ml ml_line_count)))
                ((ร @curwin.w_cursor.lnum =) botline)
                ((ร @curwin.w_valid &=) (ยง ~(VALID_WROW|VALID_WCOL|VALID_CHEIGHT|VALID_CROW)))
            )
        ))
        ((ร @curwin.w_valid |=) VALID_TOPLINE)
    ))

;; move screen 'count' pages up or down and update screen
;;
;; return false for failure, true otherwise

(defn- #_boolean onepage [#_int dir, #_long count]
    (ยง
        ((ร boolean retval =) true)

        ((ร long old_topline =) (. @curwin w_topline))

        (when (== (.. @curbuf b_ml ml_line_count) 1) ;; nothing to do
            (beep_flush)
            ((ร RETURN) false)
        )

        ((ร lineoff_C loff =) (ยง ยง_lineoff_C()))

        ((ร FOR) (ร (ยง  ) (< 0 count) (ยง --count))
            (validate_botline)

            ;; It's an error to move a page up when the first line is already on
            ;; the screen.  It's an error to move a page down when the last line
            ;; is on the screen and the topline is 'scrolloff' lines from the last line.

            (when (if (== dir FORWARD) (and (ยง @curbuf.b_ml.ml_line_count - @p_so <= @curwin.w_topline) (< (.. @curbuf b_ml ml_line_count) (. @curwin w_botline))) (== (. @curwin w_topline) 1))
                (beep_flush)
                ((ร retval =) false)
                (ร BREAK)
            )

            (cond (== dir FORWARD)
            (ยง
                (cond (< (.. @curbuf b_ml ml_line_count) (. @curwin w_botline))
                (ยง
                    ;; at end of file
                    ((ร @curwin.w_topline =) (.. @curbuf b_ml ml_line_count))
                    ((ร @curwin.w_valid &=) (ยง ~(VALID_WROW|VALID_CROW)))
                )
                :else
                (ยง
                    ;; For the overlap, start with the line just below the window and go upwards.
                    ((ร loff.lnum =) (. @curwin w_botline))
                    (get_scroll_overlap loff, -1)
                    ((ร @curwin.w_topline =) (. loff lnum))
                    ((ร @curwin.w_cursor.lnum =) (. @curwin w_topline))
                    ((ร @curwin.w_valid &=) (ยง ~(VALID_WCOL|VALID_CHEIGHT|VALID_WROW|VALID_CROW|VALID_BOTLINE|VALID_BOTLINE_AP)))
                ))
            )
            :else    ;; dir == BACKWARDS
            (ยง
                ;; Find the line at the top of the window that is going to be the line at the bottom of the window.
                ;; Make sure this results in the same line as before doing CTRL-F.
                ((ร loff.lnum =) (ยง @curwin.w_topline - 1))
                (get_scroll_overlap loff, 1)

                (if (> (. loff lnum) (.. @curbuf b_ml ml_line_count))
                    ((ร loff.lnum =) (.. @curbuf b_ml ml_line_count))
                )
                ((ร @curwin.w_cursor.lnum =) (. loff lnum))

                ;; Find the line just above the new topline to get the right line at the bottom of the window.
                ((ร long n =) 0)
                (while (ยง n <= @curwin.w_height && 1 <= loff.lnum)
                    (topline_back loff)
                    (if (== (. loff height) MAXCOL)
                        ((ร n =) MAXCOL)
                        ((ร n +=) (. loff height))
                    )
                )
                (cond (< (. loff lnum) 1)      ;; at begin of file
                (ยง
                    ((ร @curwin.w_topline =) 1)
                    ((ร @curwin.w_valid &=) (ยง ~(VALID_WROW|VALID_CROW|VALID_BOTLINE)))
                )
                :else
                (ยง
                    ;; Go two lines forward again.
                    (botline_forw loff)
                    (botline_forw loff)

                    ;; Always scroll at least one line.  Avoid getting stuck on very long lines.
                    (cond (<= (. @curwin w_topline) (. loff lnum))
                    (ยง
                        (ยง --@curwin.w_topline)

                        (comp_botline @curwin)
                        ((ร @curwin.w_cursor.lnum =) (ยง @curwin.w_botline - 1))
                        ((ร @curwin.w_valid &=) (ยง ~(VALID_WCOL|VALID_CHEIGHT|VALID_WROW|VALID_CROW)))
                    )
                    :else
                    (ยง
                        ((ร @curwin.w_topline =) (. loff lnum))
                        ((ร @curwin.w_valid &=) (ยง ~(VALID_WROW|VALID_CROW|VALID_BOTLINE)))
                    ))
                ))
            ))
        )

        (cursor_correct)
        (if retval
            (beginline (| BL_SOL BL_FIX)))
        ((ร @curwin.w_valid &=) (ยง ~(VALID_WCOL|VALID_WROW|VALID_VIRTCOL)))

        ;; Avoid the screen jumping up and down when 'scrolloff' is non-zero.
        ;; But make sure we scroll at least one line (happens with mix of long
        ;; wrapping lines and non-wrapping line).

        (when (and retval (== dir FORWARD) (check_top_offset))
            (scroll_cursor_top 1, false)
            (when (and (<= (. @curwin w_topline) old_topline) (< old_topline (.. @curbuf b_ml ml_line_count)))
                ((ร @curwin.w_topline =) (+ old_topline 1))
            )
        )

        (redraw_later VALID)
        retval
    ))

;; Decide how much overlap to use for page-up or page-down scrolling.
;; This is symmetric, so that doing both keeps the same lines displayed.
;; Three lines are examined:
;;
;;  before CTRL-F           after CTRL-F / before CTRL-B
;;     etc.                     l1
;;  l1 last but one line        ------------
;;  l2 last text line           l2 top text line
;;  -------------               l3 second text line
;;  l3                             etc.

(defn- #_void get_scroll_overlap [#_lineoff_C lp, #_int dir]
    (ยง
        ((ร int min_height =) (ยง @curwin.w_height - 2))

        ((ร lp.height =) (ยง plines(lp.lnum)))
        ((ร int h1 =) (. lp height))
        (if (< min_height h1)
            (ร RETURN)         ;; no overlap
        )

        ((ร lineoff_C loff0 =) (ยง ยง_lineoff_C()))
        (COPY_lineoff loff0, lp)
        (if (< 0 dir)
            (botline_forw lp)
            (topline_back lp))
        ((ร int h2 =) (. lp height))
        (when (or (== h2 MAXCOL) (< min_height (+ h2 h1)))
            (COPY_lineoff lp, loff0)    ;; no overlap
            (ร RETURN)
        )

        ((ร lineoff_C loff1 =) (ยง ยง_lineoff_C()))
        (COPY_lineoff loff1, lp)
        (if (< 0 dir)
            (botline_forw lp)
            (topline_back lp))
        ((ร int h3 =) (. lp height))
        (when (or (== h3 MAXCOL) (< min_height (+ h3 h2)))
            (COPY_lineoff lp, loff0)    ;; no overlap
            (ร RETURN)
        )

        ((ร lineoff_C loff2 =) (ยง ยง_lineoff_C()))
        (COPY_lineoff loff2, lp)
        (if (< 0 dir)
            (botline_forw lp)
            (topline_back lp))
        ((ร int h4 =) (. lp height))
        (if (or (== h4 MAXCOL) (< min_height (+ h4 h3 h2)) (< min_height (+ h3 h2 h1)))
            (COPY_lineoff lp, loff1)    ;; 1 line overlap
            (COPY_lineoff lp, loff2))    ;; 2 lines overlap
    ))

;; Scroll 'scroll' lines up or down.

(defn- #_void halfpage [#_boolean flag, #_long Prenum]
    (ยง
        ((ร long scrolled =) 0)

        (if (non-zero? Prenum)
            ((ร @curwin.w_options.@wo_scr =) (if (< (. @curwin w_height) Prenum) (. @curwin w_height) Prenum))
        )
        ((ร int n =) (if (<= (int @(.. @curwin w_options wo_scr)) (. @curwin w_height)) (int @(.. @curwin w_options wo_scr)) (. @curwin w_height)))

        (validate_botline)
        ((ร int room =) (. @curwin w_empty_rows))
        (cond flag
        (ยง
            ;; scroll the text up

            (while (ยง 0 < n && @curwin.w_botline <= @curbuf.b_ml.ml_line_count)
                ((ร int i =) (ยง plines(@curwin.w_topline)))
                ((ร n -=) i)
                (if (and (< n 0) (< 0 scrolled))
                    (ร BREAK)
                )
                (ยง @curwin.w_topline++)

                (when (< (.. @curwin w_cursor lnum) (.. @curbuf b_ml ml_line_count))
                    (ยง @curwin.w_cursor.lnum++)
                    ((ร @curwin.w_valid &=) (ยง ~(VALID_VIRTCOL|VALID_CHEIGHT|VALID_WCOL)))
                )

                ((ร @curwin.w_valid &=) (ยง ~(VALID_CROW|VALID_WROW)))
                ((ร scrolled +=) i)

                ;; Correct w_botline for changed w_topline.
                ;; Won't work when there are filler lines.

                ((ร room +=) i)
;               do
;               {
                    ((ร i =) (ยง plines(@curwin.w_botline)))
                    (if (< room i)
                        (ร BREAK)
                    )
                    (ยง @curwin.w_botline++)
                    ((ร room -=) i)
;               } while (@curwin.w_botline <= @curbuf.b_ml.ml_line_count);
            )

            ;; When hit bottom of the file: move cursor down.

            (when (< 0 n)
                ((ร @curwin.w_cursor.lnum +=) n)
                (check_cursor_lnum)
            )
        )
        :else
        (ยง
            ;; scroll the text down

            (while (ยง 0 < n && 1 < @curwin.w_topline)
                ((ร int i =) (ยง plines(@curwin.w_topline - 1)))
                ((ร n -=) i)
                (if (and (< n 0) (< 0 scrolled))
                    (ร BREAK)
                )
                (ยง --@curwin.w_topline)

                ((ร @curwin.w_valid &=) (ยง ~(VALID_CROW|VALID_WROW|VALID_BOTLINE|VALID_BOTLINE_AP)))
                ((ร scrolled +=) i)
                (when (< 1 (.. @curwin w_cursor lnum))
                    (ยง --@curwin.w_cursor.lnum)
                    ((ร @curwin.w_valid &=) (ยง ~(VALID_VIRTCOL|VALID_CHEIGHT|VALID_WCOL)))
                )
            )

            ;; When hit top of the file: move cursor up.

            (when (< 0 n)
                (if (<= (.. @curwin w_cursor lnum) (long n))
                    ((ร @curwin.w_cursor.lnum =) 1)
                    ((ร @curwin.w_cursor.lnum -=) n)
                )
            )
        ))
        (cursor_correct)
        (beginline (| BL_SOL BL_FIX))
        (redraw_later VALID)
    ))

(defn- #_void do_check_cursorbind []
    (ยง
        ((ร long line =) (.. @curwin w_cursor lnum))
        ((ร int col =) (.. @curwin w_cursor col))
        ((ร int coladd =) (.. @curwin w_cursor coladd))
        ((ร int curswant =) (. @curwin w_curswant))
        ((ร boolean set_curswant =) (. @curwin w_set_curswant))

        ((ร window_C old_curwin =) @curwin)
        ((ร boolean old_VIsual_select =) @VIsual_select)
        ((ร boolean old_VIsual_active =) @VIsual_active)

        ;; loop through the cursorbound windows

        (reset! VIsual_select (ยง @VIsual_active = false))
        ((ร FOR) (ร (ยง @curwin = @firstwin) (!= @curwin null) (ยง @curwin = @curwin.w_next))
            ;; skip original window  and windows with 'noscrollbind'
            (when (and (!= @curwin old_curwin) @(.. @curwin w_options wo_crb))
                ((ร @curwin.w_cursor.lnum =) line)
                ((ร @curwin.w_cursor.col =) col)
                ((ร @curwin.w_cursor.coladd =) coladd)
                ((ร @curwin.w_curswant =) curswant)
                ((ร @curwin.w_set_curswant =) set_curswant)

                ;; Make sure the cursor is in a valid position.  Temporarily set
                ;; "restart_edit" to allow the cursor to be beyond the EOL.
                ((ร int restart_edit_save =) @restart_edit)
                (reset! restart_edit TRUE)
                (check_cursor)
                (reset! restart_edit restart_edit_save)
                ;; Correct cursor for multi-byte character.
                (mb_adjust_pos @curbuf, (. @curwin w_cursor))
                (redraw_later VALID)

                ;; Only scroll when 'scrollbind' hasn't done this.
                (if (not @(.. @curwin w_options wo_scb))
                    (update_topline))
                ((ร @curwin.w_redr_status =) true)
            )
        )

        ;; reset current-window

        (reset! VIsual_select old_VIsual_select)
        (reset! VIsual_active old_VIsual_active)
        (reset! curwin old_curwin)
    ))

;;; ============================================================================================== VimX

;; syntax.c: code for syntax highlighting ---------------------------------------------------------

;; Structure that stores information about a highlight group.
;; The ID of a highlight group is also called group ID.
;; It is the index in the highlight_ga array PLUS ONE.

(class! #_final hl_group_C
    [
        (field Bytes        sg_name)            ;; highlight group name
        (field Bytes        sg_name_u)          ;; uppercase of "sg_name"
;; for normal terminals
        (field int          sg_term)            ;; "term=" highlighting attributes
        (field Bytes        sg_start)           ;; terminal string for start highl
        (field Bytes        sg_stop)            ;; terminal string for stop highl
        (field int          sg_term_attr)       ;; screen attr for term mode
;; for color terminals
        (field int          sg_cterm)           ;; "cterm=" highlighting attr
        (field boolean      sg_cterm_bold)      ;; bold attr was set for light color
        (field int          sg_cterm_fg)        ;; terminal fg color number + 1
        (field int          sg_cterm_bg)        ;; terminal bg color number + 1
        (field int          sg_cterm_attr)      ;; screen attr for color term mode
;; Store the sp color name for the GUI or synIDattr().
        (field int          sg_gui)             ;; "gui=" highlighting attributes
        (field Bytes        sg_gui_fg_name)     ;; GUI foreground color name
        (field Bytes        sg_gui_bg_name)     ;; GUI background color name
        (field Bytes        sg_gui_sp_name)     ;; GUI special color name
        (field int          sg_link)            ;; link to this highlight group ID
        (field int          sg_set)             ;; combination of SG_* flags
    ])

(defn- #_void COPY_hl_group [#_hl_group_C sg1, #_hl_group_C sg0]
    (ยง
        ((ร sg1.sg_name =) (. sg0 sg_name))
        ((ร sg1.sg_name_u =) (. sg0 sg_name_u))
        ((ร sg1.sg_term =) (. sg0 sg_term))
        ((ร sg1.sg_start =) (. sg0 sg_start))
        ((ร sg1.sg_stop =) (. sg0 sg_stop))
        ((ร sg1.sg_term_attr =) (. sg0 sg_term_attr))
        ((ร sg1.sg_cterm =) (. sg0 sg_cterm))
        ((ร sg1.sg_cterm_bold =) (. sg0 sg_cterm_bold))
        ((ร sg1.sg_cterm_fg =) (. sg0 sg_cterm_fg))
        ((ร sg1.sg_cterm_bg =) (. sg0 sg_cterm_bg))
        ((ร sg1.sg_cterm_attr =) (. sg0 sg_cterm_attr))
        ((ร sg1.sg_gui =) (. sg0 sg_gui))
        ((ร sg1.sg_gui_fg_name =) (. sg0 sg_gui_fg_name))
        ((ร sg1.sg_gui_bg_name =) (. sg0 sg_gui_bg_name))
        ((ร sg1.sg_gui_sp_name =) (. sg0 sg_gui_sp_name))
        ((ร sg1.sg_link =) (. sg0 sg_link))
        ((ร sg1.sg_set =) (. sg0 sg_set))
    ))

;; highlight groups for 'highlight' option
(atom! hl_group_C*  highlight_ga    0)

(final int MAX_HL_ID       20000)       ;; maximum value for a highlight ID.

;; An attribute number is the index in attr_table plus ATTR_OFF.

(final int ATTR_OFF (inc HL_ALL))

;; The attributes of the syntax item that has been recognized.

(atom! int current_sub_char)

;; Return conceal substitution character

(defn- #_int syn_get_sub_char []
    @current_sub_char)

;; Reset the cterm colors to what they were before Vim was started,
;; if possible.  Otherwise reset them to zero.

(defn- #_void restore_cterm_colors []
    (ยง
        (reset! cterm_normal_fg_color 0)
        (reset! cterm_normal_fg_bold 0)
        (reset! cterm_normal_bg_color 0)
    ))

;; Table with the specifications for an attribute number.
;; Note that this table is used by ALL buffers.
;; This is required because the GUI can redraw at any time for any buffer.

(atom! attrentry_C* term_attr_table     0)
(atom! attrentry_C* cterm_attr_table    0)

(atom! boolean _4_recursive)

;; Return the attr number for a set of colors and font.
;; Add a new entry to the term_attr_table, cterm_attr_table or gui_attr_table, if the combination is new.
;; Return 0 for error (no more room).

(defn- #_int get_attr_entry [#_attrentry_C* table, #_attrentry_C aep]
    (ยง
        ;; Try to find an entry with the same specifications.

        ((ร FOR) (ร (ยง int i = 0) (ยง i < table.ga_len) (ยง i++))
            ((ร attrentry_C taep =) (ยง table.ga_data[i]))
            (if (ยง aep.ae_attr == taep.ae_attr && ((table == @term_attr_table && (aep.ae_esc_start == null) == (taep.ae_esc_start == null) && (aep.ae_esc_start == null || STRCMP(aep.ae_esc_start, taep.ae_esc_start) == 0) && (aep.ae_esc_stop == null) == (taep.ae_esc_stop == null) && (aep.ae_esc_stop == null || STRCMP(aep.ae_esc_stop, taep.ae_esc_stop) == 0)) || (table == @cterm_attr_table && aep.ae_fg_color == taep.ae_fg_color && aep.ae_bg_color == taep.ae_bg_color)))
                ((ร RETURN) (+ i ATTR_OFF))
            )
        )

        ((ร final int MAX_TYPENR =) 65535)

        (when (< MAX_TYPENR (+ (. table ga_len) ATTR_OFF))
            ;; Running out of attribute entries!
            ;; Remove all attributes, and compute new ones for all groups.
            ;; When called recursively, we are really out of numbers.

            (when @_4_recursive
                (emsg (u8 "E424: Too many different highlighting attributes in use"))
                ((ร RETURN) 0)
            )
            (reset! _4_recursive true)

            (clear_hl_tables)

            (reset! must_redraw CLEAR)

            ((ร FOR) (ร (ยง int i = 0) (ยง i < @highlight_ga.ga_len) (ยง i++))
                (set_hl_attr i)
            )

            (reset! _4_recursive false)
        )

        ;; This is a new combination of colors and font, add an entry.

        (ยง table.ga_grow(1))

        ((ร attrentry_C taep =) (ยง table.ga_data[table.ga_len++] = ยง_attrentry_C()))

        ((ร taep.ae_attr =) (. aep ae_attr))
        (cond (== table @term_attr_table)
        (ยง
            (if (nil? (. aep ae_esc_start))
                ((ร taep.ae_esc_start =) null)
                ((ร taep.ae_esc_start =) (ยง STRDUP(aep.ae_esc_start)))
            )
            (if (nil? (. aep ae_esc_stop))
                ((ร taep.ae_esc_stop =) null)
                ((ร taep.ae_esc_stop =) (ยง STRDUP(aep.ae_esc_stop)))
            )
        )
        (== table @cterm_attr_table)
        (ยง
            ((ร taep.ae_fg_color =) (. aep ae_fg_color))
            ((ร taep.ae_bg_color =) (. aep ae_bg_color))
        ))

        (ยง table.ga_len - 1 + ATTR_OFF)
    ))

;; Clear all highlight tables.

(defn- #_void clear_hl_tables []
    (ยง
        ((ร FOR) (ร (ยง int i = 0) (ยง i < @term_attr_table.ga_len) (ยง i++))
            ((ร attrentry_C taep =) (ยง @term_attr_table.ga_data[i]))
            ((ร taep.ae_esc_start =) null)
            ((ร taep.ae_esc_stop =) null)
        )
        (ยง @term_attr_table.ga_clear())
        (ยง @cterm_attr_table.ga_clear())
    ))

;; Combine special attributes (e.g., for spelling)
;; with other attributes (e.g., for syntax highlighting).
;; "prim_attr" overrules "char_attr".
;; This creates a new group when required.
;; Since we expect there to be few spelling mistakes we don't cache the result.
;; Return the resulting attributes.

(defn- #_int hl_combine_attr [#_int char_attr, #_int prim_attr]
    (ยง
        ((ร attrentry_C char_aep =) null)
        (ร attrentry_C spell_aep)

        (if (zero? char_attr)
            ((ร RETURN) prim_attr)
        )
        (if (and (<= char_attr HL_ALL) (<= prim_attr HL_ALL))
            ((ร RETURN) (| char_attr prim_attr))
        )

        ((ร attrentry_C new_en =) (ยง ยง_attrentry_C()))

        (when (< 1 @t_colors)
            (if (< HL_ALL char_attr)
                ((ร char_aep =) (syn_cterm_attr2entry char_attr))
            )
            (cond (non-nil? char_aep)
            (ยง
                (COPY_attrentry new_en, char_aep)
            )
            :else
            (ยง
                (ZER0_attrentry new_en)
                (if (<= char_attr HL_ALL)
                    ((ร new_en.ae_attr =) char_attr)
                )
            ))

            (cond (<= prim_attr HL_ALL)
            (ยง
                ((ร new_en.ae_attr |=) prim_attr)
            )
            :else
            (ยง
                ((ร spell_aep =) (syn_cterm_attr2entry prim_attr))
                (when (non-nil? spell_aep)
                    ((ร new_en.ae_attr |=) (. spell_aep ae_attr))
                    (if (< 0 (. spell_aep ae_fg_color))
                        ((ร new_en.ae_fg_color =) (. spell_aep ae_fg_color))
                    )
                    (if (< 0 (. spell_aep ae_bg_color))
                        ((ร new_en.ae_bg_color =) (. spell_aep ae_bg_color))
                    )
                )
            ))

            ((ร RETURN) (get_attr_entry @cterm_attr_table, new_en))
        )

        (if (< HL_ALL char_attr)
            ((ร char_aep =) (syn_term_attr2entry char_attr))
        )
        (cond (non-nil? char_aep)
        (ยง
            (COPY_attrentry new_en, char_aep)
        )
        :else
        (ยง
            (ZER0_attrentry new_en)
            (if (<= char_attr HL_ALL)
                ((ร new_en.ae_attr =) char_attr)
            )
        ))

        (cond (<= prim_attr HL_ALL)
        (ยง
            ((ร new_en.ae_attr |=) prim_attr)
        )
        :else
        (ยง
            ((ร spell_aep =) (syn_term_attr2entry prim_attr))
            (when (non-nil? spell_aep)
                ((ร new_en.ae_attr |=) (. spell_aep ae_attr))
                (when (!= (. spell_aep ae_esc_start) null)
                    ((ร new_en.ae_esc_start =) (. spell_aep ae_esc_start))
                    ((ร new_en.ae_esc_stop =) (. spell_aep ae_esc_stop))
                )
            )
        ))

        (get_attr_entry @term_attr_table, new_en)
    ))

;; Get the highlight attributes (HL_BOLD etc.) from an attribute nr.
;; Only to be used when "attr" > HL_ALL.

(defn- #_int syn_attr2attr [#_int attr]
    (ยง
        (ร attrentry_C aep)

        (if (< 1 @t_colors)
            ((ร aep =) (syn_cterm_attr2entry attr))
            ((ร aep =) (syn_term_attr2entry attr))
        )

        (if (nil? aep)        ;; highlighting not set
            ((ร RETURN) 0)
        )

        (. aep ae_attr)
    ))

(defn- #_attrentry_C syn_term_attr2entry [#_int attr]
    (ยง
        ((ร attr -=) ATTR_OFF)
        (if (<= (. @term_attr_table ga_len) attr)     ;; did ":syntax clear"
            ((ร RETURN) null)
        )

        (ยง @term_attr_table.ga_data[attr])
    ))

(defn- #_attrentry_C syn_cterm_attr2entry [#_int attr]
    (ยง
        ((ร attr -=) ATTR_OFF)
        (if (<= (. @cterm_attr_table ga_len) attr)    ;; did ":syntax clear"
            ((ร RETURN) null)
        )

        (ยง @cterm_attr_table.ga_data[attr])
    ))

;; Set the attribute numbers for a highlight group.
;; Called after one of the attributes has changed.

(defn- #_void set_hl_attr [#_int idx]
    ;; idx: index in array
    (ยง
        ((ร hl_group_C[] hlt =) (. @highlight_ga ga_data))
        ((ร hl_group_C sgp =) (ยง hlt[idx]))

        ;; The "Normal" group doesn't need an attribute number.
        (if (and (!= (. sgp sg_name_u) null) (zero? (ยง STRCMP(sgp.sg_name_u, (u8 "NORMAL")))))
            (ร RETURN)
        )

        ;; For the term mode: If there are other than "normal" highlighting
        ;; attributes, need to allocate an attr number.

        (cond (and (nil? (. sgp sg_start)) (nil? (. sgp sg_stop)))
        (ยง
            ((ร sgp.sg_term_attr =) (. sgp sg_term))
        )
        :else
        (ยง
            ((ร attrentry_C at_en =) (ยง ยง_attrentry_C()))
            ((ร at_en.ae_attr =) (. sgp sg_term))
            ((ร at_en.ae_esc_start =) (. sgp sg_start))
            ((ร at_en.ae_esc_stop =) (. sgp sg_stop))
            ((ร sgp.sg_term_attr =) (get_attr_entry @term_attr_table, at_en))
        ))

        ;; For the color term mode: If there are other than "normal"
        ;; highlighting attributes, need to allocate an attr number.

        (cond (and (zero? (. sgp sg_cterm_fg)) (zero? (. sgp sg_cterm_bg)))
        (ยง
            ((ร sgp.sg_cterm_attr =) (. sgp sg_cterm))
        )
        :else
        (ยง
            ((ร attrentry_C at_en =) (ยง ยง_attrentry_C()))
            ((ร at_en.ae_attr =) (. sgp sg_cterm))
            ((ร at_en.ae_fg_color =) (. sgp sg_cterm_fg))
            ((ร at_en.ae_bg_color =) (. sgp sg_cterm_bg))
            ((ร sgp.sg_cterm_attr =) (get_attr_entry @cterm_attr_table, at_en))
        ))
    ))

;; Lookup a highlight group name and return it's ID.
;; If it is not found, 0 is returned.

(defn- #_int syn_name2id [#_Bytes name]
    (ยง
        ((ร Bytes name_u =) (vim_strsave_up name))

        ((ร hl_group_C[] hlt =) (. @highlight_ga ga_data))

        (ร int i)
        ((ร FOR) (ร (ยง i = @highlight_ga.ga_len) (ยง 0 <= --i) nil)
            (if (and (!= (ยง hlt[i].sg_name_u) null) (zero? (ยง STRCMP(name_u, hlt[i].sg_name_u))))
                (ร BREAK)
            )
        )
        (+ i 1)
    ))

;; Find highlight group name in the table and return it's ID.
;; The argument is a pointer to the name and the length of the name.
;; If it doesn't exist yet, a new entry is created.
;; Return 0 for failure.

(defn- #_int syn_check_group [#_Bytes pp, #_int len]
    (ยง
        ((ร Bytes name =) (STRNDUP pp, len))

        ((ร int id =) (syn_name2id name))
        (if (zero? id)                        ;; doesn't exist yet
            ((ร id =) (syn_add_group name))
        )

        id
    ))

;; Add new highlight group and return it's ID.
;; "name" must be an allocated string, it will be consumed.
;; Return 0 for failure.

(defn- #_int syn_add_group [#_Bytes name]
    (ยง
        ;; Check that the name is ASCII letters, digits and underscore.
        ((ร FOR) (ร (ยง Bytes p = name) (ยง p.at(0) != NUL) (ยง p = p.plus(1)))
            (cond (not (vim_isprintc (ยง p.at(0))))
            (ยง
                (emsg (u8 "E669: Unprintable character in group name"))
                ((ร RETURN) 0)
            )
            (and (not (asc_isalnum (ยง p.at(0)))) (!= (.at p 0) (byte \_)))
            (ยง
                ;; This is an error, but since there previously was no check only give a warning.
                (msg (u8 "W18: Invalid character in group name"))
                (ร BREAK)
            ))
        )

        (when (<= MAX_HL_ID (. @highlight_ga ga_len))
            (emsg (u8 "E849: Too many highlight and syntax groups"))
            ((ร RETURN) 0)
        )

        ;; Make room for at least one other syntax_highlight entry.

        ((ร hl_group_C[] hlt =) (ยง @highlight_ga.ga_grow(1)))

        ((ร hlt[@highlight_ga.ga_len] =) (ยง ยง_hl_group_C()))
        ((ร hlt[@highlight_ga.ga_len].sg_name =) name)
        ((ร hlt[@highlight_ga.ga_len].sg_name_u =) (vim_strsave_up name))

        (ยง @highlight_ga.ga_len++)

        (. @highlight_ga ga_len) ;; ID is index plus one
    ))

;; Translate a group ID to highlight attributes.

(defn- #_int syn_id2attr [#_int hl_id]
    (ยง
        ((ร hl_id =) (syn_get_final_id hl_id))

        ((ร hl_group_C[] hlt =) (. @highlight_ga ga_data))
        ((ร hl_group_C sgp =) (ยง hlt[hl_id - 1]))                        ;; index is ID minus one

        (if (< 1 @t_colors) (. sgp sg_cterm_attr) (. sgp sg_term_attr))
    ))

;; Translate a group ID to the final group ID (following links).

(defn- #_int syn_get_final_id [#_int hl_id]
    (ยง
        (if (or (< (. @highlight_ga ga_len) hl_id) (< hl_id 1))
            ((ร RETURN) 0)                                           ;; Can be called from eval!!
        )

        ((ร hl_group_C[] hlt =) (. @highlight_ga ga_data))

        ;; Follow links until there is no more.
        ;; Look out for loops!  Break after 100 links.

        ((ร FOR) (ร (ยง int count = 100) (ยง 0 <= --count) nil)
            ((ร hl_group_C sgp =) (ยง hlt[hl_id - 1]))                    ;; index is ID minus one
            (if (or (zero? (. sgp sg_link)) (< (. @highlight_ga ga_len) (. sgp sg_link)))
                (ร BREAK)
            )
            ((ร hl_id =) (. sgp sg_link))
        )

        hl_id
    ))

;; The HL_FLAGS must be in the same order as the HLF_ enums!
;; When changing this also adjust the default for 'highlight'.

(final int* #_"[/*HLF_COUNT*/]" hl_flags
    [
        \8, \@, \e, \i, \l, \m, \M, \n, \N, \r, \s, \S, \c, \t, \v, \w, \-, \!, \., \o
    ])

;; Translate the 'highlight' option into attributes in highlight_attr[] and
;; set up the user highlights User1..9.  If FEAT_STL_OPT is in use, a set of
;; corresponding highlights to use on top of HLF_SNC is computed.
;; Called only when the 'highlight' option has been changed and upon first
;; screen redraw after any :highlight command.
;; Return false when an invalid flag is found in 'highlight'; true otherwise.

(defn- #_boolean highlight_changed []
    (ยง
        ((ร int id_SNC =) -1)
        ((ร int id_S =) -1)

        (reset! need_highlight_changed false)

        ;; Clear all attributes.

        ((ร FOR) (ร (ยง int hlf = 0) (< hlf HLF_COUNT) (ยง hlf++))
            ((ร @highlight_attr[hlf] =) 0)
        )

        ;; First set all attributes to their default value.
        ;; Then use the attributes from the 'highlight' option.

        ((ร FOR) (ร (ยง int i = 0) (< i 2) (ยง i++))
            (ร Bytes p)
            (if (non-zero? i)
                ((ร p =) @p_hl)
                ((ร p =) (get_highlight_default))
            )
            (if (nil? p)      ;; just in case
                (ร CONTINUE)
            )

            (while (ยง p.at(0) != NUL)
                (ร int hlf)
                ((ร FOR) (ร (ยง hlf = 0) (< hlf HLF_COUNT) (ยง hlf++))
                    (if (== (ยง hl_flags[hlf]) (.at p 0))
                        (ร BREAK)
                    )
                )
                ((ร p =) (ยง p.plus(1)))
                (if (or (== hlf HLF_COUNT) (eos? p))
                    ((ร RETURN) false)
                )

                ;; Allow several hl_flags to be combined, like "bu" for bold-underlined.

                ((ร int attr =) 0)
                ((ร FOR) (ร (ยง  ) (ยง p.at(0) != NUL && p.at(0) != (byte \,)) (ยง p = p.plus(1)))            ;; parse upto comma
                    (if (vim_iswhite (ยง p.at(0)))           ;; ignore white space
                        (ร CONTINUE)
                    )

                    (if (< HL_ALL attr)  ;; Combination with ':' is not allowed.
                        ((ร RETURN) false)
                    )

                    ((ร SWITCH) (ยง p.at(0))
                        ((ร CASE) (byte \b))
                        (ยง
                            ((ร attr |=) HL_BOLD)
                            (ร BREAK)
                        )
                        ((ร CASE) (byte \i))
                        (ยง
                            ((ร attr |=) HL_ITALIC)
                            (ร BREAK)
                        )
                        ((ร CASE) (byte \-))
                        ((ร CASE) (byte \n))                       ;; no highlighting
                        (ยง
                            (ร BREAK)
                        )
                        ((ร CASE) (byte \r))
                        (ยง
                            ((ร attr |=) HL_INVERSE)
                            (ร BREAK)
                        )
                        ((ร CASE) (byte \s))
                        (ยง
                            ((ร attr |=) HL_STANDOUT)
                            (ร BREAK)
                        )
                        ((ร CASE) (byte \u))
                        (ยง
                            ((ร attr |=) HL_UNDERLINE)
                            (ร BREAK)
                        )
                        ((ร CASE) (byte \c))
                        (ยง
                            ((ร attr |=) HL_UNDERCURL)
                            (ร BREAK)
                        )
                        ((ร CASE) (byte \:))
                        (ยง
                            ((ร p =) (ยง p.plus(1)))                        ;; highlight group name
                            (if (or (non-zero? attr) (eos? p))      ;; no combinations
                                ((ร RETURN) false)
                            )
                            ((ร Bytes end =) (ยง vim_strchr(p, (byte \,))))
                            (if (nil? end)
                                ((ร end =) (ยง p.plus(STRLEN(p))))
                            )
                            ((ร int id =) (ยง syn_check_group(p, BDIFF(end, p))))
                            (if (zero? id)
                                ((ร RETURN) false)
                            )
                            ((ร attr =) (syn_id2attr id))
                            ((ร p =) (ยง end.minus(1)))
                            (cond (== hlf HLF_SNC)
                            (ยง
                                ((ร id_SNC =) (syn_get_final_id id))
                            )
                            (== hlf HLF_S)
                            (ยง
                                ((ร id_S =) (syn_get_final_id id))
                            ))
                            (ร BREAK)
                        )
                        (ร DEFAULT)
                        (ยง
                            ((ร RETURN) false)
                        )
                    )
                )
                ((ร @highlight_attr[hlf] =) attr)

                ((ร p =) (skip_to_option_part p))             ;; skip comma and spaces
            )
        )

        ;; Setup the user highlights
        ;;
        ;; Temporarily utilize 10 more hl entries.  Have to be in there
        ;; simultaneously in case of table overflows in get_attr_entry()

        ((ร hl_group_C[] hlt =) (ยง @highlight_ga.ga_grow(10)))

        ((ร int n =) (. @highlight_ga ga_len))
        ((ร FOR) (ร (ยง int i = 0) (< i 10) (ยง i++))
            ((ร hlt[n + i] =) (ยง ยง_hl_group_C()))
        )

        ;; Make sure id_S is always valid to simplify code below.
        (when (zero? id_S)
            ((ร hlt[n + 9].sg_term =) (ยง @highlight_attr[HLF_S]))
            ((ร id_S =) (+ n 10))
        )

        ((ร FOR) (ร (ยง int i = 0) (< i 9) (ยง i++))
            ((ร Bytes userhl =) (ยง new Bytes(10)))
            (ยง libC.sprintf(userhl, (u8 "User%d"), i + 1))

            ((ร int id =) (syn_name2id userhl))
            (when (non-zero? id)
                (cond (zero? id_SNC)
                (ยง
                    ((ร hlt[n + i].sg_term =) (ยง @highlight_attr[HLF_SNC]))
                    ((ร hlt[n + i].sg_cterm =) (ยง @highlight_attr[HLF_SNC]))
                    ((ร hlt[n + i].sg_gui =) (ยง @highlight_attr[HLF_SNC]))
                )
                :else
                (ยง
                    (COPY_hl_group (ยง hlt[n + i]), (ยง hlt[id_SNC - 1]))
                ))
                ((ร hlt[n + i].sg_link =) 0)

                ;; Apply difference between UserX and HLF_S to HLF_SNC.
; %%            ((ร hlt[n + i].sg_term ^=) (ยง (hlt[id - 1].sg_term ^ hlt[id_S - 1].sg_term)))
                (if (BNE (ยง hlt[id - 1].sg_start), (ยง hlt[id_S - 1].sg_start))
                    ((ร hlt[n + i].sg_start =) (ยง hlt[id - 1].sg_start))
                )
                (if (BNE (ยง hlt[id - 1].sg_stop), (ยง hlt[id_S - 1].sg_stop))
                    ((ร hlt[n + i].sg_stop =) (ยง hlt[id - 1].sg_stop))
                )
; %%            ((ร hlt[n + i].sg_cterm ^=) (ยง (hlt[id - 1].sg_cterm ^ hlt[id_S - 1].sg_cterm)))
                (if (ยง hlt[id - 1].sg_cterm_fg != hlt[id_S - 1].sg_cterm_fg)
                    ((ร hlt[n + i].sg_cterm_fg =) (ยง hlt[id - 1].sg_cterm_fg))
                )
                (if (ยง hlt[id - 1].sg_cterm_bg != hlt[id_S - 1].sg_cterm_bg)
                    ((ร hlt[n + i].sg_cterm_bg =) (ยง hlt[id - 1].sg_cterm_bg))
                )
; %%            ((ร hlt[n + i].sg_gui ^=) (ยง (hlt[id - 1].sg_gui ^ hlt[id_S - 1].sg_gui)))
                ((ร @highlight_ga.ga_len =) (ยง n + i + 1))
                (set_hl_attr (+ n i))         ;; at long last we can apply
            )
        )

        ((ร @highlight_ga.ga_len =) n)
        ((ร FOR) (ร (ยง int i = 0) (< i 10) (ยง i++))
            ((ร hlt[n + i] =) null)
        )

        true
    ))

;;; ============================================================================================== VimY

;; oops!

(final cmdname_C* cmdnames
    [
        (->cmdname_C (u8 "close"),         ex_close,         (| BANG RANGE NOTADR COUNT CMDWIN),                           ADDR_WINDOWS),
        (->cmdname_C (u8 "fixdel"),        ex_fixdel,           CMDWIN,                                                    ADDR_LINES),
        (->cmdname_C (u8 "only"),          ex_only,          (| BANG NOTADR RANGE COUNT),                                  ADDR_WINDOWS),
        (->cmdname_C (u8 "retab"),         ex_retab,         (| RANGE DFLALL BANG WORD1 CMDWIN),                           ADDR_LINES),
        (->cmdname_C (u8 "substitute"),    ex_sub,           (| RANGE EXTRA CMDWIN),                                       ADDR_LINES),
        (->cmdname_C (u8 "set"),           ex_set,           (| EXTRA CMDWIN),                                             ADDR_LINES),
        (->cmdname_C (u8 "stop"),          ex_stop,          (| BANG CMDWIN),                                              ADDR_LINES),
        (->cmdname_C (u8 "suspend"),       ex_stop,          (| BANG CMDWIN),                                              ADDR_LINES),
        (->cmdname_C (u8 "syncbind"),      ex_syncbind,         0,                                                         ADDR_LINES),
    ])

;;; ============================================================================================== VimG

;; Main loop: Execute Normal mode commands until exiting Vim.
;; Also used to handle commands in the command-line window, until the window is closed.

(defn- #_void main_loop [#_boolean cmdwin]
    ;; cmdwin: true when working in the command-line window
    (ยง
        ((ร #_"/*volatile*//*transient */"boolean previous_got_int =) false)     ;; "got_int" was true

        ((ร long conceal_old_cursor_line =) 0)
        ((ร long conceal_new_cursor_line =) 0)
        ((ร boolean conceal_update_lines =) false)

        ((ร oparg_C oa =) (ยง ยง_oparg_C()))                     ;; operator arguments

        (while (ยง !cmdwin || @cmdwin_result == 0)
            (when (stuff_empty)
                (if @need_wait_return                   ;; if wait_return still needed ...
                    (wait_return FALSE))                 ;; ... call it now
                (when (and @need_start_insertmode (goto_im) (not @VIsual_active))
                    (reset! need_start_insertmode false)
                    (stuffReadbuff (u8 "i"))                 ;; start insert mode next
                    ;; skip the fileinfo message now,
                    ;; because it would be shown after insert mode finishes!
                    (reset! need_fileinfo false)
                )
            )

            ;; Reset "got_int" now that we got back to the main loop.  Except when inside
            ;; a ":g/pat/cmd" command, then the "got_int" needs to abort the ":g" command.
            ;; For ":g/pat/vi" we reset "got_int" when used once.  When used
            ;; a second time we go back to Ex mode and abort the ":g" command.
            (cond @got_int
            (ยง
                (if (not @quit_more)
                    (vgetc))                ;; flush all buffers
                (reset! got_int false)

                ((ร previous_got_int =) true)
            )
            :else
            (ยง
                ((ร previous_got_int =) false)
            ))

            (reset! msg_scroll false)
            (reset! quit_more false)

            ;; If skip redraw is set (for ":" in wait_return()), don't redraw now.
            ;; If there is nothing in the stuff_buffer or do_redraw is true, update cursor and redraw.

            (cond @skip_redraw
            (ยง
                (reset! skip_redraw false)
            )
            (or @do_redraw (stuff_empty))
            (ยง
                ;; Trigger CursorMoved if the cursor moved.
                (when (and (not @finish_op) (< 0 @(.. @curwin w_options wo_cole)) (not (eqpos @last_cursormoved, (. @curwin w_cursor))))
                    ((ร conceal_old_cursor_line =) (. @last_cursormoved lnum))
                    ((ร conceal_new_cursor_line =) (.. @curwin w_cursor lnum))
                    ((ร conceal_update_lines =) true)

                    (COPY_pos @last_cursormoved, (. @curwin w_cursor))
                )

                ;; Before redrawing, make sure w_topline is correct,
                ;; and w_leftcol if lines don't wrap, and w_skipcol if lines wrap.

                (update_topline)
                (validate_cursor)

                (cond @VIsual_active
                (ยง
                    (update_curbuf INVERTED)    ;; update inverted part
                )
                (non-zero? @must_redraw)
                (ยง
                    (update_screen 0)
                )
                (or @redraw_cmdline @clear_cmdline)
                (ยง
                    (showmode)
                ))
                (redraw_statuslines)
                ;; display message after redraw
                (when (non-nil? @keep_msg)
                    ;; msg_attr_keep() will set "keep_msg" to null, must free the string here.
                    ;; Don't reset "keep_msg", msg_attr_keep() uses it to check for duplicates.
                    (msg_attr @keep_msg, @keep_msg_attr)
                )
                (when @need_fileinfo          ;; show file info after redraw
                    (fileinfo 0, false)
                    (reset! need_fileinfo false)
                )

                (reset! emsg_on_display false)    ;; can delete error message now
                (reset! did_emsg false)
                (reset! msg_didany false)         ;; reset lines_left in msg_start()
                (may_clear_sb_text)        ;; clear scroll-back text on next msg
                (showruler false)

                (when (and conceal_update_lines (or (!= conceal_old_cursor_line conceal_new_cursor_line) (conceal_cursor_line @curwin) @need_cursor_line_redraw))
                    (if (and (!= conceal_old_cursor_line conceal_new_cursor_line) (<= conceal_old_cursor_line (.. @curbuf b_ml ml_line_count)))
                        (update_single_line @curwin, conceal_old_cursor_line))
                    (update_single_line @curwin, conceal_new_cursor_line)
                    ((ร @curwin.w_valid &=) (ยง ~VALID_CROW))
                )
                (setcursor)
                (cursor_on)

                (reset! do_redraw false)
            ))

            ;; Update w_curswant if w_set_curswant has been set.
            ;; Postponed until here to avoid computing w_virtcol too often.

            (update_curswant)

            ;; Get and execute a normal mode command.

            (normal_cmd oa, true)
        )
    ))

;; Exit properly.
(defn- #_void getout [#_int exitval]
    (ยง
        (reset! exiting true)

        ;; Position the cursor on the last screen line, below all the text.
        (windgoto (- (int @Rows) 1), 0)

        (when @did_emsg
            ;; give the user a chance to read the (error) message
            (reset! no_wait_return FALSE)
            (wait_return FALSE)
        )

        ;; Position the cursor again, the autocommands may have moved it.
        (windgoto (- (int @Rows) 1), 0)

        (mch_exit exitval)
    ))

;;; ============================================================================================== VimZ

(defn #_void -main [& #_String* args]
    (ยง
        (reset! starttime (ยง libC._time()))

        ;; Allocate the first window and buffer.
        ;; Can't do anything without it, exit when it fails.

        (win_alloc_first)

        (init_yank)                            ;; init yank buffers

        ;; Set the default values for the options.

        (set_init_1)

        ;; Don't redraw until much later.
        (swap! redrawingDisabled inc)

        ;; mch_init() sets up the terminal (window) for use.
        ;; This must be done after resetting full_screen, otherwise it may move the cursor (MSDOS).
        ;; Note that we may use mch_exit() before mch_init()!

        (mch_init)

        (set_term)                             ;; set terminal capabilities (will set full_screen)
        (screen_start)                         ;; don't know where cursor is now

        ;; Set the default values for the options that use Rows and Columns.

        (ui_get_shellsize)                     ;; inits Rows and Columns
        (win_init_size)

        (reset! cmdline_row (ยง (int)(@Rows - @p_ch)))
        (reset! msg_row @cmdline_row)
        (screenalloc false)                     ;; allocate screen buffers

        (set_init_2)

        (reset! msg_scroll true)
        (reset! no_wait_return TRUE)

        ;; Start putting things on the screen.
        ;; Scroll screen down before drawing over it.
        ;; Clear screen now, so file message will not be cleared.

        (reset! starting NO_BUFFERS)
        (reset! no_wait_return FALSE)
        (reset! msg_scroll false)

        ;; When switching screens and something caused a message from a vimrc script,
        ;; need to output an extra newline on exit.
        (if (and (or @did_emsg @msg_didout) (non-eos? @T_TI))
            (reset! newline_on_exit true))

        ;; When done something that is not allowed or error message call wait_return.
        ;; This must be done before starttermcap(), because it may switch to another screen.
        ;; It must be done after settmode(TMODE_RAW), because we want to react on a single key stroke.
        ;; Call settmode and starttermcap here, so the T_KS and T_TI may be defined by set_term().

        (settmode TMODE_RAW)

        (if (or @need_wait_return @msg_didany)
            (wait_return TRUE))

        (starttermcap)                         ;; start termcap if not done by wait_return()

        (if @scroll_region
            (scroll_region_reset))              ;; in case Rows changed
        (scroll_start)                         ;; may scroll the screen to the right position

        (screenclear)                      ;; clear screen

        (reset! no_wait_return TRUE)

        (setpcmark)

        ;; If opened more than one window, start editing files in the other windows.

        ;; make the first window the current window
        (win_enter @firstwin)

        (reset! redrawingDisabled 0)
        (redraw_all_later NOT_VALID)
        (reset! no_wait_return FALSE)
        (reset! starting 0)

        ;; start in insert mode
        (if @p_im
            (reset! need_start_insertmode true))

        ;; If ":startinsert" command used, stuff a dummy command to be
        ;; able to call normal_cmd(), which will then start Insert mode.
        (if (non-zero? @restart_edit)
            (stuffcharReadbuff K_NOP))

        ;; Call the main command loop.  This never returns.

        (main_loop false)

        0
    ))
