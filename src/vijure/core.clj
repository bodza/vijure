(ns vijure.core
    (:refer-clojure :exclude [boolean byte short int long])
    (:require [org.baznex.imports :refer [import-static]])
    (:import [java.util Arrays])
    (:gen-class))

(org.baznex.imports/rename {vijure.VimA$Bytes 'Bytes})

(import-static vijure.VimA char_u u8 BEQ BNE BDIFF BLT BLE asc_toupper asc_tolower MEMCMP ACOPY BCOPY AFILL BFILL STRCAT STRCMP STRCPY STRLEN STRNCASECMP STRNCMP STRNCPY)
; %% (import-static vijure.VimB SIGHUP SIGQUIT SIGILL SIGTRAP SIGABRT SIGFPE SIGBUS SIGSEGV SIGSYS SIGALRM SIGTERM SIGVTALRM SIGPROF SIGXCPU SIGXFSZ SIGUSR1 SIGUSR2 SIGINT SIGWINCH SIGTSTP SIGPIPE)

(defmacro ยง [& _])
(defmacro ร [& _])

(defmacro def- [symbol & init] (list* 'def (vary-meta symbol assoc :private true) init))

(def- null nil)

(defmacro != [x y] `(not (== ~x ~y)))

(defmacro non-nil? [x] `(not (nil? ~x)))
(defmacro non-zero? [x] `(not (zero? ~x)))

(defmacro ... [a i] `(~a ~i))

(defmacro flag? [x y] `(non-zero? (& ~x ~y)))
(defmacro non-flag? [x y] `(zero? (& ~x ~y)))

(def- % rem)

(def- & bit-and)
(def- | bit-or)
(def- << bit-shift-left)
(def- >>> unsigned-bit-shift-right)

(defn- boolean? [b] (instance? Boolean b))

(def- byte! unchecked-byte)

(defn- boolean ([] (boolean nil)) ([b] (cond (nil? b) false (boolean? b) b :else (throw (IllegalArgumentException. (str "fuzzy boolean " b))))))
(defn- byte    ([] (byte nil))    ([n] (clojure.core/byte (if (nil? n) 0 n))))
(defn- short   ([] (short nil))   ([n] (clojure.core/short (if (nil? n) 0 n))))
(defn- int     ([] (int nil))     ([n] (clojure.core/int (if (nil? n) 0 n))))
(defn- long    ([] (long nil))    ([n] (clojure.core/long (if (nil? n) 0 n))))
(defn- object  ([] (object nil))  ([o] o))

(def- maybean int)

(defmacro def'type* [& types] (cons 'do
    (map (fn [t] (let [t* (symbol (str t \*))]
        `(defn- ~t* [v#] (cond (sequential? v#) (mapv ~t v#) (number? v#) (recur (repeat v# nil)) :else (assert (nil? v#) (str "fuzzy " '~t* " " v#))))
    )) types)))
(def'type* boolean byte byte* int int* long object object*)

(def- frag_C* object*)

(def- C (map #(symbol (str % "_C")) '(barray buffblock buffer buffheader cmdline_info fmark fragnode frame lpos match matchitem memline msgchunk nfa_pim nfa_state oparg pos posmatch reg_extmatch regmatch regmmatch regprog regsave regsub regsubs save_se soffset termios typebuf u_entry u_header u_link visualinfo window winopt yankreg)))

(def- C* (map #(symbol (str % "_C*")) '(attrentry backpos btcap cmdname decomp digr fmark frag frame hl_group key_name linepos llpos lpos modmasktable multipos nfa_state nfa_thread nv_cmd pos save_se signalinfo spat termcode typebuf vimoption wline yankreg)))

(def- C** (map #(symbol (str % "_C**")) '(histentry)))

(def- F (map #(symbol (str % "_F")) '(ex_func nv_func)))

(let [I '(byte byte! byte* byte** int int* long maybean) O (concat '(Bytes Object) C) O* (concat '(Bytes* Bytes*') C*)
      T (merge (zipmap I I) (zipmap O (repeat 'object)) (zipmap O* (repeat 'object*)))]
    (letfn [(f [t s] (if s (cons `(def- ~(first s) (~t ~(second s))) (f t (nnext s))) '(nil)))]
        (defmacro final [t & s] (let [t' (T t)] (assert t' (str "unexpected type: " t)) (when s (cons 'do (f t' s)))))))

(let [I '(boolean boolean* int int* int** long long* maybean) O (cons 'Bytes C) O* (concat '(Bytes* Object*) C*) O** C**
      T (merge (zipmap I I) (zipmap O (repeat 'object)) (zipmap O* (repeat 'object*)) (zipmap O** (repeat 'object**)))]
    (letfn [(f [t s] (if s (cons `(def- ~(first s) (atom (~t ~(second s)))) (f t (nnext s))) '(nil)))]
        (defmacro atom! [t & s] (let [t' (T t)] (assert t' (str "unexpected type: " t)) (when s (cons 'do (f t' s)))))))

(let [I '#{boolean byte int long} A '(byte* int*) O (concat '(Bytes Object) C F) O* (concat '(Bytes* Object*) C*) O** C**
      T (merge (zipmap I I) (zipmap A A) (zipmap O (repeat 'object)) (zipmap O* (repeat 'object*)) (zipmap O** (repeat 'object**)))]
    (letfn [(f' [[f t n & [v]]] (let [t' (T t)] (assert t' (str "unexpected type: " t))
            (case f atom' `[~n (atom (~t' ~v))]
                    field `[~(if (I t) (vary-meta n assoc :tag t) n) (~t' ~v)])))]
        (defmacro class! [c [& fs] & _] (let [fs' (map f' fs)]
            `(do (defrecord ~c ~(mapv first fs') ~@_)
                 (defn- ~(symbol (str "NEW_" c)) [] (new ~c ~@(map second fs'))) nil)))))

;;; ============================================================================================== VimA

(final maybean FALSE 0, TRUE 1, MAYBE 2)

#_(final Bytes VIMVERSION (u8 "VIM - Vi IMproved 7.4.692"))

(declare alphaOrd lowerOrd upperOrd rot13 ctrl-key is-special TERMCAP2KEY KEY2TERMCAP0 KEY2TERMCAP1 KB-SECOND KB-THIRD toSpecial vim-iswhite COPY-pos ARRAY-pos MIN1-lpos COPY-lpos ARRAY-lpos COPY--lpos COPY-regmmatch COPY-fmark ARRAY-fmark COPY-visualinfo COPY-buffblock COPY-buffheader ZER0-attrentry COPY-attrentry COPY-wline ARRAY-wline COPY-frame COPY-llpos ARRAY-llpos asc-islower asc-isupper asc-isalpha asc-isalnum asc-iscntrl asc-isgraph asc-isprint asc-ispunct hl-attr ltpos eqpos ltoreq clearpos lineempty bufempty mch-write mch-inchar handle-resize mch-delay sig-winch catch-sigint catch-sigpwr may-core-dump deathtrap mch-suspend mch-init set-signals catch-int-signal reset-signals catch-signals vim-handle-signal exit-scroll mch-exit mch-settmode get-stty mch-get-shellsize mch-set-shellsize mch-new-shellsize mch-breakcheck waitForChar realWaitForChar msg msg-attr msg-attr-keep msg-strtrunc trunc-string smsg smsg-attr emsg-not-now emsg emsg2 emsg-invreg msg-trunc-attr msg-may-trunc wait-return hit-return-msg set-keep-msg msg-start msg-starthere msg-putchar msg-putchar-attr msg-outtrans msg-outtrans-attr msg-outtrans-len msg-outtrans-len-attr screen-puts-mbyte msg-puts msg-puts-title msg-puts-attr msg-puts-attr-len msg-puts-display msg-scroll-up inc-msg-scrolled store-sb-text may-clear-sb-text clear-sb-text show-sb-text msg-sb-start disp-sb-line t-puts msg-use-printf msg-puts-printf do-more-prompt msg-screen-putchar msg-moremsg repeat-message msg-check-screen msg-clr-eos msg-clr-eos-force msg-clr-cmdline msg-end msg-check give-warning display-confirm-msg new-vimoption bool-opt long-opt utf8-opt set-init-1 set-option-default set-options-default set-number-default set-init-2 do-set illegal-char didset-options check-options check-buf-options clear-string-option check-string-option did-set-string-option check-colorcolumn set-bool-option set-num-option check-redraw findoption get-highlight-default showoneopt comp-col get-varp win-copy-options copy-winopt check-win-options check-winopt clear-winopt paste-option-changed fill-breakat-flags check-opt-strings opt-strings-flags can-bs get-sw-value get-sts-value find-mps-values briopt-check do-ascii linelen ex-retab ex-fixdel ex-sub do-sub-msg COPY-cmdline-info COPY-histentry ARRAY-histentry getcmdline text-locked text-locked-msg cmdline-charsize set-cmdspos set-cmdspos-cursor correct-cmdspos getexline alloc-cmdbuff realloc-cmdbuff draw-cmdline putcmdline unputcmdline put-on-cmdline save-cmdline restore-cmdline save-cmdline-alloc restore-cmdline-alloc cmdline-paste cmdline-paste-str redrawcmdline redrawcmdprompt redrawcmd compute-cmdrow cursorcmd gotocmdline hist-char2type init-history clear-hist-entry in-history add-to-history ex-window do-cmdline-cmd do-cmdline current-win-nr do-one-cmd append-command find-command skip-range get-address invalid-range correct-range check-nextcmd ex-close ex-win-close ex-only ex-stop ex-syncbind do-sleep ex-set eval-to-string profile-setlimit profile-passed-limit can-abandon find--command normal-cmd do-pending-operator op-colon op-function check-visual-highlight end-visual-mode reset-VIsual-and-resel reset-VIsual find-ident-under-cursor find-ident-at-pos prep-redo-cmd prep-redo checkclearop checkclearopq clearop clearopbeep unshift-special clear-showcmd add-to-showcmd add-to-showcmd-c del-from-showcmd push-showcmd pop-showcmd display-showcmd do-check-scrollbind check-scrollbind nv-ignore nv-nop nv-error nv-addsub nv-page nv-gd nv-screengo nv-scroll-line scroll-redraw nv-zet nv-exmode nv-colon nv-ctrlg nv-ctrlh nv-clear nv-ctrlo nv-hat nv-Zet do-nv-ident nv-ident get-visual-text nv-scroll nv-right nv-left nv-up nv-down nv-end nv-dollar nv-search nv-next normal-search nv-csearch nv-brackets nv-percent nv-brace nv-mark nv-findpar nv-undo nv-kundo nv-replace v-swap-corners nv-Replace nv-vreplace n-swapchar nv-cursormark v-visop nv-subst nv-abbrev nv-optrans nv-gomark nv-pcmark nv-regname nv-visual start-selection may-start-select n-start-visual-mode nv-window nv-suspend nv-g-cmd n-opencmd nv-dot nv-redo nv-Undo nv-tilde nv-operator nv-lineop nv-home nv-pipe nv-bck-word nv-wordcmd adjust-cursor nv-beginline adjust-for-sel unadjust-for-sel nv-select nv-goto nv-normal nv-esc nv-edit invoke-edit nv-object nv-record nv-at nv-halfpage nv-join nv-put nv-open nv-drop nv-cursorhold COPY-yankreg ARRAY-yankreg get-op-type op-on-lines get-op-char get-extra-op-char op-shift shift-line shift-block block-insert op-reindent get-expr-register get-expr-line valid-yank-reg get-yank-register get-register put-register do-record stuff-yank do-execreg put-reedit-in-typebuf put-in-typebuf insert-reg stuffescaped get-spec-reg cmdline-paste-reg adjust-clip-reg may-get-selection op-delete mb-adjust-opend op-replace op-tilde swapchars swapchar op-insert op-change init-yank op-yank yank-copy-line do-put adjust-cursor-eol do-join block-prep do-addsub line-count-info cursor-pos-info setmark setmark-pos setpcmark checkpcmark movemark movechangelist getmark-buf getmark getmark-buf-fnum getnextmark check-mark clrallmarks one-adjust one-adjust-nodel mark-adjust col-adjust mark-col-adjust cleanup-jumplist copy-jumplist set-last-cursor free-buff get-buffcont get-recorded get-inserted add-buff add-num-buff add-char-buff read-readbuf read-readbuffers start-stuff stuff-empty typeahead-noflush flush-buffers resetRedobuff cancelRedo appendToRedobuff appendToRedobuffLit appendCharToRedobuff appendNumberToRedobuff stuffReadbuff stuffRedoReadbuff stuffReadbuffLen stuffcharReadbuff stuffnumReadbuff init-redo read-redo start-redo start-redo-ins stop-redo-ins init-typebuf ins-typebuf ins-char-typebuf typebuf-changed del-typebuf gotchars may-sync-undo before-blocking updatescript vgetc safe-vgetc plain-vgetc vpeekc char-avail vungetc vgetorpeek inchar fix-input-buffer input-available vim-strsave-escape-special vim-unescape-special edit ins-redraw ins-ctrl-v edit-putchar edit-unputchar change-indent truncate-spaces backspace-until-column del-char-after-col get-literal insert-special isspecial insertchar redo-literal start-arrow stop-arrow stop-insert set-last-insert add-char2buf beginline oneright oneleft cursor-up cursor-down stuff-inserted get-last-insert get-last-insert-save replace-push replace-push-mb replace-pop replace-join replace-pop-ins mb-replace-pop-ins replace-flush replace-do-bs ins-reg ins-ctrl-g ins-ctrl-hat ins-esc ins-start-select ins-insert ins-ctrl-o ins-shift ins-del ins-bs-one ins-bs ins-left ins-home ins-end ins-s-left ins-right ins-s-right ins-up ins-pageup ins-down ins-pagedown ins-drop ins-tab ins-eol ins-digraph ins-copychar ins-ctrl-ey ins-try-si get-nolist-virtcol do-insert-char-pre with-nl Magic un-Magic is-Magic no-Magic toggle-Magic re-op re-next operand operand-min operand-max operand-cmp re-multi-type backslash-trans get-char-class init-class-tab ri-digit ri-hex ri-octal ri-word ri-head ri-alpha ri-lower ri-upper ri-white re-multiline re-lookbehind get-equi-class reg-equi-class get-coll-element get-cpo-flags skip-anyof skip-regexp bt-regcomp regcomp-start reg regbranch regconcat regpiece regatom do-multibyte use-multibytecode regnode regc regmbc reginsert reginsert-nr reginsert-limits re-put-long regtail regoptail initchr save-parse-state restore-parse-state peekchr skipchr skipchr-keepstart getchr ungetchr gethexchrs getdecchrs getoctchrs coll-get-char read-limits COPY-regsave ARRAY-save-se create-regstack create-backpos reg-getline bt-regexec-nl bt-regexec-multi bt-regexec-both make-extmatch regtry reg-prev-class reg-match-visual regmatch push-regitem pop-regitem drop-regbehind drop-regstar regrepeat regnext prog-magic-wrong cleanup-subexpr cleanup-zsubexpr save-subexpr restore-subexpr reg-nextline reg-save reg-restore reg-save-equal save-se-multi save-se-one save-se restore-se re-num-cmp match-with-backref re-mult-next mb-decompose cstrncmp cstrchr regtilde vim-regsub vim-regsub-multi vim-regsub-both nfa-regcomp-start nfa-get-reganch nfa-get-regstart nfa-get-match-text grow-post-array nfa-recognize-char-class emc1 emc2 nfa-emit-equi-class nfa-regatom nfa-do-multibyte nfa-regpiece nfa-regconcat nfa-regbranch nfa-reg re2post alloc-state nfa-max-width COPY-frag alloc-frag fr-single fr-patch fr-append new-nfa-stack st-push st-pop st-error post2nfa nfa-postprocess MIN1-multipos COPY-multipos ARRAY-multipos COPY--multipos ZER0-linepos COPY-linepos ARRAY-linepos COPY--linepos COPY-regsub COPY-regsubs COPY-nfa-pim COPY-nfa-thread ARRAY-nfa-thread ARRAY-nfa-list copy-pim clear-sub copy-sub copy-sub-off copy-ze-off sub-equal has-state-with-pos pim-equal match-follows state-in-list addstate addstate-here check-char-class match-backref match-zref nfa-save-listids nfa-restore-listids nfa-re-num-cmp recursive-regmatch failure-chance skip-to-start find-match-text nfa-regmatch nfa-regtry nfa-regexec-both nfa-regcomp nfa-regexec-nl nfa-regexec-multi vim-regcomp report-re-switch vim-regexec-both vim-regexec-prog vim-regexec vim-regexec-nl vim-regexec-multi COPY-soffset new-spat search-regcomp get-search-pat save-re-pat ignorecase pat-has-uppercase last-search-pat last-pat-prog searchit first-submatch do-search searchc findmatch check-prevcol findmatchlimit check-linecomment showmatch cls fwd-word bck-word end-word bckend-word skip-chars back-in-line current-word current-block find-next-quote find-prev-quote current-quote current-search is-one-char linewhite ml-open ml-get ml-get-pos ml-get-curline ml-get-cursor ml-get-buf ml-append ml-replace ml-delete close-buffer newBuffer fileinfo col-print get-rel-pos buf-spname set-chartab reset-chartab get-chartab init-chartab buf-init-chartab trans-characters transchar transchar-byte transchar-nonprint transchar-hex nr2hex mb-byte2cells mb-char2cells mb-ptr2cells mb-string2cells win-buf-chartabsize chartabsize linetabsize linetabsize-col win-linetabsize vim-isIDc vim-iswordc us-iswordb us-iswordp vim-isfilec vim-isprintc lbr-chartabsize lbr-chartabsize-adv win-lbr-chartabsize win-nolbr-chartabsize in-win-border getvcol getvcol-nolist getvvcol getvcols skipwhite skipdigits asc-isdigit asc-isodigit asc-isxdigit getdigits vim-str2nr hex2nr digr do-digraph get-digraph getexactdigraph getdigraph us-byte2len mb-byte2len us-get-class intable utf-char2cells us-ptr2cells us-string2cells utf-off2cells us-ptr2char us-safe-read-char-adv us-ptr2char-adv us-ptr2char-cc us-ptr2char-cc-len utfc-char2bytes us-ptr2len us-ptr2len-len us-ptr2len-cc us-ptr2len-cc-len utf-char2len utf-char2bytes utf-iscomposing utf-printable utf-class utf-convert utf-fold utf-tolower utf-toupper utf-islower utf-isupper us--strnicmp us-strnicmp show-utf8 us-head-off us-off-next us-tail-off utf-find-illegal mb-adjust-pos us-ptr-back us-prevptr us-charlen mb-lefthalve mb-fix-col get-indent get-indent-str set-indent copy-indent get-breakindent-win cin-is-cinword open-line plines plines-win plines-win-nofold plines-win-col plines-m-win ins-bytes ins-bytes-len ins-char ins-char-bytes ins-str del-char del-chars del-bytes truncate-line del-lines gchar-pos gchar-cursor inindent skip-to-option-part changed changed-bytes changed-one-line appended-lines appended-lines-mark deleted-lines deleted-lines-mark changed-lines changed-lines-buf changed-common unchanged check-status ask-yesno get-keystroke msgmore beep-flush vim-beep prepare-to-exit preserve-exit line-breakcheck fast-breakcheck goto-im virtual-active getviscol getviscol2 coladvance-force coladvance getvpos coladvance2 inc-cursor incp incl dec-cursor decp decl get-cursor-rel-lnum check-cursor-lnum check-cursor-col check-cursor-col-win check-cursor adjust-cursor-col leftcol-changed STRDUP STRNDUP vim-strsave-escaped vim-strsave-escaped-ext vim-strup vim-strsave-up copy-spaces copy-chars vim-strncpy vim-strcat copy-option-part vim-strchr vim-strbyte vim-strrchr vim-isspace simplify-key handle-x-keys get-special-key-name find-special-key-in-table get-real-state emsg3 emsgn trigger-cursorhold u-save-cursor u-save u-savesub u-inssub u-savedel undo-allowed get-undolevel u-savecommon u-undo u-redo u-doit undo-time u-undoredo u-undo-end u-sync u-add-time u-get-headentry u-getbot u-freeheader u-freebranch u-freeentries u-saveline u-clearline u-undoline parse-builtin-tcap set-term out-flush out-flush-check out-char out-char-nf _addfmt _tgoto _tputs out-str-nf out-str term-windgoto term-cursor-right term-append-lines term-delete-lines term-set-winsize term-fg-color term-bg-color term-color ttest check-shellsize limit-screen-size win-new-shellsize shell-resized set-shellsize settmode starttermcap stoptermcap swapping-screen scroll-start cursor-on cursor-off term-cursor-shape scroll-region-set scroll-region-reset COPY-termcode ARRAY-termcode clear-termcodes add-termcode termcode-star find-termcode del-termcode del-termcode-idx check-termcode gather-termleader ui-write ui-inchar ui-delay ui-suspend ui-get-shellsize ui-set-shellsize ui-new-shellsize ui-breakcheck is-input-buf-full is-input-buf-empty read-from-input-buf fill-input-buf ui-cursor-shape check-col check-row redraw-later redraw-win-later redraw-later-clear redraw-all-later redraw-curbuf-later redraw-buf-later redrawWinline update-curbuf update-screen conceal-cursor-line conceal-check-cursor-line update-single-line win-update win-draw-end advance-color-col win-line comp-char-differs char-needs-redraw screen-line status-redraw-all redraw-statuslines draw-vsep-win win-redr-status stl-connected screen-putchar screen-getbytes screen-comp-differs screen-puts screen-puts-len start-search-hl end-search-hl init-search-hl prepare-search-hl next-search-hl next-search-hl-pos screen-start-highlight screen-stop-highlight reset-cterm-colors screen-char screen-draw-rectangle redraw-block screen-fill check-for-delay screen-valid screenalloc screenclear screenclear2 lineclear lineinvalid linecopy can-clear screen-start windgoto setcursor win-ins-lines win-del-lines win-do-lines win-rest-invalid screen-ins-lines screen-del-lines showmode msg-pos-mode unshowmode get-trans-bufname fillchar-status fillchar-vsep redrawing messaging showruler win-redr-ruler number-width screen-screencol screen-screenrow do-window cmd-with-count win-split win-split-ins win-init win-valid win-exchange win-rotate win-totop win-equal win-equal-rec one-window win-close win-free-mem winframe-remove win-altframe frame2win frame-has-win frame-new-height frame-fixed-height frame-fixed-width frame-add-statusline frame-new-width frame-add-vsep frame-fix-width frame-fix-height frame-minheight frame-minwidth close-others win-init-empty win-alloc-first newFrame win-init-size win-goto win-goto-ver win-goto-hor win-enter win-enter-ext newWindow win-free win-append win-remove frame-append frame-insert frame-remove win-alloc-lines win-free-lines shell-new-rows shell-new-columns win-comp-pos frame-comp-pos win-setheight win-setheight-win frame-setheight win-setwidth win-setwidth-win frame-setwidth win-setminheight set-fraction win-new-height win-new-width win-comp-scroll command-height frame-add-height last-status last-status-rec min-rows clear-matches frame-check-height frame-check-width COPY-lineoff comp-botline redraw-for-cursorline update-topline-redraw update-topline scrolljump-value check-top-offset update-curswant check-cursor-moved changed-window-setting changed-window-setting-win set-topline changed-cline-bef-curs changed-cline-bef-curs-win changed-line-abv-curs changed-line-abv-curs-win validate-botline invalidate-botline invalidate-botline-win approximate-botline-win cursor-valid validate-cursor curs-rows validate-virtcol validate-virtcol-win validate-cheight validate-cursor-col win-col-off curwin-col-off win-col-off2 curwin-col-off2 curs-columns scrolldown scrollup topline-back botline-forw scroll-cursor-top set-empty-rows scroll-cursor-bot scroll-cursor-halfway cursor-correct onepage get-scroll-overlap halfpage do-check-cursorbind COPY-hl-group syn-get-sub-char restore-cterm-colors get-attr-entry clear-hl-tables hl-combine-attr syn-attr2attr syn-term-attr2entry syn-cterm-attr2entry set-hl-attr syn-name2id syn-check-group syn-add-group syn-id2attr syn-get-final-id highlight-changed main-loop getout)

;;; ============================================================================================== VimC

;; Definitions of various common control characters.

(final byte NUL     000)    ;; %% VimA/NUL
(final byte BELL    007)
(final byte BS      010)
(final byte TAB     (byte \tab))
(final byte NL      012)
(final byte FF      014)
(final byte CAR     015)    ;; CR is used by Mac OS X
(final byte ESC     033)
(final byte DEL    0x7f)

(final byte! POUND 0xa3)

(final Bytes
    NL_STR   (u8 "\012")
    ESC_STR  (u8 "\033")
    DEL_STR  (u8 "\177"))

(defn- eos?
    ([x] (eos? x 0))
    ([x y] (== (.at x y) NUL)))
(defn- non-eos?
    ([x] (non-eos? x 0))
    ([x y] (!= (.at x y) NUL)))
(defn- eos!
    ([x] (eos! x 0))
    ([x y] (.be x y, NUL)))

(defn- #_int alphaOrd [#_int x] (- x (if (< x (byte \a)) (byte \A) (byte \a))))
(defn- #_int lowerOrd [#_int x] (- x (byte \a)))
(defn- #_int upperOrd [#_int x] (- x (byte \A)))

(defn- #_int rot13 [#_int c, #_int a]
    (+ (% (+ (- c a) 13) 26) a))

(defn- #_int ctrl-key [#_byte c]
    (if (< c NUL) (char_u c) (bit-xor (asc_toupper c) 0x40)))       ;; '?' -> DEL, '@' -> ^@, etc.

(final Bytes
    CTRL_H_STR (u8 "\010")
    CTRL_V_STR (u8 "\026"))

(final byte
    Ctrl_AT   0,        ;; @
    Ctrl_A    1,
    Ctrl_B    2,
    Ctrl_C    3,
    Ctrl_D    4,
    Ctrl_E    5,
    Ctrl_F    6,
    Ctrl_G    7,
    Ctrl_H    8,
    Ctrl_I    9,
    Ctrl_J   10,
    Ctrl_K   11,
    Ctrl_L   12,
    Ctrl_M   13,
    Ctrl_N   14,
    Ctrl_O   15,
    Ctrl_P   16,
    Ctrl_Q   17,
    Ctrl_R   18,
    Ctrl_S   19,
    Ctrl_T   20,
    Ctrl_U   21,
    Ctrl_V   22,
    Ctrl_W   23,
    Ctrl_X   24,
    Ctrl_Y   25,
    Ctrl_Z   26,
                        ;; CTRL- [ Left Square Bracket == ESC
    Ctrl_BSL 28,        ;; \ BackSLash
    Ctrl_RSB 29,        ;; ] Right Square Bracket
    Ctrl_HAT 30,        ;; ^
    Ctrl__   31)

;; ----------------------------------------------------------------------- ;;

;; Keycode definitions for special keys.
;;
;; Any special key code sequences are replaced by these codes.

;; KB_SPECIAL is the first byte of a special key code and is always followed by two bytes.
;; The second byte can have any value.  ASCII is used for normal termcap entries,
;; 0x80 and higher for special keys, see below.
;; The third byte is guaranteed to be between 0x02 and 0x7f.

(final byte! KB_SPECIAL         0x80)

;; Positive characters are "normal" characters.
;; Negative characters are special key codes.  Only characters below -0x200 are used,
;; so that the absolute value can't be mistaken for a single-byte character.

(defn- #_boolean is-special [#_int c]
    (< c 0))

;; NUL cannot be in the input string, therefore it is replaced by
;;      KB_SPECIAL  KS_ZERO     KE_FILLER

(final byte! KS_ZERO            255)

;; KB_SPECIAL cannot be in the input string, therefore it is replaced by
;;      KB_SPECIAL  KS_SPECIAL  KE_FILLER

(final byte! KS_SPECIAL         254)

;; KS_EXTRA is used for keys that have no termcap name
;;      KB_SPECIAL  KS_EXTRA    KE_xxx

(final byte! KS_EXTRA           253)

;; KS_MODIFIER is used when a modifier is given for a (special) key
;;      KB_SPECIAL  KS_MODIFIER bitmask

(final byte! KS_MODIFIER        252)

;; These are used for the GUI
;;      KB_SPECIAL  KS_xxx      KE_FILLER

(final byte! KS_VER_SCROLLBAR   249)
(final byte! KS_HOR_SCROLLBAR   248)

;; Used for switching Select mode back on after a mapping or menu.

(final byte! KS_SELECT          245)

;; Used a termcap entry that produces a normal character.

(final byte! KS_KEY             242)

;; Filler used after KS_SPECIAL and others.

(final byte KE_FILLER            \X)

;; Translation of three byte code "KB_SPECIAL a b" into int "K_xxx" and back.

(defn- #_int TERMCAP2KEY [#_byte a, #_byte b]
    (int (- (+ (char_u a) (<< (char_u b) 8)))))

(defn- #_byte KEY2TERMCAP0 [#_int x]
    (byte! (& (- x) 0xff)))

(defn- #_byte KEY2TERMCAP1 [#_int x]
    (byte! (& (>>> (- x) 8) 0xff)))

;; Get second or third byte when translating special key code into three bytes.

(defn- #_byte KB-SECOND [#_int c]
    (cond (== c (char_u KB_SPECIAL)) KS_SPECIAL (== c NUL) KS_ZERO :else (KEY2TERMCAP0 c)))

(defn- #_byte KB-THIRD [#_int c]
    (if (or (== c (char_u KB_SPECIAL)) (== c NUL)) KE_FILLER (KEY2TERMCAP1 c)))

;; Codes for keys that do not have a termcap name.
;;
;; KB_SPECIAL KS_EXTRA KE_xxx

(final byte
    KE_S_UP 4,            ;; shift-up
    KE_S_DOWN 5,          ;; shift-down

    KE_S_F1 6,            ;; shifted function keys
    KE_S_F2 7,
    KE_S_F3 8,
    KE_S_F4 9,
    KE_S_F5 10,
    KE_S_F6 11,
    KE_S_F7 12,
    KE_S_F8 13,
    KE_S_F9 14,
    KE_S_F10 15,

    KE_S_F11 16,
    KE_S_F12 17,

;; Symbols for pseudo keys which are translated from the real key symbols above.

    KE_IGNORE 53,         ;; ignored mouse drag/release

    KE_TAB 54,            ;; unshifted TAB key

    KE_XF1 56,            ;; extra vt100 function keys for xterm
    KE_XF2 57,
    KE_XF3 58,
    KE_XF4 59,
    KE_XEND 60,           ;; extra (vt100) end key for xterm
    KE_ZEND 61,           ;; extra (vt100) end key for xterm
    KE_XHOME 62,          ;; extra (vt100) home key for xterm
    KE_ZHOME 63,          ;; extra (vt100) home key for xterm
    KE_XUP 64,            ;; extra vt100 cursor keys for xterm
    KE_XDOWN 65,
    KE_XLEFT 66,
    KE_XRIGHT 67,

    KE_S_XF1 70,          ;; extra vt100 shifted function keys for xterm
    KE_S_XF2 71,
    KE_S_XF3 72,
    KE_S_XF4 73,

    KE_KINS 78,           ;; keypad Insert key
    KE_KDEL 79,           ;; keypad Delete key

    KE_CMDWIN 83,         ;; open command-line window from Command-line Mode

    KE_C_LEFT 84,         ;; control-left
    KE_C_RIGHT 85,        ;; control-right
    KE_C_HOME 86,         ;; control-home
    KE_C_END 87,          ;; control-end

    KE_DROP 94,           ;; DnD data is available
    KE_CURSORHOLD 95,     ;; CursorHold event

    KE_NOP 98)            ;; doesn't do anything

;; the three byte codes are replaced with the following int when using vgetc()

(final int
    K_ZERO          (TERMCAP2KEY KS_ZERO KE_FILLER),

    K_UP            (TERMCAP2KEY (byte \k) (byte \u)),
    K_DOWN          (TERMCAP2KEY (byte \k) (byte \d)),
    K_LEFT          (TERMCAP2KEY (byte \k) (byte \l)),
    K_RIGHT         (TERMCAP2KEY (byte \k) (byte \r)),
    K_S_UP          (TERMCAP2KEY KS_EXTRA KE_S_UP),
    K_S_DOWN        (TERMCAP2KEY KS_EXTRA KE_S_DOWN),
    K_S_LEFT        (TERMCAP2KEY (byte \#) (byte \4)),
    K_C_LEFT        (TERMCAP2KEY KS_EXTRA KE_C_LEFT),
    K_S_RIGHT       (TERMCAP2KEY (byte \%) (byte \i)),
    K_C_RIGHT       (TERMCAP2KEY KS_EXTRA KE_C_RIGHT),
    K_S_HOME        (TERMCAP2KEY (byte \#) (byte \2)),
    K_C_HOME        (TERMCAP2KEY KS_EXTRA KE_C_HOME),
    K_S_END         (TERMCAP2KEY (byte \*) (byte \7)),
    K_C_END         (TERMCAP2KEY KS_EXTRA KE_C_END),
    K_TAB           (TERMCAP2KEY KS_EXTRA KE_TAB),
    K_S_TAB         (TERMCAP2KEY (byte \k) (byte \B)),

;; extra set of function keys F1-F4, for vt100 compatible xterm
    K_XF1           (TERMCAP2KEY KS_EXTRA KE_XF1),
    K_XF2           (TERMCAP2KEY KS_EXTRA KE_XF2),
    K_XF3           (TERMCAP2KEY KS_EXTRA KE_XF3),
    K_XF4           (TERMCAP2KEY KS_EXTRA KE_XF4),

;; extra set of cursor keys for vt100 compatible xterm
    K_XUP           (TERMCAP2KEY KS_EXTRA KE_XUP),
    K_XDOWN         (TERMCAP2KEY KS_EXTRA KE_XDOWN),
    K_XLEFT         (TERMCAP2KEY KS_EXTRA KE_XLEFT),
    K_XRIGHT        (TERMCAP2KEY KS_EXTRA KE_XRIGHT),

    K_F1            (TERMCAP2KEY (byte \k) (byte \1)),   ;; function keys
    K_F2            (TERMCAP2KEY (byte \k) (byte \2)),
    K_F3            (TERMCAP2KEY (byte \k) (byte \3)),
    K_F4            (TERMCAP2KEY (byte \k) (byte \4)),
    K_F5            (TERMCAP2KEY (byte \k) (byte \5)),
    K_F6            (TERMCAP2KEY (byte \k) (byte \6)),
    K_F7            (TERMCAP2KEY (byte \k) (byte \7)),
    K_F8            (TERMCAP2KEY (byte \k) (byte \8)),
    K_F9            (TERMCAP2KEY (byte \k) (byte \9)),
    K_F10           (TERMCAP2KEY (byte \k) (byte \;)),

    K_F11           (TERMCAP2KEY (byte \F) (byte \1)),
    K_F12           (TERMCAP2KEY (byte \F) (byte \2)),

;; extra set of shifted function keys F1-F4, for vt100 compatible xterm
    K_S_XF1         (TERMCAP2KEY KS_EXTRA KE_S_XF1),
    K_S_XF2         (TERMCAP2KEY KS_EXTRA KE_S_XF2),
    K_S_XF3         (TERMCAP2KEY KS_EXTRA KE_S_XF3),
    K_S_XF4         (TERMCAP2KEY KS_EXTRA KE_S_XF4),

    K_S_F1          (TERMCAP2KEY KS_EXTRA KE_S_F1),  ;; shifted func. keys
    K_S_F2          (TERMCAP2KEY KS_EXTRA KE_S_F2),
    K_S_F3          (TERMCAP2KEY KS_EXTRA KE_S_F3),
    K_S_F4          (TERMCAP2KEY KS_EXTRA KE_S_F4),
    K_S_F5          (TERMCAP2KEY KS_EXTRA KE_S_F5),
    K_S_F6          (TERMCAP2KEY KS_EXTRA KE_S_F6),
    K_S_F7          (TERMCAP2KEY KS_EXTRA KE_S_F7),
    K_S_F8          (TERMCAP2KEY KS_EXTRA KE_S_F8),
    K_S_F9          (TERMCAP2KEY KS_EXTRA KE_S_F9),
    K_S_F10         (TERMCAP2KEY KS_EXTRA KE_S_F10),

    K_S_F11         (TERMCAP2KEY KS_EXTRA KE_S_F11),
    K_S_F12         (TERMCAP2KEY KS_EXTRA KE_S_F12),

    K_HELP          (TERMCAP2KEY (byte \%) (byte \1)),
    K_UNDO          (TERMCAP2KEY (byte \&) (byte \8)),

    K_BS            (TERMCAP2KEY (byte \k) (byte \b)),

    K_INS           (TERMCAP2KEY (byte \k) (byte \I)),
    K_KINS          (TERMCAP2KEY KS_EXTRA KE_KINS),
    K_DEL           (TERMCAP2KEY (byte \k) (byte \D)),
    K_KDEL          (TERMCAP2KEY KS_EXTRA KE_KDEL),
    K_HOME          (TERMCAP2KEY (byte \k) (byte \h)),
    K_KHOME         (TERMCAP2KEY (byte \K) (byte \1)),   ;; keypad home (upper left)
    K_XHOME         (TERMCAP2KEY KS_EXTRA KE_XHOME),
    K_ZHOME         (TERMCAP2KEY KS_EXTRA KE_ZHOME),
    K_END           (TERMCAP2KEY (byte \@) (byte \7)),
    K_KEND          (TERMCAP2KEY (byte \K) (byte \4)),   ;; keypad end (lower left)
    K_XEND          (TERMCAP2KEY KS_EXTRA KE_XEND),
    K_ZEND          (TERMCAP2KEY KS_EXTRA KE_ZEND),
    K_PAGEUP        (TERMCAP2KEY (byte \k) (byte \P)),
    K_PAGEDOWN      (TERMCAP2KEY (byte \k) (byte \N)),
    K_KPAGEUP       (TERMCAP2KEY (byte \K) (byte \3)),   ;; keypad pageup (upper R.)
    K_KPAGEDOWN     (TERMCAP2KEY (byte \K) (byte \5)),   ;; keypad pagedown (lower R.)

    K_KPLUS         (TERMCAP2KEY (byte \K) (byte \6)),   ;; keypad plus
    K_KMINUS        (TERMCAP2KEY (byte \K) (byte \7)),   ;; keypad minus
    K_KDIVIDE       (TERMCAP2KEY (byte \K) (byte \8)),   ;; keypad /
    K_KMULTIPLY     (TERMCAP2KEY (byte \K) (byte \9)),   ;; keypad *
    K_KENTER        (TERMCAP2KEY (byte \K) (byte \A)),   ;; keypad Enter
    K_KPOINT        (TERMCAP2KEY (byte \K) (byte \B)),   ;; keypad . or ,

    K_K0            (TERMCAP2KEY (byte \K) (byte \C)),   ;; keypad 0
    K_K1            (TERMCAP2KEY (byte \K) (byte \D)),   ;; keypad 1
    K_K2            (TERMCAP2KEY (byte \K) (byte \E)),   ;; keypad 2
    K_K3            (TERMCAP2KEY (byte \K) (byte \F)),   ;; keypad 3
    K_K4            (TERMCAP2KEY (byte \K) (byte \G)),   ;; keypad 4
    K_K5            (TERMCAP2KEY (byte \K) (byte \H)),   ;; keypad 5
    K_K6            (TERMCAP2KEY (byte \K) (byte \I)),   ;; keypad 6
    K_K7            (TERMCAP2KEY (byte \K) (byte \J)),   ;; keypad 7
    K_K8            (TERMCAP2KEY (byte \K) (byte \K)),   ;; keypad 8
    K_K9            (TERMCAP2KEY (byte \K) (byte \L)),   ;; keypad 9

    K_VER_SCROLLBAR (TERMCAP2KEY KS_VER_SCROLLBAR KE_FILLER),
    K_HOR_SCROLLBAR (TERMCAP2KEY KS_HOR_SCROLLBAR KE_FILLER),

    K_SELECT        (TERMCAP2KEY KS_SELECT KE_FILLER),

;; Symbols for pseudo keys which are translated from the real key symbols above.

    K_IGNORE        (TERMCAP2KEY KS_EXTRA KE_IGNORE),
    K_NOP           (TERMCAP2KEY KS_EXTRA KE_NOP),

    K_CMDWIN        (TERMCAP2KEY KS_EXTRA KE_CMDWIN),

    K_DROP          (TERMCAP2KEY KS_EXTRA KE_DROP),

    K_CURSORHOLD    (TERMCAP2KEY KS_EXTRA KE_CURSORHOLD))

;; Bits for modifier mask.
;; 0x01 cannot be used, because the modifier must be 0x02 or higher

(final int
    MOD_MASK_SHIFT      0x02,
    MOD_MASK_CTRL       0x04,
    MOD_MASK_ALT        0x08,        ;; aka META
    MOD_MASK_META       0x10,        ;; META when it's different from ALT
    MOD_MASK_2CLICK     0x20,        ;; use MOD_MASK_MULTI_CLICK
    MOD_MASK_3CLICK     0x40,        ;; use MOD_MASK_MULTI_CLICK
    MOD_MASK_4CLICK     0x60)        ;; use MOD_MASK_MULTI_CLICK

(final int MOD_MASK_MULTI_CLICK (| MOD_MASK_2CLICK MOD_MASK_3CLICK MOD_MASK_4CLICK))

;; The length of the longest special key name, including modifiers.
;; Current longest is <M-C-S-T-4-MiddleRelease> (length includes '<' and '>').

(final int MAX_KEY_NAME_LEN    25)

;; Maximum length of a special key event as tokens.  This includes modifiers.
;; The longest event is something like <M-C-S-T-4-LeftDrag> which would be the
;; following string of tokens:
;;
;; <KB_SPECIAL> <KS_MODIFIER> bitmask <KB_SPECIAL> <KS_EXTRA> <KE_LEFTDRAG>.
;;
;; This is a total of 6 tokens, and is currently the longest one possible.

(final int MAX_KEY_CODE_LEN    6)

;; Get single int code from second byte after KB_SPECIAL.

(defn- #_int toSpecial [#_byte a, #_byte b]
    (cond (== a KS_SPECIAL) (char_u KB_SPECIAL) (== a KS_ZERO) K_ZERO :else (TERMCAP2KEY a, b)))

;; ----------------------------------------------------------------------- ;;

;; This file contains the defines for the machine dependent escape sequences
;; that the editor needs to perform various operations.  All of the sequences
;; here are optional, except "cm" (cursor motion).

;; Index of the termcap codes in the 'term_strings' array.

(final int
    KS_NAME  0,     ;; name of this terminal entry
    KS_CE    1,     ;; clear to end of line
    KS_AL    2,     ;; add new blank line
    KS_CAL   3,     ;; add number of blank lines
    KS_DL    4,     ;; delete line
    KS_CDL   5,     ;; delete number of lines
    KS_CS    6,     ;; scroll region
    KS_CL    7,     ;; clear screen
    KS_CD    8,     ;; clear to end of display
    KS_UT    9,     ;; clearing uses current background color
    KS_DA   10,     ;; text may be scrolled down from up
    KS_DB   11,     ;; text may be scrolled up from down
    KS_VI   12,     ;; cursor invisible
    KS_VE   13,     ;; cursor visible
    KS_VS   14,     ;; cursor very visible
    KS_ME   15,     ;; normal mode
    KS_MR   16,     ;; reverse mode
    KS_MD   17,     ;; bold mode
    KS_SE   18,     ;; normal mode
    KS_SO   19,     ;; standout mode
    KS_CZH  20,     ;; italic mode start
    KS_CZR  21,     ;; italic mode end
    KS_UE   22,     ;; exit underscore (underline) mode
    KS_US   23,     ;; underscore (underline) mode
    KS_MS   24,     ;; save to move cur in reverse mode
    KS_CM   25,     ;; cursor motion
    KS_SR   26,     ;; scroll reverse (backward)
    KS_CRI  27,     ;; cursor number of chars right
    KS_VB   28,     ;; visual bell
    KS_KS   29,     ;; put term in "keypad transmit" mode
    KS_KE   30,     ;; out of "keypad transmit" mode
    KS_TI   31,     ;; put terminal in termcap mode
    KS_TE   32,     ;; out of termcap mode
    KS_BC   33,     ;; backspace character (cursor left)
    KS_CCO  34,     ;; number of colors
    KS_CSF  35,     ;; set foreground color
    KS_CSB  36,     ;; set background color
    KS_XN   37,     ;; newline glitch
    KS_CAF  38,     ;; set foreground color (ANSI)
    KS_CAB  39,     ;; set background color (ANSI)
    KS_LE   40,     ;; cursor left (mostly backspace)
    KS_ND   41,     ;; cursor right
    KS_CWS  42,     ;; set window size in characters
    KS_CSI  43,     ;; start insert mode (bar cursor)
    KS_CEI  44,     ;; end insert mode (block cursor)
    KS_CSR  45,     ;; start replace mode (underline cursor)
    KS_CSV  46,     ;; scroll region vertical
    KS_OP   47)     ;; original color pair

;; The terminal capabilities are stored in this array.
;; IMPORTANT: When making changes, note the following:
;; - there should be an entry for each code in the builtin termcaps
;; - there should be an option for each code in option.c
;; - there should be code in term.c to obtain the value from the termcap

;; strings used for terminal

(atom! Bytes
    T_NAME  nil,    ;; terminal name
    T_CE    nil,    ;; clear to end of line
    T_AL    nil,    ;; add new blank line
    T_CAL   nil,    ;; add number of blank lines
    T_DL    nil,    ;; delete line
    T_CDL   nil,    ;; delete number of lines
    T_CS    nil,    ;; scroll region
    T_CL    nil,    ;; clear screen
    T_CD    nil,    ;; clear to end of display
    T_UT    nil,    ;; clearing uses background color
    T_DA    nil,    ;; text may be scrolled down from up
    T_DB    nil,    ;; text may be scrolled up from down
    T_VI    nil,    ;; cursor invisible
    T_VE    nil,    ;; cursor visible
    T_VS    nil,    ;; cursor very visible
    T_ME    nil,    ;; normal mode
    T_MR    nil,    ;; reverse mode
    T_MD    nil,    ;; bold mode
    T_SE    nil,    ;; normal mode
    T_SO    nil,    ;; standout mode
    T_CZH   nil,    ;; italic mode start
    T_CZR   nil,    ;; italic mode end
    T_UE    nil,    ;; exit underscore (underline) mode
    T_US    nil,    ;; underscore (underline) mode
    T_MS    nil,    ;; save to move cur in reverse mode
    T_CM    nil,    ;; cursor motion
    T_SR    nil,    ;; scroll reverse (backward)
    T_CRI   nil,    ;; cursor number of chars right
    T_VB    nil,    ;; visual bell
    T_KS    nil,    ;; put term in "keypad transmit" mode
    T_KE    nil,    ;; out of "keypad transmit" mode
    T_TI    nil,    ;; put terminal in termcap mode
    T_TE    nil,    ;; out of termcap mode
    T_BC    nil,    ;; backspace character
    T_CCO   nil,    ;; number of colors
    T_CSF   nil,    ;; set foreground color
    T_CSB   nil,    ;; set background color
    T_XN    nil,    ;; newline glitch
    T_CAF   nil,    ;; set foreground color (ANSI)
    T_CAB   nil,    ;; set background color (ANSI)
    T_LE    nil,    ;; cursor left
    T_ND    nil,    ;; cursor right
    T_CWS   nil,    ;; window size
    T_CSI   nil,    ;; start insert mode
    T_CEI   nil,    ;; end insert mode
    T_CSR   nil,    ;; start replace mode
    T_CSV   nil,    ;; scroll region vertical
    T_OP    nil)    ;; original color pair

;; 'term_strings' contains currently used terminal output strings.
;; It is initialized with the default values by parse-builtin-tcap().
;; The values can be changed by setting the option with the same name.

(final Bytes*' term_strings [ T_NAME T_CE T_AL  T_CAL T_DL  T_CDL T_CS  T_CL
                              T_CD   T_UT T_DA  T_DB  T_VI  T_VE  T_VS  T_ME
                              T_MR   T_MD T_SE  T_SO  T_CZH T_CZR T_UE  T_US
                              T_MS   T_CM T_SR  T_CRI T_VB  T_KS  T_KE  T_TI
                              T_TE   T_BC T_CCO T_CSF T_CSB T_XN  T_CAF T_CAB
                              T_LE   T_ND T_CWS T_CSI T_CEI T_CSR T_CSV T_OP ])

(final int TMODE_COOK  0)   ;; terminal mode for external cmds and Ex mode
(final int TMODE_SLEEP 1)   ;; terminal mode for sleeping (cooked but no echo)
(final int TMODE_RAW   2)   ;; terminal mode for Normal and Insert mode

;; ----------------------------------------------------------------------- ;;

;; flags for update-screen()
;; The higher the value, the higher the priority

(final int VALID        10) ;; buffer not changed, or changes marked with b_mod_*
(final int INVERTED     20) ;; redisplay inverted part that changed
(final int INVERTED_ALL 25) ;; redisplay whole inverted part
(final int REDRAW_TOP   30) ;; display first w_upd_rows screen lines
(final int SOME_VALID   35) ;; like NOT_VALID but may scroll
(final int NOT_VALID    40) ;; buffer needs complete redraw
(final int CLEAR        50) ;; screen messed up, clear it

;; Flags for w_valid.
;; These are set when something in a window structure becomes invalid, except when the cursor is moved.
;; Call check-cursor-moved() before testing one of the flags.
;; These are reset when that thing has been updated and is valid again.
;;
;; Every function that invalidates one of these must call one of the invalidate_* functions.
;;
;; w_valid is supposed to be encapsulated: use the functions that set or reset the flags, instead.
;;
;; VALID_BOTLINE    VALID_BOTLINE_AP
;;     on               on             w_botline valid
;;     off              on             w_botline approximated
;;     off              off            w_botline not valid
;;     on               off            not possible

(final int
    VALID_WROW          0x01,       ;; w_wrow (window row) is valid
    VALID_WCOL          0x02,       ;; w_wcol (window col) is valid
    VALID_VIRTCOL       0x04,       ;; w_virtcol (file col) is valid
    VALID_CHEIGHT       0x08,       ;; w_cline_height and w_cline_folded valid
    VALID_CROW          0x10,       ;; w_cline_row is valid
    VALID_BOTLINE       0x20,       ;; w_botine and w_empty_rows are valid
    VALID_BOTLINE_AP    0x40,       ;; w_botine is approximated
    VALID_TOPLINE       0x80)       ;; w_topline is valid (for cursor position)

;; Terminal highlighting attribute bits.
;; Attributes above HL_ALL are used for syntax highlighting.

(final int
    HL_NORMAL           0x00,
    HL_INVERSE          0x01,
    HL_BOLD             0x02,
    HL_ITALIC           0x04,
    HL_UNDERLINE        0x08,
    HL_UNDERCURL        0x10,
    HL_STANDOUT         0x20,
    HL_ALL              0x3f)

;; values for State
;;
;; The lower bits up to 0x20 are used to distinguish normal/visual/op_pending
;; and cmdline/insert+replace mode.  This is used for mapping.
;; If none of these bits are set, no mapping is done.
;; The upper bits are used to distinguish between other states.

(final int
    NORMAL          0x01,           ;; normal mode, command expected
    VISUAL          0x02,           ;; visual mode - use get-real-state()
    OP_PENDING      0x04,           ;; normal mode, operator is pending - use get-real-state()
    CMDLINE         0x08,           ;; editing command line
    INSERT          0x10,           ;; insert mode

    REPLACE_FLAG    0x40,           ;; replace mode flag
    REPLACE      (+ REPLACE_FLAG INSERT),
    VREPLACE_FLAG   0x80,           ;; virtual-replace mode flag
    VREPLACE     (+ REPLACE_FLAG VREPLACE_FLAG INSERT),

    NORMAL_BUSY  (+ 0x100 NORMAL),  ;; normal mode, busy with a command
    HITRETURN    (+ 0x200 NORMAL),  ;; waiting for return or command
    ASKMORE         0x300,          ;; asking if you want --more--
    SETWSIZE        0x400,          ;; window size has changed
    SHOWMATCH    (+ 0x700 INSERT),  ;; show matching paren
    CONFIRM         0x800,          ;; ":confirm" prompt
    SELECTMODE      0x1000)         ;; select mode, only for mappings

;; directions
(final int FORWARD        1)
(final int BACKWARD       -1)

(final int
    HL_CONTAINED        0x01,       ;; not used on toplevel
    HL_TRANSP           0x02,       ;; has no highlighting
    HL_ONELINE          0x04,       ;; match within one line only
    HL_HAS_EOL          0x08,       ;; end pattern that matches with $
    HL_SYNC_HERE        0x10,       ;; sync point after this item (syncing only)
    HL_SYNC_THERE       0x20,       ;; sync point at current line (syncing only)
    HL_MATCH            0x40,       ;; use match ID instead of item ID
    HL_SKIPNL           0x80,       ;; nextgroup can skip newlines
    HL_SKIPWHITE       0x100,       ;; nextgroup can skip white space
    HL_SKIPEMPTY       0x200,       ;; nextgroup can skip empty lines
    HL_KEEPEND         0x400,       ;; end match always kept
    HL_EXCLUDENL       0x800,       ;; exclude NL from match
    HL_DISPLAY        0x1000,       ;; only used for displaying, not syncing
    HL_FOLD           0x2000,       ;; define fold
    HL_EXTEND         0x4000,       ;; ignore a keepend
    HL_MATCHCONT      0x8000,       ;; match continued from previous line
    HL_TRANS_CONT    0x10000,       ;; transparent item without contains arg
    HL_CONCEAL       0x20000,       ;; can be concealed
    HL_CONCEALENDS   0x40000)       ;; can be concealed

;; Values for 'options' argument in do-search() and searchit().
(final int
    SEARCH_REV          0x01,       ;; go in reverse of previous dir.
    SEARCH_ECHO         0x02,       ;; echo the search command and handle options
    SEARCH_MSG          0x0c,       ;; give messages (yes, it's not 0x04)
    SEARCH_NFMSG        0x08,       ;; give all messages except not found
    SEARCH_OPT          0x10,       ;; interpret optional flags
    SEARCH_HIS          0x20,       ;; put search pattern in history
    SEARCH_END          0x40,       ;; put cursor at end of match
    SEARCH_NOOF         0x80,       ;; don't add offset to position
    SEARCH_START       0x100,       ;; start search without col offset
    SEARCH_MARK        0x200,       ;; set previous context mark
    SEARCH_KEEP        0x400,       ;; keep previous search pattern
    SEARCH_PEEK        0x800)       ;; peek for typed char, cancel search

;; Values for find-ident-under-cursor().
(final int FIND_IDENT      1)       ;; find identifier (word)
(final int FIND_STRING     2)       ;; find any string (WORD)
(final int FIND_EVAL       4)       ;; include "->", "[]" and "."

;; Values for change-indent().
(final int INDENT_SET      1)       ;; set indent
(final int INDENT_INC      2)       ;; increase indent
(final int INDENT_DEC      3)       ;; decrease indent

;; Values for flags argument for findmatchlimit().
(final int FM_BACKWARD     0x01)    ;; search backwards
(final int FM_FORWARD      0x02)    ;; search forwards
(final int FM_BLOCKSTOP    0x04)    ;; stop at start/end of block

;; Values for sub_cmd and which_pat argument for search-regcomp().
;; Also used for which_pat argument for searchit().
(final int RE_SEARCH       0)       ;; save/use pat in/from search_pattern
(final int RE_SUBST        1)       ;; save/use pat in/from subst_pattern
(final int RE_BOTH         2)       ;; save pat in both patterns
(final int RE_LAST         2)       ;; use last used pattern if "pat" is null

;; Second argument for vim-regcomp().
(final int RE_MAGIC        1)       ;; 'magic' option
(final int RE_STRING       2)       ;; match in string instead of buffer text
(final int RE_STRICT       4)       ;; don't allow [abc] without ]
(final int RE_AUTO         8)       ;; automatic engine selection

;; values for reg_do_extmatch
(final int REX_SET         1)       ;; to allow \z\(...\),
(final int REX_USE         2)       ;; to allow \z\1 et al.

;; flags for do-cmdline()
(final int DOCMD_VERBOSE   0x01)    ;; included command in error message
(final int DOCMD_NOWAIT    0x02)    ;; don't call wait-return() and friends
(final int DOCMD_KEYTYPED  0x08)    ;; don't reset keyTyped
(final int DOCMD_KEEPLINE  0x20)    ;; keep typed line for repeating with "."

;; flags for beginline()
(final int BL_WHITE        1)       ;; cursor on first non-white in the line
(final int BL_SOL          2)       ;; use 'sol' option
(final int BL_FIX          4)       ;; don't leave cursor on a NUL

;; flags for do-put()
(final int PUT_FIXINDENT   1)       ;; make indent look nice
(final int PUT_CURSEND     2)       ;; leave cursor after end of new text
(final int PUT_CURSLINE    4)       ;; leave cursor on last line of new text
(final int PUT_LINE        8)       ;; put register as lines
(final int PUT_LINE_SPLIT  16)      ;; split line for linewise register
(final int PUT_LINE_FORWARD 32)     ;; put linewise register below Visual sel.

;; flags for set-indent()
(final int SIN_CHANGED     1)       ;; call changed-bytes() when line changed
(final int SIN_INSERT      2)       ;; insert indent before existing text
(final int SIN_UNDO        4)       ;; save line for undo before changing it

;; flags for insertchar()
(final int INSCHAR_CTRLV   4)       ;; char typed just after CTRL-V

;; There are four history tables:

(final int HIST_CMD        0)       ;; colon commands
(final int HIST_SEARCH     1)       ;; search commands
(final int HIST_EXPR       2)       ;; expressions (from entering = register)
(final int HIST_INPUT      3)       ;; input() lines
(final int HIST_COUNT      4)       ;; number of history tables

;; Flags for chartab[].

(final int CT_CELL_MASK    0x07)    ;; mask: nr of display cells (1, 2 or 4)
(final int CT_PRINT_CHAR   0x10)    ;; flag: set for printable chars
(final int CT_ID_CHAR      0x20)    ;; flag: set for ID chars
(final int CT_FNAME_CHAR   0x40)    ;; flag: set for file name chars

;; arguments for win-split()

(final int WSP_VERT        2)       ;; split vertically
(final int WSP_TOP         4)       ;; window at top-left of shell
(final int WSP_BOT         8)       ;; window at bottom-right of shell
(final int WSP_BELOW       32)      ;; put new window below/right
(final int WSP_ABOVE       64)      ;; put new window above/left

;; Values for "starting".
(final int NO_SCREEN       2)       ;; no screen updating yet
(final int NO_BUFFERS      1)       ;; not all buffers loaded yet
;;                         0           not starting anymore

;; Values for index in highlight_attr[].
;; When making changes, also update HL_FLAGS below!
;; And update the default value of 'highlight' in option.c.

(final int
    HLF_8        0,     ;; Meta & special keys listed with ":map", text that is displayed different from what it is
    HLF_AT       1,     ;; @ and ~ characters at end of screen, characters that don't really exist in the text
    HLF_E        2,     ;; error messages
    HLF_I        3,     ;; incremental search
    HLF_L        4,     ;; last search string
    HLF_M        5,     ;; "--More--" message
    HLF_CM       6,     ;; Mode (e.g., "-- INSERT --")
    HLF_N        7,     ;; line number for ":number" and ":#" commands
    HLF_CLN      8,     ;; current line number
    HLF_R        9,     ;; return to continue message and yes/no questions
    HLF_S       10,     ;; status lines
    HLF_SNC     11,     ;; status lines of not-current windows
    HLF_C       12,     ;; column to separate vertically split windows
    HLF_T       13,     ;; Titles for output from ":set all", ":autocmd" etc.
    HLF_V       14,     ;; Visual mode
    HLF_W       15,     ;; warning messages
    HLF_CONCEAL 16,     ;; Concealed text
    HLF_CUC     17,     ;; 'cursorcolumn'
    HLF_CUL     18,     ;; 'cursorline'
    HLF_MC      19,     ;; 'colorcolumn'

    HLF_COUNT   20)     ;; MUST be the last one

;; Operator IDs; The order must correspond to opchars[] in ops.c!

(final int
    OP_NOP       0,     ;; no pending operation
    OP_DELETE    1,     ;; "d"  delete operator
    OP_YANK      2,     ;; "y"  yank operator
    OP_CHANGE    3,     ;; "c"  change operator
    OP_LSHIFT    4,     ;; "<"  left shift operator
    OP_RSHIFT    5,     ;; ">"  right shift operator
    OP_FILTER    6,     ;; "!"  filter operator
    OP_TILDE     7,     ;; "g~" switch case operator
    OP_INDENT    8,     ;; "="  indent operator
    OP_FORMAT    9,     ;; "gq" format operator
    OP_COLON    10,     ;; ":"  colon operator
    OP_UPPER    11,     ;; "gU" make upper case operator
    OP_LOWER    12,     ;; "gu" make lower case operator
    OP_JOIN     13,     ;; "J"  join operator, only for Visual mode
    OP_JOIN_NS  14,     ;; "gJ"  join operator, only for Visual mode
    OP_ROT13    15,     ;; "g?" rot-13 encoding
    OP_REPLACE  16,     ;; "r"  replace chars, only for Visual mode
    OP_INSERT   17,     ;; "I"  Insert column, only for Visual mode
    OP_APPEND   18,     ;; "A"  Append column, only for Visual mode
    OP_FORMAT2  19,     ;; "gw" format operator, keeps cursor pos
    OP_FUNCTION 20)     ;; "g@" call 'operatorfunc'

;; Motion types, used for operators and for yank/delete registers.

(final byte!
    MCHAR   0,          ;; character-wise movement/register
    MLINE   1,          ;; line-wise movement/register
    MBLOCK  2,          ;; block-wise register
    MAUTO   0xff)       ;; decide between MLINE/MCHAR

;; Minimum screen size.

(final int MIN_COLUMNS     12)          ;; minimal columns for screen
(final int MIN_LINES       2)           ;; minimal lines for screen
(final int STATUS_HEIGHT   1)           ;; height of a status line under a window

(final int IOSIZE          (inc 1024))  ;; file i/o and sprintf buffer size
(final int MAXPATHL         4096)

(final int
    MSG_BUF_LEN     480,                ;; length of buffer for small messages
    MSG_BUF_CLEN    (/ MSG_BUF_LEN 6))  ;; cell length (worst case: utf-8 takes 6 bytes for one cell)

;; Maximum length of key sequence to be mapped.

(final int MAXMAPLEN 50)

(final long MAXLNUM 0x7fffffff)      ;; maximum (invalid) line number
(final int MAXCOL 0x7fffffff)           ;; maximum column number, 31 bits

(final int SHOWCMD_COLS 10)             ;; columns needed by shown command

;; vim-iswhite() is used for "^" and the like.  It differs from isspace()
;; because it doesn't include <CR> and <LF> and the like.

(defn- #_boolean vim-iswhite [#_int x]
    (or (== x (byte \space)) (== x TAB)))

(final int MAX_MCO        6)        ;; maximum value for 'maxcombine'

;; Maximum number of bytes in a multi-byte character.  It can be one 32-bit
;; character of up to 6 bytes, or one 16-bit character of up to three bytes
;; plus six following composing characters of three bytes each.

(final int MB_MAXBYTES    21)

;;; ============================================================================================== VimD

;; option.h: definition of global variables for settable options

;; characters for the "p_cpo" option:
(final byte
    CPO_SEARCH      \c,
    CPO_DIGRAPH     \D,  ;; no digraph after "r", "f", etc.
    CPO_EMPTYREGION \E,  ;; operating on empty region is an error
    CPO_INSEND      \H,  ;; "I" inserts before last blank in line
    CPO_INDENT      \I,  ;; remove auto-indent more often
    CPO_JOINSP      \j,  ;; only use two spaces for join after '.'
    CPO_LITERAL     \l,  ;; take char after backslash in [] literal
    CPO_SHOWMATCH   \m,
    CPO_MATCHBSL    \M,  ;; "%" ignores use of backslashes
    CPO_NUMCOL      \n,  ;; 'number' column also used for text
    CPO_LINEOFF     \o,
    CPO_JOINCOL     \q,  ;; with "3J" use column after first join
    CPO_REDO        \r,
    CPO_UNDO        \u,  ;; "u" undoes itself
    CPO_CW          \w,  ;; "cw" only changes one blank
    CPO_ESC         \x,
    CPO_REPLCNT     \X,  ;; "R" with a count only deletes chars once
    CPO_YANK        \y,
    CPO_FILTER      \!,
    CPO_MATCH       \%,
    CPO_MINUS       \-,  ;; "9-" fails at and before line 9
    CPO_REGAPPEND   \>,  ;; insert NL when appending to a register

;; POSIX flags
    CPO_HASH        \#,  ;; "D", "o" and "O" do not use a count
    CPO_SUBPERCENT  \/,  ;; % in :s string uses previous one
    CPO_BACKSL      \\,  ;; \ is not special in []
    CPO_SCOLON      \;)  ;; using "," and ";" will skip over char if cursor would not move

;; default values for Vim, Vi and POSIX
(final Bytes CPO_VIM  (u8 "c"))
(final Bytes CPO_ALL  (u8 "cDEHIjlmMnoqruwxXy!%->#/\\;"))

;; characters for "p_ww" option:
(final Bytes WW_ALL   (u8 "bshl<>[],~"))

(final Bytes COCU_ALL     (u8 "nvic"))     ;; flags for 'concealcursor'

;; arguments for can-bs()
(final byte BS_INDENT     \i)      ;; "Indent"
(final byte BS_EOL        \o)      ;; "eOl"
(final byte BS_START      \s)      ;; "Start"

;; The following are actual variables for the options:

(atom! Bytes   p_bs)        ;; 'backspace'
(atom! Bytes   p_breakat)   ;; 'breakat'
(atom! long    p_ch)        ;; 'cmdheight'
(atom! long    p_cwh)       ;; 'cmdwinheight'
(atom! Bytes   p_cpo)       ;; 'cpoptions'
(atom! boolean p_deco)      ;; 'delcombine'
(atom! boolean p_dg)        ;; 'digraph'
(atom! Bytes   p_dy)        ;; 'display'

(final int
    DY_LASTLINE 0x001,
    DY_UHEX     0x002)
(atom! int    dy_flags)
(final Bytes* p_dy_values [ (u8 "lastline"), (u8 "uhex"), nil ])

(atom! Bytes   p_ead)       ;; 'eadirection'
(atom! boolean p_ea)        ;; 'equalalways'
(atom! boolean p_eb)        ;; 'errorbells'
(atom! boolean p_ek)        ;; 'esckeys'
(atom! boolean p_gd)        ;; 'gdefault'
(atom! Bytes   p_hl)        ;; 'highlight'
(atom! long    p_hi)        ;; 'history'
(atom! boolean p_hls)       ;; 'hlsearch'
(atom! boolean p_ic)        ;; 'ignorecase'
(atom! boolean p_is)        ;; 'incsearch'
(atom! boolean p_im)        ;; 'insertmode'
(atom! Bytes   p_isf)       ;; 'isfname'
(atom! Bytes   p_isi)       ;; 'isident'
(atom! Bytes   p_isp)       ;; 'isprint'
(atom! boolean p_js)        ;; 'joinspaces'
(atom! Bytes   p_km)        ;; 'keymodel'
(atom! long    p_ls)        ;; 'laststatus'
(atom! boolean p_lz)        ;; 'lazyredraw'
(atom! boolean p_magic)     ;; 'magic'
(atom! long    p_mat)       ;; 'matchtime'
(atom! long    p_mco)       ;; 'maxcombine'
(atom! long    p_mmp)       ;; 'maxmempattern'
(atom! boolean p_more)      ;; 'more'
(atom! Bytes   p_opfunc)    ;; 'operatorfunc'
(atom! boolean p_paste)     ;; 'paste'
(atom! boolean p_prompt)    ;; 'prompt'
(atom! long    p_rdt)       ;; 'redrawtime'
(atom! long    p_re)        ;; 'regexpengine'
(atom! long    p_report)    ;; 'report'
(atom! boolean p_ru)        ;; 'ruler'
(atom! long    p_sj)        ;; 'scrolljump'
(atom! long    p_so)        ;; 'scrolloff'
(atom! Bytes   p_sbo)       ;; 'scrollopt'
(atom! Bytes   p_sel)       ;; 'selection'
(atom! Bytes   p_slm)       ;; 'selectmode'
(atom! boolean p_sr)        ;; 'shiftround'
(atom! Bytes   p_sbr)       ;; 'showbreak'
(atom! boolean p_sc)        ;; 'showcmd'
(atom! boolean p_sm)        ;; 'showmatch'
(atom! boolean p_smd)       ;; 'showmode'
(atom! long    p_ss)        ;; 'sidescroll'
(atom! long    p_siso)      ;; 'sidescrolloff'
(atom! boolean p_scs)       ;; 'smartcase'
(atom! boolean p_sta)       ;; 'smarttab'
(atom! boolean p_sb)        ;; 'splitbelow'
(atom! boolean p_spr)       ;; 'splitright'
(atom! boolean p_sol)       ;; 'startofline'
(atom! boolean p_to)        ;; 'tildeop'
(atom! boolean p_timeout)   ;; 'timeout'
(atom! long    p_tm)        ;; 'timeoutlen'
(atom! boolean p_ttimeout)  ;; 'ttimeout'
(atom! long    p_ttm)       ;; 'ttimeoutlen'
(atom! long    p_ttyscroll) ;; 'ttyscroll'
(atom! long    p_ut)        ;; 'updatetime'
(atom! long    p_verbose)   ;; 'verbose'
(atom! Bytes   p_ve)        ;; 'virtualedit'

(final int
    VE_BLOCK   5,       ;; includes "all"
    VE_INSERT  6,       ;; includes "all"
    VE_ALL     4,
    VE_ONEMORE 8)
(atom! int    ve_flags)
(final Bytes* p_ve_values [ (u8 "block"), (u8 "insert"), (u8 "all"), (u8 "onemore"), nil ])

(atom! boolean p_vb)        ;; 'visualbell'
(atom! Bytes   p_ww)        ;; 'whichwrap'
(atom! long    p_wh)        ;; 'winheight'
(atom! long    p_wmh)       ;; 'winminheight'
(atom! long    p_wmw)       ;; 'winminwidth'
(atom! long    p_wiw)       ;; 'winwidth'
(atom! boolean p_ws)        ;; 'wrapscan'
(atom! long    p_wd)        ;; 'writedelay'

;; "indir" values for buffer-local opions.

(final int
    BV_AI     0,
    BV_CI     5,
    BV_CINW   9,
    BV_ET    14,
    BV_ISK   26,
    BV_KP    27,
    BV_MOD   31,
    BV_MPS   32,
    BV_NF    33,
    BV_PI    34,
    BV_QE    35,
    BV_SI    37,
    BV_STS   40,
    BV_SW    41,
    BV_TS    42,
    BV_UL    46)

;; "indir" values for window-local options.

(final int
    WV_COCU    1,
    WV_COLE    2,
    WV_CRBIND  3,
    WV_BRI     4,
    WV_BRIOPT  5,
    WV_LBR     6,
    WV_NU      7,
    WV_RNU     8,
    WV_NUW     9,
    WV_SCBIND 12,
    WV_SCROLL 13,
    WV_CUC    14,
    WV_CUL    15,
    WV_CC     16,
    WV_WFH    18,
    WV_WFW    19,
    WV_WRAP   20)

;; ----------------------------------------------------------------------- ;;

;; position in file or buffer

(class! #_final pos_C
    [
        (field long     lnum)       ;; line number
        (field int      col)        ;; column number
        (field int      coladd)
    ])

(final pos_C NOPOS (NEW_pos_C))

(defn- #_void COPY-pos [#_pos_C p1, #_pos_C p0]
    (ยง
        ((ร p1.lnum =) (:lnum p0))
        ((ร p1.col =) (:col p0))
        ((ร p1.coladd =) (:coladd p0))
        nil
    ))

(defn- #_pos_C* ARRAY-pos [#_int n]
    (vec (repeatedly n NEW_pos_C)))

;; Same, but without coladd.

(class! #_final lpos_C
    [
        (field long     lnum)       ;; line number
        (field int      col)        ;; column number
    ])

(defn- #_void MIN1-lpos [#_lpos_C lp]
    (ยง
        ((ร lp.lnum =) -1)
        ((ร lp.col =) -1)
        nil
    ))

(defn- #_void COPY-lpos [#_lpos_C lp1, #_lpos_C lp0]
    (ยง
        ((ร lp1.lnum =) (:lnum lp0))
        ((ร lp1.col =) (:col lp0))
        nil
    ))

(defn- #_lpos_C* ARRAY-lpos [#_int n]
    (vec (repeatedly n NEW_lpos_C)))

(defn- #_void COPY--lpos [#_lpos_C* a1, #_lpos_C* a0, #_int n]
    (dotimes [#_int i n]
        (COPY-lpos (... a1 i), (... a0 i))
    )
    nil)

;; ----------------------------------------------------------------------- ;;

;; The number of sub-matches is limited to 10.
;; The first one (index 0) is the whole match, referenced with "\0".
;; The second one (index 1) is the first sub-match, referenced with "\1".
;; This goes up to the tenth (index 9), referenced with "\9".

(final int NSUBEXP  10)

;; In the NFA engine: how many braces are allowed.

(final int NFA_MAX_BRACES 20)

;; In the NFA engine: how many states are allowed.

(final int NFA_MAX_STATES 100000)
(final int NFA_TOO_EXPENSIVE -1)

;; Which regexp engine to use? Needed for vim-regcomp().
;; Must match with 'regexpengine'.

(final int
    AUTOMATIC_ENGINE    0,
    BACKTRACKING_ENGINE 1,
    NFA_ENGINE          2)

;; Structure returned by vim-regcomp() to pass on to vim-regexec().
;; This is the general structure.  For the actual matcher, two specific
;; structures are used.  See code below.

(ร
;   static abstract class regprog_C
    (ยง
;       regengine_C         engine;
;       int                 regflags;
;       int                 re_engine;      ;; automatic, backtracking or nfa engine
;       int                 re_flags;       ;; second argument for vim-regcomp()

;       protected regprog_C()
;       {
;       }
    ))

;; Structure used by the back track matcher.
;; These fields are only to be used in regexp.c!
;; See regexp.c for an explanation.

(ร
;   static final class bt_regprog_C extends regprog_C
    (ยง
;       int                 reganch;
;       int                 regstart;
;       Bytes               regmust;
;       int                 regmlen;
;       int                 reghasz;
;       Bytes               program;
    ))

;; Structure representing a NFA state.
;; A NFA state may have no outgoing edge, when it is a NFA_MATCH state.

(declare NEW_fragnode_C)

(class! #_final nfa_state_C
    [
        (field int          c)
        (field fragnode_C   out0        (NEW_fragnode_C))
        (field fragnode_C   out1        (NEW_fragnode_C))
        (field int          id)
        (field int*         lastlist    2)  ;; 0: normal, 1: recursive
        (field int          val)

;       #_private void out0(nfa_state_C out0)
;       {
; %%        ((ร this.out0.fn_next =) out0)
;       }

;       #_private void out1(nfa_state_C out1)
;       {
; %%        ((ร this.out1.fn_next =) out1)
;       }

;       #_private nfa_state_C out0()
;       {
; %%        ((ร RETURN) (ร (nfa_state_C)(out0.fn_next)))
;       }

;       #_private nfa_state_C out1()
;       {
; %%        ((ร RETURN) (ร (nfa_state_C)(out1.fn_next)))
;       }
    ])

;; Structure used by the NFA matcher.

(ร
;   static final class nfa_regprog_C extends regprog_C
    (ยง
;       nfa_state_C         start;          ;; points into state[]

;       int                 reganch;        ;; pattern starts with ^
;       int                 regstart;       ;; char at start of pattern
;       Bytes               match_text;     ;; plain text to match with

;       boolean             has_zend;       ;; pattern contains \ze
;       boolean             has_backref;    ;; pattern contains \1 .. \9
;       int                 reghasz;
;       Bytes               pattern;
;       int                 nsubexp;        ;; number of ()

;       int                 nstate;         ;; states.length
;       nfa_state_C[]       states;
;       int                 istate;         ;; index in states == number of states allocated
    ))

;; Structure to be used for single-line matching.
;; Sub-match "no" starts at "startp[no]" and ends just before "endp[no]".
;; When there is no match, the pointer is null.

(class! #_final regmatch_C
    [
        (field regprog_C    regprog)
        (field Bytes*       startp      NSUBEXP)
        (field Bytes*       endp        NSUBEXP)
        (field boolean      rm_ic)
    ])

;; Structure to be used for multi-line matching.
;; Sub-match "no" starts in line "startpos[no].lnum" column "startpos[no].col"
;; and ends in line "endpos[no].lnum" just before column "endpos[no].col".
;; The line numbers are relative to the first line, thus startpos[0].lnum is always 0.
;; When there is no match, the line number is -1.

(class! #_final regmmatch_C
    [
        (field regprog_C    regprog)
        (field lpos_C*      startpos    (ARRAY-lpos NSUBEXP))
        (field lpos_C*      endpos      (ARRAY-lpos NSUBEXP))
        (field boolean      rmm_ic)
        (field int          rmm_maxcol)     ;; when not zero: maximum column
    ])

(defn- #_void COPY-regmmatch [#_regmmatch_C rmm1, #_regmmatch_C rmm0]
    (ยง
        ((ร rmm1.regprog =) (:regprog rmm0))
        (COPY--lpos (:startpos rmm1), (:startpos rmm0), NSUBEXP)
        (COPY--lpos (:endpos rmm1), (:endpos rmm0), NSUBEXP)
        ((ร rmm1.rmm_ic =) (:rmm_ic rmm0))
        ((ร rmm1.rmm_maxcol =) (:rmm_maxcol rmm0))
        nil
    ))

;; Structure used to store external references: "\z\(\)" to "\z\1".
;; Use a reference count to avoid the need to copy this around.
;; When it goes from 1 to zero the matches need to be freed.

(class! #_final reg_extmatch_C
    [
        (field Bytes*       matches     NSUBEXP)
    ])

(ร
;   static abstract class regengine_C
    (ยง
        ((ร Bytes expr =) (u8 ""))

;       protected regengine_C()
;       {
;       }

;       public abstract regprog_C regcomp(Bytes expr, int re_flags);
;       public abstract long regexec_nl(regmatch_C rmp, Bytes line, int col, boolean line_lbr);
;       public abstract long regexec_multi(regmmatch_C rmp, window_C win, buffer_C buf, long lnum, int col, long nsec);
    ))

;; ----------------------------------------------------------------------- ;;

;; marks: positions in a file
;; (a normal mark is a lnum/col pair, the same as a file position)

(final int NMARKS (inc (- (int \z) (int \a))))  ;; max. # of named marks
(final int JUMPLISTSIZE 100)        ;; max. # of marks in jump list

(class! #_final fmark_C
    [
        (field pos_C    mark    (NEW_pos_C))      ;; cursor position
    ])

(defn- #_void COPY-fmark [#_fmark_C fm1, #_fmark_C fm0]
    (COPY-pos (:mark fm1), (:mark fm0))
    nil)

(defn- #_fmark_C* ARRAY-fmark [#_int n]
    (vec (repeatedly n NEW_fmark_C)))

;; Structure that contains all options that are local to a window.
;; Used twice in a window: for the current buffer and for all buffers.

(class! #_final winopt_C
    [
        (atom' boolean wo_bri)      ;; 'breakindent'
        (atom' Bytes   wo_briopt)   ;; 'breakindentopt'
        (atom' boolean wo_lbr)      ;; 'linebreak'
        (atom' boolean wo_nu)       ;; 'number'
        (atom' boolean wo_rnu)      ;; 'relativenumber'
        (atom' long    wo_nuw)      ;; 'numberwidth'
        (atom' boolean wo_wfh)      ;; 'winfixheight'
        (atom' boolean wo_wfw)      ;; 'winfixwidth'
        (atom' long    wo_scr)      ;; 'scroll'
        (atom' boolean wo_cuc)      ;; 'cursorcolumn'
        (atom' boolean wo_cul)      ;; 'cursorline'
        (atom' Bytes   wo_cc)       ;; 'colorcolumn'
        (atom' boolean wo_scb)      ;; 'scrollbind'
        (atom' boolean wo_wrap)     ;; 'wrap'
        (atom' Bytes   wo_cocu)     ;; 'concealcursor'
        (atom' long    wo_cole)     ;; 'conceallevel'
        (atom' boolean wo_crb)      ;; 'cursorbind'
    ])

;; Structure to store info about the Visual area.
(class! #_final visualinfo_C
    [
        (field pos_C        vi_start    (NEW_pos_C))      ;; start pos of last VIsual
        (field pos_C        vi_end      (NEW_pos_C))      ;; end position of last VIsual
        (field int          vi_mode)                    ;; VIsual_mode of last VIsual
        (field int          vi_curswant)                ;; MAXCOL from w_curswant
    ])

(defn- #_void COPY-visualinfo [#_visualinfo_C vi1, #_visualinfo_C vi0]
    (ยง
        (COPY-pos (:vi_start vi1), (:vi_start vi0))
        (COPY-pos (:vi_end vi1), (:vi_end vi0))
        ((ร vi1.vi_mode =) (:vi_mode vi0))
        ((ร vi1.vi_curswant =) (:vi_curswant vi0))
        nil
    ))

;; structures used for undo

(class! #_final u_entry_C
    [
        (field u_entry_C    ue_next)        ;; pointer to next entry in list
        (field long         ue_top)         ;; number of line above undo block
        (field long         ue_bot)         ;; number of line below undo block
        (field long         ue_lcount)      ;; linecount when u-save() called
        (field Bytes*       ue_array)       ;; array of lines in undo block
        (field long         ue_size)        ;; number of lines in "ue_array"
    ])

(class! #_final u_link_C
    [
        (field u_header_C   ptr)
        (field long         seq)
    ])

(class! #_final u_header_C
    [
        ;; The following have a pointer and a number.
        ;; The number is used when reading the undo file in u_read_undo().
        (field u_link_C     uh_next         (NEW_u_link_C))       ;; next undo header in list
        (field u_link_C     uh_prev         (NEW_u_link_C))       ;; previous header in list
        (field u_link_C     uh_alt_next     (NEW_u_link_C))       ;; next header for alt. redo
        (field u_link_C     uh_alt_prev     (NEW_u_link_C))       ;; previous header for alt. redo
        (field long         uh_seq)                             ;; sequence number, higher == newer undo
        (field int          uh_walk)                            ;; used by undo-time()
        (field u_entry_C    uh_entry)                           ;; pointer to first entry
        (field u_entry_C    uh_getbot_entry)                    ;; pointer to where ue_bot must be set
        (field pos_C        uh_cursor       (NEW_pos_C))          ;; cursor position before saving
        (field long         uh_cursor_vcol)
        (field int          uh_flags)                           ;; see below
        (field pos_C*       uh_namedm       (ARRAY-pos NMARKS)) ;; marks before undo/after redo
        (field visualinfo_C uh_visual       (NEW_visualinfo_C))   ;; Visual areas before undo/after redo
        (field long         uh_time)                            ;; timestamp when the change was made
    ])

;; values for uh_flags
(final int UH_CHANGED  0x01)            ;; "b_changed" flag before undo/after redo
(final int UH_EMPTYBUF 0x02)            ;; buffer was empty

;; structure used to store one block of the stuff/redo/recording buffers

(class! #_final buffblock_C
    [
        (field buffblock_C  bb_next)        ;; pointer to next buffblock
        (field Bytes        bb_str)         ;; contents
    ])

(defn- #_void COPY-buffblock [#_buffblock_C bb1, #_buffblock_C bb0]
    (ยง
        ((ร bb1.bb_next =) (:bb_next bb0))
        ((ร bb1.bb_str =) (:bb_str bb0))
        nil
    ))

;; header used for the stuff buffer and the redo buffer

(class! #_final buffheader_C
    [
        (field buffblock_C  bh_first    (NEW_buffblock_C))    ;; first (dummy) block of list
        (field buffblock_C  bh_curr)        ;; buffblock for appending
        (field int          bh_index)       ;; index for reading
        (field int          bh_space)       ;; space in bh_curr for appending
    ])

(defn- #_void COPY-buffheader [#_buffheader_C bh1, #_buffheader_C bh0]
    (ยง
        (COPY-buffblock (:bh_first bh1), (:bh_first bh0))
        ((ร bh1.bh_curr =) (:bh_curr bh0))
        ((ร bh1.bh_index =) (:bh_index bh0))
        ((ร bh1.bh_space =) (:bh_space bh0))
        nil
    ))

;; things used in memline.c

;; 'ml_flags':
(final int ML_EMPTY        1)   ;; empty buffer

;; The memline structure holds all the information about a memline.

(class! #_final memline_C
    [
        (field long         ml_line_count)      ;; number of lines in the buffer

        (field int          ml_flags)
    ])

;; Structure shared between syntax.c and screen.c.

(class! #_final attrentry_C
    [
        (field int          ae_attr)            ;; HL_BOLD, etc.
        (field Bytes        ae_esc_start)       ;; start escape sequence
        (field Bytes        ae_esc_stop)        ;; stop escape sequence
    ;; These colors need to be > 8 bits to hold 256.
        (field int          ae_fg_color)        ;; foreground color number
        (field int          ae_bg_color)        ;; background color number
    ])

(defn- #_void ZER0-attrentry [#_attrentry_C ae]
    (ยง
        ((ร ae.ae_attr =) 0)
        ((ร ae.ae_esc_start =) nil)
        ((ร ae.ae_esc_stop =) nil)
        ((ร ae.ae_fg_color =) 0)
        ((ร ae.ae_bg_color =) 0)
        nil
    ))

(defn- #_void COPY-attrentry [#_attrentry_C ae1, #_attrentry_C ae0]
    (ยง
        ((ร ae1.ae_attr =) (:ae_attr ae0))
        ((ร ae1.ae_esc_start =) (:ae_esc_start ae0))
        ((ร ae1.ae_esc_stop =) (:ae_esc_stop ae0))
        ((ร ae1.ae_fg_color =) (:ae_fg_color ae0))
        ((ร ae1.ae_bg_color =) (:ae_bg_color ae0))
        nil
    ))

;; Used for the typeahead buffer: typebuf.

(class! #_final typebuf_C
    [
        (field Bytes        tb_buf)             ;; buffer for typed characters
        (field int          tb_buflen)          ;; size of "tb_buf"
        (field int          tb_off)             ;; current position in "tb_buf"
        (field int          tb_len)             ;; number of valid bytes in "tb_buf"
        (field int          tb_change_cnt)      ;; nr of time "tb_buf" was changed; never zero
    ])

;; buffer: structure that holds information about one file
;;
;; Several windows can share a single Buffer.

(class! #_final buffer_C
    [
        (field memline_C    b_ml)               ;; associated memline (also contains line count)

        (field int          b_nwindows)         ;; nr of windows open on this buffer

        (atom' boolean      b_changed)          ;; 'modified'
        (field int          b_changedtick)      ;; incremented for each change, also for undo

        ;; Changes to a buffer require updating of the display.
        ;; To minimize the work, remember changes made and update everything at once.

        (field boolean      b_mod_set)          ;; true when there are changes since the last time the display was updated
        (field long         b_mod_top)          ;; topmost lnum that was changed
        (field long         b_mod_bot)          ;; lnum below last changed line, AFTER the change
        (field long         b_mod_xlines)       ;; number of extra buffer lines inserted; negative when lines were deleted

        (field pos_C*       b_namedm)           ;; current named marks (mark.c)

        ;; These variables are set when VIsual_active becomes false.
        (field visualinfo_C b_visual)
        (field int          b_visual_mode_eval) ;; b_visual.vi_mode for visualmode()

        (field pos_C        b_last_cursor)      ;; cursor position when last unloading this buffer
        (field pos_C        b_last_insert)      ;; where Insert mode was left
        (field pos_C        b_last_change)      ;; position of last change: '. mark

        ;; the changelist contains old change positions

        (field pos_C*       b_changelist)
        (field int          b_changelistlen)    ;; number of active entries
        (field boolean      b_new_change)       ;; set by u-savecommon()

        ;; Character table, only used in charset.c for 'iskeyword'.
        ;; 8 bytes of 32 bits: 1 bit per character 0-255.

        (field int*         b_chartab)

        ;; start and end of an operator, also used for '[ and ']

        (field pos_C        b_op_start)
        (field pos_C        b_op_start_orig)    ;; used for insStart_orig
        (field pos_C        b_op_end)

        ;; The following only used in undo.c.

        (field u_header_C   b_u_oldhead)        ;; pointer to oldest header
        (field u_header_C   b_u_newhead)        ;; pointer to newest header; may not be valid if b_u_curhead is not null
        (field u_header_C   b_u_curhead)        ;; pointer to current header
        (field int          b_u_numhead)        ;; current number of headers
        (field boolean      b_u_synced)         ;; entry lists are synced
        (field long         b_u_seq_last)       ;; last used undo sequence number
        (field long         b_u_seq_cur)        ;; hu_seq of header below which we are now
        (field long         b_u_time_cur)       ;; uh_time of header below which we are now

        ;; variables for "U" command in undo.c

        (field Bytes        b_u_line_ptr)       ;; saved line for "U" command
        (field long         b_u_line_lnum)      ;; line number of line in u_line
        (field int          b_u_line_colnr)     ;; optional column number

        ;; Options local to a buffer.
        ;; They are here because their value depends on the type of file
        ;; or contents of the file being edited.

        (atom' boolean      b_p_ai)             ;; 'autoindent'
        (field boolean      b_p_ai_nopaste)     ;; "b_p_ai" saved for paste mode
        (atom' boolean      b_p_ci)             ;; 'copyindent'
        (atom' Bytes        b_p_cinw)           ;; 'cinwords'
        (atom' boolean      b_p_et)             ;; 'expandtab'
        (atom' Bytes        b_p_isk)            ;; 'iskeyword'
        (atom' Bytes        b_p_kp)             ;; 'keywordprg'
        (atom' Bytes        b_p_mps)            ;; 'matchpairs'
        (atom' Bytes        b_p_nf)             ;; 'nrformats'
        (atom' boolean      b_p_pi)             ;; 'preserveindent'
        (atom' Bytes        b_p_qe)             ;; 'quoteescape'
        (atom' long         b_p_sw)             ;; 'shiftwidth'
        (atom' boolean      b_p_si)             ;; 'smartindent'
        (atom' long         b_p_sts)            ;; 'softtabstop'
        (field long         b_p_sts_nopaste)    ;; "b_p_sts" saved for paste mode
        (atom' long         b_p_ts)             ;; 'tabstop'
        (atom' long         b_p_ul)             ;; 'undolevels'
    ])

(atom! long         ch_used)         ;; value of 'cmdheight' when frame size was set

;; Structure to cache info for displayed lines in w_lines[].
;; Each logical line has one entry.
;; The entry tells how the logical line is currently displayed in the window.
;; This is updated when displaying the window.
;; When the display is changed (e.g., when clearing the screen) w_lines_valid
;; is changed to exclude invalid entries.
;; When making changes to the buffer, wl_valid is reset to indicate wl_size
;; may not reflect what is actually in the buffer.  When wl_valid is false,
;; the entries can only be used to count the number of displayed lines used.
;; wl_lnum and wl_lastlnum are invalid too.

(class! #_final wline_C
    [
        (field long         wl_lnum)        ;; buffer line number for logical line
        (field int          wl_size)        ;; height in screen lines
        (field boolean      wl_valid)       ;; true values are valid for text in buffer
    ])

(defn- #_void COPY-wline [#_wline_C wl1, #_wline_C wl0]
    (ยง
        ((ร wl1.wl_lnum =) (:wl_lnum wl0))
        ((ร wl1.wl_size =) (:wl_size wl0))
        ((ร wl1.wl_valid =) (:wl_valid wl0))
        nil
    ))

(defn- #_wline_C* ARRAY-wline [#_int n]
    (vec (repeatedly n NEW_wline_C)))

;; Windows are kept in a tree of frames.  Each frame has a column (FR_COL)
;; or row (FR_ROW) layout or is a leaf, which has a window.

(class! #_final frame_C
    [
        (field byte         fr_layout)      ;; FR_LEAF, FR_COL or FR_ROW
        (field int          fr_width)
        (field int          fr_newwidth)    ;; new width used in win-equal-rec()
        (field int          fr_height)
        (field int          fr_newheight)   ;; new height used in win-equal-rec()
        (field frame_C      fr_parent)      ;; containing frame or null
        (field frame_C      fr_next)        ;; frame right or below in same parent, null for first
        (field frame_C      fr_prev)        ;; frame left or above in same parent, null for last
                                            ;; fr_child and fr_win are mutually exclusive
        (field frame_C      fr_child)       ;; first contained frame
        (field window_C     fr_win)         ;; window that fills this frame
    ])

(defn- #_void COPY-frame [#_frame_C fr1, #_frame_C fr0]
    (ยง
        ((ร fr1.fr_layout =) (:fr_layout fr0))
        ((ร fr1.fr_width =) (:fr_width fr0))
        ((ร fr1.fr_newwidth =) (:fr_newwidth fr0))
        ((ร fr1.fr_height =) (:fr_height fr0))
        ((ร fr1.fr_newheight =) (:fr_newheight fr0))
        ((ร fr1.fr_parent =) (:fr_parent fr0))
        ((ร fr1.fr_next =) (:fr_next fr0))
        ((ร fr1.fr_prev =) (:fr_prev fr0))
        ((ร fr1.fr_child =) (:fr_child fr0))
        ((ร fr1.fr_win =) (:fr_win fr0))
        nil
    ))

(final byte
    FR_LEAF 0,            ;; frame is a leaf
    FR_ROW  1,            ;; frame with a row of windows
    FR_COL  2)            ;; frame with a column of windows

;; Struct used for highlighting 'hlsearch' matches, matches defined by ":match" and
;; matches defined by match functions.  For 'hlsearch' there is one pattern for all windows.
;; For ":match" and the match functions there is a different pattern for each window.

(class! #_final match_C
    [
        (field regmmatch_C  rmm     (NEW_regmmatch_C))    ;; points to the regexp program; contains last found match (may continue in next line)
        (field buffer_C     buf)                        ;; the buffer to search for a match
        (field long         lnum)                       ;; the line to search for a match
        (field int          attr)                       ;; attributes to be used for a match
        (field int          attr_cur)                   ;; attributes currently active in win-line()
        (field long         first_lnum)                 ;; first lnum to search for multi-line pat
        (field int          startcol)                   ;; in win-line() points to char where HL starts
        (field int          endcol)                     ;; in win-line() points to char where HL ends
        (field long         nsec)                       ;; for a time limit
    ])

;; number of positions supported by matchaddpos()
(final int MAXPOSMATCH 8)

;; Same as lpos_C, but with additional field len.

(class! #_final llpos_C
    [
        (field long     lnum)       ;; line number
        (field int      col)        ;; column number
        (field int      len)        ;; length: 0 - to the end of line
    ])

(defn- #_void COPY-llpos [#_llpos_C llp1, #_llpos_C llp0]
    (ยง
        ((ร llp1.lnum =) (:lnum llp0))
        ((ร llp1.col =) (:col llp0))
        ((ร llp1.len =) (:len llp0))
        nil
    ))

(defn- #_llpos_C* ARRAY-llpos [#_int n]
    (vec (repeatedly n NEW_llpos_C)))

;; posmatch_C provides an array for storing match items for matchaddpos() function.

(class! #_final posmatch_C
    [
        (field llpos_C* pm_pos  (ARRAY-llpos MAXPOSMATCH))  ;; array of positions
        (field int      cur)        ;; internal position counter
        (field long     toplnum)    ;; top buffer line
        (field long     botlnum)    ;; bottom buffer line
    ])

;; matchitem_C provides a linked list for storing match items for ":match" and the match functions.

(class! #_final matchitem_C
    [
        (field matchitem_C  next)
        (field int          id)             ;; match ID
        (field int          priority)       ;; match priority
        (field Bytes        pattern)        ;; pattern to highlight
        (field int          hlg_id)         ;; highlight group ID
        (field regmmatch_C  mi_match    (NEW_regmmatch_C))    ;; regexp program for "pattern"
        (field posmatch_C   mi_pos      (NEW_posmatch_C))     ;; position matches
        (field match_C      mi_hl       (NEW_match_C))        ;; struct for doing the actual highlighting
    ])

;; Structure which contains all information that belongs to a window
;;
;; All row numbers are relative to the start of the window, except w_winrow.

(class! #_final window_C
    [
        (field window_C     w_prev)             ;; link to previous window
        (field window_C     w_next)             ;; link to next window

        (field frame_C      w_frame)            ;; frame containing this window

        (field pos_C        w_cursor            (NEW_pos_C))  ;; cursor position in buffer
        (field int          w_curswant)         ;; column we'd like to be at: used to try to stay in the same column for up/down cursor motions
        (field boolean      w_set_curswant)     ;; if set, update w_curswant the next time through cursupdate() to the current virtual column

        ;; the next six are used to update the visual part

        (field int          w_old_visual_mode)  ;; last known VIsual_mode
        (field long         w_old_cursor_lnum)  ;; last known end of visual part
        (field int          w_old_cursor_fcol)  ;; first column for block visual part
        (field int          w_old_cursor_lcol)  ;; last column for block visual part
        (field long         w_old_visual_lnum)  ;; last known start of visual part
        (field int          w_old_visual_col)   ;; last known start of visual part
        (field int          w_old_curswant)     ;; last known value of curswant

        ;; "w_topline", "w_leftcol" and "w_skipcol" specify the offsets for displaying the buffer.

        (field long         w_topline)          ;; buffer line number of the line at the top of the window
        (field boolean      w_topline_was_set)  ;; flag set to true when topline is set, e.g. by winrestview()
        (field int          w_leftcol)          ;; window column of the leftmost character in the window; used when 'wrap' is off
        (field int          w_skipcol)          ;; starting column when a single line doesn't fit in the window

        ;; Layout of the window in the screen.
        ;; May need to add "msg_scrolled" to "w_winrow" in rare situations.

        (field int          w_winrow)           ;; first row of window in screen
        (field int          w_height)           ;; number of rows in window, excluding status/command line(s)
        (field int          w_status_height)    ;; number of status lines (0 or 1)
        (field int          w_wincol)           ;; leftmost column of window in screen
        (field int          w_width)            ;; width of window, excluding separation
        (field int          w_vsep_width)       ;; number of separator columns (0 or 1)

        ;; === start of cached values ====

        ;; Recomputing is minimized by storing the result of computations.
        ;; Use functions in screen.c to check if they are valid and to update.
        ;; w_valid is a bitfield of flags, which indicate if specific values are
        ;; valid or need to be recomputed.  See screen.c for values.

        (field int          w_valid)
        (field pos_C        w_valid_cursor      (NEW_pos_C))  ;; last known position of w_cursor, used to adjust w_valid
        (field int          w_valid_leftcol)    ;; last known w_leftcol

        ;; w_cline_height is the number of physical lines taken by the buffer line
        ;; that the cursor is on.  We use this to avoid extra calls to plines().

        (field int          w_cline_height)     ;; current size of cursor line

        (field int          w_cline_row)        ;; starting row of the cursor line

        (field int          w_virtcol)          ;; Column number of the cursor in the buffer line,
                                                ;; as opposed to the column number we're at on the screen.
                                                ;; This makes a difference on lines which span more than
                                                ;; one screen line or when w_leftcol is non-zero.

        ;; w_wrow and w_wcol specify the cursor position in the window.
        ;; This is related to positions in the window, not in the display
        ;; or buffer, thus w_wrow is relative to w_winrow.

        (field int          w_wrow)
        (field int          w_wcol)

        (field long         w_botline)          ;; number of the line below the bottom of the screen
        (field int          w_empty_rows)       ;; number of ~ rows in window

        ;; Info about the lines currently in the window is remembered to avoid
        ;; recomputing it every time.  The allocated size of w_lines[] is Rows.
        ;; Only the w_lines_valid entries are actually valid.
        ;; When the display is up-to-date w_lines[0].wl_lnum is equal to w_topline
        ;; and w_lines[w_lines_valid - 1].wl_lnum is equal to w_botline.
        ;; Between changing text and updating the display w_lines[] represents
        ;; what is currently displayed.  wl_valid is reset to indicated this.
        ;; This is used for efficient redrawing.

        (field int          w_lines_valid)      ;; number of valid entries
        (field wline_C*     w_lines)
        (field int          w_lines_len)

        (field int          w_nrwidth)          ;; width of 'number' and 'relativenumber' column being used

        ;; === end of cached values ===

        (field int          w_redr_type)        ;; type of redraw to be performed on win
        (field int          w_upd_rows)         ;; number of window lines to update when w_redr_type is REDRAW_TOP
        (field long         w_redraw_top)       ;; when != 0: first line needing redraw
        (field long         w_redraw_bot)       ;; when != 0: last line needing redraw
        (field boolean      w_redr_status)      ;; if true status line must be redrawn

        ;; remember what is shown in the ruler for this window (if 'ruler' set)
        (field pos_C        w_ru_cursor         (NEW_pos_C))  ;; cursor position shown in ruler
        (field int          w_ru_virtcol)       ;; virtcol shown in ruler
        (field long         w_ru_topline)       ;; topline shown in ruler
        (field long         w_ru_line_count)    ;; line count used for ruler
        (field boolean      w_ru_empty)         ;; true if ruler shows 0-1 (empty line)

        ;; Options local to a window.
        ;; They are local because they influence the layout of the window or depend on the window layout.

        (field winopt_C     w_options    (NEW_winopt_C))

        (field int*         w_p_cc_cols)        ;; array of columns to highlight or null
        (field int          w_p_brimin)         ;; minimum width for breakindent
        (field int          w_p_brishift)       ;; additional shift for breakindent
        (field boolean      w_p_brisbr)         ;; sbr in 'briopt'

        (field long         w_scbind_pos)

        ;; w_prev_pcmark is used to check whether we really did jump to a new line after setting w_pcmark.
        ;; If not, we revert to using the previous w_pcmark.

        (field pos_C        w_pcmark            (NEW_pos_C))  ;; previous context mark
        (field pos_C        w_prev_pcmark       (NEW_pos_C))  ;; previous w_pcmark

        ;; the jumplist contains old cursor positions

        (field fmark_C*     w_jumplist      (ARRAY-fmark JUMPLISTSIZE))
        (field int          w_jumplistlen)      ;; number of active entries
        (field int          w_jumplistidx)      ;; current position

        (field int          w_changelistidx)    ;; current position in b_changelist

        (field matchitem_C  w_match_head)       ;; head of match list
        (field int          w_next_match_id)    ;; next match ID

        ;; w_fraction is the fractional row of the cursor within the window,
        ;; from 0 at the top row to FRACTION_MULT at the last row.
        ;; w_prev_fraction_row was the actual cursor row when w_fraction was last calculated.

        (field int          w_fraction)
        (field int          w_prev_fraction_row)

        (field long         w_nrwidth_line_count)   ;; line count when ml_nrwidth_width was computed
        (field long         w_nuw_cached)           ;; 'numberwidth' option cached
        (field int          w_nrwidth_width)        ;; nr of chars to print line count
    ])

;; Arguments for operators.

(class! #_final oparg_C
    [
        (field int          op_type)            ;; current pending operator type
        (field int          regname)            ;; register to use for the operator
        (field byte         motion_type)        ;; type of the current cursor motion
        (field int          motion_force)       ;; force motion type: 'v', 'V' or CTRL-V
        (field boolean      use_reg_one)        ;; true if delete uses reg 1 even when not linewise
        (field boolean      inclusive)          ;; true if char motion is inclusive (only valid when motion_type is MCHAR)
        (field boolean      end_adjusted)       ;; backuped b_op_end one char (only used by do_format())
        (field pos_C        op_start        (NEW_pos_C))  ;; start of the operator
        (field pos_C        op_end          (NEW_pos_C))  ;; end of the operator
        (field pos_C        cursor_start    (NEW_pos_C))  ;; cursor position before motion for "gw"
        (field long         line_count)         ;; number of lines from op_start to op_end (inclusive)
        (field boolean      empty)              ;; op_start and op_end the same (only used by do_change())
        (field boolean      is_VIsual)          ;; operator on Visual area
        (field boolean      block_mode)         ;; current operator is Visual block mode
        (field int          start_vcol)         ;; start col for block mode operator
        (field int          end_vcol)           ;; end col for block mode operator
        (field long         prev_opcount)       ;; ca.opcount saved for K_CURSORHOLD
        (field long         prev_count0)        ;; ca.count0 saved for K_CURSORHOLD
    ])

;; Arguments for Normal mode commands.

(class! #_final cmdarg_C
    [
        (field oparg_C      oap)                ;; operator arguments
        (field int          prechar)            ;; prefix character (optional, always 'g')
        (field int          cmdchar)            ;; command character
        (atom' int          nchar)              ;; next command character (optional)
        (field int          ncharC1)            ;; first composing character (optional)
        (field int          ncharC2)            ;; second composing character (optional)
        (atom' int          extra_char)         ;; yet another character (optional)
        (field long         opcount)            ;; count before an operator
        (field long         count0)             ;; count before command, default 0
        (field long         count1)             ;; count before command, default 1
        (field int          arg)                ;; extra argument from nv_cmds[]
        (field int          retval)             ;; return: CA_* values
        (field Bytes        searchbuf)          ;; return: pointer to search pattern or null
    ])

;; values for retval:
(final int CA_COMMAND_BUSY  1)  ;; skip restarting edit() once
(final int CA_NO_ADJ_OP_END 2)  ;; don't adjust operator end

;;; ============================================================================================== VimE

;; ex_cmds.h --------------------------------------------------------------------------------------

(final int
    RANGE           0x001,   ;; allow a linespecs
    BANG            0x002,   ;; allow a ! after the command name
    EXTRA           0x004,   ;; allow extra args after command name
    NOSPC           0x010,   ;; no spaces allowed in the extra part
    DFLALL          0x020,   ;; default file range is 1,$
    NEEDARG         0x080,   ;; argument required
    COUNT           0x400,   ;; allow count in argument, after command
    ZEROR          0x1000,   ;; zero line number allowed
    NOTADR         0x4000,   ;; number before command is not an address
    CMDWIN       0x100000,   ;; allowed in cmdline window

    WORD1 (| EXTRA NOSPC))   ;; one extra word allowed

;; values for cmd_addr_type
(final byte
    ADDR_LINES          0,
    ADDR_WINDOWS        1)

(final int
    CMD_close 0,
    CMD_fixdel 1,
    CMD_only 2,
    CMD_retab 3,
    CMD_substitute 4,
    CMD_set 5,
    CMD_stop 6,
    CMD_suspend 7,
    CMD_syncbind 8,

    CMD_SIZE 9)     ;; MUST be after all real commands!

;; Arguments used for Ex commands.

(class! #_final exarg_C
    [
        (field Bytes        arg)            ;; argument of the command
        (field Bytes        nextcmd)        ;; next command (null if none)
        (field Bytes        cmd)            ;; the name of the command (except for :make)
        (field Bytes*       cmdlinep)       ;; pointer to pointer of allocated cmdline
        (field int          cmdidx)         ;; the index for the command
        (field long         argt)           ;; flags for the command
        (field boolean      skip)           ;; don't execute the command, only parse it
        (field boolean      forceit)        ;; true if ! present
        (field int          addr_count)     ;; the number of addresses given
        (field long         line1)          ;; the first line number
        (field long         line2)          ;; the second line number or count
        (field int          addr_type)      ;; type of the count/range
        (field int          regname)        ;; register name (NUL if none)
        (field Bytes        errmsg)         ;; returned error message
    ])

;; ----------------------------------------------------------------------- ;;

(defn- #_boolean asc-islower [#_int c] (<= (byte \a) c (byte \z)))
(defn- #_boolean asc-isupper [#_int c] (<= (byte \A) c (byte \Z)))
(defn- #_boolean asc-isalpha [#_int c] (or (asc-isupper c) (asc-islower c)))
(defn- #_boolean asc-isalnum [#_int c] (or (asc-isalpha c) (asc-isdigit c)))
(defn- #_boolean asc-iscntrl [#_int c] (or (<= 0x00 c 0x1f) (== c 0x7f)))
(defn- #_boolean asc-isgraph [#_int c] (<= 0x21 c 0x7e))
(defn- #_boolean asc-isprint [#_int c] (<= 0x20 c 0x7e))
(defn- #_boolean asc-ispunct [#_int c] (or (<= 0x21 c 0x2f) (<= 0x3a c 0x40) (<= 0x5b c 0x60) (<= 0x7b c 0x7e)))

;;; ============================================================================================== VimF

;; #include "globals.h"             ;; global variables and messages

;; Number of Rows and Cols in the screen.
;; Must be long to be able to use them as options in option.c.
;; Note: Use screenRows and screenCols to access items in screenLines[].
;; They may have different values when the screen wasn't (re)allocated yet
;; after setting Rows or Cols (e.g., when starting up).

(atom! long   Rows      24)      ;; nr of rows in the screen
(atom! long   Cols      80)      ;; nr of columns in the screen

;; The characters that are currently on the screen are kept in screenLines[].
;; It is a single block of characters, the size of the screen plus one line.
;; The attributes for those characters are kept in screenAttrs[].
;;
;; "lineOffset[n]" is the offset from screenLines[] for the start of line 'n'.
;; The same value is used for screenLinesUC[] and screenAttrs[].
;;
;; Note: before the screen is initialized and when out of memory these can be null.

(atom! Bytes    screenLines)
(atom! int*     screenAttrs)
(atom! int*     lineOffset)
(atom! boolean* lineWraps)          ;; line wraps to next line

;; When using Unicode characters (in UTF-8 encoding) the character in
;; screenLinesUC[] contains the Unicode for the character at this position,
;; or NUL when the character in screenLines[] is to be used (ASCII char).
;; The composing characters are to be drawn on top of the original character.
;; screenLinesC[0][off] is only to be used when screenLinesUC[off] != 0.

(atom! int*     screenLinesUC)      ;; decoded UTF-8 characters
(atom! int**    screenLinesC    MAX_MCO)    ;; composing characters
(atom! int      screen_mco)         ;; value of "p_mco" used when allocating screenLinesC[]

(atom! int      screenRows)         ;; actual size of screenLines[]
(atom! int      screenCols)      ;; actual size of screenLines[]

;; When vgetc() is called, it sets mod_mask to the set of modifiers that are
;; held down based on the MOD_MASK_* symbols that are read first.

(atom! int      mod_mask)           ;; current key modifiers

;; Cmdline_row is the row where the command line starts, just below the last window.
;; When the cmdline gets longer than the available space the screen gets scrolled up.
;; After a CTRL-D (show matches), after hitting ':' after "hit return",
;; and for the :global command, the command line is temporarily moved.
;; The old position is restored with the next call to update-screen().

(atom! int      cmdline_row)

(atom! boolean  redraw_cmdline)     ;; cmdline must be redrawn
(atom! boolean  clear_cmdline)      ;; cmdline must be cleared
(atom! boolean  mode_displayed)     ;; mode is being displayed
(atom! int      cmdline_star)       ;; cmdline is crypted

(atom! boolean  exec_from_reg)      ;; executing register

(atom! maybean  screen_cleared FALSE)     ;; screen has been cleared

;; Functions for putting characters in the command line,
;; while keeping screenLines[] updated.

(atom! int      msg_col)
(atom! int      msg_row)
(atom! int      msg_scrolled)       ;; number of screen lines that windows have scrolled because of printing messages
(atom! boolean  msg_scrolled_ign)   ;; when true don't set need_wait_return in msg-puts-attr() when msg_scrolled is non-zero

(atom! Bytes    keep_msg)           ;; msg to be shown after redraw
(atom! int      keep_msg_attr)      ;; highlight attr for "keep_msg"
(atom! boolean  keep_msg_more)      ;; "keep_msg" was set by msgmore()
(atom! boolean  need_fileinfo)      ;; do fileinfo() after redraw
(atom! boolean  msg_scroll)         ;; msg-start() will scroll
(atom! boolean  msg_didout)         ;; msg_outstr() was used in line
(atom! boolean  msg_didany)         ;; msg_outstr() was used at all
(atom! boolean  msg_nowait)         ;; don't wait for this msg
(atom! int      emsg_off)           ;; don't display errors for now
(atom! boolean  info_message)       ;; printing informative message
(atom! boolean  need_clr_eos)       ;; need to clear text before displaying a message
(atom! int      emsg_skip)          ;; don't display errors for expression that is skipped
(atom! boolean  did_emsg)           ;; set by emsg() when the message is displayed or thrown
(atom! boolean  did_emsg_syntax)    ;; did_emsg set because of a syntax error
(atom! boolean  called_emsg)        ;; always set by emsg()
(atom! int      ex_exitval)         ;; exit value for ex mode
(atom! boolean  emsg_on_display)    ;; there is an error message
(atom! boolean  rc_did_emsg)        ;; vim-regcomp() called emsg()

(atom! int      no_wait_return)     ;; don't wait for return for now
(atom! boolean  need_wait_return)   ;; need to wait for return later
(atom! boolean  did_wait_return)    ;; wait-return() was used and nothing written since then

(atom! boolean  quit_more)          ;; 'q' hit at "--more--" msg
(atom! boolean  newline_on_exit)    ;; did msg in altern. screen
(atom! int      intr_char)          ;; extra interrupt character
(atom! int      vgetc_busy)         ;; when inside vgetc() then > 0

;; Lines left before a "more" message.
;; Ex mode needs to be able to reset this after you type something.

(atom! int      lines_left      -1)     ;; lines left for listing
(atom! boolean  msg_no_more)            ;; don't use more prompt, truncate messages

(atom! boolean  scroll_region)                  ;; term supports scroll region
(atom! int      t_colors)                       ;; int value of T_CCO

;; When highlight_match is true, highlight a match, starting at the cursor position.
;; Search_match_lines is the number of lines after the match (0 for a match within one line),
;; search_match_endcol the column number of the character just after the match in the last line.

(atom! boolean  highlight_match)                ;; show search match pos
(atom! long     search_match_lines)             ;; lines of of matched string
(atom! int      search_match_endcol)            ;; col nr of match end

(atom! boolean  no_smartcase)                   ;; don't use 'smartcase' once

(atom! int*     highlight_attr HLF_COUNT)       ;; highl. attr. for each context
(atom! int      cterm_normal_fg_color)
(atom! int      cterm_normal_fg_bold)
(atom! int      cterm_normal_bg_color)

(defn- #_int hl-attr [#_int n]
    (... @highlight_attr n))

;; While redrawing the screen this flag is set.
;; It means the screen size ('lines' and 'rows') must not be changed.

(atom! boolean  updating_screen)

;; All windows are linked in a list.  "firstwin" points to the first entry,
;; "lastwin" to the last entry (can be the same as "firstwin") and "curwin"
;; to the currently active window.

(atom! window_C firstwin)               ;; first window
(atom! window_C lastwin)                ;; last window
(atom! window_C prevwin)                ;; previous window
(atom! window_C curwin)                 ;; currently active window

;; The window layout is kept in a tree of frames.  "topframe" points to the top of the tree.

(atom! frame_C  topframe)               ;; top of the window frame tree

(atom! buffer_C curbuf)                 ;; currently active buffer

(atom! int      ru_col)                 ;; column for ruler
(atom! int      ru_wid)                 ;; 'rulerfmt' width of ruler when non-zero
(atom! int      sc_col)                 ;; column for shown command

;; When starting or exiting some things are done differently (e.g. screen updating).

(atom! int      starting NO_SCREEN)     ;; first NO_SCREEN, then NO_BUFFERS and then set to 0 when starting up finished
(atom! boolean  exiting)                ;; true when planning to exit Vim.  Might still keep on running if there is a changed buffer.

;; volatile because it is used in signal handler deathtrap().
(atom! #_"/*volatile*/transient" boolean full_screen)   ;; true when doing full-screen output
                                                        ;; otherwise only writing some messages

(atom! int      textlock)               ;; non-zero when changing text and jumping to another window or buffer is not allowed

(atom! pos_C    VIsual      (NEW_pos_C))  ;; start position of active Visual selection
(atom! boolean  VIsual_active)          ;; whether Visual mode is active
(atom! boolean  VIsual_select)          ;; whether Select mode is active
(atom! boolean  VIsual_reselect)        ;; whether to restart the selection after a Select mode mapping or menu

(atom! int      VIsual_mode \v)         ;; type of Visual mode

(atom! boolean  redo_VIsual_busy)       ;; true when redoing Visual

;; When pasting text with the middle mouse button in visual mode with
;; restart_edit set, remember where it started so we can set insStart.

(atom! pos_C    where_paste_started     (NEW_pos_C))

;; This flag is used to make auto-indent work right on lines where only a
;; <RETURN> or <ESC> is typed.  It is set when an auto-indent is done, and
;; reset when any other editing is done on the line.  If an <ESC> or <RETURN>
;; is received, and did_ai is true, the line is truncated.

(atom! boolean  did_ai)

;; Column of first char after autoindent.  0 when no autoindent done.
;; Used when 'backspace' is 0, to avoid backspacing over autoindent.

(atom! int      ai_col)

;; This flag is set after a ":syncbind" to let the check-scrollbind() function
;; know that it should not attempt to perform scrollbinding due to the scroll
;; that was a result of the ":syncbind." (Otherwise, check-scrollbind() will
;; undo some of the work done by ":syncbind.")  -ralston

(atom! boolean  did_syncbind)

;; This flag is set when a smart indent has been performed.
;; When the next typed character is a '{' the inserted tab will be deleted again.

(atom! boolean  did_si)

;; This flag is set after an auto indent.
;; If the next typed character is a '}' one indent will be removed.

(atom! boolean  can_si)

;; This flag is set after an "O" command.
;; If the next typed character is a '{' one indent will be removed.

(atom! boolean  can_si_back)

(atom! pos_C    saved_cursor    (NEW_pos_C)) ;; w_cursor before formatting text.

;; Stuff for insert mode.
;; This is where the latest insert/append mode started.

(atom! pos_C    insStart        (NEW_pos_C))

;; This is where the latest insert/append mode started.  In contrast to
;; insStart, this won't be reset by certain keys and is needed for
;; op-insert(), to detect correctly where inserting by the user started.

(atom! pos_C    insStart_orig   (NEW_pos_C))

;; Stuff for VREPLACE mode.

(atom! long     orig_line_count)    ;; Line count when "gR" started
(atom! int      vr_lines_changed)   ;; #Lines changed by "gR" so far

;; "State" is the main state of Vim.
;; There are other variables that modify the state:
;; "Visual_mode"    When State is NORMAL or INSERT.
;; "finish_op"      When State is NORMAL, after typing the operator and before typing the motion command.

(atom! int      State NORMAL)       ;; This is the current state of the command interpreter.

(atom! boolean  finish_op)          ;; true while an operator is pending
(atom! long     opcount)            ;; count for pending operator

(atom! boolean  Recording)          ;; true when recording into a reg.
(atom! boolean  execReg)            ;; true when executing a register

(atom! int      no_mapping)         ;; currently no mapping allowed
(atom! int      allow_keys)         ;; allow key codes when no_mapping is set
(atom! int      no_u_sync)          ;; Don't call u-sync()
(atom! int      u_sync_once)        ;; Call u-sync() once when evaluating an expression.

(atom! int      restart_edit)       ;; call edit when next cmd finished
(atom! boolean  arrow_used)         ;; Normally false, set to true after hitting cursor key in insert mode.
                                    ;; Used by vgetorpeek() to decide when to call u-sync()
(atom! boolean  ins_at_eol)         ;; put cursor after eol when restarting edit after CTRL-O

(atom! Bytes    ioBuff      (Bytes. IOSIZE))        ;; sprintf's are done in this buffer, size is IOSIZE
(atom! Bytes    nameBuff    (Bytes. MAXPATHL))      ;; file names are expanded in this buffer, size is MAXPATHL

(atom! int      redrawingDisabled)          ;; When non-zero, postpone redrawing.

(atom! typebuf_C typebuf    (NEW_typebuf_C))  ;; typeahead buffer
(atom! boolean  stop_insert_mode)           ;; for ":stopinsert" and 'insertmode'

(atom! boolean  keyTyped)                   ;; true if user typed current char
(atom! boolean  keyStuffed)                 ;; true if current char from stuffbuf
(atom! int      maptick)                    ;; tick for each non-mapped char

(final byte*    chartab     256)            ;; table used in charset.c; see init-chartab()

(atom! int      must_redraw)                ;; type of redraw necessary
(atom! boolean  skip_redraw)                ;; skip redraw once
(atom! boolean  do_redraw)                  ;; extra redraw once

(atom! boolean  need_highlight_changed true)

(atom! int      read_cmd_fd)                ;; fd to read commands from

;; volatile because it is used in signal handler catch-sigint().
(atom! #_"/*volatile*/transient" boolean got_int) ;; set to true when interrupt signal occurred

(atom! boolean  termcap_active)             ;; set by starttermcap()
(atom! int      cur_tmode       TMODE_COOK) ;; input terminal mode
(atom! boolean  bangredo)                   ;; set to true with ! command
(atom! int      searchcmdlen)               ;; length of previous search cmd
(atom! int      reg_do_extmatch)            ;; Used when compiling regexp:
                                                        ;; REX_SET to allow \z\(...\),
                                                        ;; REX_USE to allow \z\1 et al.
(atom! reg_extmatch_C re_extmatch_in)       ;; Used by vim-regexec():
                                                        ;; strings for \z\1...\z\9
(atom! reg_extmatch_C re_extmatch_out)      ;; Set by vim-regexec()
                                                        ;; to store \z\(...\) matches

(atom! boolean  need_start_insertmode)      ;; start insert mode soon
(atom! Bytes    last_cmdline)               ;; last command line (for ":)
(atom! Bytes    repeat_cmdline)             ;; command line for "."
(atom! Bytes    new_last_cmdline)           ;; new value for "last_cmdline"
(atom! boolean  did_cursorhold)             ;; set when CursorHold t'gerd
(atom! pos_C    last_cursormoved    (NEW_pos_C)) ;; for CursorMoved event
(atom! int      last_changedtick)           ;; for TextChanged event
(atom! buffer_C last_changedtick_buf)

(atom! int      postponed_split)            ;; for CTRL-W CTRL-] command
(atom! int      postponed_split_flags)      ;; args for win-split()
(atom! int      replace_offset)             ;; offset for replace-push()

;; When a string option is null (which only happens in out-of-memory situations),
;; it is set to EMPTY_OPTION to avoid having to check for null everywhere.

(final Bytes EMPTY_OPTION (u8 ""))

(atom! boolean* breakat_flags 256) ;; which characters are in 'breakat'

;; Characters from 'fillchars' option.
(atom! int
    fill_stl    \space,
    fill_stlnc  \space,
    fill_vert   \|)

;; Characters from 'listchars' option.
(atom! int
    lcs_eol     \$,
    lcs_ext     NUL,
    lcs_tab     NUL,
    lcs_trail   NUL,
    lcs_conceal \space)

;; Whether 'keymodel' contains "stopsel" and "startsel".
(atom! boolean  km_stopsel)
(atom! boolean  km_startsel)

(atom! int      cedit_key   Ctrl_F)     ;; key value of 'cedit' option
(atom! int      cmdwin_type)            ;; type of cmdline window or 0
(atom! int      cmdwin_result)          ;; result of cmdline window or 0

(final Bytes    no_lines_msg (u8 "--No lines in buffer--"))

;; When ":global" is used to number of substitutions and changed lines is
;; accumulated until it's finished.

(atom! long     sub_nsubs)              ;; total number of substitutions
(atom! long     sub_nlines)             ;; total number of lines changed

;; don't use 'hlsearch' temporarily
(atom! boolean  no_hlsearch)

(atom! boolean  term_is_xterm   true)   ;; xterm-like 'term'

;; Set to TRUE when an operator is being executed with virtual editing,
;; MAYBE when no operator is being executed, FALSE otherwise.

(atom! maybean  virtual_op  MAYBE)

;; Set when the cursor line needs to be redrawn.
(atom! boolean  need_cursor_line_redraw)

;; The error messages that can be shared are included here.
;; Excluded are errors that are only used once.

(final Bytes
    e_abort           (u8 "E470: Command aborted"),
    e_argreq          (u8 "E471: Argument required"),
    e_backslash       (u8 "E10: \\ should be followed by /, ? or &"),
    e_cmdwin          (u8 "E11: Invalid in command-line window; <CR> executes, CTRL-C quits"),
    e_internal        (u8 "E473: Internal error"),
    e_interr          (u8 "Interrupted"),
    e_invaddr         (u8 "E14: Invalid address"),
    e_invarg          (u8 "E474: Invalid argument"),
    e_invarg2         (u8 "E475: Invalid argument: %s"),
    e_invrange        (u8 "E16: Invalid range"),
    e_invcmd          (u8 "E476: Invalid command"),
    e_markinval       (u8 "E19: Mark has invalid line number"),
    e_marknotset      (u8 "E20: Mark not set"),
    e_nobang          (u8 "E477: No ! allowed"),
    e_noinstext       (u8 "E29: No inserted text yet"),
    e_nolastcmd       (u8 "E30: No previous command line"),
    e_nopresub        (u8 "E33: No previous substitute regular expression"),
    e_noprevre        (u8 "E35: No previous regular expression"),
    e_norange         (u8 "E481: No range allowed"),
    e_noroom          (u8 "E36: Not enough room"),
    e_nowrtmsg        (u8 "E37: No write since last change (add ! to override)"),
    e_null            (u8 "E38: Null argument"),
    e_number_exp      (u8 "E39: Number expected"),
    e_patnotf2        (u8 "E486: Pattern not found: %s"),
    e_positive        (u8 "E487: Argument must be positive"),
    e_re_damg         (u8 "E43: Damaged match string"),
    e_re_corr         (u8 "E44: Corrupted regexp program"),
    e_secure          (u8 "E523: Not allowed here"),
    e_scroll          (u8 "E49: Invalid scroll size"),
    e_toomsbra        (u8 "E76: Too many ["),
    e_trailing        (u8 "E488: Trailing characters"),
    e_umark           (u8 "E78: Unknown mark"),
    e_winheight       (u8 "E591: 'winheight' cannot be smaller than 'winminheight'"),
    e_winwidth        (u8 "E592: 'winwidth' cannot be smaller than 'winminwidth'"),
    e_zerocount       (u8 "Zero count"),
    e_intern2         (u8 "E685: Internal error: %s"),
    e_maxmempat       (u8 "E363: pattern uses more memory than 'maxmempattern'"),
    e_emptybuf        (u8 "E749: empty buffer"))

;; For undo we need to know the lowest time possible.
(atom! long starttime)

;; ----------------------------------------------------------------------- ;;

;; values for vim-handle-signal() that are not a signal
(final int SIGNAL_BLOCK    -1)
(final int SIGNAL_UNBLOCK  -2)

(final int KEYLEN_PART_KEY -1)      ;; keylen value for incomplete key-code
(final int KEYLEN_REMOVED  9999)    ;; keylen value for removed sequence

;; Position comparisons

(defn- #_boolean ltpos [#_pos_C a, #_pos_C b]
    (cond (!= (:lnum a) (:lnum b)) (< (:lnum a) (:lnum b)) (!= (:col a) (:col b)) (< (:col a) (:col b)) :else (< (:coladd a) (:coladd b))))

(defn- #_boolean eqpos [#_pos_C a, #_pos_C b]
    (and (== (:lnum a) (:lnum b)) (== (:col a) (:col b)) (== (:coladd a) (:coladd b))))

(defn- #_boolean ltoreq [#_pos_C a, #_pos_C b]
    (or (ltpos a, b) (eqpos a, b)))

(defn- #_void clearpos [#_pos_C a]
    (ยง
        ((ร a.lnum =) 0)
        ((ร a.col =) 0)
        ((ร a.coladd =) 0)
        nil
    ))

;; true if the line is empty

(defn- #_boolean lineempty [#_long lnum]
    (eos? (ml-get lnum)))

;; true if the current buffer is empty

(defn- #_boolean bufempty []
    (and (== (:ml_line_count (:b_ml @curbuf)) 1) (lineempty 1)))

;;; ============================================================================================== VimH

;; os_unix.c --------------------------------------------------------------------------------------

;; volatile because it is used in signal handler sig-winch().
(atom! #_"/*volatile*/transient" boolean do_resize)
;; volatile because it is used in signal handler deathtrap().
(atom! #_"/*volatile*/transient" int deadly_signal)                     ;; the signal we caught
;; volatile because it is used in signal handler deathtrap().
(atom! #_"/*volatile*/transient" boolean in_mch_delay)                  ;; sleeping in mch-delay()

(atom! int curr_tmode TMODE_COOK)                 ;; contains current terminal mode

(class! #_final signalinfo_C
    [
        (field int      sig)        ;; Signal number, e.g. SIGSEGV etc.
        (field Bytes    name)       ;; Signal name.
        (field boolean  deadly)     ;; Catch as a deadly signal?
    ])

(final signalinfo_C* signal_info
    [
; %%    (->signalinfo_C SIGHUP,    (u8 "HUP"),      true ),
; %%    (->signalinfo_C SIGQUIT,   (u8 "QUIT"),     true ),
; %%    (->signalinfo_C SIGILL,    (u8 "ILL"),      true ),
; %%    (->signalinfo_C SIGTRAP,   (u8 "TRAP"),     true ),
; %%    (->signalinfo_C SIGABRT,   (u8 "ABRT"),     true ),
; %%    (->signalinfo_C SIGFPE,    (u8 "FPE"),      true ),
; %%    (->signalinfo_C SIGBUS,    (u8 "BUS"),      true ),
; %%    (->signalinfo_C SIGSEGV,   (u8 "SEGV"),     true ),
; %%    (->signalinfo_C SIGSYS,    (u8 "SYS"),      true ),
; %%    (->signalinfo_C SIGALRM,   (u8 "ALRM"),     false),
; %%    (->signalinfo_C SIGTERM,   (u8 "TERM"),     true ),
; %%    (->signalinfo_C SIGVTALRM, (u8 "VTALRM"),   true ),
; %%    (->signalinfo_C SIGPROF,   (u8 "PROF"),     true ),
; %%    (->signalinfo_C SIGXCPU,   (u8 "XCPU"),     true ),
; %%    (->signalinfo_C SIGXFSZ,   (u8 "XFSZ"),     true ),
; %%    (->signalinfo_C SIGUSR1,   (u8 "USR1"),     true ),
; %%    (->signalinfo_C SIGUSR2,   (u8 "USR2"),     true ),
; %%    (->signalinfo_C SIGINT,    (u8 "INT"),      false),
; %%    (->signalinfo_C SIGWINCH,  (u8 "WINCH"),    false),
; %%    (->signalinfo_C SIGTSTP,   (u8 "TSTP"),     false),
; %%    (->signalinfo_C SIGPIPE,   (u8 "PIPE"),     false),

        (->signalinfo_C -1,        (u8 "Unknown!"), false)
    ])

;; Write s[len] to the screen.

(defn- #_void mch-write [#_Bytes s, #_int len]
;%% (.write libC 1, s, len)
    (when (non-zero? @p_wd)           ;; Unix is too fast, slow down a bit more
        (realWaitForChar @read_cmd_fd, @p_wd)
    )
    nil)

;; mch-inchar(): low level input function.
;; Get a characters from the keyboard.
;; Return the number of characters that are available.
;; If wtime == 0 do not wait for characters.
;; If wtime == n wait a short time for characters.
;; If wtime == -1 wait forever for characters.

(defn- #_int mch-inchar [#_Bytes buf, #_int maxlen, #_long wtime, #_int tb_change_cnt]
    (ยง
        ;; Check if window changed size while we were busy, perhaps the ":set columns=99" command was used.
        (while @do_resize
            (handle-resize)
        )

        (cond (<= 0 wtime)
        (do
            (while (not (waitForChar wtime))         ;; no character available
                (if (not @do_resize)                     ;; return if not interrupted by resize
                    ((ร RETURN) 0)
                )
                (handle-resize)
            )
        )
        :else        ;; wtime == -1
        (do
            ;; If there is no character available within 'updatetime' seconds
            ;; flush all the swap files to disk.
            ;; Also done when interrupted by SIGWINCH.

            (when (not (waitForChar @p_ut))
                (when (and (trigger-cursorhold) (<= 3 maxlen) (not (typebuf-changed tb_change_cnt)))
                    (.be buf 0, KB_SPECIAL)
                    (.be buf 1, KS_EXTRA)
                    (.be buf 2, KE_CURSORHOLD)
                    ((ร RETURN) 3)
                )
                (before-blocking)
            )
        ))

        (while true                                 ;; repeat until we got a character
            (while @do_resize
                (handle-resize)
            )                       ;; window changed size

            ;; We want to be interrupted by the winch signal
            ;; or by an event on the monitored file descriptors.

            (when (not (waitForChar -1))
                (if @do_resize                      ;; interrupted by SIGWINCH signal
                    (handle-resize))
                ((ร RETURN) 0)
            )

            ;; If input was put directly in typeahead buffer bail out here.
            (if (typebuf-changed tb_change_cnt)
                ((ร RETURN) 0)
            )

            ;; For some terminals we only get one character at a time.
            ;; We want the get all available characters, so we could keep on trying until none is available.
            ;; For some other terminals this is quite slow, that's why we don't do it.

            ((ร int len =) (read-from-input-buf buf, maxlen))
            (if (< 0 len)
                ((ร RETURN) len)
            )
        )
    ))

(defn- #_void handle-resize []
    (reset! do_resize false)
    (shell-resized)
    nil)

(defn- #_void mch-delay [#_long msec, #_boolean ignoreinput]
    (ยง
        (cond ignoreinput
        (do
            ;; Go to cooked mode without echo, to allow SIGINT interrupting us here.
            ;; But we don't want QUIT to kill us (CTRL-\ used in a shell may produce SIGQUIT).
            (reset! in_mch_delay true)
            ((ร int old_tmode =) @curr_tmode)
            (if (== @curr_tmode TMODE_RAW)
                (settmode TMODE_SLEEP))

            ;; Everybody sleeps in a different way...
            ;; Prefer nanosleep(), some versions of usleep() can only sleep up to one second.

;           {
                ((ร timespec_C ts =) (new timespec_C))

                (.tv_sec ts (/ msec 1000))
                (.tv_nsec ts (* (% msec 1000) 1000000))
                (.nanosleep libc ts, nil)
;           }

            (settmode old_tmode)
            (reset! in_mch_delay false)
        )
        :else
        (do
            (waitForChar msec)
        ))
        nil
    ))

;; We need correct prototypes for a signal function, otherwise mean compilers
;; will barf when the second argument to sigset() is ``wrong''.

(defn- #_void sig-winch [#_int _sigarg]
    ;; this is not required on all systems, but it doesn't hurt anybody
;%% (.sigset libC SIGWINCH, #_"/*(void (*)())sig-winch*/"nil)
    (reset! do_resize true)
    nil)

(defn- #_void catch-sigint [#_int _sigarg]
    ;; this is not required on all systems, but it doesn't hurt anybody
;%% (.sigset libC SIGINT, #_"/*(void (*)())catch-sigint*/"nil)
    (reset! got_int true)
    nil)

(defn- #_void catch-sigpwr [#_int _sigarg]
    ;; this is not required on all systems, but it doesn't hurt anybody
;%% (.sigset libC SIGPWR, #_"/*(void (*)())catch-sigpwr*/"nil)
    nil)

(atom! int trap__entered)       ;; Count the number of times we got here.
                                            ;; Note: when memory has been corrupted
                                            ;; this may get an arbitrary value!

(defn- #_void may-core-dump []
    (when (non-zero? @deadly_signal)
;%%     (.sigset libC @deadly_signal, #_"/*SIG_DFL*/"nil)
;%%     (.kill libc (.getpid libc), @deadly_signal)        ;; Die using the signal we caught
    )
    nil)

;; This function handles deadly signals.
;; It tries to preserve any swap files and exit properly.
;; NOTE: Avoid unsafe functions, such as allocating memory, they can result in a deadlock.

(defn- #_void deathtrap [#_int sigarg]
    (ยง
        ;; While in mch-delay() we go to cooked mode to allow a CTRL-C to interrupt us.
        ;; But in cooked mode we may also get SIGQUIT, e.g., when pressing CTRL-\,
        ;; but we don't want Vim to exit then.
        (if (and @in_mch_delay (== sigarg SIGQUIT))
            ((ร RETURN) nil)
        )

        ;; When SIGHUP, SIGQUIT, etc. are blocked: postpone the effect and return here.
        ;; This avoids that a non-reentrant function is interrupted, e.g. free().
        ;; Calling free() again may then cause a crash.
        (if (and (zero? @trap__entered) (or (== sigarg SIGHUP) (== sigarg SIGQUIT) (== sigarg SIGTERM) (== sigarg SIGPWR) (== sigarg SIGUSR1) (== sigarg SIGUSR2)) (not (vim-handle-signal sigarg)))
            ((ร RETURN) nil)
        )

        ;; Remember how often we have been called.
        (swap! trap__entered inc)

        (ร int i)

        ;; try to find the name of this signal
        ((ร FOR) (ร ((ร i =) 0) (!= (:sig (... signal_info i)) -1) (ร i++))
            (if (== sigarg (:sig (... signal_info i)))
                (ร BREAK)
            )
        )
        (reset! deadly_signal sigarg)

        (reset! full_screen false)    ;; don't write message to the GUI, it might be part of the problem...

        ;; If something goes wrong after entering here, we may get here again.
        ;; When this happens, give a message and try to exit nicely (resetting the terminal mode, etc.)
        ;; When this happens twice, just exit, don't even try to give a message,
        ;; stack may be corrupt or something weird.
        ;; When this still happens again (or memory was corrupted in such a way
        ;; that "trap__entered" was clobbered) use _exit(), don't try freeing resources.

        (when (<= 3 @trap__entered)
            (reset-signals)        ;; don't catch any signals anymore
            (may-core-dump)
            (if (<= 4 @trap__entered)
                (._exit libc 8)
            )
            (.exit libc 7)
        )
        (when (== @trap__entered 2)
            (out-str (u8 "Vim: Double signal, exiting\n"))
            (out-flush)
            (getout 1)
        )

        (.sprintf libC @ioBuff, (u8 "Vim: Caught deadly signal %s\n"), (:name (... signal_info i)))

        ;; Preserve files and exit.
        (preserve-exit)
        nil
    ))

;; If the machine has job control, use it to suspend the program,
;; otherwise fake it by starting a new shell.

(defn- #_void mch-suspend []
    (out-flush)                        ;; needed to make cursor visible on some systems
    (settmode TMODE_COOK)
    (out-flush)                        ;; needed to disable mouse on some systems

;%% (.kill libc 0, SIGTSTP)              ;; send ourselves a STOP signal

    (settmode TMODE_RAW)
    nil)

(defn- #_void mch-init []
    (reset! Cols 80)
    (reset! Rows 24)

    (out-flush)
    (set-signals)
    nil)

(defn- #_void set-signals []
    ;; WINDOW CHANGE signal is handled with sig-winch().

;%% (.sigset libC SIGWINCH, #_"/*(void (*)())sig-winch*/"nil)

    ;; We want the STOP signal to work, to make mch-suspend() work.
    ;; For "rvim" the STOP signal is ignored.

;%% (.sigset libC SIGTSTP, #_"/*SIG_DFL*/"nil)

    ;; We want to ignore breaking of PIPEs.

;%% (.sigset libC SIGPIPE, #_"/*SIG_IGN*/"nil)

    (catch-int-signal)

    ;; Ignore alarm signals (Perl's alarm() generates it).

;%% (.sigset libC SIGALRM, #_"/*SIG_IGN*/"nil)

    ;; Catch SIGPWR (power failure?) to preserve the swap files, so that no work will be lost.

;%% (.sigset libC SIGPWR, #_"/*(void (*)())catch-sigpwr*/"nil)

    ;; Arrange for other signals to gracefully shutdown Vim.

;%% (catch-signals #_"/*deathtrap*//*null*/"0, SIG_ERR)
    nil)

;; Catch CTRL-C (only works while in Cooked mode).

(defn- #_void catch-int-signal []
;%% (.sigset libC SIGINT, #_"/*(void (*)())catch-sigint*/"nil)
    nil)

(defn- #_void reset-signals []
;%% (catch-signals SIG_DFL, SIG_DFL)
    nil)

(defn- #_void catch-signals #_"/*(void (*func_deadly)(), void (*func_other)())*/" [#_@sighandler_t #_long func_deadly, #_@sighandler_t #_long func_other]
    (ยง
        ((ร FOR) (ร ((ร int i =) 0) (!= (:sig (... signal_info i)) -1) (ร i++))
            (cond (:deadly (... signal_info i))
            (do
;            // sigaction_C sa = new sigaction_C();

                ;; Setup to use the alternate stack for the signal function.
;            // sa.sa_handler(func_deadly);
                (.sigemptyset libC #_"/*&sa.sa_mask*/"nil)
;            // sa.sa_flags(SA_ONSTACK);
                (.sigaction libC (:sig (... signal_info i)), #_"/*sa*/"null, nil)
            )
            (!= func_other SIG_ERR)
            (do
                (.sigset libC (:sig (... signal_info i)), #_"/*func_other*/"nil)
            ))
        )
        nil
    ))

(atom! int got_signal)
(atom! boolean __blocked true)

;; Handling of SIGHUP, SIGQUIT and SIGTERM:
;; "when" == a signal:       when busy, postpone and return false, otherwise return true
;; "when" == SIGNAL_BLOCK:   Going to be busy, block signals
;; "when" == SIGNAL_UNBLOCK: Going to wait, unblock signals, use postponed signal
;; Returns true when Vim should exit.

(defn- #_boolean vim-handle-signal [#_int sig]
    (ยง
        ((ร SWITCH) sig
            ((ร CASE) SIGNAL_BLOCK)
            (do
                (reset! __blocked true)
                (ร BREAK)
            )
            ((ร CASE) SIGNAL_UNBLOCK)
            (do
                (reset! __blocked false)
                (when (non-zero? @got_signal)
                    (.kill libc (.getpid libc), @got_signal)
                    (reset! got_signal 0)
                )
                (ร BREAK)
            )
            (ร DEFAULT)
            (do
                (if (not @__blocked)
                    ((ร RETURN) true)            ;; exit!
                )
                (reset! got_signal sig)
                (if (!= sig SIGPWR)
                    (reset! got_int true))         ;; break any loops
                (ร BREAK)
            )
        )
        false
    ))

;; Output a newline when exiting.
;; Make sure the newline goes to the same stream as the text.

(defn- #_void exit-scroll []
    (ยง
        (cond (or @newline_on_exit @msg_didout)
        (do
            (cond (msg-use-printf)
            (do
                (if @info_message
                    (.fprintf libC stdout, (u8 "\n"))
                    (.fprintf libC stderr, (u8 "\r\n"))
                )
            )
            :else
            (do
                (out-char (byte \newline))
            ))
        )
        :else
        (do
            (restore-cterm-colors)         ;; get original colors back
            (msg-clr-eos-force)            ;; clear the rest of the display
            (windgoto (dec (int @Rows)), 0)     ;; may have moved the cursor
        ))
        nil
    ))

(defn- #_void mch-exit [#_int r]
    (reset! exiting true)

    (settmode TMODE_COOK)

    ;; When t_ti is not empty, but it doesn't cause swapping terminal pages,
    ;; need to output a newline when msg_didout is set.
    ;; But when t_ti does swap pages, it should not go to the shell page.
    ;; Do this before stoptermcap().

    (if (and (swapping-screen) (not @newline_on_exit))
        (exit-scroll))

    (stoptermcap)

    ;; A newline is only required after a message in the alternate screen.
    ;; This is set to true by wait-return().
    (if (or (not (swapping-screen)) @newline_on_exit)
        (exit-scroll))

    ;; Cursor may have been switched off without calling starttermcap()
    ;; when doing "vim -u vimrc" and vimrc contains ":q".
    (if @full_screen
        (cursor-on))

    (out-flush)

    (may-core-dump)

;%% (.exit libc r)
    nil)

;; for "new" tty systems

(atom! termios_C stm__told)

(defn- #_void mch-settmode [#_int tmode]
    (ยง
        (when (nil? @stm__told)
            (reset! stm__told (new termios_C))
            (.tcgetattr libc @read_cmd_fd, @stm__told)
        )

        ((ร termios_C tnew =) (new termios_C))
        (COPY_termios tnew, @stm__told)

        (cond (== tmode TMODE_RAW)
        (do
            ;; ~ICRNL enables typing ^V^M

            (.c_iflag tnew (& (.c_iflag tnew) (bit-not ICRNL)))
            (.c_lflag tnew (& (.c_lflag tnew) (bit-not (| ICANON ECHO ISIG ECHOE IEXTEN))))
            (.c_oflag tnew (& (.c_oflag tnew) (bit-not ONLCR)))
            (.c_vmin tnew (short 1))      ;; return after 1 char
            (.c_vtime tnew (short 0))     ;; don't wait
        )
        (== tmode TMODE_SLEEP)
        (do
            (.c_lflag tnew (& (.c_lflag tnew) (bit-not ECHO)))
        ))

        ;; A signal may cause tcsetattr() to fail (e.g., SIGCONT).  Retry a few times.
        ((ร FOR) (ร ((ร int n =) 10) (and (== (.tcsetattr libc @read_cmd_fd, TCSANOW, tnew) -1) (== (.errno libC) EINTR) (< 0 n)) (ร --n))
;           ;
        )

        (reset! curr_tmode tmode)
        nil
    ))

;; try to get the code for "t_kb" from the stty setting
;;
;; Even if termcap claims a backspace key, the user's setting *should*
;; prevail.  stty knows more about reality than termcap does, and if
;; somebody's usual erase key is DEL (which, for most BSD users, it will
;; be), they're going to get really annoyed if their erase key starts
;; doing forward deletes for no reason.

(defn- #_void get-stty []
    (ยง
        ;; for "new" tty systems
        ((ร termios_C keys =) (new termios_C))

        (when (!= (.tcgetattr libc @read_cmd_fd, keys) -1)
            ((ร Bytes buf =) (Bytes. 2))

            (.be buf 0, (.c_verase keys))
            (reset! intr_char (.c_vintr keys))
            (eos! buf 1)
            (add-termcode (u8 "kb"), buf)

            ;; If <BS> and <DEL> are now the same, redefine <DEL>.

            ((ร Bytes p =) (find-termcode (u8 "kD")))
            (if (and (non-nil? p) (== (.at p 0) (.at buf 0)) (== (.at p 1) (.at buf 1)))
                (ex-fixdel nil))
        )
        nil
    ))

;; Try to get the current window size:
;; 1. with an ioctl(), most accurate method
;; 2. from the environment variables LINES and COLUMNS
;; 4. keep using the old values
;; Return true when size could be determined, false otherwise.

(defn- #_boolean mch-get-shellsize []
    (ยง
        ((ร long rows =) 0)
        ((ร long cols =) 0)

        ;; 1. try using an ioctl.  It is the most accurate method.
;       {
            ((ร int fd =) 1)

            ;; When stdout is not a tty, use stdin for the ioctl().
            (if (and (== (.isatty libc fd) 0) (!= (.isatty libc @read_cmd_fd) 0))
                ((ร fd =) @read_cmd_fd)
            )

            ((ร winsize_C ws =) (new winsize_C))

            (when (== (.ioctl libc fd, TIOCGWINSZ, ws) 0)
                ((ร rows =) (.ws_row ws))
                ((ร cols =) (.ws_col ws))
            )
;       }

        ;; 2. get size from environment

        (when (or (zero? cols) (zero? rows))
            (ร Bytes p)
            (if (non-nil? ((ร p =) (.getenv libC (u8 "LINES"))))
                ((ร rows =) (.atoi libC p))
            )
            (if (non-nil? ((ร p =) (.getenv libC (u8 "COLUMNS"))))
                ((ร cols =) (.atoi libC p))
            )
        )

        ;; 4. If everything fails, use the old values

        (if (or (<= cols 0) (<= rows 0))
            ((ร RETURN) false)
        )

        (reset! Rows rows)
        (reset! Cols cols)
        (limit-screen-size)
        true
    ))

;; Try to set the window size to Rows and Cols.

(defn- #_void mch-set-shellsize []
    (when (non-eos? @T_CWS)
        ;; NOTE: if you get an error here that term-set-winsize() is undefined,
        ;; check the output of configure.  It could probably not find a ncurses,
        ;; termcap or termlib library.

        (term-set-winsize (int @Rows), (int @Cols))
        (out-flush)
        (screen-start)                 ;; don't know where cursor is now
    )
    nil)

;; Rows and/or Cols has changed.

(defn- #_void mch-new-shellsize []
    ;; Nothing to do.
    nil)

;; Check for CTRL-C typed by reading all available characters.
;; In cooked mode we should get SIGINT, no need to check.

(defn- #_void mch-breakcheck []
    (when (and (== @curr_tmode TMODE_RAW) (realWaitForChar @read_cmd_fd, 0))
        (fill-input-buf false)
    )
    nil)

;; Wait "msec" msec until a character is available from the keyboard or from inbuf[].
;; "msec" == -1 will block forever.

(defn- #_boolean waitForChar [#_long msec]
    (or (input-available) (realWaitForChar @read_cmd_fd, msec)))

;; Wait "msec" msec until a character is available from file descriptor "fd".
;; "msec" == 0 will check for characters once.
;; "msec" == -1 will block until a character is available.

(defn- #_boolean realWaitForChar [#_int fd, #_long msec]
    (ยง
        ((ร timeval_C tv =) (new timeval_C))
        (when (<= 0 msec)
            (.tv_sec tv (/ msec 1000))
            (.tv_usec tv (* (% msec 1000) 1000))
        )

        ;; Select on ready for reading and exceptional condition (end of file).

        ((ร FOR) (ร ((ร long[] rfds =) (ร new long[FD_SET_LENGTH], efds = new long[FD_SET_LENGTH])) true nil)
            (FD_ZERO rfds)
            (FD_ZERO efds)
            (FD_SET fd, rfds)
            (FD_SET fd, efds)

            ((ร int ret =) (.select libc (inc fd), rfds, nil, efds, (if (< msec 0) nil tv)))

            (when (and (== ret -1) (== (.errno libC) EINTR))
                ;; Check whether window has been resized, EINTR may be caused by SIGWINCH.

                (if @do_resize
                    (handle-resize))

                ;; Interrupted by a signal, need to try again.  We ignore msec here,
                ;; because we do want to check even after a timeout if characters are available.
                ;; Needed for reading output of an external command after the process has finished.

                (ร CONTINUE)
            )

            ((ร RETURN) (< 0 ret))
        )

        ;; NOTREACHED
    ))

;; message.c: functions for displaying messages on the command line -------------------------------

(atom! int      confirm_msg_used)       ;; displaying "confirm_msg"
(atom! Bytes    confirm_msg)            ;; ":confirm" message
(atom! Bytes    confirm_msg_tail)       ;; tail of "confirm_msg"

;; When writing messages to the screen, there are many different situations.
;; A number of variables is used to remember the current state:
;; msg_didany       true when messages were written since the last time the user reacted to a prompt.
;;                  Reset: After hitting a key for the hit-return prompt,
;;                  hitting <CR> for the command line or input().
;;                  Set: When any message is written to the screen.
;; msg_didout       true when something was written to the current line.
;;                  Reset: When advancing to the next line, when the current text can be overwritten.
;;                  Set: When any message is written to the screen.
;; msg_nowait       No extra delay for the last drawn message.
;;                  Used in normal-cmd() before the mode message is drawn.
;; emsg_on_display  There was an error message recently.
;;                  Indicates that there should be a delay before redrawing.
;; msg_scroll       The next message should not overwrite the current one.
;; msg_scrolled     How many lines the screen has been scrolled (because of messages).
;;                  Used in update-screen() to scroll the screen back.
;;                  Incremented each time the screen scrolls a line.
;; msg_scrolled_ign true when msg_scrolled is non-zero and msg-puts-attr() writes something
;;                  without scrolling should not make need_wait_return to be set.
;;                  This is a hack to make ":ts" work without an extra prompt.
;; lines_left       Number of lines available for messages before the more-prompt is to be given.
;;                  -1 when not set.
;; need_wait_return true when the hit-return prompt is needed.
;;                  Reset: After giving the hit-return prompt, when the user has answered some other prompt.
;;                  Set: When the ruler or typeahead display is overwritten,
;;                  scrolling the screen for some message.
;; keep_msg         Message to be displayed after redrawing the screen, in main-loop().
;;                  This is an allocated string or null when not used.

;; msg(s) - displays the string 's' on the status line.
;; Return true if wait-return not called.

(defn- #_boolean msg [#_Bytes s]
    (msg-attr-keep s, 0, false))

(defn- #_boolean msg-attr [#_Bytes s, #_int attr]
    (msg-attr-keep s, attr, false))

(atom! int msg__entered)

(defn- #_boolean msg-attr-keep [#_Bytes s, #_int attr, #_boolean keep]
    ;; keep: true: set "keep_msg" if it doesn't scroll
    (ยง
        ;; It is possible that displaying a messages causes a problem
        ;; (e.g. when redrawing the window), which causes another message, etc.
        ;; To break this loop, limit the recursiveness to 3 levels.

        (if (<= 3 @msg__entered)
            ((ร RETURN) true)
        )
        (swap! msg__entered inc)

        ;; When displaying "keep_msg", don't let msg-start() free it, caller must do that.
        (if (BEQ s, @keep_msg)
            (reset! keep_msg nil))

        ;; Truncate the message if needed.
        (msg-start)

        ((ร Bytes buf =) (msg-strtrunc s, false))
        (if (non-nil? buf)
            ((ร s =) buf)
        )

        (msg-outtrans-attr s, attr)
        (msg-clr-eos)

        ((ร boolean retval =) (msg-end))

        (if (and keep retval (< (mb-string2cells s, -1) (+ (* (int (- @Rows @cmdline_row 1)) (int @Cols)) @sc_col)))
            (set-keep-msg s, 0))

        (swap! msg__entered dec)
        retval
    ))

;; Truncate a string such that it can be printed without causing a scroll.
;; Returns an allocated string or null when no truncating is done.

(defn- #_Bytes msg-strtrunc [#_Bytes s, #_boolean force]
    ;; force: always truncate
    (ยง
        ((ร Bytes buf =) nil)

        ;; May truncate message to avoid a hit-return prompt.
        (when (or (and (not @msg_scroll) (not @need_wait_return)) force)
            (ร int room)
            ((ร int len =) (mb-string2cells s, -1))
            (cond (non-zero? @msg_scrolled)
            (do
                ;; Use all the columns.
                ((ร room =) (- (* (int (- @Rows @msg_row)) (int @Cols)) 1))
            )
            :else
            (do
                ;; Use up to 'showcmd' column.
                ((ร room =) (- (+ (* (int (- @Rows @msg_row 1)) (int @Cols)) @sc_col) 1))
            ))
            (when (and (< room len) (< 0 room))
                ;; may have up to 18 bytes per cell (6 per char, up to two composing chars)
                ((ร len =) (* (+ room 2) 18))
                ((ร buf =) (Bytes. len))
                (trunc-string s, buf, room, len)
            )
        )

        buf
    ))

;; Truncate a string "s" to "buf" with cell width "room".
;; "s" and "buf" may be equal.

(defn- #_void trunc-string [#_Bytes s, #_Bytes buf, #_int room, #_int buflen]
    (ยง
        ((ร room =) (- room 3))

        ((ร int half =) (/ room 2))
        ((ร int len =) 0)

        (ร int e)

        ;; First part: Start of the string.
        ((ร FOR) (ร ((ร e =) 0) (and (< len half) (< e buflen)) (ร e++))
            (when (eos? s e)
                ;; text fits without truncating!
                (eos! buf e)
                ((ร RETURN) nil)
            )

            ((ร int n =) (mb-ptr2cells (.plus s e)))
            (if (<= half (+ len n))
                (ร BREAK)
            )
            ((ร len =) (+ len n))
            (.be buf e, (.at s e))

            ((ร FOR) (ร ((ร n =) (us-ptr2len-cc (.plus s e))) (< 0 (ร --n)) nil)
                (if (== (ร ++e) buflen)
                    (ร BREAK)
                )
                (.be buf e, (.at s e))
            )
        )

        ;; Last part: End of the string.
        ((ร int i =) e)

        ;; For UTF-8 we can go backwards easily.
        ((ร half =) ((ร i =) (STRLEN s)))
        (while true
;           do
;           {
                ((ร half =) (- half (us-head-off s, (.plus s (dec half))) 1))
;           } while (utf-iscomposing(us-ptr2char(s.plus(half))) && 0 < half);
            ((ร int n =) (mb-ptr2cells (.plus s half)))
            (if (< room (+ len n))
                (ร BREAK)
            )
            ((ร len =) (+ len n))
            ((ร i =) half)
        )

        ;; Set the middle and copy the last part.
        (cond (< (+ e 3) buflen)
        (do
            (BCOPY buf, e, (u8 "..."), 0, 3)
            ((ร len =) (+ (STRLEN s, i) 1))
            (if (<= (- buflen e 3) len)
                ((ร len =) (- buflen e 3 1))
            )
            (BCOPY buf, (+ e 3), s, i, len)
            (.be buf (- (+ e 3 len) 1), NUL)
        )
        :else
        (do
            (.be buf (dec e), NUL)     ;; make sure it is truncated
        ))
        nil
    ))

(defn- #_final #_boolean smsg [#_Bytes s, #_Object... args]
    (smsg-attr 0, s, args))

(defn- #_boolean smsg-attr [#_int attr, #_Bytes s, #_Object... args]
;%% (vim_snprintf @ioBuff, IOSIZE, s, args)
    (msg-attr @ioBuff, attr))

;; Return true if not giving error messages right now:
;; If "emsg_off" is set: no error messages at the moment.
;; If "emsg_skip" is set: never do error messages.

(defn- #_boolean emsg-not-now []
    (or (< 0 @emsg_off) (< 0 @emsg_skip)))

;; emsg() - display an error message.
;;
;; Rings the bell, if appropriate, and calls message() to do the real work.
;;
;; Return true if wait-return not called.

(defn- #_boolean emsg [#_Bytes s]
    (ยง
        ;; Skip this if not giving error messages at the moment.
        (if (emsg-not-now)
            ((ร RETURN) true)
        )

        (reset! called_emsg true)
        (reset! ex_exitval 1)

        (when (zero? @emsg_off)
            (if @p_eb
                (beep-flush)               ;; also includes flush-buffers()
                (flush-buffers false))       ;; flush internal buffers
            (reset! did_emsg true)                ;; flag for DoOneCmd()
        )

        (reset! emsg_on_display true)             ;; remember there is an error message
        (reset! msg_scroll true)                  ;; don't overwrite a previous message
        ((ร int attr =) (hl-attr HLF_E))          ;; set highlight mode for error messages
        (when (non-zero? @msg_scrolled)
            (reset! need_wait_return true)        ;; needed in case emsg() is called after
                                            ;; wait-return has reset need_wait_return
                                            ;; and a redraw is expected because
                                            ;; msg_scrolled is non-zero
        )

        ;; Display the error message itself.

        (reset! msg_nowait false)                 ;; wait for this msg
        (msg-attr s, attr)
    ))

;; Print an error message with one "%s" and one string argument.

(defn- #_boolean emsg2 [#_Bytes s, #_Bytes a1]
    (emsg3 s, a1, nil))

;; emsg3() and emsgn() are in misc.c to avoid warnings for the prototypes.

(defn- #_void emsg-invreg [#_int name]
    (emsg2 (u8 "E354: Invalid register name: '%s'"), (transchar name))
    nil)

;; Like msg(), but truncate to a single line when "force" is true.
;; This truncates in another way as for normal messages.
;; Careful: The string may be changed by msg-may-trunc()!
;; Returns a pointer to the printed message, if wait-return() not called.

(defn- #_Bytes msg-trunc-attr [#_Bytes s, #_boolean force, #_int attr]
    (let [s (msg-may-trunc force, s)]
        (if (msg-attr s, attr) s nil)
    ))

;; Check if message "s" should be truncated at the start (for filenames).
;; Return a pointer to where the truncated message starts.
;; Note: May change the message by replacing a character with '<'.

(defn- #_Bytes msg-may-trunc [#_boolean force, #_Bytes s]
    (ยง
        ((ร int room =) (dec (+ (* (int (- @Rows @cmdline_row 1)) (int @Cols)) @sc_col)))

        (when (< 0 (- (STRLEN s) room))
            ((ร int cells =) (mb-string2cells s, -1))

            ;; There may be room anyway when there are multibyte chars.
            (if (<= cells room)
                ((ร RETURN) s)
            )

            (ร int n)
            ((ร FOR) (ร ((ร n =) 0) (<= room cells) ((ร n =) (+ n (us-ptr2len-cc (.plus s n)))))
                ((ร cells =) (- cells (us-ptr2cells (.plus s n))))
            )
            (ร --n)

            ((ร s =) (.plus s n))
            (.be s 0, (byte \<))
        )

        s
    ))

;; wait for the user to hit a key (normally a return)
;; if 'redraw' is true, clear and redraw the screen
;; if 'redraw' is false, just redraw the screen
;; if 'redraw' is -1, don't redraw at all

(defn- #_void wait-return [#_int redraw]
    (ยง
        (if (== redraw TRUE)
            (reset! must_redraw CLEAR))

        ;; When inside vgetc(), we can't wait for a typed character at all.
        ;; With the global command (and some others) we only need one return at
        ;; the end.  Adjust cmdline_row to avoid the next message overwriting the last one.

        (if (< 0 @vgetc_busy)
            ((ร RETURN) nil)
        )

        (reset! need_wait_return true)

        (when (non-zero? @no_wait_return)
            (reset! cmdline_row @msg_row)
            ((ร RETURN) nil)
        )

        (ร int c)

        ((ร int oldState =) @State)
        (cond @quit_more
        (do
            ((ร c =) CAR)                    ;; just pretend CR was hit
            (reset! quit_more false)
            (reset! got_int false)
        )
        :else
        (do
            ;; Make sure the hit-return prompt is on screen when 'guioptions' was just changed.
            (screenalloc false)

            (reset! State HITRETURN)

            (hit-return-msg)

            (ร boolean had_got_int)
;           do
;           {
                ;; Remember "got_int", if it is set vgetc() probably returns a CTRL-C,
                ;; but we need to loop then.
                ((ร had_got_int =) @got_int)

                ;; Don't do mappings here, we put the character back in the typeahead buffer.
                (swap! no_mapping inc)
                (swap! allow_keys inc)

                ;; Temporarily disable Recording.
                ;; If Recording is active, the character will be recorded later,
                ;; since it will be added to the typebuf after the loop.
                ((ร boolean save_Recording =) @Recording)
                (reset! Recording false)
                ((ร c =) (safe-vgetc))
                (if had_got_int
                    (reset! got_int false))
                (swap! no_mapping dec)
                (swap! allow_keys dec)
                (reset! Recording save_Recording)

                ;; Allow scrolling back in the messages.
                ;; Also accept scroll-down commands when messages fill the screen,
                ;; to avoid that typing one 'j' too many makes the messages disappear.

                (when @p_more
                    (cond (or (== c (byte \b)) (== c (byte \k)) (== c (byte \u)) (== c (byte \g)) (== c K_UP) (== c K_PAGEUP))
                    (do
                        (cond (< @Rows @msg_scrolled)
                        (do
                            ;; scroll back to show older messages
                            (do-more-prompt c)
                        )
                        :else
                        (do
                            (reset! msg_didout false)
                            ((ร c =) K_IGNORE)
                            (reset! msg_col 0)
                        ))
                        (cond @quit_more
                        (do
                            ((ร c =) CAR)                ;; just pretend CR was hit
                            (reset! quit_more false)
                            (reset! got_int false)
                        )
                        (!= c K_IGNORE)
                        (do
                            ((ร c =) K_IGNORE)
                            (hit-return-msg)
                        ))
                    )
                    (and (< (- @Rows 2) @msg_scrolled) (or (== c (byte \j)) (== c (byte \d)) (== c (byte \f)) (== c K_DOWN) (== c K_PAGEDOWN)))
                    (do
                        ((ร c =) K_IGNORE)
                    ))
                )
;           } while ((had_got_int && c == Ctrl_C) || c == K_IGNORE);
            (ui-breakcheck)

            (when (and (nil? (vim-strchr (u8 "\r\n "), c)) (!= c Ctrl_C))
                ;; Put the character back in the typeahead buffer.
                ;; Don't use the stuff buffer, because lmaps wouldn't work.
                (ins-char-typebuf c)
                (reset! do_redraw true)       ;; need a redraw even though there is typeahead
            )
        ))

        ;; If the user hits ':', '?' or '/' we get a command line from the next line.

        (when (or (== c (byte \:)) (== c (byte \?)) (== c (byte \/)))
            (reset! cmdline_row @msg_row)
            (reset! skip_redraw true)         ;; skip redraw once
            (reset! do_redraw false)
        )

        ;; If the window size changed set-shellsize() will redraw the screen.
        ;; Otherwise the screen is only redrawn if 'redraw' is set and no ':' typed.

        ((ร int tmpState =) @State)
        (reset! State oldState)               ;; restore State before set-shellsize
        (msg-check)

        ;; When switching screens, we need to output an extra newline on exit.

        (if (and (swapping-screen) (not @termcap_active))
            (reset! newline_on_exit true))

        (reset! need_wait_return false)
        (reset! did_wait_return true)
        (reset! emsg_on_display false)    ;; can delete error message now
        (reset! lines_left -1)            ;; reset lines_left at next msg-start()

        (when (and (non-nil? @keep_msg) (<= (+ (* (int (- @Rows @cmdline_row 1)) (int @Cols)) @sc_col) (mb-string2cells @keep_msg, -1)))
            (reset! keep_msg nil)            ;; don't redisplay message, it's too long
        )

        (cond (== tmpState SETWSIZE)       ;; got resize event while in vgetc()
        (do
            (starttermcap)             ;; start termcap before redrawing
            (shell-resized)
        )
        (and (not @skip_redraw) (or (== redraw TRUE) (and (non-zero? @msg_scrolled) (!= redraw -1))))
        (do
            (starttermcap)             ;; start termcap before redrawing
            (redraw-later VALID)
        ))
        nil
    ))

;; Write the hit-return prompt.

(defn- #_void hit-return-msg []
    (let [#_boolean save_p_more @p_more]

        (reset! p_more false)             ;; don't want see this message when scrolling back
        (if @msg_didout             ;; start on a new line
            (msg-putchar (byte \newline)))
        (if @got_int
            (msg-puts (u8 "Interrupt: ")))

        (msg-puts-attr (u8 "Press ENTER or type command to continue"), (hl-attr HLF_R))
        (if (not (msg-use-printf))
            (msg-clr-eos))
        (reset! p_more save_p_more)
        nil
    ))

;; Set "keep_msg" to "s".  Free the old value and check for null pointer.

(defn- #_void set-keep-msg [#_Bytes s, #_int attr]
    (reset! keep_msg (if (non-nil? s) (STRDUP s) nil))
    (reset! keep_msg_more false)
    (reset! keep_msg_attr attr)
    nil)

;; Prepare for outputting characters in the command line.

(defn- #_void msg-start []
    (ยง
        ((ร boolean did_return =) false)

        (reset! keep_msg nil)                    ;; don't display old message now

        (when @need_clr_eos
            ;; Halfway an ":echo" command and getting an (error) message:
            ;; clear any text from the command.
            (reset! need_clr_eos false)
            (msg-clr-eos)
        )

        (cond (and (not @msg_scroll) @full_screen)         ;; overwrite last message
        (do
            (reset! msg_row @cmdline_row)
            (reset! msg_col 0)
        )
        @msg_didout                    ;; start message on next line
        (do
            (msg-putchar (byte \newline))
            ((ร did_return =) true)
            (reset! cmdline_row @msg_row)
        ))

        (if (or (not @msg_didany) (< @lines_left 0))
            (msg-starthere))

        (reset! msg_didout false)                 ;; no output on current line yet
        (cursor-off)
        nil
    ))

;; Note that the current msg position is where messages start.

(defn- #_void msg-starthere []
    (reset! lines_left @cmdline_row)
    (reset! msg_didany false)
    nil)

(defn- #_void msg-putchar [#_int c]
    (msg-putchar-attr c, 0))

(defn- #_void msg-putchar-attr [#_int c, #_int attr]
    (let [#_Bytes buf (Bytes. (inc MB_MAXBYTES))]
        (if (is-special c)
            (-> buf (.be 0, KB_SPECIAL) (.be 1, (KB-SECOND c)) (.be 2, (KB-THIRD c)) (eos! 3))
            (eos! buf (utf-char2bytes c, buf)))
        (msg-puts-attr buf, attr)
        nil))

;; Output 'len' characters in 'p' (including NULs) with translation
;; if 'len' is -1, output upto a NUL character.
;; Use attributes 'attr'.
;; Return the number of characters it takes on the screen.

(defn- #_int msg-outtrans [#_Bytes p]
    (msg-outtrans-attr p, 0))

(defn- #_int msg-outtrans-attr [#_Bytes p, #_int attr]
    (msg-outtrans-len-attr p, (STRLEN p), attr))

(defn- #_int msg-outtrans-len [#_Bytes p, #_int len]
    (msg-outtrans-len-attr p, len, 0))

(defn- #_int msg-outtrans-len-attr [#_Bytes p, #_int len, #_int attr]
    (ยง
        ((ร int cells =) 0)

        ;; If the string starts with a composing character,
        ;; first draw a space on which the composing char can be drawn.
        (if (utf-iscomposing (us-ptr2char p))
            (msg-puts-attr (u8 " "), attr))

        ((ร Bytes q =) p)

        ;; Go over the string.  Special characters are translated and printed.
        ;; Normal characters are printed several at a time.

        (while (<= 0 (ร --len))
            ;; Don't include composing chars after the end.
            ((ร int l =) (us-ptr2len-cc-len p, (inc len)))
            (cond (< 1 l)
            (do
                ((ร int c =) (us-ptr2char p))
                (cond (vim-isprintc c)
                (do
                    ;; printable multi-byte char: count the cells.
                    ((ร cells =) (+ cells (us-ptr2cells p)))
                )
                :else
                (do
                    ;; unprintable multi-byte char: print the printable chars
                    ;; so far and the translation of the unprintable char
                    (if (BLT q, p)
                        (msg-puts-attr-len q, (BDIFF p, q), attr))
                    ((ร q =) (.plus p l))
                    (msg-puts-attr (transchar c), (if (zero? attr) (hl-attr HLF_8) attr))
                    ((ร cells =) (+ cells (mb-char2cells c)))
                ))
                ((ร len =) (- len (dec l)))
                ((ร p =) (.plus p l))
            )
            :else
            (do
                ((ร Bytes s =) (transchar-byte (.at p 0)))
                (cond (non-eos? s 1)
                (do
                    ;; unprintable char: print the printable chars so far
                    ;; and the translation of the unprintable char
                    (if (BLT q, p)
                        (msg-puts-attr-len q, (BDIFF p, q), attr))
                    ((ร q =) (.plus p 1))
                    (msg-puts-attr s, (if (zero? attr) (hl-attr HLF_8) attr))
                    ((ร cells =) (+ cells (STRLEN s)))
                )
                :else
                (do
                    (ร cells++)
                ))
                ((ร p =) (.plus p 1))
            ))
        )

        (when (BLT q, p)
            ;; print the printable chars at the end
            (msg-puts-attr-len q, (BDIFF p, q), attr)
        )

        cells
    ))

;; Use screen-puts() to output one multi-byte character.
;; Return the pointer "s" advanced to the next character.

(defn- #_Bytes screen-puts-mbyte [#_Bytes s, #_int len, #_int attr]
    (ยง
        (reset! msg_didout true)          ;; remember that line is not empty

        ((ร int cells =) (us-ptr2cells s))
        (when (and (< 1 cells) (== @msg_col (dec (int @Cols))))
            ;; Doesn't fit, print a highlighted '>' to fill it up.
            (msg-screen-putchar (byte \>), (hl-attr HLF_AT))
            ((ร RETURN) s)
        )

        (screen-puts-len s, len, @msg_row, @msg_col, attr)

        ((ร @msg_col =) (+ @msg_col cells))
        (when (<= (int @Cols) @msg_col)
            (reset! msg_col 0)
            (swap! msg_row inc)
        )

        (.plus s len)
    ))

;; Output a string to the screen at position msg_row, msg_col.
;; Update msg_row and msg_col for the next message.

(defn- #_void msg-puts [#_Bytes s]
    (msg-puts-attr s, 0)
    nil)

(defn- #_void msg-puts-title [#_Bytes s]
    (msg-puts-attr s, (hl-attr HLF_T))
    nil)

;; Basic function for writing a message with highlight attributes.

(defn- #_void msg-puts-attr [#_Bytes s, #_int attr]
    (msg-puts-attr-len s, -1, attr)
    nil)

;; Like msg-puts-attr(), but with a maximum length "maxlen" (in bytes).
;; When "maxlen" is -1 there is no maximum length.
;; When "maxlen" is >= 0 the message is not put in the history.

(defn- #_void msg-puts-attr-len [#_Bytes str, #_int maxlen, #_int attr]
    ;; When writing something to the screen after it has scrolled, requires
    ;; a wait-return prompt later.  Needed when scrolling, resetting need_wait_return
    ;; after some prompt, and then outputting something without scrolling

    (if (and (non-zero? @msg_scrolled) (not @msg_scrolled_ign))
        (reset! need_wait_return true))
    (reset! msg_didany true)          ;; remember that something was outputted

    ;; If there is no valid screen, use fprintf so we can see error messages.
    ;; If termcap is not active, we may be writing in an alternate console window,
    ;; cursor positioning may not work correctly (window size may be different,
    ;; e.g. for Win32 console) or we just don't know where the cursor is.

    (if (msg-use-printf)
        (msg-puts-printf str, maxlen)
        (msg-puts-display str, maxlen, attr, false))
    nil)

;; The display part of msg-puts-attr-len().
;; May be called recursively to display scroll-back text.

(defn- #_void msg-puts-display [#_Bytes str, #_int maxlen, #_int attr, #_boolean recurse]
    (ยง
        ((ร Bytes s =) str)
        ((ร Bytes t_s =) str)       ;; string from "t_s" to "s" is still todo
        ((ร int t_col =) 0)          ;; screen cells todo, 0 when "t_s" not used
; %%    ((ร Bytes[] sb_str =) (ร { str }))
; %%    ((ร int[] sb_col =) (ร { @msg_col }))

        (reset! did_wait_return false)
        (while (and (or (< maxlen 0) (< (BDIFF s, str) maxlen)) (non-eos? s))
            ;; We are at the end of the screen line when:
            ;; - When outputting a newline.
            ;; - When outputting a character in the last column.

            (when (and (not recurse) (<= (dec @Rows) @msg_row) (or (== (.at s 0) (byte \newline)) (<= (dec (int @Cols)) (+ @msg_col t_col)) (and (== (.at s 0) TAB) (<= (& (dec (int @Cols)) (bit-not 7)) (+ @msg_col t_col))) (and (< 1 (us-ptr2cells s)) (<= (- (int @Cols) 2) (+ @msg_col t_col)))))
                ;; The screen is scrolled up when at the last row (some terminals scroll
                ;; automatically, some don't.  To avoid problems we scroll ourselves).

                (when (< 0 t_col)
                    ;; output postponed text
                    ((ร t_col =) (t-puts t_col, t_s, s, attr))
                )

                ;; When no more prompt and no more room, truncate here.
                (if (and @msg_no_more (zero? @lines_left))
                    (ร BREAK)
                )

                ;; Scroll the screen up one line.
                (msg-scroll-up)

                (reset! msg_row (- (int @Rows) 2))
                (if (<= (int @Cols) @msg_col)     ;; can happen after screen resize
                    (reset! msg_col (dec (int @Cols))))

                (ร boolean did_last_char)

                ;; Display char in last column before showing more-prompt.
                (cond (<= (byte \space) (.at s 0))
                (do
                    (ร int len)
                    (cond (<= 0 maxlen)
                    (do
                        ;; avoid including composing chars after the end
                        ((ร len =) (us-ptr2len-cc-len s, (BDIFF (.plus str maxlen), s)))
                    )
                    :else
                    (do
                        ((ร len =) (us-ptr2len-cc s))
                    ))
                    ((ร s =) (screen-puts-mbyte s, len, attr))

                    ((ร did_last_char =) true)
                )
                :else
                (do
                    ((ร did_last_char =) false)
                ))

                (when @p_more
                    ;; store text for scrolling back
                    (store-sb-text sb_str, s, attr, sb_col, true)
                )

                (inc-msg-scrolled)
                (reset! need_wait_return true)    ;; may need wait-return in main()
                (if (< @must_redraw VALID)
                    (reset! must_redraw VALID))
                (reset! redraw_cmdline true)
                (if (< 0 @cmdline_row)
                    (swap! cmdline_row dec))

                ;; If screen is completely filled and 'more' is set then wait for a character.

                (if (< 0 @lines_left)
                    (swap! lines_left dec))
                (when (and @p_more (zero? @lines_left) (!= @State HITRETURN) (not @msg_no_more))
                    (if (do-more-prompt NUL)
                        ((ร s =) @confirm_msg_tail)
                    )
                    (if @quit_more
                        ((ร RETURN) nil)
                    )
                )

                ;; When we displayed a char in last column need to check if there is still more.
                (if did_last_char
                    (ร CONTINUE)
                )
            )

            ((ร boolean wrap =) (or (== (.at s 0) (byte \newline)) (<= (int @Cols) (+ @msg_col t_col)) (and (< 1 (us-ptr2cells s)) (<= (dec (int @Cols)) (+ @msg_col t_col)))))

            (when (and (< 0 t_col) (or wrap (== (.at s 0) (byte \return)) (== (.at s 0) (byte \backspace)) (== (.at s 0) TAB) (== (.at s 0) BELL)))
                ;; output any postponed text
                ((ร t_col =) (t-puts t_col, t_s, s, attr))
            )

            (when (and wrap @p_more (not recurse))
                ;; store text for scrolling back
                (store-sb-text sb_str, s, attr, sb_col, true)
            )

            (cond (== (.at s 0) (byte \newline))                 ;; go to next line
            (do
                (reset! msg_didout false)         ;; remember that line is empty
                (reset! msg_col 0)
                (if (<= @Rows (ร ++@msg_row))      ;; safety check
                    (reset! msg_row (dec (int @Rows))))
            )
            (== (.at s 0) (byte \return))            ;; go to column 0
            (do
                (reset! msg_col 0)
            )
            (== (.at s 0) (byte \backspace))            ;; go to previous char
            (do
                (if (< 0 @msg_col)
                    (swap! msg_col dec))
            )
            (== (.at s 0) TAB)                    ;; translate Tab into spaces
            (do
;               do
;               {
                    (msg-screen-putchar (byte \space), attr)
;               } while ((@msg_col & 7) != 0);
            )
            (== (.at s 0) BELL)                   ;; beep (from ":sh")
            (do
                (vim-beep)
            )
            :else
            (do
                ((ร int cells =) (us-ptr2cells s))

                (ร int len)
                (cond (<= 0 maxlen)
                (do
                    ;; avoid including composing chars after the end
                    ((ร len =) (us-ptr2len-cc-len s, (BDIFF (.plus str maxlen), s)))
                )
                :else
                (do
                    ((ร len =) (us-ptr2len-cc s))
                ))

                ;; When a double-wide character doesn't fit, draw a single character here.
                ;; Otherwise collect characters and draw them all at once later.
                (cond (and (< 1 cells) (<= (dec (int @Cols)) (+ @msg_col t_col)))
                (do
                    (if (< 1 len)
                        ((ร s =) (.minus (screen-puts-mbyte s, len, attr) 1))
                        (msg-screen-putchar (.at s 0), attr))
                )
                :else
                (do
                    ;; postpone this character until later
                    (if (zero? t_col)
                        ((ร t_s =) s)
                    )
                    ((ร t_col =) (+ t_col cells))
                    ((ร s =) (.plus s (dec len)))
                ))
            ))
            ((ร s =) (.plus s 1))
        )

        ;; output any postponed text
        (if (< 0 t_col)
            ((ร t_col =) (t-puts t_col, t_s, s, attr))
        )
        (if (and @p_more (not recurse))
            (store-sb-text sb_str, s, attr, sb_col, false))

        (msg-check)
        nil
    ))

;; Scroll the screen up one line for displaying the next message line.

(defn- #_void msg-scroll-up []
    (let [rows (int @Rows) cols (int @Cols)]
        ;; scrolling up always works
        (screen-del-lines 0, 0, 1, rows, true, nil)

        (when (not (can-clear (u8 " ")))
            ;; Scrolling up doesn't result in the right background.
            ;; Set the background here.  It's not efficient,
            ;; but avoids that we have to do it all over the code.
            (screen-fill (- rows 1), rows, 0, cols, (byte \space), (byte \space), 0)

            ;; Also clear the last char of the last but one line
            ;; if it was not cleared before to avoid a scroll-up.
            (if (== (... @screenAttrs (+ (... @lineOffset (- rows 2)) (- cols 1))) -1)
                (screen-fill (- rows 2), (- rows 1), (- cols 1), cols, (byte \space), (byte \space), 0))
        )
        nil
    ))

;; Increment "msg_scrolled".

(defn- #_void inc-msg-scrolled []
    (swap! msg_scrolled inc)
    nil)

;; To be able to scroll back at the "more" and "hit-enter" prompts we need to
;; store the displayed text and remember where screen lines start.

(class! #_final msgchunk_C
    [
        (field msgchunk_C   sb_next)
        (field msgchunk_C   sb_prev)
        (field boolean      sb_eol)         ;; true when line ends after this text
        (field int          sb_msg_col)     ;; column in which text starts
        (field int          sb_attr)        ;; text attributes
        (field Bytes        sb_text)        ;; text to be displayed, actually longer
    ])

(atom! msgchunk_C last_msgchunk)    ;; last displayed text

(atom! boolean do_clear_sb_text)    ;; clear text on next msg

;; Store part of a printed message for displaying when scrolling back.

(defn- #_void store-sb-text [#_Bytes* sb_str, #_Bytes s, #_int attr, #_int* sb_col, #_boolean finish]
    ;; sb_str: start of string
    ;; s: just after string
    ;; finish: line ends
    (ยง
        (when @do_clear_sb_text
            (clear-sb-text)
            (reset! do_clear_sb_text false)
        )

        (cond (BLT (... sb_str 0), s)
        (do
            ((ร msgchunk_C mp =) (NEW_msgchunk_C))

            ((ร mp.sb_eol =) finish)
            ((ร mp.sb_msg_col =) (... sb_col 0))
            ((ร mp.sb_attr =) attr)
            ((ร mp.sb_text =) (STRNDUP (... sb_str 0), (BDIFF s, (... sb_str 0))))

            (cond (nil? @last_msgchunk)
            (do
                (reset! last_msgchunk mp)
                ((ร mp.sb_prev =) nil)
            )
            :else
            (do
                ((ร mp.sb_prev =) @last_msgchunk)
                ((ร @last_msgchunk.sb_next =) mp)
                (reset! last_msgchunk mp)
            ))
            ((ร mp.sb_next =) nil)
        )
        (and finish (non-nil? @last_msgchunk))
        (do
            ((ร @last_msgchunk.sb_eol =) true)
        ))

        ((ร sb_str[0] =) s)
        ((ร sb_col[0] =) 0)
        nil
    ))

;; Finished showing messages, clear the scroll-back text on the next message.

(defn- #_void may-clear-sb-text []
    (reset! do_clear_sb_text true)
    nil)

;; Clear any text remembered for scrolling back.
;; Called when redrawing the screen.

(defn- #_void clear-sb-text []
    (reset! last_msgchunk nil)
    nil)

;; "g<" command.

(defn- #_void show-sb-text []
    (ยง
        ;; Only show something if there is more than one line, otherwise it looks weird,
        ;; typing a command without output results in one line.
        ((ร msgchunk_C mp =) (msg-sb-start @last_msgchunk))
        (cond (or (nil? mp) (nil? (:sb_prev mp)))
        (do
            (vim-beep)
        )
        :else
        (do
            (do-more-prompt (byte \G))
            (wait-return FALSE)
        ))
        nil
    ))

;; Move to the start of screen line in already displayed text.

(defn- #_msgchunk_C msg-sb-start [#_msgchunk_C mps]
    (ยง
        ((ร msgchunk_C mp =) mps)

        (while (and (non-nil? mp) (non-nil? (:sb_prev mp)) (not (:sb_eol (:sb_prev mp))))
            ((ร mp =) (:sb_prev mp))
        )

        mp
    ))

;; Display a screen line from previously displayed text at row "row".
;; Returns a pointer to the text for the next line (can be null).

(defn- #_msgchunk_C disp-sb-line [#_int row, #_msgchunk_C smp]
    (ยง
        ((ร msgchunk_C mp =) smp)

        (while true
            (reset! msg_row row)
            (reset! msg_col (:sb_msg_col mp))
            ((ร Bytes p =) (:sb_text mp))
            (if (== (.at p 0) (byte \newline))             ;; don't display the line break
                ((ร p =) (.plus p 1))
            )
            (msg-puts-display p, -1, (:sb_attr mp), true)
            (if (or (:sb_eol mp) (nil? (:sb_next mp)))
                (ร BREAK)
            )
            ((ร mp =) (:sb_next mp))
        )

        (:sb_next mp)
    ))

;; Output any postponed text for msg-puts-attr-len().

(defn- #_int t-puts [#_int t_col, #_Bytes t_s, #_Bytes s, #_int attr]
    (ยง
        ;; output postponed text
        (reset! msg_didout true)          ;; remember that line is not empty
        (screen-puts-len t_s, (BDIFF s, t_s), @msg_row, @msg_col, attr)
        ((ร @msg_col =) (+ @msg_col t_col))
        ((ร t_col =) 0)
        ;; If the string starts with a composing character,
        ;; don't increment the column position for it.
        (if (utf-iscomposing (us-ptr2char t_s))
            (swap! msg_col dec))
        (when (<= (int @Cols) @msg_col)
            (reset! msg_col 0)
            (swap! msg_row inc)
        )
        t_col
    ))

;; Returns true when messages should be printed with mch_errmsg().
;; This is used when there is no valid screen, so we can see error messages.
;; If termcap is not active, we may be writing in an alternate console window,
;; cursor positioning may not work correctly (window size may be different)
;; or we just don't know where the cursor is.

(defn- #_boolean msg-use-printf []
    (or (not (msg-check-screen)) (and (swapping-screen) (not @termcap_active))))

;; Print a message when there is no valid screen.

(defn- #_void msg-puts-printf [#_Bytes str, #_int maxlen]
    (ยง
        ((ร FOR) (ร ((ร Bytes s =) str) (and (non-eos? s) (or (< maxlen 0) (< (BDIFF s, str) maxlen))) ((ร s =) (.plus s 1)))
            ((ร Bytes buf =) (Bytes. 4))
            ((ร Bytes p =) buf)

            ;; NL --> CR NL translation (for Unix, not for "--version")
            (if (and (== (.at s 0) (byte \newline)) (not @info_message))
                (.be ((ร p =) (.plus p 1)) -1, (byte \return))
            )
            (.be ((ร p =) (.plus p 1)) -1, (.at s 0))
            (eos! p)
            (if @info_message   ;; informative message, not an error
                (.fprintf libC stdout, (u8 "%s"), buf)
                (.fprintf libC stderr, (u8 "%s"), buf)
            )

            ;; primitive way to compute the current column
            (if (or (== (.at s 0) (byte \return)) (== (.at s 0) (byte \newline)))
                (reset! msg_col 0)
                (swap! msg_col inc))
        )

        (reset! msg_didout true)      ;; assume that line is not empty
        nil
    ))

;; Show the more-prompt and handle the user response.
;; This takes care of scrolling back and displaying previously displayed text.
;; When at hit-enter prompt "typed_char" is the already typed character,
;; otherwise it's NUL.
;; Returns true when jumping ahead to "confirm_msg_tail".

(defn- #_boolean do-more-prompt [#_int typed_char]
    (ยง
        ((ร boolean retval =) false)

        ((ร int used_typed_char =) typed_char)
        ((ร int oldState =) @State)

        ((ร msgchunk_C mp_last =) nil)
        (when (== typed_char (byte \G))
            ;; "g<": Find first line on the last page.
            ((ร mp_last =) (msg-sb-start @last_msgchunk))
            ((ร FOR) (ร ((ร int i =) 0) (and (< i (- @Rows 2)) (non-nil? mp_last) (non-nil? (:sb_prev mp_last))) (ร i++))
                ((ร mp_last =) (msg-sb-start (:sb_prev mp_last)))
            )
        )

        (reset! State ASKMORE)
        (if (== typed_char NUL)
            (msg-moremsg false))

        (while true
            (ร int c)

            ;; Get a typed character directly from the user.

            (cond (!= used_typed_char NUL)
            (do
                ((ร c =) used_typed_char)        ;; was typed at hit-enter prompt
                ((ร used_typed_char =) NUL)
            )
            :else
            (do
                ((ร c =) (get-keystroke))
            ))

            ((ร int toscroll =) 0)
            ((ร SWITCH) c
                ((ร CASE) BS)                    ;; scroll one line back
                ((ร CASE) K_BS)
                ((ร CASE) (byte \k))
                ((ร CASE) K_UP)
                (do
                    ((ร toscroll =) -1)
                    (ร BREAK)
                )

                ((ร CASE) CAR)                   ;; one extra line
                ((ร CASE) NL)
                ((ร CASE) (byte \j))
                ((ร CASE) K_DOWN)
                (do
                    ((ร toscroll =) 1)
                    (ร BREAK)
                )

                ((ร CASE) (byte \u))                   ;; up half a page
                (do
                    ((ร toscroll =) (- (/ (int @Rows) 2)))
                    (ร BREAK)
                )

                ((ร CASE) (byte \d))                   ;; down half a page
                (do
                    ((ร toscroll =) (/ (int @Rows) 2))
                    (ร BREAK)
                )

                ((ร CASE) (byte \b))                   ;; one page back
                ((ร CASE) K_PAGEUP)
                (do
                    ((ร toscroll =) (- (dec (int @Rows))))
                    (ร BREAK)
                )

                ((ร CASE) (byte \space))                   ;; one extra page
                ((ร CASE) (byte \f))
                ((ร CASE) K_PAGEDOWN)
                (do
                    ((ร toscroll =) (dec (int @Rows)))
                    (ร BREAK)
                )

                ((ร CASE) (byte \g))                   ;; all the way back to the start
                (do
                    ((ร toscroll =) -999999)
                    (ร BREAK)
                )

                ((ร CASE) (byte \G))                   ;; all the way to the end
                (do
                    ((ร toscroll =) 999999)
                    (reset! lines_left 999999)
                    (ร BREAK)
                )

                ((ร CASE) (byte \:))                   ;; start new command line
                (do
                    (when (zero? @confirm_msg_used)
                        ;; Since got_int is set all typeahead will be flushed, but we
                        ;; want to keep this ':', remember that in a special way.
                        (typeahead-noflush (byte \:))
                        (reset! cmdline_row (dec (int @Rows)))         ;; put ':' on this line
                        (reset! skip_redraw true)             ;; skip redraw once
                        (reset! need_wait_return false)       ;; don't wait in main()
                    )
                    (ร FALLTHROUGH)
                )
                ((ร CASE) (byte \q))                   ;; quit
                ((ร CASE) Ctrl_C)
                ((ร CASE) ESC)
                (do
                    (cond (non-zero? @confirm_msg_used)
                    (do
                        ;; Jump to the choices of the dialog.
                        ((ร retval =) true)
                    )
                    :else
                    (do
                        (reset! got_int true)
                        (reset! quit_more true)
                    ))
                    ;; When there is some more output (wrapping line)
                    ;; display that without another prompt.
                    (reset! lines_left (dec (int @Rows)))
                    (ร BREAK)
                )

                ((ร CASE) Ctrl_Y)
                (do
                    ;; Strange way to allow copying (yanking) a modeless
                    ;; selection at the more prompt.  Use CTRL-Y,
                    ;; because the same is used in Cmdline-mode and at the
                    ;; hit-enter prompt.  However, scrolling one line up
                    ;; might be expected...
;                   
                    (ร CONTINUE)
                )

                (ร DEFAULT)                    ;; no valid response
                (do
                    (msg-moremsg true)
                    (ร CONTINUE)
                )
            )

            (when (non-zero? toscroll)
                (cond (< toscroll 0)
                (do
                    (ร msgchunk_C mp)
                    ;; go to start of last line
                    (cond (nil? mp_last)
                    (do
                        ((ร mp =) (msg-sb-start @last_msgchunk))
                    )
                    (non-nil? (:sb_prev mp_last))
                    (do
                        ((ร mp =) (msg-sb-start (:sb_prev mp_last)))
                    )
                    :else
                    (do
                        ((ร mp =) nil)
                    ))

                    ;; go to start of line at top of the screen
                    ((ร FOR) (ร ((ร int i =) 0) (and (< i (- @Rows 2)) (non-nil? mp) (non-nil? (:sb_prev mp))) (ร i++))
                        ((ร mp =) (msg-sb-start (:sb_prev mp)))
                    )

                    (when (and (non-nil? mp) (non-nil? (:sb_prev mp)))
                        ;; Find line to be displayed at top.
                        ((ร FOR) (ร ((ร int i =) 0) (< toscroll i) (ร --i))
                            (if (or (nil? mp) (nil? (:sb_prev mp)))
                                (ร BREAK)
                            )
                            ((ร mp =) (msg-sb-start (:sb_prev mp)))
                            ((ร mp_last =) (msg-sb-start (if (nil? mp_last) @last_msgchunk (:sb_prev mp_last))))
                        )

                        (cond (and (== toscroll -1) (screen-ins-lines 0, 0, 1, (int @Rows), nil))
                        (do
                            ;; display line at top
                            (disp-sb-line 0, mp)
                        )
                        :else
                        (do
                            ;; redisplay all lines
                            (screenclear)
                            ((ร FOR) (ร ((ร int i =) 0) (and (non-nil? mp) (< i (dec @Rows))) (ร i++))
                                ((ร mp =) (disp-sb-line i, mp))
                                (swap! msg_scrolled inc)
                            )
                        ))
                        ((ร toscroll =) 0)
                    )
                )
                :else
                (do
                    ;; First display any text that we scrolled back.
                    (while (and (< 0 toscroll) (non-nil? mp_last))
                        ;; scroll up, display line at bottom
                        (msg-scroll-up)
                        (inc-msg-scrolled)
                        (screen-fill (- (int @Rows) 2), (dec (int @Rows)), 0, (int @Cols), (byte \space), (byte \space), 0)
                        ((ร mp_last =) (disp-sb-line (- (int @Rows) 2), mp_last))
                        (ร --toscroll)
                    )
                ))

                (when (<= toscroll 0)
                    ;; displayed the requested text, more prompt again
                    (screen-fill (dec (int @Rows)), (int @Rows), 0, (int @Cols), (byte \space), (byte \space), 0)
                    (msg-moremsg false)
                    (ร CONTINUE)
                )

                ;; display more text, return to caller
                (reset! lines_left toscroll)
            )

            (ร BREAK)
        )

        ;; clear the --more-- message
        (screen-fill (dec (int @Rows)), (int @Rows), 0, (int @Cols), (byte \space), (byte \space), 0)
        (reset! State oldState)

        (when @quit_more
            (reset! msg_row (dec (int @Rows)))
            (reset! msg_col 0)
        )

        retval
    ))

;; Put a character on the screen at the current message position and advance
;; to the next position.  Only for printable ASCII!

(defn- #_void msg-screen-putchar [#_int c, #_int attr]
    (ยง
        (reset! msg_didout true)          ;; remember that line is not empty

        (screen-putchar c, @msg_row, @msg_col, attr)

        (when (<= (int @Cols) (ร ++@msg_col))
            (reset! msg_col 0)
            (swap! msg_row inc)
        )
        nil
    ))

(defn- #_void msg-moremsg [#_boolean full]
    (ยง
        ((ร Bytes s =) (u8 "-- More --"))

        ((ร int attr =) (hl-attr HLF_M))
        (screen-puts s, (dec (int @Rows)), 0, attr)
        (when full
            (screen-puts (u8 " SPACE/d/j: screen/page/line down, b/u/k: up, q: quit "), (dec (int @Rows)), (mb-string2cells s, -1), attr)
        )
        nil
    ))

;; Repeat the message for the current mode: ASKMORE or CONFIRM.

(defn- #_void repeat-message []
    (ยง
        (cond (== @State ASKMORE)
        (do
            (msg-moremsg true)      ;; display --more-- message again
            (reset! msg_row (dec (int @Rows)))
        )
        (== @State CONFIRM)
        (do
            (display-confirm-msg)  ;; display ":confirm" message again
            (reset! msg_row (dec (int @Rows)))
        )
        (or (== @State HITRETURN) (== @State SETWSIZE))
        (do
            (when (== @msg_row (dec (int @Rows)))
                ;; Avoid drawing the "hit-enter" prompt below the previous one,
                ;; overwrite it.  Esp. useful when regaining focus and a
                ;; FocusGained autocmd exists but didn't draw anything.
                (reset! msg_didout false)
                (reset! msg_col 0)
                (msg-clr-eos)
            )
            (hit-return-msg)
            (reset! msg_row (dec (int @Rows)))
        ))
        nil
    ))

;; msg-check-screen - check if the screen is initialized.
;; Also check msg_row and msg_col, if they are too big it may cause a crash.
;; While starting the GUI the terminal codes will be set for the GUI, but the
;; output goes to the terminal.  Don't use the terminal codes then.

(defn- #_boolean msg-check-screen []
    (ยง
        (if (or (not @full_screen) (not (screen-valid false)))
            ((ร RETURN) false)
        )

        (if (<= (int @Rows) @msg_row)
            (reset! msg_row (dec (int @Rows))))
        (if (<= (int @Cols) @msg_col)
            (reset! msg_col (dec (int @Cols))))
        true
    ))

;; Clear from current message position to end of screen.
;; Skip this when ":silent" was used, no need to clear for redirection.

(defn- #_void msg-clr-eos []
    (msg-clr-eos-force)
    nil)

;; Clear from current message position to end of screen.
;; Note: msg_col is not updated, so we remember the end of the message for msg-check().

(defn- #_void msg-clr-eos-force []
    (ยง
        (cond (msg-use-printf)
        (do
            (when @full_screen        ;; only when termcap codes are valid
                (cond (non-eos? @T_CD)
                (do
                    (out-str @T_CD)  ;; clear to end of display
                )
                (non-eos? @T_CE)
                (do
                    (out-str @T_CE)  ;; clear to end of line
                ))
            )
        )
        :else
        (do
            (screen-fill @msg_row, (inc @msg_row), @msg_col, (int @Cols), (byte \space), (byte \space), 0)
            (screen-fill (inc @msg_row), (int @Rows), 0, (int @Cols), (byte \space), (byte \space), 0)
        ))
        nil
    ))

;; Clear the command line.

(defn- #_void msg-clr-cmdline []
    (reset! msg_row @cmdline_row)
    (reset! msg_col 0)
    (msg-clr-eos-force)
    nil)

;; end putting a message on the screen
;; call wait-return if the message does not fit in the available space
;; return true if wait-return not called.

(defn- #_boolean msg-end []
    (ยง
        ;; If the string is larger than the window,
        ;; or the ruler option is set and we run into it,
        ;; we have to redraw the window.
        ;; Do not do this if we are abandoning the file or editing the command line.

        (when (and (not @exiting) @need_wait_return (non-flag? @State CMDLINE))
            (wait-return FALSE)
            ((ร RETURN) false)
        )
        (out-flush)
        true
    ))

;; If the written message runs into the shown command or ruler, we have to
;; wait for hit-return and redraw the window later.

(defn- #_void msg-check []
    (when (and (== @msg_row (dec (int @Rows))) (<= @sc_col @msg_col))
        (reset! need_wait_return true)
        (reset! redraw_cmdline true)
    )
    nil)

;; Give a warning message (for searching).
;; Use 'w' highlighting and may repeat the message after redrawing

(defn- #_void give-warning [#_Bytes message, #_boolean hl]
    ;; Don't want a hit-enter prompt here.
    (swap! no_wait_return inc)

    (reset! keep_msg nil)
    (reset! keep_msg_attr (if hl (hl-attr HLF_W) 0))
    (if (and (msg-attr message, @keep_msg_attr) (zero? @msg_scrolled))
        (set-keep-msg message, @keep_msg_attr))
    (reset! msg_didout false)     ;; overwrite this message
    (reset! msg_nowait true)      ;; don't wait for this message
    (reset! msg_col 0)

    (swap! no_wait_return dec)
    nil)

;; Display the ":confirm" message.  Also called when screen resized.

(defn- #_void display-confirm-msg []
    ;; avoid that 'q' at the more prompt truncates the message here
    (swap! confirm_msg_used inc)
    (if (non-nil? @confirm_msg)
        (msg-puts-attr @confirm_msg, (hl-attr HLF_M)))
    (swap! confirm_msg_used dec)
    nil)

;; Code to handle user-settable options.  This is all pretty much table-
;; driven.  Checklist for adding a new option:
;; - Put it in the options array below (copy an existing entry).
;; - For a global option: Add a variable for it in option.h.
;; - For a buffer or window local option:
;;   - Add a PV_XX entry to the enum below.
;;   - Add a variable to the window or buffer struct in structs.h.
;;   - For a window option, add some code to copy-winopt().
;;   - For a buffer string option, add code to check-buf-options().
;; - If it's a numeric option, add any necessary bounds checks to do-set().
;; - If it's a list of flags, add some code in do-set(), search for WW_ALL.
;; When making changes:
;; - When an entry has the P_VIM flag, or is lacking the P_VI_DEF flag,
;;   add a comment at the help for the 'compatible' option.

;; The options that are local to a window or buffer have "indir" set to
;; one of these values.  Special values:
;; 0: global option.
;; PV_WIN is added: window-local option.
;; PV_BUF is added: buffer-local option.

(final int
    PV_WIN  0x2000,
    PV_BUF  0x4000)

;; Definition of the PV_ values for buffer-local options.
;; The BV_ values are defined in option.h.

(final int
    PV_AI   (| BV_AI   PV_BUF),
    PV_CI   (| BV_CI   PV_BUF),
    PV_CINW (| BV_CINW PV_BUF),
    PV_ET   (| BV_ET   PV_BUF),
    PV_ISK  (| BV_ISK  PV_BUF),
    PV_KP   (| BV_KP   PV_BUF),
    PV_MOD  (| BV_MOD  PV_BUF),
    PV_MPS  (| BV_MPS  PV_BUF),
    PV_NF   (| BV_NF   PV_BUF),
    PV_PI   (| BV_PI   PV_BUF),
    PV_QE   (| BV_QE   PV_BUF),
    PV_SI   (| BV_SI   PV_BUF),
    PV_STS  (| BV_STS  PV_BUF),
    PV_SW   (| BV_SW   PV_BUF),
    PV_TS   (| BV_TS   PV_BUF),
    PV_UL   (| BV_UL   PV_BUF))

;; Definition of the PV_ values for window-local options.
;; The WV_ values are defined in option.h.

(final int
    PV_COCU   (| WV_COCU   PV_WIN),
    PV_COLE   (| WV_COLE   PV_WIN),
    PV_CRBIND (| WV_CRBIND PV_WIN),
    PV_BRI    (| WV_BRI    PV_WIN),
    PV_BRIOPT (| WV_BRIOPT PV_WIN),
    PV_LBR    (| WV_LBR    PV_WIN),
    PV_NU     (| WV_NU     PV_WIN),
    PV_RNU    (| WV_RNU    PV_WIN),
    PV_NUW    (| WV_NUW    PV_WIN),
    PV_SCBIND (| WV_SCBIND PV_WIN),
    PV_SCROLL (| WV_SCROLL PV_WIN),
    PV_CUC    (| WV_CUC    PV_WIN),
    PV_CUL    (| WV_CUL    PV_WIN),
    PV_CC     (| WV_CC     PV_WIN),
    PV_WFH    (| WV_WFH    PV_WIN),
    PV_WFW    (| WV_WFW    PV_WIN),
    PV_WRAP   (| WV_WRAP   PV_WIN))

(class! #_final vimoption_C
    [
        (field Bytes    fullname)   ;; full option name
        (field Bytes    shortname)  ;; permissible abbreviation
        (field long     flags)      ;; see below
        (field Object   var)        ;; pointer to variable
        (field int      indir)      ;; indirect option index
        (field Object   def_val)    ;; default value for variable
    ])

(defn- #_vimoption_C new-vimoption [#_Bytes fullname, #_Bytes shortname, #_long flags, #_Object var, #_int indir, #_Object def_val]
    (ยง
        ((ร vimoption_C v =) (NEW_vimoption_C))

        ((ร v.fullname =) fullname)
        ((ร v.shortname =) shortname)
        ((ร v.flags =) flags)
        ((ร v.var =) var)
        ((ร v.indir =) indir)
        ((ร v.def_val =) def_val)

        v
    ))

;; Flags

(final int P_BOOL               0x01)   ;; the option is boolean
(final int P_NUM                0x02)   ;; the option is numeric
(final int P_STRING             0x04)   ;; the option is a string

                                        ;; when option changed, what to display:
(final int P_RSTAT            0x1000)   ;; redraw status lines
(final int P_RWIN             0x2000)   ;; redraw current window
(final int P_RBUF             0x4000)   ;; redraw current buffer
(final int P_RALL             0x6000)   ;; redraw all windows
(final int P_RCLR             0x7000)   ;; clear and redraw all

(final int P_COMMA            0x8000)   ;; comma separated list
(final int P_NODUP           0x10000)   ;; don't allow duplicate strings
(final int P_FLAGLIST        0x20000)   ;; list of single-char flags

(final int P_CURSWANT      0x2000000)   ;; update curswant required; not needed when there is a redraw flag

(final Bytes HIGHLIGHT_INIT (u8 "8:SpecialKey,@:NonText,e:ErrorMsg,i:IncSearch,l:Search,m:MoreMsg,M:ModeMsg,n:LineNr,N:CursorLineNr,r:Question,s:StatusLine,S:StatusLineNC,c:VertSplit,t:Title,v:Visual,w:WarningMsg,-:Conceal,!:CursorColumn,.:CursorLine,o:ColorColumn"))

(defn- #_vimoption_C bool-opt [#_Bytes fname, #_Bytes sname, #_long flags, #_"/*boolean[]*/Object" var, #_int indir, #_boolean def]
    (new-vimoption fname, sname, (| P_BOOL flags), var, indir, def))

(defn- #_vimoption_C long-opt [#_Bytes fname, #_Bytes sname, #_long flags, #_"/*long[]*/Object" var, #_int indir, #_long def]
    (new-vimoption fname, sname, (| P_NUM flags), var, indir, def))

(defn- #_vimoption_C utf8-opt [#_Bytes fname, #_Bytes sname, #_long flags, #_"/*Bytes[]*/Object" var, #_int indir, #_Bytes def]
    (new-vimoption fname, sname, (| P_STRING flags), var, indir, def))

;; vimoptions[] are initialized here.
;;
;; The order of the options MUST be alphabetic for ":set all" and findoption().
;; All option names MUST start with a lowercase letter (for findoption()).

(final vimoption_C* vimoptions
    [
        (bool-opt (u8 "autoindent"),     (u8 "ai"),        0,                           nil,         PV_AI,      false),
        (utf8-opt (u8 "backspace"),      (u8 "bs"),     (| P_COMMA P_NODUP),            p_bs,        0,         (u8 "")),
        (utf8-opt (u8 "breakat"),        (u8 "brk"),    (| P_RALL P_FLAGLIST),          p_breakat,   0,         (u8 " \t!@*-+;:,./?")),
        (bool-opt (u8 "breakindent"),    (u8 "bri"),       P_RWIN,                      nil,         PV_BRI,     false),
        (utf8-opt (u8 "breakindentopt"), (u8 "briopt"), (| P_RBUF P_COMMA P_NODUP),     nil,         PV_BRIOPT, (u8 "")),
        (utf8-opt (u8 "cinwords"),       (u8 "cinw"),   (| P_COMMA P_NODUP),            nil,         PV_CINW,   (u8 "if,else,while,do,for,switch")),
        (long-opt (u8 "cmdheight"),      (u8 "ch"),        P_RALL,                      p_ch,        0,          1),
        (long-opt (u8 "cmdwinheight"),   (u8 "cwh"),       0,                           p_cwh,       0,          7),
        (utf8-opt (u8 "colorcolumn"),    (u8 "cc"),     (| P_COMMA P_NODUP P_RWIN),     nil,         PV_CC,     (u8 "")),
        (utf8-opt (u8 "concealcursor"),  (u8 "cocu"),      P_RWIN,                      nil,         PV_COCU,   (u8 "")),
        (long-opt (u8 "conceallevel"),   (u8 "cole"),      P_RWIN,                      nil,         PV_COLE,    0),
        (bool-opt (u8 "copyindent"),     (u8 "ci"),        0,                           nil,         PV_CI,      false),
        (utf8-opt (u8 "cpoptions"),      (u8 "cpo"),    (| P_RALL P_FLAGLIST),          p_cpo,       0,          CPO_VIM),
        (bool-opt (u8 "cursorbind"),     (u8 "crb"),       0,                           nil,         PV_CRBIND,  false),
        (bool-opt (u8 "cursorcolumn"),   (u8 "cuc"),       P_RWIN,                      nil,         PV_CUC,     false),
        (bool-opt (u8 "cursorline"),     (u8 "cul"),       P_RWIN,                      nil,         PV_CUL,     false),
        (bool-opt (u8 "delcombine"),     (u8 "deco"),      0,                           p_deco,      0,          false),
        (bool-opt (u8 "digraph"),        (u8 "dg"),        0,                           p_dg,        0,          false),
        (utf8-opt (u8 "display"),        (u8 "dy"),     (| P_COMMA P_RALL P_NODUP),     p_dy,        0,         (u8 "")),
        (utf8-opt (u8 "eadirection"),    (u8 "ead"),       0,                           p_ead,       0,         (u8 "both")),
        (bool-opt (u8 "equalalways"),    (u8 "ea"),        P_RALL,                      p_ea,        0,          true),
        (bool-opt (u8 "errorbells"),     (u8 "eb"),        0,                           p_eb,        0,          false),
        (bool-opt (u8 "esckeys"),        (u8 "ek"),        0,                           p_ek,        0,          true),
        (bool-opt (u8 "expandtab"),      (u8 "et"),        0,                           nil,         PV_ET,      false),
        (bool-opt (u8 "gdefault"),       (u8 "gd"),        0,                           p_gd,        0,          false),
        (utf8-opt (u8 "highlight"),      (u8 "hl"),     (| P_RCLR P_COMMA P_NODUP),     p_hl,        0,          HIGHLIGHT_INIT),
        (long-opt (u8 "history"),        (u8 "hi"),        0,                           p_hi,        0,          50),
        (bool-opt (u8 "hlsearch"),       (u8 "hls"),       P_RALL,                      p_hls,       0,          false),
        (bool-opt (u8 "ignorecase"),     (u8 "ic"),        0,                           p_ic,        0,          false),
        (bool-opt (u8 "incsearch"),      (u8 "is"),        0,                           p_is,        0,          false),
        (bool-opt (u8 "insertmode"),     (u8 "im"),        0,                           p_im,        0,          false),
        (utf8-opt (u8 "isfname"),        (u8 "isf"),    (| P_COMMA P_NODUP),            p_isf,       0,         (u8 "@,48-57,/,.,-,_,+,,,#,$,%,~,=")),
        (utf8-opt (u8 "isident"),        (u8 "isi"),    (| P_COMMA P_NODUP),            p_isi,       0,         (u8 "@,48-57,_,192-255")),
        (utf8-opt (u8 "iskeyword"),      (u8 "isk"),    (| P_COMMA P_NODUP),            nil,         PV_ISK,    (u8 "@,48-57,_,192-255")),
        (utf8-opt (u8 "isprint"),        (u8 "isp"),    (| P_RALL P_COMMA P_NODUP),     p_isp,       0,         (u8 "@,161-255")),
        (bool-opt (u8 "joinspaces"),     (u8 "js"),        0,                           p_js,        0,          true),
        (utf8-opt (u8 "keymodel"),       (u8 "km"),     (| P_COMMA P_NODUP),            p_km,        0,         (u8 "")),
        (utf8-opt (u8 "keywordprg"),     (u8 "kp"),        0,                           nil,         PV_KP,     (u8 ":echo")),
        (long-opt (u8 "laststatus"),     (u8 "ls"),        P_RALL,                      p_ls,        0,          1),
        (bool-opt (u8 "lazyredraw"),     (u8 "lz"),        0,                           p_lz,        0,          false),
        (bool-opt (u8 "linebreak"),      (u8 "lbr"),       P_RWIN,                      nil,         PV_LBR,     false),
        (bool-opt (u8 "magic"),           nil,             0,                           p_magic,     0,          true),
        (utf8-opt (u8 "matchpairs"),     (u8 "mps"),    (| P_COMMA P_NODUP),            nil,         PV_MPS,    (u8 "(:),{:},[:]")),
        (long-opt (u8 "matchtime"),      (u8 "mat"),       0,                           p_mat,       0,          5),
        (long-opt (u8 "maxcombine"),     (u8 "mco"),       P_CURSWANT,                  p_mco,       0,          2),
        (long-opt (u8 "maxmempattern"),  (u8 "mmp"),       0,                           p_mmp,       0,          1000),
        (bool-opt (u8 "modified"),       (u8 "mod"),       P_RSTAT,                     nil,         PV_MOD,     false),
        (bool-opt (u8 "more"),            nil,             0,                           p_more,      0,          true),
        (utf8-opt (u8 "nrformats"),      (u8 "nf"),     (| P_COMMA P_NODUP),            nil,         PV_NF,     (u8 "octal,hex")),
        (bool-opt (u8 "number"),         (u8 "nu"),        P_RWIN,                      nil,         PV_NU,      false),
        (long-opt (u8 "numberwidth"),    (u8 "nuw"),       P_RWIN,                      nil,         PV_NUW,     4),
        (utf8-opt (u8 "operatorfunc"),   (u8 "opfunc"),    0,                           p_opfunc,    0,         (u8 "")),
        (bool-opt (u8 "paste"),           nil,             0,                           p_paste,     0,          false),
        (bool-opt (u8 "preserveindent"), (u8 "pi"),        0,                           nil,         PV_PI,      false),
        (bool-opt (u8 "prompt"),          nil,             0,                           p_prompt,    0,          true),
        (utf8-opt (u8 "quoteescape"),    (u8 "qe"),        0,                           nil,         PV_QE,     (u8 "\\")),
        (long-opt (u8 "redrawtime"),     (u8 "rdt"),       0,                           p_rdt,       0,          2000),
        (long-opt (u8 "regexpengine"),   (u8 "re"),        0,                           p_re,        0,          0),
        (bool-opt (u8 "relativenumber"), (u8 "rnu"),       P_RWIN,                      nil,         PV_RNU,     false),
        (long-opt (u8 "report"),          nil,             0,                           p_report,    0,          2),
        (bool-opt (u8 "ruler"),          (u8 "ru"),        P_RSTAT,                     p_ru,        0,          false),
        (long-opt (u8 "scroll"),         (u8 "scr"),       0,                           nil,         PV_SCROLL,  12),
        (bool-opt (u8 "scrollbind"),     (u8 "scb"),       0,                           nil,         PV_SCBIND,  false),
        (long-opt (u8 "scrolljump"),     (u8 "sj"),        0,                           p_sj,        0,          1),
        (long-opt (u8 "scrolloff"),      (u8 "so"),        P_RALL,                      p_so,        0,          0),
        (utf8-opt (u8 "scrollopt"),      (u8 "sbo"),    (| P_COMMA P_NODUP),            p_sbo,       0,         (u8 "ver,jump")),
        (utf8-opt (u8 "selection"),      (u8 "sel"),       0,                           p_sel,       0,         (u8 "inclusive")),
        (utf8-opt (u8 "selectmode"),     (u8 "slm"),    (| P_COMMA P_NODUP),            p_slm,       0,         (u8 "")),
        (bool-opt (u8 "shiftround"),     (u8 "sr"),        0,                           p_sr,        0,          false),
        (long-opt (u8 "shiftwidth"),     (u8 "sw"),        0,                           nil,         PV_SW,      8),
        (utf8-opt (u8 "showbreak"),      (u8 "sbr"),       P_RALL,                      p_sbr,       0,         (u8 "")),
        (bool-opt (u8 "showcmd"),        (u8 "sc"),        0,                           p_sc,        0,          false),
        (bool-opt (u8 "showmatch"),      (u8 "sm"),        0,                           p_sm,        0,          false),
        (bool-opt (u8 "showmode"),       (u8 "smd"),       0,                           p_smd,       0,          true),
        (long-opt (u8 "sidescroll"),     (u8 "ss"),        0,                           p_ss,        0,          0),
        (long-opt (u8 "sidescrolloff"),  (u8 "siso"),      P_RBUF,                      p_siso,      0,          0),
        (bool-opt (u8 "smartcase"),      (u8 "scs"),       0,                           p_scs,       0,          false),
        (bool-opt (u8 "smartindent"),    (u8 "si"),        0,                           nil,         PV_SI,      false),
        (bool-opt (u8 "smarttab"),       (u8 "sta"),       0,                           p_sta,       0,          false),
        (long-opt (u8 "softtabstop"),    (u8 "sts"),       0,                           nil,         PV_STS,     0),
        (bool-opt (u8 "splitbelow"),     (u8 "sb"),        0,                           p_sb,        0,          false),
        (bool-opt (u8 "splitright"),     (u8 "spr"),       0,                           p_spr,       0,          false),
        (bool-opt (u8 "startofline"),    (u8 "sol"),       0,                           p_sol,       0,          true),
        (long-opt (u8 "tabstop"),        (u8 "ts"),        P_RBUF,                      nil,         PV_TS,      8),
        (bool-opt (u8 "tildeop"),        (u8 "top"),       0,                           p_to,        0,          false),
        (bool-opt (u8 "timeout"),        (u8 "to"),        0,                           p_timeout,   0,          true),
        (long-opt (u8 "timeoutlen"),     (u8 "tm"),        0,                           p_tm,        0,          1000),
        (bool-opt (u8 "ttimeout"),        nil,             0,                           p_ttimeout,  0,          false),
        (long-opt (u8 "ttimeoutlen"),    (u8 "ttm"),       0,                           p_ttm,       0,          -1),
        (long-opt (u8 "ttyscroll"),      (u8 "tsl"),       0,                           p_ttyscroll, 0,          999),
        (long-opt (u8 "undolevels"),     (u8 "ul"),        0,                           nil,         PV_UL,      1000),
        (long-opt (u8 "updatetime"),     (u8 "ut"),        0,                           p_ut,        0,          4000),
        (long-opt (u8 "verbose"),        (u8 "vbs"),       0,                           p_verbose,   0,          0),
        (utf8-opt (u8 "virtualedit"),    (u8 "ve"),     (| P_COMMA P_NODUP P_CURSWANT), p_ve,        0,         (u8 "")),
        (bool-opt (u8 "visualbell"),     (u8 "vb"),        0,                           p_vb,        0,          false),
        (utf8-opt (u8 "whichwrap"),      (u8 "ww"),     (| P_COMMA P_FLAGLIST),         p_ww,        0,         (u8 "b,s")),
        (long-opt (u8 "winheight"),      (u8 "wh"),        0,                           p_wh,        0,          1),
        (bool-opt (u8 "winfixheight"),   (u8 "wfh"),       P_RSTAT,                     nil,         PV_WFH,     false),
        (bool-opt (u8 "winfixwidth"),    (u8 "wfw"),       P_RSTAT,                     nil,         PV_WFW,     false),
        (long-opt (u8 "winminheight"),   (u8 "wmh"),       0,                           p_wmh,       0,          1),
        (long-opt (u8 "winminwidth"),    (u8 "wmw"),       0,                           p_wmw,       0,          1),
        (long-opt (u8 "winwidth"),       (u8 "wiw"),       0,                           p_wiw,       0,          20),
        (bool-opt (u8 "wrap"),            nil,             P_RWIN,                      nil,         PV_WRAP,    true),
        (bool-opt (u8 "wrapscan"),       (u8 "ws"),        0,                           p_ws,        0,          true),
        (long-opt (u8 "writedelay"),     (u8 "wd"),        0,                           p_wd,        0,          0),
    ])

(final Bytes*
    p_nf_values     [ (u8 "octal"), (u8 "hex"), (u8 "alpha"), nil ],
    p_sel_values    [ (u8 "inclusive"), (u8 "exclusive"), (u8 "old"), nil ],
    p_slm_values    [ (u8 "key"), (u8 "cmd"), nil ],
    p_km_values     [ (u8 "startsel"), (u8 "stopsel"), nil ],
    p_scbopt_values [ (u8 "ver"), (u8 "hor"), (u8 "jump"), nil ],
    p_ead_values    [ (u8 "both"), (u8 "ver"), (u8 "hor"), nil ],
    p_bs_values     [ (u8 "indent"), (u8 "eol"), (u8 "start"), nil ])

;; Initialize the options, first part.
;;
;; Called only once from main(), just after creating the first buffer.

(defn- #_void set-init-1 []
    ;; Set all the options (except the terminal options) to their default value.
    ;; Also set the global value for local options.

    (set-options-default)
    (check-buf-options @curbuf)
    (check-win-options @curwin)
    (check-options)
    (didset-options)

    (fill-breakat-flags)
    (highlight-changed)
    (init-chartab)
    (screenalloc false)
    nil)

;; Set an option to its default value.
;; This does not take care of side effects!

(defn- #_void set-option-default [#_int opt_idx]
    (ยง
        ((ร vimoption_C v =) (... vimoptions opt_idx))

        ((ร Object varp =) (get-varp v))

        (cond (flag? (:flags v) P_STRING)
        (do
            ((ร (Bytes)@varp =) (STRDUP (ร (Bytes)(v.def_val))))
        )
        (flag? (:flags v) P_NUM)
        (do
            (if (== (:indir v) PV_SCROLL)
                (win-comp-scroll @curwin)
                ((ร (long)@varp =) (long (:def_val v)))
            )
        )
        (flag? (:flags v) P_BOOL)
        (do
            ((ร (boolean)@varp =) (boolean (:def_val v)))
        ))
        nil
    ))

;; Set all options (except terminal options) to their default value.

(defn- #_void set-options-default []
    (ยง
        (dotimes [#_int i (:length vimoptions)]
            (set-option-default i)
        )

        ;; The 'scroll' option must be computed for all windows.
        ((ร FOR) (ร ((ร window_C wp =) @firstwin) (non-nil? wp) ((ร wp =) (:w_next wp)))
            (win-comp-scroll wp)
        )
        nil
    ))

;; Set the Vi-default value of a number option.
;; Used for 'lines' and 'columns'.

(defn- #_void set-number-default [#_Bytes name, #_long val]
    (ยง
        ((ร int opt_idx =) (findoption name))
        (when (<= 0 opt_idx)
            ((ร vimoptions[opt_idx].def_val =) val)
        )
        nil
    ))

;; Initialize the options, part two: After getting Rows and Cols and setting 'term'.

(defn- #_void set-init-2 []
    ;; 'scroll' defaults to half the window height.
    ;; Note that this default is wrong when the window height changes.

    (set-number-default (u8 "scroll"), (>>> @Rows 1))
    (win-comp-scroll @curwin)
    (comp-col)
    nil)

;; Parse 'arg' for option settings.
;;
;; returns false if an error is detected, true otherwise

(defn- #_boolean do-set [#_Bytes arg]
    ;; arg: option string (may be written to!)
    (ยง
        ((ร boolean did_show =) false)           ;; already showed one value

        ((ร Bytes errbuf =) (Bytes. 80))

        ((ร FOR) (ร nil (non-eos? arg) ((ร arg =) (skipwhite arg)))             ;; loop to process all options
            ((ร Bytes errmsg =) nil)
            ((ร Bytes startarg =) arg)      ;; remember for error message

            ((ร int prefix =) 1)     ;; 1: nothing, 0: "no", 2: "inv" in front of name
            (cond (and (zero? (STRNCMP arg, (u8 "no"), 2)) (non-zero? (STRNCMP arg, (u8 "novice"), 6)))
            (do
                ((ร prefix =) 0)
                ((ร arg =) (.plus arg 2))
            )
            (zero? (STRNCMP arg, (u8 "inv"), 3))
            (do
                ((ร prefix =) 2)
                ((ร arg =) (.plus arg 3))
            ))

;           skip:
;           {
                (when (== (.at arg 0) (byte \<))
                    ((ร errmsg =) e_invarg)
                    (ร BREAK skip)
                )

                (ร int nextchar)           ;; next non-white char after option name

                ;; find end of name
                ((ร int len =) 0)
                (while (or (asc-isalnum (.at arg len)) (== (.at arg len) (byte \_)))
                    (ร len++)
                )
                ((ร nextchar =) (.at arg len))
                (eos! arg len)                           ;; put NUL after name
                ((ร int opt_idx =) (findoption arg))
                (.be arg len, nextchar)                      ;; restore nextchar

                (when (== opt_idx -1)      ;; found a mismatch: skip
                    ((ร errmsg =) (u8 "E518: Unknown option"))
                    (ร BREAK skip)
                )

                ;; remember character after option name
                ((ร byte afterchar =) (.at arg len))

                ;; skip white space, allow ":set ai  ?"
                (while (vim-iswhite (.at arg len))
                    (ร len++)
                )

                ((ร nextchar =) (.at arg len))

                (when (and (!= nextchar NUL) (== (.at arg (inc len)) (byte \=)))
                    ((ร errmsg =) e_invarg)
                    (ร BREAK skip)
                )

                ((ร vimoption_C v =) (... vimoptions opt_idx))

                ((ร Object varp =) (get-varp v))

                (when (non-nil? (vim-strchr (u8 "?=:!&<"), nextchar))
                    ((ร arg =) (.plus arg len))
                    (when (and (non-nil? (vim-strchr (u8 "?!&<"), nextchar)) (non-eos? arg 1) (not (vim-iswhite (.at arg 1))))
                        ((ร errmsg =) e_trailing)
                        (ร BREAK skip)
                    )
                )

                ;; allow '=' and ':' as MSDOS command.com allows
                ;; only one '=' character per "set" command line

                (cond (or (== nextchar (byte \?)) (and (== prefix 1) (nil? (vim-strchr (u8 "=:&<"), nextchar)) (non-flag? (:flags v) P_BOOL)))
                (do
                    ;; print value
                    (cond did_show
                    (do
                        (msg-putchar (byte \newline))      ;; cursor below last one
                    )
                    :else
                    (do
                        (gotocmdline true)      ;; cursor at status line
                        ((ร did_show =) true)        ;; remember that we did a line
                    ))

                    (showoneopt v)

                    (if (and (!= nextchar (byte \?)) (!= nextchar NUL) (not (vim-iswhite afterchar)))
                        ((ร errmsg =) e_trailing)
                    )
                )
                :else
                (do
                    (cond (flag? (:flags v) P_BOOL)          ;; boolean
                    (do
                        (when (or (== nextchar (byte \=)) (== nextchar (byte \:)) (== nextchar (byte \<)))
                            ((ร errmsg =) e_invarg)
                            (ร BREAK skip)
                        )

                        (ร boolean value)

                        ;; ":set opt!": invert
                        ;; ":set opt&": reset to default value

                        (cond (== nextchar (byte \!))
                        (do
                            ((ร value =) (not (boolean @varp)))
                        )
                        (== nextchar (byte \&))
                        (do
                            ((ร value =) (boolean (:def_val v)))
                        )
                        :else
                        (do
                            ;; ":set invopt": invert
                            ;; ":set opt" or ":set noopt": set or reset

                            (when (and (!= nextchar NUL) (not (vim-iswhite afterchar)))
                                ((ร errmsg =) e_trailing)
                                (ร BREAK skip)
                            )
                            ((ร value =) (if (== prefix 2) (not (boolean @varp)) (!= prefix 0)))
                        ))

                        ((ร errmsg =) (set-bool-option opt_idx, (ร (boolean[])varp), value))
                    )
                    :else                                ;; numeric or string
                    (do
                        (when (or (nil? (vim-strchr (u8 "=:&"), nextchar)) (!= prefix 1))
                            ((ร errmsg =) e_invarg)
                            (ร BREAK skip)
                        )

                        (cond (flag? (:flags v) P_NUM)       ;; numeric
                        (do
                            (ร long value)

                            ;; Different ways to set a number option:
                            ;; &        set to default value
                            ;; <xx>     accept special key codes for 'wildchar'
                            ;; c        accept any non-digit for 'wildchar'
                            ;; [-]0-9   set number
                            ;; other    error

                            ((ร arg =) (.plus arg 1))
                            (cond (== nextchar (byte \&))
                            (do
                                ((ร value =) (long (:def_val v)))
                            )
                            (or (== (.at arg 0) (byte \-)) (asc-isdigit (.at arg 0)))
                            (do
                                ((ร int[] ip =) (ร new int[1]))

                                ;; Allow negative (for 'undolevels'), octal and hex numbers.
;                               { long[] __ = new long[1]; vim-str2nr(arg, null, ip, TRUE, TRUE, __); value = __[0]; }
                                (when (and (!= (.at arg (... ip 0)) NUL) (not (vim-iswhite (.at arg (... ip 0)))))
                                    ((ร errmsg =) e_invarg)
                                    (ร BREAK skip)
                                )
                            )
                            :else
                            (do
                                ((ร errmsg =) (u8 "E521: Number required after ="))
                                (ร BREAK skip)
                            ))

                            ((ร errmsg =) (set-num-option opt_idx, (ร (long[])varp), value, errbuf, (.size errbuf)))
                        )
                        :else                  ;; string
                        (do
                            ((ร Bytes save_arg =) nil)

                            (ร Bytes newval)
                            ;; The old value is kept until we are sure that the new value is valid.
                            ((ร Bytes oldval =) (ร (Bytes)@varp))
                            (cond (== nextchar (byte \&))    ;; set to default val
                            (do
                                ((ร newval =) (ร (Bytes)v.def_val))
                                ((ร newval =) (if (nil? newval) EMPTY_OPTION (STRDUP newval)))
                            )
                            :else
                            (do
                                ((ร arg =) (.plus arg 1))      ;; jump to after the '=' or ':'

                                ;; Set 'keywordprg' to ":echo" if an empty
                                ;; value was passed to :set by the user.
                                ;; Misuse errbuf[] for the resulting string.

                                (when (and (== varp @(:b_p_kp @curbuf)) (or (eos? arg) (== (.at arg 0) (byte \space))))
                                    (STRCPY errbuf, (u8 ":echo"))
                                    ((ร save_arg =) arg)
                                    ((ร arg =) errbuf)
                                )

                                ((ร Bytes origval =) oldval)

                                ((ร newval =) (Bytes. (inc (STRLEN arg))))
                                ((ร Bytes s =) newval)

                                ;; Copy the string, skip over escaped chars.

                                (while (and (non-eos? arg) (not (vim-iswhite (.at arg 0))))
                                    (if (and (== (.at arg 0) (byte \\)) (non-eos? arg 1))
                                        ((ร arg =) (.plus arg 1))      ;; remove backslash
                                    )
                                    ((ร int i =) (us-ptr2len-cc arg))
                                    (cond (< 1 i)
                                    (do
                                        ;; copy multibyte char
                                        (BCOPY s, arg, i)
                                        ((ร arg =) (.plus arg i))
                                        ((ร s =) (.plus s i))
                                    )
                                    :else
                                    (do
                                        (.be ((ร s =) (.plus s 1)) -1, (.at ((ร arg =) (.plus arg 1)) -1))
                                    ))
                                )
                                (eos! s)

                                ;; Locate newval[] in origval[] when removing it and when adding to avoid duplicates.
                                ((ร int i =) 0)
                                (when (flag? (:flags v) P_NODUP)
                                    ((ร i =) (STRLEN newval))
                                    ((ร int bs =) 0)
                                    ((ร FOR) (ร ((ร s =) origval) (non-eos? s) ((ร s =) (.plus s 1)))
                                        (if (and (or (non-flag? (:flags v) P_COMMA) (BEQ s, origval) (and (== (.at s -1) (byte \,)) (zero? (& bs 1)))) (zero? (STRNCMP s, newval, i)) (or (non-flag? (:flags v) P_COMMA) (== (.at s i) (byte \,)) (eos? s i)))
                                            (ร BREAK)
                                        )
                                        ;; Count backslashes.
                                        ;; Only a comma with an even number of backslashes before it is recognized as a separator.
                                        (if (and (BLT origval, s) (== (.at s -1) (byte \\)))
                                            (ร bs++)
                                            ((ร bs =) 0)
                                        )
                                    )
                                )

                                (when (flag? (:flags v) P_FLAGLIST)
                                    ;; Remove flags that appear twice.
                                    ((ร FOR) (ร ((ร s =) newval) (non-eos? s) ((ร s =) (.plus s 1)))
                                        (when (and (or (non-flag? (:flags v) P_COMMA) (!= (.at s 0) (byte \,))) (non-nil? (vim-strbyte (.plus s 1), (.at s 0))))
                                            (BCOPY s, 0, s, 1, (+ (STRLEN s, 1) 1))
                                            ((ร s =) (.minus s 1))
                                        )
                                    )
                                )

                                (if (non-nil? save_arg)   ;; number for 'whichwrap'
                                    ((ร arg =) save_arg)
                                )
                            ))

                            ;; Set the new value.
                            ((ร (Bytes)@varp =) newval)

                            ;; Handle side effects, and set the global value for ":set" on local options.
                            ((ร errmsg =) (did-set-string-option opt_idx, (ร (Bytes[])varp), oldval, errbuf))

                            ;; If error detected, print the error message.
                            (if (non-nil? errmsg)
                                (ร BREAK skip)
                            )
                        ))
                    ))
                ))
;           }

            ;; Advance to next argument.
            ;; - skip until a blank found, taking care of backslashes
            ;; - skip blanks
            ;; - skip one "=val" argument (for hidden options ":set gfn =xx")

            (dotimes [_ 2]
                (while (and (non-eos? arg) (not (vim-iswhite (.at arg 0))))
                    (if (and (== (.at ((ร arg =) (.plus arg 1)) -1) (byte \\)) (non-eos? arg))
                        ((ร arg =) (.plus arg 1))
                    )
                )
                ((ร arg =) (skipwhite arg))
                (if (!= (.at arg 0) (byte \=))
                    (ร BREAK)
                )
            )

            (when (non-nil? errmsg)
                (vim-strncpy @ioBuff, errmsg, (dec IOSIZE))
                ((ร int i =) (+ (STRLEN @ioBuff) 2))
                (when (< (+ i (BDIFF arg, startarg)) IOSIZE)
                    ;; append the argument with the error
                    (STRCAT @ioBuff, (u8 ": "))
                    (BCOPY @ioBuff, i, startarg, 0, (BDIFF arg, startarg))
                    (.be @ioBuff (+ i (BDIFF arg, startarg)), NUL)
                )
                ;; make sure all characters are printable
                (trans-characters @ioBuff, IOSIZE)

                (swap! no_wait_return inc)       ;; wait-return done later
                (emsg @ioBuff)           ;; show error highlighted
                (swap! no_wait_return dec)

                ((ร RETURN) false)
            )
        )

        true
    ))

(defn- #_Bytes illegal-char [#_Bytes errbuf, #_int c]
    (ยง
        (if (nil? errbuf)
            ((ร RETURN) (u8 ""))
        )

        (.sprintf libC errbuf, (u8 "E539: Illegal character <%s>"), (transchar c))
        errbuf
    ))

;; After setting various option values: recompute variables that depend on option values.

(defn- #_void didset-options []
    ;; initialize the table for 'iskeyword' et al.
    (init-chartab)

    (opt-strings-flags @p_dy, p_dy_values, dy_flags, true)
    (opt-strings-flags @p_ve, p_ve_values, ve_flags, true)

    (briopt-check @curwin)
    nil)

;; Check for string options that are null (normally only termcap options).

(defn- #_void check-options []
    (ยง
        (dotimes [#_int i (:length vimoptions)]
            (when (flag? (:flags (... vimoptions i)) P_STRING)
                (check-string-option (ร (Bytes[])get-varp(vimoptions[i])))
            )
        )
        nil
    ))

;; Check string options in a buffer for null value.

(defn- #_void check-buf-options [#_buffer_C buf]
    (check-string-option (:b_p_kp buf))
    (check-string-option (:b_p_mps buf))
    (check-string-option (:b_p_isk buf))
    (check-string-option (:b_p_nf buf))
    (check-string-option (:b_p_qe buf))
    (check-string-option (:b_p_cinw buf))
    nil)

(defn- #_void clear-string-option [#_Bytes* pp]
    (ยง
        ((ร pp[0] =) EMPTY_OPTION)
        nil
    ))

(defn- #_void check-string-option [#_Bytes* pp]
    (ยง
        (when (nil? (... pp 0))
            ((ร pp[0] =) EMPTY_OPTION)
        )
        nil
    ))

;; Handle string options that need some action to perform when changed.
;; Returns null for success, or an error message for an error.

(defn- #_Bytes did-set-string-option [#_int opt_idx, #_Bytes* varp, #_Bytes oldval, #_Bytes errbuf]
    ;; opt_idx: index in vimoptions[] table
    ;; varp: pointer to the option variable
    ;; oldval: previous value of the option
    ;; errbuf: buffer for errors, or null
    (ยง
        ((ร vimoption_C v =) (... vimoptions opt_idx))

        ((ร Bytes errmsg =) nil)
        ((ร boolean did_chartab =) false)

        ;; 'breakindentopt'
        (cond (== varp (:wo_briopt (:w_options @curwin)))
        (do
            (if (not (briopt-check @curwin))
                ((ร errmsg =) e_invarg)
            )
        )

        ;; 'isident', 'iskeyword', 'isprint' or 'isfname' option: refill chartab[]
        ;; If the new option is invalid, use old value.

        (or (== varp p_isi) (== varp (:b_p_isk @curbuf)) (== varp p_isp) (== varp p_isf))
        (do
            (when (not (init-chartab))
                ((ร did_chartab =) true)     ;; need to restore it below
                ((ร errmsg =) e_invarg)      ;; error in value
            )
        )

        ;; 'colorcolumn'
        (== varp (:wo_cc (:w_options @curwin)))
        (do
            ((ร errmsg =) (check-colorcolumn @curwin))
        )

        ;; 'highlight'
        (== varp p_hl)
        (do
            (if (not (highlight-changed))
                ((ร errmsg =) e_invarg)  ;; invalid flags
            )
        )

        ;; 'nrformats'
        (== varp (:b_p_nf @curbuf))
        (do
            (if (not (check-opt-strings (... varp 0), p_nf_values, true))
                ((ร errmsg =) e_invarg)
            )
        )

        ;; 'scrollopt'
        (== varp p_sbo)
        (do
            (if (not (check-opt-strings @p_sbo, p_scbopt_values, true))
                ((ร errmsg =) e_invarg)
            )
        )

        ;; 'matchpairs'
        (== varp (:b_p_mps @curbuf))
        (do
            ((ร FOR) (ร ((ร Bytes p =) (... varp 0)) (non-eos? p) ((ร p =) (.plus p 1)))
                ((ร int x2 =) -1)
                ((ร int x3 =) -1)

                (if (non-eos? p)
                    ((ร p =) (.plus p (us-ptr2len-cc p)))
                )
                (if (non-eos? p)
                    ((ร x2 =) (.at ((ร p =) (.plus p 1)) -1))
                )
                (when (non-eos? p)
                    ((ร x3 =) (us-ptr2char p))
                    ((ร p =) (.plus p (us-ptr2len-cc p)))
                )
                (when (or (!= x2 (byte \:)) (== x3 -1) (and (non-eos? p) (!= (.at p 0) (byte \,))))
                    ((ร errmsg =) e_invarg)
                    (ร BREAK)
                )
                (if (eos? p)
                    (ร BREAK)
                )
            )
        )

        ;; 'showbreak'
        (== varp p_sbr)
        (do
            ((ร FOR) (ร ((ร Bytes s =) @p_sbr) (non-eos? s) nil)
                (if (!= (mb-ptr2cells s) 1)
                    ((ร errmsg =) (u8 "E595: contains unprintable or wide character"))
                )
                ((ร s =) (.plus s (us-ptr2len-cc s)))
            )
        )

        ;; 'breakat'
        (== varp p_breakat)
        (do
            (fill-breakat-flags)
        )

        ;; 'selection'
        (== varp p_sel)
        (do
            (if (or (eos? @p_sel) (not (check-opt-strings @p_sel, p_sel_values, false)))
                ((ร errmsg =) e_invarg)
            )
        )

        ;; 'selectmode'
        (== varp p_slm)
        (do
            (if (not (check-opt-strings @p_slm, p_slm_values, true))
                ((ร errmsg =) e_invarg)
            )
        )

        ;; 'keymodel'
        (== varp p_km)
        (do
            (cond (not (check-opt-strings @p_km, p_km_values, true))
            (do
                ((ร errmsg =) e_invarg)
            )
            :else
            (do
                (reset! km_stopsel (non-nil? (vim-strchr @p_km, (byte \o))))
                (reset! km_startsel (non-nil? (vim-strchr @p_km, (byte \a))))
            ))
        )

        ;; 'display'
        (== varp p_dy)
        (do
            (if (not (opt-strings-flags @p_dy, p_dy_values, dy_flags, true))
                ((ร errmsg =) e_invarg)
                (init-chartab))
        )

        ;; 'eadirection'
        (== varp p_ead)
        (do
            (if (not (check-opt-strings @p_ead, p_ead_values, false))
                ((ร errmsg =) e_invarg)
            )
        )

        ;; 'backspace'
        (== varp p_bs)
        (do
            (if (not (check-opt-strings @p_bs, p_bs_values, true))
                ((ร errmsg =) e_invarg)
            )
        )

        ;; 'virtualedit'
        (== varp p_ve)
        (do
            (cond (not (opt-strings-flags @p_ve, p_ve_values, ve_flags, true))
            (do
                ((ร errmsg =) e_invarg)
            )
            (non-zero? (STRCMP @p_ve, oldval))
            (do
                ;; Recompute cursor position in case the new 've' setting changes something.
                (validate-virtcol)
                (coladvance (:w_virtcol @curwin))
            ))
        )

        ;; Options that are a list of flags.
        :else
        (do
            ((ร Bytes p =) nil)
            (cond (== varp p_ww)
            (do
                ((ร p =) WW_ALL)
            )
            (== varp p_cpo)
            (do
                ((ร p =) CPO_ALL)
            )
            (== varp (:wo_cocu (:w_options @curwin)))
            (do
                ((ร p =) COCU_ALL)
            ))
            (when (non-nil? p)
                ((ร FOR) (ร ((ร Bytes s =) (... varp 0)) (non-eos? s) ((ร s =) (.plus s 1)))
                    (when (nil? (vim-strchr p, (.at s 0)))
                        ((ร errmsg =) (illegal-char errbuf, (.at s 0)))
                        (ร BREAK)
                    )
                )
            )
        ))

        ;; If error detected, restore the previous value.

        (when (non-nil? errmsg)
            ((ร varp[0] =) oldval)

            ;; When resetting some values, need to act on it.

            (if did_chartab
                (init-chartab))
            (if (== varp p_hl)
                (highlight-changed))
        )

        (if (and (!= (:w_curswant @curwin) MAXCOL) (flag? (:flags v) (| P_CURSWANT P_RALL)))
            ((ร @curwin.w_set_curswant =) true)
        )
        (check-redraw (:flags v))

        errmsg
    ))

;; Handle setting 'colorcolumn' in window "wp".
;; Returns error message, null if it's OK.

(defn- #_Bytes check-colorcolumn [#_window_C wp]
    (ยง
        ((ร int count =) 0)
        ((ร int[] color_cols =) (ร new int[256]))

        ((ร FOR) (ร ((ร Bytes s =) @(:wo_cc (:w_options wp))) (and (non-eos? s) (< count 255)) nil)
            (if (not (asc-isdigit (.at s 0)))
                ((ร RETURN) e_invarg)
            )

            (ร int col)
;           Bytes[] __ = { s }; col = (int)getdigits(__); s = __[0];

            ((ร color_cols[count++] =) (dec col))  ;; 1-based to 0-based

            (if (eos? s)
                (ร BREAK)
            )
            (if (!= (.at s 0) (byte \,))
                ((ร RETURN) e_invarg)
            )
            (if (== (.at ((ร s =) (.plus s 1)) 0) NUL)
                ((ร RETURN) e_invarg)    ;; illegal trailing comma as in "set cc=80,"
            )
        )

        (cond (zero? count)
        (do
            ((ร wp.w_p_cc_cols =) nil)
        )
        :else
        (do
            ((ร wp.w_p_cc_cols =) (ร new int[count + 1]))

            ;; sort the columns for faster usage on screen redraw inside win-line()
            (Arrays/sort color_cols, 0, count)

            ((ร int j =) 0)
            (dotimes [#_int i count]
                ;; skip duplicates
                (if (or (zero? j) (!= (... (:w_p_cc_cols wp) (dec j)) (... color_cols i)))
                    ((ร wp.w_p_cc_cols[j++] =) (... color_cols i))
                )
            )
            ((ร wp.w_p_cc_cols[j] =) -1)     ;; end marker
        ))

        nil    ;; no error
    ))

;; Set the value of a boolean option, and take care of side effects.
;; Returns null for success, or an error message for an error.

(defn- #_Bytes set-bool-option [#_int opt_idx, #_boolean* varp, #_boolean value]
    ;; opt_idx: index in vimoptions[] table
    ;; varp: pointer to the option variable
    ;; value: new value
    (ยง
        ((ร vimoption_C v =) (... vimoptions opt_idx))

        ((ร boolean old_value =) (... varp 0))
        ((ร varp[0] =) value)                    ;; set the new value

        ;; Handle side effects of changing a bool option.

        ;; when 'paste' is set or reset also change other options
        (cond (== varp p_paste)
        (do
            (paste-option-changed)
        )

        ;; when 'insertmode' is set from an autocommand need to do work here
        (== varp p_im)
        (do
            (cond @p_im
            (do
                (if (non-flag? @State INSERT)
                    (reset! need_start_insertmode true))
                (reset! stop_insert_mode false)
            )
            :else
            (do
                (reset! need_start_insertmode false)
                (reset! stop_insert_mode true)
                (if (and (non-zero? @restart_edit) @mode_displayed)
                    (reset! clear_cmdline true))   ;; remove "(insert)"
                (reset! restart_edit 0)
            ))
        )

        ;; when 'ignorecase' is set or reset and 'hlsearch' is set, redraw
        (and (== varp p_ic) @p_hls)
        (do
            (redraw-all-later SOME_VALID)
        )

        ;; when 'hlsearch' is set or reset: reset no_hlsearch
        (== varp p_hls)
        (do
            (reset! no_hlsearch false)
        )

        ;; when 'scrollbind' is set:
        ;; snapshot the current position to avoid a jump at the end of normal-cmd()
        (== varp (:wo_scb (:w_options @curwin)))
        (do
            (when @(:wo_scb (:w_options @curwin))
                (do-check-scrollbind false)
                ((ร @curwin.w_scbind_pos =) (:w_topline @curwin))
            )
        )

        ;; If 'wrap' is set, set w_leftcol to zero.
        (== varp (:wo_wrap (:w_options @curwin)))
        (do
            (if @(:wo_wrap (:w_options @curwin))
                ((ร @curwin.w_leftcol =) 0)
            )
        )

        (== varp p_ea)
        (do
            (if (and @p_ea (not old_value))
                (win-equal @curwin, false, 0))
        ))

        ;; End of handling side effects for bool options.

        (comp-col)                     ;; in case 'ruler' or 'showcmd' changed
        (if (and (!= (:w_curswant @curwin) MAXCOL) (flag? (:flags v) (| P_CURSWANT P_RALL)))
            ((ร @curwin.w_set_curswant =) true)
        )
        (check-redraw (:flags v))

        nil
    ))

;; Set the value of a number option, and take care of side effects.
;; Returns null for success, or an error message for an error.

(defn- #_Bytes set-num-option [#_int opt_idx, #_long* varp, #_long value, #_Bytes errbuf, #_int errbuflen]
    ;; opt_idx: index in vimoptions[] table
    ;; varp: pointer to the option variable
    ;; value: new value
    ;; errbuf: buffer for error messages
    ;; errbuflen: length of "errbuf"
    (ยง
        ((ร Bytes errmsg =) nil)
        ((ร long old_value =) (... varp 0))
        ((ร long old_Rows =) @Rows)               ;; remember old Rows
        ((ร long old_Cols =) @Cols)         ;; remember old Cols

        ((ร varp[0] =) value)

        (when (< @(:b_p_sw @curbuf) 0)
            ((ร errmsg =) e_positive)
            ((ร @curbuf.@b_p_sw =) @(:b_p_ts @curbuf))
        )

        ;; Number options that need some action when changed.

        (cond (== varp p_wh)
        (do
            (when (< @p_wh 1)
                ((ร errmsg =) e_positive)
                (reset! p_wh 1)
            )
            (when (< @p_wh @p_wmh)
                ((ร errmsg =) e_winheight)
                (reset! p_wh @p_wmh)
            )

            ;; Change window height NOW.
            (when (!= @lastwin @firstwin)
                (if (and (== varp p_wh) (< (:w_height @curwin) @p_wh))
                    (win-setheight (int @p_wh)))
            )
        )

        ;; 'winminheight'
        (== varp p_wmh)
        (do
            (when (< @p_wmh 0)
                ((ร errmsg =) e_positive)
                (reset! p_wmh 0)
            )
            (when (< @p_wh @p_wmh)
                ((ร errmsg =) e_winheight)
                (reset! p_wmh @p_wh)
            )
            (win-setminheight)
        )

        (== varp p_wiw)
        (do
            (when (< @p_wiw 1)
                ((ร errmsg =) e_positive)
                (reset! p_wiw 1)
            )
            (when (< @p_wiw @p_wmw)
                ((ร errmsg =) e_winwidth)
                (reset! p_wiw @p_wmw)
            )

            ;; Change window width NOW.
            (if (and (!= @lastwin @firstwin) (< (:w_width @curwin) @p_wiw))
                (win-setwidth (int @p_wiw)))
        )

        ;; 'winminwidth'
        (== varp p_wmw)
        (do
            (when (< @p_wmw 0)
                ((ร errmsg =) e_positive)
                (reset! p_wmw 0)
            )
            (when (< @p_wiw @p_wmw)
                ((ร errmsg =) e_winwidth)
                (reset! p_wmw @p_wiw)
            )
            (win-setminheight)
        )

        ;; (re)set last window status line
        (== varp p_ls)
        (do
            (last-status false)
        )

        ;; 'maxcombine'
        (== varp p_mco)
        (do
            (cond (< MAX_MCO @p_mco)
            (do
                (reset! p_mco MAX_MCO)
            )
            (< @p_mco 0)
            (do
                (reset! p_mco 0)
            ))
            (screenclear)      ;; will re-allocate the screen
        )

        ;; if "p_ch" changed value, change the command line height
        (== varp p_ch)
        (do
            (when (< @p_ch 1)
                ((ร errmsg =) e_positive)
                (reset! p_ch 1)
            )
            ((ร int min =) (min-rows))
            (if (> @p_ch (+ (- @Rows min) 1))
                (reset! p_ch (+ (- @Rows min) 1)))

            ;; Only compute the new window layout when startup has been completed,
            ;; otherwise the frame sizes may be wrong.
            (if (and (!= @p_ch old_value) @full_screen)
                (command-height))
        )

        (== varp (:wo_cole (:w_options @curwin)))
        (do
            (cond (< @(:wo_cole (:w_options @curwin)) 0)
            (do
                ((ร errmsg =) e_positive)
                ((ร @curwin.w_options.@wo_cole =) 0)
            )
            (< 3 @(:wo_cole (:w_options @curwin)))
            (do
                ((ร errmsg =) e_invarg)
                ((ร @curwin.w_options.@wo_cole =) 3)
            ))
        )

        ;; sync undo before 'undolevels' changes
        (== varp (:b_p_ul @curbuf))
        (do
            ;; use the old value, otherwise u-sync() may not work properly
            ((ร @curbuf.@b_p_ul =) old_value)
            (u-sync true)
            ((ร @curbuf.@b_p_ul =) value)
        )

        ;; 'numberwidth' must be positive
        (== varp (:wo_nuw (:w_options @curwin)))
        (do
            (when (< @(:wo_nuw (:w_options @curwin)) 1)
                ((ร errmsg =) e_positive)
                ((ร @curwin.w_options.@wo_nuw =) 1)
            )
            (when (< 10 @(:wo_nuw (:w_options @curwin)))
                ((ร errmsg =) e_invarg)
                ((ร @curwin.w_options.@wo_nuw =) 10)
            )
            ((ร @curwin.w_nrwidth_line_count =) 0)    ;; trigger a redraw
        ))

        ;; Check the bounds for numeric options here.

        (when @full_screen
            ((ร int min =) (min-rows))
            (when (< @Rows min)
                (when (non-nil? errbuf)
;%%                 (vim_snprintf errbuf, errbuflen, (u8 "E593: Need at least %d lines"), min)
                    ((ร errmsg =) errbuf)
                )
                (reset! Rows min)
            )
            (when (< (int @Cols) MIN_COLUMNS)
                (when (non-nil? errbuf)
;%%                 (vim_snprintf errbuf, errbuflen, (u8 "E594: Need at least %d columns"), MIN_COLUMNS)
                    ((ร errmsg =) errbuf)
                )
                (reset! Cols MIN_COLUMNS)
            )
        )
        (limit-screen-size)

        ;; If the screen (shell) height has been changed, assume it is the physical screenheight.

        (when (or (!= old_Rows @Rows) (!= old_Cols @Cols))
            ;; Changing the screen size is not allowed while updating the screen.
            (cond @updating_screen
            (do
                ((ร varp[0] =) old_value)
            )
            @full_screen
            (do
                (set-shellsize (int @Cols), (int @Rows), true)
            )
            :else
            (do
                ;; Postpone the resizing; check the size and cmdline position for messages.
                (check-shellsize)
                (if (and (> @cmdline_row (- @Rows @p_ch)) (< @p_ch @Rows))
                    (reset! cmdline_row (int (- @Rows @p_ch))))
            ))
        )

        (when (<= @(:b_p_ts @curbuf) 0)
            ((ร errmsg =) e_positive)
            ((ร @curbuf.@b_p_ts =) 8)
        )
        (when (< @p_tm 0)
            ((ร errmsg =) e_positive)
            (reset! p_tm 0)
        )
        (when (and (or (<= @(:wo_scr (:w_options @curwin)) 0) (and (< (:w_height @curwin) @(:wo_scr (:w_options @curwin))) (< 0 (:w_height @curwin)))) @full_screen)
            (cond (== varp (:wo_scr (:w_options @curwin)))
            (do
                (if (!= @(:wo_scr (:w_options @curwin)) 0)
                    ((ร errmsg =) e_scroll)
                )
                (win-comp-scroll @curwin)
            )
            ;; If 'scroll' became invalid because of a side effect silently adjust it.
            (<= @(:wo_scr (:w_options @curwin)) 0)
            (do
                ((ร @curwin.w_options.@wo_scr =) 1)
            )
            :else ;; @curwin.w_options.@wo_scr > @curwin.w_height
            (do
                ((ร @curwin.w_options.@wo_scr =) (:w_height @curwin))
            ))
        )
        (cond (< @p_hi 0)
        (do
            ((ร errmsg =) e_positive)
            (reset! p_hi 0)
        )
        (< 10000 @p_hi)
        (do
            ((ร errmsg =) e_invarg)
            (reset! p_hi 10000)
        ))
        (when (or (< @p_re 0) (< 2 @p_re))
            ((ร errmsg =) e_invarg)
            (reset! p_re 0)
        )
        (when (< @p_report 0)
            ((ร errmsg =) e_positive)
            (reset! p_report 1)
        )
        (when (and (or (< @p_sj -100) (<= @Rows @p_sj)) @full_screen)
            (cond (!= @Rows old_Rows)   ;; Rows changed, just adjust "p_sj"
            (do
                (reset! p_sj (/ @Rows 2))
            )
            :else
            (do
                ((ร errmsg =) e_scroll)
                (reset! p_sj 1)
            ))
        )
        (when (and (< @p_so 0) @full_screen)
            ((ร errmsg =) e_scroll)
            (reset! p_so 0)
        )
        (when (and (< @p_siso 0) @full_screen)
            ((ร errmsg =) e_positive)
            (reset! p_siso 0)
        )
        (when (< @p_cwh 1)
            ((ร errmsg =) e_positive)
            (reset! p_cwh 1)
        )
        (when (< @p_ut 0)
            ((ร errmsg =) e_positive)
            (reset! p_ut 2000)
        )
        (when (< @p_ss 0)
            ((ร errmsg =) e_positive)
            (reset! p_ss 0)
        )

        ((ร vimoption_C v =) (... vimoptions opt_idx))

        (comp-col)                     ;; in case 'columns' or 'ls' changed
        (if (and (!= (:w_curswant @curwin) MAXCOL) (flag? (:flags v) (| P_CURSWANT P_RALL)))
            ((ร @curwin.w_set_curswant =) true)
        )
        (check-redraw (:flags v))

        errmsg
    ))

;; Called after an option changed: check if something needs to be redrawn.

(defn- #_void check-redraw [#_long flags]
    ;; Careful: P_RCLR and P_RALL are a combination of other P_ flags.
    (let [#_boolean doclear (== (& flags P_RCLR) P_RCLR)
          #_boolean all (or (== (& flags P_RALL) P_RALL) doclear)]

        (if (or (flag? flags P_RSTAT) all)      ;; mark all status lines dirty
            (status-redraw-all))
        (if (or (flag? flags P_RBUF) (flag? flags P_RWIN) all)
            (changed-window-setting))
        (if (flag? flags P_RBUF)
            (redraw-curbuf-later NOT_VALID))
        (cond
            doclear (redraw-all-later CLEAR)
            all (redraw-all-later NOT_VALID)
        )
        nil
    ))

;; Find index for option 'arg'.
;; Return -1 if not found.

(defn- #_int findoption [#_Bytes arg]
    (ยง
        (if (<= (byte \a) (.at arg 0) (byte \z))

            (dotimes [#_int opt_idx (:length vimoptions)]
                ((ร Bytes s =) (:fullname (... vimoptions opt_idx)))
                (if (zero? (STRCMP arg, s))                             ;; match full name
                    ((ร RETURN) opt_idx)
                )
            )

            (dotimes [#_int opt_idx (:length vimoptions)]
                ((ร Bytes s =) (:shortname (... vimoptions opt_idx)))
                (if (and (non-nil? s) (zero? (STRCMP arg, s)))          ;; match short name
                    ((ร RETURN) opt_idx)
                )
            )
        )
        -1
    ))

(defn- #_Bytes get-highlight-default []
    (ยง
        ((ร int i =) (findoption (u8 "hl")))
        (if (< i 0)
            ((ร RETURN) nil)
        )

        (ร (Bytes)vimoptions[i].def_val)
    ))

;; showoneopt: show the value of one option

(defn- #_void showoneopt [#_vimoption_C v]
    (ยง
        (reset! info_message true)

        ((ร Object varp =) (get-varp v))

        (if (and (flag? (:flags v) P_BOOL) (not (boolean @varp)))
            (msg-puts (u8 "no"))
            (msg-puts (u8 "  ")))

        (msg-puts (:fullname v))

        (when (non-flag? (:flags v) P_BOOL)
            (msg-putchar (byte \=))

            (cond (flag? (:flags v) P_NUM)
            (do
                (.sprintf libC @nameBuff, (u8 "%ld"), (long @varp))
            )
            (flag? (:flags v) P_STRING)
            (do
                (if (nil? @varp)              ;; just in case
                    (eos! @nameBuff)
                    (vim-strncpy @nameBuff, (ร (Bytes)@varp), (dec MAXPATHL)))
            ))

            (msg-outtrans @nameBuff)
        )

        (reset! info_message false)
        nil
    ))

;; Compute columns for ruler and shown command. 'sc_col' is also used to
;; decide what the maximum length of a message on the status line can be.
;; If there is a status line for the last window, 'sc_col' is independent
;; of 'ru_col'.

(final int COL_RULER 17)        ;; columns needed by standard ruler

(defn- #_void comp-col []
    (ยง
        ((ร boolean last_has_status =) (or (== @p_ls 2) (and (== @p_ls 1) (!= @firstwin @lastwin))))

        (reset! sc_col 0)
        (reset! ru_col 0)
        (when @p_ru
            (reset! ru_col (inc (if (non-zero? @ru_wid) @ru_wid COL_RULER)))
            ;; no last status line, adjust sc_col
            (if (not last_has_status)
                (reset! sc_col @ru_col))
        )
        (when @p_sc
            ((ร @sc_col =) (+ @sc_col SHOWCMD_COLS))
            (if (or (not @p_ru) last_has_status)       ;; no need for separating space
                (swap! sc_col inc))
        )
        (reset! sc_col (- (int @Cols) @sc_col))
        (reset! ru_col (- (int @Cols) @ru_col))
        (if (<= @sc_col 0)            ;; screen too narrow, will become a mess
            (reset! sc_col 1))
        (when (<= @ru_col 0)
            (reset! ru_col 1)
        )
        nil
    ))

;; Get pointer to option variable.

(defn- #_Object get-varp [#_vimoption_C v]
    (ยง
        ((ร SWITCH) (:indir v)
            ((ร CASE) PV_BRI)
            (do
                ((ร RETURN) (:wo_bri (:w_options @curwin)))
            )
            ((ร CASE) PV_BRIOPT)
            (do
                ((ร RETURN) (:wo_briopt (:w_options @curwin)))
            )
            ((ร CASE) PV_CC)
            (do
                ((ร RETURN) (:wo_cc (:w_options @curwin)))
            )
            ((ร CASE) PV_COCU)
            (do
                ((ร RETURN) (:wo_cocu (:w_options @curwin)))
            )
            ((ร CASE) PV_COLE)
            (do
                ((ร RETURN) (:wo_cole (:w_options @curwin)))
            )
            ((ร CASE) PV_CRBIND)
            (do
                ((ร RETURN) (:wo_crb (:w_options @curwin)))
            )
            ((ร CASE) PV_CUC)
            (do
                ((ร RETURN) (:wo_cuc (:w_options @curwin)))
            )
            ((ร CASE) PV_CUL)
            (do
                ((ร RETURN) (:wo_cul (:w_options @curwin)))
            )
            ((ร CASE) PV_LBR)
            (do
                ((ร RETURN) (:wo_lbr (:w_options @curwin)))
            )
            ((ร CASE) PV_NU)
            (do
                ((ร RETURN) (:wo_nu (:w_options @curwin)))
            )
            ((ร CASE) PV_NUW)
            (do
                ((ร RETURN) (:wo_nuw (:w_options @curwin)))
            )
            ((ร CASE) PV_RNU)
            (do
                ((ร RETURN) (:wo_rnu (:w_options @curwin)))
            )
            ((ร CASE) PV_SCBIND)
            (do
                ((ร RETURN) (:wo_scb (:w_options @curwin)))
            )
            ((ร CASE) PV_SCROLL)
            (do
                ((ร RETURN) (:wo_scr (:w_options @curwin)))
            )
            ((ร CASE) PV_WFH)
            (do
                ((ร RETURN) (:wo_wfh (:w_options @curwin)))
            )
            ((ร CASE) PV_WFW)
            (do
                ((ร RETURN) (:wo_wfw (:w_options @curwin)))
            )
            ((ร CASE) PV_WRAP)
            (do
                ((ร RETURN) (:wo_wrap (:w_options @curwin)))
            )

            ((ร CASE) PV_AI)
            (do
                ((ร RETURN) (:b_p_ai @curbuf))
            )
            ((ร CASE) PV_CI)
            (do
                ((ร RETURN) (:b_p_ci @curbuf))
            )
            ((ร CASE) PV_CINW)
            (do
                ((ร RETURN) (:b_p_cinw @curbuf))
            )
            ((ร CASE) PV_ET)
            (do
                ((ร RETURN) (:b_p_et @curbuf))
            )
            ((ร CASE) PV_ISK)
            (do
                ((ร RETURN) (:b_p_isk @curbuf))
            )
            ((ร CASE) PV_KP)
            (do
                ((ร RETURN) (:b_p_kp @curbuf))
            )
            ((ร CASE) PV_MOD)
            (do
                ((ร RETURN) (:b_changed @curbuf))
            )
            ((ร CASE) PV_MPS)
            (do
                ((ร RETURN) (:b_p_mps @curbuf))
            )
            ((ร CASE) PV_NF)
            (do
                ((ร RETURN) (:b_p_nf @curbuf))
            )
            ((ร CASE) PV_PI)
            (do
                ((ร RETURN) (:b_p_pi @curbuf))
            )
            ((ร CASE) PV_QE)
            (do
                ((ร RETURN) (:b_p_qe @curbuf))
            )
            ((ร CASE) PV_SI)
            (do
                ((ร RETURN) (:b_p_si @curbuf))
            )
            ((ร CASE) PV_STS)
            (do
                ((ร RETURN) (:b_p_sts @curbuf))
            )
            ((ร CASE) PV_SW)
            (do
                ((ร RETURN) (:b_p_sw @curbuf))
            )
            ((ร CASE) PV_TS)
            (do
                ((ร RETURN) (:b_p_ts @curbuf))
            )
            ((ร CASE) PV_UL)
            (do
                ((ร RETURN) (:b_p_ul @curbuf))
            )
        )

        (:var v)
    ))

;; Copy options from one window to another.
;; Used when splitting a window.

(defn- #_void win-copy-options [#_window_C wp_from, #_window_C wp_to]
    (copy-winopt (:w_options wp_from), (:w_options wp_to))
    (briopt-check wp_to)
    nil)

;; Copy the options from one winopt_C to another.
;; Doesn't free the old option values in "to", use clear-winopt() for that.
;; The 'scroll' option is not copied, because it depends on the window height.
;; The 'previewwindow' option is reset, there can be only one preview window.

(defn- #_void copy-winopt [#_winopt_C from, #_winopt_C to]
    (ยง
        ((ร to.@wo_nu =) @(:wo_nu from))
        ((ร to.@wo_rnu =) @(:wo_rnu from))
        ((ร to.@wo_nuw =) @(:wo_nuw from))
        ((ร to.@wo_wrap =) @(:wo_wrap from))
        ((ร to.@wo_lbr =) @(:wo_lbr from))
        ((ร to.@wo_bri =) @(:wo_bri from))
        ((ร to.@wo_briopt =) (STRDUP @(:wo_briopt from)))
        ((ร to.@wo_scb =) @(:wo_scb from))
        ((ร to.@wo_crb =) @(:wo_crb from))
        ((ร to.@wo_cuc =) @(:wo_cuc from))
        ((ร to.@wo_cul =) @(:wo_cul from))
        ((ร to.@wo_cc =) (STRDUP @(:wo_cc from)))
        ((ร to.@wo_cocu =) (STRDUP @(:wo_cocu from)))
        ((ร to.@wo_cole =) @(:wo_cole from))

        (check-winopt to)           ;; don't want null pointers
        nil
    ))

;; Check string options in a window for a null value.

(defn- #_void check-win-options [#_window_C win]
    (check-winopt (:w_options win))
    nil)

;; Check for null pointers in a winopt_C and replace them with EMPTY_OPTION.

(defn- #_void check-winopt [#_winopt_C wop]
    (check-string-option (:wo_briopt wop))
    (check-string-option (:wo_cc wop))
    (check-string-option (:wo_cocu wop))
    nil)

;; Free the allocated memory inside a winopt_C.

(defn- #_void clear-winopt [#_winopt_C wop]
    (clear-string-option (:wo_briopt wop))
    (clear-string-option (:wo_cc wop))
    (clear-string-option (:wo_cocu wop))
    nil)

(atom! boolean old_p_paste)
(atom! boolean save_sm)
(atom! boolean save_ru)

;; paste-option-changed() - Called after "p_paste" was set or reset.

(defn- #_void paste-option-changed []
    (ยง
        (cond @p_paste
        (do
            ;; Paste switched from off to on.
            ;; Save the current values, so they can be restored later.

            (when (not @old_p_paste)
                ;; save options
                ((ร buffer_C buf =) @curbuf)
;               {
                    ((ร buf.b_p_sts_nopaste =) @(:b_p_sts buf))
                    ((ร buf.b_p_ai_nopaste =) @(:b_p_ai buf))
;               }

                ;; save global options
                (reset! save_sm @p_sm)
                (reset! save_ru @p_ru)
            )

            ;; Always set the option values, also when 'paste' is set when it is already on.

            ;; set options
            ((ร buffer_C buf =) @curbuf)
;           {
                ((ร buf.@b_p_sts =) 0)        ;; softtabstop is 0
                ((ร buf.@b_p_ai =) false)         ;; no auto-indent
;           }

            ;; set global options
            (reset! p_sm false)                   ;; no showmatch
            (if @p_ru
                (status-redraw-all))    ;; redraw to remove the ruler
            (reset! p_ru false)                   ;; no ruler
        )

        ;; Paste switched from on to off: Restore saved values.

        @old_p_paste
        (do
            ;; restore options
            ((ร buffer_C buf =) @curbuf)
;           {
                ((ร buf.@b_p_sts =) (:b_p_sts_nopaste buf))
                ((ร buf.@b_p_ai =) (:b_p_ai_nopaste buf))
;           }

            ;; restore global options
            (reset! p_sm @save_sm)
            (if (!= @p_ru @save_ru)
                (status-redraw-all))    ;; redraw to draw the ruler
            (reset! p_ru @save_ru)
        ))

        (reset! old_p_paste @p_paste)
        nil
    ))

;; fill-breakat-flags() -- called when 'breakat' changes value.

(defn- #_void fill-breakat-flags []
    (ยง
        (dotimes [#_int i 256]
            ((ร @breakat_flags[i] =) false)
        )

        (when (non-nil? @p_breakat)
            ((ร FOR) (ร ((ร Bytes p =) @p_breakat) (non-eos? p) ((ร p =) (.plus p 1)))
                ((ร @breakat_flags[char_u(p.at(0))] =) true)
            )
        )
        nil
    ))

;; Check an option that can be a range of string values.
;;
;; Return true for correct value, false otherwise.
;; Empty is always OK.

(defn- #_boolean check-opt-strings [#_Bytes val, #_Bytes* values, #_boolean list]
    ;; list: when true: accept a list of values
    (opt-strings-flags val, values, nil, list))

;; Handle an option that can be a range of string values.
;; Set a flag in "*flagp" for each string present.
;;
;; Return true for correct value, false otherwise.
;; Empty is always OK.

(defn- #_boolean opt-strings-flags [#_Bytes val, #_Bytes* values, #_int* flagp, #_boolean list]
    ;; val: new value
    ;; values: array of valid string values
    ;; list: when true: accept a list of values
    (ยง
        ((ร int new_flags =) 0)

        (while (non-eos? val)
            ((ร FOR) (ร ((ร int i =) 0) true (ร i++))
                (if (nil? (... values i))      ;; "val" not found in values[]
                    ((ร RETURN) false)
                )

                ((ร int len =) (STRLEN (... values i)))
                (when (and (zero? (STRNCMP (... values i), val, len)) (or (and list (== (.at val len) (byte \,))) (eos? val len)))
                    ((ร val =) (.plus val (+ len (if (== (.at val len) (byte \,)) 1 0))))
                    ((ร new_flags =) (| new_flags (<< 1 i)))
                    (ร BREAK)                  ;; check next item in "val" list
                )
            )
        )
        (if (non-nil? flagp)
            ((ร flagp[0] =) new_flags)
        )

        true
    ))

;; Check if backspacing over something is allowed.

(defn- #_boolean can-bs [#_int what]
    ;; what: BS_INDENT, BS_EOL or BS_START
    (non-nil? (vim-strchr @p_bs, what)))

;; Return the effective shiftwidth value for current buffer,
;; using the 'tabstop' value when 'shiftwidth' is zero.

(defn- #_long get-sw-value [#_buffer_C buf]
    (let [sw @(:b_p_sw buf)]
        (if (non-zero? sw) sw @(:b_p_ts buf))
    ))

;; Return the effective softtabstop value for the current buffer,
;; using the 'tabstop' value when 'softtabstop' is negative.

(defn- #_long get-sts-value []
    (let [sts @(:b_p_sts @curbuf)]
        (if (< sts 0) (get-sw-value @curbuf) sts)
    ))

;; Check matchpairs option for "*initc".
;; If there is a match set "*initc" to the matching character and "*findc" to the opposite.
;; Set "*backwards" to the direction.
;; When "switchit" is true, swap the direction.

(defn- #_void find-mps-values [#_int* initc, #_int* findc, #_boolean* backwards, #_boolean switchit]
    (ยง
        ((ร Bytes ptr =) @(:b_p_mps @curbuf))
        (while (non-eos? ptr)
            (ร Bytes prev)

            (when (== (us-ptr2char ptr) (... initc 0))
                (cond switchit
                (do
                    ((ร findc[0] =) (... initc 0))
                    ((ร initc[0] =) (us-ptr2char (.plus ptr (+ (us-ptr2len-cc ptr) 1))))
                    ((ร backwards[0] =) true)
                )
                :else
                (do
                    ((ร findc[0] =) (us-ptr2char (.plus ptr (+ (us-ptr2len-cc ptr) 1))))
                    ((ร backwards[0] =) false)
                ))
                ((ร RETURN) nil)
            )
            ((ร prev =) ptr)
            ((ร ptr =) (.plus ptr (+ (us-ptr2len-cc ptr) 1)))
            (when (== (us-ptr2char ptr) (... initc 0))
                (cond switchit
                (do
                    ((ร findc[0] =) (... initc 0))
                    ((ร initc[0] =) (us-ptr2char prev))
                    ((ร backwards[0] =) false)
                )
                :else
                (do
                    ((ร findc[0] =) (us-ptr2char prev))
                    ((ร backwards[0] =) true)
                ))
                ((ร RETURN) nil)
            )
            ((ร ptr =) (.plus ptr (us-ptr2len-cc ptr)))

            (if (== (.at ptr 0) (byte \,))
                ((ร ptr =) (.plus ptr 1))
            )
        )
        nil
    ))

;; This is called when 'breakindentopt' is changed and when a window is initialized.

(defn- #_boolean briopt-check [#_window_C wp]
    (ยง
        ((ร int bri_shift =) 0)
        ((ร int bri_min =) 20)
        ((ร boolean bri_sbr =) false)

        ((ร Bytes p =) @(:wo_briopt (:w_options wp)))
        (while (non-eos? p)
            (cond (and (zero? (STRNCMP p, (u8 "shift:"), 6)) (or (and (== (.at p 6) (byte \-)) (asc-isdigit (.at p 7))) (asc-isdigit (.at p 6))))
            (do
                ((ร p =) (.plus p 6))
;               { Bytes[] __ = { p }; bri_shift = (int)getdigits(__); p = __[0]; }
            )
            (and (zero? (STRNCMP p, (u8 "min:"), 4)) (asc-isdigit (.at p 4)))
            (do
                ((ร p =) (.plus p 4))
;               { Bytes[] __ = { p }; bri_min = (int)getdigits(__); p = __[0]; }
            )
            (zero? (STRNCMP p, (u8 "sbr"), 3))
            (do
                ((ร p =) (.plus p 3))
                ((ร bri_sbr =) true)
            ))
            (if (and (!= (.at p 0) (byte \,)) (non-eos? p))
                ((ร RETURN) false)
            )
            (if (== (.at p 0) (byte \,))
                ((ร p =) (.plus p 1))
            )
        )

        ((ร wp.w_p_brishift =) bri_shift)
        ((ร wp.w_p_brimin =) bri_min)
        ((ร wp.w_p_brisbr =) bri_sbr)

        true
    ))

;; ex_cmds.c: some functions for command line commands --------------------------------------------

;; ":ascii" and "ga".

(defn- #_void do-ascii []
    (ยง
        ((ร int[] cc =) (ร new int[MAX_MCO]))

        ((ร int c =) (us-ptr2char-cc (ml-get-cursor), cc))
        (when (== c NUL)
            (msg (u8 "NUL"))
            ((ร RETURN) nil)
        )

        ((ร int ci =) 0)

        (eos! @ioBuff)
        (when (< c 0x80)
            (if (== c NL)        ;; NUL is stored as NL
                ((ร c =) NUL)
            )

            ((ร int cval =) c)

            ((ร Bytes buf1 =) (Bytes. 20))
            (cond (and (vim-isprintc c) (or (< c (byte \space)) (< (byte \~) c)))
            (do
                ((ร Bytes buf3 =) (Bytes. 7))
                (transchar-nonprint buf3, c)
;%%             (vim_snprintf buf1, (.size buf1), (u8 "  <%s>"), buf3)
            )
            :else
            (do
                (eos! buf1)
            ))

            ((ร Bytes buf2 =) (Bytes. 20))
            (if (<= 0x80 c)
;%%             (vim_snprintf buf2, (.size buf2), (u8 "  <M-%s>"), (transchar (& c 0x7f)))
                (eos! buf2)
            )

;%%         (vim_snprintf @ioBuff, IOSIZE, (u8 "<%s>%s%s  %d,  Hex %02x,  Octal %03o"), (transchar c), buf1, buf2, cval, cval, cval)
            ((ร c =) (... cc (ร ci++)))
        )

        ;; Repeat for combining characters.
        (while (or (<= 0x100 c) (<= 0x80 c))
            ((ร int len =) (STRLEN @ioBuff))
            ;; This assumes every multi-byte char is printable...
            (if (< 0 len)
                (.be @ioBuff (ร len++), (byte \space))
            )
            (.be @ioBuff (ร len++), (byte \<))
            (if (utf-iscomposing c)
                (.be @ioBuff (ร len++), (byte \space))                ;; draw composing char on top of a space
            )
            ((ร len =) (+ len (utf-char2bytes c, (.plus @ioBuff len))))
;%%         (vim_snprintf (.plus @ioBuff len), (- IOSIZE len), (if (< c 0x10000) (u8 "> %d, Hex %04x, Octal %o") (u8 "> %d, Hex %08x, Octal %o")), c, c, c)
            (if (== ci MAX_MCO)
                (ร BREAK)
            )
            ((ร c =) (... cc (ร ci++)))
        )

        (msg @ioBuff)
        nil
    ))

;; Get the length of the current line, excluding trailing white space.

(defn- #_int linelen [#_boolean* has_tab]
    (ยง
        ;; find the first non-blank character
        ((ร Bytes line =) (ml-get-curline))
        ((ร Bytes first =) (skipwhite line))

        ;; find the character after the last non-blank character
        (ร Bytes last)
        ((ร FOR) (ร ((ร last =) (.plus first (STRLEN first))) (and (BLT first, last) (vim-iswhite (.at last -1))) ((ร last =) (.minus last 1)))
            ;
        )

        ((ร byte save =) (.at last 0))
        (eos! last)
        ((ร int len =) (linetabsize line))        ;; get line length
        (if (non-nil? has_tab)                ;; check for embedded TAB
            ((ร has_tab[0] =) (non-nil? (vim-strrchr first, TAB)))
        )
        (.be last 0, save)

        len
    ))

;; ":retab".

(defn- #_void ex-retab [#_exarg_C eap]
    (ยง
        ((ร boolean got_tab =) false)
        ((ร int num_spaces =) 0)
        ((ร int start_col =) 0)                          ;; for start of white-space string
        ((ร int start_vcol =) 0)                         ;; for start of white-space string
        ((ร long first_line =) 0)                        ;; first changed line
        ((ร long last_line =) 0)                         ;; last changed line

        (ร int new_ts)
;       { Bytes[] __ = { eap.arg }; new_ts = (int)getdigits(__); eap.arg = __[0]; }
        (when (< new_ts 0)
            (emsg e_positive)
            ((ร RETURN) nil)
        )
        (if (zero? new_ts)
            ((ร new_ts =) (int @(:b_p_ts @curbuf)))
        )

;       loop:
        ((ร FOR) (ร ((ร long lnum =) (:line1 eap)) (and (not @got_int) (<= lnum (:line2 eap))) (ร lnum++))
            ((ร Bytes ptr =) (ml-get lnum))
            ((ร int col =) 0)
            ((ร int vcol =) 0)
            ((ร boolean did_undo =) false)           ;; called u-save() for current line
            (while true
                (cond (vim-iswhite (.at ptr col))
                (do
                    (when (and (not got_tab) (zero? num_spaces))
                        ;; First consecutive white-space.
                        ((ร start_vcol =) vcol)
                        ((ร start_col =) col)
                    )
                    (if (== (.at ptr col) (byte \space))
                        (ร num_spaces++)
                        ((ร got_tab =) true)
                    )
                )
                :else
                (do
                    (when (or got_tab (and (:forceit eap) (< 1 num_spaces)))
                        ;; Retabulate this string of white-space.

                        ;; len is virtual length of white string
                        ((ร int len =) ((ร num_spaces =) (- vcol start_vcol)))
                        ((ร int num_tabs =) 0)
                        (when (not @(:b_p_et @curbuf))
                            ((ร int temp =) (- new_ts (% start_vcol new_ts)))
                            (when (<= temp num_spaces)
                                ((ร num_spaces =) (- num_spaces temp))
                                (ร num_tabs++)
                            )
                            ((ร num_tabs =) (+ num_tabs (/ num_spaces new_ts)))
                            ((ร num_spaces =) (- num_spaces (* (/ num_spaces new_ts) new_ts)))
                        )
                        (when (or @(:b_p_et @curbuf) got_tab (< (+ num_spaces num_tabs) len))
                            (when (not did_undo)
                                ((ร did_undo =) true)
                                (if (not (u-save (dec lnum), (inc lnum)))
                                    (ร BREAK loop)        ;; out-of-memory ???
                                )
                            )

                            ;; len is actual number of white characters used
                            ((ร len =) (+ num_spaces num_tabs))
                            ((ร int old_len =) (STRLEN ptr))
                            ((ร Bytes new_line =) (Bytes. (+ (- old_len col) start_col len 1)))

                            (if (< 0 start_col)
                                (BCOPY new_line, ptr, start_col))
                            (BCOPY new_line, (+ start_col len), ptr, col, (+ (- old_len col) 1))
                            ((ร ptr =) (.plus new_line start_col))
                            ((ร FOR) (ร ((ร col =) 0) (< col len) (ร col++))
                                (.be ptr col, (if (< col num_tabs) TAB (byte \space)))
                            )
                            (ml-replace lnum, new_line)
                            (if (zero? first_line)
                                ((ร first_line =) lnum)
                            )
                            ((ร last_line =) lnum)
                            ((ร ptr =) new_line)
                            ((ร col =) (+ start_col len))
                        )
                    )
                    ((ร got_tab =) false)
                    ((ร num_spaces =) 0)
                ))
                (if (eos? ptr col)
                    (ร BREAK)
                )
                ((ร vcol =) (+ vcol (chartabsize (.plus ptr col), vcol)))
                ((ร col =) (+ col (us-ptr2len-cc (.plus ptr col))))
            )
            (line-breakcheck)
        )
        (if @got_int
            (emsg e_interr))

        (if (!= @(:b_p_ts @curbuf) new_ts)
            (redraw-curbuf-later NOT_VALID))
        (if (non-zero? first_line)
            (changed-lines first_line, 0, (inc last_line), 0))

        ((ร @curbuf.@b_p_ts =) new_ts)
        (coladvance (:w_curswant @curwin))

        (u-clearline)
        nil
    ))

;; Implementation of ":fixdel", also used by get-stty().
;;  <BS>    resulting <Del>
;;   ^?         ^H
;; not ^?       ^?

(defn- #_void ex-fixdel [#_exarg_C _eap]
    (let [#_Bytes p (find-termcode (u8 "kb"))]
        (add-termcode (u8 "kD"), (if (and (non-nil? p) (== (.at p 0) DEL)) CTRL_H_STR DEL_STR))
        nil
    ))

(atom! Bytes old_sub)              ;; previous substitute pattern

(atom! boolean do__all)                 ;; do multiple substitutions per line
(atom! boolean do__count)               ;; count only
(atom! boolean do__error true)        ;; if false, ignore errors
(atom! int do__ic)                      ;; ignore case flag

;; Perform a substitution from line eap.line1 to line eap.line2 using
;; the command pointed to by eap.arg which should be of the form:
;;
;; /pattern/substitution/{flags}
;;
;; The usual escapes are supported as described in the regexp docs.

(defn- #_void ex-sub [#_exarg_C eap]
    (ยง
        ((ร long i =) 0)

        ((ร Bytes pat =) (ร nil, sub = nil))
        ((ร boolean got_quit =) false)
        ((ร boolean got_match =) false)
        ((ร long first_line =) 0)                        ;; first changed line
        ((ร long last_line =) 0)                          ;; below last changed line AFTER the change
        ((ร long old_line_count =) (:ml_line_count (:b_ml @curbuf)))
        ((ร boolean endcolumn =) false)                  ;; cursor in last column when done
        ((ร pos_C old_cursor =) (NEW_pos_C))
        (COPY-pos old_cursor, (:w_cursor @curwin))

        ((ร Bytes cmd =) (:arg eap))

        (reset! sub_nsubs 0)
        (reset! sub_nlines 0)

        ((ร long start_nsubs =) @sub_nsubs)

        ((ร int which_pat =) (if (== (:cmdidx eap) (ร CMD_tilde))
            RE_LAST            ;; use last used regexp
            RE_SUBST           ;; use last substitute regexp
        ))

                                                ;; new pattern and substitution
        (cond (and (== (.at (:cmd eap) 0) (byte \s)) (non-eos? cmd) (not (vim-iswhite (.at cmd 0))) (nil? (vim-strbyte (u8 "0123456789cegriIp|\""), (.at cmd 0))))
        (do
            (when (asc-isalpha (.at cmd 0))         ;; don't accept alphanumeric for separator
                (emsg (u8 "E146: Regular expressions can't be delimited by letters"))
                ((ร RETURN) nil)
            )

            (ร byte delimiter)

            ;; undocumented vi feature:
            ;;  "\/sub/" and "\?sub?" use last used search pattern (almost like //sub/r).
            ;; "\&sub&" use last substitute pattern (like //sub/).

            (cond (== (.at cmd 0) (byte \\))
            (do
                ((ร cmd =) (.plus cmd 1))
                (when (nil? (vim-strbyte (u8 "/?&"), (.at cmd 0)))
                    (emsg e_backslash)
                    ((ร RETURN) nil)
                )
                (if (!= (.at cmd 0) (byte \&))
                    ((ร which_pat =) RE_SEARCH)      ;; use last '/' pattern
                )
                ((ร pat =) (u8 ""))                       ;; empty search pattern
                ((ร delimiter =) (.at ((ร cmd =) (.plus cmd 1)) -1))             ;; remember delimiter character
            )
            :else            ;; find the end of the regexp
            (do
                ((ร which_pat =) RE_LAST)            ;; use last used regexp
                ((ร delimiter =) (.at ((ร cmd =) (.plus cmd 1)) -1))             ;; remember delimiter character
                ((ร pat =) cmd)                      ;; remember start of search pattern
;               { Bytes[] __ = { eap.arg }; cmd = skip-regexp(cmd, delimiter, @p_magic, __); eap.arg = __[0]; }
                (if (== (.at cmd 0) delimiter)        ;; end delimiter found
                    (.be ((ร cmd =) (.plus cmd 1)) -1, NUL)               ;; replace it with a NUL
                )
            ))

            ;; Small incompatibility: vi sees '\n' as end of the command, but in
            ;; Vim we want to use '\n' to find/substitute a NUL.

            ((ร sub =) cmd)          ;; remember the start of the substitution

            (while (non-eos? cmd)
                (when (== (.at cmd 0) delimiter)            ;; end delimiter found
                    (.be ((ร cmd =) (.plus cmd 1)) -1, NUL)                   ;; replace it with a NUL
                    (ร BREAK)
                )
                (if (and (== (.at cmd 0) (byte \\)) (non-eos? cmd 1))  ;; skip escaped characters
                    ((ร cmd =) (.plus cmd 1))
                )
                ((ร cmd =) (.plus cmd (us-ptr2len-cc cmd)))
            )

            (when (not (:skip eap))
                ;; In POSIX vi ":s/pat/%/" uses the previous subst. string.
                (cond (and (zero? (STRCMP sub, (u8 "%"))) (non-nil? (vim-strbyte @p_cpo, CPO_SUBPERCENT)))
                (do
                    (when (nil? @old_sub)    ;; there is no previous command
                        (emsg e_nopresub)
                        ((ร RETURN) nil)
                    )
                    ((ร sub =) @old_sub)
                )
                :else
                (do
                    (reset! old_sub (STRDUP sub))
                ))
            )
        )
        (not (:skip eap))         ;; use previous pattern and substitution
        (do
            (when (nil? @old_sub)    ;; there is no previous command
                (emsg e_nopresub)
                ((ร RETURN) nil)
            )
            ((ร pat =) nil)             ;; search-regcomp() will use previous pattern
            ((ร sub =) @old_sub)

            ;; Vi compatibility quirk:
            ;; repeating with ":s" keeps the cursor in the last column after using "$".
            ((ร endcolumn =) (== (:w_curswant @curwin) MAXCOL))
        ))

        ;; Recognize ":%s/\n//" and turn it into a join command, which is much more efficient.
        ;; TODO: find a generic solution to make line-joining operations more
        ;; efficient, avoid allocating a string that grows in size.

        (when (and (non-nil? pat) (zero? (STRCMP pat, (u8 "\\n"))) (eos? sub) (or (eos? cmd) (and (eos? cmd 1) (== (.at cmd 0) (byte \g)))))
            ((ร @curwin.w_cursor.lnum =) (:line1 eap))

            ;; The number of lines joined is the number of lines in the range plus one.
            ;; One less when the last line is included.
            ((ร int joined_lines_count =) (int (+ (- (:line2 eap) (:line1 eap)) 1)))
            (if (< (:line2 eap) (:ml_line_count (:b_ml @curbuf)))
                (ร joined_lines_count++)
            )
            (when (< 1 joined_lines_count)
                (do-join joined_lines_count, false, true, false, true)
                (reset! sub_nsubs (dec joined_lines_count))
                (reset! sub_nlines 1)
                (do-sub-msg false)
            )

            (save-re-pat RE_SUBST, pat, @p_magic)
            ;; put pattern in history
            (add-to-history HIST_SEARCH, pat, NUL)

            ((ร RETURN) nil)
        )

        ;; Find trailing options.  When '&' is used, keep old options.

        (cond (== (.at cmd 0) (byte \&))
        (do
            ((ร cmd =) (.plus cmd 1))
        )
        :else
        (do
            (reset! do__all @p_gd)         ;; default is global on
            (reset! do__error true)
            (reset! do__count false)
            (reset! do__ic 0)
        ))
        (while (non-eos? cmd)
            ;; Note that 'g' and 'c' are always inverted.
            ;; 'r' is never inverted.

            (cond (== (.at cmd 0) (byte \g))
            (do
                (reset! do__all (not @do__all))
            )
            (== (.at cmd 0) (byte \n))
            (do
                (reset! do__count true)
            )
            (== (.at cmd 0) (byte \e))
            (do
                (reset! do__error (not @do__error))
            )
            (== (.at cmd 0) (byte \r))       ;; use last used regexp
            (do
                ((ร which_pat =) RE_LAST)
            )
            (== (.at cmd 0) (byte \i))       ;; ignore case
            (do
                (reset! do__ic (byte \i))
            )
            (== (.at cmd 0) (byte \I))       ;; don't ignore case
            (do
                (reset! do__ic (byte \I))
            )
            :else
            (do
                (ร BREAK)
            ))
            ((ร cmd =) (.plus cmd 1))
        )

        ;; check for a trailing count

        ((ร cmd =) (skipwhite cmd))
        (when (asc-isdigit (.at cmd 0))
;           { Bytes[] __ = { cmd }; i = getdigits(__); cmd = __[0]; }
            (when (and (<= i 0) (not (:skip eap)) @do__error)
                (emsg e_zerocount)
                ((ร RETURN) nil)
            )
            ((ร eap.line1 =) (:line2 eap))
            ((ร eap.line2 =) (+ (:line2 eap) (dec i)))
            (if (> (:line2 eap) (:ml_line_count (:b_ml @curbuf)))
                ((ร eap.line2 =) (:ml_line_count (:b_ml @curbuf)))
            )
        )

        ;; check for trailing command or garbage

        ((ร cmd =) (skipwhite cmd))
        (when (and (non-eos? cmd) (!= (.at cmd 0) (byte \")))        ;; if not end-of-line or comment """
            ((ร eap.nextcmd =) (check-nextcmd cmd))
            (when (nil? (:nextcmd eap))
                (emsg e_trailing)
                ((ร RETURN) nil)
            )
        )

        (if (:skip eap)       ;; not executing commands, only parsing
            ((ร RETURN) nil)
        )

        ((ร regmmatch_C regmatch =) (NEW_regmmatch_C))
        (when (not (search-regcomp pat, RE_SUBST, which_pat, SEARCH_HIS, regmatch))
            (if @do__error
                (emsg e_invcmd))
            ((ร RETURN) nil)
        )

        ;; the 'i' or 'I' flag overrules 'ignorecase' and 'smartcase'
        (cond (== @do__ic (byte \i))
        (do
            ((ร regmatch.rmm_ic =) true)
        )
        (== @do__ic (byte \I))
        (do
            ((ร regmatch.rmm_ic =) false)
        ))

        ((ร Bytes sub_firstline =) nil)        ;; allocated copy of first sub line

        ;; ~ in the substitute pattern is replaced with the old pattern.
        ;; We do it here once to avoid it to be replaced over and over again.
        ;; But don't do it when it starts with "\=", then it's an expression.

        (if (not (and (== (.at sub 0) (byte \\)) (== (.at sub 1) (byte \=))))
            ((ร sub =) (regtilde sub, @p_magic))
        )

        ;; Check for a match on each line.

        ((ร long line2 =) (:line2 eap))
        ((ร FOR) (ร ((ร long lnum =) (:line1 eap)) (and (<= lnum line2) (not (or got_quit @got_int))) (ร lnum++))
            ((ร long nmatch =) (vim-regexec-multi regmatch, @curwin, @curbuf, lnum, 0, nil))
            (when (non-zero? nmatch)                        ;; number of lines in match
                ;; The new text is build up step by step, to avoid too much copying.
                ;; There are these pieces:
                ;;
                ;; sub_firstline    The old text, unmodified.
                ;; copycol          Column in the old text where we started looking for a match;
                ;;                  from here old text still needs to be copied to the new text.
                ;; matchcol         Column number of the old text where to look for the next match.
                ;;                  It's just after the previous match or one further.
                ;; prev_matchcol    Column just after the previous match (if any).
                ;;                  Mostly equal to matchcol, except for the first
                ;;                  match and after skipping an empty match.
                ;; regmatch.*pos    Where the pattern matched in the old text.
                ;; new_start        The new text, all that has been produced so far.
                ;; new_end          The new text, where to append new text.
                ;;
                ;; lnum             The line number where we found the start of the match.
                ;;                  Can be below the line we searched when there is a \n
                ;;                  before a \zs in the pattern.
                ;; sub_firstlnum    The line number in the buffer where to look for a match.
                ;;                  Can be different from "lnum" when the pattern or substitute
                ;;                  string contains line breaks.
                ;;
                ;; Special situations:
                ;; - When the substitute string contains a line break, the part up to the line
                ;;   break is inserted in the text, but the copy of the original line is kept.
                ;;   "sub_firstlnum" is adjusted for the inserted lines.
                ;; - When the matched pattern contains a line break, the old line is taken from
                ;;   the line at the end of the pattern.  The lines in the match are deleted
                ;;   later, "sub_firstlnum" is adjusted accordingly.
                ;;
                ;; The new text is built up in new_start[].  It has some extra room to avoid
                ;; using calloc()/free() too often.  new_start_len is the length of the allocated
                ;; memory at new_start.
                ;;
                ;; Make a copy of the old line, so it won't be taken away when updating the screen
                ;; or handling a multi-line match.  The "old_" pointers point into this copy.

                ((ร int prev_matchcol =) MAXCOL)
                ((ร Bytes new_start =) nil)
                ((ร int new_start_len =) 0)
                ((ร boolean did_sub =) false)
                ((ร long nmatch_tl =) 0)                     ;; nr of lines matched below lnum
                ((ร boolean skip_match =) false)

                ((ร long sub_firstlnum =) lnum)              ;; nr of first sub line
                ((ร int copycol =) 0)
                ((ร int matchcol =) 0)

                ;; At first match, remember current cursor position.
                (when (not got_match)
                    (setpcmark)
                    ((ร got_match =) true)
                )

                ;; Loop until nothing more to replace in this line.
                ;; 1. Handle match with empty string.
                ;; 3. Substitute the string.
                ;; 4. If do__all is set, find next match.
                ;; 5. Break if there isn't another match in this line.

                (while true
                    ;; Advance "lnum" to the line where the match starts.
                    ;; The match does not start in the first line when there is a line break before \zs.
                    (when (< 0 (:lnum (... (:startpos regmatch) 0)))
                        ((ร lnum =) (+ lnum (:lnum (... (:startpos regmatch) 0))))
                        ((ร sub_firstlnum =) (+ sub_firstlnum (:lnum (... (:startpos regmatch) 0))))
                        ((ร nmatch =) (- nmatch (:lnum (... (:startpos regmatch) 0))))
                        ((ร sub_firstline =) nil)
                    )

                    (if (nil? sub_firstline)
                        ((ร sub_firstline =) (STRDUP (ml-get sub_firstlnum)))
                    )

                    ;; Save the line number of the last change for the final cursor position (just like Vi).
                    ((ร @curwin.w_cursor.lnum =) lnum)
                    ((ร boolean do_again =) false)               ;; do it again after joining lines

;                   skip:
;                   {
                        ;; 1. Match empty string does not count, except for first match.
                        ;; This reproduces the strange vi behaviour.
                        ;; This also catches endless loops.

                        (when (and (== matchcol prev_matchcol) (zero? (:lnum (... (:endpos regmatch) 0))) (== matchcol (:col (... (:endpos regmatch) 0))))
                            (cond (eos? sub_firstline matchcol)
                            (do
                                ;; We already were at the end of the line.
                                ;; Don't look for a match in this line again.
                                ((ร skip_match =) true)
                            )
                            :else
                            (do
                                ;; search for a match at next column
                                ((ร matchcol =) (+ matchcol (us-ptr2len-cc (.plus sub_firstline matchcol))))
                            ))
                            (ร BREAK skip)
                        )

                        ;; Normally we continue searching for a match just after the previous match.
                        ((ร matchcol =) (:col (... (:endpos regmatch) 0)))
                        ((ร prev_matchcol =) matchcol)

                        ;; 2. If do__count is set only increase the counter.

                        (when @do__count
                            ;; For a multi-line match, put matchcol at the NUL at
                            ;; the end of the line and set nmatch to one, so that
                            ;; we continue looking for a match on the next line.
                            ;; Avoids that ":s/\nB\@=//gc" get stuck.
                            (when (< 1 nmatch)
                                ((ร matchcol =) (STRLEN sub_firstline))
                                ((ร nmatch =) 1)
                                ((ร skip_match =) true)
                            )
                            (swap! sub_nsubs inc)
                            ((ร did_sub =) true)
                            ;; Skip the substitution, unless an expression is used,
                            ;; then it is evaluated in the sandbox.
                            (if (not (and (== (.at sub 0) (byte \\)) (== (.at sub 1) (byte \=))))
                                (ร BREAK skip)
                            )
                        )

                        ;; Move the cursor to the start of the match, so that we can use "\=col(".").
                        ((ร @curwin.w_cursor.col =) (:col (... (:startpos regmatch) 0)))

                        ;; 3. substitute the string.

                        ;; get length of substitution part
                        ((ร int sublen =) (vim-regsub-multi regmatch, (- sub_firstlnum (:lnum (... (:startpos regmatch) 0))), sub, sub_firstline, false, @p_magic, true))

                        (if @do__count
                            (ร BREAK skip)
                        )

                        ;; When the match included the "$" of the last line it may
                        ;; go beyond the last line of the buffer.
                        (when (> nmatch (+ (- (:ml_line_count (:b_ml @curbuf)) sub_firstlnum) 1))
                            ((ร nmatch =) (+ (- (:ml_line_count (:b_ml @curbuf)) sub_firstlnum) 1))
                            ((ร skip_match =) true)
                        )

                        ;; Need room for:
                        ;; - result so far in "new_start" (not for first sub in line)
                        ;; - original text up to match
                        ;; - length of substituted part
                        ;; - original text after match

                        (ร Bytes p1)
                        (cond (== nmatch 1)
                        (do
                            ((ร p1 =) sub_firstline)
                        )
                        :else
                        (do
                            ((ร p1 =) (ml-get (- (+ sub_firstlnum nmatch) 1)))
                            ((ร nmatch_tl =) (+ nmatch_tl (dec nmatch)))
                        ))
                        ((ร int copy_len =) (- (:col (... (:startpos regmatch) 0)) copycol))
                        ((ร int needed_len =) (+ copy_len (- (STRLEN p1) (:col (... (:endpos regmatch) 0))) sublen 1))
                        (ร Bytes new_end)
                        (cond (nil? new_start)
                        (do
                            ;; Get some space for a temporary buffer to do the substitution into
                            ;; (and some extra space to avoid too many calls to calloc()/free()).

                            ((ร new_start_len =) (+ needed_len 50))
                            ((ร new_start =) (Bytes. new_start_len))
                            (eos! new_start)
                            ((ร new_end =) new_start)
                        )
                        :else
                        (do
                            ;; Check if the temporary buffer is long enough to do the
                            ;; substitution into.  If not, make it larger (with a bit
                            ;; extra to avoid too many calls to calloc()/free()).

                            ((ร int len =) (STRLEN new_start))
                            ((ร needed_len =) (+ needed_len len))
                            (when (< new_start_len needed_len)
                                ((ร new_start_len =) (+ needed_len 50))
                                ((ร p1 =) (Bytes. new_start_len))
                                (BCOPY p1, new_start, (inc len))
                                ((ร new_start =) p1)
                            )
                            ((ร new_end =) (.plus new_start len))
                        ))

                        ;; copy the text up to the part that matched

                        (BCOPY new_end, 0, sub_firstline, copycol, copy_len)
                        ((ร new_end =) (.plus new_end copy_len))

                        (vim-regsub-multi regmatch, (- sub_firstlnum (:lnum (... (:startpos regmatch) 0))), sub, new_end, true, @p_magic, true)

                        (swap! sub_nsubs inc)
                        ((ร did_sub =) true)

                        ;; Move the cursor to the start of the line, to avoid that
                        ;; it is beyond the end of the line after the substitution.
                        ((ร @curwin.w_cursor.col =) 0)

                        ;; For a multi-line match, make a copy of the last matched
                        ;; line and continue in that one.
                        (when (< 1 nmatch)
                            ((ร sub_firstlnum =) (+ sub_firstlnum (dec nmatch)))
                            ((ร sub_firstline =) (STRDUP (ml-get sub_firstlnum)))
                            ;; When going beyond the last line, stop substituting.
                            (if (<= sub_firstlnum line2)
                                ((ร do_again =) true)
                                (reset! do__all false))
                        )

                        ;; Remember next character to be copied.
                        ((ร copycol =) (:col (... (:endpos regmatch) 0)))

                        (when skip_match
                            ;; Already hit end of the buffer,
                            ;; sub_firstlnum is one less than what it ought to be.
                            ((ร sub_firstline =) (STRDUP (u8 "")))
                            ((ร copycol =) 0)
                        )

                        ;; Now the trick is to replace CTRL-M chars with a real line break.
                        ;; This would make it impossible to insert a CTRL-M in the text.
                        ;; The line break can be avoided by preceding the CTRL-M with a backslash.
                        ;; To be able to insert a backslash, they must be doubled in the string
                        ;; and are halved here.
                        ;; That is Vi compatible.

                        ((ร FOR) (ร ((ร p1 =) new_end) (non-eos? p1) ((ร p1 =) (.plus p1 1)))
                            (cond (and (== (.at p1 0) (byte \\)) (non-eos? p1 1))  ;; remove backslash
                            (do
                                (BCOPY p1, 0, p1, 1, (+ (STRLEN p1, 1) 1))
                            )
                            (== (.at p1 0) CAR)
                            (do
                                (when (u-inssub lnum)     ;; prepare for undo
                                    (eos! p1)                  ;; truncate up to the CR
                                    (ml-append (dec lnum), new_start)
                                    (mark-adjust (inc lnum), MAXLNUM, 1, 0)

                                    (if (zero? first_line)
                                        ((ร first_line =) lnum)
                                    )
                                    ((ร last_line =) (inc lnum))

                                    ;; All line numbers increase.
                                    (ร sub_firstlnum++)
                                    (ร lnum++)
                                    (ร line2++)
                                    ;; move the cursor to the new line, like Vi
                                    (ร @curwin.w_cursor.lnum++)
                                    ;; copy the rest
                                    (BCOPY new_start, 0, p1, 1, (+ (STRLEN p1, 1) 1))
                                    ((ร p1 =) (.minus new_start 1))
                                )
                            )
                            :else
                            (do
                                ((ร p1 =) (.plus p1 (- (us-ptr2len-cc p1) 1)))
                            ))
                        )
;                   }

                    ;; 4. If do__all is set, find next match.
                    ;; Prevent endless loop with patterns that match empty
                    ;; strings, e.g. :s/$/pat/g or :s/[a-z]* /(&)/g.
                    ;; But ":s/\n/#/" is OK.

                    ;; We already know that we did the last subst when we are at the end of the line,
                    ;; except that a pattern like "bar\|\nfoo" may match at the NUL.
                    ;; "lnum" can be below "line2" when there is a \zs in the pattern after a line break.

                    ((ร boolean lastone =) (or skip_match @got_int got_quit (< line2 lnum) (not (or @do__all do_again)) (and (eos? sub_firstline matchcol) (<= nmatch 1) (not (re-multiline (:regprog regmatch))))))
                    ((ร nmatch =) -1)

                    ;; Replace the line in the buffer when needed.
                    ;; This is skipped when there are more matches.
                    ;; The check for nmatch_tl is needed for when multi-line matching must replace
                    ;; the lines before trying to do another match, otherwise "\@<=" won't work.
                    ;; When the match starts below where we start searching
                    ;; also need to replace the line first (using \zs after \n).

                    (when (or lastone (< 0 nmatch_tl) (zero? ((ร nmatch =) (vim-regexec-multi regmatch, @curwin, @curbuf, sub_firstlnum, matchcol, nil))) (< 0 (:lnum (... (:startpos regmatch) 0))))
                        (when (non-nil? new_start)
                            ;; Copy the rest of the line, that didn't match.
                            ;; "matchcol" has to be adjusted, we use the end of the line as reference,
                            ;; because the substitute may have changed the number of characters.
                            ;; Same for "prev_matchcol".

                            (STRCAT new_start, (.plus sub_firstline copycol))
                            ((ร matchcol =) (- (STRLEN sub_firstline) matchcol))
                            ((ร prev_matchcol =) (- (STRLEN sub_firstline) prev_matchcol))

                            (if (!= (u-savesub lnum) true)
                                (ร BREAK)
                            )
                            (ml-replace lnum, new_start)

                            (when (< 0 nmatch_tl)
                                ;; Matched lines have now been substituted and are useless, delete them.
                                ;; The part after the match has been appended to "new_start", we don't need
                                ;; it in the buffer.

                                (ร lnum++)
                                (if (not (u-savedel lnum, nmatch_tl))
                                    (ร BREAK)
                                )
                                ((ร FOR) (ร ((ร i =) 0) (< i nmatch_tl) (ร i++))
                                    (ml-delete lnum, false)
                                )
                                (mark-adjust lnum, (- (+ lnum nmatch_tl) 1), MAXLNUM, (- nmatch_tl))
                                (ร --lnum)
                                ((ร line2 =) (- line2 nmatch_tl)) ;; nr of lines decreases
                                ((ร nmatch_tl =) 0)
                            )

                            (if (zero? first_line)
                                ((ร first_line =) lnum)
                            )
                            ((ร last_line =) (inc lnum))

                            ((ร sub_firstlnum =) lnum)
                            ((ร sub_firstline =) new_start)
                            ((ร new_start =) nil)
                            ((ร matchcol =) (- (STRLEN sub_firstline) matchcol))
                            ((ร prev_matchcol =) (- (STRLEN sub_firstline) prev_matchcol))
                            ((ร copycol =) 0)
                        )
                        (if (and (== nmatch -1) (not lastone))
                            ((ร nmatch =) (vim-regexec-multi regmatch, @curwin, @curbuf, sub_firstlnum, matchcol, nil))
                        )

                        ;; 5. break if there isn't another match in this line

                        (when (<= nmatch 0)
                            ;; If the match found didn't start where we were
                            ;; searching, do the next search in the line where we
                            ;; found the match.
                            (if (== nmatch -1)
                                ((ร lnum =) (- lnum (:lnum (... (:startpos regmatch) 0))))
                            )
                            (ร BREAK)
                        )
                    )

                    (line-breakcheck)
                )

                (if did_sub
                    (swap! sub_nlines inc))
                ((ร sub_firstline =) nil)
            )

            (line-breakcheck)
        )

        (when (non-zero? first_line)
            ;; Need to subtract the number of added lines from "last_line" to get
            ;; the line number before the change (same as adding the number of deleted lines).

            ((ร i =) (- (:ml_line_count (:b_ml @curbuf)) old_line_count))
            (changed-lines first_line, 0, (- last_line i), i)
        )

        ;; ":s/pat//n" doesn't move the cursor
        (if @do__count
            (COPY-pos (:w_cursor @curwin), old_cursor))

        (cond (< start_nsubs @sub_nsubs)
        (do
            ;; Set the '[ and '] marks.
            ((ร @curbuf.b_op_start.lnum =) (:line1 eap))
            ((ร @curbuf.b_op_end.lnum =) line2)
            ((ร @curbuf.b_op_start.col =) (ร @curbuf.b_op_end.col =) 0)

            (if endcolumn
                (coladvance MAXCOL)
                (beginline (| BL_WHITE BL_FIX)))

            (do-sub-msg @do__count)
        )
        :else
        (do
            (cond @got_int                ;; interrupted
            (do
                (emsg e_interr)
            )
            got_match         ;; did find something but nothing substituted
            (do
                (msg (u8 ""))
            )
            @do__error         ;; nothing found
            (do
                (emsg2 e_patnotf2, (get-search-pat))
            ))
        ))
        nil
    ))

;; Give message for number of substitutions.
;; Return true if a message was given.

(defn- #_boolean do-sub-msg [#_boolean count_only]
    ;; count_only: used 'n' flag for ":s"
    (ยง
        ;; Only report substitutions when:
        ;; - more than 'report' substitutions
        ;; - command was typed by user, or number of changed lines > 'report'
        ;; - giving messages is not disabled by 'lazyredraw'

        (when (and (or (and (< @p_report @sub_nsubs) (or @keyTyped (< 1 @sub_nlines) (< @p_report 1))) count_only) (messaging))
            ((ร Bytes msg_buf =) (Bytes. MSG_BUF_LEN))
            (if @got_int
                (STRCPY msg_buf, (u8 "(Interrupted) "))
                (eos! msg_buf)
            )
            (if (== @sub_nsubs 1)
                (vim_snprintf_add msg_buf, MSG_BUF_LEN, (u8 "%s"), (if count_only (u8 "1 match") (u8 "1 substitution")))
                (vim_snprintf_add msg_buf, MSG_BUF_LEN, (if count_only (u8 "%ld matches") (u8 "%ld substitutions")), @sub_nsubs)
            )
            (if (== @sub_nlines 1)
                (vim_snprintf_add msg_buf, MSG_BUF_LEN, (u8 "%s"), (u8 " on 1 line"))
                (vim_snprintf_add msg_buf, MSG_BUF_LEN, (u8 " on %ld lines"), @sub_nlines)
            )
            (when (msg msg_buf)
                ;; save message to display it after redraw
                (set-keep-msg msg_buf, 0)
            )
            ((ร RETURN) true)
        )
        (when @got_int
            (emsg e_interr)
            ((ร RETURN) true)
        )
        false
    ))

;; ex_getln.c: Functions for entering and editing an Ex command line ------------------------------

;; Variables shared between getcmdline(), redrawcmdline() and others.
;; These need to be saved when using CTRL-R |, that's why they are in a structure.

(class! #_final cmdline_info_C
    [
        (field Bytes        cmdbuff)        ;; pointer to command line buffer
        (field int          cmdbufflen)     ;; length of "cmdbuff"
        (field int          cmdlen)         ;; number of chars in command line
        (field int          cmdpos)         ;; current cursor position
        (field int          cmdspos)        ;; cursor column on screen
        (field int          cmdfirstc)      ;; ':', '/', '?', '=' or NUL
        (field int          cmdindent)      ;; number of spaces before cmdline
        (field Bytes        cmdprompt)      ;; message in front of cmdline
        (field int          cmdattr)        ;; attributes for prompt
        (field boolean      overstrike)     ;; Typing mode on the command line.  Shared by getcmdline() and put-on-cmdline().
    ])

(defn- #_void COPY-cmdline-info [#_cmdline_info_C cli1, #_cmdline_info_C cli0]
    (ยง
        ((ร cli1.cmdbuff =) (:cmdbuff cli0))
        ((ร cli1.cmdbufflen =) (:cmdbufflen cli0))
        ((ร cli1.cmdlen =) (:cmdlen cli0))
        ((ร cli1.cmdpos =) (:cmdpos cli0))
        ((ร cli1.cmdspos =) (:cmdspos cli0))
        ((ร cli1.cmdfirstc =) (:cmdfirstc cli0))
        ((ร cli1.cmdindent =) (:cmdindent cli0))
        ((ร cli1.cmdprompt =) (:cmdprompt cli0))
        ((ร cli1.cmdattr =) (:cmdattr cli0))
        ((ร cli1.overstrike =) (:overstrike cli0))
        nil
    ))

;; The current cmdline_info.  It is initialized in getcmdline() and after that
;; used by other functions.  When invoking getcmdline() recursively it needs
;; to be saved with save-cmdline() and restored with restore-cmdline().
;; TODO: make it local to getcmdline() and pass it around.

(atom! cmdline_info_C ccline    (NEW_cmdline_info_C))

(atom! int new_cmdpos)  ;; position set by set_cmdline_pos()

(class! #_final histentry_C
    [
        (field int      hisnum)     ;; identifying number
        (field Bytes    hisstr)     ;; actual entry, separator char after the NUL
    ])

(defn- #_void COPY-histentry [#_histentry_C he1, #_histentry_C he0]
    (ยง
        ((ร he1.hisnum =) (:hisnum he0))
        ((ร he1.hisstr =) (:hisstr he0))
        nil
    ))

(defn- #_histentry_C* ARRAY-histentry [#_int n]
    (vec (repeatedly n NEW_histentry_C)))

(atom! histentry_C**    history     HIST_COUNT)
(atom! int*             hisidx      (repeat HIST_COUNT -1))     ;; last used entry
;; identifying (unique) number of newest history entry
(atom! int*             hisnum      HIST_COUNT)
(atom! int              hislen)                                 ;; actual length of history tables

;; getcmdline() - accept a command line starting with firstc.
;;
;; firstc == ':'            get ":" command line.
;; firstc == '/' or '?'     get search pattern
;; firstc == '='            get expression
;; firstc == '@'            get text for input() function
;; firstc == '>'            get text for debug mode
;; firstc == NUL            get text for :insert command
;; firstc == -1             like NUL, and break on CTRL-C
;;
;; The line is collected in ccline.cmdbuff, which is reallocated to fit the command line.
;;
;; Careful: getcmdline() can be called recursively!
;;
;; Return pointer to allocated string if there is a commandline, null otherwise.

(defn- #_Bytes getcmdline [#_int firstc, #_long count]
    ;; count: only used for incremental search
    (ยง
        ((ร boolean gotesc =) false)                 ;; true when <ESC> just typed
        ((ร Bytes lookfor =) nil)                  ;; string to match
        ((ร boolean did_incsearch =) false)
        ((ร boolean incsearch_postponed =) false)
        ((ร boolean did_wild_list =) false)          ;; did wild_list() recently
        ((ร boolean save_msg_scroll =) @msg_scroll)
        ((ร int save_State =) @State)                 ;; remember State when called
        ((ร boolean some_key_typed =) false)         ;; one of the keys was typed

        ((ร boolean break_ctrl_c =) false)

        ;; Everything that may work recursively should save and restore the current command line in save_cli.
        ;; That includes update-screen(), a custom status line may invoke ":normal".

        ((ร cmdline_info_C save_cli =) (NEW_cmdline_info_C))

        (when (== firstc -1)
            ((ร firstc =) NUL)
            ((ร break_ctrl_c =) true)
        )

        ((ร @ccline.overstrike =) false)                  ;; always start in insert mode
        ((ร pos_C old_cursor =) (NEW_pos_C))
        (COPY-pos old_cursor, (:w_cursor @curwin))      ;; needs to be restored later
        ((ร int old_curswant =) (:w_curswant @curwin))
        ((ร int old_leftcol =) (:w_leftcol @curwin))
        ((ร long old_topline =) (:w_topline @curwin))
        ((ร long old_botline =) (:w_botline @curwin))

        ;; set some variables for redrawcmd()

        ((ร @ccline.cmdfirstc =) (if (== firstc (byte \@)) 0 firstc))
        ((ร @ccline.cmdindent =) 0)

        ;; alloc initial ccline.cmdbuff
        (alloc-cmdbuff 1)
        ((ร @ccline.cmdlen =) (ร @ccline.cmdpos =) 0)
        (eos! (:cmdbuff @ccline))

        ;; autoindent for :insert and :append
        (when (<= firstc 0)
;           copy-spaces(@ccline.cmdbuff, 0);
            (eos! (:cmdbuff @ccline))
            ((ร @ccline.cmdpos =) 0)
            ((ร @ccline.cmdspos =) 0)
            ((ร @ccline.cmdlen =) 0)
        )

;       {
            ((ร int i =) @msg_scrolled)
            (reset! msg_scrolled 0)               ;; avoid wait-return message
            (gotocmdline true)
            ((ร @msg_scrolled =) (+ @msg_scrolled i))
            (redrawcmdprompt)
            (set-cmdspos)
;       }

        ;; Avoid scrolling when called by a recursive do-cmdline(),
        ;; e.g. when doing ":@0" when register 0 doesn't contain a CR.

        (reset! msg_scroll false)

        (reset! State CMDLINE)

        (ui-cursor-shape)          ;; may show different cursor shape

        ;; When inside an autocommand for writing "exiting" may be set and terminal mode set to cooked.
        ;; Need to set raw mode here then.
        (settmode TMODE_RAW)

        (init-history)
        ((ร int hiscnt =) @hislen)        ;; current history line in use; set to impossible history value
        ((ร int histype =) (hist-char2type firstc))   ;; history type to be used

        (do-digraph -1)             ;; init digraph typeahead

        ;; If something above caused an error, reset the flags, we do want to type and execute commands.
        ;; Display may be messed up a bit.
        (if @did_emsg
            (redrawcmd))
        (reset! did_emsg false)
        (reset! got_int false)

        ;; Collect the command string, handling editing keys.

;       returncmd:
        (while true
            (reset! quit_more false)  ;; reset after CTRL-D which had a more-prompt

            (cursorcmd)        ;; set the cursor on the right spot

            ;; Get a character.
            ;; Ignore K_IGNORE, it should not do anything, such as stop completion.
            (ร int c)
;           do
;           {
                ((ร c =) (safe-vgetc))
;           } while (c == K_IGNORE);

            (when @keyTyped
                ((ร some_key_typed =) true)
            )

            ;; Ignore got_int when CTRL-C was typed here.
            ;; Don't ignore it in :global, we really need to break then,
            ;; e.g. for ":g/pat/normal /pat" (without the <CR>).
            ;; Don't ignore it for the input() function.

            (when (and (or (== c Ctrl_C) (== c @intr_char)) (!= firstc (byte \@)) (not break_ctrl_c))
                (reset! got_int false)
            )

            ;; free old command line when finished moving around in the history list
            (when (and (non-nil? lookfor) (!= c K_S_DOWN) (!= c K_S_UP) (!= c K_DOWN) (!= c K_UP) (!= c K_PAGEDOWN) (!= c K_PAGEUP) (!= c K_KPAGEDOWN) (!= c K_KPAGEUP) (!= c K_LEFT) (!= c K_RIGHT) (!= c Ctrl_P) (!= c Ctrl_N))
                ((ร lookfor =) nil)
            )

;           cmdline_changed:
;           {
;               cmdline_not_changed:
;               {
                    ;; CTRL-\ CTRL-N goes to Normal mode,
                    ;; CTRL-\ CTRL-G goes to Insert mode when 'insertmode' is set,
                    ;; CTRL-\ e prompts for an expression.
                    (when (== c Ctrl_BSL)
                        (swap! no_mapping inc)
                        (swap! allow_keys inc)
                        ((ร c =) (plain-vgetc))
                        (swap! no_mapping dec)
                        (swap! allow_keys dec)
                        ;; CTRL-\ e doesn't work when obtaining an expression, unless it is in a mapping.
                        (cond (and (!= c Ctrl_N) (!= c Ctrl_G) (or (!= c (byte \e)) (and (== (:cmdfirstc @ccline) (byte \=)) @keyTyped)))
                        (do
                            (vungetc c)
                            ((ร c =) Ctrl_BSL)
                        )
                        (== c (byte \e))
                        (do
                            ;; Replace the command line with the result of an expression.
                            ;; Need to save and restore the current command line, to be
                            ;; able to enter a new one...

                            (if (== (:cmdpos @ccline) (:cmdlen @ccline))
                                (reset! new_cmdpos 99999) ;; keep it at the end
                                (reset! new_cmdpos (:cmdpos @ccline)))

                            (save-cmdline save_cli)
                            ((ร c =) (get-expr-register))
                            (restore-cmdline save_cli)

                            (when (== c (byte \=))
                                ;; Need to save and restore ccline, and set "textlock" to avoid nasty things
                                ;; like going to another buffer when evaluating an expression.
                                (save-cmdline save_cli)
                                (swap! textlock inc)
                                ((ร Bytes p =) (get-expr-line))
                                (swap! textlock dec)
                                (restore-cmdline save_cli)

                                (when (non-nil? p)
                                    ((ร int len =) (STRLEN p))
                                    (realloc-cmdbuff (inc len))

                                    ((ร @ccline.cmdlen =) len)
                                    (STRCPY (:cmdbuff @ccline), p)

                                    ;; Restore the cursor or use the position set with set_cmdline_pos().
                                    ((ร @ccline.cmdpos =) (if (< (:cmdlen @ccline) @new_cmdpos) (:cmdlen @ccline) @new_cmdpos))

                                    (reset! keyTyped false)   ;; Don't do 'wildchar' completion.
                                    (redrawcmd)
                                    (ร BREAK cmdline_changed)
                                )
                            )

                            (beep-flush)
                            (reset! got_int false)        ;; don't abandon the command line
                            (reset! did_emsg false)
                            (reset! emsg_on_display false)
                            (redrawcmd)
                            (ร BREAK cmdline_not_changed)
                        )
                        :else
                        (do
                            (if (and (== c Ctrl_G) @p_im (zero? @restart_edit))
                                (reset! restart_edit (byte \a)))
                            ((ร gotesc =) true)          ;; will free ccline.cmdbuff after putting it in history
                            (ร BREAK returncmd)        ;; back to Normal mode
                        ))
                    )

                    (cond (or (== c @cedit_key) (== c K_CMDWIN))
                    (do
                        (when (not @got_int)
                            ;; Open a window to edit the command line (and history).
                            ((ร c =) (ex-window))
                            ((ร some_key_typed =) true)
                        )
                    )
                    :else
                    (do
                        ((ร c =) (do-digraph c))
                    ))

                    (when (or (== c (byte \newline)) (== c (byte \return)) (== c K_KENTER) (and (== c ESC) (or (not @keyTyped) (non-nil? (vim-strbyte @p_cpo, CPO_ESC)))))
                        ((ร gotesc =) false)                     ;; Might have typed ESC previously,
                                                            ;; don't truncate the cmdline now.
                        (windgoto @msg_row, 0)
                        (out-flush)
                        (ร BREAK)
                    )

                    ((ร gotesc =) false)

                    (if (or (== c NUL) (== c K_ZERO))        ;; NUL is stored as NL
                        ((ร c =) NL)
                    )

                    ((ร boolean do_abbr =) true)             ;; default: check for abbreviation

                    ;; Big switch for a typed command line character.

                    ((ร SWITCH) c
                        ((ร CASE) K_BS)
                        ((ร CASE) Ctrl_H)
                        ((ร CASE) K_DEL)
                        ((ร CASE) K_KDEL)
                        ((ร CASE) Ctrl_W)
                        (do
                            (if (== c K_KDEL)
                                ((ร c =) K_DEL)
                            )

                            ;; delete current character is the same as backspace on next
                            ;; character, except at end of line

                            (if (and (== c K_DEL) (!= (:cmdpos @ccline) (:cmdlen @ccline)))
                                (ร @ccline.cmdpos++)
                            )
                            (if (== c K_DEL)
                                ((ร @ccline.cmdpos =) (+ (:cmdpos @ccline) (us-off-next (:cmdbuff @ccline), (.plus (:cmdbuff @ccline) (:cmdpos @ccline)))))
                            )
                            (cond (< 0 (:cmdpos @ccline))
                            (do
                                ((ร int j =) (:cmdpos @ccline))
                                ((ร Bytes p =) (us-prevptr (:cmdbuff @ccline), (.plus (:cmdbuff @ccline) j)))

                                (when (== c Ctrl_W)
                                    (while (and (BLT (:cmdbuff @ccline), p) (vim-isspace (.at p 0)))
                                        ((ร p =) (us-prevptr (:cmdbuff @ccline), p))
                                    )
                                    ((ร int i =) (us-get-class p, @curbuf))
                                    (while (and (BLT (:cmdbuff @ccline), p) (== (us-get-class p, @curbuf) i))
                                        ((ร p =) (us-prevptr (:cmdbuff @ccline), p))
                                    )
                                    (if (!= (us-get-class p, @curbuf) i)
                                        ((ร p =) (.plus p (us-ptr2len-cc p)))
                                    )
                                )

                                ((ร @ccline.cmdpos =) (BDIFF p, (:cmdbuff @ccline)))
                                ((ร @ccline.cmdlen =) (- (:cmdlen @ccline) (- j (:cmdpos @ccline))))
                                ((ร int i =) (:cmdpos @ccline))
                                (while (< i (:cmdlen @ccline))
                                    (.be (:cmdbuff @ccline) (ร i++), (.at (:cmdbuff @ccline) (ร j++)))
                                )

                                ;; Truncate at the end, required for multi-byte chars.
                                (.be (:cmdbuff @ccline) (:cmdlen @ccline), NUL)
                                (redrawcmd)
                            )
                            (and (zero? (:cmdlen @ccline)) (!= c Ctrl_W) (nil? (:cmdprompt @ccline)))
                            (do
                                ((ร @ccline.cmdbuff =) nil)     ;; no commandline to return

                                (reset! msg_col 0)
                                (msg-putchar (byte \space))           ;; delete ':'

                                (reset! redraw_cmdline true)
                                (ร BREAK returncmd)            ;; back to cmd mode
                            ))
                            (ร BREAK cmdline_changed)
                        )

                        ((ร CASE) K_INS)
                        ((ร CASE) K_KINS)
                        (do
                            ((ร @ccline.overstrike =) (not (:overstrike @ccline)))
                            (ui-cursor-shape)              ;; may show different cursor shape
                            (ร BREAK cmdline_not_changed)
                        )

                        ((ร CASE) Ctrl_HAT)
                        (do
                            (ร BREAK cmdline_not_changed)
                        )

                        ((ร CASE) Ctrl_U)
                        (do
                            ;; delete all characters left of the cursor
                            ((ร int j =) (:cmdpos @ccline))
                            ((ร @ccline.cmdlen =) (- (:cmdlen @ccline) j))
                            ((ร int i =) (ร @ccline.cmdpos =) 0)
                            (while (< i (:cmdlen @ccline))
                                (.be (:cmdbuff @ccline) (ร i++), (.at (:cmdbuff @ccline) (ร j++)))
                            )
                            ;; Truncate at the end, required for multi-byte chars.
                            (.be (:cmdbuff @ccline) (:cmdlen @ccline), NUL)
                            (redrawcmd)
                            (ร BREAK cmdline_changed)
                        )

                        ((ร CASE) ESC)       ;; get here when ESC typed twice
                        ((ร CASE) Ctrl_C)
                        (do
                            ((ร gotesc =) true)              ;; will free ccline.cmdbuff after putting it in history
                            (ร BREAK returncmd)            ;; back to cmd mode
                        )

                        ((ร CASE) Ctrl_R)                    ;; insert register
                        (do
                            (putcmdline (byte \"), true)    ;; """
                            (swap! no_mapping inc)
                            ((ร int i =) ((ร c =) (plain-vgetc)))  ;; CTRL-R <char>
                            (if (== i Ctrl_O)
                                ((ร i =) Ctrl_R)             ;; CTRL-R CTRL-O == CTRL-R CTRL-R
                            )
                            (if (== i Ctrl_R)
                                ((ร c =) (plain-vgetc))      ;; CTRL-R CTRL-R <char>
                            )
                            (swap! no_mapping dec)

                            ;; Insert the result of an expression.
                            ;; Need to save the current command line, to be able to enter a new one...

                            (reset! new_cmdpos -1)
                            (when (== c (byte \=))
                                (cond (== (:cmdfirstc @ccline) (byte \=))    ;; can't do this recursively
                                (do
                                    (beep-flush)
                                    ((ร c =) ESC)
                                )
                                :else
                                (do
                                    (save-cmdline save_cli)
                                    ((ร c =) (get-expr-register))
                                    (restore-cmdline save_cli)
                                ))
                            )
                            (when (!= c ESC)               ;; use ESC to cancel inserting register
                                (cmdline-paste c, (== i Ctrl_R), false)

                                ;; When there was a serious error abort getting the command line.
                                (when @got_int
                                    ((ร gotesc =) true)      ;; will free ccline.cmdbuff after putting it in history
                                    (ร BREAK returncmd)    ;; back to cmd mode
                                )
                                (reset! keyTyped false)       ;; Don't do 'wildchar' completion.
                                (when (<= 0 @new_cmdpos)
                                    ;; set_cmdline_pos() was used
                                    ((ร @ccline.cmdpos =) (if (< (:cmdlen @ccline) @new_cmdpos) (:cmdlen @ccline) @new_cmdpos))
                                )
                            )
                            (redrawcmd)
                            (ร BREAK cmdline_changed)
                        )

                        ((ร CASE) K_RIGHT)
                        ((ร CASE) K_S_RIGHT)
                        ((ร CASE) K_C_RIGHT)
                        (do
;                           do
;                           {
                                (if (<= (:cmdlen @ccline) (:cmdpos @ccline))
                                    (ร BREAK)
                                )
                                ((ร int i =) (cmdline-charsize (:cmdpos @ccline)))
                                (if (and @keyTyped (<= (* (int @Cols) (int @Rows)) (+ (:cmdspos @ccline) i)))
                                    (ร BREAK)
                                )
                                ((ร @ccline.cmdspos =) (+ (:cmdspos @ccline) i))
                                ((ร @ccline.cmdpos =) (+ (:cmdpos @ccline) (us-ptr2len-cc (.plus (:cmdbuff @ccline) (:cmdpos @ccline)))))
;                           }
                            (while (and (or (== c K_S_RIGHT) (== c K_C_RIGHT) (flag? @mod_mask (| MOD_MASK_SHIFT MOD_MASK_CTRL))) (!= (.at (:cmdbuff @ccline) (:cmdpos @ccline)) (byte \space)))
;                               ;
                            )
                            (set-cmdspos-cursor)
                            (ร BREAK cmdline_not_changed)
                        )

                        ((ร CASE) K_LEFT)
                        ((ร CASE) K_S_LEFT)
                        ((ร CASE) K_C_LEFT)
                        (do
                            (if (zero? (:cmdpos @ccline))
                                (ร BREAK cmdline_not_changed)
                            )
;                           do
;                           {
                                (ร --@ccline.cmdpos)
                                ;; move to first byte of char
                                ((ร @ccline.cmdpos =) (- (:cmdpos @ccline) (us-head-off (:cmdbuff @ccline), (.plus (:cmdbuff @ccline) (:cmdpos @ccline)))))
                                ((ร @ccline.cmdspos =) (- (:cmdspos @ccline) (cmdline-charsize (:cmdpos @ccline))))
;                           }
                            (while (and (< 0 (:cmdpos @ccline)) (or (== c K_S_LEFT) (== c K_C_LEFT) (flag? @mod_mask (| MOD_MASK_SHIFT MOD_MASK_CTRL))) (!= (.at (:cmdbuff @ccline) (- (:cmdpos @ccline) 1)) (byte \space)))
;                               ;
                            )
                            (set-cmdspos-cursor)
                            (ร BREAK cmdline_not_changed)
                        )

                        ((ร CASE) K_IGNORE)
                        (do
                            (ร BREAK cmdline_not_changed)          ;; Ignore mouse event or ex-window() result.
                        )

                        ((ร CASE) K_DROP)
                        (do
                            (cmdline-paste (byte \~), true, false)
                            (redrawcmd)
                            (ร BREAK cmdline_changed)
                        )

                        ((ร CASE) K_SELECT)      ;; end of Select mode mapping - ignore
                        (do
                            (ร BREAK cmdline_not_changed)
                        )

                        ((ร CASE) Ctrl_B)        ;; begin of command line
                        ((ร CASE) K_HOME)
                        ((ร CASE) K_KHOME)
                        ((ร CASE) K_S_HOME)
                        ((ร CASE) K_C_HOME)
                        (do
                            ((ร @ccline.cmdpos =) 0)
                            (set-cmdspos)
                            (ร BREAK cmdline_not_changed)
                        )

                        ((ร CASE) Ctrl_E)        ;; end of command line
                        ((ร CASE) K_END)
                        ((ร CASE) K_KEND)
                        ((ร CASE) K_S_END)
                        ((ร CASE) K_C_END)
                        (do
                            ((ร @ccline.cmdpos =) (:cmdlen @ccline))
                            (set-cmdspos-cursor)
                            (ร BREAK cmdline_not_changed)
                        )

                        ((ร CASE) Ctrl_L)
                        (do
                            (when (and @p_is (or (== firstc (byte \/)) (== firstc (byte \?))))
                                ;; Add a character from under the cursor for 'incsearch'.
                                (when (and did_incsearch (not (eqpos (:w_cursor @curwin), old_cursor)))
                                    ((ร c =) (gchar-cursor))
                                    ;; If 'ignorecase' and 'smartcase' are set and the command line
                                    ;; has no uppercase characters, convert the character to lowercase.
                                    (if (and @p_ic @p_scs (not (pat-has-uppercase (:cmdbuff @ccline))))
                                        ((ร c =) (utf-tolower c))
                                    )
                                    (when (!= c NUL)
                                        (when (or (== c firstc) (!= (vim-strchr (if @p_magic (u8 "\\^$.*[") (u8 "\\^$")), c) nil))
                                            ;; put a backslash before special characters
                                            (stuffcharReadbuff c)
                                            ((ร c =) (byte \\))
                                        )
                                        (ร BREAK)
                                    )
                                )
                                (ร BREAK cmdline_not_changed)
                            )

                            (ร BREAK)
                        )

                        ((ร CASE) Ctrl_N)        ;; next match
                        ((ร CASE) Ctrl_P)        ;; previous match

                        ((ร CASE) K_UP)
                        ((ร CASE) K_DOWN)
                        ((ร CASE) K_S_UP)
                        ((ร CASE) K_S_DOWN)
                        ((ร CASE) K_PAGEUP)
                        ((ร CASE) K_KPAGEUP)
                        ((ร CASE) K_PAGEDOWN)
                        ((ร CASE) K_KPAGEDOWN)
                        (do
                            (if (or (zero? @hislen) (== firstc NUL))       ;; no history
                                (ร BREAK cmdline_not_changed)
                            )

                            ((ร int i =) hiscnt)

                            ;; save current command string so it can be restored later
                            (when (nil? lookfor)
                                ((ร lookfor =) (STRDUP (:cmdbuff @ccline)))
                                (if (nil? lookfor)
                                    (ร BREAK cmdline_not_changed)
                                )
                                (.be lookfor (:cmdpos @ccline), NUL)
                            )

                            ((ร FOR) (ร ((ร int n =) (STRLEN lookfor)) true nil)
                                ;; one step backwards
                                (cond (or (== c K_UP) (== c K_S_UP) (== c Ctrl_P) (== c K_PAGEUP) (== c K_KPAGEUP))
                                (do
                                    (cond (== hiscnt @hislen)   ;; first time
                                    (do
                                        ((ร hiscnt =) (... @hisidx histype))
                                    )
                                    (and (zero? hiscnt) (!= (... @hisidx histype) (dec @hislen)))
                                    (do
                                        ((ร hiscnt =) (dec @hislen))
                                    )
                                    (!= hiscnt (+ (... @hisidx histype) 1))
                                    (do
                                        (ร --hiscnt)
                                    )
                                    :else                    ;; at top of list
                                    (do
                                        ((ร hiscnt =) i)
                                        (ร BREAK)
                                    ))
                                )
                                :else    ;; one step forwards
                                (do
                                    ;; on last entry, clear the line
                                    (when (== hiscnt (... @hisidx histype))
                                        ((ร hiscnt =) @hislen)
                                        (ร BREAK)
                                    )

                                    ;; not on a history line, nothing to do
                                    (if (== hiscnt @hislen)
                                        (ร BREAK)
                                    )
                                    (if (== hiscnt (dec @hislen))   ;; wrap around
                                        ((ร hiscnt =) 0)
                                        (ร hiscnt++)
                                    )
                                ))
                                (when (or (< hiscnt 0) (nil? (:hisstr (... (... @history histype) hiscnt))))
                                    ((ร hiscnt =) i)
                                    (ร BREAK)
                                )
                                (when (or (and (!= c K_UP) (!= c K_DOWN)) (== hiscnt i) (zero? (STRNCMP (:hisstr (... (... @history histype) hiscnt)), lookfor, n)))
                                    (ร BREAK)
                                )
                            )

                            (when (!= hiscnt i)        ;; jumped to other entry
                                ((ร @ccline.cmdbuff =) nil)

                                ((ร Bytes p =) (if (== hiscnt @hislen)
                                    lookfor    ;; back to the old one
                                    (:hisstr (... (... @history histype) hiscnt))
                                ))

                                (ร int old_firstc)
                                (cond (and (== histype HIST_SEARCH) (BNE p, lookfor) (!= ((ร old_firstc =) (.at p (+ (STRLEN p) 1))) firstc))
                                (do
                                    ;; Correct for the separator character used when
                                    ;; adding the history entry vs the one used now.
                                    ;; First loop: count length.
                                    ;; Second loop: copy the characters.
                                    ((ร FOR) (ร ((ร int round =) 0) (<= round 1) (ร round++))
                                        ((ร int len =) 0)

                                        ((ร FOR) (ร (ร #_"/*int */"i = 0) (non-eos? p i) (ร i++))
                                            ;; Replace old sep with new sep, unless it is escaped.
                                            (cond (and (== (.at p i) old_firstc) (or (zero? i) (!= (.at p (dec i)) (byte \\))))
                                            (do
                                                (if (< 0 round)
                                                    (.be (:cmdbuff @ccline) len, firstc)
                                                )
                                            )
                                            :else
                                            (do
                                                ;; Escape new sep, unless it is already escaped.
                                                (when (and (== (.at p i) firstc) (or (zero? i) (!= (.at p (dec i)) (byte \\))))
                                                    (if (< 0 round)
                                                        (.be (:cmdbuff @ccline) len, (byte \\))
                                                    )
                                                    (ร len++)
                                                )
                                                (if (< 0 round)
                                                    (.be (:cmdbuff @ccline) len, (.at p i))
                                                )
                                            ))
                                            (ร len++)
                                        )

                                        (if (< 0 round)
                                            (.be (:cmdbuff @ccline) len, NUL)
                                            (alloc-cmdbuff len))
                                    )
                                )
                                :else
                                (do
                                    (alloc-cmdbuff (STRLEN p))
                                    (STRCPY (:cmdbuff @ccline), p)
                                ))

                                ((ร @ccline.cmdpos =) (ร @ccline.cmdlen =) (STRLEN (:cmdbuff @ccline)))
                                (redrawcmd)
                                (ร BREAK cmdline_changed)
                            )
                            (beep-flush)
                            (ร BREAK cmdline_not_changed)
                        )

                        ((ร CASE) Ctrl_V)
                        ((ร CASE) Ctrl_Q)
                        (do
                            (putcmdline (byte \^), true)
                            ((ร c =) (get-literal))          ;; get next (two) character(s)
                            ((ร do_abbr =) false)            ;; don't do abbreviation now
                            ;; may need to remove ^ when composing char was typed
                            (when (utf-iscomposing c)
                                (draw-cmdline (:cmdpos @ccline), (- (:cmdlen @ccline) (:cmdpos @ccline)))
                                (msg-putchar (byte \space))
                                (cursorcmd)
                            )
                            (ร BREAK)
                        )

                        ((ร CASE) Ctrl_K)
                        (do
                            (putcmdline (byte \?), true)
                            ((ร c =) (get-digraph true))
                            (if (!= c NUL)
                                (ร BREAK)
                            )

                            (redrawcmd)
                            (ร BREAK cmdline_not_changed)
                        )

                        (ร DEFAULT)
                        (do
                            (when (== c @intr_char)
                                ((ร gotesc =) true)      ;; will free ccline.cmdbuff after putting it in history
                                (ร BREAK returncmd)    ;; back to Normal mode
                            )

                            ;; Normal character with no special meaning.  Just set mod_mask
                            ;; to 0x0 so that typing Shift-Space in the GUI doesn't enter
                            ;; the string <S-Space>.  This should only happen after ^V.

                            (if (not (is-special c))
                                (reset! mod_mask 0x0))
                            (ร BREAK)
                        )
                    )

                    ;; End of switch on command line character.
                    ;; We come here if we have a normal character.

                    (if (and do_abbr (or (is-special c) (not (vim-iswordc c, @curbuf))) (== c Ctrl_RSB))
                        (ร BREAK cmdline_changed)
                    )

                    ;; put the character in the command line

                    (cond (or (is-special c) (non-zero? @mod_mask))
                    (do
                        (put-on-cmdline (get-special-key-name c, @mod_mask), -1, true)
                    )
                    :else
                    (do
                        ((ร int j =) (utf-char2bytes c, @ioBuff))
                        (eos! @ioBuff j)          ;; exclude composing chars
                        (put-on-cmdline @ioBuff, j, true)
                    ))
                    (ร BREAK cmdline_changed)
;               }

                ;; This part implements incremental searches for "/" and "?"
                ;; Jump to cmdline_not_changed when a character has been read but the command
                ;; line did not change.  Then we only search and redraw if something changed in the past.
                ;; Jump to cmdline_changed when the command line did change.

                (if (not incsearch_postponed)
                    (ร CONTINUE)
                )
;           }

            ;; 'incsearch' highlighting.

            (when (and @p_is (or (== firstc (byte \/)) (== firstc (byte \?))))
                ;; if there is a character waiting, search and redraw later
                (when (char-avail)
                    ((ร incsearch_postponed =) true)
                    (ร CONTINUE)
                )
                ((ร incsearch_postponed =) false)
                (COPY-pos (:w_cursor @curwin), old_cursor) ;; start at old position

                ;; If there is no command line, don't do anything.
                (ร int i)
                (cond (zero? (:cmdlen @ccline))
                (do
                    ((ร i =) 0)
                )
                :else
                (do
                    (cursor-off)               ;; so the user knows we're busy
                    (out-flush)
                    (swap! emsg_off inc)                 ;; so it doesn't beep if bad expr
                    ;; Set the time limit to half a second.
                    ((ร long nsec =) (profile-setlimit 500))
                    ((ร i =) (do-search nil, (byte firstc), (:cmdbuff @ccline), count, (+ SEARCH_KEEP SEARCH_OPT SEARCH_NOOF SEARCH_PEEK), nsec))
                    (swap! emsg_off dec)
                    ;; if interrupted while searching, behave like it failed
                    (cond @got_int
                    (do
                        (vpeekc)               ;; remove <C-C> from input stream
                        (reset! got_int false)        ;; don't abandon the command line
                        ((ร i =) 0)
                    )
                    (char-avail)
                    (do
                        ;; cancelled searching because a char was typed
                        ((ร incsearch_postponed =) true)
                    ))
                ))
                (if (non-zero? i)
                    (reset! highlight_match true)         ;; highlight position
                    (reset! highlight_match false))        ;; remove highlight

                ;; First restore the old curwin values, so the screen is
                ;; positioned in the same way as the actual search command.
                ((ร @curwin.w_leftcol =) old_leftcol)
                ((ร @curwin.w_topline =) old_topline)
                ((ร @curwin.w_botline =) old_botline)
                (changed-cline-bef-curs)
                (update-topline)

                ((ร pos_C end_pos =) (NEW_pos_C))
                (cond (non-zero? i)
                (do
                    ((ร pos_C save_pos =) (NEW_pos_C))
                    (COPY-pos save_pos, (:w_cursor @curwin))

                    ;; First move the cursor to the end of the match, then to the start.
                    ;; This moves the whole match onto the screen when 'nowrap' is set.

                    ((ร @curwin.w_cursor.lnum =) (+ (:lnum (:w_cursor @curwin)) @search_match_lines))
                    ((ร @curwin.w_cursor.col =) @search_match_endcol)
                    (when (> (:lnum (:w_cursor @curwin)) (:ml_line_count (:b_ml @curbuf)))
                        ((ร @curwin.w_cursor.lnum =) (:ml_line_count (:b_ml @curbuf)))
                        (coladvance MAXCOL)
                    )
                    (validate-cursor)
                    (COPY-pos end_pos, (:w_cursor @curwin))
                    (COPY-pos (:w_cursor @curwin), save_pos)
                )
                :else
                (do
                    (COPY-pos end_pos, (:w_cursor @curwin))
                ))

                (validate-cursor)
                ;; May redraw the status line to show the cursor position.
                (if (and @p_ru (< 0 (:w_status_height @curwin)))
                    ((ร @curwin.w_redr_status =) true)
                )

                (save-cmdline save_cli)
                (update-screen SOME_VALID)
                (restore-cmdline save_cli)

                ;; Leave it at the end to make CTRL-R CTRL-W work.
                (if (non-zero? i)
                    (COPY-pos (:w_cursor @curwin), end_pos))

                (msg-starthere)
                (redrawcmdline)
                ((ร did_incsearch =) true)
            )
        )

        (when did_incsearch
            (COPY-pos (:w_cursor @curwin), old_cursor)
            ((ร @curwin.w_curswant =) old_curswant)
            ((ร @curwin.w_leftcol =) old_leftcol)
            ((ร @curwin.w_topline =) old_topline)
            ((ร @curwin.w_botline =) old_botline)
            (reset! highlight_match false)
            (validate-cursor)      ;; needed for TAB
            (redraw-later SOME_VALID)
        )

        (when (non-nil? (:cmdbuff @ccline))
            ;; Put line in history buffer (":" and "=" only when it was typed).

            (when (and (non-zero? (:cmdlen @ccline)) (!= firstc NUL) (or some_key_typed (== histype HIST_SEARCH)))
                (add-to-history histype, (:cmdbuff @ccline), (if (== histype HIST_SEARCH) firstc NUL))
                (if (== firstc (byte \:))
                    (reset! new_last_cmdline (STRDUP (:cmdbuff @ccline))))
            )

            (when gotesc         ;; abandon command line
                ((ร @ccline.cmdbuff =) nil)
                (if (zero? @msg_scrolled)
                    (compute-cmdrow))
                (msg (u8 ""))
                (reset! redraw_cmdline true)
            )
        )

        ;; If the screen was shifted up, redraw the whole screen (later).
        ;; If the line is too long, clear it, so ruler and shown command
        ;; do not get printed in the middle of it.

        (msg-check)
        (reset! msg_scroll save_msg_scroll)

        ;; When the command line was typed, no need for a wait-return prompt.
        (if some_key_typed
            (reset! need_wait_return false))

        (reset! State save_State)
        (ui-cursor-shape)          ;; may show different cursor shape

        ((ร Bytes p =) (:cmdbuff @ccline))
        ;; Make ccline empty, getcmdline() may try to use it.
        ((ร @ccline.cmdbuff =) nil)
        p
    ))

;; Return true when the text must not be changed and we can't switch to
;; another window or buffer.  Used when editing the command line, etc.

(defn- #_boolean text-locked []
    (or (non-zero? @cmdwin_type) (non-zero? @textlock)))

;; Give an error message for a command that isn't allowed while the cmdline
;; window is open or editing the cmdline in another way.

(defn- #_void text-locked-msg []
    (emsg (if (non-zero? @cmdwin_type) e_cmdwin e_secure))
    nil)

(defn- #_int cmdline-charsize [#_int idx]
    (if (< 0 @cmdline_star)           ;; showing '*', always 1 position
        1
        (mb-ptr2cells (.plus (:cmdbuff @ccline) idx))
    ))

;; Compute the offset of the cursor on the command line for the prompt.

(defn- #_void set-cmdspos []
    (ยง
        ((ร @ccline.cmdspos =) (+ (if (!= (:cmdfirstc @ccline) NUL) 1 0) (:cmdindent @ccline)))
        nil
    ))

;; Compute the screen position for the cursor on the command line.

(defn- #_void set-cmdspos-cursor []
    (ยง
        (ร int i, m, c)

        (set-cmdspos)
        (cond @keyTyped
        (do
            ((ร m =) (* (int @Cols) (int @Rows)))
            (if (< m 0)      ;; overflow, Cols or Rows at weird value
                ((ร m =) MAXCOL)
            )
        )
        :else
        (do
            ((ร m =) MAXCOL)
        ))
        ((ร FOR) (ร ((ร i =) 0) (and (< i (:cmdlen @ccline)) (< i (:cmdpos @ccline))) (ร i++))
            ((ร c =) (cmdline-charsize i))
            ;; Count ">" for double-wide multi-byte char that doesn't fit.
            (correct-cmdspos i, c)
            ;; If the cmdline doesn't fit, show cursor on last visible char.
            ;; Don't move the cursor itself, so we can still append.
            (when (<= m ((ร @ccline.cmdspos =) (+ (:cmdspos @ccline) c)))
                ((ร @ccline.cmdspos =) (- (:cmdspos @ccline) c))
                (ร BREAK)
            )
            ((ร i =) (+ i (- (us-ptr2len-cc (.plus (:cmdbuff @ccline) i)) 1)))
        )
        nil
    ))

;; Check if the character at "idx", which is "cells" wide, is a multi-byte
;; character that doesn't fit, so that a ">" must be displayed.

(defn- #_void correct-cmdspos [#_int idx, #_int cells]
    (ยง
        (when (and (< 1 (us-ptr2len-cc (.plus (:cmdbuff @ccline) idx))) (< 1 (us-ptr2cells (.plus (:cmdbuff @ccline) idx))) (< (int @Cols) (+ (% (:cmdspos @ccline) (int @Cols)) cells)))
            (ร @ccline.cmdspos++)
        )
        nil
    ))

;; Get an Ex command line for the ":" command.

(defn- #_Bytes getexline []
    ;; When executing a register, remove ':' that's in front of each line.
    (if (and @exec_from_reg (== (vpeekc) (byte \:)))
        (vgetc))
    (getcmdline (byte \:), 1))

;; Allocate a new command line buffer.
;; Assigns the new buffer to ccline.cmdbuff and ccline.cmdbufflen.
;; Returns the new value of ccline.cmdbuff and ccline.cmdbufflen.

(defn- #_void alloc-cmdbuff [#_int len]
    (ยง
        ;; give some extra space to avoid having to allocate all the time

        (if (< len 80)
            ((ร len =) 100)
            ((ร len =) (+ len 20))
        )

        ((ร @ccline.cmdbuff =) (Bytes. len))
        ((ร @ccline.cmdbufflen =) len)
        nil
    ))

;; Re-allocate the command line to length len + something extra.

(defn- #_void realloc-cmdbuff [#_int len]
    (ยง
        (if (< len (:cmdbufflen @ccline))
            ((ร RETURN) nil)                             ;; no need to resize
        )

        ((ร Bytes p =) (:cmdbuff @ccline))
        (alloc-cmdbuff len)                     ;; will get some more
        ;; There isn't always a NUL after the command, but it may need to be there,
        ;; thus copy up to the NUL and add a NUL.
        (BCOPY (:cmdbuff @ccline), p, (:cmdlen @ccline))
        (.be (:cmdbuff @ccline) (:cmdlen @ccline), NUL)
        nil
    ))

;; Draw part of the cmdline at the current cursor position;
;; but draw stars when cmdline_star is true.

(defn- #_void draw-cmdline [#_int start, #_int len]
    (ยง
        (cond (< 0 @cmdline_star)
        (do
            ((ร FOR) (ร ((ร int i =) 0) (< i len) (ร i++))
                (msg-putchar (byte \*))
                ((ร i =) (+ i (- (us-ptr2len-cc (.plus (:cmdbuff @ccline) (+ start i))) 1)))
            )
        )
        :else
        (do
            (msg-outtrans-len (.plus (:cmdbuff @ccline) start), len)
        ))
        nil
    ))

;; Put a character on the command line.  Shifts the following text to the
;; right when "shift" is true.  Used for CTRL-V, CTRL-K, etc.
;; "c" must be printable (fit in one display cell)!

(defn- #_void putcmdline [#_int c, #_boolean shift]
    (reset! msg_no_more true)
    (msg-putchar c)
    (if shift (let [pos (:cmdpos @ccline) len (:cmdlen @ccline)]
        (draw-cmdline pos, (- len pos))))
    (reset! msg_no_more false)
    (cursorcmd)
    nil)

;; Undo a putcmdline(c, false).

(defn- #_void unputcmdline []
    (reset! msg_no_more true)
    (let [pos (:cmdpos @ccline) len (:cmdlen @ccline)]
        (if (== len pos)
            (msg-putchar (byte \space))
            (draw-cmdline pos, (us-ptr2len-cc (.plus (:cmdbuff @ccline) pos)))))
    (reset! msg_no_more false)
    (cursorcmd)
    nil)

;; Put the given string, of the given length, onto the command line.
;; If len is -1, then STRLEN() is used to calculate the length.
;; If 'redraw' is true then the new part of the command line, and the remaining part
;; will be redrawn, otherwise it will not.  If this function is called twice in a row,
;; then 'redraw' should be false and redrawcmd() should be called afterwards.

(defn- #_void put-on-cmdline [#_Bytes str, #_int len, #_boolean redraw]
    (ยง
        (if (< len 0)
            ((ร len =) (STRLEN str))
        )

        ;; Check if ccline.cmdbuff needs to be longer.
        (if (<= (:cmdbufflen @ccline) (+ (:cmdlen @ccline) len 1))
            (realloc-cmdbuff (+ (:cmdlen @ccline) len 1)))

        (cond (not (:overstrike @ccline))
        (do
            (BCOPY (:cmdbuff @ccline), (+ (:cmdpos @ccline) len), (:cmdbuff @ccline), (:cmdpos @ccline), (- (:cmdlen @ccline) (:cmdpos @ccline)))
            ((ร @ccline.cmdlen =) (+ (:cmdlen @ccline) len))
        )
        :else
        (do
            ;; Count nr of characters in the new string.
            ((ร int m =) (ร 0, n))
            ((ร FOR) (ร ((ร n =) 0) (< n len) ((ร n =) (+ n (us-ptr2len-cc (.plus str n)))))
                (ร m++)
            )
            ;; Count nr of bytes in cmdline that are overwritten by these characters.
            ((ร FOR) (ร ((ร n =) (:cmdpos @ccline)) (and (< n (:cmdlen @ccline)) (< 0 m)) ((ร n =) (+ n (us-ptr2len-cc (.plus (:cmdbuff @ccline) n)))))
                (ร --m)
            )
            (cond (< n (:cmdlen @ccline))
            (do
                (BCOPY (:cmdbuff @ccline), (+ (:cmdpos @ccline) len), (:cmdbuff @ccline), n, (- (:cmdlen @ccline) n))
                ((ร @ccline.cmdlen =) (+ (:cmdlen @ccline) (- (+ (:cmdpos @ccline) len) n)))
            )
            :else
            (do
                ((ร @ccline.cmdlen =) (+ (:cmdpos @ccline) len))
            ))
        ))
        (BCOPY (:cmdbuff @ccline), (:cmdpos @ccline), str, 0, len)
        (.be (:cmdbuff @ccline) (:cmdlen @ccline), NUL)

        ;; When the inserted text starts with a composing character,
        ;; backup to the character before it.  There could be two of them.

        ((ร int i =) 0)
        ((ร int c =) (us-ptr2char (.plus (:cmdbuff @ccline) (:cmdpos @ccline))))
        (while (and (< 0 (:cmdpos @ccline)) (utf-iscomposing c))
            ((ร i =) (+ (us-head-off (:cmdbuff @ccline), (.plus (:cmdbuff @ccline) (- (:cmdpos @ccline) 1))) 1))
            ((ร @ccline.cmdpos =) (- (:cmdpos @ccline) i))
            ((ร len =) (+ len i))
            ((ร c =) (us-ptr2char (.plus (:cmdbuff @ccline) (:cmdpos @ccline))))
        )
        (when (non-zero? i)
            ;; Also backup the cursor position.
            ((ร i =) (mb-ptr2cells (.plus (:cmdbuff @ccline) (:cmdpos @ccline))))
            ((ร @ccline.cmdspos =) (- (:cmdspos @ccline) i))
            ((ร @msg_col =) (- @msg_col i))
            (when (< @msg_col 0)
                ((ร @msg_col =) (+ @msg_col (int @Cols)))
                (swap! msg_row dec)
            )
        )

        (when redraw
            (reset! msg_no_more true)
            ((ร i =) @cmdline_row)
            (cursorcmd)
            (draw-cmdline (:cmdpos @ccline), (- (:cmdlen @ccline) (:cmdpos @ccline)))
            ;; Avoid clearing the rest of the line too often.
            (if (or (!= @cmdline_row i) (:overstrike @ccline))
                (msg-clr-eos))
            (reset! msg_no_more false)
        )

        (ร int m)
        (cond @keyTyped
        (do
            ((ร m =) (* (int @Cols) (int @Rows)))
            (if (< m 0)      ;; overflow, Cols or Rows at weird value
                ((ร m =) MAXCOL)
            )
        )
        :else
        (do
            ((ร m =) MAXCOL)
        ))

        ((ร FOR) (ร ((ร i =) 0) (< i len) (ร i++))
            ((ร c =) (cmdline-charsize (:cmdpos @ccline)))
            ;; count ">" for a double-wide char that doesn't fit.
            (correct-cmdspos (:cmdpos @ccline), c)
            ;; Stop cursor at the end of the screen, but do increment the insert position,
            ;; so that entering a very long command works, even though you can't see it.
            (if (< (+ (:cmdspos @ccline) c) m)
                ((ร @ccline.cmdspos =) (+ (:cmdspos @ccline) c))
            )

            ((ร c =) (- (us-ptr2len-cc (.plus (:cmdbuff @ccline) (:cmdpos @ccline))) 1))
            (if (> c (- len i 1))
                ((ร c =) (- len i 1))
            )
            ((ร @ccline.cmdpos =) (+ (:cmdpos @ccline) c))
            ((ร i =) (+ i c))

            (ร @ccline.cmdpos++)
        )

        (when redraw
            (msg-check)
        )
        nil
    ))

(atom! cmdline_info_C prev_ccline)

;; Save ccline, because obtaining the "=" register may execute "normal :cmd" and overwrite it.
;; But get_cmdline_str() may need it, thus make it available globally in prev_ccline.

(defn- #_void save-cmdline [#_cmdline_info_C cli]
    (ยง
        (if (nil? @prev_ccline)
            (reset! prev_ccline (NEW_cmdline_info_C)))

        (COPY-cmdline-info cli, @prev_ccline)
        (COPY-cmdline-info @prev_ccline, @ccline)

        ((ร @ccline.cmdbuff =) nil)
        ((ร @ccline.cmdprompt =) nil)
        nil
    ))

;; Restore ccline after it has been saved with save-cmdline().

(defn- #_void restore-cmdline [#_cmdline_info_C cli]
    (COPY-cmdline-info @ccline, @prev_ccline)
    (COPY-cmdline-info @prev_ccline, cli)
    nil)

;; Save the command line into allocated memory.
;; Returns a pointer to be passed to restore-cmdline-alloc() later.

(defn- #_cmdline_info_C save-cmdline-alloc []
    (ยง
        ((ร cmdline_info_C cli =) (NEW_cmdline_info_C))
        (save-cmdline cli)
        cli
    ))

;; Restore the command line from the return value of save-cmdline-alloc().

(defn- #_void restore-cmdline-alloc [#_cmdline_info_C cli]
    (when (non-nil? cli)
        (restore-cmdline cli)
    )
    nil)

;; Paste a yank register into the command line.
;; Used by CTRL-R command in command-line mode.
;; insert-reg() can't be used here, because special characters
;; from the register contents will be interpreted as commands.
;;
;; return false for failure, true otherwise

(defn- #_boolean cmdline-paste [#_int regname, #_boolean literally, #_boolean remcr]
    ;; literally: Insert text literally instead of "as typed"
    ;; remcr: remove trailing CR
    (ยง
        ;; check for valid regname; also accept special characters for CTRL-R in the command line
        (if (and (!= regname Ctrl_F) (!= regname Ctrl_P) (!= regname Ctrl_W) (!= regname Ctrl_A) (not (valid-yank-reg regname, false)))
            ((ร RETURN) false)
        )

        ;; A register containing CTRL-R can cause an endless loop.
        ;; Allow using CTRL-C to break the loop.
        (line-breakcheck)
        (if @got_int
            ((ร RETURN) false)
        )

        ((ร regname =) (may-get-selection regname))

        ;; Need to save and restore ccline.  And set "textlock" to avoid nasty
        ;; things like going to another buffer when evaluating an expression.
        ((ร cmdline_info_C save_cli =) (save-cmdline-alloc))
        (swap! textlock inc)

        ((ร Bytes[] arg =) (ร new Bytes[1]))
        ((ร boolean[] allocated =) (ร new boolean[1]))
        ((ร boolean got =) (get-spec-reg regname, arg, allocated, true))

        (swap! textlock dec)
        (restore-cmdline-alloc save_cli)

        (when got
            ;; Got the value of a special register in "arg".
            (if (nil? (... arg 0))
                ((ร RETURN) false)
            )

            ;; When 'incsearch' is set and CTRL-R CTRL-W used: skip the duplicate part of the word.
            ((ร Bytes p =) (... arg 0))

            (when (and @p_is (== regname Ctrl_W))
                ;; Locate start of last word in the cmd buffer.
                (ร Bytes w)
                ((ร FOR) (ร ((ร w =) (.plus (:cmdbuff @ccline) (:cmdpos @ccline))) (BLT (:cmdbuff @ccline), w) nil)
                    ((ร int len =) (+ (us-head-off (:cmdbuff @ccline), (.minus w 1)) 1))
                    (if (not (vim-iswordc (us-ptr2char (.minus w len)), @curbuf))
                        (ร BREAK)
                    )
                    ((ร w =) (.minus w len))
                )
                ((ร int len =) (BDIFF (.plus (:cmdbuff @ccline) (:cmdpos @ccline)), w))
                (if (if @p_ic (zero? (STRNCASECMP w, (... arg 0), len)) (zero? (STRNCMP w, (... arg 0), len)))
                    ((ร p =) (.plus p len))
                )
            )

            (cmdline-paste-str p, literally)

            ((ร RETURN) true)
        )

        (cmdline-paste-reg regname, literally, remcr)
    ))

;; Put a string on the command line.
;; When "literally" is true, insert literally.
;; When "literally" is false, insert as typed, but don't leave the command line.

(defn- #_void cmdline-paste-str [#_Bytes _s, #_boolean literally]
    (ยง
; %%    ((ร Bytes[] s =) (ร { _s }))
        (cond literally
        (do
            (put-on-cmdline (... s 0), -1, true)
        )
        :else
        (do
            (while (non-eos? (... s 0))
                ((ร int cv =) (.at (... s 0) 0))
                (if (and (== cv Ctrl_V) (non-eos? (... s 0) 1))
                    ((ร s[0] =) (.plus (... s 0) 1))
                )
                ((ร int c =) (us-ptr2char-adv s, false))
                (when (or (== cv Ctrl_V) (== c ESC) (== c Ctrl_C) (== c CAR) (== c NL) (== c Ctrl_L) (== c @intr_char) (and (== c Ctrl_BSL) (== (.at (... s 0) 0) Ctrl_N)))
                    (stuffcharReadbuff Ctrl_V)
                )
                (stuffcharReadbuff c)
            )
        ))
        nil
    ))

;; this function is called when the screen size changes and with incremental search

(defn- #_void redrawcmdline []
    (reset! need_wait_return false)
    (compute-cmdrow)
    (redrawcmd)
    (cursorcmd)
    nil)

(defn- #_void redrawcmdprompt []
    (ยง
        (if (!= (:cmdfirstc @ccline) NUL)
            (msg-putchar (:cmdfirstc @ccline)))
        (cond (non-nil? (:cmdprompt @ccline))
        (do
            (msg-puts-attr (:cmdprompt @ccline), (:cmdattr @ccline))
            ((ร @ccline.cmdindent =) (+ @msg_col (* (- @msg_row @cmdline_row) (int @Cols))))
            ;; do the reverse of set-cmdspos()
            (if (!= (:cmdfirstc @ccline) NUL)
                (ร --@ccline.cmdindent)
            )
        )
        :else
        (do
            ((ร FOR) (ร ((ร int i =) (:cmdindent @ccline)) (< 0 i) (ร --i))
                (msg-putchar (byte \space))
            )
        ))
        nil
    ))

;; Redraw what is currently on the command line.

(defn- #_void redrawcmd []
    (ยง
        ;; when 'incsearch' is set there may be no command line while redrawing
        (when (nil? (:cmdbuff @ccline))
            (windgoto @cmdline_row, 0)
            (msg-clr-eos)
            ((ร RETURN) nil)
        )

        (msg-start)
        (redrawcmdprompt)

        ;; Don't use more prompt, truncate the cmdline if it doesn't fit.
        (reset! msg_no_more true)
        (draw-cmdline 0, (:cmdlen @ccline))
        (msg-clr-eos)
        (reset! msg_no_more false)

        (set-cmdspos-cursor)

        ;; An emsg() before may have set msg_scroll.  This is used in normal mode,
        ;; in cmdline mode we can reset them now.

        (reset! msg_scroll false)         ;; next message overwrites cmdline

        ;; Typing ':' at the more prompt may set skip_redraw.  We don't want this in cmdline mode.
        (reset! skip_redraw false)
        nil
    ))

(defn- #_void compute-cmdrow []
    (reset! cmdline_row (if (non-zero? @msg_scrolled) (dec (int @Rows)) (+ (:w_winrow @lastwin) (:w_height @lastwin) (:w_status_height @lastwin))))
    nil)

(defn- #_void cursorcmd []
    (reset! msg_row (+ @cmdline_row (/ (:cmdspos @ccline) (int @Cols))))
    (reset! msg_col (% (:cmdspos @ccline) (int @Cols)))
    (if (<= @Rows @msg_row)
        (reset! msg_row (dec (int @Rows))))

    (windgoto @msg_row, @msg_col)
    nil)

(defn- #_void gotocmdline [#_boolean clr]
    (msg-start)
    (reset! msg_col 0)           ;; always start in column 0
    (if clr                ;; clear the bottom line(s)
        (msg-clr-eos))      ;; will reset clear_cmdline

    (windgoto @cmdline_row, 0)
    nil)

;; Command line history stuff

;; Translate a history character to the associated type number.

(defn- #_int hist-char2type [#_int c]
    (ยง
        (if (== c (byte \:))
            ((ร RETURN) HIST_CMD)
        )
        (if (== c (byte \=))
            ((ร RETURN) HIST_EXPR)
        )
        (if (== c (byte \@))
            ((ร RETURN) HIST_INPUT)
        )

        HIST_SEARCH     ;; must be '?' or '/'
    ))

;; init-history() - Initialize the command line history.
;; Also used to re-allocate the history when the size changes.

(defn- #_void init-history []
    (ยง
        ;; If size of history table changed, reallocate it.

        ((ร int newlen =) (int @p_hi))
        (when (!= newlen @hislen)                                   ;; history length changed
            (dotimes [#_int type HIST_COUNT]       ;; adjust the tables
                ((ร histentry_C[] temp =) nil)

                (if (non-zero? newlen)
                    ((ร temp =) (ARRAY-histentry newlen))
                )

                (when (or (zero? newlen) (non-nil? temp))
                    (cond (< (... @hisidx type) 0)                       ;; there are no entries yet
                    (do
                        (dotimes [#_int i newlen]
                            (clear-hist-entry (... temp i))
                        )
                    )
                    (< @hislen newlen)                   ;; array becomes bigger
                    (do
                        (ร int i)
                        ((ร FOR) (ร ((ร i =) 0) (<= i (... @hisidx type)) (ร i++))
                            (COPY-histentry (... temp i), (... (... @history type) i))
                        )
                        ((ร int j =) i)
                        ((ร FOR) (ร nil (<= i (- newlen (- @hislen (... @hisidx type)))) (ร i++))
                            (clear-hist-entry (... temp i))
                        )
                        ((ร FOR) (ร nil (< j @hislen) (ร i++, j++))
                            (COPY-histentry (... temp i), (... (... @history type) j))
                        )
                    )
                    :else                                        ;; array becomes smaller or 0
                    (do
                        ((ร int j =) (... @hisidx type))
                        ((ร FOR) (ร ((ร int i =) (dec newlen)) true (ร --i))
                            (if (<= 0 i)
                                (COPY-histentry (... temp i), (... (... @history type) j))      ;; copy newest entries
                                ((ร @history[type][j].hisstr =) nil)                    ;; remove older entries
                            )
                            (if (< (ร --j) 0)
                                ((ร j =) (dec @hislen))
                            )
                            (if (== j (... @hisidx type))
                                (ร BREAK)
                            )
                        )
                        ((ร @hisidx[type] =) (dec newlen))
                    ))
                    ((ร @history[type] =) temp)
                )
            )
            (reset! hislen newlen)
        )
        nil
    ))

(defn- #_void clear-hist-entry [#_histentry_C hisptr]
    (ยง
        ((ร hisptr.hisnum =) 0)
        ((ร hisptr.hisstr =) nil)
        nil
    ))

;; Check if command line 'str' is already in history.
;; If 'move_to_front' is true, matching entry is moved to end of history.

(defn- #_boolean in-history [#_int type, #_Bytes str, #_boolean move_to_front, #_int sep]
    ;; move_to_front: Move the entry to the front if it exists
    (ยง
        (if (< (... @hisidx type) 0)
            ((ร RETURN) false)
        )

        ((ร int last_i =) -1)

        ((ร int i =) (... @hisidx type))
;       do
;       {
            (if (nil? (:hisstr (... (... @history type) i)))
                ((ร RETURN) false)
            )

            ;; For search history, check that the separator character matches as well.
            ((ร Bytes p =) (:hisstr (... (... @history type) i)))
            (when (and (zero? (STRCMP str, p)) (or (!= type HIST_SEARCH) (== sep (.at p (+ (STRLEN p) 1)))))
                (if (not move_to_front)
                    ((ร RETURN) true)
                )
                ((ร last_i =) i)
                (ร BREAK)
            )
            (if (< (ร --i) 0)
                ((ร i =) (dec @hislen))
            )
;       } while (i != @hisidx[type]);

        (when (<= 0 last_i)
            ((ร str =) (:hisstr (... (... @history type) i)))
            (while (!= i (... @hisidx type))
                (if (<= @hislen (ร ++i))
                    ((ร i =) 0)
                )
                (COPY-histentry (... (... @history type) last_i), (... (... @history type) i))
                ((ร last_i =) i)
            )
            ((ร @history[type][i].hisnum =) (ร ++@hisnum[type]))
            ((ร @history[type][i].hisstr =) str)
            ((ร RETURN) true)
        )

        false
    ))

(atom! int      last_maptick -1)      ;; last seen maptick

;; Add the given string to the given history.  If the string is already in the
;; history then it is moved to the front.  "histype" may be one of he HIST_ values.

(defn- #_void add-to-history [#_int histype, #_Bytes new_entry, #_int sep]
    ;; sep: separator character used (search hist)
    (ยง
        (if (zero? @hislen)            ;; no history
            ((ร RETURN) nil)
        )

        ;; Searches inside the same mapping overwrite each other, so that only
        ;; the last line is kept.  Be careful not to remove a line that was moved
        ;; down, only lines that were added.

        (when (== histype HIST_SEARCH)
            (when (== @maptick @last_maptick)
                ;; Current line is from the same mapping, remove it.
                ((ร histentry_C hisptr =) (... (... @history HIST_SEARCH) (... @hisidx HIST_SEARCH)))
                ((ร hisptr.hisstr =) nil)
                (clear-hist-entry hisptr)
                (ร --@hisnum[histype])
                (if (< (ร --@hisidx[HIST_SEARCH]) 0)
                    ((ร @hisidx[HIST_SEARCH] =) (dec @hislen))
                )
            )
            (reset! last_maptick -1)
        )

        (when (not (in-history histype, new_entry, true, sep))
            (if (== (ร ++@hisidx[histype]) @hislen)
                ((ร @hisidx[histype] =) 0)
            )

            ((ร histentry_C hisptr =) (... (... @history histype) (... @hisidx histype)))

            ;; Store the separator after the NUL of the string.
            ((ร int len =) (STRLEN new_entry))
            ((ร hisptr.hisstr =) (STRNDUP new_entry, (+ len 2)))
;           hisptr.hisstr.be(len + 1, sep);

            ((ร hisptr.hisnum =) (ร ++@hisnum[histype]))
            (if (== histype HIST_SEARCH)
                (reset! last_maptick @maptick))
        )
        nil
    ))

;; Open a window on the current command line and history.
;; Allow editing in the window.  When the window is closed,
;; returns:
;;      CR       if the command is to be executed
;;      Ctrl_C   if it is to be abandoned
;;      K_IGNORE if editing continues

(defn- #_int ex-window []
    (beep-flush)
    K_IGNORE)

;; ex_docmd.c: functions for executing an Ex command line -----------------------------------------

(atom! int      quitmore)
(atom! boolean  ex_pressedreturn)

;;; ============================================================================================== VimI

;; This file defines the Ex commands.
;;
;; When adding an Ex command:
;; 1. Add an entry in the table below.  Keep it sorted on the shortest
;;    version of the command name that works.  If it doesn't start with a
;;    lower case letter, add it at the end.
;; 2. Add a "case: CMD_xxx" in the big switch in ex_docmd.c.

;; This array maps ex command names to command codes.
;; The order in which command names are listed below is significant --
;; ambiguous abbreviations are always resolved to be the first possible match
;; (e.g. "r" is taken to mean "read", not "rewind", because "read" comes before "rewind").
;; Not supported commands are included to avoid ambiguities.

(class! #_final cmdname_C
    [
        (field Bytes        cmd_name)       ;; name of the command
        (field ex_func_F    cmd_func)       ;; function for this command
        (field long         cmd_argt)       ;; flags declared above
        (field int          cmd_addr_type)  ;; flag for address type
    ])

;; ----------------------------------------------------------------------- ;;

;; Execute a simple command line.  Used for translated commands like "*".

(defn- #_boolean do-cmdline-cmd [#_Bytes cmd]
    (do-cmdline cmd, false, (| DOCMD_VERBOSE DOCMD_NOWAIT DOCMD_KEYTYPED)))

(atom! int _0_recurse)              ;; recursive depth

;; do-cmdline(): execute one Ex command line
;;
;; 1. Execute "cmdline" when it is not null.
;;    If "cmdline" is null, or more lines are needed, getexline() is used.
;; 2. Split up in parts separated with '|'.
;;
;; This function can be called recursively!
;;
;; flags:
;; DOCMD_VERBOSE  - The command will be included in the error message.
;; DOCMD_NOWAIT   - Don't call wait-return() and friends.
;; DOCMD_KEYTYPED - Don't reset keyTyped.
;; DOCMD_KEEPLINE - Store first typed line (for repeating with ".").
;;
;; return false if cmdline could not be executed, true otherwise

(defn- #_boolean do-cmdline [#_Bytes cmdline, #_boolean use_getline, #_int flags]
    (ยง
        ((ร boolean retval =) true)

        ((ร boolean used_getline =) false)               ;; used getexline() to obtain command

        ((ร boolean msg_didout_before_start =) false)
        ((ร int count =) 0)                              ;; line number count
        ((ร boolean did_inc =) false)                    ;; incremented redrawingDisabled

        ;; "did_emsg" will be set to true when emsg() is used,
        ;; in which case we cancel the whole command line, and any if/endif or loop.

        (reset! did_emsg false)

        ;; keyTyped is only set when calling vgetc().
        ;; Reset it here when not calling vgetc() (sourced command lines).

        (if (and (non-flag? flags DOCMD_KEYTYPED) (not use_getline))
            (reset! keyTyped false))

; %%    ((ร Bytes[] cmdline_copy =) (ร { null }))                ;; copy of cmd line

        ;; Continue executing command lines:
        ;; - when inside an ":if", ":while" or ":for"
        ;; - for multiple commands on one line, separated with '|'
        ;; - when repeating until there are no more lines (for ":source")

        ((ร Bytes next_cmdline =) cmdline)
;       do
;       {
            ;; stop skipping cmds for an error msg after all endif/while/for
            (if (nil? next_cmdline)
                (reset! did_emsg false))

            ;; 2. If no line given, get an allocated line with getexline().
            (cond (nil? next_cmdline)
            (do
                ;; Need to set msg_didout for the first line after an ":if",
                ;; otherwise the ":if" will be overwritten.

                (if (and (== count 1) use_getline)
                    (reset! msg_didout true))
                (when (or (not use_getline) (nil? ((ร next_cmdline =) (getexline))))
                    ;; Don't call wait-return for aborted command line.  The null
                    ;; returned for the end of a sourced file or executed function
                    ;; doesn't do this.
                    (if @keyTyped
                        (reset! need_wait_return false))
                    ((ร retval =) false)
                    (ร BREAK)
                )
                ((ร used_getline =) true)

                ;; Keep the first typed line.  Clear it when more lines are typed.

                (when (flag? flags DOCMD_KEEPLINE)
                    (if (zero? count)
                        (reset! repeat_cmdline (STRDUP next_cmdline))
                        (reset! repeat_cmdline nil))
                )
            )

            ;; 3. Make a copy of the command so we can mess with it.
            (nil? (... cmdline_copy 0))
            (do
                ((ร next_cmdline =) (STRDUP next_cmdline))
            ))
            ((ร cmdline_copy[0] =) next_cmdline)

            (when (zero? (ร count++))
                ;; All output from the commands is put below each other, without waiting for a return.
                ;; Don't do this when executing commands from a script or when being called recursive
                ;; (e.g. for ":e +command file").

                (when (and (non-flag? flags DOCMD_NOWAIT) (zero? @_0_recurse))
                    ((ร msg_didout_before_start =) @msg_didout)
                    (reset! msg_didany false) ;; no output yet
                    (msg-start)
                    (reset! msg_scroll true)  ;; put messages below each other
                    (swap! no_wait_return inc)   ;; don't wait for return until finished
                    (swap! redrawingDisabled inc)
                    ((ร did_inc =) true)
                )
            )

            ;; 2. Execute one '|' separated command.
            ;;    do-one-cmd() will return null if there is no trailing '|'.
            ;;    "cmdline_copy" can change, e.g. for '%' and '#' expansion.

            (swap! _0_recurse inc)
            ((ร next_cmdline =) (do-one-cmd cmdline_copy, (flag? flags DOCMD_VERBOSE)))
            (swap! _0_recurse dec)

            (cond (nil? next_cmdline)
            (do
                ((ร cmdline_copy[0] =) nil)

                ;; If the command was typed, remember it for the ':' register.
                ;; Do this AFTER executing the command to make :@: work.

                (when (and use_getline (non-nil? @new_last_cmdline))
                    (reset! last_cmdline @new_last_cmdline)
                    (reset! new_last_cmdline nil)
                )
            )
            :else
            (do
                ;; Need to copy the command after the '|' to 'cmdline_copy',
                ;; for the next do-one-cmd().
                (BCOPY (... cmdline_copy 0), next_cmdline, (+ (STRLEN next_cmdline) 1))
                ((ร next_cmdline =) (... cmdline_copy 0))
            ))
;       }

        ;; Continue executing command lines when:
        ;; - no CTRL-C typed, no aborting error, no exception thrown or try conditionals need
        ;;   to be checked for executing finally clauses or catching an interrupt exception
        ;; - didn't get an error message or lines are not typed
        ;; - there is a command after '|', inside a :if, :while, :for or :try, or looping
        ;;   for ":source" command or function call.

        (while (and (not @got_int) (not (and @did_emsg used_getline use_getline)) (non-nil? next_cmdline))
;           ;
        )

        (reset! did_emsg_syntax false)

        ;; If there was too much output to fit on the command line, ask the user to
        ;; hit return before redrawing the screen.  With the ":global" command we do
        ;; this only once after the command is finished.

        (when did_inc
            (swap! redrawingDisabled dec)
            (swap! no_wait_return dec)
            (reset! msg_scroll false)

            ;; When just finished an ":if"-":else" which was typed, no need to
            ;; wait for hit-return.  Also for an error situation.

            (cond (not retval)
            (do
                (reset! need_wait_return false)
                (reset! msg_didany false)         ;; don't wait when restarting edit
            )
            @need_wait_return
            (do
                ;; The msg-start() above clears msg_didout.  The wait-return we do here
                ;; should not overwrite the command that may be shown before doing that.

                ((ร @msg_didout =) (| @msg_didout msg_didout_before_start))
                (wait-return FALSE)
            ))
        )

        retval
    ))

(defn- #_int current-win-nr [#_window_C win]
    (ยง
        ((ร int nr =) 0)

        ((ร FOR) (ร ((ร window_C wp =) @firstwin) (non-nil? wp) ((ร wp =) (:w_next wp)))
            (ร nr++)
            (if (== wp win)
                (ร BREAK)
            )
        )

        nr
    ))

;; Execute one Ex command.
;;
;; If 'verbose' is true, the command will be included in the error message.
;;
;; 1. skip comment lines and leading space
;; 2. handle command modifiers
;; 3. find the command
;; 4. parse range
;; 5. parse the command
;; 6. parse arguments
;; 7. switch on command name
;;
;; This function may be called recursively!

(defn- #_Bytes do-one-cmd [#_Bytes* cmdlinep, #_boolean verbose]
    (ยง
        ((ร Bytes errormsg =) nil)         ;; error message
        ((ร boolean save_msg_scroll =) @msg_scroll)
        ((ร int did_esilent =) 0)

        ((ร exarg_C ea =) (NEW_exarg_C))     ;; Ex command arguments
        ((ร ea.line1 =) 1)
        ((ร ea.line2 =) 1)

        ;; When the last file has not been edited :q has to be typed twice.
        (if (non-zero? @quitmore)
            (swap! quitmore dec))

;       doend:
;       {
            ;; "#!anything" is handled like a comment.
            (if (and (== (.at (... cmdlinep 0) 0) (byte \#)) (== (.at (... cmdlinep 0) 1) (byte \!)))
                (ร BREAK doend)
            )

            ;; Repeat until no more command modifiers are found.

            ((ร ea.cmd =) (... cmdlinep 0))
            (while true
                ;; 1. Skip comment lines and leading white space and colons.

                (while (or (== (.at (:cmd ea) 0) (byte \space)) (== (.at (:cmd ea) 0) TAB) (== (.at (:cmd ea) 0) (byte \:)))
                    ((ร ea.cmd =) (.plus (:cmd ea) 1))
                )

                ;; ignore comment and empty lines
                (if (== (.at (:cmd ea) 0) (byte \")) ;; """
                    (ร BREAK doend)
                )
                (when (eos? (:cmd ea))
                    (reset! ex_pressedreturn true)
                    (ร BREAK doend)
                )

                ;; 2. Handle command modifiers.

; %%            ((ร Bytes[] p =) (ร { (ea.cmd) }))
                (if (asc-isdigit (.at (... p 0) 0))
                    ((ร p[0] =) (skipwhite (skipdigits (... p 0))))
                )
                ((ร SWITCH) (.at (... p 0) 0)
;                   
                )
                (ร BREAK)
            )

            ((ร ea.skip =) (or @did_emsg @got_int))

            ;; 3. Skip over the range to find the command.  Let "p" point to after it.
            ;;
            ;; We need the command to know what kind of range it uses.

            ((ร Bytes cmd =) (:cmd ea))
            ((ร ea.cmd =) (skip-range (:cmd ea)))
            (if (== (.at (:cmd ea) 0) (byte \*))
                ((ร ea.cmd =) (skipwhite (.plus (:cmd ea) 1)))
            )

            ((ร Bytes p =) (find-command ea))

            ;; 4. parse a range specifier of the form: addr [,addr] [;addr] ..
            ;;
            ;; where 'addr' is:
            ;;
            ;; %          (entire file)
            ;; $  [+-NUM]
            ;; 'x [+-NUM] (where x denotes a currently defined mark)
            ;; .  [+-NUM]
            ;; [+-NUM]..
            ;; NUM
            ;;
            ;; The ea.cmd pointer is updated to point to the first character following the range spec.
            ;; If an initial address is found, but no second, the upper bound is equal to the lower.

            ((ร ea.addr_type =) (if (!= (:cmdidx ea) CMD_SIZE) (:cmd_addr_type (... cmdnames (:cmdidx ea))) ADDR_LINES))

            (ร long lnum)

            ;; repeat for all ',' or ';' separated addresses
            ((ร ea.cmd =) cmd)
            (while true
                ((ร ea.line1 =) (:line2 ea))
                ((ร SWITCH) (:addr_type ea)
                    ((ร CASE) ADDR_LINES)
                    (do
                        ;; default is current line number
                        ((ร ea.line2 =) (:lnum (:w_cursor @curwin)))
                        (ร BREAK)
                    )

                    ((ร CASE) ADDR_WINDOWS)
                    (do
                        ((ร lnum =) (current-win-nr @curwin))
                        ((ร ea.line2 =) lnum)
                        (ร BREAK)
                    )
                )
                ((ร ea.cmd =) (skipwhite (:cmd ea)))
;               { Bytes[] __ = { ea.cmd }; lnum = get-address(__, ea.addr_type, ea.skip, ea.addr_count == 0); ea.cmd = __[0]; }
                (if (nil? (:cmd ea))                 ;; error detected
                    (ร BREAK doend)
                )
                (cond (== lnum MAXLNUM)
                (do
                    (cond (== (.at (:cmd ea) 0) (byte \%))          ;; '%' - all lines
                    (do
                        ((ร ea.cmd =) (.plus (:cmd ea) 1))
                        ((ร SWITCH) (:addr_type ea)
                            ((ร CASE) ADDR_LINES)
                            (do
                                ((ร ea.line1 =) 1)
                                ((ร ea.line2 =) (:ml_line_count (:b_ml @curbuf)))
                                (ร BREAK)
                            )

                            ((ร CASE) ADDR_WINDOWS)
                            (do
                                ;; There is no Vim command which uses '%' and ADDR_WINDOWS.
                                ((ร errormsg =) e_invrange)
                                (ร BREAK doend)
                            )
                        )
                        (ร ea.addr_count++)
                    )
                    (== (.at (:cmd ea) 0) (byte \*))     ;; '*' - visual area
                    (do
                        (when (!= (:addr_type ea) ADDR_LINES)
                            ((ร errormsg =) e_invrange)
                            (ร BREAK doend)
                        )

                        ((ร ea.cmd =) (.plus (:cmd ea) 1))
                        (when (not (:skip ea))
                            ((ร pos_C fp =) (getmark (byte \<), false))
                            (if (not (check-mark fp))
                                (ร BREAK doend)
                            )
                            ((ร ea.line1 =) (:lnum fp))
                            ((ร fp =) (getmark (byte \>), false))
                            (if (not (check-mark fp))
                                (ร BREAK doend)
                            )
                            ((ร ea.line2 =) (:lnum fp))
                            (ร ea.addr_count++)
                        )
                    ))
                )
                :else
                (do
                    ((ร ea.line2 =) lnum)
                ))
                (ร ea.addr_count++)

                (cond (== (.at (:cmd ea) 0) (byte \;))
                (do
                    (if (not (:skip ea))
                        ((ร @curwin.w_cursor.lnum =) (:line2 ea))
                    )
                )
                (!= (.at (:cmd ea) 0) (byte \,))
                (do
                    (ร BREAK)
                ))
                ((ร ea.cmd =) (.plus (:cmd ea) 1))
            )

            ;; One address given: set start and end lines.
            (when (== (:addr_count ea) 1)
                ((ร ea.line1 =) (:line2 ea))
                ;; ... but only implicit: really no address given
                (if (== lnum MAXLNUM)
                    ((ร ea.addr_count =) 0)
                )
            )

            ;; Don't leave the cursor on an illegal line (caused by ';').
            (check-cursor-lnum)

            ;; 5. Parse the command.

            ;; Skip ':' and any white space

            ((ร ea.cmd =) (skipwhite (:cmd ea)))
            (while (== (.at (:cmd ea) 0) (byte \:))
                ((ร ea.cmd =) (skipwhite (.plus (:cmd ea) 1)))
            )

            ;; If we got a line, but no command, then go to the line.
            ;; If we find a '|' or '\n' we set ea.nextcmd.

            (when (or (eos? (:cmd ea)) (== (.at (:cmd ea) 0) (byte \")) (non-nil? ((ร ea.nextcmd =) (check-nextcmd (:cmd ea)))))  ;; """
                ;; strange vi behaviour:
                ;; ":3"         jumps to line 3
                ;; ":3|..."     prints line 3
                ;; ":|"         prints current line

                (if (:skip ea)    ;; skip this if inside :if
                    (ร BREAK doend)
                )
                (cond (== (.at (:cmd ea) 0) (byte \|))
                (do
                    ((ร ea.cmdidx =) (ร CMD_print))
                    ((ร ea.argt =) (+ RANGE COUNT))
                    (when (nil? ((ร errormsg =) (invalid-range ea)))
                        (correct-range ea)
;                       ex_print(ea);
                    )
                )
                (non-zero? (:addr_count ea))
                (do
                    (when (< (:ml_line_count (:b_ml @curbuf)) (:line2 ea))
                        ;; With '-' in 'cpoptions' a line number past the file is an error,
                        ;; otherwise put it at the end of the file.
                        ((ร ea.line2 =) (if (non-nil? (vim-strbyte @p_cpo, CPO_MINUS)) -1 (:ml_line_count (:b_ml @curbuf))))
                    )

                    (cond (< (:line2 ea) 0)
                    (do
                        ((ร errormsg =) e_invrange)
                    )
                    :else
                    (do
                        ((ร @curwin.w_cursor.lnum =) (if (zero? (:line2 ea)) 1 (:line2 ea)))
                        (beginline (| BL_SOL BL_FIX))
                    ))
                ))
                (ร BREAK doend)
            )

            (when (nil? p)
                (if (not (:skip ea))
                    ((ร errormsg =) (u8 "E464: Ambiguous use of user-defined command"))
                )
                (ร BREAK doend)
            )

            (when (== (:cmdidx ea) CMD_SIZE)
                (when (not (:skip ea))
                    (STRCPY @ioBuff, (u8 "E492: Not an editor command"))
                    (if (not verbose)
                        (append-command (... cmdlinep 0)))
                    ((ร errormsg =) @ioBuff)
                    (reset! did_emsg_syntax true)
                )
                (ร BREAK doend)
            )

            ;; forced commands
            (cond (and (== (.at p 0) (byte \!)) (!= (:cmdidx ea) CMD_substitute))
            (do
                ((ร p =) (.plus p 1))
                ((ร ea.forceit =) true)
            )
            :else
            (do
                ((ร ea.forceit =) false)
            ))

            ;; 6. Parse arguments.

            ((ร ea.argt =) (:cmd_argt (... cmdnames (:cmdidx ea))))

            (when (not (:skip ea))
                (when (and (text-locked) (non-flag? (:argt ea) CMDWIN))
                    ;; Command not allowed when editing the command line.
                    ((ร errormsg =) (if (non-zero? @cmdwin_type) e_cmdwin e_secure))
                    (ร BREAK doend)
                )

                (when (and (non-flag? (:argt ea) RANGE) (< 0 (:addr_count ea)))
                    ;; no range allowed
                    ((ร errormsg =) e_norange)
                    (ร BREAK doend)
                )
            )

            (when (and (non-flag? (:argt ea) BANG) (:forceit ea)) ;; no <!> allowed
                ((ร errormsg =) e_nobang)
                (ร BREAK doend)
            )

            ;; Don't complain about the range if it is not used
            ;; (could happen if line_count is accidentally set to 0).

            (when (not (:skip ea))
                ;; If the range is backwards, ask for confirmation and, if given,
                ;; swap ea.line1 & ea.line2 so it's forwards again.

                (when (< (:line2 ea) (:line1 ea))
                    (when verbose
                        ((ร errormsg =) (u8 "E493: Backwards range given"))
                        (ร BREAK doend)
                    )
                    (if (!= (ask-yesno (u8 "Backwards range given, OK to swap"), false) (byte \y))
                        (ร BREAK doend)
                    )

                    ((ร lnum =) (:line1 ea))
                    ((ร ea.line1 =) (:line2 ea))
                    ((ร ea.line2 =) lnum)
                )
                (if (non-nil? ((ร errormsg =) (invalid-range ea)))
                    (ร BREAK doend)
                )
            )

            (if (and (flag? (:argt ea) NOTADR) (zero? (:addr_count ea))) ;; default is 1, not cursor
                ((ร ea.line2 =) 1)
            )

            (correct-range ea)

            ;; Skip to start of argument.

            ((ร ea.arg =) (skipwhite p))

            (when (and (flag? (:argt ea) DFLALL) (zero? (:addr_count ea)))
                ((ร ea.line1 =) 1)
                ((ร SWITCH) (:addr_type ea)
                    ((ร CASE) ADDR_LINES)
                    (do
                        ((ร ea.line2 =) (:ml_line_count (:b_ml @curbuf)))
                        (ร BREAK)
                    )

                    ((ร CASE) ADDR_WINDOWS)
                    (do
                        ((ร ea.line2 =) (current-win-nr nil))
                        (ร BREAK)
                    )
                )
            )

            ;; Check for a count.

            (when (and (flag? (:argt ea) COUNT) (asc-isdigit (.at (:arg ea) 0)))
                (ร long n)
;               { Bytes[] __ = { ea.arg }; n = getdigits(__); ea.arg = __[0]; }
                ((ร ea.arg =) (skipwhite (:arg ea)))
                (when (and (<= n 0) (non-flag? (:argt ea) ZEROR))
                    ((ร errormsg =) e_zerocount)
                    (ร BREAK doend)
                )
                (cond (flag? (:argt ea) NOTADR)    ;; e.g. :buffer 2, :sleep 3
                (do
                    ((ร ea.line2 =) n)
                    (if (zero? (:addr_count ea))
                        ((ร ea.addr_count =) 1)
                    )
                )
                :else
                (do
                    ((ร ea.line1 =) (:line2 ea))
                    ((ร ea.line2 =) (+ (:line2 ea) (dec n)))
                    (ร ea.addr_count++)

                    ;; Be vi compatible: no error message for out of range.

                    (if (> (:line2 ea) (:ml_line_count (:b_ml @curbuf)))
                        ((ร ea.line2 =) (:ml_line_count (:b_ml @curbuf)))
                    )
                ))
            )

            (when (and (non-flag? (:argt ea) EXTRA) (non-eos? (:arg ea)) (!= (.at (:arg ea) 0) (byte \"))) ;; """
                ((ร errormsg =) e_trailing)
                (ร BREAK doend)
            )

            (when (and (flag? (:argt ea) NEEDARG) (eos? (:arg ea)))
                ((ร errormsg =) e_argreq)
                (ร BREAK doend)
            )

            ;; Skip the command when it's not going to be executed.
            ;; The commands like :if, :endif, etc. always need to be executed.
            ;; Also make an exception for commands that handle a trailing command themselves.

            (when (:skip ea)
                ((ร SWITCH) (:cmdidx ea)
                    ;; Commands that handle '|' themselves.  Check: A command should
                    ;; either have the TRLBAR flag, appear in this list or appear in
                    ;; the list at ":help :bar".
                    ((ร CASE) CMD_substitute)
                    (do
                        (ร BREAK)
                    )

                    (ร DEFAULT)
                    (do
                        (ร BREAK doend)
                    )
                )
            )

            ;; 7. Switch on command name.
            ;;
            ;; The "ea" structure holds the arguments that can be used.

            ((ร ea.cmdlinep =) cmdlinep)

            ;; Call the function to execute the command.

            ((ร ea.errmsg =) nil)
;           cmdnames[ea.cmdidx].cmd_func(ea);
            (if (non-nil? (:errmsg ea))
                ((ร errormsg =) (:errmsg ea))
            )
;       }

        (if (zero? (:lnum (:w_cursor @curwin)))  ;; can happen with zero line number
            ((ร @curwin.w_cursor.lnum =) 1)
        )

        (when (and (non-nil? errormsg) (non-eos? errormsg) (not @did_emsg))
            (when verbose
                (when (BNE errormsg, @ioBuff)
                    (STRCPY @ioBuff, errormsg)
                    ((ร errormsg =) @ioBuff)
                )
                (append-command (... cmdlinep 0))
            )
            (emsg errormsg)
        )

        (if (and (non-nil? (:nextcmd ea)) (eos? (:nextcmd ea)))      ;; not really a next command
            ((ร ea.nextcmd =) nil)
        )

        (:nextcmd ea)
    ))

;; Append "cmd" to the error message in ioBuff.
;; Takes care of limiting the length and handling 0xa0,
;; which would be invisible otherwise.

(defn- #_void append-command [#_Bytes cmd]
    (ยง
        (STRCAT @ioBuff, (u8 ": "))

        ((ร Bytes d =) (.plus @ioBuff (STRLEN @ioBuff)))
        ((ร FOR) (ร ((ร Bytes s =) cmd) (and (non-eos? s) (< (BDIFF d, @ioBuff) (- IOSIZE 7))) nil)
            (cond (and (== (char_u (.at s 0)) 0xc2) (== (char_u (.at s 1)) 0xa0))
            (do
                ((ร s =) (.plus s 2))
                (STRCPY d, (u8 "<a0>"))
                ((ร d =) (.plus d 4))
            )
            :else
            (do
                ((ร int len =) (us-ptr2len-cc s))
                (BCOPY d, s, len)
                ((ร d =) (.plus d len))
                ((ร s =) (.plus s len))
            ))
        )
        (eos! d)
        nil
    ))

;; Find an Ex command by its name, either built-in or user.
;; Start of the name can be found at eap.cmd.
;; Returns pointer to char after the command name.
;; Returns null for an ambiguous user command.

(defn- #_Bytes find-command [#_exarg_C eap]
    (ยง
        ;; Isolate the command and search for it in the command table.
        ;; Exceptions:
        ;; - the 's' command can be followed directly by 'c', 'g', 'i', 'I' or 'r',
        ;;      but :sre[wind] is another command, as are :scr[iptnames], :scs[cope], :sim[alt], :sig[ns] and :sil[ent].

        ((ร Bytes p =) (:cmd eap))
        (cond (and (== (.at p 0) (byte \s)) (or (and (== (.at p 1) (byte \c)) (!= (.at p 2) (byte \s)) (!= (.at p 2) (byte \r)) (!= (.at p 3) (byte \i)) (!= (.at p 4) (byte \p))) (== (.at p 1) (byte \g)) (and (== (.at p 1) (byte \i)) (!= (.at p 2) (byte \m)) (!= (.at p 2) (byte \l)) (!= (.at p 2) (byte \g))) (== (.at p 1) (byte \I)) (and (== (.at p 1) (byte \r)) (!= (.at p 2) (byte \e)))))
        (do
            ((ร eap.cmdidx =) CMD_substitute)
            ((ร p =) (.plus p 1))
        )
        :else
        (do
            (while (asc-isalpha (.at p 0))
                ((ร p =) (.plus p 1))
            )

            ;; check for non-alpha command
            (if (and (BEQ p, (:cmd eap)) (non-nil? (vim-strbyte (u8 "@*!=><&~#"), (.at p 0))))
                ((ร p =) (.plus p 1))
            )

            ((ร int len =) (BDIFF p, (:cmd eap)))

            ((ร FOR) (ร ((ร eap.cmdidx =) 0) (< (:cmdidx eap) CMD_SIZE) (ร eap.cmdidx++))
                (if (zero? (STRNCMP (:cmd_name (... cmdnames (:cmdidx eap))), (:cmd eap), len))
                    (ร BREAK)
                )
            )

            ;; Look for a user defined command as a last resort.
            (when (and (== (:cmdidx eap) CMD_SIZE) (<= (byte \A) (.at (:cmd eap) 0)) (<= (.at (:cmd eap) 0) (byte \Z)))
                ;; User defined commands may contain digits.
                (while (asc-isalnum (.at p 0))
                    ((ร p =) (.plus p 1))
                )
            )

            (if (BEQ p, (:cmd eap))
                ((ร eap.cmdidx =) CMD_SIZE)
            )
        ))

        p
    ))

;; skip a range specifier of the form: addr [,addr] [;addr] ..
;;
;; Backslashed delimiters after / or ? will be skipped, and commands will
;; not be expanded between /'s and ?'s or after "'".
;;
;; Also skip white space and ":" characters.
;; Returns the "cmd" pointer advanced to beyond the range.

(defn- #_Bytes skip-range [#_Bytes cmd]
    (ยง
        (while (non-nil? (vim-strbyte (u8 " \t0123456789.$%'/?-+,;"), (.at cmd 0)))
            (cond (== (.at cmd 0) (byte \'))
            (do
                ((ร cmd =) (.plus cmd 1))
            )
            (or (== (.at cmd 0) (byte \/)) (== (.at cmd 0) (byte \?)))
            (do
                ((ร byte delim =) (.at ((ร cmd =) (.plus cmd 1)) -1))
                (while (and (non-eos? cmd) (!= (.at cmd 0) delim))
                    (if (and (== (.at ((ร cmd =) (.plus cmd 1)) -1) (byte \\)) (non-eos? cmd))
                        ((ร cmd =) (.plus cmd 1))
                    )
                )
            ))
            (if (non-eos? cmd)
                ((ร cmd =) (.plus cmd 1))
            )
        )

        ;; Skip ":" and white space.
        (while (== (.at cmd 0) (byte \:))
            ((ร cmd =) (skipwhite (.plus cmd 1)))
        )

        cmd
    ))

;; get a single EX address
;;
;; Set ptr to the next character after the part that was interpreted.
;; Set ptr to null when an error is encountered.
;;
;; Return MAXLNUM when no Ex address was found.

(defn- #_long get-address [#_Bytes* ptr, #_int addr_type, #_boolean skip, #_boolean to_other_file]
    ;; addr_type: flag: one of ADDR_LINES, ...
    ;; skip: only skip the address, don't use it
    ;; to_other_file: flag: may jump to other file
    (ยง
        ((ร long lnum =) MAXLNUM)
        ((ร Bytes cmd =) (skipwhite (... ptr 0)))

;       error:
;       do
;       {
            ((ร SWITCH) (.at cmd 0)
                ((ร CASE) (byte \.))                       ;; '.' - Cursor position
                (do
                    ((ร cmd =) (.plus cmd 1))
                    ((ร SWITCH) addr_type
                        ((ร CASE) ADDR_LINES)
                        (do
                            ((ร lnum =) (:lnum (:w_cursor @curwin)))
                            (ร BREAK)
                        )

                        ((ร CASE) ADDR_WINDOWS)
                        (do
                            ((ร lnum =) (current-win-nr @curwin))
                            (ร BREAK)
                        )
                    )
                    (ร BREAK)
                )

                ((ร CASE) (byte \$))                       ;; '$' - last line
                (do
                    ((ร cmd =) (.plus cmd 1))
                    ((ร SWITCH) addr_type
                        ((ร CASE) ADDR_LINES)
                        (do
                            ((ร lnum =) (:ml_line_count (:b_ml @curbuf)))
                            (ร BREAK)
                        )

                        ((ร CASE) ADDR_WINDOWS)
                        (do
                            ((ร lnum =) (current-win-nr nil))
                            (ร BREAK)
                        )
                    )
                    (ร BREAK)
                )

                ((ร CASE) (byte \'))                      ;; ''' - mark
                (do
                    (when (== (.at ((ร cmd =) (.plus cmd 1)) 0) NUL)
                        ((ร cmd =) nil)
                        (ร BREAK error)
                    )
                    (when (!= addr_type ADDR_LINES)
                        (emsg e_invaddr)
                        ((ร cmd =) nil)
                        (ร BREAK error)
                    )
                    (cond skip
                    (do
                        ((ร cmd =) (.plus cmd 1))
                    )
                    :else
                    (do
                        ;; Only accept a mark in another file when it is used by itself: ":'M".
                        ((ร pos_C fp =) (getmark (.at cmd 0), (and to_other_file (eos? cmd 1))))
                        ((ร cmd =) (.plus cmd 1))
                        (cond (== fp NOPOS)
                        (do
                            ;; Jumped to another file.
                            ((ร lnum =) (:lnum (:w_cursor @curwin)))
                        )
                        :else
                        (do
                            (when (not (check-mark fp))
                                ((ร cmd =) nil)
                                (ร BREAK error)
                            )
                            ((ร lnum =) (:lnum fp))
                        ))
                    ))
                    (ร BREAK)
                )

                ((ร CASE) (byte \/))
                ((ร CASE) (byte \?))                   ;; '/' or '?' - search
                (do
                    ((ร byte c =) (.at ((ร cmd =) (.plus cmd 1)) -1))
                    (when (!= addr_type ADDR_LINES)
                        (emsg e_invaddr)
                        ((ร cmd =) nil)
                        (ร BREAK error)
                    )
                    (cond skip       ;; skip "/pat/"
                    (do
                        ((ร cmd =) (skip-regexp cmd, c, @p_magic, nil))
                        (if (== (.at cmd 0) c)
                            ((ร cmd =) (.plus cmd 1))
                        )
                    )
                    :else
                    (do
                        ((ร pos_C save_pos =) (NEW_pos_C))
                        (COPY-pos save_pos, (:w_cursor @curwin))

                        ;; When '/' or '?' follows another address, start from there.

                        (if (!= lnum MAXLNUM)
                            ((ร @curwin.w_cursor.lnum =) lnum)
                        )

                        ;; Start a forward search at the end of the line.
                        ;; Start a backward search at the start of the line.
                        ;; This makes sure we never match in the current line,
                        ;; and can match anywhere in the next/previous line.

                        ((ร @curwin.w_cursor.col =) (if (== c (byte \/)) MAXCOL 0))
                        (reset! searchcmdlen 0)
                        (when (zero? (do-search nil, c, cmd, 1, (| SEARCH_HIS SEARCH_MSG), nil))
                            (COPY-pos (:w_cursor @curwin), save_pos)
                            ((ร cmd =) nil)
                            (ร BREAK error)
                        )
                        ((ร lnum =) (:lnum (:w_cursor @curwin)))
                        (COPY-pos (:w_cursor @curwin), save_pos)
                        ;; adjust command string pointer
                        ((ร cmd =) (.plus cmd @searchcmdlen))
                    ))
                    (ร BREAK)
                )

                ((ร CASE) (byte \\))              ;; "\?", "\/" or "\&", repeat search
                (do
                    ((ร cmd =) (.plus cmd 1))
                    (when (!= addr_type ADDR_LINES)
                        (emsg e_invaddr)
                        ((ร cmd =) nil)
                        (ร BREAK error)
                    )
                    (ร int i)
                    (cond (== (.at cmd 0) (byte \&))
                    (do
                        ((ร i =) RE_SUBST)
                    )
                    (or (== (.at cmd 0) (byte \?)) (== (.at cmd 0) (byte \/)))
                    (do
                        ((ร i =) RE_SEARCH)
                    )
                    :else
                    (do
                        (emsg e_backslash)
                        ((ร cmd =) nil)
                        (ร BREAK error)
                    ))

                    (when (not skip)
                        ((ร pos_C pos =) (NEW_pos_C))

                        ;; When search follows another address, start from there.

                        ((ร pos.lnum =) (if (!= lnum MAXLNUM) lnum (:lnum (:w_cursor @curwin))))

                        ;; Start the search just like for the above do-search().

                        ((ร pos.col =) (if (!= (.at cmd 0) (byte \?)) MAXCOL 0))

                        (cond (!= (searchit @curwin, @curbuf, pos, (if (== (.at cmd 0) (byte \?)) BACKWARD FORWARD), (u8 ""), 1, SEARCH_MSG, i, 0, nil) 0)
                        (do
                            ((ร lnum =) (:lnum pos))
                        )
                        :else
                        (do
                            ((ร cmd =) nil)
                            (ร BREAK error)
                        ))
                    )
                    ((ร cmd =) (.plus cmd 1))
                    (ร BREAK)
                )

                (ร DEFAULT)
                (do
                    (when (asc-isdigit (.at cmd 0))     ;; absolute line number
;                       Bytes[] __ = { cmd }; lnum = getdigits(__); cmd = __[0];
                    )
                    (ร BREAK)
                )
            )

            (while true
                ((ร cmd =) (skipwhite cmd))
                (if (and (!= (.at cmd 0) (byte \-)) (!= (.at cmd 0) (byte \+)) (not (asc-isdigit (.at cmd 0))))
                    (ร BREAK)
                )

                (when (== lnum MAXLNUM)
                    ((ร SWITCH) addr_type
                        ((ร CASE) ADDR_LINES)
                        (do
                            ;; "+1" is same as ".+1"
                            ((ร lnum =) (:lnum (:w_cursor @curwin)))
                            (ร BREAK)
                        )

                        ((ร CASE) ADDR_WINDOWS)
                        (do
                            ((ร lnum =) (current-win-nr @curwin))
                            (ร BREAK)
                        )
                    )
                )

                ((ร int m =) (if (asc-isdigit (.at cmd 0))
                    (byte \+)                    ;; "number" is same as "+number"
                    (.at ((ร cmd =) (.plus cmd 1)) -1)
                ))
                (ร int n)
                (cond (not (asc-isdigit (.at cmd 0)))    ;; '+' is '+1', but '+0' is not '+1'
                (do
                    ((ร n =) 1)
                )
                :else
                (do
;                   Bytes[] __ = { cmd }; n = (int)getdigits(__); cmd = __[0];
                ))
                (if (== m (byte \-))
                    ((ร lnum =) (- lnum n))
                    ((ร lnum =) (+ lnum n))
                )
            )
;       } while (cmd.at(0) == (byte \/) || cmd.at(0) == (byte \?));

        ((ร ptr[0] =) cmd)
        lnum
    ))

;; Check range in Ex command for validity.
;; Return null when valid, error message when invalid.

(defn- #_Bytes invalid-range [#_exarg_C eap]
    (ยง
        (if (or (< (:line1 eap) 0) (< (:line2 eap) 0) (< (:line2 eap) (:line1 eap)))
            ((ร RETURN) e_invrange)
        )

        (when (flag? (:argt eap) RANGE)
            ((ร SWITCH) (:addr_type eap)
                ((ร CASE) ADDR_LINES)
                (do
                    (if (and (non-flag? (:argt eap) NOTADR) (< (:ml_line_count (:b_ml @curbuf)) (:line2 eap)))
                        ((ร RETURN) e_invrange)
                    )
                    (ร BREAK)
                )

                ((ร CASE) ADDR_WINDOWS)
                (do
                    (if (< (current-win-nr nil) (:line2 eap))
                        ((ร RETURN) e_invrange)
                    )
                    (ร BREAK)
                )
            )
        )

        nil
    ))

;; Correct the range for zero line number, if required.

(defn- #_void correct-range [#_exarg_C eap]
    (ยง
        (when (non-flag? (:argt eap) ZEROR)    ;; zero in range not allowed
            (if (zero? (:line1 eap))
                ((ร eap.line1 =) 1)
            )
            (if (zero? (:line2 eap))
                ((ร eap.line2 =) 1)
            )
        )
        nil
    ))

;; Check if *p is a separator between Ex commands.
;; Return null if it isn't, (p + 1) if it is.

(defn- #_Bytes check-nextcmd [#_Bytes p]
    (let [p (skipwhite p)]
        (if (or (== (.at p 0) (byte \|)) (== (.at p 0) (byte \newline))) (.plus p 1) nil)
    ))

;; ":close": close current window, unless it is the last one

(defn- #_void ex-close [#_exarg_C eap]
    (ยง
        (cond (non-zero? @cmdwin_type)
        (do
            (reset! cmdwin_result Ctrl_C)
        )
        (not (text-locked))
        (do
            (cond (zero? (:addr_count eap))
            (do
                (ex-win-close (:forceit eap), @curwin)
            )
            :else
            (do
                (ร window_C win)
                ((ร int winnr =) 0)
                ((ร FOR) (ร ((ร win =) @firstwin) (non-nil? win) ((ร win =) (:w_next win)))
                    (if (== (ร ++winnr) (:line2 eap))
                        (ร BREAK)
                    )
                )
                (if (nil? win)
                    ((ร win =) @lastwin)
                )
                (ex-win-close (:forceit eap), win)
            ))
        ))
        nil
    ))

;; Close window "win" and take care of handling closing the last window for a modified buffer.

(defn- #_void ex-win-close [#_boolean forceit, #_window_C win]
    (ยง
        ((ร buffer_C buf =) @curbuf)

        ((ร boolean need_hide =) (and @(:b_changed buf) (<= (:b_nwindows buf) 1)))
        (when (and need_hide (not forceit))
            (emsg e_nowrtmsg)
            ((ร RETURN) nil)
        )

        (win-close win, (not need_hide))
        nil
    ))

;; ":only".

(defn- #_void ex-only [#_exarg_C eap]
    (ยง
        (when (< 0 (:addr_count eap))
            ((ร int wnr =) (int (:line2 eap)))
            (ร window_C wp)
            ((ร FOR) (ร ((ร wp =) @firstwin) (< 0 (ร --wnr)) nil)
                (if (nil? (:w_next wp))
                    (ร BREAK)
                    ((ร wp =) (:w_next wp))
                )
            )
            (win-goto wp)
        )

        (close-others true, (:forceit eap))
        nil
    ))

;; ":stop" and ":suspend": Suspend Vim.

(defn- #_void ex-stop [#_exarg_C eap]
    (windgoto (dec (int @Rows)), 0)
    (out-char (byte \newline))
    (out-flush)
    (stoptermcap)
    (out-flush)            ;; needed for SUN to restore xterm buffer
    (ui-suspend)           ;; call machine specific function
    (starttermcap)
    (scroll-start)         ;; scroll screen before redrawing
    (redraw-later-clear)
    (shell-resized)        ;; may have resized window
    nil)

;; ":syncbind" forces all 'scrollbind' windows to have the same relative offset.

(defn- #_void ex-syncbind [#_exarg_C _eap]
    (ยง
        ((ร window_C save_curwin =) @curwin)
        ((ร long old_linenr =) (:lnum (:w_cursor @curwin)))

        (setpcmark)

        (ร long topline)
        ;; determine max topline
        (cond @(:wo_scb (:w_options @curwin))
        (do
            ((ร topline =) (:w_topline @curwin))
            ((ร FOR) (ร ((ร window_C wp =) @firstwin) (non-nil? wp) ((ร wp =) (:w_next wp)))
                (when @(:wo_scb (:w_options wp))
                    ((ร long y =) (- (:ml_line_count (:b_ml @curbuf)) @p_so))
                    (if (< y topline)
                        ((ร topline =) y)
                    )
                )
            )
            (if (< topline 1)
                ((ร topline =) 1)
            )
        )
        :else
        (do
            ((ร topline =) 1)
        ))

        ;; Set all scrollbind windows to the same topline.

        ((ร FOR) (ร ((ร @curwin =) @firstwin) (non-nil? @curwin) ((ร @curwin =) (:w_next @curwin)))
            (when @(:wo_scb (:w_options @curwin))
                ((ร long y =) (- topline (:w_topline @curwin)))
                (if (< 0 y)
                    (scrollup y)
                    (scrolldown (- y)))
                ((ร @curwin.w_scbind_pos =) topline)
                (redraw-later VALID)
                (cursor-correct)
                ((ร @curwin.w_redr_status =) true)
            )
        )
        (reset! curwin save_curwin)
        (when @(:wo_scb (:w_options @curwin))
            (reset! did_syncbind true)
            (checkpcmark)
            (when (!= old_linenr (:lnum (:w_cursor @curwin)))
                ((ร Bytes ctrl_o =) (Bytes. 2))

                (.be ctrl_o 0, Ctrl_O)
                (eos! ctrl_o 1)

                (ins-typebuf ctrl_o)
            )
        )
        nil
    ))

;; Sleep for "msec" milliseconds, but keep checking for a CTRL-C every second.

(defn- #_void do-sleep [#_long msec]
    (ยง
        (cursor-on)
        (out-flush)
        ((ร FOR) (ร ((ร long done =) 0) (and (not @got_int) (< done msec)) ((ร done =) (+ done 1000)))
            (ui-delay (if (< 1000 (- msec done)) 1000 (- msec done)), true)
            (ui-breakcheck)
        )
        nil
    ))

;; ":set"

(defn- #_void ex-set [#_exarg_C eap]
    (do-set (:arg eap))
    nil)

;;; ============================================================================================== VimJ

;; eval.c: Expression evaluation ------------------------------------------------------------------

;; Top level evaluation function, returning a string.

(defn- #_Bytes eval-to-string [#_Bytes arg, #_Bytes* nextcmd]
    ;; %% not yet
    nil)

;; Return the time 'msec' past now.

(defn- #_long profile-setlimit [#_long msec]
    (if (< 0 msec)
        (+ (System/nanoTime) (* msec 1000 1000))
        0)) ;; no limit

;; Return true if the current time is past 'nsec'.

(defn- #_boolean profile-passed-limit [#_long nsec]
    (if (zero? nsec) ;; timer was not set
        false
        (< nsec (System/nanoTime))))

;; Return true if the buffer "buf" can be abandoned, either by making it
;; hidden, autowriting it or unloading it.

(defn- #_boolean can-abandon [#_buffer_C buf, #_boolean forceit]
    (or (not @(:b_changed buf)) (< 1 (:b_nwindows buf)) forceit))

;;; ============================================================================================== VimK

;; normal.c ---------------------------------------------------------------------------------------
;; Contains the main routine for processing characters in command mode.
;; Communicates closely with the code in ops.c to handle the operators.

;; The Visual area is remembered for reselection.

(atom! int      resel_VIsual_mode       NUL)    ;; 'v', 'V', or Ctrl-V
(atom! long     resel_VIsual_line_count)        ;; number of lines
(atom! int      resel_VIsual_vcol)              ;; nr of cols or end col
(atom! int      VIsual_mode_orig        NUL)    ;; saved Visual mode

(atom! int      restart_VIsual_select)

;; nv_*(): functions called to handle Normal and Visual mode commands.
;; n_*(): functions called to handle Normal mode commands.
;; v_*(): functions called to handle Visual mode commands.

(final Bytes e_noident (u8 "E349: No identifier under cursor"))

;; Values for cmd_flags.
(final int NV_NCH      0x01)            ;; may need to get a second char
(final int NV_NCH_NOP  (| 0x02 NV_NCH))   ;; get second char when no operator pending
(final int NV_NCH_ALW  (| 0x04 NV_NCH))   ;; always get a second char
(final int NV_LANG     0x08)            ;; second char needs language adjustment

(final int NV_SS       0x10)            ;; may start selection
(final int NV_SSS      0x20)            ;; may start selection with shift modifier
(final int NV_STS      0x40)            ;; may stop selection without shift modif.
(final int NV_RL       0x80)            ;; 'rightleft' modifies command
(final int NV_KEEPREG  0x100)           ;; don't clear regname
(final int NV_NCW      0x200)           ;; not allowed in command-line window

;; Generally speaking, every Normal mode command should either clear any
;; pending operator (with *clearop*()), or set the motion type variable
;; oap.motion_type.
;;
;; When a cursor motion command is made, it is marked as being a character or
;; line oriented motion.  Then, if an operator is in effect, the operation
;; becomes character or line oriented accordingly.

;; Function to be called for a Normal or Visual mode command.
;; The argument is a cmdarg_C.

(class! #_final nv_cmd_C
    [
        (field int          cmd_char)           ;; (first) command character
        (field nv_func_F    cmd_func)           ;; function for this command
        (field int          cmd_flags)          ;; NV_ flags
        (field int          cmd_arg)            ;; value for ca.arg
    ])

;; Search for a command in the commands table.
;; Returns -1 for invalid command.

(defn- #_int find--command [#_int cmdchar]
    (ยง
        ;; A multi-byte character is never a command.
        (if (<= 0x100 cmdchar)
            ((ร RETURN) -1)
        )

;       %% return nv_cmds index for cmd_char or -1
    ))

;; Execute a command in Normal mode.

(defn- #_void normal-cmd [#_oparg_C oap, #_boolean toplevel]
    ;; toplevel: true when called from main()
    (ยง
        ((ร int old_col =) (:w_curswant @curwin))

        ((ร cmdarg_C ca =) (NEW_cmdarg_C))   ;; command arguments
        ((ร ca.oap =) oap)

        ;; Use a count remembered from before entering an operator.
        ;; After typing "3d" we return from normal-cmd() and come back here,
        ;; the "3" is remembered in "opcount".
        ((ร ca.opcount =) @opcount)

        ;; If there is an operator pending, then the command we take this time
        ;; will terminate it.  finish_op tells us to finish the operation before
        ;; returning this time (unless the operation was cancelled).

        ((ร boolean save_finish_op =) @finish_op)
        (reset! finish_op (!= (:op_type oap) OP_NOP))
        (when (!= @finish_op save_finish_op)
            (ui-cursor-shape)              ;; may show different cursor shape
        )

        ;; When not finishing an operator and no register name typed, reset the count.
        (when (and (not @finish_op) (zero? (:regname oap)))
            ((ร ca.opcount =) 0)
        )

        ;; Restore counts from before receiving K_CURSORHOLD.
        ;; This means after typing "3", handling K_CURSORHOLD
        ;; and then typing "2" we get "32", not "3 * 2".
        (when (or (< 0 (:prev_opcount oap)) (< 0 (:prev_count0 oap)))
            ((ร ca.opcount =) (:prev_opcount oap))
            ((ร ca.count0 =) (:prev_count0 oap))
            ((ร oap.prev_opcount =) 0)
            ((ร oap.prev_count0 =) 0)
        )

        (reset! State NORMAL_BUSY)

        ;; Get the command character from the user.

        ((ร int c =) (safe-vgetc))

        (if (== c NUL)
            ((ร c =) K_ZERO)
        )

        ;; In Select mode, typed text replaces the selection.

        (when (and @VIsual_active @VIsual_select (or (vim-isprintc c) (== c NL) (== c CAR) (== c K_KENTER)))
            ;; Fake a "c"hange command.
            ;; When "restart_edit" is set (e.g., because 'insertmode' is set)
            ;; fake a "d"elete command, Insert mode will restart automatically.
            ;; Insert the typed character in the typeahead buffer, so it can be
            ;; mapped in Insert mode.  Required for ":lmap" to work.
            (ins-char-typebuf c)
            ((ร c =) (if (non-zero? @restart_edit) (byte \d) (byte \c)))
            (reset! msg_nowait true)      ;; don't delay going to insert mode
        )

        ((ร boolean need_flushbuf =) (add-to-showcmd c))      ;; need to call out-flush()
        ((ร boolean ctrl_w =) false)                         ;; got CTRL-W command

;       getcount:
        (while true
            (when (not (and @VIsual_active @VIsual_select))
                ;; Handle a count before a command and compute ca.count0.
                ;; Note that '0' is a command and not the start of a count,
                ;; but it's part of a count after other digits.

                (while (or (<= (byte \1) c (byte \9)) (and (!= (:count0 ca) 0) (or (== c K_DEL) (== c K_KDEL) (== c (byte \0)))))
                    (cond (or (== c K_DEL) (== c K_KDEL))
                    (do
                        ((ร ca.count0 =) (/ (:count0 ca) 10))
                        (del-from-showcmd 4)    ;; delete the digit and ~@%
                    )
                    :else
                    (do
                        ((ร ca.count0 =) (+ (* (:count0 ca) 10) (- c (byte \0))))
                    ))
                    (if (< (:count0 ca) 0)          ;; got too large!
                        ((ร ca.count0 =) 999999999)
                    )

                    (when ctrl_w
                        (swap! no_mapping inc)
                        (swap! allow_keys inc)           ;; no mapping for nchar, but keys
                    )
                    ((ร c =) (plain-vgetc))
                    (when ctrl_w
                        (swap! no_mapping dec)
                        (swap! allow_keys dec)
                    )
                    ((ร need_flushbuf =) (| need_flushbuf (add-to-showcmd c)))
                )

                ;; If we got CTRL-W there may be a/another count

                (when (and (== c Ctrl_W) (not ctrl_w) (== (:op_type oap) OP_NOP))
                    ((ร ctrl_w =) true)
                    ((ร ca.opcount =) (:count0 ca))     ;; remember first count
                    ((ร ca.count0 =) 0)
                    (swap! no_mapping inc)
                    (swap! allow_keys inc)               ;; no mapping for nchar, but keys
                    ((ร c =) (plain-vgetc))          ;; get next character
                    (swap! no_mapping dec)
                    (swap! allow_keys dec)
                    ((ร need_flushbuf =) (| need_flushbuf (add-to-showcmd c)))
                    (ร CONTINUE getcount)              ;; jump back
                )
            )

            (ร BREAK)
        )

        (cond (== c K_CURSORHOLD)
        (do
            ;; Save the count values so that ca.opcount and ca.count0 are exactly
            ;; the same when coming back here after handling K_CURSORHOLD.
            ((ร oap.prev_opcount =) (:opcount ca))
            ((ร oap.prev_count0 =) (:count0 ca))
        )
        (non-zero? (:opcount ca))
        (do
            ;; If we're in the middle of an operator (including after entering a
            ;; yank buffer with '"') AND we had a count before the operator, then
            ;; that count overrides the current value of ca.count0.
            ;; What this means effectively, is that commands like "3dw" get turned
            ;; into "d3w" which makes things fall into place pretty neatly.
            ;; If you give a count before AND after the operator, they are multiplied.

            (if (non-zero? (:count0 ca))
                ((ร ca.count0 =) (* (:count0 ca) (:opcount ca)))
                ((ร ca.count0 =) (:opcount ca))
            )
        ))

        ;; Always remember the count.
        ;; It will be set to zero (on the next call, above) when there is no pending operator.
        ;; When called from main(), save the count for use by the "count" built-in variable.

        ((ร ca.opcount =) (:count0 ca))
        ((ร ca.count1 =) (if (zero? (:count0 ca)) 1 (:count0 ca)))

        ;; Find the command character in the table of commands.
        ;; For CTRL-W we already got nchar when looking for a count.

        (cond ctrl_w
        (do
            ((ร ca.@nchar =) c)
            ((ร ca.cmdchar =) Ctrl_W)
        )
        :else
        (do
            ((ร ca.cmdchar =) c)
        ))

;       normal_end:
;       {
            ((ร int idx =) (find--command (:cmdchar ca)))
            (when (< idx 0)
                ;; Not a known command: beep.
                (clearopbeep oap)
                (ร BREAK normal_end)
            )

            (when (and (text-locked) (non-zero? (& (:cmd_flags (... nv_cmds idx)) NV_NCW)))
                ;; This command is not allowed while editing a cmdline: beep.
                (clearopbeep oap)
                (text-locked-msg)
                (ร BREAK normal_end)
            )

            ;; In Visual/Select mode, a few keys are handled in a special way.

            (when @VIsual_active
                ;; when 'keymodel' contains "stopsel" may stop Select/Visual mode
                (when (and @km_stopsel (non-zero? (& (:cmd_flags (... nv_cmds idx)) NV_STS)) (non-flag? @mod_mask MOD_MASK_SHIFT))
                    (end-visual-mode)
                    (redraw-curbuf-later INVERTED)
                )

                ;; Keys that work different when 'keymodel' contains "startsel".
                (when @km_startsel
                    (cond (non-zero? (& (:cmd_flags (... nv_cmds idx)) NV_SS))
                    (do
                        (unshift-special ca)
                        ((ร idx =) (find--command (:cmdchar ca)))
                        (when (< idx 0)
                            ;; Just in case.
                            (clearopbeep oap)
                            (ร BREAK normal_end)
                        )
                    )
                    (and (non-zero? (& (:cmd_flags (... nv_cmds idx)) NV_SSS)) (flag? @mod_mask MOD_MASK_SHIFT))
                    (do
                        ((ร @mod_mask =) (& @mod_mask (bit-not MOD_MASK_SHIFT)))
                    ))
                )
            )

            ;; Get an additional character if we need one.

            (when (and (!= (& (:cmd_flags (... nv_cmds idx)) NV_NCH) 0) (or (and (== (& (:cmd_flags (... nv_cmds idx)) NV_NCH_NOP) NV_NCH_NOP) (== (:op_type oap) OP_NOP)) (== (& (:cmd_flags (... nv_cmds idx)) NV_NCH_ALW) NV_NCH_ALW) (and (== (:cmdchar ca) (byte \q)) (== (:op_type oap) OP_NOP) (not @Recording) (not @execReg)) (and (or (== (:cmdchar ca) (byte \a)) (== (:cmdchar ca) (byte \i))) (or (!= (:op_type oap) OP_NOP) @VIsual_active))))
                ((ร boolean repl =) false)                   ;; get character for replace mode
                ((ร boolean lit =) false)                    ;; get extra character literally

                (swap! no_mapping inc)
                (swap! allow_keys inc)                           ;; no mapping for nchar, but allow key codes
                ;; Don't generate a CursorHold event here,
                ;; most commands can't handle it, e.g. nv-replace(), nv-csearch().
                (reset! did_cursorhold true)
                (ร int[] cp)
                (cond (== (:cmdchar ca) (byte \g))
                (do
                    ;; For 'g' get the next character now, so that we can check for "gr", "g'" and "g`".

                    ((ร ca.@nchar =) (plain-vgetc))
                    ((ร need_flushbuf =) (| need_flushbuf (add-to-showcmd @(:nchar ca))))
                    (cond (or (== @(:nchar ca) (byte \r)) (== @(:nchar ca) (byte \')) (== @(:nchar ca) (byte \`)) (== @(:nchar ca) Ctrl_BSL))
                    (do
                        ((ร cp =) (:extra_char ca))            ;; need to get a third character
                        (if (!= @(:nchar ca) (byte \r))
                            ((ร lit =) true)                 ;; get it literally
                            ((ร repl =) true)                ;; get it in replace mode
                        )
                    )
                    :else
                    (do
                        ((ร cp =) nil)                      ;; no third character needed
                    ))
                )
                :else
                (do
                    (if (== (:cmdchar ca) (byte \r))              ;; get it in replace mode
                        ((ร repl =) true)
                    )
                    ((ร cp =) (:nchar ca))
                ))

                ((ร boolean lang =) (or repl (!= (& (:cmd_flags (... nv_cmds idx)) NV_LANG) 0)))

                ;; Get a second or third character.

                (when (non-nil? cp)
                    (when repl
                        (reset! State REPLACE)                ;; pretend Replace mode
                        (ui-cursor-shape)              ;; show different cursor shape
                    )

                    ((ร cp[0] =) (plain-vgetc))

                    (reset! State NORMAL_BUSY)
                    ((ร need_flushbuf =) (| need_flushbuf (add-to-showcmd (... cp 0))))

                    (when (not lit)
                        ;; Typing CTRL-K gets a digraph.
                        (when (and (== (... cp 0) Ctrl_K) (or (non-zero? (& (:cmd_flags (... nv_cmds idx)) NV_LANG)) (== cp (:extra_char ca))) (nil? (vim-strbyte @p_cpo, CPO_DIGRAPH)))
                            ((ร c =) (get-digraph false))
                            (when (< 0 c)
                                ((ร cp[0] =) c)
                                ;; Guessing how to update showcmd here...
                                (del-from-showcmd 3)
                                ((ร need_flushbuf =) (| need_flushbuf (add-to-showcmd (... cp 0))))
                            )
                        )
                    )

                    ;; When the next character is CTRL-\ a following CTRL-N means
                    ;; the command is aborted and we go to Normal mode.

                    (cond (and (== cp (:extra_char ca)) (== @(:nchar ca) Ctrl_BSL) (or (== @(:extra_char ca) Ctrl_N) (== @(:extra_char ca) Ctrl_G)))
                    (do
                        ((ร ca.cmdchar =) Ctrl_BSL)
                        ((ร ca.@nchar =) @(:extra_char ca))
                        ((ร idx =) (find--command (:cmdchar ca)))
                    )
                    (and (or (== @(:nchar ca) (byte \n)) (== @(:nchar ca) (byte \N))) (== (:cmdchar ca) (byte \g)))
                    (do
                        ((ร ca.oap.op_type =) (get-op-type (... cp 0), NUL))
                    )
                    (== (... cp 0) Ctrl_BSL)
                    (do
                        ((ร long towait =) (if (<= 0 @p_ttm) @p_ttm @p_tm))

                        ;; There is a busy wait here when typing "f<C-\>" and then
                        ;; something different from CTRL-N.  Can't be avoided.
                        (while (and (<= ((ร c =) (vpeekc)) 0) (< 0 towait))
                            (do-sleep (if (< 50 towait) 50 towait))
                            ((ร towait =) (- towait 50))
                        )
                        (when (< 0 c)
                            ((ร c =) (plain-vgetc))
                            (cond (and (!= c Ctrl_N) (!= c Ctrl_G))
                            (do
                                (vungetc c)
                            )
                            :else
                            (do
                                ((ร ca.cmdchar =) Ctrl_BSL)
                                ((ร ca.@nchar =) c)
                                ((ร idx =) (find--command (:cmdchar ca)))
                            ))
                        )
                    ))

                    ;; When getting a text character and the next character is a multi-byte character,
                    ;; it could be a composing character.  However, don't wait for it to arrive.
                    ;; Also, do enable mapping, because if it's put back with vungetc() it's too late
                    ;; to apply mapping.
                    (swap! no_mapping dec)
                    (while (and lang (< 0 ((ร c =) (vpeekc))) (or (<= 0x100 c) (< 1 (mb-byte2len (vpeekc)))))
                        ((ร c =) (plain-vgetc))
                        (cond (not (utf-iscomposing c))
                        (do
                            (vungetc c)         ;; it wasn't, put it back
                            (ร BREAK)
                        )
                        (zero? (:ncharC1 ca))
                        (do
                            ((ร ca.ncharC1 =) c)
                        )
                        :else
                        (do
                            ((ร ca.ncharC2 =) c)
                        ))
                    )
                    (swap! no_mapping inc)
                )
                (swap! no_mapping dec)
                (swap! allow_keys dec)
            )

            ;; Flush the showcmd characters onto the screen so we can see them while the command
            ;; is being executed.  Only do this when the shown command was actually displayed,
            ;; otherwise this will slow down a lot when executing mappings.

            (if need_flushbuf
                (out-flush))
            (if (!= (:cmdchar ca) K_IGNORE)
                (reset! did_cursorhold false))

            (reset! State NORMAL)

            (when (== @(:nchar ca) ESC)
                (clearop oap)
                (if (and (zero? @restart_edit) (goto-im))
                    (reset! restart_edit (byte \a)))
                (ร BREAK normal_end)
            )

            (when (!= (:cmdchar ca) K_IGNORE)
                (reset! msg_didout false)         ;; don't scroll screen up for normal command
                (reset! msg_col 0)
            )

            ((ร pos_C old_pos =) (NEW_pos_C))
            (COPY-pos old_pos, (:w_cursor @curwin))     ;; remember where cursor was

            ;; When 'keymodel' contains "startsel" some keys start Select/Visual mode.
            (when (and (not @VIsual_active) @km_startsel)
                (cond (non-zero? (& (:cmd_flags (... nv_cmds idx)) NV_SS))
                (do
                    (start-selection)
                    (unshift-special ca)
                    ((ร idx =) (find--command (:cmdchar ca)))
                )
                (and (non-zero? (& (:cmd_flags (... nv_cmds idx)) NV_SSS)) (flag? @mod_mask MOD_MASK_SHIFT))
                (do
                    (start-selection)
                    ((ร @mod_mask =) (& @mod_mask (bit-not MOD_MASK_SHIFT)))
                ))
            )

            ;; Execute the command!
            ;; Call the command function found in the commands table.

            ((ร ca.arg =) (:cmd_arg (... nv_cmds idx)))
;           nv_cmds[idx].cmd_func(ca);

            ;; If we didn't start or finish an operator, reset oap.regname, unless we need it later.

            (when (and (not @finish_op) (== (:op_type oap) OP_NOP) (or (< idx 0) (zero? (& (:cmd_flags (... nv_cmds idx)) NV_KEEPREG))))
                (clearop oap)
            )

            ;; If an operation is pending, handle it...

            (do-pending-operator ca, old_col, false)

            ;; Wait for a moment when a message is displayed that will be overwritten by the mode message.
            ;; In Visual mode and with "^O" in Insert mode, a short message will be
            ;; overwritten by the mode message.  Wait a bit, until a key is hit.
            ;; In Visual mode, it's more important to keep the Visual area updated
            ;; than keeping a message (e.g. from a /pat search).
            ;; Only do this if the command was typed, not from a mapping.
            ;; Also wait a bit after an error message, e.g. for "^O:".
            ;; Don't redraw the screen, it would remove the message.

            (when (and (or (and @p_smd (or (!= @restart_edit 0) (and @VIsual_active (== (:lnum old_pos) (:lnum (:w_cursor @curwin))) (== (:col old_pos) (:col (:w_cursor @curwin))))) (or @clear_cmdline @redraw_cmdline) (or @msg_didout (and @msg_didany @msg_scroll)) (not @msg_nowait) @keyTyped) (and (!= @restart_edit 0) (not @VIsual_active) (or @msg_scroll @emsg_on_display))) (== (:regname oap) 0) (non-flag? (:retval ca) CA_COMMAND_BUSY) (stuff-empty) (not @did_wait_return) (== (:op_type oap) OP_NOP))
                ((ร int save_State =) @State)

                ;; Draw the cursor with the right shape here.
                (if (non-zero? @restart_edit)
                    (reset! State INSERT))

                ;; If need to redraw, and there is a "keep_msg", redraw before the delay.
                (when (and (non-zero? @must_redraw) (non-nil? @keep_msg) (not @emsg_on_display))
                    ((ร Bytes kmsg =) @keep_msg)
                    (reset! keep_msg nil)
                    ;; showmode() will clear "keep_msg", but we want to use it anyway
                    (update-screen 0)
                    ;; now reset it, otherwise it's put in the history again
                    (reset! keep_msg kmsg)
                    (msg-attr kmsg, @keep_msg_attr)
                )
                (setcursor)
                (cursor-on)
                (out-flush)
                (if (or @msg_scroll @emsg_on_display)
                    (ui-delay 1000, true))      ;; wait at least one second
                (ui-delay 3000, false)         ;; wait up to three seconds
                (reset! State save_State)

                (reset! msg_scroll false)
                (reset! emsg_on_display false)
            )
;       }

        ;; Finish up after executing a Normal mode command.

        (reset! msg_nowait false)

        ;; Reset finish_op, in case it was set.
        ((ร save_finish_op =) @finish_op)
        (reset! finish_op false)
        ;; Redraw the cursor with another shape,
        ;; if we were in Operator-pending mode or did a replace command.
        (when (or save_finish_op (== (:cmdchar ca) (byte \r)))
            (ui-cursor-shape)              ;; may show different cursor shape
        )

        (if (and (== (:op_type oap) OP_NOP) (zero? (:regname oap)) (!= (:cmdchar ca) K_CURSORHOLD))
            (clear-showcmd))

        (checkpcmark)                      ;; check if we moved since setting pcmark
        ((ร ca.searchbuf =) nil)

        (mb-adjust-pos @curbuf, (:w_cursor @curwin))

        (when (and @(:wo_scb (:w_options @curwin)) toplevel)
            (validate-cursor)              ;; may need to update w_leftcol
            (do-check-scrollbind true)
        )

        (when (and @(:wo_crb (:w_options @curwin)) toplevel)
            (validate-cursor)              ;; may need to update w_leftcol
            (do-check-cursorbind)
        )

        ;; May restart edit(), if we got here with CTRL-O in Insert mode
        ;; (but not if still inside a mapping that started in Visual mode).
        ;; May switch from Visual to Select mode after CTRL-O command.

        (when (and (== (:op_type oap) OP_NOP) (or (and (non-zero? @restart_edit) (not @VIsual_active)) (== @restart_VIsual_select 1)) (non-flag? (:retval ca) CA_COMMAND_BUSY) (stuff-empty) (zero? (:regname oap)))
            (when (== @restart_VIsual_select 1)
                (reset! VIsual_select true)
                (showmode)
                (reset! restart_VIsual_select 0)
            )
            (if (and (non-zero? @restart_edit) (not @VIsual_active))
                (edit @restart_edit, false, 1))
        )

        (if (== @restart_VIsual_select 2)
            (reset! restart_VIsual_select 1))

        ;; Save count before an operator for next time.
        (reset! opcount (:opcount ca))
        nil
    ))

;; The visual area is remembered for redo.
(atom! int      redo_VIsual_mode NUL)     ;; 'v', 'V', or Ctrl-V
(atom! long     redo_VIsual_line_count)     ;; number of lines
(atom! int      redo_VIsual_vcol)           ;; number of cols or end column
(atom! long     redo_VIsual_count)          ;; count for Visual operator

;; Handle an operator after visual mode or when the movement is finished.

(defn- #_void do-pending-operator [#_cmdarg_C cap, #_int old_col, #_boolean gui_yank]
    (ยง
        ((ร oparg_C oap =) (:oap cap))

        ((ร boolean lbr_saved =) @(:wo_lbr (:w_options @curwin)))
        ((ร boolean include_line_break =) false)

        ((ร pos_C old_cursor =) (NEW_pos_C))
        (COPY-pos old_cursor, (:w_cursor @curwin))

        ;; If an operation is pending, handle it...

        (when (and (or @finish_op @VIsual_active) (!= (:op_type oap) OP_NOP))
            ;; Avoid a problem with unwanted linebreaks in block mode.
            ((ร @curwin.w_options.@wo_lbr =) false)
            ((ร oap.is_VIsual =) @VIsual_active)
            (cond (== (:motion_force oap) (byte \V))
            (do
                ((ร oap.motion_type =) MLINE)
            )
            (== (:motion_force oap) (byte \v))
            (do
                ;; If the motion was linewise, "inclusive" will not have been set.
                ;; Use "exclusive" to be consistent.  Makes "dvj" work nice.
                (cond (== (:motion_type oap) MLINE)
                (do
                    ((ร oap.inclusive =) false)
                )
                ;; If the motion already was characterwise, toggle "inclusive".
                (== (:motion_type oap) MCHAR)
                (do
                    ((ร oap.inclusive =) (not (:inclusive oap)))
                ))
                ((ร oap.motion_type =) MCHAR)
            )
            (== (:motion_force oap) Ctrl_V)
            (do
                ;; Change line- or characterwise motion into Visual block mode.
                (reset! VIsual_active true)
                (COPY-pos @VIsual, (:op_start oap))
                (reset! VIsual_mode Ctrl_V)
                (reset! VIsual_select false)
                (reset! VIsual_reselect false)
            ))

            ;; Only redo yank when 'y' flag is in 'cpoptions'.
            ;; Also redo Operator-pending Visual mode mappings.
            (when (and (or (non-nil? (vim-strbyte @p_cpo, CPO_YANK)) (!= (:op_type oap) OP_YANK)) (or (not @VIsual_active) (!= (:motion_force oap) 0) (and @VIsual_active (== (:cmdchar cap) (byte \:)) (!= (:op_type oap) OP_COLON))) (!= (:cmdchar cap) (byte \D)))
                (prep-redo (:regname oap), (:count0 cap), (get-op-char (:op_type oap)), (get-extra-op-char (:op_type oap)), (:motion_force oap), (:cmdchar cap), @(:nchar cap))
                (cond (or (== (:cmdchar cap) (byte \/)) (== (:cmdchar cap) (byte \?))) ;; was a search
                (do
                    ;; If 'cpoptions' does not contain 'r',
                    ;; insert the search pattern to really repeat the same command.

                    (if (nil? (vim-strbyte @p_cpo, CPO_REDO))
                        (appendToRedobuffLit (:searchbuf cap), -1))
                    (appendToRedobuff NL_STR)
                )
                (== (:cmdchar cap) (byte \:))
                (do
                    ;; do-cmdline() has stored the first typed line in "repeat_cmdline".
                    ;; When several lines are typed repeating won't be possible.

                    (cond (nil? @repeat_cmdline)
                    (do
                        (resetRedobuff)
                    )
                    :else
                    (do
                        (appendToRedobuffLit @repeat_cmdline, -1)
                        (appendToRedobuff NL_STR)
                        (reset! repeat_cmdline nil)
                    ))
                ))
            )

            (cond @redo_VIsual_busy
            (do
                ;; Redo of an operation on a Visual area.
                ;; Use the same size from redo_VIsual_line_count and redo_VIsual_vcol.

                (COPY-pos (:op_start oap), (:w_cursor @curwin))
                ((ร @curwin.w_cursor.lnum =) (+ (:lnum (:w_cursor @curwin)) (dec @redo_VIsual_line_count)))
                (if (> (:lnum (:w_cursor @curwin)) (:ml_line_count (:b_ml @curbuf)))
                    ((ร @curwin.w_cursor.lnum =) (:ml_line_count (:b_ml @curbuf)))
                )
                (reset! VIsual_mode @redo_VIsual_mode)
                (when (or (== @redo_VIsual_vcol MAXCOL) (== @VIsual_mode (byte \v)))
                    (cond (== @VIsual_mode (byte \v))
                    (do
                        (cond (<= @redo_VIsual_line_count 1)
                        (do
                            (validate-virtcol)
                            ((ร @curwin.w_curswant =) (- (+ (:w_virtcol @curwin) @redo_VIsual_vcol) 1))
                        )
                        :else
                        (do
                            ((ร @curwin.w_curswant =) @redo_VIsual_vcol)
                        ))
                    )
                    :else
                    (do
                        ((ร @curwin.w_curswant =) MAXCOL)
                    ))
                    (coladvance (:w_curswant @curwin))
                )
                ((ร cap.count0 =) @redo_VIsual_count)
                ((ร cap.count1 =) (if (non-zero? @redo_VIsual_count) @redo_VIsual_count 1))
            )
            @VIsual_active
            (do
                (when (not gui_yank)
                    ;; Save the current VIsual area for '< and '> marks, and "gv".
                    (COPY-pos (:vi_start (:b_visual @curbuf)), @VIsual)
                    (COPY-pos (:vi_end (:b_visual @curbuf)), (:w_cursor @curwin))
                    ((ร @curbuf.b_visual.vi_mode =) @VIsual_mode)
                    (when (!= @VIsual_mode_orig NUL)
                        ((ร @curbuf.b_visual.vi_mode =) @VIsual_mode_orig)
                        (reset! VIsual_mode_orig NUL)
                    )
                    ((ร @curbuf.b_visual.vi_curswant =) (:w_curswant @curwin))
                    ((ร @curbuf.b_visual_mode_eval =) @VIsual_mode)
                )

                ;; In Select mode,
                ;; a linewise selection is operated upon like a characterwise selection.
                (cond (and @VIsual_select (== @VIsual_mode (byte \V)))
                (do
                    (cond (ltpos @VIsual, (:w_cursor @curwin))
                    (do
                        ((ร @VIsual.col =) 0)
                        ((ร @curwin.w_cursor.col =) (STRLEN (ml-get (:lnum (:w_cursor @curwin)))))
                    )
                    :else
                    (do
                        ((ร @curwin.w_cursor.col =) 0)
                        ((ร @VIsual.col =) (STRLEN (ml-get (:lnum @VIsual))))
                    ))
                    (reset! VIsual_mode (byte \v))
                )
                ;; If 'selection' is "exclusive", backup one character for charwise selections.
                (== @VIsual_mode (byte \v))
                (do
                    ((ร include_line_break =) (unadjust-for-sel))
                ))

                (COPY-pos (:op_start oap), @VIsual)
                (if (== @VIsual_mode (byte \V))
                    ((ร oap.op_start.col =) 0)
                )
            ))

            ;; Set oap.op_start to the first position of the operated text, oap.op_end
            ;; to the end of the operated text.  w_cursor is equal to oap.op_start.

            (cond (ltpos (:op_start oap), (:w_cursor @curwin))
            (do
                (COPY-pos (:op_end oap), (:w_cursor @curwin))
                (COPY-pos (:w_cursor @curwin), (:op_start oap))

                ;; w_virtcol may have been updated; if the cursor goes back to its previous
                ;; position, w_virtcol becomes invalid and isn't updated automatically.
                ((ร @curwin.w_valid =) (& (:w_valid @curwin) (bit-not VALID_VIRTCOL)))
            )
            :else
            (do
                (COPY-pos (:op_end oap), (:op_start oap))
                (COPY-pos (:op_start oap), (:w_cursor @curwin))
            ))

            ((ร oap.line_count =) (+ (- (:lnum (:op_end oap)) (:lnum (:op_start oap))) 1))

            ;; Set "virtual_op" before resetting VIsual_active.
            (reset! virtual_op (if (virtual-active) TRUE FALSE))

            (when (or @VIsual_active @redo_VIsual_busy)
                (when (== @VIsual_mode Ctrl_V)  ;; block mode
                    ((ร oap.block_mode =) true)

; %%                ((ร int[] start =) (ร { (oap.start_vcol) }))
; %%                ((ร int[] end =) (ร { (oap.end_vcol) }))
                    (getvvcol @curwin, (:op_start oap), start, nil, end)
                    ((ร oap.start_vcol =) (... start 0))
                    ((ร oap.end_vcol =) (... end 0))

                    (when (not @redo_VIsual_busy)
                        (getvvcol @curwin, (:op_end oap), start, nil, end)

                        (if (< (... start 0) (:start_vcol oap))
                            ((ร oap.start_vcol =) (... start 0))
                        )
                        (when (< (:end_vcol oap) (... end 0))
                            ((ร oap.end_vcol =) (if (and (== (.at @p_sel 0) (byte \e)) (<= 1 (... start 0)) (<= (:end_vcol oap) (dec (... start 0)))) (dec (... start 0)) (... end 0)))
                        )
                    )

                    ;; if '$' was used, get oap.end_vcol from longest line
                    (cond (== (:w_curswant @curwin) MAXCOL)
                    (do
                        ((ร @curwin.w_cursor.col =) MAXCOL)
                        ((ร oap.end_vcol =) 0)
                        ((ร FOR) (ร ((ร @curwin.w_cursor.lnum =) (:lnum (:op_start oap))) (<= (:lnum (:w_cursor @curwin)) (:lnum (:op_end oap))) (ร @curwin.w_cursor.lnum++))
                            (getvvcol @curwin, (:w_cursor @curwin), nil, nil, end)
                            (if (< (:end_vcol oap) (... end 0))
                                ((ร oap.end_vcol =) (... end 0))
                            )
                        )
                    )
                    @redo_VIsual_busy
                    (do
                        ((ร oap.end_vcol =) (- (+ (:start_vcol oap) @redo_VIsual_vcol) 1))
                    ))

                    ;; Correct oap.op_end.col and oap.op_start.col to be the
                    ;; upper-left and lower-right corner of the block area.
                    ;;
                    ;; (Actually, this does convert column positions into character positions.)

                    ((ร @curwin.w_cursor.lnum =) (:lnum (:op_end oap)))
                    (coladvance (:end_vcol oap))
                    (COPY-pos (:op_end oap), (:w_cursor @curwin))

                    (COPY-pos (:w_cursor @curwin), (:op_start oap))
                    (coladvance (:start_vcol oap))
                    (COPY-pos (:op_start oap), (:w_cursor @curwin))
                )

                (when (and (not @redo_VIsual_busy) (not gui_yank))
                    ;; Prepare to reselect and redo Visual:
                    ;; this is based on the size of the Visual text

                    (reset! resel_VIsual_mode @VIsual_mode)
                    (cond (== (:w_curswant @curwin) MAXCOL)
                    (do
                        (reset! resel_VIsual_vcol MAXCOL)
                    )
                    :else
                    (do
                        (when (!= @VIsual_mode Ctrl_V)
; %%                        ((ร int[] __ =) (ร { (oap.end_vcol) }))
                            (getvvcol @curwin, (:op_end oap), nil, nil, __)
                            ((ร oap.end_vcol =) (... __ 0))
                        )
                        (cond (or (== @VIsual_mode Ctrl_V) (<= (:line_count oap) 1))
                        (do
                            (when (!= @VIsual_mode Ctrl_V)
; %%                            ((ร int[] __ =) (ร { (oap.start_vcol) }))
                                (getvvcol @curwin, (:op_start oap), __, nil, nil)
                                ((ร oap.start_vcol =) (... __ 0))
                            )
                            (reset! resel_VIsual_vcol (+ (- (:end_vcol oap) (:start_vcol oap)) 1))
                        )
                        :else
                        (do
                            (reset! resel_VIsual_vcol (:end_vcol oap))
                        ))
                    ))
                    (reset! resel_VIsual_line_count (:line_count oap))
                )

                ;; can't redo yank (unless 'y' is in 'cpoptions') and ":"
                (when (and (or (non-nil? (vim-strbyte @p_cpo, CPO_YANK)) (!= (:op_type oap) OP_YANK)) (!= (:op_type oap) OP_COLON) (== (:motion_force oap) NUL))
                    ;; Prepare for redoing.  Only use the nchar field for "r",
                    ;; otherwise it might be the second char of the operator.

                    (cond (and (== (:cmdchar cap) (byte \g)) (or (== @(:nchar cap) (byte \n)) (== @(:nchar cap) (byte \N))))
                    (do
                        (prep-redo (:regname oap), (:count0 cap), (get-op-char (:op_type oap)), (get-extra-op-char (:op_type oap)), (:motion_force oap), (:cmdchar cap), @(:nchar cap))
                    )
                    (!= (:cmdchar cap) (byte \:))
                    (do
                        (prep-redo (:regname oap), 0, NUL, (byte \v), (get-op-char (:op_type oap)), (get-extra-op-char (:op_type oap)), (if (== (:op_type oap) OP_REPLACE) @(:nchar cap) NUL))
                    ))
                    (when (not @redo_VIsual_busy)
                        (reset! redo_VIsual_mode @resel_VIsual_mode)
                        (reset! redo_VIsual_vcol @resel_VIsual_vcol)
                        (reset! redo_VIsual_line_count @resel_VIsual_line_count)
                        (reset! redo_VIsual_count (:count0 cap))
                    )
                )

                ;; oap.inclusive defaults to true.
                ;; If oap.op_end is on a NUL (empty line) oap.inclusive becomes false.
                ;; This makes "d}P" and "v}dP" work the same.

                (if (or (== (:motion_force oap) NUL) (== (:motion_type oap) MLINE))
                    ((ร oap.inclusive =) true)
                )
                (cond (== @VIsual_mode (byte \V))
                (do
                    ((ร oap.motion_type =) MLINE)
                )
                :else
                (do
                    ((ร oap.motion_type =) MCHAR)
                    (when (and (!= @VIsual_mode Ctrl_V) (== (.at (ml-get-pos (:op_end oap)) 0) NUL) (or include_line_break (== @virtual_op FALSE)))
                        ((ร oap.inclusive =) false)
                        ;; Try to include the newline,
                        ;; unless it's an operator that works on lines only.
                        (when (and (!= (.at @p_sel 0) (byte \o)) (not (op-on-lines (:op_type oap))))
                            (cond (< (:lnum (:op_end oap)) (:ml_line_count (:b_ml @curbuf)))
                            (do
                                (ร oap.op_end.lnum++)
                                ((ร oap.op_end.col =) 0)
                                ((ร oap.op_end.coladd =) 0)
                                (ร oap.line_count++)
                            )
                            :else
                            (do
                                ;; Cannot move below the last line, make the op inclusive
                                ;; to tell the operation to include the line break.
                                ((ร oap.inclusive =) true)
                            ))
                        )
                    )
                ))

                (reset! redo_VIsual_busy false)

                ;; Switch Visual off now, so screen updating does
                ;; not show inverted text when the screen is redrawn.
                ;; With OP_YANK and sometimes with OP_COLON and OP_FILTER there is
                ;; no screen redraw, so it is done here to remove the inverted part.

                (when (not gui_yank)
                    (reset! VIsual_active false)
                    (if @mode_displayed
                        (reset! clear_cmdline true)   ;; unshow visual mode later
                        (clear-showcmd))
                    (when (and (or (== (:op_type oap) OP_YANK) (== (:op_type oap) OP_COLON) (== (:op_type oap) OP_FUNCTION) (== (:op_type oap) OP_FILTER)) (== (:motion_force oap) NUL))
                        ;; make sure redrawing is correct
                        ((ร @curwin.w_options.@wo_lbr =) lbr_saved)
                        (redraw-curbuf-later INVERTED)
                    )
                )
            )

            ;; Include the trailing byte of a multi-byte char.
            (when (:inclusive oap)
                ((ร int l =) (us-ptr2len-cc (ml-get-pos (:op_end oap))))
                (if (< 1 l)
                    ((ร oap.op_end.col =) (+ (:col (:op_end oap)) (dec l)))
                )
            )
            ((ร @curwin.w_set_curswant =) true)

            ;; oap.empty is set when start and end are the same.
            ;; The inclusive flag affects this too, unless yanking and the end is on a NUL.

            ((ร oap.empty =) (and (== (:motion_type oap) MCHAR) (or (not (:inclusive oap)) (and (== (:op_type oap) OP_YANK) (== (gchar-pos (:op_end oap)) NUL))) (eqpos (:op_start oap), (:op_end oap)) (not (and (!= @virtual_op FALSE) (!= (:coladd (:op_start oap)) (:coladd (:op_end oap)))))))

            ;; For delete, change and yank, it's an error to operate on an
            ;; empty region, when 'E' included in 'cpoptions' (Vi compatible).

            ((ร boolean empty_region_error =) (and (:empty oap) (non-nil? (vim-strbyte @p_cpo, CPO_EMPTYREGION))))

            ;; Force a redraw when operating on an empty Visual region,
            ;; when 'modifiable' is off or creating a fold.
            (when (and (:is_VIsual oap) (:empty oap))
                ((ร @curwin.w_options.@wo_lbr =) lbr_saved)
                (redraw-curbuf-later INVERTED)
            )

            ;; If the end of an operator is in column one while oap.motion_type
            ;; is MCHAR and oap.inclusive is false, we put op_end after the last
            ;; character in the previous line.  If op_start is on or before the
            ;; first non-blank in the line, the operator becomes linewise
            ;; (strange, but that's the way vi does it).

            (cond (and (== (:motion_type oap) MCHAR) (not (:inclusive oap)) (non-flag? (:retval cap) CA_NO_ADJ_OP_END) (== (:col (:op_end oap)) 0) (or (not (:is_VIsual oap)) (== (.at @p_sel 0) (byte \o))) (not (:block_mode oap)) (< 1 (:line_count oap)))
            (do
                ((ร oap.end_adjusted =) true)    ;; remember that we did this
                (ร --oap.line_count)
                (ร --oap.op_end.lnum)
                (cond (inindent 0)
                (do
                    ((ร oap.motion_type =) MLINE)
                )
                :else
                (do
                    ((ร oap.op_end.col =) (STRLEN (ml-get (:lnum (:op_end oap)))))
                    (when (< 0 (:col (:op_end oap)))
                        (ร --oap.op_end.col)
                        ((ร oap.inclusive =) true)
                    )
                ))
            )
            :else
            (do
                ((ร oap.end_adjusted =) false)
            ))

            ((ร SWITCH) (:op_type oap)
                ((ร CASE) OP_LSHIFT)
                ((ร CASE) OP_RSHIFT)
                (do
                    (op-shift oap, true, (if (:is_VIsual oap) (int (:count1 cap)) 1))
                    (ร BREAK)
                )

                ((ร CASE) OP_JOIN_NS)
                ((ร CASE) OP_JOIN)
                (do
                    (if (< (:line_count oap) 2)
                        ((ร oap.line_count =) 2)
                    )
                    (if (< (:ml_line_count (:b_ml @curbuf)) (- (+ (:lnum (:w_cursor @curwin)) (:line_count oap)) 1))
                        (beep-flush)
                        (do-join (int (:line_count oap)), (== (:op_type oap) OP_JOIN), true, true, true))
                    (ร BREAK)
                )

                ((ร CASE) OP_DELETE)
                (do
                    (reset! VIsual_reselect false)        ;; don't reselect now
                    (cond empty_region_error
                    (do
                        (vim-beep)
                        (cancelRedo)
                    )
                    :else
                    (do
                        (op-delete oap)
                    ))
                    (ร BREAK)
                )

                ((ร CASE) OP_YANK)
                (do
                    (cond empty_region_error
                    (do
                        (when (not gui_yank)
                            (vim-beep)
                            (cancelRedo)
                        )
                    )
                    :else
                    (do
                        ((ร @curwin.w_options.@wo_lbr =) lbr_saved)
                        (op-yank oap, false, (not gui_yank))
                    ))
                    (check-cursor-col)
                    (ร BREAK)
                )

                ((ร CASE) OP_CHANGE)
                (do
                    (reset! VIsual_reselect false)        ;; don't reselect now
                    (cond empty_region_error
                    (do
                        (vim-beep)
                        (cancelRedo)
                    )
                    :else
                    (do
                        ;; This is a new edit command, not a restart.
                        ;; Need to remember it to make 'insertmode' work with mappings for Visual mode.
                        ;; But do this only once and not when typed and 'insertmode' isn't set.
                        (ร int restart_edit_save)
                        ((ร restart_edit_save =) (if (or @p_im (not @keyTyped)) @restart_edit 0))
                        (reset! restart_edit 0)
                        ;; Restore linebreak, so that when the user edits it looks as before.
                        ((ร @curwin.w_options.@wo_lbr =) lbr_saved)
                        ;; Reset finish_op now, don't want it set inside edit().
                        (reset! finish_op false)
                        (if (op-change oap)         ;; will call edit()
                            ((ร cap.retval =) (| (:retval cap) CA_COMMAND_BUSY))
                        )
                        (if (zero? @restart_edit)
                            (reset! restart_edit restart_edit_save))
                    ))
                    (ร BREAK)
                )

                ((ร CASE) OP_INDENT)
                (do
                    (op-reindent oap, (ร get_c_indent))
                    (ร BREAK)
                )

                ((ร CASE) OP_FILTER)
                (do
                    (if (non-nil? (vim-strbyte @p_cpo, CPO_FILTER))
                        (appendToRedobuff (u8 "!\r"))    ;; use any last used !cmd
                        (reset! bangredo true))            ;; do_bang() will put cmd in redo buffer
                    (ร FALLTHROUGH)
                )

                ((ร CASE) OP_COLON)
                (do
                    (op-colon oap)
                    (ร BREAK)
                )

                ((ร CASE) OP_TILDE)
                ((ร CASE) OP_UPPER)
                ((ร CASE) OP_LOWER)
                ((ร CASE) OP_ROT13)
                (do
                    (cond empty_region_error
                    (do
                        (vim-beep)
                        (cancelRedo)
                    )
                    :else
                    (do
                        (op-tilde oap)
                    ))
                    (check-cursor-col)
                    (ร BREAK)
                )

                ((ร CASE) OP_FORMAT)
                (do
;                   op_format(oap, false);              ;; use internal function
                    (ร BREAK)
                )

                ((ร CASE) OP_FORMAT2)
                (do
;                   op_format(oap, true);               ;; use internal function
                    (ร BREAK)
                )

                ((ร CASE) OP_FUNCTION)
                (do
                    (op-function oap)                   ;; call 'operatorfunc'
                    (ร BREAK)
                )

                ((ร CASE) OP_INSERT)
                ((ร CASE) OP_APPEND)
                (do
                    (reset! VIsual_reselect false)           ;; don't reselect now
                    (cond empty_region_error
                    (do
                        (vim-beep)
                        (cancelRedo)
                    )
                    :else
                    (do
                        ;; This is a new edit command, not a restart.
                        ;; Need to remember it to make 'insertmode' work with mappings for Visual mode.
                        ;; But do this only once.
                        ((ร int restart_edit_save =) @restart_edit)
                        (reset! restart_edit 0)
                        ;; Restore linebreak, so that when the user edits it looks as before.
                        ((ร @curwin.w_options.@wo_lbr =) lbr_saved)
                        (op-insert oap, (:count1 cap))
                        ;; Reset linebreak, so that formatting works correctly.
                        ((ร @curwin.w_options.@wo_lbr =) false)

                        (if (zero? @restart_edit)
                            (reset! restart_edit restart_edit_save))
                    ))
                    (ร BREAK)
                )

                ((ร CASE) OP_REPLACE)
                (do
                    (reset! VIsual_reselect false)    ;; don't reselect now
                    (cond empty_region_error
                    (do
                        (vim-beep)
                        (cancelRedo)
                    )
                    :else
                    (do
                        ;; Restore linebreak, so that when the user edits it looks as before.
                        ((ร @curwin.w_options.@wo_lbr =) lbr_saved)
                        (op-replace oap, @(:nchar cap))
                    ))
                    (ร BREAK)
                )

                (ร DEFAULT)
                (do
                    (clearopbeep oap)
                    (ร BREAK)
                )
            )

            (reset! virtual_op MAYBE)

            (cond (not gui_yank)
            (do
                ;; if 'sol' not set, go back to old column for some commands

                (when (and (not @p_sol) (== (:motion_type oap) MLINE) (not (:end_adjusted oap)) (or (== (:op_type oap) OP_LSHIFT) (== (:op_type oap) OP_RSHIFT) (== (:op_type oap) OP_DELETE)))
                    ((ร @curwin.w_options.@wo_lbr =) false)
                    (coladvance ((ร @curwin.w_curswant =) old_col))
                )
            )
            :else
            (do
                (COPY-pos (:w_cursor @curwin), old_cursor)
            ))
            ((ร oap.block_mode =) false)
            (clearop oap)
        )

        ((ร @curwin.w_options.@wo_lbr =) lbr_saved)
        nil
    ))

;; Handle filter operator and visual mode ":".

(defn- #_void op-colon [#_oparg_C oap]
    (ยง
        (stuffcharReadbuff (byte \:))
        (cond (:is_VIsual oap)
        (do
            (stuffReadbuff (u8 "'<,'>"))
        )
        :else
        (do
            ;; Make the range look nice, so it can be repeated.

            (if (== (:lnum (:op_start oap)) (:lnum (:w_cursor @curwin)))
                (stuffcharReadbuff (byte \.))
                (stuffnumReadbuff (:lnum (:op_start oap))))
            (when (!= (:lnum (:op_end oap)) (:lnum (:op_start oap)))
                (stuffcharReadbuff (byte \,))
                (cond (== (:lnum (:op_end oap)) (:lnum (:w_cursor @curwin)))
                (do
                    (stuffcharReadbuff (byte \.))
                )
                (== (:lnum (:op_end oap)) (:ml_line_count (:b_ml @curbuf)))
                (do
                    (stuffcharReadbuff (byte \$))
                )
                (== (:lnum (:op_start oap)) (:lnum (:w_cursor @curwin)))
                (do
                    (stuffReadbuff (u8 ".+"))
                    (stuffnumReadbuff (- (:line_count oap) 1))
                )
                :else
                (do
                    (stuffnumReadbuff (:lnum (:op_end oap)))
                ))
            )
        ))
        (when (!= (:op_type oap) OP_COLON)
            (stuffReadbuff (u8 "!"))
        )

        ;; do-cmdline() does the rest
        nil
    ))

;; Handle the "g@" operator: call 'operatorfunc'.

(defn- #_void op-function [#_oparg_C oap]
    (ยง
        ((ร Bytes[] argv =) (ร new Bytes[1]))
        ((ร maybean save_virtual_op =) @virtual_op)

        (cond (eos? @p_opfunc)
        (do
            (emsg (u8 "E774: 'operatorfunc' is empty"))
        )
        :else
        (do
            ;; Set '[ and '] marks to text to be operated on.
            (COPY-pos (:b_op_start @curbuf), (:op_start oap))
            (COPY-pos (:b_op_end @curbuf), (:op_end oap))
            (when (and (!= (:motion_type oap) MLINE) (not (:inclusive oap)))
                ;; Exclude the end position.
                (decl (:b_op_end @curbuf))
            )

            (cond (:block_mode oap)
            (do
                ((ร argv[0] =) (u8 "block"))
            )
            (== (:motion_type oap) MLINE)
            (do
                ((ร argv[0] =) (u8 "line"))
            )
            :else
            (do
                ((ร argv[0] =) (u8 "char"))
            ))

            ;; Reset virtual_op so that 'virtualedit' can be changed in the function.
            (reset! virtual_op MAYBE)

;           call_func_retnr(@p_opfunc, 1, argv, false);

            (reset! virtual_op save_virtual_op)
        ))
        nil
    ))

(atom! boolean did_check_visual_highlight)

;; Check if highlighting for visual mode is possible, give a warning message if not.

(defn- #_void check-visual-highlight []
    (when @full_screen
        (if (and (not @did_check_visual_highlight) (zero? (hl-attr HLF_V)))
            (msg (u8 "Warning: terminal cannot highlight")))
        (reset! did_check_visual_highlight true)
    )
    nil)

;; End Visual mode.
;; This function should ALWAYS be called to end Visual mode, except from do-pending-operator().

(defn- #_void end-visual-mode []
    (ยง
        (reset! VIsual_active false)

        ;; Save the current VIsual area for '< and '> marks, and "gv".
        ((ร @curbuf.b_visual.vi_mode =) @VIsual_mode)
        (COPY-pos (:vi_start (:b_visual @curbuf)), @VIsual)
        (COPY-pos (:vi_end (:b_visual @curbuf)), (:w_cursor @curwin))
        ((ร @curbuf.b_visual.vi_curswant =) (:w_curswant @curwin))
        ((ร @curbuf.b_visual_mode_eval =) @VIsual_mode)
        (if (not (virtual-active))
            ((ร @curwin.w_cursor.coladd =) 0)
        )

        (if @mode_displayed
            (reset! clear_cmdline true)           ;; unshow visual mode later
            (clear-showcmd))

        (adjust-cursor-eol)
        nil
    ))

;; Reset VIsual_active and VIsual_reselect.

(defn- #_void reset-VIsual-and-resel []
    (when @VIsual_active
        (end-visual-mode)
        (redraw-curbuf-later INVERTED)  ;; delete the inversion later
    )
    (reset! VIsual_reselect false)
    nil)

;; Reset VIsual_active and VIsual_reselect if it's set.

(defn- #_void reset-VIsual []
    (when @VIsual_active
        (end-visual-mode)
        (redraw-curbuf-later INVERTED)  ;; delete the inversion later
        (reset! VIsual_reselect false)
    )
    nil)

;; Find the identifier under or to the right of the cursor.
;; "find_type" can have one of three values:
;; FIND_IDENT:   find an identifier (keyword)
;; FIND_STRING:  find any non-white string
;; FIND_IDENT + FIND_STRING: find any non-white string, identifier preferred.
;; FIND_EVAL:    find text useful for C program debugging
;;
;; There are three steps:
;; 1. Search forward for the start of an identifier/string.
;;    Doesn't move if already on one.
;; 2. Search backward for the start of this identifier/string.
;;    This doesn't match the real Vi but I like it a little better
;;    and it shouldn't bother anyone.
;; 3. Search forward to the end of this identifier/string.
;;    When FIND_IDENT isn't defined, we backup until a blank.
;;
;; Returns the length of the string, or zero if no string is found.
;; If a string is found, a pointer to the string is put in "*string".
;; This string is not always NUL terminated.

(defn- #_int find-ident-under-cursor [#_Bytes* string, #_int find_type]
    (let [cursor (:w_cursor @curwin)]
        (find-ident-at-pos @curwin, (:lnum cursor), (:col cursor), string, find_type)
    ))

;; Like find-ident-under-cursor(), but for any window and any position.
;; However: Uses 'iskeyword' from the current window!.

(defn- #_int find-ident-at-pos [#_window_C wp, #_long lnum, #_int startcol, #_Bytes* string, #_int find_type]
    (ยง
        ((ร Bytes p =) (ml-get-buf @curbuf, lnum))

        ((ร int col =) 0)
        ((ร int this_class =) 0)

        (ร int round)

        ;; if round == 0: try to find an identifier
        ;; if round == 1: try to find any non-white string

        ((ร FOR) (ร ((ร round =) (if (flag? find_type FIND_IDENT) 0 1)) (< round 2) (ร round++))
            ;; 1. Skip to start of identifier/string.

            ((ร col =) startcol)
            (while (non-eos? p col)
                ((ร this_class =) (us-get-class (.plus p col), @curbuf))
                (if (and (non-zero? this_class) (or (== round 1) (!= this_class 1)))
                    (ร BREAK)
                )
                ((ร col =) (+ col (us-ptr2len-cc (.plus p col))))
            )

            ;; 2. Back up to start of identifier/string.

            ;; Remember class of character under cursor.
            ((ร this_class =) (us-get-class (.plus p col), @curbuf))
            (while (and (< 0 col) (!= this_class 0))
                ((ร int prevcol =) (- col 1 (us-head-off p, (.plus p (dec col)))))
                ((ร int prev_class =) (us-get-class (.plus p prevcol), @curbuf))
                (if (and (!= this_class prev_class) (or (zero? round) (zero? prev_class) (flag? find_type FIND_IDENT)))
                    (ร BREAK)
                )
                ((ร col =) prevcol)
            )

            ;; If we don't want just any old string, or we've found an identifier, stop searching.
            (if (< 2 this_class)
                ((ร this_class =) 2)
            )
            (if (or (non-flag? find_type FIND_STRING) (== this_class 2))
                (ร BREAK)
            )
        )

        (when (or (eos? p col) (and (zero? round) (!= this_class 2)))
            ;; didn't find an identifier or string

            (if (flag? find_type FIND_STRING)
                (emsg (u8 "E348: No string under cursor"))
                (emsg e_noident))
            ((ร RETURN) 0)
        )
        ((ร p =) (.plus p col))
        ((ร string[0] =) p)

        ;; 3. Find the end if the identifier/string.

        ((ร col =) 0)
        ;; Search for point of changing multibyte character class.
        ((ร this_class =) (us-get-class p, @curbuf))
        (while (and (non-eos? p col) (if (zero? round) (== (us-get-class (.plus p col), @curbuf) this_class) (!= (us-get-class (.plus p col), @curbuf) 0)))
            ((ร col =) (+ col (us-ptr2len-cc (.plus p col))))
        )

        col
    ))

;; Prepare for redo of a normal command.

(defn- #_void prep-redo-cmd [#_cmdarg_C cap]
    (prep-redo (:regname (:oap cap)), (:count0 cap), NUL, (:cmdchar cap), NUL, NUL, @(:nchar cap))
    nil)

;; Prepare for redo of any command.
;; Note that only the last argument can be a multi-byte char.

(defn- #_void prep-redo [#_int regname, #_long num, #_int cmd1, #_int cmd2, #_int cmd3, #_int cmd4, #_int cmd5]
    (resetRedobuff)
    (when (non-zero? regname)   ;; yank from specified buffer
        (appendCharToRedobuff (byte \"))    ;; """
        (appendCharToRedobuff regname)
    )
    (if (non-zero? num)
        (appendNumberToRedobuff num))

    (if (!= cmd1 NUL)
        (appendCharToRedobuff cmd1))
    (if (!= cmd2 NUL)
        (appendCharToRedobuff cmd2))
    (if (!= cmd3 NUL)
        (appendCharToRedobuff cmd3))
    (if (!= cmd4 NUL)
        (appendCharToRedobuff cmd4))
    (if (!= cmd5 NUL)
        (appendCharToRedobuff cmd5))
    nil)

;; check for operator active and clear it
;;
;; return true if operator was active

(defn- #_boolean checkclearop [#_oparg_C oap]
    (ยง
        (if (== (:op_type oap) OP_NOP)
            ((ร RETURN) false)
        )
        (clearopbeep oap)
        true
    ))

;; Check for operator or Visual active.  Clear active operator.
;;
;; Return true if operator or Visual was active.

(defn- #_boolean checkclearopq [#_oparg_C oap]
    (ยง
        (if (and (== (:op_type oap) OP_NOP) (not @VIsual_active))
            ((ร RETURN) false)
        )
        (clearopbeep oap)
        true
    ))

(defn- #_void clearop [#_oparg_C oap]
    (ยง
        ((ร oap.op_type =) OP_NOP)
        ((ร oap.regname =) 0)
        ((ร oap.motion_force =) NUL)
        ((ร oap.use_reg_one =) false)
        nil
    ))

(defn- #_void clearopbeep [#_oparg_C oap]
    (clearop oap)
    (beep-flush)
    nil)

;; Remove the shift modifier from a special key.

(defn- #_void unshift-special [#_cmdarg_C cap]
    (ยง
        ((ร SWITCH) (:cmdchar cap)
            ((ร CASE) K_S_RIGHT)
            (do
                ((ร cap.cmdchar =) K_RIGHT)
                (ร BREAK)
            )
            ((ร CASE) K_S_LEFT)
            (do
                ((ร cap.cmdchar =) K_LEFT)
                (ร BREAK)
            )
            ((ร CASE) K_S_UP)
            (do
                ((ร cap.cmdchar =) K_UP)
                (ร BREAK)
            )
            ((ร CASE) K_S_DOWN)
            (do
                ((ร cap.cmdchar =) K_DOWN)
                (ร BREAK)
            )
            ((ร CASE) K_S_HOME)
            (do
                ((ร cap.cmdchar =) K_HOME)
                (ร BREAK)
            )
            ((ร CASE) K_S_END)
            (do
                ((ร cap.cmdchar =) K_END)
                (ร BREAK)
            )
        )
;       { int[] __ = { @mod_mask }; cap.cmdchar = simplify-key(cap.cmdchar, __); @mod_mask = __[0]; }
        nil
    ))

;; Routines for displaying a partly typed command

(final int SHOWCMD_BUFLEN (+ SHOWCMD_COLS 1 30))
(final Bytes    showcmd_buf     (Bytes. SHOWCMD_BUFLEN))
(final Bytes    old_showcmd_buf (Bytes. SHOWCMD_BUFLEN))    ;; for push-showcmd()
(atom! boolean  showcmd_is_clear true)
(atom! boolean  showcmd_visual)

(defn- #_void clear-showcmd []
    (ยง
        (if (not @p_sc)
            ((ร RETURN) nil)
        )

        (cond (and @VIsual_active (not (char-avail)))
        (do
            ((ร boolean cursor_bot =) (ltpos @VIsual, (:w_cursor @curwin)))
            (ร long lines)
            (ร long top, bot)

            ;; Show the size of the Visual area.
            (cond cursor_bot
            (do
                ((ร top =) (:lnum @VIsual))
                ((ร bot =) (:lnum (:w_cursor @curwin)))
            )
            :else
            (do
                ((ร top =) (:lnum (:w_cursor @curwin)))
                ((ร bot =) (:lnum @VIsual))
            ))
            ((ร lines =) (+ (- bot top) 1))

            (cond (== @VIsual_mode Ctrl_V)
            (do
                ((ร Bytes saved_sbr =) @p_sbr)
                ((ร int[] leftcol =) (ร new int[1]))
                ((ร int[] rightcol =) (ร new int[1]))

                ;; Make 'sbr' empty for a moment to get the correct size.
                (reset! p_sbr EMPTY_OPTION)
                (getvcols @curwin, (:w_cursor @curwin), @VIsual, leftcol, rightcol)
                (reset! p_sbr saved_sbr)
                (.sprintf libC showcmd_buf, (u8 "%ldx%ld"), lines, (long (+ (- (... rightcol 0) (... leftcol 0)) 1)))
            )
            (or (== @VIsual_mode (byte \V)) (!= (:lnum @VIsual) (:lnum (:w_cursor @curwin))))
            (do
                (.sprintf libC showcmd_buf, (u8 "%ld"), lines)
            )
            :else
            (do
                ((ร int bytes =) 0)
                ((ร int chars =) 0)

                (ร Bytes s, e)
                (cond cursor_bot
                (do
                    ((ร s =) (ml-get-pos @VIsual))
                    ((ร e =) (ml-get-cursor))
                )
                :else
                (do
                    ((ร s =) (ml-get-cursor))
                    ((ร e =) (ml-get-pos @VIsual))
                ))
                (while (if (!= (.at @p_sel 0) (byte \e)) (BLE s, e) (BLT s, e))
                    ((ร int l =) (us-ptr2len-cc s))
                    (when (zero? l)
                        (ร bytes++)
                        (ร chars++)
                        (ร BREAK)  ;; end of line
                    )
                    ((ร bytes =) (+ bytes l))
                    (ร chars++)
                    ((ร s =) (.plus s l))
                )
                (if (== bytes chars)
                    (.sprintf libC showcmd_buf, (u8 "%d"), chars)
                    (.sprintf libC showcmd_buf, (u8 "%d-%d"), chars, bytes)
                )
            ))
            (eos! showcmd_buf SHOWCMD_COLS)      ;; truncate
            (reset! showcmd_visual true)
        )
        :else
        (do
            (eos! showcmd_buf)
            (reset! showcmd_visual false)

            ;; Don't actually display something if there is nothing to clear.
            (if @showcmd_is_clear
                ((ร RETURN) nil)
            )
        ))

        (display-showcmd)
        nil
    ))

(final int* ignore_showcmd
    [
        K_IGNORE,
        K_CURSORHOLD,
        0
    ])

;; Add 'c' to string of shown command chars.
;; Return true if output has been written (and setcursor() has been called).

(defn- #_boolean add-to-showcmd [#_int c]
    (ยง
        (if (not @p_sc)
            ((ร RETURN) false)
        )

        (when @showcmd_visual
            (eos! showcmd_buf)
            (reset! showcmd_visual false)
        )

        ;; Ignore keys that are scrollbar updates and mouse clicks.
        (when (is-special c)
            ((ร FOR) (ร ((ร int i =) 0) (!= (... ignore_showcmd i) 0) (ร i++))
                (if (== (... ignore_showcmd i) c)
                    ((ร RETURN) false)
                )
            )
        )

        ((ร Bytes p =) (transchar c))
        (if (== (.at p 0) (byte \space))
            (STRCPY p, (u8 "<20>")))

        ((ร int old_len =) (STRLEN showcmd_buf))
        ((ร int extra_len =) (STRLEN p))
        ((ร int overflow =) (- (+ old_len extra_len) SHOWCMD_COLS))
        (if (< 0 overflow)
            (BCOPY showcmd_buf, 0, showcmd_buf, overflow, (+ (- old_len overflow) 1)))
        (STRCAT showcmd_buf, p)

        (if (char-avail)
            ((ร RETURN) false)
        )

        (display-showcmd)

        true
    ))

(defn- #_void add-to-showcmd-c [#_int c]
    (when (not (add-to-showcmd c))
        (setcursor)
    )
    nil)

;; Delete 'len' characters from the end of the shown command.

(defn- #_void del-from-showcmd [#_int len]
    (when @p_sc
        (let [#_int old_len (STRLEN showcmd_buf) len (if (< old_len len) old_len len)]
            (eos! showcmd_buf (- old_len len))
        )
        (when (not (char-avail))
            (display-showcmd)
        )
    )
    nil)

;; push-showcmd() and pop-showcmd() are used when waiting for the user
;; to type something and there is a partial mapping.

(defn- #_void push-showcmd []
    (when @p_sc
        (STRCPY old_showcmd_buf, showcmd_buf)
    )
    nil)

(defn- #_void pop-showcmd []
    (when @p_sc
        (STRCPY showcmd_buf, old_showcmd_buf)
        (display-showcmd)
    )
    nil)

(defn- #_void display-showcmd []
    (cursor-off)

    (let [#_int len (STRLEN showcmd_buf)]
        (if (non-zero? len)
            (screen-puts showcmd_buf, (dec (int @Rows)), @sc_col, 0))
        ;; clear the rest of an old message by outputting up to SHOWCMD_COLS spaces
        (screen-puts (.plus (u8 "          ") len), (dec (int @Rows)), (+ @sc_col len), 0)
        (reset! showcmd_is_clear (zero? len))
    )

    (setcursor)            ;; put cursor back where it belongs
    nil)

(atom! window_C scr_old_curwin)
(atom! long scr_old_topline)
(atom! int scr_old_leftcol)

;; When "check" is false, prepare for commands that scroll the window.
;; When "check" is true, take care of scroll-binding after the window has scrolled.
;; Called from normal-cmd() and edit().

(defn- #_void do-check-scrollbind [#_boolean check]
    (ยง
        (when (and check @(:wo_scb (:w_options @curwin)))
            ;; If a ":syncbind" command was just used, don't scroll, only reset the values.
            (cond @did_syncbind
            (do
                (reset! did_syncbind false)
            )
            (== @curwin @scr_old_curwin)
            (do
                ;; Synchronize other windows, as necessary according to 'scrollbind'.

                (when (or (!= (:w_topline @curwin) @scr_old_topline) (!= (:w_leftcol @curwin) @scr_old_leftcol))
                    (check-scrollbind (- (:w_topline @curwin) @scr_old_topline), (long (- (:w_leftcol @curwin) @scr_old_leftcol)))
                )
            )
            (non-nil? (vim-strchr @p_sbo, (byte \j))) ;; jump flag set in 'scrollopt'
            (do
                ;; When switching between windows, make sure that the relative
                ;; vertical offset is valid for the new window.  The relative
                ;; offset is invalid whenever another 'scrollbind' window has
                ;; scrolled to a point that would force the current window to
                ;; scroll past the beginning or end of its buffer.  When the
                ;; resync is performed, some of the other 'scrollbind' windows may
                ;; need to jump so that the current window's relative position is
                ;; visible on-screen.

                (check-scrollbind (- (:w_topline @curwin) (:w_scbind_pos @curwin)), 0)
            ))
            ((ร @curwin.w_scbind_pos =) (:w_topline @curwin))
        )

        (reset! scr_old_curwin @curwin)
        (reset! scr_old_topline (:w_topline @curwin))
        (reset! scr_old_leftcol (:w_leftcol @curwin))
        nil
    ))

;; Synchronize any windows that have "scrollbind" set,
;; based on the number of rows by which the current window has changed.

(defn- #_void check-scrollbind [#_long topline_diff, #_long leftcol_diff]
    (ยง
        ((ร window_C old_curwin =) @curwin)
        ((ร boolean old_VIsual_select =) @VIsual_select)
        ((ร boolean old_VIsual_active =) @VIsual_active)
        ((ร int tgt_leftcol =) (:w_leftcol @curwin))

        ;; check 'scrollopt' string for vertical and horizontal scroll options

        ((ร boolean want_ver =) (and (non-nil? (vim-strchr @p_sbo, (byte \v))) (!= topline_diff 0)))
        ((ร boolean want_hor =) (and (non-nil? (vim-strchr @p_sbo, (byte \h))) (or (!= leftcol_diff 0) (!= topline_diff 0))))

        ;; loop through the scrollbound windows and scroll accordingly

        (reset! VIsual_select ((ร @VIsual_active =) false))
        ((ร FOR) (ร ((ร @curwin =) @firstwin) (non-nil? @curwin) ((ร @curwin =) (:w_next @curwin)))
            ;; skip original window and windows with 'noscrollbind'
            (when (and (!= @curwin old_curwin) @(:wo_scb (:w_options @curwin)))
                ;; do the vertical scroll

                (when want_ver
                    ((ร @curwin.w_scbind_pos =) (+ (:w_scbind_pos @curwin) topline_diff))
                    ((ร long topline =) (:w_scbind_pos @curwin))
                    (if (> topline (:ml_line_count (:b_ml @curbuf)))
                        ((ร topline =) (:ml_line_count (:b_ml @curbuf)))
                    )
                    (if (< topline 1)
                        ((ร topline =) 1)
                    )

                    ((ร long y =) (- topline (:w_topline @curwin)))
                    (if (< 0 y)
                        (scrollup y)
                        (scrolldown (- y)))

                    (redraw-later VALID)
                    (cursor-correct)
                    ((ร @curwin.w_redr_status =) true)
                )

                ;; do the horizontal scroll

                (when (and want_hor (!= (:w_leftcol @curwin) tgt_leftcol))
                    ((ร @curwin.w_leftcol =) tgt_leftcol)
                    (leftcol-changed)
                )
            )
        )

        ;; reset current-window

        (reset! VIsual_select old_VIsual_select)
        (reset! VIsual_active old_VIsual_active)
        (reset! curwin old_curwin)
        nil
    ))

;; Command character that's ignored.
;; Used for CTRL-Q and CTRL-S to avoid problems with terminals that use xon/xoff.

(defn- #_void nv-ignore [#_cmdarg_C cap]
    (ยง
        ((ร cap.retval =) (| (:retval cap) CA_COMMAND_BUSY))      ;; don't call edit() now
        nil
    ))

;; Command character that doesn't do anything, but unlike nv-ignore()
;; does start edit().  Used for "startinsert" executed while starting up.

(defn- #_void nv-nop [#_cmdarg_C _cap]
    nil)

;; Command character doesn't exist.

(defn- #_void nv-error [#_cmdarg_C cap]
    (clearopbeep (:oap cap))
    nil)

;; CTRL-A and CTRL-X: Add or subtract from letter or number under cursor.

(defn- #_void nv-addsub [#_cmdarg_C cap]
    (when (and (not (checkclearopq (:oap cap))) (do-addsub (:cmdchar cap), (:count1 cap)))
        (prep-redo-cmd cap)
    )
    nil)

;; CTRL-F, CTRL-B, etc: Scroll page up or down.

(defn- #_void nv-page [#_cmdarg_C cap]
    (when (not (checkclearop (:oap cap)))
        (if (non-flag? @mod_mask MOD_MASK_CTRL)
            (onepage (:arg cap), (:count1 cap)))
    )
    nil)

;; Implementation of "gd" and "gD" command.

(defn- #_void nv-gd [#_oparg_C oap, #_int nchar, #_boolean thisblock]
    ;; thisblock: true for "1gd" and "1gD"
    (ยง
        ((ร Bytes[] ptr =) (ร new Bytes[1]))
        ((ร int len =) (find-ident-under-cursor ptr, FIND_IDENT))
        (when (or (zero? len) (not (find_decl (... ptr 0), len, (== nchar (byte \d)), thisblock, 0)))
            (clearopbeep oap)
        )
        nil
    ))

;; Move 'dist' lines in direction 'dir',
;; counting lines by *screen* lines rather than lines in the file.
;; 'dist' must be positive.
;;
;; Return true if able to move cursor, false otherwise.

(defn- #_boolean nv-screengo [#_oparg_C oap, #_int dir, #_long dist]
    (ยง
        ((ร boolean retval =) true)
        ((ร boolean atend =) false)

        ((ร int linelen =) (linetabsize (ml-get-curline)))

        ((ร oap.motion_type =) MCHAR)
        ((ร oap.inclusive =) (== (:w_curswant @curwin) MAXCOL))

        ((ร int col_off1 =) (curwin-col-off))                ;; margin offset for first screen line
        ((ร int col_off2 =) (- col_off1 (curwin-col-off2)))    ;; margin offset for wrapped screen line
        ((ร int width1 =) (- (:w_width @curwin) col_off1))         ;; text width for first screen line
        ((ร int width2 =) (- (:w_width @curwin) col_off2))         ;; test width for wrapped screen line
        (if (zero? width2)
            ((ร width2 =) 1)                                 ;; avoid divide by zero
        )

        (when (non-zero? (:w_width @curwin))
            ;; Instead of sticking at the last character of the buffer line we
            ;; try to stick in the last column of the screen.

            (cond (== (:w_curswant @curwin) MAXCOL)
            (do
                ((ร atend =) true)
                (validate-virtcol)
                (cond (<= width1 0)
                (do
                    ((ร @curwin.w_curswant =) 0)
                )
                :else
                (do
                    ((ร @curwin.w_curswant =) (dec width1))
                    (if (< (:w_curswant @curwin) (:w_virtcol @curwin))
                        ((ร @curwin.w_curswant =) (+ (:w_curswant @curwin) (* (inc (/ (- (:w_virtcol @curwin) (:w_curswant @curwin) 1) width2)) width2)))
                    )
                ))
            )
            :else
            (do
                ((ร int n =) (if (< width1 linelen) (+ (* (inc (/ (- linelen width1 1) width2)) width2) width1) width1))
                (if (< (inc n) (:w_curswant @curwin))
                    ((ร @curwin.w_curswant =) (- (:w_curswant @curwin) (* (inc (/ (- (:w_curswant @curwin) n) width2)) width2)))
                )
            ))

            (while (< 0 (ร dist--))
                (cond (== dir BACKWARD)
                (do
                    (cond (<= width2 (long (:w_curswant @curwin)))
                    (do
                        ;; move back within line
                        ((ร @curwin.w_curswant =) (- (:w_curswant @curwin) width2))
                    )
                    :else
                    (do
                        ;; to previous line
                        (when (== (:lnum (:w_cursor @curwin)) 1)
                            ((ร retval =) false)
                            (ร BREAK)
                        )
                        (ร --@curwin.w_cursor.lnum)
                        ((ร linelen =) (linetabsize (ml-get-curline)))
                        (if (< width1 linelen)
                            ((ร @curwin.w_curswant =) (+ (:w_curswant @curwin) (* (inc (/ (- linelen width1 1) width2)) width2)))
                        )
                    ))
                )
                :else ;; dir == FORWARD
                (do
                    ((ร int n =) (if (< width1 linelen) (+ (* (inc (/ (- linelen width1 1) width2)) width2) width1) width1))
                    (cond (< (+ (:w_curswant @curwin) width2) n)
                    (do
                        ;; move forward within line
                        ((ร @curwin.w_curswant =) (+ (:w_curswant @curwin) width2))
                    )
                    :else
                    (do
                        ;; to next line
                        (when (== (:lnum (:w_cursor @curwin)) (:ml_line_count (:b_ml @curbuf)))
                            ((ร retval =) false)
                            (ร BREAK)
                        )
                        (ร @curwin.w_cursor.lnum++)
                        ((ร @curwin.w_curswant =) (% (:w_curswant @curwin) width2))
                        ((ร linelen =) (linetabsize (ml-get-curline)))
                    ))
                ))
            )
        )

        (if (and (virtual-active) atend)
            (coladvance MAXCOL)
            (coladvance (:w_curswant @curwin)))

        (when (and (< 0 (:col (:w_cursor @curwin))) @(:wo_wrap (:w_options @curwin)))
            (ร int virtcol)

            ;; Check for landing on a character that got split at the end of the
            ;; last line.  We want to advance a screenline, not end up in the same
            ;; screenline or move two screenlines.

            (validate-virtcol)
            ((ร virtcol =) (:w_virtcol @curwin))
            (if (and (> virtcol width1) (non-eos? @p_sbr))
                ((ร virtcol =) (- virtcol (mb-string2cells @p_sbr, -1)))
            )

            (when (and (< (:w_curswant @curwin) virtcol) (if (< (:w_curswant @curwin) width1) (> (:w_curswant @curwin) (/ width1 2)) (> (% (- (:w_curswant @curwin) width1) width2) (/ width2 2))))
                (ร --@curwin.w_cursor.col)
            )
        )

        (if atend
            ((ร @curwin.w_curswant =) MAXCOL)     ;; stick in the last column
        )

        retval
    ))

;; Handle CTRL-E and CTRL-Y commands: scroll a line up or down.
;; cap.arg must be TRUE for CTRL-E.

(defn- #_void nv-scroll-line [#_cmdarg_C cap]
    (when (not (checkclearop (:oap cap)))
        (scroll-redraw (non-zero? (:arg cap)), (:count1 cap))
    )
    nil)

;; Scroll "count" lines up or down, and redraw.

(defn- #_void scroll-redraw [#_boolean up, #_long count]
    (ยง
        ((ร long prev_topline =) (:w_topline @curwin))
        ((ร long prev_lnum =) (:lnum (:w_cursor @curwin)))

        (if up
            (scrollup count)
            (scrolldown count))
        (when (non-zero? @p_so)
            ;; Adjust the cursor position for 'scrolloff'.  Mark w_topline as valid,
            ;; otherwise the screen jumps back at the end of the file.
            (cursor-correct)
            (check-cursor-moved @curwin)
            ((ร @curwin.w_valid =) (| (:w_valid @curwin) VALID_TOPLINE))

            ;; If moved back to where we were, at least move the cursor, otherwise
            ;; we get stuck at one position.  Don't move the cursor up if the
            ;; first line of the buffer is already on the screen.
            (while (== (:w_topline @curwin) prev_topline)
                (cond up
                (do
                    (if (or (< prev_lnum (:lnum (:w_cursor @curwin))) (not (cursor-down 1, false)))
                        (ร BREAK)
                    )
                )
                :else
                (do
                    (if (or (< (:lnum (:w_cursor @curwin)) prev_lnum) (== prev_topline 1) (not (cursor-up 1, false)))
                        (ร BREAK)
                    )
                ))
                ;; Mark w_topline as valid, otherwise the screen jumps back at the end of the file.
                (check-cursor-moved @curwin)
                ((ร @curwin.w_valid =) (| (:w_valid @curwin) VALID_TOPLINE))
            )
        )
        (if (!= (:lnum (:w_cursor @curwin)) prev_lnum)
            (coladvance (:w_curswant @curwin)))
        (redraw-later VALID)
        nil
    ))

;; Commands that start with "z".

(defn- #_void nv-zet [#_cmdarg_C cap]
    (ยง
        ((ร int nchar =) @(:nchar cap))

;       dozet:
        (when (asc-isdigit nchar)
            ;; "z123{nchar}": edit the count before obtaining {nchar}

            (if (checkclearop (:oap cap))
                ((ร RETURN) nil)
            )

            ((ร FOR) (ร ((ร long n =) (- nchar (byte \0))) true nil)
                (swap! no_mapping inc)
                (swap! allow_keys inc)   ;; no mapping for nchar, but allow key codes
                ((ร nchar =) (plain-vgetc))
                (swap! no_mapping dec)
                (swap! allow_keys dec)

                (add-to-showcmd nchar)

                (cond (or (== nchar K_DEL) (== nchar K_KDEL))
                (do
                    ((ร n =) (/ n 10))
                )
                (asc-isdigit nchar)
                (do
                    ((ร n =) (+ (* n 10) (- nchar (byte \0))))
                )
                (== nchar CAR)
                (do
                    (win-setheight (int n))
                    (ร BREAK)
                )
                (or (== nchar (byte \l)) (== nchar (byte \h)) (== nchar K_LEFT) (== nchar K_RIGHT))
                (do
                    ((ร cap.count1 =) (if (non-zero? n) (* n (:count1 cap)) (:count1 cap)))
                    (ร BREAK dozet)
                )
                :else
                (do
                    (clearopbeep (:oap cap))
                    (ร BREAK)
                ))
            )

            ((ร cap.oap.op_type =) OP_NOP)
            ((ร RETURN) nil)
        )

        (if (checkclearop (:oap cap))
            ((ร RETURN) nil)
        )

        ;; For "z+", "z<CR>", "zt", "z.", "zz", "z^", "z-", "zb":
        ;; If line number given, set cursor.

        (when (and (non-nil? (vim-strchr (u8 "+\r\nt.z^-b"), nchar)) (non-zero? (:count0 cap)) (!= (:count0 cap) (:lnum (:w_cursor @curwin))))
            (setpcmark)
            ((ร @curwin.w_cursor.lnum =) (if (< (:ml_line_count (:b_ml @curbuf)) (:count0 cap)) (:ml_line_count (:b_ml @curbuf)) (:count0 cap)))
            (check-cursor-col)
        )

        ((ร SWITCH) nchar
            ((ร CASE) (byte \+))   ;; "z+", "z<CR>" and "zt": put cursor at top of screen
            (do
                (when (zero? (:count0 cap))
                    ;; No count given: put cursor at the line below screen.
                    (validate-botline) ;; make sure w_botline is valid
                    ((ร @curwin.w_cursor.lnum =) (if (< (:ml_line_count (:b_ml @curbuf)) (:w_botline @curwin)) (:ml_line_count (:b_ml @curbuf)) (:w_botline @curwin)))
                )
                (ร FALLTHROUGH)
            )

            ((ร CASE) NL)
            ((ร CASE) CAR)
            ((ร CASE) K_KENTER)
            (do
                (beginline (| BL_WHITE BL_FIX))
                (ร FALLTHROUGH)
            )

            ((ร CASE) (byte \t))
            (do
                (scroll-cursor-top 0, true)
                (redraw-later VALID)
                (ร BREAK)
            )

            ((ร CASE) (byte \.))   ;; "z." and "zz": put cursor in middle of screen
            (do
                (beginline (| BL_WHITE BL_FIX))
                (ร FALLTHROUGH)
            )

            ((ร CASE) (byte \z))
            (do
                (scroll-cursor-halfway true)
                (redraw-later VALID)
                (ร BREAK)
            )

            ((ร CASE) (byte \^))   ;; "z^", "z-" and "zb": put cursor at bottom of screen
            (do
                ;; Strange Vi behavior:
                ;; <count>z^ finds line at top of window when <count> is at bottom of window,
                ;; and puts that one at bottom of window.
                (cond (non-zero? (:count0 cap))
                (do
                    (scroll-cursor-bot 0, true)
                    ((ร @curwin.w_cursor.lnum =) (:w_topline @curwin))
                )
                (== (:w_topline @curwin) 1)
                (do
                    ((ร @curwin.w_cursor.lnum =) 1)
                )
                :else
                (do
                    ((ร @curwin.w_cursor.lnum =) (- (:w_topline @curwin) 1))
                ))
                (ร FALLTHROUGH)
            )

            ((ร CASE) (byte \-))
            (do
                (beginline (| BL_WHITE BL_FIX))
                (ร FALLTHROUGH)
            )

            ((ร CASE) (byte \b))
            (do
                (scroll-cursor-bot 0, true)
                (redraw-later VALID)
                (ร BREAK)
            )

            ((ร CASE) (byte \H))   ;; "zH" - scroll screen right half-page
            (do
                ((ร cap.count1 =) (* (:count1 cap) (/ (:w_width @curwin) 2)))
                (ร FALLTHROUGH)
            )

            ((ร CASE) (byte \h))   ;; "zh" - scroll screen to the right
            ((ร CASE) K_LEFT)
            (do
                (when (not @(:wo_wrap (:w_options @curwin)))
                    (if (< (:w_leftcol @curwin) (int (:count1 cap)))
                        ((ร @curwin.w_leftcol =) 0)
                        ((ร @curwin.w_leftcol =) (- (:w_leftcol @curwin) (int (:count1 cap))))
                    )
                    (leftcol-changed)
                )
                (ร BREAK)
            )

            ((ร CASE) (byte \L))   ;; "zL" - scroll screen left half-page
            (do
                ((ร cap.count1 =) (* (:count1 cap) (/ (:w_width @curwin) 2)))
                (ร FALLTHROUGH)
            )

            ((ร CASE) (byte \l))   ;; "zl" - scroll screen to the left
            ((ร CASE) K_RIGHT)
            (do
                (when (not @(:wo_wrap (:w_options @curwin)))
                    ;; scroll the window left
                    ((ร @curwin.w_leftcol =) (+ (:w_leftcol @curwin) (int (:count1 cap))))
                    (leftcol-changed)
                )
                (ร BREAK)
            )

            ((ร CASE) (byte \s))   ;; "zs" - scroll screen, cursor at the start
            (do
                (when (not @(:wo_wrap (:w_options @curwin)))
                    ((ร int[] col =) (ร new int[1]))
                    (getvcol @curwin, (:w_cursor @curwin), col, nil, nil)
                    (if (< @p_siso (long (... col 0)))
                        ((ร col[0] =) (- (... col 0) @p_siso))
                        ((ร col[0] =) 0)
                    )
                    (when (!= (:w_leftcol @curwin) (... col 0))
                        ((ร @curwin.w_leftcol =) (... col 0))
                        (redraw-later NOT_VALID)
                    )
                )
                (ร BREAK)
            )

            ((ร CASE) (byte \e))   ;; "ze" - scroll screen, cursor at the end
            (do
                (when (not @(:wo_wrap (:w_options @curwin)))
                    ((ร int[] col =) (ร new int[1]))
                    (getvcol @curwin, (:w_cursor @curwin), nil, nil, col)
                    ((ร long n =) (- (:w_width @curwin) (curwin-col-off)))
                    (if (< (+ (long (... col 0)) @p_siso) n)
                        ((ร col[0] =) 0)
                        ((ร col[0] =) (+ (... col 0) (+ (- @p_siso n) 1)))
                    )
                    (when (!= (:w_leftcol @curwin) (... col 0))
                        ((ร @curwin.w_leftcol =) (... col 0))
                        (redraw-later NOT_VALID)
                    )
                )
                (ร BREAK)
            )

            (ร DEFAULT)
            (do
                (clearopbeep (:oap cap))
                (ร BREAK)
            )
        )
        nil
    ))

;; "Q" command.

(defn- #_void nv-exmode [#_cmdarg_C cap]
    (ยง
        ;; Ignore 'Q' in Visual mode, just give a beep.

        (cond @VIsual_active
        (do
            (vim-beep)
        )
        (not (checkclearop (:oap cap)))
        (do
;           do_exmode(false);
        ))
        nil
    ))

;; Handle a ":" command.

(defn- #_void nv-colon [#_cmdarg_C cap]
    (ยง
        (cond @VIsual_active
        (do
            (nv-operator cap)
        )
        :else
        (do
            (cond (!= (:op_type (:oap cap)) OP_NOP)
            (do
                ;; Using ":" as a movement is characterwise exclusive.
                ((ร cap.oap.motion_type =) MCHAR)
                ((ร cap.oap.inclusive =) false)
            )
            (non-zero? (:count0 cap))
            (do
                ;; translate "count:" into ":.,.+(count - 1)"
                (stuffcharReadbuff (byte \.))
                (when (< 1 (:count0 cap))
                    (stuffReadbuff (u8 ",.+"))
                    (stuffnumReadbuff (- (:count0 cap) 1))
                )
            ))

            ;; When typing, don't type below an old message.
            (if @keyTyped
                (compute-cmdrow))

            ((ร boolean old_p_im =) @p_im)

            ;; get a command line and execute it
            ((ร boolean cmd_result =) (do-cmdline nil, true, (if (!= (:op_type (:oap cap)) OP_NOP) DOCMD_KEEPLINE 0)))

            ;; If 'insertmode' changed, enter or exit Insert mode.
            (when (!= @p_im old_p_im)
                (if @p_im
                    (reset! restart_edit (byte \i))
                    (reset! restart_edit 0))
            )

            (cond (not cmd_result)
            (do
                ;; The Ex command failed, do not execute the operator.
                (clearop (:oap cap))
            )
            (and (!= (:op_type (:oap cap)) OP_NOP) (or (< (:ml_line_count (:b_ml @curbuf)) (:lnum (:op_start (:oap cap)))) (< (STRLEN (ml-get (:lnum (:op_start (:oap cap))))) (:col (:op_start (:oap cap)))) @did_emsg))
            (do
                ;; The start of the operator has become invalid by the Ex command.
                (clearopbeep (:oap cap))
            ))
        ))
        nil
    ))

;; Handle CTRL-G command.

(defn- #_void nv-ctrlg [#_cmdarg_C cap]
    (ยง
        (cond @VIsual_active  ;; toggle Selection/Visual mode
        (do
            (reset! VIsual_select (not @VIsual_select))
            (showmode)
        )
        (not (checkclearop (:oap cap)))
        (do
            ;; print full name if count given
            (fileinfo (int (:count0 cap)), true)
        ))
        nil
    ))

;; Handle CTRL-H <Backspace> command.

(defn- #_void nv-ctrlh [#_cmdarg_C cap]
    (ยง
        (cond (and @VIsual_active @VIsual_select)
        (do
            ((ร cap.cmdchar =) (byte \x))  ;; BS key behaves like 'x' in Select mode
            (v-visop cap)
        )
        :else
        (do
            (nv-left cap)
        ))
        nil
    ))

;; CTRL-L: clear screen and redraw.

(defn- #_void nv-clear [#_cmdarg_C cap]
    (when (not (checkclearop (:oap cap)))
        (redraw-later CLEAR)
    )
    nil)

;; CTRL-O: In Select mode: switch to Visual mode for one command.
;; Otherwise: Go to older pcmark.

(defn- #_void nv-ctrlo [#_cmdarg_C cap]
    (ยง
        (cond (and @VIsual_active @VIsual_select)
        (do
            (reset! VIsual_select false)
            (showmode)
            (reset! restart_VIsual_select 2)      ;; restart Select mode later
        )
        :else
        (do
            ((ร cap.count1 =) (- (:count1 cap)))
            (nv-pcmark cap)
        ))
        nil
    ))

;; CTRL-^ command, short for ":e #"

(defn- #_void nv-hat [#_cmdarg_C cap]
    (ยง
        (when (not (checkclearopq (:oap cap)))
;           buflist_getfile((int)cap.count0, 0, GETF_SETMARK|GETF_ALT, false);
        )
        nil
    ))

;; "Z" commands.

(defn- #_void nv-Zet [#_cmdarg_C cap]
    (ยง
        (when (not (checkclearopq (:oap cap)))
            ((ร SWITCH) @(:nchar cap)
                ;; "ZZ": equivalent to ":x".
                ((ร CASE) (byte \Z))
                (do
                    (do-cmdline-cmd (u8 "x"))
                    (ร BREAK)
                )

                ;; "ZQ": equivalent to ":q!" (Elvis compatible).
                ((ร CASE) (byte \Q))
                (do
                    (do-cmdline-cmd (u8 "q!"))
                    (ร BREAK)
                )

                (ร DEFAULT)
                (do
                    (clearopbeep (:oap cap))
                    (ร BREAK)
                )
            )
        )
        nil
    ))

;; Call nv-ident() as if "c1" was used, with "c2" as next character.

(defn- #_void do-nv-ident [#_int c1, #_int c2]
    (ยง
        ((ร oparg_C oa =) (NEW_oparg_C))
        ((ร cmdarg_C ca =) (NEW_cmdarg_C))

        ((ร ca.oap =) oa)
        ((ร ca.cmdchar =) c1)
        ((ร ca.@nchar =) c2)
        (nv-ident ca)
        nil
    ))

;; Handle the commands that use the word under the cursor.
;; [g] CTRL-]   :ta to current identifier
;; [g] 'K'      run program for current identifier
;; [g] '*'      / to current identifier or string
;; [g] '#'      ? to current identifier or string
;;  g  ']'      :tselect for current identifier

(defn- #_void nv-ident [#_cmdarg_C cap]
    (ยง
        ((ร int cmdchar =) (:cmdchar cap))

        ((ร boolean g_cmd =) (== cmdchar (byte \g)))
        (if g_cmd                          ;; "g*", "g#", "g]" and "gCTRL-]"
            ((ร cmdchar =) @(:nchar cap))
        )

        (if (== cmdchar (char_u POUND))       ;; the pound sign, '#' for English keyboards
            ((ร cmdchar =) (byte \#))
        )

; %%    ((ร Bytes[] ident =) (ร { null }))
; %%    ((ร int[] n =) (ร { 0 }))

        ;; The "]", "CTRL-]" and "K" commands accept an argument in Visual mode.

        (when (or (== cmdchar (byte \])) (== cmdchar Ctrl_RSB) (== cmdchar (byte \K)))
            (if (and @VIsual_active (not (get-visual-text cap, ident, n)))
                ((ร RETURN) nil)
            )
            (if (checkclearopq (:oap cap))
                ((ร RETURN) nil)
            )
        )

        (when (nil? (... ident 0))
            ((ร int type =) (if (or (== cmdchar (byte \*)) (== cmdchar (byte \#))) (| FIND_IDENT FIND_STRING) FIND_IDENT))
            ((ร n[0] =) (find-ident-under-cursor ident, type))
            (when (zero? (... n 0))
                (clearop (:oap cap))
                ((ร RETURN) nil)
            )
        )

        ;; Allocate buffer to put the command in.
        ;; Inserting backslashes can double the length of the word.
        ;; "curbuf.b_p_kp" could be added and some numbers.

        ((ร Bytes kp =) @(:b_p_kp @curbuf))    ;; value of 'keywordprg'

        ((ร Bytes buf =) (Bytes. (+ (* (... n 0) 2) 30 (STRLEN kp))))
        (eos! buf)

        ((ร boolean tag_cmd =) false)

        ((ร SWITCH) cmdchar
            ((ร CASE) (byte \*))
            ((ร CASE) (byte \#))
            (do
                ;; Put cursor at start of word, makes search skip the word under the cursor.
                ;; Call setpcmark() first, so "*``" puts the cursor back where it was.

                (setpcmark)
                ((ร @curwin.w_cursor.col =) (BDIFF (... ident 0), (ml-get-curline)))

                (if (and (not g_cmd) (us-iswordp (... ident 0), @curbuf))
                    (STRCPY buf, (u8 "\\<")))
                (reset! no_smartcase true)        ;; don't use 'smartcase' now
                (ร BREAK)
            )

            ((ร CASE) (byte \K))
            (do
                ;; An external command will probably use an argument starting
                ;; with "-" as an option.  To avoid trouble we skip the "-".

                ((ร FOR) (ร nil (and (< 0 (... n 0)) (== (.at (... ident 0) 0) (byte \-))) (ร --n[0]))
                    ((ร ident[0] =) (.plus (... ident 0) 1))
                )
                (when (zero? (... n 0))
                    (emsg e_noident)        ;; found dashes only
                    ((ร RETURN) nil)
                )

                ;; When a count is given, turn it into a range.  Is this really what we want?
                (if (non-zero? (:count0 cap))
                    (.sprintf libC buf, (u8 ".,.+%ld"), (- (:count0 cap) 1))
                )

                (if (!= (.at kp 0) (byte \:))
                    (STRCAT buf, (u8 "!")))
                (STRCAT buf, (if (!= (.at kp 0) (byte \:)) kp (.plus kp 1)))
                (STRCAT buf, (u8 " "))
                (ร BREAK)
            )

            ((ร CASE) (byte \]))
            (do
                ((ร tag_cmd =) true)
                (STRCPY buf, (u8 "ts "))
                (ร BREAK)
            )

            (ร DEFAULT)
            (do
                ((ร tag_cmd =) true)
                (if g_cmd
                    (STRCPY buf, (u8 "tj "))
                    (.sprintf libC buf, (u8 "%ldta "), (:count0 cap))
                )
                (ร BREAK)
            )
        )

        ;; Now grab the chars in the identifier

        (ร Bytes aux)
        (cond (== cmdchar (byte \*))
        (do
            ((ร aux =) (if @p_magic (u8 "/.*~[^$\\") (u8 "/^$\\")))
        )
        (== cmdchar (byte \#))
        (do
            ((ร aux =) (if @p_magic (u8 "/?.*~[^$\\") (u8 "/?^$\\")))
        )
        tag_cmd
        (do
            ((ร aux =) (u8 "\\|\"\n["))
        )
        :else
        (do
            ((ร aux =) (u8 "\\|\"\n*?["))
        ))

        ((ร Bytes p =) (.plus buf (STRLEN buf)))
        (while (< 0 (ร n[0]--))
            ;; put a backslash before \ and some others
            (if (non-nil? (vim-strchr aux, (.at (... ident 0) 0)))
                (.be ((ร p =) (.plus p 1)) -1, (byte \\))
            )

            ;; When current byte is part of multibyte character, copy all bytes of the character.
            ((ร FOR) (ร ((ร int i =) (ร 0, len = us-ptr2len-cc(ident[0]) - 1)) (and (< i len) (<= 1 (... n 0))) (ร ++i, --n[0]))
                (.be ((ร p =) (.plus p 1)) -1, (.at ((ร ident[0] =) (.plus (... ident 0) 1)) -1))
            )

            (.be ((ร p =) (.plus p 1)) -1, (.at ((ร ident[0] =) (.plus (... ident 0) 1)) -1))
        )
        (eos! p)

        ;; Execute the command.

        (cond (or (== cmdchar (byte \*)) (== cmdchar (byte \#)))
        (do
            (if (and (not g_cmd) (us-iswordp (us-prevptr (ml-get-curline), (... ident 0)), @curbuf))
                (STRCAT buf, (u8 "\\>")))
            ;; put pattern in search history
            (init-history)
            (add-to-history HIST_SEARCH, buf, NUL)
            (normal-search cap, (if (== cmdchar (byte \*)) (byte \/) (byte \?)), buf, 0)
        )
        :else
        (do
            (do-cmdline-cmd buf)
        ))
        nil
    ))

;; Get visually selected text, within one line only.
;; Returns false if more than one line selected.

(defn- #_boolean get-visual-text [#_cmdarg_C cap, #_Bytes* pp, #_int* lenp]
    ;; pp: return: start of selected text
    ;; lenp: return: length of selected text
    (ยง
        (if (!= @VIsual_mode (byte \V))
            (unadjust-for-sel))
        (when (!= (:lnum @VIsual) (:lnum (:w_cursor @curwin)))
            (if (non-nil? cap)
                (clearopbeep (:oap cap)))
            ((ร RETURN) false)
        )
        (cond (== @VIsual_mode (byte \V))
        (do
            ((ร pp[0] =) (ml-get-curline))
            ((ร lenp[0] =) (STRLEN (... pp 0)))
        )
        :else
        (do
            (cond (ltpos (:w_cursor @curwin), @VIsual)
            (do
                ((ร pp[0] =) (ml-get-pos (:w_cursor @curwin)))
                ((ร lenp[0] =) (+ (- (:col @VIsual) (:col (:w_cursor @curwin))) 1))
            )
            :else
            (do
                ((ร pp[0] =) (ml-get-pos @VIsual))
                ((ร lenp[0] =) (+ (- (:col (:w_cursor @curwin)) (:col @VIsual)) 1))
            ))

            ;; Correct the length to include the whole last character.
            ((ร lenp[0] =) (+ (... lenp 0) (- (us-ptr2len-cc (.plus (... pp 0) (- (... lenp 0) 1))) 1)))
        ))
        (reset-VIsual-and-resel)
        true
    ))

;; Handle scrolling command 'H', 'L' and 'M'.

(defn- #_void nv-scroll [#_cmdarg_C cap]
    (ยง
        ((ร cap.oap.motion_type =) MLINE)
        (setpcmark)

        (cond (== (:cmdchar cap) (byte \L))
        (do
            (validate-botline)         ;; make sure curwin.w_botline is valid
            ((ร @curwin.w_cursor.lnum =) (- (:w_botline @curwin) 1))
            (cond (<= (:lnum (:w_cursor @curwin)) (- (:count1 cap) 1))
            (do
                ((ร @curwin.w_cursor.lnum =) 1)
            )
            :else
            (do
                ((ร @curwin.w_cursor.lnum =) (- (:lnum (:w_cursor @curwin)) (- (:count1 cap) 1)))
            ))
        )
        :else
        (do
            (ร long n)
            (cond (== (:cmdchar cap) (byte \M))
            (do
                (validate-botline)     ;; make sure w_empty_rows is valid

                ((ร int half =) (/ (+ (- (:w_height @curwin) (:w_empty_rows @curwin)) 1) 2))
                ((ร int used =) 0)
                ((ร FOR) (ร ((ร n =) 0) (< (+ (:w_topline @curwin) n) (:ml_line_count (:b_ml @curbuf))) (ร n++))
                    ((ร used =) (+ used (plines (+ (:w_topline @curwin) n))))
                    (if (<= half used)
                        (ร BREAK)
                    )
                )
                (if (and (< 0 n) (< (:w_height @curwin) used))
                    (ร --n)
                )
            )
            :else ;; (cap.cmdchar == 'H')
            (do
                ((ร n =) (- (:count1 cap) 1))
            ))
            ((ร @curwin.w_cursor.lnum =) (+ (:w_topline @curwin) n))
            (if (> (:lnum (:w_cursor @curwin)) (:ml_line_count (:b_ml @curbuf)))
                ((ร @curwin.w_cursor.lnum =) (:ml_line_count (:b_ml @curbuf)))
            )
        ))

        (cursor-correct)   ;; correct for 'so'
        (beginline (| BL_SOL BL_FIX))
        nil
    ))

;; Cursor right commands.

(defn- #_void nv-right [#_cmdarg_C cap]
    (ยง
        (when (flag? @mod_mask (| MOD_MASK_SHIFT MOD_MASK_CTRL))
            ;; <C-Right> and <S-Right> move a word or WORD right
            (if (flag? @mod_mask MOD_MASK_CTRL)
                ((ร cap.arg =) TRUE)
            )
            (nv-wordcmd cap)
            ((ร RETURN) nil)
        )

        ((ร cap.oap.motion_type =) MCHAR)
        ((ร cap.oap.inclusive =) false)
        ((ร boolean past_line =) (and @VIsual_active (!= (.at @p_sel 0) (byte \o))))

        ;; In virtual edit mode, there's no such thing as "past_line",
        ;; as lines are (theoretically) infinitely long.

        (if (virtual-active)
            ((ร past_line =) false)
        )

        ((ร FOR) (ร ((ร long n =) (:count1 cap)) (< 0 n) (ร --n))
            (cond (or (and (not past_line) (not (oneright))) (and past_line (eos? (ml-get-cursor))))
            (do
                ;;    <Space> wraps to next line if 'whichwrap' has 's'.
                ;;        'l' wraps to next line if 'whichwrap' has 'l'.
                ;; CURS_RIGHT wraps to next line if 'whichwrap' has '>'.

                (when (and (or (and (== (:cmdchar cap) (byte \space)) (non-nil? (vim-strchr @p_ww, (byte \s)))) (and (== (:cmdchar cap) (byte \l)) (non-nil? (vim-strchr @p_ww, (byte \l)))) (and (== (:cmdchar cap) K_RIGHT) (non-nil? (vim-strchr @p_ww, (byte \>))))) (< (:lnum (:w_cursor @curwin)) (:ml_line_count (:b_ml @curbuf))))
                    ;; When deleting we also count the NL as a character.
                    ;; Set cap.oap.inclusive when last char in the line is
                    ;; included, move to next line after that
                    (cond (and (!= (:op_type (:oap cap)) OP_NOP) (not (:inclusive (:oap cap))) (not (lineempty (:lnum (:w_cursor @curwin)))))
                    (do
                        ((ร cap.oap.inclusive =) true)
                    )
                    :else
                    (do
                        (ร @curwin.w_cursor.lnum++)
                        ((ร @curwin.w_cursor.col =) 0)
                        ((ร @curwin.w_cursor.coladd =) 0)
                        ((ร @curwin.w_set_curswant =) true)
                        ((ร cap.oap.inclusive =) false)
                    ))
                    (ร CONTINUE)
                )
                (cond (== (:op_type (:oap cap)) OP_NOP)
                (do
                    ;; Only beep and flush if not moved at all.
                    (if (== n (:count1 cap))
                        (beep-flush))
                )
                :else
                (do
                    (if (not (lineempty (:lnum (:w_cursor @curwin))))
                        ((ร cap.oap.inclusive =) true)
                    )
                ))
                (ร BREAK)
            )
            past_line
            (do
                ((ร @curwin.w_set_curswant =) true)
                (if (virtual-active)
                    (oneright)
                    ((ร @curwin.w_cursor.col =) (+ (:col (:w_cursor @curwin)) (us-ptr2len-cc (ml-get-cursor))))
                )
            ))
        )
        nil
    ))

;; Cursor left commands.
;;
;; Returns true when operator end should not be adjusted.

(defn- #_void nv-left [#_cmdarg_C cap]
    (ยง
        (when (flag? @mod_mask (| MOD_MASK_SHIFT MOD_MASK_CTRL))
            ;; <C-Left> and <S-Left> move a word or WORD left
            (if (flag? @mod_mask MOD_MASK_CTRL)
                ((ร cap.arg =) 1)
            )
            (nv-bck-word cap)
            ((ร RETURN) nil)
        )

        ((ร cap.oap.motion_type =) MCHAR)
        ((ร cap.oap.inclusive =) false)

        ((ร FOR) (ร ((ร long n =) (:count1 cap)) (< 0 n) (ร --n))
            (when (not (oneleft))
                ;; <BS> and <Del> wrap to previous line if 'whichwrap' has 'b'.
                ;;           'h' wraps to previous line if 'whichwrap' has 'h'.
                ;;     CURS_LEFT wraps to previous line if 'whichwrap' has '<'.

                (cond (and (or (and (or (== (:cmdchar cap) K_BS) (== (:cmdchar cap) Ctrl_H)) (non-nil? (vim-strchr @p_ww, (byte \b)))) (or (and (== (:cmdchar cap) (byte \h)) (non-nil? (vim-strchr @p_ww, (byte \h)))) (and (== (:cmdchar cap) K_LEFT) (non-nil? (vim-strchr @p_ww, (byte \<)))))) (< 1 (:lnum (:w_cursor @curwin))))
                (do
                    (ร --@curwin.w_cursor.lnum)
                    (coladvance MAXCOL)
                    ((ร @curwin.w_set_curswant =) true)

                    ;; When the NL before the first char has to be deleted we
                    ;; put the cursor on the NUL after the previous line.
                    ;; This is a very special case, be careful!
                    ;; Don't adjust op_end now, otherwise it won't work.
                    (when (and (or (== (:op_type (:oap cap)) OP_DELETE) (== (:op_type (:oap cap)) OP_CHANGE)) (not (lineempty (:lnum (:w_cursor @curwin)))))
                        ((ร Bytes cp =) (ml-get-cursor))

                        (if (non-eos? cp)
                            ((ร @curwin.w_cursor.col =) (+ (:col (:w_cursor @curwin)) (us-ptr2len-cc cp)))
                        )
                        ((ร cap.retval =) (| (:retval cap) CA_NO_ADJ_OP_END))
                    )
                    (ร CONTINUE)
                )
                ;; Only beep and flush if not moved at all.
                (and (== (:op_type (:oap cap)) OP_NOP) (== n (:count1 cap)))
                (do
                    (beep-flush)
                ))
                (ร BREAK)
            )
        )
        nil
    ))

;; Cursor up commands.
;; cap.arg is TRUE for "-": Move cursor to first non-blank.

(defn- #_void nv-up [#_cmdarg_C cap]
    (ยง
        (cond (flag? @mod_mask MOD_MASK_SHIFT)
        (do
            ;; <S-Up> is page up
            ((ร cap.arg =) BACKWARD)
            (nv-page cap)
        )
        :else
        (do
            ((ร cap.oap.motion_type =) MLINE)
            (cond (not (cursor-up (:count1 cap), (== (:op_type (:oap cap)) OP_NOP)))
            (do
                (clearopbeep (:oap cap))
            )
            (non-zero? (:arg cap))
            (do
                (beginline (| BL_WHITE BL_FIX))
            ))
        ))
        nil
    ))

;; Cursor down commands.
;; cap.arg is TRUE for CR and "+": Move cursor to first non-blank.

(defn- #_void nv-down [#_cmdarg_C cap]
    (ยง
        (cond (flag? @mod_mask MOD_MASK_SHIFT)
        (do
            ;; <S-Down> is page down
            ((ร cap.arg =) FORWARD)
            (nv-page cap)
        )
        :else
        (do
            ;; In the cmdline window a <CR> executes the command.
            (cond (and (non-zero? @cmdwin_type) (== (:cmdchar cap) CAR))
            (do
                (reset! cmdwin_result CAR)
            )
            :else
            (do
                ((ร cap.oap.motion_type =) MLINE)
                (cond (not (cursor-down (:count1 cap), (== (:op_type (:oap cap)) OP_NOP)))
                (do
                    (clearopbeep (:oap cap))
                )
                (non-zero? (:arg cap))
                (do
                    (beginline (| BL_WHITE BL_FIX))
                ))
            ))
        ))
        nil
    ))

;; <End> command: to end of current line or last line.

(defn- #_void nv-end [#_cmdarg_C cap]
    (ยง
        (when (or (non-zero? (:arg cap)) (flag? @mod_mask MOD_MASK_CTRL))    ;; CTRL-END = goto last line
            ((ร cap.arg =) TRUE)
            (nv-goto cap)
            ((ร cap.count1 =) 1)             ;; to end of current line
        )
        (nv-dollar cap)
        nil
    ))

;; Handle the "$" command.

(defn- #_void nv-dollar [#_cmdarg_C cap]
    (ยง
        ((ร cap.oap.motion_type =) MCHAR)
        ((ร cap.oap.inclusive =) true)

        ;; In virtual mode when off the edge of a line and an operator
        ;; is pending (whew!) keep the cursor where it is.
        ;; Otherwise, send it to the end of the line.

        (if (or (not (virtual-active)) (!= (gchar-cursor) NUL) (== (:op_type (:oap cap)) OP_NOP))
            ((ร @curwin.w_curswant =) MAXCOL)     ;; so we stay at the end
        )
        (when (not (cursor-down (- (:count1 cap) 1), (== (:op_type (:oap cap)) OP_NOP)))
            (clearopbeep (:oap cap))
        )
        nil
    ))

;; Implementation of '?' and '/' commands.
;; If cap.arg is TRUE, don't set PC mark.

(defn- #_void nv-search [#_cmdarg_C cap]
    (ยง
        ((ร oparg_C oap =) (:oap cap))

        (when (and (== (:cmdchar cap) (byte \?)) (== (:op_type (:oap cap)) OP_ROT13))
            ;; Translate "g??" to "g?g?".
            ((ร cap.cmdchar =) (byte \g))
            ((ร cap.@nchar =) (byte \?))
            (nv-operator cap)
            ((ร RETURN) nil)
        )

        ((ร cap.searchbuf =) (getcmdline (:cmdchar cap), (:count1 cap)))

        (when (nil? (:searchbuf cap))
            (clearop oap)
            ((ร RETURN) nil)
        )

        (normal-search cap, (byte (:cmdchar cap)), (:searchbuf cap), (if (non-zero? (:arg cap)) 0 SEARCH_MARK))
        nil
    ))

;; Handle "N" and "n" commands.
;; cap.arg is SEARCH_REV for "N", 0 for "n".

(defn- #_void nv-next [#_cmdarg_C cap]
    (ยง
        ((ร pos_C old =) (NEW_pos_C))
        (COPY-pos old, (:w_cursor @curwin))
        ((ร int i =) (normal-search cap, NUL, nil, (| SEARCH_MARK (:arg cap))))

        (when (and (== i 1) (eqpos old, (:w_cursor @curwin)))
            ;; Avoid getting stuck on the current cursor position, which can
            ;; happen when an offset is given and the cursor is on the last char
            ;; in the buffer: Repeat with count + 1.
            ((ร cap.count1 =) (+ (:count1 cap) 1))
            (normal-search cap, NUL, nil, (| SEARCH_MARK (:arg cap)))
            ((ร cap.count1 =) (- (:count1 cap) 1))
        )
        nil
    ))

;; Search for "pat" in direction "dirc" ('/' or '?', 0 for repeat).
;; Uses only cap.count1 and cap.oap from "cap".
;; Return 0 for failure, 1 for found, 2 for found and line offset added.

(defn- #_int normal-search [#_cmdarg_C cap, #_byte dirc, #_Bytes pat, #_int opt]
    ;; opt: extra flags for do-search()
    (ยง
        ((ร cap.oap.motion_type =) MCHAR)
        ((ร cap.oap.inclusive =) false)
        ((ร cap.oap.use_reg_one =) true)
        ((ร @curwin.w_set_curswant =) true)

        ((ร int i =) (do-search (:oap cap), dirc, pat, (:count1 cap), (| opt SEARCH_OPT SEARCH_ECHO SEARCH_MSG), nil))
        (cond (zero? i)
        (do
            (clearop (:oap cap))
        )
        :else
        (do
            (if (== i 2)
                ((ร cap.oap.motion_type =) MLINE)
            )
            ((ร @curwin.w_cursor.coladd =) 0)
        ))

        ;; "/$" will put the cursor after the end of the line, may need to correct that here
        (check-cursor)
        i
    ))

;; Character search commands.
;; cap.arg is BACKWARD for 'F' and 'T', FORWARD for 'f' and 't', TRUE for ',' and FALSE for ';'.
;; cap.nchar is NUL for ',' and ';' (repeat the search).

(defn- #_void nv-csearch [#_cmdarg_C cap]
    (ยง
        ((ร boolean t_cmd =) (or (== (:cmdchar cap) (byte \t)) (== (:cmdchar cap) (byte \T))))

        ((ร cap.oap.motion_type =) MCHAR)
        (cond (or (is-special @(:nchar cap)) (not (searchc cap, t_cmd)))
        (do
            (clearopbeep (:oap cap))
        )
        :else
        (do
            ((ร @curwin.w_set_curswant =) true)
            ;; Include a Tab for "tx" and for "dfx".
            (cond (and (== (gchar-cursor) TAB) (virtual-active) (== (:arg cap) FORWARD) (or t_cmd (!= (:op_type (:oap cap)) OP_NOP)))
            (do
                ((ร int[] scol =) (ร new int[1]))
                ((ร int[] ecol =) (ร new int[1]))

                (getvcol @curwin, (:w_cursor @curwin), scol, nil, ecol)
                ((ร @curwin.w_cursor.coladd =) (- (... ecol 0) (... scol 0)))
            )
            :else
            (do
                ((ร @curwin.w_cursor.coladd =) 0)
            ))
            (adjust-for-sel cap)
        ))
        nil
    ))

;; "[" and "]" commands.
;; cap.arg is BACKWARD for "[" and FORWARD for "]".

(defn- #_void nv-brackets [#_cmdarg_C cap]
    (ยง
        ((ร cap.oap.motion_type =) MCHAR)
        ((ร cap.oap.inclusive =) false)
        ((ร pos_C old_pos =) (NEW_pos_C))
        (COPY-pos old_pos, (:w_cursor @curwin))     ;; cursor position before command
        ((ร @curwin.w_cursor.coladd =) 0)             ;; TODO: don't do this for an error

        ((ร pos_C prev_pos =) (NEW_pos_C))

        ;; "[{", "[(", "]}" or "])": go to Nth unclosed '{', '(', '}' or ')'
        ;; "[#", "]#": go to start/end of Nth innermost #if..#endif construct.
        ;; "[/", "[*", "]/", "]*": go to Nth comment start/end.
        ;; "[m" or "]m" search for prev/next start of (Java) method.
        ;; "[M" or "]M" search for prev/next end of (Java) method.

        (cond (or (and (== (:cmdchar cap) (byte \[)) (non-nil? (vim-strchr (u8 "{(*/#mM"), @(:nchar cap)))) (and (== (:cmdchar cap) (byte \])) (non-nil? (vim-strchr (u8 "})*/#mM"), @(:nchar cap)))))
        (do
            (if (== @(:nchar cap) (byte \*))
                ((ร cap.@nchar =) (byte \/))
            )

            (ร int findc)
            (ร long n)
            (cond (or (== @(:nchar cap) (byte \m)) (== @(:nchar cap) (byte \M)))
            (do
                ((ร findc =) (if (== (:cmdchar cap) (byte \[)) (byte \{) (byte \})))
                ((ร n =) 9999)
            )
            :else
            (do
                ((ร findc =) @(:nchar cap))
                ((ร n =) (:count1 cap))
            ))

            ((ร pos_C pos =) nil)
            ((ร prev_pos.lnum =) 0)
            ((ร pos_C new_pos =) (NEW_pos_C))

            ((ร FOR) (ร nil (< 0 n) (ร --n))
                ((ร pos =) (findmatchlimit (:oap cap), findc, (if (== (:cmdchar cap) (byte \[)) FM_BACKWARD FM_FORWARD), 0))
                (when (nil? pos)
                    (cond (zero? (:lnum new_pos)) ;; nothing found
                    (do
                        (if (and (!= @(:nchar cap) (byte \m)) (!= @(:nchar cap) (byte \M)))
                            (clearopbeep (:oap cap)))
                    )
                    :else
                    (do
                        ((ร pos =) new_pos)      ;; use last one found
                    ))
                    (ร BREAK)
                )
                (COPY-pos prev_pos, new_pos)
                (COPY-pos (:w_cursor @curwin), pos)
                (COPY-pos new_pos, pos)
            )
            (COPY-pos (:w_cursor @curwin), old_pos)

            ;; Handle "[m", "]m", "[M" and "[M".  The findmatchlimit() only
            ;; brought us to the match for "[m" and "]M" when inside a method.
            ;; Try finding the '{' or '}' we want to be at.
            ;; Also repeat for the given count.

            (when (or (== @(:nchar cap) (byte \m)) (== @(:nchar cap) (byte \M)))
                ;; norm is true for "]M" and "[m"
                ((ร boolean norm =) (== (== findc (byte \{)) (== @(:nchar cap) (byte \m))))

                ((ร n =) (:count1 cap))
                ;; found a match: we were inside a method
                (cond (non-zero? (:lnum prev_pos))
                (do
                    ((ร pos =) prev_pos)
                    (COPY-pos (:w_cursor @curwin), prev_pos)
                    (if norm
                        (ร --n)
                    )
                )
                :else
                (do
                    ((ร pos =) nil)
                ))
                ((ร FOR) (ร nil (< 0 n) (ร --n))
                    (while true
                        (when (< (if (== findc (byte \{)) (dec-cursor) (inc-cursor)) 0)
                            ;; if not found anything, that's an error
                            (if (nil? pos)
                                (clearopbeep (:oap cap)))
                            ((ร n =) 0)
                            (ร BREAK)
                        )
                        ((ร int c =) (gchar-cursor))
                        (when (or (== c (byte \{)) (== c (byte \})))
                            ;; Must have found end/start of class: use it.
                            ;; Or found the place to be at.
                            (cond (or (and (== c findc) norm) (and (== n 1) (not norm)))
                            (do
                                (COPY-pos new_pos, (:w_cursor @curwin))
                                ((ร pos =) new_pos)
                                ((ร n =) 0)
                            )
                            ;; If no match found at all, we started outside of the class
                            ;; and we're inside now.  Just go on.
                            (zero? (:lnum new_pos))
                            (do
                                (COPY-pos new_pos, (:w_cursor @curwin))
                                ((ร pos =) new_pos)
                            )
                            ;; found start/end of other method: go to match
                            (nil? ((ร pos =) (findmatchlimit (:oap cap), findc, (if (== (:cmdchar cap) (byte \[)) FM_BACKWARD FM_FORWARD), 0)))
                            (do
                                ((ร n =) 0)
                            )
                            :else
                            (do
                                (COPY-pos (:w_cursor @curwin), pos)
                            ))
                            (ร BREAK)
                        )
                    )
                )
                (COPY-pos (:w_cursor @curwin), old_pos)
                (if (and (nil? pos) (non-zero? (:lnum new_pos)))
                    (clearopbeep (:oap cap)))
            )
            (when (non-nil? pos)
                (setpcmark)
                (COPY-pos (:w_cursor @curwin), pos)
                ((ร @curwin.w_set_curswant =) true)
            )
        )

        ;; "[[", "[]", "]]" and "][": move to start or end of function

        (or (== @(:nchar cap) (byte \[)) (== @(:nchar cap) (byte \])))
        (do
            ((ร int flag =) (if (== @(:nchar cap) (:cmdchar cap)) (byte \{) (byte \})))   ;; "]]" or "[[" ;; "][" or "[]"

            ((ร @curwin.w_set_curswant =) true)

            ;; Imitate strange Vi behaviour: When using "]]" with an operator we also stop at '}'.

            (ร boolean b)
;           { boolean[] __ = { cap.oap.inclusive }; b = findpar(__, cap.arg, cap.count1, flag, (cap.oap.op_type != OP_NOP && cap.arg == FORWARD && flag == (byte \{))); cap.oap.inclusive = __[0]; }
            (cond (not b)
            (do
                (clearopbeep (:oap cap))
            )
            :else
            (do
                (if (== (:op_type (:oap cap)) OP_NOP)
                    (beginline (| BL_WHITE BL_FIX)))
            ))
        )

        ;; "[p", "[P", "]P" and "]p": put with indent adjustment

        (or (== @(:nchar cap) (byte \p)) (== @(:nchar cap) (byte \P)))
        (do
            (when (not (checkclearop (:oap cap)))
                ((ร int dir =) (if (and (== (:cmdchar cap) (byte \])) (== @(:nchar cap) (byte \p))) FORWARD BACKWARD))
                ((ร int regname =) (:regname (:oap cap)))
                ((ร boolean was_visual =) @VIsual_active)
                ((ร long line_count =) (:ml_line_count (:b_ml @curbuf)))

                ((ร pos_C start =) (NEW_pos_C))
                ((ร pos_C end =) (NEW_pos_C))
                (when @VIsual_active
                    (COPY-pos start, (if (ltoreq @VIsual, (:w_cursor @curwin)) @VIsual (:w_cursor @curwin)))
                    (COPY-pos end, (if (eqpos start, @VIsual) (:w_cursor @curwin) @VIsual))
                    (COPY-pos (:w_cursor @curwin), (if (== dir BACKWARD) start end))
                )

                ((ร regname =) (adjust-clip-reg regname))
                (prep-redo-cmd cap)

                (do-put regname, dir, (int (:count1 cap)), PUT_FIXINDENT)

                (when was_visual
                    (COPY-pos @VIsual, start)
                    (COPY-pos (:w_cursor @curwin), end)
                    (when (== dir BACKWARD)
                        ;; adjust lines
                        ((ร @VIsual.lnum =) (+ (:lnum @VIsual) (- (:ml_line_count (:b_ml @curbuf)) line_count)))
                        ((ร @curwin.w_cursor.lnum =) (+ (:lnum (:w_cursor @curwin)) (- (:ml_line_count (:b_ml @curbuf)) line_count)))
                    )

                    (reset! VIsual_active true)
                    (when (== @VIsual_mode (byte \V))
                        ;; delete visually selected lines
                        ((ร cap.cmdchar =) (byte \d))
                        ((ร cap.@nchar =) NUL)
                        ((ร cap.oap.regname =) regname)
                        (nv-operator cap)
                        (do-pending-operator cap, 0, false)
                    )
                    (when @VIsual_active
                        (end-visual-mode)
                        (redraw-later SOME_VALID)
                    )
                )
            )
        )

        ;; "['", "[`", "]'" and "]`": jump to next mark

        (or (== @(:nchar cap) (byte \')) (== @(:nchar cap) (byte \`)))
        (do
            ((ร pos_C pos =) (:w_cursor @curwin))
            ((ร FOR) (ร ((ร long n =) (:count1 cap)) (< 0 n) (ร --n))
                (COPY-pos prev_pos, pos)
                ((ร pos =) (getnextmark pos, (if (== (:cmdchar cap) (byte \[)) BACKWARD FORWARD), (== @(:nchar cap) (byte \'))))
                (if (nil? pos)
                    (ร BREAK)
                )
            )
            (if (nil? pos)
                ((ร pos =) prev_pos)
            )
            (nv-cursormark cap, (== @(:nchar cap) (byte \')), pos)
        )

        ;; Not a valid cap.nchar.
        :else
        (do
            (clearopbeep (:oap cap))
        ))
        nil
    ))

;; Handle Normal mode "%" command.

(defn- #_void nv-percent [#_cmdarg_C cap]
    (ยง
        ((ร cap.oap.inclusive =) true)
        (cond (non-zero? (:count0 cap))                ;; {cnt}% : goto {cnt} percentage in file
        (do
            (cond (< 100 (:count0 cap))
            (do
                (clearopbeep (:oap cap))
            )
            :else
            (do
                ((ร cap.oap.motion_type =) MLINE)
                (setpcmark)
                ;; Round up, so CTRL-G will give same value.
                ;; Watch out for a large line count, the line number must not go negative!
                ((ร @curwin.w_cursor.lnum =) (if (< 1000000 (:ml_line_count (:b_ml @curbuf)))
                    (* (/ (+ (:ml_line_count (:b_ml @curbuf)) 99) 100) (:count0 cap))
                    (/ (+ (* (:ml_line_count (:b_ml @curbuf)) (:count0 cap)) 99) 100)
                ))
                (if (> (:lnum (:w_cursor @curwin)) (:ml_line_count (:b_ml @curbuf)))
                    ((ร @curwin.w_cursor.lnum =) (:ml_line_count (:b_ml @curbuf)))
                )
                (beginline (| BL_SOL BL_FIX))
            ))
        )
        :else                            ;; "%" : go to matching paren
        (do
            ((ร cap.oap.motion_type =) MCHAR)
            ((ร cap.oap.use_reg_one =) true)

            ((ร pos_C pos =) (findmatch (:oap cap), NUL))
            (cond (nil? pos)
            (do
                (clearopbeep (:oap cap))
            )
            :else
            (do
                (setpcmark)
                (COPY-pos (:w_cursor @curwin), pos)
                ((ร @curwin.w_set_curswant =) true)
                ((ร @curwin.w_cursor.coladd =) 0)
                (adjust-for-sel cap)
            ))
        ))
        nil
    ))

;; Handle "(" and ")" commands.
;; cap.arg is BACKWARD for "(" and FORWARD for ")".

(defn- #_void nv-brace [#_cmdarg_C cap]
    (ยง
        ((ร cap.oap.motion_type =) MCHAR)
        ((ร cap.oap.use_reg_one =) true)
        ;; The motion used to be inclusive for "(", but that is not what Vi does.
        ((ร cap.oap.inclusive =) false)
        ((ร @curwin.w_set_curswant =) true)

        (cond (not (findsent (:arg cap), (:count1 cap)))
        (do
            (clearopbeep (:oap cap))
        )
        :else
        (do
            ;; Don't leave the cursor on the NUL past end of line.
            (adjust-cursor (:oap cap))
            ((ร @curwin.w_cursor.coladd =) 0)
        ))
        nil
    ))

;; "m" command: Mark a position.

(defn- #_void nv-mark [#_cmdarg_C cap]
    (when (not (checkclearop (:oap cap)))
        (if (not (setmark @(:nchar cap)))
            (clearopbeep (:oap cap)))
    )
    nil)

;; "{" and "}" commands.
;; cmd.arg is BACKWARD for "{" and FORWARD for "}".

(defn- #_void nv-findpar [#_cmdarg_C cap]
    (ยง
        ((ร cap.oap.motion_type =) MCHAR)
        ((ร cap.oap.inclusive =) false)
        ((ร cap.oap.use_reg_one =) true)
        ((ร @curwin.w_set_curswant =) true)
        (ร boolean b)
;       { boolean[] __ = { cap.oap.inclusive }; b = findpar(__, cap.arg, cap.count1, NUL, false); cap.oap.inclusive = __[0]; }
        (if (not b)
            (clearopbeep (:oap cap))
            ((ร @curwin.w_cursor.coladd =) 0)
        )
        nil
    ))

;; "u" command: Undo or make lower case.

(defn- #_void nv-undo [#_cmdarg_C cap]
    (ยง
        (cond (or (== (:op_type (:oap cap)) OP_LOWER) @VIsual_active)
        (do
            ;; translate "<Visual>u" to "<Visual>gu" and "guu" to "gugu"
            ((ร cap.cmdchar =) (byte \g))
            ((ร cap.@nchar =) (byte \u))
            (nv-operator cap)
        )
        :else
        (do
            (nv-kundo cap)
        ))
        nil
    ))

;; <Undo> command.

(defn- #_void nv-kundo [#_cmdarg_C cap]
    (ยง
        (when (not (checkclearopq (:oap cap)))
            (u-undo (int (:count1 cap)))
            ((ร @curwin.w_set_curswant =) true)
        )
        nil
    ))

;; Handle the "r" command.

(defn- #_void nv-replace [#_cmdarg_C cap]
    (ยง
        (if (checkclearop (:oap cap))
            ((ร RETURN) nil)
        )

        ;; get another character
        (ร int had_ctrl_v)
        (cond (== @(:nchar cap) Ctrl_V)
        (do
            ((ร had_ctrl_v =) Ctrl_V)
            ((ร cap.@nchar =) (get-literal))
            ;; Don't redo a multibyte character with CTRL-V.
            (if (< DEL @(:nchar cap))
                ((ร had_ctrl_v =) NUL)
            )
        )
        :else
        (do
            ((ร had_ctrl_v =) NUL)
        ))

        ;; Abort if the character is a special key.
        (when (is-special @(:nchar cap))
            (clearopbeep (:oap cap))
            ((ร RETURN) nil)
        )

        ;; Visual mode "r".
        (when @VIsual_active
            (if @got_int
                (reset-VIsual))
            (when (!= had_ctrl_v NUL)
                (cond (== @(:nchar cap) (byte \return))
                (do
                    ((ร cap.@nchar =) -1)
                )
                (== @(:nchar cap) (byte \newline))
                (do
                    ((ร cap.@nchar =) -2)
                ))
            )
            (nv-operator cap)
            ((ร RETURN) nil)
        )

        ;; Break tabs, etc.
        (when (virtual-active)
            (if (not (u-save-cursor))
                ((ร RETURN) nil)
            )
            (cond (== (gchar-cursor) NUL)
            (do
                ;; Add extra space and put the cursor on the first one.
                (coladvance-force (int (+ (getviscol) (:count1 cap))))
                ((ร @curwin.w_cursor.col =) (- (:col (:w_cursor @curwin)) (:count1 cap)))
            )
            (== (gchar-cursor) TAB)
            (do
                (coladvance-force (getviscol))
            ))
        )

        ;; Abort if not enough characters to replace.
        ((ร Bytes ptr =) (ml-get-cursor))
        (when (or (< (STRLEN ptr) (:count1 cap)) (< (us-charlen ptr) (:count1 cap)))
            (clearopbeep (:oap cap))
            ((ร RETURN) nil)
        )

        ;; Replacing with a TAB is done by edit() when it is complicated because
        ;; 'expandtab' or 'smarttab' is set.  CTRL-V TAB inserts a literal TAB.
        ;; Other characters are done below to avoid problems with things like
        ;; CTRL-V 048 (for edit() this would be R CTRL-V 0 ESC).

        (when (and (!= had_ctrl_v Ctrl_V) (== @(:nchar cap) TAB) (or @(:b_p_et @curbuf) @p_sta))
            (stuffnumReadbuff (:count1 cap))
            (stuffcharReadbuff (byte \R))
            (stuffcharReadbuff TAB)
            (stuffcharReadbuff ESC)
            ((ร RETURN) nil)
        )

        ;; save line for undo
        (if (not (u-save-cursor))
            ((ร RETURN) nil)
        )

        (cond (and (!= had_ctrl_v Ctrl_V) (or (== @(:nchar cap) (byte \return)) (== @(:nchar cap) (byte \newline))))
        (do
            ;; Replace character(s) by a single newline.
            ;; Strange vi behaviour: Only one newline is inserted.
            ;; Delete the characters here.
            ;; Insert the newline with an insert command, takes care of
            ;; autoindent.  The insert command depends on being on the last
            ;; character of a line or not.

            (del-chars (int (:count1 cap)), false)      ;; delete the characters
            (stuffcharReadbuff (byte \return))
            (stuffcharReadbuff ESC)

            ;; Give 'r' to edit(), to get the redo command right.
            (invoke-edit cap, true, (byte \r), false)
        )
        :else
        (do
            (prep-redo (:regname (:oap cap)), (:count1 cap), NUL, (byte \r), NUL, had_ctrl_v, @(:nchar cap))

            (COPY-pos (:b_op_start @curbuf), (:w_cursor @curwin))

;           {
                ((ร int old_State =) @State)

                (if (non-zero? (:ncharC1 cap))
                    (appendCharToRedobuff (:ncharC1 cap)))
                (if (non-zero? (:ncharC2 cap))
                    (appendCharToRedobuff (:ncharC2 cap)))

                ;; This is slow, but it handles replacing a single-byte with a
                ;; multi-byte and the other way around.  Also handles adding
                ;; composing characters for utf-8.
                ((ร FOR) (ร ((ร long n =) (:count1 cap)) (< 0 n) (ร --n))
                    (reset! State REPLACE)
                    (cond (or (== @(:nchar cap) Ctrl_E) (== @(:nchar cap) Ctrl_Y))
                    (do
                        ((ร int c =) (ins-copychar (+ (:lnum (:w_cursor @curwin)) (if (== @(:nchar cap) Ctrl_Y) -1 1))))
                        (cond (!= c NUL)
                        (do
                            (ins-char c)
                        )
                        :else
                        (do
                            ;; will be decremented further down
                            (ร @curwin.w_cursor.col++)
                        ))
                    )
                    :else
                    (do
                        (ins-char @(:nchar cap))
                    ))
                    (reset! State old_State)
                    (if (non-zero? (:ncharC1 cap))
                        (ins-char (:ncharC1 cap)))
                    (if (non-zero? (:ncharC2 cap))
                        (ins-char (:ncharC2 cap)))
                )
;           }

            (ร --@curwin.w_cursor.col)      ;; cursor on the last replaced char

            ;; If the character on the left of the current cursor
            ;; is a multi-byte character, move two characters left.
            (mb-adjust-pos @curbuf, (:w_cursor @curwin))
            (COPY-pos (:b_op_end @curbuf), (:w_cursor @curwin))
            ((ร @curwin.w_set_curswant =) true)
            (set-last-insert @(:nchar cap))
        ))
        nil
    ))

;; 'o': Exchange start and end of Visual area.
;; 'O': same, but in block mode exchange left and right corners.

(defn- #_void v-swap-corners [#_int cmdchar]
    (ยง
        (cond (and (== cmdchar (byte \O)) (== @VIsual_mode Ctrl_V))
        (do
            ((ร pos_C old_cursor =) (NEW_pos_C))
            (COPY-pos old_cursor, (:w_cursor @curwin))
            ((ร int[] left =) (ร new int[1]))
            ((ร int[] right =) (ร new int[1]))
            (getvcols @curwin, old_cursor, @VIsual, left, right)
            ((ร @curwin.w_cursor.lnum =) (:lnum @VIsual))
            (coladvance (... left 0))
            (COPY-pos @VIsual, (:w_cursor @curwin))

            ((ร @curwin.w_cursor.lnum =) (:lnum old_cursor))
            ((ร @curwin.w_curswant =) (... right 0))
            ;; 'selection "exclusive" and cursor at right-bottom corner: move it right one column
            (if (and (<= (:lnum @VIsual) (:lnum old_cursor)) (== (.at @p_sel 0) (byte \e)))
                (ร @curwin.w_curswant++)
            )
            (coladvance (:w_curswant @curwin))
            (when (and (== (:col (:w_cursor @curwin)) (:col old_cursor)) (or (not (virtual-active)) (== (:coladd (:w_cursor @curwin)) (:coladd old_cursor))))
                ((ร @curwin.w_cursor.lnum =) (:lnum @VIsual))
                (if (and (<= (:lnum old_cursor) (:lnum @VIsual)) (== (.at @p_sel 0) (byte \e)))
                    (ร right[0]++)
                )
                (coladvance (... right 0))
                (COPY-pos @VIsual, (:w_cursor @curwin))

                ((ร @curwin.w_cursor.lnum =) (:lnum old_cursor))
                (coladvance (... left 0))
                ((ร @curwin.w_curswant =) (... left 0))
            )
        )
        :else
        (do
            ((ร pos_C old_cursor =) (NEW_pos_C))
            (COPY-pos old_cursor, (:w_cursor @curwin))
            (COPY-pos (:w_cursor @curwin), @VIsual)
            (COPY-pos @VIsual, old_cursor)
            ((ร @curwin.w_set_curswant =) true)
        ))
        nil
    ))

;; "R" (cap.arg is FALSE) and "gR" (cap.arg is TRUE).

(defn- #_void nv-Replace [#_cmdarg_C cap]
    (ยง
        (cond @VIsual_active          ;; "R" is replace lines
        (do
            ((ร cap.cmdchar =) (byte \c))
            ((ร cap.@nchar =) NUL)
            (reset! VIsual_mode_orig @VIsual_mode) ;; remember original area for gv
            (reset! VIsual_mode (byte \V))
            (nv-operator cap)
        )
        (not (checkclearopq (:oap cap)))
        (do
            (if (virtual-active)
                (coladvance (getviscol)))
            (invoke-edit cap, false, (if (non-zero? (:arg cap)) (byte \V) (byte \R)), false)
        ))
        nil
    ))

;; "gr".

(defn- #_void nv-vreplace [#_cmdarg_C cap]
    (ยง
        (cond @VIsual_active
        (do
            ((ร cap.cmdchar =) (byte \r))
            ((ร cap.@nchar =) @(:extra_char cap))
            (nv-replace cap)        ;; do same as "r" in Visual mode for now
        )
        (not (checkclearopq (:oap cap)))
        (do
            (if (== @(:extra_char cap) Ctrl_V)       ;; get another character
                ((ร cap.@extra_char =) (get-literal))
            )
            (stuffcharReadbuff @(:extra_char cap))
            (stuffcharReadbuff ESC)
            (if (virtual-active)
                (coladvance (getviscol)))
            (invoke-edit cap, true, (byte \v), false)
        ))
        nil
    ))

;; Swap case for "~" command, when it does not work like an operator.

(defn- #_void n-swapchar [#_cmdarg_C cap]
    (ยง
        (if (checkclearopq (:oap cap))
            ((ร RETURN) nil)
        )

        (when (and (lineempty (:lnum (:w_cursor @curwin))) (nil? (vim-strchr @p_ww, (byte \~))))
            (clearopbeep (:oap cap))
            ((ร RETURN) nil)
        )

        (prep-redo-cmd cap)

        (if (not (u-save-cursor))
            ((ร RETURN) nil)
        )

        ((ร boolean did_change =) false)

        ((ร pos_C startpos =) (NEW_pos_C))
        (COPY-pos startpos, (:w_cursor @curwin))

        ((ร FOR) (ร ((ร long n =) (:count1 cap)) (< 0 n) (ร --n))
            ((ร did_change =) (| did_change (swapchar (:op_type (:oap cap)), (:w_cursor @curwin))))
            (inc-cursor)
            (when (== (gchar-cursor) NUL)
                (cond (and (non-nil? (vim-strchr @p_ww, (byte \~))) (< (:lnum (:w_cursor @curwin)) (:ml_line_count (:b_ml @curbuf))))
                (do
                    (ร @curwin.w_cursor.lnum++)
                    ((ร @curwin.w_cursor.col =) 0)
                    (when (< 1 n)
                        (if (not (u-savesub (:lnum (:w_cursor @curwin))))
                            (ร BREAK)
                        )
                        (u-clearline)
                    )
                )
                :else
                (do
                    (ร BREAK)
                ))
            )
        )

        (check-cursor)
        ((ร @curwin.w_set_curswant =) true)

        (when did_change
            (changed-lines (:lnum startpos), (:col startpos), (+ (:lnum (:w_cursor @curwin)) 1), 0)
            (COPY-pos (:b_op_start @curbuf), startpos)
            (COPY-pos (:b_op_end @curbuf), (:w_cursor @curwin))
            (if (< 0 (:col (:b_op_end @curbuf)))
                (ร --@curbuf.b_op_end.col)
            )
        )
        nil
    ))

;; Move cursor to mark.

(defn- #_void nv-cursormark [#_cmdarg_C cap, #_boolean flag, #_pos_C pos]
    (ยง
        (cond (not (check-mark pos))
        (do
            (clearop (:oap cap))
        )
        :else
        (do
            (if (or (== (:cmdchar cap) (byte \')) (== (:cmdchar cap) (byte \`)) (== (:cmdchar cap) (byte \[)) (== (:cmdchar cap) (byte \])))
                (setpcmark))
            (COPY-pos (:w_cursor @curwin), pos)
            (if flag
                (beginline (| BL_WHITE BL_FIX))
                (check-cursor))
        ))
        ((ร cap.oap.motion_type =) (if flag MLINE MCHAR))
        (if (== (:cmdchar cap) (byte \`))
            ((ร cap.oap.use_reg_one =) true)
        )
        ((ร cap.oap.inclusive =) false)              ;; ignored if not MCHAR
        ((ร @curwin.w_set_curswant =) true)
        nil
    ))

(final Bytes visop_trans (u8 "YyDdCcxdXdAAIIrr"))

;; Handle commands that are operators in Visual mode.

(defn- #_void v-visop [#_cmdarg_C cap]
    (ยง
        ;; Uppercase means linewise, except in block mode,
        ;; then "D" deletes, and "C" replaces till EOL.
        (when (asc-isupper (:cmdchar cap))
            (cond (!= @VIsual_mode Ctrl_V)
            (do
                (reset! VIsual_mode_orig @VIsual_mode)
                (reset! VIsual_mode (byte \V))
            )
            (or (== (:cmdchar cap) (byte \C)) (== (:cmdchar cap) (byte \D)))
            (do
                ((ร @curwin.w_curswant =) MAXCOL)
            ))
        )
        ((ร cap.cmdchar =) (.at (vim-strchr visop_trans, (:cmdchar cap)) 1))
        (nv-operator cap)
        nil
    ))

;; "s" and "S" commands.

(defn- #_void nv-subst [#_cmdarg_C cap]
    (ยง
        (cond @VIsual_active  ;; "vs" and "vS" are the same as "vc"
        (do
            (when (== (:cmdchar cap) (byte \S))
                (reset! VIsual_mode_orig @VIsual_mode)
                (reset! VIsual_mode (byte \V))
            )
            ((ร cap.cmdchar =) (byte \c))
            (nv-operator cap)
        )
        :else
        (do
            (nv-optrans cap)
        ))
        nil
    ))

;; Abbreviated commands.

(defn- #_void nv-abbrev [#_cmdarg_C cap]
    (ยง
        (if (or (== (:cmdchar cap) K_DEL) (== (:cmdchar cap) K_KDEL))
            ((ร cap.cmdchar =) (byte \x))          ;; DEL key behaves like 'x'
        )

        ;; in Visual mode these commands are operators
        (if @VIsual_active
            (v-visop cap)
            (nv-optrans cap))
        nil
    ))

(final Bytes* #_"[/*8*/]" optrans_ar
    [
        (u8 "dl"), (u8 "dh"),
        (u8 "d$"), (u8 "c$"),
        (u8 "cl"), (u8 "cc"),
        (u8 "yy"), (u8 ":s\r")
    ])
(final Bytes optrans_str (u8 "xXDCsSY&"))

;; Translate a command into another command.

(defn- #_void nv-optrans [#_cmdarg_C cap]
    (ยง
        (when (not (checkclearopq (:oap cap)))
            ;; In Vi "2D" doesn't delete the next line.
            ;; Can't translate it either, because "2." should also not use the count.
            (cond (and (== (:cmdchar cap) (byte \D)) (non-nil? (vim-strbyte @p_cpo, CPO_HASH)))
            (do
                (COPY-pos (:op_start (:oap cap)), (:w_cursor @curwin))
                ((ร cap.oap.op_type =) OP_DELETE)
                ((ร cap.count1 =) 1)
                (nv-dollar cap)
                (reset! finish_op true)
                (resetRedobuff)
                (appendCharToRedobuff (byte \D))
            )
            :else
            (do
                (if (non-zero? (:count0 cap))
                    (stuffnumReadbuff (:count0 cap)))
                (stuffReadbuff (... optrans_ar (BDIFF (vim-strchr optrans_str, (:cmdchar cap)), optrans_str)))
            ))
        )
        ((ร cap.opcount =) 0)
        nil
    ))

;; "'" and "`" commands.  Also for "g'" and "g`".
;; cap.arg is TRUE for "'" and "g'".

(defn- #_void nv-gomark [#_cmdarg_C cap]
    (ยง
        ((ร int c =) (if (== (:cmdchar cap) (byte \g)) @(:extra_char cap) @(:nchar cap)))

        ((ร pos_C pos =) (getmark c, (== (:op_type (:oap cap)) OP_NOP)))
        (cond (== pos NOPOS)   ;; jumped to other file
        (do
            (cond (non-zero? (:arg cap))
            (do
                (check-cursor-lnum)
                (beginline (| BL_WHITE BL_FIX))
            )
            :else
            (do
                (check-cursor)
            ))
        )
        :else
        (do
            (nv-cursormark cap, (non-zero? (:arg cap)), pos)
        ))

        ;; May need to clear the coladd that a mark includes.
        (when (not (virtual-active))
            ((ร @curwin.w_cursor.coladd =) 0)
        )
        nil
    ))

;; Handle CTRL-O, CTRL-I, "g;" and "g," commands.

(defn- #_void nv-pcmark [#_cmdarg_C cap]
    (ยง
        (ร pos_C pos)

        (when (not (checkclearopq (:oap cap)))
            ((ร pos =) (if (== (:cmdchar cap) (byte \g))
                (movechangelist (int (:count1 cap)))
                (movemark (int (:count1 cap)))
            ))
            (cond (== pos NOPOS)           ;; jump to other file
            (do
                ((ร @curwin.w_set_curswant =) true)
                (check-cursor)
            )
            (non-nil? pos)               ;; can jump
            (do
                (nv-cursormark cap, false, pos)
            )
            (== (:cmdchar cap) (byte \g))
            (do
                (cond (zero? (:b_changelistlen @curbuf))
                (do
                    (emsg (u8 "E664: changelist is empty"))
                )
                (< (:count1 cap) 0)
                (do
                    (emsg (u8 "E662: At start of changelist"))
                )
                :else
                (do
                    (emsg (u8 "E663: At end of changelist"))
                ))
            )
            :else
            (do
                (clearopbeep (:oap cap))
            ))
        )
        nil
    ))

;; Handle '"' command.

(defn- #_void nv-regname [#_cmdarg_C cap]
    (ยง
        (if (checkclearop (:oap cap))
            ((ร RETURN) nil)
        )
        (if (== @(:nchar cap) (byte \=))
            ((ร cap.@nchar =) (get-expr-register))
        )
        (cond (and (!= @(:nchar cap) NUL) (valid-yank-reg @(:nchar cap), false))
        (do
            ((ร cap.oap.regname =) @(:nchar cap))
            ((ร cap.opcount =) (:count0 cap))       ;; remember count before '"'
        )
        :else
        (do
            (clearopbeep (:oap cap))
        ))
        nil
    ))

;; Handle "v", "V" and "CTRL-V" commands.
;; Also for "gh", "gH" and "g^H" commands: Always start Select mode, cap.arg is TRUE.
;; Handle CTRL-Q just like CTRL-V.

(defn- #_void nv-visual [#_cmdarg_C cap]
    (ยง
        (if (== (:cmdchar cap) Ctrl_Q)
            ((ร cap.cmdchar =) Ctrl_V)
        )

        ;; 'v', 'V' and CTRL-V can be used while an operator is pending to make it
        ;; characterwise, linewise, or blockwise.
        (when (!= (:op_type (:oap cap)) OP_NOP)
            ((ร cap.oap.motion_force =) (:cmdchar cap))
            (reset! finish_op false)      ;; operator doesn't finish now but later
            ((ร RETURN) nil)
        )

        (reset! VIsual_select (non-zero? (:arg cap)))
        (cond @VIsual_active      ;; change Visual mode
        (do
            (cond (== @VIsual_mode (:cmdchar cap))     ;; stop visual mode
            (do
                (end-visual-mode)
            )
            :else                                ;; toggle char/block mode or char/line mode
            (do
                (reset! VIsual_mode (:cmdchar cap))
                (showmode)
            ))
            (redraw-curbuf-later INVERTED)      ;; update the inversion
        )
        :else                    ;; start Visual mode
        (do
            (check-visual-highlight)
            (cond (and (< 0 (:count0 cap)) (!= @resel_VIsual_mode NUL))
            (do
                ;; use previously selected part
                (COPY-pos @VIsual, (:w_cursor @curwin))

                (reset! VIsual_active true)
                (reset! VIsual_reselect true)
                (when (zero? (:arg cap))
                    ;; start Select mode when 'selectmode' contains "cmd"
                    (may-start-select (byte \c))
                )
                (if @p_smd
                    (reset! redraw_cmdline true))      ;; show visual mode later

                ;; For V and ^V, we multiply the number of lines even if there was only one.

                (when (or (!= @resel_VIsual_mode (byte \v)) (< 1 @resel_VIsual_line_count))
                    ((ร @curwin.w_cursor.lnum =) (+ (:lnum (:w_cursor @curwin)) (- (* @resel_VIsual_line_count (:count0 cap)) 1)))
                    (if (> (:lnum (:w_cursor @curwin)) (:ml_line_count (:b_ml @curbuf)))
                        ((ร @curwin.w_cursor.lnum =) (:ml_line_count (:b_ml @curbuf)))
                    )
                )
                (reset! VIsual_mode @resel_VIsual_mode)
                (when (== @VIsual_mode (byte \v))
                    (cond (<= @resel_VIsual_line_count 1)
                    (do
                        (validate-virtcol)
                        ((ร @curwin.w_curswant =) (- (+ (:w_virtcol @curwin) (* @resel_VIsual_vcol (int (:count0 cap)))) 1))
                    )
                    :else
                    (do
                        ((ร @curwin.w_curswant =) @resel_VIsual_vcol)
                    ))
                    (coladvance (:w_curswant @curwin))
                )
                (cond (== @resel_VIsual_vcol MAXCOL)
                (do
                    ((ร @curwin.w_curswant =) MAXCOL)
                    (coladvance MAXCOL)
                )
                (== @VIsual_mode Ctrl_V)
                (do
                    (validate-virtcol)
                    ((ร @curwin.w_curswant =) (- (+ (:w_virtcol @curwin) (* @resel_VIsual_vcol (int (:count0 cap)))) 1))
                    (coladvance (:w_curswant @curwin))
                )
                :else
                (do
                    ((ร @curwin.w_set_curswant =) true)
                ))
                (redraw-curbuf-later INVERTED)      ;; show the inversion
            )
            :else
            (do
                (when (zero? (:arg cap))
                    ;; start Select mode when 'selectmode' contains "cmd"
                    (may-start-select (byte \c))
                )
                (n-start-visual-mode (:cmdchar cap))
                (if (and (!= @VIsual_mode (byte \V)) (== (.at @p_sel 0) (byte \e)))
                    (ร cap.count1++)   ;; include one more char
                )
                (when (and (< 0 (:count0 cap)) (< 0 (ร --cap.count1)))
                    ;; With a count select that many characters or lines.
                    (cond (or (== @VIsual_mode (byte \v)) (== @VIsual_mode Ctrl_V))
                    (do
                        (nv-right cap)
                    )
                    (== @VIsual_mode (byte \V))
                    (do
                        (nv-down cap)
                    ))
                )
            ))
        ))
        nil
    ))

;; Start selection for Shift-movement keys.

(defn- #_void start-selection []
    ;; if 'selectmode' contains "key", start Select mode
    (may-start-select (byte \k))
    (n-start-visual-mode (byte \v))
    nil)

;; Start Select mode, if "c" is in 'selectmode' and not in a mapping or menu.

(defn- #_void may-start-select [#_int c]
    (reset! VIsual_select (and (stuff-empty) (non-nil? (vim-strchr @p_slm, c))))
    nil)

;; Start Visual mode "c".
;; Should set VIsual_select before calling this.

(defn- #_void n-start-visual-mode [#_int c]
    (ยง
        ;; Check for redraw before changing the state.
        (conceal-check-cursor-line)

        (reset! VIsual_mode c)
        (reset! VIsual_active true)
        (reset! VIsual_reselect true)
        ;; Corner case: the 0 position in a tab may change when going into
        ;; virtualedit.  Recalculate curwin.w_cursor to avoid bad hilighting.

        (when (and (== c Ctrl_V) (flag? @ve_flags VE_BLOCK) (== (gchar-cursor) TAB))
            (validate-virtcol)
            (coladvance (:w_virtcol @curwin))
        )
        (COPY-pos @VIsual, (:w_cursor @curwin))

        ;; Check for redraw after changing the state.
        (conceal-check-cursor-line)

        (if @p_smd
            (reset! redraw_cmdline true))  ;; show visual mode later

        ;; Only need to redraw this line, unless still need to redraw
        ;; an old Visual area (when 'lazyredraw' is set).
        (when (< (:w_redr_type @curwin) INVERTED)
            ((ร @curwin.w_old_cursor_lnum =) (:lnum (:w_cursor @curwin)))
            ((ร @curwin.w_old_visual_lnum =) (:lnum (:w_cursor @curwin)))
        )
        nil
    ))

;; CTRL-W: Window commands

(defn- #_void nv-window [#_cmdarg_C cap]
    (when (not (checkclearop (:oap cap)))
        (do-window @(:nchar cap), (:count0 cap), NUL)
    )
    nil)

;; CTRL-Z: Suspend

(defn- #_void nv-suspend [#_cmdarg_C cap]
    (clearop (:oap cap))
    (if @VIsual_active
        (end-visual-mode))              ;; stop Visual mode
    (do-cmdline-cmd (u8 "st"))
    nil)

;; Commands starting with "g".

(defn- #_void nv-g-cmd [#_cmdarg_C cap]
    (ยง
        ((ร oparg_C oap =) (:oap cap))
        ((ร boolean flag =) false)

        ((ร SWITCH) @(:nchar cap)
            ;; "gR": Enter virtual replace mode.

            ((ร CASE) (byte \R))
            (do
                ((ร cap.arg =) TRUE)
                (nv-Replace cap)
                (ร BREAK)
            )

            ((ร CASE) (byte \r))
            (do
                (nv-vreplace cap)
                (ร BREAK)
            )

            ((ร CASE) (byte \&))
            (do
                (do-cmdline-cmd (u8 "%s//~/&"))
                (ร BREAK)
            )

            ;; "gv": Reselect the previous Visual area.
            ;;       If Visual already active, exchange previous and current Visual area.

            ((ร CASE) (byte \v))
            (do
                (if (checkclearop oap)
                    (ร BREAK)
                )

                (cond (or (zero? (:lnum (:vi_start (:b_visual @curbuf)))) (< (:ml_line_count (:b_ml @curbuf)) (:lnum (:vi_start (:b_visual @curbuf)))) (zero? (:lnum (:vi_end (:b_visual @curbuf)))))
                (do
                    (beep-flush)
                )
                :else
                (do
                    ;; set w_cursor to the start of the Visual area, tpos to the end
                    ((ร pos_C tpos =) (NEW_pos_C))
                    (cond @VIsual_active
                    (do
                        ((ร int i =) @VIsual_mode)
                        (reset! VIsual_mode (:vi_mode (:b_visual @curbuf)))
                        ((ร @curbuf.b_visual.vi_mode =) i)
                        ((ร @curbuf.b_visual_mode_eval =) i)
                        ((ร i =) (:w_curswant @curwin))
                        ((ร @curwin.w_curswant =) (:vi_curswant (:b_visual @curbuf)))
                        ((ร @curbuf.b_visual.vi_curswant =) i)

                        (COPY-pos tpos, (:vi_end (:b_visual @curbuf)))
                        (COPY-pos (:vi_end (:b_visual @curbuf)), (:w_cursor @curwin))
                        (COPY-pos (:w_cursor @curwin), (:vi_start (:b_visual @curbuf)))
                        (COPY-pos (:vi_start (:b_visual @curbuf)), @VIsual)
                    )
                    :else
                    (do
                        (reset! VIsual_mode (:vi_mode (:b_visual @curbuf)))
                        ((ร @curwin.w_curswant =) (:vi_curswant (:b_visual @curbuf)))
                        (COPY-pos tpos, (:vi_end (:b_visual @curbuf)))
                        (COPY-pos (:w_cursor @curwin), (:vi_start (:b_visual @curbuf)))
                    ))

                    (reset! VIsual_active true)
                    (reset! VIsual_reselect true)

                    ;; Set Visual to the start and w_cursor to the end of the Visual area.
                    ;; Make sure they are on an existing character.
                    (check-cursor)
                    (COPY-pos @VIsual, (:w_cursor @curwin))
                    (COPY-pos (:w_cursor @curwin), tpos)
                    (check-cursor)
                    (update-topline)

                    ;; When called from normal "g" command: start Select mode when 'selectmode'
                    ;; contains "cmd".  When called for K_SELECT, always start Select mode.

                    (if (non-zero? (:arg cap))
                        (reset! VIsual_select true)
                        (may-start-select (byte \c)))

                    (redraw-curbuf-later INVERTED)
                    (showmode)
                ))
                (ร BREAK)
            )

            ;; "gV": Don't reselect the previous Visual area after a Select mode mapping of menu.

            ((ร CASE) (byte \V))
            (do
                (reset! VIsual_reselect false)
                (ร BREAK)
            )

            ;; "gh":  start Select mode.
            ;; "gH":  start Select line mode.
            ;; "g^H": start Select block mode.

            ((ร CASE) K_BS)
            (do
                ((ร cap.@nchar =) Ctrl_H)
                (ร FALLTHROUGH)
            )

            ((ร CASE) (byte \h))
            ((ร CASE) (byte \H))
            ((ร CASE) Ctrl_H)
            (do
                ((ร cap.cmdchar =) (+ @(:nchar cap) (- (byte \v) (byte \h))))
                ((ร cap.arg =) TRUE)
                (nv-visual cap)
                (ร BREAK)
            )

            ;; "gn", "gN" visually select next/previous search match
            ;; "gn" selects next match
            ;; "gN" selects previous match

            ((ร CASE) (byte \N))
            ((ร CASE) (byte \n))
            (do
                (if (not (current-search (:count1 cap), (== @(:nchar cap) (byte \n))))
                    (clearopbeep oap))
                (ร BREAK)
            )

            ;; "gj" and "gk" two new funny movement keys -- up and down
            ;; movement based on *screen* line rather than *file* line.

            ((ร CASE) (byte \j))
            ((ร CASE) K_DOWN)
            (do
                (ร boolean i)

                ;; with 'nowrap' it works just like the normal "j" command;
                ;; also when in a closed fold
                (cond (not @(:wo_wrap (:w_options @curwin)))
                (do
                    ((ร oap.motion_type =) MLINE)
                    ((ร i =) (cursor-down (:count1 cap), (== (:op_type oap) OP_NOP)))
                )
                :else
                (do
                    ((ร i =) (nv-screengo oap, FORWARD, (:count1 cap)))
                ))
                (if (not i)
                    (clearopbeep oap))
                (ร BREAK)
            )

            ((ร CASE) (byte \k))
            ((ร CASE) K_UP)
            (do
                (ร boolean i)

                ;; with 'nowrap' it works just like the normal "k" command;
                ;; also when in a closed fold
                (cond (not @(:wo_wrap (:w_options @curwin)))
                (do
                    ((ร oap.motion_type =) MLINE)
                    ((ร i =) (cursor-up (:count1 cap), (== (:op_type oap) OP_NOP)))
                )
                :else
                (do
                    ((ร i =) (nv-screengo oap, BACKWARD, (:count1 cap)))
                ))
                (if (not i)
                    (clearopbeep oap))
                (ร BREAK)
            )

            ;; "gJ": join two lines without inserting a space.

            ((ร CASE) (byte \J))
            (do
                (nv-join cap)
                (ร BREAK)
            )

            ;; "g0", "g^" and "g$": Like "0", "^" and "$" but for screen lines.
            ;; "gm": middle of "g0" and "g$".

            ((ร CASE) (byte \^))
            (do
                ((ร flag =) true)
                (ร FALLTHROUGH)
            )

            ((ร CASE) (byte \0))
            ((ร CASE) (byte \m))
            ((ร CASE) K_HOME)
            ((ร CASE) K_KHOME)
            (do
                (ร int i)

                ((ร oap.motion_type =) MCHAR)
                ((ร oap.inclusive =) false)
                (cond (and @(:wo_wrap (:w_options @curwin)) (non-zero? (:w_width @curwin)))
                (do
                    ((ร int width1 =) (- (:w_width @curwin) (curwin-col-off)))
                    ((ร int width2 =) (+ width1 (curwin-col-off2)))

                    (validate-virtcol)
                    ((ร i =) 0)
                    (if (and (<= width1 (:w_virtcol @curwin)) (< 0 width2))
                        ((ร i =) (+ (* (/ (- (:w_virtcol @curwin) width1) width2) width2) width1))
                    )
                )
                :else
                (do
                    ((ร i =) (:w_leftcol @curwin))
                ))
                ;; Go to the middle of the screen line.  When 'number' or 'relativenumber' is on
                ;; and lines are wrapping the middle can be more to the left.
                (when (== @(:nchar cap) (byte \m))
                    ((ร i =) (+ i (/ (+ (- (:w_width @curwin) (curwin-col-off)) (if (and @(:wo_wrap (:w_options @curwin)) (< 0 i)) (curwin-col-off2) 0)) 2)))
                )
                (coladvance i)
                (when flag
;                   do
;                   {
                        ((ร i =) (gchar-cursor))
;                   } while (vim-iswhite(i) && oneright());
                )
                ((ร @curwin.w_set_curswant =) true)
                (ร BREAK)
            )

            ((ร CASE) (byte \_))
            (do
                ;; "g_": to the last non-blank character in the line or <count> lines downward.
                ((ร cap.oap.motion_type =) MCHAR)
                ((ร cap.oap.inclusive =) true)
                ((ร @curwin.w_curswant =) MAXCOL)
                (cond (not (cursor-down (- (:count1 cap) 1), (== (:op_type (:oap cap)) OP_NOP)))
                (do
                    (clearopbeep (:oap cap))
                )
                :else
                (do
                    ((ร Bytes ptr =) (ml-get-curline))

                    ;; In Visual mode we may end up after the line.
                    (if (and (< 0 (:col (:w_cursor @curwin))) (== (.at ptr (:col (:w_cursor @curwin))) NUL))
                        (ร --@curwin.w_cursor.col)
                    )

                    ;; Decrease the cursor column until it's on a non-blank.
                    (while (and (< 0 (:col (:w_cursor @curwin))) (vim-iswhite (.at ptr (:col (:w_cursor @curwin)))))
                        (ร --@curwin.w_cursor.col)
                    )
                    ((ร @curwin.w_set_curswant =) true)
                    (adjust-for-sel cap)
                ))
                (ร BREAK)
            )

            ((ร CASE) (byte \$))
            ((ร CASE) K_END)
            ((ร CASE) K_KEND)
            (do
                ((ร int col_off =) (curwin-col-off))

                ((ร oap.motion_type =) MCHAR)
                ((ร oap.inclusive =) true)
                (cond (and @(:wo_wrap (:w_options @curwin)) (non-zero? (:w_width @curwin)))
                (do
                    ((ร @curwin.w_curswant =) MAXCOL) ;; so we stay at the end
                    (cond (== (:count1 cap) 1)
                    (do
                        ((ร int width1 =) (- (:w_width @curwin) col_off))
                        ((ร int width2 =) (+ width1 (curwin-col-off2)))

                        (validate-virtcol)
                        ((ร int i =) (dec width1))
                        (if (<= width1 (:w_virtcol @curwin))
                            ((ร i =) (+ i (* (+ (/ (- (:w_virtcol @curwin) width1) width2) 1) width2)))
                        )
                        (coladvance i)

                        ;; Make sure we stick in this column.
                        (validate-virtcol)
                        ((ร @curwin.w_curswant =) (:w_virtcol @curwin))
                        ((ร @curwin.w_set_curswant =) false)
                        (when (and (< 0 (:col (:w_cursor @curwin))) @(:wo_wrap (:w_options @curwin)))
                            ;; Check for landing on a character that got split at the end of the line.
                            ;; We do not want to advance to the next screen line.

                            (if (< i (:w_virtcol @curwin))
                                (ร --@curwin.w_cursor.col)
                            )
                        )
                    )
                    (not (nv-screengo oap, FORWARD, (- (:count1 cap) 1)))
                    (do
                        (clearopbeep oap)
                    ))
                )
                :else
                (do
                    ((ร int i =) (- (- (+ (:w_leftcol @curwin) (:w_width @curwin)) col_off) 1))
                    (coladvance i)

                    ;; Make sure we stick in this column.
                    (validate-virtcol)
                    ((ร @curwin.w_curswant =) (:w_virtcol @curwin))
                    ((ร @curwin.w_set_curswant =) false)
                ))
                (ร BREAK)
            )

            ;; "g*" and "g#", like "*" and "#" but without using "\<" and "\>"

            ((ร CASE) (byte \*))
            ((ร CASE) (byte \#))
            ((ร CASE) (char_u POUND))             ;; pound sign (sometimes equal to '#')
            ((ร CASE) Ctrl_RSB)                  ;; :tag or :tselect for current identifier
            ((ร CASE) (byte \]))                       ;; :tselect for current identifier
            (do
                (nv-ident cap)
                (ร BREAK)
            )

            ;; ge and gE: go back to end of word

            ((ร CASE) (byte \e))
            ((ร CASE) (byte \E))
            (do
                ((ร oap.motion_type =) MCHAR)
                ((ร @curwin.w_set_curswant =) true)
                ((ร oap.inclusive =) true)
                (if (not (bckend-word (:count1 cap), (== @(:nchar cap) (byte \E)), false))
                    (clearopbeep oap))
                (ร BREAK)
            )

            ;; "g CTRL-G": display info about cursor position.

            ((ร CASE) Ctrl_G)
            (do
                (cursor-pos-info)
                (ร BREAK)
            )

            ;; "gi": start Insert at the last position.

            ((ร CASE) (byte \i))
            (do
                (when (non-zero? (:lnum (:b_last_insert @curbuf)))
                    (COPY-pos (:w_cursor @curwin), (:b_last_insert @curbuf))
                    (check-cursor-lnum)
                    ((ร int i =) (STRLEN (ml-get-curline)))
                    (when (< i (:col (:w_cursor @curwin)))
                        (if (virtual-active)
                            ((ร @curwin.w_cursor.coladd =) (+ (:coladd (:w_cursor @curwin)) (- (:col (:w_cursor @curwin)) i)))
                        )
                        ((ร @curwin.w_cursor.col =) i)
                    )
                )
                ((ร cap.cmdchar =) (byte \i))
                (nv-edit cap)
                (ร BREAK)
            )

            ;; "gI": Start insert in column 1.

            ((ร CASE) (byte \I))
            (do
                (beginline 0)
                (if (not (checkclearopq oap))
                    (invoke-edit cap, false, (byte \g), false))
                (ร BREAK)
            )

            ;; "g'm" and "g`m": jump to mark without setting pcmark.

            ((ร CASE) (byte \'))
            (do
                ((ร cap.arg =) TRUE)
                (ร FALLTHROUGH)
            )

            ((ร CASE) (byte \`))
            (do
                (nv-gomark cap)
                (ร BREAK)
            )

            ;; "gs": Goto sleep.

            ((ร CASE) (byte \s))
            (do
                (do-sleep (* (:count1 cap) 1000))
                (ร BREAK)
            )

            ;; "ga": Display the ascii value of the character under the cursor.
            ;;       It is displayed in decimal, hex, and octal.

            ((ร CASE) (byte \a))
            (do
                (do-ascii)
                (ร BREAK)
            )

            ;; "g8": Display the bytes used for the UTF-8 character under the cursor.
            ;;       It is displayed in hex.
            ;; "8g8" finds illegal byte sequence.

            ((ร CASE) (byte \8))
            (do
                (if (== (:count0 cap) 8)
                    (utf-find-illegal)
                    (show-utf8)
                )
                (ร BREAK)
            )

            ((ร CASE) (byte \<))
            (do
                (show-sb-text)
                (ร BREAK)
            )

            ;; "gg": Goto the first line in file.
            ;;       With a count it goes to that line number like for "G".

            ((ร CASE) (byte \g))
            (do
                ((ร cap.arg =) FALSE)
                (nv-goto cap)
                (ร BREAK)
            )

            ;; Two-character operators:
            ;;  "gq"    Format text.
            ;;  "gw"    Format text and keep cursor position.
            ;;  "g~"    Toggle the case of the text.
            ;;  "gu"    Change text to lower case.
            ;;  "gU"    Change text to upper case.
            ;;  "g?"    rot13 encoding
            ;;  "g@"    call 'operatorfunc'

            ((ร CASE) (byte \q))
            ((ร CASE) (byte \w))
            (do
                (COPY-pos (:cursor_start oap), (:w_cursor @curwin))
                (ร FALLTHROUGH)
            )

            ((ร CASE) (byte \~))
            ((ร CASE) (byte \u))
            ((ร CASE) (byte \U))
            ((ร CASE) (byte \?))
            ((ร CASE) (byte \@))
            (do
                (nv-operator cap)
                (ร BREAK)
            )

            ;; "gd": Find first occurrence of pattern under the cursor in the current function;
            ;; "gD": idem, but in the current file.

            ((ร CASE) (byte \d))
            ((ร CASE) (byte \D))
            (do
                (nv-gd oap, @(:nchar cap), (== (:count0 cap) 1))
                (ร BREAK)
            )

            ((ร CASE) K_IGNORE)
            (do
                (ร BREAK)
            )

            ;; "gP" and "gp": same as "P" and "p" but leave cursor just after new text.

            ((ร CASE) (byte \p))
            ((ร CASE) (byte \P))
            (do
                (nv-put cap)
                (ร BREAK)
            )

            ;; "go": goto byte count from start of buffer
            ((ร CASE) (byte \o))
            (do
;               goto_byte(cap.count0);
                (ร BREAK)
            )

            ;; "gQ": improved Ex mode
            ((ร CASE) (byte \Q))
            (do
                (when (text-locked)
                    (clearopbeep (:oap cap))
                    (text-locked-msg)
                    (ร BREAK)
                )

                (if (not (checkclearopq oap))
;                   do_exmode(true);
                )
                (ร BREAK)
            )

            ((ร CASE) (byte \,))
            (do
                (nv-pcmark cap)
                (ร BREAK)
            )

            ((ร CASE) (byte \;))
            (do
                ((ร cap.count1 =) (- (:count1 cap)))
                (nv-pcmark cap)
                (ร BREAK)
            )

            ;; "g+" and "g-": undo or redo along the timeline.

            ((ร CASE) (byte \+))
            ((ร CASE) (byte \-))
            (do
                (if (not (checkclearopq oap))
                    (undo-time (if (== @(:nchar cap) (byte \-)) (- (:count1 cap)) (:count1 cap)), false, false))
                (ร BREAK)
            )

            (ร DEFAULT)
            (do
                (clearopbeep oap)
                (ร BREAK)
            )
        )
        nil
    ))

;; Handle "o" and "O" commands.

(defn- #_void n-opencmd [#_cmdarg_C cap]
    (ยง
        ((ร long oldline =) (:lnum (:w_cursor @curwin)))

        (when (not (checkclearopq (:oap cap)))
            (when (and (u-save (- (:lnum (:w_cursor @curwin)) (if (== (:cmdchar cap) (byte \O)) 1 0)), (+ (:lnum (:w_cursor @curwin)) (if (== (:cmdchar cap) (byte \o)) 1 0))) (open-line (if (== (:cmdchar cap) (byte \O)) BACKWARD FORWARD), 0, 0))
                (if (and (< 0 @(:wo_cole (:w_options @curwin))) (!= oldline (:lnum (:w_cursor @curwin))))
                    (update-single-line @curwin, oldline))
                ;; When '#' is in 'cpoptions' ignore the count.
                (if (non-nil? (vim-strbyte @p_cpo, CPO_HASH))
                    ((ร cap.count1 =) 1)
                )
                (invoke-edit cap, false, (:cmdchar cap), true)
            )
        )
        nil
    ))

;; "." command: redo last change.

(defn- #_void nv-dot [#_cmdarg_C cap]
    (when (not (checkclearopq (:oap cap)))
        ;; If "restart_edit" is true, the last but one command is repeated
        ;; instead of the last command (inserting text).  This is used for
        ;; CTRL-O <.> in insert mode.

        (if (not (start-redo (:count0 cap), (and (non-zero? @restart_edit) (not @arrow_used))))
            (clearopbeep (:oap cap)))
    )
    nil)

;; CTRL-R: undo undo

(defn- #_void nv-redo [#_cmdarg_C cap]
    (ยง
        (when (not (checkclearopq (:oap cap)))
            (u-redo (int (:count1 cap)))
            ((ร @curwin.w_set_curswant =) true)
        )
        nil
    ))

;; Handle "U" command.

(defn- #_void nv-Undo [#_cmdarg_C cap]
    (ยง
        ;; In Visual mode and typing "gUU" triggers an operator.
        (cond (or (== (:op_type (:oap cap)) OP_UPPER) @VIsual_active)
        (do
            ;; translate "gUU" to "gUgU"
            ((ร cap.cmdchar =) (byte \g))
            ((ร cap.@nchar =) (byte \U))
            (nv-operator cap)
        )
        (not (checkclearopq (:oap cap)))
        (do
            (u-undoline)
            ((ร @curwin.w_set_curswant =) true)
        ))
        nil
    ))

;; '~' command: If tilde is not an operator and Visual is off: swap case of a single character.

(defn- #_void nv-tilde [#_cmdarg_C cap]
    (if (and (not @p_to) (not @VIsual_active) (!= (:op_type (:oap cap)) OP_TILDE))
        (n-swapchar cap)
        (nv-operator cap))
    nil)

;; Handle an operator command.
;; The actual work is done by do-pending-operator().

(defn- #_void nv-operator [#_cmdarg_C cap]
    (ยง
        ((ร int op_type =) (get-op-type (:cmdchar cap), @(:nchar cap)))

        (cond (== op_type (:op_type (:oap cap)))     ;; double operator works on lines
        (do
            (nv-lineop cap)
        )
        (not (checkclearop (:oap cap)))
        (do
            (COPY-pos (:op_start (:oap cap)), (:w_cursor @curwin))
            ((ร cap.oap.op_type =) op_type)
        ))
        nil
    ))

;; Handle linewise operator "dd", "yy", etc.
;;
;; "_" is is a strange motion command that helps make operators more logical.
;; It is actually implemented, but not documented in the real Vi.  This motion
;; command actually refers to "the current line".  Commands like "dd" and "yy"
;; are really an alternate form of "d_" and "y_".  It does accept a count, so
;; "d3_" works to delete 3 lines.

(defn- #_void nv-lineop [#_cmdarg_C cap]
    (ยง
        ((ร cap.oap.motion_type =) MLINE)
        (cond (not (cursor-down (- (:count1 cap) 1), (== (:op_type (:oap cap)) OP_NOP)))
        (do
            (clearopbeep (:oap cap))
        )
        ;; only with linewise motions
        (or (and (== (:op_type (:oap cap)) OP_DELETE) (!= (:motion_force (:oap cap)) (byte \v)) (!= (:motion_force (:oap cap)) Ctrl_V)) (== (:op_type (:oap cap)) OP_LSHIFT) (== (:op_type (:oap cap)) OP_RSHIFT))
        (do
            (beginline (| BL_SOL BL_FIX))
        )
        (!= (:op_type (:oap cap)) OP_YANK)        ;; 'Y' does not move cursor
        (do
            (beginline (| BL_WHITE BL_FIX))
        ))
        nil
    ))

;; <Home> command.

(defn- #_void nv-home [#_cmdarg_C cap]
    (ยง
        ;; CTRL-HOME is like "gg"
        (cond (flag? @mod_mask MOD_MASK_CTRL)
        (do
            (nv-goto cap)
        )
        :else
        (do
            ((ร cap.count0 =) 1)
            (nv-pipe cap)
        ))
        (reset! ins_at_eol false)     ;; Don't move cursor past eol
                                    ;; (only necessary in a one-character line).
        nil
    ))

;; "|" command.

(defn- #_void nv-pipe [#_cmdarg_C cap]
    (ยง
        ((ร cap.oap.motion_type =) MCHAR)
        ((ร cap.oap.inclusive =) false)
        (beginline 0)
        (cond (< 0 (:count0 cap))
        (do
            (coladvance (int (- (:count0 cap) 1)))
            ((ร @curwin.w_curswant =) (int (- (:count0 cap) 1)))
        )
        :else
        (do
            ((ร @curwin.w_curswant =) 0)
        ))
        ;; Keep curswant at the column where we wanted to go,
        ;; not where we ended; differs if line is too short.
        ((ร @curwin.w_set_curswant =) false)
        nil
    ))

;; Handle back-word command "b" and "B".
;; cap.arg is 1 for "B"

(defn- #_void nv-bck-word [#_cmdarg_C cap]
    (ยง
        ((ร cap.oap.motion_type =) MCHAR)
        ((ร cap.oap.inclusive =) false)
        ((ร @curwin.w_set_curswant =) true)
        (when (not (bck-word (:count1 cap), (non-zero? (:arg cap)), false))
            (clearopbeep (:oap cap))
        )
        nil
    ))

;; Handle word motion commands "e", "E", "w" and "W".
;; cap.arg is TRUE for "E" and "W".

(defn- #_void nv-wordcmd [#_cmdarg_C cap]
    (ยง
        ((ร pos_C startpos =) (NEW_pos_C))
        (COPY-pos startpos, (:w_cursor @curwin))

        ;; Set inclusive for the "E" and "e" command.

        ((ร boolean word_end =) (or (== (:cmdchar cap) (byte \e)) (== (:cmdchar cap) (byte \E))))
        ((ร cap.oap.inclusive =) word_end)

        ((ร boolean flag =) false)

        ;; "cw" and "cW" are a special case.

        (when (and (not word_end) (== (:op_type (:oap cap)) OP_CHANGE))
            ((ร int n =) (gchar-cursor))
            (when (!= n NUL)                   ;; not an empty line
                (cond (vim-iswhite n)
                (do
                    ;; Reproduce a funny Vi behaviour: "cw" on a blank only
                    ;; changes one character, not all blanks until the start of
                    ;; the next word.  Only do this when the 'w' flag is included
                    ;; in 'cpoptions'.

                    (when (and (== (:count1 cap) 1) (non-nil? (vim-strbyte @p_cpo, CPO_CW)))
                        ((ร cap.oap.inclusive =) true)
                        ((ร cap.oap.motion_type =) MCHAR)
                        ((ร RETURN) nil)
                    )
                )
                :else
                (do
                    ;; This is a little strange.  To match what the real Vi does,
                    ;; we effectively map 'cw' to 'ce', and 'cW' to 'cE', provided
                    ;; that we are not on a space or a TAB.  This seems impolite
                    ;; at first, but it's really more what we mean when we say 'cw'.
                    ;; Another strangeness: When standing on the end of a word
                    ;; "ce" will change until the end of the next word, but "cw"
                    ;; will change only one character! This is done by setting flag.

                    ((ร cap.oap.inclusive =) true)
                    ((ร word_end =) true)
                    ((ร flag =) true)
                ))
            )
        )

        ((ร cap.oap.motion_type =) MCHAR)
        ((ร @curwin.w_set_curswant =) true)
        ((ร boolean n =) (if word_end
            (end-word (:count1 cap), (!= (:arg cap) 0), flag, false)
            (fwd-word (:count1 cap), (!= (:arg cap) 0), (!= (:op_type (:oap cap)) OP_NOP))
        ))

        ;; Don't leave the cursor on the NUL past the end of line.
        ;; Unless we didn't move it forward.
        (if (ltpos startpos, (:w_cursor @curwin))
            (adjust-cursor (:oap cap)))

        (if (and (not n) (== (:op_type (:oap cap)) OP_NOP))
            (clearopbeep (:oap cap))
            (adjust-for-sel cap))
        nil
    ))

;; Used after a movement command: if the cursor ends up on the NUL after the end of the line,
;; may move it back to the last character and make the motion inclusive.

(defn- #_void adjust-cursor [#_oparg_C oap]
    (ยง
        ;; The cursor cannot remain on the NUL when:
        ;; - the column is > 0
        ;; - not in Visual mode or 'selection' is "o"
        ;; - 'virtualedit' is not "all" and not "onemore".

        (when (and (< 0 (:col (:w_cursor @curwin))) (== (gchar-cursor) NUL) (or (not @VIsual_active) (== (.at @p_sel 0) (byte \o))) (not (virtual-active)) (non-flag? @ve_flags VE_ONEMORE))
            (ร --@curwin.w_cursor.col)
            ;; prevent cursor from moving on the trail byte
            (mb-adjust-pos @curbuf, (:w_cursor @curwin))
            ((ร oap.inclusive =) true)
        )
        nil
    ))

;; "0" and "^" commands.
;; cap.arg is the argument for beginline().

(defn- #_void nv-beginline [#_cmdarg_C cap]
    (ยง
        ((ร cap.oap.motion_type =) MCHAR)
        ((ร cap.oap.inclusive =) false)
        (beginline (:arg cap))
        (reset! ins_at_eol false)     ;; Don't move cursor past eol
                                    ;; (only necessary in a one-character line).
        nil
    ))

;; In exclusive Visual mode, may include the last character.

(defn- #_void adjust-for-sel [#_cmdarg_C cap]
    (ยง
        (when (and @VIsual_active (:inclusive (:oap cap)) (== (.at @p_sel 0) (byte \e)) (!= (gchar-cursor) NUL) (ltpos @VIsual, (:w_cursor @curwin)))
            (inc-cursor)
            ((ร cap.oap.inclusive =) false)
        )
        nil
    ))

;; Exclude last character at end of Visual area for 'selection' == "exclusive".
;; Should check VIsual_mode before calling this.
;; Returns true when backed up to the previous line.

(defn- #_boolean unadjust-for-sel []
    (ยง
        (when (and (== (.at @p_sel 0) (byte \e)) (not (eqpos @VIsual, (:w_cursor @curwin))))
            ((ร pos_C pp =) (if (ltpos @VIsual, (:w_cursor @curwin)) (:w_cursor @curwin) @VIsual))
            (cond (< 0 (:coladd pp))
            (do
                (ร --pp.coladd)
            )
            (< 0 (:col pp))
            (do
                (ร --pp.col)
                (mb-adjust-pos @curbuf, pp)
            )
            (< 1 (:lnum pp))
            (do
                (ร --pp.lnum)
                ((ร pp.col =) (STRLEN (ml-get (:lnum pp))))
                ((ร RETURN) true)
            ))
        )
        false
    ))

;; SELECT key in Normal or Visual mode: end of Select mode mapping.

(defn- #_void nv-select [#_cmdarg_C cap]
    (ยง
        (cond @VIsual_active
        (do
            (reset! VIsual_select true)
        )
        @VIsual_reselect
        (do
            ((ร cap.@nchar =) (byte \v))        ;; fake "gv" command
            ((ร cap.arg =) TRUE)
            (nv-g-cmd cap)
        ))
        nil
    ))

;; "G", "gg", CTRL-END, CTRL-HOME.
;; cap.arg is TRUE for "G".

(defn- #_void nv-goto [#_cmdarg_C cap]
    (ยง
        ((ร long lnum =) (if (non-zero? (:arg cap)) (:ml_line_count (:b_ml @curbuf)) 1))

        ((ร cap.oap.motion_type =) MLINE)
        (setpcmark)

        ;; When a count is given, use it instead of the default lnum.
        (if (non-zero? (:count0 cap))
            ((ร lnum =) (:count0 cap))
        )
        (cond (< lnum 1)
        (do
            ((ร lnum =) 1)
        )
        (< (:ml_line_count (:b_ml @curbuf)) lnum)
        (do
            ((ร lnum =) (:ml_line_count (:b_ml @curbuf)))
        ))
        ((ร @curwin.w_cursor.lnum =) lnum)
        (beginline (| BL_SOL BL_FIX))
        nil
    ))

;; CTRL-\ in Normal mode.

(defn- #_void nv-normal [#_cmdarg_C cap]
    (ยง
        (cond (or (== @(:nchar cap) Ctrl_N) (== @(:nchar cap) Ctrl_G))
        (do
            (clearop (:oap cap))
            (if (and (non-zero? @restart_edit) @mode_displayed)
                (reset! clear_cmdline true))               ;; unshow mode later
            (reset! restart_edit 0)
            (if (non-zero? @cmdwin_type)
                (reset! cmdwin_result Ctrl_C))
            (when @VIsual_active
                (end-visual-mode)          ;; stop Visual
                (redraw-curbuf-later INVERTED)
            )
            ;; CTRL-\ CTRL-G restarts Insert mode when 'insertmode' is set.
            (if (and (== @(:nchar cap) Ctrl_G) @p_im)
                (reset! restart_edit (byte \a)))
        )
        :else
        (do
            (clearopbeep (:oap cap))
        ))
        nil
    ))

;; ESC in Normal mode: beep, but don't flush buffers.
;; Don't even beep if we are canceling a command.

(defn- #_void nv-esc [#_cmdarg_C cap]
    (ยง
        ((ร boolean no_reason =) (and (== (:op_type (:oap cap)) OP_NOP) (== (:opcount cap) 0) (== (:count0 cap) 0) (== (:regname (:oap cap)) 0) (not @p_im)))

        (when (non-zero? (:arg cap))                   ;; true for CTRL-C
            (if (and (zero? @restart_edit) (zero? @cmdwin_type) (not @VIsual_active) no_reason)
                (msg (u8 "Type  :quit<Enter>  to exit Vim")))

            ;; Don't reset "restart_edit" when 'insertmode' is set,
            ;; it won't be set again below when halfway a mapping.
            (if (not @p_im)
                (reset! restart_edit 0))
            (when (non-zero? @cmdwin_type)
                (reset! cmdwin_result K_IGNORE)
                (reset! got_int false)            ;; don't stop executing autocommands et al.
                ((ร RETURN) nil)
            )
        )

        (cond @VIsual_active
        (do
            (end-visual-mode)              ;; stop Visual
            (check-cursor-col)             ;; make sure cursor is not beyond EOL
            ((ร @curwin.w_set_curswant =) true)
            (redraw-curbuf-later INVERTED)
        )
        no_reason
        (do
            (vim-beep)
        ))
        (clearop (:oap cap))

        ;; A CTRL-C is often used at the start of a menu.
        ;; When 'insertmode' is set, return to Insert mode afterwards.
        (when (and (zero? @restart_edit) (goto-im))
            (reset! restart_edit (byte \a))
        )
        nil
    ))

;; Handle "A", "a", "I", "i" and <Insert> commands.

(defn- #_void nv-edit [#_cmdarg_C cap]
    (ยง
        ;; <Insert> is equal to "i"
        (if (or (== (:cmdchar cap) K_INS) (== (:cmdchar cap) K_KINS))
            ((ร cap.cmdchar =) (byte \i))
        )

        ;; in Visual mode "A" and "I" are an operator
        (cond (and @VIsual_active (or (== (:cmdchar cap) (byte \A)) (== (:cmdchar cap) (byte \I))))
        (do
            (v-visop cap)
        )
        ;; in Visual mode and after an operator "a" and "i" are for text objects
        (and (or (== (:cmdchar cap) (byte \a)) (== (:cmdchar cap) (byte \i))) (or (!= (:op_type (:oap cap)) OP_NOP) @VIsual_active))
        (do
            (nv-object cap)
        )
        (not (checkclearopq (:oap cap)))
        (do
            ((ร SWITCH) (:cmdchar cap)
                ((ร CASE) (byte \A))   ;; "A"ppend after the line
                (do
                    ((ร @curwin.w_set_curswant =) true)
                    (cond (== @ve_flags VE_ALL)
                    (do
                        ((ร int save_State =) @State)

                        ;; Pretend Insert mode here to allow the cursor
                        ;; on the character past the end of the line.
                        (reset! State INSERT)
                        (coladvance MAXCOL)
                        (reset! State save_State)
                    )
                    :else
                    (do
                        ((ร @curwin.w_cursor.col =) (+ (:col (:w_cursor @curwin)) (STRLEN (ml-get-cursor))))
                    ))
                    (ร BREAK)
                )

                ((ร CASE) (byte \I))   ;; "I"nsert before the first non-blank
                (do
                    (if (nil? (vim-strbyte @p_cpo, CPO_INSEND))
                        (beginline BL_WHITE)
                        (beginline (| BL_WHITE BL_FIX)))
                    (ร BREAK)
                )

                ((ร CASE) (byte \a))   ;; "a"ppend is like "i"nsert on the next character
                (do
                    ;; Increment coladd when in virtual space, increment the
                    ;; column otherwise, also to append after an unprintable char.
                    (cond (and (virtual-active) (or (< 0 (:coladd (:w_cursor @curwin))) (eos? (ml-get-cursor)) (== (.at (ml-get-cursor) 0) TAB)))
                    (do
                        (ร @curwin.w_cursor.coladd++)
                    )
                    (non-eos? (ml-get-cursor))
                    (do
                        (inc-cursor)
                    ))
                    (ร BREAK)
                )
            )

            (when (and (non-zero? (:coladd (:w_cursor @curwin))) (!= (:cmdchar cap) (byte \A)))
                ((ร int save_State =) @State)

                ;; Pretend Insert mode here to allow the cursor
                ;; on the character past the end of the line.
                (reset! State INSERT)
                (coladvance (getviscol))
                (reset! State save_State)
            )

            (invoke-edit cap, false, (:cmdchar cap), false)
        ))
        nil
    ))

;; Invoke edit() and take care of "restart_edit" and the return value.

(defn- #_void invoke-edit [#_cmdarg_C cap, #_boolean repl, #_int cmd, #_boolean startln]
    ;; repl: "r" or "gr" command
    (ยง
        ;; Complicated: when the user types "a<C-O>a", we don't want to do Insert mode recursively.
        ;; But when doing "a<C-O>." or "a<C-O>rx", we do allow it.
        ((ร int restart_edit_save =) (if (or repl (not (stuff-empty))) @restart_edit 0))

        ;; Always reset "restart_edit", this is not a restarted edit.
        (reset! restart_edit 0)

        (if (edit cmd, startln, (:count1 cap))
            ((ร cap.retval =) (| (:retval cap) CA_COMMAND_BUSY))
        )

        (when (zero? @restart_edit)
            (reset! restart_edit restart_edit_save)
        )
        nil
    ))

;; "a" or "i" while an operator is pending or in Visual mode: object motion.

(defn- #_void nv-object [#_cmdarg_C cap]
    (ยง
        ;; "ax" = an object: include white space
        ;; "ix" = inner object: exclude white space
        ((ร boolean include =) (!= (:cmdchar cap) (byte \i)))

        ;; Make sure (), [], {} and <> are in 'matchpairs'.
        ((ร Bytes mps_save =) @(:b_p_mps @curbuf))
        ((ร @curbuf.@b_p_mps =) (u8 "(:),{:},[:],<:>"))

        (ร boolean flag)
        ((ร SWITCH) @(:nchar cap)
            ((ร CASE) (byte \w)) ;; "aw" = a word
            (do
                ((ร flag =) (current-word (:oap cap), (:count1 cap), include, false))
                (ร BREAK)
            )
            ((ร CASE) (byte \W)) ;; "aW" = a WORD
            (do
                ((ร flag =) (current-word (:oap cap), (:count1 cap), include, true))
                (ร BREAK)
            )
            ((ร CASE) (byte \b)) ;; "ab" = a braces block
            ((ร CASE) (byte \())
            ((ร CASE) (byte \)))
            (do
                ((ร flag =) (current-block (:oap cap), (:count1 cap), include, (byte \(), (byte \))))
                (ร BREAK)
            )
            ((ร CASE) (byte \B)) ;; "aB" = a Brackets block
            ((ร CASE) (byte \{))
            ((ร CASE) (byte \}))
            (do
                ((ร flag =) (current-block (:oap cap), (:count1 cap), include, (byte \{), (byte \})))
                (ร BREAK)
            )
            ((ร CASE) (byte \[)) ;; "a[" = a [] block
            ((ร CASE) (byte \]))
            (do
                ((ร flag =) (current-block (:oap cap), (:count1 cap), include, (byte \[), (byte \])))
                (ร BREAK)
            )
            ((ร CASE) (byte \<)) ;; "a<" = a <> block
            ((ร CASE) (byte \>))
            (do
                ((ร flag =) (current-block (:oap cap), (:count1 cap), include, (byte \<), (byte \>)))
                (ร BREAK)
            )
            ((ร CASE) (byte \p)) ;; "ap" = a paragraph
            (do
                ((ร flag =) (current_par (:oap cap), (:count1 cap), include, (byte \p)))
                (ร BREAK)
            )
            ((ร CASE) (byte \s)) ;; "as" = a sentence
            (do
                ((ร flag =) (current_sent (:oap cap), (:count1 cap), include))
                (ร BREAK)
            )
            ((ร CASE) (byte \")) ;; "a"" = a double quoted string
            ((ร CASE) (byte \')) ;; "a'" = a single quoted string
            ((ร CASE) (byte \`)) ;; "a`" = a backtick quoted string
            (do
                ((ร flag =) (current-quote (:oap cap), (:count1 cap), include, @(:nchar cap)))
                (ร BREAK)
            )
            (ร DEFAULT)
            (do
                ((ร flag =) false)
                (ร BREAK)
            )
        )

        ((ร @curbuf.@b_p_mps =) mps_save)
        (if (not flag)
            (clearopbeep (:oap cap)))
        (adjust-cursor-col)
        ((ร @curwin.w_set_curswant =) true)
        nil
    ))

;; "q" command: Start/stop recording.
;; "q:", "q/", "q?": edit command-line in command-line window.

(defn- #_void nv-record [#_cmdarg_C cap]
    (ยง
        (cond (== (:op_type (:oap cap)) OP_FORMAT)
        (do
            ;; "gqq" is the same as "gqgq": format line
            ((ร cap.cmdchar =) (byte \g))
            ((ร cap.@nchar =) (byte \q))
            (nv-operator cap)
        )
        (not (checkclearop (:oap cap)))
        (do
            (cond (or (== @(:nchar cap) (byte \:)) (== @(:nchar cap) (byte \/)) (== @(:nchar cap) (byte \?)))
            (do
                (stuffcharReadbuff @(:nchar cap))
                (stuffcharReadbuff K_CMDWIN)
            )
            :else
            (do
                ;; (stop) recording into a named register, unless executing a register
                (if (and (not @execReg) (not (do-record @(:nchar cap))))
                    (clearopbeep (:oap cap)))
            ))
        ))
        nil
    ))

;; Handle the "@r" command.

(defn- #_void nv-at [#_cmdarg_C cap]
    (ยง
        (if (checkclearop (:oap cap))
            ((ร RETURN) nil)
        )
        (when (== @(:nchar cap) (byte \=))
            (if (== (get-expr-register) NUL)
                ((ร RETURN) nil)
            )
        )
        (while (and (< 0 (ร cap.count1--)) (not @got_int))
            (when (not (do-execreg @(:nchar cap)))
                (clearopbeep (:oap cap))
                (ร BREAK)
            )
            (line-breakcheck)
        )
        nil
    ))

;; Handle the CTRL-U and CTRL-D commands.

(defn- #_void nv-halfpage [#_cmdarg_C cap]
    (ยง
        (cond (or (and (== (:cmdchar cap) Ctrl_U) (== (:lnum (:w_cursor @curwin)) 1)) (and (== (:cmdchar cap) Ctrl_D) (== (:lnum (:w_cursor @curwin)) (:ml_line_count (:b_ml @curbuf)))))
        (do
            (clearopbeep (:oap cap))
        )
        (not (checkclearop (:oap cap)))
        (do
            (halfpage (== (:cmdchar cap) Ctrl_D), (:count0 cap))
        ))
        nil
    ))

;; Handle "J" or "gJ" command.

(defn- #_void nv-join [#_cmdarg_C cap]
    (ยง
        (cond @VIsual_active  ;; join the visual lines
        (do
            (nv-operator cap)
        )
        (not (checkclearop (:oap cap)))
        (do
            (if (<= (:count0 cap) 1)
                ((ร cap.count0 =) 2)         ;; default for join is two lines!
            )
            (cond (< (:ml_line_count (:b_ml @curbuf)) (- (+ (:lnum (:w_cursor @curwin)) (:count0 cap)) 1))
            (do
                (clearopbeep (:oap cap))   ;; beyond last line
            )
            :else
            (do
                (prep-redo (:regname (:oap cap)), (:count0 cap), NUL, (:cmdchar cap), NUL, NUL, @(:nchar cap))
                (do-join (int (:count0 cap)), (== @(:nchar cap) NUL), true, true, true)
            ))
        ))
        nil
    ))

;; "P", "gP", "p" and "gp" commands.

(defn- #_void nv-put [#_cmdarg_C cap]
    (ยง
        ((ร int regname =) 0)
        ((ร boolean empty =) false)
        ((ร boolean was_visual =) false)
        ((ร int flags =) 0)

        (cond (!= (:op_type (:oap cap)) OP_NOP)
        (do
            (clearopbeep (:oap cap))
        )
        :else
        (do
            ((ร int dir =) (if (or (== (:cmdchar cap) (byte \P)) (and (== (:cmdchar cap) (byte \g)) (== @(:nchar cap) (byte \P)))) BACKWARD FORWARD))
            (prep-redo-cmd cap)
            (if (== (:cmdchar cap) (byte \g))
                ((ร flags =) (| flags PUT_CURSEND))
            )

            ((ร yankreg_C reg1 =) (ร nil, reg2 = nil))

            (when @VIsual_active
                ;; Putting in Visual mode: The put text replaces the selected
                ;; text.  First delete the selected text, then put the new text.
                ;; Need to save and restore the registers that the delete
                ;; overwrites if the old contents is being put.

                ((ร was_visual =) true)
                ((ร regname =) (:regname (:oap cap)))
                ((ร regname =) (adjust-clip-reg regname))
                (when (or (zero? regname) (== regname (byte \")) (asc-isdigit regname) (== regname (byte \-)))  ;; """
                    ;; The delete is going to overwrite the register we want to put, save it first.
                    ((ร reg1 =) (get-register regname, true))
                )

                ;; Now delete the selected text.
                ((ร cap.cmdchar =) (byte \d))
                ((ร cap.@nchar =) NUL)
                ((ร cap.oap.regname =) NUL)
                (nv-operator cap)
                (do-pending-operator cap, 0, false)
                ((ร empty =) (!= (& (:ml_flags (:b_ml @curbuf)) ML_EMPTY) 0))

                ;; delete PUT_LINE_BACKWARD;
                ((ร cap.oap.regname =) regname)

                (when (non-nil? reg1)
                    ;; Delete probably changed the register we want to put, save it first.
                    ;; Then put back what was there before the delete.
                    ((ร reg2 =) (get-register regname, false))
                    (put-register regname, reg1)
                )

                ;; When deleted a linewise Visual area,
                ;; put the register as lines to avoid it joined with the next line.
                ;; When deletion was characterwise, split a line when putting lines.
                (cond (== @VIsual_mode (byte \V))
                (do
                    ((ร flags =) (| flags PUT_LINE))
                )
                (== @VIsual_mode (byte \v))
                (do
                    ((ร flags =) (| flags PUT_LINE_SPLIT))
                ))
                (if (and (== @VIsual_mode Ctrl_V) (== dir FORWARD))
                    ((ร flags =) (| flags PUT_LINE_FORWARD))
                )
                ((ร dir =) BACKWARD)
                (when (or (and (!= @VIsual_mode (byte \V)) (< (:col (:w_cursor @curwin)) (:col (:b_op_start @curbuf)))) (and (== @VIsual_mode (byte \V)) (< (:lnum (:w_cursor @curwin)) (:lnum (:b_op_start @curbuf)))))
                    ;; cursor is at the end of the line or end of file, put forward.
                    ((ร dir =) FORWARD)
                )
                ;; May have been reset in do-put().
                (reset! VIsual_active true)
            )

            (do-put (:regname (:oap cap)), dir, (int (:count1 cap)), flags)

            ;; If a register was saved, put it back now.
            (if (non-nil? reg2)
                (put-register regname, reg2))

            ;; What to reselect with "gv"?
            ;; Selecting the just put text seems to be the most useful, since the original was removed.
            (when was_visual
                (COPY-pos (:vi_start (:b_visual @curbuf)), (:b_op_start @curbuf))
                (COPY-pos (:vi_end (:b_visual @curbuf)), (:b_op_end @curbuf))
            )

            ;; When all lines were selected and deleted do-put() leaves
            ;; an empty line that needs to be deleted now.
            (when (and empty (== (.at (ml-get (:ml_line_count (:b_ml @curbuf))) 0) NUL))
                (ml-delete (:ml_line_count (:b_ml @curbuf)), true)

                ;; If the cursor was in that line, move it to the end of the last line.
                (when (> (:lnum (:w_cursor @curwin)) (:ml_line_count (:b_ml @curbuf)))
                    ((ร @curwin.w_cursor.lnum =) (:ml_line_count (:b_ml @curbuf)))
                    (coladvance MAXCOL)
                )
            )
        ))
        nil
    ))

;; "o" and "O" commands.

(defn- #_void nv-open [#_cmdarg_C cap]
    (if @VIsual_active  ;; switch start and end of visual
        (v-swap-corners (:cmdchar cap))
        (n-opencmd cap))
    nil)

(defn- #_void nv-drop [#_cmdarg_C _cap]
    (do-put (byte \~), BACKWARD, 1, PUT_CURSEND)
    nil)

;; Trigger CursorHold event.
;; When waiting for a character for 'updatetime' K_CURSORHOLD is put in the
;; input buffer.  "did_cursorhold" is set to avoid retriggering.

(defn- #_void nv-cursorhold [#_cmdarg_C cap]
    (ยง
        (reset! did_cursorhold true)
        ((ร cap.retval =) (| (:retval cap) CA_COMMAND_BUSY))  ;; don't call edit() now
        nil
    ))

;; This table contains one entry for every Normal or Visual mode command.
;; The order doesn't matter, init_normal_cmds() will create a sorted index.
;; It is faster when all keys from zero to '~' are present.

(final nv_cmd_C* nv_cmds
    [
        (->nv_cmd_C NUL,              nv-error,       0,                      0               ),
        (->nv_cmd_C Ctrl_A,           nv-addsub,      0,                      0               ),
        (->nv_cmd_C Ctrl_B,           nv-page,        NV_STS,                 BACKWARD        ),
        (->nv_cmd_C Ctrl_C,           nv-esc,         0,                      TRUE            ),
        (->nv_cmd_C Ctrl_D,           nv-halfpage,    0,                      0               ),
        (->nv_cmd_C Ctrl_E,           nv-scroll-line, 0,                      TRUE            ),
        (->nv_cmd_C Ctrl_F,           nv-page,        NV_STS,                 FORWARD         ),
        (->nv_cmd_C Ctrl_G,           nv-ctrlg,       0,                      0               ),
        (->nv_cmd_C Ctrl_H,           nv-ctrlh,       0,                      0               ),
        (->nv_cmd_C Ctrl_I,           nv-pcmark,      0,                      0               ),
        (->nv_cmd_C NL,               nv-down,        0,                      FALSE           ),
        (->nv_cmd_C Ctrl_K,           nv-error,       0,                      0               ),
        (->nv_cmd_C Ctrl_L,           nv-clear,       0,                      0               ),
        (->nv_cmd_C Ctrl_M,           nv-down,        0,                      TRUE            ),
        (->nv_cmd_C Ctrl_N,           nv-down,        NV_STS,                 FALSE           ),
        (->nv_cmd_C Ctrl_O,           nv-ctrlo,       0,                      0               ),
        (->nv_cmd_C Ctrl_P,           nv-up,          NV_STS,                 FALSE           ),
        (->nv_cmd_C Ctrl_Q,           nv-visual,      0,                      FALSE           ),
        (->nv_cmd_C Ctrl_R,           nv-redo,        0,                      0               ),
        (->nv_cmd_C Ctrl_S,           nv-ignore,      0,                      0               ),
        (->nv_cmd_C Ctrl_T,           nv-error,       0,                      0               ),
        (->nv_cmd_C Ctrl_U,           nv-halfpage,    0,                      0               ),
        (->nv_cmd_C Ctrl_V,           nv-visual,      0,                      FALSE           ),
        (->nv_cmd_C (int \V),         nv-visual,      0,                      FALSE           ),
        (->nv_cmd_C (int \v),         nv-visual,      0,                      FALSE           ),
        (->nv_cmd_C Ctrl_W,           nv-window,      0,                      0               ),
        (->nv_cmd_C Ctrl_X,           nv-addsub,      0,                      0               ),
        (->nv_cmd_C Ctrl_Y,           nv-scroll-line, 0,                      FALSE           ),
        (->nv_cmd_C Ctrl_Z,           nv-suspend,     0,                      0               ),
        (->nv_cmd_C ESC,              nv-esc,         0,                      FALSE           ),
        (->nv_cmd_C Ctrl_BSL,         nv-normal,      NV_NCH_ALW,             0               ),
        (->nv_cmd_C Ctrl_RSB,         nv-ident,       NV_NCW,                 0               ),
        (->nv_cmd_C Ctrl_HAT,         nv-hat,         NV_NCW,                 0               ),
        (->nv_cmd_C Ctrl__,           nv-error,       0,                      0               ),
        (->nv_cmd_C (int \space),     nv-right,       0,                      0               ),
        (->nv_cmd_C (int \!),         nv-operator,    0,                      0               ),
        (->nv_cmd_C (int \"),         nv-regname,  (| NV_NCH_NOP NV_KEEPREG), 0               ),    ;; """
        (->nv_cmd_C (int \#),         nv-ident,       0,                      0               ),
        (->nv_cmd_C (int \$),         nv-dollar,      0,                      0               ),
        (->nv_cmd_C (int \%),         nv-percent,     0,                      0               ),
        (->nv_cmd_C (int \&),         nv-optrans,     0,                      0               ),
        (->nv_cmd_C (int \'),         nv-gomark,      NV_NCH_ALW,             TRUE            ),
        (->nv_cmd_C (int \(),         nv-brace,       0,                      BACKWARD        ),
        (->nv_cmd_C (int \)),         nv-brace,       0,                      FORWARD         ),
        (->nv_cmd_C (int \*),         nv-ident,       0,                      0               ),
        (->nv_cmd_C (int \+),         nv-down,        0,                      TRUE            ),
        (->nv_cmd_C (int \,),         nv-csearch,     0,                      TRUE            ),
        (->nv_cmd_C (int \-),         nv-up,          0,                      TRUE            ),
        (->nv_cmd_C (int \.),         nv-dot,         NV_KEEPREG,             0               ),
        (->nv_cmd_C (int \/),         nv-search,      0,                      FALSE           ),
        (->nv_cmd_C (int \0),         nv-beginline,   0,                      0               ),
        (->nv_cmd_C (int \1),         nv-ignore,      0,                      0               ),
        (->nv_cmd_C (int \2),         nv-ignore,      0,                      0               ),
        (->nv_cmd_C (int \3),         nv-ignore,      0,                      0               ),
        (->nv_cmd_C (int \4),         nv-ignore,      0,                      0               ),
        (->nv_cmd_C (int \5),         nv-ignore,      0,                      0               ),
        (->nv_cmd_C (int \6),         nv-ignore,      0,                      0               ),
        (->nv_cmd_C (int \7),         nv-ignore,      0,                      0               ),
        (->nv_cmd_C (int \8),         nv-ignore,      0,                      0               ),
        (->nv_cmd_C (int \9),         nv-ignore,      0,                      0               ),
        (->nv_cmd_C (int \:),         nv-colon,       0,                      0               ),
        (->nv_cmd_C (int \;),         nv-csearch,     0,                      FALSE           ),
        (->nv_cmd_C (int \<),         nv-operator,    NV_RL,                  0               ),
        (->nv_cmd_C (int \=),         nv-operator,    0,                      0               ),
        (->nv_cmd_C (int \>),         nv-operator,    NV_RL,                  0               ),
        (->nv_cmd_C (int \?),         nv-search,      0,                      FALSE           ),
        (->nv_cmd_C (int \@),         nv-at,          NV_NCH_NOP,             FALSE           ),
        (->nv_cmd_C (int \A),         nv-edit,        0,                      0               ),
        (->nv_cmd_C (int \B),         nv-bck-word,    0,                      1               ),
        (->nv_cmd_C (int \C),         nv-abbrev,      NV_KEEPREG,             0               ),
        (->nv_cmd_C (int \D),         nv-abbrev,      NV_KEEPREG,             0               ),
        (->nv_cmd_C (int \E),         nv-wordcmd,     0,                      TRUE            ),
        (->nv_cmd_C (int \F),         nv-csearch,  (| NV_NCH_ALW NV_LANG),    BACKWARD        ),
        (->nv_cmd_C (int \G),         nv-goto,        0,                      TRUE            ),
        (->nv_cmd_C (int \H),         nv-scroll,      0,                      0               ),
        (->nv_cmd_C (int \I),         nv-edit,        0,                      0               ),
        (->nv_cmd_C (int \J),         nv-join,        0,                      0               ),
        (->nv_cmd_C (int \K),         nv-ident,       0,                      0               ),
        (->nv_cmd_C (int \L),         nv-scroll,      0,                      0               ),
        (->nv_cmd_C (int \M),         nv-scroll,      0,                      0               ),
        (->nv_cmd_C (int \N),         nv-next,        0,                      SEARCH_REV      ),
        (->nv_cmd_C (int \O),         nv-open,        0,                      0               ),
        (->nv_cmd_C (int \P),         nv-put,         0,                      0               ),
        (->nv_cmd_C (int \Q),         nv-exmode,      NV_NCW,                 0               ),
        (->nv_cmd_C (int \R),         nv-Replace,     0,                      FALSE           ),
        (->nv_cmd_C (int \S),         nv-subst,       NV_KEEPREG,             0               ),
        (->nv_cmd_C (int \T),         nv-csearch,  (| NV_NCH_ALW NV_LANG),    BACKWARD        ),
        (->nv_cmd_C (int \U),         nv-Undo,        0,                      0               ),
        (->nv_cmd_C (int \W),         nv-wordcmd,     0,                      TRUE            ),
        (->nv_cmd_C (int \X),         nv-abbrev,      NV_KEEPREG,             0               ),
        (->nv_cmd_C (int \Y),         nv-abbrev,      NV_KEEPREG,             0               ),
        (->nv_cmd_C (int \Z),         nv-Zet,      (| NV_NCH_NOP NV_NCW),     0               ),
        (->nv_cmd_C (int \[),         nv-brackets,    NV_NCH_ALW,             BACKWARD        ),
        (->nv_cmd_C (int \\),         nv-error,       0,                      0               ),
        (->nv_cmd_C (int \]),         nv-brackets,    NV_NCH_ALW,             FORWARD         ),
        (->nv_cmd_C (int \^),         nv-beginline,   0,                   (| BL_WHITE BL_FIX)),
        (->nv_cmd_C (int \_),         nv-lineop,      0,                      0               ),
        (->nv_cmd_C (int \`),         nv-gomark,      NV_NCH_ALW,             FALSE           ),
        (->nv_cmd_C (int \a),         nv-edit,        NV_NCH,                 0               ),
        (->nv_cmd_C (int \b),         nv-bck-word,    0,                      0               ),
        (->nv_cmd_C (int \c),         nv-operator,    0,                      0               ),
        (->nv_cmd_C (int \d),         nv-operator,    0,                      0               ),
        (->nv_cmd_C (int \e),         nv-wordcmd,     0,                      FALSE           ),
        (->nv_cmd_C (int \f),         nv-csearch,  (| NV_NCH_ALW NV_LANG),    FORWARD         ),
        (->nv_cmd_C (int \g),         nv-g-cmd,       NV_NCH_ALW,             FALSE           ),
        (->nv_cmd_C (int \h),         nv-left,        NV_RL,                  0               ),
        (->nv_cmd_C (int \i),         nv-edit,        NV_NCH,                 0               ),
        (->nv_cmd_C (int \j),         nv-down,        0,                      FALSE           ),
        (->nv_cmd_C (int \k),         nv-up,          0,                      FALSE           ),
        (->nv_cmd_C (int \l),         nv-right,       NV_RL,                  0               ),
        (->nv_cmd_C (int \m),         nv-mark,        NV_NCH_NOP,             0               ),
        (->nv_cmd_C (int \n),         nv-next,        0,                      0               ),
        (->nv_cmd_C (int \o),         nv-open,        0,                      0               ),
        (->nv_cmd_C (int \p),         nv-put,         0,                      0               ),
        (->nv_cmd_C (int \q),         nv-record,      NV_NCH,                 0               ),
        (->nv_cmd_C (int \r),         nv-replace,  (| NV_NCH_NOP NV_LANG),    0               ),
        (->nv_cmd_C (int \s),         nv-subst,       NV_KEEPREG,             0               ),
        (->nv_cmd_C (int \t),         nv-csearch,  (| NV_NCH_ALW NV_LANG),    FORWARD         ),
        (->nv_cmd_C (int \u),         nv-undo,        0,                      0               ),
        (->nv_cmd_C (int \w),         nv-wordcmd,     0,                      FALSE           ),
        (->nv_cmd_C (int \x),         nv-abbrev,      NV_KEEPREG,             0               ),
        (->nv_cmd_C (int \y),         nv-operator,    0,                      0               ),
        (->nv_cmd_C (int \z),         nv-zet,         NV_NCH_ALW,             0               ),
        (->nv_cmd_C (int \{),         nv-findpar,     0,                      BACKWARD        ),
        (->nv_cmd_C (int \|),         nv-pipe,        0,                      0               ),
        (->nv_cmd_C (int \}),         nv-findpar,     0,                      FORWARD         ),
        (->nv_cmd_C (int \~),         nv-tilde,       0,                      0               ),

        ;; pound sign
        (->nv_cmd_C (char_u POUND),   nv-ident,       0,                      0               ),
        (->nv_cmd_C K_IGNORE,         nv-ignore,      NV_KEEPREG,             0               ),
        (->nv_cmd_C K_NOP,            nv-nop,         0,                      0               ),
        (->nv_cmd_C K_INS,            nv-edit,        0,                      0               ),
        (->nv_cmd_C K_KINS,           nv-edit,        0,                      0               ),
        (->nv_cmd_C K_BS,             nv-ctrlh,       0,                      0               ),
        (->nv_cmd_C K_UP,             nv-up,       (| NV_SSS NV_STS),         FALSE           ),
        (->nv_cmd_C K_S_UP,           nv-page,        NV_SS,                  BACKWARD        ),
        (->nv_cmd_C K_DOWN,           nv-down,     (| NV_SSS NV_STS),         FALSE           ),
        (->nv_cmd_C K_S_DOWN,         nv-page,        NV_SS,                  FORWARD         ),
        (->nv_cmd_C K_LEFT,           nv-left,     (| NV_SSS NV_STS NV_RL),   0               ),
        (->nv_cmd_C K_S_LEFT,         nv-bck-word, (| NV_SS NV_RL),           0               ),
        (->nv_cmd_C K_C_LEFT,         nv-bck-word, (| NV_SSS NV_RL NV_STS),   1               ),
        (->nv_cmd_C K_RIGHT,          nv-right,    (| NV_SSS NV_STS NV_RL),   0               ),
        (->nv_cmd_C K_S_RIGHT,        nv-wordcmd,  (| NV_SS NV_RL),           FALSE           ),
        (->nv_cmd_C K_C_RIGHT,        nv-wordcmd,  (| NV_SSS NV_RL NV_STS),   TRUE            ),
        (->nv_cmd_C K_PAGEUP,         nv-page,     (| NV_SSS NV_STS),         BACKWARD        ),
        (->nv_cmd_C K_KPAGEUP,        nv-page,     (| NV_SSS NV_STS),         BACKWARD        ),
        (->nv_cmd_C K_PAGEDOWN,       nv-page,     (| NV_SSS NV_STS),         FORWARD         ),
        (->nv_cmd_C K_KPAGEDOWN,      nv-page,     (| NV_SSS NV_STS),         FORWARD         ),
        (->nv_cmd_C K_END,            nv-end,      (| NV_SSS NV_STS),         FALSE           ),
        (->nv_cmd_C K_KEND,           nv-end,      (| NV_SSS NV_STS),         FALSE           ),
        (->nv_cmd_C K_S_END,          nv-end,         NV_SS,                  FALSE           ),
        (->nv_cmd_C K_C_END,          nv-end,      (| NV_SSS NV_STS),         TRUE            ),
        (->nv_cmd_C K_HOME,           nv-home,     (| NV_SSS NV_STS),         0               ),
        (->nv_cmd_C K_KHOME,          nv-home,     (| NV_SSS NV_STS),         0               ),
        (->nv_cmd_C K_S_HOME,         nv-home,        NV_SS,                  0               ),
        (->nv_cmd_C K_C_HOME,         nv-goto,     (| NV_SSS NV_STS),         FALSE           ),
        (->nv_cmd_C K_DEL,            nv-abbrev,      0,                      0               ),
        (->nv_cmd_C K_KDEL,           nv-abbrev,      0,                      0               ),
        (->nv_cmd_C K_UNDO,           nv-kundo,       0,                      0               ),
        (->nv_cmd_C K_SELECT,         nv-select,      0,                      0               ),
        (->nv_cmd_C K_DROP,           nv-drop,        NV_STS,                 0               ),
        (->nv_cmd_C K_CURSORHOLD,     nv-cursorhold,  NV_KEEPREG,             0               ),
    ])

;; ops.c: implementation of op-shift, op-delete, op-tilde, op-change, op-yank, do-put and do-join

;; Number of registers.
;;      0 = unnamed register, for normal yanks and puts
;;   1..9 = registers '1' to '9', for deletes
;; 10..35 = registers 'a' to 'z'
;;     36 = delete register '-'
;;     37 = Selection register '*'.  Only if FEAT_CLIPBOARD defined
;;     38 = Clipboard register '+'.  Only if FEAT_CLIPBOARD and FEAT_X11 defined

;; Symbolic names for some registers.

(final int DELETION_REGISTER       36)
(final int STAR_REGISTER           37)
(final int PLUS_REGISTER           STAR_REGISTER)           ;; there is only one
(final int TILDE_REGISTER          (inc PLUS_REGISTER))

(final int NUM_REGISTERS           (inc TILDE_REGISTER))

;; Each yank register is an array of pointers to lines.

(class! #_final yankreg_C
    [
        (field Bytes*       y_array)            ;; pointer to array of line pointers
        (field int          y_size)             ;; number of lines in "y_array"
        (field byte         y_type)             ;; MLINE, MCHAR or MBLOCK
        (field int          y_width)            ;; only set if y_type == MBLOCK
    ])

(defn- #_void COPY-yankreg [#_yankreg_C y1, #_yankreg_C y0]
    (ยง
        ((ร y1.y_array =) (:y_array y0))
        ((ร y1.y_size =) (:y_size y0))
        ((ร y1.y_type =) (:y_type y0))
        ((ร y1.y_width =) (:y_width y0))
        nil
    ))

(defn- #_yankreg_C* ARRAY-yankreg [#_int n]
    (vec (repeatedly n NEW_yankreg_C)))

(final yankreg_C*   y_regs    (ARRAY-yankreg NUM_REGISTERS))

(atom! yankreg_C    y_current)      ;; ptr to current yankreg
(atom! boolean      y_append)       ;; true when appending
(atom! yankreg_C    y_previous)     ;; ptr to last written yankreg

;; structure used by block-prep, op-delete and op-yank for blockwise operators
;; also op-change, op-shift, op-insert, op-replace

(class! #_final block_def_C
    [
        (field int          startspaces)        ;; 'extra' cols before first char
        (field int          endspaces)          ;; 'extra' cols after last char
        (field int          textlen)            ;; chars in block
        (field Bytes        textstart)          ;; pointer to 1st char (partially) in block
        (field int          textcol)            ;; index of chars (partially) in block
        (field int          start_vcol)         ;; start col of 1st char wholly inside block
        (field int          end_vcol)           ;; start col of 1st char wholly after block
        (field boolean      is_short)           ;; true if line is too short to fit in block
        (field boolean      is_MAX)             ;; true if curswant == MAXCOL when starting
        (field boolean      is_oneChar)         ;; true if block within one character
        (field int          pre_whitesp)        ;; screen cols of ws before block
        (field int          pre_whitesp_c)      ;; chars of ws before block
        (field int          end_char_vcols)     ;; number of vcols of post-block char
        (field int          start_char_vcols)   ;; number of vcols of pre-block char
    ])

;; The names of operators.
;; IMPORTANT: Index must correspond with defines in vim.h!!!
;; The third field indicates whether the operator always works on lines.

(final byte** #_"[/*3*/]" opchars
    [
        [ NUL, NUL, FALSE ],    ;; OP_NOP
        [ \d,  NUL, FALSE ],    ;; OP_DELETE
        [ \y,  NUL, FALSE ],    ;; OP_YANK
        [ \c,  NUL, FALSE ],    ;; OP_CHANGE
        [ \<,  NUL, TRUE  ],    ;; OP_LSHIFT
        [ \>,  NUL, TRUE  ],    ;; OP_RSHIFT
        [ \!,  NUL, TRUE  ],    ;; OP_FILTER
        [ \g,  \~,  FALSE ],    ;; OP_TILDE
        [ \=,  NUL, TRUE  ],    ;; OP_INDENT
        [ \g,  \q,  TRUE  ],    ;; OP_FORMAT
        [ \:,  NUL, TRUE  ],    ;; OP_COLON
        [ \g,  \U,  FALSE ],    ;; OP_UPPER
        [ \g,  \u,  FALSE ],    ;; OP_LOWER
        [ \J,  NUL, TRUE  ],    ;; DO_JOIN
        [ \g,  \J,  TRUE  ],    ;; DO_JOIN_NS
        [ \g,  \?,  FALSE ],    ;; OP_ROT13
        [ \r,  NUL, FALSE ],    ;; OP_REPLACE
        [ \I,  NUL, FALSE ],    ;; OP_INSERT
        [ \A,  NUL, FALSE ],    ;; OP_APPEND
        [ \g,  \w,  TRUE  ],    ;; OP_FORMAT2
        [ \g,  \@,  FALSE ],    ;; OP_FUNCTION
    ])

;; Translate a command name into an operator type.
;; Must only be called with a valid operator name!

(defn- #_int get-op-type [#_int char1, #_int char2]
    (ยง
        (if (== char1 (byte \r))           ;; ignore second character
            ((ร RETURN) OP_REPLACE)
        )
        (if (== char1 (byte \~))           ;; when tilde is an operator
            ((ร RETURN) OP_TILDE)
        )

        (ร int i)
        ((ร FOR) (ร ((ร i =) 0) true (ร i++))
            (if (and (== (... (... opchars i) 0) char1) (== (... (... opchars i) 1) char2))
                (ร BREAK)
            )
        )
        i
    ))

;; Return true if operator "op" always works on whole lines.

(defn- #_boolean op-on-lines [#_int op]
    (!= (... (... opchars op) 2) FALSE))

;; Get first operator command character.
;; Returns 'g' or 'z' if there is another command character.

(defn- #_int get-op-char [#_int optype]
    (... (... opchars optype) 0))

;; Get second operator command character.

(defn- #_int get-extra-op-char [#_int optype]
    (... (... opchars optype) 1))

;; op-shift - handle a shift operation

(defn- #_void op-shift [#_oparg_C oap, #_boolean curs_top, #_int amount]
    (ยง
        ((ร int block_col =) 0)

        (if (not (u-save (- (:lnum (:op_start oap)) 1), (+ (:lnum (:op_end oap)) 1)))
            ((ร RETURN) nil)
        )

        (if (:block_mode oap)
            ((ร block_col =) (:col (:w_cursor @curwin)))
        )

        ((ร FOR) (ร ((ร long n =) (:line_count oap)) (<= 0 (ร --n)) (ร @curwin.w_cursor.lnum++))
            ((ร byte c0 =) (.at (ml-get-curline) 0))
            (cond (== c0 NUL)                      ;; empty line
            (do
                ((ร @curwin.w_cursor.col =) 0)
            )
            (:block_mode oap)
            (do
                (shift-block oap, amount)
            )
            :else
            (do
                (shift-line (== (:op_type oap) OP_LSHIFT), @p_sr, amount, false)
            ))
        )

        (changed-lines (:lnum (:op_start oap)), 0, (+ (:lnum (:op_end oap)) 1), 0)

        (cond (:block_mode oap)
        (do
            ((ร @curwin.w_cursor.lnum =) (:lnum (:op_start oap)))
            ((ร @curwin.w_cursor.col =) block_col)
        )
        curs_top      ;; put cursor on first line, for ">>"
        (do
            ((ร @curwin.w_cursor.lnum =) (:lnum (:op_start oap)))
            (beginline (| BL_SOL BL_FIX))     ;; shift-line() may have set cursor.col
        )
        :else
        (do
            (ร --@curwin.w_cursor.lnum)         ;; put cursor on last line, for ":>"
        ))

        (when (< @p_report (:line_count oap))
            ((ร Bytes s =) (if (== (:op_type oap) OP_RSHIFT) (u8 ">") (u8 "<")))
            (cond (== (:line_count oap) 1)
            (do
                (if (== amount 1)
                    (.sprintf libC @ioBuff, (u8 "1 line %sed 1 time"), s)
                    (.sprintf libC @ioBuff, (u8 "1 line %sed %d times"), s, amount)
                )
            )
            :else
            (do
                (if (== amount 1)
                    (.sprintf libC @ioBuff, (u8 "%ld lines %sed 1 time"), (:line_count oap), s)
                    (.sprintf libC @ioBuff, (u8 "%ld lines %sed %d times"), (:line_count oap), s, amount)
                )
            ))
            (msg @ioBuff)
        )

        ;; Set "'[" and "']" marks.

        (COPY-pos (:b_op_start @curbuf), (:op_start oap))
        ((ร @curbuf.b_op_end.lnum =) (:lnum (:op_end oap)))
        ((ร @curbuf.b_op_end.col =) (STRLEN (ml-get (:lnum (:op_end oap)))))
        (when (< 0 (:col (:b_op_end @curbuf)))
            (ร --@curbuf.b_op_end.col)
        )
        nil
    ))

;; shift the current line one shiftwidth left (if left != 0) or right
;; leaves cursor on first blank in the line

(defn- #_void shift-line [#_boolean left, #_boolean round, #_int amount, #_boolean call_changed_bytes]
    ;; call_changed_bytes: call changed-bytes()
    (ยง
        ((ร int q_sw =) (int (get-sw-value @curbuf)))

        ((ร int count =) (get-indent))       ;; get current indent

        (cond round                      ;; round off indent
        (do
            ((ร int i =) (/ count q_sw))       ;; number of 'shiftwidth' rounded down
            ((ร int j =) (% count q_sw))       ;; extra spaces
            (if (and (non-zero? j) left)         ;; first remove extra spaces
                (ร --amount)
            )
            (cond left
            (do
                ((ร i =) (- i amount))
                (if (< i 0)
                    ((ร i =) 0)
                )
            )
            :else
            (do
                ((ร i =) (+ i amount))
            ))
            ((ร count =) (* i q_sw))
        )
        :else                            ;; original vi indent
        (do
            (cond left
            (do
                ((ร count =) (- count (* q_sw amount)))
                (if (< count 0)
                    ((ร count =) 0)
                )
            )
            :else
            (do
                ((ร count =) (+ count (* q_sw amount)))
            ))
        ))

        ;; Set new indent.
        (if (flag? @State VREPLACE_FLAG)
            (change-indent INDENT_SET, count, false, NUL, call_changed_bytes)
            (set-indent count, (if call_changed_bytes SIN_CHANGED 0)))
        nil
    ))

;; Shift one line of the current block one shiftwidth right or left.
;; Leaves cursor on first character in block.

(defn- #_void shift-block [#_oparg_C oap, #_int amount]
    (ยง
        ((ร boolean left =) (== (:op_type oap) OP_LSHIFT))

        ((ร int oldcol =) (:col (:w_cursor @curwin)))
        ((ร int q_sw =) (int (get-sw-value @curbuf)))
        ((ร int q_ts =) (int @(:b_p_ts @curbuf)))

        ((ร int oldstate =) @State)
        (reset! State INSERT)             ;; don't want REPLACE for State

        ((ร block_def_C bd =) (NEW_block_def_C))
        (block-prep oap, bd, (:lnum (:w_cursor @curwin)), true)
        (if (:is_short bd)
            ((ร RETURN) nil)
        )

        ;; total is number of screen columns to be inserted/removed
        ((ร int total =) (* amount q_sw))
        ((ร Bytes oldp =) (ml-get-curline))
        (ร Bytes newp)

        (cond (not left)
        (do
            ;;  1. Get start vcol
            ;;  2. Total ws vcols
            ;;  3. Divvy into TABs & spp
            ;;  4. Construct new string

            ((ร total =) (+ total (:pre_whitesp bd)))    ;; all virtual WS upto & incl. a split TAB
            ((ร int ws_vcol =) (- (:start_vcol bd) (:pre_whitesp bd)))
            (if (non-zero? (:startspaces bd))
                ((ร bd.textstart =) (.plus (:textstart bd) (us-ptr2len-cc (:textstart bd))))
            )
            (while (vim-iswhite (.at (:textstart bd) 0))
                ;; TODO: is passing bd.textstart for start of the line OK?
                (ร int incr)
;               { Bytes[] __ = { bd.textstart }; incr = lbr-chartabsize-adv(bd.textstart, __, bd.start_vcol); bd.textstart = __[0]; }
                ((ร total =) (+ total incr))
                ((ร bd.start_vcol =) (+ (:start_vcol bd) incr))
            )
            ;; OK, now total=all the VWS reqd, and textstart
            ;; points at the 1st non-ws char in the block.
            ((ร int i =) (ร 0, j = total))
            (if (not @(:b_p_et @curbuf))
                ((ร i =) (/ (+ (% ws_vcol q_ts) total) q_ts)) ;; number of tabs
            )
            (if (non-zero? i)
                ((ร j =) (% (+ (% ws_vcol q_ts) total) q_ts)) ;; number of spp
            )
            ;; if we're splitting a TAB, allow for it
            ((ร bd.textcol =) (- (:textcol bd) (- (:pre_whitesp_c bd) (if (non-zero? (:startspaces bd)) 1 0))))
            ((ร int len =) (+ (STRLEN (:textstart bd)) 1))
            ((ร newp =) (Bytes. (+ (:textcol bd) i j len)))

            (BCOPY newp, oldp, (:textcol bd))
            (copy-chars (.plus newp (:textcol bd)), i, TAB)
            (copy-spaces (.plus newp (+ (:textcol bd) i)), j)
            (BCOPY newp, (+ (:textcol bd) i j), (:textstart bd), 0, len)
        )
        :else ;; left
        (do
            ;; Firstly, let's find the first non-whitespace character that is
            ;; displayed after the block's start column and the character's column
            ;; number.  Also, let's calculate the width of all the whitespace
            ;; characters that are displayed in the block and precede the searched
            ;; non-whitespace character.

            ;; If "bd.startspaces" is set, "bd.textstart" points to the character,
            ;; the part of which is displayed at the block's beginning.  Let's start
            ;; searching from the next character.
; %%        ((ร Bytes[] non_white =) (ร { (bd.textstart) }))
            (if (non-zero? (:startspaces bd))
                ((ร non_white[0] =) (.plus (... non_white 0) (us-ptr2len-cc (... non_white 0))))
            )

            ;; The character's column is in "bd.start_vcol".
            ((ร int non_white_col =) (:start_vcol bd))

            (while (vim-iswhite (.at (... non_white 0) 0))
                ((ร int incr =) (lbr-chartabsize-adv (:textstart bd), non_white, non_white_col))
                ((ร non_white_col =) (+ non_white_col incr))
            )

            ((ร int block_space_width =) (- non_white_col (:start_vcol oap)))
            ;; We will shift by "total" or "block_space_width", whichever is less.
            ((ร int shift_amount =) (if (< block_space_width total) block_space_width total))

            ;; The column to which we will shift the text.
            ((ร int destination_col =) (- non_white_col shift_amount))

            ;; Now let's find out how much of the beginning
            ;; of the line we can reuse without modification.

            ;; end of the part of the line which is copied verbatim
            ((ร Bytes verbatim_copy_end =) (:textstart bd))
            ;; the (displayed) width of this part of line
            ((ร int verbatim_copy_width =) (:start_vcol bd))

            ;; If "bd.startspaces" is set, "bd.textstart" points to the character preceding the block.
            ;; We have to subtract its width to obtain its column number.
            (if (non-zero? (:startspaces bd))
                ((ร verbatim_copy_width =) (- verbatim_copy_width (:start_char_vcols bd)))
            )
            (while (< verbatim_copy_width destination_col)
                ((ร Bytes line =) verbatim_copy_end)

                ;; TODO: is passing "verbatim_copy_end" for start of the line OK?
                ((ร int incr =) (lbr-chartabsize line, verbatim_copy_end, verbatim_copy_width))
                (if (< destination_col (+ verbatim_copy_width incr))
                    (ร BREAK)
                )
                ((ร verbatim_copy_width =) (+ verbatim_copy_width incr))
                ((ร verbatim_copy_end =) (.plus verbatim_copy_end (us-ptr2len-cc verbatim_copy_end)))
            )

            ;; If "destination_col" is different from the width of the initial
            ;; part of the line that will be copied, it means we encountered a tab
            ;; character, which we will have to partly replace with spaces.
            ((ร int fill =) (- destination_col verbatim_copy_width))

            ;; The replacement line will consist of:
            ;; - the beginning of the original line up to "verbatim_copy_end",
            ;; - "fill" number of spaces,
            ;; - the rest of the line, pointed to by "non_white".

            ;; the length of the line after the block shift
            ((ร int diff =) (BDIFF verbatim_copy_end, oldp))
            ((ร int new_line_len =) (+ diff fill (STRLEN (... non_white 0)) 1))

            ((ร newp =) (Bytes. new_line_len))

            (BCOPY newp, oldp, diff)
            (copy-spaces (.plus newp diff), fill)
            (BCOPY newp, (+ diff fill), (... non_white 0), 0, (+ (STRLEN (... non_white 0)) 1))
        ))

        ;; replace the line
        (ml-replace (:lnum (:w_cursor @curwin)), newp)
        (changed-bytes (:lnum (:w_cursor @curwin)), (:textcol bd))
        (reset! State oldstate)
        ((ร @curwin.w_cursor.col =) oldcol)
        nil
    ))

;; Insert string "s" (b_insert ? before : after) block.
;; Caller must prepare for undo.

(defn- #_void block-insert [#_oparg_C oap, #_Bytes s, #_boolean b_insert, #_block_def_C bdp]
    (ยง
        ((ร int count =) 0)                                  ;; extra spaces to replace a cut TAB
        ((ร int spaces =) 0)                                 ;; non-zero if cutting a TAB

        ((ร int oldstate =) @State)
        (reset! State INSERT)                                 ;; don't want REPLACE for State

        ((ร int s_len =) (STRLEN s))

        ((ร FOR) (ร ((ร long lnum =) (+ (:lnum (:op_start oap)) 1)) (<= lnum (:lnum (:op_end oap))) (ร lnum++))
            (block-prep oap, bdp, lnum, true)
            (if (and (:is_short bdp) b_insert)
                (ร CONTINUE)                               ;; OP_INSERT, line ends before block start
            )

            ((ร Bytes oldp =) (ml-get lnum))

            (ร int q_ts)
            (ร int offset)
            (cond b_insert
            (do
                ((ร q_ts =) (:start_char_vcols bdp))
                ((ร spaces =) (:startspaces bdp))
                (if (non-zero? spaces)
                    ((ร count =) (dec q_ts))                   ;; we're cutting a TAB
                )
                ((ร offset =) (:textcol bdp))
            )
            :else                                        ;; append
            (do
                ((ร q_ts =) (:end_char_vcols bdp))
                (cond (not (:is_short bdp))                      ;; spaces = padding after block
                (do
                    ((ร spaces =) (if (non-zero? (:endspaces bdp)) (- q_ts (:endspaces bdp)) 0))
                    (if (non-zero? spaces)
                        ((ร count =) (dec q_ts))               ;; we're cutting a TAB
                    )
                    ((ร offset =) (- (+ (:textcol bdp) (:textlen bdp)) (if (non-zero? spaces) 1 0)))
                )
                :else                                    ;; spaces = padding to block edge
                (do
                    ;; if $ used, just append to EOL (ie spaces==0)
                    (if (not (:is_MAX bdp))
                        ((ร spaces =) (+ (- (:end_vcol oap) (:end_vcol bdp)) 1))
                    )
                    ((ร count =) spaces)
                    ((ร offset =) (+ (:textcol bdp) (:textlen bdp)))
                ))
            ))

            (when (< 0 spaces)
                (ร int off)

                ;; Avoid starting halfway a multi-byte character.
                (cond b_insert
                (do
                    ((ร off =) (us-head-off oldp, (.plus oldp (+ offset spaces))))
                )
                :else
                (do
                    ((ร off =) (us-off-next oldp, (.plus oldp offset)))
                    ((ร offset =) (+ offset off))
                ))
                ((ร spaces =) (- spaces off))
                ((ร count =) (- count off))
            )

            ((ร Bytes newp =) (Bytes. (+ (STRLEN oldp) s_len count 1)))

            ;; copy up to shifted part
            (BCOPY newp, oldp, offset)
            ((ร oldp =) (.plus oldp offset))

            ;; insert pre-padding
            (copy-spaces (.plus newp offset), spaces)

            ;; copy the new text
            (BCOPY newp, (+ offset spaces), s, 0, s_len)
            ((ร offset =) (+ offset s_len))

            (when (and (< 0 spaces) (not (:is_short bdp)))
                ;; insert post-padding
                (copy-spaces (.plus newp (+ offset spaces)), (- q_ts spaces))
                ;; We're splitting a TAB, don't copy it.
                ((ร oldp =) (.plus oldp 1))
                ;; We allowed for that TAB, remember this now.
                (ร count++)
            )

            (if (< 0 spaces)
                ((ร offset =) (+ offset count))
            )
            (BCOPY newp, offset, oldp, 0, (+ (STRLEN oldp) 1))

            (ml-replace lnum, newp)

            (when (== lnum (:lnum (:op_end oap)))
                ;; Set "']" mark to the end of the block instead of the end of the insert in the first line.
                ((ร @curbuf.b_op_end.lnum =) (:lnum (:op_end oap)))
                ((ร @curbuf.b_op_end.col =) offset)
            )
        )

        (changed-lines (+ (:lnum (:op_start oap)) 1), 0, (+ (:lnum (:op_end oap)) 1), 0)

        (reset! State oldstate)
        nil
    ))

;; op-reindent - handle reindenting a block of lines.

(defn- #_void op-reindent [#_oparg_C oap, #_getindent_F getindent]
    (ยง
        ((ร long first_changed =) 0)
        ((ร long last_changed =) 0)
        ((ร long start_lnum =) (:lnum (:w_cursor @curwin)))

        (ร long i)
        ((ร FOR) (ร ((ร i =) (:line_count oap)) (and (<= 0 (ร --i)) (not @got_int)) nil)
            ;; It's a slow thing to do, so give feedback,
            ;; so there's no worry that the computer's just hung.

            (if (and (< 1 i) (or (zero? (% i 50)) (== i (- (:line_count oap) 1))) (< @p_report (:line_count oap)))
                (smsg (u8 "%ld lines to indent... "), i))

            ((ร int count =) 0)
            ((ร Bytes l =) (skipwhite (ml-get-curline)))
            (if (non-eos? l)                     ;; empty or blank line
                ((ร count =) (getindent))            ;; get the indent for this line
            )

            (when (set-indent count, SIN_UNDO)
                ;; did change the indent, call changed-lines() later
                (if (zero? first_changed)
                    ((ร first_changed =) (:lnum (:w_cursor @curwin)))
                )
                ((ร last_changed =) (:lnum (:w_cursor @curwin)))
            )

            (ร @curwin.w_cursor.lnum++)
            ((ร @curwin.w_cursor.col =) 0)            ;; make sure it's valid
        )

        ;; put cursor on first non-blank of indented line
        ((ร @curwin.w_cursor.lnum =) start_lnum)
        (beginline (| BL_SOL BL_FIX))

        ;; Mark changed lines so that they will be redrawn.
        ;; When Visual highlighting was present, need to continue until the last line.
        ;; When there is no change still need to remove the Visual highlighting.
        (cond (non-zero? last_changed)
        (do
            (changed-lines first_changed, 0, (if (:is_VIsual oap) (+ start_lnum (:line_count oap)) (inc last_changed)), 0)
        )
        (:is_VIsual oap)
        (do
            (redraw-curbuf-later INVERTED)
        ))

        (when (< @p_report (:line_count oap))
            ((ร i =) (- (:line_count oap) (inc i)))
            (if (== i 1)
                (msg (u8 "1 line indented "))
                (smsg (u8 "%ld lines indented "), i))
        )
        ;; set '[ and '] marks
        (COPY-pos (:b_op_start @curbuf), (:op_start oap))
        (COPY-pos (:b_op_end @curbuf), (:op_end oap))
        nil
    ))

;; Keep the last expression line here, for repeating.

(atom! Bytes expr_line)

;; Get an expression for the "\"=expr1" or "CTRL-R =expr1"
;; Returns '=' when OK, NUL otherwise.

(defn- #_int get-expr-register []
    (ยง
        ((ร Bytes new_line =) (getcmdline (byte \=), 0))
        (if (nil? new_line)
            ((ร RETURN) NUL)
        )

        (cond (eos? new_line)
        (do
            ; ;; use previous line
        )
        :else
        (do
            (reset! expr_line new_line)
        ))

        (byte \=)
    ))

(atom! int __nested)

;; Get the result of the '=' register expression.
;; Returns a pointer to allocated memory, or null for failure.

(defn- #_Bytes get-expr-line []
    (ยง
        (if (nil? @expr_line)
            ((ร RETURN) nil)
        )

        ;; Make a copy of the expression, because evaluating it may cause it to be changed.
        ((ร Bytes expr_copy =) (STRDUP @expr_line))

        ;; When we are invoked recursively limit the evaluation to 10 levels.
        ;; Then return the string as-is.
        (if (<= 10 @__nested)
            ((ร RETURN) expr_copy)
        )

        (swap! __nested inc)
        ((ร Bytes rv =) (eval-to-string expr_copy, nil))
        (swap! __nested dec)
        rv
    ))

;; Check if 'regname' is a valid name of a yank register.
;; Note: There is no check for 0 (default register), caller should do this.

(defn- #_boolean valid-yank-reg [#_int regname, #_boolean writing]
    ;; writing: if true check for writable registers
    (or (and (< 0 regname) (asc-isalnum regname))
        (and (not writing) (non-nil? (vim-strchr (u8 "/.%:="), regname)))
        (== regname (byte \#))
        (== regname (byte \"))   ;; """
        (== regname (byte \-))
        (== regname (byte \_))
        (== regname (byte \*))
        (== regname (byte \+))
        (and (not writing) (== regname (byte \~)))
    ))

;; Set y_current and y_append, according to the value of "regname".
;; Cannot handle the '_' register.
;; Must only be called with a valid register name!
;;
;; If regname is 0 and writing, use register 0.
;; If regname is 0 and reading, use previous register.

(defn- #_void get-yank-register [#_int regname, #_boolean writing]
    (ยง
        (reset! y_append false)

        (when (and (or (zero? regname) (== regname (byte \"))) (not writing) (non-nil? @y_previous))    ;; """
            (reset! y_current @y_previous)
            ((ร RETURN) nil)
        )

        ((ร int i =) regname)
        (cond (asc-isdigit i)
        (do
            ((ร i =) (- i (byte \0)))
        )
        (asc-islower i)
        (do
            ((ร i =) (+ (lowerOrd i) 10))
        )
        (asc-isupper i)
        (do
            ((ร i =) (+ (upperOrd i) 10))
            (reset! y_append true)
        )
        (== regname (byte \-))
        (do
            ((ร i =) DELETION_REGISTER)
        )
        (and (not writing) (== regname (byte \~)))
        (do
            ((ร i =) TILDE_REGISTER)
        )
        :else                ;; not 0-9, a-z, A-Z or '-': use register 0
        (do
            ((ร i =) 0)
        ))

        (reset! y_current (... y_regs i))

        (when writing        ;; remember the register we write into for do-put()
            (reset! y_previous @y_current)
        )
        nil
    ))

;; Obtain the contents of a "normal" register.  The register is made empty.
;; The returned pointer has allocated memory, use put-register() later.

(defn- #_yankreg_C get-register [#_int name, #_boolean copy]
    ;; copy: make a copy, if false make register empty.
    (ยง
        (get-yank-register name, false)

        ((ร yankreg_C reg =) (NEW_yankreg_C))

        (COPY-yankreg reg, @y_current)
        (cond copy
        (do
            ;; If we run out of memory some or all of the lines are empty.
            (cond (zero? (:y_size reg))
            (do
                ((ร reg.y_array =) nil)
            )
            :else
            (do
                ((ร reg.y_array =) (ร new Bytes[reg.y_size]))

                (dotimes [#_int i (:y_size reg)]
                    ((ร reg.y_array[i] =) (STRDUP (... (:y_array @y_current) i)))
                )
            ))
        )
        :else
        (do
            ((ร @y_current.y_array =) nil)
        ))

        reg
    ))

;; Put "reg" into register "name".  Free any previous contents and "reg".

(defn- #_void put-register [#_int name, #_yankreg_C reg]
    (ยง
        (get-yank-register name, false)
        ((ร @y_current.y_array =) nil)
        (COPY-yankreg @y_current, reg)
        nil
    ))

(atom! int rec__regname)

;; Start or stop recording into a yank register.
;;
;; Return false for failure, true otherwise.

(defn- #_boolean do-record [#_int c]
    (ยง
        (ร boolean retval)

        (cond (not @Recording)         ;; start recording
        (do
            ;; registers 0-9, a-z and " are allowed
            (cond (or (< c 0) (and (not (asc-isalnum c)) (!= c (byte \")))) ;; """
            (do
                ((ร retval =) false)
            )
            :else
            (do
                (reset! Recording true)
                (showmode)
                (reset! rec__regname c)
                ((ร retval =) true)
            ))
        )
        :else                            ;; stop recording
        (do
            ;; Get the recorded key hits.
            ;; KB_SPECIAL will be escaped, this needs to be removed again to put it in a register.
            ;; exec_reg then adds the escaping back later.

            (reset! Recording false)
            (msg (u8 ""))
            ((ร Bytes p =) (get-recorded))
            (cond (nil? p)
            (do
                ((ร retval =) false)
            )
            :else
            (do
                ;; Remove escaping for KB_SPECIAL in multi-byte chars.
                (vim-unescape-special p)

                ;; We don't want to change the default register here,
                ;; so save and restore the current register name.

                ((ร yankreg_C old_y_previous =) @y_previous)
                ((ร yankreg_C old_y_current =) @y_current)

                ((ร retval =) (stuff-yank @rec__regname, p))

                (reset! y_previous old_y_previous)
                (reset! y_current old_y_current)
            ))
        ))

        retval
    ))

;; Stuff string "p" into yank register "regname" as a single line (append if uppercase).
;; "p" must have been alloced.
;;
;; return false for failure, true otherwise

(defn- #_boolean stuff-yank [#_int regname, #_Bytes p]
    (ยง
        ;; check for read-only register
        (if (and (non-zero? regname) (not (valid-yank-reg regname, true)))
            ((ร RETURN) false)
        )
        (if (== regname (byte \_))             ;; black hole: don't do anything
            ((ร RETURN) true)
        )

        (get-yank-register regname, true)

        (cond (and @y_append (non-nil? (:y_array @y_current)))
        (do
            ((ร Bytes[] a =) (:y_array @y_current))
            ((ร int i =) (- (:y_size @y_current) 1))

            ((ร Bytes lp =) (Bytes. (+ (STRLEN (... a i)) (STRLEN p) 1)))
            (STRCPY lp, (... a i))
            (STRCAT lp, p)
            ((ร a[i] =) lp)
        )
        :else
        (do
            ((ร @y_current.y_array =) (ร new Bytes[1]))
            ((ร @y_current.y_array[0] =) p)
            ((ร @y_current.y_size =) 1)
            ((ร @y_current.y_type =) MCHAR)   ;; used to be MLINE, why?
        ))

        true
    ))

(atom! int execreg_lastc NUL)

;; execute a yank register: copy it into the stuff buffer
;;
;; return false for failure, true otherwise

(defn- #_boolean do-execreg [#_int regname]
    (ยง
        (when (== regname (byte \@))                 ;; repeat previous one
            (when (== @execreg_lastc NUL)
                (emsg (u8 "E748: No previously used register"))
                ((ร RETURN) false)
            )
            ((ร regname =) @execreg_lastc)
        )
                                            ;; check for valid regname
        (when (or (== regname (byte \%)) (== regname (byte \#)) (not (valid-yank-reg regname, false)))
            (emsg-invreg regname)
            ((ร RETURN) false)
        )
        (reset! execreg_lastc regname)

        ((ร regname =) (may-get-selection regname))

        (if (== regname (byte \_))                 ;; black hole: don't stuff anything
            ((ร RETURN) true)
        )

        (when (== regname (byte \:))                 ;; use last command line
            (when (nil? @last_cmdline)
                (emsg e_nolastcmd)
                ((ร RETURN) false)
            )

            (reset! new_last_cmdline nil)        ;; don't keep the cmdline containing @:

            ;; Escape all control characters with a CTRL-V.
            ((ร Bytes p =) (vim-strsave-escaped-ext @last_cmdline, (u8 "\001\002\003\004\005\006\007\010\011\012\013\014\015\016\017\020\021\022\023\024\025\026\027\030\031\032\033\034\035\036\037"), Ctrl_V))

            ;; When in Visual mode "'<,'>" will be prepended to the command.
            ;; Remove it when it's already there.
            (if (and @VIsual_active (zero? (STRNCMP p, (u8 "'<,'>"), 5)))
                ((ร p =) (.plus p 5))
            )

            ((ร RETURN) (put-in-typebuf p, true, true))
        )

        (when (== regname (byte \=))
            ((ร Bytes p =) (get-expr-line))
            (if (nil? p)
                ((ร RETURN) false)
            )

            ((ร RETURN) (put-in-typebuf p, true, false))
        )

        (when (== regname (byte \.))            ;; use last inserted text
            ((ร Bytes p =) (get-last-insert-save))
            (when (nil? p)
                (emsg e_noinstext)
                ((ร RETURN) false)
            )
            ((ร RETURN) (put-in-typebuf p, false, false))
        )

        (get-yank-register regname, false)
        (if (nil? (:y_array @y_current))
            ((ร RETURN) false)
        )

        ;; Insert lines into typeahead buffer, from last one to first one.

        (put-reedit-in-typebuf)

        ((ร FOR) (ร ((ร int i =) (:y_size @y_current)) (<= 0 (ร --i)) nil)
            ;; insert NL between lines and after last line if type is MLINE
            (if (or (== (:y_type @y_current) MLINE) (< i (- (:y_size @y_current) 1)))
                (ins-typebuf (u8 "\n")))

            ((ร Bytes escaped =) (vim-strsave-escape-special (... (:y_array @y_current) i)))

            (ins-typebuf escaped)
        )

        (reset! execReg true)         ;; disable the 'q' command

        true
    ))

;; If "restart_edit" is not zero, put it in the typeahead buffer,
;; so that it's used only after other typeahead has been processed.

(defn- #_void put-reedit-in-typebuf []
    (ยง
        (when (!= @restart_edit NUL)
            ((ร Bytes buf =) (Bytes. 3))

            (cond (== @restart_edit (byte \V))
            (do
                (.be buf 0, (byte \g))
                (.be buf 1, (byte \R))
                (eos! buf 2)
            )
            :else
            (do
                (.be buf 0, (if (== @restart_edit (byte \I)) (byte \i) @restart_edit))
                (eos! buf 1)
            ))

            (ins-typebuf buf)
            (reset! restart_edit NUL)
        )
        nil
    ))

;; Insert register contents "s" into the typeahead buffer, so that it will be executed again.
;; When "esc" is true it is to be taken literally: escape CSI characters and no remapping.

(defn- #_boolean put-in-typebuf [#_Bytes s, #_boolean esc, #_boolean colon]
    ;; colon: add ':' before the line
    (ยง
        (put-reedit-in-typebuf)

        (if colon
            (ins-typebuf (u8 "\n")))

        ((ร Bytes p =) (if esc (vim-strsave-escape-special s) s))
        (if (nil? p)
            ((ร RETURN) false)
        )

        (ins-typebuf p)

        (if colon
            (ins-typebuf (u8 ":")))

        true
    ))

;; Insert a yank register: copy it into the Read buffer.
;; Used by CTRL-R command and middle mouse button in insert mode.
;;
;; return false for failure, true otherwise

(defn- #_boolean insert-reg [#_int regname, #_boolean literally]
    ;; literally: insert literally, not as if typed
    (ยง
        ((ร boolean retval =) true)

        ;; It is possible to get into an endless loop by having CTRL-R a in
        ;; register a and then, in insert mode, doing CTRL-R a.
        ;; If you hit CTRL-C, the loop will be broken here.

        (ui-breakcheck)
        (if @got_int
            ((ร RETURN) false)
        )

        ;; check for valid regname
        (if (and (!= regname NUL) (not (valid-yank-reg regname, false)))
            ((ร RETURN) false)
        )

        ((ร regname =) (may-get-selection regname))

        ((ร Bytes[] arg =) (ร new Bytes[1]))
        ((ร boolean[] allocated =) (ร new boolean[1]))

        (cond (== regname (byte \.))                 ;; insert last inserted text
        (do
            ((ร retval =) (stuff-inserted NUL, 1, true))
        )
        (get-spec-reg regname, arg, allocated, true)
        (do
            (if (nil? (... arg 0))
                ((ร RETURN) false)
            )
            (stuffescaped (... arg 0), literally)
        )
        :else                                ;; name or number register
        (do
            (get-yank-register regname, false)
            (cond (nil? (:y_array @y_current))
            (do
                ((ร retval =) false)
            )
            :else
            (do
                (dotimes [#_int i (:y_size @y_current)]
                    (stuffescaped (... (:y_array @y_current) i), literally)

                    ;; Insert a newline between lines and after last line if y_type is MLINE.

                    (if (or (== (:y_type @y_current) MLINE) (< i (- (:y_size @y_current) 1)))
                        (stuffcharReadbuff (byte \newline)))
                )
            ))
        ))

        retval
    ))

;; Stuff a string into the typeahead buffer, such that edit() will insert it
;; literally ("literally" true) or interpret is as typed characters.

(defn- #_void stuffescaped [#_Bytes _arg, #_boolean literally]
    (ยง
; %%    ((ร Bytes[] arg =) (ร { _arg }))
        (while (non-eos? (... arg 0))
            ;; Stuff a sequence of normal ASCII characters, that's fast.
            ;; Also stuff KB_SPECIAL to get the effect of a special key when "literally" is true.
            ((ร Bytes start =) (... arg 0))
            (while (or (and (<= (byte \space) (.at (... arg 0) 0)) (< (.at (... arg 0) 0) DEL)) (and (== (.at (... arg 0) 0) KB_SPECIAL) (not literally)))
                ((ร arg[0] =) (.plus (... arg 0) 1))
            )
            (if (BLT start, (... arg 0))
                (stuffReadbuffLen start, (BDIFF (... arg 0), start)))

            ;; stuff a single special character
            (when (non-eos? (... arg 0))
                ((ร int c =) (us-ptr2char-adv arg, false))
                (if (and literally (or (and (< c (byte \space)) (!= c TAB)) (== c DEL)))
                    (stuffcharReadbuff Ctrl_V))
                (stuffcharReadbuff c)
            )
        )
        nil
    ))

;; If "regname" is a special register, return true and store a pointer to its value in "argp".

(defn- #_boolean get-spec-reg [#_int regname, #_Bytes* argp, #_boolean* allocated, #_boolean errmsg]
    ;; allocated: return: true when value was allocated
    ;; errmsg: give error message when failing
    (ยง
        ((ร argp[0] =) nil)
        ((ร allocated[0] =) false)

        ((ร SWITCH) regname
            ((ร CASE) (byte \%))                                       ;; file name
            ((ร CASE) (byte \#))                                       ;; alternate file name
            (do
                ((ร argp[0] =) (ร null))
                ((ร RETURN) false)
            )

            ((ร CASE) (byte \=))                                       ;; result of expression
            (do
                ((ร argp[0] =) (get-expr-line))
                ((ร allocated[0] =) true)
                ((ร RETURN) true)
            )

            ((ร CASE) (byte \:))                                       ;; last command line
            (do
                (if (and (nil? @last_cmdline) errmsg)
                    (emsg e_nolastcmd))
                ((ร argp[0] =) @last_cmdline)
                ((ร RETURN) true)
            )

            ((ร CASE) (byte \/))                                       ;; last search-pattern
            (do
                (if (and (nil? (last-search-pat)) errmsg)
                    (emsg e_noprevre))
                ((ร argp[0] =) (last-search-pat))
                ((ร RETURN) true)
            )

            ((ร CASE) (byte \.))                                       ;; last inserted text
            (do
                ((ร argp[0] =) (get-last-insert-save))
                ((ร allocated[0] =) true)
                (if (and (nil? (... argp 0)) errmsg)
                    (emsg e_noinstext))
                ((ร RETURN) true)
            )

            ((ร CASE) Ctrl_W)                                    ;; word under cursor
            ((ร CASE) Ctrl_A)                                    ;; WORD (mnemonic All) under cursor
            (do
                (if (not errmsg)
                    ((ร RETURN) false)
                )
                ((ร int cnt =) (find-ident-under-cursor argp, (if (== regname Ctrl_W) (| FIND_IDENT FIND_STRING) FIND_STRING)))
                ((ร argp[0] =) (if (non-zero? cnt) (STRNDUP (... argp 0), cnt) nil))
                ((ร allocated[0] =) true)
                ((ร RETURN) true)
            )

            ((ร CASE) (byte \_))               ;; black hole: always empty
            (do
                ((ร argp[0] =) (u8 ""))
                ((ร RETURN) true)
            )
        )

        false
    ))

;; Paste a yank register into the command line.
;; Only for non-special registers.
;; Used by CTRL-R command in command-line mode
;; insert-reg() can't be used here, because special characters from the
;; register contents will be interpreted as commands.
;;
;; return false for failure, true otherwise

(defn- #_boolean cmdline-paste-reg [#_int regname, #_boolean literally, #_boolean remcr]
    ;; literally: Insert text literally instead of "as typed"
    ;; remcr: don't add trailing CR
    (ยง
        (get-yank-register regname, false)
        (if (nil? (:y_array @y_current))
            ((ร RETURN) false)
        )

        (dotimes [#_int i (:y_size @y_current)]
            (cmdline-paste-str (... (:y_array @y_current) i), literally)

            ;; Insert ^M between lines and after last line if type is MLINE.
            ;; Don't do this when "remcr" is true and the next line is empty.
            (when (or (== (:y_type @y_current) MLINE) (and (< i (- (:y_size @y_current) 1)) (not (and remcr (== i (- (:y_size @y_current) 2)) (== (.at (... (:y_array @y_current) (inc i)) 0) NUL)))))
                (cmdline-paste-str (u8 "\r"), literally)
            )

            ;; Check for CTRL-C in case someone tries to paste
            ;; a few thousand lines and gets bored.
            (ui-breakcheck)
            (if @got_int
                ((ร RETURN) false)
            )
        )

        true
    ))

;; Adjust the register name "reg" for the clipboard being used always and the clipboard being available.

(defn- #_int adjust-clip-reg [#_int reg]
    (ยง
        (if (or (== reg (byte \*)) (== reg (byte \+)))
            ((ร reg =) 0)
        )

        reg
    ))

;; When "reg" is a clipboard register, obtain the selection.
;; If it's not available return zero, otherwise return "reg".

(defn- #_int may-get-selection [#_int reg]
    (ยง
        (if (or (== reg (byte \*)) (== reg (byte \+)))
            ((ร reg =) 0)
        )

        reg
    ))

;; Handle a delete operation.
;;
;; Return false if undo failed, true otherwise.

(defn- #_boolean op-delete [#_oparg_C oap]
    (ยง
        ((ร long old_lcount =) (:ml_line_count (:b_ml @curbuf)))
        ((ร boolean did_yank =) false)
        ((ร int orig_regname =) (:regname oap))

        (if (non-zero? (& (:ml_flags (:b_ml @curbuf)) ML_EMPTY)) ;; nothing to do
            ((ร RETURN) true)
        )

        ;; Nothing to delete, return here.  Do prepare undo, for op-change().
        (if (:empty oap)
            ((ร RETURN) (u-save-cursor))
        )

        ((ร oap.regname =) (adjust-clip-reg (:regname oap)))

        (mb-adjust-opend oap)

        ;; Imitate the strange Vi behaviour: If the delete spans more than one
        ;; line and motion_type == MCHAR and the result is a blank line, make the
        ;; delete linewise.  Don't do this for the change command or Visual mode.

        (when (and (== (:motion_type oap) MCHAR) (not (:is_VIsual oap)) (not (:block_mode oap)) (< 1 (:line_count oap)) (== (:motion_force oap) NUL) (== (:op_type oap) OP_DELETE))
            ((ร Bytes ptr =) (.plus (ml-get (:lnum (:op_end oap))) (:col (:op_end oap))))
            (if (and (non-eos? ptr) (:inclusive oap))
                ((ร ptr =) (.plus ptr 1))
            )
            ((ร ptr =) (skipwhite ptr))
            (if (and (eos? ptr) (inindent 0))
                ((ร oap.motion_type =) MLINE)
            )
        )

;       setmarks:
;       {
            ;; Check for trying to delete (e.g. "D") in an empty line.
            ;; Note: For the change operator it is ok.

            (when (and (== (:motion_type oap) MCHAR) (== (:line_count oap) 1) (== (:op_type oap) OP_DELETE) (== (.at (ml-get (:lnum (:op_start oap))) 0) NUL))
                ;; It's an error to operate on an empty region,
                ;; when 'E' included in 'cpoptions' (Vi compatible).

                (when (!= @virtual_op FALSE)
                    ;; Virtual editing: nothing gets deleted,
                    ;; but we set the '[ and '] marks as if it happened.
                    (ร BREAK setmarks)
                )
                (if (non-nil? (vim-strbyte @p_cpo, CPO_EMPTYREGION))
                    (beep-flush))
                ((ร RETURN) true)
            )

            ;; Do a yank of whatever we're about to delete.
            ;; If a yank register was specified, put the deleted text into that register.
            ;; For the black hole register '_' don't yank anything.

            (when (!= (:regname oap) (byte \_))
                (when (non-zero? (:regname oap))
                    ;; check for read-only register
                    (when (not (valid-yank-reg (:regname oap), true))
                        (beep-flush)
                        ((ร RETURN) true)
                    )
                    (get-yank-register (:regname oap), true)       ;; yank into specif'd reg.
                    (if (op-yank oap, true, false)      ;; yank without message
                        ((ร did_yank =) true)
                    )
                )

                ;; Put deleted text into register 1 and shift number registers if the
                ;; delete contains a line break, or when a regname has been specified.
                ;; Use the register name from before adjust-clip-reg() may have changed it.

                (when (or (non-zero? orig_regname) (== (:motion_type oap) MLINE) (< 1 (:line_count oap)) (:use_reg_one oap))
                    (reset! y_current (... y_regs 9))
                    ((ร @y_current.y_array =) nil)               ;; free register nine
                    ((ร FOR) (ร ((ร int n =) 9) (< 1 n) (ร --n))
                        (COPY-yankreg (... y_regs n), (... y_regs (dec n)))
                    )
                    (reset! y_previous ((ร @y_current =) (... y_regs 1)))
                    ((ร y_regs[1].y_array =) nil)               ;; set register one to empty
                    (if (op-yank oap, true, false)
                        ((ร did_yank =) true)
                    )
                )

                ;; Yank into small delete register when no named register specified
                ;; and the delete is within one line.
                (when (and (zero? (:regname oap)) (!= (:motion_type oap) MLINE) (== (:line_count oap) 1))
                    ((ร oap.regname =) (byte \-))
                    (get-yank-register (:regname oap), true)
                    (if (op-yank oap, true, false)
                        ((ร did_yank =) true)
                    )
                    ((ร oap.regname =) 0)
                )

                ;; If there's too much stuff to fit in the yank register, then get a
                ;; confirmation before doing the delete.  This is crude, but simple.
                ;; And it avoids doing a delete of something we can't put back if we want.

                (when (and (not did_yank) (!= (ask-yesno (u8 "cannot yank; delete anyway"), true) (byte \y)))
                    (emsg e_abort)
                    ((ร RETURN) false)
                )
            )

            ;; block mode delete

            (cond (:block_mode oap)
            (do
                (if (not (u-save (- (:lnum (:op_start oap)) 1), (+ (:lnum (:op_end oap)) 1)))
                    ((ร RETURN) false)
                )

                ((ร block_def_C bd =) (NEW_block_def_C))
                ((ร FOR) (ร ((ร long lnum =) (:lnum (:w_cursor @curwin))) (<= lnum (:lnum (:op_end oap))) (ร lnum++))
                    (block-prep oap, bd, lnum, true)
                    (if (zero? (:textlen bd))    ;; nothing to delete
                        (ร CONTINUE)
                    )

                    ;; Adjust cursor position for tab replaced by spaces and 'lbr'.
                    (when (== lnum (:lnum (:w_cursor @curwin)))
                        ((ร @curwin.w_cursor.col =) (+ (:textcol bd) (:startspaces bd)))
                        ((ร @curwin.w_cursor.coladd =) 0)
                    )

                    ;; n == number of chars deleted
                    ;; If we delete a TAB, it may be replaced by several characters.
                    ;; Thus the number of characters may increase!

                    ((ร int n =) (- (:textlen bd) (:startspaces bd) (:endspaces bd)))
                    ((ร Bytes oldp =) (ml-get lnum))
                    ((ร Bytes newp =) (Bytes. (- (+ (STRLEN oldp) 1) n)))

                    ;; copy up to deleted part
                    (BCOPY newp, oldp, (:textcol bd))
                    ;; insert spaces
                    (copy-spaces (.plus newp (:textcol bd)), (+ (:startspaces bd) (:endspaces bd)))
                    ;; copy the part after the deleted part
                    ((ร oldp =) (.plus oldp (+ (:textcol bd) (:textlen bd))))
                    (BCOPY newp, (+ (:textcol bd) (:startspaces bd) (:endspaces bd)), oldp, 0, (+ (STRLEN oldp) 1))
                    ;; replace the line
                    (ml-replace lnum, newp)
                )

                (check-cursor-col)
                (changed-lines (:lnum (:w_cursor @curwin)), (:col (:w_cursor @curwin)), (+ (:lnum (:op_end oap)) 1), 0)
                ((ร oap.line_count =) 0)     ;; no lines deleted
            )
            (== (:motion_type oap) MLINE)
            (do
                (cond (== (:op_type oap) OP_CHANGE)
                (do
                    ;; Delete the lines except the first one.  Temporarily move the
                    ;; cursor to the next line.  Save the current line number, if the
                    ;; last line is deleted it may be changed.

                    (when (< 1 (:line_count oap))
                        ((ร long lnum =) (:lnum (:w_cursor @curwin)))
                        (ร @curwin.w_cursor.lnum++)
                        (del-lines (- (:line_count oap) 1), true)
                        ((ร @curwin.w_cursor.lnum =) lnum)
                    )
                    (if (not (u-save-cursor))
                        ((ร RETURN) false)
                    )
                    (cond @(:b_p_ai @curbuf)                  ;; don't delete indent
                    (do
                        (beginline BL_WHITE)            ;; cursor on first non-white
                        (reset! did_ai true)                  ;; delete the indent when ESC hit
                        (reset! ai_col (:col (:w_cursor @curwin)))
                    )
                    :else
                    (do
                        (beginline 0)                   ;; cursor in column 0
                    ))
                    (truncate-line false)               ;; delete the rest of the line
                                                        ;; leave cursor past last char in line
                    (if (< 1 (:line_count oap))
                        (u-clearline))                  ;; "U" command not possible after "2cc"
                )
                :else
                (do
                    (del-lines (:line_count oap), true)
                    (beginline (| BL_WHITE BL_FIX))
                    (u-clearline)                      ;; "U" command not possible after "dd"
                ))
            )
            :else
            (do
                (when (!= @virtual_op FALSE)
                    ((ร int endcol =) 0)

                    ;; For virtualedit: break the tabs that are partly included.
                    (when (== (gchar-pos (:op_start oap)) TAB)
                        (if (not (u-save-cursor))       ;; save first line for undo
                            ((ร RETURN) false)
                        )
                        (if (== (:line_count oap) 1)
                            ((ร endcol =) (getviscol2 (:col (:op_end oap)), (:coladd (:op_end oap))))
                        )
                        (coladvance-force (getviscol2 (:col (:op_start oap)), (:coladd (:op_start oap))))
                        (COPY-pos (:op_start oap), (:w_cursor @curwin))
                        (when (== (:line_count oap) 1)
                            (coladvance endcol)
                            ((ร oap.op_end.col =) (:col (:w_cursor @curwin)))
                            ((ร oap.op_end.coladd =) (:coladd (:w_cursor @curwin)))
                            (COPY-pos (:w_cursor @curwin), (:op_start oap))
                        )
                    )

                    ;; Break a tab only when it's included in the area.
                    (when (and (== (gchar-pos (:op_end oap)) TAB) (< (:coladd (:op_end oap)) (if (:inclusive oap) 1 0)))
                        ;; save last line for undo
                        (if (not (u-save (- (:lnum (:op_end oap)) 1), (+ (:lnum (:op_end oap)) 1)))
                            ((ร RETURN) false)
                        )
                        (COPY-pos (:w_cursor @curwin), (:op_end oap))
                        (coladvance-force (getviscol2 (:col (:op_end oap)), (:coladd (:op_end oap))))
                        (COPY-pos (:op_end oap), (:w_cursor @curwin))
                        (COPY-pos (:w_cursor @curwin), (:op_start oap))
                    )
                )

                (cond (== (:line_count oap) 1)            ;; delete characters within one line
                (do
                    (if (not (u-save-cursor))           ;; save line for undo
                        ((ร RETURN) false)
                    )

                    ((ร int n =) (- (+ (- (:col (:op_end oap)) (:col (:op_start oap))) 1) (if (not (:inclusive oap)) 1 0)))

                    (when (!= @virtual_op FALSE)
                        ;; fix up things for virtualedit-delete:
                        ;; break the tabs which are going to get in our way

                        ((ร Bytes curline =) (ml-get-curline))
                        ((ร int len =) (STRLEN curline))

                        (when (and (non-zero? (:coladd (:op_end oap))) (<= (dec len) (:col (:op_end oap))) (not (and (non-zero? (:coladd (:op_start oap))) (<= (dec len) (:col (:op_end oap))))))
                            (ร n++)
                        )
                        ;; Delete at least one char (e.g, when on a control char).
                        (if (and (zero? n) (!= (:coladd (:op_start oap)) (:coladd (:op_end oap))))
                            ((ร n =) 1)
                        )

                        ;; When deleted a char in the line, reset coladd.
                        (if (!= (gchar-cursor) NUL)
                            ((ร @curwin.w_cursor.coladd =) 0)
                        )
                    )
                    (cond (and (== (:op_type oap) OP_DELETE) (:inclusive oap) (== (:lnum (:op_end oap)) (:ml_line_count (:b_ml @curbuf))) (< (STRLEN (ml-get (:lnum (:op_end oap)))) n))
                    (do
                        ;; Special case: gH<Del> deletes the last line.
                        (del-lines 1, false)
                    )
                    :else
                    (do
                        (del-bytes n, (== @virtual_op FALSE), (and (== (:op_type oap) OP_DELETE) (not (:is_VIsual oap))))
                    ))
                )
                :else                                    ;; delete characters between lines
                (do
                    ;; save deleted and changed lines for undo
                    (if (not (u-save (- (:lnum (:w_cursor @curwin)) 1), (+ (:lnum (:w_cursor @curwin)) (:line_count oap))))
                        ((ร RETURN) false)
                    )

                    ((ร boolean delete_last_line =) (== (:lnum (:op_end oap)) (:ml_line_count (:b_ml @curbuf))))
                    (truncate-line true)                ;; delete from cursor to end of line

                    ((ร pos_C curpos =) (NEW_pos_C))
                    (COPY-pos curpos, (:w_cursor @curwin))

                    (ร @curwin.w_cursor.lnum++)
                    (del-lines (- (:line_count oap) 2), false)

                    (if delete_last_line
                        ((ร oap.op_end.lnum =) (:ml_line_count (:b_ml @curbuf)))
                    )

                    ((ร int n =) (- (+ (:col (:op_end oap)) 1) (if (not (:inclusive oap)) 1 0)))
                    (cond (and (:inclusive oap) delete_last_line (< (STRLEN (ml-get (:lnum (:op_end oap)))) n))
                    (do
                        ;; Special case: gH<Del> deletes the last line.
                        (del-lines 1, false)
                        (COPY-pos (:w_cursor @curwin), curpos)
                        (if (> (:lnum (:w_cursor @curwin)) (:ml_line_count (:b_ml @curbuf)))
                            ((ร @curwin.w_cursor.lnum =) (:ml_line_count (:b_ml @curbuf)))
                        )
                    )
                    :else
                    (do
                        ;; delete from start of line until op_end
                        ((ร @curwin.w_cursor.col =) 0)
                        (del-bytes n, (== @virtual_op FALSE), (and (== (:op_type oap) OP_DELETE) (not (:is_VIsual oap))))
                        (COPY-pos (:w_cursor @curwin), curpos)
                    ))
                    (if (< (:lnum (:w_cursor @curwin)) (:ml_line_count (:b_ml @curbuf)))
                        (do-join 2, false, false, false, false))
                ))
            ))

            (msgmore (- (:ml_line_count (:b_ml @curbuf)) old_lcount))
;       }

        (cond (:block_mode oap)
        (do
            ((ร @curbuf.b_op_end.lnum =) (:lnum (:op_end oap)))
            ((ร @curbuf.b_op_end.col =) (:col (:op_start oap)))
        )
        :else
        (do
            (COPY-pos (:b_op_end @curbuf), (:op_start oap))
        ))
        (COPY-pos (:b_op_start @curbuf), (:op_start oap))

        true
    ))

;; Adjust end of operating area for ending on a multi-byte character.
;; Used for deletion.

(defn- #_void mb-adjust-opend [#_oparg_C oap]
    (ยง
        (when (:inclusive oap)
            ((ร Bytes p =) (ml-get (:lnum (:op_end oap))))
            ((ร oap.op_end.col =) (+ (:col (:op_end oap)) (us-tail-off p, (.plus p (:col (:op_end oap))))))
        )
        nil
    ))

;; Replace a whole area with one character.

(defn- #_boolean op-replace [#_oparg_C oap, #_int c]
    (ยง
        ((ร Bytes after_p =) nil)
        ((ร boolean had_ctrl_v_cr =) (or (== c -1) (== c -2)))

        (if (or (non-zero? (& (:ml_flags (:b_ml @curbuf)) ML_EMPTY)) (:empty oap))
            ((ร RETURN) true)            ;; nothing to do
        )

        (if had_ctrl_v_cr
            ((ร c =) (if (== c -1) (byte \return) (byte \newline)))
        )

        (mb-adjust-opend oap)

        (if (not (u-save (- (:lnum (:op_start oap)) 1), (+ (:lnum (:op_end oap)) 1)))
            ((ร RETURN) false)
        )

        ;; block mode replace

        (cond (:block_mode oap)
        (do
            ((ร block_def_C bd =) (NEW_block_def_C))

            ((ร bd.is_MAX =) (== (:w_curswant @curwin) MAXCOL))
            ((ร FOR) (ร nil (<= (:lnum (:w_cursor @curwin)) (:lnum (:op_end oap))) (ร @curwin.w_cursor.lnum++))
                ((ร @curwin.w_cursor.col =) 0)    ;; make sure cursor position is valid
                (block-prep oap, bd, (:lnum (:w_cursor @curwin)), true)
                (when (and (zero? (:textlen bd)) (or (== @virtual_op FALSE) (:is_MAX bd)))
                    (ร CONTINUE)               ;; nothing to replace
                )

                ;; n == number of extra chars required
                ;; If we split a TAB, it may be replaced by several characters.
                ;; Thus the number of characters may increase!

                ;; If the range starts in virtual space,
                ;; count the initial coladd offset as part of "startspaces".
                (ร int n)
                (cond (and (!= @virtual_op FALSE) (:is_short bd) (eos? (:textstart bd)))
                (do
                    ((ร pos_C vpos =) (NEW_pos_C))

                    ((ร vpos.lnum =) (:lnum (:w_cursor @curwin)))
                    (getvpos vpos, (:start_vcol oap))
                    ((ร bd.startspaces =) (+ (:startspaces bd) (:coladd vpos)))
                    ((ร n =) (:startspaces bd))
                )
                :else
                (do
                    ;; allow for pre spaces
                    ((ร n =) (if (non-zero? (:startspaces bd)) (- (:start_char_vcols bd) 1) 0))
                ))

                ;; allow for post spp
                ((ร n =) (+ n (if (and (non-zero? (:endspaces bd)) (not (:is_oneChar bd)) (< 0 (:end_char_vcols bd))) (- (:end_char_vcols bd) 1) 0)))
                ;; Figure out how many characters to replace.
                ((ร int numc =) (+ (- (:end_vcol oap) (:start_vcol oap)) 1))
                (if (and (:is_short bd) (or (== @virtual_op FALSE) (:is_MAX bd)))
                    ((ร numc =) (- numc (+ (- (:end_vcol oap) (:end_vcol bd)) 1)))
                )

                ;; A double-wide character can be replaced only up to half the times.
                (when (< 1 (utf-char2cells c))
                    (when (and (non-zero? (& numc 1)) (not (:is_short bd)))
                        (ร bd.endspaces++)
                        (ร n++)
                    )
                    ((ร numc =) (/ numc 2))
                )

                ;; Compute bytes needed, move character count to num_chars.
                ((ร int num_chars =) numc)
                ((ร numc =) (* numc (utf-char2len c)))
                ;; oldlen includes textlen, so don't double count
                ((ร n =) (+ n (- numc (:textlen bd))))

                ((ร Bytes oldp =) (ml-get-curline))
                ((ร int oldlen =) (STRLEN oldp))
                ((ร Bytes newp =) (Bytes. (+ oldlen 1 n)))

                ;; copy up to deleted part
                (BCOPY newp, oldp, (:textcol bd))
                ((ร oldp =) (.plus oldp (+ (:textcol bd) (:textlen bd))))
                ;; insert pre-spaces
                (copy-spaces (.plus newp (:textcol bd)), (:startspaces bd))
                ;; insert replacement chars CHECK FOR ALLOCATED SPACE
                ;; -1/-2 is used for entering CR literally.
                (cond (or had_ctrl_v_cr (and (!= c (byte \return)) (!= c (byte \newline))))
                (do
                    ((ร n =) (STRLEN newp))
                    (while (<= 0 (ร --num_chars))
                        ((ร n =) (+ n (utf-char2bytes c, (.plus newp n))))
                    )

                    (when (not (:is_short bd))
                        ;; insert post-spaces
                        (copy-spaces (.plus newp (STRLEN newp)), (:endspaces bd))
                        ;; copy the part after the changed part
                        (BCOPY newp, (STRLEN newp), oldp, 0, (+ (STRLEN oldp) 1))
                    )
                )
                :else
                (do
                    ;; Replacing with \r or \n means splitting the line.
                    ((ร after_p =) (Bytes. (- (+ oldlen 1 n) (STRLEN newp))))
                    (BCOPY after_p, oldp, (+ (STRLEN oldp) 1))
                ))
                ;; replace the line
                (ml-replace (:lnum (:w_cursor @curwin)), newp)
                (when (non-nil? after_p)
                    (ml-append (ร @curwin.w_cursor.lnum++), after_p)
                    (appended-lines-mark (:lnum (:w_cursor @curwin)), 1)
                    (ร oap.op_end.lnum++)
                )
            )
        )
        :else
        (do
            ;; MCHAR and MLINE motion replace.

            (cond (== (:motion_type oap) MLINE)
            (do
                ((ร oap.op_start.col =) 0)
                ((ร @curwin.w_cursor.col =) 0)
                ((ร oap.op_end.col =) (STRLEN (ml-get (:lnum (:op_end oap)))))
                (if (non-zero? (:col (:op_end oap)))
                    (ร --oap.op_end.col)
                )
            )
            (not (:inclusive oap))
            (do
                (decp (:op_end oap))
            ))

            (while (ltoreq (:w_cursor @curwin), (:op_end oap))
                ((ร int n =) (gchar-cursor))
                (cond (!= n NUL)
                (do
                    (cond (or (< 1 (utf-char2len c)) (< 1 (utf-char2len n)))
                    (do
                        ;; This is slow, but it handles replacing a single-byte
                        ;; with a multi-byte and the other way around.
                        (if (== (:lnum (:w_cursor @curwin)) (:lnum (:op_end oap)))
                            ((ร oap.op_end.col =) (+ (:col (:op_end oap)) (- (utf-char2len c) (utf-char2len n))))
                        )
                        ((ร n =) @State)
                        (reset! State REPLACE)
                        (ins-char c)
                        (reset! State n)
                        ;; Backup to the replaced character.
                        (dec-cursor)
                    )
                    :else
                    (do
                        (when (== n TAB)
                            ((ร int end_vcol =) 0)

                            (when (== (:lnum (:w_cursor @curwin)) (:lnum (:op_end oap)))
                                ;; oap.op_end has to be recalculated when the tab breaks
                                ((ร end_vcol =) (getviscol2 (:col (:op_end oap)), (:coladd (:op_end oap))))
                            )
                            (coladvance-force (getviscol))
                            (if (== (:lnum (:w_cursor @curwin)) (:lnum (:op_end oap)))
                                (getvpos (:op_end oap), end_vcol))
                        )
                        (.be (ml-get-buf @curbuf, (:lnum (:w_cursor @curwin))) (:col (:w_cursor @curwin)), c)
                    ))
                )
                (and (!= @virtual_op FALSE) (== (:lnum (:w_cursor @curwin)) (:lnum (:op_end oap))))
                (do
                    ((ร int virtcols =) (:coladd (:op_end oap)))

                    (when (and (== (:lnum (:w_cursor @curwin)) (:lnum (:op_start oap))) (== (:col (:op_start oap)) (:col (:op_end oap))) (non-zero? (:coladd (:op_start oap))))
                        ((ร virtcols =) (- virtcols (:coladd (:op_start oap))))
                    )

                    ;; 'oap.op_end' has been trimmed, so it's effectively inclusive;
                    ;; as a result, an extra +1 must be counted, so we don't trample the NUL byte.
                    (coladvance-force (+ (getviscol2 (:col (:op_end oap)), (:coladd (:op_end oap))) 1))
                    ((ร @curwin.w_cursor.col =) (- (:col (:w_cursor @curwin)) (inc virtcols)))
                    ((ร FOR) (ร nil (<= 0 virtcols) (ร virtcols--))
                        (.be (ml-get-buf @curbuf, (:lnum (:w_cursor @curwin))) (:col (:w_cursor @curwin)), c)
                        (if (== (incp (:w_cursor @curwin)) -1)
                            (ร BREAK)
                        )
                    )
                ))

                ;; Advance to next character, stop at the end of the file.
                (if (== (inc-cursor) -1)
                    (ร BREAK)
                )
            )
        ))

        (COPY-pos (:w_cursor @curwin), (:op_start oap))
        (check-cursor)
        (changed-lines (:lnum (:op_start oap)), (:col (:op_start oap)), (+ (:lnum (:op_end oap)) 1), 0)

        ;; Set "'[" and "']" marks.
        (COPY-pos (:b_op_start @curbuf), (:op_start oap))
        (COPY-pos (:b_op_end @curbuf), (:op_end oap))

        true
    ))

;; Handle the (non-standard vi) tilde operator.  Also for "gu", "gU" and "g?".

(defn- #_void op-tilde [#_oparg_C oap]
    (ยง
        ((ร boolean did_change =) false)

        (if (not (u-save (- (:lnum (:op_start oap)) 1), (+ (:lnum (:op_end oap)) 1)))
            ((ร RETURN) nil)
        )

        ((ร pos_C pos =) (NEW_pos_C))
        (COPY-pos pos, (:op_start oap))

        (cond (:block_mode oap)                     ;; Visual block mode
        (do
            ((ร FOR) (ร nil (<= (:lnum pos) (:lnum (:op_end oap))) (ร pos.lnum++))
                ((ร block_def_C bd =) (NEW_block_def_C))
                (block-prep oap, bd, (:lnum pos), false)
                ((ร pos.col =) (:textcol bd))
                ((ร boolean one_change =) (swapchars (:op_type oap), pos, (:textlen bd)))
                ((ร did_change =) (| did_change one_change))
            )
            (if did_change
                (changed-lines (:lnum (:op_start oap)), 0, (+ (:lnum (:op_end oap)) 1), 0))
        )
        :else                                    ;; not block mode
        (do
            (cond (== (:motion_type oap) MLINE)
            (do
                ((ร oap.op_start.col =) 0)
                ((ร pos.col =) 0)
                ((ร oap.op_end.col =) (STRLEN (ml-get (:lnum (:op_end oap)))))
                (if (non-zero? (:col (:op_end oap)))
                    (ร --oap.op_end.col)
                )
            )
            (not (:inclusive oap))
            (do
                (decp (:op_end oap))
            ))

            (cond (== (:lnum pos) (:lnum (:op_end oap)))
            (do
                ((ร did_change =) (swapchars (:op_type oap), pos, (+ (- (:col (:op_end oap)) (:col pos)) 1)))
            )
            :else
            (do
                (while true
                    ((ร did_change =) (| did_change (swapchars (:op_type oap), pos, (if (== (:lnum pos) (:lnum (:op_end oap))) (+ (:col (:op_end oap)) 1) (STRLEN (ml-get-pos pos))))))
                    (if (or (ltoreq (:op_end oap), pos) (== (incp pos) -1))
                        (ร BREAK)
                    )
                )
            ))

            (when did_change
                (changed-lines (:lnum (:op_start oap)), (:col (:op_start oap)), (+ (:lnum (:op_end oap)) 1), 0)
            )
        ))

        (when (and (not did_change) (:is_VIsual oap))
            ;; No change: need to remove the Visual selection.
            (redraw-curbuf-later INVERTED)
        )

        ;; Set '[ and '] marks.

        (COPY-pos (:b_op_start @curbuf), (:op_start oap))
        (COPY-pos (:b_op_end @curbuf), (:op_end oap))

        (when (< @p_report (:line_count oap))
            (if (== (:line_count oap) 1)
                (msg (u8 "1 line changed"))
                (smsg (u8 "%ld lines changed"), (:line_count oap)))
        )
        nil
    ))

;; Invoke swapchar() on "length" bytes at position "pos".
;; "pos" is advanced to just after the changed characters.
;; "length" is rounded up to include the whole last multi-byte character.
;; Also works correctly when the number of bytes changes.
;; Returns true if some character was changed.

(defn- #_boolean swapchars [#_int op_type, #_pos_C pos, #_int length]
    (ยง
        ((ร boolean did_change =) false)

        ((ร FOR) (ร ((ร int todo =) length) (< 0 todo) (ร --todo))
            ((ร int len =) (us-ptr2len-cc (ml-get-pos pos)))

            ;; we're counting bytes, not characters
            (if (< 0 len)
                ((ร todo =) (- todo (dec len)))
            )

            ((ร did_change =) (| did_change (swapchar op_type, pos)))
            (if (== (incp pos) -1)     ;; at end of file
                (ร BREAK)
            )
        )

        did_change
    ))

;; If op_type == OP_UPPER: make uppercase,
;; if op_type == OP_LOWER: make lowercase,
;; if op_type == OP_ROT13: do rot13 encoding,
;; else swap case of character at 'pos'
;; returns true when something actually changed.

(defn- #_boolean swapchar [#_int op_type, #_pos_C pos]
    (ยง
        ((ร int c =) (gchar-pos pos))

        ;; Only do rot13 encoding for ASCII characters.
        (if (and (<= 0x80 c) (== op_type OP_ROT13))
            ((ร RETURN) false)
        )

        (when (and (== op_type OP_UPPER) (== c 0xdf))
            ((ร pos_C sp =) (NEW_pos_C))
            (COPY-pos sp, (:w_cursor @curwin))

            ;; Special handling of German sharp s: change to "SS".
            (COPY-pos (:w_cursor @curwin), pos)
            (del-char false)
            (ins-char (byte \S))
            (ins-char (byte \S))
            (COPY-pos (:w_cursor @curwin), sp)
            (incp pos)
        )

        ((ร int nc =) c)
        (cond (utf-islower c)
        (do
            (cond (== op_type OP_ROT13)
            (do
                ((ร nc =) (rot13 c, (byte \a)))
            )
            (!= op_type OP_LOWER)
            (do
                ((ร nc =) (utf-toupper c))
            ))
        )
        (utf-isupper c)
        (do
            (cond (== op_type OP_ROT13)
            (do
                ((ร nc =) (rot13 c, (byte \A)))
            )
            (!= op_type OP_UPPER)
            (do
                ((ร nc =) (utf-tolower c))
            ))
        ))
        (when (!= nc c)
            (cond (or (<= 0x80 c) (<= 0x80 nc))
            (do
                ((ร pos_C sp =) (NEW_pos_C))
                (COPY-pos sp, (:w_cursor @curwin))

                (COPY-pos (:w_cursor @curwin), pos)
                ;; don't use del-char(), it also removes composing chars
                (del-bytes (us-ptr2len (ml-get-cursor)), false, false)
                (ins-char nc)
                (COPY-pos (:w_cursor @curwin), sp)
            )
            :else
            (do
                (.be (ml-get-buf @curbuf, (:lnum pos)) (:col pos), nc)
            ))
            ((ร RETURN) true)
        )
        false
    ))

;; op-insert - Insert and append operators for Visual mode.

(defn- #_void op-insert [#_oparg_C oap, #_long count1]
    (ยง
        ((ร int pre_textlen =) 0)

        ;; edit() changes this - record it for OP_APPEND
        ((ร block_def_C bd =) (NEW_block_def_C))
        ((ร bd.is_MAX =) (== (:w_curswant @curwin) MAXCOL))

        ;; vis block is still marked.  Get rid of it now.
        ((ร @curwin.w_cursor.lnum =) (:lnum (:op_start oap)))
        (update-screen INVERTED)

        (when (:block_mode oap)
            ;; When 'virtualedit' is used, need to insert the extra spaces before doing block-prep().
            ;; When only "block" is used, virtual edit is already disabled,
            ;; but still need it when calling coladvance-force().
            (when (< 0 (:coladd (:w_cursor @curwin)))
                ((ร int old_ve_flags =) @ve_flags)

                (reset! ve_flags VE_ALL)
                (if (not (u-save-cursor))
                    ((ร RETURN) nil)
                )

                (coladvance-force (if (== (:op_type oap) OP_APPEND) (+ (:end_vcol oap) 1) (getviscol)))
                (if (== (:op_type oap) OP_APPEND)
                    (ร --@curwin.w_cursor.col)
                )
                (reset! ve_flags old_ve_flags)
            )
            ;; Get the info about the block before entering the text.
            (block-prep oap, bd, (:lnum (:op_start oap)), true)
            ((ร Bytes firstline =) (.plus (ml-get (:lnum (:op_start oap))) (:textcol bd)))
            (if (== (:op_type oap) OP_APPEND)
                ((ร firstline =) (.plus firstline (:textlen bd)))
            )
            ((ร pre_textlen =) (STRLEN firstline))
        )

        (when (== (:op_type oap) OP_APPEND)
            (cond (and (:block_mode oap) (zero? (:coladd (:w_cursor @curwin))))
            (do
                ;; Move the cursor to the character right of the block.
                ((ร @curwin.w_set_curswant =) true)
                (while (and (non-eos? (ml-get-cursor)) (< (:col (:w_cursor @curwin)) (+ (:textcol bd) (:textlen bd))))
                    (ร @curwin.w_cursor.col++)
                )
                (when (and (:is_short bd) (not (:is_MAX bd)))
                    ;; First line was too short, make it longer and adjust the values in "bd".
                    (if (not (u-save-cursor))
                        ((ร RETURN) nil)
                    )

                    (dotimes [_ (:endspaces bd)]
                        (ins-char (byte \space))
                    )
                    ((ร bd.textlen =) (+ (:textlen bd) (:endspaces bd)))
                )
            )
            :else
            (do
                (COPY-pos (:w_cursor @curwin), (:op_end oap))
                (check-cursor-col)

                ;; Works just like an 'i'nsert on the next character.
                (if (and (not (lineempty (:lnum (:w_cursor @curwin)))) (!= (:start_vcol oap) (:end_vcol oap)))
                    (inc-cursor))
            ))
        )

        ((ร pos_C t1 =) (NEW_pos_C))
        (COPY-pos t1, (:op_start oap))

        (edit NUL, false, count1)

        ;; When a tab was inserted, and the characters in front of the tab
        ;; have been converted to a tab as well, the column of the cursor
        ;; might have actually been reduced, so need to adjust here.
        (if (and (== (:lnum t1) (:lnum (:b_op_start_orig @curbuf))) (ltpos (:b_op_start_orig @curbuf), t1))
            (COPY-pos (:op_start oap), (:b_op_start_orig @curbuf)))

        ;; If user has moved off this line, we don't know what to do, so do nothing.
        ;; Also don't repeat the insert when Insert mode ended with CTRL-C.
        (if (or (!= (:lnum (:w_cursor @curwin)) (:lnum (:op_start oap))) @got_int)
            ((ร RETURN) nil)
        )

        (when (:block_mode oap)
            ((ร block_def_C bd2 =) (NEW_block_def_C))

            ;; The user may have moved the cursor before inserting something,
            ;; try to adjust the block for that.
            (when (and (== (:lnum (:op_start oap)) (:lnum (:b_op_start_orig @curbuf))) (not (:is_MAX bd)))
                (cond (and (== (:op_type oap) OP_INSERT) (!= (+ (:col (:op_start oap)) (:coladd (:op_start oap))) (+ (:col (:b_op_start_orig @curbuf)) (:coladd (:b_op_start_orig @curbuf)))))
                (do
                    ((ร int t =) (getviscol2 (:col (:b_op_start_orig @curbuf)), (:coladd (:b_op_start_orig @curbuf))))
                    ((ร oap.op_start.col =) (:col (:b_op_start_orig @curbuf)))
                    ((ร pre_textlen =) (- pre_textlen (- t (:start_vcol oap))))
                    ((ร oap.start_vcol =) t)
                )
                (and (== (:op_type oap) OP_APPEND) (<= (+ (:col (:b_op_start_orig @curbuf)) (:coladd (:b_op_start_orig @curbuf))) (+ (:col (:op_end oap)) (:coladd (:op_end oap)))))
                (do
                    ((ร int t =) (getviscol2 (:col (:b_op_start_orig @curbuf)), (:coladd (:b_op_start_orig @curbuf))))
                    ((ร oap.op_start.col =) (:col (:b_op_start_orig @curbuf)))
                    ;; reset pre_textlen to the value of OP_INSERT
                    ((ร pre_textlen =) (+ pre_textlen (:textlen bd)))
                    ((ร pre_textlen =) (- pre_textlen (- t (:start_vcol oap))))
                    ((ร oap.start_vcol =) t)
                    ((ร oap.op_type =) OP_INSERT)
                ))
            )

            ;; Spaces and tabs in the indent may have changed to other spaces and tabs.
            ;; Get the starting column again and correct the length.
            ;; Don't do this when "$" used, end-of-line will have changed.

            (block-prep oap, bd2, (:lnum (:op_start oap)), true)
            (when (or (not (:is_MAX bd)) (< (:textlen bd2) (:textlen bd)))
                (when (== (:op_type oap) OP_APPEND)
                    ((ร pre_textlen =) (+ pre_textlen (- (:textlen bd2) (:textlen bd))))
                    (if (non-zero? (:endspaces bd2))
                        (ร --bd2.textlen)
                    )
                )
                ((ร bd.textcol =) (:textcol bd2))
                ((ร bd.textlen =) (:textlen bd2))
            )

            ;; Subsequent calls to ml-get() flush the firstline data
            ;; - take a copy of the required string.

            ((ร Bytes firstline =) (.plus (ml-get (:lnum (:op_start oap))) (:textcol bd)))
            (if (== (:op_type oap) OP_APPEND)
                ((ร firstline =) (.plus firstline (:textlen bd)))
            )

            (ร int ins_len)
            (when (and (<= 0 pre_textlen) (< 0 ((ร ins_len =) (- (STRLEN firstline) pre_textlen))))
                ((ร Bytes ins_text =) (STRNDUP firstline, ins_len))

                ;; block handled here
                (if (u-save (:lnum (:op_start oap)), (+ (:lnum (:op_end oap)) 1))
                    (block-insert oap, ins_text, (== (:op_type oap) OP_INSERT), bd))

                ((ร @curwin.w_cursor.col =) (:col (:op_start oap)))
                (check-cursor)
            )
        )
        nil
    ))

;; op-change - handle a change operation
;;
;; return true if edit() returns because of a CTRL-O command

(defn- #_boolean op-change [#_oparg_C oap]
    (ยง
        ((ร int pre_textlen =) 0)
        ((ร int pre_indent =) 0)

        ((ร int l =) (:col (:op_start oap)))
        (when (== (:motion_type oap) MLINE)
            ((ร l =) 0)
            (if (and (not @p_paste) @(:b_p_si @curbuf))
                (reset! can_si true))      ;; It's like opening a new line, do si
        )

        ;; First delete the text in the region.  In an empty buffer only need to save for undo.
        (cond (non-zero? (& (:ml_flags (:b_ml @curbuf)) ML_EMPTY))
        (do
            (if (not (u-save-cursor))
                ((ร RETURN) false)
            )
        )
        (not (op-delete oap))
        (do
            ((ร RETURN) false)
        ))

        (if (and (< (:col (:w_cursor @curwin)) l) (not (lineempty (:lnum (:w_cursor @curwin)))) (== @virtual_op FALSE))
            (inc-cursor))

        ((ร block_def_C bd =) (NEW_block_def_C))
        ;; check for still on same line (<CR> in inserted text meaningless); skip blank lines too
        (when (:block_mode oap)
            ;; Add spaces before getting the current line length.
            (if (and (!= @virtual_op FALSE) (or (< 0 (:coladd (:w_cursor @curwin))) (== (gchar-cursor) NUL)))
                (coladvance-force (getviscol)))
            ((ร Bytes firstline =) (ml-get (:lnum (:op_start oap))))
            ((ร pre_textlen =) (STRLEN firstline))
            ((ร pre_indent =) (BDIFF (skipwhite firstline), firstline))
            ((ร bd.textcol =) (:col (:w_cursor @curwin)))
        )

        ((ร boolean retval =) (edit NUL, false, 1))

        ;; In Visual block mode, handle copying the new text to all lines of the block.
        ;; Don't repeat the insert when Insert mode ended with CTRL-C.

        (when (and (:block_mode oap) (!= (:lnum (:op_start oap)) (:lnum (:op_end oap))) (not @got_int))
            ;; Auto-indenting may have changed the indent.  If the cursor was past
            ;; the indent, exclude that indent change from the inserted text.
            ((ร Bytes firstline =) (ml-get (:lnum (:op_start oap))))
            (when (< pre_indent (:textcol bd))
                ((ร int new_indent =) (BDIFF (skipwhite firstline), firstline))

                ((ร pre_textlen =) (+ pre_textlen (- new_indent pre_indent)))
                ((ร bd.textcol =) (+ (:textcol bd) (- new_indent pre_indent)))
            )

            ((ร int ins_len =) (- (STRLEN firstline) pre_textlen))
            (when (< 0 ins_len)
                ;; Subsequent calls to ml-get() flush the "firstline" data
                ;; -- take a copy of the inserted text.
                ((ร Bytes ins_text =) (STRNDUP (.plus firstline (:textcol bd)), ins_len))

                ((ร FOR) (ร ((ร long linenr =) (+ (:lnum (:op_start oap)) 1)) (<= linenr (:lnum (:op_end oap))) (ร linenr++))
                    (block-prep oap, bd, linenr, true)
                    (when (or (not (:is_short bd)) (!= @virtual_op FALSE))
                        ((ร pos_C vpos =) (NEW_pos_C))

                        ;; If the block starts in virtual space, count the
                        ;; initial coladd offset as part of "startspaces".
                        (cond (:is_short bd)
                        (do
                            ((ร vpos.lnum =) linenr)
                            (getvpos vpos, (:start_vcol oap))
                        )
                        :else
                        (do
                            ((ร vpos.coladd =) 0)
                        ))
                        ((ร Bytes oldp =) (ml-get linenr))
                        ((ร Bytes newp =) (Bytes. (+ (STRLEN oldp) (:coladd vpos) ins_len 1)))

                        ;; copy up to block start
                        (BCOPY newp, oldp, (:textcol bd))
                        ((ร int offset =) (:textcol bd))
                        (copy-spaces (.plus newp offset), (:coladd vpos))
                        ((ร offset =) (+ offset (:coladd vpos)))
                        (BCOPY newp, offset, ins_text, 0, ins_len)
                        ((ร offset =) (+ offset ins_len))
                        ((ร oldp =) (.plus oldp (:textcol bd)))
                        (BCOPY newp, offset, oldp, 0, (+ (STRLEN oldp) 1))
                        (ml-replace linenr, newp)
                    )
                )
                (check-cursor)

                (changed-lines (+ (:lnum (:op_start oap)) 1), 0, (+ (:lnum (:op_end oap)) 1), 0)
            )
        )

        retval
    ))

;; set all the yank registers to empty (called from main())

(defn- #_void init-yank []
    (ยง
        (dotimes [#_int i NUM_REGISTERS]
            ((ร y_regs[i].y_array =) nil)
        )
        nil
    ))

;; Yank the text between "oap.op_start" and "oap.op_end" into a yank register.
;; If we are to append (uppercase register), we first yank into a new yank
;; register and then concatenate the old and the new one (so we keep the old
;; one in case of out-of-memory).
;;
;; Return false for failure, true otherwise.

(defn- #_boolean op-yank [#_oparg_C oap, #_boolean deleting, #_boolean mess]
    (ยง
        ((ร byte yanktype =) (:motion_type oap))
        ((ร int yanklines =) (int (:line_count oap)))
        ((ร long yankendlnum =) (:lnum (:op_end oap)))

                                                        ;; check for read-only register
        (when (and (non-zero? (:regname oap)) (not (valid-yank-reg (:regname oap), true)))
            (beep-flush)
            ((ร RETURN) false)
        )
        (if (== (:regname oap) (byte \_))                         ;; black hole: nothing to do
            ((ร RETURN) true)
        )

        (cond (== (:regname oap) (byte \*))
        (do
            ((ร oap.regname =) 0)
        )
        (== (:regname oap) (byte \+))
        (do
            ((ร oap.regname =) 0)
        ))

        (if (not deleting)                                  ;; op-delete() already set y_current
            (get-yank-register (:regname oap), true))

        ((ร yankreg_C curr =) @y_current)                     ;; copy of y_current
        ((ร yankreg_C newreg =) (NEW_yankreg_C))             ;; new yank register when appending
        (if (and @y_append (non-nil? (:y_array @y_current)))      ;; append to existing contents
            (reset! y_current newreg)
            ((ร @y_current.y_array =) nil)                   ;; free previously yanked lines
        )

        ;; If the cursor was in column 1 before and after the movement,
        ;; and the operator is not inclusive, the yank is always linewise.

        (when (and (== (:motion_type oap) MCHAR) (zero? (:col (:op_start oap))) (not (:inclusive oap)) (or (not (:is_VIsual oap)) (== (.at @p_sel 0) (byte \o))) (not (:block_mode oap)) (zero? (:col (:op_end oap))) (< 1 yanklines))
            ((ร yanktype =) MLINE)
            (ร --yankendlnum)
            (ร --yanklines)
        )

        ((ร @y_current.y_size =) yanklines)
        ((ร @y_current.y_type =) yanktype)                    ;; set the yank register type
        ((ร @y_current.y_width =) 0)
        ((ร @y_current.y_array =) (ร new Bytes[yanklines]))

        ((ร int y_idx =) 0)                                 ;; index in y_array[]
        ((ร long lnum =) (:lnum (:op_start oap)))                  ;; current line number

        (when (:block_mode oap)
            ;; Visual block mode.
            ((ร @y_current.y_type =) MBLOCK)                  ;; set the yank register type
            ((ร @y_current.y_width =) (- (:end_vcol oap) (:start_vcol oap)))

            (if (and (== (:w_curswant @curwin) MAXCOL) (< 0 (:y_width @y_current)))
                (ร @y_current.y_width--)
            )
        )

        ((ร block_def_C bd =) (NEW_block_def_C))

        ((ร FOR) (ร nil (<= lnum yankendlnum) (ร lnum++, y_idx++))
            ((ร SWITCH) (:y_type @y_current)
                ((ร CASE) MBLOCK)
                (do
                    (block-prep oap, bd, lnum, false)
                    (yank-copy-line bd, y_idx)
                    (ร BREAK)
                )

                ((ร CASE) MLINE)
                (do
                    ((ร @y_current.y_array[y_idx] =) (STRDUP (ml-get lnum)))
                    (ร BREAK)
                )

                ((ร CASE) MCHAR)
                (do
                    ((ร int startcol =) (ร 0, endcol = MAXCOL))
                    ((ร boolean is_oneChar =) false)
                    ((ร Bytes p =) (ml-get lnum))
                    ((ร bd.startspaces =) 0)
                    ((ร bd.endspaces =) 0)

                    (when (== lnum (:lnum (:op_start oap)))
                        ((ร startcol =) (:col (:op_start oap)))
                        (when (!= @virtual_op FALSE)
                            ((ร int[] cs =) (ร new int[1]))
                            ((ร int[] ce =) (ร new int[1]))
                            (getvcol @curwin, (:op_start oap), cs, nil, ce)
                            (when (and (!= (... ce 0) (... cs 0)) (< 0 (:coladd (:op_start oap))))
                                ;; Part of a tab selected -- but don't double-count it.
                                ((ร bd.startspaces =) (- (+ (- (... ce 0) (... cs 0)) 1) (:coladd (:op_start oap))))
                                (ร startcol++)
                            )
                        )
                    )

                    (when (== lnum (:lnum (:op_end oap)))
                        ((ร endcol =) (:col (:op_end oap)))
                        (when (!= @virtual_op FALSE)
                            ((ร int[] cs =) (ร new int[1]))
                            ((ร int[] ce =) (ร new int[1]))
                            (getvcol @curwin, (:op_end oap), cs, nil, ce)
                            ;; Don't add space for double-wide char; endcol will be on last byte of multi-byte char.
                            (when (or (eos? p endcol) (and (< (+ (... cs 0) (:coladd (:op_end oap))) (... ce 0)) (zero? (us-head-off p, (.plus p endcol)))))
                                (cond (and (== (:lnum (:op_start oap)) (:lnum (:op_end oap))) (== (:col (:op_start oap)) (:col (:op_end oap))))
                                (do
                                    ;; Special case: inside a single char.
                                    ((ร is_oneChar =) true)
                                    ((ร bd.startspaces =) (+ (- (:coladd (:op_end oap)) (:coladd (:op_start oap))) (if (:inclusive oap) 1 0)))
                                    ((ร endcol =) startcol)
                                )
                                :else
                                (do
                                    ((ร bd.endspaces =) (+ (:coladd (:op_end oap)) (if (:inclusive oap) 1 0)))
                                    ((ร endcol =) (- endcol (if (:inclusive oap) 1 0)))
                                ))
                            )
                        )
                    )
                    (if (== endcol MAXCOL)
                        ((ร endcol =) (STRLEN p))
                    )
                    ((ร bd.textlen =) (if (or (< endcol startcol) is_oneChar) 0 (+ (- endcol startcol) (if (:inclusive oap) 1 0))))
                    ((ร bd.textstart =) (.plus p startcol))
                    (yank-copy-line bd, y_idx)
                    (ร BREAK)
                )
            )
        )

        (when (!= curr @y_current)      ;; append the new block to the old block
            ((ร Bytes[] new_ptr =) (ร new Bytes[curr.y_size + @y_current.y_size]))

            (ร int j)
            ((ร FOR) (ร ((ร j =) 0) (< j (:y_size curr)) (ร j++))
                ((ร new_ptr[j] =) (... (:y_array curr) j))
            )
            ((ร curr.y_array =) new_ptr)

            (if (== yanktype MLINE)  ;; MLINE overrides MCHAR and MBLOCK
                ((ร curr.y_type =) MLINE)
            )

            ;; Concatenate the last line of the old block with the first line of the new block,
            ;; unless being Vi compatible.
            (cond (and (== (:y_type curr) MCHAR) (nil? (vim-strbyte @p_cpo, CPO_REGAPPEND)))
            (do
                ((ร Bytes p =) (Bytes. (+ (STRLEN (... (:y_array curr) (- (:y_size curr) 1))) (STRLEN (... (:y_array @y_current) 0)) 1)))

                (STRCPY p, (... (:y_array curr) (ร --j)))
                (STRCAT p, (... (:y_array @y_current) 0))
                ((ร @y_current.y_array[0] =) nil)
                ((ร curr.y_array[j++] =) p)
                ((ร y_idx =) 1)
            )
            :else
            (do
                ((ร y_idx =) 0)
            ))
            (while (< y_idx (:y_size @y_current))
                ((ร curr.y_array[j++] =) (... (:y_array @y_current) (ร y_idx++)))
            )
            ((ร curr.y_size =) j)
            ((ร @y_current.y_array =) nil)
            (reset! y_current curr)
        )

        (if @(:wo_rnu (:w_options @curwin))
            (redraw-later SOME_VALID))       ;; cursor moved to start

        (when mess                   ;; Display message about yank?
            (if (and (== yanktype MCHAR) (not (:block_mode oap)) (== yanklines 1))
                ((ร yanklines =) 0)
            )
            ;; Some versions of Vi use ">=" here, some don't...
            (when (< @p_report yanklines)
                ;; redisplay now, so message is not deleted
                (update-topline-redraw)
                (cond (== yanklines 1)
                (do
                    (if (:block_mode oap)
                        (msg (u8 "block of 1 line yanked"))
                        (msg (u8 "1 line yanked")))
                )
                (:block_mode oap)
                (do
                    (smsg (u8 "block of %ld lines yanked"), yanklines)
                )
                :else
                (do
                    (smsg (u8 "%ld lines yanked"), yanklines)
                ))
            )
        )

        ;; Set "'[" and "']" marks.

        (COPY-pos (:b_op_start @curbuf), (:op_start oap))
        (COPY-pos (:b_op_end @curbuf), (:op_end oap))
        (when (and (== yanktype MLINE) (not (:block_mode oap)))
            ((ร @curbuf.b_op_start.col =) 0)
            ((ร @curbuf.b_op_end.col =) MAXCOL)
        )

        true
    ))

(defn- #_void yank-copy-line [#_block_def_C bd, #_int y_idx]
    (ยง
        ((ร Bytes pnew =) (Bytes. (+ (:startspaces bd) (:endspaces bd) (:textlen bd) 1)))

        ((ร @y_current.y_array[y_idx] =) pnew)
        (copy-spaces pnew, (:startspaces bd))
        ((ร pnew =) (.plus pnew (:startspaces bd)))
        (BCOPY pnew, (:textstart bd), (:textlen bd))
        ((ร pnew =) (.plus pnew (:textlen bd)))
        (copy-spaces pnew, (:endspaces bd))
        ((ร pnew =) (.plus pnew (:endspaces bd)))
        (eos! pnew)
        nil
    ))

;; Put contents of register "regname" into the text.
;; Caller must check "regname" to be valid!
;; "flags": PUT_FIXINDENT       make indent look nice
;;          PUT_CURSEND         leave cursor after end of new text
;;          PUT_LINE            force linewise put (":put")

(defn- #_void do-put [#_int regname, #_int dir, #_int count, #_int flags]
    ;; dir: BACKWARD for 'P', FORWARD for 'p'
    (ยง
        ((ร int totlen =) 0)
        ((ร int y_width =) 0)
        ((ร int incr =) 0)
        ((ร long nr_lines =) 0)
        ((ร int orig_indent =) 0)
        ((ร int indent_diff =) 0)
        ((ร boolean first_indent =) true)
        ((ร int lendiff =) 0)

        ;; Adjust register name for "unnamed" in 'clipboard'.
        ((ร regname =) (adjust-clip-reg regname))
        (may-get-selection regname)

        (if (flag? flags PUT_FIXINDENT)
            ((ร orig_indent =) (get-indent))
        )

        (COPY-pos (:b_op_start @curbuf), (:w_cursor @curwin))   ;; default for '[ mark
        (COPY-pos (:b_op_end @curbuf), (:w_cursor @curwin))     ;; default for '] mark

        ;; Using inserted text works differently, because the register includes
        ;; special characters (newlines, etc.).

        (when (== regname (byte \.))
            (stuff-inserted (if (== dir FORWARD) (if (== count -1) (byte \o) (byte \a)) (if (== count -1) (byte \O) (byte \i))), count, false)
            ;; Putting the text is done later, so can't really move the cursor
            ;; to the next character.  Use "l" to simulate it.
            (if (and (flag? flags PUT_CURSEND) (!= (gchar-cursor) NUL))
                (stuffcharReadbuff (byte \l)))
            ((ร RETURN) nil)
        )

        ;; For special registers '%' (file name), '#' (alternate file name) and
        ;; ':' (last command line), etc. we have to create a fake yank register.

; %%    ((ร Bytes[] insert_string =) (ร { null }))
; %%    ((ร boolean[] allocated =) (ร { false }))
        (when (get-spec-reg regname, insert_string, allocated, true)
            (if (nil? (... insert_string 0))
                ((ร RETURN) nil)
            )
        )

        ;; Autocommands may be executed when saving lines for undo,
        ;; which may make "y_array" invalid.  Start undo now to avoid that.
        (u-save (:lnum (:w_cursor @curwin)), (+ (:lnum (:w_cursor @curwin)) 1))

        (ร int y_type)
        (ร int y_size)
        ((ร Bytes[] y_array =) nil)

        (cond (non-nil? (... insert_string 0))
        (do
            ((ร y_type =) MCHAR)
            (cond (== regname (byte \=))
            (do
                ;; For the = register we need to split the string at NL characters.
                ;; Loop twice: count the number of lines and save them.
                (while true
                    ((ร y_size =) 0)
                    ((ร FOR) (ร ((ร Bytes p =) (... insert_string 0)) (non-nil? p) nil)
                        (if (non-nil? y_array)
                            ((ร y_array[y_size] =) p)
                        )
                        (ร y_size++)
                        ((ร p =) (vim-strchr p, (byte \newline)))
                        (when (non-nil? p)
                            (if (non-nil? y_array)
                                (eos! p)
                            )
                            ((ร p =) (.plus p 1))
                            ;; A trailing '\n' makes the register linewise.
                            (when (eos? p)
                                ((ร y_type =) MLINE)
                                (ร BREAK)
                            )
                        )
                    )
                    (if (non-nil? y_array)
                        (ร BREAK)
                    )
                    ((ร y_array =) (ร new Bytes[y_size]))
                )
            )
            :else
            (do
                ((ร y_size =) 1)         ;; use fake one-line yank register
; %%            ((ร y_array =) (ร new Bytes[] { insert_string[0] }))
            ))
        )
        :else
        (do
            (get-yank-register regname, false)

            ((ร y_type =) (:y_type @y_current))
            ((ร y_width =) (:y_width @y_current))
            ((ร y_size =) (:y_size @y_current))
            ((ร y_array =) (:y_array @y_current))
        ))

;       theend:
;       {
            (when (== y_type MLINE)
                (when (flag? flags PUT_LINE_SPLIT)
                    ;; "p" or "P" in Visual mode: split the lines to put the text in between.
                    (if (not (u-save-cursor))
                        (ร BREAK theend)
                    )

                    ((ร Bytes p =) (STRDUP (ml-get-cursor)))
                    (ml-append (:lnum (:w_cursor @curwin)), p)
                    ((ร p =) (STRNDUP (ml-get-curline), (:col (:w_cursor @curwin))))
                    (ml-replace (:lnum (:w_cursor @curwin)), p)
                    (ร nr_lines++)
                    ((ร dir =) FORWARD)
                )
                (when (flag? flags PUT_LINE_FORWARD)
                    ;; Must be "p" for a Visual block, put lines below the block.
                    (COPY-pos (:w_cursor @curwin), (:vi_end (:b_visual @curbuf)))
                    ((ร dir =) FORWARD)
                )
                (COPY-pos (:b_op_start @curbuf), (:w_cursor @curwin))   ;; default for '[ mark
                (COPY-pos (:b_op_end @curbuf), (:w_cursor @curwin))     ;; default for '] mark
            )

            (if (flag? flags PUT_LINE)        ;; :put command or "p" in Visual line mode.
                ((ร y_type =) MLINE)
            )

            (when (or (zero? y_size) (nil? y_array))
                (emsg2 (u8 "E353: Nothing in register %s"), (if (zero? regname) (u8 "\"") (transchar regname)))
                (ร BREAK theend)
            )

            (ร long lnum)
            (cond (== y_type MBLOCK)
            (do
                ((ร lnum =) (+ (:lnum (:w_cursor @curwin)) y_size 1))
                (if (> lnum (:ml_line_count (:b_ml @curbuf)))
                    ((ร lnum =) (+ (:ml_line_count (:b_ml @curbuf)) 1))
                )
                (if (not (u-save (- (:lnum (:w_cursor @curwin)) 1), lnum))
                    (ร BREAK theend)
                )
            )
            (== y_type MLINE)
            (do
                ((ร lnum =) (:lnum (:w_cursor @curwin)))
                (if (== dir FORWARD)
                    (ร lnum++)
                )
                ;; In an empty buffer the empty line is going to be replaced,
                ;; include it in the saved lines.
                (if (not (if (bufempty) (u-save 0, 2) (u-save (dec lnum), lnum)))
                    (ร BREAK theend)
                )
            )
            (not (u-save-cursor))
            (do
                (ร BREAK theend)
            ))

            ((ร int yanklen =) (STRLEN (... y_array 0)))

            (when (and (== @ve_flags VE_ALL) (== y_type MCHAR))
                (cond (== (gchar-cursor) TAB)
                (do
                    ;; Don't need to insert spaces when "p" on the last position
                    ;; of a tab or "P" on the first position.
                    (cond (if (== dir FORWARD) (< (:coladd (:w_cursor @curwin)) (- @(:b_p_ts @curbuf) 1)) (< 0 (:coladd (:w_cursor @curwin))))
                    (do
                        (coladvance-force (getviscol))
                    )
                    :else
                    (do
                        ((ร @curwin.w_cursor.coladd =) 0)
                    ))
                )
                (or (< 0 (:coladd (:w_cursor @curwin))) (== (gchar-cursor) NUL))
                (do
                    (coladvance-force (+ (getviscol) (if (== dir FORWARD) 1 0)))
                ))
            )

            ((ร lnum =) (:lnum (:w_cursor @curwin)))
; %%        ((ร int[] col =) (ร { (@curwin.w_cursor.col) }))

            ;; Block mode

            (cond (== y_type MBLOCK)
            (do
                ((ร block_def_C bd =) (NEW_block_def_C))
                ((ร int c =) (gchar-cursor))
; %%            ((ร int[] endcol2 =) (ร { 0 }))

                (cond (and (== dir FORWARD) (!= c NUL))
                (do
                    (if (== @ve_flags VE_ALL)
                        (getvcol @curwin, (:w_cursor @curwin), col, nil, endcol2)
                        (getvcol @curwin, (:w_cursor @curwin), nil, nil, col))

                    ;; move to start of next multi-byte character
                    ((ร @curwin.w_cursor.col =) (+ (:col (:w_cursor @curwin)) (us-ptr2len-cc (ml-get-cursor))))

                    (ร col[0]++)
                )
                :else
                (do
                    (getvcol @curwin, (:w_cursor @curwin), col, nil, endcol2)
                ))

                ((ร col[0] =) (+ (... col 0) (:coladd (:w_cursor @curwin))))
                (when (and (== @ve_flags VE_ALL) (or (< 0 (:coladd (:w_cursor @curwin))) (== (... endcol2 0) (:col (:w_cursor @curwin)))))
                    (if (and (== dir FORWARD) (== c NUL))
                        (ร col[0]++)
                    )
                    (if (and (!= dir FORWARD) (!= c NUL))
                        (ร @curwin.w_cursor.col++)
                    )
                    (when (== c TAB)
                        (if (and (== dir BACKWARD) (< 0 (:col (:w_cursor @curwin))))
                            (ร @curwin.w_cursor.col--)
                        )
                        (if (and (== dir FORWARD) (== (- (... col 0) 1) (... endcol2 0)))
                            (ร @curwin.w_cursor.col++)
                        )
                    )
                )
                ((ร @curwin.w_cursor.coladd =) 0)
                ((ร bd.textcol =) 0)
                (dotimes [#_int i y_size]
                    ((ร bd.startspaces =) 0)
                    ((ร bd.endspaces =) 0)
                    ((ร int vcol =) 0)
                    ((ร int delcount =) 0)

                    ;; add a new line
                    (when (< (:ml_line_count (:b_ml @curbuf)) (:lnum (:w_cursor @curwin)))
                        (if (not (ml-append (:ml_line_count (:b_ml @curbuf)), (u8 "")))
                            (ร BREAK)
                        )
                        (ร nr_lines++)
                    )
                    ;; get the old line and advance to the position to insert at
                    ((ร Bytes oldp =) (ml-get-curline))
                    ((ร int oldlen =) (STRLEN oldp))
                    ((ร Bytes[] pp =) (ร new Bytes[1]))
                    ((ร FOR) (ร ((ร pp[0] =) oldp) (and (< vcol (... col 0)) (non-eos? (... pp 0))) nil)
                        ;; Count a tab for what it's worth (if list mode not on).
                        ((ร incr =) (lbr-chartabsize-adv oldp, pp, vcol))
                        ((ร vcol =) (+ vcol incr))
                    )
                    ((ร bd.textcol =) (BDIFF (... pp 0), oldp))

                    ((ร boolean shortline =) (or (< vcol (... col 0)) (and (== vcol (... col 0)) (eos? (... pp 0)))))

                    (cond (< vcol (... col 0)) ;; line too short, padd with spaces
                    (do
                        ((ร bd.startspaces =) (- (... col 0) vcol))
                    )
                    (< (... col 0) vcol)
                    (do
                        ((ร bd.endspaces =) (- vcol (... col 0)))
                        ((ร bd.startspaces =) (- incr (:endspaces bd)))
                        (ร --bd.textcol)
                        ((ร delcount =) 1)
                        ((ร bd.textcol =) (- (:textcol bd) (us-head-off oldp, (.plus oldp (:textcol bd)))))
                        (when (!= (.at oldp (:textcol bd)) TAB)
                            ;; Only a Tab can be split into spaces.
                            ;; Other characters will have to be moved to after the block,
                            ;; causing misalignment.
                            ((ร delcount =) 0)
                            ((ร bd.endspaces =) 0)
                        )
                    ))

                    ((ร yanklen =) (STRLEN (... y_array i)))

                    ;; calculate number of spaces required to fill right side of block
                    ((ร int spaces =) (inc y_width))
                    (dotimes [#_int j yanklen]
                        ((ร spaces =) (- spaces (lbr-chartabsize nil, (.plus (... y_array i) j), 0)))
                    )
                    (if (< spaces 0)
                        ((ร spaces =) 0)
                    )

                    ;; insert the new text
                    ((ร totlen =) (+ (* count (+ yanklen spaces)) (:startspaces bd) (:endspaces bd)))
                    ((ร Bytes newp =) (Bytes. (+ totlen oldlen 1)))

                    ;; copy part up to cursor to new line
                    ((ร Bytes p =) newp)
                    (BCOPY p, oldp, (:textcol bd))
                    ((ร p =) (.plus p (:textcol bd)))
                    ;; may insert some spaces before the new text
                    (copy-spaces p, (:startspaces bd))
                    ((ร p =) (.plus p (:startspaces bd)))
                    ;; insert the new text
                    (dotimes [#_int j count]
                        (BCOPY p, (... y_array i), yanklen)
                        ((ร p =) (.plus p yanklen))

                        ;; insert block's trailing spaces only if there's text behind
                        (when (and (or (< j (dec count)) (not shortline)) (non-zero? spaces))
                            (copy-spaces p, spaces)
                            ((ร p =) (.plus p spaces))
                        )
                    )
                    ;; may insert some spaces after the new text
                    (copy-spaces p, (:endspaces bd))
                    ((ร p =) (.plus p (:endspaces bd)))
                    ;; move the text after the cursor to the end of the line.
                    (BCOPY p, 0, oldp, (+ (:textcol bd) delcount), (+ (- oldlen (:textcol bd) delcount) 1))
                    (ml-replace (:lnum (:w_cursor @curwin)), newp)

                    (ร @curwin.w_cursor.lnum++)
                    (if (zero? i)
                        ((ร @curwin.w_cursor.col =) (+ (:col (:w_cursor @curwin)) (:startspaces bd)))
                    )
                )

                (changed-lines lnum, 0, (:lnum (:w_cursor @curwin)), nr_lines)

                ;; Set '[ mark.
                (COPY-pos (:b_op_start @curbuf), (:w_cursor @curwin))
                ((ร @curbuf.b_op_start.lnum =) lnum)

                ;; Adjust '] mark.
                ((ร @curbuf.b_op_end.lnum =) (- (:lnum (:w_cursor @curwin)) 1))
                ((ร @curbuf.b_op_end.col =) (- (+ (:textcol bd) totlen) 1))
                ((ร @curbuf.b_op_end.coladd =) 0)
                (cond (flag? flags PUT_CURSEND)
                (do
                    (COPY-pos (:w_cursor @curwin), (:b_op_end @curbuf))
                    (ร @curwin.w_cursor.col++)

                    ;; in Insert mode we might be after the NUL, correct for that
                    ((ร int len =) (STRLEN (ml-get-curline)))
                    (if (> (:col (:w_cursor @curwin)) len)
                        ((ร @curwin.w_cursor.col =) len)
                    )
                )
                :else
                (do
                    ((ร @curwin.w_cursor.lnum =) lnum)
                ))
            )
            :else
            (do
                ;; Character or Line mode

                (cond (== y_type MCHAR)
                (do
                    ;; if type is MCHAR, FORWARD is the same as BACKWARD on the next char
                    (when (and (== dir FORWARD) (!= (gchar-cursor) NUL))
                        ((ร int bytelen =) (us-ptr2len-cc (ml-get-cursor)))

                        ;; put it on the next of the multi-byte character.
                        ((ร col[0] =) (+ (... col 0) bytelen))
                        (when (non-zero? yanklen)
                            ((ร @curwin.w_cursor.col =) (+ (:col (:w_cursor @curwin)) bytelen))
                            ((ร @curbuf.b_op_end.col =) (+ (:col (:b_op_end @curbuf)) bytelen))
                        )
                    )
                    (COPY-pos (:b_op_start @curbuf), (:w_cursor @curwin))
                )

                ;; Line mode: BACKWARD is the same as FORWARD on the previous line

                (== dir BACKWARD)
                (do
                    (ร --lnum)
                ))

                ((ร pos_C new_cursor =) (NEW_pos_C))
                (COPY-pos new_cursor, (:w_cursor @curwin))

                ;; simple case: insert into current line

                (cond (and (== y_type MCHAR) (== y_size 1))
                (do
;                   do
;                   {
                        ((ร totlen =) (* count yanklen))
                        (when (< 0 totlen)
                            ((ร Bytes oldp =) (ml-get lnum))
                            ((ร Bytes newp =) (Bytes. (+ (STRLEN oldp) totlen 1)))

                            (BCOPY newp, oldp, (... col 0))
                            ((ร Bytes p =) (.plus newp (... col 0)))
                            (dotimes [_ count]
                                (BCOPY p, (... y_array 0), yanklen)
                                ((ร p =) (.plus p yanklen))
                            )
                            (BCOPY p, 0, oldp, (... col 0), (+ (STRLEN oldp, (... col 0)) 1))
                            (ml-replace lnum, newp)
                            ;; Place cursor on last putted char.
                            (when (== lnum (:lnum (:w_cursor @curwin)))
                                ;; make sure curwin.w_virtcol is updated
                                (changed-cline-bef-curs)
                                ((ร @curwin.w_cursor.col =) (+ (:col (:w_cursor @curwin)) (dec totlen)))
                            )
                        )
                        (if @VIsual_active
                            (ร lnum++)
                        )
;                   } while (@VIsual_active && lnum <= @curbuf.b_visual.vi_end.lnum);

                    (if @VIsual_active ;; reset lnum to the last visual line
                        (ร lnum--)
                    )

                    (COPY-pos (:b_op_end @curbuf), (:w_cursor @curwin))
                    ;; For "CTRL-O p" in Insert mode, put cursor after last char.
                    (if (and (non-zero? totlen) (or (non-zero? @restart_edit) (flag? flags PUT_CURSEND)))
                        (ร @curwin.w_cursor.col++)
                    )
                    (changed-bytes lnum, (... col 0))
                )
                :else
                (do
                    ;; Insert at least one line.  When y_type is MCHAR, break the first line in two.

;                   error:
                    ((ร FOR) (ร ((ร long cnt =) 1) (<= cnt count) (ร cnt++))
                        ((ร int i =) 0)
                        (when (== y_type MCHAR)
                            ;; Split the current line in two at the insert position.
                            ;; First insert y_array[size - 1] in front of second line.
                            ;; Then append y_array[0] to first line.

                            ((ร lnum =) (:lnum new_cursor))
                            ((ร Bytes p =) (.plus (ml-get lnum) (... col 0)))
                            ((ร totlen =) (STRLEN (... y_array (dec y_size))))
                            ((ร Bytes newp =) (Bytes. (+ (STRLEN p) totlen 1)))
                            (STRCPY newp, (... y_array (dec y_size)))
                            (STRCAT newp, p)
                            ;; insert second line
                            (ml-append lnum, newp)

                            ((ร Bytes oldp =) (ml-get lnum))
                            ((ร newp =) (Bytes. (+ (... col 0) yanklen 1)))
                            ;; copy first part of line
                            (BCOPY newp, oldp, (... col 0))
                            ;; append to first line
                            (BCOPY newp, (... col 0), (... y_array 0), 0, (inc yanklen))
                            (ml-replace lnum, newp)

                            ((ร @curwin.w_cursor.lnum =) lnum)
                            ((ร i =) 1)
                        )

                        ((ร FOR) (ร nil (< i y_size) (ร i++))
                            (if (and (or (!= y_type MCHAR) (< i (dec y_size))) (not (ml-append lnum, (... y_array i))))
                                (ร BREAK error)
                            )
                            (ร lnum++)
                            (ร nr_lines++)
                            (when (flag? flags PUT_FIXINDENT)
                                ((ร pos_C old_pos =) (NEW_pos_C))
                                (COPY-pos old_pos, (:w_cursor @curwin))
                                ((ร @curwin.w_cursor.lnum =) lnum)
                                ((ร Bytes p =) (ml-get lnum))
                                (if (and (== cnt count) (== i (dec y_size)))
                                    ((ร lendiff =) (STRLEN p))
                                )
                                (ร int indent)
                                (cond (eos? p)
                                (do
                                    ((ร indent =) 0)     ;; ignore empty lines
                                )
                                first_indent
                                (do
                                    ((ร indent_diff =) (- orig_indent (get-indent)))
                                    ((ร indent =) orig_indent)
                                    ((ร first_indent =) false)
                                )
                                (< ((ร indent =) (+ (get-indent) indent_diff)) 0)
                                (do
                                    ((ร indent =) 0)
                                ))
                                (set-indent indent, 0)
                                (COPY-pos (:w_cursor @curwin), old_pos)
                                ;; remember how many chars were removed
                                (if (and (== cnt count) (== i (dec y_size)))
                                    ((ร lendiff =) (- lendiff (STRLEN (ml-get lnum))))
                                )
                            )
                        )
                    )

                    ;; Adjust marks.
                    (when (== y_type MLINE)
                        ((ร @curbuf.b_op_start.col =) 0)
                        (if (== dir FORWARD)
                            (ร @curbuf.b_op_start.lnum++)
                        )
                    )
                    (mark-adjust (+ (:lnum (:b_op_start @curbuf)) (if (== y_type MCHAR) 1 0)), MAXLNUM, nr_lines, 0)

                    ;; note changed text for displaying and folding
                    (if (== y_type MCHAR)
                        (changed-lines (:lnum (:w_cursor @curwin)), (... col 0), (+ (:lnum (:w_cursor @curwin)) 1), nr_lines)
                        (changed-lines (:lnum (:b_op_start @curbuf)), 0, (:lnum (:b_op_start @curbuf)), nr_lines))

                    ;; put '] mark at last inserted character
                    ((ร @curbuf.b_op_end.lnum =) lnum)
                    ;; correct length for change in indent
                    ((ร col[0] =) (- (STRLEN (... y_array (dec y_size))) lendiff))
                    ((ร @curbuf.b_op_end.col =) (if (< 1 (... col 0)) (dec (... col 0)) 0))

                    (cond (flag? flags PUT_CURSLINE)
                    (do
                        ;; ":put": put cursor on last inserted line
                        ((ร @curwin.w_cursor.lnum =) lnum)
                        (beginline (| BL_WHITE BL_FIX))
                    )
                    (flag? flags PUT_CURSEND)
                    (do
                        ;; put cursor after inserted text
                        (cond (== y_type MLINE)
                        (do
                            ((ร @curwin.w_cursor.lnum =) (if (<= (:ml_line_count (:b_ml @curbuf)) lnum) (:ml_line_count (:b_ml @curbuf)) (inc lnum)))
                            ((ร @curwin.w_cursor.col =) 0)
                        )
                        :else
                        (do
                            ((ร @curwin.w_cursor.lnum =) lnum)
                            ((ร @curwin.w_cursor.col =) (... col 0))
                        ))
                    )
                    (== y_type MLINE)
                    (do
                        ;; put cursor on first non-blank in first inserted line
                        ((ร @curwin.w_cursor.col =) 0)
                        (if (== dir FORWARD)
                            (ร @curwin.w_cursor.lnum++)
                        )
                        (beginline (| BL_WHITE BL_FIX))
                    )
                    :else        ;; put cursor on first inserted character
                    (do
                        (COPY-pos (:w_cursor @curwin), new_cursor)
                    ))
                ))
            ))

            (msgmore nr_lines)
            ((ร @curwin.w_set_curswant =) true)
;       }

        (reset! VIsual_active false)

        ;; If the cursor is past the end of the line put it at the end.
        (adjust-cursor-eol)
        nil
    ))

;; When the cursor is on the NUL past the end of the line
;; and it should not be there, move it left.

(defn- #_void adjust-cursor-eol []
    (ยง
        (when (and (< 0 (:col (:w_cursor @curwin))) (== (gchar-cursor) NUL) (non-flag? @ve_flags VE_ONEMORE) (zero? @restart_edit) (non-flag? @State INSERT))
            ;; Put the cursor on the last character in the line.
            (dec-cursor)

            (when (== @ve_flags VE_ALL)
                ((ร int[] scol =) (ร new int[1]))
                ((ร int[] ecol =) (ร new int[1]))

                ;; Coladd is set to the width of the last character.
                (getvcol @curwin, (:w_cursor @curwin), scol, nil, ecol)
                ((ร @curwin.w_cursor.coladd =) (+ (- (... ecol 0) (... scol 0)) 1))
            )
        )
        nil
    ))

;; Join 'count' lines (minimal 2) at cursor position.
;; When "save_undo" is true save lines for undo first.
;; Set "use_formatoptions" to false when e.g. processing backspace and comment
;; leaders should not be removed.
;; When setmark is true, sets the '[ and '] mark, else, the caller is expected
;; to set those marks.
;;
;; return false for failure, true otherwise

(defn- #_boolean do-join [#_int count, #_boolean insert_space, #_boolean save_undo, #_boolean use_formatoptions, #_boolean setmark]
    (ยง
        ((ร boolean retval =) true)

        ((ร Bytes curr =) nil)
        ((ร Bytes curr_start =) nil)
        ((ร int endcurr1 =) NUL)
        ((ร int endcurr2 =) NUL)
        ((ร int currsize =) 0)               ;; size of the current line
        ((ร int sumsize =) 0)                ;; size of the long new line
        ((ร int col =) 0)

        (if (and save_undo (not (u-save (- (:lnum (:w_cursor @curwin)) 1), (+ (:lnum (:w_cursor @curwin)) count))))
            ((ร RETURN) false)
        )

        ;; Allocate an array to store the number of spaces inserted before each line.
        ;; We will use it to pre-compute the length of the new line and the
        ;; proper placement of each original line in the new one.
        ((ร int[] spaces =) (ร new int[count]))

        ;; Don't move anything, just compute the final line length
        ;; and setup the array of space strings lengths.

        (dotimes [#_int t count]
            ((ร curr =) ((ร curr_start =) (ml-get (+ (:lnum (:w_cursor @curwin)) t))))
            (when (and (zero? t) setmark)
                ;; Set the '[ mark.
                ((ร @curbuf.b_op_start.lnum =) (:lnum (:w_cursor @curwin)))
                ((ร @curbuf.b_op_start.col =) (STRLEN curr))
            )

            (when (and insert_space (< 0 t))
                ((ร curr =) (skipwhite curr))
                (when (and (!= (.at curr 0) (byte \))) (non-zero? currsize) (!= endcurr1 TAB))
                    ;; don't add a space if the line is ending in a space
                    (if (== endcurr1 (byte \space))
                        ((ร endcurr1 =) endcurr2)
                        (ร ++spaces[t])
                    )
                    ;; extra space when 'joinspaces' set and line ends in '.'
                    (if (and @p_js (or (== endcurr1 (byte \.)) (and (nil? (vim-strbyte @p_cpo, CPO_JOINSP)) (or (== endcurr1 (byte \?)) (== endcurr1 (byte \!))))))
                        (ร ++spaces[t])
                    )
                )
            )
            ((ร currsize =) (STRLEN curr))
            ((ร sumsize =) (+ sumsize (+ currsize (... spaces t))))
            ((ร endcurr1 =) ((ร endcurr2 =) NUL))
            (when (and insert_space (< 0 currsize))
                ((ร Bytes cend =) (.plus curr currsize))
                ((ร cend =) (.minus cend (us-ptr-back curr, cend)))
                ((ร endcurr1 =) (us-ptr2char cend))
                (when (BLT curr, cend)
                    ((ร cend =) (.minus cend (us-ptr-back curr, cend)))
                    ((ร endcurr2 =) (us-ptr2char cend))
                )
            )
            (line-breakcheck)
            (if @got_int
                ((ร RETURN) false)
            )
        )

        ;; store the column position before last line
        ((ร col =) (- sumsize currsize (... spaces (dec count))))

        ;; allocate the space for the new line
        ((ร Bytes newp =) (Bytes. (inc sumsize)))
        ((ร Bytes cend =) (.plus newp sumsize))
        (eos! cend)

        ;; Move affected lines to the new long one.
        ;;
        ;; Move marks from each deleted line to the joined line, adjusting the
        ;; column.  This is not Vi compatible, but Vi deletes the marks, thus that
        ;; should not really be a problem.

        ((ร FOR) (ร ((ร int t =) (dec count)) true (ร --t))
            ((ร cend =) (.minus cend currsize))
            (BCOPY cend, curr, currsize)
            (when (< 0 (... spaces t))
                ((ร cend =) (.minus cend (... spaces t)))
                (copy-spaces cend, (... spaces t))
            )
            (mark-col-adjust (+ (:lnum (:w_cursor @curwin)) t), 0, (long (- t)), (long (- (+ (BDIFF cend, newp) (... spaces t)) (BDIFF curr, curr_start))))
            (if (zero? t)
                (ร BREAK)
            )
            ((ร curr =) ((ร curr_start =) (ml-get (- (+ (:lnum (:w_cursor @curwin)) t) 1))))
            (if (and insert_space (< 1 t))
                ((ร curr =) (skipwhite curr))
            )
            ((ร currsize =) (STRLEN curr))
        )
        (ml-replace (:lnum (:w_cursor @curwin)), newp)

        (when setmark
            ;; Set the '] mark.
            ((ร @curbuf.b_op_end.lnum =) (:lnum (:w_cursor @curwin)))
            ((ร @curbuf.b_op_end.col =) (STRLEN newp))
        )

        ;; Only report the change in the first line here,
        ;; del-lines() will report the deleted line.
        (changed-lines (:lnum (:w_cursor @curwin)), currsize, (+ (:lnum (:w_cursor @curwin)) 1), 0)

        ;; Delete following lines.  To do this we move the cursor there
        ;; briefly, and then move it back.  After del-lines() the cursor may
        ;; have moved up (last line deleted), so the current lnum is kept in t.

        ((ร long t =) (:lnum (:w_cursor @curwin)))
        (ร @curwin.w_cursor.lnum++)
        (del-lines (dec count), false)
        ((ร @curwin.w_cursor.lnum =) t)

        ;; Set the cursor column:
        ;; Vi compatible: use the column of the first join
        ;; vim:           use the column of the last join

        ((ร @curwin.w_cursor.col =) (if (non-nil? (vim-strbyte @p_cpo, CPO_JOINCOL)) currsize col))
        (check-cursor-col)

        ((ร @curwin.w_cursor.coladd =) 0)
        ((ร @curwin.w_set_curswant =) true)

        retval
    ))

;; prepare a few things for block mode yank/delete/tilde
;;
;; for delete:
;; - textlen includes the first/last char to be (partly) deleted
;; - start/endspaces is the number of columns that are taken by the
;;   first/last deleted char minus the number of columns that have to be deleted.
;; for yank and tilde:
;; - textlen includes the first/last char to be wholly yanked
;; - start/endspaces is the number of columns of the first/last yanked char
;;   that are to be yanked.

(defn- #_void block-prep [#_oparg_C oap, #_block_def_C bdp, #_long lnum, #_boolean is_del]
    (ยง
        ((ร int incr =) 0)

        ((ร bdp.startspaces =) 0)
        ((ร bdp.endspaces =) 0)
        ((ร bdp.textlen =) 0)
        ((ร bdp.start_vcol =) 0)
        ((ร bdp.end_vcol =) 0)
        ((ร bdp.is_short =) false)
        ((ร bdp.is_oneChar =) false)
        ((ร bdp.pre_whitesp =) 0)
        ((ร bdp.pre_whitesp_c =) 0)
        ((ร bdp.end_char_vcols =) 0)
        ((ร bdp.start_char_vcols =) 0)

        ((ร Bytes line =) (ml-get lnum))

        ((ร Bytes pstart =) line)
        ((ร Bytes prev_pstart =) line)

        (while (and (< (:start_vcol bdp) (:start_vcol oap)) (non-eos? pstart))
            ;; Count a tab for what it's worth (if list mode not on).
            ((ร incr =) (lbr-chartabsize line, pstart, (:start_vcol bdp)))
            ((ร bdp.start_vcol =) (+ (:start_vcol bdp) incr))
            (cond (vim-iswhite (.at pstart 0))
            (do
                ((ร bdp.pre_whitesp =) (+ (:pre_whitesp bdp) incr))
                (ร bdp.pre_whitesp_c++)
            )
            :else
            (do
                ((ร bdp.pre_whitesp =) 0)
                ((ร bdp.pre_whitesp_c =) 0)
            ))
            ((ร prev_pstart =) pstart)
            ((ร pstart =) (.plus pstart (us-ptr2len-cc pstart)))
        )

        ((ร bdp.start_char_vcols =) incr)

        (cond (< (:start_vcol bdp) (:start_vcol oap))        ;; line too short
        (do
            ((ร bdp.end_vcol =) (:start_vcol bdp))
            ((ร bdp.is_short =) true)
            (if (or (not is_del) (== (:op_type oap) OP_APPEND))
                ((ร bdp.endspaces =) (+ (- (:end_vcol oap) (:start_vcol oap)) 1))
            )
        )
        :else
        (do
            ;; notice: this converts partly selected Multibyte characters to spaces, too.
            ((ร bdp.startspaces =) (- (:start_vcol bdp) (:start_vcol oap)))
            (if (and is_del (non-zero? (:startspaces bdp)))
                ((ร bdp.startspaces =) (- (:start_char_vcols bdp) (:startspaces bdp)))
            )
; %%        ((ร Bytes[] pend =) (ร { pstart }))
            ((ร bdp.end_vcol =) (:start_vcol bdp))
            (cond (< (:end_vcol oap) (:end_vcol bdp))        ;; it's all in one character
            (do
                ((ร bdp.is_oneChar =) true)
                (cond (== (:op_type oap) OP_INSERT)
                (do
                    ((ร bdp.endspaces =) (- (:start_char_vcols bdp) (:startspaces bdp)))
                )
                (== (:op_type oap) OP_APPEND)
                (do
                    ((ร bdp.startspaces =) (+ (:startspaces bdp) (+ (- (:end_vcol oap) (:start_vcol oap)) 1)))
                    ((ร bdp.endspaces =) (- (:start_char_vcols bdp) (:startspaces bdp)))
                )
                :else
                (do
                    ((ร bdp.startspaces =) (+ (- (:end_vcol oap) (:start_vcol oap)) 1))
                    (when (and is_del (!= (:op_type oap) OP_LSHIFT))
                        ;; just putting the sum of those two into
                        ;; bdp.startspaces doesn't work for Visual replace,
                        ;; so we have to split the tab in two
                        ((ร bdp.startspaces =) (- (:start_char_vcols bdp) (- (:start_vcol bdp) (:start_vcol oap))))
                        ((ร bdp.endspaces =) (- (:end_vcol bdp) (:end_vcol oap) 1))
                    )
                ))
            )
            :else
            (do
                ((ร Bytes prev_pend =) (... pend 0))
                (while (and (<= (:end_vcol bdp) (:end_vcol oap)) (non-eos? (... pend 0)))
                    ;; Count a tab for what it's worth (if list mode not on).
                    ((ร prev_pend =) (... pend 0))
                    ((ร incr =) (lbr-chartabsize-adv line, pend, (:end_vcol bdp)))
                    ((ร bdp.end_vcol =) (+ (:end_vcol bdp) incr))
                )
                (cond (and (<= (:end_vcol bdp) (:end_vcol oap)) (or (not is_del) (== (:op_type oap) OP_APPEND) (== (:op_type oap) OP_REPLACE))) ;; line too short
                (do
                    ((ร bdp.is_short =) true)
                    ;; Alternative: include spaces to fill up the block.
                    ;; Disadvantage: can lead to trailing spaces when
                    ;; the line is short where the text is put.
                    ;; if (!is_del || oap.op_type == OP_APPEND)
                    ((ร bdp.endspaces =) (if (or (== (:op_type oap) OP_APPEND) (!= @virtual_op FALSE))
                        (+ (- (:end_vcol oap) (:end_vcol bdp)) (if (:inclusive oap) 1 0))
                        0 ;; replace doesn't add characters
                    ))
                )
                (< (:end_vcol oap) (:end_vcol bdp))
                (do
                    ((ร bdp.endspaces =) (- (:end_vcol bdp) (:end_vcol oap) 1))
                    (when (and (not is_del) (non-zero? (:endspaces bdp)))
                        ((ร bdp.endspaces =) (- incr (:endspaces bdp)))
                        (if (BNE (... pend 0), pstart)
                            ((ร pend[0] =) prev_pend)
                        )
                    )
                ))
            ))
            ((ร bdp.end_char_vcols =) incr)
            (if (and is_del (non-zero? (:startspaces bdp)))
                ((ร pstart =) prev_pstart)
            )
            ((ร bdp.textlen =) (BDIFF (... pend 0), pstart))
        ))

        ((ร bdp.textcol =) (BDIFF pstart, line))
        ((ร bdp.textstart =) pstart)
        nil
    ))

(final int NUMBUFLEN 30)        ;; length of a buffer to store a number in ASCII

(atom! boolean hexupper)                                ;; 0xABC

;; add or subtract 'Prenum1' from a number in a line
;; 'command' is CTRL-A for add, CTRL-X for subtract
;;
;; return false for failure, true otherwise

(defn- #_boolean do-addsub [#_int command, #_long Prenum1]
    (ยง
        ((ร boolean dohex =) (non-nil? (vim-strchr @(:b_p_nf @curbuf), (byte \x))))   ;; "heX"
        ((ร boolean dooct =) (non-nil? (vim-strchr @(:b_p_nf @curbuf), (byte \o))))   ;; "Octal"
        ((ร boolean doalp =) (non-nil? (vim-strchr @(:b_p_nf @curbuf), (byte \p))))   ;; "alPha"

        ((ร Bytes ptr =) (ml-get-curline))

        ;; First check if we are on a hexadecimal number, after the "0x".

        ((ร int col =) (:col (:w_cursor @curwin)))
        (when dohex
            (while (and (< 0 col) (asc-isxdigit (.at ptr col)))
                (ร --col)
            )
        )
        (cond (and dohex (< 0 col) (or (== (.at ptr col) (byte \X)) (== (.at ptr col) (byte \x))) (== (.at ptr (dec col)) (byte \0)) (asc-isxdigit (.at ptr (inc col))))
        (do
            ;; Found hexadecimal number, move to its start.

            (ร --col)
        )
        :else
        (do
            ;; Search forward and then backward to find the start of number.

            ((ร col =) (:col (:w_cursor @curwin)))

            (while (and (non-eos? ptr col) (not (asc-isdigit (.at ptr col))) (not (and doalp (asc-isalpha (.at ptr col)))))
                (ร col++)
            )

            (while (and (< 0 col) (asc-isdigit (.at ptr (dec col))) (not (and doalp (asc-isalpha (.at ptr col)))))
                (ร --col)
            )
        ))

        ;; If a number was found, and saving for undo works, replace the number.

        ((ร int firstdigit =) (.at ptr col))

        (when (or (and (not (asc-isdigit firstdigit)) (not (and doalp (asc-isalpha firstdigit)))) (not (u-save-cursor)))
            (beep-flush)
            ((ร RETURN) false)
        )

        ;; get 'ptr' again, because u-save() may have changed it
        ((ร ptr =) (ml-get-curline))

        (cond (and doalp (asc-isalpha firstdigit))
        (do
            ;; decrement or increment alphabetic character
            (cond (== command Ctrl_X)
            (do
                (cond (< (alphaOrd firstdigit) Prenum1)
                (do
                    ((ร firstdigit =) (if (asc-isupper firstdigit) (byte \A) (byte \a)))
                )
                :else
                (do
                    ((ร firstdigit =) (- firstdigit Prenum1))
                ))
            )
            :else
            (do
                (cond (< (- 26 (alphaOrd firstdigit) 1) Prenum1)
                (do
                    ((ร firstdigit =) (if (asc-isupper firstdigit) (byte \Z) (byte \z)))
                )
                :else
                (do
                    ((ร firstdigit =) (+ firstdigit Prenum1))
                ))
            ))
            ((ร @curwin.w_cursor.col =) col)
            (del-char false)
            (ins-char firstdigit)
        )
        :else
        (do
            ((ร boolean negative =) false)
            (when (and (< 0 col) (== (.at ptr (dec col)) (byte \-)))        ;; negative number
                (ร --col)
                ((ร negative =) true)
            )

            ((ร int[] hex =) (ร new int[1]))                             ;; 'X' or 'x': hex; '0': octal
; %%        ((ร int[] length =) (ร { 0 }))                               ;; character length of the number
            ((ร long[] n =) (ร new long[1]))
            ;; get the number value (unsigned)
            (vim-str2nr (.plus ptr col), hex, length, (if dooct TRUE FALSE), (if dohex TRUE FALSE), n)
            (if (< (... n 0) 0)
                ((ร n[0] =) (- (... n 0)))
            )

            ;; ignore leading '-' for hex and octal numbers
            (when (and (non-zero? (... hex 0)) negative)
                (ร col++)
                (ร --length[0])
                ((ร negative =) false)
            )

            ;; add or subtract
            ((ร boolean subtract =) false)
            (if (== command Ctrl_X)
                ((ร subtract =) (not subtract))
            )
            (if negative
                ((ร subtract =) (not subtract))
            )

            ((ร long oldn =) (... n 0))
            ((ร n[0] =) ((if subtract - +) (... n 0) Prenum1))

            ((ร final long roof =) 0x7fffffffffffffff)
            ((ร n[0] =) (& (... n 0) roof))

            ;; handle wraparound for decimal numbers
            (when (zero? (... hex 0))
                (cond subtract
                (do
                    (when (< oldn (... n 0))
                        ((ร n[0] =) (inc (bit-xor (... n 0) roof)))
                        ((ร negative =) (not negative))
                    )
                )
                :else ;; add
                (do
                    (when (< (... n 0) oldn)
                        ((ร n[0] =) (bit-xor (... n 0) roof))
                        ((ร negative =) (not negative))
                    )
                ))
                (if (zero? (... n 0))
                    ((ร negative =) false)
                )
            )

            ;; Delete the old number.

            ((ร @curwin.w_cursor.col =) col)
            ((ร int todel =) (... length 0))
            ((ร int c =) (gchar-cursor))

            ;; Don't include the '-' in the length, only the length of the part
            ;; after it is kept the same.

            (if (== c (byte \-))
                (ร --length[0])
            )
            (while (< 0 (ร todel--))
                (when (and (< c 0x100) (asc-isalpha c))
                    (reset! hexupper (asc-isupper c))
                )
                ;; del-char() will mark line needing displaying
                (del-char false)
                ((ร c =) (gchar-cursor))
            )

            ;; Prepare the leading characters in buf1[].
            ;; When there are many leading zeros it could be very long.
            ;; Allocate a bit too much.

            ((ร Bytes buf1 =) (Bytes. (+ (... length 0) NUMBUFLEN)))

            ((ร ptr =) buf1)
            (when negative
                (.be ((ร ptr =) (.plus ptr 1)) -1, (byte \-))
            )
            (when (non-zero? (... hex 0))
                (.be ((ร ptr =) (.plus ptr 1)) -1, (byte \0))
                (ร --length[0])
            )
            (when (or (== (... hex 0) (byte \x)) (== (... hex 0) (byte \X)))
                (.be ((ร ptr =) (.plus ptr 1)) -1, (... hex 0))
                (ร --length[0])
            )

            ;; Put the number characters in buf2[].

            ((ร Bytes buf2 =) (Bytes. NUMBUFLEN))
            (cond (zero? (... hex 0))
            (do
                (.sprintf libC buf2, (u8 "%ld"), (... n 0))
            )
            (== (... hex 0) (byte \0))
            (do
                (.sprintf libC buf2, (u8 "%lo"), (... n 0))
            )
            (and (non-zero? (... hex 0)) @hexupper)
            (do
                (.sprintf libC buf2, (u8 "%lX"), (... n 0))
            )
            :else
            (do
                (.sprintf libC buf2, (u8 "%lx"), (... n 0))
            ))
            ((ร length[0] =) (- (... length 0) (STRLEN buf2)))

            ;; Adjust number of zeros to the new number of digits,
            ;; so the total length of the number remains the same.
            ;; Don't do this when the result may look like an octal number.

            (when (and (== firstdigit (byte \0)) (not (and dooct (zero? (... hex 0)))))
                (while (< 0 (ร length[0]--))
                    (.be ((ร ptr =) (.plus ptr 1)) -1, (byte \0))
                )
            )
            (eos! ptr)
            (STRCAT buf1, buf2)
            (ins-str buf1)          ;; insert the new number
        ))

        (ร --@curwin.w_cursor.col)
        ((ร @curwin.w_set_curswant =) true)
        ((ร ptr =) (ml-get-buf @curbuf, (:lnum (:w_cursor @curwin))))

        true
    ))

;; Count the number of bytes, characters and "words" in a line.
;;
;; "Words" are counted by looking for boundaries between non-space and
;; space characters.  (it seems to produce results that match 'wc'.)
;;
;; Return value is byte count; word count for the line is added to "*wc".
;; Char count is added to "*cc".
;;
;; The function will only examine the first "limit" characters in the
;; line, stopping if it encounters an end-of-line (NUL byte).  In that
;; case, eol_size will be added to the character count to account for
;; the size of the EOL character.

(defn- #_int line-count-info [#_Bytes line, #_int* wc, #_int* cc, #_int limit, #_int eol_size]
    (ยง
        (ร int i)

        ((ร int words =) 0)
        ((ร int chars =) 0)
        ((ร boolean is_word =) false)

        ((ร FOR) (ร ((ร i =) 0) (and (< i limit) (non-eos? line i)) nil)
            (cond is_word
            (do
                (when (vim-isspace (.at line i))
                    (ร words++)
                    ((ร is_word =) false)
                )
            )
            (not (vim-isspace (.at line i)))
            (do
                ((ร is_word =) true)
            ))
            (ร chars++)
            ((ร i =) (+ i (us-ptr2len-cc (.plus line i))))
        )

        (if is_word
            (ร words++)
        )
        ((ร wc[0] =) (+ (... wc 0) words))

        ;; Add eol_size if the end of line was reached before hitting limit.
        (when (and (< i limit) (eos? line i))
            ((ร i =) (+ i eol_size))
            ((ร chars =) (+ chars eol_size))
        )
        ((ร cc[0] =) (+ (... cc 0) chars))

        i
    ))

;; Give some info about the position of the cursor (for "g CTRL-G").
;; In Visual mode, give some info about the selected region.  (In this case,
;; the *_count_cursor variables store running totals for the selection.)

(defn- #_void cursor-pos-info []
    (ยง
        ;; Compute the length of the file in characters.

        (when (non-zero? (& (:ml_flags (:b_ml @curbuf)) ML_EMPTY))
            (msg no_lines_msg)
            ((ร RETURN) nil)
        )

        ((ร Bytes buf1 =) (Bytes. 50))
        ((ร Bytes buf2 =) (Bytes. 40))
        ((ร int byte_count =) 0)
        ((ร int byte_count_cursor =) 0)
; %%    ((ร int[] char_count =) (ร { 0 }))
; %%    ((ร int[] char_count_cursor =) (ร { 0 }))
; %%    ((ร int[] word_count =) (ร { 0 }))
; %%    ((ร int[] word_count_cursor =) (ร { 0 }))
        ((ร int last_check =) 100000)
        ((ร long line_count_selected =) 0)

        ((ร pos_C min_pos =) (NEW_pos_C))
        ((ร pos_C max_pos =) (NEW_pos_C))
        ((ร oparg_C oparg =) (NEW_oparg_C))

        ((ร int eol_size =) 1)

        (when @VIsual_active
            (cond (ltpos @VIsual, (:w_cursor @curwin))
            (do
                (COPY-pos min_pos, @VIsual)
                (COPY-pos max_pos, (:w_cursor @curwin))
            )
            :else
            (do
                (COPY-pos min_pos, (:w_cursor @curwin))
                (COPY-pos max_pos, @VIsual)
            ))
            (if (and (== (.at @p_sel 0) (byte \e)) (< 0 (:col max_pos)))
                (ร --max_pos.col)
            )

            (when (== @VIsual_mode Ctrl_V)
                ((ร Bytes saved_sbr =) @p_sbr)

                ;; Make 'sbr' empty for a moment to get the correct size.
                (reset! p_sbr EMPTY_OPTION)
                ((ร oparg.is_VIsual =) true)
                ((ร oparg.block_mode =) true)
                ((ร oparg.op_type =) OP_NOP)
;               {
; %%                ((ร int[] scol =) (ร { (oparg.start_vcol) }))
; %%                ((ร int[] ecol =) (ร { (oparg.end_vcol) }))
                    (getvcols @curwin, min_pos, max_pos, scol, ecol)
                    ((ร oparg.start_vcol =) (... scol 0))
                    ((ร oparg.end_vcol =) (... ecol 0))
;               }
                (reset! p_sbr saved_sbr)
                (if (== (:w_curswant @curwin) MAXCOL)
                    ((ร oparg.end_vcol =) MAXCOL)
                )
                ;; Swap the start, end vcol if needed.
                (when (< (:end_vcol oparg) (:start_vcol oparg))
                    ((ร oparg.end_vcol =) (+ (:end_vcol oparg) (:start_vcol oparg)))
                    ((ร oparg.start_vcol =) (- (:end_vcol oparg) (:start_vcol oparg)))
                    ((ร oparg.end_vcol =) (- (:end_vcol oparg) (:start_vcol oparg)))
                )
            )

            ((ร line_count_selected =) (+ (- (:lnum max_pos) (:lnum min_pos)) 1))
        )

        ((ร FOR) (ร ((ร long lnum =) 1) (<= lnum (:ml_line_count (:b_ml @curbuf))) (ร lnum++))
            ;; Check for a CTRL-C every 100000 characters.
            (when (< last_check byte_count)
                (ui-breakcheck)
                (if @got_int
                    ((ร RETURN) nil)
                )
                ((ร last_check =) (+ byte_count 100000))
            )

            ;; Do extra processing for VIsual mode.
            (cond (and @VIsual_active (<= (:lnum min_pos) lnum) (<= lnum (:lnum max_pos)))
            (do
                ((ร Bytes s =) nil)
                ((ร int len =) 0)

                ((ร SWITCH) @VIsual_mode
                    ((ร CASE) Ctrl_V)
                    (do
                        (reset! virtual_op (if (virtual-active) TRUE FALSE))
                        ((ร block_def_C bd =) (NEW_block_def_C))
                        (block-prep oparg, bd, lnum, false)
                        (reset! virtual_op MAYBE)
                        ((ร s =) (:textstart bd))
                        ((ร len =) (:textlen bd))
                        (ร BREAK)
                    )

                    ((ร CASE) (byte \V))
                    (do
                        ((ร s =) (ml-get lnum))
                        ((ร len =) MAXCOL)
                        (ร BREAK)
                    )

                    ((ร CASE) (byte \v))
                    (do
                        ((ร int start_col =) (if (== lnum (:lnum min_pos)) (:col min_pos) 0))
                        ((ร int end_col =) (if (== lnum (:lnum max_pos)) (+ (- (:col max_pos) start_col) 1) MAXCOL))

                        ((ร s =) (.plus (ml-get lnum) start_col))
                        ((ร len =) end_col)
                        (ร BREAK)
                    )
                )

                (if (non-nil? s)
                    ((ร byte_count_cursor =) (+ byte_count_cursor (line-count-info s, word_count_cursor, char_count_cursor, len, eol_size)))
                )
            )
            :else
            (do
                ;; In non-visual mode, check for the line the cursor is on.
                (when (== lnum (:lnum (:w_cursor @curwin)))
                    ((ร word_count_cursor[0] =) (+ (... word_count_cursor 0) (... word_count 0)))
                    ((ร char_count_cursor[0] =) (+ (... char_count_cursor 0) (... char_count 0)))
;                   byte_count_cursor = byte_count +
                        (line-count-info (ml-get lnum), word_count_cursor, char_count_cursor, (+ (:col (:w_cursor @curwin)) 1), eol_size)
                )
            ))

            ;; Add to the running totals.
            ((ร byte_count =) (+ byte_count (line-count-info (ml-get lnum), word_count, char_count, MAXCOL, eol_size)))
        )

        (cond @VIsual_active
        (do
            (cond (and (== @VIsual_mode Ctrl_V) (< (:w_curswant @curwin) MAXCOL))
            (do
;               {
; %%                ((ร int[] _1 =) (ร { (min_pos.col) }))
; %%                ((ร int[] _2 =) (ร { (max_pos.col) }))
                    (getvcols @curwin, min_pos, max_pos, _1, _2)
                    ((ร min_pos.col =) (... _1 0))
                    ((ร max_pos.col =) (... _2 0))
;               }
;%%             (vim_snprintf buf1, (.size buf1), (u8 "%ld Cols; "), (+ (- (:end_vcol oparg) (:start_vcol oparg)) 1))
            )
            :else
            (do
                (eos! buf1)
            ))

            (cond (and (== (... char_count_cursor 0) byte_count_cursor) (== (... char_count 0) byte_count))
            (do
;%%             (vim_snprintf @ioBuff, IOSIZE, (u8 "Selected %s%ld of %ld Lines; %ld of %ld Words; %ld of %ld Bytes"), buf1, line_count_selected, (:ml_line_count (:b_ml @curbuf)), (... word_count_cursor 0), (... word_count 0), byte_count_cursor, byte_count)
            )
            :else
            (do
;%%             (vim_snprintf @ioBuff, IOSIZE, (u8 "Selected %s%ld of %ld Lines; %ld of %ld Words; %ld of %ld Chars; %ld of %ld Bytes"), buf1, line_count_selected, (:ml_line_count (:b_ml @curbuf)), (... word_count_cursor 0), (... word_count 0), (... char_count_cursor 0), (... char_count 0), byte_count_cursor, byte_count)
            ))
        )
        :else
        (do
            ((ร Bytes p =) (ml-get-curline))
            (validate-virtcol)
            (col-print buf1, (.size buf1), (+ (:col (:w_cursor @curwin)) 1), (+ (:w_virtcol @curwin) 1))
            (col-print buf2, (.size buf2), (STRLEN p), (linetabsize p))

            (cond (and (== (... char_count_cursor 0) byte_count_cursor) (== (... char_count 0) byte_count))
            (do
;%%             (vim_snprintf @ioBuff, IOSIZE, (u8 "Col %s of %s; Line %ld of %ld; Word %ld of %ld; Byte %ld of %ld"), buf1, buf2, (:lnum (:w_cursor @curwin)), (:ml_line_count (:b_ml @curbuf)), (... word_count_cursor 0), (... word_count 0), byte_count_cursor, byte_count)
            )
            :else
            (do
;%%             (vim_snprintf @ioBuff, IOSIZE, (u8 "Col %s of %s; Line %ld of %ld; Word %ld of %ld; Char %ld of %ld; Byte %ld of %ld"), buf1, buf2, (:lnum (:w_cursor @curwin)), (:ml_line_count (:b_ml @curbuf)), (... word_count_cursor 0), (... word_count 0), (... char_count_cursor 0), (... char_count 0), byte_count_cursor, byte_count)
            ))
        ))

        (msg @ioBuff)
        nil
    ))

;; mark.c: functions for setting marks and jumping to them ----------------------------------------

;; If a named file mark's lnum is non-zero, it is valid.
;; There are marks 'A - 'Z (set by user) and '0 to '9 (set when writing viminfo).

(final int EXTRA_MARKS 10)                                              ;; marks 0-9
(final fmark_C*    namedfm    (ARRAY-fmark (+ NMARKS EXTRA_MARKS)))   ;; marks with file nr

;; Set named mark "c" at current cursor position.
;; Returns true on success, false if bad name given.

(defn- #_boolean setmark [#_int c]
    (setmark-pos c, (:w_cursor @curwin)))

;; Set named mark "c" to position "pos".
;; Returns true on success, false if bad name given.

(defn- #_boolean setmark-pos [#_int c, #_pos_C pos]
    (ยง
        ;; Check for a special key (may cause islower() to crash).
        (if (< c 0)
            ((ร RETURN) false)
        )

        (when (or (== c (byte \')) (== c (byte \`)))
            (cond (== pos (:w_cursor @curwin))
            (do
                (setpcmark)
                ;; keep it even when the cursor doesn't move
                (COPY-pos (:w_prev_pcmark @curwin), (:w_pcmark @curwin))
            )
            :else
            (do
                (COPY-pos (:w_pcmark @curwin), pos)
            ))
            ((ร RETURN) true)
        )

        (when (== c (byte \"))  ;; """
            (COPY-pos (:b_last_cursor @curbuf), pos)
            ((ร RETURN) true)
        )

        ;; Allow setting '[ and '] for an autocommand that simulates reading a file.
        (when (== c (byte \[))
            (COPY-pos (:b_op_start @curbuf), pos)
            ((ร RETURN) true)
        )
        (when (== c (byte \]))
            (COPY-pos (:b_op_end @curbuf), pos)
            ((ร RETURN) true)
        )

        (when (or (== c (byte \<)) (== c (byte \>)))
            (if (== c (byte \<))
                (COPY-pos (:vi_start (:b_visual @curbuf)), pos)
                (COPY-pos (:vi_end (:b_visual @curbuf)), pos))
            (when (== (:vi_mode (:b_visual @curbuf)) NUL)
                ;; Visual_mode has not yet been set, use a sane default.
                ((ร @curbuf.b_visual.vi_mode =) (byte \v))
            )
            ((ร RETURN) true)
        )

        (if (< (byte \z) c)        ;; some islower() and isupper() cannot handle characters above 127
            ((ร RETURN) false)
        )
        (when (asc-islower c)
            ((ร int i =) (- c (byte \a)))
            (COPY-pos (... (:b_namedm @curbuf) i), pos)
            ((ร RETURN) true)
        )
        (when (asc-isupper c)
            ((ร int i =) (- c (byte \A)))
            (COPY-pos (:mark (... namedfm i)), pos)
            ((ร RETURN) true)
        )

        false
    ))

;; Set the previous context mark to the current position and add it to the jump list.

(defn- #_void setpcmark []
    (ยง
        (COPY-pos (:w_prev_pcmark @curwin), (:w_pcmark @curwin))
        (COPY-pos (:w_pcmark @curwin), (:w_cursor @curwin))

        ;; If jumplist is full: remove oldest entry.
        (when (> (ร ++@curwin.w_jumplistlen) JUMPLISTSIZE)
            ((ร @curwin.w_jumplistlen =) JUMPLISTSIZE)
            ((ร FOR) (ร ((ร int i =) 1) (< i JUMPLISTSIZE) (ร i++))
                (COPY-fmark (... (:w_jumplist @curwin) (dec i)), (... (:w_jumplist @curwin) i))
            )
        )
        ((ร @curwin.w_jumplistidx =) (:w_jumplistlen @curwin))
        ((ร fmark_C fm =) (... (:w_jumplist @curwin) (- (:w_jumplistlen @curwin) 1)))

        (COPY-pos (:mark fm), (:w_pcmark @curwin))
        nil
    ))

;; To change context, call setpcmark(), then move the current position to
;; where ever, then call checkpcmark().  This ensures that the previous
;; context will only be changed if the cursor moved to a different line.
;; If pcmark was deleted (with "dG") the previous mark is restored.

(defn- #_void checkpcmark []
    (ยง
        (when (and (non-zero? (:lnum (:w_prev_pcmark @curwin))) (or (eqpos (:w_pcmark @curwin), (:w_cursor @curwin)) (zero? (:lnum (:w_pcmark @curwin)))))
            (COPY-pos (:w_pcmark @curwin), (:w_prev_pcmark @curwin))
            ((ร @curwin.w_prev_pcmark.lnum =) 0)      ;; show it has been checked
        )
        nil
    ))

;; Move "count" positions in the jump list (count may be negative).

(defn- #_pos_C movemark [#_int count]
    (ยง
        (cleanup-jumplist)

        (if (zero? (:w_jumplistlen @curwin))          ;; nothing to jump to
            ((ร RETURN) nil)
        )

        (while true
            (if (or (< (+ (:w_jumplistidx @curwin) count) 0) (<= (:w_jumplistlen @curwin) (+ (:w_jumplistidx @curwin) count)))
                ((ร RETURN) nil)
            )

            ;; If first CTRL-O or CTRL-I command after a jump, add cursor position
            ;; to list.  Careful: If there are duplicates (CTRL-O immediately after
            ;; starting Vim on a file), another entry may have been removed.

            (when (== (:w_jumplistidx @curwin) (:w_jumplistlen @curwin))
                (setpcmark)
                (ร --@curwin.w_jumplistidx)         ;; skip the new entry
                (if (< (+ (:w_jumplistidx @curwin) count) 0)
                    ((ร RETURN) nil)
                )
            )

            ((ร @curwin.w_jumplistidx =) (+ (:w_jumplistidx @curwin) count))

            ((ร RETURN) (:mark (... (:w_jumplist @curwin) (:w_jumplistidx @curwin))))
        )
    ))

;; Move "count" positions in the changelist (count may be negative).

(defn- #_pos_C movechangelist [#_int count]
    (ยง
        (if (zero? (:b_changelistlen @curbuf))    ;; nothing to jump to
            ((ร RETURN) nil)
        )

        ((ร int n =) (:w_changelistidx @curwin))
        (cond (< (+ n count) 0)
        (do
            (if (zero? n)
                ((ร RETURN) nil)
            )
            ((ร n =) 0)
        )
        (<= (:b_changelistlen @curbuf) (+ n count))
        (do
            (if (== n (- (:b_changelistlen @curbuf) 1))
                ((ร RETURN) nil)
            )
            ((ร n =) (- (:b_changelistlen @curbuf) 1))
        )
        :else
        (do
            ((ร n =) (+ n count))
        ))
        ((ร @curwin.w_changelistidx =) n)
        (... (:b_changelist @curbuf) n)
    ))

;; Find mark "c" in buffer pointed to by "buf".
;; If "changefile" is true it's allowed to edit another file for '0, 'A, etc.
;; Returns:
;; - pointer to pos_C if found.  lnum is 0 when mark not set, -1 when mark is
;;   in another file which can't be gotten. (caller needs to check lnum!)
;; - null if there is no mark called 'c'.
;; - -1 if mark is in other file and jumped there (only if changefile is true)

(defn- #_pos_C getmark-buf [#_buffer_C buf, #_int c, #_boolean changefile]
    (getmark-buf-fnum buf, c, changefile))

(defn- #_pos_C getmark [#_int c, #_boolean changefile]
    (getmark-buf-fnum @curbuf, c, changefile))

(atom! pos_C _1_pos_copy    (NEW_pos_C))

(defn- #_pos_C getmark-buf-fnum [#_buffer_C buf, #_int c, #_boolean changefile]
    (ยง
        ((ร pos_C posp =) nil)

        ;; Check for special key, can't be a mark name and might cause islower() to crash.
        (if (< c 0)
            ((ร RETURN) posp)
        )

        (cond (< (byte \~) c)                                ;; check for islower()/isupper()
        (do
            ;
        )
        (or (== c (byte \')) (== c (byte \`)))             ;; previous context mark
        (do
            (COPY-pos @_1_pos_copy, (:w_pcmark @curwin)) ;; need to make a copy because
            ((ร posp =) @_1_pos_copy)                     ;; w_pcmark may be changed soon
        )
        (== c (byte \"))                          ;; to pos when leaving buffer """
        (do
            ((ร posp =) (:b_last_cursor buf))
        )
        (== c (byte \^))                          ;; to where Insert mode stopped
        (do
            ((ร posp =) (:b_last_insert buf))
        )
        (== c (byte \.))                          ;; to where last change was made
        (do
            ((ร posp =) (:b_last_change buf))
        )
        (== c (byte \[))                          ;; to start of previous operator
        (do
            ((ร posp =) (:b_op_start buf))
        )
        (== c (byte \]))                          ;; to end of previous operator
        (do
            ((ร posp =) (:b_op_end buf))
        )
        (or (== c (byte \{)) (== c (byte \})))              ;; to previous/next paragraph
        (do
;           
        )
        (or (== c (byte \()) (== c (byte \))))              ;; to previous/next sentence
        (do
;           
        )
        (or (== c (byte \<)) (== c (byte \>)))              ;; start/end of visual area
        (do
            ((ร pos_C startp =) (:vi_start (:b_visual buf)))
            ((ร pos_C endp =) (:vi_end (:b_visual buf)))
            ((ร posp =) (if (== (== c (byte \<)) (ltpos startp, endp)) startp endp))

            ;; For Visual line mode, set mark at begin or end of line

            (when (== (:vi_mode (:b_visual buf)) (byte \V))
                (COPY-pos @_1_pos_copy, posp)
                ((ร posp =) @_1_pos_copy)
                ((ร @_1_pos_copy.col =) (if (== c (byte \<)) 0 MAXCOL))
                ((ร @_1_pos_copy.coladd =) 0)
            )
        )
        (asc-islower c)                    ;; normal named mark
        (do
            ((ร posp =) (... (:b_namedm buf) (- c (byte \a))))
        )
        (or (asc-isupper c) (asc-isdigit c))  ;; named file mark
        (do
            ((ร posp =) (:mark (... namedfm (if (asc-isdigit c) (+ (- c (byte \0)) NMARKS) (- c (byte \A))))))
        ))

        posp
    ))

;; Search for the next named mark in the current file.
;;
;; Returns pointer to pos_C of the next mark or null if no mark is found.

(defn- #_pos_C getnextmark [#_pos_C startpos, #_int dir, #_boolean begin_line]
    ;; startpos: where to start
    ;; dir: direction for search
    (ยง
        ((ร pos_C result =) nil)
        ((ร pos_C pos =) (NEW_pos_C))
        (COPY-pos pos, startpos)

        ;; When searching backward and leaving the cursor on the first non-blank,
        ;; position must be in a previous line.
        ;; When searching forward and leaving the cursor on the first non-blank,
        ;; position must be in a next line.
        (cond (and (== dir BACKWARD) begin_line)
        (do
            ((ร pos.col =) 0)
        )
        (and (== dir FORWARD) begin_line)
        (do
            ((ร pos.col =) MAXCOL)
        ))

        (dotimes [#_int i NMARKS]
            (when (< 0 (:lnum (... (:b_namedm @curbuf) i)))
                (cond (== dir FORWARD)
                (do
                    (if (and (or (nil? result) (ltpos (... (:b_namedm @curbuf) i), result)) (ltpos pos, (... (:b_namedm @curbuf) i)))
                        ((ร result =) (... (:b_namedm @curbuf) i))
                    )
                )
                :else
                (do
                    (if (and (or (nil? result) (ltpos result, (... (:b_namedm @curbuf) i))) (ltpos (... (:b_namedm @curbuf) i), pos))
                        ((ร result =) (... (:b_namedm @curbuf) i))
                    )
                ))
            )
        )

        result
    ))

;; Check a if a position from a mark is valid.
;; Give and error message and return false if not.

(defn- #_boolean check-mark [#_pos_C pos]
    (ยง
        (when (nil? pos)
            (emsg e_umark)
            ((ร RETURN) false)
        )
        (when (<= (:lnum pos) 0)
            ;; 'lnum' is negative if mark is in another file and can't get that file,
            ;; error message already give then.
            (if (zero? (:lnum pos))
                (emsg e_marknotset))
            ((ร RETURN) false)
        )
        (when (< (:ml_line_count (:b_ml @curbuf)) (:lnum pos))
            (emsg e_markinval)
            ((ร RETURN) false)
        )
        true
    ))

(atom! int mark_i -1)

;; clrallmarks() - clear all marks in the buffer 'buf'
;;
;; Used mainly when trashing the entire buffer during ":e" type commands

(defn- #_void clrallmarks [#_buffer_C buf]
    (ยง
        (when (== @mark_i -1)                   ;; first call ever: initialize
            ((ร FOR) (ร ((ร @mark_i =) 0) (< @mark_i (inc NMARKS)) (ร @mark_i++))
                ((ร namedfm[@mark_i].mark.lnum =) 0)
            )
        )

        ((ร FOR) (ร ((ร @mark_i =) 0) (< @mark_i NMARKS) (ร @mark_i++))
            ((ร buf.b_namedm[@mark_i].lnum =) 0)
        )
        ((ร buf.b_op_start.lnum =) 0)            ;; start/end op mark cleared
        ((ร buf.b_op_end.lnum =) 0)
        ((ร buf.b_last_cursor.lnum =) 1)         ;; '" mark cleared
        ((ร buf.b_last_cursor.col =) 0)
        ((ร buf.b_last_cursor.coladd =) 0)
        ((ร buf.b_last_insert.lnum =) 0)         ;; '^ mark cleared
        ((ร buf.b_last_change.lnum =) 0)         ;; '. mark cleared
        ((ร buf.b_changelistlen =) 0)
        nil
    ))

(defn- #_long one-adjust [#_long add, #_long line1, #_long line2, #_long amount, #_long amount_after]
    (ยง
        (cond (<= line1 add line2)
        (do
            (if (== amount MAXLNUM)
                ((ร add =) 0)
                ((ร add =) (+ add amount))
            )
        )
        (and (non-zero? amount_after) (< line2 add))
        (do
            ((ร add =) (+ add amount_after))
        ))

        add
    ))

;; don't delete the line, just put at first deleted line
(defn- #_long one-adjust-nodel [#_long add, #_long line1, #_long line2, #_long amount, #_long amount_after]
    (ยง
        (cond (<= line1 add line2)
        (do
            (if (== amount MAXLNUM)
                ((ร add =) line1)
                ((ร add =) (+ add amount))
            )
        )
        (and (non-zero? amount_after) (< line2 add))
        (do
            ((ร add =) (+ add amount_after))
        ))

        add
    ))

(atom! pos_C mark_initpos (->pos_C 1, 0, 0))

;; Adjust marks between line1 and line2 (inclusive) to move 'amount' lines.
;; Must be called before changed_*(), appended-lines() or deleted-lines().
;; May be called before or after changing the text.
;; When deleting lines line1 to line2, use an 'amount' of MAXLNUM:
;; The marks within this range are made invalid.
;; If 'amount_after' is non-zero adjust marks after line2.
;; Example: Delete lines 34 and 35: mark-adjust(34, 35, MAXLNUM, -2);
;; Example: Insert two lines below 55: mark-adjust(56, MAXLNUM, 2, 0);
;;                                 or: mark-adjust(56, 55, MAXLNUM, 2);

(defn- #_void mark-adjust [#_long line1, #_long line2, #_long amount, #_long amount_after]
    (ยง
        (if (and (< line2 line1) (zero? amount_after))                ;; nothing to do
            ((ร RETURN) nil)
        )

        ;; named marks, lower case and upper case
        (dotimes [#_int i NMARKS]
            ((ร @curbuf.b_namedm[i].lnum =) (one-adjust (:lnum (... (:b_namedm @curbuf) i)), line1, line2, amount, amount_after))
            ((ร namedfm[i].mark.lnum =) (one-adjust-nodel (:lnum (:mark (... namedfm i))), line1, line2, amount, amount_after))
        )
        ((ร FOR) (ร ((ร int i =) NMARKS) (< i (+ NMARKS EXTRA_MARKS)) (ร i++))
            ((ร namedfm[i].mark.lnum =) (one-adjust-nodel (:lnum (:mark (... namedfm i))), line1, line2, amount, amount_after))
        )

        ;; last Insert position
        ((ร @curbuf.b_last_insert.lnum =) (one-adjust (:lnum (:b_last_insert @curbuf)), line1, line2, amount, amount_after))

        ;; last change position
        ((ร @curbuf.b_last_change.lnum =) (one-adjust (:lnum (:b_last_change @curbuf)), line1, line2, amount, amount_after))

        ;; last cursor position, if it was set
        (if (not (eqpos (:b_last_cursor @curbuf), @mark_initpos))
            ((ร @curbuf.b_last_cursor.lnum =) (one-adjust (:lnum (:b_last_cursor @curbuf)), line1, line2, amount, amount_after))
        )

        ;; list of change positions
        (dotimes [#_int i (:b_changelistlen @curbuf)]
            ((ร @curbuf.b_changelist[i].lnum =) (one-adjust-nodel (:lnum (... (:b_changelist @curbuf) i)), line1, line2, amount, amount_after))
        )

        ;; Visual area.
        ((ร @curbuf.b_visual.vi_start.lnum =) (one-adjust-nodel (:lnum (:vi_start (:b_visual @curbuf))), line1, line2, amount, amount_after))
        ((ร @curbuf.b_visual.vi_end.lnum =) (one-adjust-nodel (:lnum (:vi_end (:b_visual @curbuf))), line1, line2, amount, amount_after))

        ;; previous context mark
        ((ร @curwin.w_pcmark.lnum =) (one-adjust (:lnum (:w_pcmark @curwin)), line1, line2, amount, amount_after))

        ;; previous pcmark
        ((ร @curwin.w_prev_pcmark.lnum =) (one-adjust (:lnum (:w_prev_pcmark @curwin)), line1, line2, amount, amount_after))

        ;; saved cursor for formatting
        (if (non-zero? (:lnum @saved_cursor))
            ((ร @saved_cursor.lnum =) (one-adjust-nodel (:lnum @saved_cursor), line1, line2, amount, amount_after))
        )

        ;; Adjust items in all windows related to the current buffer.

        ((ร FOR) (ร ((ร window_C win =) @firstwin) (non-nil? win) ((ร win =) (:w_next win)))
            ;; Marks in the jumplist.  When deleting lines, this may create
            ;; duplicate marks in the jumplist, they will be removed later.
            (dotimes [#_int i (:w_jumplistlen win)]
                ((ร win.w_jumplist[i].mark.lnum =) (one-adjust-nodel (:lnum (:mark (... (:w_jumplist win) i))), line1, line2, amount, amount_after))
            )

            ;; the displayed Visual area
            (when (non-zero? (:w_old_cursor_lnum win))
                ((ร win.w_old_cursor_lnum =) (one-adjust-nodel (:w_old_cursor_lnum win), line1, line2, amount, amount_after))
                ((ร win.w_old_visual_lnum =) (one-adjust-nodel (:w_old_visual_lnum win), line1, line2, amount, amount_after))
            )

            ;; topline and cursor position for windows with the same buffer
            ;; other than the current window
            (when (!= win @curwin)
                (cond (and (<= line1 (:w_topline win)) (<= (:w_topline win) line2))
                (do
                    (cond (== amount MAXLNUM)              ;; topline is deleted
                    (do
                        ((ร win.w_topline =) (if (<= line1 1) 1 (dec line1)))
                    )
                    :else                                ;; keep topline on the same line
                    (do
                        ((ร win.w_topline =) (+ (:w_topline win) amount))
                    ))
                )
                (and (non-zero? amount_after) (< line2 (:w_topline win)))
                (do
                    ((ร win.w_topline =) (+ (:w_topline win) amount_after))
                ))

                (cond (and (<= line1 (:lnum (:w_cursor win))) (<= (:lnum (:w_cursor win)) line2))
                (do
                    (cond (== amount MAXLNUM)              ;; line with cursor is deleted
                    (do
                        ((ร win.w_cursor.lnum =) (if (<= line1 1) 1 (dec line1)))
                        ((ร win.w_cursor.col =) 0)
                    )
                    :else                                ;; keep cursor on the same line
                    (do
                        ((ร win.w_cursor.lnum =) (+ (:lnum (:w_cursor win)) amount))
                    ))
                )
                (and (non-zero? amount_after) (< line2 (:lnum (:w_cursor win))))
                (do
                    ((ร win.w_cursor.lnum =) (+ (:lnum (:w_cursor win)) amount_after))
                ))
            )
        )
        nil
    ))

;; This code is used often, needs to be fast.
(defn- #_void col-adjust [#_pos_C posp, #_long lnum, #_int mincol, #_long lnum_amount, #_long col_amount]
    (ยง
        (when (and (== (:lnum posp) lnum) (<= mincol (:col posp)))
            ((ร posp.lnum =) (+ (:lnum posp) lnum_amount))
            (if (and (< col_amount 0) (<= (:col posp) (int (- col_amount))))
                ((ร posp.col =) 0)
                ((ร posp.col =) (+ (:col posp) col_amount))
            )
        )
        nil
    ))

;; Adjust marks in line "lnum" at column "mincol" and further: add
;; "lnum_amount" to the line number and add "col_amount" to the column position.

(defn- #_void mark-col-adjust [#_long lnum, #_int mincol, #_long lnum_amount, #_long col_amount]
    (ยง
        (if (and (zero? col_amount) (zero? lnum_amount))
            ((ร RETURN) nil) ;; nothing to do
        )

        ;; named marks, lower case and upper case
        (dotimes [#_int i NMARKS]
            (col-adjust (... (:b_namedm @curbuf) i), lnum, mincol, lnum_amount, col_amount)
            (col-adjust (:mark (... namedfm i)), lnum, mincol, lnum_amount, col_amount)
        )
        ((ร FOR) (ร ((ร int i =) NMARKS) (< i (+ NMARKS EXTRA_MARKS)) (ร i++))
            (col-adjust (:mark (... namedfm i)), lnum, mincol, lnum_amount, col_amount)
        )

        ;; last Insert position
        (col-adjust (:b_last_insert @curbuf), lnum, mincol, lnum_amount, col_amount)

        ;; last change position
        (col-adjust (:b_last_change @curbuf), lnum, mincol, lnum_amount, col_amount)

        ;; list of change positions
        (dotimes [#_int i (:b_changelistlen @curbuf)]
            (col-adjust (... (:b_changelist @curbuf) i), lnum, mincol, lnum_amount, col_amount)
        )

        ;; Visual area.
        (col-adjust (:vi_start (:b_visual @curbuf)), lnum, mincol, lnum_amount, col_amount)
        (col-adjust (:vi_end (:b_visual @curbuf)), lnum, mincol, lnum_amount, col_amount)

        ;; previous context mark
        (col-adjust (:w_pcmark @curwin), lnum, mincol, lnum_amount, col_amount)

        ;; previous pcmark
        (col-adjust (:w_prev_pcmark @curwin), lnum, mincol, lnum_amount, col_amount)

        ;; saved cursor for formatting
        (col-adjust @saved_cursor, lnum, mincol, lnum_amount, col_amount)

        ;; Adjust items in all windows related to the current buffer.

        ((ร FOR) (ร ((ร window_C wp =) @firstwin) (non-nil? wp) ((ร wp =) (:w_next wp)))
            ;; marks in the jumplist
            (dotimes [#_int i (:w_jumplistlen wp)]
                (col-adjust (:mark (... (:w_jumplist wp) i)), lnum, mincol, lnum_amount, col_amount)
            )

            ;; cursor position for other windows with the same buffer
            (if (!= wp @curwin)
                (col-adjust (:w_cursor wp), lnum, mincol, lnum_amount, col_amount))
        )
        nil
    ))

;; When deleting lines, this may create duplicate marks in the jumplist.
;; They will be removed here for the current window.

(defn- #_void cleanup-jumplist []
    (ยง
        ((ร int to =) 0)

        (dotimes [#_int from (:w_jumplistlen @curwin)]
            (if (== (:w_jumplistidx @curwin) from)
                ((ร @curwin.w_jumplistidx =) to)
            )
            (ร int i)
            ((ร FOR) (ร ((ร i =) (inc from)) (< i (:w_jumplistlen @curwin)) (ร i++))
                (if (== (:lnum (:mark (... (:w_jumplist @curwin) i))) (:lnum (:mark (... (:w_jumplist @curwin) from))))
                    (ร BREAK)
                )
            )
            (if (<= (:w_jumplistlen @curwin) i)  ;; no duplicate
                (COPY-fmark (... (:w_jumplist @curwin) (ร to++)), (... (:w_jumplist @curwin) from)))
        )

        (if (== (:w_jumplistidx @curwin) (:w_jumplistlen @curwin))
            ((ร @curwin.w_jumplistidx =) to)
        )
        ((ร @curwin.w_jumplistlen =) to)
        nil
    ))

;; Copy the jumplist from window "from" to window "to".

(defn- #_void copy-jumplist [#_window_C from, #_window_C to]
    (ยง
        (dotimes [#_int i (:w_jumplistlen from)]
            (COPY-fmark (... (:w_jumplist to) i), (... (:w_jumplist from) i))
        )
        ((ร to.w_jumplistlen =) (:w_jumplistlen from))
        ((ร to.w_jumplistidx =) (:w_jumplistidx from))
        nil
    ))

(defn- #_void set-last-cursor [#_window_C win]
    (COPY-pos (:b_last_cursor @curbuf), (:w_cursor win))
    nil)

;;; ============================================================================================== VimL

;; getchar.c --------------------------------------------------------------------------------------
;;
;; functions related with getting a character from the user/mapping/redo/...
;;
;; manipulations with redo buffer and stuff buffer
;; mappings and abbreviations

;; These buffers are used for storing:
;; - stuffed characters: A command that is translated into another command.
;; - redo characters: will redo the last change.
;; - recorded characters: for the "q" command.
;;
;; The bytes are stored like in the typeahead buffer:
;; - KB_SPECIAL introduces a special key (two more bytes follow).
;;   A literal KB_SPECIAL is stored as KB_SPECIAL KS_SPECIAL KE_FILLER.
;; These translations are also done on multi-byte characters!
;;
;; Escaping KB_SPECIAL is done by inchar().
;; Un-escaping is done by vgetc().

(atom! buffheader_C redobuff    (NEW_buffheader_C))
(atom! buffheader_C old_redobuff    (NEW_buffheader_C))
(atom! buffheader_C recordbuff  (NEW_buffheader_C))

(atom! int typeahead_char)      ;; typeahead char that's not flushed

;; When block_redo is true redo buffer will not be changed;
;; used by edit() to repeat insertions and 'V' command for redoing.

(atom! boolean block_redo)

;; Variables used by vgetorpeek() and flush-buffers().
;;
;; typebuf.tb_buf[] contains all characters that are not consumed yet.
;; typebuf.tb_buf[typebuf.tb_off] is the first valid character.
;; typebuf.tb_buf[typebuf.tb_off + typebuf.tb_len - 1] is the last valid char.
;; typebuf.tb_buf[typebuf.tb_off + typebuf.tb_len] must be NUL.
;;
;; After the head are characters that come from the terminal.

;; typebuf.tb_buf has three parts:
;;  room in front (for result of mappings),
;;  the middle for typeahead and
;;  room for new characters (which needs to be 3 * MAXMAPLEN).

(atom! int      last_recorded_len)          ;; number of last recorded chars

;; Free and clear a buffer.

(defn- #_void free-buff [#_buffheader_C buf]
    (ยง
        ((ร buf.bh_first.bb_next =) nil)
        nil
    ))

;; Return the contents of a buffer as a single string.
;; KB_SPECIAL in the returned string is escaped.

(defn- #_Bytes get-buffcont [#_buffheader_C buffer, #_boolean dozero]
    ;; dozero: count == zero is not an error
    (ยง
        ((ร int count =) 0)

        ;; compute the total length of the string
        ((ร FOR) (ร ((ร buffblock_C bp =) (:bb_next (:bh_first buffer))) (non-nil? bp) ((ร bp =) (:bb_next bp)))
            ((ร count =) (+ count (STRLEN (:bb_str bp))))
        )

        ((ร Bytes p =) nil)

        (when (or (< 0 count) dozero)
            ((ร p =) (Bytes. (inc count)))

            ((ร Bytes q =) p)
            ((ร FOR) (ร ((ร buffblock_C bp =) (:bb_next (:bh_first buffer))) (non-nil? bp) ((ร bp =) (:bb_next bp)))
                ((ร FOR) (ร ((ร Bytes s =) (:bb_str bp)) (non-eos? s) nil)
                    (.be ((ร q =) (.plus q 1)) -1, (.at ((ร s =) (.plus s 1)) -1))
                )
            )
            (eos! q)
        )

        p
    ))

;; Return the contents of the record buffer as a single string and clear the record buffer.
;; KB_SPECIAL in the returned string is escaped.

(defn- #_Bytes get-recorded []
    (ยง
        ((ร Bytes p =) (get-buffcont @recordbuff, true))
        (free-buff @recordbuff)

        ;; Remove the characters that were added the last time, these must be the
        ;; (possibly mapped) characters that stopped the recording.

        ((ร int len =) (STRLEN p))
        (when (<= @last_recorded_len len)
            ((ร len =) (- len @last_recorded_len))
            (eos! p len)
        )

        ;; When stopping recording from Insert mode with CTRL-O q, also remove the CTRL-O.

        (if (and (< 0 len) (non-zero? @restart_edit) (== (.at p (dec len)) Ctrl_O))
            (.be p (dec len), NUL)
        )

        p
    ))

;; Return the contents of the redo buffer as a single string.
;; KB_SPECIAL in the returned string is escaped.

(defn- #_Bytes get-inserted []
    (get-buffcont @redobuff, false))

;; Add string "s" after the current block of buffer "buf".
;; KB_SPECIAL should have been escaped already.

(defn- #_void add-buff [#_buffheader_C buf, #_Bytes s, #_long slen]
    ;; slen: length of "s" or -1
    (ยง
        (if (< slen 0)
            ((ร slen =) (STRLEN s))
        )
        (if (zero? slen)                          ;; don't add empty strings
            ((ร RETURN) nil)
        )

        (cond (nil? (:bb_next (:bh_first buf)))       ;; first add to list
        (do
            ((ร buf.bh_space =) 0)
            ((ร buf.bh_curr =) (:bh_first buf))
        )
        (nil? (:bh_curr buf))           ;; buffer has already been read
        (do
            (emsg (u8 "E222: Add to read buffer"))
            ((ร RETURN) nil)
        )
        (non-zero? (:bh_index buf))
        (do
            ((ร buffblock_C bp =) (:bb_next (:bh_first buf)))
            ((ร int len =) (+ (STRLEN (.plus (:bb_str bp) (:bh_index buf))) 1))
            (BCOPY (:bb_str bp), 0, (:bb_str bp), (:bh_index buf), len)
        ))
        ((ร buf.bh_index =) 0)

        (cond (<= (int slen) (:bh_space buf))
        (do
            ((ร int len =) (STRLEN (:bb_str (:bh_curr buf))))
            (vim-strncpy (.plus (:bb_str (:bh_curr buf)) len), s, (int slen))
            ((ร buf.bh_space =) (- (:bh_space buf) slen))
        )
        :else
        (do
            ((ร final int MINIMAL_SIZE =) 20)            ;; minimal size for bb_str

            ((ร int len =) (if (< (int slen) MINIMAL_SIZE) MINIMAL_SIZE (int slen)))

            ((ร buffblock_C bp =) (NEW_buffblock_C))

            ((ร bp.bb_str =) (Bytes. (inc len)))
            (vim-strncpy (:bb_str bp), s, (int slen))
            ((ร buf.bh_space =) (- len (int slen)))

            ((ร bp.bb_next =) (:bb_next (:bh_curr buf)))
            ((ร buf.bh_curr.bb_next =) bp)
            ((ร buf.bh_curr =) bp)
        ))
        nil
    ))

;; Add number "n" to buffer "buf".

(defn- #_void add-num-buff [#_buffheader_C buf, #_long n]
    (ยง
        ((ร Bytes number =) (Bytes. 32))

        (.sprintf libC number, (u8 "%ld"), n)
        (add-buff buf, number, -1)
        nil
    ))

;; Add character 'c' to buffer "buf".
;; Translates special keys, NUL, KB_SPECIAL and multibyte characters.

(defn- #_void add-char-buff [#_buffheader_C buf, #_int c]
    (ยง
        ((ร Bytes bytes =) (Bytes. (inc MB_MAXBYTES)))

        ((ร int len =) (if (is-special c) 1 (utf-char2bytes c, bytes)))

        ((ร Bytes temp =) (Bytes. 4))

        (dotimes [#_int i len]
            (if (not (is-special c))
                ((ร c =) (char_u (.at bytes i)))
            )

            (cond (or (is-special c) (== c (char_u KB_SPECIAL)) (== c NUL))
            (do
                ;; translate special key code into three byte sequence
                (.be temp 0, KB_SPECIAL)
                (.be temp 1, (KB-SECOND c))
                (.be temp 2, (KB-THIRD c))
                (eos! temp 3)
            )
            :else
            (do
                (.be temp 0, c)
                (eos! temp 1)
            ))

            (add-buff buf, temp, -1)
        )
        nil
    ))

;; First read ahead buffer.  Used for translated commands.
(atom! buffheader_C readbuf1    (NEW_buffheader_C))

;; Second read ahead buffer.  Used for redo.
(atom! buffheader_C readbuf2    (NEW_buffheader_C))

;; Get one byte from a read buffer.
;; If advance == true go to the next char.
;; No translation is done KB_SPECIAL is escaped.

(defn- #_byte read-readbuf [#_buffheader_C buf, #_boolean advance]
    (ยง
        ((ร buffblock_C bp =) (:bb_next (:bh_first buf)))
        (if (nil? bp) ;; buffer is empty
            ((ร RETURN) NUL)
        )

        ((ร byte b =) (.at (:bb_str bp) (:bh_index buf)))

        (when (and advance (== (.at (:bb_str bp) (ร ++buf.bh_index)) NUL))
            ((ร buf.bh_first.bb_next =) (:bb_next bp))
            ((ร buf.bh_index =) 0)
        )

        b
    ))

;; Get one byte from the read buffers.
;; Use readbuf1 one first, use readbuf2 if that one is empty.
;; If advance == true go to the next char.
;; No translation is done KB_SPECIAL is escaped.

(defn- #_byte read-readbuffers [#_boolean advance]
    (ยง
        ((ร byte b =) (read-readbuf @readbuf1, advance))
        (if (== b NUL)
            ((ร b =) (read-readbuf @readbuf2, advance))
        )
        b
    ))

;; Prepare the read buffers for reading (if they contain something).

(defn- #_void start-stuff []
    (ยง
        (when (non-nil? (:bb_next (:bh_first @readbuf1)))
            ((ร @readbuf1.bh_curr =) (:bh_first @readbuf1))
            ((ร @readbuf1.bh_space =) 0)
        )
        (when (non-nil? (:bb_next (:bh_first @readbuf2)))
            ((ร @readbuf2.bh_curr =) (:bh_first @readbuf2))
            ((ร @readbuf2.bh_space =) 0)
        )
        nil
    ))

;; Return true if the stuff buffer is empty.

(defn- #_boolean stuff-empty []
    (and (nil? (:bb_next (:bh_first @readbuf1))) (nil? (:bb_next (:bh_first @readbuf2)))))

;; Set a typeahead character that won't be flushed.

(defn- #_void typeahead-noflush [#_int c]
    (reset! typeahead_char c)
    nil)

;; Remove the contents of the stuff buffer and the mapped characters
;; in the typeahead buffer (used in case of an error).
;; If "flush_typeahead" is true, flush all typeahead characters
;; (used when interrupted by a CTRL-C).

(defn- #_void flush-buffers [#_boolean flush_typeahead]
    (ยง
        (init-typebuf)

        (start-stuff)
        (while (!= (read-readbuffers true) NUL)
            ;
        )

        (when flush_typeahead            ;; remove all typeahead
            ;; We have to get all characters, because we may delete the first part of an escape sequence.
            ;; In an xterm we get one char at a time and we have to get them all.

            (while (!= (inchar (:tb_buf @typebuf), (- (:tb_buflen @typebuf) 1), 10, (:tb_change_cnt @typebuf)) 0)
                ;
            )
            ((ร @typebuf.tb_off =) MAXMAPLEN)
            ((ร @typebuf.tb_len =) 0)
        )
        nil
    ))

;; The previous contents of the redo buffer is kept in old_redobuffer.
;; This is used for the CTRL-O <.> command in insert mode.

(defn- #_void resetRedobuff []
    (ยง
        (when (not @block_redo)
            (free-buff @old_redobuff)
            (COPY-buffheader @old_redobuff, @redobuff)
            ((ร @redobuff.bh_first.bb_next =) nil)
        )
        nil
    ))

;; Discard the contents of the redo buffer and restore the previous redo buffer.

(defn- #_void cancelRedo []
    (ยง
        (when (not @block_redo)
            (free-buff @redobuff)
            (COPY-buffheader @redobuff, @old_redobuff)
            ((ร @old_redobuff.bh_first.bb_next =) nil)
            (start-stuff)
            (while (!= (read-readbuffers true) NUL)
                ;
            )
        )
        nil
    ))

;; Append "s" to the redo buffer.
;; KB_SPECIAL should already have been escaped.

(defn- #_void appendToRedobuff [#_Bytes s]
    (when (not @block_redo)
        (add-buff @redobuff, s, -1)
    )
    nil)

;; Append to Redo buffer literally, escaping special characters with CTRL-V.
;; KB_SPECIAL is escaped as well.

(defn- #_void appendToRedobuffLit [#_Bytes str, #_int len]
    ;; len: length of "str" or -1 for up to the NUL
    (ยง
        (if @block_redo
            ((ร RETURN) nil)
        )

; %%    ((ร FOR) (ร ((ร Bytes[] s =) (ร { str })) (if (< len 0) (non-eos? (... s 0)) (< (BDIFF (... s 0), str) len)) nil)
            ;; Put a string of normal characters in the redo buffer (that's faster).
            ((ร Bytes start =) (... s 0))
            (while (and (<= (byte \space) (.at (... s 0) 0)) (< (.at (... s 0) 0) DEL) (or (< len 0) (< (BDIFF (... s 0), str) len)))
                ((ร s[0] =) (.plus (... s 0) 1))
            )

            ;; Don't put '0' or '^' as last character, just in case a CTRL-D is typed next.
            (if (and (eos? (... s 0)) (or (== (.at (... s 0) -1) (byte \0)) (== (.at (... s 0) -1) (byte \^))))
                ((ร s[0] =) (.minus (... s 0) 1))
            )
            (if (BLT start, (... s 0))
                (add-buff @redobuff, start, (BDIFF (... s 0), start)))

            (if (or (eos? (... s 0)) (and (<= 0 len) (<= len (BDIFF (... s 0), str))))
                (ร BREAK)
            )

            ;; Handle a special or multibyte character.
            ;; Handle composing chars separately.
            ((ร int c =) (us-ptr2char-adv s, false))
            (if (or (< c (byte \space)) (== c DEL) (and (eos? (... s 0)) (or (== c (byte \0)) (== c (byte \^)))))
                (add-char-buff @redobuff, Ctrl_V))

            ;; CTRL-V '0' must be inserted as CTRL-V 048
            (if (and (eos? (... s 0)) (== c (byte \0)))
                (add-buff @redobuff, (u8 "048"), 3)
                (add-char-buff @redobuff, c))
; %%    )
        nil
    ))

;; Append a character to the redo buffer.
;; Translates special keys, NUL, KB_SPECIAL and multibyte characters.

(defn- #_void appendCharToRedobuff [#_int c]
    (when (not @block_redo)
        (add-char-buff @redobuff, c)
    )
    nil)

;; Append a number to the redo buffer.

(defn- #_void appendNumberToRedobuff [#_long n]
    (when (not @block_redo)
        (add-num-buff @redobuff, n)
    )
    nil)

;; Append string "s" to the stuff buffer.
;; KB_SPECIAL must already have been escaped.

(defn- #_void stuffReadbuff [#_Bytes s]
    (add-buff @readbuf1, s, -1)
    nil)

;; Append string "s" to the redo stuff buffer.
;; KB_SPECIAL must already have been escaped.

(defn- #_void stuffRedoReadbuff [#_Bytes s]
    (add-buff @readbuf2, s, -1)
    nil)

(defn- #_void stuffReadbuffLen [#_Bytes s, #_long len]
    (add-buff @readbuf1, s, len)
    nil)

;; Append a character to the stuff buffer.
;; Translates special keys, NUL, KB_SPECIAL and multibyte characters.

(defn- #_void stuffcharReadbuff [#_int c]
    (add-char-buff @readbuf1, c)
    nil)

;; Append a number to the stuff buffer.

(defn- #_void stuffnumReadbuff [#_long n]
    (add-num-buff @readbuf1, n)
    nil)

(atom! buffblock_C redo_bp)
(atom! Bytes redo_sp)

;; Prepare for redo; return false if nothing to redo, true otherwise.
;; If old_redo is true, use old_redobuff instead of redobuff.

(defn- #_boolean init-redo [#_boolean old_redo]
    (ยง
        (reset! redo_bp (:bb_next (:bh_first (if old_redo @old_redobuff @redobuff))))
        (cond (nil? @redo_bp)
        (do
            false
        )
        :else
        (do
            (reset! redo_sp (:bb_str @redo_bp))
            true
        ))
    ))

;; Read a character from the redo buffer.
;; Translates KB_SPECIAL and multibyte characters.
;; The redo buffer is left as it is.

(defn- #_int read-redo []
    (ยง
        (when (non-eos? @redo_sp)
            ;; For a multi-byte character get all the bytes and return the converted character.
            ((ร int n =) (if (or (!= (.at @redo_sp 0) KB_SPECIAL) (== (.at @redo_sp 1) KS_SPECIAL)) (mb-byte2len (char_u (.at @redo_sp 0))) 1))

            ((ร Bytes buf =) (Bytes. (inc MB_MAXBYTES)))

            ((ร FOR) (ร ((ร int i =) 0) true (ร i++))
                (ร int c)
                (cond (== (.at @redo_sp 0) KB_SPECIAL)   ;; special key or escaped KB_SPECIAL
                (do
                    ((ร c =) (toSpecial (.at @redo_sp 1), (.at @redo_sp 2)))
                    (reset! redo_sp (.plus @redo_sp 3))
                )
                :else
                (do
                    ((ร c =) (char_u (.at @redo_sp 0)))
                    (reset! redo_sp (.plus @redo_sp 1))
                ))

                (when (and (eos? @redo_sp) (non-nil? (:bb_next @redo_bp)))
                    (reset! redo_bp (:bb_next @redo_bp))
                    (reset! redo_sp (:bb_str @redo_bp))
                )

                (.be buf i, c)
                (when (== i (dec n))                 ;; last byte of a character
                    (if (!= n 1)
                        ((ร c =) (us-ptr2char buf))
                    )
                    ((ร RETURN) c)
                )

                (if (eos? @redo_sp)          ;; cannot happen?
                    (ร BREAK)
                )
            )
        )

        NUL
    ))

;; Stuff the redo buffer into readbuf2.
;; Insert the redo count into the command.
;; If "old_redo" is true, the last but one command is repeated
;; instead of the last command (inserting text).
;; This is used for CTRL-O <.> in insert mode.
;;
;; Return false for failure, true otherwise.

(defn- #_boolean start-redo [#_long count, #_boolean old_redo]
    (ยง
        ;; init the pointers; return if nothing to redo
        (if (not (init-redo old_redo))
            ((ร RETURN) false)
        )

        ((ร int c =) (read-redo))

        ;; copy the buffer name, if present
        (when (== c (byte \"))
            (add-buff @readbuf2, (u8 "\""), 1)
            ((ร c =) (read-redo))

            ;; if a numbered buffer is used, increment the number
            (if (and (<= (byte \1) c) (< c (byte \9)))
                (ร c++)
            )
            (add-char-buff @readbuf2, c)
            ((ร c =) (read-redo))
        )

        (when (== c (byte \v))   ;; redo Visual
            (COPY-pos @VIsual, (:w_cursor @curwin))
            (reset! VIsual_active true)
            (reset! VIsual_select false)
            (reset! VIsual_reselect true)
            (reset! redo_VIsual_busy true)
            ((ร c =) (read-redo))
        )

        ;; try to enter the count (in place of a previous count)
        (when (non-zero? count)
            (while (asc-isdigit c)  ;; skip "old" count
                ((ร c =) (read-redo))
            )
            (add-num-buff @readbuf2, count)
        )

        ;; copy from the redo buffer into the stuff buffer
        (add-char-buff @readbuf2, c)
        (while (!= ((ร c =) (read-redo)) NUL)
            (add-char-buff @readbuf2, c)
        )

        true
    ))

;; Repeat the last insert (R, o, O, a, A, i or I command) by stuffing the redo buffer into readbuf2.
;; Return false for failure, true otherwise.

(defn- #_boolean start-redo-ins []
    (ยง
        (if (not (init-redo false))
            ((ร RETURN) false)
        )

        (start-stuff)

        ;; skip the count and the command character
        ((ร FOR) (ร (ร int c) (!= ((ร c =) (read-redo)) NUL) nil)
            (when (non-nil? (vim-strchr (u8 "AaIiRrOo"), c))
                (if (or (== c (byte \O)) (== c (byte \o)))
                    (add-buff @readbuf2, NL_STR, -1))
                (ร BREAK)
            )
        )

        ;; copy the typed text from the redo buffer into the stuff buffer
        ((ร FOR) (ร (ร int c) (!= ((ร c =) (read-redo)) NUL) nil)
            (add-char-buff @readbuf2, c)
        )

        (reset! block_redo true)
        true
    ))

(defn- #_void stop-redo-ins []
    (reset! block_redo false)
    nil)

(final int TYPELEN_INIT    (* 5 (+ MAXMAPLEN 3)))

;; Initialize typebuf.

(defn- #_void init-typebuf []
    (ยง
        (when (nil? (:tb_buf @typebuf))
            ((ร @typebuf.tb_buf =) (Bytes. TYPELEN_INIT))
            ((ร @typebuf.tb_buflen =) TYPELEN_INIT)
            ((ร @typebuf.tb_len =) 0)
            ((ร @typebuf.tb_off =) 0)
            ((ร @typebuf.tb_change_cnt =) 1)
        )
        nil
    ))

;; Insert a string in the typeahead buffer.

(defn- #_void ins-typebuf [#_Bytes str]
    (ยง
        (init-typebuf)
        (if (zero? (ร ++@typebuf.tb_change_cnt))
            ((ร @typebuf.tb_change_cnt =) 1)
        )

        ((ร int addlen =) (STRLEN str))

        ;; Easy case: there is room in front of typebuf.tb_buf[typebuf.tb_off]

        (cond (<= addlen (:tb_off @typebuf))
        (do
            ((ร @typebuf.tb_off =) (- (:tb_off @typebuf) addlen))
            (BCOPY (:tb_buf @typebuf), (:tb_off @typebuf), str, 0, addlen)
        )
        :else
        (do
            ;; Need to allocate a new buffer.
            ;; In typebuf.tb_buf there must always be room for 3 * MAXMAPLEN + 4 characters.
            ;; We add some extra room to avoid having to allocate too often.

            ((ร int newoff =) (+ MAXMAPLEN 4))
            ((ร int newlen =) (+ (:tb_len @typebuf) addlen newoff (* 4 (+ MAXMAPLEN 4))))

            ((ร Bytes newbuf =) (Bytes. newlen))
            ((ร @typebuf.tb_buflen =) newlen)

            ;; copy the new chars
            (BCOPY newbuf, newoff, str, 0, addlen)
            ;; copy the old chars, after the insertion point, including the NUL at the end
            (BCOPY newbuf, (+ newoff addlen), (:tb_buf @typebuf), (:tb_off @typebuf), (+ (:tb_len @typebuf) 1))

            ((ร @typebuf.tb_buf =) newbuf)
            ((ร @typebuf.tb_off =) newoff)
        ))

        ((ร @typebuf.tb_len =) (+ (:tb_len @typebuf) addlen))
        nil
    ))

;; Put character "c" back into the typeahead buffer.
;; Can be used for a character obtained by vgetc() that needs to be put back.
;; Uses keyTyped to restore the flags belonging to the char.

(defn- #_void ins-char-typebuf [#_int c]
    (ยง
        ((ร Bytes buf =) (Bytes. (inc MB_MAXBYTES)))

        (cond (is-special c)
        (do
            (.be buf 0, KB_SPECIAL)
            (.be buf 1, (KB-SECOND c))
            (.be buf 2, (KB-THIRD c))
            (eos! buf 3)
        )
        :else
        (do
            (.be buf (utf-char2bytes c, buf), NUL)
        ))

        (ins-typebuf buf)
        nil
    ))

;; Return true if the typeahead buffer was changed (while waiting for a character to arrive).
;; Happens when a message was received from a client or from feedkeys().
;; But check in a more generic way to avoid trouble: When "typebuf.tb_buf"
;; changed it was reallocated and the old pointer can no longer be used.
;; Or "typebuf.tb_off" may have been changed and we would overwrite characters that was just added.

(defn- #_boolean typebuf-changed [#_int cnt]
    ;; cnt: old value of typebuf.tb_change_cnt
    (and (non-zero? cnt) (!= (:tb_change_cnt @typebuf) cnt)))

;; remove "len" characters from typebuf.tb_buf[typebuf.tb_off]

(defn- #_void del-typebuf [#_int len]
    (ยง
        (if (zero? len)
            ((ร RETURN) nil)         ;; nothing to do
        )

        ((ร @typebuf.tb_len =) (- (:tb_len @typebuf) len))

        (cond (<= (+ (* 3 MAXMAPLEN) 3) (- (:tb_buflen @typebuf) (+ (:tb_off @typebuf) len)))
        (do
            ((ร @typebuf.tb_off =) (+ (:tb_off @typebuf) len))
        )
        :else
        (do
            ((ร int i =) (:tb_off @typebuf))

            ;; Leave some extra room at the end to avoid reallocation.

            (if (< MAXMAPLEN (:tb_off @typebuf))
                ((ร @typebuf.tb_off =) MAXMAPLEN)
            )

            ;; adjust typebuf.tb_buf (include the NUL at the end)
            (BCOPY (:tb_buf @typebuf), (:tb_off @typebuf), (:tb_buf @typebuf), (+ i len), (+ (:tb_len @typebuf) 1))
        ))

        (when (zero? (ร ++@typebuf.tb_change_cnt))
            ((ร @typebuf.tb_change_cnt =) 1)
        )
        nil
    ))

;; Write typed characters to script file.
;; If recording is on put the character in the recordbuffer.

(defn- #_void gotchars [#_Bytes chars, #_int len]
    (ยง
        ((ร Bytes buf =) (Bytes. 2))

        ;; Remember how many chars were last recorded.
        (if @Recording
            ((ร @last_recorded_len =) (+ @last_recorded_len len))
        )

        (dotimes [#_int i len]
            ;; Handle one byte at a time; no translation to be done.
            ((ร byte c =) (.at chars i))
            (updatescript c)

            (when @Recording
                (.be buf 0, c)
                (add-buff @recordbuff, buf, 1)
            )
        )
        (may-sync-undo)

        ;; Since characters have been typed, consider the following to be in another mapping.
        ;; Search string will be kept in history.
        (swap! maptick inc)
        nil
    ))

;; Sync undo.  Called when typed characters are obtained from the typeahead
;; buffer, or when a menu is used.
;; Do not sync:
;; - In Insert mode, unless cursor key has been used.
;; - While reading a script file.
;; - When no_u_sync is non-zero.

(defn- #_void may-sync-undo []
    (when (or (non-flag? @State (+ INSERT CMDLINE)) @arrow_used)
        (u-sync false)
    )
    nil)

(atom! int old_char         -1) ;; character put back by vungetc()
(atom! int old_mod_mask)        ;; mod_mask for ungotten character

;; This function is called just before doing a blocking wait.
;; Thus after waiting 'updatetime' for a character to arrive.

(defn- #_void before-blocking []
    (updatescript NUL)
    nil)

;; updatescipt() is called when a character can be written into the script file
;; or when we have waited some time for a character (c == 0)

(defn- #_void updatescript [#_byte c]
    (ยง
;       
        nil
    ))

;; Get the next input character.
;; Can return a special key or a multi-byte character.
;; Can return NUL when called recursively, use safe-vgetc() if that's not wanted.
;; This translates escaped KB_SPECIAL bytes to a KB_SPECIAL byte.
;; Collects the bytes of a multibyte character into the whole character.
;; Returns the modifiers in the global "mod_mask".

(defn- #_int vgetc []
    (ยง
        (ร int c)

        ;; If a character was put back with vungetc, it was already processed.
        ;; Return it directly.

        (cond (!= @old_char -1)
        (do
            ((ร c =) @old_char)
            (reset! old_char -1)
            (reset! mod_mask @old_mod_mask)
        )
        :else
        (do
            ((ร Bytes buf =) (Bytes. (inc MB_MAXBYTES)))

            (reset! mod_mask 0)
            (reset! last_recorded_len 0)

            (while true                     ;; this is done twice if there are modifiers
                (when (non-zero? @mod_mask)          ;; no mapping after modifier has been read
                    (swap! no_mapping inc)
                    (swap! allow_keys inc)
                )
                ((ร c =) (vgetorpeek true))
                (when (non-zero? @mod_mask)
                    (swap! no_mapping dec)
                    (swap! allow_keys dec)
                )

                ;; Get two extra bytes for special keys.
                (when (== c (char_u KB_SPECIAL))
                    ((ร int save_allow_keys =) @allow_keys)

                    (swap! no_mapping inc)
                    (reset! allow_keys 0)                 ;; make sure BS is not found
                    ((ร int c2 =) (vgetorpeek true))      ;; no mapping for these chars
                    ((ร c =) (vgetorpeek true))
                    (swap! no_mapping dec)
                    (reset! allow_keys save_allow_keys)

                    (when (== c2 (char_u KS_MODIFIER))
                        (reset! mod_mask c)
                        (ร CONTINUE)
                    )
                    ((ร c =) (toSpecial (byte c2), (byte c)))
                )

                ;; a keypad or special function key was not mapped, use it like its ASCII equivalent
                ((ร SWITCH) c
                    ((ร CASE) K_KPLUS)
                    (do
                        ((ร c =) (byte \+))
                        (ร BREAK)
                    )
                    ((ร CASE) K_KMINUS)
                    (do
                        ((ร c =) (byte \-))
                        (ร BREAK)
                    )
                    ((ร CASE) K_KDIVIDE)
                    (do
                        ((ร c =) (byte \/))
                        (ร BREAK)
                    )
                    ((ร CASE) K_KMULTIPLY)
                    (do
                        ((ร c =) (byte \*))
                        (ร BREAK)
                    )
                    ((ร CASE) K_KENTER)
                    (do
                        ((ร c =) CAR)
                        (ร BREAK)
                    )
                    ((ร CASE) K_KPOINT)
                    (do
                        ((ร c =) (byte \.))
                        (ร BREAK)
                    )
                    ((ร CASE) K_K0)
                    (do
                        ((ร c =) (byte \0))
                        (ร BREAK)
                    )
                    ((ร CASE) K_K1)
                    (do
                        ((ร c =) (byte \1))
                        (ร BREAK)
                    )
                    ((ร CASE) K_K2)
                    (do
                        ((ร c =) (byte \2))
                        (ร BREAK)
                    )
                    ((ร CASE) K_K3)
                    (do
                        ((ร c =) (byte \3))
                        (ร BREAK)
                    )
                    ((ร CASE) K_K4)
                    (do
                        ((ร c =) (byte \4))
                        (ร BREAK)
                    )
                    ((ร CASE) K_K5)
                    (do
                        ((ร c =) (byte \5))
                        (ร BREAK)
                    )
                    ((ร CASE) K_K6)
                    (do
                        ((ร c =) (byte \6))
                        (ร BREAK)
                    )
                    ((ร CASE) K_K7)
                    (do
                        ((ร c =) (byte \7))
                        (ร BREAK)
                    )
                    ((ร CASE) K_K8)
                    (do
                        ((ร c =) (byte \8))
                        (ร BREAK)
                    )
                    ((ร CASE) K_K9)
                    (do
                        ((ร c =) (byte \9))
                        (ร BREAK)
                    )

                    ((ร CASE) K_XHOME)
                    ((ร CASE) K_ZHOME)
                    (do
                        (cond (== @mod_mask MOD_MASK_SHIFT)
                        (do
                            ((ร c =) K_S_HOME)
                            (reset! mod_mask 0)
                        )
                        (== @mod_mask MOD_MASK_CTRL)
                        (do
                            ((ร c =) K_C_HOME)
                            (reset! mod_mask 0)
                        )
                        :else
                        (do
                            ((ร c =) K_HOME)
                        ))
                        (ร BREAK)
                    )
                    ((ร CASE) K_XEND)
                    ((ร CASE) K_ZEND)
                    (do
                        (cond (== @mod_mask MOD_MASK_SHIFT)
                        (do
                            ((ร c =) K_S_END)
                            (reset! mod_mask 0)
                        )
                        (== @mod_mask MOD_MASK_CTRL)
                        (do
                            ((ร c =) K_C_END)
                            (reset! mod_mask 0)
                        )
                        :else
                        (do
                            ((ร c =) K_END)
                        ))
                        (ร BREAK)
                    )

                    ((ร CASE) K_XUP)
                    (do
                        ((ร c =) K_UP)
                        (ร BREAK)
                    )
                    ((ร CASE) K_XDOWN)
                    (do
                        ((ร c =) K_DOWN)
                        (ร BREAK)
                    )
                    ((ร CASE) K_XLEFT)
                    (do
                        ((ร c =) K_LEFT)
                        (ร BREAK)
                    )
                    ((ร CASE) K_XRIGHT)
                    (do
                        ((ร c =) K_RIGHT)
                        (ร BREAK)
                    )
                )

                ;; For a multi-byte character get all the bytes and return the converted character.
                ;; Note: This will loop until enough bytes are received!

                ((ร int n =) (mb-byte2len c))
                (when (< 1 n)
                    (swap! no_mapping inc)
                    (.be buf 0, c)
                    ((ร FOR) (ร ((ร int i =) 1) (< i n) (ร i++))
                        (.be buf i, (vgetorpeek true))
                        (when (== (.at buf i) KB_SPECIAL)
                            ;; Must be a KB_SPECIAL - KS_SPECIAL - KE_FILLER sequence,
                            ;; which represents a KB_SPECIAL (0x80).
                            ((ร c =) (vgetorpeek true))
                        )
                    )
                    (swap! no_mapping dec)
                    ((ร c =) (us-ptr2char buf))
                )

                (ร BREAK)
            )
        ))

        c
    ))

;; Like vgetc(), but never return a NUL when called recursively,
;; get a key directly from the user (ignoring typeahead).

(defn- #_int safe-vgetc []
    (ยง
        ((ร int c =) (vgetc))
        (if (== c NUL)
            ((ร c =) (get-keystroke))
        )
        c
    ))

;; Like safe-vgetc(), but loop to handle K_IGNORE.
;; Also ignore scrollbar events.

(defn- #_int plain-vgetc []
    (ยง
        (ร int c)

;       do
;       {
            ((ร c =) (safe-vgetc))
;       } while (c == K_IGNORE || c == K_VER_SCROLLBAR || c == K_HOR_SCROLLBAR);

        c
    ))

;; Check if a character is available, such that vgetc() will not block.
;; If the next character is a special character or multi-byte, the returned character is not valid!

(defn- #_int vpeekc []
    (ยง
        (if (!= @old_char -1)
            ((ร RETURN) @old_char)
        )

        (vgetorpeek false)
    ))

;; Call vpeekc() without causing anything to be mapped.
;; Return true if a character is available, false otherwise.

(defn- #_boolean char-avail []
    (ยง
        (ร int retval)

        (swap! no_mapping inc)
        ((ร retval =) (vpeekc))
        (swap! no_mapping dec)

        (!= retval NUL)
    ))

;; unget one character (can only be done once!)
(defn- #_void vungetc [#_int c]
    (reset! old_char c)
    (reset! old_mod_mask @mod_mask)
    nil)

(atom! int __tc)

;; get a character:
;; 1. from the stuffbuffer
;;      This is used for abbreviated commands like "D" -> "d$".
;;      Also used to redo a command for ".".
;; 2. from the typeahead buffer
;;      Stores text obtained previously but not used yet.
;;      Also stores the result of mappings.
;;      Also used for the ":normal" command.
;; 3. from the user
;;      This may do a blocking wait if "advance" is true.
;;
;; if "advance" is true (vgetc()):
;;      really get the character.
;;      keyTyped is set to true in the case the user typed the key.
;;      keyStuffed is true if the character comes from the stuff buffer.
;; if "advance" is false (vpeekc()):
;;      just look whether there is a character available.
;;
;; When "no_mapping" is zero, checks for mappings in the current mode.
;; Only returns one byte (of a multi-byte character).
;; KB_SPECIAL may be escaped, need to get two more bytes then.

(defn- #_int vgetorpeek [#_boolean advance]
    (ยง
        ;; This function doesn't work very well when called recursively.
        ;; It may happen though, because of:
        ;;
        ;; 1. The call to add-to-showcmd(). char-avail() is then used to check
        ;; if there is a character available, which calls this function.
        ;; In that case we must return NUL, to indicate no character is available.
        ;;
        ;; 2. A GUI callback function writes to the screen, causing a wait-return().
        ;; Using ":normal" can also do this, but it saves the typeahead buffer,
        ;; thus it should be OK.  But don't get a key from the user then.

        (if (< 0 @vgetc_busy)
            ((ร RETURN) NUL)
        )

        (swap! vgetc_busy inc)

        (if advance
            (reset! keyStuffed false))

        (init-typebuf)
        (start-stuff)
        (if advance
            (reset! execReg false))

        ((ร boolean timedout =) false)       ;; waited for more than 1 second for mapping to complete
        ((ร int mapdepth =) 0)               ;; check for recursive mapping
        ((ร boolean mode_deleted =) false)   ;; set when mode has been deleted

        (ร int c)

;       do
;       {
;; get a character: 1. from the stuffbuffer

            (cond (non-zero? @typeahead_char)
            (do
                ((ร c =) @typeahead_char)
                (if advance
                    (reset! typeahead_char 0))
            )
            :else
            (do
                ((ร c =) (char_u (read-readbuffers advance)))
            ))

            (cond (and (!= c NUL) (not @got_int))
            (do
                (when advance
                    ;; keyTyped = false;
                    ;; When the command that stuffed something was typed,
                    ;; behave like the stuffed command was typed;
                    ;; needed e.g. for CTRL-W CTRl-] to open a fold.
                    (reset! keyStuffed true)
                )
            )
            :else
            (do
                ;; Loop until we either find a matching mapped key,
                ;; or we are sure that it is not a mapped key.
                ;; If a mapped key sequence is found, we go back to the start to try re-mapping.

                (while true
                    (ui-breakcheck)            ;; check for CTRL-C

                    (when @got_int
                        ;; flush all input
                        ((ร int len =) (inchar (:tb_buf @typebuf), (- (:tb_buflen @typebuf) 1), 0, (:tb_change_cnt @typebuf)))

                        ;; If inchar() returns true (script file was active)
                        ;; or we are inside a mapping, get out of insert mode.
                        ;; Otherwise we behave like having gotten a CTRL-C.
                        ;; As a result typing CTRL-C in insert mode will really insert a CTRL-C.

                        ((ร c =) (if (and (non-zero? len) (flag? @State (+ INSERT CMDLINE))) ESC Ctrl_C))

                        (flush-buffers true)        ;; flush all typeahead

                        (when advance
                            ;; Also record this character, it might be needed to get out of Insert mode.
                            (.be (:tb_buf @typebuf) 0, c)
                            (gotchars (:tb_buf @typebuf), 1)
                        )

                        (ร BREAK)
                    )

                    ((ร int keylen =) 0)

                    (when (< 0 (:tb_len @typebuf))
                        ;; When no matching mapping found or found a non-matching mapping
                        ;; that matches at least what the matching mapping matched:
                        ;; Check if we have a terminal code, when:
                        ;; - mapping is allowed,
                        ;; - keys have not been mapped,
                        ;; - and when not timed out.

                        (when (and (or (zero? @no_mapping) (non-zero? @allow_keys)) (not timedout))
                            ((ร keylen =) (check-termcode nil, 0, nil))

                            ;; When getting a partial match, but the last characters were not typed,
                            ;; don't wait for a typed character to complete the termcode.
                            ;; This helps a lot when a ":normal" command ends in an ESC.

                            (if (and (< keylen 0) (zero? (:tb_len @typebuf)))
                                ((ร keylen =) 0)
                            )
                        )

                        (when (zero? keylen)        ;; no matching terminal code
;; get a character: 2. from the typeahead buffer

                            ((ร c =) (& (.at (:tb_buf @typebuf) (:tb_off @typebuf)) 0xff))
                            (when advance    ;; remove chars from tb_buf
                                (reset! keyTyped true)
                                ;; write char to script file(s)
                                (gotchars (.plus (:tb_buf @typebuf) (:tb_off @typebuf)), 1)

                                (del-typebuf 1)
                            )
                            (ร BREAK)          ;; got character, break for loop
                        )

                        (when (< 0 keylen)         ;; full matching terminal code
                            (ร CONTINUE)           ;; try mapping again
                        )

                        ;; Partial match: get some more characters.
                        ((ร keylen =) KEYLEN_PART_KEY)
                    )

;; get a character: 3. from the user - handle <Esc> in Insert mode

                    ;; Special case: if we get an <ESC> in insert mode and there are no more
                    ;; characters at once, we pretend to go out of insert mode.  This prevents
                    ;; the one second delay after typing an <ESC>.  If we get something after
                    ;; all, we may have to redisplay the mode.  That the cursor is in the wrong
                    ;; place does not matter.

                    ((ร int len =) 0)
                    ((ร int new_wcol =) (:w_wcol @curwin))
                    ((ร int new_wrow =) (:w_wrow @curwin))
                    (when (and advance (== (:tb_len @typebuf) 1) (== (.at (:tb_buf @typebuf) (:tb_off @typebuf)) ESC) (zero? @no_mapping) (flag? @State INSERT) (or @p_timeout (and (== keylen KEYLEN_PART_KEY) @p_ttimeout)) (zero? ((ร len =) (inchar (.plus (:tb_buf @typebuf) (+ (:tb_off @typebuf) (:tb_len @typebuf))), 3, 25, (:tb_change_cnt @typebuf)))))
                        (when @mode_displayed
                            (unshowmode true)
                            ((ร mode_deleted =) true)
                        )
                        (validate-cursor)
                        ((ร int old_wcol =) (:w_wcol @curwin))
                        ((ร int old_wrow =) (:w_wrow @curwin))

                        ;; move cursor left, if possible
                        (when (non-zero? (:col (:w_cursor @curwin)))
                            ((ร int col =) 0)
                            (cond (< 0 (:w_wcol @curwin))
                            (do
                                (cond @did_ai
                                (do
                                    ;; We are expecting to truncate the trailing white-space,
                                    ;; so find the last non-white character.

                                    ((ร col =) (ร @curwin.w_wcol =) 0)
                                    ((ร Bytes ptr =) (ml-get-curline))
                                    ((ร FOR) (ร ((ร int vcol =) col) (< col (:col (:w_cursor @curwin))) nil)
                                        (if (not (vim-iswhite (.at ptr col)))
                                            ((ร @curwin.w_wcol =) vcol)
                                        )
                                        ((ร vcol =) (+ vcol (lbr-chartabsize ptr, (.plus ptr col), vcol)))
                                        ((ร col =) (+ col (us-ptr2len-cc (.plus ptr col))))
                                    )
                                    ((ร @curwin.w_wrow =) (+ (:w_cline_row @curwin) (/ (:w_wcol @curwin) (:w_width @curwin))))
                                    ((ร @curwin.w_wcol =) (% (:w_wcol @curwin) (:w_width @curwin)))
                                    ((ร @curwin.w_wcol =) (+ (:w_wcol @curwin) (curwin-col-off)))
                                    ((ร col =) 0)        ;; no correction needed
                                )
                                :else
                                (do
                                    (ร --@curwin.w_wcol)
                                    ((ร col =) (- (:col (:w_cursor @curwin)) 1))
                                ))
                            )
                            (and @(:wo_wrap (:w_options @curwin)) (< 0 (:w_wrow @curwin)))
                            (do
                                (ร --@curwin.w_wrow)
                                ((ร @curwin.w_wcol =) (- (:w_width @curwin) 1))
                                ((ร col =) (- (:col (:w_cursor @curwin)) 1))
                            ))

                            (when (and (< 0 col) (< 0 (:w_wcol @curwin)))
                                ;; Correct when the cursor is on the right halve of a double-wide character.
                                ((ร Bytes p =) (ml-get-curline))
                                ((ร col =) (- col (us-head-off p, (.plus p col))))
                                (if (< 1 (us-ptr2cells (.plus p col)))
                                    (ร --@curwin.w_wcol)
                                )
                            )
                        )
                        (setcursor)
                        (out-flush)
                        ((ร new_wcol =) (:w_wcol @curwin))
                        ((ร new_wrow =) (:w_wrow @curwin))
                        ((ร @curwin.w_wcol =) old_wcol)
                        ((ร @curwin.w_wrow =) old_wrow)
                    )
                    (if (< len 0)
                        (ร CONTINUE)   ;; end of input script reached
                    )

                    ((ร @typebuf.tb_len =) (+ (:tb_len @typebuf) len))

                    ;; buffer full, don't map
                    (when (<= MAXMAPLEN (:tb_len @typebuf))
                        ((ร timedout =) true)
                        (ร CONTINUE)
                    )

;; get a character: 3. from the user - update display

                    ;; In insert mode a screen update is skipped when characters are still available.
                    ;; But when those available characters are part of a mapping, and we are going
                    ;; to do a blocking wait here.  Need to update the screen to display the changed
                    ;; text so far.  Also for when 'lazyredraw' is set and redrawing was postponed
                    ;; because there was something in the input buffer (e.g., termresponse).

                    (when (and (or (flag? @State INSERT) @p_lz) (non-flag? @State CMDLINE) advance (non-zero? @must_redraw) (not @need_wait_return))
                        (update-screen 0)
                        (setcursor)            ;; put cursor back where it belongs
                    )

                    ;; If we have a partial match (and are going to wait for more input from the user),
                    ;; show the partially matched characters to the user with showcmd.

                    ((ร int i =) 0)
                    ((ร int c1 =) 0)
                    (when (and (< 0 (:tb_len @typebuf)) advance)
                        (when (and (flag? @State (| NORMAL INSERT)) (!= @State HITRETURN))
                            ;; this looks nice when typing a dead character map
                            (when (and (flag? @State INSERT) (== (mb-ptr2cells (.plus (:tb_buf @typebuf) (- (+ (:tb_off @typebuf) (:tb_len @typebuf)) 1))) 1))
                                (edit-putchar (.at (:tb_buf @typebuf) (- (+ (:tb_off @typebuf) (:tb_len @typebuf)) 1)), false)
                                (setcursor)    ;; put cursor back where it belongs
                                ((ร c1 =) 1)
                            )
                            ;; need to use the col and row from above here
                            ((ร int old_wcol =) (:w_wcol @curwin))
                            ((ร int old_wrow =) (:w_wrow @curwin))
                            ((ร @curwin.w_wcol =) new_wcol)
                            ((ร @curwin.w_wrow =) new_wrow)
                            (push-showcmd)
                            (if (< SHOWCMD_COLS (:tb_len @typebuf))
                                ((ร i =) (- (:tb_len @typebuf) SHOWCMD_COLS))
                            )
                            ((ร FOR) (ร nil (< i (:tb_len @typebuf)) (ร i++))
                                (add-to-showcmd (.at (:tb_buf @typebuf) (+ (:tb_off @typebuf) i)))
                            )
                            ((ร @curwin.w_wcol =) old_wcol)
                            ((ร @curwin.w_wrow =) old_wrow)
                        )

                        ;; this looks nice when typing a dead character map
                        (when (and (flag? @State CMDLINE) (zero? @cmdline_star) (== (mb-ptr2cells (.plus (:tb_buf @typebuf) (- (+ (:tb_off @typebuf) (:tb_len @typebuf)) 1))) 1))
                            (putcmdline (.at (:tb_buf @typebuf) (- (+ (@typebuf.tb_off) (@typebuf.tb_len)) 1)), false)
                            ((ร c1 =) 1)
                        )
                    )

;; get a character: 3. from the user - get it

                    ((ร int wait_tb_len =) (:tb_len @typebuf))
                    ((ร len =) (inchar (.plus (:tb_buf @typebuf) (+ (:tb_off @typebuf) (:tb_len @typebuf))), (- (:tb_buflen @typebuf) (:tb_off @typebuf) (:tb_len @typebuf) 1), (if (not advance) 0 (if (or (zero? (:tb_len @typebuf)) (not (or @p_timeout (and @p_ttimeout (== keylen KEYLEN_PART_KEY))))) -1 (if (and (== keylen KEYLEN_PART_KEY) (<= 0 @p_ttm)) @p_ttm @p_tm))), (:tb_change_cnt @typebuf)))

                    (if (non-zero? i)
                        (pop-showcmd))
                    (when (== c1 1)
                        (if (flag? @State INSERT)
                            (edit-unputchar))
                        (if (flag? @State CMDLINE)
                            (unputcmdline)
                            (setcursor))            ;; put cursor back where it belongs
                    )

                    (if (< len 0)
                        (ร CONTINUE)                   ;; end of input script reached
                    )
                    (cond (zero? len)                   ;; no character available
                    (do
                        (when (not advance)
                            ((ร c =) NUL)
                            (ร BREAK)
                        )
                        (when (< 0 wait_tb_len)        ;; timed out
                            ((ร timedout =) true)
                            (ร CONTINUE)
                        )
                    )
                    :else
                    (do
                        (while (!= (.at (:tb_buf @typebuf) (+ (:tb_off @typebuf) (:tb_len @typebuf))) NUL)
                            (ร @typebuf.tb_len++)
                        )
                    ))
                )
            ))
;       } while (c < 0 || (advance && c == NUL));   ;; if advance is false don't loop on NULs

        ;; The "INSERT" message is taken care of here:
        ;;   if we return an ESC to exit insert mode, the message is deleted;
        ;;   if we don't return an ESC, but deleted the message before, redisplay it.

        (when (and advance @p_smd (flag? @State INSERT))
            (cond (and (== c ESC) (not mode_deleted) (zero? @no_mapping) @mode_displayed)
            (do
                (if (and (non-zero? (:tb_len @typebuf)) (not @keyTyped))
                    (reset! redraw_cmdline true)          ;; delete mode later
                    (unshowmode false))
            )
            (and (!= c ESC) mode_deleted)
            (do
                (if (and (non-zero? (:tb_len @typebuf)) (not @keyTyped))
                    (reset! redraw_cmdline true)          ;; show mode later
                    (showmode))
            ))
        )

        (swap! vgetc_busy dec)

        c
    ))

;; inchar() - get one character from
;;      1. a scriptfile
;;      2. the keyboard
;;
;; As much characters as we can get (upto 'maxlen') are put in "buf" and
;; NUL terminated (buffer length must be 'maxlen' + 1).
;; Minimum for "maxlen" is 3!!!!
;;
;; "tb_change_cnt" is the value of typebuf.tb_change_cnt if "buf" points into it.
;; When typebuf.tb_change_cnt changes (e.g., when a message is received from
;; a remote client) "buf" can no longer be used.  "tb_change_cnt" is 0 otherwise.
;;
;; If we got an interrupt all input is read until none is available.
;;
;; If wait_time == 0  there is no waiting for the char.
;; If wait_time == n  we wait for n msec for a character to arrive.
;; If wait_time == -1 we wait forever for a character to arrive.
;;
;; Return the number of obtained characters.
;; Return -1 when end of input script reached.

(defn- #_int inchar [#_Bytes buf, #_int maxlen, #_long wait_time, #_int tb_change_cnt]
    ;; wait_time: milli seconds
    (ยง
        (when (or (== wait_time -1) (< 100 wait_time))   ;; flush output before waiting
            (cursor-on)
            (out-flush)
        )

        ((ร int len =) 0)
        ((ร boolean retesc =) false)                     ;; return ESC with gotint

        ;; If we got an interrupt, skip all previously typed characters
        ;; and return true if quit reading script file.
        ;; Stop reading typeahead when a single CTRL-C was read,
        ;; fill-input-buf() returns this when not able to read from stdin.
        ;; Don't use *buf here, closescript() may have freed typebuf.tb_buf[]
        ;; and "buf" may be pointing inside typebuf.tb_buf[].

        (when @got_int
            ((ร final int DUM_LEN =) (+ (* MAXMAPLEN 3) 3))
            ((ร Bytes dum =) (Bytes. (inc DUM_LEN)))

            (while true
                ((ร len =) (ui-inchar dum, DUM_LEN, 0, 0))
                (if (or (zero? len) (and (== len 1) (== (.at dum 0) 3)))
                    (ร BREAK)
                )
            )
            ((ร RETURN) (if retesc 1 0))
        )

        ;; Always flush the output characters when getting input characters from the user.

        (out-flush)

        ;; Fill up to a third of the buffer, because each character may be tripled below.

        ((ร len =) (ui-inchar buf, (/ maxlen 3), wait_time, tb_change_cnt))

        (if (typebuf-changed tb_change_cnt)
            ((ร RETURN) 0)
        )

        (fix-input-buffer buf, len)
    ))

;; Fix typed characters for use by vgetc() and check-termcode().
;; buf[] must have room to triple the number of bytes!
;; Returns the new length.

(defn- #_int fix-input-buffer [#_Bytes buf, #_int len]
    (ยง
        ;; Two characters are special: NUL and KB_SPECIAL.
        ;; Replace        NUL by KB_SPECIAL KS_ZERO    KE_FILLER
        ;; Replace KB_SPECIAL by KB_SPECIAL KS_SPECIAL KE_FILLER

        ((ร Bytes p =) buf)
        ((ร FOR) (ร ((ร int i =) len) (<= 0 (ร --i)) ((ร p =) (.plus p 1)))
            ;; timeout may generate K_CURSORHOLD
            (when (or (eos? p) (and (== (.at p 0) KB_SPECIAL) (or (< i 2) (!= (.at p 1) KS_EXTRA) (!= (.at p 2) KE_CURSORHOLD))))
                (BCOPY p, 3, p, 1, i)
                (.be p 2, (KB-THIRD (char_u (.at p 0))))
                (.be p 1, (KB-SECOND (char_u (.at p 0))))
                (.be p 0, KB_SPECIAL)
                ((ร p =) (.plus p 2))
                ((ร len =) (+ len 2))
            )
        )
        (eos! p)           ;; add trailing NUL

        len
    ))

;; Return true when bytes are in the input buffer or in the typeahead buffer.

(defn- #_boolean input-available []
    (not (is-input-buf-empty)))

;; Escape KB_SPECIAL so that the result can be put in the typeahead buffer.

(defn- #_Bytes vim-strsave-escape-special [#_Bytes p]
    (ยง
        ;; Need a buffer to hold up to three times as much.
        ((ร Bytes res =) (Bytes. (+ (* (STRLEN p) 3) 1)))

        ((ร Bytes d =) res)
        ((ร FOR) (ร ((ร Bytes s =) p) (non-eos? s) nil)
            (cond (and (== (.at s 0) KB_SPECIAL) (non-eos? s 1) (non-eos? s 2))
            (do
                ;; Copy special key unmodified.
                (.be ((ร d =) (.plus d 1)) -1, (.at ((ร s =) (.plus s 1)) -1))
                (.be ((ร d =) (.plus d 1)) -1, (.at ((ร s =) (.plus s 1)) -1))
                (.be ((ร d =) (.plus d 1)) -1, (.at ((ร s =) (.plus s 1)) -1))
            )
            :else
            (do
                ;; Add character, possibly multi-byte to destination, escaping KB_SPECIAL.
                ((ร int c =) (us-ptr2char s))
                ((ร d =) (add-char2buf c, d))
                ((ร FOR) (ร ((ร int len =) (ร utf-char2len(c), end = us-ptr2len-cc(s))) (< len end) ((ร len =) (+ len (utf-char2len c))))
                    ;; Add following combining char.
                    ((ร c =) (us-ptr2char (.plus s len)))
                    ((ร d =) (add-char2buf c, d))
                )
                ((ร s =) (.plus s (us-ptr2len-cc s)))
            ))
        )
        (eos! d)

        res
    ))

;; Remove escaping from KB_SPECIAL characters.
;; Reverse of vim-strsave-escape-special().
;; Works in-place.

(defn- #_void vim-unescape-special [#_Bytes p]
    (ยง
        ((ร Bytes d =) p)
        ((ร FOR) (ร ((ร Bytes s =) p) (non-eos? s) nil)
            (cond (and (== (.at s 0) KB_SPECIAL) (== (.at s 1) KS_SPECIAL) (== (.at s 2) KE_FILLER))
            (do
                (.be ((ร d =) (.plus d 1)) -1, KB_SPECIAL)
                ((ร s =) (.plus s 3))
            )
            :else
            (do
                (.be ((ร d =) (.plus d 1)) -1, (.at ((ร s =) (.plus s 1)) -1))
            ))
        )
        (eos! d)
        nil
    ))

;;; ============================================================================================== VimM

;; edit.c: functions for Insert mode --------------------------------------------------------------

(final int BACKSPACE_CHAR              1)
(final int BACKSPACE_WORD              2)
(final int BACKSPACE_WORD_NOT_SPACE    3)
(final int BACKSPACE_LINE              4)

(atom! int      insStart_textlen)               ;; length of line when insert started
(atom! int      insStart_blank_vcol)            ;; vcol for first inserted blank
(atom! boolean  update_insStart_orig true)    ;; set insStart_orig to insStart

(atom! Bytes    last_insert)                    ;; the text of the previous insert, KB_SPECIAL is escaped
(atom! int      last_insert_skip)               ;; nr of chars in front of previous insert
(atom! int      new_insert_skip)                ;; nr of chars in front of current insert
(atom! int      did_restart_edit)               ;; "restart_edit" when calling edit()

(atom! boolean  can_cindent)                    ;; may do cindenting on this line

(atom! int      old_indent)                     ;; for ^^D command in insert mode

(atom! boolean  ins_need_undo)                  ;; call u-save() before inserting a char;
                                                            ;; set when edit() is called;
                                                            ;; after that arrow_used is used

(atom! long     o_lnum)

;; edit(): Start inserting text.
;;
;; "cmdchar" can be:
;; 'i'  normal insert command
;; 'a'  normal append command
;; 'R'  replace command
;; 'r'  "r<CR>" command: insert one <CR>.  Note: count can be > 1, for redo,
;;      but still only one <CR> is inserted.  The <Esc> is not used for redo.
;; 'g'  "gI" command.
;; 'V'  "gR" command for Virtual Replace mode.
;; 'v'  "gr" command for single character Virtual Replace mode.
;;
;; This function is not called recursively.  For CTRL-O commands, it returns
;; and lets the caller handle the Normal-mode command.
;;
;; Return true if a CTRL-O command caused the return (insert mode pending).

(defn- #_boolean edit [#_int cmdchar, #_boolean startln, #_long _count]
    ;; startln: if set, insert at start of line
    (ยง
; %%    ((ร long[] count =) (ร { _count }))

        ((ร boolean did_backspace =) true)           ;; previous char was backspace
        ((ร boolean line_is_white =) false)          ;; line is empty before insert
        ((ร long old_topline =) 0)                   ;; topline before insertion
; %%    ((ร boolean[] inserted_space =) (ร { false }))         ;; just inserted a space
        ((ร boolean nomove =) false)                 ;; don't move cursor on return

        ;; Remember whether editing was restarted after CTRL-O.
        (reset! did_restart_edit @restart_edit)

        ;; sleep before redrawing, needed for "CTRL-O :" that results in an error message
        (check-for-delay true)

        ;; set insStart_orig to insStart
        (reset! update_insStart_orig true)

        ;; Don't allow changes in the buffer while editing the cmdline.
        ;; The caller of getcmdline() may get confused.
        (when (non-zero? @textlock)
            (emsg e_secure)
            ((ร RETURN) false)
        )

        ;; Check if the cursor line needs redrawing before changing State.
        ;; If 'concealcursor' is "n", it needs to be redrawn without concealing.
        (conceal-check-cursor-line)

        ;; When doing a paste with the middle mouse button,
        ;; insStart is set to where the paste started.

        (cond (non-zero? (:lnum @where_paste_started))
        (do
            (COPY-pos @insStart, @where_paste_started)
        )
        :else
        (do
            (COPY-pos @insStart, (:w_cursor @curwin))
            (if startln
                ((ร @insStart.col =) 0)
            )
        ))
        (reset! insStart_textlen (linetabsize (ml-get-curline)))
        (reset! insStart_blank_vcol MAXCOL)
        (if (not @did_ai)
            (reset! ai_col 0))

        (when (and (!= cmdchar NUL) (zero? @restart_edit))
            (resetRedobuff)
            (appendNumberToRedobuff (... count 0))
            (cond (or (== cmdchar (byte \V)) (== cmdchar (byte \v)))
            (do
                ;; "gR" or "gr" command
                (appendCharToRedobuff (byte \g))
                (appendCharToRedobuff (if (== cmdchar (byte \v)) (byte \r) (byte \R)))
            )
            :else
            (do
                (appendCharToRedobuff cmdchar)
                (cond (== cmdchar (byte \g))             ;; "gI" command
                (do
                    (appendCharToRedobuff (byte \I))
                )
                (== cmdchar (byte \r))        ;; "r<CR>" command
                (do
                    ((ร count[0] =) 1)                  ;; insert only one <CR>
                ))
            ))
        )

        ((ร int replaceState =) REPLACE)
        (cond (== cmdchar (byte \R))
        (do
            (reset! State REPLACE)
        )
        (or (== cmdchar (byte \V)) (== cmdchar (byte \v)))
        (do
            (reset! State VREPLACE)
            ((ร replaceState =) VREPLACE)
            (reset! orig_line_count (:ml_line_count (:b_ml @curbuf)))
            (reset! vr_lines_changed 1)
        )
        :else
        (do
            (reset! State INSERT)
        ))

        (reset! stop_insert_mode false)

        ;; Need to recompute the cursor position,
        ;; it might move when the cursor is on a TAB or special character.

        (curs-columns true)

        (clear-showcmd)

        ;; Handle restarting Insert mode.
        ;; Don't do this for "CTRL-O ." (repeat an insert): we get here with
        ;; restart_edit non-zero, and something in the stuff buffer.

        (cond (and (non-zero? @restart_edit) (stuff-empty))
        (do
            ;; After a paste we consider text typed to be part of the insert for
            ;; the pasted text.  You can backspace over the pasted text too.

            (reset! arrow_used (zero? (:lnum @where_paste_started)))
            (reset! restart_edit 0)

            ;; If the cursor was after the end-of-line before the CTRL-O and it is
            ;; now at the end-of-line, put it after the end-of-line (this is not
            ;; correct in very rare cases).
            ;; Also do this if curswant is greater than the current virtual column.
            ;; E.g. after "^O$" or "^O80|".

            (validate-virtcol)
            (update-curswant)
            (when (or (and @ins_at_eol (== (:lnum (:w_cursor @curwin)) @o_lnum)) (< (:w_virtcol @curwin) (:w_curswant @curwin)))
                ((ร Bytes p =) (.plus (ml-get-curline) (:col (:w_cursor @curwin))))
                (when (non-eos? p)
                    (cond (eos? p 1)
                    (do
                        (ร @curwin.w_cursor.col++)
                    )
                    :else
                    (do
                        ((ร int n =) (us-ptr2len-cc p))
                        (if (eos? p n)
                            ((ร @curwin.w_cursor.col =) (+ (:col (:w_cursor @curwin)) n))
                        )
                    ))
                )
            )
            (reset! ins_at_eol false)
        )
        :else
        (do
            (reset! arrow_used false)
        ))

        ;; We are in insert mode now, don't need to start it anymore.
        (reset! need_start_insertmode false)

        ;; Need to save the line for undo before inserting the first char.
        (reset! ins_need_undo true)

        ((ร @where_paste_started.lnum =) 0)
        (reset! can_cindent true)

        ;; If 'showmode' is set, show the current (insert/replace/..) mode.
        ;; A warning message for changing a readonly file is given here, before
        ;; actually changing anything.  It's put after the mode, if any.

        ((ร int i =) 0)
        (if @p_smd
            ((ร i =) (showmode))
        )

        (ui-cursor-shape)          ;; may show different cursor shape
        (do-digraph -1)             ;; clear digraphs

        ;; Get the current length of the redo buffer,
        ;; those characters have to be skipped if we want to get to the inserted characters.

        ((ร Bytes ptr =) (get-inserted))
        (if (nil? ptr)
            (reset! new_insert_skip 0)
            (reset! new_insert_skip (STRLEN ptr)))

        (reset! old_indent 0)

        ;; Main loop in Insert mode: repeat until Insert mode is left.

        ((ร FOR) (ร ((ร int lastc =) (ร 0, c = 0)) true nil)
            (if @arrow_used     ;; don't repeat insert when arrow key used
                ((ร count[0] =) 0)
            )

            (if @update_insStart_orig
                (COPY-pos @insStart_orig, @insStart))

;           doESCkey:
;           {
                (when @stop_insert_mode
                    ;; ":stopinsert" used or 'insertmode' reset
                    ((ร count[0] =) 0)
                    (ร BREAK doESCkey)
                )

                ;; set curwin.w_curswant for next K_DOWN or K_UP
                (if (not @arrow_used)
                    ((ร @curwin.w_set_curswant =) true)
                )

                ;; When emsg() was called msg_scroll will have been set.

                (reset! msg_scroll false)

                ;; If we inserted a character at the last position of the last line in the window,
                ;; scroll the window one line up.  This avoids an extra redraw.
                ;; This is detected when the cursor column is smaller after inserting something.
                ;; Don't do this when the topline changed already,
                ;; it has already been adjusted (by insertchar() calling open-line())).

                (when (and (:b_mod_set @curbuf) @(:wo_wrap (:w_options @curwin)) (not did_backspace) (== (:w_topline @curwin) old_topline))
                    ((ร int mincol =) (:w_wcol @curwin))
                    (validate-cursor-col)

                    (when (and (< (:w_wcol @curwin) (- mincol @(:b_p_ts @curbuf))) (== (:w_wrow @curwin) (- (- (+ (:w_winrow @curwin) (:w_height @curwin)) 1) @p_so)) (!= (:lnum (:w_cursor @curwin)) (:w_topline @curwin)))
                        (set-topline @curwin, (+ (:w_topline @curwin) 1))
                    )
                )

                ;; May need to adjust w_topline to show the cursor.
                (update-topline)

                ((ร did_backspace =) false)

                (validate-cursor)              ;; may set must_redraw

                ;; Redraw the display when no characters are waiting.
                ;; Also shows mode, ruler and positions cursor.

                (ins-redraw true)

                (if @(:wo_scb (:w_options @curwin))
                    (do-check-scrollbind true))

                (if @(:wo_crb (:w_options @curwin))
                    (do-check-cursorbind))
                (update-curswant)
                ((ร old_topline =) (:w_topline @curwin))

                ;; Get a character for Insert mode.  Ignore K_IGNORE.

                (if (!= c K_CURSORHOLD)
                    ((ร lastc =) c)          ;; remember the previous char for CTRL-D
                )
;               do
;               {
                    ((ร c =) (safe-vgetc))
;               } while (c == K_IGNORE);

                ;; Don't want K_CURSORHOLD for the second key, e.g., after CTRL-V.
                (reset! did_cursorhold true)

                ;; CTRL-\ CTRL-N goes to Normal mode,
                ;; CTRL-\ CTRL-G goes to mode selected with 'insertmode',
                ;; CTRL-\ CTRL-O is like CTRL-O but without moving the cursor.
                (when (== c Ctrl_BSL)
                    ;; may need to redraw when no more chars available now
                    (ins-redraw false)

                    (swap! no_mapping inc)
                    (swap! allow_keys inc)
                    ((ร c =) (plain-vgetc))
                    (swap! no_mapping dec)
                    (swap! allow_keys dec)

                    (cond (and (!= c Ctrl_N) (!= c Ctrl_G) (!= c Ctrl_O))
                    (do
                        ;; it's something else
                        (vungetc c)
                        ((ร c =) Ctrl_BSL)
                    )
                    (and (== c Ctrl_G) @p_im)
                    (do
                        (ร CONTINUE)
                    )
                    :else
                    (do
                        (when (== c Ctrl_O)
                            (ins-ctrl-o)
                            (reset! ins_at_eol false) ;; cursor keeps its column
                            ((ร nomove =) true)
                        )
                        ((ร count[0] =) 0)
                        (ร BREAK doESCkey)
                    ))
                )

                ((ร c =) (do-digraph c))

                (when (or (== c Ctrl_V) (== c Ctrl_Q))
                    (ins-ctrl-v)
                    ((ร c =) Ctrl_V)         ;; pretend CTRL-V is last typed character
                    (ร CONTINUE)
                )

                ;; If 'keymodel' contains "startsel", may start selection.
                ;; If it does, a CTRL-O and c will be stuffed, we need to get these characters.

                (if (ins-start-select c)
                    (ร CONTINUE)
                )

;               normalchar:
;               {
                    ;; The big switch to handle a character in insert mode.

                    ((ร SWITCH) c
                        ((ร CASE) ESC)                           ;; end input mode
                        (do
                            (ร FALLTHROUGH)
                        )

                        ((ร CASE) Ctrl_C)                        ;; end input mode
                        (do
                            (when (and (== c Ctrl_C) (non-zero? @cmdwin_type))
                                ;; Close the cmdline window.
                                (reset! cmdwin_result K_IGNORE)
                                (reset! got_int false)            ;; don't stop executing autocommands et al.
                                ((ร nomove =) true)
                                (ร BREAK doESCkey)
                            )

                            ;; When 'insertmode' set, and not halfway a mapping, don't leave Insert mode.
                            (when (goto-im)
                                (cond @got_int
                                (do
                                    (vgetc)                ;; flush all buffers
                                    (reset! got_int false)
                                )
                                :else
                                (do
                                    (vim-beep)
                                ))
                                (ร BREAK normalchar)
                            )
                            (ร BREAK doESCkey)
                        )

                        ((ร CASE) Ctrl_Z)                        ;; suspend when 'insertmode' set
                        (do
                            (if (not @p_im)
                                (ร BREAK)            ;; insert CTRL-Z as normal char
                            )
                            (stuffReadbuff (u8 ":st\r"))
                            ((ร c =) Ctrl_O)
                            (ร FALLTHROUGH)
                        )

                        ((ร CASE) Ctrl_O)                        ;; execute one command
                        (do
                            (ins-ctrl-o)

                            ;; Don't move the cursor left when 'virtualedit' has "onemore".
                            (when (flag? @ve_flags VE_ONEMORE)
                                (reset! ins_at_eol false)
                                ((ร nomove =) true)
                            )
                            ((ร count[0] =) 0)
                            (ร BREAK doESCkey)
                        )

                        ((ร CASE) K_INS)                         ;; toggle insert/replace mode
                        ((ร CASE) K_KINS)
                        (do
                            (ins-insert replaceState)
                            (ร BREAK normalchar)
                        )

                        ((ร CASE) K_SELECT)                      ;; end of Select mode mapping - ignore
                        (do
                            (ร BREAK normalchar)
                        )

                        ((ร CASE) K_HELP)                        ;; Help key works like <ESC> <Help>
                        ((ร CASE) K_F1)
                        ((ร CASE) K_XF1)
                        (do
                            (stuffcharReadbuff K_HELP)
                            (if @p_im
                                (reset! need_start_insertmode true))
                            (ร BREAK doESCkey)
                        )

                        ((ร CASE) K_ZERO)                        ;; insert the previously inserted text
                        ((ร CASE) NUL)
                        ((ร CASE) Ctrl_A)
                        (do
                            ;; For ^@ the trailing ESC will end the insert, unless there is an error.
                            (if (and (not (stuff-inserted NUL, 1, (== c Ctrl_A))) (!= c Ctrl_A) (not @p_im))
                                (ร BREAK doESCkey)             ;; quit insert mode
                            )
                            ((ร inserted_space[0] =) false)
                            (ร BREAK normalchar)
                        )

                        ((ร CASE) Ctrl_R)                        ;; insert the contents of a register
                        (do
                            (ins-reg)
                            ((ร inserted_space[0] =) false)
                            (ร BREAK normalchar)
                        )

                        ((ร CASE) Ctrl_G)                        ;; commands starting with CTRL-G
                        (do
                            (ins-ctrl-g)
                            (ร BREAK normalchar)
                        )

                        ((ร CASE) Ctrl_HAT)                      ;; switch input mode and/or langmap
                        (do
                            (ins-ctrl-hat)
                            (ร BREAK normalchar)
                        )

                        ((ร CASE) Ctrl__)                        ;; switch between languages
                        (do
                            (ร BREAK)
                        )

                        ((ร CASE) Ctrl_D)                        ;; make indent one shiftwidth smaller
                        (do
                            (ร FALLTHROUGH)
                        )
                        ((ร CASE) Ctrl_T)                        ;; make indent one shiftwidth greater
                        (do
                            (ins-shift c, lastc)
                            ((ร inserted_space[0] =) false)
                            (ร BREAK normalchar)
                        )

                        ((ร CASE) K_DEL)                         ;; delete character under the cursor
                        ((ร CASE) K_KDEL)
                        (do
                            (ins-del)
                            (ร BREAK normalchar)
                        )

                        ((ร CASE) K_BS)                          ;; delete character before the cursor
                        ((ร CASE) Ctrl_H)
                        (do
                            ((ร did_backspace =) (ins-bs c, BACKSPACE_CHAR, inserted_space))
                            (ร BREAK normalchar)
                        )

                        ((ร CASE) Ctrl_W)                        ;; delete word before the cursor
                        (do
                            ((ร did_backspace =) (ins-bs c, BACKSPACE_WORD, inserted_space))
                            (ร BREAK normalchar)
                        )

                        ((ร CASE) Ctrl_U)                        ;; delete all inserted text in current line
                        (do
                            ((ร did_backspace =) (ins-bs c, BACKSPACE_LINE, inserted_space))
                            ((ร inserted_space[0] =) false)
                            (ร BREAK normalchar)
                        )

                        ((ร CASE) K_IGNORE)                      ;; something mapped to nothing
                        (do
                            (ร BREAK normalchar)
                        )

                        ((ร CASE) K_CURSORHOLD)                  ;; didn't type something for a while
                        (do
                            (reset! did_cursorhold true)
                            (ร BREAK normalchar)
                        )

                        ((ร CASE) K_HOME)                        ;; <Home>
                        ((ร CASE) K_KHOME)
                        ((ร CASE) K_S_HOME)
                        ((ร CASE) K_C_HOME)
                        (do
                            (ins-home c)
                            (ร BREAK normalchar)
                        )

                        ((ร CASE) K_END)                         ;; <End>
                        ((ร CASE) K_KEND)
                        ((ร CASE) K_S_END)
                        ((ร CASE) K_C_END)
                        (do
                            (ins-end c)
                            (ร BREAK normalchar)
                        )

                        ((ร CASE) K_LEFT)                        ;; <Left>
                        (do
                            (if (flag? @mod_mask (| MOD_MASK_SHIFT MOD_MASK_CTRL))
                                (ins-s-left)
                                (ins-left))
                            (ร BREAK normalchar)
                        )

                        ((ร CASE) K_S_LEFT)                      ;; <S-Left>
                        ((ร CASE) K_C_LEFT)
                        (do
                            (ins-s-left)
                            (ร BREAK normalchar)
                        )

                        ((ร CASE) K_RIGHT)                       ;; <Right>
                        (do
                            (if (flag? @mod_mask (| MOD_MASK_SHIFT MOD_MASK_CTRL))
                                (ins-s-right)
                                (ins-right))
                            (ร BREAK normalchar)
                        )

                        ((ร CASE) K_S_RIGHT)                     ;; <S-Right>
                        ((ร CASE) K_C_RIGHT)
                        (do
                            (ins-s-right)
                            (ร BREAK normalchar)
                        )

                        ((ร CASE) K_UP)                          ;; <Up>
                        (do
                            (if (flag? @mod_mask MOD_MASK_SHIFT)
                                (ins-pageup)
                                (ins-up false))
                            (ร BREAK normalchar)
                        )

                        ((ร CASE) K_S_UP)                        ;; <S-Up>
                        ((ร CASE) K_PAGEUP)
                        ((ร CASE) K_KPAGEUP)
                        (do
                            (ins-pageup)
                            (ร BREAK normalchar)
                        )

                        ((ร CASE) K_DOWN)                        ;; <Down>
                        (do
                            (if (flag? @mod_mask MOD_MASK_SHIFT)
                                (ins-pagedown)
                                (ins-down false))
                            (ร BREAK normalchar)
                        )

                        ((ร CASE) K_S_DOWN)                      ;; <S-Down>
                        ((ร CASE) K_PAGEDOWN)
                        ((ร CASE) K_KPAGEDOWN)
                        (do
                            (ins-pagedown)
                            (ร BREAK normalchar)
                        )

                        ((ร CASE) K_DROP)                        ;; drag-n-drop event
                        (do
                            (ins-drop)
                            (ร BREAK normalchar)
                        )

                        ((ร CASE) K_S_TAB)                       ;; when not mapped, use like a normal TAB
                        (do
                            ((ร c =) TAB)
                            (ร FALLTHROUGH)
                        )
                        ((ร CASE) TAB)                           ;; TAB or Complete patterns along path
                        (do
                            ((ร inserted_space[0] =) false)
                            (if (ins-tab)
                                (ร BREAK)            ;; insert TAB as a normal char
                            )
                            (ร BREAK normalchar)
                        )

                        ((ร CASE) K_KENTER)                      ;; <Enter>
                        (do
                            ((ร c =) CAR)
                            (ร FALLTHROUGH)
                        )
                        ((ร CASE) CAR)
                        ((ร CASE) NL)
                        (do
                            (when (non-zero? @cmdwin_type)
                                ;; Execute the command in the cmdline window.
                                (reset! cmdwin_result CAR)
                                (ร BREAK doESCkey)
                            )
                            (if (and (ins-eol c) (not @p_im))
                                (ร BREAK doESCkey)             ;; out of memory
                            )
                            ((ร inserted_space[0] =) false)
                            (ร BREAK normalchar)
                        )

                        ((ร CASE) Ctrl_K)                        ;; digraph or keyword completion
                        (do
                            ((ร c =) (ins-digraph))
                            (if (== c NUL)
                                (ร BREAK normalchar)
                            )
                            (ร BREAK)
                        )

                        ((ร CASE) Ctrl_L)                        ;; whole line completion after ^X
                        (do
                            ;; CTRL-L with 'insertmode' set: Leave Insert mode.
                            (if @p_im
                                (ร BREAK doESCkey)
                            )
                            (ร BREAK)
                        )

                        ((ร CASE) Ctrl_Y)                        ;; copy from previous line or scroll down
                        ((ร CASE) Ctrl_E)                        ;; copy from next     line or scroll up
                        (do
                            ((ร c =) (ins-ctrl-ey c))
                            (ร BREAK normalchar)
                        )

                        (ร DEFAULT)
                        (do
                            (when (== c @intr_char)             ;; special interrupt char
                                ;; When 'insertmode' set, and not halfway a mapping, don't leave Insert mode.
                                (when (goto-im)
                                    (cond @got_int
                                    (do
                                        (vgetc)                ;; flush all buffers
                                        (reset! got_int false)
                                    )
                                    :else
                                    (do
                                        (vim-beep)
                                    ))
                                    (ร BREAK normalchar)
                                )
                                (ร BREAK doESCkey)
                            )
                            (ร BREAK)
                        )
                    )

                    ;; Insert a normal character.

                    (when (not @p_paste)
                        ;; Trigger InsertCharPre.
                        ((ร Bytes s =) (do-insert-char-pre c))

                        (when (non-nil? s)
                            (when (and (non-eos? s) (stop-arrow))
                                ;; Insert the new value of v:char literally.
                                ((ร FOR) (ร ((ร Bytes p =) s) (non-eos? p) ((ร p =) (.plus p (us-ptr2len-cc p))))
                                    ((ร c =) (us-ptr2char p))
                                    (if (or (== c CAR) (== c K_KENTER) (== c NL))
                                        (ins-eol c)
                                        (ins-char c))
                                )
                                (appendToRedobuffLit s, -1)
                            )
                            ((ร c =) NUL)
                        )

                        ;; If the new value is already inserted or an empty string,
                        ;; then don't insert any character.
                        (if (== c NUL)
                            (ร BREAK normalchar)
                        )
                    )
                    ;; Try to perform smart-indenting.
                    (ins-try-si c)

                    (when (== c (byte \space))
                        ((ร inserted_space[0] =) true)
                        (if (inindent 0)
                            (reset! can_cindent false))
                        (if (and (== @insStart_blank_vcol MAXCOL) (== (:lnum (:w_cursor @curwin)) (:lnum @insStart)))
                            (reset! insStart_blank_vcol (get-nolist-virtcol)))
                    )

                    ;; Insert a normal character and check for abbreviations on a special character.
                    ;; Let CTRL-] expand abbreviations without inserting it.
                    (when (or (vim-iswordc c, @curbuf) (!= c Ctrl_RSB))
                        (insert-special c, false, false)
                    )
;               }

                ;; If typed something may trigger CursorHoldI again.
                (if (!= c K_CURSORHOLD)
                    (reset! did_cursorhold false))

                ;; If the cursor was moved we didn't just insert a space.
                (if @arrow_used
                    ((ร inserted_space[0] =) false)
                )

                (ร CONTINUE)
;           }

            ;; This is the ONLY return from edit()!

            ;; Always update o_lnum, so that a "CTRL-O ." that adds a line
            ;; still puts the cursor back after the inserted text.
            (if (and @ins_at_eol (== (gchar-cursor) NUL))
                (reset! o_lnum (:lnum (:w_cursor @curwin))))

            (when (ins-esc count, cmdchar, nomove)
                (reset! did_cursorhold false)
                ((ร RETURN) (== c Ctrl_O))
            )
        )

        ;; NOTREACHED
    ))

;; Redraw for Insert mode.
;; This is postponed until getting the next character to make '$' in the 'cpo' option work correctly.
;; Only redraw when there are no characters available.
;; This speeds up inserting sequences of characters (e.g., for CTRL-R).

(defn- #_void ins-redraw [#_boolean ready]
    ;; ready: not busy with something
    (ยง
        (if (char-avail)
            ((ร RETURN) nil)
        )

        ((ร long conceal_old_cursor_line =) 0)
        ((ร long conceal_new_cursor_line =) 0)
        ((ร boolean conceal_update_lines =) false)

        ;; Trigger CursorMoved if the cursor moved.
        ;; Not when the popup menu is visible, the command might delete it.
        (when (and ready (< 0 @(:wo_cole (:w_options @curwin))) (not (eqpos @last_cursormoved, (:w_cursor @curwin))))
            ((ร conceal_old_cursor_line =) (:lnum @last_cursormoved))
            ((ร conceal_new_cursor_line =) (:lnum (:w_cursor @curwin)))
            ((ร conceal_update_lines =) true)

            (COPY-pos @last_cursormoved, (:w_cursor @curwin))
        )

        (cond (non-zero? @must_redraw)
        (do
            (update-screen 0)
        )
        (or @clear_cmdline @redraw_cmdline)
        (do
            (showmode)             ;; clear cmdline and show mode
        ))
        (when (or (and conceal_update_lines (or (!= conceal_old_cursor_line conceal_new_cursor_line) (conceal-cursor-line @curwin))) @need_cursor_line_redraw)
            (if (!= conceal_old_cursor_line conceal_new_cursor_line)
                (update-single-line @curwin, conceal_old_cursor_line))
            (update-single-line @curwin, (if (zero? conceal_new_cursor_line) (:lnum (:w_cursor @curwin)) conceal_new_cursor_line))
            ((ร @curwin.w_valid =) (& (:w_valid @curwin) (bit-not VALID_CROW)))
        )
        (showruler false)
        (setcursor)
        (reset! emsg_on_display false)    ;; may remove error message now
        nil
    ))

;; Handle a CTRL-V or CTRL-Q typed in Insert mode.

(defn- #_void ins-ctrl-v []
    (ยง
        ((ร boolean did_putchar =) false)

        ;; may need to redraw when no more chars available now
        (ins-redraw false)

        (when (and (redrawing) (not (char-avail)))
            (edit-putchar (byte \^), true)
            ((ร did_putchar =) true)
        )
        (appendToRedobuff CTRL_V_STR)   ;; CTRL-V

        (add-to-showcmd-c Ctrl_V)

        ((ร int c =) (get-literal))
        (when did_putchar
            ;; When the line fits in 'columns' the '^' is at the start
            ;; of the next line and will not removed by the redraw.
            (edit-unputchar)
        )
        (clear-showcmd)
        (insert-special c, false, true)
        nil
    ))

;; Put a character directly onto the screen.  It's not stored in a buffer.
;; Used while handling CTRL-K, CTRL-V, etc. in Insert mode.

(atom! int  pc_status)
(final int PC_STATUS_UNSET 0)                   ;; "pc_bytes" was not set
(final int PC_STATUS_RIGHT 1)                   ;; right halve of double-wide char
(final int PC_STATUS_LEFT  2)                   ;; left halve of double-wide char
(final int PC_STATUS_SET   3)                   ;; "pc_bytes" was filled

(final Bytes pc_bytes (Bytes. (inc MB_MAXBYTES)))   ;; saved bytes
(atom! int  pc_attr)
(atom! int  pc_row)
(atom! int  pc_col)

(defn- #_void edit-putchar [#_int c, #_boolean highlight]
    (ยง
        (when (non-nil? @screenLines)
            (update-topline)       ;; just in case w_topline isn't valid
            (validate-cursor)

            ((ร int attr =) (if highlight (hl-attr HLF_8) 0))

            (reset! pc_row (+ (:w_winrow @curwin) (:w_wrow @curwin)))
            (reset! pc_col (:w_wincol @curwin))
            (reset! pc_status PC_STATUS_UNSET)

            ((ร @pc_col =) (+ @pc_col (:w_wcol @curwin)))
            (if (mb-lefthalve @pc_row, @pc_col)
                (reset! pc_status PC_STATUS_LEFT))

            ;; save the character to be able to put it back
            (when (== @pc_status PC_STATUS_UNSET)
                (screen-getbytes @pc_row, @pc_col, pc_bytes, pc_attr)
                (reset! pc_status PC_STATUS_SET)
            )
            (screen-putchar c, @pc_row, @pc_col, attr)
        )
        nil
    ))

;; Undo the previous edit-putchar().

(defn- #_void edit-unputchar []
    (ยง
        (when (and (!= @pc_status PC_STATUS_UNSET) (<= @msg_scrolled @pc_row))
            (if (== @pc_status PC_STATUS_RIGHT)
                (ร @curwin.w_wcol++)
            )
            (if (or (== @pc_status PC_STATUS_RIGHT) (== @pc_status PC_STATUS_LEFT))
                (redrawWinline (:lnum (:w_cursor @curwin)))
                (screen-puts pc_bytes, (- @pc_row @msg_scrolled), @pc_col, @pc_attr))
        )
        nil
    ))

;; Insert an indent (for <Tab> or CTRL-T) or delete an indent (for CTRL-D).
;; Keep the cursor on the same character.
;; type == INDENT_INC   increase indent (for CTRL-T or <Tab>)
;; type == INDENT_DEC   decrease indent (for CTRL-D)
;; type == INDENT_SET   set indent to "amount"
;; If round is true, round the indent to 'shiftwidth' (only with _INC and _DEC).

(defn- #_void change-indent [#_int type, #_int amount, #_boolean round, #_int replaced, #_boolean call_changed_bytes]
    ;; replaced: replaced character, put on replace stack
    ;; call_changed_bytes: call changed-bytes()
    (ยง
        ((ร Bytes orig_line =) nil)
        ((ร int orig_col =) 0)

        ;; VREPLACE mode needs to know what the line was like before changing.
        (when (flag? @State VREPLACE_FLAG)
            ((ร orig_line =) (STRDUP (ml-get-curline)))   ;; Deal with null below
            ((ร orig_col =) (:col (:w_cursor @curwin)))
        )

        ((ร int vc =) (getvcol-nolist (:w_cursor @curwin)))
        ((ร int vcol =) vc)

        ;; For Replace mode we need to fix the replace stack later, which is only
        ;; possible when the cursor is in the indent.  Remember the number of
        ;; characters before the cursor if it's possible.

        ((ร int start_col =) (:col (:w_cursor @curwin)))

        ;; determine offset from first non-blank
        ((ร int new_cursor_col =) (:col (:w_cursor @curwin)))
        (beginline BL_WHITE)
        ((ร new_cursor_col =) (- new_cursor_col (:col (:w_cursor @curwin))))

        ((ร int insstart_less =) (:col (:w_cursor @curwin)))    ;; reduction for insStart.col

        ;; If the cursor is in the indent, compute how many screen columns the
        ;; cursor is to the left of the first non-blank.

        (if (< new_cursor_col 0)
            ((ร vcol =) (- (get-indent) vcol))
        )

        (if (< 0 new_cursor_col)         ;; can't fix replace stack
            ((ร start_col =) -1)
        )

        ;; Set the new indent.  The cursor will be put on the first non-blank.

        (cond (== type INDENT_SET)
        (do
            (set-indent amount, (if call_changed_bytes SIN_CHANGED 0))
        )
        :else
        (do
            ((ร int save_State =) @State)

            ;; Avoid being called recursively.
            (if (flag? @State VREPLACE_FLAG)
                (reset! State INSERT))
            (shift-line (== type INDENT_DEC), round, 1, call_changed_bytes)

            (reset! State save_State)
        ))
        ((ร insstart_less =) (- insstart_less (:col (:w_cursor @curwin))))

        ;; Try to put cursor on same character.
        ;; If the cursor is at or after the first non-blank in the line,
        ;; compute the cursor column relative to the column of the first non-blank character.
        ;; If we are not in insert mode, leave the cursor on the first non-blank.
        ;; If the cursor is before the first non-blank, position it relative
        ;; to the first non-blank, counted in screen columns.

        (cond (<= 0 new_cursor_col)
        (do
            ;; When changing the indent while the cursor is touching it, reset insStart_col to 0.

            (if (zero? new_cursor_col)
                ((ร insstart_less =) MAXCOL)
            )
            ((ร new_cursor_col =) (+ new_cursor_col (:col (:w_cursor @curwin))))
        )
        (non-flag? @State INSERT)
        (do
            ((ร new_cursor_col =) (:col (:w_cursor @curwin)))
        )
        :else
        (do
            ;; Compute the screen column where the cursor should be.

            ((ร vcol =) (- (get-indent) vcol))
            ((ร @curwin.w_virtcol =) (if (< vcol 0) 0 vcol))

            ;; Advance the cursor until we reach the right screen column.

            ((ร int last_vcol =) ((ร vcol =) 0))
            ((ร new_cursor_col =) -1)
            ((ร Bytes ptr =) (ml-get-curline))
            (while (<= vcol (:w_virtcol @curwin))
                ((ร last_vcol =) vcol)
                (if (<= 0 new_cursor_col)
                    ((ร new_cursor_col =) (+ new_cursor_col (us-ptr2len-cc (.plus ptr new_cursor_col))))
                    (ร new_cursor_col++)
                )
                ((ร vcol =) (+ vcol (lbr-chartabsize ptr, (.plus ptr new_cursor_col), vcol)))
            )
            ((ร vcol =) last_vcol)

            ;; May need to insert spaces to be able to position the cursor on
            ;; the right screen column.

            (when (!= vcol (:w_virtcol @curwin))
                ((ร @curwin.w_cursor.col =) new_cursor_col)
                ((ร int i =) (- (:w_virtcol @curwin) vcol))
                ((ร ptr =) (Bytes. (inc i)))

                ((ร new_cursor_col =) (+ new_cursor_col i))
                (eos! ptr i)
                (while (<= 0 (ร --i))
                    (.be ptr i, (byte \space))
                )
                (ins-str ptr)
            )

            ;; When changing the indent while the cursor is in it, reset insStart_col to 0.

            ((ร insstart_less =) MAXCOL)
        ))

        ((ร @curwin.w_cursor.col =) (if (<= new_cursor_col 0) 0 new_cursor_col))
        ((ร @curwin.w_set_curswant =) true)
        (changed-cline-bef-curs)

        ;; May have to adjust the start of the insert.

        (when (flag? @State INSERT)
            (when (and (== (:lnum (:w_cursor @curwin)) (:lnum @insStart)) (non-zero? (:col @insStart)))
                ((ร @insStart.col =) (if (<= (:col @insStart) insstart_less) 0 (- (:col @insStart) insstart_less)))
            )
            (swap! ai_col #(if (<= % insstart_less) 0 (- % insstart_less)))
        )

        ;; For REPLACE mode, may have to fix the replace stack, if it's possible.
        ;; If the number of characters before the cursor decreased, need to pop a
        ;; few characters from the replace stack.
        ;; If the number of characters before the cursor increased, need to push a
        ;; few NULs onto the replace stack.

        (when (and (flag? @State REPLACE_FLAG) (non-flag? @State VREPLACE_FLAG) (<= 0 start_col))
            (while (< (:col (:w_cursor @curwin)) start_col)
                (replace-join 0)        ;; remove a NUL from the replace stack
                (ร --start_col)
            )
            (while (or (< start_col (:col (:w_cursor @curwin))) (!= replaced NUL))
                (replace-push NUL)
                (when (!= replaced NUL)
                    (replace-push replaced)
                    ((ร replaced =) NUL)
                )
                (ร start_col++)
            )
        )

        ;; For VREPLACE mode, we also have to fix the replace stack.  In this case
        ;; it is always possible because we backspace over the whole line and then
        ;; put it back again the way we wanted it.

        (when (flag? @State VREPLACE_FLAG)
            ;; If 'orig_line' didn't allocate, just return.
            ;; At least we did the job, even if you can't backspace.
            (if (nil? orig_line)
                ((ร RETURN) nil)
            )

            ;; Save new line.
            ((ร Bytes new_line =) (STRDUP (ml-get-curline)))

            ;; We only put back the new line up to the cursor.
            (.be new_line (:col (:w_cursor @curwin)), NUL)

            ;; Put back original line.
            (ml-replace (:lnum (:w_cursor @curwin)), orig_line)
            ((ร @curwin.w_cursor.col =) orig_col)

            ;; Backspace from cursor to start of line.
            (backspace-until-column 0)

            ;; Insert new stuff into line again.
            (ins-bytes new_line)
        )
        nil
    ))

;; Truncate the space at the end of a line.  This is to be used only in an
;; insert mode.  It handles fixing the replace stack for REPLACE and VREPLACE modes.

(defn- #_void truncate-spaces [#_Bytes line]
    (ยง
        ;; find start of trailing white space
        (ร int i)
        ((ร FOR) (ร ((ร i =) (- (STRLEN line) 1)) (and (<= 0 i) (vim-iswhite (.at line i))) (ร i--))
            (if (flag? @State REPLACE_FLAG)
                (replace-join 0))        ;; remove a NUL from the replace stack
        )
        (.be line (inc i), NUL)
        nil
    ))

;; Backspace the cursor until the given column.  Handles REPLACE and VREPLACE
;; modes correctly.  May also be used when not in insert mode at all.
;; Will attempt not to go before "col" even when there is a composing character.

(defn- #_void backspace-until-column [#_int col]
    (ยง
        (while (< col (:col (:w_cursor @curwin)))
            (ร --@curwin.w_cursor.col)
            (cond (flag? @State REPLACE_FLAG)
            (do
                (replace-do-bs col)
            )
            (not (del-char-after-col col))
            (do
                (ร BREAK)
            ))
        )
        nil
    ))

;; Like del-char(), but make sure not to go before column "limit_col".
;; Only matters when there are composing characters.
;; Return true when something was deleted.

(defn- #_boolean del-char-after-col [#_int limit_col]
    (ยง
        (cond (<= 0 limit_col)
        (do
            ((ร int ecol =) (+ (:col (:w_cursor @curwin)) 1))

            ;; Make sure the cursor is at the start of a character, but
            ;; skip forward again when going too far back because of a
            ;; composing character.
            (mb-adjust-pos @curbuf, (:w_cursor @curwin))
            (while (< (:col (:w_cursor @curwin)) limit_col)
                ((ร int l =) (us-ptr2len (ml-get-cursor)))

                (if (zero? l)     ;; end of line
                    (ร BREAK)
                )
                ((ร @curwin.w_cursor.col =) (+ (:col (:w_cursor @curwin)) l))
            )
            (if (or (eos? (ml-get-cursor)) (== (:col (:w_cursor @curwin)) ecol))
                ((ร RETURN) false)
            )
            (del-bytes (- ecol (:col (:w_cursor @curwin))), false, true)
        )
        :else
        (do
            (del-char false)
        ))
        true
    ))

;; Next character is interpreted literally.
;; A one, two or three digit decimal number is interpreted as its byte value.
;; If one or two digits are entered, the next character is given to vungetc().
;; For Unicode a character > 255 may be returned.

(defn- #_int get-literal []
    (ยง
        (if @got_int
            ((ร RETURN) Ctrl_C)
        )

        ((ร boolean hex =) false)
        ((ร boolean octal =) false)
        ((ร int unicode =) 0)

        (ร int nc)
        (swap! no_mapping inc)               ;; don't map the next key hits

        ((ร int cc =) 0)
        ((ร int i =) 0)
        (while true
            ((ร nc =) (plain-vgetc))

            (if (and (non-flag? @State CMDLINE) (== (mb-byte2len nc) 1))
                (add-to-showcmd nc))

            (cond (or (== nc (byte \x)) (== nc (byte \X)))
            (do
                ((ร hex =) true)
            )
            (or (== nc (byte \o)) (== nc (byte \O)))
            (do
                ((ร octal =) true)
            )
            (or (== nc (byte \u)) (== nc (byte \U)))
            (do
                ((ร unicode =) nc)
            )
            :else
            (do
                (cond (or hex (non-zero? unicode))
                (do
                    (if (not (asc-isxdigit nc))
                        (ร BREAK)
                    )
                    ((ร cc =) (+ (* cc 16) (hex2nr nc)))
                )
                octal
                (do
                    (if (or (< nc (byte \0)) (< (byte \7) nc))
                        (ร BREAK)
                    )
                    ((ร cc =) (+ (* cc 8) (- nc (byte \0))))
                )
                :else
                (do
                    (if (not (asc-isdigit nc))
                        (ร BREAK)
                    )
                    ((ร cc =) (+ (* cc 10) (- nc (byte \0))))
                ))

                (ร i++)
            ))

            (if (and (> cc 255) (zero? unicode))
                ((ร cc =) 255)           ;; limit range to 0-255
            )
            ((ร nc =) 0)

            (cond hex                ;; hex: up to two chars
            (do
                (if (<= 2 i)
                    (ร BREAK)
                )
            )
            (non-zero? unicode)  ;; Unicode: up to four or eight chars
            (do
                (if (or (and (== unicode (byte \u)) (<= 4 i)) (and (== unicode (byte \U)) (<= 8 i)))
                    (ร BREAK)
                )
            )
            (<= 3 i)        ;; decimal or octal: up to three chars
            (do
                (ร BREAK)
            ))
        )
        (when (zero? i)                 ;; no number entered
            (cond (== nc K_ZERO)       ;; NUL is stored as NL
            (do
                ((ร cc =) (byte \newline))
                ((ร nc =) 0)
            )
            :else
            (do
                ((ร cc =) nc)
                ((ร nc =) 0)
            ))
        )

        (if (zero? cc)                ;; NUL is stored as NL
            ((ร cc =) (byte \newline))
        )

        (swap! no_mapping dec)
        (if (non-zero? nc)
            (vungetc nc))

        (reset! got_int false)            ;; CTRL-C typed after CTRL-V is not an interrupt
        cc
    ))

;; Insert character, taking care of special keys and mod_mask

(defn- #_void insert-special [#_int c, #_boolean allow_modmask, #_boolean ctrlv]
    ;; ctrlv: c was typed after CTRL-V
    (ยง
        ;; Special function key, translate into "<Key>".  Up to the last '>' is
        ;; inserted with ins-str(), so as not to replace characters in replace mode.
        ;; Only use mod_mask for special keys, to avoid things like <S-Space>,
        ;; unless 'allow_modmask' is true.

        (when (or (is-special c) (and (non-zero? @mod_mask) allow_modmask))
            ((ร Bytes p =) (get-special-key-name c, @mod_mask))
            ((ร int len =) (STRLEN p))
            ((ร c =) (.at p (dec len)))
            (when (< 2 len)
                (if (not (stop-arrow))
                    ((ร RETURN) nil)
                )
                (.be p (dec len), NUL)
                (ins-str p)
                (appendToRedobuffLit p, -1)
                ((ร ctrlv =) false)
            )
        )
        (when (stop-arrow)
            (insertchar c, (if ctrlv INSCHAR_CTRLV 0))
        )
        nil
    ))

;; Special characters in this context are those that need processing other
;; than the simple insertion that can be performed here.  This includes ESC
;; which terminates the insert, and CR/NL which need special processing to
;; open up a new line.  This routine tries to optimize insertions performed by
;; the "redo", "undo" or "put" commands, so it needs to know when it should
;; stop and defer processing to the "normal" mechanism.
;; '0' and '^' are special, because they can be followed by CTRL-D.

(defn- #_boolean isspecial [#_int c]
    (or (< c (byte \space)) (<= DEL c) (== c (byte \0)) (== c (byte \^))))

;; "flags": INSCHAR_CTRLV  - char typed just after CTRL-V

(defn- #_void insertchar [#_int c, #_int flags]
    ;; c: character to insert or NUL
    (ยง
        (if (== c NUL)           ;; only formatting was wanted
            ((ร RETURN) nil)
        )

        (reset! did_ai false)
        (reset! did_si false)
        (reset! can_si false)
        (reset! can_si_back false)

        ;; If there's any pending input, grab up to INPUT_BUFLEN at once.
        ;; This speeds up normal text input considerably.
        ;; Don't do this when 'cindent' or 'indentexpr' is set, because we might
        ;; need to re-indent at a ':', or any other character (but not what 'paste' is set)..
        ;; Don't do this when there an InsertCharPre autocommand is defined,
        ;; because we need to fire the event for every character.

        (cond (and (not (isspecial c)) (== (utf-char2len c) 1) (!= (vpeekc) NUL) (non-flag? @State REPLACE_FLAG))
        (do
            ((ร final int INPUT_BUFLEN =) 100)
            ((ร Bytes buf =) (Bytes. (inc INPUT_BUFLEN)))

            (.be buf 0, c)
            ((ร int i =) 1)

            ;; Stop the string when:
            ;; - no more chars available
            ;; - finding a special character (command key)
            ;; - buffer is full
            ;; - running into the 'textwidth' boundary

            (while (and (!= ((ร c =) (vpeekc)) NUL) (not (isspecial c)) (== (mb-byte2len c) 1) (< i INPUT_BUFLEN))
                ((ร c =) (vgetc))
                (.be buf (ร i++), c)
            )

            (do-digraph -1)                 ;; clear digraphs
            (do-digraph (.at buf (dec i)))      ;; may be the start of a digraph
            (eos! buf i)
            (ins-str buf)
            (cond (flag? flags INSCHAR_CTRLV)
            (do
                (redo-literal (.at buf 0))
                ((ร i =) 1)
            )
            :else
            (do
                ((ร i =) 0)
            ))
            (if (non-eos? buf i)
                (appendToRedobuffLit (.plus buf i), -1))
        )
        :else
        (do
            ((ร int cc =) (utf-char2len c))
            (cond (< 1 cc)
            (do
                ((ร Bytes buf =) (Bytes. (inc MB_MAXBYTES)))

                (utf-char2bytes c, buf)
                (eos! buf cc)
                (ins-char-bytes buf, cc)
                (appendCharToRedobuff c)
            )
            :else
            (do
                (ins-char c)
                (if (flag? flags INSCHAR_CTRLV)
                    (redo-literal c)
                    (appendCharToRedobuff c))
            ))
        ))
        nil
    ))

;; Put a character in the redo buffer, for when just after a CTRL-V.

(defn- #_void redo-literal [#_int c]
    (ยง
        ((ร Bytes buf =) (Bytes. 10))

        ;; Only digits need special treatment.  Translate them into a string of three digits.
        (cond (asc-isdigit c)
        (do
;%%         (vim_snprintf buf, (.size buf), (u8 "%03d"), c)
            (appendToRedobuff buf)
        )
        :else
        (do
            (appendCharToRedobuff c)
        ))
        nil
    ))

;; start-arrow() is called when an arrow key is used in insert mode.
;; For undo/redo it resembles hitting the <ESC> key.

(defn- #_void start-arrow [#_pos_C end_insert_pos]
    ;; end_insert_pos: can be null
    (when (not @arrow_used)                ;; something has been inserted
        (appendToRedobuff ESC_STR)
        (stop-insert end_insert_pos, false, false)
        (reset! arrow_used true)          ;; this means we stopped the current insert
    )
    nil)

;; stop-arrow() is called before a change is made in insert mode.
;; If an arrow key has been used, start a new insertion.
;; Returns false if undo is impossible, shouldn't insert then.

(defn- #_boolean stop-arrow []
    (ยง
        (cond @arrow_used
        (do
            (COPY-pos @insStart, (:w_cursor @curwin))    ;; new insertion starts here
            (when (and (< (:col @insStart_orig) (:col @insStart)) (not @ins_need_undo))
                ;; Don't update the original insert position when moved to the right,
                ;; except when nothing was inserted yet.
                (reset! update_insStart_orig false)
            )
            (reset! insStart_textlen (linetabsize (ml-get-curline)))

            (when (u-save-cursor)
                (reset! arrow_used false)
                (reset! ins_need_undo false)
            )

            (reset! ai_col 0)
            (when (flag? @State VREPLACE_FLAG)
                (reset! orig_line_count (:ml_line_count (:b_ml @curbuf)))
                (reset! vr_lines_changed 1)
            )
            (resetRedobuff)
            (appendToRedobuff (u8 "1i"))         ;; pretend we start an insertion
            (reset! new_insert_skip 2)
        )
        @ins_need_undo
        (do
            (if (u-save-cursor)
                (reset! ins_need_undo false))
        ))

        (or @arrow_used (not @ins_need_undo))
    ))

;; Do a few things to stop inserting.
;; "end_insert_pos" is where insert ended.
;; It is null when we already jumped to another window/buffer.

(defn- #_void stop-insert [#_pos_C end_insert_pos, #_boolean esc, #_boolean nomove]
    ;; esc: called by ins-esc()
    ;; nomove: <c-\><c-o>, don't move cursor
    (ยง
        (stop-redo-ins)
        (replace-flush)            ;; abandon replace stack

        ;; Save the inserted text for later redo with ^@ and CTRL-A.
        ;; Don't do it when "restart_edit" was set and nothing was inserted,
        ;; otherwise CTRL-O w and then <Left> will clear "last_insert".

        ((ร Bytes ptr =) (get-inserted))
        (when (or (zero? @did_restart_edit) (and (non-nil? ptr) (< @new_insert_skip (STRLEN ptr))))
            (reset! last_insert ptr)
            (reset! last_insert_skip @new_insert_skip)
        )

        (when (and (not @arrow_used) (non-nil? end_insert_pos))
            ;; If we just did an auto-indent, remove the white space from the end of the line,
            ;; and put the cursor back.  Do this when ESC was used or moving the cursor up/down.
            ;; Check for the old position still being valid, just in case the text got changed
            ;; unexpectedly.
            (when (and (not nomove) @did_ai (or esc (and (nil? (vim-strbyte @p_cpo, CPO_INDENT)) (!= (:lnum (:w_cursor @curwin)) (:lnum end_insert_pos)))) (<= (:lnum end_insert_pos) (:ml_line_count (:b_ml @curbuf))))
                (ร int cc)

                ((ร pos_C tpos =) (NEW_pos_C))
                (COPY-pos tpos, (:w_cursor @curwin))

                (COPY-pos (:w_cursor @curwin), end_insert_pos)
                (check-cursor-col)                     ;; make sure it is not past the line
                (while true
                    (if (and (== (gchar-cursor) NUL) (< 0 (:col (:w_cursor @curwin))))
                        (ร --@curwin.w_cursor.col)
                    )
                    ((ร cc =) (gchar-cursor))
                    (if (not (vim-iswhite cc))
                        (ร BREAK)
                    )
                    (if (not (del-char true))
                        (ร BREAK)  ;; should not happen
                    )
                )
                (cond (!= (:lnum (:w_cursor @curwin)) (:lnum tpos))
                (do
                    (COPY-pos (:w_cursor @curwin), tpos)
                )
                :else
                (do
                    ;; reset tpos, could have been invalidated in the loop above
                    (COPY-pos tpos, (:w_cursor @curwin))
                    (ร tpos.col++)
                    (if (and (!= cc NUL) (== (gchar-pos tpos) NUL))
                        (ร @curwin.w_cursor.col++)      ;; put cursor back on the NUL
                    )
                ))

                ;; <C-S-Right> may have started Visual mode, adjust the position for deleted characters.
                (when (and @VIsual_active (== (:lnum @VIsual) (:lnum (:w_cursor @curwin))))
                    ((ร int len =) (STRLEN (ml-get-curline)))

                    (when (< len (:col @VIsual))
                        ((ร @VIsual.col =) len)
                        ((ร @VIsual.coladd =) 0)
                    )
                )
            )
        )

        (reset! did_ai false)
        (reset! did_si false)
        (reset! can_si false)
        (reset! can_si_back false)

        ;; Set '[ and '] to the inserted text.
        ;; When end_insert_pos is null we are now in a different buffer.
        (when (non-nil? end_insert_pos)
            (COPY-pos (:b_op_start @curbuf), @insStart)
            (COPY-pos (:b_op_start_orig @curbuf), @insStart_orig)
            (COPY-pos (:b_op_end @curbuf), end_insert_pos)
        )
        nil
    ))

;; Set the last inserted text to a single character.
;; Used for the replace command.

(defn- #_void set-last-insert [#_int c]
    (ยง
        (reset! last_insert (Bytes. (+ (* MB_MAXBYTES 3) 5)))

        ((ร Bytes s =) @last_insert)
        ;; Use the CTRL-V only when entering a special char.
        (if (or (< c (byte \space)) (== c DEL))
            (.be ((ร s =) (.plus s 1)) -1, Ctrl_V)
        )
        ((ร s =) (add-char2buf c, s))
        (.be ((ร s =) (.plus s 1)) -1, ESC)
        (.be ((ร s =) (.plus s 1)) -1, NUL)
        (reset! last_insert_skip 0)
        nil
    ))

;; Add character "c" to buffer "s".
;; Escape the special meaning of KB_SPECIAL.
;; Handle multi-byte characters.
;; Returns a pointer to after the added bytes.

(defn- #_Bytes add-char2buf [#_int c, #_Bytes s]
    (ยง
        ((ร Bytes temp =) (Bytes. (inc MB_MAXBYTES)))
        ((ร int len =) (utf-char2bytes c, temp))
        (dotimes [#_int i len]
            ((ร byte b =) (.at temp i))
            ;; Need to escape KB_SPECIAL like in the typeahead buffer.
            (cond (== b KB_SPECIAL)
            (do
                (.be ((ร s =) (.plus s 1)) -1, KB_SPECIAL)
                (.be ((ร s =) (.plus s 1)) -1, KS_SPECIAL)
                (.be ((ร s =) (.plus s 1)) -1, KE_FILLER)
            )
            :else
            (do
                (.be ((ร s =) (.plus s 1)) -1, b)
            ))
        )
        s
    ))

;; Move cursor to start of line:
;;  if (flags & BL_WHITE) move to first non-white;
;;  if (flags & BL_SOL)   move to first non-white if startofline is set, otherwise keep "curswant" column;
;;  if (flags & BL_FIX)   don't leave the cursor on a NUL.

(defn- #_void beginline [#_int flags]
    (ยง
        (cond (and (flag? flags BL_SOL) (not @p_sol))
        (do
            (coladvance (:w_curswant @curwin))
        )
        :else
        (do
            ((ร @curwin.w_cursor.col =) 0)
            ((ร @curwin.w_cursor.coladd =) 0)

            (when (flag? flags (| BL_WHITE BL_SOL))
                ((ร FOR) (ร ((ร Bytes ptr =) (ml-get-curline)) (and (vim-iswhite (.at ptr 0)) (not (and (flag? flags BL_FIX) (eos? ptr 1)))) ((ร ptr =) (.plus ptr 1)))
                    (ร @curwin.w_cursor.col++)
                )
            )
            ((ร @curwin.w_set_curswant =) true)
        ))
        nil
    ))

;; oneright oneleft cursor-down cursor-up
;;
;; Move one char {right,left,down,up}.
;; Doesn't move onto the NUL past the end of the line, unless it is allowed.
;; Return true when successful, false when we hit a line of file boundary.

(defn- #_boolean oneright []
    (ยง
        (when (virtual-active)
            ((ร pos_C prevpos =) (NEW_pos_C))
            (COPY-pos prevpos, (:w_cursor @curwin))

            ;; Adjust for multi-wide char (excluding TAB).
            ((ร Bytes ptr =) (ml-get-cursor))
            (coladvance (+ (getviscol) (if (and (!= (.at ptr 0) TAB) (vim-isprintc (us-ptr2char ptr))) (mb-ptr2cells ptr) 1)))
            ((ร @curwin.w_set_curswant =) true)
            ;; Return true if the cursor moved, false otherwise (at window edge).
            ((ร RETURN) (or (!= (:col prevpos) (:col (:w_cursor @curwin))) (!= (:coladd prevpos) (:coladd (:w_cursor @curwin)))))
        )

        ((ร Bytes ptr =) (ml-get-cursor))
        (if (eos? ptr)
            ((ร RETURN) false)           ;; already at the very end
        )

        ((ร int l =) (us-ptr2len-cc ptr))

        ;; Move "l" bytes right, but don't end up on the NUL, unless 'virtualedit' contains "onemore".
        (if (and (eos? ptr l) (non-flag? @ve_flags VE_ONEMORE))
            ((ร RETURN) false)
        )
        ((ร @curwin.w_cursor.col =) (+ (:col (:w_cursor @curwin)) l))

        ((ร @curwin.w_set_curswant =) true)
        true
    ))

(defn- #_boolean oneleft []
    (ยง
        (when (virtual-active)
            ((ร int v =) (getviscol))
            (if (zero? v)
                ((ร RETURN) false)
            )

            ;; We might get stuck on 'showbreak', skip over it.
            ((ร FOR) (ร ((ร int width =) 1) true nil)
                (coladvance (- v width))
                ;; getviscol() is slow, skip it when 'showbreak' is empty,
                ;; 'breakindent' is not set and there are no multi-byte characters
                (if (< (getviscol) v)
                    (ร BREAK)
                )
                (ร width++)
            )

            (when (== (:coladd (:w_cursor @curwin)) 1)
                ;; Adjust for multi-wide char (not a TAB).
                ((ร Bytes ptr =) (ml-get-cursor))
                (if (and (!= (.at ptr 0) TAB) (vim-isprintc (us-ptr2char ptr)) (< 1 (mb-ptr2cells ptr)))
                    ((ร @curwin.w_cursor.coladd =) 0)
                )
            )

            ((ร @curwin.w_set_curswant =) true)
            ((ร RETURN) true)
        )

        (if (zero? (:col (:w_cursor @curwin)))
            ((ร RETURN) false)
        )

        ((ร @curwin.w_set_curswant =) true)
        (ร --@curwin.w_cursor.col)

        ;; If the character on the left of the current cursor is a multi-byte character,
        ;; move to its first byte.
        (mb-adjust-pos @curbuf, (:w_cursor @curwin))
        true
    ))

(defn- #_boolean cursor-up [#_long n, #_boolean upd_topline]
    ;; upd_topline: When true: update topline
    (ยง
        (when (< 0 n)
            ((ร long lnum =) (:lnum (:w_cursor @curwin)))
            ;; This fails if the cursor is already in the first line or the count
            ;; is larger than the line number and '-' is in 'cpoptions'.
            (if (or (<= lnum 1) (and (<= lnum n) (non-nil? (vim-strbyte @p_cpo, CPO_MINUS))))
                ((ร RETURN) false)
            )
            (if (<= lnum n)
                ((ร lnum =) 1)
                ((ร lnum =) (- lnum n))
            )
            ((ร @curwin.w_cursor.lnum =) lnum)
        )

        ;; try to advance to the column we want to be at
        (coladvance (:w_curswant @curwin))

        (if upd_topline
            (update-topline))       ;; make sure curwin.w_topline is valid

        true
    ))

;; Cursor down a number of logical lines.

(defn- #_boolean cursor-down [#_long n, #_boolean upd_topline]
    ;; upd_topline: When true: update topline
    (ยง
        (when (< 0 n)
            ((ร long lnum =) (:lnum (:w_cursor @curwin)))
            ;; This fails if the cursor is already in the last line
            ;; or would move beyond the last line and '-' is in 'cpoptions'.
            (if (or (<= (:ml_line_count (:b_ml @curbuf)) lnum) (and (< (:ml_line_count (:b_ml @curbuf)) (+ lnum n)) (non-nil? (vim-strbyte @p_cpo, CPO_MINUS))))
                ((ร RETURN) false)
            )
            (if (<= (:ml_line_count (:b_ml @curbuf)) (+ lnum n))
                ((ร lnum =) (:ml_line_count (:b_ml @curbuf)))
                ((ร lnum =) (+ lnum n))
            )
            ((ร @curwin.w_cursor.lnum =) lnum)
        )

        ;; try to advance to the column we want to be at
        (coladvance (:w_curswant @curwin))

        (if upd_topline
            (update-topline))       ;; make sure curwin.w_topline is valid

        true
    ))

;; Stuff the last inserted text in the read buffer.
;; Last_insert actually is a copy of the redo buffer, so we
;; first have to remove the command.

(defn- #_boolean stuff-inserted [#_int c, #_long count, #_boolean no_esc]
    ;; c: Command character to be inserted
    ;; count: Repeat this many times
    ;; no_esc: Don't add an ESC at the end
    (ยง
        ((ร Bytes ptr =) (get-last-insert))
        (when (nil? ptr)
            (emsg e_noinstext)
            ((ร RETURN) false)
        )

        ;; may want to stuff the command character, to start Insert mode
        (if (!= c NUL)
            (stuffcharReadbuff c))
        ((ร Bytes esc_ptr =) (vim-strrchr ptr, ESC))
        (if (non-nil? esc_ptr)
            (eos! esc_ptr)     ;; remove the ESC
        )

        ((ร byte last =) NUL)

        ;; when the last char is either "0" or "^" it will be quoted if no ESC comes
        ;; after it OR if it will inserted more than once and "ptr" starts with ^D.

        ((ร Bytes last_ptr =) (if (non-nil? esc_ptr) (.minus esc_ptr 1) (.plus ptr (- (STRLEN ptr) 1))))
        (when (and (BLE ptr, last_ptr) (or (== (.at last_ptr 0) (byte \0)) (== (.at last_ptr 0) (byte \^))) (or no_esc (and (== (.at ptr 0) Ctrl_D) (< 1 count))))
            ((ร last =) (.at last_ptr 0))
            (eos! last_ptr)
        )

;       do
;       {
            (stuffReadbuff ptr)
            ;; a trailing "0" is inserted as "<C-V>048", "^" as "<C-V>^"
            (if (!= last NUL)
                (stuffReadbuff (if (== last (byte \0)) (u8 "\026\060\064\070") (u8 "\026^"))))
;       } while (0 < --count);

        (if (!= last NUL)
            (.be last_ptr 0, last)
        )

        (if (non-nil? esc_ptr)
            (.be esc_ptr 0, ESC)     ;; put the ESC back
        )

        ;; may want to stuff a trailing ESC, to get out of Insert mode
        (if (not no_esc)
            (stuffcharReadbuff ESC))

        true
    ))

(defn- #_Bytes get-last-insert []
    (ยง
        (if (nil? @last_insert)
            ((ร RETURN) nil)
        )

        (.plus @last_insert @last_insert_skip)
    ))

;; Get last inserted string, and remove trailing <Esc>.
;; Returns pointer to allocated memory (must be freed) or null.

(defn- #_Bytes get-last-insert-save []
    (ยง
        (if (nil? @last_insert)
            ((ร RETURN) nil)
        )

        ((ร Bytes s =) (STRDUP (.plus @last_insert @last_insert_skip)))
        ((ร int len =) (STRLEN s))
        (if (and (< 0 len) (== (.at s (dec len)) ESC))       ;; remove trailing ESC
            (.be s (dec len), NUL)
        )
        s
    ))

;; replace-stack functions
;;
;; When replacing characters, the replaced characters are remembered for each
;; new character.  This is used to re-insert the old text when backspacing.
;;
;; There is a NUL headed list of characters for each character that is
;; currently in the file after the insertion point.  When BS is used, one NUL
;; headed list is put back for the deleted character.
;;
;; For a newline, there are two NUL headed lists.  One contains the characters
;; that the NL replaced.  The extra one stores the characters after the cursor
;; that were deleted (always white space).
;;
;; Replace_offset is normally 0, in which case replace-push will add a new
;; character at the end of the stack.  If replace_offset is not 0, that many
;; characters will be left on the stack above the newly inserted character.

(atom! Bytes    replace_stack)
(atom! int      replace_stack_nr)       ;; next entry in replace stack
(atom! int      replace_stack_len)      ;; max. number of entries

(defn- #_void replace-push [#_int c]
    ;; c: character that is replaced (NUL is none)
    (ยง
        (if (< @replace_stack_nr @replace_offset)      ;; nothing to do
            ((ร RETURN) nil)
        )

        (when (<= @replace_stack_len @replace_stack_nr)
            ((ร @replace_stack_len =) (+ @replace_stack_len 50))
            ((ร Bytes p =) (Bytes. @replace_stack_len))
            (if (non-nil? @replace_stack)
                (BCOPY p, @replace_stack, @replace_stack_nr))
            (reset! replace_stack p)
        )

        ((ร Bytes p =) (.plus @replace_stack (- @replace_stack_nr @replace_offset)))
        (if (non-zero? @replace_offset)
            (BCOPY p, 1, p, 0, @replace_offset))
        (.be p 0, c)
        (swap! replace_stack_nr inc)
        nil
    ))

;; Push a character onto the replace stack.
;; Handles a multi-byte character in reverse byte order, so that the first byte is popped off first.
;; Return the number of bytes done (includes composing characters).

(defn- #_int replace-push-mb [#_Bytes p]
    (ยง
        ((ร int l =) (us-ptr2len-cc p))

        ((ร FOR) (ร ((ร int j =) (dec l)) (<= 0 j) (ร --j))
            (replace-push (.at p j))
        )

        l
    ))

;; Pop one item from the replace stack.
;; return -1 if stack empty
;; return replaced character or NUL otherwise

(defn- #_int replace-pop []
    (ยง
        (if (zero? @replace_stack_nr)
            ((ร RETURN) -1)
        )

        (.at @replace_stack (ร --@replace_stack_nr))
    ))

;; Join the top two items on the replace stack.  This removes to "off"'th NUL encountered.

(defn- #_void replace-join [#_int off]
    ;; off: offset for which NUL to remove
    (ยง
        ((ร FOR) (ร ((ร int i =) @replace_stack_nr) (<= 0 (ร --i)) nil)
            (when (and (eos? @replace_stack i) (<= (ร off--) 0))
                (swap! replace_stack_nr dec)
                (BCOPY @replace_stack, i, @replace_stack, (inc i), (- @replace_stack_nr i))
                ((ร RETURN) nil)
            )
        )
        nil
    ))

;; Pop bytes from the replace stack until a NUL is found, and insert them
;; before the cursor.  Can only be used in REPLACE or VREPLACE mode.

(defn- #_void replace-pop-ins []
    (ยง
        ((ร int oldState =) @State)
        (reset! State NORMAL)                     ;; don't want REPLACE here

        ((ร FOR) (ร (ร int cc) (< 0 ((ร cc =) (replace-pop))) nil)
            (mb-replace-pop-ins cc)
            (dec-cursor)
        )

        (reset! State oldState)
        nil
    ))

;; Insert bytes popped from the replace stack. "cc" is the first byte.
;; If it indicates a multi-byte char, pop the other bytes too.

(defn- #_void mb-replace-pop-ins [#_int cc]
    (ยง
        ((ร Bytes buf =) (Bytes. (inc MB_MAXBYTES)))

        ((ร int n =) (mb-byte2len cc))
        (cond (< 1 n)
        (do
            (.be buf 0, cc)
            ((ร FOR) (ร ((ร int i =) 1) (< i n) (ร i++))
                (.be buf i, (replace-pop))
            )
            (ins-bytes-len buf, n)
        )
        :else
        (do
            (ins-char cc)
        ))

        ;; Handle composing chars.
        (while true
            ((ร int c =) (replace-pop))
            (if (== c -1)            ;; stack empty
                (ร BREAK)
            )
            (cond (== ((ร n =) (mb-byte2len c)) 1)
            (do
                ;; Not a multi-byte char, put it back.
                (replace-push c)
                (ร BREAK)
            )
            :else
            (do
                (.be buf 0, c)
                ((ร FOR) (ร ((ร int i =) 1) (< i n) (ร i++))
                    (.be buf i, (replace-pop))
                )
                (cond (utf-iscomposing (us-ptr2char buf))
                (do
                    (ins-bytes-len buf, n)
                )
                :else
                (do
                    ;; Not a composing char, put it back.
                    ((ร FOR) (ร ((ร int i =) (dec n)) (<= 0 i) (ร --i))
                        (replace-push (.at buf i))
                    )
                    (ร BREAK)
                ))
            ))
        )
        nil
    ))

;; make the replace stack empty
;; (called when exiting replace mode)

(defn- #_void replace-flush []
    (reset! replace_stack nil)
    (reset! replace_stack_len 0)
    (reset! replace_stack_nr 0)
    nil)

;; Handle doing a BS for one character.
;; cc < 0: replace stack empty, just move cursor
;; cc == 0: character was inserted, delete it
;; cc > 0: character was replaced, put cc (first byte of original char) back
;; and check for more characters to be put back
;; When "limit_col" is >= 0, don't delete before this column.  Matters when
;; using composing characters, use del-char-after-col() instead of del-char().

(defn- #_void replace-do-bs [#_int limit_col]
    (ยง
        ((ร int orig_len =) 0)
        ((ร int orig_vcols =) 0)

        ((ร int cc =) (replace-pop))
        (cond (< 0 cc)
        (do
            ((ร int[] start_vcol =) (ร new int[1]))
            (when (flag? @State VREPLACE_FLAG)
                ;; Get the number of screen cells used by the character we are going to delete.
                (getvcol @curwin, (:w_cursor @curwin), nil, start_vcol, nil)
                ((ร orig_vcols =) (chartabsize (ml-get-cursor), (... start_vcol 0)))
            )

            (del-char-after-col limit_col)
            (if (flag? @State VREPLACE_FLAG)
                ((ร orig_len =) (STRLEN (ml-get-cursor)))
            )
            (replace-push cc)

            (replace-pop-ins)

            (when (flag? @State VREPLACE_FLAG)
                ;; Get the number of screen cells used by the inserted characters.
                ((ร Bytes p =) (ml-get-cursor))
                ((ร int ins_len =) (- (STRLEN p) orig_len))
                ((ร int vcol =) (... start_vcol 0))
                ((ร FOR) (ร ((ร int i =) 0) (< i ins_len) (ร i++))
                    ((ร vcol =) (+ vcol (chartabsize (.plus p i), vcol)))
                    ((ร i =) (+ i (- (us-ptr2len-cc p) 1)))
                )
                ((ร vcol =) (- vcol (... start_vcol 0)))

                ;; Delete spaces that were inserted after the cursor to keep the text aligned.
                ((ร @curwin.w_cursor.col =) (+ (:col (:w_cursor @curwin)) ins_len))
                (while (and (< orig_vcols vcol) (== (gchar-cursor) (byte \space)))
                    (del-char false)
                    (ร orig_vcols++)
                )
                ((ร @curwin.w_cursor.col =) (- (:col (:w_cursor @curwin)) ins_len))
            )

            ;; mark the buffer as changed and prepare for displaying
            (changed-bytes (:lnum (:w_cursor @curwin)), (:col (:w_cursor @curwin)))
        )
        (zero? cc)
        (do
            (del-char-after-col limit_col)
        ))
        nil
    ))

(defn- #_void ins-reg []
    (ยง
        ((ร boolean need_redraw =) false)
        ((ร int literally =) 0)
        ((ร boolean vis_active =) @VIsual_active)

        ;; If we are going to wait for a character, show a '"'.

        (reset! pc_status PC_STATUS_UNSET)
        (when (and (redrawing) (not (char-avail)))
            ;; May need to redraw when no more chars available now.
            (ins-redraw false)

            (edit-putchar (byte \"), true)  ;; """
            (add-to-showcmd-c Ctrl_R)
        )

        ;; Don't map the register name.
        ;; This also prevents the mode message to be deleted when ESC is hit.

        (swap! no_mapping inc)
        ((ร int regname =) (plain-vgetc))
        (when (or (== regname Ctrl_R) (== regname Ctrl_O) (== regname Ctrl_P))
            ;; Get a third key for literal register insertion.
            ((ร literally =) regname)
            (add-to-showcmd-c literally)
            ((ร regname =) (plain-vgetc))
        )
        (swap! no_mapping dec)

        ;; Don't call u-sync() while typing the expression or giving an error message for it.
        ;; Only call it explicitly.
        (swap! no_u_sync inc)
        (when (== regname (byte \=))
            ;; Sync undo when evaluating the expression calls setline() or append(),
            ;; so that it can be undone separately.
            (reset! u_sync_once 2)

            ((ร regname =) (get-expr-register))
        )
        (cond (or (== regname NUL) (not (valid-yank-reg regname, false)))
        (do
            (vim-beep)
            ((ร need_redraw =) true)     ;; remove the '"'
        )
        :else
        (do
            (cond (or (== literally Ctrl_O) (== literally Ctrl_P))
            (do
                ;; Append the command to the redo buffer.
                (appendCharToRedobuff Ctrl_R)
                (appendCharToRedobuff literally)
                (appendCharToRedobuff regname)

                (do-put regname, BACKWARD, 1, (| (if (== literally Ctrl_P) PUT_FIXINDENT 0) PUT_CURSEND))
            )
            (not (insert-reg regname, (non-zero? literally)))
            (do
                (vim-beep)
                ((ร need_redraw =) true) ;; remove the '"'
            )
            @stop_insert_mode
            (do
                ;; When the '=' register was used and a function was invoked that
                ;; did ":stopinsert" then stuff-empty() returns false but we won't
                ;; insert anything, need to remove the '"'
                ((ร need_redraw =) true)
            ))
        ))
        (swap! no_u_sync dec)
        (if (== @u_sync_once 1)
            (reset! ins_need_undo true))
        (reset! u_sync_once 0)
        (clear-showcmd)

        ;; If the inserted register is empty, we need to remove the '"'.
        (if (or need_redraw (stuff-empty))
            (edit-unputchar))

        ;; Disallow starting Visual mode here, would get a weird mode.
        (when (and (not vis_active) @VIsual_active)
            (end-visual-mode)
        )
        nil
    ))

;; CTRL-G commands in Insert mode.

(defn- #_void ins-ctrl-g []
    (ยง
        ;; Don't map the second key.  This also prevents the mode message to be deleted when ESC is hit.

        (swap! no_mapping inc)
        ((ร int c =) (plain-vgetc))
        (swap! no_mapping dec)
        ((ร SWITCH) c
            ;; CTRL-G k and CTRL-G <Up>: cursor up to insStart.col.
            ((ร CASE) K_UP)
            ((ร CASE) Ctrl_K)
            ((ร CASE) (byte \k))
            (do
                (ins-up true)
                (ร BREAK)
            )

            ;; CTRL-G j and CTRL-G <Down>: cursor down to insStart.col.
            ((ร CASE) K_DOWN)
            ((ร CASE) Ctrl_J)
            ((ร CASE) (byte \j))
            (do
                (ins-down true)
                (ร BREAK)
            )

            ;; CTRL-G u: start new undoable edit.
            ((ร CASE) (byte \u))
            (do
                (u-sync true)
                (reset! ins_need_undo true)

                ;; Need to reset insStart, esp. because a BS that joins
                ;; a line to the previous one must save for undo.
                (reset! update_insStart_orig false)
                (COPY-pos @insStart, (:w_cursor @curwin))
                (ร BREAK)
            )

            ;; Unknown CTRL-G command, reserved for future expansion.
            (ร DEFAULT)
            (do
                (vim-beep)
                (ร BREAK)
            )
        )
        nil
    ))

;; CTRL-^ in Insert mode.

(defn- #_void ins-ctrl-hat []
    (ยง
;       
        (showmode)
        nil
    ))

(atom! boolean disabled_redraw)

;; Handle ESC in insert mode.
;; Returns true when leaving insert mode, false when going to repeat the insert.

(defn- #_boolean ins-esc [#_long* count, #_int cmdchar, #_boolean nomove]
    ;; nomove: don't move cursor
    (ยง
        ((ร int temp =) (:col (:w_cursor @curwin)))

        (when @disabled_redraw
            (swap! redrawingDisabled dec)
            (reset! disabled_redraw false)
        )
        (when (not @arrow_used)
            ;; Don't append the ESC for "r<CR>" and "grx".
            ;; When 'insertmode' is set only CTRL-L stops Insert mode.
            ;; Needed for when "count" is non-zero.

            (if (and (!= cmdchar (byte \r)) (!= cmdchar (byte \v)))
                (appendToRedobuff (if @p_im (u8 "\014") ESC_STR)))

            ;; Repeating insert may take a long time.  Check for interrupt now and then.

            (when (< 0 (... count 0))
                (line-breakcheck)
                (if @got_int
                    ((ร count[0] =) 0)
                )
            )

            (when (< 0 (ร --count[0]))       ;; repeat what was typed
                ;; Vi repeats the insert without replacing characters.
                (if (non-nil? (vim-strbyte @p_cpo, CPO_REPLCNT))
                    ((ร @State =) (& @State (bit-not REPLACE_FLAG)))
                )

                (start-redo-ins)
                (if (or (== cmdchar (byte \r)) (== cmdchar (byte \v)))
                    (stuffRedoReadbuff ESC_STR))     ;; no ESC in redo buffer
                (swap! redrawingDisabled inc)
                (reset! disabled_redraw true)
                ((ร RETURN) false)       ;; repeat the insert
            )
            (stop-insert (:w_cursor @curwin), true, nomove)
        )

        ;; When an autoindent was removed, curswant stays after the indent.
        (if (and (== @restart_edit NUL) (== temp (:col (:w_cursor @curwin))))
            ((ร @curwin.w_set_curswant =) true)
        )

        ;; Remember the last Insert position in the '^ mark.
        (COPY-pos (:b_last_insert @curbuf), (:w_cursor @curwin))

        ;; The cursor should end up on the last inserted character.
        ;; Don't do it for CTRL-O, unless past the end of the line.

        (when (and (not nomove) (or (non-zero? (:col (:w_cursor @curwin))) (< 0 (:coladd (:w_cursor @curwin)))) (or (== @restart_edit NUL) (and (== (gchar-cursor) NUL) (not @VIsual_active))))
            (cond (or (< 0 (:coladd (:w_cursor @curwin))) (== @ve_flags VE_ALL))
            (do
                (oneleft)
                (if (!= @restart_edit NUL)
                    (ร @curwin.w_cursor.coladd++)
                )
            )
            :else
            (do
                (ร --@curwin.w_cursor.col)
                ;; Correct cursor for multi-byte character.
                (mb-adjust-pos @curbuf, (:w_cursor @curwin))
            ))
        )

        (reset! State NORMAL)
        ;; need to position cursor again (e.g. when on a TAB )
        (changed-cline-bef-curs)

        (ui-cursor-shape)          ;; may show different cursor shape

        ;; When recording or for CTRL-O, need to display the new mode.
        ;; Otherwise remove the mode message.

        (cond (or @Recording (!= @restart_edit NUL))
        (do
            (showmode)
        )
        @p_smd
        (do
            (msg (u8 ""))
        ))

        true            ;; exit Insert mode
    ))

;; If 'keymodel' contains "startsel", may start selection.
;; Returns true when a CTRL-O and other keys stuffed.

(defn- #_boolean ins-start-select [#_int c]
    (ยง
        (when @km_startsel
            ((ร SWITCH) c
                ((ร CASE) K_KHOME)
                ((ร CASE) K_KEND)
                ((ร CASE) K_PAGEUP)
                ((ร CASE) K_KPAGEUP)
                ((ร CASE) K_PAGEDOWN)
                ((ร CASE) K_KPAGEDOWN)
                (do
                    (if (non-flag? @mod_mask MOD_MASK_SHIFT)
                        (ร BREAK)
                    )
                    (ร FALLTHROUGH)
                )
                ((ร CASE) K_S_LEFT)
                ((ร CASE) K_S_RIGHT)
                ((ร CASE) K_S_UP)
                ((ร CASE) K_S_DOWN)
                ((ร CASE) K_S_END)
                ((ร CASE) K_S_HOME)
                (do
                    ;; Start selection right away, the cursor can move with
                    ;; CTRL-O when beyond the end of the line.
                    (start-selection)

                    ;; Execute the key in (insert) Select mode.
                    (stuffcharReadbuff Ctrl_O)
                    (when (non-zero? @mod_mask)
                        ((ร Bytes buf =) (Bytes. 4))

                        (.be buf 0, KB_SPECIAL)
                        (.be buf 1, KS_MODIFIER)
                        (.be buf 2, @mod_mask)
                        (eos! buf 3)
                        (stuffReadbuff buf)
                    )
                    (stuffcharReadbuff c)
                    ((ร RETURN) true)
                )
            )
        )

        false
    ))

;; <Insert> key in Insert mode: toggle insert/replace mode.

(defn- #_void ins-insert [#_int replaceState]
    (swap! State #(if (flag? % REPLACE_FLAG) INSERT replaceState))
    (appendCharToRedobuff K_INS)
    (showmode)
    (ui-cursor-shape)          ;; may show different cursor shape
    nil)

;; Pressed CTRL-O in Insert mode.

(defn- #_void ins-ctrl-o []
    (reset! restart_edit (cond (flag? @State VREPLACE_FLAG) (byte \V) (flag? @State REPLACE_FLAG) (byte \R) :else (byte \I)))

    (reset! ins_at_eol (if (virtual-active)
        false     ;; cursor always keeps its column
        (== (gchar-cursor) NUL)))
    nil)

;; If the cursor is on an indent, ^T/^D insert/delete one shiftwidth.
;; Otherwise ^T/^D behave like a "<<" or ">>".
;; Always round the indent to 'shiftwidth', this is compatible with vi.
;; But vi only supports ^T and ^D after an autoindent, we support it everywhere.

(defn- #_void ins-shift [#_int c, #_int lastc]
    (ยง
        (if (not (stop-arrow))
            ((ร RETURN) nil)
        )

        (appendCharToRedobuff c)

        ;; 0^D and ^^D: remove all indent.

        (cond (and (== c Ctrl_D) (or (== lastc (byte \0)) (== lastc (byte \^))) (< 0 (:col (:w_cursor @curwin))))
        (do
            (ร --@curwin.w_cursor.col)
            (del-char false)                ;; delete the '^' or '0'
            ;; In Replace mode, restore the characters that '^' or '0' replaced.
            (if (flag? @State REPLACE_FLAG)
                (replace-pop-ins))
            (if (== lastc (byte \^))
                (reset! old_indent (get-indent)))  ;; remember curr. indent
            (change-indent INDENT_SET, 0, true, NUL, true)
        )
        :else
        (do
            (change-indent (if (== c Ctrl_D) INDENT_DEC INDENT_INC), 0, true, NUL, true)
        ))

        (if (and @did_ai (!= (.at (skipwhite (ml-get-curline)) 0) NUL))
            (reset! did_ai false))
        (reset! did_si false)
        (reset! can_si false)
        (reset! can_si_back false)
        (reset! can_cindent false)        ;; no cindenting after ^D or ^T
        nil
    ))

(defn- #_void ins-del []
    (ยง
        (if (not (stop-arrow))
            ((ร RETURN) nil)
        )

        (cond (== (gchar-cursor) NUL)              ;; delete newline
        (do
            ((ร int temp =) (:col (:w_cursor @curwin)))
            (cond (or (not (can-bs BS_EOL)) (not (do-join 2, false, true, false, false)))                 ;; only if "eol" included
            (do
                (vim-beep)
            )
            :else
            (do
                ((ร @curwin.w_cursor.col =) temp)
            ))
        )
        (not (del-char false))      ;; delete char under cursor
        (do
            (vim-beep)
        ))

        (reset! did_ai false)
        (reset! did_si false)
        (reset! can_si false)
        (reset! can_si_back false)

        (appendCharToRedobuff K_DEL)
        nil
    ))

;; Delete one character for ins-bs().

(defn- #_void ins-bs-one [#_int* vcolp]
    (ยง
        (dec-cursor)
        (getvcol @curwin, (:w_cursor @curwin), vcolp, nil, nil)
        (cond (flag? @State REPLACE_FLAG)
        (do
            ;; Don't delete characters before the insert point when in Replace mode.
            (if (or (!= (:lnum (:w_cursor @curwin)) (:lnum @insStart)) (<= (:col @insStart) (:col (:w_cursor @curwin))))
                (replace-do-bs -1))
        )
        :else
        (do
            (del-char false)
        ))
        nil
    ))

;; Handle Backspace, delete-word and delete-line in Insert mode.
;; Return true when backspace was actually used.

(defn- #_boolean ins-bs [#_int c, #_int mode, #_boolean* inserted_space_p]
    (ยง
        ((ร boolean did_backspace =) false)

        ;; can't delete anything in an empty file
        ;; can't backup past first character in buffer
        ;; can't backup past starting point unless 'backspace' > 1
        ;; can backup to a previous line if 'backspace' == 0

        (when (or (bufempty) (and (== (:lnum (:w_cursor @curwin)) 1) (zero? (:col (:w_cursor @curwin)))) (and (not (can-bs BS_START)) (or @arrow_used (and (== (:lnum (:w_cursor @curwin)) (:lnum @insStart_orig)) (<= (:col (:w_cursor @curwin)) (:col @insStart_orig))))) (and (not (can-bs BS_INDENT)) (not @arrow_used) (< 0 @ai_col) (<= (:col (:w_cursor @curwin)) @ai_col)) (and (not (can-bs BS_EOL)) (zero? (:col (:w_cursor @curwin)))))
            (vim-beep)
            ((ร RETURN) false)
        )

        (if (not (stop-arrow))
            ((ร RETURN) false)
        )

        ((ร boolean in_indent =) (inindent 0))
        (if in_indent
            (reset! can_cindent false))

        ;; Virtualedit:
        ;;  BACKSPACE_CHAR eats a virtual space
        ;;  BACKSPACE_WORD eats all coladd
        ;;  BACKSPACE_LINE eats all coladd and keeps going

        (when (< 0 (:coladd (:w_cursor @curwin)))
            (when (== mode BACKSPACE_CHAR)
                (ร --@curwin.w_cursor.coladd)
                ((ร RETURN) true)
            )
            (when (== mode BACKSPACE_WORD)
                ((ร @curwin.w_cursor.coladd =) 0)
                ((ร RETURN) true)
            )
            ((ร @curwin.w_cursor.coladd =) 0)
        )

        ;; delete newline!

        (cond (zero? (:col (:w_cursor @curwin)))
        (do
            ((ร long lnum =) (:lnum @insStart))
            (when (== (:lnum (:w_cursor @curwin)) lnum)
                (if (not (u-save (- (:lnum (:w_cursor @curwin)) 2), (+ (:lnum (:w_cursor @curwin)) 1)))
                    ((ร RETURN) false)
                )
                (ร --@insStart.lnum)
                ((ร @insStart.col =) MAXCOL)
            )

            ;; In replace mode:
            ;; cc < 0: NL was inserted, delete it
            ;; cc >= 0: NL was replaced, put original characters back

            ((ร int cc =) -1)
            (if (flag? @State REPLACE_FLAG)
                ((ร cc =) (replace-pop))     ;; returns -1 if NL was inserted
            )

            ;; In replace mode, in the line we started replacing, we only move the cursor.

            (cond (and (flag? @State REPLACE_FLAG) (<= (:lnum (:w_cursor @curwin)) lnum))
            (do
                (dec-cursor)
            )
            :else
            (do
                (cond (or (non-flag? @State VREPLACE_FLAG) (< @orig_line_count (:lnum (:w_cursor @curwin))))
                (do
                    ((ร int temp =) (gchar-cursor))      ;; remember current char
                    (ร --@curwin.w_cursor.lnum)

                    (do-join 2, false, false, false, false)
                    (if (and (== temp NUL) (!= (gchar-cursor) NUL))
                        (inc-cursor))
                )
                :else
                (do
                    (dec-cursor)
                ))

                ;; In REPLACE mode we have to put back the text that was replaced by the NL.
                ;; On the replace stack is first a NUL-terminated sequence of characters
                ;; that were deleted and then the characters that NL replaced.

                (when (flag? @State REPLACE_FLAG)
                    ;; Do the next ins-char() in NORMAL state, to prevent ins-char()
                    ;; from replacing characters and avoiding showmatch().

                    ((ร int oldState =) @State)
                    (reset! State NORMAL)

                    ;; restore characters (blanks) deleted after cursor

                    (while (< 0 cc)
                        ((ร int save_col =) (:col (:w_cursor @curwin)))
                        (mb-replace-pop-ins cc)
                        ((ร @curwin.w_cursor.col =) save_col)
                        ((ร cc =) (replace-pop))
                    )
                    ;; restore the characters that NL replaced
                    (replace-pop-ins)
                    (reset! State oldState)
                )
            ))
            (reset! did_ai false)
        )
        :else
        (do
            ;; Delete character(s) before the cursor.

            ((ร int mincol =) 0)
                                                    ;; keep indent
            (when (and (== mode BACKSPACE_LINE) @(:b_p_ai @curbuf))
                ((ร int save_col =) (:col (:w_cursor @curwin)))
                (beginline BL_WHITE)
                (if (< (:col (:w_cursor @curwin)) save_col)
                    ((ร mincol =) (:col (:w_cursor @curwin)))
                )
                ((ร @curwin.w_cursor.col =) save_col)
            )

            ;; Handle deleting one 'shiftwidth' or 'softtabstop'.

            (cond (and (== mode BACKSPACE_CHAR) (or (and @p_sta in_indent) (and (non-zero? (get-sts-value)) (< 0 (:col (:w_cursor @curwin))) (or (== (.at (ml-get-cursor) -1) TAB) (and (== (.at (ml-get-cursor) -1) (byte \space)) (or (not (... inserted_space_p 0)) @arrow_used))))))
            (do
                ((ร inserted_space_p[0] =) false)

                ((ร int ts =) (int (if (and @p_sta in_indent) (get-sw-value @curbuf) (get-sts-value))))

                ;; Compute the virtual column where we want to be.  Since 'showbreak' may
                ;; get in the way, need to get the last column of the previous character.
                ((ร int[] vcol =) (ร new int[1]))
                (getvcol @curwin, (:w_cursor @curwin), vcol, nil, nil)
                ((ร int start_vcol =) (... vcol 0))
                (dec-cursor)
                ((ร int[] want_vcol =) (ร new int[1]))
                (getvcol @curwin, (:w_cursor @curwin), nil, nil, want_vcol)
                (inc-cursor)
                ((ร want_vcol[0] =) (* (/ (... want_vcol 0) ts) ts))

                ;; delete characters until we are at or before "want_vcol"
                (while (and (< (... want_vcol 0) (... vcol 0)) (vim-iswhite (.at (ml-get-cursor) -1)))
                    (ins-bs-one vcol)
                )

                ;; insert extra spaces until we are at "want_vcol"
                (while (< (... vcol 0) (... want_vcol 0))
                    ;; Remember the first char we inserted.
                    (if (and (== (:lnum (:w_cursor @curwin)) (:lnum @insStart_orig)) (< (:col (:w_cursor @curwin)) (:col @insStart_orig)))
                        ((ร @insStart_orig.col =) (:col (:w_cursor @curwin)))
                    )

                    (cond (flag? @State VREPLACE_FLAG)
                    (do
                        (ins-char (byte \space))
                    )
                    :else
                    (do
                        (ins-str (u8 " "))
                        (if (flag? @State REPLACE_FLAG)
                            (replace-push NUL))
                    ))
                    (getvcol @curwin, (:w_cursor @curwin), vcol, nil, nil)
                )

                ;; If we are now back where we started delete one character.
                ;; Can happen when using 'sts' and 'linebreak'.
                (if (<= start_vcol (... vcol 0))
                    (ins-bs-one vcol))
            )
            :else ;; Delete upto starting point, start of line or previous word.
            (do
                ((ร int prev_cclass =) 0)
                ((ร int cclass =) (us-get-class (ml-get-cursor), @curbuf))

                ((ร boolean temp =) false)
;               do
;               {
                    (dec-cursor)           ;; put cursor on char to be deleted

                    ((ร int cc =) (gchar-cursor))
                    ;; look multi-byte character class
                    ((ร prev_cclass =) cclass)
                    ((ร cclass =) (us-get-class (ml-get-cursor), @curbuf))

                    ;; start of word?
                    (cond (and (== mode BACKSPACE_WORD) (not (vim-isspace cc)))
                    (do
                        ((ร mode =) BACKSPACE_WORD_NOT_SPACE)
                        ((ร temp =) (vim-iswordc cc, @curbuf))
                    )
                    ;; end of word?
                    (and (== mode BACKSPACE_WORD_NOT_SPACE) (or (vim-isspace cc) (!= (vim-iswordc cc, @curbuf) temp) (!= prev_cclass cclass)))
                    (do
                        (inc-cursor)
                        (ร BREAK)
                    ))

                    (cond (flag? @State REPLACE_FLAG)
                    (do
                        (replace-do-bs -1)
                    )
                    :else
                    (do
                        ((ร int[] cpc =) (ร new int[MAX_MCO]))   ;; composing characters
                        (if @p_deco
                            (us-ptr2char-cc (ml-get-cursor), cpc))
                        (del-char false)

                        ;; If there are combining characters and 'delcombine' is set
                        ;; move the cursor back.  Don't back up before the base character.

                        (if (and @p_deco (!= (... cpc 0) NUL))
                            (inc-cursor))
                    ))
                    ;; Just a single backspace?:
                    (if (== mode BACKSPACE_CHAR)
                        (ร BREAK)
                    )
;               } while (mincol < @curwin.w_cursor.col && (@curwin.w_cursor.lnum != @insStart_orig.lnum || @curwin.w_cursor.col != @insStart_orig.col));
            ))
            ((ร did_backspace =) true)
        ))

        (reset! did_si false)
        (reset! can_si false)
        (reset! can_si_back false)
        (if (<= (:col (:w_cursor @curwin)) 1)
            (reset! did_ai false))

        ;; It's a little strange to put backspaces into the redo buffer,
        ;; but it makes auto-indent a lot easier to deal with.

        (appendCharToRedobuff c)

        ;; If deleted before the insertion point, adjust it.
        (if (and (== (:lnum (:w_cursor @curwin)) (:lnum @insStart_orig)) (< (:col (:w_cursor @curwin)) (:col @insStart_orig)))
            ((ร @insStart_orig.col =) (:col (:w_cursor @curwin)))
        )

        did_backspace
    ))

(defn- #_void ins-left []
    (ยง
        ((ร pos_C tpos =) (NEW_pos_C))
        (COPY-pos tpos, (:w_cursor @curwin))

        (cond (oneleft)
        (do
            (start-arrow tpos)
        )
        ;; if 'whichwrap' set for cursor in insert mode may go to previous line
        (and (non-nil? (vim-strchr @p_ww, (byte \[))) (< 1 (:lnum (:w_cursor @curwin))))
        (do
            (start-arrow tpos)
            (ร --@curwin.w_cursor.lnum)
            (coladvance MAXCOL)
            ((ร @curwin.w_set_curswant =) true)   ;; so we stay at the end
        )
        :else
        (do
            (vim-beep)
        ))
        nil
    ))

(defn- #_void ins-home [#_int c]
    (ยง
        ((ร pos_C tpos =) (NEW_pos_C))
        (COPY-pos tpos, (:w_cursor @curwin))

        (if (== c K_C_HOME)
            ((ร @curwin.w_cursor.lnum =) 1)
        )
        ((ร @curwin.w_cursor.col =) 0)
        ((ร @curwin.w_cursor.coladd =) 0)
        ((ร @curwin.w_curswant =) 0)

        (start-arrow tpos)
        nil
    ))

(defn- #_void ins-end [#_int c]
    (ยง
        ((ร pos_C tpos =) (NEW_pos_C))
        (COPY-pos tpos, (:w_cursor @curwin))

        (if (== c K_C_END)
            ((ร @curwin.w_cursor.lnum =) (:ml_line_count (:b_ml @curbuf)))
        )
        (coladvance MAXCOL)
        ((ร @curwin.w_curswant =) MAXCOL)

        (start-arrow tpos)
        nil
    ))

(defn- #_void ins-s-left []
    (ยง
        (cond (or (< 1 (:lnum (:w_cursor @curwin))) (< 0 (:col (:w_cursor @curwin))))
        (do
            (start-arrow (:w_cursor @curwin))
            (bck-word 1, false, false)
            ((ร @curwin.w_set_curswant =) true)
        )
        :else
        (do
            (vim-beep)
        ))
        nil
    ))

(defn- #_void ins-right []
    (ยง
        (cond (or (!= (gchar-cursor) NUL) (virtual-active))
        (do
            (start-arrow (:w_cursor @curwin))
            ((ร @curwin.w_set_curswant =) true)
            (if (virtual-active)
                (oneright)
                ((ร @curwin.w_cursor.col =) (+ (:col (:w_cursor @curwin)) (us-ptr2len-cc (ml-get-cursor))))
            )
        )
        ;; if 'whichwrap' set for cursor in insert mode, may move the cursor to the next line
        (and (non-nil? (vim-strchr @p_ww, (byte \]))) (< (:lnum (:w_cursor @curwin)) (:ml_line_count (:b_ml @curbuf))))
        (do
            (start-arrow (:w_cursor @curwin))
            ((ร @curwin.w_set_curswant =) true)
            (ร @curwin.w_cursor.lnum++)
            ((ร @curwin.w_cursor.col =) 0)
        )
        :else
        (do
            (vim-beep)
        ))
        nil
    ))

(defn- #_void ins-s-right []
    (ยง
        (cond (or (< (:lnum (:w_cursor @curwin)) (:ml_line_count (:b_ml @curbuf))) (!= (gchar-cursor) NUL))
        (do
            (start-arrow (:w_cursor @curwin))
            (fwd-word 1, false, false)
            ((ร @curwin.w_set_curswant =) true)
        )
        :else
        (do
            (vim-beep)
        ))
        nil
    ))

(defn- #_void ins-up [#_boolean startcol]
    ;; startcol: when true move to insStart.col
    (ยง
        ((ร long old_topline =) (:w_topline @curwin))

        ((ร pos_C tpos =) (NEW_pos_C))
        (COPY-pos tpos, (:w_cursor @curwin))

        (cond (cursor-up 1, true)
        (do
            (if startcol
                (coladvance (getvcol-nolist @insStart)))
            (if (!= old_topline (:w_topline @curwin))
                (redraw-later VALID))
            (start-arrow tpos)
            (reset! can_cindent true)
        )
        :else
        (do
            (vim-beep)
        ))
        nil
    ))

(defn- #_void ins-pageup []
    (ยง
        (when (non-flag? @mod_mask MOD_MASK_CTRL)
            ((ร pos_C tpos =) (NEW_pos_C))
            (COPY-pos tpos, (:w_cursor @curwin))

            (cond (onepage BACKWARD, 1)
            (do
                (start-arrow tpos)
                (reset! can_cindent true)
            )
            :else
            (do
                (vim-beep)
            ))
        )
        nil
    ))

(defn- #_void ins-down [#_boolean startcol]
    ;; startcol: when true move to insStart.col
    (ยง
        ((ร long old_topline =) (:w_topline @curwin))

        ((ร pos_C tpos =) (NEW_pos_C))
        (COPY-pos tpos, (:w_cursor @curwin))

        (cond (cursor-down 1, true)
        (do
            (if startcol
                (coladvance (getvcol-nolist @insStart)))
            (if (!= old_topline (:w_topline @curwin))
                (redraw-later VALID))
            (start-arrow tpos)
            (reset! can_cindent true)
        )
        :else
        (do
            (vim-beep)
        ))
        nil
    ))

(defn- #_void ins-pagedown []
    (ยง
        (when (non-flag? @mod_mask MOD_MASK_CTRL)
            ((ร pos_C tpos =) (NEW_pos_C))
            (COPY-pos tpos, (:w_cursor @curwin))

            (cond (onepage FORWARD, 1)
            (do
                (start-arrow tpos)
                (reset! can_cindent true)
            )
            :else
            (do
                (vim-beep)
            ))
        )
        nil
    ))

(defn- #_void ins-drop []
    (do-put (byte \~), BACKWARD, 1, PUT_CURSEND)
    nil)

;; Handle TAB in Insert or Replace mode.
;; Return true when the TAB needs to be inserted like a normal character.

(defn- #_boolean ins-tab []
    (ยง
        (if (and (== @insStart_blank_vcol MAXCOL) (== (:lnum (:w_cursor @curwin)) (:lnum @insStart)))
            (reset! insStart_blank_vcol (get-nolist-virtcol)))

        ((ร boolean ind =) (inindent 0))
        (if ind
            (reset! can_cindent false))

        ;; When nothing special, insert TAB like a normal character

        (when (and (not @(:b_p_et @curbuf)) (not (and @p_sta ind (!= @(:b_p_ts @curbuf) (get-sw-value @curbuf)))) (zero? (get-sts-value)))
            ((ร RETURN) true)
        )

        (if (not (stop-arrow))
            ((ร RETURN) true)
        )

        (reset! did_ai false)
        (reset! did_si false)
        (reset! can_si false)
        (reset! can_si_back false)

        (appendToRedobuff (u8 "\t"))

        (ร int temp)
        (cond (and @p_sta ind)                       ;; insert tab in indent, use 'shiftwidth'
        (do
            ((ร temp =) (int (get-sw-value @curbuf)))
        )
        (!= @(:b_p_sts @curbuf) 0)           ;; use 'softtabstop' when set
        (do
            ((ร temp =) (int (get-sts-value)))
        )
        :else                                    ;; otherwise use 'tabstop'
        (do
            ((ร temp =) (int @(:b_p_ts @curbuf)))
        ))
        ((ร temp =) (- temp (% (get-nolist-virtcol) temp)))

        ;; Insert the first space with ins-char().  It will delete one char in
        ;; replace mode.  Insert the rest with ins-str(); it will not delete any
        ;; chars.  For VREPLACE mode, we use ins-char() for all characters.

        (ins-char (byte \space))
        (while (< 0 (ร --temp))
            (cond (flag? @State VREPLACE_FLAG)
            (do
                (ins-char (byte \space))
            )
            :else
            (do
                (ins-str (u8 " "))
                (if (flag? @State REPLACE_FLAG)    ;; no char replaced
                    (replace-push NUL))
            ))
        )

        ;; When 'expandtab' not set: Replace spaces by TABs where possible.

        (when (and (not @(:b_p_et @curbuf)) (or (non-zero? (get-sts-value)) (and @p_sta ind)))
            ;; Get the current line.
            ;; For VREPLACE mode, don't make real changes yet, just work on a copy of the line.

            ((ร pos_C pos =) (NEW_pos_C))
            (ร pos_C cursor)
            ((ร Bytes saved_line =) nil)
            (ร Bytes ptr)
            (cond (flag? @State VREPLACE_FLAG)
            (do
                (COPY-pos pos, (:w_cursor @curwin))
                ((ร cursor =) pos)
                ((ร saved_line =) (STRDUP (ml-get-curline)))
                ((ร ptr =) (.plus saved_line (:col pos)))
            )
            :else
            (do
                ((ร ptr =) (ml-get-cursor))
                ((ร cursor =) (:w_cursor @curwin))
            ))

            ;; Find first white before the cursor.
            ((ร pos_C fpos =) (NEW_pos_C))
            (COPY-pos fpos, (:w_cursor @curwin))
            (while (and (< 0 (:col fpos)) (vim-iswhite (.at ptr -1)))
                (ร --fpos.col)
                ((ร ptr =) (.minus ptr 1))
            )

            ;; In Replace mode, don't change characters before the insert point.
            (when (and (flag? @State REPLACE_FLAG) (== (:lnum fpos) (:lnum @insStart)) (< (:col fpos) (:col @insStart)))
                ((ร ptr =) (.plus ptr (- (:col @insStart) (:col fpos))))
                ((ร fpos.col =) (:col @insStart))
            )

            ;; compute virtual column numbers of first white and cursor
            ((ร int[] vcol =) (ร new int[1]))
            (getvcol @curwin, fpos, vcol, nil, nil)
            ((ร int[] want_vcol =) (ร new int[1]))
            (getvcol @curwin, cursor, want_vcol, nil, nil)

            ((ร int change_col =) -1)
            ;; Use as many TABs as possible.
            ;; Beware of 'breakindent', 'showbreak' and 'linebreak' adding extra virtual columns.
            (while (vim-iswhite (.at ptr 0))
                ((ร int i =) (lbr-chartabsize nil, (u8 "\t"), (... vcol 0)))
                (if (< (... want_vcol 0) (+ (... vcol 0) i))
                    (ร BREAK)
                )
                (when (!= (.at ptr 0) TAB)
                    (.be ptr 0, TAB)
                    (when (< change_col 0)
                        ((ร change_col =) (:col fpos)) ;; column of first change
                        ;; May have to adjust insStart.
                        (if (and (== (:lnum fpos) (:lnum @insStart)) (< (:col fpos) (:col @insStart)))
                            ((ร @insStart.col =) (:col fpos))
                        )
                    )
                )
                (ร fpos.col++)
                ((ร ptr =) (.plus ptr 1))
                ((ร vcol[0] =) (+ (... vcol 0) i))
            )

            (when (<= 0 change_col)
                ((ร int repl_off =) 0)
                ((ร Bytes line =) ptr)

                ;; Skip over the spaces we need.
                (while (and (< (... vcol 0) (... want_vcol 0)) (== (.at ptr 0) (byte \space)))
                    ((ร vcol[0] =) (+ (... vcol 0) (lbr-chartabsize line, ptr, (... vcol 0))))
                    ((ร ptr =) (.plus ptr 1))
                    (ร repl_off++)
                )
                (when (< (... want_vcol 0) (... vcol 0))
                    ;; Must have a char with 'showbreak' just before it.
                    ((ร ptr =) (.minus ptr 1))
                    (ร --repl_off)
                )
                ((ร fpos.col =) (+ (:col fpos) repl_off))

                ;; Delete following spaces.
                ((ร int i =) (- (:col cursor) (:col fpos)))
                (when (< 0 i)
                    (BCOPY ptr, 0, ptr, i, (+ (STRLEN ptr, i) 1))
                    ;; correct replace stack.
                    (when (and (flag? @State REPLACE_FLAG) (non-flag? @State VREPLACE_FLAG))
                        ((ร FOR) (ร ((ร temp =) i) (<= 0 (ร --temp)) nil)
                            (replace-join repl_off)
                        )
                    )
                )
                ((ร cursor.col =) (- (:col cursor) i))

                ;; In VREPLACE mode, we haven't changed anything yet.  Do it now by
                ;; backspacing over the changed spacing and then inserting the new spacing.

                (when (flag? @State VREPLACE_FLAG)
                    ;; Backspace from real cursor to change_col.
                    (backspace-until-column change_col)

                    ;; Insert each char in saved_line from changed_col to ptr-cursor.
                    (ins-bytes-len (.plus saved_line change_col), (- (:col cursor) change_col))
                )
            )
        )

        false
    ))

;; Handle CR or NL in insert mode.
;; Return true when out of memory or can't undo.

(defn- #_boolean ins-eol [#_int c]
    (ยง
        (if (not (stop-arrow))
            ((ร RETURN) true)
        )

        ;; Strange Vi behaviour:
        ;; In Replace mode, typing a NL will not delete the character under the cursor.
        ;; Only push a NUL on the replace stack, nothing to put back when the NL is deleted.

        (when (and (flag? @State REPLACE_FLAG) (non-flag? @State VREPLACE_FLAG))
            (replace-push NUL)
        )

        ;; In VREPLACE mode, a NL replaces the rest of the line, and starts replacing the next line,
        ;; so we push all of the characters left on the line onto the replace stack.
        ;; This is not done here though, it is done in open-line().

        ;; Put cursor on NUL if on the last char and coladd is 1 (happens after CTRL-O).
        (if (and (virtual-active) (< 0 (:coladd (:w_cursor @curwin))))
            (coladvance (getviscol)))

        (appendToRedobuff NL_STR)
        ((ร boolean b =) (open-line FORWARD, 0, @old_indent))
        (reset! old_indent 0)
        (reset! can_cindent true)

        (not b)
    ))

;; Handle digraph in insert mode.
;; Returns character still to be inserted, or NUL when nothing remaining to be done.

(defn- #_int ins-digraph []
    (ยง
        ((ร boolean did_putchar =) false)

        (reset! pc_status PC_STATUS_UNSET)
        (when (and (redrawing) (not (char-avail)))
            ;; May need to redraw when no more chars available now.
            (ins-redraw false)

            (edit-putchar (byte \?), true)
            ((ร did_putchar =) true)
            (add-to-showcmd-c Ctrl_K)
        )

        ;; Don't map the digraph chars.
        ;; This also prevents the mode message to be deleted when ESC is hit.
        (swap! no_mapping inc)
        (swap! allow_keys inc)
        ((ร int c =) (plain-vgetc))
        (swap! no_mapping dec)
        (swap! allow_keys dec)
        (when did_putchar
            ;; When the line fits in 'columns',
            ;; the '?' is at the start of the next line and will not be removed by the redraw.
            (edit-unputchar)
        )

        (when (or (is-special c) (non-zero? @mod_mask))         ;; special key
            (clear-showcmd)
            (insert-special c, true, false)
            ((ร RETURN) NUL)
        )

        (when (!= c ESC)
            ((ร did_putchar =) false)
            (when (and (redrawing) (not (char-avail)))
                ;; May need to redraw when no more chars available now.
                (ins-redraw false)

                (when (== (mb-char2cells c) 1)
                    (ins-redraw false)
                    (edit-putchar c, true)
                    ((ร did_putchar =) true)
                )
                (add-to-showcmd-c c)
            )
            (swap! no_mapping inc)
            (swap! allow_keys inc)
            ((ร int cc =) (plain-vgetc))
            (swap! no_mapping dec)
            (swap! allow_keys dec)
            (when did_putchar
                ;; When the line fits in 'columns',
                ;; the '?' is at the start of the next line and will not be removed by a redraw.
                (edit-unputchar)
            )
            (when (!= cc ESC)
                (appendToRedobuff CTRL_V_STR)
                ((ร c =) (getdigraph c, cc, true))
                (clear-showcmd)
                ((ร RETURN) c)
            )
        )
        (clear-showcmd)
        NUL
    ))

;; Handle CTRL-E and CTRL-Y in Insert mode: copy char from other line.
;; Returns the char to be inserted, or NUL if none found.

(defn- #_int ins-copychar [#_long lnum]
    (ยง
        (when (or (< lnum 1) (< (:ml_line_count (:b_ml @curbuf)) lnum))
            (vim-beep)
            ((ร RETURN) NUL)
        )

        ;; try to advance to the cursor column
        ((ร Bytes line =) (ml-get lnum))
; %%    ((ร Bytes[] ptr =) (ร { line }))
        ((ร Bytes prev_ptr =) (... ptr 0))
        (validate-virtcol)

        ((ร int temp =) 0)
        (while (and (< temp (:w_virtcol @curwin)) (non-eos? (... ptr 0)))
            ((ร prev_ptr =) (... ptr 0))
            ((ร temp =) (+ temp (lbr-chartabsize-adv line, ptr, temp)))
        )
        (if (< (:w_virtcol @curwin) temp)
            ((ร ptr[0] =) prev_ptr)
        )

        ((ร int c =) (us-ptr2char (... ptr 0)))
        (if (== c NUL)
            (vim-beep))
        c
    ))

;; CTRL-Y or CTRL-E typed in Insert mode.

(defn- #_int ins-ctrl-ey [#_int tc]
    (ยง
        ((ร int c =) (ins-copychar (+ (:lnum (:w_cursor @curwin)) (if (== tc Ctrl_Y) -1 1))))
        (when (!= c NUL)
            ;; The character must be taken literally, insert like it was typed after a CTRL-V.
            ;; Digits, 'o' and 'x' are special after a CTRL-V, don't use it for these.
            (if (and (< c 256) (not (asc-isalnum c)))
                (appendToRedobuff CTRL_V_STR)) ;; CTRL-V

            (insert-special c, true, false)

            ((ร c =) Ctrl_V)                     ;; pretend CTRL-V is last character
        )

        c
    ))

;; Try to do some very smart auto-indenting.
;; Used when inserting a "normal" character.

(defn- #_void ins-try-si [#_int c]
    (ยง
        ;; do some very smart indenting when entering '{' or '}'

        (when (or (and (or @did_si @can_si_back) (== c (byte \{))) (and @can_si (== c (byte \}))))
            (ร pos_C pos)

            ;; for '}' set indent equal to indent of line containing matching '{'

            (cond (and (== c (byte \})) (non-nil? ((ร pos =) (findmatch nil, (byte \{)))))
            (do
                ((ร pos_C old_pos =) (NEW_pos_C))
                (COPY-pos old_pos, (:w_cursor @curwin))

                ;; If the matching '{' has a ')' immediately before it (ignoring
                ;; white-space), then line up with the start of the line containing
                ;; the matching '(' if there is one.  This handles the case where
                ;; an "if (..\n..) {" statement continues over multiple lines.

                ((ร Bytes ptr =) (ml-get (:lnum pos)))
                ((ร int i =) (:col pos))
                (when (< 0 i)          ;; skip blanks before '{'
                    (while (and (< 0 (ร --i)) (vim-iswhite (.at ptr i)))
                        ;
                    )
                )
                ((ร @curwin.w_cursor.lnum =) (:lnum pos))
                ((ร @curwin.w_cursor.col =) i)
                (if (and (== (.at ptr i) (byte \))) (non-nil? ((ร pos =) (findmatch nil, (byte \()))))
                    (COPY-pos (:w_cursor @curwin), pos))
                ((ร i =) (get-indent))
                (COPY-pos (:w_cursor @curwin), old_pos)
                (if (flag? @State VREPLACE_FLAG)
                    (change-indent INDENT_SET, i, false, NUL, true)
                    (set-indent i, SIN_CHANGED))
            )
            (< 0 (:col (:w_cursor @curwin)))
            (do
                ;; when inserting '{' after "O" reduce indent,
                ;; but not more than indent of previous line

                ((ร boolean temp =) true)
                (when (and (== c (byte \{)) @can_si_back (< 1 (:lnum (:w_cursor @curwin))))
                    ((ร pos_C old_pos =) (NEW_pos_C))
                    (COPY-pos old_pos, (:w_cursor @curwin))
                    ((ร int i =) (get-indent))
                    (while (< 1 (:lnum (:w_cursor @curwin)))
                        ((ร Bytes ptr =) (skipwhite (ml-get (ร --@curwin.w_cursor.lnum))))

                        ;; ignore empty lines and lines starting with '#'.
                        (if (and (!= (.at ptr 0) (byte \#)) (non-eos? ptr))
                            (ร BREAK)
                        )
                    )
                    (if (<= i (get-indent))
                        ((ร temp =) false)
                    )
                    (COPY-pos (:w_cursor @curwin), old_pos)
                )
                (if temp
                    (shift-line true, false, 1, true))
            ))
        )

        ;; set indent of '#' always to 0

        (when (and (< 0 (:col (:w_cursor @curwin))) @can_si (== c (byte \#)))
            ;; remember current indent for next line
            (reset! old_indent (get-indent))
            (set-indent 0, SIN_CHANGED)
        )

        ;; Adjust ai_col, the char at this position can be deleted.
        (when (> @ai_col (:col (:w_cursor @curwin)))
            (reset! ai_col (:col (:w_cursor @curwin)))
        )
        nil
    ))

;; Get the value that w_virtcol would have when 'list' is off.

(defn- #_int get-nolist-virtcol []
    (validate-virtcol)
    (:w_virtcol @curwin))

;; Handle the InsertCharPre autocommand.
;; "c" is the character that was typed.
;; Return a pointer to allocated memory with the replacement string.
;; Return null to continue inserting "c".

(defn- #_Bytes do-insert-char-pre [#_int c]
    ;; %% not yet
    nil)

;;; ============================================================================================== VimN

;; regexp.c ---------------------------------------------------------------------------------------

;; Handling of regular expressions: vim-regcomp(), vim-regexec(), vim-regsub()
;;
;; Beware that some of this code is subtly aware of the way operator
;; precedence is structured in regular expressions.  Serious changes in
;; regular-expression syntax might require a total rethink.

;; The "internal use only" fields in regexp.h are present to pass info from
;; compile to execute that permits the execute phase to run lots faster on
;; simple cases.  They are:
;;
;; regstart     char that must begin a match; NUL if none obvious; Can be a
;;              multi-byte character.
;; reganch      is the match anchored (at beginning-of-line only)?
;; regmust      string (pointer into program) that match must include, or null
;; regmlen      length of regmust string
;; regflags     RF_ values or'ed together
;;
;; Regstart and reganch permit very fast decisions on suitable starting points
;; for a match, cutting down the work a lot.  Regmust permits fast rejection
;; of lines that cannot possibly match.  The regmust tests are costly enough
;; that vim-regcomp() supplies a regmust only if the r.e. contains something
;; potentially expensive (at present, the only such thing detected is * or +
;; at the start of the r.e., which can involve a lot of backup).  Regmlen is
;; supplied because the test in vim-regexec() needs it and vim-regcomp() is
;; computing it anyway.

;; Structure for regexp "program".  This is essentially a linear encoding
;; of a nondeterministic finite-state machine (aka syntax charts or
;; "railroad normal form" in parsing technology).  Each node is an opcode
;; plus a "next" pointer, possibly plus an operand.  "Next" pointers of
;; all nodes except BRANCH and BRACES_COMPLEX implement concatenation; a "next"
;; pointer with a BRANCH on both ends of it is connecting two alternatives.
;; (Here we have one of the subtle syntax dependencies: an individual BRANCH
;; (as opposed to a collection of them) is never concatenated with anything
;; because of operator precedence).  The "next" pointer of a BRACES_COMPLEX
;; node points to the node after the stuff to be repeated.
;; The operand of some types of node is a literal string; for others, it is a
;; node leading into a sub-FSM.  In particular, the operand of a BRANCH node
;; is the first node of the branch.
;; (NB this is *not* a tree structure: the tail of the branch connects to the
;; thing following the set of BRANCHes.)
;;
;; pattern      is coded like:
;;
;;                        +-----------------+
;;                        |                 V
;; <aa>\|<bb>   BRANCH <aa> BRANCH <bb> --> END
;;                   |      ^    |          ^
;;                   +------+    +----------+
;;
;;                     +------------------+
;;                     V                  |
;; <aa>*        BRANCH BRANCH <aa> --> BACK BRANCH --> NOTHING --> END
;;                   |      |               ^                      ^
;;                   |      +---------------+                      |
;;                   +---------------------------------------------+
;;
;;                     +----------------------+
;;                     V                      |
;; <aa>\+       BRANCH <aa> --> BRANCH --> BACK  BRANCH --> NOTHING --> END
;;                   |               |           ^                      ^
;;                   |               +-----------+                      |
;;                   +--------------------------------------------------+
;;
;;                                      +-------------------------+
;;                                      V                         |
;; <aa>\{}      BRANCH BRACE_LIMITS --> BRACE_COMPLEX <aa> --> BACK  END
;;                   |                              |                ^
;;                   |                              +----------------+
;;                   +-----------------------------------------------+
;;
;; <aa>\@!<bb>  BRANCH NOMATCH <aa> --> END  <bb> --> END
;;                   |       |                ^       ^
;;                   |       +----------------+       |
;;                   +--------------------------------+
;;
;;                                                    +---------+
;;                                                    |         V
;; \z[abc]      BRANCH BRANCH  a  BRANCH  b  BRANCH  c  BRANCH  NOTHING --> END
;;                   |      |          |          |     ^                   ^
;;                   |      |          |          +-----+                   |
;;                   |      |          +----------------+                   |
;;                   |      +---------------------------+                   |
;;                   +------------------------------------------------------+
;;
;; They all start with a BRANCH for "\|" alternatives, even when there is only
;; one alternative.

;; The opcodes are:

;; definition   number             opnd?    meaning
(final int END             0)       ;;      End of program or NOMATCH operand.
(final int BOL             1)       ;;      Match "" at beginning of line.
(final int EOL             2)       ;;      Match "" at end of line.
(final int BRANCH          3)       ;; node Match this alternative, or the next...
(final int BACK            4)       ;;      Match "", "next" ptr points backward.
(final int EXACTLY         5)       ;; str  Match this string.
(final int NOTHING         6)       ;;      Match empty string.
(final int STAR            7)       ;; node Match this (simple) thing 0 or more times.
(final int PLUS            8)       ;; node Match this (simple) thing 1 or more times.
(final int MATCH           9)       ;; node match the operand zero-width
(final int NOMATCH         10)      ;; node check for no match with operand
(final int BEHIND          11)      ;; node look behind for a match with operand
(final int NOBEHIND        12)      ;; node look behind for no match with operand
(final int SUBPAT          13)      ;; node match the operand here
(final int BRACE_SIMPLE    14)      ;; node Match this (simple) thing between m and
                                    ;;      n times (\{m,n\}).
(final int BOW             15)      ;;      Match "" after [^a-zA-Z0-9_]
(final int EOW             16)      ;;      Match "" at    [^a-zA-Z0-9_]
(final int BRACE_LIMITS    17)      ;; nr nr  define the min & max for BRACE_SIMPLE
                                    ;;      and BRACE_COMPLEX.
(final int NEWL            18)      ;;      Match line-break
(final int BHPOS           19)      ;;      End position for BEHIND or NOBEHIND

;; character classes: 20-48 normal, 50-78 include a line-break
(final int ADD_NL          30)

(final int ANY             20)      ;;      Match any one character.
(final int ANYOF           21)      ;; str  Match any character in this string.
(final int ANYBUT          22)      ;; str  Match any character not in this string.
(final int IDENT           23)      ;;      Match identifier char
(final int SIDENT          24)      ;;      Match identifier char but no digit
(final int KWORD           25)      ;;      Match keyword char
(final int SKWORD          26)      ;;      Match word char but no digit
(final int FNAME           27)      ;;      Match file name char
(final int SFNAME          28)      ;;      Match file name char but no digit
(final int PRINT           29)      ;;      Match printable char
(final int SPRINT          30)      ;;      Match printable char but no digit
(final int WHITE           31)      ;;      Match whitespace char
(final int NWHITE          32)      ;;      Match non-whitespace char
(final int DIGIT           33)      ;;      Match digit char
(final int NDIGIT          34)      ;;      Match non-digit char
(final int HEX             35)      ;;      Match hex char
(final int NHEX            36)      ;;      Match non-hex char
(final int OCTAL           37)      ;;      Match octal char
(final int NOCTAL          38)      ;;      Match non-octal char
(final int WORD            39)      ;;      Match word char
(final int NWORD           40)      ;;      Match non-word char
(final int HEAD            41)      ;;      Match head char
(final int NHEAD           42)      ;;      Match non-head char
(final int ALPHA           43)      ;;      Match alpha char
(final int NALPHA          44)      ;;      Match non-alpha char
(final int LOWER           45)      ;;      Match lowercase char
(final int NLOWER          46)      ;;      Match non-lowercase char
(final int UPPER           47)      ;;      Match uppercase char
(final int NUPPER          48)      ;;      Match non-uppercase char

(final int FIRST_NL        (+ ANY ADD_NL))
(final int LAST_NL         (+ NUPPER ADD_NL))

(defn- #_boolean with-nl [#_int op]
    (<= FIRST_NL op LAST_NL))

(final int MOPEN           80)  ;; -89       Mark this point in input as start of
                                    ;;       \( subexpr.  MOPEN + 0 marks start of match.
(final int MCLOSE          90)  ;; -99       Analogous to MOPEN.  MCLOSE + 0 marks
                                    ;;       end of match.
(final int BACKREF         100) ;; -109 node Match same string again \1-\9

(final int ZOPEN           110) ;; -119      Mark this point in input as start of \z( subexpr.
(final int ZCLOSE          120) ;; -129      Analogous to ZOPEN.
(final int ZREF            130) ;; -139 node Match external submatch \z1-\z9

(final int BRACE_COMPLEX   140) ;; -149 node Match nodes between m & n times

(final int NOPEN           150)     ;;      Mark this point in input as start of \%( subexpr.
(final int NCLOSE          151)     ;;      Analogous to NOPEN.

(final int MULTIBYTECODE   200)     ;; mbc  Match one multi-byte character
(final int RE_BOF          201)     ;;      Match "" at beginning of file.
(final int RE_EOF          202)     ;;      Match "" at end of file.
(final int CURSOR          203)     ;;      Match location of cursor.

(final int RE_LNUM         204)     ;; nr cmp  Match line number
(final int RE_COL          205)     ;; nr cmp  Match column number
(final int RE_VCOL         206)     ;; nr cmp  Match virtual column number

(final int RE_MARK         207)     ;; mark cmp  Match mark position
(final int RE_VISUAL       208)     ;;      Match Visual area
(final int RE_COMPOSING    209)     ;; any composing characters

;; Magic characters have a special meaning, they don't match literally.
;; Magic characters are negative.  This separates them from literal characters
;; (possibly multi-byte).  Only ASCII characters can be Magic.

(defn- #_final #_int Magic [#_int x]
    (- x 256))

(defn- #_int un-Magic [#_int x]
    (+ x 256))

(defn- #_boolean is-Magic [#_int x]
    (< x 0))

(defn- #_int no-Magic [#_int x]
    (if (is-Magic x) (un-Magic x) x))

(defn- #_int toggle-Magic [#_int x]
    (if (is-Magic x) (un-Magic x) (Magic x)))

;; The first byte of the regexp internal "program" is actually this magic number;
;; the start node begins in the second byte.
;; It's used to catch the most severe mutilation of the program by the caller.

(final byte! REGMAGIC 0234)

;; Opcode notes:
;;
;; BRANCH           The set of branches constituting a single choice are hooked
;;                  together with their "next" pointers, since precedence prevents
;;                  anything being concatenated to any individual branch.  The
;;                  "next" pointer of the last BRANCH in a choice points to the
;;                  thing following the whole choice.  This is also where the
;;                  final "next" pointer of each individual branch points; each
;;                  branch starts with the operand node of a BRANCH node.
;;
;; BACK             Normal "next" pointers all implicitly point forward; BACK
;;                  exists to make loop structures possible.
;;
;; STAR,PLUS        '=', and complex '*' and '+', are implemented as circular
;;                  BRANCH structures using BACK.  Simple cases (one character
;;                  per match) are implemented with STAR and PLUS for speed
;;                  and to minimize recursive plunges.
;;
;; BRACE_LIMITS     This is always followed by a BRACE_SIMPLE or BRACE_COMPLEX
;;                  node, and defines the min and max limits to be used for that node.
;;
;; MOPEN, MCLOSE    ... are numbered at compile time.
;; ZOPEN, ZCLOSE    ... ditto

;; A node is one char of opcode followed by two chars of "next" pointer.
;; "Next" pointers are stored as two 8-bit bytes, high order first.  The
;; value is a positive offset from the opcode of the node containing it.
;; An operand, if any, simply follows the node.  (Note that much of the
;; code generation knows about this implicit relationship.)
;;
;; Using two bytes for the "next" pointer is vast overkill for most things,
;; but allows patterns to get big without disasters.

(defn- #_int re-op [#_Bytes p]
    (int (.at p 0)))

(defn- #_int re-next [#_Bytes p]
    (+ (<< (int (.at p 1)) 8) (int (.at p 2))))

(defn- #_Bytes operand [#_Bytes p]
    (.plus p 3))

;; Obtain an operand that was stored as four bytes, MSB first.
(defn- #_long operand-min [#_Bytes p]
    (+ (<< (long (.at p 3)) 24) (<< (long (.at p 4)) 16) (<< (long (.at p 5)) 8) (long (.at p 6))))

;; Obtain a second operand stored as four bytes.
(defn- #_long operand-max [#_Bytes p]
    (operand-min (.plus p 4)))

;; Obtain a second single-byte operand stored after a four bytes operand.
(defn- #_byte operand-cmp [#_Bytes p]
    (.at p 7))

(final long MAX_LIMIT       (<< 32767 16))

(final Bytes e_missingbracket  (u8 "E769: Missing ] after %s["))
(final Bytes e_unmatchedpp     (u8 "E53: Unmatched %s%%("))
(final Bytes e_unmatchedp      (u8 "E54: Unmatched %s("))
(final Bytes e_unmatchedpar    (u8 "E55: Unmatched %s)"))
(final Bytes e_z_not_allowed   (u8 "E66: \\z( not allowed here"))
(final Bytes e_z1_not_allowed  (u8 "E67: \\z1 et al. not allowed here"))
(final Bytes e_missing_sb      (u8 "E69: Missing ] after %s%%["))
(final Bytes e_empty_sb        (u8 "E70: Empty %s%%[]"))

(final int NOT_MULTI       0)
(final int MULTI_ONE       1)
(final int MULTI_MULT      2)

;; Return NOT_MULTI if c is not a "multi" operator.
;; Return MULTI_ONE if c is a single "multi" operator.
;; Return MULTI_MULT if c is a multi "multi" operator.

(defn- #_int re-multi-type [#_int c]
    (cond
        (or (== c (Magic (byte \@))) (== c (Magic (byte \=))) (== c (Magic (byte \?))))
            MULTI_ONE
        (or (== c (Magic (byte \*))) (== c (Magic (byte \+))) (== c (Magic (byte \{))))
            MULTI_MULT
        :else
            NOT_MULTI
    ))

;; Flags to be passed up and down.

(final int HASWIDTH        0x1)     ;; Known never to match null string.
(final int SIMPLE          0x2)     ;; Simple enough to be STAR/PLUS operand.
(final int SPSTART         0x4)     ;; Starts with * or +.
(final int HASNL           0x8)     ;; Contains some \n.
(final int HASLOOKBH       0x10)    ;; Contains "\@<=" or "\@<!".
(final int WORST           0)       ;; Worst case.

;; When regcode is set to this value, code is not emitted and size is computed instead.

(final Bytes JUST_CALC_SIZE (u8 ""))

(atom! Bytes reg_prev_sub)

;; REGEXP_INRANGE contains all characters which are always special in a [] range after '\'.
;; REGEXP_ABBR contains all characters which act as abbreviations after '\'.
;; These are:
;;  \n  - New line (NL).
;;  \r  - Carriage Return (CR).
;;  \t  - Tab (TAB).
;;  \e  - Escape (ESC).
;;  \b  - Backspace (Ctrl_H).
;;  \d  - Character code in decimal, e.g. \d123
;;  \o  - Character code in octal, e.g. \o80
;;  \x  - Character code in hex, e.g. \x4a
;;  \\u (sic!) - Multibyte character code, e.g. \u20ac
;;  \U  - Long multibyte character code, e.g. \U12345678

(final Bytes REGEXP_INRANGE (u8 "]^-n\\"))
(final Bytes REGEXP_ABBR (u8 "nrtebdoxuU"))

;; Translate '\x' to its control character, except "\n", which is Magic.

(defn- #_int backslash-trans [#_int c]
    (ยง
        ((ร SWITCH) c
            ((ร CASE) (byte \r))
            (do
                ((ร RETURN) CAR)
            )
            ((ร CASE) (byte \t))
            (do
                ((ร RETURN) TAB)
            )
            ((ร CASE) (byte \e))
            (do
                ((ร RETURN) ESC)
            )
            ((ร CASE) (byte \b))
            (do
                ((ร RETURN) BS)
            )
        )
        c
    ))

(final int
    CLASS_ALNUM 0,
    CLASS_ALPHA 1,
    CLASS_BLANK 2,
    CLASS_CNTRL 3,
    CLASS_DIGIT 4,
    CLASS_GRAPH 5,
    CLASS_LOWER 6,
    CLASS_PRINT 7,
    CLASS_PUNCT 8,
    CLASS_SPACE 9,
    CLASS_UPPER 10,
    CLASS_XDIGIT 11,
    CLASS_TAB 12,
    CLASS_RETURN 13,
    CLASS_BACKSPACE 14,
    CLASS_ESCAPE 15,
    CLASS_NONE 99)

(final Bytes* class_names
    [
        (u8 "alnum:]")
        (u8 "alpha:]")
        (u8 "blank:]")
        (u8 "cntrl:]")
        (u8 "digit:]")
        (u8 "graph:]")
        (u8 "lower:]")
        (u8 "print:]")
        (u8 "punct:]")
        (u8 "space:]")
        (u8 "upper:]")
        (u8 "xdigit:]")
        (u8 "tab:]")
        (u8 "return:]")
        (u8 "backspace:]")
        (u8 "escape:]")
    ])

;; Check for a character class name "[:name:]".  "pp" points to the '['.
;; Returns one of the CLASS_ items.  CLASS_NONE means that no item was
;; recognized.  Otherwise "pp" is advanced to after the item.

(defn- #_int get-char-class [#_Bytes* pp]
    (ยง
        (when (== (.at (... pp 0) 1) (byte \:))
            (dotimes [#_int i (:length class_names)]
                ((ร int len =) (STRLEN (... class_names i)))
                (when (zero? (STRNCMP (.plus (... pp 0) 2), (... class_names i), len))
                    ((ร pp[0] =) (.plus (... pp 0) (+ len 2)))
                    ((ร RETURN) i)
                )
            )
        )
        CLASS_NONE
    ))

;; Specific version of character class functions.
;; Using a table to keep this fast.

(atom! int* class_tab 256)

(final int
    RI_DIGIT    0x01,
    RI_HEX      0x02,
    RI_OCTAL    0x04,
    RI_WORD     0x08,
    RI_HEAD     0x10,
    RI_ALPHA    0x20,
    RI_LOWER    0x40,
    RI_UPPER    0x80,
    RI_WHITE    0x100)

(atom! boolean class_tab_done)

(defn- #_void init-class-tab []
    (ยง
        (if @class_tab_done
            ((ร RETURN) nil)
        )

        (dotimes [#_int i 256]
            ((ร @class_tab[i] =) (cond
                (<= (byte \0) i (byte \7)) (+ RI_DIGIT RI_HEX RI_OCTAL RI_WORD)
                (<= (byte \8) i (byte \9)) (+ RI_DIGIT RI_HEX RI_WORD)
                (<= (byte \a) i (byte \f)) (+ RI_HEX RI_WORD RI_HEAD RI_ALPHA RI_LOWER)
                (<= (byte \g) i (byte \z)) (+ RI_WORD RI_HEAD RI_ALPHA RI_LOWER)
                (<= (byte \A) i (byte \F)) (+ RI_HEX RI_WORD RI_HEAD RI_ALPHA RI_UPPER)
                (<= (byte \G) i (byte \Z)) (+ RI_WORD RI_HEAD RI_ALPHA RI_UPPER)
                (== i (byte \_)) (+ RI_WORD RI_HEAD)
                :else 0
            ))
        )
        ((ร @class_tab[(byte \space)] =) (| (... @class_tab (byte \space)) RI_WHITE))
        ((ร @class_tab[TAB] =) (| (... @class_tab TAB) RI_WHITE))

        (reset! class_tab_done true)
        nil
    ))

(defn- #_boolean ri-digit [#_int c] (and (< c 0x100) (flag? (... @class_tab c) RI_DIGIT)))
(defn- #_boolean ri-hex   [#_int c] (and (< c 0x100) (flag? (... @class_tab c) RI_HEX)))
(defn- #_boolean ri-octal [#_int c] (and (< c 0x100) (flag? (... @class_tab c) RI_OCTAL)))
(defn- #_boolean ri-word  [#_int c] (and (< c 0x100) (flag? (... @class_tab c) RI_WORD)))
(defn- #_boolean ri-head  [#_int c] (and (< c 0x100) (flag? (... @class_tab c) RI_HEAD)))
(defn- #_boolean ri-alpha [#_int c] (and (< c 0x100) (flag? (... @class_tab c) RI_ALPHA)))
(defn- #_boolean ri-lower [#_int c] (and (< c 0x100) (flag? (... @class_tab c) RI_LOWER)))
(defn- #_boolean ri-upper [#_int c] (and (< c 0x100) (flag? (... @class_tab c) RI_UPPER)))
(defn- #_boolean ri-white [#_int c] (and (< c 0x100) (flag? (... @class_tab c) RI_WHITE)))

;; flags for regflags
(final int RF_ICASE    1)   ;; ignore case
(final int RF_NOICASE  2)   ;; don't ignore case
(final int RF_HASNL    4)   ;; can match a NL
(final int RF_ICOMBINE 8)   ;; ignore combining characters
(final int RF_LOOKBH   16)  ;; uses "\@<=" or "\@<!"

;; Global work variables for vim-regcomp().

(atom! Bytes    regparse)                   ;; input-scan pointer
(atom! int      prevchr_len)                ;; byte length of previous char
(atom! int      num_complex_braces)         ;; complex \{...} count
(atom! int      regnpar)                    ;; () count
(atom! int      regnzpar)                   ;; \z() count
(atom! int      re_has_z)                   ;; \z item detected
(atom! Bytes    regcode)                    ;; code-emit pointer, or JUST_CALC_SIZE
(atom! int      regsize)                    ;; code size
(atom! boolean  reg_toolong)                ;; true when offset out of range
(atom! boolean* had_endbrace    NSUBEXP)    ;; flags, true if end of () found
(atom! int      regflags)                   ;; RF_ flags for prog
(atom! long*    brace_min       10)         ;; minimums for complex brace repeats
(atom! long*    brace_max       10)         ;; maximums for complex brace repeats
(atom! int*     brace_count     10)         ;; current counts for complex brace repeats
(atom! boolean  one_exactly)                ;; only do one char for EXACTLY

(atom! int      reg_magic)                  ;; magicness of the pattern:
(final int
    MAGIC_NONE  1,                   ;; "\V" very unmagic
    MAGIC_OFF   2,                   ;; "\M" or 'magic' off
    MAGIC_ON    3,                   ;; "\m" or 'magic'
    MAGIC_ALL   4)                   ;; "\v" very magic

(atom! boolean  reg_string)                 ;; matching with a string instead of a buffer line
(atom! boolean  reg_strict)                 ;; "[abc" is illegal

;; META contains all characters that may be magic, except '^' and '$'.

;; META[] is used often enough to justify turning it into a table.
(final byte* META_flags
    [
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
;;                     %  &     (  )  *  +        .
        0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 1, 0,
;;         1  2  3  4  5  6  7  8  9        <  =  >  ?
        0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1,
;;      @  A     C  D     F     H  I     K  L  M     O
        1, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 1, 1, 0, 1,
;;      P        S     U  V  W  X     Z  [           _
        1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 1,
;;         a     c  d     f     h  i     k  l  m  n  o
        0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1,
;;      p        s     u  v  w  x     z  {  |     ~
        1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1
    ])

(atom! int      curchr)             ;; currently parsed character

;; Previous character.  Note: prevchr is sometimes -1 when we are not at the start,
;; e.g. in /[ ^I]^ the pattern was never found even if it existed,
;; because ^ was taken to be magic.

(atom! int      prevchr)
(atom! int      prevprevchr)        ;; previous-previous character
(atom! int      nextchr)            ;; used for ungetchr()

;; arguments for reg()
(final int REG_NOPAREN     0)           ;; toplevel reg()
(final int REG_PAREN       1)           ;; \(\)
(final int REG_ZPAREN      2)           ;; \z(\)
(final int REG_NPAREN      3)           ;; \%(\)

(class! #_final parse_state_C
    [
        (field Bytes        regparse)
        (field int          prevchr_len)
        (field int          curchr)
        (field int          prevchr)
        (field int          prevprevchr)
        (field int          nextchr)
        (field boolean      at_start)
        (field boolean      prev_at_start)
        (field int          regnpar)
    ])

;; Forward declarations for vim-regcomp()'s friends.

;   static regengine_C bt_regengine = new regengine_C()
;   {
;       public regprog_C regcomp(Bytes expr, int re_flags)
;       {
; %%        ((ร RETURN) (bt-regcomp expr, re_flags))
;       }

;       public long regexec_nl(regmatch_C rmp, Bytes line, int col, boolean line_lbr)
;       {
; %%        ((ร RETURN) (bt-regexec-nl rmp, line, col, line_lbr))
;       }

;       public long regexec_multi(regmmatch_C rmp, window_C win, buffer_C buf, long lnum, int col, long nsec)
;       {
; %%        ((ร RETURN) (bt-regexec-multi rmp, win, buf, lnum, col, nsec))
;       }
;   };

;   static regengine_C nfa_regengine = new regengine_C()
;   {
;       public regprog_C regcomp(Bytes expr, int re_flags)
;       {
; %%        ((ร RETURN) (nfa-regcomp expr, re_flags))
;       }

;       public long regexec_nl(regmatch_C rmp, Bytes line, int col, boolean line_lbr)
;       {
; %%        ((ร RETURN) (nfa-regexec-nl rmp, line, col, line_lbr))
;       }

;       public long regexec_multi(regmmatch_C rmp, window_C win, buffer_C buf, long lnum, int col, long nsec)
;       {
; %%        ((ร RETURN) (nfa-regexec-multi rmp, win, buf, lnum, col, nsec))
;       }
;   };

;; Return true if compiled regular expression "prog" can match a line break.

(defn- #_boolean re-multiline [#_regprog_C prog]
    (flag? (:regflags prog) RF_HASNL))

;; Return true if compiled regular expression "prog" looks before the start
;; position (pattern contains "\@<=" or "\@<!").

(defn- #_boolean re-lookbehind [#_regprog_C prog]
    (flag? (:regflags prog) RF_LOOKBH))

;; Check for an equivalence class name "[=a=]".  "pp" points to the '['.
;; Returns a character representing the class.  Zero means that no item was
;; recognized.  Otherwise "pp" is advanced to after the item.

(defn- #_int get-equi-class [#_Bytes* pp]
    (ยง
        ((ร Bytes p =) (... pp 0))
        (when (== (.at p 1) (byte \=))
            ((ร int len =) (us-ptr2len-cc (.plus p 2)))
            (when (and (== (.at p (+ len 2)) (byte \=)) (== (.at p (+ len 3)) (byte \])))
                ((ร int c =) (us-ptr2char (.plus p 2)))
                ((ร pp[0] =) (.plus (... pp 0) (+ len 4)))
                ((ร RETURN) c)
            )
        )
        0
    ))

;; Produce the bytes for equivalence class "c".
;; Currently only handles latin1, latin9 and utf-8.
;;
;; NOTE! When changing this function, also change nfa-emit-equi-class()

(defn- #_void reg-equi-class [#_int c]
    (ยง
        ((ร SWITCH) c
            ((ร CASE) (byte \A))
            ((ร CASE) 0xc0) ((ร CASE) 0xc1) ((ร CASE) 0xc2)
            ((ร CASE) 0xc3) ((ร CASE) 0xc4) ((ร CASE) 0xc5)
            ((ร CASE) 0x100) ((ร CASE) 0x102) ((ร CASE) 0x104)
            ((ร CASE) 0x1cd) ((ร CASE) 0x1de) ((ร CASE) 0x1e0)
            ((ร CASE) 0x1ea2)
            (do
                (regmbc (byte \A))
                (regmbc 0xc0) regmbc(0xc1) (regmbc 0xc2)
                (regmbc 0xc3) regmbc(0xc4) (regmbc 0xc5)
                (regmbc 0x100) regmbc(0x102) (regmbc 0x104)
                (regmbc 0x1cd) regmbc(0x1de) (regmbc 0x1e0)
                (regmbc 0x1ea2)
                ((ร RETURN) nil)
            )
            ((ร CASE) (byte \a))
            ((ร CASE) 0xe0) ((ร CASE) 0xe1) ((ร CASE) 0xe2)
            ((ร CASE) 0xe3) ((ร CASE) 0xe4) ((ร CASE) 0xe5)
            ((ร CASE) 0x101) ((ร CASE) 0x103) ((ร CASE) 0x105)
            ((ร CASE) 0x1ce) ((ร CASE) 0x1df) ((ร CASE) 0x1e1)
            ((ร CASE) 0x1ea3)
            (do
                (regmbc (byte \a))
                (regmbc 0xe0) regmbc(0xe1) (regmbc 0xe2)
                (regmbc 0xe3) regmbc(0xe4) (regmbc 0xe5)
                (regmbc 0x101) regmbc(0x103) (regmbc 0x105)
                (regmbc 0x1ce) regmbc(0x1df) (regmbc 0x1e1)
                (regmbc 0x1ea3)
                ((ร RETURN) nil)
            )

            ((ร CASE) (byte \B))
            ((ร CASE) 0x1e02) ((ร CASE) 0x1e06)
            (do
                (regmbc (byte \B))
                (regmbc 0x1e02) regmbc(0x1e06)
                ((ร RETURN) nil)
            )
            ((ร CASE) (byte \b))
            ((ร CASE) 0x1e03) ((ร CASE) 0x1e07)
            (do
                (regmbc (byte \b))
                (regmbc 0x1e03) regmbc(0x1e07)
                ((ร RETURN) nil)
            )

            ((ร CASE) (byte \C))
            ((ร CASE) 0xc7)
            ((ร CASE) 0x106) ((ร CASE) 0x108) ((ร CASE) 0x10a) ((ร CASE) 0x10c)
            (do
                (regmbc (byte \C))
                (regmbc 0xc7)
                (regmbc 0x106) regmbc(0x108) (regmbc 0x10a) regmbc(0x10c)
                ((ร RETURN) nil)
            )
            ((ร CASE) (byte \c))
            ((ร CASE) 0xe7)
            ((ร CASE) 0x107) ((ร CASE) 0x109) ((ร CASE) 0x10b) ((ร CASE) 0x10d)
            (do
                (regmbc (byte \c))
                (regmbc 0xe7)
                (regmbc 0x107) regmbc(0x109) (regmbc 0x10b) regmbc(0x10d)
                ((ร RETURN) nil)
            )

            ((ร CASE) (byte \D))
            ((ร CASE) 0x10e) ((ร CASE) 0x110)
            ((ร CASE) 0x1e0a) ((ร CASE) 0x1e0c) ((ร CASE) 0x1e0e) ((ร CASE) 0x1e10) ((ร CASE) 0x1e12)
            (do
                (regmbc (byte \D))
                (regmbc 0x10e) regmbc(0x110)
                (regmbc 0x1e0a) regmbc(0x1e0c) (regmbc 0x1e0e) regmbc(0x1e10) (regmbc 0x1e12)
                ((ร RETURN) nil)
            )
            ((ร CASE) (byte \d))
            ((ร CASE) 0x10f) ((ร CASE) 0x111)
            ((ร CASE) 0x1e0b) ((ร CASE) 0x1e0d) ((ร CASE) 0x1e0f) ((ร CASE) 0x1e11) ((ร CASE) 0x1e13)
            (do
                (regmbc (byte \d))
                (regmbc 0x10f) regmbc(0x111)
                (regmbc 0x1e0b) regmbc(0x1e0d) (regmbc 0x1e0f) regmbc(0x1e11) (regmbc 0x1e13)
                ((ร RETURN) nil)
            )

            ((ร CASE) (byte \E))
            ((ร CASE) 0xc8) ((ร CASE) 0xc9) ((ร CASE) 0xca) ((ร CASE) 0xcb)
            ((ร CASE) 0x112) ((ร CASE) 0x114) ((ร CASE) 0x116) ((ร CASE) 0x118) ((ร CASE) 0x11a)
            ((ร CASE) 0x1eba) ((ร CASE) 0x1ebc)
            (do
                (regmbc (byte \E))
                (regmbc 0xc8) regmbc(0xc9) (regmbc 0xca) regmbc(0xcb)
                (regmbc 0x112) regmbc(0x114) (regmbc 0x116) regmbc(0x118) (regmbc 0x11a)
                (regmbc 0x1eba) regmbc(0x1ebc)
                ((ร RETURN) nil)
            )
            ((ร CASE) (byte \e))
            ((ร CASE) 0xe8) ((ร CASE) 0xe9) ((ร CASE) 0xea) ((ร CASE) 0xeb)
            ((ร CASE) 0x113) ((ร CASE) 0x115) ((ร CASE) 0x117) ((ร CASE) 0x119) ((ร CASE) 0x11b)
            ((ร CASE) 0x1ebb) ((ร CASE) 0x1ebd)
            (do
                (regmbc (byte \e))
                (regmbc 0xe8) regmbc(0xe9) (regmbc 0xea) regmbc(0xeb)
                (regmbc 0x113) regmbc(0x115) (regmbc 0x117) regmbc(0x119) (regmbc 0x11b)
                (regmbc 0x1ebb) regmbc(0x1ebd)
                ((ร RETURN) nil)
            )

            ((ร CASE) (byte \F))
            ((ร CASE) 0x1e1e)
            (do
                (regmbc (byte \F))
                (regmbc 0x1e1e)
                ((ร RETURN) nil)
            )
            ((ร CASE) (byte \f))
            ((ร CASE) 0x1e1f)
            (do
                (regmbc (byte \f))
                (regmbc 0x1e1f)
                ((ร RETURN) nil)
            )

            ((ร CASE) (byte \G))
            ((ร CASE) 0x11c) ((ร CASE) 0x11e) ((ร CASE) 0x120) ((ร CASE) 0x122)
            ((ร CASE) 0x1e4) ((ร CASE) 0x1e6) ((ร CASE) 0x1f4)
            ((ร CASE) 0x1e20)
            (do
                (regmbc (byte \G))
                (regmbc 0x11c) regmbc(0x11e) (regmbc 0x120) regmbc(0x122)
                (regmbc 0x1e4) regmbc(0x1e6) (regmbc 0x1f4)
                (regmbc 0x1e20)
                ((ร RETURN) nil)
            )
            ((ร CASE) (byte \g))
            ((ร CASE) 0x11d) ((ร CASE) 0x11f) ((ร CASE) 0x121) ((ร CASE) 0x123)
            ((ร CASE) 0x1e5) ((ร CASE) 0x1e7) ((ร CASE) 0x1f5)
            ((ร CASE) 0x1e21)
            (do
                (regmbc (byte \g))
                (regmbc 0x11d) regmbc(0x11f) (regmbc 0x121) regmbc(0x123)
                (regmbc 0x1e5) regmbc(0x1e7) (regmbc 0x1f5)
                (regmbc 0x1e21)
                ((ร RETURN) nil)
            )

            ((ร CASE) (byte \H))
            ((ร CASE) 0x124) ((ร CASE) 0x126)
            ((ร CASE) 0x1e22) ((ร CASE) 0x1e26) ((ร CASE) 0x1e28)
            (do
                (regmbc (byte \H))
                (regmbc 0x124) regmbc(0x126)
                (regmbc 0x1e22) regmbc(0x1e26) (regmbc 0x1e28)
                ((ร RETURN) nil)
            )
            ((ร CASE) (byte \h))
            ((ร CASE) 0x125) ((ร CASE) 0x127)
            ((ร CASE) 0x1e23) ((ร CASE) 0x1e27) ((ร CASE) 0x1e29) ((ร CASE) 0x1e96)
            (do
                (regmbc (byte \h))
                (regmbc 0x125) regmbc(0x127)
                (regmbc 0x1e23) regmbc(0x1e27) (regmbc 0x1e29) regmbc(0x1e96)
                ((ร RETURN) nil)
            )

            ((ร CASE) (byte \I))
            ((ร CASE) 0xcc) ((ร CASE) 0xcd) ((ร CASE) 0xce) ((ร CASE) 0xcf)
            ((ร CASE) 0x128) ((ร CASE) 0x12a) ((ร CASE) 0x12c) ((ร CASE) 0x12e) ((ร CASE) 0x130)
            ((ร CASE) 0x1cf)
            ((ร CASE) 0x1ec8)
            (do
                (regmbc (byte \I))
                (regmbc 0xcc) regmbc(0xcd) (regmbc 0xce) regmbc(0xcf)
                (regmbc 0x128) regmbc(0x12a) (regmbc 0x12c) regmbc(0x12e) (regmbc 0x130)
                (regmbc 0x1cf)
                (regmbc 0x1ec8)
                ((ร RETURN) nil)
            )
            ((ร CASE) (byte \i))
            ((ร CASE) 0xec) ((ร CASE) 0xed) ((ร CASE) 0xee) ((ร CASE) 0xef)
            ((ร CASE) 0x129) ((ร CASE) 0x12b) ((ร CASE) 0x12d) ((ร CASE) 0x12f) ((ร CASE) 0x131)
            ((ร CASE) 0x1d0)
            ((ร CASE) 0x1ec9)
            (do
                (regmbc (byte \i))
                (regmbc 0xec) regmbc(0xed) (regmbc 0xee) regmbc(0xef)
                (regmbc 0x129) regmbc(0x12b) (regmbc 0x12d) regmbc(0x12f) (regmbc 0x131)
                (regmbc 0x1d0)
                (regmbc 0x1ec9)
                ((ร RETURN) nil)
            )

            ((ร CASE) (byte \J))
            ((ร CASE) 0x134)
            (do
                (regmbc (byte \J))
                (regmbc 0x134)
                ((ร RETURN) nil)
            )
            ((ร CASE) (byte \j))
            ((ร CASE) 0x135) ((ร CASE) 0x1f0)
            (do
                (regmbc (byte \j))
                (regmbc 0x135) regmbc(0x1f0)
                ((ร RETURN) nil)
            )

            ((ร CASE) (byte \K))
            ((ร CASE) 0x136) ((ร CASE) 0x1e8)
            ((ร CASE) 0x1e30) ((ร CASE) 0x1e34)
            (do
                (regmbc (byte \K))
                (regmbc 0x136) regmbc(0x1e8)
                (regmbc 0x1e30) regmbc(0x1e34)
                ((ร RETURN) nil)
            )
            ((ร CASE) (byte \k))
            ((ร CASE) 0x137) ((ร CASE) 0x1e9)
            ((ร CASE) 0x1e31) ((ร CASE) 0x1e35)
            (do
                (regmbc (byte \k))
                (regmbc 0x137) regmbc(0x1e9)
                (regmbc 0x1e31) regmbc(0x1e35)
                ((ร RETURN) nil)
            )

            ((ร CASE) (byte \L))
            ((ร CASE) 0x139) ((ร CASE) 0x13b) ((ร CASE) 0x13d) ((ร CASE) 0x13f) ((ร CASE) 0x141)
            ((ร CASE) 0x1e3a)
            (do
                (regmbc (byte \L))
                (regmbc 0x139) regmbc(0x13b) (regmbc 0x13d) regmbc(0x13f) (regmbc 0x141)
                (regmbc 0x1e3a)
                ((ร RETURN) nil)
            )
            ((ร CASE) (byte \l))
            ((ร CASE) 0x13a) ((ร CASE) 0x13c) ((ร CASE) 0x13e) ((ร CASE) 0x140) ((ร CASE) 0x142)
            ((ร CASE) 0x1e3b)
            (do
                (regmbc (byte \l))
                (regmbc 0x13a) regmbc(0x13c) (regmbc 0x13e) regmbc(0x140) (regmbc 0x142)
                (regmbc 0x1e3b)
                ((ร RETURN) nil)
            )

            ((ร CASE) (byte \M))
            ((ร CASE) 0x1e3e) ((ร CASE) 0x1e40)
            (do
                (regmbc (byte \M))
                (regmbc 0x1e3e) regmbc(0x1e40)
                ((ร RETURN) nil)
            )
            ((ร CASE) (byte \m))
            ((ร CASE) 0x1e3f) ((ร CASE) 0x1e41)
            (do
                (regmbc (byte \m))
                (regmbc 0x1e3f) regmbc(0x1e41)
                ((ร RETURN) nil)
            )

            ((ร CASE) (byte \N))
            ((ร CASE) 0xd1)
            ((ร CASE) 0x143) ((ร CASE) 0x145) ((ร CASE) 0x147)
            ((ร CASE) 0x1e44) ((ร CASE) 0x1e48)
            (do
                (regmbc (byte \N))
                (regmbc 0xd1)
                (regmbc 0x143) regmbc(0x145) (regmbc 0x147)
                (regmbc 0x1e44) regmbc(0x1e48)
                ((ร RETURN) nil)
            )
            ((ร CASE) (byte \n))
            ((ร CASE) 0xf1)
            ((ร CASE) 0x144) ((ร CASE) 0x146) ((ร CASE) 0x148) ((ร CASE) 0x149)
            ((ร CASE) 0x1e45) ((ร CASE) 0x1e49)
            (do
                (regmbc (byte \n))
                (regmbc 0xf1)
                (regmbc 0x144) regmbc(0x146) (regmbc 0x148) regmbc(0x149)
                (regmbc 0x1e45) regmbc(0x1e49)
                ((ร RETURN) nil)
            )

            ((ร CASE) (byte \O))
            ((ร CASE) 0xd2) ((ร CASE) 0xd3) ((ร CASE) 0xd4)
            ((ร CASE) 0xd5) ((ร CASE) 0xd6) ((ร CASE) 0xd8)
            ((ร CASE) 0x14c) ((ร CASE) 0x14e) ((ร CASE) 0x150)
            ((ร CASE) 0x1a0) ((ร CASE) 0x1d1) ((ร CASE) 0x1ea) ((ร CASE) 0x1ec)
            ((ร CASE) 0x1ece)
            (do
                (regmbc (byte \O))
                (regmbc 0xd2) regmbc(0xd3) (regmbc 0xd4)
                (regmbc 0xd5) regmbc(0xd6) (regmbc 0xd8)
                (regmbc 0x14c) regmbc(0x14e) (regmbc 0x150)
                (regmbc 0x1a0) regmbc(0x1d1) (regmbc 0x1ea) regmbc(0x1ec)
                (regmbc 0x1ece)
                ((ร RETURN) nil)
            )
            ((ร CASE) (byte \o))
            ((ร CASE) 0xf2) ((ร CASE) 0xf3) ((ร CASE) 0xf4)
            ((ร CASE) 0xf5) ((ร CASE) 0xf6) ((ร CASE) 0xf8)
            ((ร CASE) 0x14d) ((ร CASE) 0x14f) ((ร CASE) 0x151)
            ((ร CASE) 0x1a1) ((ร CASE) 0x1d2) ((ร CASE) 0x1eb) ((ร CASE) 0x1ed)
            ((ร CASE) 0x1ecf)
            (do
                (regmbc (byte \o))
                (regmbc 0xf2) regmbc(0xf3) (regmbc 0xf4)
                (regmbc 0xf5) regmbc(0xf6) (regmbc 0xf8)
                (regmbc 0x14d) regmbc(0x14f) (regmbc 0x151)
                (regmbc 0x1a1) regmbc(0x1d2) (regmbc 0x1eb) regmbc(0x1ed)
                (regmbc 0x1ecf)
                ((ร RETURN) nil)
            )

            ((ร CASE) (byte \P))
            ((ร CASE) 0x1e54) ((ร CASE) 0x1e56)
            (do
                (regmbc (byte \P))
                (regmbc 0x1e54) regmbc(0x1e56)
                ((ร RETURN) nil)
            )
            ((ร CASE) (byte \p))
            ((ร CASE) 0x1e55) ((ร CASE) 0x1e57)
            (do
                (regmbc (byte \p))
                (regmbc 0x1e55) regmbc(0x1e57)
                ((ร RETURN) nil)
            )

            ((ร CASE) (byte \R))
            ((ร CASE) 0x154) ((ร CASE) 0x156) ((ร CASE) 0x158)
            ((ร CASE) 0x1e58) ((ร CASE) 0x1e5e)
            (do
                (regmbc (byte \R))
                (regmbc 0x154) regmbc(0x156) (regmbc 0x158)
                (regmbc 0x1e58) regmbc(0x1e5e)
                ((ร RETURN) nil)
            )
            ((ร CASE) (byte \r))
            ((ร CASE) 0x155) ((ร CASE) 0x157) ((ร CASE) 0x159)
            ((ร CASE) 0x1e59) ((ร CASE) 0x1e5f)
            (do
                (regmbc (byte \r))
                (regmbc 0x155) regmbc(0x157) (regmbc 0x159)
                (regmbc 0x1e59) regmbc(0x1e5f)
                ((ร RETURN) nil)
            )

            ((ร CASE) (byte \S))
            ((ร CASE) 0x15a) ((ร CASE) 0x15c) ((ร CASE) 0x15e) ((ร CASE) 0x160)
            ((ร CASE) 0x1e60)
            (do
                (regmbc (byte \S))
                (regmbc 0x15a) regmbc(0x15c) (regmbc 0x15e) regmbc(0x160)
                (regmbc 0x1e60)
                ((ร RETURN) nil)
            )
            ((ร CASE) (byte \s))
            ((ร CASE) 0x15b) ((ร CASE) 0x15d) ((ร CASE) 0x15f) ((ร CASE) 0x161)
            ((ร CASE) 0x1e61)
            (do
                (regmbc (byte \s))
                (regmbc 0x15b) regmbc(0x15d) (regmbc 0x15f) regmbc(0x161)
                (regmbc 0x1e61)
                ((ร RETURN) nil)
            )

            ((ร CASE) (byte \T))
            ((ร CASE) 0x162) ((ร CASE) 0x164) ((ร CASE) 0x166)
            ((ร CASE) 0x1e6a) ((ร CASE) 0x1e6e)
            (do
                (regmbc (byte \T))
                (regmbc 0x162) regmbc(0x164) (regmbc 0x166)
                (regmbc 0x1e6a) regmbc(0x1e6e)
                ((ร RETURN) nil)
            )
            ((ร CASE) (byte \t))
            ((ร CASE) 0x163) ((ร CASE) 0x165) ((ร CASE) 0x167)
            ((ร CASE) 0x1e6b) ((ร CASE) 0x1e6f) ((ร CASE) 0x1e97)
            (do
                (regmbc (byte \t))
                (regmbc 0x163) regmbc(0x165) (regmbc 0x167)
                (regmbc 0x1e6b) regmbc(0x1e6f) (regmbc 0x1e97)
                ((ร RETURN) nil)
            )

            ((ร CASE) (byte \U))
            ((ร CASE) 0xd9) ((ร CASE) 0xda) ((ร CASE) 0xdb) ((ร CASE) 0xdc)
            ((ร CASE) 0x168) ((ร CASE) 0x16a) ((ร CASE) 0x16c) ((ร CASE) 0x16e)
            ((ร CASE) 0x170) ((ร CASE) 0x172) ((ร CASE) 0x1af) ((ร CASE) 0x1d3)
            ((ร CASE) 0x1ee6)
            (do
                (regmbc (byte \U))
                (regmbc 0xd9) regmbc(0xda) (regmbc 0xdb) regmbc(0xdc)
                (regmbc 0x168) regmbc(0x16a) (regmbc 0x16c) regmbc(0x16e)
                (regmbc 0x170) regmbc(0x172) (regmbc 0x1af) regmbc(0x1d3)
                (regmbc 0x1ee6)
                ((ร RETURN) nil)
            )
            ((ร CASE) (byte \u))
            ((ร CASE) 0xf9) ((ร CASE) 0xfa) ((ร CASE) 0xfb) ((ร CASE) 0xfc)
            ((ร CASE) 0x169) ((ร CASE) 0x16b) ((ร CASE) 0x16d) ((ร CASE) 0x16f)
            ((ร CASE) 0x171) ((ร CASE) 0x173) ((ร CASE) 0x1b0) ((ร CASE) 0x1d4)
            ((ร CASE) 0x1ee7)
            (do
                (regmbc (byte \u))
                (regmbc 0xf9) regmbc(0xfa) (regmbc 0xfb) regmbc(0xfc)
                (regmbc 0x169) regmbc(0x16b) (regmbc 0x16d) regmbc(0x16f)
                (regmbc 0x171) regmbc(0x173) (regmbc 0x1b0) regmbc(0x1d4)
                (regmbc 0x1ee7)
                ((ร RETURN) nil)
            )

            ((ร CASE) (byte \V))
            ((ร CASE) 0x1e7c)
            (do
                (regmbc (byte \V))
                (regmbc 0x1e7c)
                ((ร RETURN) nil)
            )
            ((ร CASE) (byte \v))
            ((ร CASE) 0x1e7d)
            (do
                (regmbc (byte \v))
                (regmbc 0x1e7d)
                ((ร RETURN) nil)
            )

            ((ร CASE) (byte \W))
            ((ร CASE) 0x174)
            ((ร CASE) 0x1e80) ((ร CASE) 0x1e82) ((ร CASE) 0x1e84) ((ร CASE) 0x1e86)
            (do
                (regmbc (byte \W))
                (regmbc 0x174)
                (regmbc 0x1e80) regmbc(0x1e82) (regmbc 0x1e84) regmbc(0x1e86)
                ((ร RETURN) nil)
            )
            ((ร CASE) (byte \w))
            ((ร CASE) 0x175)
            ((ร CASE) 0x1e81) ((ร CASE) 0x1e83) ((ร CASE) 0x1e85) ((ร CASE) 0x1e87) ((ร CASE) 0x1e98)
            (do
                (regmbc (byte \w))
                (regmbc 0x175)
                (regmbc 0x1e81) regmbc(0x1e83) (regmbc 0x1e85) regmbc(0x1e87) (regmbc 0x1e98)
                ((ร RETURN) nil)
            )

            ((ร CASE) (byte \X))
            ((ร CASE) 0x1e8a) ((ร CASE) 0x1e8c)
            (do
                (regmbc (byte \X))
                (regmbc 0x1e8a) regmbc(0x1e8c)
                ((ร RETURN) nil)
            )
            ((ร CASE) (byte \x))
            ((ร CASE) 0x1e8b) ((ร CASE) 0x1e8d)
            (do
                (regmbc (byte \x))
                (regmbc 0x1e8b) regmbc(0x1e8d)
                ((ร RETURN) nil)
            )

            ((ร CASE) (byte \Y))
            ((ร CASE) 0xdd)
            ((ร CASE) 0x176) ((ร CASE) 0x178)
            ((ร CASE) 0x1e8e) ((ร CASE) 0x1ef2) ((ร CASE) 0x1ef6) ((ร CASE) 0x1ef8)
            (do
                (regmbc (byte \Y))
                (regmbc 0xdd)
                (regmbc 0x176) regmbc(0x178)
                (regmbc 0x1e8e) regmbc(0x1ef2) (regmbc 0x1ef6) regmbc(0x1ef8)
                ((ร RETURN) nil)
            )
            ((ร CASE) (byte \y))
            ((ร CASE) 0xfd) ((ร CASE) 0xff)
            ((ร CASE) 0x177)
            ((ร CASE) 0x1e8f) ((ร CASE) 0x1e99) ((ร CASE) 0x1ef3) ((ร CASE) 0x1ef7) ((ร CASE) 0x1ef9)
            (do
                (regmbc (byte \y))
                (regmbc 0xfd) regmbc(0xff)
                (regmbc 0x177)
                (regmbc 0x1e8f) regmbc(0x1e99) (regmbc 0x1ef3) regmbc(0x1ef7) (regmbc 0x1ef9)
                ((ร RETURN) nil)
            )

            ((ร CASE) (byte \Z))
            ((ร CASE) 0x179) ((ร CASE) 0x17b) ((ร CASE) 0x17d) ((ร CASE) 0x1b5)
            ((ร CASE) 0x1e90) ((ร CASE) 0x1e94)
            (do
                (regmbc (byte \Z))
                (regmbc 0x179) regmbc(0x17b) (regmbc 0x17d) regmbc(0x1b5)
                (regmbc 0x1e90) regmbc(0x1e94)
                ((ร RETURN) nil)
            )
            ((ร CASE) (byte \z))
            ((ร CASE) 0x17a) ((ร CASE) 0x17c) ((ร CASE) 0x17e) ((ร CASE) 0x1b6)
            ((ร CASE) 0x1e91) ((ร CASE) 0x1e95)
            (do
                (regmbc (byte \z))
                (regmbc 0x17a) regmbc(0x17c) (regmbc 0x17e) regmbc(0x1b6)
                (regmbc 0x1e91) regmbc(0x1e95)
                ((ร RETURN) nil)
            )
        )

        (regmbc c)
        nil
    ))

;; Check for a collating element "[.a.]".  "pp" points to the '['.
;; Returns a character.  Zero means that no item was recognized.
;; Otherwise "pp" is advanced to after the item.
;; Currently only single characters are recognized!

(defn- #_int get-coll-element [#_Bytes* pp]
    (ยง
        ((ร Bytes p =) (... pp 0))

        (when (== (.at p 1) (byte \.))
            ((ร int len =) (us-ptr2len-cc (.plus p 2)))
            (when (and (== (.at p (+ len 2)) (byte \.)) (== (.at p (+ len 3)) (byte \])))
                ((ร int c =) (us-ptr2char (.plus p 2)))
                ((ร pp[0] =) (.plus (... pp 0) (+ len 4)))
                ((ร RETURN) c)
            )
        )

        0
    ))

(atom! boolean reg_cpo_lit)     ;; 'cpoptions' contains 'l' flag
(atom! boolean reg_cpo_bsl)     ;; 'cpoptions' contains '\' flag

(defn- #_void get-cpo-flags []
    (reset! reg_cpo_lit (non-nil? (vim-strbyte @p_cpo, CPO_LITERAL)))
    (reset! reg_cpo_bsl (non-nil? (vim-strbyte @p_cpo, CPO_BACKSL)))
    nil)

;; Skip over a "[]" range.
;; "p" must point to the character after the '['.
;; The returned pointer is on the matching ']', or the terminating NUL.

(defn- #_Bytes skip-anyof [#_Bytes p]
    (ยง
        (if (== (.at p 0) (byte \^))      ;; Complement of range.
            ((ร p =) (.plus p 1))
        )
        (if (or (== (.at p 0) (byte \])) (== (.at p 0) (byte \-)))
            ((ร p =) (.plus p 1))
        )
        (while (and (non-eos? p) (!= (.at p 0) (byte \])))
            ((ร int l =) (us-ptr2len-cc p))
            (cond (< 1 l)
            (do
                ((ร p =) (.plus p l))
            )
            (== (.at p 0) (byte \-))
            (do
                ((ร p =) (.plus p 1))
                (if (and (!= (.at p 0) (byte \])) (non-eos? p))
                    ((ร p =) (.plus p (us-ptr2len-cc p)))
                )
            )
            (and (== (.at p 0) (byte \\)) (not @reg_cpo_bsl) (or (non-nil? (vim-strchr REGEXP_INRANGE, (.at p 1))) (and (not @reg_cpo_lit) (non-nil? (vim-strchr REGEXP_ABBR, (.at p 1))))))
            (do
                ((ร p =) (.plus p 2))
            )
            (== (.at p 0) (byte \[))
            (do
                (ร boolean b)
;               { Bytes[] __ = { p }; b = (get-char-class(__) == CLASS_NONE && get-equi-class(__) == 0 && get-coll-element(__) == 0); p = __[0]; }
                (if b
                    ((ร p =) (.plus p 1)) ;; not a class name
                )
            )
            :else
            (do
                ((ร p =) (.plus p 1))
            ))
        )

        p
    ))

;; Skip past regular expression.
;; Stop at end of "startp" or where "dirc" is found ('/', '?', etc).
;; Take care of characters with a backslash in front of it.
;; Skip strings inside [ and ].
;; When "newp" is not null and "dirc" is '?', make an allocated copy of the expression
;; and change "\?" to "?".  If "*newp" is not null the expression is changed in-place.

(defn- #_Bytes skip-regexp [#_Bytes startp, #_byte dirc, #_boolean magic, #_Bytes* newp]
    (ยง
        ((ร Bytes p =) startp)

        ((ร int mymagic =) (if magic MAGIC_ON MAGIC_OFF))

        (get-cpo-flags)

        ((ร FOR) (ร nil (non-eos? p) ((ร p =) (.plus p (us-ptr2len-cc p))))
            (if (== (.at p 0) dirc)       ;; found end of regexp
                (ร BREAK)
            )
            (cond (or (and (== (.at p 0) (byte \[)) (<= MAGIC_ON mymagic)) (and (== (.at p 0) (byte \\)) (== (.at p 1) (byte \[)) (<= mymagic MAGIC_OFF)))
            (do
                ((ร p =) (skip-anyof (.plus p 1)))
                (if (eos? p)
                    (ร BREAK)
                )
            )
            (and (== (.at p 0) (byte \\)) (non-eos? p 1))
            (do
                (cond (and (== dirc (byte \?)) (non-nil? newp) (== (.at p 1) (byte \?)))
                (do
                    ;; change "\?" to "?", make a copy first.
                    (when (nil? (... newp 0))
                        ((ร newp[0] =) (STRDUP startp))
                        ((ร p =) (.plus (... newp 0) (BDIFF p, startp)))
                    )
                    (if (non-nil? (... newp 0))
                        (BCOPY p, 0, p, 1, (+ (STRLEN p, 1) 1))
                        ((ร p =) (.plus p 1))
                    )
                )
                :else
                (do
                    ((ร p =) (.plus p 1))    ;; skip next character
                ))
                (cond (== (.at p 0) (byte \v))
                (do
                    ((ร mymagic =) MAGIC_ALL)
                )
                (== (.at p 0) (byte \V))
                (do
                    ((ร mymagic =) MAGIC_NONE)
                ))
            ))
        )

        p
    ))

;; bt-regcomp() - compile a regular expression into internal code for the
;; traditional back track matcher.
;; Returns the program in allocated space.  Returns null for an error.
;;
;; We can't allocate space until we know how big the compiled form will be,
;; but we can't compile it (and thus know how big it is) until we've got a
;; place to put the code.  So we cheat:  we compile it twice, once with code
;; generation turned off and size counting turned on, and once "for real".
;; This also means that we don't allocate space until we are sure that the
;; thing really will compile successfully, and we never have to move the
;; code and thus invalidate pointers into it.
;;
;; Whether upper/lower case is to be ignored is decided when executing the
;; program, it does not matter here.
;;
;; Beware that the optimization-preparation code in here knows about some
;; of the structure of the compiled regexp.
;; "re_flags": RE_MAGIC and/or RE_STRING.

(defn- #_regprog_C bt-regcomp [#_Bytes expr, #_int re_flags]
    (ยง
        (when (nil? expr)
            (emsg e_null)
            (reset! rc_did_emsg true)
            ((ร RETURN) nil)
        )

        (init-class-tab)

        ;; First pass: determine size, legality.

        (regcomp-start expr, re_flags)
        (reset! regcode JUST_CALC_SIZE)
        (regc REGMAGIC)
        ((ร int[] flags =) (ร new int[1]))
        (if (nil? (reg REG_NOPAREN, flags))
            ((ร RETURN) nil)
        )

        ;; Allocate space.
        ((ร bt_regprog_C r =) (new bt_regprog_C))
        ((ร r.program =) (Bytes. (inc @regsize)))

        ;; Second pass: emit code.

        (regcomp-start expr, re_flags)
        (reset! regcode (:program r))
        (regc REGMAGIC)
        (when (or (nil? (reg REG_NOPAREN, flags)) @reg_toolong)
            (when @reg_toolong
                (emsg (u8 "E339: Pattern too long"))
                (reset! rc_did_emsg true)
            )
            ((ร RETURN) nil)
        )

        ;; Dig out information for optimizations.
        ((ร r.regstart =) NUL)                   ;; Worst-case defaults.
        ((ร r.reganch =) 0)
        ((ร r.regmust =) nil)
        ((ร r.regmlen =) 0)
        ((ร r.regflags =) @regflags)
        (if (flag? (... flags 0) HASNL)
            ((ร r.regflags =) (| (:regflags r) RF_HASNL))
        )
        (if (flag? (... flags 0) HASLOOKBH)
            ((ร r.regflags =) (| (:regflags r) RF_LOOKBH))
        )
        ;; Remember whether this pattern has any \z specials in it.
        ((ร r.reghasz =) @re_has_z)

        ((ร Bytes scan =) (.plus (:program r) 1))        ;; First BRANCH.
        (when (== (re-op (regnext scan)) END)    ;; Only one top-level choice.
            ((ร scan =) (operand scan))

            ;; Starting-point info.
            (when (or (== (re-op scan) BOL) (== (re-op scan) RE_BOF))
                (ร r.reganch++)
                ((ร scan =) (regnext scan))
            )

            (cond (== (re-op scan) EXACTLY)
            (do
                ((ร r.regstart =) (us-ptr2char (operand scan)))
            )
            (and (or (== (re-op scan) BOW) (== (re-op scan) EOW) (== (re-op scan) NOTHING) (== (re-op scan) (+ MOPEN 0)) (== (re-op scan) NOPEN) (== (re-op scan) (+ MCLOSE 0)) (== (re-op scan) NCLOSE)) (== (re-op (regnext scan)) EXACTLY))
            (do
                ((ร r.regstart =) (us-ptr2char (operand (regnext scan))))
            ))

            ;; If there's something expensive in the r.e., find the longest literal string
            ;; that must appear and make it the regmust.  Resolve ties in favor of later strings,
            ;; since the regstart check works with the beginning of the r.e. and avoiding duplication
            ;; strengthens checking.  Not a strong reason, but sufficient in the absence of others.

            ;; When the r.e. starts with BOW, it is faster to look for a regmust first.
            ;; Used a lot for "#" and "*" commands.

            (when (and (or (flag? (... flags 0) SPSTART) (== (re-op scan) BOW) (== (re-op scan) EOW)) (non-flag? (... flags 0) HASNL))
                ((ร Bytes longest =) nil)
                ((ร int len =) 0)
                ((ร FOR) (ร nil (non-nil? scan) ((ร scan =) (regnext scan)))
                    (when (and (== (re-op scan) EXACTLY) (<= len (STRLEN (operand scan))))
                        ((ร longest =) (operand scan))
                        ((ร len =) (STRLEN (operand scan)))
                    )
                )
                ((ร r.regmust =) longest)
                ((ร r.regmlen =) len)
            )
        )

        ((ร r.engine =) bt_regengine)
        (ร (regprog_C)r)
    ))

;; Setup to parse the regexp.  Used once to get the length and once to do it.

(defn- #_void regcomp-start [#_Bytes expr, #_int re_flags]
    ;; re_flags: see vim-regcomp()
    (initchr expr)
    (reset! reg_magic (if (flag? re_flags RE_MAGIC) MAGIC_ON MAGIC_OFF))
    (reset! reg_string (flag? re_flags RE_STRING))
    (reset! reg_strict (flag? re_flags RE_STRICT))
    (get-cpo-flags)

    (reset! num_complex_braces 0)
    (reset! regnpar 1)
    (AFILL @had_endbrace, false)
    (reset! regnzpar 1)
    (reset! re_has_z 0)
    (reset! regsize 0)
    (reset! reg_toolong false)
    (reset! regflags 0)
    nil)

;; Parse regular expression, i.e. main body or parenthesized thing.
;;
;; Caller must absorb opening parenthesis.
;;
;; Combining parenthesis handling with the base level of regular expression
;; is a trifle forced, but the need to tie the tails of the branches to what
;; follows makes it hard to avoid.

(defn- #_Bytes reg [#_int paren, #_int* flagp]
    ;; paren: REG_NOPAREN, REG_PAREN, REG_NPAREN or REG_ZPAREN
    (ยง
        (ร Bytes ret)

        ((ร flagp[0] =) HASWIDTH)          ;; Tentatively.

        ((ร int parno =) 0)
        (cond (== paren REG_ZPAREN)
        (do
            ;; Make a ZOPEN node.
            (when (<= NSUBEXP @regnzpar)
                (emsg (u8 "E50: Too many \\z("))
                (reset! rc_did_emsg true)
                ((ร RETURN) nil)
            )
            ((ร parno =) @regnzpar)
            (swap! regnzpar inc)
            ((ร ret =) (regnode (+ ZOPEN parno)))
        )
        (== paren REG_PAREN)
        (do
            ;; Make a MOPEN node.
            (when (<= NSUBEXP @regnpar)
                (emsg2 (u8 "E51: Too many %s("), (if (== @reg_magic MAGIC_ALL) (u8 "") (u8 "\\")))
                (reset! rc_did_emsg true)
                ((ร RETURN) nil)
            )
            ((ร parno =) @regnpar)
            (swap! regnpar inc)
            ((ร ret =) (regnode (+ MOPEN parno)))
        )
        (== paren REG_NPAREN)
        (do
            ;; Make a NOPEN node.
            ((ร ret =) (regnode NOPEN))
        )
        :else
        (do
            ((ร ret =) nil)
        ))

        ;; Pick up the branches, linking them together.
        ((ร int[] flags =) (ร new int[1]))
        ((ร Bytes br =) (regbranch flags))
        (if (nil? br)
            ((ร RETURN) nil)
        )
        (if (non-nil? ret)
            (regtail ret, br)       ;; [MZ]OPEN -> first.
            ((ร ret =) br)
        )
        ;; If one of the branches can be zero-width, the whole thing can.
        ;; If one of the branches has * at start or matches a line-break, the whole thing can.
        (if (non-flag? (... flags 0) HASWIDTH)
            ((ร flagp[0] =) (& (... flagp 0) (bit-not HASWIDTH)))
        )
        ((ร flagp[0] =) (| (... flagp 0) (& (... flags 0) (| SPSTART HASNL HASLOOKBH))))
        (while (== (peekchr) (Magic (byte \|)))
            (skipchr)
            ((ร br =) (regbranch flags))
            (if (or (nil? br) @reg_toolong)
                ((ร RETURN) nil)
            )
            (regtail ret, br)       ;; BRANCH -> BRANCH.
            (if (non-flag? (... flags 0) HASWIDTH)
                ((ร flagp[0] =) (& (... flagp 0) (bit-not HASWIDTH)))
            )
            ((ร flagp[0] =) (| (... flagp 0) (& (... flags 0) (| SPSTART HASNL HASLOOKBH))))
        )

        ;; Make a closing node, and hook it on the end.
        ((ร Bytes ender =) (regnode (cond (== paren REG_ZPAREN) (+ ZCLOSE parno) (== paren REG_PAREN) (+ MCLOSE parno) (== paren REG_NPAREN) NCLOSE :else END)))

        (regtail ret, ender)

        ;; Hook the tails of the branches to the closing node.
        ((ร FOR) (ร ((ร br =) ret) (non-nil? br) ((ร br =) (regnext br)))
            (regoptail br, ender)
        )

        ;; Check for proper termination.
        (cond (and (!= paren REG_NOPAREN) (!= (getchr) (Magic (byte \)))))
        (do
            (cond (== paren REG_ZPAREN)
            (do
                (emsg (u8 "E52: Unmatched \\z("))
            )
            (== paren REG_NPAREN)
            (do
                (emsg2 e_unmatchedpp, (if (== @reg_magic MAGIC_ALL) (u8 "") (u8 "\\")))
            )
            :else
            (do
                (emsg2 e_unmatchedp, (if (== @reg_magic MAGIC_ALL) (u8 "") (u8 "\\")))
            ))
            (reset! rc_did_emsg true)
            ((ร RETURN) nil)
        )
        (and (== paren REG_NOPAREN) (!= (peekchr) NUL))
        (do
            (if (== @curchr (Magic (byte \))))
                (emsg2 e_unmatchedpar, (if (== @reg_magic MAGIC_ALL) (u8 "") (u8 "\\")))
                (emsg e_trailing))
            (reset! rc_did_emsg true)
            ((ร RETURN) nil)                    ;; "Can't happen".
        ))

        ;; Here we set the flag allowing back references to this set of parentheses.

        (if (== paren REG_PAREN)
            ((ร @had_endbrace[parno] =) true)     ;; have seen the close paren
        )
        ret
    ))

;; Parse one alternative of an | operator.
;; Implements the & operator.

(defn- #_Bytes regbranch [#_int* flagp]
    (ยง
        ((ร flagp[0] =) (| WORST HASNL))           ;; Tentatively.

        ((ร Bytes ret =) (regnode BRANCH))

        ((ร FOR) (ร ((ร Bytes chain =) nil) true nil)
            ((ร int[] flags =) (ร new int[1]))
            ((ร Bytes latest =) (regconcat flags))
            (if (nil? latest)
                ((ร RETURN) nil)
            )

            ;; If one of the branches has width, the whole thing has.
            ;; If one of the branches anchors at start-of-line, the whole thing does.
            ;; If one of the branches uses look-behind, the whole thing does.
            ((ร flagp[0] =) (| (... flagp 0) (& (... flags 0) (| HASWIDTH SPSTART HASLOOKBH))))
            ;; If one of the branches doesn't match a line-break, the whole thing doesn't.
            ((ร flagp[0] =) (& (... flagp 0) (| (bit-not HASNL) (& (... flags 0) HASNL))))
            (if (non-nil? chain)
                (regtail chain, latest))
            (if (!= (peekchr) (Magic (byte \&)))
                (ร BREAK)
            )

            (skipchr)
            (regtail latest, (regnode END)) ;; operand ends
            (if @reg_toolong
                (ร BREAK)
            )

            (reginsert MATCH, latest)
            ((ร chain =) latest)
        )

        ret
    ))

;; Parse one alternative of an | or & operator.
;; Implements the concatenation operator.

(defn- #_Bytes regconcat [#_int* flagp]
    (ยง
        ((ร Bytes first =) nil)
        ((ร Bytes chain =) nil)

        ((ร flagp[0] =) WORST)             ;; Tentatively.

        ((ร FOR) (ร ((ร boolean cont =) true) cont nil)
            ((ร SWITCH) (peekchr)
                ((ร CASE) NUL)
                ((ร CASE) (Magic (byte \|)))
                ((ร CASE) (Magic (byte \&)))
                ((ร CASE) (Magic (byte \))))
                (do
                    ((ร cont =) false)
                    (ร BREAK)
                )

                ((ร CASE) (Magic (byte \Z)))
                (do
                    ((ร @regflags =) (| @regflags RF_ICOMBINE))
                    (skipchr-keepstart)
                    (ร BREAK)
                )

                ((ร CASE) (Magic (byte \c)))
                (do
                    ((ร @regflags =) (| @regflags RF_ICASE))
                    (skipchr-keepstart)
                    (ร BREAK)
                )

                ((ร CASE) (Magic (byte \C)))
                (do
                    ((ร @regflags =) (| @regflags RF_NOICASE))
                    (skipchr-keepstart)
                    (ร BREAK)
                )

                ((ร CASE) (Magic (byte \v)))
                (do
                    (reset! reg_magic MAGIC_ALL)
                    (skipchr-keepstart)
                    (reset! curchr -1)
                    (ร BREAK)
                )

                ((ร CASE) (Magic (byte \m)))
                (do
                    (reset! reg_magic MAGIC_ON)
                    (skipchr-keepstart)
                    (reset! curchr -1)
                    (ร BREAK)
                )

                ((ร CASE) (Magic (byte \M)))
                (do
                    (reset! reg_magic MAGIC_OFF)
                    (skipchr-keepstart)
                    (reset! curchr -1)
                    (ร BREAK)
                )

                ((ร CASE) (Magic (byte \V)))
                (do
                    (reset! reg_magic MAGIC_NONE)
                    (skipchr-keepstart)
                    (reset! curchr -1)
                    (ร BREAK)
                )

                (ร DEFAULT)
                (do
                    ((ร int[] flags =) (ร new int[1]))
                    ((ร Bytes latest =) (regpiece flags))
                    (if (or (nil? latest) @reg_toolong)
                        ((ร RETURN) nil)
                    )

                    ((ร flagp[0] =) (| (... flagp 0) (& (... flags 0) (| HASWIDTH HASNL HASLOOKBH))))
                    (if (nil? chain)  ;; First piece.
                        ((ร flagp[0] =) (| (... flagp 0) (& (... flags 0) SPSTART)))
                        (regtail chain, latest))
                    ((ร chain =) latest)
                    (if (nil? first)
                        ((ร first =) latest)
                    )
                    (ร BREAK)
                )
            )
        )

        (if (nil? first)          ;; Loop ran zero times.
            ((ร first =) (regnode NOTHING))
        )
        first
    ))

;; Parse something followed by possible [*+=].
;;
;; Note that the branching code sequences used for = and the general cases
;; of * and + are somewhat optimized:  they use the same NOTHING node as
;; both the endmarker for their branch list and the body of the last branch.
;; It might seem that this node could be dispensed with entirely, but the
;; endmarker role is not redundant.

(defn- #_Bytes regpiece [#_int* flagp]
    (ยง
        ((ร int[] flags =) (ร new int[1]))
        ((ร Bytes ret =) (regatom flags))
        (if (nil? ret)
            ((ร RETURN) nil)
        )

        ((ร int op =) (peekchr))
        (when (== (re-multi-type op) NOT_MULTI)
            ((ร flagp[0] =) (... flags 0))
            ((ร RETURN) ret)
        )

        ;; default flags
        ((ร flagp[0] =) (| WORST SPSTART (& (... flags 0) (| HASNL HASLOOKBH))))

        (skipchr)
        ((ร SWITCH) op
            ((ร CASE) (Magic (byte \*)))
            (do
                (cond (flag? (... flags 0) SIMPLE)
                (do
                    (reginsert STAR, ret)
                )
                :else
                (do
                    ;; Emit x* as (x&|), where & means "self".
                    (reginsert BRANCH, ret)             ;; Either x
                    (regoptail ret, (regnode BACK))      ;; and loop
                    (regoptail ret, ret)                ;; back
                    (regtail ret, (regnode BRANCH))      ;; or
                    (regtail ret, (regnode NOTHING))     ;; null.
                ))
                (ร BREAK)
            )

            ((ร CASE) (Magic (byte \+)))
            (do
                (cond (flag? (... flags 0) SIMPLE)
                (do
                    (reginsert PLUS, ret)
                )
                :else
                (do
                    ;; Emit x+ as x(&|), where & means "self".
                    ((ร Bytes next =) (regnode BRANCH))      ;; Either
                    (regtail ret, next)
                    (regtail (regnode BACK), ret)        ;; loop back
                    (regtail next, (regnode BRANCH))     ;; or
                    (regtail ret, (regnode NOTHING))     ;; null.
                ))
                ((ร flagp[0] =) (| WORST HASWIDTH (& (... flags 0) (| HASNL HASLOOKBH))))
                (ร BREAK)
            )

            ((ร CASE) (Magic (byte \@)))
            (do
                ((ร int lop =) END)
                ((ร int nr =) (getdecchrs))

                ((ร SWITCH) (no-Magic (getchr))
                    ((ร CASE) (byte \=))
                    (do
                        ((ร lop =) MATCH)                ;; \@=
                        (ร BREAK)
                    )
                    ((ร CASE) (byte \!))
                    (do
                        ((ร lop =) NOMATCH)              ;; \@!
                        (ร BREAK)
                    )
                    ((ร CASE) (byte \>))
                    (do
                        ((ร lop =) SUBPAT)               ;; \@>
                        (ร BREAK)
                    )
                    ((ร CASE) (byte \<))
                    (do
                        ((ร SWITCH) (no-Magic (getchr))
                            ((ร CASE) (byte \=))
                            (do
                                ((ร lop =) BEHIND)       ;; \@<=
                                (ร BREAK)
                            )
                            ((ร CASE) (byte \!))
                            (do
                                ((ร lop =) NOBEHIND)     ;; \@<!
                                (ร BREAK)
                            )
                        )
                        (ร BREAK)
                    )
                )

                (when (== lop END)
                    (emsg2 (u8 "E59: invalid character after %s@"), (if (== @reg_magic MAGIC_ALL) (u8 "") (u8 "\\")))
                    (reset! rc_did_emsg true)
                    ((ร RETURN) nil)
                )
                ;; Look behind must match with behind_pos.
                (when (or (== lop BEHIND) (== lop NOBEHIND))
                    (regtail ret, (regnode BHPOS))
                    ((ร flagp[0] =) (| (... flagp 0) HASLOOKBH))
                )
                (regtail ret, (regnode END))                 ;; operand ends
                (cond (or (== lop BEHIND) (== lop NOBEHIND))
                (do
                    (if (< nr 0)
                        ((ร nr =) 0)                             ;; no limit is same as zero limit
                    )
                    (reginsert-nr lop, nr, ret)
                )
                :else
                (do
                    (reginsert lop, ret)
                ))
                (ร BREAK)
            )

            ((ร CASE) (Magic (byte \?)))
            ((ร CASE) (Magic (byte \=)))
            (do
                ;; Emit x= as (x|).
                (reginsert BRANCH, ret)                 ;; Either x
                (regtail ret, (regnode BRANCH))          ;; or
                ((ร Bytes next =) (regnode NOTHING))         ;; null.
                (regtail ret, next)
                (regoptail ret, next)
                (ร BREAK)
            )

            ((ร CASE) (Magic (byte \{)))
            (do
                ((ร long[] minval =) (ร new long[1]))
                ((ร long[] maxval =) (ร new long[1]))
                (if (not (read-limits minval, maxval))
                    ((ร RETURN) nil)
                )

                (cond (flag? (... flags 0) SIMPLE)
                (do
                    (reginsert BRACE_SIMPLE, ret)
                    (reginsert-limits BRACE_LIMITS, (... minval 0), (... maxval 0), ret)
                )
                :else
                (do
                    (when (<= 10 @num_complex_braces)
                        (emsg2 (u8 "E60: Too many complex %s{...}s"), (if (== @reg_magic MAGIC_ALL) (u8 "") (u8 "\\")))
                        (reset! rc_did_emsg true)
                        ((ร RETURN) nil)
                    )
                    (reginsert (+ BRACE_COMPLEX @num_complex_braces), ret)
                    (regoptail ret, (regnode BACK))
                    (regoptail ret, ret)
                    (reginsert-limits BRACE_LIMITS, (... minval 0), (... maxval 0), ret)
                    (swap! num_complex_braces inc)
                ))
                (if (and (< 0 (... minval 0)) (< 0 (... maxval 0)))
                    ((ร flagp[0] =) (| HASWIDTH (& (... flags 0) (| HASNL HASLOOKBH))))
                )
                (ร BREAK)
            )
        )

        (when (!= (re-multi-type (peekchr)) NOT_MULTI)
            ;; Can't have a multi follow a multi.
            (if (== (peekchr) (Magic (byte \*)))
                (.sprintf libC @ioBuff, (u8 "E61: Nested %s*"), (if (<= MAGIC_ON @reg_magic) (u8 "") (u8 "\\")))
                (.sprintf libC @ioBuff, (u8 "E62: Nested %s%c"), (if (== @reg_magic MAGIC_ALL) (u8 "") (u8 "\\")), (no-Magic (peekchr)))
            )

            (emsg @ioBuff)
            (reset! rc_did_emsg true)
            ((ร RETURN) nil)
        )

        ret
    ))

;; When making changes to "classchars" also change "nfa_classcodes".
(final Bytes classchars (u8 ".iIkKfFpPsSdDxXoOwWhHaAlLuU"))
(final int* classcodes
    [
        ANY,
        IDENT, SIDENT,
        KWORD, SKWORD,
        FNAME, SFNAME,
        PRINT, SPRINT,
        WHITE, NWHITE,
        DIGIT, NDIGIT,
        HEX,   NHEX,
        OCTAL, NOCTAL,
        WORD,  NWORD,
        HEAD,  NHEAD,
        ALPHA, NALPHA,
        LOWER, NLOWER,
        UPPER, NUPPER
    ])

;; Parse the lowest level.
;;
;; Optimization:  gobbles an entire sequence of ordinary characters so that
;; it can turn them into a single node, which is smaller to store and
;; faster to run.  Don't do this when one_exactly is set.

(defn- #_Bytes regatom [#_int* flagp]
    (ยง
        (ร Bytes ret)

        ((ร int extra =) 0)

        ((ร flagp[0] =) WORST)             ;; Tentatively.

        ((ร int c =) (getchr))

;       collection:
;       {
            ((ร SWITCH) c
                ((ร CASE) (Magic (byte \^)))
                (do
                    ((ร ret =) (regnode BOL))
                    (ร BREAK)
                )

                ((ร CASE) (Magic (byte \$)))
                (do
                    ((ร ret =) (regnode EOL))
                    (ร BREAK)
                )

                ((ร CASE) (Magic (byte \<)))
                (do
                    ((ร ret =) (regnode BOW))
                    (ร BREAK)
                )

                ((ร CASE) (Magic (byte \>)))
                (do
                    ((ร ret =) (regnode EOW))
                    (ร BREAK)
                )

                ((ร CASE) (Magic (byte \_)))
                (do
                    ((ร c =) (no-Magic (getchr)))
                    (when (== c (byte \^))           ;; "\_^" is start-of-line
                        ((ร ret =) (regnode BOL))
                        (ร BREAK)
                    )
                    (when (== c (byte \$))           ;; "\_$" is end-of-line
                        ((ร ret =) (regnode EOL))
                        (ร BREAK)
                    )

                    ((ร extra =) ADD_NL)
                    ((ร flagp[0] =) (| (... flagp 0) HASNL))

                    ;; "\_[" is character range plus newline
                    (if (== c (byte \[))
                        (ร BREAK collection)
                    )

                    ;; "\_x" is character class plus newline
                    (ร FALLTHROUGH)
                )

                ;; Character classes.

                ((ร CASE) (Magic (byte \.)))
                ((ร CASE) (Magic (byte \i)))
                ((ร CASE) (Magic (byte \I)))
                ((ร CASE) (Magic (byte \k)))
                ((ร CASE) (Magic (byte \K)))
                ((ร CASE) (Magic (byte \f)))
                ((ร CASE) (Magic (byte \F)))
                ((ร CASE) (Magic (byte \p)))
                ((ร CASE) (Magic (byte \P)))
                ((ร CASE) (Magic (byte \s)))
                ((ร CASE) (Magic (byte \S)))
                ((ร CASE) (Magic (byte \d)))
                ((ร CASE) (Magic (byte \D)))
                ((ร CASE) (Magic (byte \x)))
                ((ร CASE) (Magic (byte \X)))
                ((ร CASE) (Magic (byte \o)))
                ((ร CASE) (Magic (byte \O)))
                ((ร CASE) (Magic (byte \w)))
                ((ร CASE) (Magic (byte \W)))
                ((ร CASE) (Magic (byte \h)))
                ((ร CASE) (Magic (byte \H)))
                ((ร CASE) (Magic (byte \a)))
                ((ร CASE) (Magic (byte \A)))
                ((ร CASE) (Magic (byte \l)))
                ((ร CASE) (Magic (byte \L)))
                ((ร CASE) (Magic (byte \u)))
                ((ร CASE) (Magic (byte \U)))
                (do
                    ((ร Bytes p =) (vim-strchr classchars, (no-Magic c)))
                    (when (nil? p)
                        (emsg (u8 "E63: invalid use of \\_"))
                        (reset! rc_did_emsg true)
                        ((ร RETURN) nil)
                    )
                    ;; When '.' is followed by a composing char ignore the dot,
                    ;; so that the composing char is matched here.
                    (when (and (== c (Magic (byte \.))) (utf-iscomposing (peekchr)))
                        ((ร c =) (getchr))
                        ((ร ret =) (regnode MULTIBYTECODE))
                        (regmbc c)
                        ((ร flagp[0] =) (| (... flagp 0) (| HASWIDTH SIMPLE)))
                        (ร BREAK)
                    )
                    ((ร ret =) (regnode (+ (... classcodes (BDIFF p, classchars)) extra)))
                    ((ร flagp[0] =) (| (... flagp 0) (| HASWIDTH SIMPLE)))
                    (ร BREAK)
                )

                ((ร CASE) (Magic (byte \n)))
                (do
                    (cond @reg_string
                    (do
                        ;; In a string "\n" matches a newline character.
                        ((ร ret =) (regnode EXACTLY))
                        (regc NL)
                        (regc NUL)
                        ((ร flagp[0] =) (| (... flagp 0) (| HASWIDTH SIMPLE)))
                    )
                    :else
                    (do
                        ;; In buffer text "\n" matches the end of a line.
                        ((ร ret =) (regnode NEWL))
                        ((ร flagp[0] =) (| (... flagp 0) (| HASWIDTH HASNL)))
                    ))
                    (ร BREAK)
                )

                ((ร CASE) (Magic (byte \()))
                (do
                    (when @one_exactly
                        (emsg2 (u8 "E369: invalid item in %s%%[]"), (if (== @reg_magic MAGIC_ALL) (u8 "") (u8 "\\")))
                        (reset! rc_did_emsg true)
                        ((ร RETURN) nil)
                    )
                    ((ร int[] flags =) (ร new int[1]))
                    ((ร ret =) (reg REG_PAREN, flags))
                    (if (nil? ret)
                        ((ร RETURN) nil)
                    )
                    ((ร flagp[0] =) (| (... flagp 0) (& (... flags 0) (| HASWIDTH SPSTART HASNL HASLOOKBH))))
                    (ร BREAK)
                )

                ((ร CASE) NUL)
                ((ร CASE) (Magic (byte \|)))
                ((ร CASE) (Magic (byte \&)))
                ((ร CASE) (Magic (byte \))))
                (do
                    (if @one_exactly
                        (emsg2 (u8 "E369: invalid item in %s%%[]"), (if (== @reg_magic MAGIC_ALL) (u8 "") (u8 "\\")))
                        (emsg e_internal))       ;; Supposed to be caught earlier.
                    (reset! rc_did_emsg true)
                    ((ร RETURN) nil)
                )

                ((ร CASE) (Magic (byte \=)))
                ((ร CASE) (Magic (byte \?)))
                ((ร CASE) (Magic (byte \+)))
                ((ร CASE) (Magic (byte \@)))
                ((ร CASE) (Magic (byte \{)))
                ((ร CASE) (Magic (byte \*)))
                (do
                    ((ร c =) (no-Magic c))
                    (.sprintf libC @ioBuff, (u8 "E64: %s%c follows nothing"), (if (if (== c (byte \*)) (<= MAGIC_ON @reg_magic) (== @reg_magic MAGIC_ALL)) (u8 "") (u8 "\\")), c)

                    (emsg @ioBuff)
                    (reset! rc_did_emsg true)
                    ((ร RETURN) nil)
                )

                ((ร CASE) (Magic (byte \~)))                    ;; previous substitute pattern
                (do
                    (cond (non-nil? @reg_prev_sub)
                    (do
                        ((ร ret =) (regnode EXACTLY))
                        ((ร Bytes lp =) @reg_prev_sub)
                        (while (non-eos? lp)
                            (regc (.at ((ร lp =) (.plus lp 1)) -1))
                        )
                        (regc NUL)
                        (when (non-eos? @reg_prev_sub)
                            ((ร flagp[0] =) (| (... flagp 0) HASWIDTH))
                            (if (== (BDIFF lp, @reg_prev_sub) 1)
                                ((ร flagp[0] =) (| (... flagp 0) SIMPLE))
                            )
                        )
                    )
                    :else
                    (do
                        (emsg e_nopresub)
                        (reset! rc_did_emsg true)
                        ((ร RETURN) nil)
                    ))
                    (ร BREAK)
                )

                ((ร CASE) (Magic (byte \1)))
                ((ร CASE) (Magic (byte \2)))
                ((ร CASE) (Magic (byte \3)))
                ((ร CASE) (Magic (byte \4)))
                ((ร CASE) (Magic (byte \5)))
                ((ร CASE) (Magic (byte \6)))
                ((ร CASE) (Magic (byte \7)))
                ((ร CASE) (Magic (byte \8)))
                ((ร CASE) (Magic (byte \9)))
                (do
                    ((ร int refnum =) (- c (Magic (byte \0))))

                    ;; Check if the back reference is legal.  We must have seen the close brace.
                    ;; TODO: Should also check that we don't refer to something
                    ;; that is repeated (+*=): what instance of the repetition should we match?

                    (when (not (... @had_endbrace refnum))
                        ;; Trick: check if "@<=" or "@<!" follows, in which case
                        ;; the \1 can appear before the referenced match.
                        (ร Bytes p)
                        ((ร FOR) (ร ((ร p =) @regparse) (non-eos? p) ((ร p =) (.plus p 1)))
                            (if (and (== (.at p 0) (byte \@)) (== (.at p 1) (byte \<)) (or (== (.at p 2) (byte \!)) (== (.at p 2) (byte \=))))
                                (ร BREAK)
                            )
                        )
                        (when (eos? p)
                            (emsg (u8 "E65: Illegal back reference"))
                            (reset! rc_did_emsg true)
                            ((ร RETURN) nil)
                        )
                    )
                    ((ร ret =) (regnode (+ BACKREF refnum)))
                    (ร BREAK)
                )

                ((ร CASE) (Magic (byte \z)))
                (do
                    ((ร c =) (no-Magic (getchr)))
                    ((ร SWITCH) c
                        ((ร CASE) (byte \())
                        (do
                            (when (!= @reg_do_extmatch REX_SET)
                                (emsg e_z_not_allowed)
                                (reset! rc_did_emsg true)
                                ((ร RETURN) nil)
                            )
                            (when @one_exactly
                                (emsg2 (u8 "E369: invalid item in %s%%[]"), (if (== @reg_magic MAGIC_ALL) (u8 "") (u8 "\\")))
                                (reset! rc_did_emsg true)
                                ((ร RETURN) nil)
                            )
                            ((ร int[] flags =) (ร new int[1]))
                            ((ร ret =) (reg REG_ZPAREN, flags))
                            (if (nil? ret)
                                ((ร RETURN) nil)
                            )
                            ((ร flagp[0] =) (| (... flagp 0) (& (... flags 0) (| HASWIDTH SPSTART HASNL HASLOOKBH))))
                            (reset! re_has_z REX_SET)
                            (ร BREAK)
                        )
                        ((ร CASE) (byte \1))
                        ((ร CASE) (byte \2))
                        ((ร CASE) (byte \3))
                        ((ร CASE) (byte \4))
                        ((ร CASE) (byte \5))
                        ((ร CASE) (byte \6))
                        ((ร CASE) (byte \7))
                        ((ร CASE) (byte \8))
                        ((ร CASE) (byte \9))
                        (do
                            (when (!= @reg_do_extmatch REX_USE)
                                (emsg e_z1_not_allowed)
                                (reset! rc_did_emsg true)
                                ((ร RETURN) nil)
                            )
                            ((ร ret =) (regnode (- (+ ZREF c) (byte \0))))
                            (reset! re_has_z REX_USE)
                            (ร BREAK)
                        )
                        ((ร CASE) (byte \s))
                        (do
                            ((ร ret =) (regnode (+ MOPEN 0)))
                            (if (not (re-mult-next (u8 "\\zs")))
                                ((ร RETURN) nil)
                            )
                            (ร BREAK)
                        )
                        ((ร CASE) (byte \e))
                        (do
                            ((ร ret =) (regnode (+ MCLOSE 0)))
                            (if (not (re-mult-next (u8 "\\ze")))
                                ((ร RETURN) nil)
                            )
                            (ร BREAK)
                        )
                        (ร DEFAULT)
                        (do
                            (emsg (u8 "E68: Invalid character after \\z"))
                            (reset! rc_did_emsg true)
                            ((ร RETURN) nil)
                        )
                    )
                    (ร BREAK)
                )

                ((ร CASE) (Magic (byte \%)))
                (do
                    ((ร c =) (no-Magic (getchr)))
                    ((ร SWITCH) c
                        ;; () without a back reference
                        ((ร CASE) (byte \())
                        (do
                            (when @one_exactly
                                (emsg2 (u8 "E369: invalid item in %s%%[]"), (if (== @reg_magic MAGIC_ALL) (u8 "") (u8 "\\")))
                                (reset! rc_did_emsg true)
                                ((ร RETURN) nil)
                            )
                            ((ร int[] flags =) (ร new int[1]))
                            ((ร ret =) (reg REG_NPAREN, flags))
                            (if (nil? ret)
                                ((ร RETURN) nil)
                            )
                            ((ร flagp[0] =) (| (... flagp 0) (& (... flags 0) (| HASWIDTH SPSTART HASNL HASLOOKBH))))
                            (ร BREAK)
                        )
                        ;; Catch \%^ and \%$ regardless of where they appear in the
                        ;; pattern -- regardless of whether or not it makes sense.
                        ((ร CASE) (byte \^))
                        (do
                            ((ร ret =) (regnode RE_BOF))
                            (ร BREAK)
                        )

                        ((ร CASE) (byte \$))
                        (do
                            ((ร ret =) (regnode RE_EOF))
                            (ร BREAK)
                        )

                        ((ร CASE) (byte \#))
                        (do
                            ((ร ret =) (regnode CURSOR))
                            (ร BREAK)
                        )

                        ((ร CASE) (byte \V))
                        (do
                            ((ร ret =) (regnode RE_VISUAL))
                            (ร BREAK)
                        )

                        ((ร CASE) (byte \C))
                        (do
                            ((ร ret =) (regnode RE_COMPOSING))
                            (ร BREAK)
                        )

                        ;; \%[abc]: Emit as a list of branches,
                        ;; all ending at the last branch which matches nothing.
                        ((ร CASE) (byte \[))
                        (do
                            (when @one_exactly        ;; doesn't nest
                                (emsg2 (u8 "E369: invalid item in %s%%[]"), (if (== @reg_magic MAGIC_ALL) (u8 "") (u8 "\\")))
                                (reset! rc_did_emsg true)
                                ((ร RETURN) nil)
                            )

                            (ร Bytes lastbranch)
                            ((ร Bytes lastnode =) nil)
                            (ร Bytes br)

                            ((ร ret =) nil)
                            (while (!= ((ร c =) (getchr)) (byte \]))
                                (when (== c NUL)
                                    (emsg2 e_missing_sb, (if (== @reg_magic MAGIC_ALL) (u8 "") (u8 "\\")))
                                    (reset! rc_did_emsg true)
                                    ((ร RETURN) nil)
                                )
                                ((ร br =) (regnode BRANCH))
                                (if (nil? ret)
                                    ((ร ret =) br)
                                    (regtail lastnode, br))

                                (ungetchr)
                                (reset! one_exactly true)
                                ((ร lastnode =) (regatom flagp))
                                (reset! one_exactly false)
                                (if (nil? lastnode)
                                    ((ร RETURN) nil)
                                )
                            )
                            (when (nil? ret)
                                (emsg2 e_empty_sb, (if (== @reg_magic MAGIC_ALL) (u8 "") (u8 "\\")))
                                (reset! rc_did_emsg true)
                                ((ร RETURN) nil)
                            )
                            ((ร lastbranch =) (regnode BRANCH))
                            ((ร br =) (regnode NOTHING))
                            (when (!= ret JUST_CALC_SIZE)
                                (regtail lastnode, br)
                                (regtail lastbranch, br)
                                ;; connect all branches to the NOTHING branch at the end
                                ((ร FOR) (ร ((ร br =) ret) (BNE br, lastnode) nil)
                                    (cond (== (re-op br) BRANCH)
                                    (do
                                        (regtail br, lastbranch)
                                        ((ร br =) (operand br))
                                    )
                                    :else
                                    (do
                                        ((ร br =) (regnext br))
                                    ))
                                )
                            )
                            ((ร flagp[0] =) (& (... flagp 0) (bit-not (| HASWIDTH SIMPLE))))
                            (ร BREAK)
                        )
                        ((ร CASE) (byte \d))   ;; %d123 decimal
                        ((ร CASE) (byte \o))   ;; %o123 octal
                        ((ร CASE) (byte \x))   ;; %xab hex 2
                        ((ร CASE) (byte \u))   ;; %uabcd hex 4
                        ((ร CASE) (byte \U))   ;; %U1234abcd hex 8
                        (do
                            (ร int i)
                            ((ร SWITCH) c
                                ((ร CASE) (byte \d))
                                (do
                                    ((ร i =) (getdecchrs))
                                    (ร BREAK)
                                )
                                ((ร CASE) (byte \o))
                                (do
                                    ((ร i =) (getoctchrs))
                                    (ร BREAK)
                                )
                                ((ร CASE) (byte \x))
                                (do
                                    ((ร i =) (gethexchrs 2))
                                    (ร BREAK)
                                )
                                ((ร CASE) (byte \u))
                                (do
                                    ((ร i =) (gethexchrs 4))
                                    (ร BREAK)
                                )
                                ((ร CASE) (byte \U))
                                (do
                                    ((ร i =) (gethexchrs 8))
                                    (ร BREAK)
                                )
                                (ร DEFAULT)
                                (do
                                    ((ร i =) -1)
                                    (ร BREAK)
                                )
                            )

                            (when (< i 0)
                                (emsg2 (u8 "E678: Invalid character after %s%%[dxouU]"), (if (== @reg_magic MAGIC_ALL) (u8 "") (u8 "\\")))
                                (reset! rc_did_emsg true)
                                ((ร RETURN) nil)
                            )
                            ((ร ret =) (regnode (if (use-multibytecode i) MULTIBYTECODE EXACTLY)))
                            (if (zero? i)
                                (regc 0x0a)
                                (regmbc i))
                            (regc NUL)
                            ((ร flagp[0] =) (| (... flagp 0) HASWIDTH))
                            (ร BREAK)
                        )
                        (ร DEFAULT)
                        (do
                            (when (or (asc-isdigit c) (== c (byte \<)) (== c (byte \>)) (== c (byte \')))
                                ((ร int cmp =) c)
                                (if (or (== cmp (byte \<)) (== cmp (byte \>)))
                                    ((ร c =) (getchr))
                                )

                                ((ร long n =) 0)
                                (while (asc-isdigit c)
                                    ((ร n =) (+ (* n 10) (- c (byte \0))))
                                    ((ร c =) (getchr))
                                )

                                (cond (and (== c (byte \')) (zero? n))
                                (do
                                    ;; "\%'m", "\%<'m" and "\%>'m": Mark
                                    ((ร c =) (getchr))
                                    ((ร ret =) (regnode RE_MARK))
                                    (cond (== ret JUST_CALC_SIZE)
                                    (do
                                        ((ร @regsize =) (+ @regsize 2))
                                    )
                                    :else
                                    (do
                                        (.be ((ร @regcode =) (.plus @regcode 1)) -1, c)
                                        (.be ((ร @regcode =) (.plus @regcode 1)) -1, cmp)
                                    ))
                                    (ร BREAK)
                                )
                                (or (== c (byte \l)) (== c (byte \c)) (== c (byte \v)))
                                (do
                                    (cond (== c (byte \l))
                                    (do
                                        ((ร ret =) (regnode RE_LNUM))
                                    )
                                    (== c (byte \c))
                                    (do
                                        ((ร ret =) (regnode RE_COL))
                                    )
                                    :else
                                    (do
                                        ((ร ret =) (regnode RE_VCOL))
                                    ))
                                    (cond (== ret JUST_CALC_SIZE)
                                    (do
                                        ((ร @regsize =) (+ @regsize 5))
                                    )
                                    :else
                                    (do
                                        ;; put the number and the optional
                                        ;; comparator after the opcode
                                        (reset! regcode (re-put-long @regcode, n))
                                        (.be ((ร @regcode =) (.plus @regcode 1)) -1, cmp)
                                    ))
                                    (ร BREAK)
                                ))
                            )

                            (emsg2 (u8 "E71: Invalid character after %s%%"), (if (== @reg_magic MAGIC_ALL) (u8 "") (u8 "\\")))
                            (reset! rc_did_emsg true)
                            ((ร RETURN) nil)
                        )
                    )
                    (ร BREAK)
                )

                ((ร CASE) (Magic (byte \[)))
                (do
                    (ร BREAK collection)
                )

                (ร DEFAULT)
                (do
                    ((ร RETURN) (do-multibyte c, flagp))
                )
            )

            ((ร RETURN) ret)
;       }

        ;; If there is no matching ']', we assume the '[' is a normal character.
        ;; This makes 'incsearch' and ":help [" work.

        ((ร Bytes lp =) (skip-anyof @regparse))

        (when (== (.at lp 0) (byte \]))     ;; there is a matching ']'
            ((ร int startc =) -1)    ;; > 0 when next '-' is a range
            (ร int endc)

            ;; In a character class, different parsing rules apply.
            ;; Not even \ is special anymore, nothing is.

            (cond (== (.at @regparse 0) (byte \^))       ;; Complement of range.
            (do
                ((ร ret =) (regnode (+ ANYBUT extra)))
                (reset! regparse (.plus @regparse 1))
            )
            :else
            (do
                ((ร ret =) (regnode (+ ANYOF extra)))
            ))

            ;; At the start ']' and '-' mean the literal character.
            (when (or (== (.at @regparse 0) (byte \])) (== (.at @regparse 0) (byte \-)))
                ((ร startc =) (.at @regparse 0))
                (regc (.at ((ร @regparse =) (.plus @regparse 1)) -1))
            )

            (while (and (non-eos? @regparse) (!= (.at @regparse 0) (byte \])))
                (cond (== (.at @regparse 0) (byte \-))
                (do
                    (reset! regparse (.plus @regparse 1))
                    ;; The '-' is not used for a range at the end and after or before a '\n'.
                    (cond (or (== (.at @regparse 0) (byte \])) (eos? @regparse) (== startc -1) (and (== (.at @regparse 0) (byte \\)) (== (.at @regparse 1) (byte \n))))
                    (do
                        (regc (byte \-))
                        ((ร startc =) (byte \-))       ;; [--x] is a range
                    )
                    :else
                    (do
                        ;; Also accept "a-[.z.]".
                        ((ร endc =) 0)
                        (when (== (.at @regparse 0) (byte \[))
; %%                        ((ร Bytes[] __ =) (ร { @regparse }))
                            ((ร endc =) (get-coll-element __))
                            (reset! regparse (... __ 0))
                        )
                        (when (zero? endc)
; %%                        ((ร Bytes[] __ =) (ร { @regparse }))
                            ((ร endc =) (us-ptr2char-adv __, true))
                            (reset! regparse (... __ 0))
                        )

                        ;; Handle \o40, \x20 and \u20AC style sequences.
                        (if (and (== endc (byte \\)) (not @reg_cpo_lit) (not @reg_cpo_bsl))
                            ((ร endc =) (coll-get-char))
                        )

                        (when (< endc startc)
                            (emsg e_invrange)
                            (reset! rc_did_emsg true)
                            ((ร RETURN) nil)
                        )
                        (cond (or (< 1 (utf-char2len startc)) (< 1 (utf-char2len endc)))
                        (do
                            ;; Limit to a range of 256 chars.
                            (when (< (+ startc 256) endc)
                                (emsg e_invrange)
                                (reset! rc_did_emsg true)
                                ((ร RETURN) nil)
                            )
                            (while (<= (ร ++startc) endc)
                                (regmbc startc)
                            )
                        )
                        :else
                        (do
                            (while (<= (ร ++startc) endc)
                                (regc startc)
                            )
                        ))
                        ((ร startc =) -1)
                    ))
                )

                ;; Only "\]", "\^", "\]" and "\\" are special in Vi.  Vim
                ;; accepts "\t", "\e", etc., but only when the 'l' flag in
                ;; 'cpoptions' is not included.
                ;; Posix doesn't recognize backslash at all.

                (and (== (.at @regparse 0) (byte \\)) (not @reg_cpo_bsl) (or (non-nil? (vim-strchr REGEXP_INRANGE, (.at @regparse 1))) (and (not @reg_cpo_lit) (non-nil? (vim-strchr REGEXP_ABBR, (.at @regparse 1))))))
                (do
                    (reset! regparse (.plus @regparse 1))
                    (cond (== (.at @regparse 0) (byte \n))
                    (do
                        ;; '\n' in range: also match NL
                        (when (!= ret JUST_CALC_SIZE)
                            ;; Using \n inside [^] does not change what
                            ;; matches.  "[^\n]" is the same as ".".
                            (when (== (.at ret 0) ANYOF)
                                (.be ret 0, (+ ANYOF ADD_NL))
                                ((ร flagp[0] =) (| (... flagp 0) HASNL))
                            )
                            ;; else: must have had a \n already
                        )
                        (reset! regparse (.plus @regparse 1))
                        ((ร startc =) -1)
                    )
                    (or (== (.at @regparse 0) (byte \d)) (== (.at @regparse 0) (byte \o)) (== (.at @regparse 0) (byte \x)) (== (.at @regparse 0) (byte \u)) (== (.at @regparse 0) (byte \U)))
                    (do
                        ((ร startc =) (coll-get-char))
                        (if (zero? startc)
                            (regc 0x0a)
                            (regmbc startc))
                    )
                    :else
                    (do
                        ((ร startc =) (backslash-trans (.at ((ร @regparse =) (.plus @regparse 1)) -1)))
                        (regc startc)
                    ))
                )
                (== (.at @regparse 0) (byte \[))
                (do
                    (ร int cu)

                    (ร int c_class)
;                   { Bytes[] __ = { @regparse }; c_class = get-char-class(__); @regparse = __[0]; }
                    ((ร startc =) -1)
                    ;; Characters assumed to be 8 bits!
                    ((ร SWITCH) c_class
                        ((ร CASE) CLASS_NONE)
                        (do
;                           { Bytes[] __ = { @regparse }; c_class = get-equi-class(__); @regparse = __[0]; }
                            (cond (non-zero? c_class)
                            (do
                                ;; produce equivalence class
                                (reg-equi-class c_class)
                            )
                            :else
                            (do
;                               { Bytes[] __ = { @regparse }; c_class = get-coll-element(__); @regparse = __[0]; }
                                (cond (non-zero? c_class)
                                (do
                                    ;; produce a collating element
                                    (regmbc c_class)
                                )
                                :else
                                (do
                                    ;; literal '[', allow [[-x] as a range
                                    ((ร startc =) (.at ((ร @regparse =) (.plus @regparse 1)) -1))
                                    (regc startc)
                                ))
                            ))
                            (ร BREAK)
                        )
                        ((ร CASE) CLASS_ALNUM)
                        (do
                            ((ร FOR) (ร ((ร cu =) 1) (<= cu 255) (ร cu++))
                                (if (asc-isalnum cu)
                                    (regc cu))
                            )
                            (ร BREAK)
                        )
                        ((ร CASE) CLASS_ALPHA)
                        (do
                            ((ร FOR) (ร ((ร cu =) 1) (<= cu 255) (ร cu++))
                                (if (asc-isalpha cu)
                                    (regc cu))
                            )
                            (ร BREAK)
                        )
                        ((ร CASE) CLASS_BLANK)
                        (do
                            (regc (byte \space))
                            (regc TAB)
                            (ร BREAK)
                        )
                        ((ร CASE) CLASS_CNTRL)
                        (do
                            ((ร FOR) (ร ((ร cu =) 1) (<= cu 255) (ร cu++))
                                (if (asc-iscntrl cu)
                                    (regc cu))
                            )
                            (ร BREAK)
                        )
                        ((ร CASE) CLASS_DIGIT)
                        (do
                            ((ร FOR) (ร ((ร cu =) 1) (<= cu 255) (ร cu++))
                                (if (asc-isdigit cu)
                                    (regc cu))
                            )
                            (ร BREAK)
                        )
                        ((ร CASE) CLASS_GRAPH)
                        (do
                            ((ร FOR) (ร ((ร cu =) 1) (<= cu 255) (ร cu++))
                                (if (asc-isgraph cu)
                                    (regc cu))
                            )
                            (ร BREAK)
                        )
                        ((ร CASE) CLASS_LOWER)
                        (do
                            ((ร FOR) (ร ((ร cu =) 1) (<= cu 255) (ร cu++))
                                (if (utf-islower cu)
                                    (regc cu))
                            )
                            (ร BREAK)
                        )
                        ((ร CASE) CLASS_PRINT)
                        (do
                            ((ร FOR) (ร ((ร cu =) 1) (<= cu 255) (ร cu++))
                                (if (vim-isprintc cu)
                                    (regc cu))
                            )
                            (ร BREAK)
                        )
                        ((ร CASE) CLASS_PUNCT)
                        (do
                            ((ร FOR) (ร ((ร cu =) 1) (<= cu 255) (ร cu++))
                                (if (asc-ispunct cu)
                                    (regc cu))
                            )
                            (ร BREAK)
                        )
                        ((ร CASE) CLASS_SPACE)
                        (do
                            ((ร FOR) (ร ((ร cu =) 9) (<= cu 13) (ร cu++))
                                (regc cu)
                            )
                            (regc (byte \space))
                            (ร BREAK)
                        )
                        ((ร CASE) CLASS_UPPER)
                        (do
                            ((ร FOR) (ร ((ร cu =) 1) (<= cu 255) (ร cu++))
                                (if (utf-isupper cu)
                                    (regc cu))
                            )
                            (ร BREAK)
                        )
                        ((ร CASE) CLASS_XDIGIT)
                        (do
                            ((ร FOR) (ร ((ร cu =) 1) (<= cu 255) (ร cu++))
                                (if (asc-isxdigit cu)
                                    (regc cu))
                            )
                            (ร BREAK)
                        )
                        ((ร CASE) CLASS_TAB)
                        (do
                            (regc TAB)
                            (ร BREAK)
                        )
                        ((ร CASE) CLASS_RETURN)
                        (do
                            (regc (byte \return))
                            (ร BREAK)
                        )
                        ((ร CASE) CLASS_BACKSPACE)
                        (do
                            (regc (byte \backspace))
                            (ร BREAK)
                        )
                        ((ร CASE) CLASS_ESCAPE)
                        (do
                            (regc ESC)
                            (ร BREAK)
                        )
                    )
                )
                :else
                (do
                    ;; produce a multibyte character,
                    ;; including any following composing characters
                    ((ร startc =) (us-ptr2char @regparse))
                    ((ร int len =) (us-ptr2len-cc @regparse))
                    (if (!= (utf-char2len startc) len)
                        ((ร startc =) -1)        ;; composing chars
                    )
                    (while (<= 0 (ร --len))
                        (regc (.at ((ร @regparse =) (.plus @regparse 1)) -1))
                    )
                ))
            )
            (regc NUL)
            (reset! prevchr_len 1)                ;; last char was the ']'
            (when (!= (.at @regparse 0) (byte \]))
                (emsg e_toomsbra)
                (reset! rc_did_emsg true)
                ((ร RETURN) nil)                ;; Cannot happen?
            )
            (skipchr)                      ;; let's be friends with the lexer again
            ((ร flagp[0] =) (| (... flagp 0) (| HASWIDTH SIMPLE)))
            ((ร RETURN) ret)
        )

        (when @reg_strict
            (emsg2 e_missingbracket, (if (< MAGIC_OFF @reg_magic) (u8 "") (u8 "\\")))
            (reset! rc_did_emsg true)
            ((ร RETURN) nil)
        )

        (do-multibyte c, flagp)
    ))

(defn- #_final #_Bytes do-multibyte [#_int c, #_int* flagp]
    (ยง
        (ร Bytes ret)

        ;; A multi-byte character is handled as a separate atom
        ;; if it's before a multi and when it's a composing char.
        (when (use-multibytecode c)
            ((ร ret =) (regnode MULTIBYTECODE))
            (regmbc c)
            ((ร flagp[0] =) (| (... flagp 0) (| HASWIDTH SIMPLE)))
            ((ร RETURN) ret)
        )

        ((ร ret =) (regnode EXACTLY))

        ;; Append characters as long as:
        ;; - there is no following multi, we then need the character in
        ;;   front of it as a single character operand
        ;; - not running into a Magic character
        ;; - "one_exactly" is not set
        ;; But always emit at least one character.  Might be a Multi,
        ;; e.g., a "[" without matching "]".

        (ร int len)
        ((ร FOR) (ร ((ร len =) 0) (and (!= c NUL) (or (== len 0) (and (== (re-multi-type (peekchr)) NOT_MULTI) (not @one_exactly) (not (is-Magic c))))) (ร len++))
            ((ร c =) (no-Magic c))

            (regmbc c)

            ;; Need to get composing character too.
            (while true
                ((ร int l =) (us-ptr2len @regparse))
                (if (not (utf-iscomposing (us-ptr2char (.plus @regparse l))))
                    (ร BREAK)
                )
                (regmbc (us-ptr2char @regparse))
                (skipchr)
            )

            ((ร c =) (getchr))
        )
        (ungetchr)

        (regc NUL)

        ((ร flagp[0] =) (| (... flagp 0) HASWIDTH))
        (if (== len 1)
            ((ร flagp[0] =) (| (... flagp 0) SIMPLE))
        )

        ret
    ))

;; Return true if MULTIBYTECODE should be used instead of EXACTLY for character "c".

(defn- #_boolean use-multibytecode [#_int c]
    (and (< 1 (utf-char2len c)) (or (!= (re-multi-type (peekchr)) NOT_MULTI) (utf-iscomposing c))))

;; Emit a node.
;; Return pointer to generated code.

(defn- #_Bytes regnode [#_int op]
    (ยง
        ((ร Bytes ret =) @regcode)

        (cond (== ret JUST_CALC_SIZE)
        (do
            ((ร @regsize =) (+ @regsize 3))
        )
        :else
        (do
            (.be ((ร @regcode =) (.plus @regcode 1)) -1, op)
            (.be ((ร @regcode =) (.plus @regcode 1)) -1, NUL)           ;; Null "next" pointer.
            (.be ((ร @regcode =) (.plus @regcode 1)) -1, NUL)
        ))

        ret
    ))

;; Emit (if appropriate) a byte of code.

(defn- #_void regc [#_int b]
    (ยง
        (if (== @regcode JUST_CALC_SIZE)
            (swap! regsize inc)
            (.be ((ร @regcode =) (.plus @regcode 1)) -1, b)
        )
        nil
    ))

;; Emit (if appropriate) a multi-byte character of code.

(defn- #_void regmbc [#_int c]
    (ยง
        (if (== @regcode JUST_CALC_SIZE)
            ((ร @regsize =) (+ @regsize (utf-char2len c)))
            (reset! regcode (.plus @regcode (utf-char2bytes c, @regcode))))
        nil
    ))

;; Insert an operator in front of already-emitted operand.
;;
;; Means relocating the operand.

(defn- #_void reginsert [#_int op, #_Bytes opnd]
    (ยง
        (when (== @regcode JUST_CALC_SIZE)
            ((ร @regsize =) (+ @regsize 3))
            ((ร RETURN) nil)
        )

        ((ร Bytes src =) @regcode)
        (reset! regcode (.plus @regcode 3))
        ((ร Bytes dst =) @regcode)
        (while (BLT opnd, src)
            (.be ((ร dst =) (.minus dst 1)) 0, (.at ((ร src =) (.minus src 1)) 0))
        )

        ((ร Bytes place =) opnd) ;; Op node, where operand used to be.
        (.be ((ร place =) (.plus place 1)) -1, op)
        (.be ((ร place =) (.plus place 1)) -1, NUL)
        (eos! place)
        nil
    ))

;; Insert an operator in front of already-emitted operand.
;; Add a number to the operator.

(defn- #_void reginsert-nr [#_int op, #_long val, #_Bytes opnd]
    (ยง
        (when (== @regcode JUST_CALC_SIZE)
            ((ร @regsize =) (+ @regsize 7))
            ((ร RETURN) nil)
        )

        ((ร Bytes src =) @regcode)
        (reset! regcode (.plus @regcode 7))
        ((ร Bytes dst =) @regcode)
        (while (BLT opnd, src)
            (.be ((ร dst =) (.minus dst 1)) 0, (.at ((ร src =) (.minus src 1)) 0))
        )

        ((ร Bytes place =) opnd) ;; Op node, where operand used to be.
        (.be ((ร place =) (.plus place 1)) -1, op)
        (.be ((ร place =) (.plus place 1)) -1, NUL)
        (.be ((ร place =) (.plus place 1)) -1, NUL)
        ((ร place =) (re-put-long place, val))
        nil
    ))

;; Insert an operator in front of already-emitted operand.
;; The operator has the given limit values as operands.
;; Also set next pointer.
;;
;; Means relocating the operand.

(defn- #_void reginsert-limits [#_int op, #_long minval, #_long maxval, #_Bytes opnd]
    (ยง
        (when (== @regcode JUST_CALC_SIZE)
            ((ร @regsize =) (+ @regsize 11))
            ((ร RETURN) nil)
        )

        ((ร Bytes src =) @regcode)
        (reset! regcode (.plus @regcode 11))
        ((ร Bytes dst =) @regcode)
        (while (BLT opnd, src)
            (.be ((ร dst =) (.minus dst 1)) 0, (.at ((ร src =) (.minus src 1)) 0))
        )

        ((ร Bytes place =) opnd) ;; Op node, where operand used to be.
        (.be ((ร place =) (.plus place 1)) -1, op)
        (.be ((ร place =) (.plus place 1)) -1, NUL)
        (.be ((ร place =) (.plus place 1)) -1, NUL)
        ((ร place =) (re-put-long place, minval))
        ((ร place =) (re-put-long place, maxval))
        (regtail opnd, place)
        nil
    ))

;; Write a long as four bytes at "p" and return pointer to the next char.

(defn- #_Bytes re-put-long [#_Bytes p, #_long val]
    (ยง
        (.be ((ร p =) (.plus p 1)) -1, (byte (& (>>> val 24) 0xff)))
        (.be ((ร p =) (.plus p 1)) -1, (byte (& (>>> val 16) 0xff)))
        (.be ((ร p =) (.plus p 1)) -1, (byte (& (>>> val  8) 0xff)))
        (.be ((ร p =) (.plus p 1)) -1, (byte (&      val     0xff)))
        p
    ))

;; Set the next-pointer at the end of a node chain.

(defn- #_void regtail [#_Bytes p, #_Bytes val]
    (ยง
        (if (== p JUST_CALC_SIZE)
            ((ร RETURN) nil)
        )

        ;; Find last node.
        ((ร Bytes scan =) p)
        (while true
            ((ร Bytes temp =) (regnext scan))
            (if (nil? temp)
                (ร BREAK)
            )
            ((ร scan =) temp)
        )

        ((ร int offset =) (if (== (re-op scan) BACK) (BDIFF scan, val) (BDIFF val, scan)))
        ;; When the offset uses more than 16 bits it can no longer fit in the two bytes available.
        ;; Use a global flag to avoid having to check return values in too many places.
        (cond (< 0xffff offset)
        (do
            (reset! reg_toolong true)
        )
        :else
        (do
            (.be scan 1, (byte (& (>>> offset 8) 0xff)))
            (.be scan 2, (byte (&      offset    0xff)))
        ))
        nil
    ))

;; Like regtail, on item after a BRANCH; nop if none.

(defn- #_void regoptail [#_Bytes p, #_Bytes val]
    (ยง
        ;; When op is neither BRANCH nor BRACE_COMPLEX0-9, it is "operandless".
        (when (or (nil? p) (== p JUST_CALC_SIZE) (and (!= (re-op p) BRANCH) (or (< (re-op p) BRACE_COMPLEX) (< (+ BRACE_COMPLEX 9) (re-op p)))))
            ((ร RETURN) nil)
        )

        (regtail (operand p), val)
        nil
    ))

;; Functions for getting characters from the regexp input.

(atom! boolean at_start)        ;; true when on the first character
(atom! boolean prev_at_start)   ;; true when on the second character

;; Start parsing at "str".

(defn- #_void initchr [#_Bytes str]
    (ยง
        (reset! regparse str)
        (reset! prevchr_len 0)
        (reset! curchr ((ร @prevprevchr =) ((ร @prevchr =) ((ร @nextchr =) -1))))
        (reset! at_start true)
        (reset! prev_at_start false)
        nil
    ))

;; Save the current parse state, so that it can be restored and parsing
;; starts in the same state again.

(defn- #_void save-parse-state [#_parse_state_C ps]
    (ยง
        ((ร ps.regparse =) @regparse)
        ((ร ps.prevchr_len =) @prevchr_len)
        ((ร ps.curchr =) @curchr)
        ((ร ps.prevchr =) @prevchr)
        ((ร ps.prevprevchr =) @prevprevchr)
        ((ร ps.nextchr =) @nextchr)
        ((ร ps.at_start =) @at_start)
        ((ร ps.prev_at_start =) @prev_at_start)
        ((ร ps.regnpar =) @regnpar)
        nil
    ))

;; Restore a previously saved parse state.

(defn- #_void restore-parse-state [#_parse_state_C ps]
    (reset! regparse (:regparse ps))
    (reset! prevchr_len (:prevchr_len ps))
    (reset! curchr (:curchr ps))
    (reset! prevchr (:prevchr ps))
    (reset! prevprevchr (:prevprevchr ps))
    (reset! nextchr (:nextchr ps))
    (reset! at_start (:at_start ps))
    (reset! prev_at_start (:prev_at_start ps))
    (reset! regnpar (:regnpar ps))
    nil)

(atom! int after_slash)

;; Get the next character without advancing.

(defn- #_int peekchr []
    (ยง
        (when (== @curchr -1)
            ((ร SWITCH) ((ร @curchr =) (.at @regparse 0))
                ((ร CASE) (byte \.))
                ((ร CASE) (byte \[))
                ((ร CASE) (byte \~))
                (do
                    ;; magic when 'magic' is on
                    (if (<= MAGIC_ON @reg_magic)
                        (reset! curchr (Magic @curchr)))
                    (ร BREAK)
                )

                ((ร CASE) (byte \())
                ((ร CASE) (byte \)))
                ((ร CASE) (byte \{))
                ((ร CASE) (byte \%))
                ((ร CASE) (byte \+))
                ((ร CASE) (byte \=))
                ((ร CASE) (byte \?))
                ((ร CASE) (byte \@))
                ((ร CASE) (byte \!))
                ((ร CASE) (byte \&))
                ((ร CASE) (byte \|))
                ((ร CASE) (byte \<))
                ((ร CASE) (byte \>))
                ((ร CASE) (byte \#))       ;; future ext.
                ((ร CASE) (byte \"))       ;; future ext. """
                ((ร CASE) (byte \'))      ;; future ext.
                ((ร CASE) (byte \,))       ;; future ext.
                ((ร CASE) (byte \-))       ;; future ext.
                ((ร CASE) (byte \:))       ;; future ext.
                ((ร CASE) (byte \;))       ;; future ext.
                ((ร CASE) (byte \`))       ;; future ext.
                ((ร CASE) (byte \/))       ;; can't be used in / command
                (do
                    ;; magic only after "\v"
                    (if (== @reg_magic MAGIC_ALL)
                        (reset! curchr (Magic @curchr)))
                    (ร BREAK)
                )

                ((ร CASE) (byte \*))
                (do
                    ;; * is not magic as the very first character, e.g. "?*ptr",
                    ;; when after '^', e.g. "/^*ptr" and when after "\(", "\|", "\&".
                    ;; But "\(\*" is not magic, thus must be magic if "after_slash"
                    (when (and (<= MAGIC_ON @reg_magic) (not @at_start) (not (and @prev_at_start (== @prevchr (Magic (byte \^))))) (or (!= @after_slash 0) (and (!= @prevchr (Magic (byte \())) (!= @prevchr (Magic (byte \&))) (!= @prevchr (Magic (byte \|))))))
                        (reset! curchr (Magic (byte \*)))
                    )
                    (ร BREAK)
                )

                ((ร CASE) (byte \^))
                (do
                    ;; '^' is only magic as the very first character
                    ;; and if it's after "\(", "\|", "\&' or "\n"
                    (when (and (<= MAGIC_OFF @reg_magic) (or @at_start (== @reg_magic MAGIC_ALL) (== @prevchr (Magic (byte \())) (== @prevchr (Magic (byte \|))) (== @prevchr (Magic (byte \&))) (== @prevchr (Magic (byte \n))) (and (== (no-Magic @prevchr) (byte \()) (== @prevprevchr (Magic (byte \%))))))
                        (reset! curchr (Magic (byte \^)))
                        (reset! at_start true)
                        (reset! prev_at_start false)
                    )
                    (ร BREAK)
                )

                ((ร CASE) (byte \$))
                (do
                    ;; '$' is only magic as the very last char
                    ;; and if it's in front of either "\|", "\)", "\&", or "\n"
                    (when (<= MAGIC_OFF @reg_magic)
                        ((ร Bytes p =) (.plus @regparse 1))
                        ((ร boolean is_magic_all =) (== @reg_magic MAGIC_ALL))

                        ;; ignore \c \C \m \M \v \V and \Z after '$'
                        (while (and (== (.at p 0) (byte \\)) (or (== (.at p 1) (byte \c)) (== (.at p 1) (byte \C)) (== (.at p 1) (byte \m)) (== (.at p 1) (byte \M)) (== (.at p 1) (byte \v)) (== (.at p 1) (byte \V)) (== (.at p 1) (byte \Z))))
                            (cond (== (.at p 1) (byte \v))
                            (do
                                ((ร is_magic_all =) true)
                            )
                            (or (== (.at p 1) (byte \m)) (== (.at p 1) (byte \M)) (== (.at p 1) (byte \V)))
                            (do
                                ((ร is_magic_all =) false)
                            ))
                            ((ร p =) (.plus p 2))
                        )
                        (if (or (eos? p) (and (== (.at p 0) (byte \\)) (or (== (.at p 1) (byte \|)) (== (.at p 1) (byte \&)) (== (.at p 1) (byte \))) (== (.at p 1) (byte \n)))) (and is_magic_all (or (== (.at p 0) (byte \|)) (== (.at p 0) (byte \&)) (== (.at p 0) (byte \))))) (== @reg_magic MAGIC_ALL))
                            (reset! curchr (Magic (byte \$)))
                        )
                    )
                    (ร BREAK)
                )

                ((ร CASE) (byte \\))
                (do
                    ((ร int c =) (.at @regparse 1))

                    (cond (== c NUL)
                    (do
                        (reset! curchr (byte \\))      ;; trailing '\'
                    )
                    (and (<= (char_u (byte c)) (byte \~)) (non-zero? (... META_flags c)))
                    (do
                        ;; META contains everything that may be magic sometimes,
                        ;; except ^ and $ ("\^" and "\$" are only magic after "\v").
                        ;; We now fetch the next character and toggle its magicness.
                        ;; Therefore, \ is so meta-magic that it is not in META.

                        (reset! curchr -1)
                        (reset! prev_at_start @at_start)
                        (reset! at_start false)   ;; be able to say "/\*ptr"
                        (reset! regparse (.plus @regparse 1))
                        (swap! after_slash inc)
                        (peekchr)
                        (reset! regparse (.minus @regparse 1))
                        (swap! after_slash dec)
                        (reset! curchr (toggle-Magic @curchr))
                    )
                    (non-nil? (vim-strchr REGEXP_ABBR, c))
                    (do
                        ;; Handle abbreviations, like "\t" for TAB.

                        (reset! curchr (backslash-trans c))
                    )
                    (and (== @reg_magic MAGIC_NONE) (or (== c (byte \$)) (== c (byte \^))))
                    (do
                        (reset! curchr (toggle-Magic c))
                    )
                    :else
                    (do
                        ;; Next character can never be (made) magic?
                        ;; Then backslashing it won't do anything.

                        (reset! curchr (us-ptr2char (.plus @regparse 1)))
                    ))
                    (ร BREAK)
                )

                (ร DEFAULT)
                (do
                    (reset! curchr (us-ptr2char @regparse))
                    (ร BREAK)
                )
            )
        )

        @curchr
    ))

;; Eat one lexed character.  Do this in a way that we can undo it.

(defn- #_void skipchr []
    (ยง
        ;; peekchr() eats a backslash, do the same here
        (if (== (.at @regparse 0) (byte \\))
            (reset! prevchr_len 1)
            (reset! prevchr_len 0))
        (when (non-eos? @regparse @prevchr_len)
            ;; exclude composing chars that us-ptr2len-cc does include
            ((ร @prevchr_len =) (+ @prevchr_len (us-ptr2len (.plus @regparse @prevchr_len))))
        )
        (reset! regparse (.plus @regparse @prevchr_len))
        (reset! prev_at_start @at_start)
        (reset! at_start false)
        (reset! prevprevchr @prevchr)
        (reset! prevchr @curchr)
        (reset! curchr @nextchr)       ;; use previously unget char, or -1
        (reset! nextchr -1)
        nil
    ))

;; Skip a character while keeping the value of prev_at_start for at_start.
;; prevchr and prevprevchr are also kept.

(defn- #_void skipchr-keepstart []
    (ยง
        ((ร boolean as =) @prev_at_start)
        ((ร int pr =) @prevchr)
        ((ร int prpr =) @prevprevchr)

        (skipchr)

        (reset! at_start as)
        (reset! prevchr pr)
        (reset! prevprevchr prpr)
        nil
    ))

;; Get the next character from the pattern.  We know about magic and such, so
;; therefore we need a lexical analyzer.

(defn- #_int getchr []
    (ยง
        ((ร int chr =) (peekchr))

        (skipchr)

        chr
    ))

;; put character back.  Works only once!

(defn- #_void ungetchr []
    (reset! nextchr @curchr)
    (reset! curchr @prevchr)
    (reset! prevchr @prevprevchr)
    (reset! at_start @prev_at_start)
    (reset! prev_at_start false)

    ;; Backup "regparse", so that it's at the same position as before the getchr().
    (swap! regparse #(.minus % @prevchr_len))
    nil)

;; Get and return the value of the hex string at the current position.
;; Return -1 if there is no valid hex number.
;; The position is updated:
;;     blahblah\%x20asdf
;;         before-^ ^-after
;; The parameter controls the maximum number of input characters.  This will be
;; 2 when reading a \%x20 sequence and 4 when reading a \%u20AC sequence.

(defn- #_int gethexchrs [#_int maxinputlen]
    (ยง
        ((ร int nr =) 0)
        (ร int i)

        ((ร FOR) (ร ((ร i =) 0) (< i maxinputlen) (ร i++))
            ((ร int c =) (.at @regparse 0))
            (if (not (asc-isxdigit c))
                (ร BREAK)
            )
;           nr <<= 4;
            ((ร nr =) (| nr (hex2nr c)))
            (reset! regparse (.plus @regparse 1))
        )

        (if (zero? i)
            ((ร RETURN) -1)
        )

        nr
    ))

;; Get and return the value of the decimal string immediately after the
;; current position.  Return -1 for invalid.  Consumes all digits.

(defn- #_int getdecchrs []
    (ยง
        ((ร int nr =) 0)
        (ร int i)

        ((ร FOR) (ร ((ร i =) 0) true (ร i++))
            ((ร int c =) (.at @regparse 0))
            (if (or (< c (byte \0)) (< (byte \9) c))
                (ร BREAK)
            )
            ((ร nr =) (* nr 10))
            ((ร nr =) (+ nr (- c (byte \0))))
            (reset! regparse (.plus @regparse 1))
            (reset! curchr -1)    ;; no longer valid
        )

        (if (zero? i)
            ((ร RETURN) -1)
        )

        nr
    ))

;; get and return the value of the octal string immediately after the current
;; position. Return -1 for invalid, or 0-255 for valid.  Smart enough to handle
;; numbers > 377 correctly (for example, 400 is treated as 40) and doesn't
;; treat 8 or 9 as recognised characters.  Position is updated:
;;     blahblah\%o210asdf
;;         before-^  ^-after

(defn- #_int getoctchrs []
    (ยง
        ((ร int nr =) 0)
        (ร int i)

        ((ร FOR) (ร ((ร i =) 0) (and (< i 3) (< nr 040)) (ร i++))
            ((ร int c =) (.at @regparse 0))
            (if (or (< c (byte \0)) (< (byte \7) c))
                (ร BREAK)
            )
;           nr <<= 3;
            ((ร nr =) (| nr (hex2nr c)))
            (reset! regparse (.plus @regparse 1))
        )

        (if (zero? i)
            ((ร RETURN) -1)
        )

        nr
    ))

;; Get a number after a backslash that is inside [].
;; When nothing is recognized return a backslash.

(defn- #_int coll-get-char []
    (ยง
        ((ร int nr =) -1)

        ((ร SWITCH) (.at ((ร @regparse =) (.plus @regparse 1)) -1)
            ((ร CASE) (byte \d))
            (do
                ((ร nr =) (getdecchrs))
                (ร BREAK)
            )
            ((ร CASE) (byte \o))
            (do
                ((ร nr =) (getoctchrs))
                (ร BREAK)
            )
            ((ร CASE) (byte \x))
            (do
                ((ร nr =) (gethexchrs 2))
                (ร BREAK)
            )
            ((ร CASE) (byte \u))
            (do
                ((ร nr =) (gethexchrs 4))
                (ร BREAK)
            )
            ((ร CASE) (byte \U))
            (do
                ((ร nr =) (gethexchrs 8))
                (ร BREAK)
            )
        )
        (when (< nr 0)
            ;; If getting the number fails be backwards compatible: the character is a backslash.
            (reset! regparse (.minus @regparse 1))
            ((ร nr =) (byte \\))
        )

        nr
    ))

;; read-limits - Read two integers to be taken as a minimum and maximum.
;; If the first character is '-', then the range is reversed.
;; Should end with 'end'.  If minval is missing, zero is default,
;; if maxval is missing, a very big number is the default.

(defn- #_boolean read-limits [#_long* minval, #_long* maxval]
    (ยง
        ((ร boolean reverse =) false)

        (when (== (.at @regparse 0) (byte \-))
            ;; starts with '-', so reverse the range later
            (reset! regparse (.plus @regparse 1))
            ((ร reverse =) true)
        )
        ((ร Bytes first_char =) @regparse)
;       { Bytes[] __ = { @regparse }; minval[0] = getdigits(__); @regparse = __[0]; }
        (cond (== (.at @regparse 0) (byte \,))                       ;; there is a comma
        (do
            (cond (asc-isdigit (.at ((ร @regparse =) (.plus @regparse 1)) 0))
            (do
;               Bytes[] __ = { @regparse }; maxval[0] = getdigits(__); @regparse = __[0];
            )
            :else
            (do
                ((ร maxval[0] =) MAX_LIMIT)
            ))
        )
        (asc-isdigit (.at first_char 0))
        (do
            ((ร maxval[0] =) (... minval 0))                      ;; it was \{n} or \{-n}
        )
        :else
        (do
            ((ร maxval[0] =) MAX_LIMIT)                      ;; it was \{} or \{-}
        ))
        (if (== (.at @regparse 0) (byte \\))
            (reset! regparse (.plus @regparse 1)))                ;; allow either \{...} or \{...\}
        (when (!= (.at @regparse 0) (byte \}))
            (.sprintf libC @ioBuff, (u8 "E554: Syntax error in %s{...}"), (if (== @reg_magic MAGIC_ALL) (u8 "") (u8 "\\")))

            (emsg @ioBuff)
            (reset! rc_did_emsg true)
            ((ร RETURN) false)
        )

        ;; Reverse the range if there was a '-', or make sure it is in the right order otherwise.

        (when (or (and (not reverse) (< (... maxval 0) (... minval 0))) (and reverse (< (... minval 0) (... maxval 0))))
            ((ร long tmp =) (... minval 0))
            ((ร minval[0] =) (... maxval 0))
            ((ร maxval[0] =) tmp)
        )
        (skipchr)          ;; let's be friends with the lexer again
        true
    ))

;; Global work variables for vim-regexec().

;; The current match-position is remembered with these variables:
(atom! long     reglnum)                ;; line number, relative to first line
(atom! Bytes    regline)                ;; start of current line
(atom! Bytes    reginput)               ;; current input, points into "regline"

(atom! boolean  need_clear_subexpr)     ;; subexpressions still need to be cleared
(atom! boolean  need_clear_zsubexpr)    ;; extmatch subexpressions still need to be cleared

;; Structure used to save the current input state, when it needs to be
;; restored after trying a match.  Used by reg-save() and reg-restore().
;; Also stores the length of "backpos".

(class! #_final regsave_C
    [
        (field Bytes        rs_ptr)     ;; reginput pointer, for single-line regexp
        (field lpos_C       rs_pos      (NEW_lpos_C)) ;; reginput pos, for multi-line regexp
        (field int          rs_len)
    ])

(defn- #_void COPY-regsave [#_regsave_C rs1, #_regsave_C rs0]
    (ยง
        ((ร rs1.rs_ptr =) (:rs_ptr rs0))
        (COPY-lpos (:rs_pos rs1), (:rs_pos rs0))
        ((ร rs1.rs_len =) (:rs_len rs0))
        nil
    ))

;; struct to save start/end pointer/position in for \(\)
(class! #_final save_se_C
    [
        (field Bytes        se_ptr)
        (field lpos_C       se_pos      (NEW_lpos_C))
    ])

(defn- #_save_se_C* ARRAY-save-se [#_int n]
    (vec (repeatedly n NEW_save_se_C)))

;; used for BEHIND and NOBEHIND matching
(class! #_final regbehind_C
    [
        (field regsave_C    save_after      (NEW_regsave_C))
        (field regsave_C    save_behind     (NEW_regsave_C))
        (field boolean      save_need_clear_subexpr)
        (field save_se_C*   save_start  (ARRAY-save-se NSUBEXP))
        (field save_se_C*   save_end    (ARRAY-save-se NSUBEXP))
    ])

;; Internal copy of 'ignorecase'.  It is set at each call to vim-regexec().
;; Normally it gets the value of "rm_ic" or "rmm_ic", but when the pattern
;; contains '\c' or '\C' the value is overruled.

(atom! boolean ireg_ic)

;; Similar to ireg_ic, but only for 'combining' characters.  Set with \Z flag
;; in the regexp.  Defaults to false, always.

(atom! boolean ireg_icombine)

;; Copy of "rmm_maxcol": maximum column to search for a match.  Zero when
;; there is no maximum.

(atom! int     ireg_maxcol)

;; Sometimes need to save a copy of a line.  Since calloc()/free() is very
;; slow, we keep one allocated piece of memory and only re-allocate it when
;; it's too small.  It's freed in bt-regexec-both() when finished.

(atom! Bytes reg_tofree)
(atom! int reg_tofree_len)

;; These variables are set when executing a regexp to speed up the execution.
;; Which ones are set depends on whether a single-line or multi-line match is
;; done:
;;                      single-line             multi-line
;; reg_match            regmatch_C              null
;; reg_mmatch           null                    regmmatch_C
;; reg_startp           reg_match.startp        <invalid>
;; reg_endp             reg_match.endp          <invalid>
;; reg_startpos         <invalid>               reg_mmatch.startpos
;; reg_endpos           <invalid>               reg_mmatch.endpos
;; reg_win              null                    window in which to search
;; reg_buf              curbuf                  buffer in which to search
;; reg_firstlnum        <invalid>               first line in which to search
;; reg_maxline          0                       last line nr
;; reg_line_lbr         false or true           false

(atom! regmatch_C   reg_match)
(atom! regmmatch_C  reg_mmatch)
(atom! Bytes*       reg_startp)
(atom! Bytes*       reg_endp)
(atom! lpos_C*      reg_startpos)
(atom! lpos_C*      reg_endpos)
(atom! window_C     reg_win)
(atom! buffer_C     reg_buf)
(atom! long         reg_firstlnum)
(atom! long         reg_maxline)
(atom! boolean      reg_line_lbr)       ;; "\n" in string is line break

;; Values for rs_state in regitem_C.
(final int
    RS_NOPEN 0,           ;; NOPEN and NCLOSE
    RS_MOPEN 1,           ;; MOPEN + [0-9]
    RS_MCLOSE 2,          ;; MCLOSE + [0-9]
    RS_ZOPEN 3,           ;; ZOPEN + [0-9]
    RS_ZCLOSE 4,          ;; ZCLOSE + [0-9]
    RS_BRANCH 5,          ;; BRANCH
    RS_BRCPLX_MORE 6,     ;; BRACE_COMPLEX and trying one more match
    RS_BRCPLX_LONG 7,     ;; BRACE_COMPLEX and trying longest match
    RS_BRCPLX_SHORT 8,    ;; BRACE_COMPLEX and trying shortest match
    RS_NOMATCH 9,         ;; NOMATCH
    RS_BEHIND1 10,        ;; BEHIND / NOBEHIND matching rest
    RS_BEHIND2 11,        ;; BEHIND / NOBEHIND matching behind part
    RS_STAR_LONG 12,      ;; STAR/PLUS/BRACE_SIMPLE longest match
    RS_STAR_SHORT 13)     ;; STAR/PLUS/BRACE_SIMPLE shortest match

;; When there are alternatives, a RS_ is put on the regstack to remember what we are doing.
;; Before it may be another type of item, depending on "rs_state", to remember more things.

(class! #_final regitem_C
    [
        (field int          rs_state)       ;; what we are doing, one of RS_ above
        (field Bytes        rs_scan)        ;; current node in program
        (field save_se_C    rs_sesave       (NEW_save_se_C))  ;; union room for saving reginput
        (field regsave_C    rs_regsave      (NEW_regsave_C))  ;; union room for saving reginput
        (field int          rs_no)          ;; submatch nr or BEHIND/NOBEHIND
    ])

;; Used for STAR, PLUS and BRACE_SIMPLE matching.
(class! #_final regstar_C
    [
        (field int          nextb)          ;; next byte
        (field int          nextb_ic)       ;; next byte reverse case
        (field long         count)
        (field long         minval)
        (field long         maxval)
    ])

;; Used to store input position when a BACK was encountered,
;; so that we now if we made any progress since the last time.

(class! #_final backpos_C
    [
        (field Bytes        bp_scan)        ;; "scan" where BACK was encountered
        (field regsave_C    bp_pos      (NEW_regsave_C))  ;; last input position
    ])

;; "regstack" and "backpos" are used by regmatch().
;; They are kept over calls to avoid invoking calloc() and free() often.
;; "regstack" is a stack with regitem_C items, sometimes preceded by regstar_C or regbehind_C.
;; "backpos" is a table with backpos_C items for BACK.

(atom! Object*      regstack)
(atom! backpos_C*   backpos)

;; Both for regstack and backpos tables we use the following strategy of allocation
;; (to reduce calloc/free calls):
;; - Initial size is fairly small.
;; - When needed, the tables are grown bigger (8 times at first, double after that).
;; - After executing the match we free the memory only if the array has grown.
;;   Thus the memory is kept allocated when it's at the initial size.
;; This makes it fast while not keeping a lot of memory allocated.
;; A three times speed increase was observed when using many simple patterns.

(final int REGSTACK_INITIAL 2048)
(final int BACKPOS_INITIAL    64)

;; Create "regstack" and "backpos".
;; We allocate *_INITIAL amount of bytes first and then set the grow size to much bigger value
;; to avoid many calloc calls in case of deep regular expressions.

(defn- #_void create-regstack []
    (ยง
        ;; Use Object item, since we push different things onto the regstack.
        (reset! regstack (ร new Growing<Object>(Object.class, REGSTACK_INITIAL)))
        (.ga_grow @regstack REGSTACK_INITIAL)
        ((ร @regstack.ga_growsize =) (* REGSTACK_INITIAL 8))
        nil
    ))

(defn- #_void create-backpos []
    (ยง
        (reset! backpos (ร new Growing<backpos_C>(backpos_C.class, BACKPOS_INITIAL)))
        (.ga_grow @backpos BACKPOS_INITIAL)
        ((ร @backpos.ga_growsize =) (* BACKPOS_INITIAL 8))
        nil
    ))

;; Get pointer to the line "lnum", which is relative to "reg_firstlnum".

(defn- #_Bytes reg-getline [#_long lnum]
    (ยง
        ;; When looking behind for a match/no-match, lnum is negative, but we can't go before line 1.
        (if (< (+ @reg_firstlnum lnum) 1)
            ((ร RETURN) nil)
        )
        (when (< @reg_maxline lnum)
            ;; Must have matched the "\n" in the last line.
            ((ร RETURN) (u8 ""))
        )

        (ml-get-buf @reg_buf, (+ @reg_firstlnum lnum))
    ))

(atom! regsave_C    behind_pos      (NEW_regsave_C))

(final Bytes*       reg_startzp     NSUBEXP)                ;; Workspace to mark beginning
(final Bytes*       reg_endzp       NSUBEXP)                ;;   and end of \z(...\) matches
(final lpos_C*      reg_startzpos   (ARRAY-lpos NSUBEXP))   ;; idem, beginning pos
(final lpos_C*      reg_endzpos     (ARRAY-lpos NSUBEXP))   ;; idem, end pos

;; Match a regexp against a string.
;; "rmp.regprog" is a compiled regexp as returned by vim-regcomp().
;; Uses curbuf for line count and 'iskeyword'.
;; If "line_lbr" is true, consider a "\n" in "line" to be a line break.
;;
;; Returns 0 for failure, number of lines contained in the match otherwise.

(defn- #_long bt-regexec-nl [#_regmatch_C rmp, #_Bytes line, #_int col, #_boolean line_lbr]
    ;; line: string to match against
    ;; col: column to start looking for match
    (reset! reg_match rmp)
    (reset! reg_mmatch nil)
    (reset! reg_maxline 0)
    (reset! reg_line_lbr line_lbr)
    (reset! reg_buf @curbuf)
    (reset! reg_win nil)
    (reset! ireg_ic (:rm_ic rmp))
    (reset! ireg_icombine false)
    (reset! ireg_maxcol 0)

    (bt-regexec-both line, col, nil))

;; Match a regexp against multiple lines.
;; "rmp.regprog" is a compiled regexp as returned by vim-regcomp().
;; Uses curbuf for line count and 'iskeyword'.
;;
;; Return zero if there is no match.  Return number of lines contained in the match otherwise.

(defn- #_long bt-regexec-multi [#_regmmatch_C rmp, #_window_C win, #_buffer_C buf, #_long lnum, #_int col, #_long nsec]
    ;; win: window in which to search or null
    ;; buf: buffer in which to search
    ;; lnum: nr of line to start looking for match
    ;; col: column to start looking for match
    ;; nsec: timeout limit or 0
    (reset! reg_match nil)
    (reset! reg_mmatch rmp)
    (reset! reg_buf buf)
    (reset! reg_win win)
    (reset! reg_firstlnum lnum)
    (reset! reg_maxline (- (:ml_line_count (:b_ml @reg_buf)) lnum))
    (reset! reg_line_lbr false)
    (reset! ireg_ic (:rmm_ic rmp))
    (reset! ireg_icombine false)
    (reset! ireg_maxcol (:rmm_maxcol rmp))

    (bt-regexec-both nil, col, nsec))

;; Match a regexp against a string ("line" points to the string)
;; or multiple lines ("line" is null, use reg-getline()).
;; Returns 0 for failure, number of lines contained in the match otherwise.

(defn- #_long bt-regexec-both [#_Bytes line, #_int col, #_long nsec]
    ;; col: column to start looking for match
    ;; nsec: timeout limit or 0
    (ยง
        ((ร long retval =) 0)

        (if (nil? @regstack)
            (create-regstack))
        (if (nil? @backpos)
            (create-backpos))

        (ร bt_regprog_C prog)
        (cond (nil? @reg_match)
        (do
            ((ร prog =) (ร (bt_regprog_C)(@reg_mmatch.regprog)))
            ((ร line =) (reg-getline 0))
            (reset! reg_startpos (:startpos @reg_mmatch))
            (reset! reg_endpos (:endpos @reg_mmatch))
        )
        :else
        (do
            ((ร prog =) (ร (bt_regprog_C)(@reg_match.regprog)))
            (reset! reg_startp (:startp @reg_match))
            (reset! reg_endp (:endp @reg_match))
        ))

;       theend:
;       {
            ;; Be paranoid...
            (when (or (nil? prog) (nil? line))
                (emsg e_null)
                (ร BREAK theend)
            )

            ;; Check validity of program.
            (if (prog-magic-wrong)
                (ร BREAK theend)
            )

            ;; If the start column is past the maximum column: no need to try.
            (if (and (< 0 @ireg_maxcol) (<= @ireg_maxcol col))
                (ร BREAK theend)
            )

            ;; If pattern contains "\c" or "\C": overrule value of ireg_ic.
            (cond (flag? (:regflags prog) RF_ICASE)
            (do
                (reset! ireg_ic true)
            )
            (flag? (:regflags prog) RF_NOICASE)
            (do
                (reset! ireg_ic false)
            ))

            ;; If pattern contains "\Z" overrule value of ireg_icombine.
            (if (flag? (:regflags prog) RF_ICOMBINE)
                (reset! ireg_icombine true))

            ;; If there is a "must appear" string, look for it.
            (when (non-nil? (:regmust prog))
                ((ร int c =) (us-ptr2char (:regmust prog)))
                ((ร Bytes s =) (.plus line col))

                ;; This is used very often, esp. for ":global".
                ;; Use three versions of the loop to avoid overhead of conditions.

                (cond (not @ireg_ic)
                (do
                    (while (!= ((ร s =) (vim-strchr s, c)) nil)
                        (ร int cmp)
;                       { int[] __ = { prog.regmlen }; cmp = cstrncmp(s, prog.regmust, __); prog.regmlen = __[0]; }
                        (if (zero? cmp)
                            (ร BREAK)              ;; Found it.
                        )
                        ((ร s =) (.plus s (us-ptr2len-cc s)))
                    )
                )
                :else
                (do
                    (while (!= ((ร s =) (cstrchr s, c)) nil)
                        (ร int cmp)
;                       { int[] __ = { prog.regmlen }; cmp = cstrncmp(s, prog.regmust, __); prog.regmlen = __[0]; }
                        (if (zero? cmp)
                            (ร BREAK)              ;; Found it.
                        )
                        ((ร s =) (.plus s (us-ptr2len-cc s)))
                    )
                ))
                (if (nil? s)          ;; Not present.
                    (ร BREAK theend)
                )
            )

            (reset! regline line)
            (reset! reglnum 0)
            (reset! reg_toolong false)

            ;; Simplest case: Anchored match need be tried only once.
            (cond (non-zero? (:reganch prog))
            (do
                ((ร int c =) (us-ptr2char (.plus @regline col)))
                (cond (or (== (:regstart prog) NUL) (== (:regstart prog) c) (and @ireg_ic (or (== (utf-fold (:regstart prog)) (utf-fold c)) (and (< c 255) (< (:regstart prog) 255) (== (utf-tolower (:regstart prog)) (utf-tolower c))))))
                (do
                    ((ร retval =) (regtry prog, col))
                )
                :else
                (do
                    ((ร retval =) 0)
                ))
            )
            :else
            (do
                ((ร int tm_count =) 0)
                ;; Messy cases: Unanchored match.
                (while (not @got_int)
                    (when (!= (:regstart prog) NUL)
                        ;; Skip until the char we know it must start with.
                        ;; Used often, do some work to avoid call overhead.
                        ((ร Bytes s =) (cstrchr (.plus @regline col), (:regstart prog)))
                        (when (nil? s)
                            ((ร retval =) 0)
                            (ร BREAK)
                        )
                        ((ร col =) (BDIFF s, @regline))
                    )

                    ;; Check for maximum column to try.
                    (when (and (< 0 @ireg_maxcol) (<= @ireg_maxcol col))
                        ((ร retval =) 0)
                        (ร BREAK)
                    )

                    ((ร retval =) (regtry prog, col))
                    (if (< 0 retval)
                        (ร BREAK)
                    )

                    ;; if not currently on the first line, get it again
                    (when (non-zero? @reglnum)
                        (reset! reglnum 0)
                        (reset! regline (reg-getline 0))
                    )
                    (if (eos? @regline col)
                        (ร BREAK)
                    )
                    ((ร col =) (+ col (us-ptr2len-cc (.plus @regline col))))
                    ;; Check for timeout once in a twenty times to avoid overhead.
                    (when (and (non-zero? nsec) (== (ร ++tm_count) 20))
                        ((ร tm_count =) 0)
                        (if (profile-passed-limit nsec)
                            (ร BREAK)
                        )
                    )
                )
            ))
;       }

        ;; Free "reg_tofree" when it's a bit big.
        (if (< 400 @reg_tofree_len)
            (reset! reg_tofree nil))

        ;; Free backpos and regstack if they are bigger than their initial size.
        (when (< BACKPOS_INITIAL (:ga_maxlen @backpos))
            ((ร backpos_C[] bpp =) (:ga_data @backpos))
            (while (< 0 (ร @backpos.ga_len--))
                ((ร bpp[@backpos.ga_len] =) nil)
            )
            (.ga_clear @backpos)
            (reset! backpos nil)
        )
        (when (< REGSTACK_INITIAL (:ga_maxlen @regstack))
            ((ร Object[] rpp =) (:ga_data @regstack))
            (while (< 0 (ร @regstack.ga_len--))
                ((ร rpp[@regstack.ga_len] =) nil)
            )
            (.ga_clear @regstack)
            (reset! regstack nil)
        )

        retval
    ))

;; Create a new extmatch and mark it as referenced once.

(defn- #_reg_extmatch_C make-extmatch []
    (NEW_reg_extmatch_C))

;; Try match of "prog" with at regline[col].
;; Returns 0 for failure, number of lines contained in the match otherwise.

(defn- #_long regtry [#_bt_regprog_C prog, #_int col]
    (ยง
        (reset! reginput (.plus @regline col))
        (reset! need_clear_subexpr true)
        ;; Clear the external match subpointers if necessary.
        (if (== (:reghasz prog) REX_SET)
            (reset! need_clear_zsubexpr true))

        (if (not (regmatch (.plus (:program prog) 1)))
            ((ร RETURN) 0)
        )

        (cleanup-subexpr)
        (cond (nil? @reg_match)
        (do
            (when (< (:lnum (... @reg_startpos 0)) 0)
                ((ร @reg_startpos[0].lnum =) 0)
                ((ร @reg_startpos[0].col =) col)
            )
            (cond (< (:lnum (... @reg_endpos 0)) 0)
            (do
                ((ร @reg_endpos[0].lnum =) @reglnum)
                ((ร @reg_endpos[0].col =) (BDIFF @reginput, @regline))
            )
            :else
            (do
                ;; Use line number of "\ze".
                (reset! reglnum (:lnum (... @reg_endpos 0)))
            ))
        )
        :else
        (do
            (if (nil? (... @reg_startp 0))
                ((ร @reg_startp[0] =) (.plus @regline col))
            )
            (if (nil? (... @reg_endp 0))
                ((ร @reg_endp[0] =) @reginput)
            )
        ))
        ;; Package any found \z(...\) matches for export.  Default is none.
        (reset! re_extmatch_out nil)

        (when (== (:reghasz prog) REX_SET)
            (cleanup-zsubexpr)
            (reset! re_extmatch_out (make-extmatch))
            (dotimes [#_int i NSUBEXP]
                (cond (nil? @reg_match)
                (do
                    ;; Only accept single line matches.
                    (when (and (<= 0 (:lnum (... reg_startzpos i))) (== (:lnum (... reg_endzpos i)) (:lnum (... reg_startzpos i))) (>= (:col (... reg_endzpos i)) (:col (... reg_startzpos i))))
                        ((ร @re_extmatch_out.matches[i] =) (STRNDUP (.plus (reg-getline (:lnum (... reg_startzpos i))) (:col (... reg_startzpos i))), (- (:col (... reg_endzpos i)) (:col (... reg_startzpos i)))))
                    )
                )
                :else
                (do
                    (when (and (non-nil? (... reg_startzp i)) (non-nil? (... reg_endzp i)))
                        ((ร @re_extmatch_out.matches[i] =) (STRNDUP (... reg_startzp i), (BDIFF (... reg_endzp i), (... reg_startzp i))))
                    )
                ))
            )
        )
        (+ 1 @reglnum)
    ))

;; Get class of previous character.

(defn- #_int reg-prev-class []
    (ยง
        (if (BLT @regline, @reginput)
            ((ร RETURN) (us-get-class (.minus @reginput (+ 1 (us-head-off @regline, (.minus @reginput 1)))), @reg_buf))
        )

        -1
    ))

;; Return true if the current reginput position matches the Visual area.

(defn- #_boolean reg-match-visual []
    (ยง
        ((ร window_C wp =) (if (nil? @reg_win) @curwin @reg_win))

        ;; Check if the buffer is the current buffer.
        (if (or (!= @reg_buf @curbuf) (zero? (:lnum @VIsual)))
            ((ร RETURN) false)
        )

        ((ร pos_C top =) (NEW_pos_C))
        ((ร pos_C bot =) (NEW_pos_C))
        (ร int mode)
        (cond @VIsual_active
        (do
            (cond (ltpos @VIsual, (:w_cursor wp))
            (do
                (COPY-pos top, @VIsual)
                (COPY-pos bot, (:w_cursor wp))
            )
            :else
            (do
                (COPY-pos top, (:w_cursor wp))
                (COPY-pos bot, @VIsual)
            ))
            ((ร mode =) @VIsual_mode)
        )
        :else
        (do
            (cond (ltpos (:vi_start (:b_visual @curbuf)), (:vi_end (:b_visual @curbuf)))
            (do
                (COPY-pos top, (:vi_start (:b_visual @curbuf)))
                (COPY-pos bot, (:vi_end (:b_visual @curbuf)))
            )
            :else
            (do
                (COPY-pos top, (:vi_end (:b_visual @curbuf)))
                (COPY-pos bot, (:vi_start (:b_visual @curbuf)))
            ))
            ((ร mode =) (:vi_mode (:b_visual @curbuf)))
        ))
        ((ร long lnum =) (+ @reglnum @reg_firstlnum))
        (if (or (< lnum (:lnum top)) (< (:lnum bot) lnum))
            ((ร RETURN) false)
        )

        (cond (== mode (byte \v))
        (do
            ((ร int col =) (BDIFF @reginput, @regline))
            (if (or (and (== lnum (:lnum top)) (< col (:col top))) (and (== lnum (:lnum bot)) (>= col (+ (:col bot) (if (!= (.at @p_sel 0) (byte \e)) 1 0)))))
                ((ร RETURN) false)
            )
        )
        (== mode Ctrl_V)
        (do
            ((ร int[] start1 =) (ร new int[1]))
            ((ร int[] end1 =) (ร new int[1]))
            (getvvcol wp, top, start1, nil, end1)
            ((ร int[] start2 =) (ร new int[1]))
            ((ร int[] end2 =) (ร new int[1]))
            (getvvcol wp, bot, start2, nil, end2)
            (if (< (... start2 0) (... start1 0))
                ((ร start1[0] =) (... start2 0))
            )
            (if (< (... end1 0) (... end2 0))
                ((ร end1[0] =) (... end2 0))
            )
            (if (or (== (:col top) MAXCOL) (== (:col bot) MAXCOL))
                ((ร end1[0] =) MAXCOL)
            )
            ((ร int cols =) (win-linetabsize wp, @regline, (BDIFF @reginput, @regline)))
            (if (or (< cols (... start1 0)) (< (- (... end1 0) (if (== (.at @p_sel 0) (byte \e)) 1 0)) cols))
                ((ร RETURN) false)
            )
        ))

        true
    ))

;; The arguments from BRACE_LIMITS are stored here.  They are actually local
;; to regmatch(), but they are here to reduce the amount of stack space used
;; (it can be called recursively many times).

(atom! long     bl_minval)
(atom! long     bl_maxval)

(final int
    RA_FAIL 1,            ;; something failed, abort
    RA_CONT 2,            ;; continue in inner loop
    RA_BREAK 3,           ;; break inner loop
    RA_MATCH 4,           ;; successful match
    RA_NOMATCH 5)         ;; didn't match

;; regmatch - main matching routine
;;
;; Conceptually the strategy is simple:
;; check to see whether the current node matches, push an item onto the regstack
;; and loop to see whether the rest matches, and then act accordingly.
;;
;; In practice we make some effort to avoid using the regstack,
;; in particular by going through "ordinary" nodes (that don't need to know
;; whether the rest of the match failed) by a nested loop.
;;
;; Returns true when there is a match.
;; Leaves reginput and reglnum just after the last matched character.
;;
;; Returns false when there is no match.
;; Leaves reginput and reglnum in an undefined state!

(defn- #_boolean regmatch [#_Bytes scan]
    ;; scan: Current node.
    (ยง
        (ร int status)                 ;; one of the RA_ values:

        ;; Make "regstack" and "backpos" empty.
        ;; They are allocated and freed in bt-regexec-both() to reduce calloc()/free() calls.
        ((ร @regstack.ga_len =) 0)
        ((ร @backpos.ga_len =) 0)

        ;; Repeat until "regstack" is empty.

        (while true
            ;; Some patterns may take a long time to match, e.g., "\([a-z]\+\)\+Q".
            ;; Allow interrupting them with CTRL-C.
            (fast-breakcheck)

            ;; Repeat for items that can be matched sequentially, without using the regstack.

            (while true
                (when (or @got_int (nil? scan))
                    ((ร status =) RA_FAIL)
                    (ร BREAK)
                )
                ((ร status =) RA_CONT)

                ((ร Bytes next =) (regnext scan))        ;; Next node.

                ((ร int op =) (re-op scan))
                ;; Check for character class with NL added.
                (cond (and (not @reg_line_lbr) (with-nl op) (nil? @reg_match) (eos? @reginput) (<= @reglnum @reg_maxline))
                (do
                    (reg-nextline)
                )
                (and @reg_line_lbr (with-nl op) (== (.at @reginput 0) (byte \newline)))
                (do
                    (reset! reginput (.plus @reginput (us-ptr2len-cc @reginput)))
                )
                :else
                (do
                    (if (with-nl op)
                        ((ร op =) (- op ADD_NL))
                    )
                    ((ร int c =) (us-ptr2char @reginput))
                    ((ร SWITCH) op
                        ((ร CASE) BOL)
                        (do
                            (if (BNE @reginput, @regline)
                                ((ร status =) RA_NOMATCH)
                            )
                            (ร BREAK)
                        )

                        ((ร CASE) EOL)
                        (do
                            (if (!= c NUL)
                                ((ร status =) RA_NOMATCH)
                            )
                            (ร BREAK)
                        )

                        ((ร CASE) RE_BOF)
                        (do
                            ;; We're not at the beginning of the file when below the first
                            ;; line where we started, not at the start of the line or we
                            ;; didn't start at the first line of the buffer.
                            (if (or (non-zero? @reglnum) (BNE @reginput, @regline) (and (nil? @reg_match) (< 1 @reg_firstlnum)))
                                ((ร status =) RA_NOMATCH)
                            )
                            (ร BREAK)
                        )

                        ((ร CASE) RE_EOF)
                        (do
                            (if (or (!= @reglnum @reg_maxline) (!= c NUL))
                                ((ร status =) RA_NOMATCH)
                            )
                            (ร BREAK)
                        )

                        ((ร CASE) CURSOR)
                        (do
                            ;; Check if the buffer is in a window and compare the
                            ;; reg_win.w_cursor position to the match position.
                            (when (or (nil? @reg_win) (!= (+ @reglnum @reg_firstlnum) (:lnum (:w_cursor @reg_win))) (!= (BDIFF @reginput, @regline) (:col (:w_cursor @reg_win))))
                                ((ร status =) RA_NOMATCH)
                            )
                            (ร BREAK)
                        )

                        ((ร CASE) RE_MARK)
                        (do
                            ;; Compare the mark position to the match position.
                            ((ร int mark =) (.at (operand scan) 0))
                            ((ร int cmp =) (.at (operand scan) 1))

                            ((ร pos_C pos =) (getmark-buf @reg_buf, mark, false))
                                                            ;; mark doesn't exist
                                                            ;; mark isn't set in reg_buf
                            (if (or (nil? pos) (<= (:lnum pos) 0) (if (== (:lnum pos) (+ @reglnum @reg_firstlnum)) (if (== (:col pos) (BDIFF @reginput, @regline)) (or (== cmp (byte \<)) (== cmp (byte \>))) (if (< (:col pos) (BDIFF @reginput, @regline)) (!= cmp (byte \>)) (!= cmp (byte \<)))) (if (< (:lnum pos) (+ @reglnum @reg_firstlnum)) (!= cmp (byte \>)) (!= cmp (byte \<)))))
                                ((ร status =) RA_NOMATCH)
                            )
                            (ร BREAK)
                        )

                        ((ร CASE) RE_VISUAL)
                        (do
                            (if (not (reg-match-visual))
                                ((ร status =) RA_NOMATCH)
                            )
                            (ร BREAK)
                        )

                        ((ร CASE) RE_LNUM)
                        (do
                            (if (or (non-nil? @reg_match) (not (re-num-cmp (+ @reglnum @reg_firstlnum), scan)))
                                ((ร status =) RA_NOMATCH)
                            )
                            (ร BREAK)
                        )

                        ((ร CASE) RE_COL)
                        (do
                            (if (not (re-num-cmp (+ (BDIFF @reginput, @regline) 1), scan))
                                ((ร status =) RA_NOMATCH)
                            )
                            (ร BREAK)
                        )

                        ((ร CASE) RE_VCOL)
                        (do
                            (if (not (re-num-cmp (+ (long (win-linetabsize (if (nil? @reg_win) @curwin @reg_win), @regline, (BDIFF @reginput, @regline))) 1), scan))
                                ((ร status =) RA_NOMATCH)
                            )
                            (ร BREAK)
                        )

                        ((ร CASE) BOW)                           ;; \<word; reginput points to w
                        (do
                            (cond (== c NUL)                   ;; Can't match at end of line
                            (do
                                ((ร status =) RA_NOMATCH)
                            )
                            :else
                            (do
                                (ร int this_class)

                                ;; Get class of current and previous char (if it exists).
                                ((ร this_class =) (us-get-class @reginput, @reg_buf))
                                (cond (<= this_class 1)
                                (do
                                    ((ร status =) RA_NOMATCH)    ;; not on a word at all
                                )
                                (== (reg-prev-class) this_class)
                                (do
                                    ((ร status =) RA_NOMATCH)    ;; previous char is in same word
                                ))
                            ))
                            (ร BREAK)
                        )

                        ((ร CASE) EOW)                           ;; word\>; reginput points after d
                        (do
                            (cond (BEQ @reginput, @regline)        ;; Can't match at start of line
                            (do
                                ((ร status =) RA_NOMATCH)
                            )
                            :else
                            (do
                                (ร int this_class, prev_class)

                                ;; Get class of current and previous char (if it exists).
                                ((ร this_class =) (us-get-class @reginput, @reg_buf))
                                ((ร prev_class =) (reg-prev-class))
                                (if (or (== this_class prev_class) (zero? prev_class) (== prev_class 1))
                                    ((ร status =) RA_NOMATCH)
                                )
                            ))
                            (ร BREAK) ;; Matched with EOW
                        )

                        ((ร CASE) ANY)
                        (do
                            ;; ANY does not match new lines.
                            (if (== c NUL)
                                ((ร status =) RA_NOMATCH)
                                (reset! reginput (.plus @reginput (us-ptr2len-cc @reginput))))
                            (ร BREAK)
                        )

                        ((ร CASE) IDENT)
                        (do
                            (if (not (vim-isIDc c))
                                ((ร status =) RA_NOMATCH)
                                (reset! reginput (.plus @reginput (us-ptr2len-cc @reginput))))
                            (ร BREAK)
                        )

                        ((ร CASE) SIDENT)
                        (do
                            (if (or (asc-isdigit (.at @reginput 0)) (not (vim-isIDc c)))
                                ((ร status =) RA_NOMATCH)
                                (reset! reginput (.plus @reginput (us-ptr2len-cc @reginput))))
                            (ร BREAK)
                        )

                        ((ร CASE) KWORD)
                        (do
                            (if (not (us-iswordp @reginput, @reg_buf))
                                ((ร status =) RA_NOMATCH)
                                (reset! reginput (.plus @reginput (us-ptr2len-cc @reginput))))
                            (ร BREAK)
                        )

                        ((ร CASE) SKWORD)
                        (do
                            (if (or (asc-isdigit (.at @reginput 0)) (not (us-iswordp @reginput, @reg_buf)))
                                ((ร status =) RA_NOMATCH)
                                (reset! reginput (.plus @reginput (us-ptr2len-cc @reginput))))
                            (ร BREAK)
                        )

                        ((ร CASE) FNAME)
                        (do
                            (if (not (vim-isfilec c))
                                ((ร status =) RA_NOMATCH)
                                (reset! reginput (.plus @reginput (us-ptr2len-cc @reginput))))
                            (ร BREAK)
                        )

                        ((ร CASE) SFNAME)
                        (do
                            (if (or (asc-isdigit (.at @reginput 0)) (not (vim-isfilec c)))
                                ((ร status =) RA_NOMATCH)
                                (reset! reginput (.plus @reginput (us-ptr2len-cc @reginput))))
                            (ร BREAK)
                        )

                        ((ร CASE) PRINT)
                        (do
                            (if (not (vim-isprintc (us-ptr2char @reginput)))
                                ((ร status =) RA_NOMATCH)
                                (reset! reginput (.plus @reginput (us-ptr2len-cc @reginput))))
                            (ร BREAK)
                        )

                        ((ร CASE) SPRINT)
                        (do
                            (if (or (asc-isdigit (.at @reginput 0)) (not (vim-isprintc (us-ptr2char @reginput))))
                                ((ร status =) RA_NOMATCH)
                                (reset! reginput (.plus @reginput (us-ptr2len-cc @reginput))))
                            (ร BREAK)
                        )

                        ((ร CASE) WHITE)
                        (do
                            (if (not (vim-iswhite c))
                                ((ร status =) RA_NOMATCH)
                                (reset! reginput (.plus @reginput (us-ptr2len-cc @reginput))))
                            (ร BREAK)
                        )

                        ((ร CASE) NWHITE)
                        (do
                            (if (or (== c NUL) (vim-iswhite c))
                                ((ร status =) RA_NOMATCH)
                                (reset! reginput (.plus @reginput (us-ptr2len-cc @reginput))))
                            (ร BREAK)
                        )

                        ((ร CASE) DIGIT)
                        (do
                            (if (not (ri-digit c))
                                ((ร status =) RA_NOMATCH)
                                (reset! reginput (.plus @reginput (us-ptr2len-cc @reginput))))
                            (ร BREAK)
                        )

                        ((ร CASE) NDIGIT)
                        (do
                            (if (or (== c NUL) (ri-digit c))
                                ((ร status =) RA_NOMATCH)
                                (reset! reginput (.plus @reginput (us-ptr2len-cc @reginput))))
                            (ร BREAK)
                        )

                        ((ร CASE) HEX)
                        (do
                            (if (not (ri-hex c))
                                ((ร status =) RA_NOMATCH)
                                (reset! reginput (.plus @reginput (us-ptr2len-cc @reginput))))
                            (ร BREAK)
                        )

                        ((ร CASE) NHEX)
                        (do
                            (if (or (== c NUL) (ri-hex c))
                                ((ร status =) RA_NOMATCH)
                                (reset! reginput (.plus @reginput (us-ptr2len-cc @reginput))))
                            (ร BREAK)
                        )

                        ((ร CASE) OCTAL)
                        (do
                            (if (not (ri-octal c))
                                ((ร status =) RA_NOMATCH)
                                (reset! reginput (.plus @reginput (us-ptr2len-cc @reginput))))
                            (ร BREAK)
                        )

                        ((ร CASE) NOCTAL)
                        (do
                            (if (or (== c NUL) (ri-octal c))
                                ((ร status =) RA_NOMATCH)
                                (reset! reginput (.plus @reginput (us-ptr2len-cc @reginput))))
                            (ร BREAK)
                        )

                        ((ร CASE) WORD)
                        (do
                            (if (not (ri-word c))
                                ((ร status =) RA_NOMATCH)
                                (reset! reginput (.plus @reginput (us-ptr2len-cc @reginput))))
                            (ร BREAK)
                        )

                        ((ร CASE) NWORD)
                        (do
                            (if (or (== c NUL) (ri-word c))
                                ((ร status =) RA_NOMATCH)
                                (reset! reginput (.plus @reginput (us-ptr2len-cc @reginput))))
                            (ร BREAK)
                        )

                        ((ร CASE) HEAD)
                        (do
                            (if (not (ri-head c))
                                ((ร status =) RA_NOMATCH)
                                (reset! reginput (.plus @reginput (us-ptr2len-cc @reginput))))
                            (ร BREAK)
                        )

                        ((ร CASE) NHEAD)
                        (do
                            (if (or (== c NUL) (ri-head c))
                                ((ร status =) RA_NOMATCH)
                                (reset! reginput (.plus @reginput (us-ptr2len-cc @reginput))))
                            (ร BREAK)
                        )

                        ((ร CASE) ALPHA)
                        (do
                            (if (not (ri-alpha c))
                                ((ร status =) RA_NOMATCH)
                                (reset! reginput (.plus @reginput (us-ptr2len-cc @reginput))))
                            (ร BREAK)
                        )

                        ((ร CASE) NALPHA)
                        (do
                            (if (or (== c NUL) (ri-alpha c))
                                ((ร status =) RA_NOMATCH)
                                (reset! reginput (.plus @reginput (us-ptr2len-cc @reginput))))
                            (ร BREAK)
                        )

                        ((ร CASE) LOWER)
                        (do
                            (if (not (ri-lower c))
                                ((ร status =) RA_NOMATCH)
                                (reset! reginput (.plus @reginput (us-ptr2len-cc @reginput))))
                            (ร BREAK)
                        )

                        ((ร CASE) NLOWER)
                        (do
                            (if (or (== c NUL) (ri-lower c))
                                ((ร status =) RA_NOMATCH)
                                (reset! reginput (.plus @reginput (us-ptr2len-cc @reginput))))
                            (ร BREAK)
                        )

                        ((ร CASE) UPPER)
                        (do
                            (if (not (ri-upper c))
                                ((ร status =) RA_NOMATCH)
                                (reset! reginput (.plus @reginput (us-ptr2len-cc @reginput))))
                            (ร BREAK)
                        )

                        ((ร CASE) NUPPER)
                        (do
                            (if (or (== c NUL) (ri-upper c))
                                ((ร status =) RA_NOMATCH)
                                (reset! reginput (.plus @reginput (us-ptr2len-cc @reginput))))
                            (ร BREAK)
                        )

                        ((ร CASE) EXACTLY)
                        (do
                            ((ร Bytes opnd =) (operand scan))
                            ;; Inline the first byte, for speed.
                            (cond (and (!= (.at opnd 0) (.at @reginput 0)) (not @ireg_ic))
                            (do
                                ((ร status =) RA_NOMATCH)
                            )
                            (eos? opnd)
                            (do
                                ;; match empty string always works; happens when "~" is empty.
                            )
                            :else
                            (do
                                ((ร int[] len =) (ร new int[1]))
                                (cond (and (eos? opnd 1) (not @ireg_ic))
                                (do
                                    ((ร len[0] =) 1)        ;; matched a single byte above
                                )
                                :else
                                (do
                                    ;; Need to match first byte again for multi-byte.
                                    ((ร len[0] =) (STRLEN opnd))
                                    (if (non-zero? (cstrncmp opnd, @reginput, len))
                                        ((ร status =) RA_NOMATCH)
                                    )
                                ))
                                ;; Check for following composing character, unless %C
                                ;; follows (skips over all composing chars).
                                (when (and (!= status RA_NOMATCH) (utf-iscomposing (us-ptr2char (.plus @reginput (... len 0)))) (not @ireg_icombine) (!= (re-op next) RE_COMPOSING))
                                    ;; This code makes a composing character get ignored,
                                    ;; which is the correct behavior (sometimes)
                                    ;; for voweled Hebrew texts.
                                    ((ร status =) RA_NOMATCH)
                                )
                                (if (!= status RA_NOMATCH)
                                    (reset! reginput (.plus @reginput (... len 0))))
                            ))
                            (ร BREAK)
                        )

                        ((ร CASE) ANYOF)
                        ((ร CASE) ANYBUT)
                        (do
                            (cond (== c NUL)
                            (do
                                ((ร status =) RA_NOMATCH)
                            )
                            (== (nil? (cstrchr (operand scan), c)) (== op ANYOF))
                            (do
                                ((ร status =) RA_NOMATCH)
                            )
                            :else
                            (do
                                (reset! reginput (.plus @reginput (us-ptr2len-cc @reginput)))
                            ))
                            (ร BREAK)
                        )

                        ((ร CASE) MULTIBYTECODE)
                        (do
                            ((ร Bytes opnd =) (operand scan))
                            ;; Safety check (just in case 'encoding' was changed since compiling the program).
                            ((ร int len =) (us-ptr2len-cc opnd))
                            (when (< len 2)
                                ((ร status =) RA_NOMATCH)
                                (ร BREAK)
                            )
                            ((ร int opndc =) (us-ptr2char opnd))
                            (cond (utf-iscomposing opndc)
                            (do
                                ;; When only a composing char is given match at any
                                ;; position where that composing char appears.
                                ((ร status =) RA_NOMATCH)
                                ((ร FOR) (ร ((ร int i =) 0) (non-eos? @reginput i) ((ร i =) (+ i (us-ptr2len (.plus @reginput i)))))
                                    ((ร int inpc =) (us-ptr2char (.plus @reginput i)))
                                    (cond (not (utf-iscomposing inpc))
                                    (do
                                        (if (< 0 i)
                                            (ร BREAK)
                                        )
                                    )
                                    (== opndc inpc)
                                    (do
                                        ;; Include all following composing chars.
                                        ((ร len =) (+ i (us-ptr2len-cc (.plus @reginput i))))
                                        ((ร status =) RA_MATCH)
                                        (ร BREAK)
                                    ))
                                )
                            )
                            :else
                            (do
                                (dotimes [#_int i len]
                                    (when (!= (.at opnd i) (.at @reginput i))
                                        ((ร status =) RA_NOMATCH)
                                        (ร BREAK)
                                    )
                                )
                            ))

                            (reset! reginput (.plus @reginput len))
                            (ร BREAK)
                        )

                        ((ร CASE) RE_COMPOSING)
                        (do
                            ;; Skip composing characters.
                            (while (utf-iscomposing (us-ptr2char @reginput))
                                (reset! reginput (.plus @reginput (us-ptr2len @reginput)))
                            )
                            (ร BREAK)
                        )

                        ((ร CASE) NOTHING)
                        (do
                            (ร BREAK)
                        )

                        ((ร CASE) BACK)
                        (do
                            ;; When we run into BACK we need to check if we don't keep
                            ;; looping without matching any input.  The second and later
                            ;; times a BACK is encountered it fails if the input is still
                            ;; at the same position as the previous time.
                            ;; The positions are stored in "backpos" and found by the
                            ;; current value of "scan", the position in the RE program.

                            ((ร backpos_C[] bpp =) (:ga_data @backpos))

                            (ร int i)
                            ((ร FOR) (ร ((ร i =) 0) (< i (:ga_len @backpos)) (ร i++))
                                (if (BEQ (:bp_scan (... bpp i)), scan)
                                    (ร BREAK)
                                )
                            )
                            (cond (== i (:ga_len @backpos))
                            (do
                                ;; First time at this BACK, make room to store the pos.
                                ((ร bpp =) (.ga_grow @backpos 1))
                                ((ร bpp[i] =) (NEW_backpos_C))
                                ((ร bpp[i].bp_scan =) scan)
                                (ร @backpos.ga_len++)
                            )
                            (reg-save-equal (:bp_pos (... bpp i)))
                            (do
                                ;; Still at same position as last time, fail.
                                ((ร status =) RA_NOMATCH)
                            ))

                            (if (and (!= status RA_FAIL) (!= status RA_NOMATCH))
                                (reg-save (:bp_pos (... bpp i)), @backpos))

                            (ร BREAK)
                        )

                        ((ร CASE) (+ MOPEN 0))     ;; Match start: \zs
                        ((ร CASE) (inc MOPEN))     ;; \(
                        ((ร CASE) (+ MOPEN 2))
                        ((ร CASE) (+ MOPEN 3))
                        ((ร CASE) (+ MOPEN 4))
                        ((ร CASE) (+ MOPEN 5))
                        ((ร CASE) (+ MOPEN 6))
                        ((ร CASE) (+ MOPEN 7))
                        ((ร CASE) (+ MOPEN 8))
                        ((ร CASE) (+ MOPEN 9))
                        (do
                            ((ร int no =) (- op MOPEN))
                            (cleanup-subexpr)
                            ((ร regitem_C rip =) (push-regitem RS_MOPEN, scan))
                            (cond (nil? rip)
                            (do
                                ((ร status =) RA_FAIL)
                            )
                            :else
                            (do
                                ((ร rip.rs_no =) no)
                                ((ร @reg_startp[no] =) (save-se (:rs_sesave rip), (... @reg_startpos no), (... @reg_startp no)))
                                ;; We simply continue and handle the result when done.
                            ))
                            (ร BREAK)
                        )

                        ((ร CASE) NOPEN)         ;; \%(
                        ((ร CASE) NCLOSE)        ;; \) after \%(
                        (do
                            (if (nil? (push-regitem RS_NOPEN, scan))
                                ((ร status =) RA_FAIL)
                            )
                            ;; We simply continue and handle the result when done.
                            (ร BREAK)
                        )

                        ((ร CASE) (inc ZOPEN))
                        ((ร CASE) (+ ZOPEN 2))
                        ((ร CASE) (+ ZOPEN 3))
                        ((ร CASE) (+ ZOPEN 4))
                        ((ร CASE) (+ ZOPEN 5))
                        ((ร CASE) (+ ZOPEN 6))
                        ((ร CASE) (+ ZOPEN 7))
                        ((ร CASE) (+ ZOPEN 8))
                        ((ร CASE) (+ ZOPEN 9))
                        (do
                            ((ร int no =) (- op ZOPEN))
                            (cleanup-zsubexpr)
                            ((ร regitem_C rip =) (push-regitem RS_ZOPEN, scan))
                            (cond (nil? rip)
                            (do
                                ((ร status =) RA_FAIL)
                            )
                            :else
                            (do
                                ((ร rip.rs_no =) no)
                                ((ร reg_startzp[no] =) (save-se (:rs_sesave rip), (... reg_startzpos no), (... reg_startzp no)))
                                ;; We simply continue and handle the result when done.
                            ))
                            (ร BREAK)
                        )

                        ((ร CASE) (+ MCLOSE 0))    ;; Match end: \ze
                        ((ร CASE) (inc MCLOSE))    ;; \)
                        ((ร CASE) (+ MCLOSE 2))
                        ((ร CASE) (+ MCLOSE 3))
                        ((ร CASE) (+ MCLOSE 4))
                        ((ร CASE) (+ MCLOSE 5))
                        ((ร CASE) (+ MCLOSE 6))
                        ((ร CASE) (+ MCLOSE 7))
                        ((ร CASE) (+ MCLOSE 8))
                        ((ร CASE) (+ MCLOSE 9))
                        (do
                            ((ร int no =) (- op MCLOSE))
                            (cleanup-subexpr)
                            ((ร regitem_C rip =) (push-regitem RS_MCLOSE, scan))
                            (cond (nil? rip)
                            (do
                                ((ร status =) RA_FAIL)
                            )
                            :else
                            (do
                                ((ร rip.rs_no =) no)
                                ((ร @reg_endp[no] =) (save-se (:rs_sesave rip), (... @reg_endpos no), (... @reg_endp no)))
                                ;; We simply continue and handle the result when done.
                            ))
                            (ร BREAK)
                        )

                        ((ร CASE) (inc ZCLOSE))    ;; \) after \z(
                        ((ร CASE) (+ ZCLOSE 2))
                        ((ร CASE) (+ ZCLOSE 3))
                        ((ร CASE) (+ ZCLOSE 4))
                        ((ร CASE) (+ ZCLOSE 5))
                        ((ร CASE) (+ ZCLOSE 6))
                        ((ร CASE) (+ ZCLOSE 7))
                        ((ร CASE) (+ ZCLOSE 8))
                        ((ร CASE) (+ ZCLOSE 9))
                        (do
                            ((ร int no =) (- op ZCLOSE))
                            (cleanup-zsubexpr)
                            ((ร regitem_C rip =) (push-regitem RS_ZCLOSE, scan))
                            (cond (nil? rip)
                            (do
                                ((ร status =) RA_FAIL)
                            )
                            :else
                            (do
                                ((ร rip.rs_no =) no)
                                ((ร reg_endzp[no] =) (save-se (:rs_sesave rip), (... reg_endzpos no), (... reg_endzp no)))
                                ;; We simply continue and handle the result when done.
                            ))
                            (ร BREAK)
                        )

                        ((ร CASE) (inc BACKREF))
                        ((ร CASE) (+ BACKREF 2))
                        ((ร CASE) (+ BACKREF 3))
                        ((ร CASE) (+ BACKREF 4))
                        ((ร CASE) (+ BACKREF 5))
                        ((ร CASE) (+ BACKREF 6))
                        ((ร CASE) (+ BACKREF 7))
                        ((ร CASE) (+ BACKREF 8))
                        ((ร CASE) (+ BACKREF 9))
                        (do
                            ((ร int[] len =) (ร new int[1]))

                            ((ร int no =) (- op BACKREF))
                            (cleanup-subexpr)
                            (cond (non-nil? @reg_match)       ;; Single-line regexp
                            (do
                                (cond (or (nil? (... @reg_startp no)) (nil? (... @reg_endp no)))
                                (do
                                    ;; Backref was not set: Match an empty string.
                                    ((ร len[0] =) 0)
                                )
                                :else
                                (do
                                    ;; Compare current input with back-ref in the same line.
                                    ((ร len[0] =) (BDIFF (... @reg_endp no), (... @reg_startp no)))
                                    (if (non-zero? (cstrncmp (... @reg_startp no), @reginput, len))
                                        ((ร status =) RA_NOMATCH)
                                    )
                                ))
                            )
                            :else                            ;; Multi-line regexp
                            (do
                                (cond (or (< (:lnum (... @reg_startpos no)) 0) (< (:lnum (... @reg_endpos no)) 0))
                                (do
                                    ;; Backref was not set: Match an empty string.
                                    ((ร len[0] =) 0)
                                )
                                :else
                                (do
                                    (cond (and (== (:lnum (... @reg_startpos no)) @reglnum) (== (:lnum (... @reg_endpos no)) @reglnum))
                                    (do
                                        ;; Compare back-ref within the current line.
                                        ((ร len[0] =) (- (:col (... @reg_endpos no)) (:col (... @reg_startpos no))))
                                        (if (non-zero? (cstrncmp (.plus @regline (:col (... @reg_startpos no))), @reginput, len))
                                            ((ร status =) RA_NOMATCH)
                                        )
                                    )
                                    :else
                                    (do
                                        ;; Messy situation: Need to compare between two lines.
                                        ((ร int r =) (match-with-backref (:lnum (... @reg_startpos no)), (:col (... @reg_startpos no)), (:lnum (... @reg_endpos no)), (:col (... @reg_endpos no)), len))

                                        (if (!= r RA_MATCH)
                                            ((ร status =) r)
                                        )
                                    ))
                                ))
                            ))

                            ;; Matched the backref, skip over it.
                            (reset! reginput (.plus @reginput (... len 0)))
                            (ร BREAK)
                        )

                        ((ร CASE) (inc ZREF))
                        ((ร CASE) (+ ZREF 2))
                        ((ร CASE) (+ ZREF 3))
                        ((ร CASE) (+ ZREF 4))
                        ((ร CASE) (+ ZREF 5))
                        ((ร CASE) (+ ZREF 6))
                        ((ร CASE) (+ ZREF 7))
                        ((ร CASE) (+ ZREF 8))
                        ((ร CASE) (+ ZREF 9))
                        (do
                            (cleanup-zsubexpr)
                            ((ร int no =) (- op ZREF))
                            (cond (and (non-nil? @re_extmatch_in) (non-nil? (... (:matches @re_extmatch_in) no)))
                            (do
; %%                            ((ร int[] len =) (ร { STRLEN(@re_extmatch_in.matches[no]) }))
                                (if (non-zero? (cstrncmp (... (:matches @re_extmatch_in) no), @reginput, len))
                                    ((ร status =) RA_NOMATCH)
                                    (reset! reginput (.plus @reginput (... len 0))))
                            )
                            :else
                            (do
                                ;; Backref was not set: Match an empty string.
                            ))
                            (ร BREAK)
                        )

                        ((ร CASE) BRANCH)
                        (do
                            (cond (!= (re-op next) BRANCH) ;; No choice.
                            (do
                                ((ร next =) (operand scan))       ;; Avoid recursion.
                            )
                            :else
                            (do
                                ((ร regitem_C rip =) (push-regitem RS_BRANCH, scan))
                                ((ร status =) (if (nil? rip) RA_FAIL RA_BREAK))      ;; rest is below
                            ))
                            (ร BREAK)
                        )

                        ((ร CASE) BRACE_LIMITS)
                        (do
                            (cond (== (re-op next) BRACE_SIMPLE)
                            (do
                                (reset! bl_minval (operand-min scan))
                                (reset! bl_maxval (operand-max scan))
                            )
                            (and (<= BRACE_COMPLEX (re-op next)) (< (re-op next) (+ BRACE_COMPLEX 10)))
                            (do
                                ((ร int no =) (- (re-op next) BRACE_COMPLEX))
                                ((ร @brace_min[no] =) (operand-min scan))
                                ((ร @brace_max[no] =) (operand-max scan))
                                ((ร @brace_count[no] =) 0)
                            )
                            :else
                            (do
                                (emsg e_internal)       ;; Shouldn't happen.
                                ((ร status =) RA_FAIL)
                            ))
                            (ร BREAK)
                        )

                        ((ร CASE) (+ BRACE_COMPLEX 0))
                        ((ร CASE) (inc BRACE_COMPLEX))
                        ((ร CASE) (+ BRACE_COMPLEX 2))
                        ((ร CASE) (+ BRACE_COMPLEX 3))
                        ((ร CASE) (+ BRACE_COMPLEX 4))
                        ((ร CASE) (+ BRACE_COMPLEX 5))
                        ((ร CASE) (+ BRACE_COMPLEX 6))
                        ((ร CASE) (+ BRACE_COMPLEX 7))
                        ((ร CASE) (+ BRACE_COMPLEX 8))
                        ((ร CASE) (+ BRACE_COMPLEX 9))
                        (do
                            ((ร int no =) (- op BRACE_COMPLEX))
                            (ร ++@brace_count[no])

                            ;; If not matched enough times yet, try one more.
                            (when (<= (... @brace_count no) (if (<= (... @brace_min no) (... @brace_max no)) (... @brace_min no) (... @brace_max no)))
                                ((ร regitem_C rip =) (push-regitem RS_BRCPLX_MORE, scan))
                                (cond (nil? rip)
                                (do
                                    ((ร status =) RA_FAIL)
                                )
                                :else
                                (do
                                    ((ร rip.rs_no =) no)
                                    (reg-save (:rs_regsave rip), @backpos)
                                    ((ร next =) (operand scan))
                                    ;; We continue and handle the result when done.
                                ))
                                (ร BREAK)
                            )

                            ;; If matched enough times, may try matching some more.
                            (cond (<= (... @brace_min no) (... @brace_max no))
                            (do
                                ;; Range is the normal way around, use longest match.
                                (when (<= (... @brace_count no) (... @brace_max no))
                                    ((ร regitem_C rip =) (push-regitem RS_BRCPLX_LONG, scan))
                                    (cond (nil? rip)
                                    (do
                                        ((ร status =) RA_FAIL)
                                    )
                                    :else
                                    (do
                                        ((ร rip.rs_no =) no)
                                        (reg-save (:rs_regsave rip), @backpos)
                                        ((ร next =) (operand scan))
                                        ;; We continue and handle the result when done.
                                    ))
                                )
                            )
                            :else
                            (do
                                ;; Range is backwards, use shortest match first.
                                (when (<= (... @brace_count no) (... @brace_min no))
                                    ((ร regitem_C rip =) (push-regitem RS_BRCPLX_SHORT, scan))
                                    (cond (nil? rip)
                                    (do
                                        ((ร status =) RA_FAIL)
                                    )
                                    :else
                                    (do
                                        (reg-save (:rs_regsave rip), @backpos)
                                        ;; We continue and handle the result when done.
                                    ))
                                )
                            ))
                            (ร BREAK)
                        )

                        ((ร CASE) BRACE_SIMPLE)
                        ((ร CASE) STAR)
                        ((ร CASE) PLUS)
                        (do
                            ((ร regstar_C rst =) (NEW_regstar_C))

                            ;; Lookahead to avoid useless match attempts when we know
                            ;; what character comes next.

                            (cond (== (re-op next) EXACTLY)
                            (do
                                ((ร rst.nextb =) (.at (operand next) 0))
                                (cond @ireg_ic
                                (do
                                    ((ร rst.nextb_ic =) (if (utf-isupper (:nextb rst)) (utf-tolower (:nextb rst)) (utf-toupper (:nextb rst))))
                                )
                                :else
                                (do
                                    ((ร rst.nextb_ic =) (:nextb rst))
                                ))
                            )
                            :else
                            (do
                                ((ร rst.nextb =) NUL)
                                ((ร rst.nextb_ic =) NUL)
                            ))

                            (cond (!= op BRACE_SIMPLE)
                            (do
                                ((ร rst.minval =) (if (== op STAR) 0 1))
                                ((ร rst.maxval =) MAX_LIMIT)
                            )
                            :else
                            (do
                                ((ร rst.minval =) @bl_minval)
                                ((ร rst.maxval =) @bl_maxval)
                            ))

                            ;; When maxval > minval, try matching as much as possible, up to maxval.
                            ;; When maxval < minval, try matching at least the minimal number
                            ;; (since the range is backwards, that's also maxval!).

                            ((ร rst.count =) (regrepeat (operand scan), (:maxval rst)))
                            (when @got_int
                                ((ร status =) RA_FAIL)
                                (ร BREAK)
                            )

                            (cond (if (<= (:minval rst) (:maxval rst)) (<= (:minval rst) (:count rst)) (<= (:maxval rst) (:count rst)))
                            (do
                                ;; It could match.  Prepare for trying to match
                                ;; what follows.  The code is below.  Parameters
                                ;; are stored in a regstar_C on the regstack.
                                (cond (<= @p_mmp (>>> (:ga_len @regstack) 10))
                                (do
                                    (emsg e_maxmempat)
                                    ((ร status =) RA_FAIL)
                                )
                                :else
                                (do
                                    (.ga_grow @regstack 1)
                                    ((ร @regstack.ga_data[@regstack.ga_len++] =) rst)
                                    ((ร rst =) nil)

                                    ((ร regitem_C rip =) (push-regitem (if (<= (:minval rst) (:maxval rst)) RS_STAR_LONG RS_STAR_SHORT), scan))
                                    ((ร status =) (if (nil? rip) RA_FAIL RA_BREAK))      ;; skip the restore bits
                                ))
                            )
                            :else
                            (do
                                ((ร status =) RA_NOMATCH)
                            ))

                            (ร BREAK)
                        )

                        ((ร CASE) NOMATCH)
                        ((ร CASE) MATCH)
                        ((ร CASE) SUBPAT)
                        (do
                            ((ร regitem_C rip =) (push-regitem RS_NOMATCH, scan))
                            (cond (nil? rip)
                            (do
                                ((ร status =) RA_FAIL)
                            )
                            :else
                            (do
                                ((ร rip.rs_no =) op)
                                (reg-save (:rs_regsave rip), @backpos)
                                ((ร next =) (operand scan))
                                ;; We continue and handle the result when done.
                            ))
                            (ร BREAK)
                        )

                        ((ร CASE) BEHIND)
                        ((ร CASE) NOBEHIND)
                        (do
                            ;; Need a bit of room to store extra positions.
                            (cond (<= @p_mmp (>>> (:ga_len @regstack) 10))
                            (do
                                (emsg e_maxmempat)
                                ((ร status =) RA_FAIL)
                            )
                            :else
                            (do
                                ((ร regbehind_C rbp =) (NEW_regbehind_C))

                                (.ga_grow @regstack 1)
                                ((ร @regstack.ga_data[@regstack.ga_len++] =) rbp)

                                ((ร regitem_C rip =) (push-regitem RS_BEHIND1, scan))
                                (cond (nil? rip)
                                (do
                                    ((ร status =) RA_FAIL)
                                )
                                :else
                                (do
                                    ;; Need to save the subexpr to be able to restore them
                                    ;; when there is a match but we don't use it.
                                    (save-subexpr rbp)

                                    ((ร rip.rs_no =) op)
                                    (reg-save (:rs_regsave rip), @backpos)
                                    ;; First try if what follows matches.
                                    ;; If it does, then we check the behind match by looping.
                                ))
                            ))
                            (ร BREAK)
                        )

                        ((ร CASE) BHPOS)
                        (do
                            (cond (nil? @reg_match)
                            (do
                                (when (or (!= (:col (:rs_pos @behind_pos)) (BDIFF @reginput, @regline)) (!= (:lnum (:rs_pos @behind_pos)) @reglnum))
                                    ((ร status =) RA_NOMATCH)
                                )
                            )
                            (BNE (:rs_ptr @behind_pos), @reginput)
                            (do
                                ((ร status =) RA_NOMATCH)
                            ))
                            (ร BREAK)
                        )

                        ((ร CASE) NEWL)
                        (do
                            (cond (and (or (!= c NUL) (non-nil? @reg_match) (< @reg_maxline @reglnum) @reg_line_lbr) (or (!= c (byte \newline)) (not @reg_line_lbr)))
                            (do
                                ((ร status =) RA_NOMATCH)
                            )
                            @reg_line_lbr
                            (do
                                (reset! reginput (.plus @reginput (us-ptr2len-cc @reginput)))
                            )
                            :else
                            (do
                                (reg-nextline)
                            ))
                            (ร BREAK)
                        )

                        ((ร CASE) END)
                        (do
                            ((ร status =) RA_MATCH)  ;; Success!
                            (ร BREAK)
                        )

                        (ร DEFAULT)
                        (do
                            (emsg e_re_corr)
                            ((ร status =) RA_FAIL)
                            (ร BREAK)
                        )
                    )
                ))

                ;; If we can't continue sequentially, break the inner loop.
                (if (!= status RA_CONT)
                    (ร BREAK)
                )

                ;; Continue in inner loop, advance to next item.
                ((ร scan =) next)
            )

            ;; If there is something on the regstack, execute the code for the state.
            ;; If the state is popped then loop and use the older state.

            (while (and (< 0 (:ga_len @regstack)) (!= status RA_FAIL))
                ((ร Object vip =) (if (< 1 (:ga_len @regstack)) (... (:ga_data @regstack) (- (:ga_len @regstack) 2)) nil))
                ((ร regitem_C rip =) (ร (regitem_C)(@regstack.ga_data[@regstack.ga_len - 1])))

                ((ร SWITCH) (:rs_state rip)
                    ((ร CASE) RS_NOPEN)
                    (do
                        ;; Result is passed on as-is, simply pop the state.
                        ((ร scan =) (pop-regitem))
                        (ร BREAK)
                    )

                    ((ร CASE) RS_MOPEN)
                    (do
                        ;; Pop the state.  Restore pointers when there is no match.
                        (when (== status RA_NOMATCH)
                            ((ร @reg_startp[rip.rs_no] =) (restore-se (:rs_sesave rip), (... @reg_startpos (:rs_no rip)), (... @reg_startp (:rs_no rip))))
                        )
                        ((ร scan =) (pop-regitem))
                        (ร BREAK)
                    )

                    ((ร CASE) RS_ZOPEN)
                    (do
                        ;; Pop the state.  Restore pointers when there is no match.
                        (when (== status RA_NOMATCH)
                            ((ร reg_startzp[rip.rs_no] =) (restore-se (:rs_sesave rip), (... reg_startzpos (:rs_no rip)), (... reg_startzp (:rs_no rip))))
                        )
                        ((ร scan =) (pop-regitem))
                        (ร BREAK)
                    )

                    ((ร CASE) RS_MCLOSE)
                    (do
                        ;; Pop the state.  Restore pointers when there is no match.
                        (when (== status RA_NOMATCH)
                            ((ร @reg_endp[rip.rs_no] =) (restore-se (:rs_sesave rip), (... @reg_endpos (:rs_no rip)), (... @reg_endp (:rs_no rip))))
                        )
                        ((ร scan =) (pop-regitem))
                        (ร BREAK)
                    )

                    ((ร CASE) RS_ZCLOSE)
                    (do
                        ;; Pop the state.  Restore pointers when there is no match.
                        (when (== status RA_NOMATCH)
                            ((ร reg_endzp[rip.rs_no] =) (restore-se (:rs_sesave rip), (... reg_endzpos (:rs_no rip)), (... reg_endzp (:rs_no rip))))
                        )
                        ((ร scan =) (pop-regitem))
                        (ร BREAK)
                    )

                    ((ร CASE) RS_BRANCH)
                    (do
                        (cond (== status RA_MATCH)
                        (do
                            ;; this branch matched, use it
                            ((ร scan =) (pop-regitem))
                        )
                        :else
                        (do
                            (when (!= status RA_BREAK)
                                ;; After a non-matching branch: try next one.
                                (reg-restore (:rs_regsave rip), @backpos)
                                ((ร scan =) (:rs_scan rip))
                            )
                            (cond (or (nil? scan) (!= (re-op scan) BRANCH))
                            (do
                                ;; no more branches, didn't find a match
                                ((ร status =) RA_NOMATCH)
                                ((ร scan =) (pop-regitem))
                            )
                            :else
                            (do
                                ;; Prepare to try a branch.
                                ((ร rip.rs_scan =) (regnext scan))
                                (reg-save (:rs_regsave rip), @backpos)
                                ((ร scan =) (operand scan))
                            ))
                        ))
                        (ร BREAK)
                    )

                    ((ร CASE) RS_BRCPLX_MORE)
                    (do
                        ;; Pop the state.  Restore pointers when there is no match.
                        (when (== status RA_NOMATCH)
                            (reg-restore (:rs_regsave rip), @backpos)
                            (ร --@brace_count[rip.rs_no])       ;; decrement match count
                        )
                        ((ร scan =) (pop-regitem))
                        (ร BREAK)
                    )

                    ((ร CASE) RS_BRCPLX_LONG)
                    (do
                        ;; Pop the state.  Restore pointers when there is no match.
                        (when (== status RA_NOMATCH)
                            ;; There was no match, but we did find enough matches.
                            (reg-restore (:rs_regsave rip), @backpos)
                            (ร --@brace_count[rip.rs_no])
                            ;; continue with the items after "\{}"
                            ((ร status =) RA_CONT)
                        )
                        ((ร scan =) (pop-regitem))
                        (if (== status RA_CONT)
                            ((ร scan =) (regnext scan))
                        )
                        (ร BREAK)
                    )

                    ((ร CASE) RS_BRCPLX_SHORT)
                    (do
                        ;; Pop the state.  Restore pointers when there is no match.
                        (when (== status RA_NOMATCH)
                            ;; There was no match, try to match one more item.
                            (reg-restore (:rs_regsave rip), @backpos)
                        )
                        ((ร scan =) (pop-regitem))
                        (when (== status RA_NOMATCH)
                            ((ร scan =) (operand scan))
                            ((ร status =) RA_CONT)
                        )
                        (ร BREAK)
                    )

                    ((ร CASE) RS_NOMATCH)
                    (do
                        ;; Pop the state.  If the operand matches for NOMATCH or
                        ;; doesn't match for MATCH/SUBPAT, we fail.  Otherwise backup,
                        ;; except for SUBPAT, and continue with the next item.
                        (cond (== status (if (== (:rs_no rip) NOMATCH) RA_MATCH RA_NOMATCH))
                        (do
                            ((ร status =) RA_NOMATCH)
                        )
                        :else
                        (do
                            ((ร status =) RA_CONT)
                            (if (!= (:rs_no rip) SUBPAT)        ;; zero-width
                                (reg-restore (:rs_regsave rip), @backpos))
                        ))
                        ((ร scan =) (pop-regitem))
                        (if (== status RA_CONT)
                            ((ร scan =) (regnext scan))
                        )
                        (ร BREAK)
                    )

                    ((ร CASE) RS_BEHIND1)
                    (do
                        (cond (== status RA_NOMATCH)
                        (do
                            ((ร scan =) (pop-regitem))
                            (drop-regbehind)
                        )
                        :else
                        (do
                            ;; The stuff after BEHIND/NOBEHIND matches.
                            ;; Now try if the behind part does (not) match before the current
                            ;; position in the input.  This must be done at every position in the
                            ;; input and checking if the match ends at the current position.

                            ;; save the position after the found match for next
                            (reg-save (:save_after (ร (regbehind_C)vip)), @backpos)

                            ;; Start looking for a match with operand at the current position.
                            ;; Go back one character until we find the result, hitting the start
                            ;; of the line or the previous line (for multi-line matching).
                            ;; Set behind_pos to where the match should end, BHPOS will match it.
                            ;; Save the current value.
                            (COPY-regsave (:save_behind (ร (regbehind_C)vip)), @behind_pos)
                            (COPY-regsave @behind_pos, (:rs_regsave rip))

                            ((ร rip.rs_state =) RS_BEHIND2)

                            (reg-restore (:rs_regsave rip), @backpos)
                            ((ร scan =) (.plus (operand (:rs_scan rip)) 4))
                        ))
                        (ร BREAK)
                    )

                    ((ร CASE) RS_BEHIND2)
                    (do
                        ;; Looping for BEHIND / NOBEHIND match.

                        (cond (and (== status RA_MATCH) (reg-save-equal @behind_pos))
                        (do
                            ;; found a match that ends where "next" started
                            (COPY-regsave @behind_pos, (:save_behind (ร (regbehind_C)vip)))
                            (cond (== (:rs_no rip) BEHIND)
                            (do
                                (reg-restore (:save_after (ร (regbehind_C)vip)), @backpos)
                            )
                            :else
                            (do
                                ;; But we didn't want a match.  Need to restore the subexpr,
                                ;; because what follows matched, so they have been set.
                                ((ร status =) RA_NOMATCH)
                                (restore-subexpr (ร (regbehind_C)vip))
                            ))
                            ((ร scan =) (pop-regitem))
                            (drop-regbehind)
                        )
                        :else
                        (do
                            ;; No match or a match that doesn't end where we want it:
                            ;; go back one character.  May go to previous line once.
                            ((ร boolean no =) true)
                            ((ร long limit =) (operand-min (:rs_scan rip)))
                            (cond (nil? @reg_match)
                            (do
                                (cond (and (< 0 limit) (<= limit (- (if (< (:lnum (:rs_pos (:rs_regsave rip))) (:lnum (:rs_pos @behind_pos))) (STRLEN @regline) (:col (:rs_pos @behind_pos))) (:col (:rs_pos (:rs_regsave rip))))))
                                (do
                                    ((ร no =) false)
                                )
                                (zero? (:col (:rs_pos (:rs_regsave rip))))
                                (do
                                    (cond (or (< (:lnum (:rs_pos (:rs_regsave rip))) (:lnum (:rs_pos @behind_pos))) (nil? (reg-getline (ร --rip.rs_regsave.rs_pos.lnum))))
                                    (do
                                        ((ร no =) false)
                                    )
                                    :else
                                    (do
                                        (reg-restore (:rs_regsave rip), @backpos)
                                        ((ร rip.rs_regsave.rs_pos.col =) (STRLEN @regline))
                                    ))
                                )
                                :else
                                (do
                                    ((ร rip.rs_regsave.rs_pos.col =) (- (:col (:rs_pos (:rs_regsave rip))) (inc (us-head-off @regline, (.plus @regline (dec (:col (:rs_pos (:rs_regsave rip)))))))))
                                ))
                            )
                            :else
                            (do
                                (cond (BEQ (:rs_ptr (:rs_regsave rip)), @regline)
                                (do
                                    ((ร no =) false)
                                )
                                :else
                                (do
                                    ((ร rip.rs_regsave.rs_ptr =) (.minus (:rs_ptr (:rs_regsave rip)) (us-ptr-back @regline, (:rs_ptr (:rs_regsave rip)))))
                                    (if (and (< 0 limit) (< limit (BDIFF (:rs_ptr @behind_pos), (:rs_ptr (:rs_regsave rip)))))
                                        ((ร no =) false)
                                    )
                                ))
                            ))
                            (cond no
                            (do
                                ;; Advanced, prepare for finding match again.
                                (reg-restore (:rs_regsave rip), @backpos)
                                ((ร scan =) (.plus (operand (:rs_scan rip)) 4))
                                (when (== status RA_MATCH)
                                    ;; We did match, so subexpr may have been changed,
                                    ;; need to restore them for the next try.
                                    ((ร status =) RA_NOMATCH)
                                    (restore-subexpr (ร (regbehind_C)vip))
                                )
                            )
                            :else
                            (do
                                ;; Can't advance.  For NOBEHIND that's a match.
                                (COPY-regsave @behind_pos, (:save_behind (ร (regbehind_C)vip)))
                                (cond (== (:rs_no rip) NOBEHIND)
                                (do
                                    (reg-restore (:save_after (ร (regbehind_C)vip)), @backpos)
                                    ((ร status =) RA_MATCH)
                                )
                                :else
                                (do
                                    ;; We do want a proper match.  Need to restore the subexpr
                                    ;; if we had a match, because they may have been set.
                                    (when (== status RA_MATCH)
                                        ((ร status =) RA_NOMATCH)
                                        (restore-subexpr (ร (regbehind_C)vip))
                                    )
                                ))
                                ((ร scan =) (pop-regitem))
                                (drop-regbehind)
                            ))
                        ))
                        (ร BREAK)
                    )

                    ((ร CASE) RS_STAR_LONG)
                    ((ร CASE) RS_STAR_SHORT)
                    (do
                        ((ร regstar_C rst =) (ร (regstar_C)vip))

                        (when (== status RA_MATCH)
                            ((ร scan =) (pop-regitem))
                            (drop-regstar)
                            (ร BREAK)
                        )

                        ;; Tried once already, restore input pointers.
                        (if (!= status RA_BREAK)
                            (reg-restore (:rs_regsave rip), @backpos))

                        ;; Repeat until we found a position where it could match.
                        (while true
                            (cond (!= status RA_BREAK)
                            (do
                                ;; Tried first position already, advance.
                                (cond (== (:rs_state rip) RS_STAR_LONG)
                                (do
                                    ;; Trying for longest match, but couldn't
                                    ;; or didn't match -- back up one char.
                                    (if (< (ร --rst.count) (:minval rst))
                                        (ร BREAK)
                                    )
                                    (cond (BEQ @reginput, @regline)
                                    (do
                                        ;; backup to last char of previous line
                                        (swap! reglnum dec)
                                        (reset! regline (reg-getline @reglnum))
                                        ;; Just in case regrepeat() didn't count right.
                                        (if (nil? @regline)
                                            (ร BREAK)
                                        )
                                        (reset! reginput (.plus @regline (STRLEN @regline)))
                                        (fast-breakcheck)
                                    )
                                    :else
                                    (do
                                        (reset! reginput (.minus @reginput (us-ptr-back @regline, @reginput)))
                                    ))
                                )
                                :else
                                (do
                                    ;; Range is backwards, use shortest match first.
                                    ;; Careful: maxval and minval are exchanged!
                                    ;; Couldn't or didn't match: try advancing one char.
                                    (if (or (== (:count rst) (:minval rst)) (zero? (regrepeat (operand (:rs_scan rip)), 1)))
                                        (ร BREAK)
                                    )
                                    (ร rst.count++)
                                ))
                                (if @got_int
                                    (ร BREAK)
                                )
                            )
                            :else
                            (do
                                ((ร status =) RA_NOMATCH)
                            ))

                            ;; If it could match, try it.
                            (when (or (== (:nextb rst) NUL) (== (.at @reginput 0) (:nextb rst)) (== (.at @reginput 0) (:nextb_ic rst)))
                                (reg-save (:rs_regsave rip), @backpos)
                                ((ร scan =) (regnext (:rs_scan rip)))
                                ((ร status =) RA_CONT)
                                (ร BREAK)
                            )
                        )
                        (when (!= status RA_CONT)
                            ;; Failed.
                            ((ร scan =) (pop-regitem))
                            (drop-regstar)
                            ((ร status =) RA_NOMATCH)
                        )
                    )
                    (ร BREAK)
                )

                ;; If we want to continue the inner loop or didn't pop a state continue matching loop.
                (if (or (== status RA_CONT) (== rip (ร (regitem_C)(@regstack.ga_data[@regstack.ga_len - 1]))))
                    (ร BREAK)
                )
            )

            ;; May need to continue with the inner loop, starting at "scan".
            (if (== status RA_CONT)
                (ร CONTINUE)
            )

            ;; If the regstack is empty or something failed we are done.

            (when (or (zero? (:ga_len @regstack)) (== status RA_FAIL))
                (when (nil? scan)
                    ;; We get here only if there's trouble -- normally
                    ;; "case END" is the terminating point.

                    (emsg e_re_corr)
                )
                (if (== status RA_FAIL)
                    (reset! got_int true))
                ((ร RETURN) (== status RA_MATCH))
            )
        )

        ;; NOTREACHED
    ))

;; Push an item onto the regstack.
;; Returns pointer to new item.  Returns null when out of memory.

(defn- #_regitem_C push-regitem [#_int state, #_Bytes scan]
    (ยง
        (when (<= @p_mmp (>>> (:ga_len @regstack) 10))
            (emsg e_maxmempat)
            ((ร RETURN) nil)
        )

        ((ร regitem_C rip =) (NEW_regitem_C))

        (.ga_grow @regstack 1)
        ((ร @regstack.ga_data[@regstack.ga_len++] =) rip)

        ((ร rip.rs_state =) state)
        ((ร rip.rs_scan =) scan)

        rip
    ))

;; Pop an item from the regstack.

(defn- #_Bytes pop-regitem []
    (ยง
        ((ร regitem_C rip =) (ร (regitem_C)(@regstack.ga_data[--@regstack.ga_len])))
        ((ร @regstack.ga_data[@regstack.ga_len] =) nil)

        (:rs_scan rip)
    ))

(defn- #_void drop-regbehind []
    (ยง
        ((ร @regstack.ga_data[--@regstack.ga_len] =) nil)
        nil
    ))

(defn- #_void drop-regstar []
    (ยง
        ((ร @regstack.ga_data[--@regstack.ga_len] =) nil)
        nil
    ))

;; regrepeat - repeatedly match something simple, return how many.
;; Advances reginput (and reglnum) to just after the matched chars.

(defn- #_int regrepeat [#_Bytes p, #_long maxcount]
    ;; maxcount: maximum number of matches allowed
    (ยง
        ((ร long count =) 0)
        ((ร int testval =) 0)
        (ร int mask)

        ((ร Bytes scan =) @reginput)     ;; Make local copy of reginput for speed.
        ((ร Bytes opnd =) (operand p))

;       do_class:
;       {
            ((ร SWITCH) (re-op p)
                ((ร CASE) ANY)
                ((ร CASE) (+ ANY ADD_NL))
                (do
                    (while (< count maxcount)
                        ;; Matching anything means we continue until end-of-line (or
                        ;; end-of-file for ANY + ADD_NL), only limited by maxcount.
                        (while (and (non-eos? scan) (< count maxcount))
                            (ร count++)
                            ((ร scan =) (.plus scan (us-ptr2len-cc scan)))
                        )
                        (if (or (non-nil? @reg_match) (not (with-nl (re-op p))) (< @reg_maxline @reglnum) @reg_line_lbr (== count maxcount))
                            (ร BREAK)
                        )
                        (ร count++)                ;; count the line-break
                        (reg-nextline)
                        ((ร scan =) @reginput)
                        (if @got_int
                            (ร BREAK)
                        )
                    )
                    (ร BREAK do_class)
                )

                ((ร CASE) IDENT)
                ((ร CASE) (+ IDENT ADD_NL))
                (do
                    ((ร testval =) TRUE)
                    (ร FALLTHROUGH)
                )
                ((ร CASE) SIDENT)
                ((ร CASE) (+ SIDENT ADD_NL))
                (do
                    (while (< count maxcount)
                        (cond (and (vim-isIDc (us-ptr2char scan)) (or (non-zero? testval) (not (asc-isdigit (.at scan 0)))))
                        (do
                            ((ร scan =) (.plus scan (us-ptr2len-cc scan)))
                        )
                        (eos? scan)
                        (do
                            (if (or (non-nil? @reg_match) (not (with-nl (re-op p))) (< @reg_maxline @reglnum) @reg_line_lbr)
                                (ร BREAK)
                            )
                            (reg-nextline)
                            ((ร scan =) @reginput)
                            (if @got_int
                                (ร BREAK)
                            )
                        )
                        (and @reg_line_lbr (== (.at scan 0) (byte \newline)) (with-nl (re-op p)))
                        (do
                            ((ร scan =) (.plus scan 1))
                        )
                        :else
                        (do
                            (ร BREAK)
                        ))
                        (ร count++)
                    )
                    (ร BREAK do_class)
                )

                ((ร CASE) KWORD)
                ((ร CASE) (+ KWORD ADD_NL))
                (do
                    ((ร testval =) TRUE)
                    (ร FALLTHROUGH)
                )
                ((ร CASE) SKWORD)
                ((ร CASE) (+ SKWORD ADD_NL))
                (do
                    (while (< count maxcount)
                        (cond (and (us-iswordp scan, @reg_buf) (or (non-zero? testval) (not (asc-isdigit (.at scan 0)))))
                        (do
                            ((ร scan =) (.plus scan (us-ptr2len-cc scan)))
                        )
                        (eos? scan)
                        (do
                            (if (or (non-nil? @reg_match) (not (with-nl (re-op p))) (< @reg_maxline @reglnum) @reg_line_lbr)
                                (ร BREAK)
                            )
                            (reg-nextline)
                            ((ร scan =) @reginput)
                            (if @got_int
                                (ร BREAK)
                            )
                        )
                        (and @reg_line_lbr (== (.at scan 0) (byte \newline)) (with-nl (re-op p)))
                        (do
                            ((ร scan =) (.plus scan 1))
                        )
                        :else
                        (do
                            (ร BREAK)
                        ))
                        (ร count++)
                    )
                    (ร BREAK do_class)
                )

                ((ร CASE) FNAME)
                ((ร CASE) (+ FNAME ADD_NL))
                (do
                    ((ร testval =) TRUE)
                    (ร FALLTHROUGH)
                )
                ((ร CASE) SFNAME)
                ((ร CASE) (+ SFNAME ADD_NL))
                (do
                    (while (< count maxcount)
                        (cond (and (vim-isfilec (us-ptr2char scan)) (or (non-zero? testval) (not (asc-isdigit (.at scan 0)))))
                        (do
                            ((ร scan =) (.plus scan (us-ptr2len-cc scan)))
                        )
                        (eos? scan)
                        (do
                            (if (or (non-nil? @reg_match) (not (with-nl (re-op p))) (< @reg_maxline @reglnum) @reg_line_lbr)
                                (ร BREAK)
                            )
                            (reg-nextline)
                            ((ร scan =) @reginput)
                            (if @got_int
                                (ร BREAK)
                            )
                        )
                        (and @reg_line_lbr (== (.at scan 0) (byte \newline)) (with-nl (re-op p)))
                        (do
                            ((ร scan =) (.plus scan 1))
                        )
                        :else
                        (do
                            (ร BREAK)
                        ))
                        (ร count++)
                    )
                    (ร BREAK do_class)
                )

                ((ร CASE) PRINT)
                ((ร CASE) (+ PRINT ADD_NL))
                (do
                    ((ร testval =) TRUE)
                    (ร FALLTHROUGH)
                )
                ((ร CASE) SPRINT)
                ((ร CASE) (+ SPRINT ADD_NL))
                (do
                    (while (< count maxcount)
                        (cond (eos? scan)
                        (do
                            (if (or (non-nil? @reg_match) (not (with-nl (re-op p))) (< @reg_maxline @reglnum) @reg_line_lbr)
                                (ร BREAK)
                            )
                            (reg-nextline)
                            ((ร scan =) @reginput)
                            (if @got_int
                                (ร BREAK)
                            )
                        )
                        (and (vim-isprintc (us-ptr2char scan)) (or (non-zero? testval) (not (asc-isdigit (.at scan 0)))))
                        (do
                            ((ร scan =) (.plus scan (us-ptr2len-cc scan)))
                        )
                        (and @reg_line_lbr (== (.at scan 0) (byte \newline)) (with-nl (re-op p)))
                        (do
                            ((ร scan =) (.plus scan 1))
                        )
                        :else
                        (do
                            (ร BREAK)
                        ))
                        (ร count++)
                    )
                    (ร BREAK do_class)
                )

                ((ร CASE) WHITE)
                ((ร CASE) (+ WHITE ADD_NL))
                (do
                    ((ร testval =) ((ร mask =) RI_WHITE))
                    (ร BREAK)
                )

                ((ร CASE) NWHITE)
                ((ร CASE) (+ NWHITE ADD_NL))
                (do
                    ((ร mask =) RI_WHITE)
                    (ร BREAK)
                )

                ((ร CASE) DIGIT)
                ((ร CASE) (+ DIGIT ADD_NL))
                (do
                    ((ร testval =) ((ร mask =) RI_DIGIT))
                    (ร BREAK)
                )

                ((ร CASE) NDIGIT)
                ((ร CASE) (+ NDIGIT ADD_NL))
                (do
                    ((ร mask =) RI_DIGIT)
                    (ร BREAK)
                )

                ((ร CASE) HEX)
                ((ร CASE) (+ HEX ADD_NL))
                (do
                    ((ร testval =) ((ร mask =) RI_HEX))
                    (ร BREAK)
                )

                ((ร CASE) NHEX)
                ((ร CASE) (+ NHEX ADD_NL))
                (do
                    ((ร mask =) RI_HEX)
                    (ร BREAK)
                )

                ((ร CASE) OCTAL)
                ((ร CASE) (+ OCTAL ADD_NL))
                (do
                    ((ร testval =) ((ร mask =) RI_OCTAL))
                    (ร BREAK)
                )

                ((ร CASE) NOCTAL)
                ((ร CASE) (+ NOCTAL ADD_NL))
                (do
                    ((ร mask =) RI_OCTAL)
                    (ร BREAK)
                )

                ((ร CASE) WORD)
                ((ร CASE) (+ WORD ADD_NL))
                (do
                    ((ร testval =) ((ร mask =) RI_WORD))
                    (ร BREAK)
                )

                ((ร CASE) NWORD)
                ((ร CASE) (+ NWORD ADD_NL))
                (do
                    ((ร mask =) RI_WORD)
                    (ร BREAK)
                )

                ((ร CASE) HEAD)
                ((ร CASE) (+ HEAD ADD_NL))
                (do
                    ((ร testval =) ((ร mask =) RI_HEAD))
                    (ร BREAK)
                )

                ((ร CASE) NHEAD)
                ((ร CASE) (+ NHEAD ADD_NL))
                (do
                    ((ร mask =) RI_HEAD)
                    (ร BREAK)
                )

                ((ร CASE) ALPHA)
                ((ร CASE) (+ ALPHA ADD_NL))
                (do
                    ((ร testval =) ((ร mask =) RI_ALPHA))
                    (ร BREAK)
                )

                ((ร CASE) NALPHA)
                ((ร CASE) (+ NALPHA ADD_NL))
                (do
                    ((ร mask =) RI_ALPHA)
                    (ร BREAK)
                )

                ((ร CASE) LOWER)
                ((ร CASE) (+ LOWER ADD_NL))
                (do
                    ((ร testval =) ((ร mask =) RI_LOWER))
                    (ร BREAK)
                )

                ((ร CASE) NLOWER)
                ((ร CASE) (+ NLOWER ADD_NL))
                (do
                    ((ร mask =) RI_LOWER)
                    (ร BREAK)
                )

                ((ร CASE) UPPER)
                ((ร CASE) (+ UPPER ADD_NL))
                (do
                    ((ร testval =) ((ร mask =) RI_UPPER))
                    (ร BREAK)
                )

                ((ร CASE) NUPPER)
                ((ร CASE) (+ NUPPER ADD_NL))
                (do
                    ((ร mask =) RI_UPPER)
                    (ร BREAK)
                )

                ((ร CASE) EXACTLY)
                (do
                    ;; This doesn't do a multi-byte character, because a MULTIBYTECODE would have
                    ;; been used for it.  It does handle single-byte characters, such as latin1.
                    (cond @ireg_ic
                    (do
                        ((ร int cu =) (utf-toupper (.at opnd 0)))
                        ((ร int cl =) (utf-tolower (.at opnd 0)))
                        (while (and (< count maxcount) (or (== (.at scan 0) cu) (== (.at scan 0) cl)))
                            (ร count++)
                            ((ร scan =) (.plus scan 1))
                        )
                    )
                    :else
                    (do
                        ((ร int cu =) (.at opnd 0))
                        (while (and (< count maxcount) (== (.at scan 0) cu))
                            (ร count++)
                            ((ร scan =) (.plus scan 1))
                        )
                    ))
                    (ร BREAK do_class)
                )

                ((ร CASE) MULTIBYTECODE)
                (do
                    ;; Safety check (just in case 'encoding' was changed since compiling the program).
                    ((ร int len =) (us-ptr2len-cc opnd))
                    (when (< 1 len)
                        ((ร int cf =) 0)
                        (if @ireg_ic
                            ((ร cf =) (utf-fold (us-ptr2char opnd)))
                        )
                        (while (< count maxcount)
                            (ร int i)
                            ((ร FOR) (ร ((ร i =) 0) (< i len) (ร i++))
                                (if (!= (.at opnd i) (.at scan i))
                                    (ร BREAK)
                                )
                            )
                            (if (and (< i len) (or (not @ireg_ic) (!= (utf-fold (us-ptr2char scan)) cf)))
                                (ร BREAK)
                            )
                            ((ร scan =) (.plus scan len))
                            (ร count++)
                        )
                    )
                    (ร BREAK do_class)
                )

                ((ร CASE) ANYOF)
                ((ร CASE) (+ ANYOF ADD_NL))
                (do
                    ((ร testval =) TRUE)
                    (ร FALLTHROUGH)
                )
                ((ร CASE) ANYBUT)
                ((ร CASE) (+ ANYBUT ADD_NL))
                (do
                    (while (< count maxcount)
                        (ร int len)
                        (cond (eos? scan)
                        (do
                            (if (or (non-nil? @reg_match) (not (with-nl (re-op p))) (< @reg_maxline @reglnum) @reg_line_lbr)
                                (ร BREAK)
                            )
                            (reg-nextline)
                            ((ร scan =) @reginput)
                            (if @got_int
                                (ร BREAK)
                            )
                        )
                        (and @reg_line_lbr (== (.at scan 0) (byte \newline)) (with-nl (re-op p)))
                        (do
                            ((ร scan =) (.plus scan 1))
                        )
                        (< 1 ((ร len =) (us-ptr2len-cc scan)))
                        (do
                            (if (== (nil? (cstrchr opnd, (us-ptr2char scan))) (non-zero? testval))
                                (ร BREAK)
                            )
                            ((ร scan =) (.plus scan len))
                        )
                        :else
                        (do
                            (if (== (nil? (cstrchr opnd, (.at scan 0))) (non-zero? testval))
                                (ร BREAK)
                            )
                            ((ร scan =) (.plus scan 1))
                        ))
                        (ร count++)
                    )
                    (ร BREAK do_class)
                )

                ((ร CASE) NEWL)
                (do
                    (while (and (< count maxcount) (or (and (eos? scan) (<= @reglnum @reg_maxline) (not @reg_line_lbr) (nil? @reg_match)) (and (== (.at scan 0) (byte \newline)) @reg_line_lbr)))
                        (ร count++)
                        (if @reg_line_lbr
                            (reset! reginput (.plus @reginput (us-ptr2len-cc @reginput)))
                            (reg-nextline))
                        ((ร scan =) @reginput)
                        (if @got_int
                            (ร BREAK)
                        )
                    )
                    (ร BREAK do_class)
                )

                (ร DEFAULT)                ;; Oh dear.  Called inappropriately.
                (do
                    (emsg e_re_corr)
                    (ร BREAK do_class)
                )
            )

            (while (< count maxcount)
                (ร int l)
                (cond (eos? scan)
                (do
                    (if (or (non-nil? @reg_match) (not (with-nl (re-op p))) (< @reg_maxline @reglnum) @reg_line_lbr)
                        (ร BREAK)
                    )
                    (reg-nextline)
                    ((ร scan =) @reginput)
                    (if @got_int
                        (ร BREAK)
                    )
                )
                (< 1 ((ร l =) (us-ptr2len-cc scan)))
                (do
                    (if (non-zero? testval)
                        (ร BREAK)
                    )
                    ((ร scan =) (.plus scan l))
                )
                (== (& (... @class_tab (char_u (.at scan 0))) mask) testval)
                (do
                    ((ร scan =) (.plus scan 1))
                )
                (and @reg_line_lbr (== (.at scan 0) (byte \newline)) (with-nl (re-op p)))
                (do
                    ((ร scan =) (.plus scan 1))
                )
                :else
                (do
                    (ร BREAK)
                ))
                (ร count++)
            )
;       }

        (reset! reginput scan)

        (int count)
    ))

;; Dig the "next" pointer out of a node.
;; Returns null when calculating size, when there is no next item and when there is an error.

(defn- #_Bytes regnext [#_Bytes p]
    (if (or (== p JUST_CALC_SIZE) @reg_toolong)
        nil
        (let [#_int offset (re-next p)]
            (if (zero? offset) nil (if (== (re-op p) BACK) (.minus p offset) (.plus p offset))))
    ))

;; Check the regexp program for its magic number.
;; Return true if it's wrong.

(defn- #_boolean prog-magic-wrong []
    (ยง
        ((ร regprog_C prog =) (if (nil? @reg_match) (:regprog @reg_mmatch) (:regprog @reg_match)))
        (when (== (:engine prog) nfa_regengine)
            ;; For NFA matcher we don't check the magic.
            ((ร RETURN) false)
        )

        (when (!= (.at (:program (ร (bt_regprog_C)prog)) 0) REGMAGIC)
            (emsg e_re_corr)
            ((ร RETURN) true)
        )

        false
    ))

;; Cleanup the subexpressions, if this wasn't done yet.
;; This construction is used to clear the subexpressions
;; only when they are used (to increase speed).

(defn- #_void cleanup-subexpr []
    (ยง
        (when @need_clear_subexpr
            (cond (nil? @reg_match)
            (do
                (dotimes [#_int i NSUBEXP]
                    ;; Use 0xff to set lnum to -1.
                    (MIN1-lpos (... @reg_startpos i))
                    (MIN1-lpos (... @reg_endpos i))
                )
            )
            :else
            (do
                (dotimes [#_int i NSUBEXP]
                    ((ร @reg_startp[i] =) nil)
                    ((ร @reg_endp[i] =) nil)
                )
            ))
            (reset! need_clear_subexpr false)
        )
        nil
    ))

(defn- #_void cleanup-zsubexpr []
    (ยง
        (when @need_clear_zsubexpr
            (cond (nil? @reg_match)
            (do
                (dotimes [#_int i NSUBEXP]
                    ;; Use 0xff to set lnum to -1.
                    (MIN1-lpos (... reg_startzpos i))
                    (MIN1-lpos (... reg_endzpos i))
                )
            )
            :else
            (do
                (dotimes [#_int i NSUBEXP]
                    ((ร reg_startzp[i] =) nil)
                    ((ร reg_endzp[i] =) nil)
                )
            ))
            (reset! need_clear_zsubexpr false)
        )
        nil
    ))

;; Save the current subexpr to "bp", so that they can be restored later by restore-subexpr().

(defn- #_void save-subexpr [#_regbehind_C bp]
    (ยง
        ;; When "need_clear_subexpr" is set we don't need to save the values,
        ;; only remember that this flag needs to be set again when restoring.
        ((ร bp.save_need_clear_subexpr =) @need_clear_subexpr)
        (when (not @need_clear_subexpr)
            (dotimes [#_int i NSUBEXP]
                (cond (nil? @reg_match)
                (do
                    (COPY-lpos (:se_pos (... (:save_start bp) i)), (... @reg_startpos i))
                    (COPY-lpos (:se_pos (... (:save_end bp) i)), (... @reg_endpos i))
                )
                :else
                (do
                    ((ร bp.save_start[i].se_ptr =) (... @reg_startp i))
                    ((ร bp.save_end[i].se_ptr =) (... @reg_endp i))
                ))
            )
        )
        nil
    ))

;; Restore the subexpr from "bp".

(defn- #_void restore-subexpr [#_regbehind_C bp]
    (ยง
        ;; Only need to restore saved values when they are not to be cleared.
        (reset! need_clear_subexpr (:save_need_clear_subexpr bp))
        (when (not @need_clear_subexpr)
            (dotimes [#_int i NSUBEXP]
                (cond (nil? @reg_match)
                (do
                    (COPY-lpos (... @reg_startpos i), (:se_pos (... (:save_start bp) i)))
                    (COPY-lpos (... @reg_endpos i), (:se_pos (... (:save_end bp) i)))
                )
                :else
                (do
                    ((ร @reg_startp[i] =) (:se_ptr (... (:save_start bp) i)))
                    ((ร @reg_endp[i] =) (:se_ptr (... (:save_end bp) i)))
                ))
            )
        )
        nil
    ))

;; Advance "reglnum", "regline" and "reginput" to the next line.

(defn- #_void reg-nextline []
    (ยง
        (reset! regline (reg-getline (ร ++@reglnum)))
        (reset! reginput @regline)
        (fast-breakcheck)
        nil
    ))

;; Save the input line and position in a regsave_C.

(defn- #_void reg-save [#_regsave_C save, #_backpos_C* gap]
    (ยง
        (cond (nil? @reg_match)
        (do
            ((ร save.rs_pos.col =) (BDIFF @reginput, @regline))
            ((ร save.rs_pos.lnum =) @reglnum)
        )
        :else
        (do
            ((ร save.rs_ptr =) @reginput)
        ))
        ((ร save.rs_len =) (:ga_len gap))
        nil
    ))

;; Restore the input line and position from a regsave_C.

(defn- #_void reg-restore [#_regsave_C save, #_backpos_C* gap]
    (ยง
        (cond (nil? @reg_match)
        (do
            (when (!= @reglnum (:lnum (:rs_pos save)))
                ;; only call reg-getline() when the line number changed to save a bit of time
                (reset! reglnum (:lnum (:rs_pos save)))
                (reset! regline (reg-getline @reglnum))
            )
            (reset! reginput (.plus @regline (:col (:rs_pos save))))
        )
        :else
        (do
            (reset! reginput (:rs_ptr save))
        ))
        ((ร gap.ga_len =) (:rs_len save))
        nil
    ))

;; Return true if current position is equal to saved position.

(defn- #_boolean reg-save-equal [#_regsave_C save]
    (ยง
        (if (nil? @reg_match)
            ((ร RETURN) (and (== @reglnum (:lnum (:rs_pos save))) (BEQ @reginput, (.plus @regline (:col (:rs_pos save))))))
        )

        (BEQ @reginput, (:rs_ptr save))
    ))

;; Tentatively set the sub-expression start to the current position (after calling regmatch()
;; they will have changed).  Need to save the existing values for when there is no match.
;; Use se_save() to use pointer (save-se-multi()) or position (save-se-one()),
;; depending on REG_MULTI.

(defn- #_void save-se-multi [#_save_se_C savep, #_lpos_C posp]
    (ยง
        (COPY-lpos (:se_pos savep), posp)
        ((ร posp.lnum =) @reglnum)
        ((ร posp.col =) (BDIFF @reginput, @regline))
        nil
    ))

(defn- #_Bytes save-se-one [#_save_se_C savep, #_Bytes pp]
    (ยง
        ((ร savep.se_ptr =) pp)
        ((ร pp =) @reginput)
        pp
    ))

;; Save the sub-expressions before attempting a match.
(defn- #_Bytes save-se [#_save_se_C savep, #_lpos_C posp, #_Bytes pp]
    (ยง
        (if (nil? @reg_match)
            (save-se-multi savep, posp)
            ((ร pp =) (save-se-one savep, pp))
        )

        pp
    ))

;; After a failed match restore the sub-expressions.
(defn- #_Bytes restore-se [#_save_se_C savep, #_lpos_C posp, #_Bytes pp]
    (ยง
        (if (nil? @reg_match)
            (COPY-lpos posp, (:se_pos savep))
            ((ร pp =) (:se_ptr savep))
        )

        pp
    ))

;; Compare a number with the operand of RE_LNUM, RE_COL or RE_VCOL.

(defn- #_boolean re-num-cmp [#_long val, #_Bytes scan]
    (let [#_long n (operand-min scan)]
        (condp == (operand-cmp scan) (byte \>) (> val n) (byte \<) (< val n) (== val n))
    ))

;; Check whether a backreference matches.
;; Returns RA_FAIL, RA_NOMATCH or RA_MATCH.
;; If "bytelen" is not null, it is set to the byte length of the match in the last line.

(defn- #_int match-with-backref [#_long start_lnum, #_int start_col, #_long end_lnum, #_int end_col, #_int* bytelen]
    (ยง
        ((ร long clnum =) start_lnum)
        ((ร int ccol =) start_col)

        (if (non-nil? bytelen)
            ((ร bytelen[0] =) 0)
        )

        (while true
            ;; Since getting one line may invalidate the other, need to make copy.
            ;; Slow!
            (when (BNE @regline, @reg_tofree)
                ((ร int len =) (STRLEN @regline))
                (when (or (nil? @reg_tofree) (<= @reg_tofree_len len))
                    ((ร len =) (+ len 50))                              ;; get some extra
                    (reset! reg_tofree (Bytes. len))
                    (reset! reg_tofree_len len)
                )
                (STRCPY @reg_tofree, @regline)
                (reset! reginput (.plus @reg_tofree (BDIFF @reginput, @regline)))
                (reset! regline @reg_tofree)
            )

            ;; Get the line to compare with.
            ((ร Bytes p =) (reg-getline clnum))
            ((ร int[] len =) (ร new int[1]))
            ((ร len[0] =) (if (== clnum end_lnum) (- end_col ccol) (STRLEN p, ccol)))

            (if (non-zero? (cstrncmp (.plus p ccol), @reginput, len))
                ((ร RETURN) RA_NOMATCH)                          ;; doesn't match
            )
            (if (non-nil? bytelen)
                ((ร bytelen[0] =) (+ (... bytelen 0) (... len 0)))
            )
            (if (== clnum end_lnum)
                (ร BREAK)                                      ;; match and at end!
            )
            (if (<= @reg_maxline @reglnum)
                ((ร RETURN) RA_NOMATCH)                          ;; text too short
            )

            ;; Advance to next line.
            (reg-nextline)
            (if (non-nil? bytelen)
                ((ร bytelen[0] =) 0)
            )
            (ร clnum++)
            ((ร ccol =) 0)
            (if @got_int
                ((ร RETURN) RA_FAIL)
            )
        )

        ;; Found a match!
        ;; Note that regline may now point to a copy of the line, that should not matter.
        RA_MATCH
    ))

;; Used in a place where no * or \+ can follow.

(defn- #_boolean re-mult-next [#_Bytes what]
    (ยง
        (when (== (re-multi-type (peekchr)) MULTI_MULT)
            (emsg2 (u8 "E888: (NFA regexp) cannot repeat %s"), what)
            (reset! rc_did_emsg true)
            ((ร RETURN) false)
        )
        true
    ))

(class! #_final decomp_C
    [
        (field int a) (field int b) (field int c)
    ])

;; 0xfb20 - 0xfb4f
(final decomp_C* decomp_table
    [
        (->decomp_C  0x5e2,     0,     0)   ;; 0xfb20   alt ayin
        (->decomp_C  0x5d0,     0,     0)   ;; 0xfb21   alt alef
        (->decomp_C  0x5d3,     0,     0)   ;; 0xfb22   alt dalet
        (->decomp_C  0x5d4,     0,     0)   ;; 0xfb23   alt he
        (->decomp_C  0x5db,     0,     0)   ;; 0xfb24   alt kaf
        (->decomp_C  0x5dc,     0,     0)   ;; 0xfb25   alt lamed
        (->decomp_C  0x5dd,     0,     0)   ;; 0xfb26   alt mem-sofit
        (->decomp_C  0x5e8,     0,     0)   ;; 0xfb27   alt resh
        (->decomp_C  0x5ea,     0,     0)   ;; 0xfb28   alt tav
        (->decomp_C (int \+),   0,     0)   ;; 0xfb29   alt plus
        (->decomp_C  0x5e9, 0x5c1,     0)   ;; 0xfb2a   shin+shin-dot
        (->decomp_C  0x5e9, 0x5c2,     0)   ;; 0xfb2b   shin+sin-dot
        (->decomp_C  0x5e9, 0x5c1, 0x5bc)   ;; 0xfb2c   shin+shin-dot+dagesh
        (->decomp_C  0x5e9, 0x5c2, 0x5bc)   ;; 0xfb2d   shin+sin-dot+dagesh
        (->decomp_C  0x5d0, 0x5b7,     0)   ;; 0xfb2e   alef+patah
        (->decomp_C  0x5d0, 0x5b8,     0)   ;; 0xfb2f   alef+qamats
        (->decomp_C  0x5d0, 0x5b4,     0)   ;; 0xfb30   alef+hiriq
        (->decomp_C  0x5d1, 0x5bc,     0)   ;; 0xfb31   bet+dagesh
        (->decomp_C  0x5d2, 0x5bc,     0)   ;; 0xfb32   gimel+dagesh
        (->decomp_C  0x5d3, 0x5bc,     0)   ;; 0xfb33   dalet+dagesh
        (->decomp_C  0x5d4, 0x5bc,     0)   ;; 0xfb34   he+dagesh
        (->decomp_C  0x5d5, 0x5bc,     0)   ;; 0xfb35   vav+dagesh
        (->decomp_C  0x5d6, 0x5bc,     0)   ;; 0xfb36   zayin+dagesh
        (->decomp_C 0xfb37,     0,     0)   ;; 0xfb37 - UNUSED
        (->decomp_C  0x5d8, 0x5bc,     0)   ;; 0xfb38   tet+dagesh
        (->decomp_C  0x5d9, 0x5bc,     0)   ;; 0xfb39   yud+dagesh
        (->decomp_C  0x5da, 0x5bc,     0)   ;; 0xfb3a   kaf sofit+dagesh
        (->decomp_C  0x5db, 0x5bc,     0)   ;; 0xfb3b   kaf+dagesh
        (->decomp_C  0x5dc, 0x5bc,     0)   ;; 0xfb3c   lamed+dagesh
        (->decomp_C 0xfb3d,     0,     0)   ;; 0xfb3d - UNUSED
        (->decomp_C  0x5de, 0x5bc,     0)   ;; 0xfb3e   mem+dagesh
        (->decomp_C 0xfb3f,     0,     0)   ;; 0xfb3f - UNUSED
        (->decomp_C  0x5e0, 0x5bc,     0)   ;; 0xfb40   nun+dagesh
        (->decomp_C  0x5e1, 0x5bc,     0)   ;; 0xfb41   samech+dagesh
        (->decomp_C 0xfb42,     0,     0)   ;; 0xfb42 - UNUSED
        (->decomp_C  0x5e3, 0x5bc,     0)   ;; 0xfb43   pe sofit+dagesh
        (->decomp_C  0x5e4, 0x5bc,     0)   ;; 0xfb44   pe+dagesh
        (->decomp_C 0xfb45,     0,     0)   ;; 0xfb45 - UNUSED
        (->decomp_C  0x5e6, 0x5bc,     0)   ;; 0xfb46   tsadi+dagesh
        (->decomp_C  0x5e7, 0x5bc,     0)   ;; 0xfb47   qof+dagesh
        (->decomp_C  0x5e8, 0x5bc,     0)   ;; 0xfb48   resh+dagesh
        (->decomp_C  0x5e9, 0x5bc,     0)   ;; 0xfb49   shin+dagesh
        (->decomp_C  0x5ea, 0x5bc,     0)   ;; 0xfb4a   tav+dagesh
        (->decomp_C  0x5d5, 0x5b9,     0)   ;; 0xfb4b   vav+holam
        (->decomp_C  0x5d1, 0x5bf,     0)   ;; 0xfb4c   bet+rafe
        (->decomp_C  0x5db, 0x5bf,     0)   ;; 0xfb4d   kaf+rafe
        (->decomp_C  0x5e4, 0x5bf,     0)   ;; 0xfb4e   pe+rafe
        (->decomp_C  0x5d0, 0x5dc,     0)   ;; 0xfb4f   alef-lamed
    ])

(defn- #_void mb-decompose [#_int c, #_int* c1, #_int* c2, #_int* c3]
    (ยง
        (cond (<= 0xfb20 c 0xfb4f)
        (do
            ((ร decomp_C d =) (... decomp_table (- c 0xfb20)))
            ((ร c1[0] =) (:a d))
            ((ร c2[0] =) (:b d))
            ((ร c3[0] =) (:c d))
        )
        :else
        (do
            ((ร c1[0] =) c)
            ((ร c2[0] =) (ร c3[0] = 0))
        ))
        nil
    ))

;; Compare two strings, ignore case if ireg_ic set.
;; Return 0 if strings match, non-zero otherwise.
;; Correct the length "*n" when composing characters are ignored.

(defn- #_int cstrncmp [#_Bytes s1, #_Bytes s2, #_int* n]
    (ยง
        ((ร int result =) (if (not @ireg_ic) (STRNCMP s1, s2, (... n 0)) (us-strnicmp s1, s2, (... n 0))))

        ;; if it failed and it's utf8 and we want to combineignore
        (when (and (non-zero? result) @ireg_icombine)
; %%        ((ร Bytes[] str1 =) (ร { s1 }))
; %%        ((ร Bytes[] str2 =) (ร { s2 }))
            ((ร int c1 =) (ร 0, c2 = 0))

            ;; We have to handle the strcmp() ourselves, since it is necessary
            ;; to deal with the composing characters by ignoring them.
            (while (< (BDIFF (... str1 0), s1) (... n 0))
                ((ร c1 =) (us-ptr2char-adv str1, true))
                ((ร c2 =) (us-ptr2char-adv str2, true))

                ;; Decompose the character if necessary into 'base' characters,
                ;; because I don't care about Arabic, I will hard-code the Hebrew
                ;; which I *do* care about!  So sue me...
                (when (and (!= c1 c2) (or (not @ireg_ic) (!= (utf-fold c1) (utf-fold c2))))
                    ((ร int[] c11 =) (ร new int[1]))
                    ((ร int[] c12 =) (ร new int[1]))
                    ((ร int[] junk =) (ร new int[1]))

                    ;; decomposition necessary?
                    (mb-decompose c1, c11, junk, junk)
                    (mb-decompose c2, c12, junk, junk)
                    ((ร c1 =) (... c11 0))
                    ((ร c2 =) (... c12 0))
                    (if (and (!= (... c11 0) (... c12 0)) (or (not @ireg_ic) (!= (utf-fold (... c11 0)) (utf-fold (... c12 0)))))
                        (ร BREAK)
                    )
                )
            )
            ((ร result =) (- c2 c1))
            (if (zero? result)
                ((ร n[0] =) (BDIFF (... str2 0), s2))
            )
        )

        result
    ))

;; This function is used a lot for simple searches, keep it fast!

(defn- #_Bytes cstrchr [#_Bytes s, #_int c]
    (ยง
        (if (not @ireg_ic)
            ((ร RETURN) (vim-strchr s, c))
        )

        (ร int cc)
        (cond (< 0x80 c)
        (do
            ((ร cc =) (utf-fold c))
        )
        (utf-isupper c)
        (do
            ((ร cc =) (utf-tolower c))
        )
        (utf-islower c)
        (do
            ((ร cc =) (utf-toupper c))
        )
        :else
        (do
            ((ร RETURN) (vim-strchr s, c))
        ))

        ((ร FOR) (ร ((ร Bytes p =) s) (non-eos? p) ((ร p =) (.plus p (us-ptr2len-cc p))))
            (cond (< 0x80 c)
            (do
                (if (== (utf-fold (us-ptr2char p)) cc)
                    ((ร RETURN) p)
                )
            )
            (or (== (.at p 0) c) (== (.at p 0) cc))
            (do
                ((ร RETURN) p)
            ))
        )

        nil
    ))

;; regsub stuff

;; We should define ftpr as a pointer to a function returning
;; a pointer to a function returning a pointer to a function ...
;; This is impossible, so we declare a pointer to a function
;; returning a pointer to a function returning void.

(ร
;   static abstract class fptr_C
    (ยง
;       public abstract fptr_C flip(int[] d, int c);
    ))

;   static final fptr_C do_upper = new fptr_C()
;   {
;       public fptr_C flip(int[] d, int c) { d[0] = utf-toupper(c); return null; }
;   };

;   static final fptr_C do_Upper = new fptr_C()
;   {
;       public fptr_C flip(int[] d, int c) { d[0] = utf-toupper(c); return this; }
;   };

;   static final fptr_C do_lower = new fptr_C()
;   {
;       public fptr_C flip(int[] d, int c) { d[0] = utf-tolower(c); return null; }
;   };

;   static final fptr_C do_Lower = new fptr_C()
;   {
;       public fptr_C flip(int[] d, int c) { d[0] = utf-tolower(c); return this; }
;   };

;; regtilde(): Replace tildes in the pattern by the old pattern.
;;
;; Short explanation of the tilde: It stands for the previous replacement pattern.
;; If that previous pattern also contains a ~ we should go back a step further...
;; But we insert the previous pattern into the current one and remember that.
;; This still does not handle the case where "magic" changes.  So require the
;; user to keep his hands off of "magic".
;;
;; The tildes are parsed once before the first call to vim-regsub().

(defn- #_Bytes regtilde [#_Bytes source, #_boolean magic]
    (ยง
        ((ร Bytes newsub =) source)

        ((ร FOR) (ร ((ร Bytes p =) newsub) (non-eos? p) ((ร p =) (.plus p 1)))
            (cond (or (and (== (.at p 0) (byte \~)) magic) (and (== (.at p 0) (byte \\)) (== (.at p 1) (byte \~)) (not magic)))
            (do
                (cond (non-nil? @reg_prev_sub)
                (do
                    ;; length = len(newsub) - 1 + len(prev_sub) + 1
                    ((ร int prevlen =) (STRLEN @reg_prev_sub))
                    ((ร Bytes tmpsub =) (Bytes. (+ (STRLEN newsub) prevlen)))

                    ;; copy prefix
                    ((ร int len =) (BDIFF p, newsub))            ;; not including ~
                    (BCOPY tmpsub, newsub, len)
                    ;; interpret tilde
                    (BCOPY tmpsub, len, @reg_prev_sub, 0, prevlen)
                    ;; copy postfix
                    (if (not magic)
                        ((ร p =) (.plus p 1))                                ;; back off \
                    )
                    (STRCPY (.plus tmpsub (+ len prevlen)), (.plus p 1))

                    ((ร newsub =) tmpsub)
                    ((ร p =) (.plus newsub (+ len prevlen)))
                )
                magic
                (do
                    (BCOPY p, 0, p, 1, (+ (STRLEN p, 1) 1))   ;; remove '~'
                )
                :else
                (do
                    (BCOPY p, 0, p, 2, (+ (STRLEN p, 2) 1))   ;; remove '\~'
                ))
                ((ร p =) (.minus p 1))
            )
            :else
            (do
                (if (and (== (.at p 0) (byte \\)) (non-eos? p 1))        ;; skip escaped characters
                    ((ร p =) (.plus p 1))
                )
                ((ร p =) (.plus p (- (us-ptr2len-cc p) 1)))
            ))
        )

        (if (BNE newsub, source)
            (reset! reg_prev_sub newsub)                    ;; "newsub" was allocated, just keep it
            (reset! reg_prev_sub (STRDUP newsub)))           ;; no ~ found, need to save "newsub"

        newsub
    ))

(atom! boolean can_f_submatch)          ;; true when submatch() can be used

;; These pointers are used instead of reg_match and reg_mmatch for reg_submatch().
;; Needed when the substitution string is an expression
;; that contains a call to substitute() and submatch().

(atom! regmatch_C       submatch_match)
(atom! regmmatch_C      submatch_mmatch)
(atom! long             submatch_firstlnum)
(atom! long             submatch_maxline)
(atom! boolean          submatch_line_lbr)

;; vim-regsub() - perform substitutions after a vim-regexec() or vim-regexec-multi() match.
;;
;; If "copy" is true really copy into "dest".
;; If "copy" is false nothing is copied, this is just to find out the length of the result.
;;
;; If "backslash" is true, a backslash will be removed later, need to double them to keep them,
;; and insert a backslash before a CR to avoid it being replaced with a line break later.
;;
;; Note: The matched text must not change between the call of vim-regexec()/vim-regexec-multi()
;; and vim-regsub()!  It would make the back references invalid!
;;
;; Returns the size of the replacement, including terminating NUL.

(defn- #_int vim-regsub [#_regmatch_C rmp, #_Bytes source, #_Bytes dest, #_boolean copy, #_boolean magic, #_boolean backslash]
    (reset! reg_match rmp)
    (reset! reg_mmatch nil)
    (reset! reg_maxline 0)
    (reset! reg_buf @curbuf)
    (reset! reg_line_lbr true)

    (vim-regsub-both source, dest, copy, magic, backslash))

(defn- #_int vim-regsub-multi [#_regmmatch_C rmp, #_long lnum, #_Bytes source, #_Bytes dest, #_boolean copy, #_boolean magic, #_boolean backslash]
    (reset! reg_match nil)
    (reset! reg_mmatch rmp)
    (reset! reg_buf @curbuf)           ;; always works on the current buffer!
    (reset! reg_firstlnum lnum)
    (reset! reg_maxline (- (:ml_line_count (:b_ml @curbuf)) lnum))
    (reset! reg_line_lbr false)

    (vim-regsub-both source, dest, copy, magic, backslash))

(atom! Bytes eval_result)

(defn- #_int vim-regsub-both [#_Bytes source, #_Bytes dest, #_boolean copy, #_boolean magic, #_boolean backslash]
    (ยง
        ;; Be paranoid...
        (when (or (nil? source) (nil? dest))
            (emsg e_null)
            ((ร RETURN) 0)
        )
        (if (prog-magic-wrong)
            ((ร RETURN) 0)
        )

        ((ร Bytes dst =) dest)

        ;; When the substitute part starts with "\=" evaluate it as an expression.

        (cond (and (== (.at source 0) (byte \\)) (== (.at source 1) (byte \=)) (not @can_f_submatch))   ;; can't do this recursively
        (do
            ;; To make sure that the length doesn't change between checking the length
            ;; and copying the string, and to speed up things, the resulting string is saved
            ;; from the call with "copy" == false to the call with "copy" == true.
            (cond copy
            (do
                (when (non-nil? @eval_result)
                    (STRCPY dest, @eval_result)
                    ((ร dst =) (.plus dst (STRLEN @eval_result)))
                    (reset! eval_result nil)
                )
            )
            :else
            (do
                ;; The expression may contain substitute(), which calls us recursively.
                ;; Make sure submatch() gets the text from the first level.
                ;; Don't need to save "reg_buf", because vim-regexec-multi() can't be called recursively.

                (reset! submatch_match @reg_match)
                (reset! submatch_mmatch @reg_mmatch)
                (reset! submatch_firstlnum @reg_firstlnum)
                (reset! submatch_maxline @reg_maxline)
                (reset! submatch_line_lbr @reg_line_lbr)

                ((ร window_C save_reg_win =) @reg_win)
                ((ร boolean save_ireg_ic =) @ireg_ic)
                (reset! can_f_submatch true)

                (reset! eval_result (eval-to-string (.plus source 2), nil))
                (when (non-nil? @eval_result)
                    ((ร boolean had_backslash =) false)

                    ((ร FOR) (ร ((ร Bytes s =) @eval_result) (non-eos? s) ((ร s =) (.plus s (us-ptr2len-cc s))))
                        ;; Change NL to CR, so that it becomes a line break,
                        ;; unless called from vim-regexec-nl().
                        ;; Skip over a backslashed character.
                        (cond (and (== (.at s 0) NL) (not @submatch_line_lbr))
                        (do
                            (.be s 0, CAR)
                        )
                        (and (== (.at s 0) (byte \\)) (non-eos? s 1))
                        (do
                            ((ร s =) (.plus s 1))
                            ;; Change NL to CR here too, so that this works:
                            ;; :s/abc\\\ndef/\="aaa\\\nbbb"/  on text:
                            ;;   abc\
                            ;;   def
                            ;; Not when called from vim-regexec-nl().

                            (if (and (== (.at s 0) NL) (not @submatch_line_lbr))
                                (.be s 0, CAR)
                            )
                            ((ร had_backslash =) true)
                        ))
                    )
                    (when (and had_backslash backslash)
                        ;; Backslashes will be consumed, need to double them.
                        (reset! eval_result (vim-strsave-escaped @eval_result, (u8 "\\")))
                    )

                    ((ร dst =) (.plus dst (STRLEN @eval_result)))
                )

                (reset! reg_match @submatch_match)
                (reset! reg_mmatch @submatch_mmatch)
                (reset! reg_firstlnum @submatch_firstlnum)
                (reset! reg_maxline @submatch_maxline)
                (reset! reg_line_lbr @submatch_line_lbr)
                (reset! reg_win save_reg_win)
                (reset! ireg_ic save_ireg_ic)
                (reset! can_f_submatch false)
            ))
        )
        :else
        (do
            ((ร fptr_C func_one =) nil)
            ((ร fptr_C func_all =) nil)

            ((ร int no =) -1)
            ((ร long clnum =) 0)
            ((ร int len =) 0)

            ((ร Bytes src =) source)

            ((ร FOR) (ร (byte b) (!= ((ร b =) (.at ((ร src =) (.plus src 1)) -1)) NUL) nil)
                (cond (and (== b (byte \&)) magic)
                (do
                    ((ร no =) 0)
                )
                (and (== b (byte \\)) (non-eos? src))
                (do
                    (cond (and (== (.at src 0) (byte \&)) (not magic))
                    (do
                        ((ร src =) (.plus src 1))
                        ((ร no =) 0)
                    )
                    (and (<= (byte \0) (.at src 0)) (<= (.at src 0) (byte \9)))
                    (do
                        ((ร no =) (- (.at ((ร src =) (.plus src 1)) -1) (byte \0)))
                    )
                    (non-nil? (vim-strbyte (u8 "uUlLeE"), (.at src 0)))
                    (do
                        ((ร SWITCH) (.at ((ร src =) (.plus src 1)) -1)
                            ((ร CASE) (byte \u))
                            (do
                                ((ร func_one =) do_upper)
                                (ร CONTINUE)
                            )
                            ((ร CASE) (byte \U))
                            (do
                                ((ร func_all =) do_Upper)
                                (ร CONTINUE)
                            )
                            ((ร CASE) (byte \l))
                            (do
                                ((ร func_one =) do_lower)
                                (ร CONTINUE)
                            )
                            ((ร CASE) (byte \L))
                            (do
                                ((ร func_all =) do_Lower)
                                (ร CONTINUE)
                            )
                            ((ร CASE) (byte \e))
                            ((ร CASE) (byte \E))
                            (do
                                ((ร func_one =) nil)
                                ((ร func_all =) nil)
                                (ร CONTINUE)
                            )
                        )
                    ))
                ))
                (cond (< no 0)             ;; Ordinary character.
                (do
                    (when (and (== b KB_SPECIAL) (non-eos? src) (non-eos? src 1))
                        ;; Copy a special key as-is.
                        (cond copy
                        (do
                            (.be ((ร dst =) (.plus dst 1)) -1, b)
                            (.be ((ร dst =) (.plus dst 1)) -1, (.at ((ร src =) (.plus src 1)) -1))
                            (.be ((ร dst =) (.plus dst 1)) -1, (.at ((ร src =) (.plus src 1)) -1))
                        )
                        :else
                        (do
                            ((ร dst =) (.plus dst 3))
                            ((ร src =) (.plus src 2))
                        ))
                        (ร CONTINUE)
                    )

                    (ร int c)
                    (cond (and (== b (byte \\)) (non-eos? src))
                    (do
                        ;; Check for abbreviations.
                        ((ร SWITCH) (.at src 0)
                            ((ร CASE) (byte \r))
                            (do
                                ((ร b =) CAR)
                                ((ร src =) (.plus src 1))
                                (ร BREAK)
                            )
                            ((ร CASE) (byte \n))
                            (do
                                ((ร b =) NL)
                                ((ร src =) (.plus src 1))
                                (ร BREAK)
                            )
                            ((ร CASE) (byte \t))
                            (do
                                ((ร b =) TAB)
                                ((ร src =) (.plus src 1))
                                (ร BREAK)
                            )
                         ;; case (byte \e):     ;; Oh no!  \e already has meaning in subst pat.
                         ;; {
                         ;;     b = ESC;
                         ;;     src = src.plus(1);
                         ;;     break;
                         ;; }
                            ((ร CASE) (byte \b))
                            (do
                                ((ร b =) Ctrl_H)
                                ((ร src =) (.plus src 1))
                                (ร BREAK)
                            )

                            ;; If "backslash" is true the backslash will be removed later.
                            ;; Used to insert a literal CR.
                            (ร DEFAULT)
                            (do
                                (when backslash
                                    (if copy
                                        (.be dst 0, (byte \\))
                                    )
                                    ((ร dst =) (.plus dst 1))
                                )
                                ((ร b =) (.at ((ร src =) (.plus src 1)) -1))
                                (ร BREAK)
                            )
                        )
                        ((ร c =) (char_u b))
                    )
                    :else
                    (do
                        ((ร c =) (us-ptr2char (.minus src 1)))
                    ))

                    ;; Write to buffer, if copy is set.
                    ((ร int[] cc =) (ร new int[1]))
                    (cond (non-nil? func_one)
                    (do
                        ((ร func_one =) (.flip func_one cc, c))
                    )
                    (non-nil? func_all)
                    (do
                        ((ร func_all =) (.flip func_all cc, c))
                    )
                    :else ;; just copy
                    (do
                        ((ร cc[0] =) c)
                    ))

                    ((ร int totlen =) (us-ptr2len-cc (.minus src 1)))

                    (if copy
                        (utf-char2bytes (... cc 0), dst))
                    ((ร dst =) (.plus dst (- (utf-char2len (... cc 0)) 1)))

                    ((ร int clen =) (us-ptr2len (.minus src 1)))

                    ;; If the character length is shorter than "totlen",
                    ;; there are composing characters; copy them as-is.
                    (when (< clen totlen)
                        (if copy
                            (BCOPY dst, 1, src, (+ -1 clen), (- totlen clen)))
                        ((ร dst =) (.plus dst (- totlen clen)))
                    )

                    ((ร src =) (.plus src (dec totlen)))

                    ((ร dst =) (.plus dst 1))
                )
                :else
                (do
                    (ร Bytes s)
                    (cond (nil? @reg_match)
                    (do
                        ((ร clnum =) (:lnum (... (:startpos @reg_mmatch) no)))
                        (cond (or (< clnum 0) (< (:lnum (... (:endpos @reg_mmatch) no)) 0))
                        (do
                            ((ร s =) nil)
                        )
                        :else
                        (do
                            ((ร s =) (.plus (reg-getline clnum) (:col (... (:startpos @reg_mmatch) no))))
                            ((ร len =) (if (== (:lnum (... (:endpos @reg_mmatch) no)) clnum)
                                (- (:col (... (:endpos @reg_mmatch) no)) (:col (... (:startpos @reg_mmatch) no)))
                                (STRLEN s)
                            ))
                        ))
                    )
                    :else
                    (do
                        ((ร s =) (... (:startp @reg_match) no))
                        (if (nil? (... (:endp @reg_match) no))
                            ((ร s =) nil)
                            ((ร len =) (BDIFF (... (:endp @reg_match) no), s))
                        )
                    ))
                    (when (non-nil? s)
                        (while true
                            (cond (zero? len)
                            (do
                                (cond (nil? @reg_match)
                                (do
                                    (if (== (:lnum (... (:endpos @reg_mmatch) no)) clnum)
                                        (ร BREAK)
                                    )
                                    (if copy
                                        (.be dst 0, CAR)
                                    )
                                    ((ร dst =) (.plus dst 1))
                                    ((ร s =) (reg-getline (ร ++clnum)))
                                    ((ร len =) (if (== (:lnum (... (:endpos @reg_mmatch) no)) clnum)
                                        (:col (... (:endpos @reg_mmatch) no))
                                        (STRLEN s)
                                    ))
                                )
                                :else
                                (do
                                    (ร BREAK)
                                ))
                            )
                            (eos? s)
                            (do
                                (if copy
                                    (emsg e_re_damg))
                                ((ร RETURN) (+ (BDIFF dst, dest) 1))
                            )
                            :else
                            (do
                                (cond (and backslash (or (== (.at s 0) CAR) (== (.at s 0) (byte \\))))
                                (do
                                    ;; Insert a backslash in front of a CR,
                                    ;; otherwise it will be replaced by a line break.
                                    ;; Number of backslashes will be halved later, double them here.

                                    (when copy
                                        (.be dst 0, (byte \\))
                                        (.be dst 1, (.at s 0))
                                    )
                                    ((ร dst =) (.plus dst 2))
                                )
                                :else
                                (do
                                    ((ร int c =) (us-ptr2char s))

                                    ((ร int[] cc =) (ร new int[1]))
                                    (cond (non-nil? func_one)
                                    (do
                                        ((ร func_one =) (.flip func_one cc, c))
                                    )
                                    (non-nil? func_all)
                                    (do
                                        ((ร func_all =) (.flip func_all cc, c))
                                    )
                                    :else ;; just copy
                                    (do
                                        ((ร cc[0] =) c)
                                    ))

                                    ;; Copy composing characters separately, one at a time.
                                    ((ร int l =) (- (us-ptr2len s) 1))

                                    ((ร s =) (.plus s l))
                                    ((ร len =) (- len l))
                                    (if copy
                                        (utf-char2bytes (... cc 0), dst))
                                    ((ร dst =) (.plus dst (- (utf-char2len (... cc 0)) 1)))

                                    ((ร dst =) (.plus dst 1))
                                ))

                                ((ร s =) (.plus s 1))
                                (ร --len)
                            ))
                        )
                    )
                    ((ร no =) -1)
                ))
            )
        ))

        (if copy
            (eos! dst)
        )

        (+ (BDIFF dst, dest) 1)
    ))

;;; ============================================================================================== VimO

;; NFA regular expression implementation.

;; Added to NFA_ANY - NFA_NUPPER_IC to include a NL.
(final int NFA_ADD_NL 31)

(final int
    NFA_SPLIT -1024,
    NFA_MATCH -1023,
    NFA_EMPTY -1022,                      ;; matches 0-length

    NFA_START_COLL -1021,                 ;; [abc] start
    NFA_END_COLL -1020,                   ;; [abc] end
    NFA_START_NEG_COLL -1019,             ;; [^abc] start
    NFA_END_NEG_COLL -1018,               ;; [^abc] end (postfix only)
    NFA_RANGE -1017,                      ;; range of the two previous items (postfix only)
    NFA_RANGE_MIN -1016,                  ;; low end of a range
    NFA_RANGE_MAX -1015,                  ;; high end of a range

    NFA_CONCAT -1014,                     ;; concatenate two previous items (postfix only)
    NFA_OR -1013,                         ;; \| (postfix only)
    NFA_STAR -1012,                       ;; greedy * (posfix only)
    NFA_STAR_NONGREEDY -1011,             ;; non-greedy * (postfix only)
    NFA_QUEST -1010,                      ;; greedy \? (postfix only)
    NFA_QUEST_NONGREEDY -1009,            ;; non-greedy \? (postfix only)

    NFA_BOL -1008,                        ;; ^    Begin line
    NFA_EOL -1007,                        ;; $    End line
    NFA_BOW -1006,                        ;; \<   Begin word
    NFA_EOW -1005,                        ;; \>   End word
    NFA_BOF -1004,                        ;; \%^  Begin file
    NFA_EOF -1003,                        ;; \%$  End file
    NFA_NEWL -1002,
    NFA_ZSTART -1001,                     ;; Used for \zs
    NFA_ZEND -1000,                       ;; Used for \ze
    NFA_NOPEN -999,                       ;; Start of subexpression marked with \%(
    NFA_NCLOSE -998,                      ;; End of subexpr. marked with \%( ... \)
    NFA_START_INVISIBLE -997,
    NFA_START_INVISIBLE_FIRST -996,
    NFA_START_INVISIBLE_NEG -995,
    NFA_START_INVISIBLE_NEG_FIRST -994,
    NFA_START_INVISIBLE_BEFORE -993,
    NFA_START_INVISIBLE_BEFORE_FIRST -992,
    NFA_START_INVISIBLE_BEFORE_NEG -991,
    NFA_START_INVISIBLE_BEFORE_NEG_FIRST -990,
    NFA_START_PATTERN -989,
    NFA_END_INVISIBLE -988,
    NFA_END_INVISIBLE_NEG -987,
    NFA_END_PATTERN -986,
    NFA_COMPOSING -985,                   ;; Next nodes in NFA are part of the composing multibyte char
    NFA_END_COMPOSING -984,               ;; End of a composing char in the NFA
    NFA_ANY_COMPOSING -983,               ;; \%C: Any composing characters.
    NFA_OPT_CHARS -982,                   ;; \%[abc]

    ;; The following are used only in the postfix form, not in the NFA.
    NFA_PREV_ATOM_NO_WIDTH -981,          ;; Used for \@=
    NFA_PREV_ATOM_NO_WIDTH_NEG -980,      ;; Used for \@!
    NFA_PREV_ATOM_JUST_BEFORE -979,       ;; Used for \@<=
    NFA_PREV_ATOM_JUST_BEFORE_NEG -978,   ;; Used for \@<!
    NFA_PREV_ATOM_LIKE_PATTERN -977,      ;; Used for \@>

    NFA_BACKREF1 -976,                    ;; \1
    NFA_BACKREF2 -975,                    ;; \2
    NFA_BACKREF3 -974,                    ;; \3
    NFA_BACKREF4 -973,                    ;; \4
    NFA_BACKREF5 -972,                    ;; \5
    NFA_BACKREF6 -971,                    ;; \6
    NFA_BACKREF7 -970,                    ;; \7
    NFA_BACKREF8 -969,                    ;; \8
    NFA_BACKREF9 -968,                    ;; \9
    NFA_ZREF1 -967,                       ;; \z1
    NFA_ZREF2 -966,                       ;; \z2
    NFA_ZREF3 -965,                       ;; \z3
    NFA_ZREF4 -964,                       ;; \z4
    NFA_ZREF5 -963,                       ;; \z5
    NFA_ZREF6 -962,                       ;; \z6
    NFA_ZREF7 -961,                       ;; \z7
    NFA_ZREF8 -960,                       ;; \z8
    NFA_ZREF9 -959,                       ;; \z9
    NFA_SKIP -958,                        ;; Skip characters

    NFA_MOPEN -957,
    NFA_MOPEN1 -956,
    NFA_MOPEN2 -955,
    NFA_MOPEN3 -954,
    NFA_MOPEN4 -953,
    NFA_MOPEN5 -952,
    NFA_MOPEN6 -951,
    NFA_MOPEN7 -950,
    NFA_MOPEN8 -949,
    NFA_MOPEN9 -948,

    NFA_MCLOSE -947,
    NFA_MCLOSE1 -946,
    NFA_MCLOSE2 -945,
    NFA_MCLOSE3 -944,
    NFA_MCLOSE4 -943,
    NFA_MCLOSE5 -942,
    NFA_MCLOSE6 -941,
    NFA_MCLOSE7 -940,
    NFA_MCLOSE8 -939,
    NFA_MCLOSE9 -938,

    NFA_ZOPEN -937,
    NFA_ZOPEN1 -936,
    NFA_ZOPEN2 -935,
    NFA_ZOPEN3 -934,
    NFA_ZOPEN4 -933,
    NFA_ZOPEN5 -932,
    NFA_ZOPEN6 -931,
    NFA_ZOPEN7 -930,
    NFA_ZOPEN8 -929,
    NFA_ZOPEN9 -928,

    NFA_ZCLOSE -927,
    NFA_ZCLOSE1 -926,
    NFA_ZCLOSE2 -925,
    NFA_ZCLOSE3 -924,
    NFA_ZCLOSE4 -923,
    NFA_ZCLOSE5 -922,
    NFA_ZCLOSE6 -921,
    NFA_ZCLOSE7 -920,
    NFA_ZCLOSE8 -919,
    NFA_ZCLOSE9 -918,

    ;; NFA_FIRST_NL
    NFA_ANY -917,                        ;; Match any one character.
    NFA_IDENT -916,                      ;; Match identifier char
    NFA_SIDENT -915,                     ;; Match identifier char but no digit
    NFA_KWORD -914,                      ;; Match keyword char
    NFA_SKWORD -913,                     ;; Match word char but no digit
    NFA_FNAME -912,                      ;; Match file name char
    NFA_SFNAME -911,                     ;; Match file name char but no digit
    NFA_PRINT -910,                      ;; Match printable char
    NFA_SPRINT -909,                     ;; Match printable char but no digit
    NFA_WHITE -908,                      ;; Match whitespace char
    NFA_NWHITE -907,                     ;; Match non-whitespace char
    NFA_DIGIT -906,                      ;; Match digit char
    NFA_NDIGIT -905,                     ;; Match non-digit char
    NFA_HEX -904,                        ;; Match hex char
    NFA_NHEX -903,                       ;; Match non-hex char
    NFA_OCTAL -902,                      ;; Match octal char
    NFA_NOCTAL -901,                     ;; Match non-octal char
    NFA_WORD -900,                       ;; Match word char
    NFA_NWORD -899,                      ;; Match non-word char
    NFA_HEAD -898,                       ;; Match head char
    NFA_NHEAD -897,                      ;; Match non-head char
    NFA_ALPHA -896,                      ;; Match alpha char
    NFA_NALPHA -895,                     ;; Match non-alpha char
    NFA_LOWER -894,                      ;; Match lowercase char
    NFA_NLOWER -893,                     ;; Match non-lowercase char
    NFA_UPPER -892,                      ;; Match uppercase char
    NFA_NUPPER -891,                     ;; Match non-uppercase char
    NFA_LOWER_IC -890,                   ;; Match [a-z]
    NFA_NLOWER_IC -889,                  ;; Match [^a-z]
    NFA_UPPER_IC -888,                   ;; Match [A-Z]
    NFA_NUPPER_IC -887,                  ;; Match [^A-Z]

    NFA_FIRST_NL (+ NFA_ANY NFA_ADD_NL),
    NFA_LAST_NL (+ NFA_NUPPER_IC NFA_ADD_NL),

    NFA_CURSOR -855,                     ;; Match cursor pos
    NFA_LNUM -854,                       ;; Match line number
    NFA_LNUM_GT -853,                    ;; Match > line number
    NFA_LNUM_LT -852,                    ;; Match < line number
    NFA_COL -851,                        ;; Match cursor column
    NFA_COL_GT -850,                     ;; Match > cursor column
    NFA_COL_LT -849,                     ;; Match < cursor column
    NFA_VCOL -848,                       ;; Match cursor virtual column
    NFA_VCOL_GT -847,                    ;; Match > cursor virtual column
    NFA_VCOL_LT -846,                    ;; Match < cursor virtual column
    NFA_MARK -845,                       ;; Match mark
    NFA_MARK_GT -844,                    ;; Match > mark
    NFA_MARK_LT -843,                    ;; Match < mark
    NFA_VISUAL -842,                     ;; Match Visual area

    ;; Character classes [:alnum:] etc.
    NFA_CLASS_ALNUM -841,
    NFA_CLASS_ALPHA -840,
    NFA_CLASS_BLANK -839,
    NFA_CLASS_CNTRL -838,
    NFA_CLASS_DIGIT -837,
    NFA_CLASS_GRAPH -836,
    NFA_CLASS_LOWER -835,
    NFA_CLASS_PRINT -834,
    NFA_CLASS_PUNCT -833,
    NFA_CLASS_SPACE -832,
    NFA_CLASS_UPPER -831,
    NFA_CLASS_XDIGIT -830,
    NFA_CLASS_TAB -829,
    NFA_CLASS_RETURN -828,
    NFA_CLASS_BACKSPACE -827,
    NFA_CLASS_ESCAPE -826)

;; Keep in sync with "classchars".
(final int* nfa_classcodes
    [
        NFA_ANY, NFA_IDENT, NFA_SIDENT, NFA_KWORD, NFA_SKWORD,
        NFA_FNAME, NFA_SFNAME, NFA_PRINT, NFA_SPRINT,
        NFA_WHITE, NFA_NWHITE, NFA_DIGIT, NFA_NDIGIT,
        NFA_HEX, NFA_NHEX, NFA_OCTAL, NFA_NOCTAL,
        NFA_WORD, NFA_NWORD, NFA_HEAD, NFA_NHEAD,
        NFA_ALPHA, NFA_NALPHA, NFA_LOWER, NFA_NLOWER,
        NFA_UPPER, NFA_NUPPER
    ])

(final Bytes e_nul_found       (u8 "E865: (NFA) Regexp end encountered prematurely"))
(final Bytes e_misplaced       (u8 "E866: (NFA regexp) Misplaced %c"))
(final Bytes e_ill_char_class  (u8 "E877: (NFA regexp) Invalid character class: %ld"))

;; re_flags passed to nfa-regcomp()
(atom! int nfa_re_flags)

;; NFA regexp \ze operator encountered.
(atom! boolean nfa_has_zend)

;; NFA regexp \1 .. \9 encountered.
(atom! boolean nfa_has_backref)

;; NFA regexp has \z( ), set zsubexpr.
(atom! boolean nfa_has_zsubexpr)

;; Number of sub expressions actually being used during execution.
;; 1 if only the whole match (subexpr 0) is used.

(atom! int nfa_nsubexpr)

(atom! int* post_array)    ;; holds the postfix form of r.e.
(atom! int post_index)

;; If not null match must end at this position.
(atom! save_se_C nfa_endp)

;; 'listid' is global, so that it increases on recursive calls to nfa-regmatch(),
;; which means we don't have to clear the lastlist field of all the states.

(atom! int nfa_listid)
(atom! int nfa_alt_listid)

;; 0 for first call to nfa-regmatch(), 1 for recursive call.
(atom! int nfa_ll_index)

;; Initialize internal variables before NFA compilation.
;; Return true on success, false otherwise.

(defn- #_void nfa-regcomp-start [#_Bytes expr, #_int re_flags]
    ;; re_flags: see vim-regcomp()
    (ยง
        ;; A reasonable estimation for maximum size.
        ((ร int nstate_max =) (* (+ (STRLEN expr) 1) 25))

        ;; Some items blow up in size, such as [A-z].  Add more space for that.
        ;; When it is still not enough grow-post-array() will be used.
        ((ร nstate_max =) (+ nstate_max 1000))

        (reset! post_array (ร new int[nstate_max]))
        (reset! post_index 0)

        (reset! nfa_has_zend false)
        (reset! nfa_has_backref false)

        ;; shared with BT engine
        (regcomp-start expr, re_flags)
        nil
    ))

;; Figure out if the NFA state list starts with an anchor, must match at start of the line.

(defn- #_boolean nfa-get-reganch [#_nfa_state_C start, #_int depth]
    (ยง
        (if (< 4 depth)
            ((ร RETURN) false)
        )

        ((ร FOR) (ร ((ร nfa_state_C p =) start) (non-nil? p) nil)
            ((ร SWITCH) (:c p)
                ((ร CASE) NFA_BOL)
                ((ร CASE) NFA_BOF)
                (do
                    ((ร RETURN) true) ;; yes!
                )

                ((ร CASE) NFA_ZSTART)
                ((ร CASE) NFA_ZEND)
                ((ร CASE) NFA_CURSOR)
                ((ร CASE) NFA_VISUAL)

                ((ร CASE) NFA_MOPEN)
                ((ร CASE) NFA_MOPEN1)
                ((ร CASE) NFA_MOPEN2)
                ((ร CASE) NFA_MOPEN3)
                ((ร CASE) NFA_MOPEN4)
                ((ร CASE) NFA_MOPEN5)
                ((ร CASE) NFA_MOPEN6)
                ((ร CASE) NFA_MOPEN7)
                ((ร CASE) NFA_MOPEN8)
                ((ร CASE) NFA_MOPEN9)
                ((ร CASE) NFA_NOPEN)
                ((ร CASE) NFA_ZOPEN)
                ((ร CASE) NFA_ZOPEN1)
                ((ร CASE) NFA_ZOPEN2)
                ((ร CASE) NFA_ZOPEN3)
                ((ร CASE) NFA_ZOPEN4)
                ((ร CASE) NFA_ZOPEN5)
                ((ร CASE) NFA_ZOPEN6)
                ((ร CASE) NFA_ZOPEN7)
                ((ร CASE) NFA_ZOPEN8)
                ((ร CASE) NFA_ZOPEN9)
                (do
                    ((ร p =) (.out0 p))
                    (ร BREAK)
                )

                ((ร CASE) NFA_SPLIT)
                (do
                    ((ร RETURN) (and (nfa-get-reganch (.out0 p), (inc depth)) (nfa-get-reganch (.out1 p), (inc depth))))
                )

                (ร DEFAULT)
                (do
                    ((ร RETURN) false) ;; noooo!
                )
            )
        )

        false
    ))

;; Figure out if the NFA state list starts with a character which must match at start of the match.

(defn- #_int nfa-get-regstart [#_nfa_state_C start, #_int depth]
    (ยง
        (if (< 4 depth)
            ((ร RETURN) 0)
        )

        ((ร FOR) (ร ((ร nfa_state_C p =) start) (non-nil? p) nil)
            ((ร SWITCH) (:c p)
                ;; all kinds of zero-width matches
                ((ร CASE) NFA_BOL)
                ((ร CASE) NFA_BOF)
                ((ร CASE) NFA_BOW)
                ((ร CASE) NFA_EOW)
                ((ร CASE) NFA_ZSTART)
                ((ร CASE) NFA_ZEND)
                ((ร CASE) NFA_CURSOR)
                ((ร CASE) NFA_VISUAL)
                ((ร CASE) NFA_LNUM)
                ((ร CASE) NFA_LNUM_GT)
                ((ร CASE) NFA_LNUM_LT)
                ((ร CASE) NFA_COL)
                ((ร CASE) NFA_COL_GT)
                ((ร CASE) NFA_COL_LT)
                ((ร CASE) NFA_VCOL)
                ((ร CASE) NFA_VCOL_GT)
                ((ร CASE) NFA_VCOL_LT)
                ((ร CASE) NFA_MARK)
                ((ร CASE) NFA_MARK_GT)
                ((ร CASE) NFA_MARK_LT)

                ((ร CASE) NFA_MOPEN)
                ((ร CASE) NFA_MOPEN1)
                ((ร CASE) NFA_MOPEN2)
                ((ร CASE) NFA_MOPEN3)
                ((ร CASE) NFA_MOPEN4)
                ((ร CASE) NFA_MOPEN5)
                ((ร CASE) NFA_MOPEN6)
                ((ร CASE) NFA_MOPEN7)
                ((ร CASE) NFA_MOPEN8)
                ((ร CASE) NFA_MOPEN9)
                ((ร CASE) NFA_NOPEN)
                ((ร CASE) NFA_ZOPEN)
                ((ร CASE) NFA_ZOPEN1)
                ((ร CASE) NFA_ZOPEN2)
                ((ร CASE) NFA_ZOPEN3)
                ((ร CASE) NFA_ZOPEN4)
                ((ร CASE) NFA_ZOPEN5)
                ((ร CASE) NFA_ZOPEN6)
                ((ร CASE) NFA_ZOPEN7)
                ((ร CASE) NFA_ZOPEN8)
                ((ร CASE) NFA_ZOPEN9)
                (do
                    ((ร p =) (.out0 p))
                    (ร BREAK)
                )

                ((ร CASE) NFA_SPLIT)
                (do
                    ((ร int c1 =) (nfa-get-regstart (.out0 p), (inc depth)))
                    ((ร int c2 =) (nfa-get-regstart (.out1 p), (inc depth)))

                    ((ร RETURN) (if (== c1 c2) c1 0))
                )

                (ร DEFAULT)
                (do
                    ((ร RETURN) (if (< 0 (:c p)) (:c p) 0))
                )
            )
        )

        0
    ))

;; Figure out if the NFA state list contains just literal text and nothing else.
;; If so return a string in allocated memory with what must match after regstart.
;; Otherwise return null.

(defn- #_Bytes nfa-get-match-text [#_nfa_state_C start]
    (ยง
        ((ร nfa_state_C p =) start)
        (if (!= (:c p) NFA_MOPEN)
            ((ร RETURN) nil)                ;; just in case
        )
        ((ร p =) (.out0 p))

        ((ร int len =) 0)
        (while (< 0 (:c p))
            ((ร len =) (+ len (utf-char2len (:c p))))
            ((ร p =) (.out0 p))
        )

        (if (or (!= (:c p) NFA_MCLOSE) (!= (.. p (out0) c) NFA_MATCH))
            ((ร RETURN) nil)
        )

        ((ร Bytes ret =) (Bytes. len))

        ((ร p =) (.. start (out0) (out0)))    ;; skip first char, it goes into regstart
        ((ร Bytes s =) ret)
        (while (< 0 (:c p))
            ((ร s =) (.plus s (utf-char2bytes (:c p), s)))
            ((ร p =) (.out0 p))
        )
        (eos! s)

        ret
    ))

;; Allocate more space for post_array.
;; Called when running above the estimated number of states.

(defn- #_void grow-post-array [#_int more]
    (reset! post_array (Arrays/copyOf @post_array, (+ (:length @post_array) more)))
    nil)

;; Search between "start" and "end" and try to recognize a character class in expanded form.
;; For example [0-9].
;; On success, return the id the character class to be emitted.
;; On failure, return 0 (=false).
;; Start points to the first char of the range, while end should point to the closing brace.
;; Keep in mind that 'ignorecase' applies at execution time,
;; thus [a-z] may need to be interpreted as [a-zA-Z].

(final int
    CLASS_not        0x80,
    CLASS_af         0x40,
    CLASS_AF         0x20,
    CLASS_az         0x10,
    CLASS_AZ         0x08,
    CLASS_o7         0x04,
    CLASS_o9         0x02,
    CLASS_underscore 0x01)

(defn- #_int nfa-recognize-char-class [#_Bytes start, #_Bytes end, #_boolean newl]
    (ยง
        ((ร int config =) 0)

        (if (!= (.at end 0) (byte \]))
            ((ร RETURN) 0)
        )

        ((ร Bytes p =) start)
        (when (== (.at p 0) (byte \^))
            ((ร config =) (| config CLASS_not))
            ((ร p =) (.plus p 1))
        )

        (while (BLT p, end)
            (cond (and (BLT (.plus p 2), end) (== (.at p 1) (byte \-)))
            (do
                ((ร SWITCH) (.at p 0)
                    ((ร CASE) (byte \0))
                    (do
                        (cond (== (.at p 2) (byte \9))
                        (do
                            ((ร config =) (| config CLASS_o9))
                            (ร BREAK)
                        )
                        (== (.at p 2) (byte \7))
                        (do
                            ((ร config =) (| config CLASS_o7))
                            (ร BREAK)
                        ))
                        (ร FALLTHROUGH)
                    )
                    ((ร CASE) (byte \a))
                    (do
                        (cond (== (.at p 2) (byte \z))
                        (do
                            ((ร config =) (| config CLASS_az))
                            (ร BREAK)
                        )
                        (== (.at p 2) (byte \f))
                        (do
                            ((ร config =) (| config CLASS_af))
                            (ร BREAK)
                        ))
                        (ร FALLTHROUGH)
                    )
                    ((ร CASE) (byte \A))
                    (do
                        (cond (== (.at p 2) (byte \Z))
                        (do
                            ((ร config =) (| config CLASS_AZ))
                            (ร BREAK)
                        )
                        (== (.at p 2) (byte \F))
                        (do
                            ((ร config =) (| config CLASS_AF))
                            (ร BREAK)
                        ))
                        (ร FALLTHROUGH)
                    )
                    (ร DEFAULT)
                    (do
                        ((ร RETURN) 0)
                    )
                )
                ((ร p =) (.plus p 3))
            )
            (and (BLT (.plus p 1), end) (== (.at p 0) (byte \\)) (== (.at p 1) (byte \n)))
            (do
                ((ร newl =) true)
                ((ร p =) (.plus p 2))
            )
            (== (.at p 0) (byte \_))
            (do
                ((ร config =) (| config CLASS_underscore))
                ((ร p =) (.plus p 1))
            )
            (== (.at p 0) (byte \newline))
            (do
                ((ร newl =) true)
                ((ร p =) (.plus p 1))
            )
            :else
            (do
                ((ร RETURN) 0)
            ))
        )

        (if (BNE p, end)
            ((ร RETURN) 0)
        )

        ((ร int nfa_add_nl =) (if newl NFA_ADD_NL 0))

        ((ร SWITCH) config
            ((ร CASE) CLASS_o9)
            (do
                ((ร RETURN) (+ nfa_add_nl NFA_DIGIT))
            )
            ((ร CASE) (| CLASS_not CLASS_o9))
            (do
                ((ร RETURN) (+ nfa_add_nl NFA_NDIGIT))
            )
            ((ร CASE) (| CLASS_af CLASS_AF CLASS_o9))
            (do
                ((ร RETURN) (+ nfa_add_nl NFA_HEX))
            )
            ((ร CASE) (| CLASS_not CLASS_af CLASS_AF CLASS_o9))
            (do
                ((ร RETURN) (+ nfa_add_nl NFA_NHEX))
            )
            ((ร CASE) CLASS_o7)
            (do
                ((ร RETURN) (+ nfa_add_nl NFA_OCTAL))
            )
            ((ร CASE) (| CLASS_not CLASS_o7))
            (do
                ((ร RETURN) (+ nfa_add_nl NFA_NOCTAL))
            )
            ((ร CASE) (| CLASS_az CLASS_AZ CLASS_o9 CLASS_underscore))
            (do
                ((ร RETURN) (+ nfa_add_nl NFA_WORD))
            )
            ((ร CASE) (| CLASS_not CLASS_az CLASS_AZ CLASS_o9 CLASS_underscore))
            (do
                ((ร RETURN) (+ nfa_add_nl NFA_NWORD))
            )
            ((ร CASE) (| CLASS_az CLASS_AZ CLASS_underscore))
            (do
                ((ร RETURN) (+ nfa_add_nl NFA_HEAD))
            )
            ((ร CASE) (| CLASS_not CLASS_az CLASS_AZ CLASS_underscore))
            (do
                ((ร RETURN) (+ nfa_add_nl NFA_NHEAD))
            )
            ((ร CASE) (| CLASS_az CLASS_AZ))
            (do
                ((ร RETURN) (+ nfa_add_nl NFA_ALPHA))
            )
            ((ร CASE) (| CLASS_not CLASS_az CLASS_AZ))
            (do
                ((ร RETURN) (+ nfa_add_nl NFA_NALPHA))
            )
            ((ร CASE) CLASS_az)
            (do
                ((ร RETURN) (+ nfa_add_nl NFA_LOWER_IC))
            )
            ((ร CASE) (| CLASS_not CLASS_az))
            (do
                ((ร RETURN) (+ nfa_add_nl NFA_NLOWER_IC))
            )
            ((ร CASE) CLASS_AZ)
            (do
                ((ร RETURN) (+ nfa_add_nl NFA_UPPER_IC))
            )
            ((ร CASE) (| CLASS_not CLASS_AZ))
            (do
                ((ร RETURN) (+ nfa_add_nl NFA_NUPPER_IC))
            )
        )

        0
    ))

;; helper functions used when doing re2post() ... regatom() parsing

(defn- #_boolean emc1 [#_int c]
    (ยง
        (if (<= (:length @post_array) @post_index)
            (grow-post-array 1000))

        ((ร @post_array[@post_index++] =) c)

        true
    ))

(defn- #_boolean emc2 [#_int c]
    (and (emc1 c) (emc1 NFA_CONCAT)))

;; Produce the bytes for equivalence class "c".
;; Currently only handles latin1, latin9 and utf-8.
;; Emits bytes in postfix notation: 'a,b,NFA_OR,c,NFA_OR' is equivalent to 'a OR b OR c'.
;;
;; NOTE! When changing this function, also update reg-equi-class()

(defn- #_boolean nfa-emit-equi-class [#_int c]
    (ยง
        ((ร SWITCH) c
            ((ร CASE) (byte \A))
            ((ร CASE) 0xc0) ((ร CASE) 0xc1) ((ร CASE) 0xc2)
            ((ร CASE) 0xc3) ((ร CASE) 0xc4) ((ร CASE) 0xc5)
            ((ร CASE) 0x100) ((ร CASE) 0x102) ((ร CASE) 0x104)
            ((ร CASE) 0x1cd) ((ร CASE) 0x1de) ((ร CASE) 0x1e0)
            ((ร CASE) 0x1ea2)
            (do
                ((ร RETURN) (and (emc2 (byte \A))
                    (emc2 0xc0) (emc2 0xc1) (emc2 0xc2)
                    (emc2 0xc3) (emc2 0xc4) (emc2 0xc5)
                    (emc2 0x100) (emc2 0x102) (emc2 0x104)
                    (emc2 0x1cd) (emc2 0x1de) (emc2 0x1e0)
                    (emc2 0x1ea2)))
            )
            ((ร CASE) (byte \a))
            ((ร CASE) 0xe0) ((ร CASE) 0xe1) ((ร CASE) 0xe2)
            ((ร CASE) 0xe3) ((ร CASE) 0xe4) ((ร CASE) 0xe5)
            ((ร CASE) 0x101) ((ร CASE) 0x103) ((ร CASE) 0x105)
            ((ร CASE) 0x1ce) ((ร CASE) 0x1df) ((ร CASE) 0x1e1)
            ((ร CASE) 0x1ea3)
            (do
                ((ร RETURN) (and (emc2 (byte \a))
                    (emc2 0xe0) (emc2 0xe1) (emc2 0xe2)
                    (emc2 0xe3) (emc2 0xe4) (emc2 0xe5)
                    (emc2 0x101) (emc2 0x103) (emc2 0x105)
                    (emc2 0x1ce) (emc2 0x1df) (emc2 0x1e1)
                    (emc2 0x1ea3)))
            )

            ((ร CASE) (byte \B))
            ((ร CASE) 0x1e02) ((ร CASE) 0x1e06)
            (do
                ((ร RETURN) (and (emc2 (byte \B))
                    (emc2 0x1e02) (emc2 0x1e06)))
            )
            ((ร CASE) (byte \b))
            ((ร CASE) 0x1e03) ((ร CASE) 0x1e07)
            (do
                ((ร RETURN) (and (emc2 (byte \b))
                    (emc2 0x1e03) (emc2 0x1e07)))
            )

            ((ร CASE) (byte \C))
            ((ร CASE) 0xc7)
            ((ร CASE) 0x106) ((ร CASE) 0x108) ((ร CASE) 0x10a) ((ร CASE) 0x10c)
            (do
                ((ร RETURN) (and (emc2 (byte \C))
                    (emc2 0xc7)
                    (emc2 0x106) (emc2 0x108) (emc2 0x10a) (emc2 0x10c)))
            )
            ((ร CASE) (byte \c))
            ((ร CASE) 0xe7)
            ((ร CASE) 0x107) ((ร CASE) 0x109) ((ร CASE) 0x10b) ((ร CASE) 0x10d)
            (do
                ((ร RETURN) (and (emc2 (byte \c))
                    (emc2 0xe7)
                    (emc2 0x107) (emc2 0x109) (emc2 0x10b) (emc2 0x10d)))
            )

            ((ร CASE) (byte \D))
            ((ร CASE) 0x10e) ((ร CASE) 0x110)
            ((ร CASE) 0x1e0a) ((ร CASE) 0x1e0c) ((ร CASE) 0x1e0e) ((ร CASE) 0x1e10) ((ร CASE) 0x1e12)
            (do
                ((ร RETURN) (and (emc2 (byte \D))
                    (emc2 0x10e) (emc2 0x110)
                    (emc2 0x1e0a) (emc2 0x1e0c) (emc2 0x1e0e) (emc2 0x1e10) (emc2 0x1e12)))
            )
            ((ร CASE) (byte \d))
            ((ร CASE) 0x10f) ((ร CASE) 0x111)
            ((ร CASE) 0x1e0b) ((ร CASE) 0x1e0d) ((ร CASE) 0x1e0f) ((ร CASE) 0x1e11) ((ร CASE) 0x1e13)
            (do
                ((ร RETURN) (and (emc2 (byte \d))
                    (emc2 0x10f) (emc2 0x111)
                    (emc2 0x1e0b) (emc2 0x1e0d) (emc2 0x1e0f) (emc2 0x1e11) (emc2 0x1e13)))
            )

            ((ร CASE) (byte \E))
            ((ร CASE) 0xc8) ((ร CASE) 0xc9) ((ร CASE) 0xca) ((ร CASE) 0xcb)
            ((ร CASE) 0x112) ((ร CASE) 0x114) ((ร CASE) 0x116) ((ร CASE) 0x118) ((ร CASE) 0x11a)
            ((ร CASE) 0x1eba) ((ร CASE) 0x1ebc)
            (do
                ((ร RETURN) (and (emc2 (byte \E))
                    (emc2 0xc8) (emc2 0xc9) (emc2 0xca) (emc2 0xcb)
                    (emc2 0x112) (emc2 0x114) (emc2 0x116) (emc2 0x118) (emc2 0x11a)
                    (emc2 0x1eba) (emc2 0x1ebc)))
            )
            ((ร CASE) (byte \e))
            ((ร CASE) 0xe8) ((ร CASE) 0xe9) ((ร CASE) 0xea) ((ร CASE) 0xeb)
            ((ร CASE) 0x113) ((ร CASE) 0x115) ((ร CASE) 0x117) ((ร CASE) 0x119) ((ร CASE) 0x11b)
            ((ร CASE) 0x1ebb) ((ร CASE) 0x1ebd)
            (do
                ((ร RETURN) (and (emc2 (byte \e))
                    (emc2 0xe8) (emc2 0xe9) (emc2 0xea) (emc2 0xeb)
                    (emc2 0x113) (emc2 0x115) (emc2 0x117) (emc2 0x119) (emc2 0x11b)
                    (emc2 0x1ebb) (emc2 0x1ebd)))
            )

            ((ร CASE) (byte \F))
            ((ร CASE) 0x1e1e)
            (do
                ((ร RETURN) (and (emc2 (byte \F))
                    (emc2 0x1e1e)))
            )
            ((ร CASE) (byte \f))
            ((ร CASE) 0x1e1f)
            (do
                ((ร RETURN) (and (emc2 (byte \f))
                    (emc2 0x1e1f)))
            )

            ((ร CASE) (byte \G))
            ((ร CASE) 0x11c) ((ร CASE) 0x11e) ((ร CASE) 0x120) ((ร CASE) 0x122)
            ((ร CASE) 0x1e4) ((ร CASE) 0x1e6) ((ร CASE) 0x1f4)
            ((ร CASE) 0x1e20)
            (do
                ((ร RETURN) (and (emc2 (byte \G))
                    (emc2 0x11c) (emc2 0x11e) (emc2 0x120) (emc2 0x122)
                    (emc2 0x1e4) (emc2 0x1e6) (emc2 0x1f4)
                    (emc2 0x1e20)))
            )
            ((ร CASE) (byte \g))
            ((ร CASE) 0x11d) ((ร CASE) 0x11f) ((ร CASE) 0x121) ((ร CASE) 0x123)
            ((ร CASE) 0x1e5) ((ร CASE) 0x1e7) ((ร CASE) 0x1f5)
            ((ร CASE) 0x1e21)
            (do
                ((ร RETURN) (and (emc2 (byte \g))
                    (emc2 0x11d) (emc2 0x11f) (emc2 0x121) (emc2 0x123)
                    (emc2 0x1e5) (emc2 0x1e7) (emc2 0x1f5)
                    (emc2 0x1e21)))
            )

            ((ร CASE) (byte \H))
            ((ร CASE) 0x124) ((ร CASE) 0x126)
            ((ร CASE) 0x1e22) ((ร CASE) 0x1e26) ((ร CASE) 0x1e28)
            (do
                ((ร RETURN) (and (emc2 (byte \H))
                    (emc2 0x124) (emc2 0x126)
                    (emc2 0x1e22) (emc2 0x1e26) (emc2 0x1e28)))
            )
            ((ร CASE) (byte \h))
            ((ร CASE) 0x125) ((ร CASE) 0x127)
            ((ร CASE) 0x1e23) ((ร CASE) 0x1e27) ((ร CASE) 0x1e29) ((ร CASE) 0x1e96)
            (do
                ((ร RETURN) (and (emc2 (byte \h))
                    (emc2 0x125) (emc2 0x127)
                    (emc2 0x1e23) (emc2 0x1e27) (emc2 0x1e29) (emc2 0x1e96)))
            )

            ((ร CASE) (byte \I))
            ((ร CASE) 0xcc) ((ร CASE) 0xcd) ((ร CASE) 0xce) ((ร CASE) 0xcf)
            ((ร CASE) 0x128) ((ร CASE) 0x12a) ((ร CASE) 0x12c) ((ร CASE) 0x12e) ((ร CASE) 0x130)
            ((ร CASE) 0x1cf)
            ((ร CASE) 0x1ec8)
            (do
                ((ร RETURN) (and (emc2 (byte \I))
                    (emc2 0xcc) (emc2 0xcd) (emc2 0xce) (emc2 0xcf)
                    (emc2 0x128) (emc2 0x12a) (emc2 0x12c) (emc2 0x12e) (emc2 0x130)
                    (emc2 0x1cf)
                    (emc2 0x1ec8)))
            )
            ((ร CASE) (byte \i))
            ((ร CASE) 0xec) ((ร CASE) 0xed) ((ร CASE) 0xee) ((ร CASE) 0xef)
            ((ร CASE) 0x129) ((ร CASE) 0x12b) ((ร CASE) 0x12d) ((ร CASE) 0x12f) ((ร CASE) 0x131)
            ((ร CASE) 0x1d0)
            ((ร CASE) 0x1ec9)
            (do
                ((ร RETURN) (and (emc2 (byte \i))
                    (emc2 0xec) (emc2 0xed) (emc2 0xee) (emc2 0xef)
                    (emc2 0x129) (emc2 0x12b) (emc2 0x12d) (emc2 0x12f) (emc2 0x131)
                    (emc2 0x1d0)
                    (emc2 0x1ec9)))
            )

            ((ร CASE) (byte \J))
            ((ร CASE) 0x134)
            (do
                ((ร RETURN) (and (emc2 (byte \J))
                    (emc2 0x134)))
            )
            ((ร CASE) (byte \j))
            ((ร CASE) 0x135) ((ร CASE) 0x1f0)
            (do
                ((ร RETURN) (and (emc2 (byte \j))
                    (emc2 0x135) (emc2 0x1f0)))
            )

            ((ร CASE) (byte \K))
            ((ร CASE) 0x136) ((ร CASE) 0x1e8)
            ((ร CASE) 0x1e30) ((ร CASE) 0x1e34)
            (do
                ((ร RETURN) (and (emc2 (byte \K))
                    (emc2 0x136) (emc2 0x1e8)
                    (emc2 0x1e30) (emc2 0x1e34)))
            )
            ((ร CASE) (byte \k))
            ((ร CASE) 0x137) ((ร CASE) 0x1e9)
            ((ร CASE) 0x1e31) ((ร CASE) 0x1e35)
            (do
                ((ร RETURN) (and (emc2 (byte \k))
                    (emc2 0x137) (emc2 0x1e9)
                    (emc2 0x1e31) (emc2 0x1e35)))
            )

            ((ร CASE) (byte \L))
            ((ร CASE) 0x139) ((ร CASE) 0x13b) ((ร CASE) 0x13d) ((ร CASE) 0x13f) ((ร CASE) 0x141)
            ((ร CASE) 0x1e3a)
            (do
                ((ร RETURN) (and (emc2 (byte \L))
                    (emc2 0x139) (emc2 0x13b) (emc2 0x13d) (emc2 0x13f) (emc2 0x141)
                    (emc2 0x1e3a)))
            )
            ((ร CASE) (byte \l))
            ((ร CASE) 0x13a) ((ร CASE) 0x13c) ((ร CASE) 0x13e) ((ร CASE) 0x140) ((ร CASE) 0x142)
            ((ร CASE) 0x1e3b)
            (do
                ((ร RETURN) (and (emc2 (byte \l))
                    (emc2 0x13a) (emc2 0x13c) (emc2 0x13e) (emc2 0x140) (emc2 0x142)
                    (emc2 0x1e3b)))
            )

            ((ร CASE) (byte \M))
            ((ร CASE) 0x1e3e) ((ร CASE) 0x1e40)
            (do
                ((ร RETURN) (and (emc2 (byte \M))
                    (emc2 0x1e3e) (emc2 0x1e40)))
            )
            ((ร CASE) (byte \m))
            ((ร CASE) 0x1e3f) ((ร CASE) 0x1e41)
            (do
                ((ร RETURN) (and (emc2 (byte \m))
                    (emc2 0x1e3f) (emc2 0x1e41)))
            )

            ((ร CASE) (byte \N))
            ((ร CASE) 0xd1)
            ((ร CASE) 0x143) ((ร CASE) 0x145) ((ร CASE) 0x147)
            ((ร CASE) 0x1e44) ((ร CASE) 0x1e48)
            (do
                ((ร RETURN) (and (emc2 (byte \N))
                    (emc2 0xd1)
                    (emc2 0x143) (emc2 0x145) (emc2 0x147)
                    (emc2 0x1e44) (emc2 0x1e48)))
            )
            ((ร CASE) (byte \n))
            ((ร CASE) 0xf1)
            ((ร CASE) 0x144) ((ร CASE) 0x146) ((ร CASE) 0x148) ((ร CASE) 0x149)
            ((ร CASE) 0x1e45) ((ร CASE) 0x1e49)
            (do
                ((ร RETURN) (and (emc2 (byte \n))
                    (emc2 0xf1)
                    (emc2 0x144) (emc2 0x146) (emc2 0x148) (emc2 0x149)
                    (emc2 0x1e45) (emc2 0x1e49)))
            )

            ((ร CASE) (byte \O))
            ((ร CASE) 0xd2) ((ร CASE) 0xd3) ((ร CASE) 0xd4)
            ((ร CASE) 0xd5) ((ร CASE) 0xd6) ((ร CASE) 0xd8)
            ((ร CASE) 0x14c) ((ร CASE) 0x14e) ((ร CASE) 0x150)
            ((ร CASE) 0x1a0) ((ร CASE) 0x1d1) ((ร CASE) 0x1ea) ((ร CASE) 0x1ec)
            ((ร CASE) 0x1ece)
            (do
                ((ร RETURN) (and (emc2 (byte \O))
                    (emc2 0xd2) (emc2 0xd3) (emc2 0xd4)
                    (emc2 0xd5) (emc2 0xd6) (emc2 0xd8)
                    (emc2 0x14c) (emc2 0x14e) (emc2 0x150)
                    (emc2 0x1a0) (emc2 0x1d1) (emc2 0x1ea) (emc2 0x1ec)
                    (emc2 0x1ece)))
            )
            ((ร CASE) (byte \o))
            ((ร CASE) 0xf2) ((ร CASE) 0xf3) ((ร CASE) 0xf4)
            ((ร CASE) 0xf5) ((ร CASE) 0xf6) ((ร CASE) 0xf8)
            ((ร CASE) 0x14d) ((ร CASE) 0x14f) ((ร CASE) 0x151)
            ((ร CASE) 0x1a1) ((ร CASE) 0x1d2) ((ร CASE) 0x1eb) ((ร CASE) 0x1ed)
            ((ร CASE) 0x1ecf)
            (do
                ((ร RETURN) (and (emc2 (byte \o))
                    (emc2 0xf2) (emc2 0xf3) (emc2 0xf4)
                    (emc2 0xf5) (emc2 0xf6) (emc2 0xf8)
                    (emc2 0x14d) (emc2 0x14f) (emc2 0x151)
                    (emc2 0x1a1) (emc2 0x1d2) (emc2 0x1eb) (emc2 0x1ed)
                    (emc2 0x1ecf)))
            )

            ((ร CASE) (byte \P))
            ((ร CASE) 0x1e54) ((ร CASE) 0x1e56)
            (do
                ((ร RETURN) (and (emc2 (byte \P))
                    (emc2 0x1e54) (emc2 0x1e56)))
            )
            ((ร CASE) (byte \p))
            ((ร CASE) 0x1e55) ((ร CASE) 0x1e57)
            (do
                ((ร RETURN) (and (emc2 (byte \p))
                    (emc2 0x1e55) (emc2 0x1e57)))
            )

            ((ร CASE) (byte \R))
            ((ร CASE) 0x154) ((ร CASE) 0x156) ((ร CASE) 0x158)
            ((ร CASE) 0x1e58) ((ร CASE) 0x1e5e)
            (do
                ((ร RETURN) (and (emc2 (byte \R))
                    (emc2 0x154) (emc2 0x156) (emc2 0x158)
                    (emc2 0x1e58) (emc2 0x1e5e)))
            )
            ((ร CASE) (byte \r))
            ((ร CASE) 0x155) ((ร CASE) 0x157) ((ร CASE) 0x159)
            ((ร CASE) 0x1e59) ((ร CASE) 0x1e5f)
            (do
                ((ร RETURN) (and (emc2 (byte \r))
                    (emc2 0x155) (emc2 0x157) (emc2 0x159)
                    (emc2 0x1e59) (emc2 0x1e5f)))
            )

            ((ร CASE) (byte \S))
            ((ร CASE) 0x15a) ((ร CASE) 0x15c) ((ร CASE) 0x15e) ((ร CASE) 0x160)
            ((ร CASE) 0x1e60)
            (do
                ((ร RETURN) (and (emc2 (byte \S))
                    (emc2 0x15a) (emc2 0x15c) (emc2 0x15e) (emc2 0x160)
                    (emc2 0x1e60)))
            )
            ((ร CASE) (byte \s))
            ((ร CASE) 0x15b) ((ร CASE) 0x15d) ((ร CASE) 0x15f) ((ร CASE) 0x161)
            ((ร CASE) 0x1e61)
            (do
                ((ร RETURN) (and (emc2 (byte \s))
                    (emc2 0x15b) (emc2 0x15d) (emc2 0x15f) (emc2 0x161)
                    (emc2 0x1e61)))
            )

            ((ร CASE) (byte \T))
            ((ร CASE) 0x162) ((ร CASE) 0x164) ((ร CASE) 0x166)
            ((ร CASE) 0x1e6a) ((ร CASE) 0x1e6e)
            (do
                ((ร RETURN) (and (emc2 (byte \T))
                    (emc2 0x162) (emc2 0x164) (emc2 0x166)
                    (emc2 0x1e6a) (emc2 0x1e6e)))
            )
            ((ร CASE) (byte \t))
            ((ร CASE) 0x163) ((ร CASE) 0x165) ((ร CASE) 0x167)
            ((ร CASE) 0x1e6b) ((ร CASE) 0x1e6f) ((ร CASE) 0x1e97)
            (do
                ((ร RETURN) (and (emc2 (byte \t))
                    (emc2 0x163) (emc2 0x165) (emc2 0x167)
                    (emc2 0x1e6b) (emc2 0x1e6f) (emc2 0x1e97)))
            )

            ((ร CASE) (byte \U))
            ((ร CASE) 0xd9) ((ร CASE) 0xda) ((ร CASE) 0xdb) ((ร CASE) 0xdc)
            ((ร CASE) 0x168) ((ร CASE) 0x16a) ((ร CASE) 0x16c) ((ร CASE) 0x16e)
            ((ร CASE) 0x170) ((ร CASE) 0x172) ((ร CASE) 0x1af) ((ร CASE) 0x1d3)
            ((ร CASE) 0x1ee6)
            (do
                ((ร RETURN) (and (emc2 (byte \U))
                    (emc2 0xd9) (emc2 0xda) (emc2 0xdb) (emc2 0xdc)
                    (emc2 0x168) (emc2 0x16a) (emc2 0x16c) (emc2 0x16e)
                    (emc2 0x170) (emc2 0x172) (emc2 0x1af) (emc2 0x1d3)
                    (emc2 0x1ee6)))
            )
            ((ร CASE) (byte \u))
            ((ร CASE) 0xf9) ((ร CASE) 0xfa) ((ร CASE) 0xfb) ((ร CASE) 0xfc)
            ((ร CASE) 0x169) ((ร CASE) 0x16b) ((ร CASE) 0x16d) ((ร CASE) 0x16f)
            ((ร CASE) 0x171) ((ร CASE) 0x173) ((ร CASE) 0x1b0) ((ร CASE) 0x1d4)
            ((ร CASE) 0x1ee7)
            (do
                ((ร RETURN) (and (emc2 (byte \u))
                    (emc2 0xf9) (emc2 0xfa) (emc2 0xfb) (emc2 0xfc)
                    (emc2 0x169) (emc2 0x16b) (emc2 0x16d) (emc2 0x16f)
                    (emc2 0x171) (emc2 0x173) (emc2 0x1b0) (emc2 0x1d4)
                    (emc2 0x1ee7)))
            )

            ((ร CASE) (byte \V))
            ((ร CASE) 0x1e7c)
            (do
                ((ร RETURN) (and (emc2 (byte \V))
                    (emc2 0x1e7c)))
            )
            ((ร CASE) (byte \v))
            ((ร CASE) 0x1e7d)
            (do
                ((ร RETURN) (and (emc2 (byte \v))
                    (emc2 0x1e7d)))
            )

            ((ร CASE) (byte \W))
            ((ร CASE) 0x174)
            ((ร CASE) 0x1e80) ((ร CASE) 0x1e82) ((ร CASE) 0x1e84) ((ร CASE) 0x1e86)
            (do
                ((ร RETURN) (and (emc2 (byte \W))
                    (emc2 0x174)
                    (emc2 0x1e80) (emc2 0x1e82) (emc2 0x1e84) (emc2 0x1e86)))
            )
            ((ร CASE) (byte \w))
            ((ร CASE) 0x175)
            ((ร CASE) 0x1e81) ((ร CASE) 0x1e83) ((ร CASE) 0x1e85) ((ร CASE) 0x1e87) ((ร CASE) 0x1e98)
            (do
                ((ร RETURN) (and (emc2 (byte \w))
                    (emc2 0x175)
                    (emc2 0x1e81) (emc2 0x1e83) (emc2 0x1e85) (emc2 0x1e87) (emc2 0x1e98)))
            )

            ((ร CASE) (byte \X))
            ((ร CASE) 0x1e8a) ((ร CASE) 0x1e8c)
            (do
                ((ร RETURN) (and (emc2 (byte \X))
                    (emc2 0x1e8a) (emc2 0x1e8c)))
            )
            ((ร CASE) (byte \x))
            ((ร CASE) 0x1e8b) ((ร CASE) 0x1e8d)
            (do
                ((ร RETURN) (and (emc2 (byte \x))
                    (emc2 0x1e8b) (emc2 0x1e8d)))
            )

            ((ร CASE) (byte \Y))
            ((ร CASE) 0xdd)
            ((ร CASE) 0x176) ((ร CASE) 0x178)
            ((ร CASE) 0x1e8e) ((ร CASE) 0x1ef2) ((ร CASE) 0x1ef6) ((ร CASE) 0x1ef8)
            (do
                ((ร RETURN) (and (emc2 (byte \Y))
                    (emc2 0xdd)
                    (emc2 0x176) (emc2 0x178)
                    (emc2 0x1e8e) (emc2 0x1ef2) (emc2 0x1ef6) (emc2 0x1ef8)))
            )
            ((ร CASE) (byte \y))
            ((ร CASE) 0xfd) ((ร CASE) 0xff)
            ((ร CASE) 0x177)
            ((ร CASE) 0x1e8f) ((ร CASE) 0x1e99) ((ร CASE) 0x1ef3) ((ร CASE) 0x1ef7) ((ร CASE) 0x1ef9)
            (do
                ((ร RETURN) (and (emc2 (byte \y))
                    (emc2 0xfd) (emc2 0xff)
                    (emc2 0x177)
                    (emc2 0x1e8f) (emc2 0x1e99) (emc2 0x1ef3) (emc2 0x1ef7) (emc2 0x1ef9)))
            )

            ((ร CASE) (byte \Z))
            ((ร CASE) 0x179) ((ร CASE) 0x17b) ((ร CASE) 0x17d) ((ร CASE) 0x1b5)
            ((ร CASE) 0x1e90) ((ร CASE) 0x1e94)
            (do
                ((ร RETURN) (and (emc2 (byte \Z))
                    (emc2 0x179) (emc2 0x17b) (emc2 0x17d) (emc2 0x1b5)
                    (emc2 0x1e90) (emc2 0x1e94)))
            )
            ((ร CASE) (byte \z))
            ((ร CASE) 0x17a) ((ร CASE) 0x17c) ((ร CASE) 0x17e) ((ร CASE) 0x1b6)
            ((ร CASE) 0x1e91) ((ร CASE) 0x1e95)
            (do
                ((ร RETURN) (and (emc2 (byte \z))
                    (emc2 0x17a) (emc2 0x17c) (emc2 0x17e) (emc2 0x1b6)
                    (emc2 0x1e91) (emc2 0x1e95)))
            )

            ;; default: character itself
        )

        (emc2 c)
    ))

;; Code to parse regular expression.
;;
;; We try to reuse parsing functions in regexp.c to
;; minimize surprise and keep the syntax consistent.

;; Parse the lowest level.
;;
;; An atom can be one of a long list of items.  Many atoms match one character
;; in the text.  It is often an ordinary character or a character class.
;; Braces can be used to make a pattern into an atom.  The "\z(\)" construct
;; is only for syntax highlighting.
;;
;; atom    ::=     ordinary-atom
;;     or  \( pattern \)
;;     or  \%( pattern \)
;;     or  \z( pattern \)

(defn- #_boolean nfa-regatom []
    (ยง
        ((ร Bytes old_regparse =) @regparse)
        ((ร int extra =) 0)
        ((ร int startc =) -1)
        ((ร int endc =) -1)
        ((ร int oldstartc =) -1)

        ((ร int c =) (getchr))

;       collection:
;       {
            ((ร SWITCH) c
                ((ร CASE) NUL)
                (do
                    (emsg e_nul_found)
                    (reset! rc_did_emsg true)
                    ((ร RETURN) false)
                )

                ((ร CASE) (Magic (byte \^)))
                (do
                    (emc1 NFA_BOL)
                    (ร BREAK)
                )

                ((ร CASE) (Magic (byte \$)))
                (do
                    (emc1 NFA_EOL)
                    (ร BREAK)
                )

                ((ร CASE) (Magic (byte \<)))
                (do
                    (emc1 NFA_BOW)
                    (ร BREAK)
                )

                ((ร CASE) (Magic (byte \>)))
                (do
                    (emc1 NFA_EOW)
                    (ร BREAK)
                )

                ((ร CASE) (Magic (byte \_)))
                (do
                    ((ร c =) (no-Magic (getchr)))
                    (when (== c NUL)
                        (emsg e_nul_found)
                        (reset! rc_did_emsg true)
                        ((ร RETURN) false)
                    )

                    (when (== c (byte \^))       ;; "\_^" is start-of-line
                        (emc1 NFA_BOL)
                        (ร BREAK)
                    )
                    (when (== c (byte \$))       ;; "\_$" is end-of-line
                        (emc1 NFA_EOL)
                        (ร BREAK)
                    )

                    ((ร extra =) NFA_ADD_NL)

                    ;; "\_[" is collection plus newline
                    (if (== c (byte \[))
                        (ร BREAK collection)
                    )

                    ;; "\_x" is character class plus newline
                    (ร FALLTHROUGH)
                )

                ;; Character classes.

                ((ร CASE) (Magic (byte \.)))
                ((ร CASE) (Magic (byte \i)))
                ((ร CASE) (Magic (byte \I)))
                ((ร CASE) (Magic (byte \k)))
                ((ร CASE) (Magic (byte \K)))
                ((ร CASE) (Magic (byte \f)))
                ((ร CASE) (Magic (byte \F)))
                ((ร CASE) (Magic (byte \p)))
                ((ร CASE) (Magic (byte \P)))
                ((ร CASE) (Magic (byte \s)))
                ((ร CASE) (Magic (byte \S)))
                ((ร CASE) (Magic (byte \d)))
                ((ร CASE) (Magic (byte \D)))
                ((ร CASE) (Magic (byte \x)))
                ((ร CASE) (Magic (byte \X)))
                ((ร CASE) (Magic (byte \o)))
                ((ร CASE) (Magic (byte \O)))
                ((ร CASE) (Magic (byte \w)))
                ((ร CASE) (Magic (byte \W)))
                ((ร CASE) (Magic (byte \h)))
                ((ร CASE) (Magic (byte \H)))
                ((ร CASE) (Magic (byte \a)))
                ((ร CASE) (Magic (byte \A)))
                ((ร CASE) (Magic (byte \l)))
                ((ร CASE) (Magic (byte \L)))
                ((ร CASE) (Magic (byte \u)))
                ((ร CASE) (Magic (byte \U)))
                (do
                    ((ร Bytes p =) (vim-strchr classchars, (no-Magic c)))
                    (when (nil? p)
                        (when (== extra NFA_ADD_NL)
                            (emsgn e_ill_char_class, (long c))
                            (reset! rc_did_emsg true)
                            ((ร RETURN) false)
                        )
                        (emsgn (u8 "INTERNAL: Unknown character class char: %ld"), (long c))
                        ((ร RETURN) false)
                    )
                    ;; When '.' is followed by a composing char ignore the dot,
                    ;; so that the composing char is matched here.
                    (when (and (== c (Magic (byte \.))) (utf-iscomposing (peekchr)))
                        ((ร old_regparse =) @regparse)
                        ((ร c =) (getchr))
                        ((ร RETURN) (nfa-do-multibyte c, old_regparse))
                    )
                    (emc1 (... nfa_classcodes (BDIFF p, classchars)))
                    (when (== extra NFA_ADD_NL)
                        (emc1 NFA_NEWL)
                        (emc1 NFA_OR)
                        ((ร @regflags =) (| @regflags RF_HASNL))
                    )
                    (ร BREAK)
                )

                ((ร CASE) (Magic (byte \n)))
                (do
                    (cond @reg_string
                    (do
                        ;; In a string "\n" matches a newline character.
                        (emc1 NL)
                    )
                    :else
                    (do
                        ;; In buffer text "\n" matches the end of a line.
                        (emc1 NFA_NEWL)
                        ((ร @regflags =) (| @regflags RF_HASNL))
                    ))
                    (ร BREAK)
                )

                ((ร CASE) (Magic (byte \()))
                (do
                    (if (not (nfa-reg REG_PAREN))
                        ((ร RETURN) false)           ;; cascaded error
                    )
                    (ร BREAK)
                )

                ((ร CASE) (Magic (byte \|)))
                ((ร CASE) (Magic (byte \&)))
                ((ร CASE) (Magic (byte \))))
                (do
                    (emsgn e_misplaced, (long (no-Magic c)))
                    ((ร RETURN) false)
                )

                ((ร CASE) (Magic (byte \=)))
                ((ร CASE) (Magic (byte \?)))
                ((ร CASE) (Magic (byte \+)))
                ((ร CASE) (Magic (byte \@)))
                ((ร CASE) (Magic (byte \*)))
                ((ร CASE) (Magic (byte \{)))
                (do
                    ;; these should follow an atom, not form an atom
                    (emsgn e_misplaced, (long (no-Magic c)))
                    ((ร RETURN) false)
                )

                ((ร CASE) (Magic (byte \~)))
                (do
                    ;; Previous substitute pattern.
                    ;; Generated as "\%(pattern\)".
                    (when (nil? @reg_prev_sub)
                        (emsg e_nopresub)
                        ((ร RETURN) false)
                    )
                    ((ร FOR) (ร ((ร Bytes lp =) @reg_prev_sub) (non-eos? lp) ((ร lp =) (.plus lp (us-ptr2len lp))))
                        (emc1 (us-ptr2char lp))
                        (if (BNE lp, @reg_prev_sub)
                            (emc1 NFA_CONCAT))
                    )
                    (emc1 NFA_NOPEN)
                    (ร BREAK)
                )

                ((ร CASE) (Magic (byte \1)))
                ((ร CASE) (Magic (byte \2)))
                ((ร CASE) (Magic (byte \3)))
                ((ร CASE) (Magic (byte \4)))
                ((ร CASE) (Magic (byte \5)))
                ((ร CASE) (Magic (byte \6)))
                ((ร CASE) (Magic (byte \7)))
                ((ร CASE) (Magic (byte \8)))
                ((ร CASE) (Magic (byte \9)))
                (do
                    (emc1 (+ NFA_BACKREF1 (- (no-Magic c) (byte \1))))
                    (reset! nfa_has_backref true)
                    (ร BREAK)
                )

                ((ร CASE) (Magic (byte \z)))
                (do
                    ((ร c =) (no-Magic (getchr)))
                    ((ร SWITCH) c
                        ((ร CASE) (byte \s))
                        (do
                            (emc1 NFA_ZSTART)
                            (if (not (re-mult-next (u8 "\\zs")))
                                ((ร RETURN) false)
                            )
                            (ร BREAK)
                        )

                        ((ร CASE) (byte \e))
                        (do
                            (emc1 NFA_ZEND)
                            (reset! nfa_has_zend true)
                            (if (not (re-mult-next (u8 "\\ze")))
                                ((ร RETURN) false)
                            )
                            (ร BREAK)
                        )

                        ((ร CASE) (byte \1))
                        ((ร CASE) (byte \2))
                        ((ร CASE) (byte \3))
                        ((ร CASE) (byte \4))
                        ((ร CASE) (byte \5))
                        ((ร CASE) (byte \6))
                        ((ร CASE) (byte \7))
                        ((ร CASE) (byte \8))
                        ((ร CASE) (byte \9))
                        (do
                            ;; \z1...\z9
                            (when (!= @reg_do_extmatch REX_USE)
                                (emsg e_z1_not_allowed)
                                (reset! rc_did_emsg true)
                                ((ร RETURN) false)
                            )
                            (emc1 (+ NFA_ZREF1 (- (no-Magic c) (byte \1))))
                            ;; No need to set nfa_has_backref, the sub-matches
                            ;; don't change when \z1 .. \z9 matches or not.
                            (reset! re_has_z REX_USE)
                            (ร BREAK)
                        )

                        ((ร CASE) (byte \())
                        (do
                            ;; \z(
                            (when (!= @reg_do_extmatch REX_SET)
                                (emsg e_z_not_allowed)
                                (reset! rc_did_emsg true)
                                ((ร RETURN) false)
                            )
                            (if (not (nfa-reg REG_ZPAREN))
                                ((ร RETURN) false)           ;; cascaded error
                            )
                            (reset! re_has_z REX_SET)
                            (ร BREAK)
                        )

                        (ร DEFAULT)
                        (do
                            (emsgn (u8 "E867: (NFA) Unknown operator '\\z%c'"), (long (no-Magic c)))
                            ((ร RETURN) false)
                        )
                    )
                    (ร BREAK)
                )

                ((ร CASE) (Magic (byte \%)))
                (do
                    ((ร c =) (no-Magic (getchr)))
                    ((ร SWITCH) c
                        ;; () without a back reference
                        ((ร CASE) (byte \())
                        (do
                            (if (not (nfa-reg REG_NPAREN))
                                ((ร RETURN) false)
                            )
                            (emc1 NFA_NOPEN)
                            (ร BREAK)
                        )

                        ((ร CASE) (byte \d))   ;; %d123 decimal
                        ((ร CASE) (byte \o))   ;; %o123 octal
                        ((ร CASE) (byte \x))   ;; %xab hex 2
                        ((ร CASE) (byte \u))   ;; %uabcd hex 4
                        ((ร CASE) (byte \U))   ;; %U1234abcd hex 8
                        (do
                            (ร int nr)

                            ((ร SWITCH) c
                                ((ร CASE) (byte \d))
                                (do
                                    ((ร nr =) (getdecchrs))
                                    (ร BREAK)
                                )
                                ((ร CASE) (byte \o))
                                (do
                                    ((ร nr =) (getoctchrs))
                                    (ร BREAK)
                                )
                                ((ร CASE) (byte \x))
                                (do
                                    ((ร nr =) (gethexchrs 2))
                                    (ร BREAK)
                                )
                                ((ร CASE) (byte \u))
                                (do
                                    ((ร nr =) (gethexchrs 4))
                                    (ร BREAK)
                                )
                                ((ร CASE) (byte \U))
                                (do
                                    ((ร nr =) (gethexchrs 8))
                                    (ร BREAK)
                                )
                                (ร DEFAULT)
                                (do
                                    ((ร nr =) -1)
                                    (ร BREAK)
                                )
                            )

                            (when (< nr 0)
                                (emsg2 (u8 "E678: Invalid character after %s%%[dxouU]"), (if (== @reg_magic MAGIC_ALL) (u8 "") (u8 "\\")))
                                (reset! rc_did_emsg true)
                                ((ร RETURN) false)
                            )
                            ;; A NUL is stored in the text as NL.
                            ;; TODO: what if a composing character follows?
                            (emc1 (if (zero? nr) 0x0a nr))
                            (ร BREAK)
                        )

                        ;; Catch \%^ and \%$ regardless of where they appear in the
                        ;; pattern -- regardless of whether or not it makes sense.
                        ((ร CASE) (byte \^))
                        (do
                            (emc1 NFA_BOF)
                            (ร BREAK)
                        )

                        ((ร CASE) (byte \$))
                        (do
                            (emc1 NFA_EOF)
                            (ร BREAK)
                        )

                        ((ร CASE) (byte \#))
                        (do
                            (emc1 NFA_CURSOR)
                            (ร BREAK)
                        )

                        ((ร CASE) (byte \V))
                        (do
                            (emc1 NFA_VISUAL)
                            (ร BREAK)
                        )

                        ((ร CASE) (byte \C))
                        (do
                            (emc1 NFA_ANY_COMPOSING)
                            (ร BREAK)
                        )

                        ((ร CASE) (byte \[))
                        (do
                            (ร int n)

                            ;; \%[abc]
                            ((ร FOR) (ร ((ร n =) 0) (!= ((ร c =) (peekchr)) (byte \])) (ร n++))
                                (when (== c NUL)
                                    (emsg2 e_missing_sb, (if (== @reg_magic MAGIC_ALL) (u8 "") (u8 "\\")))
                                    (reset! rc_did_emsg true)
                                    ((ร RETURN) false)
                                )
                                ;; recursive call!
                                (if (not (nfa-regatom))
                                    ((ร RETURN) false)
                                )
                            )
                            (getchr)       ;; get the ]
                            (when (zero? n)
                                (emsg2 e_empty_sb, (if (== @reg_magic MAGIC_ALL) (u8 "") (u8 "\\")))
                                (reset! rc_did_emsg true)
                                ((ร RETURN) false)
                            )
                            (emc1 NFA_OPT_CHARS)
                            (emc1 n)

                            ;; Emit as "\%(\%[abc]\)" to be able to handle "\%[abc]*" which would
                            ;; cause the empty string to be matched an unlimited number of times.
                            ;; NFA_NOPEN is added only once at a position, while NFA_SPLIT is added
                            ;; multiple times.  This is more efficient than not allowing NFA_SPLIT
                            ;; multiple times, it is used a lot.

                            (emc1 NFA_NOPEN)
                            (ร BREAK)
                        )

                        (ร DEFAULT)
                        (do
                            ((ร int n =) 0)
                            ((ร int cmp =) c)

                            (if (or (== c (byte \<)) (== c (byte \>)))
                                ((ร c =) (getchr))
                            )
                            (while (asc-isdigit c)
                                ((ร n =) (+ (* n 10) (- c (byte \0))))
                                ((ร c =) (getchr))
                            )
                            (cond (or (== c (byte \l)) (== c (byte \c)) (== c (byte \v)))
                            (do
                                (cond (== c (byte \l))
                                (do
                                    ;; \%{n}l  \%{n}<l  \%{n}>l
                                    (emc1 (cond (== cmp (byte \<)) NFA_LNUM_LT (== cmp (byte \>)) NFA_LNUM_GT :else NFA_LNUM))
                                )
                                (== c (byte \c))
                                (do
                                    ;; \%{n}c  \%{n}<c  \%{n}>c
                                    (emc1 (cond (== cmp (byte \<)) NFA_COL_LT (== cmp (byte \>)) NFA_COL_GT :else NFA_COL))
                                )
                                :else
                                (do
                                    ;; \%{n}v  \%{n}<v  \%{n}>v
                                    (emc1 (cond (== cmp (byte \<)) NFA_VCOL_LT (== cmp (byte \>)) NFA_VCOL_GT :else NFA_VCOL))
                                ))
                                (emc1 n)
                                (ร BREAK)
                            )
                            (and (== c (byte \')) (zero? n))
                            (do
                                ;; \%'m  \%<'m  \%>'m
                                (emc1 (cond (== cmp (byte \<)) NFA_MARK_LT (== cmp (byte \>)) NFA_MARK_GT :else NFA_MARK))
                                (emc1 (getchr))
                                (ร BREAK)
                            ))
                            (emsgn (u8 "E867: (NFA) Unknown operator '\\%%%c'"), (long (no-Magic c)))
                            ((ร RETURN) false)
                        )
                    )
                    (ร BREAK)
                )

                ((ร CASE) (Magic (byte \[)))
                (do
                    (ร BREAK collection)
                )

                (ร DEFAULT)
                (do
                    ((ร RETURN) (nfa-do-multibyte c, old_regparse))
                )
            )

            ((ร RETURN) true)
;       }

        ;; [abc]  uses NFA_START_COLL - NFA_END_COLL
        ;; [^abc] uses NFA_START_NEG_COLL - NFA_END_NEG_COLL
        ;; Each character is produced as a regular state,
        ;; using NFA_CONCAT to bind them together.
        ;; Besides normal characters there can be:
        ;; - character classes  NFA_CLASS_*
        ;; - ranges, two characters followed by NFA_RANGE.

        ((ร Bytes p =) @regparse)
        ((ร Bytes endp =) (skip-anyof p))

        (when (== (.at endp 0) (byte \]))
            ;; Try to reverse engineer character classes.  For example,
            ;; recognize that [0-9] stands for \d and [A-Za-z_] for \h,
            ;; and perform the necessary substitutions in the NFA.

            ((ร int result =) (nfa-recognize-char-class @regparse, endp, (== extra NFA_ADD_NL)))
            (when (non-zero? result)
                (cond (<= NFA_FIRST_NL result NFA_LAST_NL)
                (do
                    (emc1 (- result NFA_ADD_NL))
                    (emc1 NFA_NEWL)
                    (emc1 NFA_OR)
                )
                :else
                (do
                    (emc1 result)
                ))
                (reset! regparse endp)
                (reset! regparse (.plus @regparse (us-ptr2len-cc @regparse)))
                ((ร RETURN) true)
            )

            ;; Failed to recognize a character class.
            ;; Use the simple version that turns [abc] into 'a' OR 'b' OR 'c'.

            ((ร startc =) ((ร endc =) ((ร oldstartc =) -1)))
            ((ร boolean negated =) false)
            (cond (== (.at @regparse 0) (byte \^))                   ;; negated range
            (do
                ((ร negated =) true)
                (reset! regparse (.plus @regparse (us-ptr2len-cc @regparse)))
                (emc1 NFA_START_NEG_COLL)
            )
            :else
            (do
                (emc1 NFA_START_COLL)
            ))
            (when (== (.at @regparse 0) (byte \-))
                ((ร startc =) (byte \-))
                (emc1 startc)
                (emc1 NFA_CONCAT)
                (reset! regparse (.plus @regparse (us-ptr2len-cc @regparse)))
            )
            ;; Emit the OR branches for each character in the [].
            ((ร boolean emit_range =) false)
            (while (BLT @regparse, endp)
                ((ร oldstartc =) startc)
                ((ร startc =) -1)
                ((ร boolean got_coll_char =) false)
                (when (== (.at @regparse 0) (byte \[))
                    ;; Check for [: :], [= =], [. .].
                    (ร int charclass, equiclass = 0, collclass = 0)
;                   { Bytes[] __ = { @regparse }; charclass = get-char-class(__); @regparse = __[0]; }
                    (when (== charclass CLASS_NONE)
;                       { Bytes[] __ = { @regparse }; equiclass = get-equi-class(__); @regparse = __[0]; }
                        (when (zero? equiclass)
;                           { Bytes[] __ = { @regparse }; collclass = get-coll-element(__); @regparse = __[0]; }
                        )
                    )

                    ;; Character class like [:alpha:].
                    (when (!= charclass CLASS_NONE)
                        ((ร SWITCH) charclass
                            ((ร CASE) CLASS_ALNUM)
                            (do
                                (emc1 NFA_CLASS_ALNUM)
                                (ร BREAK)
                            )
                            ((ร CASE) CLASS_ALPHA)
                            (do
                                (emc1 NFA_CLASS_ALPHA)
                                (ร BREAK)
                            )
                            ((ร CASE) CLASS_BLANK)
                            (do
                                (emc1 NFA_CLASS_BLANK)
                                (ร BREAK)
                            )
                            ((ร CASE) CLASS_CNTRL)
                            (do
                                (emc1 NFA_CLASS_CNTRL)
                                (ร BREAK)
                            )
                            ((ร CASE) CLASS_DIGIT)
                            (do
                                (emc1 NFA_CLASS_DIGIT)
                                (ร BREAK)
                            )
                            ((ร CASE) CLASS_GRAPH)
                            (do
                                (emc1 NFA_CLASS_GRAPH)
                                (ร BREAK)
                            )
                            ((ร CASE) CLASS_LOWER)
                            (do
                                (emc1 NFA_CLASS_LOWER)
                                (ร BREAK)
                            )
                            ((ร CASE) CLASS_PRINT)
                            (do
                                (emc1 NFA_CLASS_PRINT)
                                (ร BREAK)
                            )
                            ((ร CASE) CLASS_PUNCT)
                            (do
                                (emc1 NFA_CLASS_PUNCT)
                                (ร BREAK)
                            )
                            ((ร CASE) CLASS_SPACE)
                            (do
                                (emc1 NFA_CLASS_SPACE)
                                (ร BREAK)
                            )
                            ((ร CASE) CLASS_UPPER)
                            (do
                                (emc1 NFA_CLASS_UPPER)
                                (ร BREAK)
                            )
                            ((ร CASE) CLASS_XDIGIT)
                            (do
                                (emc1 NFA_CLASS_XDIGIT)
                                (ร BREAK)
                            )
                            ((ร CASE) CLASS_TAB)
                            (do
                                (emc1 NFA_CLASS_TAB)
                                (ร BREAK)
                            )
                            ((ร CASE) CLASS_RETURN)
                            (do
                                (emc1 NFA_CLASS_RETURN)
                                (ร BREAK)
                            )
                            ((ร CASE) CLASS_BACKSPACE)
                            (do
                                (emc1 NFA_CLASS_BACKSPACE)
                                (ร BREAK)
                            )
                            ((ร CASE) CLASS_ESCAPE)
                            (do
                                (emc1 NFA_CLASS_ESCAPE)
                                (ร BREAK)
                            )
                        )
                        (emc1 NFA_CONCAT)
                        (ร CONTINUE)
                    )
                    ;; Try equivalence class [=a=] and the like.
                    (when (non-zero? equiclass)
                        (when (not (nfa-emit-equi-class equiclass))
                            ;; should never happen
                            (emsg (u8 "E868: Error building NFA with equivalence class!"))
                            (reset! rc_did_emsg true)
                            ((ร RETURN) false)
                        )
                        (ร CONTINUE)
                    )
                    ;; Try collating class like [. .].
                    (when (non-zero? collclass)
                        ((ร startc =) collclass)     ;; allow [.a.]-x as a range
                        ;; Will emit the proper atom at the end of the while loop.
                    )
                )
                ;; Try a range like 'a-x' or '\t-z'.  Also allows '-' as a start character.
                (when (and (== (.at @regparse 0) (byte \-)) (!= oldstartc -1))
                    ((ร emit_range =) true)
                    ((ร startc =) oldstartc)
                    (reset! regparse (.plus @regparse (us-ptr2len-cc @regparse)))
                    (ร CONTINUE)           ;; reading the end of the range
                )

                ;; Now handle simple and escaped characters.
                ;; Only "\]", "\^", "\]" and "\\" are special in Vi.
                ;; Vim accepts "\t", "\e", etc., but only when the 'l' flag in 'cpoptions' is not included.
                ;; Posix doesn't recognize backslash at all.

                (when (and (== (.at @regparse 0) (byte \\)) (not @reg_cpo_bsl) (BLE (.plus @regparse 1), endp) (or (non-nil? (vim-strchr REGEXP_INRANGE, (.at @regparse 1))) (and (not @reg_cpo_lit) (non-nil? (vim-strchr REGEXP_ABBR, (.at @regparse 1))))))
                    (reset! regparse (.plus @regparse (us-ptr2len-cc @regparse)))

                    (cond (== (.at @regparse 0) (byte \n))
                    (do
                        ((ร startc =) (if @reg_string NL NFA_NEWL))
                    )
                    (or (== (.at @regparse 0) (byte \d)) (== (.at @regparse 0) (byte \o)) (== (.at @regparse 0) (byte \x)) (== (.at @regparse 0) (byte \u)) (== (.at @regparse 0) (byte \U)))
                    (do
                        ;; TODO(RE) This needs more testing.
                        ((ร startc =) (coll-get-char))
                        ((ร got_coll_char =) true)
                        (reset! regparse (.minus @regparse (us-ptr-back old_regparse, @regparse)))
                    )
                    :else
                    (do
                        ;; \r,\t,\e,\b
                        ((ร startc =) (backslash-trans (.at @regparse 0)))
                    ))
                )

                ;; Normal printable char.
                (if (== startc -1)
                    ((ร startc =) (us-ptr2char @regparse))
                )

                ;; Previous char was '-', so this char is end of range.
                (cond emit_range
                (do
                    ((ร endc =) startc)
                    ((ร startc =) oldstartc)
                    (when (< endc startc)
                        (emsg e_invrange)
                        (reset! rc_did_emsg true)
                        ((ร RETURN) false)
                    )

                    (cond (< (+ startc 2) endc)
                    (do
                        ;; Emit a range instead of the sequence of individual characters.
                        (cond (zero? startc)
                        (do
                            ;; \x00 is translated to \x0a, start at \x01.
                            (emc1 1)
                        )
                        :else
                        (do
                            (swap! post_index dec) ;; remove NFA_CONCAT
                        ))
                        (emc1 endc)
                        (emc1 NFA_RANGE)
                        (emc1 NFA_CONCAT)
                    )
                    (or (< 1 (utf-char2len startc)) (< 1 (utf-char2len endc)))
                    (do
                        ;; Emit the characters in the range.
                        ;; "startc" was already emitted, so skip it.

                        ((ร FOR) (ร ((ร c =) (inc startc)) (<= c endc) (ร c++))
                            (emc1 c)
                            (emc1 NFA_CONCAT)
                        )
                    )
                    :else
                    (do
                        ;; Emit the range. "startc" was already emitted, so skip it.
                        ((ร FOR) (ร ((ร c =) (inc startc)) (<= c endc) (ร c++))
                            (emc1 c)
                            (emc1 NFA_CONCAT)
                        )
                    ))
                    ((ร emit_range =) false)
                    ((ร startc =) -1)
                )
                :else
                (do
                    ;; This char (startc) is not part of a range.  Just emit it.
                    ;; Normally, simply emit startc.  But if we get char
                    ;; code=0 from a collating char, then replace it with 0x0a.
                    ;; This is needed to completely mimic the behaviour of
                    ;; the backtracking engine.
                    (cond (== startc NFA_NEWL)
                    (do
                        ;; Line break can't be matched as part of the collection,
                        ;; add an OR below.  But not for negated range.
                        (if (not negated)
                            ((ร extra =) NFA_ADD_NL)
                        )
                    )
                    :else
                    (do
                        (if (and got_coll_char (zero? startc))
                            (emc1 0x0a)
                            (emc1 startc))
                        (emc1 NFA_CONCAT)
                    ))
                ))

                (reset! regparse (.plus @regparse (us-ptr2len-cc @regparse)))
            )

            (reset! regparse (.minus @regparse (us-ptr-back old_regparse, @regparse)))
            (when (== (.at @regparse 0) (byte \-))       ;; if last, '-' is just a char
                (emc1 (byte \-))
                (emc1 NFA_CONCAT)
            )

            ;; skip the trailing ]
            (reset! regparse endp)
            (reset! regparse (.plus @regparse (us-ptr2len-cc @regparse)))

            ;; Mark end of the collection.
            (if negated
                (emc1 NFA_END_NEG_COLL)
                (emc1 NFA_END_COLL))

            ;; \_[] also matches \n but it's not negated
            (when (== extra NFA_ADD_NL)
                (emc1 (if @reg_string NL NFA_NEWL))
                (emc1 NFA_OR)
            )

            ((ร RETURN) true)
        )

        (when @reg_strict
            (emsg e_missingbracket)
            (reset! rc_did_emsg true)
            ((ร RETURN) false)
        )

        (nfa-do-multibyte c, old_regparse)
    ))

(defn- #_final #_boolean nfa-do-multibyte [#_int c, #_Bytes old_regparse]
    (ยง
        (ร int plen)

        ;; plen is length of current char with composing chars
        (cond (or (!= (utf-char2len c) ((ร plen =) (us-ptr2len-cc old_regparse))) (utf-iscomposing c))
        (do
            ((ร int i =) 0)

            ;; A base character plus composing characters, or just one or more
            ;; composing characters.  This requires creating a separate atom
            ;; as if enclosing the characters in (), where NFA_COMPOSING is
            ;; the ( and NFA_END_COMPOSING is the ).
            ;; Note that right now we are building the postfix form, not the
            ;; NFA itself; a composing char could be: a, b, c, NFA_COMPOSING
            ;; where 'b' and 'c' are chars with codes > 256.
            (while true
                (emc1 c)
                (if (< 0 i)
                    (emc1 NFA_CONCAT))
                (if (<= plen ((ร i =) (+ i (utf-char2len c))))
                    (ร BREAK)
                )
                ((ร c =) (us-ptr2char (.plus old_regparse i)))
            )
            (emc1 NFA_COMPOSING)
            (reset! regparse (.plus old_regparse plen))
        )
        :else
        (do
            ((ร c =) (no-Magic c))
            (emc1 c)
        ))

        true
    ))

;; Parse something followed by possible [*+=].
;;
;; A piece is an atom, possibly followed by a multi, an indication of how many
;; times the atom can be matched.  Example: "a*" matches any sequence of "a"
;; characters: "", "a", "aa", etc.
;;
;; piece   ::=      atom
;;      or  atom  multi

(defn- #_boolean nfa-regpiece []
    (ยง
        ;; Save the current parse state, so that we can use it if <atom>{m,n} is next.
        ((ร parse_state_C old_state =) (NEW_parse_state_C))
        (save-parse-state old_state)

        ;; store current pos in the postfix form, for \{m,n} involving 0s
        ((ร int my_post_start =) @post_index)

        ((ร boolean ret =) (nfa-regatom))
        (if (not ret)
            ((ร RETURN) false)           ;; cascaded error
        )

        ((ร int op =) (peekchr))
        (if (== (re-multi-type op) NOT_MULTI)
            ((ร RETURN) true)
        )

        (skipchr)
        ((ร SWITCH) op
            ((ร CASE) (Magic (byte \*)))
            (do
                (emc1 NFA_STAR)
                (ร BREAK)
            )

            ((ร CASE) (Magic (byte \+)))
            (do
                ;; Trick: Normally, (a*)\+ would match the whole input "aaa".  The first and
                ;; only submatch would be "aaa".  But the backtracking engine interprets the
                ;; plus as "try matching one more time", and a* matches a second time at the
                ;; end of the input, the empty string.  The submatch will be the empty string.
                ;;
                ;; In order to be consistent with the old engine,
                ;; we replace <atom>+ with <atom><atom>*

                (restore-parse-state old_state)
                (reset! curchr -1)
                (if (not (nfa-regatom))
                    ((ร RETURN) false)
                )
                (emc1 NFA_STAR)
                (emc1 NFA_CONCAT)
                (skipchr)          ;; skip the \+
                (ร BREAK)
            )

            ((ร CASE) (Magic (byte \@)))
            (do
                ((ร int c2 =) (getdecchrs))
                ((ร op =) (no-Magic (getchr)))
                ((ร int i =) 0)
                ((ร SWITCH) op
                    ((ร CASE) (byte \=))
                    (do
                        ;; \@=
                        ((ร i =) NFA_PREV_ATOM_NO_WIDTH)
                        (ร BREAK)
                    )
                    ((ร CASE) (byte \!))
                    (do
                        ;; \@!
                        ((ร i =) NFA_PREV_ATOM_NO_WIDTH_NEG)
                        (ร BREAK)
                    )
                    ((ร CASE) (byte \<))
                    (do
                        ((ร op =) (no-Magic (getchr)))
                        (cond (== op (byte \=))
                        (do
                            ;; \@<=
                            ((ร i =) NFA_PREV_ATOM_JUST_BEFORE)
                        )
                        (== op (byte \!))
                        (do
                            ;; \@<!
                            ((ร i =) NFA_PREV_ATOM_JUST_BEFORE_NEG)
                        ))
                        (ร BREAK)
                    )
                    ((ร CASE) (byte \>))
                    (do
                        ;; \@>
                        ((ร i =) NFA_PREV_ATOM_LIKE_PATTERN)
                        (ร BREAK)
                    )
                )
                (when (zero? i)
                    (emsgn (u8 "E869: (NFA) Unknown operator '\\@%c'"), (long op))
                    ((ร RETURN) false)
                )
                (emc1 i)
                (if (or (== i NFA_PREV_ATOM_JUST_BEFORE) (== i NFA_PREV_ATOM_JUST_BEFORE_NEG))
                    (emc1 c2))
                (ร BREAK)
            )

            ((ร CASE) (Magic (byte \?)))
            ((ร CASE) (Magic (byte \=)))
            (do
                (emc1 NFA_QUEST)
                (ร BREAK)
            )

            ((ร CASE) (Magic (byte \{)))
            (do
                ;; a{2,5} will expand to 'aaa?a?a?'
                ;; a{-1,3} will expand to 'aa??a??', where ?? is the nongreedy version of '?'
                ;; \v(ab){2,3} will expand to '(ab)(ab)(ab)?', where all the parenthesis have the same id

                ((ร boolean greedy =) true)      ;; Braces are prefixed with '-' ?
                ((ร int c2 =) (peekchr))
                (when (or (== c2 (byte \-)) (== c2 (Magic (byte \-))))
                    (skipchr)
                    ((ร greedy =) false)
                )
                ((ร long[] minval =) (ร new long[1]))
                ((ร long[] maxval =) (ร new long[1]))
                (when (not (read-limits minval, maxval))
                    (emsg (u8 "E870: (NFA regexp) Error reading repetition limits"))
                    (reset! rc_did_emsg true)
                    ((ร RETURN) false)
                )

                ;;  <atom>{0,inf}, <atom>{0,} and <atom>{}  are equivalent to <atom>*
                (when (and (zero? (... minval 0)) (== (... maxval 0) MAX_LIMIT))
                    (cond greedy            ;; { { (match the braces)
                    (do
                        ;; \{}, \{0,}
                        (emc1 NFA_STAR)
                    )
                    :else                   ;; { { (match the braces)
                    (do
                        ;; \{-}, \{-0,}
                        (emc1 NFA_STAR_NONGREEDY)
                    ))
                    (ร BREAK)
                )

                ;; Special case: x{0} or x{-0}.
                (when (zero? (... maxval 0))
                    ;; Ignore result of previous call to nfa-regatom().
                    (reset! post_index my_post_start)
                    ;; NFA_EMPTY is 0-length and works everywhere.
                    (emc1 NFA_EMPTY)
                    ((ร RETURN) true)
                )

                ;; The engine is very inefficient (uses too many states) when the
                ;; maximum is much larger than the minimum and when the maximum is
                ;; large.  Bail out if we can use the other engine.
                (if (and (flag? @nfa_re_flags RE_AUTO) (or (< (+ (... minval 0) 200) (... maxval 0)) (< 500 (... maxval 0))))
                    ((ร RETURN) false)
                )

                ;; Ignore previous call to nfa-regatom().
                (reset! post_index my_post_start)
                ;; Save parse state after the repeated atom and the \{}.
                ((ร parse_state_C new_state =) (NEW_parse_state_C))
                (save-parse-state new_state)

                ((ร int quest =) (if greedy NFA_QUEST NFA_QUEST_NONGREEDY))
                (dotimes [#_int i (... maxval 0)]
                    ;; Goto beginning of the repeated atom.
                    (restore-parse-state old_state)
                    ((ร int old_post_pos =) @post_index)
                    (if (not (nfa-regatom))
                        ((ร RETURN) false)
                    )

                    ;; after "minval" times, atoms are optional
                    (when (< (... minval 0) (inc i))
                        (cond (== (... maxval 0) MAX_LIMIT)
                        (do
                            (if greedy
                                (emc1 NFA_STAR)
                                (emc1 NFA_STAR_NONGREEDY))
                        )
                        :else
                        (do
                            (emc1 quest)
                        ))
                    )
                    (if (!= old_post_pos my_post_start)
                        (emc1 NFA_CONCAT))
                    (if (and (< (... minval 0) (inc i)) (== (... maxval 0) MAX_LIMIT))
                        (ร BREAK)
                    )
                )

                ;; Go to just after the repeated atom and the \{}.
                (restore-parse-state new_state)
                (reset! curchr -1)
                (ร BREAK)
            )

            (ร DEFAULT)
            (do
                (ร BREAK)
            )
        )

        (when (!= (re-multi-type (peekchr)) NOT_MULTI)
            (emsg (u8 "E871: (NFA regexp) Can't have a multi follow a multi !"))
            (reset! rc_did_emsg true)
            ((ร RETURN) false)
        )

        true
    ))

;; Parse one or more pieces, concatenated.  It matches a match for the
;; first piece, followed by a match for the second piece, etc.  Example:
;; "f[0-9]b", first matches "f", then a digit and then "b".
;;
;; concat  ::=      piece
;;      or  piece piece
;;      or  piece piece piece
;;      etc.

(defn- #_boolean nfa-regconcat []
    (ยง
        ((ร boolean cont =) true)
        ((ร boolean first =) true)

        (while cont
            ((ร SWITCH) (peekchr)
                ((ร CASE) NUL)
                ((ร CASE) (Magic (byte \|)))
                ((ร CASE) (Magic (byte \&)))
                ((ร CASE) (Magic (byte \))))
                (do
                    ((ร cont =) false)
                    (ร BREAK)
                )

                ((ร CASE) (Magic (byte \Z)))
                (do
                    ((ร @regflags =) (| @regflags RF_ICOMBINE))
                    (skipchr-keepstart)
                    (ร BREAK)
                )

                ((ร CASE) (Magic (byte \c)))
                (do
                    ((ร @regflags =) (| @regflags RF_ICASE))
                    (skipchr-keepstart)
                    (ร BREAK)
                )

                ((ร CASE) (Magic (byte \C)))
                (do
                    ((ร @regflags =) (| @regflags RF_NOICASE))
                    (skipchr-keepstart)
                    (ร BREAK)
                )

                ((ร CASE) (Magic (byte \v)))
                (do
                    (reset! reg_magic MAGIC_ALL)
                    (skipchr-keepstart)
                    (reset! curchr -1)
                    (ร BREAK)
                )

                ((ร CASE) (Magic (byte \m)))
                (do
                    (reset! reg_magic MAGIC_ON)
                    (skipchr-keepstart)
                    (reset! curchr -1)
                    (ร BREAK)
                )

                ((ร CASE) (Magic (byte \M)))
                (do
                    (reset! reg_magic MAGIC_OFF)
                    (skipchr-keepstart)
                    (reset! curchr -1)
                    (ร BREAK)
                )

                ((ร CASE) (Magic (byte \V)))
                (do
                    (reset! reg_magic MAGIC_NONE)
                    (skipchr-keepstart)
                    (reset! curchr -1)
                    (ร BREAK)
                )

                (ร DEFAULT)
                (do
                    (if (not (nfa-regpiece))
                        ((ร RETURN) false)
                    )
                    (if (not first)
                        (emc1 NFA_CONCAT)
                        ((ร first =) false)
                    )
                    (ร BREAK)
                )
            )
        )

        true
    ))

;; Parse a branch, one or more concats, separated by "\&".  It matches the
;; last concat, but only if all the preceding concats also match at the same
;; position.  Examples:
;;      "foobeep\&..." matches "foo" in "foobeep".
;;      ".*Peter\&.*Bob" matches in a line containing both "Peter" and "Bob"
;;
;; branch ::=       concat
;;              or  concat \& concat
;;              or  concat \& concat \& concat
;;              etc.

(defn- #_boolean nfa-regbranch []
    (ยง
        ((ร int old_post_pos =) @post_index)

        ;; First branch, possibly the only one.
        (if (not (nfa-regconcat))
            ((ร RETURN) false)
        )

        ((ร int ch =) (peekchr))
        ;; Try next concats.
        (while (== ch (Magic (byte \&)))
            (skipchr)
            (emc1 NFA_NOPEN)
            (emc1 NFA_PREV_ATOM_NO_WIDTH)
            ((ร old_post_pos =) @post_index)
            (if (not (nfa-regconcat))
                ((ร RETURN) false)
            )
            ;; if concat is empty do emit a node
            (if (== old_post_pos @post_index)
                (emc1 NFA_EMPTY))
            (emc1 NFA_CONCAT)
            ((ร ch =) (peekchr))
        )

        ;; if a branch is empty, emit one node for it
        (if (== old_post_pos @post_index)
            (emc1 NFA_EMPTY))

        true
    ))

;; Parse a pattern, one or more branches, separated by "\|".
;; It matches anything that matches one of the branches.
;; Example: "foo\|beep" matches "foo" and matches "beep".
;; If more than one branch matches, the first one is used.
;;
;; pattern ::=     branch
;;     or  branch \| branch
;;     or  branch \| branch \| branch
;;     etc.

(defn- #_boolean nfa-reg [#_int paren]
    ;; paren: REG_NOPAREN, REG_PAREN, REG_NPAREN or REG_ZPAREN
    (ยง
        ((ร int parno =) 0)

        (cond (== paren REG_PAREN)
        (do
            (when (<= NSUBEXP @regnpar)
                (emsg (u8 "E872: (NFA regexp) Too many '('"))
                (reset! rc_did_emsg true)
                ((ร RETURN) false)
            )
            ((ร parno =) (ร @regnpar++))
        )
        (== paren REG_ZPAREN)
        (do
            ;; Make a ZOPEN node.
            (when (<= NSUBEXP @regnzpar)
                (emsg (u8 "E879: (NFA regexp) Too many \\z("))
                (reset! rc_did_emsg true)
                ((ร RETURN) false)
            )
            ((ร parno =) (ร @regnzpar++))
        ))

        (if (not (nfa-regbranch))
            ((ร RETURN) false)                   ;; cascaded error
        )

        (while (== (peekchr) (Magic (byte \|)))
            (skipchr)
            (if (not (nfa-regbranch))
                ((ร RETURN) false)               ;; cascaded error
            )
            (emc1 NFA_OR)
        )

        ;; Check for proper termination.
        (cond (and (!= paren REG_NOPAREN) (!= (getchr) (Magic (byte \)))))
        (do
            (if (== paren REG_NPAREN)
                (emsg2 e_unmatchedpp, (if (== @reg_magic MAGIC_ALL) (u8 "") (u8 "\\")))
                (emsg2 e_unmatchedp, (if (== @reg_magic MAGIC_ALL) (u8 "") (u8 "\\"))))
            (reset! rc_did_emsg true)
            ((ร RETURN) false)
        )
        (and (== paren REG_NOPAREN) (!= (peekchr) NUL))
        (do
            (if (== (peekchr) (Magic (byte \))))
                (emsg2 e_unmatchedpar, (if (== @reg_magic MAGIC_ALL) (u8 "") (u8 "\\")))
                (emsg (u8 "E873: (NFA regexp) proper termination error")))
            (reset! rc_did_emsg true)
            ((ร RETURN) false)
        ))

        ;; Here we set the flag allowing back references to this set of parentheses.

        (cond (== paren REG_PAREN)
        (do
            ((ร @had_endbrace[parno] =) true)     ;; have seen the close paren
            (emc1 (+ NFA_MOPEN parno))
        )
        (== paren REG_ZPAREN)
        (do
            (emc1 (+ NFA_ZOPEN parno))
        ))

        true
    ))

;; Parse r.e. @expr and convert it into postfix form.
;; Return the postfix string on success, null otherwise.

(defn- #_int* re2post []
    (ยง
        (if (not (nfa-reg REG_NOPAREN))
            ((ร RETURN) nil)
        )

        (emc1 NFA_MOPEN)
        @post_array
    ))

;; Represents an NFA state plus zero or one or two arrows exiting.
;; if c == MATCH, no arrows out; matching state.
;; If c == SPLIT, unlabeled arrows to out0 and out1 (if != null).
;; If c < 256, labeled arrow with character c to out0.

(atom! nfa_state_C* nfa_states) ;; points to nfa_prog.states

;; Allocate and initialize nfa_state_C.

(defn- #_nfa_state_C alloc-state [#_nfa_regprog_C prog, #_int c, #_nfa_state_C out0, #_nfa_state_C out1]
    (ยง
        (if (<= (:nstate prog) (:istate prog))
            ((ร RETURN) nil)
        )

        ((ร nfa_state_C state =) (ร @nfa_states[prog.istate++] =) (NEW_nfa_state_C))

        ((ร state.c =) c)
        (.out0 state out0)
        (.out1 state out1)
        ((ร state.val =) 0)

        ((ร state.id =) (:istate prog))
        ((ร state.lastlist[0] =) 0)
        ((ร state.lastlist[1] =) 0)

        state
    ))

;; Estimate the maximum byte length of anything matching "state".
;; When unknown or unlimited return -1.

(defn- #_int nfa-max-width [#_nfa_state_C startstate, #_int depth]
    (ยง
        ;; detect looping in a NFA_SPLIT
        (if (< 4 depth)
            ((ร RETURN) -1)
        )

        ((ร int len =) 0)

        ((ร FOR) (ร ((ร nfa_state_C state =) startstate) (non-nil? state) nil)
            ((ร SWITCH) (:c state)
                ((ร CASE) NFA_END_INVISIBLE)
                ((ร CASE) NFA_END_INVISIBLE_NEG)
                (do
                    ;; the end, return what we have
                    ((ร RETURN) len)
                )

                ((ร CASE) NFA_SPLIT)
                (do
                    ;; two alternatives, use the maximum
                    ((ร int l =) (nfa-max-width (.out0 state), (inc depth)))
                    ((ร int r =) (nfa-max-width (.out1 state), (inc depth)))
                    (if (or (< l 0) (< r 0))
                        ((ร RETURN) -1)
                    )

                    ((ร RETURN) (+ len (if (< r l) l r)))
                )

                ((ร CASE) NFA_ANY)
                ((ร CASE) NFA_START_COLL)
                ((ร CASE) NFA_START_NEG_COLL)
                (do
                    ;; matches some character, including composing chars
                    ((ร len =) (+ len MB_MAXBYTES))
                    (when (!= (:c state) NFA_ANY)
                        ;; skip over the characters
                        ((ร state =) (.. state (out1) (out0)))
                        (ร CONTINUE)
                    )
                    (ร BREAK)
                )

                ((ร CASE) NFA_DIGIT)
                ((ร CASE) NFA_WHITE)
                ((ร CASE) NFA_HEX)
                ((ร CASE) NFA_OCTAL)
                (do
                    ;; ascii
                    (ร len++)
                    (ร BREAK)
                )

                ((ร CASE) NFA_IDENT)
                ((ร CASE) NFA_SIDENT)
                ((ร CASE) NFA_KWORD)
                ((ร CASE) NFA_SKWORD)
                ((ร CASE) NFA_FNAME)
                ((ร CASE) NFA_SFNAME)
                ((ร CASE) NFA_PRINT)
                ((ร CASE) NFA_SPRINT)
                ((ร CASE) NFA_NWHITE)
                ((ร CASE) NFA_NDIGIT)
                ((ร CASE) NFA_NHEX)
                ((ร CASE) NFA_NOCTAL)
                ((ร CASE) NFA_WORD)
                ((ร CASE) NFA_NWORD)
                ((ร CASE) NFA_HEAD)
                ((ร CASE) NFA_NHEAD)
                ((ร CASE) NFA_ALPHA)
                ((ร CASE) NFA_NALPHA)
                ((ร CASE) NFA_LOWER)
                ((ร CASE) NFA_NLOWER)
                ((ร CASE) NFA_UPPER)
                ((ร CASE) NFA_NUPPER)
                ((ร CASE) NFA_LOWER_IC)
                ((ร CASE) NFA_NLOWER_IC)
                ((ร CASE) NFA_UPPER_IC)
                ((ร CASE) NFA_NUPPER_IC)
                ((ร CASE) NFA_ANY_COMPOSING)
                (do
                    ;; possibly non-ascii
                    ((ร len =) (+ len 3))
                    (ร BREAK)
                )

                ((ร CASE) NFA_START_INVISIBLE)
                ((ร CASE) NFA_START_INVISIBLE_NEG)
                ((ร CASE) NFA_START_INVISIBLE_BEFORE)
                ((ร CASE) NFA_START_INVISIBLE_BEFORE_NEG)
                (do
                    ;; zero-width, out1 points to the END state
                    ((ร state =) (.. state (out1) (out0)))
                    (ร CONTINUE)
                )

                ((ร CASE) NFA_BACKREF1)
                ((ร CASE) NFA_BACKREF2)
                ((ร CASE) NFA_BACKREF3)
                ((ร CASE) NFA_BACKREF4)
                ((ร CASE) NFA_BACKREF5)
                ((ร CASE) NFA_BACKREF6)
                ((ร CASE) NFA_BACKREF7)
                ((ร CASE) NFA_BACKREF8)
                ((ร CASE) NFA_BACKREF9)
                ((ร CASE) NFA_ZREF1)
                ((ร CASE) NFA_ZREF2)
                ((ร CASE) NFA_ZREF3)
                ((ร CASE) NFA_ZREF4)
                ((ร CASE) NFA_ZREF5)
                ((ร CASE) NFA_ZREF6)
                ((ร CASE) NFA_ZREF7)
                ((ร CASE) NFA_ZREF8)
                ((ร CASE) NFA_ZREF9)
                ((ร CASE) NFA_NEWL)
                ((ร CASE) NFA_SKIP)
                (do
                    ;; unknown width
                    ((ร RETURN) -1)
                )

                ((ร CASE) NFA_BOL)
                ((ร CASE) NFA_EOL)
                ((ร CASE) NFA_BOF)
                ((ร CASE) NFA_EOF)
                ((ร CASE) NFA_BOW)
                ((ร CASE) NFA_EOW)
                ((ร CASE) NFA_MOPEN)
                ((ร CASE) NFA_MOPEN1)
                ((ร CASE) NFA_MOPEN2)
                ((ร CASE) NFA_MOPEN3)
                ((ร CASE) NFA_MOPEN4)
                ((ร CASE) NFA_MOPEN5)
                ((ร CASE) NFA_MOPEN6)
                ((ร CASE) NFA_MOPEN7)
                ((ร CASE) NFA_MOPEN8)
                ((ร CASE) NFA_MOPEN9)
                ((ร CASE) NFA_ZOPEN)
                ((ร CASE) NFA_ZOPEN1)
                ((ร CASE) NFA_ZOPEN2)
                ((ร CASE) NFA_ZOPEN3)
                ((ร CASE) NFA_ZOPEN4)
                ((ร CASE) NFA_ZOPEN5)
                ((ร CASE) NFA_ZOPEN6)
                ((ร CASE) NFA_ZOPEN7)
                ((ร CASE) NFA_ZOPEN8)
                ((ร CASE) NFA_ZOPEN9)
                ((ร CASE) NFA_ZCLOSE)
                ((ร CASE) NFA_ZCLOSE1)
                ((ร CASE) NFA_ZCLOSE2)
                ((ร CASE) NFA_ZCLOSE3)
                ((ร CASE) NFA_ZCLOSE4)
                ((ร CASE) NFA_ZCLOSE5)
                ((ร CASE) NFA_ZCLOSE6)
                ((ร CASE) NFA_ZCLOSE7)
                ((ร CASE) NFA_ZCLOSE8)
                ((ร CASE) NFA_ZCLOSE9)
                ((ร CASE) NFA_MCLOSE)
                ((ร CASE) NFA_MCLOSE1)
                ((ร CASE) NFA_MCLOSE2)
                ((ร CASE) NFA_MCLOSE3)
                ((ร CASE) NFA_MCLOSE4)
                ((ร CASE) NFA_MCLOSE5)
                ((ร CASE) NFA_MCLOSE6)
                ((ร CASE) NFA_MCLOSE7)
                ((ร CASE) NFA_MCLOSE8)
                ((ร CASE) NFA_MCLOSE9)
                ((ร CASE) NFA_NOPEN)
                ((ร CASE) NFA_NCLOSE)

                ((ร CASE) NFA_LNUM_GT)
                ((ร CASE) NFA_LNUM_LT)
                ((ร CASE) NFA_COL_GT)
                ((ร CASE) NFA_COL_LT)
                ((ร CASE) NFA_VCOL_GT)
                ((ร CASE) NFA_VCOL_LT)
                ((ร CASE) NFA_MARK_GT)
                ((ร CASE) NFA_MARK_LT)
                ((ร CASE) NFA_VISUAL)
                ((ร CASE) NFA_LNUM)
                ((ร CASE) NFA_CURSOR)
                ((ร CASE) NFA_COL)
                ((ร CASE) NFA_VCOL)
                ((ร CASE) NFA_MARK)

                ((ร CASE) NFA_ZSTART)
                ((ร CASE) NFA_ZEND)
                ((ร CASE) NFA_OPT_CHARS)
                ((ร CASE) NFA_EMPTY)
                ((ร CASE) NFA_START_PATTERN)
                ((ร CASE) NFA_END_PATTERN)
                ((ร CASE) NFA_COMPOSING)
                ((ร CASE) NFA_END_COMPOSING)
                (do
                    ;; zero-width
                    (ร BREAK)
                )

                (ร DEFAULT)
                (do
                    (when (< (:c state) 0)
                        ;; don't know what this is
                        ((ร RETURN) -1)
                    )
                    ;; normal character
                    ((ร len =) (+ len (utf-char2len (:c state))))
                    (ร BREAK)
                )
            )

            ;; normal way to continue
            ((ร state =) (.out0 state))
        )

        ;; unrecognized, "cannot happen"
        -1
    ))

;; A partially built NFA without the matching state filled in.
;; frag_C.fr_start points at the start state.
;; frag_C.fr_out is a list of places that need to be set to the next state for this fragment.

;; Since the out pointers in the list are always uninitialized,
;; we use the pointers themselves as storage for the fragnode_C.

(class! #_final fragnode_C
    [
        (field #_"/*fragnode_C*/"Object     fn_next)
    ])

(class! #_final frag_C
    [
        (field nfa_state_C  fr_start)
        (field fragnode_C   fr_out)
    ])

(defn- #_void COPY-frag [#_frag_C fr1, #_frag_C fr0]
    (ยง
        ((ร fr1.fr_start =) (:fr_start fr0))
        ((ร fr1.fr_out =) (:fr_out fr0))
        nil
    ))

;; Initialize a frag_C struct and return it.

(defn- #_frag_C alloc-frag [#_nfa_state_C start, #_fragnode_C out]
    (ยง
        ((ร frag_C frag =) (NEW_frag_C))

        ((ร frag.fr_start =) start)
        ((ร frag.fr_out =) out)

        frag
    ))

;; Create singleton list containing just outp.

(defn- #_fragnode_C fr-single [#_fragnode_C node]
    (ยง
        ((ร node.fn_next =) nil)
        node
    ))

;; Patch the list of states at out to point to start.

(defn- #_void fr-patch [#_fragnode_C node, #_nfa_state_C start]
    (ยง
        ((ร FOR) (ร (ร fragnode_C next) (non-nil? node) ((ร node =) next))
            ((ร next =) (ร (fragnode_C)(node.fn_next)))
            ((ร node.fn_next =) start)
        )
        nil
    ))

;; Join the two lists returning the concatenation.

(defn- #_fragnode_C fr-append [#_fragnode_C head, #_fragnode_C tail]
    (ยง
        ((ร fragnode_C list =) head)

        (while (non-nil? (:fn_next head))
            ((ร head =) (ร (fragnode_C)(head.fn_next)))
        )
        ((ร head.fn_next =) tail)

        list
    ))

;; Stack used for transforming postfix form into NFA.

(class! #_final nfa_stack_C
    [
        (field frag_C*      st_base)
        (field int          st_next)
        (field int          st_over)
    ])

(defn- #_nfa_stack_C new-nfa-stack [#_int n]
    (->nfa_stack_C (frag_C* n) 0 n))

;; Push an item onto the stack.

(defn- #_boolean st-push [#_nfa_stack_C stack, #_frag_C frag]
    (ยง
        (when (< (:st_next stack) (:st_over stack))
            ((ร stack.st_base[stack.st_next++] =) frag)
            ((ร RETURN) true)
        )

        false
    ))

;; Pop an item from the stack.

(defn- #_frag_C st-pop [#_nfa_stack_C stack]
    (ยง
        (if (< (ร --stack.st_next) 0)
            ((ร RETURN) nil)
        )

        ((ร frag_C frag =) (... (:st_base stack) (:st_next stack)))
        ((ร stack.st_base[stack.st_next] =) nil)
        frag
    ))

(defn- #_nfa_state_C st-error [#_int* _postfix, #_int _i, #_int _over]
    (emsg (u8 "E874: (NFA) Could not pop the stack !"))
    nil)

;; Convert a postfix form into its equivalent NFA.
;; Return the NFA start state on success, null otherwise.

(defn- #_nfa_state_C post2nfa [#_int* postfix, #_int over, #_nfa_regprog_C prog, #_boolean nfa_calc_size]
    (ยง
        (if (nil? postfix)
            ((ร RETURN) nil)
        )

        ((ร nfa_stack_C stack =) (if nfa_calc_size nil (new-nfa-stack (+ (:nstate prog) 1))))

        (ร int i)
        ((ร FOR) (ร ((ร i =) 0) (< i over) (ร i++))
            ((ร SWITCH) (... postfix i)
                ((ร CASE) NFA_CONCAT)
                (do
                    ;; Concatenation.
                    ;; Pay attention: this operator does not exist in the r.e. itself (it is implicit, really).
                    ;; It is added when r.e. is translated to postfix form in re2post().
                    (when nfa_calc_size
                        ;; prog.nstate += 0;
                        (ร BREAK)
                    )

                    ((ร frag_C e2 =) (st-pop stack))
                    (if (nil? e2)
                        ((ร RETURN) (st-error postfix, i, over))
                    )
                    ((ร frag_C e1 =) (st-pop stack))
                    (if (nil? e1)
                        ((ร RETURN) (st-error postfix, i, over))
                    )
                    (fr-patch (:fr_out e1), (:fr_start e2))
                    (st-push stack, (alloc-frag (:fr_start e1), (:fr_out e2)))
                    (ร BREAK)
                )

                ((ร CASE) NFA_OR)
                (do
                    ;; Alternation.
                    (when nfa_calc_size
                        (ร prog.nstate++)
                        (ร BREAK)
                    )

                    ((ร frag_C e2 =) (st-pop stack))
                    (if (nil? e2)
                        ((ร RETURN) (st-error postfix, i, over))
                    )
                    ((ร frag_C e1 =) (st-pop stack))
                    (if (nil? e1)
                        ((ร RETURN) (st-error postfix, i, over))
                    )
                    ((ร nfa_state_C s0 =) (alloc-state prog, NFA_SPLIT, (:fr_start e1), (:fr_start e2)))
                    (if (nil? s0)
                        ((ร RETURN) nil)
                    )
                    (st-push stack, (alloc-frag s0, (fr-append (:fr_out e1), (:fr_out e2))))
                    (ร BREAK)
                )

                ((ร CASE) NFA_STAR)
                (do
                    ;; Zero or more, prefer more.
                    (when nfa_calc_size
                        (ร prog.nstate++)
                        (ร BREAK)
                    )

                    ((ร frag_C e0 =) (st-pop stack))
                    (if (nil? e0)
                        ((ร RETURN) (st-error postfix, i, over))
                    )
                    ((ร nfa_state_C s0 =) (alloc-state prog, NFA_SPLIT, (:fr_start e0), nil))
                    (if (nil? s0)
                        ((ร RETURN) nil)
                    )
                    (fr-patch (:fr_out e0), s0)
                    (st-push stack, (alloc-frag s0, (fr-single (:out1 s0))))
                    (ร BREAK)
                )

                ((ร CASE) NFA_STAR_NONGREEDY)
                (do
                    ;; Zero or more, prefer zero.
                    (when nfa_calc_size
                        (ร prog.nstate++)
                        (ร BREAK)
                    )

                    ((ร frag_C e0 =) (st-pop stack))
                    (if (nil? e0)
                        ((ร RETURN) (st-error postfix, i, over))
                    )
                    ((ร nfa_state_C s0 =) (alloc-state prog, NFA_SPLIT, nil, (:fr_start e0)))
                    (if (nil? s0)
                        ((ร RETURN) nil)
                    )
                    (fr-patch (:fr_out e0), s0)
                    (st-push stack, (alloc-frag s0, (fr-single (:out0 s0))))
                    (ร BREAK)
                )

                ((ร CASE) NFA_QUEST)
                (do
                    ;; one or zero atoms=> greedy match
                    (when nfa_calc_size
                        (ร prog.nstate++)
                        (ร BREAK)
                    )

                    ((ร frag_C e0 =) (st-pop stack))
                    (if (nil? e0)
                        ((ร RETURN) (st-error postfix, i, over))
                    )
                    ((ร nfa_state_C s0 =) (alloc-state prog, NFA_SPLIT, (:fr_start e0), nil))
                    (if (nil? s0)
                        ((ร RETURN) nil)
                    )
                    (st-push stack, (alloc-frag s0, (fr-append (:fr_out e0), (fr-single (:out1 s0)))))
                    (ร BREAK)
                )

                ((ร CASE) NFA_QUEST_NONGREEDY)
                (do
                    ;; zero or one atoms => non-greedy match
                    (when nfa_calc_size
                        (ร prog.nstate++)
                        (ร BREAK)
                    )

                    ((ร frag_C e0 =) (st-pop stack))
                    (if (nil? e0)
                        ((ร RETURN) (st-error postfix, i, over))
                    )
                    ((ร nfa_state_C s0 =) (alloc-state prog, NFA_SPLIT, nil, (:fr_start e0)))
                    (if (nil? s0)
                        ((ร RETURN) nil)
                    )
                    (st-push stack, (alloc-frag s0, (fr-append (:fr_out e0), (fr-single (:out0 s0)))))
                    (ร BREAK)
                )

                ((ร CASE) NFA_END_COLL)
                ((ร CASE) NFA_END_NEG_COLL)
                (do
                    ;; On the stack is the sequence starting with NFA_START_COLL or
                    ;; NFA_START_NEG_COLL and all possible characters.  Patch it to
                    ;; add the output to the start.
                    (when nfa_calc_size
                        (ร prog.nstate++)
                        (ร BREAK)
                    )

                    ((ร frag_C e0 =) (st-pop stack))
                    (if (nil? e0)
                        ((ร RETURN) (st-error postfix, i, over))
                    )
                    ((ร nfa_state_C s0 =) (alloc-state prog, NFA_END_COLL, nil, nil))
                    (if (nil? s0)
                        ((ร RETURN) nil)
                    )
                    (fr-patch (:fr_out e0), s0)
;                   e0.fr_start.out1(s0);
                    (st-push stack, (alloc-frag (:fr_start e0), (fr-single (:out0 s0))))
                    (ร BREAK)
                )

                ((ร CASE) NFA_RANGE)
                (do
                    ;; Before this are two characters, the low and high end of a range.
                    ;; Turn them into two states with MIN and MAX.
                    (when nfa_calc_size
                        ;; prog.nstate += 0;
                        (ร BREAK)
                    )

                    ((ร frag_C e2 =) (st-pop stack))
                    (if (nil? e2)
                        ((ร RETURN) (st-error postfix, i, over))
                    )
                    ((ร frag_C e1 =) (st-pop stack))
                    (if (nil? e1)
                        ((ร RETURN) (st-error postfix, i, over))
                    )
                    ((ร e2.fr_start.val =) (:c (:fr_start e2)))
                    ((ร e2.fr_start.c =) NFA_RANGE_MAX)
                    ((ร e1.fr_start.val =) (:c (:fr_start e1)))
                    ((ร e1.fr_start.c =) NFA_RANGE_MIN)
                    (fr-patch (:fr_out e1), (:fr_start e2))
                    (st-push stack, (alloc-frag (:fr_start e1), (:fr_out e2)))
                    (ร BREAK)
                )

                ((ร CASE) NFA_EMPTY)
                (do
                    ;; 0-length, used in a repetition with max/min count of 0
                    (when nfa_calc_size
                        (ร prog.nstate++)
                        (ร BREAK)
                    )

                    ((ร nfa_state_C s0 =) (alloc-state prog, NFA_EMPTY, nil, nil))
                    (if (nil? s0)
                        ((ร RETURN) nil)
                    )
                    (st-push stack, (alloc-frag s0, (fr-single (:out0 s0))))
                    (ร BREAK)
                )

                ((ร CASE) NFA_OPT_CHARS)
                (do
                    ;; \%[abc] implemented as:
                    ;;    NFA_SPLIT
                    ;;    +-CHAR(a)
                    ;;    | +-NFA_SPLIT
                    ;;    |   +-CHAR(b)
                    ;;    |   | +-NFA_SPLIT
                    ;;    |   |   +-CHAR(c)
                    ;;    |   |   | +-next
                    ;;    |   |   +- next
                    ;;    |   +- next
                    ;;    +- next

                    ((ร int n =) (... postfix (ร ++i)))                           ;; get number of characters
                    (when nfa_calc_size
                        ((ร prog.nstate =) (+ (:nstate prog) n))
                        (ร BREAK)
                    )

                    ((ร frag_C e1 =) (alloc-frag nil, nil))     ;; e1.fr_out: stores list with out1's
                    ((ร nfa_state_C s0 =) nil)
                    ((ร FOR) (ร ((ร nfa_state_C s1 =) nil) (< 0 (ร n--)) ((ร s1 =) s0))  ;; s1: previous NFA_SPLIT to connect to
                        ((ร frag_C e0 =) (st-pop stack))          ;; get character
                        (if (nil? e0)
                            ((ร RETURN) (st-error postfix, i, over))
                        )
                        ((ร s0 =) (alloc-state prog, NFA_SPLIT, (:fr_start e0), nil))
                        (if (nil? s0)
                            ((ร RETURN) nil)
                        )
                        (if (nil? (:fr_out e1))
                            (COPY-frag e1, e0))
                        (fr-patch (:fr_out e0), s1)
                        (fr-append (:fr_out e1), (fr-single (:out1 s0)))
                    )
                    (st-push stack, (alloc-frag s0, (:fr_out e1)))
                    (ร BREAK)
                )

                ((ร CASE) NFA_PREV_ATOM_NO_WIDTH)
                ((ร CASE) NFA_PREV_ATOM_NO_WIDTH_NEG)
                ((ร CASE) NFA_PREV_ATOM_JUST_BEFORE)
                ((ร CASE) NFA_PREV_ATOM_JUST_BEFORE_NEG)
                ((ร CASE) NFA_PREV_ATOM_LIKE_PATTERN)
                (do
                    ((ร boolean before =) (or (== (... postfix i) NFA_PREV_ATOM_JUST_BEFORE) (== (... postfix i) NFA_PREV_ATOM_JUST_BEFORE_NEG)))
                    ((ร boolean pattern =) (== (... postfix i) NFA_PREV_ATOM_LIKE_PATTERN))

                    (ร int start_state, end_state)
                    ((ร SWITCH) (... postfix i)
                        ((ร CASE) NFA_PREV_ATOM_NO_WIDTH)
                        (do
                            ((ร start_state =) NFA_START_INVISIBLE)
                            ((ร end_state =) NFA_END_INVISIBLE)
                            (ร BREAK)
                        )
                        ((ร CASE) NFA_PREV_ATOM_NO_WIDTH_NEG)
                        (do
                            ((ร start_state =) NFA_START_INVISIBLE_NEG)
                            ((ร end_state =) NFA_END_INVISIBLE_NEG)
                            (ร BREAK)
                        )
                        ((ร CASE) NFA_PREV_ATOM_JUST_BEFORE)
                        (do
                            ((ร start_state =) NFA_START_INVISIBLE_BEFORE)
                            ((ร end_state =) NFA_END_INVISIBLE)
                            (ร BREAK)
                        )
                        ((ร CASE) NFA_PREV_ATOM_JUST_BEFORE_NEG)
                        (do
                            ((ร start_state =) NFA_START_INVISIBLE_BEFORE_NEG)
                            ((ร end_state =) NFA_END_INVISIBLE_NEG)
                            (ร BREAK)
                        )
                        (ร DEFAULT) ;; NFA_PREV_ATOM_LIKE_PATTERN:
                        (do
                            ((ร start_state =) NFA_START_PATTERN)
                            ((ร end_state =) NFA_END_PATTERN)
                            (ร BREAK)
                        )
                    )

                    ((ร int n =) (if before (... postfix (ร ++i)) 0))    ;; get the count

                    ;; The \@= operator: match the preceding atom with zero width.
                    ;; The \@! operator: no match for the preceding atom.
                    ;; The \@<= operator: match for the preceding atom.
                    ;; The \@<! operator: no match for the preceding atom.
                    ;; Surrounds the preceding atom with START_INVISIBLE and END_INVISIBLE, similarly to MOPEN.

                    (when nfa_calc_size
                        ((ร prog.nstate =) (+ (:nstate prog) (if pattern 4 2)))
                        (ร BREAK)
                    )

                    ((ร frag_C e0 =) (st-pop stack))
                    (if (nil? e0)
                        ((ร RETURN) (st-error postfix, i, over))
                    )

                    ((ร nfa_state_C s1 =) (alloc-state prog, end_state, nil, nil))
                    (if (nil? s1)
                        ((ร RETURN) nil)
                    )

                    ((ร nfa_state_C s0 =) (alloc-state prog, start_state, (:fr_start e0), s1))
                    (if (nil? s0)
                        ((ร RETURN) nil)
                    )

                    (cond pattern
                    (do
                        ;; NFA_ZEND -> NFA_END_PATTERN -> NFA_SKIP -> what follows.
                        ((ร nfa_state_C skip =) (alloc-state prog, NFA_SKIP, nil, nil))
                        ((ร nfa_state_C zend =) (alloc-state prog, NFA_ZEND, s1, nil))
                        (.out0 s1 skip)
                        (fr-patch (:fr_out e0), zend)
                        (st-push stack, (alloc-frag s0, (fr-single (:out0 skip))))
                    )
                    :else
                    (do
                        (fr-patch (:fr_out e0), s1)
                        (st-push stack, (alloc-frag s0, (fr-single (:out0 s1))))
                        (when before
                            ;; See if we can guess the maximum width, it avoids a lot of pointless tries.
                            (if (<= n 0)
                                ((ร n =) (nfa-max-width (:fr_start e0), 0))
                            )
                            ((ร s0.val =) n) ;; store the count
                        )
                    ))
                    (ร BREAK)
                )

                ((ร CASE) NFA_COMPOSING)     ;; char with composing char
                (do
                    (when (flag? @regflags RF_ICOMBINE)
                        ;; TODO: use the base character only
                    )
                    (ร FALLTHROUGH)
                )

                ((ร CASE) NFA_MOPEN) ;; \( \) Submatch
                ((ร CASE) NFA_MOPEN1)
                ((ร CASE) NFA_MOPEN2)
                ((ร CASE) NFA_MOPEN3)
                ((ร CASE) NFA_MOPEN4)
                ((ร CASE) NFA_MOPEN5)
                ((ร CASE) NFA_MOPEN6)
                ((ร CASE) NFA_MOPEN7)
                ((ร CASE) NFA_MOPEN8)
                ((ร CASE) NFA_MOPEN9)
                ((ร CASE) NFA_ZOPEN) ;; \z( \) Submatch
                ((ร CASE) NFA_ZOPEN1)
                ((ร CASE) NFA_ZOPEN2)
                ((ร CASE) NFA_ZOPEN3)
                ((ร CASE) NFA_ZOPEN4)
                ((ร CASE) NFA_ZOPEN5)
                ((ร CASE) NFA_ZOPEN6)
                ((ร CASE) NFA_ZOPEN7)
                ((ร CASE) NFA_ZOPEN8)
                ((ร CASE) NFA_ZOPEN9)
                ((ร CASE) NFA_NOPEN) ;; \%( \) "Invisible Submatch"
                (do
                    (when nfa_calc_size
                        ((ร prog.nstate =) (+ (:nstate prog) 2))
                        (ร BREAK)
                    )

                    ((ร int mopen =) (ร postfix[i], mclose))
                    ((ร SWITCH) (... postfix i)
                        ((ร CASE) NFA_NOPEN)
                        (do
                            ((ร mclose =) NFA_NCLOSE)
                            (ร BREAK)
                        )
                        ((ร CASE) NFA_ZOPEN)
                        (do
                            ((ร mclose =) NFA_ZCLOSE)
                            (ร BREAK)
                        )
                        ((ร CASE) NFA_ZOPEN1)
                        (do
                            ((ร mclose =) NFA_ZCLOSE1)
                            (ร BREAK)
                        )
                        ((ร CASE) NFA_ZOPEN2)
                        (do
                            ((ร mclose =) NFA_ZCLOSE2)
                            (ร BREAK)
                        )
                        ((ร CASE) NFA_ZOPEN3)
                        (do
                            ((ร mclose =) NFA_ZCLOSE3)
                            (ร BREAK)
                        )
                        ((ร CASE) NFA_ZOPEN4)
                        (do
                            ((ร mclose =) NFA_ZCLOSE4)
                            (ร BREAK)
                        )
                        ((ร CASE) NFA_ZOPEN5)
                        (do
                            ((ร mclose =) NFA_ZCLOSE5)
                            (ร BREAK)
                        )
                        ((ร CASE) NFA_ZOPEN6)
                        (do
                            ((ร mclose =) NFA_ZCLOSE6)
                            (ร BREAK)
                        )
                        ((ร CASE) NFA_ZOPEN7)
                        (do
                            ((ร mclose =) NFA_ZCLOSE7)
                            (ร BREAK)
                        )
                        ((ร CASE) NFA_ZOPEN8)
                        (do
                            ((ร mclose =) NFA_ZCLOSE8)
                            (ร BREAK)
                        )
                        ((ร CASE) NFA_ZOPEN9)
                        (do
                            ((ร mclose =) NFA_ZCLOSE9)
                            (ร BREAK)
                        )
                        ((ร CASE) NFA_COMPOSING)
                        (do
                            ((ร mclose =) NFA_END_COMPOSING)
                            (ร BREAK)
                        )
                        (ร DEFAULT)
                        (do
                            ;; NFA_MOPEN, NFA_MOPEN1 .. NFA_MOPEN9
                            ((ร mclose =) (+ (... postfix i) NSUBEXP))
                            (ร BREAK)
                        )
                    )

                    ;; Allow "NFA_MOPEN" as a valid postfix representation for the empty regexp "".
                    ;; In this case, the NFA will be NFA_MOPEN -> NFA_MCLOSE.  Note that this also
                    ;; allows empty groups of parenthesis, and empty mbyte chars.
                    (when (zero? (:st_next stack))
                        ((ร nfa_state_C s0 =) (alloc-state prog, mopen, nil, nil))
                        (if (nil? s0)
                            ((ร RETURN) nil)
                        )
                        ((ร nfa_state_C s1 =) (alloc-state prog, mclose, nil, nil))
                        (if (nil? s1)
                            ((ร RETURN) nil)
                        )
                        (fr-patch (fr-single (:out0 s0)), s1)
                        (st-push stack, (alloc-frag s0, (fr-single (:out0 s1))))
                        (ร BREAK)
                    )

                    ;; At least one node was emitted before NFA_MOPEN, so
                    ;; at least one node will be between NFA_MOPEN and NFA_MCLOSE.
                    ((ร frag_C e0 =) (st-pop stack))
                    (if (nil? e0)
                        ((ร RETURN) (st-error postfix, i, over))
                    )
                    ((ร nfa_state_C s0 =) (alloc-state prog, mopen, (:fr_start e0), nil))   ;; `('
                    (if (nil? s0)
                        ((ร RETURN) nil)
                    )

                    ((ร nfa_state_C s1 =) (alloc-state prog, mclose, nil, nil))         ;; `)'
                    (if (nil? s1)
                        ((ร RETURN) nil)
                    )
                    (fr-patch (:fr_out e0), s1)

                    (when (== mopen NFA_COMPOSING)
                        ;; COMPOSING.out1 = END_COMPOSING
                        (fr-patch (fr-single (:out1 s0)), s1)
                    )

                    (st-push stack, (alloc-frag s0, (fr-single (:out0 s1))))
                    (ร BREAK)
                )

                ((ร CASE) NFA_BACKREF1)
                ((ร CASE) NFA_BACKREF2)
                ((ร CASE) NFA_BACKREF3)
                ((ร CASE) NFA_BACKREF4)
                ((ร CASE) NFA_BACKREF5)
                ((ร CASE) NFA_BACKREF6)
                ((ร CASE) NFA_BACKREF7)
                ((ร CASE) NFA_BACKREF8)
                ((ร CASE) NFA_BACKREF9)
                ((ร CASE) NFA_ZREF1)
                ((ร CASE) NFA_ZREF2)
                ((ร CASE) NFA_ZREF3)
                ((ร CASE) NFA_ZREF4)
                ((ร CASE) NFA_ZREF5)
                ((ร CASE) NFA_ZREF6)
                ((ร CASE) NFA_ZREF7)
                ((ร CASE) NFA_ZREF8)
                ((ร CASE) NFA_ZREF9)
                (do
                    (when nfa_calc_size
                        ((ร prog.nstate =) (+ (:nstate prog) 2))
                        (ร BREAK)
                    )

                    ((ร nfa_state_C s0 =) (alloc-state prog, (... postfix i), nil, nil))
                    (if (nil? s0)
                        ((ร RETURN) nil)
                    )
                    ((ร nfa_state_C s1 =) (alloc-state prog, NFA_SKIP, nil, nil))
                    (if (nil? s1)
                        ((ร RETURN) nil)
                    )
                    (fr-patch (fr-single (:out0 s0)), s1)
                    (st-push stack, (alloc-frag s0, (fr-single (:out0 s1))))
                    (ร BREAK)
                )

                ((ร CASE) NFA_LNUM)
                ((ร CASE) NFA_LNUM_GT)
                ((ร CASE) NFA_LNUM_LT)
                ((ร CASE) NFA_VCOL)
                ((ร CASE) NFA_VCOL_GT)
                ((ร CASE) NFA_VCOL_LT)
                ((ร CASE) NFA_COL)
                ((ร CASE) NFA_COL_GT)
                ((ร CASE) NFA_COL_LT)
                ((ร CASE) NFA_MARK)
                ((ร CASE) NFA_MARK_GT)
                ((ร CASE) NFA_MARK_LT)
                (do
                    ((ร int n =) (... postfix (ร ++i))) ;; lnum, col or mark name

                    (when nfa_calc_size
                        ((ร prog.nstate =) (+ (:nstate prog) 1))
                        (ร BREAK)
                    )

                    ((ร nfa_state_C s0 =) (alloc-state prog, (... postfix (dec i)), nil, nil))
                    (if (nil? s0)
                        ((ร RETURN) nil)
                    )
                    ((ร s0.val =) n)
                    (st-push stack, (alloc-frag s0, (fr-single (:out0 s0))))
                    (ร BREAK)
                )

                ((ร CASE) NFA_ZSTART)
                ((ร CASE) NFA_ZEND)
                (ร DEFAULT)
                (do
                    ;; Operands.
                    (when nfa_calc_size
                        (ร prog.nstate++)
                        (ร BREAK)
                    )

                    ((ร nfa_state_C s0 =) (alloc-state prog, (... postfix i), nil, nil))
                    (if (nil? s0)
                        ((ร RETURN) nil)
                    )
                    (st-push stack, (alloc-frag s0, (fr-single (:out0 s0))))
                    (ร BREAK)
                )
            )
        )

        (when nfa_calc_size
            (ร prog.nstate++)
            ((ร RETURN) nil)  ;; Return value when counting size is ignored anyway.
        )

        ((ร frag_C e0 =) (st-pop stack))
        (if (nil? e0)
            ((ร RETURN) (st-error postfix, i, over))
        )
        (when (< 0 (:st_next stack))
            (emsg (u8 "E875: (NFA regexp) (While converting from postfix to NFA), too many states left on stack"))
            (reset! rc_did_emsg true)
            ((ร RETURN) nil)
        )

        (when (<= (:nstate prog) (:istate prog))
            (emsg (u8 "E876: (NFA regexp) Not enough space to store the whole NFA"))
            (reset! rc_did_emsg true)
            ((ร RETURN) nil)
        )

        ((ร nfa_state_C state =) (ร @nfa_states[prog.istate++] =) (NEW_nfa_state_C))
        ((ร state.c =) NFA_MATCH)
        (.out0 state nil)
        (.out1 state nil)
        ((ร state.id =) 0)

        (fr-patch (:fr_out e0), state)
        (:fr_start e0)
    ))

;; After building the NFA program, inspect it to add optimization hints.

(defn- #_void nfa-postprocess [#_nfa_regprog_C prog]
    (ยง
        (dotimes [#_int i (:nstate prog)]
            ((ร nfa_state_C state =) (... (:states prog) i))
            (if (nil? state)
                (ร CONTINUE)
            )

            ((ร int c =) (:c state))
            (when (or (== c NFA_START_INVISIBLE) (== c NFA_START_INVISIBLE_NEG) (== c NFA_START_INVISIBLE_BEFORE) (== c NFA_START_INVISIBLE_BEFORE_NEG))
                (ร boolean directly)

                ;; Do it directly when what follows is possibly the end of the match.
                (cond (match-follows (.. state (out1) (out0)), 0)
                (do
                    ((ร directly =) true)
                )
                :else
                (do
                    ((ร int ch_invisible =) (failure-chance (.out0 state), 0))
                    ((ร int ch_follows =) (failure-chance (.. state (out1) (out0)), 0))

                    ;; Postpone when the invisible match is expensive or has a lower chance of failing.
                    (cond (or (== c NFA_START_INVISIBLE_BEFORE) (== c NFA_START_INVISIBLE_BEFORE_NEG))
                    (do
                        ;; "before" matches are very expensive when unbounded,
                        ;; always prefer what follows then, unless what follows will always match.
                        ;; Otherwise strongly prefer what follows.
                        ((ร directly =) (if (and (<= (:val state) 0) (< 0 ch_follows)) false (< (* ch_follows 10) ch_invisible)))
                    )
                    :else
                    (do
                        ;; normal invisible, first do the one with the highest failure chance
                        ((ร directly =) (< ch_follows ch_invisible))
                    ))
                ))
                (when directly
                    ;; switch to the _FIRST state
                    (ร state.c++)
                )
            )
        )
        nil
    ))

;; NFA execution code.

(class! #_final multipos_C
    [
        (field long         start_lnum)
        (field long         end_lnum)
        (field int          start_col)
        (field int          end_col)
    ])

(defn- #_void MIN1-multipos [#_multipos_C mp]
    (ยง
        ((ร mp.start_lnum =) -1)
        ((ร mp.end_lnum =) -1)
        ((ร mp.start_col =) -1)
        ((ร mp.end_col =) -1)
        nil
    ))

(defn- #_void COPY-multipos [#_multipos_C mp1, #_multipos_C mp0]
    (ยง
        ((ร mp1.start_lnum =) (:start_lnum mp0))
        ((ร mp1.end_lnum =) (:end_lnum mp0))
        ((ร mp1.start_col =) (:start_col mp0))
        ((ร mp1.end_col =) (:end_col mp0))
        nil
    ))

(defn- #_multipos_C* ARRAY-multipos [#_int n]
    (vec (repeatedly n NEW_multipos_C)))

(defn- #_void COPY--multipos [#_multipos_C* a1, #_multipos_C* a0, #_int n]
    (dotimes [#_int i n]
        (COPY-multipos (... a1 i), (... a0 i))
    )
    nil)

(class! #_final linepos_C
    [
        (field Bytes        start)
        (field Bytes        end)
    ])

(defn- #_void ZER0-linepos [#_linepos_C lp]
    (ยง
        ((ร lp.start =) nil)
        ((ร lp.end =) nil)
        nil
    ))

(defn- #_void COPY-linepos [#_linepos_C lp1, #_linepos_C lp0]
    (ยง
        ((ร lp1.start =) (:start lp0))
        ((ร lp1.end =) (:end lp0))
        nil
    ))

(defn- #_linepos_C* ARRAY-linepos [#_int n]
    (vec (repeatedly n NEW_linepos_C)))

(defn- #_void COPY--linepos [#_linepos_C* a1, #_linepos_C* a0, #_int n]
    (dotimes [#_int i n]
        (COPY-linepos (... a1 i), (... a0 i))
    )
    nil)

(class! #_final regsub_C
    [
        (field int          in_use)         ;; number of subexpr with useful info

        (field multipos_C*  rs_multi    (ARRAY-multipos NSUBEXP))   ;; union: when reg_match == null
        (field linepos_C*   rs_line     (ARRAY-linepos NSUBEXP))    ;; union: when reg_match != null
    ])

(defn- #_void COPY-regsub [#_regsub_C rs1, #_regsub_C rs0]
    (ยง
        ((ร rs1.in_use =) (:in_use rs0))

        (COPY--multipos (:rs_multi rs1), (:rs_multi rs0), NSUBEXP)
        (COPY--linepos (:rs_line rs1), (:rs_line rs0), NSUBEXP)
        nil
    ))

(class! #_final regsubs_C
    [
        (field regsub_C     rs_norm     (NEW_regsub_C))   ;; \( .. \) matches
        (field regsub_C     rs_synt     (NEW_regsub_C))   ;; \z( .. \) matches
    ])

(defn- #_void COPY-regsubs [#_regsubs_C rs1, #_regsubs_C rs0]
    (COPY-regsub (:rs_norm rs1), (:rs_norm rs0))
    (COPY-regsub (:rs_synt rs1), (:rs_synt rs0))
    nil)

;; nfa_pim_C stores a Postponed Invisible Match.
(class! #_final nfa_pim_C
    [
        (field int          result)         ;; NFA_PIM_*, see below
        (field nfa_state_C  state)          ;; the invisible match start state
        (field regsubs_C    np_subs     (NEW_regsubs_C))  ;; submatch info, only party used

        (field lpos_C       end_pos     (NEW_lpos_C))     ;; union upon reg_match: where the match must end
        (field Bytes        end_ptr)        ;; union upon reg_match: where the match must end
    ])

(defn- #_void COPY-nfa-pim [#_nfa_pim_C np1, #_nfa_pim_C np0]
    (ยง
        ((ร np1.result =) (:result np0))
        ((ร np1.state =) (:state np0))
        (COPY-regsubs (:np_subs np1), (:np_subs np0))

        (COPY-lpos (:end_pos np1), (:end_pos np0))
        ((ร np1.end_ptr =) (:end_ptr np0))
        nil
    ))

;; Values for done in nfa_pim_C.
(final int NFA_PIM_UNUSED   0)      ;; pim not used
(final int NFA_PIM_TODO     1)      ;; pim not done yet
(final int NFA_PIM_MATCH    2)      ;; pim executed, matches
(final int NFA_PIM_NOMATCH  3)      ;; pim executed, no match

;; nfa_thread_C contains execution information of a NFA state
(class! #_final nfa_thread_C
    [
        (field nfa_state_C  state)
        (field int          count)
        (field nfa_pim_C    th_pim      (NEW_nfa_pim_C))  ;; if pim.result != NFA_PIM_UNUSED: postponed invisible match
        (field regsubs_C    th_subs     (NEW_regsubs_C))  ;; submatch info, only party used
    ])

(defn- #_void COPY-nfa-thread [#_nfa_thread_C th1, #_nfa_thread_C th0]
    (ยง
        ((ร th1.state =) (:state th0))
        ((ร th1.count =) (:count th0))
        (COPY-nfa-pim (:th_pim th1), (:th_pim th0))
        (COPY-regsubs (:th_subs th1), (:th_subs th0))
        nil
    ))

(defn- #_nfa_thread_C* ARRAY-nfa-thread [#_int n]
    (vec (repeatedly n NEW_nfa_thread_C)))

;; nfa_list_C contains the alternative NFA execution states.
(class! #_final nfa_list_C
    [
        (field nfa_thread_C*    threads)        ;; allocated array of states
        (field int              n)              ;; nr of states currently in "t"
        (field int              len)            ;; max nr of states in "t"
        (field int              id)             ;; ID of the list
        (field boolean          has_pim)        ;; true when any state has a PIM
    ])

(defn- #_nfa_list_C* ARRAY-nfa-list [#_int n]
    (vec (repeatedly n NEW_nfa_list_C)))

;; Used during execution: whether a match has been found.
(atom! int nfa_match)
(atom! long nfa_time_limit)
(atom! int nfa_time_count)

;; Copy postponed invisible match info from "from" to "to".

(defn- #_void copy-pim [#_nfa_pim_C to, #_nfa_pim_C from]
    (ยง
        ((ร to.result =) (:result from))
        ((ร to.state =) (:state from))
        (copy-sub (:rs_norm (:np_subs to)), (:rs_norm (:np_subs from)))
        (if @nfa_has_zsubexpr
            (copy-sub (:rs_synt (:np_subs to)), (:rs_synt (:np_subs from))))
        (COPY-lpos (:end_pos to), (:end_pos from))
        ((ร to.end_ptr =) (:end_ptr from))
        nil
    ))

(defn- #_void clear-sub [#_regsub_C sub]
    (ยง
        (cond (nil? @reg_match)
        (do
            ;; Use 0xff to set lnum to -1.
            (dotimes [#_int i @nfa_nsubexpr]
                (MIN1-multipos (... (:rs_multi sub) i))
            )
        )
        :else
        (do
            (dotimes [#_int i @nfa_nsubexpr]
                (ZER0-linepos (... (:rs_line sub) i))
            )
        ))
        ((ร sub.in_use =) 0)
        nil
    ))

;; Copy the submatches from "from" to "to".

(defn- #_void copy-sub [#_regsub_C to, #_regsub_C from]
    (ยง
        ((ร to.in_use =) (:in_use from))
        (when (< 0 (:in_use from))
            ;; Copy the match start and end positions.
            (cond (nil? @reg_match)
            (do
                (dotimes [#_int i (:in_use from)]
                    (COPY-multipos (... (:rs_multi to) i), (... (:rs_multi from) i))
                )
            )
            :else
            (do
                (dotimes [#_int i (:in_use from)]
                    (COPY-linepos (... (:rs_line to) i), (... (:rs_line from) i))
                )
            ))
        )
        nil
    ))

;; Like copy-sub() but exclude the main match.

(defn- #_void copy-sub-off [#_regsub_C to, #_regsub_C from]
    (ยง
        (if (< (:in_use to) (:in_use from))
            ((ร to.in_use =) (:in_use from))
        )
        (when (< 1 (:in_use from))
            ;; Copy the match start and end positions.
            (cond (nil? @reg_match)
            (do
                ((ร FOR) (ร ((ร int i =) 1) (< i (:in_use from)) (ร i++))
                    (COPY-multipos (... (:rs_multi to) i), (... (:rs_multi from) i))
                )
            )
            :else
            (do
                ((ร FOR) (ร ((ร int i =) 1) (< i (:in_use from)) (ร i++))
                    (COPY-linepos (... (:rs_line to) i), (... (:rs_line from) i))
                )
            ))
        )
        nil
    ))

;; Like copy-sub() but only do the end of the main match if \ze is present.

(defn- #_void copy-ze-off [#_regsub_C to, #_regsub_C from]
    (ยง
        (when @nfa_has_zend
            (cond (nil? @reg_match)
            (do
                (when (<= 0 (:end_lnum (... (:rs_multi from) 0)))
                    ((ร to.rs_multi[0].end_lnum =) (:end_lnum (... (:rs_multi from) 0)))
                    ((ร to.rs_multi[0].end_col =) (:end_col (... (:rs_multi from) 0)))
                )
            )
            :else
            (do
                (if (non-nil? (:end (... (:rs_line from) 0)))
                    ((ร to.rs_line[0].end =) (:end (... (:rs_line from) 0)))
                )
            ))
        )
        nil
    ))

;; Return true if "sub1" and "sub2" have the same start positions.
;; When using back-references also check the end position.

(defn- #_boolean sub-equal [#_regsub_C sub1, #_regsub_C sub2]
    (ยง
        ((ร int todo =) (if (< (:in_use sub2) (:in_use sub1)) (:in_use sub1) (:in_use sub2)))

        (cond (nil? @reg_match)
        (do
            (dotimes [#_int i todo]
                ((ร long s1 =) (if (< i (:in_use sub1)) (:start_lnum (... (:rs_multi sub1) i)) -1))
                ((ร long s2 =) (if (< i (:in_use sub2)) (:start_lnum (... (:rs_multi sub2) i)) -1))
                (if (!= s1 s2)
                    ((ร RETURN) false)
                )
                (if (and (!= s1 -1) (!= (:start_col (... (:rs_multi sub1) i)) (:start_col (... (:rs_multi sub2) i))))
                    ((ร RETURN) false)
                )

                (when @nfa_has_backref
                    ((ร s1 =) (if (< i (:in_use sub1)) (:end_lnum (... (:rs_multi sub1) i)) -1))
                    ((ร s2 =) (if (< i (:in_use sub2)) (:end_lnum (... (:rs_multi sub2) i)) -1))
                    (if (!= s1 s2)
                        ((ร RETURN) false)
                    )
                    (if (and (!= s1 -1) (!= (:end_col (... (:rs_multi sub1) i)) (:end_col (... (:rs_multi sub2) i))))
                        ((ร RETURN) false)
                    )
                )
            )
        )
        :else
        (do
            (dotimes [#_int i todo]
                ((ร Bytes sp1 =) (if (< i (:in_use sub1)) (:start (... (:rs_line sub1) i)) nil))
                ((ร Bytes sp2 =) (if (< i (:in_use sub2)) (:start (... (:rs_line sub2) i)) nil))
                (if (BNE sp1, sp2)
                    ((ร RETURN) false)
                )
                (when @nfa_has_backref
                    ((ร sp1 =) (if (< i (:in_use sub1)) (:end (... (:rs_line sub1) i)) nil))
                    ((ร sp2 =) (if (< i (:in_use sub2)) (:end (... (:rs_line sub2) i)) nil))
                    (if (BNE sp1, sp2)
                        ((ร RETURN) false)
                    )
                )
            )
        ))

        true
    ))

;; Return true if the same state is already in list "nfl" with the same positions as "subs".

(defn- #_boolean has-state-with-pos [#_nfa_list_C nfl, #_nfa_state_C state, #_regsubs_C subs, #_nfa_pim_C pim]
    ;; nfl: runtime state list
    ;; state: state to update
    ;; subs: pointers to subexpressions
    ;; pim: postponed match or null
    (ยง
        (dotimes [#_int i (:n nfl)]
            ((ร nfa_thread_C thread =) (... (:threads nfl) i))

            (when (and (== (:id (:state thread)) (:id state)) (sub-equal (:rs_norm (:th_subs thread)), (:rs_norm subs)) (or (not @nfa_has_zsubexpr) (sub-equal (:rs_synt (:th_subs thread)), (:rs_synt subs))) (pim-equal (:th_pim thread), pim))
                ((ร RETURN) true)
            )
        )

        false
    ))

;; Return true if "one" and "two" are equal.  That includes when both are not set.

(defn- #_boolean pim-equal [#_nfa_pim_C one, #_nfa_pim_C two]
    (ยง
        ((ร boolean one_unused =) (or (nil? one) (== (:result one) NFA_PIM_UNUSED)))
        ((ร boolean two_unused =) (or (nil? two) (== (:result two) NFA_PIM_UNUSED)))

        (when one_unused
            ;; one is unused: equal when two is also unused
            ((ร RETURN) two_unused)
        )
        (when two_unused
            ;; one is used and two is not: not equal
            ((ร RETURN) false)
        )
        ;; compare the state id
        (if (!= (:id (:state one)) (:id (:state two)))
            ((ร RETURN) false)
        )
        ;; compare the position
        (if (nil? @reg_match)
            ((ร RETURN) (and (== (:lnum (:end_pos one)) (:lnum (:end_pos two))) (== (:col (:end_pos one)) (:col (:end_pos two)))))
        )

        (BEQ (:end_ptr one), (:end_ptr two))
    ))

;; Return true if "state" leads to a NFA_MATCH without advancing the input.

(defn- #_boolean match-follows [#_nfa_state_C startstate, #_int depth]
    (ยง
        ;; avoid too much recursion
        (if (< 10 depth)
            ((ร RETURN) false)
        )

        ((ร FOR) (ร ((ร nfa_state_C state =) startstate) (non-nil? state) nil)
            ((ร SWITCH) (:c state)
                ((ร CASE) NFA_MATCH)
                ((ร CASE) NFA_MCLOSE)
                ((ร CASE) NFA_END_INVISIBLE)
                ((ร CASE) NFA_END_INVISIBLE_NEG)
                ((ร CASE) NFA_END_PATTERN)
                (do
                    ((ร RETURN) true)
                )

                ((ร CASE) NFA_SPLIT)
                (do
                    ((ร RETURN) (or (match-follows (.out0 state), (inc depth)) (match-follows (.out1 state), (inc depth))))
                )

                ((ร CASE) NFA_START_INVISIBLE)
                ((ร CASE) NFA_START_INVISIBLE_FIRST)
                ((ร CASE) NFA_START_INVISIBLE_BEFORE)
                ((ร CASE) NFA_START_INVISIBLE_BEFORE_FIRST)
                ((ร CASE) NFA_START_INVISIBLE_NEG)
                ((ร CASE) NFA_START_INVISIBLE_NEG_FIRST)
                ((ร CASE) NFA_START_INVISIBLE_BEFORE_NEG)
                ((ร CASE) NFA_START_INVISIBLE_BEFORE_NEG_FIRST)
                ((ร CASE) NFA_COMPOSING)
                (do
                    ;; skip ahead to next state
                    ((ร state =) (.. state (out1) (out0)))
                    (ร CONTINUE)
                )

                ((ร CASE) NFA_ANY)
                ((ร CASE) NFA_ANY_COMPOSING)
                ((ร CASE) NFA_IDENT)
                ((ร CASE) NFA_SIDENT)
                ((ร CASE) NFA_KWORD)
                ((ร CASE) NFA_SKWORD)
                ((ร CASE) NFA_FNAME)
                ((ร CASE) NFA_SFNAME)
                ((ร CASE) NFA_PRINT)
                ((ร CASE) NFA_SPRINT)
                ((ร CASE) NFA_WHITE)
                ((ร CASE) NFA_NWHITE)
                ((ร CASE) NFA_DIGIT)
                ((ร CASE) NFA_NDIGIT)
                ((ร CASE) NFA_HEX)
                ((ร CASE) NFA_NHEX)
                ((ร CASE) NFA_OCTAL)
                ((ร CASE) NFA_NOCTAL)
                ((ร CASE) NFA_WORD)
                ((ร CASE) NFA_NWORD)
                ((ร CASE) NFA_HEAD)
                ((ร CASE) NFA_NHEAD)
                ((ร CASE) NFA_ALPHA)
                ((ร CASE) NFA_NALPHA)
                ((ร CASE) NFA_LOWER)
                ((ร CASE) NFA_NLOWER)
                ((ร CASE) NFA_UPPER)
                ((ร CASE) NFA_NUPPER)
                ((ร CASE) NFA_LOWER_IC)
                ((ร CASE) NFA_NLOWER_IC)
                ((ร CASE) NFA_UPPER_IC)
                ((ร CASE) NFA_NUPPER_IC)
                ((ร CASE) NFA_START_COLL)
                ((ร CASE) NFA_START_NEG_COLL)
                ((ร CASE) NFA_NEWL)
                (do
                    ;; state will advance input
                    ((ร RETURN) false)
                )

                (ร DEFAULT)
                (do
                    (when (< 0 (:c state))
                        ;; state will advance input
                        ((ร RETURN) false)
                    )

                    ;; Others: zero-width or possibly zero-width,
                    ;; might still find a match at the same position, keep looking.
                    (ร BREAK)
                )
            )
            ((ร state =) (.out0 state))
        )

        false
    ))

;; Return true if "state" is already in list "nfl".

(defn- #_boolean state-in-list [#_nfa_list_C nfl, #_nfa_state_C state, #_regsubs_C subs]
    ;; nfl: runtime state list
    ;; state: state to update
    ;; subs: pointers to subexpressions
    (ยง
        (when (== (... (:lastlist state) @nfa_ll_index) (:id nfl))
            (if (or (not @nfa_has_backref) (has-state-with-pos nfl, state, subs, nil))
                ((ร RETURN) true)
            )
        )

        false
    ))

(atom! regsubs_C temp_subs  (NEW_regsubs_C))

;; Add "state" and possibly what follows to state list ".".
;; Returns "subs_arg", possibly copied into temp_subs.

(defn- #_regsubs_C addstate [#_nfa_list_C nfl, #_nfa_state_C state, #_regsubs_C subs_arg, #_nfa_pim_C pim, #_int off]
    ;; nfl: runtime state list
    ;; state: state to update
    ;; subs_arg: pointers to subexpressions
    ;; pim: postponed look-behind match
    ;; off: byte offset, when -1 go to next line
    (ยง
        ((ร regsubs_C subs =) subs_arg)

        ((ร SWITCH) (:c state)
            ((ร CASE) NFA_NCLOSE)
            ((ร CASE) NFA_MCLOSE)
            ((ร CASE) NFA_MCLOSE1)
            ((ร CASE) NFA_MCLOSE2)
            ((ร CASE) NFA_MCLOSE3)
            ((ร CASE) NFA_MCLOSE4)
            ((ร CASE) NFA_MCLOSE5)
            ((ร CASE) NFA_MCLOSE6)
            ((ร CASE) NFA_MCLOSE7)
            ((ร CASE) NFA_MCLOSE8)
            ((ร CASE) NFA_MCLOSE9)
            ((ร CASE) NFA_ZCLOSE)
            ((ร CASE) NFA_ZCLOSE1)
            ((ร CASE) NFA_ZCLOSE2)
            ((ร CASE) NFA_ZCLOSE3)
            ((ร CASE) NFA_ZCLOSE4)
            ((ร CASE) NFA_ZCLOSE5)
            ((ร CASE) NFA_ZCLOSE6)
            ((ร CASE) NFA_ZCLOSE7)
            ((ร CASE) NFA_ZCLOSE8)
            ((ร CASE) NFA_ZCLOSE9)
            ((ร CASE) NFA_MOPEN)
            ((ร CASE) NFA_ZEND)
            ((ร CASE) NFA_SPLIT)
            ((ร CASE) NFA_EMPTY)
            (do
                ;; These nodes are not added themselves
                ;; but their "out0" and/or "out1" may be added below.
                (ร BREAK)
            )

            ((ร CASE) NFA_BOL)
            ((ร CASE) NFA_BOF)
            (do
                ;; "^" won't match past end-of-line, don't bother trying.
                ;; Except when at the end of the line, or when we are going
                ;; to the next line for a look-behind match.
                (when (and (BLT @regline, @reginput) (non-eos? @reginput) (or (nil? @nfa_endp) (non-nil? @reg_match) (== @reglnum (:lnum (:se_pos @nfa_endp)))))
                    ((ร RETURN) subs)
                )
                (ร FALLTHROUGH)
            )

            ((ร CASE) NFA_MOPEN1)
            ((ร CASE) NFA_MOPEN2)
            ((ร CASE) NFA_MOPEN3)
            ((ร CASE) NFA_MOPEN4)
            ((ร CASE) NFA_MOPEN5)
            ((ร CASE) NFA_MOPEN6)
            ((ร CASE) NFA_MOPEN7)
            ((ร CASE) NFA_MOPEN8)
            ((ร CASE) NFA_MOPEN9)
            ((ร CASE) NFA_ZOPEN)
            ((ร CASE) NFA_ZOPEN1)
            ((ร CASE) NFA_ZOPEN2)
            ((ร CASE) NFA_ZOPEN3)
            ((ร CASE) NFA_ZOPEN4)
            ((ร CASE) NFA_ZOPEN5)
            ((ร CASE) NFA_ZOPEN6)
            ((ร CASE) NFA_ZOPEN7)
            ((ร CASE) NFA_ZOPEN8)
            ((ร CASE) NFA_ZOPEN9)
            ((ร CASE) NFA_NOPEN)
            ((ร CASE) NFA_ZSTART)

                ;; These nodes need to be added so that we can bail out
                ;; when it was added to this list before at the same
                ;; position to avoid an endless loop for "\(\)*"

            (ร DEFAULT)
            (do
                (when (and (== (... (:lastlist state) @nfa_ll_index) (:id nfl)) (!= (:c state) NFA_SKIP))
                    ;; This state is already in the list, don't add it again,
                    ;; unless it is an MOPEN that is used for a backreference or
                    ;; when there is a PIM.  For NFA_MATCH check the position,
                    ;; lower position is preferred.
                    (if (and (not @nfa_has_backref) (nil? pim) (not (:has_pim nfl)) (!= (:c state) NFA_MATCH))
                        ((ร RETURN) subs)
                    )

                    ;; Do not add the state again when it exists with the same positions.
                    (if (has-state-with-pos nfl, state, subs, pim)
                        ((ร RETURN) subs)
                    )
                )

                ;; When there are backreferences or PIMs,
                ;; the number of states may be (a lot) bigger than anticipated.
                (when (== (:n nfl) (:len nfl))
                    (when (!= subs @temp_subs)
                        ;; "subs" may point into the current array,
                        ;; need to make a copy before it becomes invalid.
                        (copy-sub (:rs_norm @temp_subs), (:rs_norm subs))
                        (if @nfa_has_zsubexpr
                            (copy-sub (:rs_synt @temp_subs), (:rs_synt subs)))
                        ((ร subs =) @temp_subs)
                    )

                    ((ร int newlen =) (+ (/ (* (:len nfl) 3) 2) 50))
                    ((ร nfa_thread_C[] a =) (ARRAY-nfa-thread newlen))
                    (dotimes [#_int i (:n nfl)]
                        (COPY-nfa-thread (... a i), (... (:threads nfl) i))
                    )
                    ((ร nfl.threads =) a)
                    ((ร nfl.len =) newlen)
                )

                ;; add the state to the list
                ((ร state.lastlist[@nfa_ll_index] =) (:id nfl))
                ((ร nfa_thread_C thread =) (... (:threads nfl) (ร nfl.n++)))
                ((ร thread.state =) state)
                (cond (nil? pim)
                (do
                    ((ร thread.th_pim.result =) NFA_PIM_UNUSED)
                )
                :else
                (do
                    (copy-pim (:th_pim thread), pim)
                    ((ร nfl.has_pim =) true)
                ))
                (copy-sub (:rs_norm (:th_subs thread)), (:rs_norm subs))
                (if @nfa_has_zsubexpr
                    (copy-sub (:rs_synt (:th_subs thread)), (:rs_synt subs)))

                (ร BREAK)
            )
        )

        ((ร SWITCH) (:c state)
            ((ร CASE) NFA_MATCH)
            (do
                (ร BREAK)
            )

            ((ร CASE) NFA_SPLIT)
            (do
                ;; order matters here
                ((ร subs =) (addstate nfl, (.out0 state), subs, pim, off))
                ((ร subs =) (addstate nfl, (.out1 state), subs, pim, off))
                (ร BREAK)
            )

            ((ร CASE) NFA_EMPTY)
            ((ร CASE) NFA_NOPEN)
            ((ร CASE) NFA_NCLOSE)
            (do
                ((ร subs =) (addstate nfl, (.out0 state), subs, pim, off))
                (ร BREAK)
            )

            ((ร CASE) NFA_MOPEN)
            ((ร CASE) NFA_MOPEN1)
            ((ร CASE) NFA_MOPEN2)
            ((ร CASE) NFA_MOPEN3)
            ((ร CASE) NFA_MOPEN4)
            ((ร CASE) NFA_MOPEN5)
            ((ร CASE) NFA_MOPEN6)
            ((ร CASE) NFA_MOPEN7)
            ((ร CASE) NFA_MOPEN8)
            ((ร CASE) NFA_MOPEN9)
            ((ร CASE) NFA_ZOPEN)
            ((ร CASE) NFA_ZOPEN1)
            ((ร CASE) NFA_ZOPEN2)
            ((ร CASE) NFA_ZOPEN3)
            ((ร CASE) NFA_ZOPEN4)
            ((ร CASE) NFA_ZOPEN5)
            ((ร CASE) NFA_ZOPEN6)
            ((ร CASE) NFA_ZOPEN7)
            ((ร CASE) NFA_ZOPEN8)
            ((ร CASE) NFA_ZOPEN9)
            ((ร CASE) NFA_ZSTART)
            (do
                (ร int subidx)
                (ร regsub_C sub)
                (cond (== (:c state) NFA_ZSTART)
                (do
                    ((ร subidx =) 0)
                    ((ร sub =) (:rs_norm subs))
                )
                (and (<= NFA_ZOPEN (:c state)) (<= (:c state) NFA_ZOPEN9))
                (do
                    ((ร subidx =) (- (:c state) NFA_ZOPEN))
                    ((ร sub =) (:rs_synt subs))
                )
                :else
                (do
                    ((ร subidx =) (- (:c state) NFA_MOPEN))
                    ((ร sub =) (:rs_norm subs))
                ))

                ((ร lpos_C save_lpos =) (NEW_lpos_C))
                ((ร save_lpos.lnum =) 0)
                ((ร save_lpos.col =) 0)
                ((ร Bytes save_ptr =) nil)

                (ร int save_in_use)
                ;; Set the position (with "off" added) in the subexpression.
                ;; Save and restore it when it was in use.
                ;; Otherwise fill any gap.
                (cond (nil? @reg_match)
                (do
                    (cond (< subidx (:in_use sub))
                    (do
                        ((ร save_lpos.lnum =) (:start_lnum (... (:rs_multi sub) subidx)))
                        ((ร save_lpos.col =) (:start_col (... (:rs_multi sub) subidx)))
                        ((ร save_in_use =) -1)
                    )
                    :else
                    (do
                        ((ร save_in_use =) (:in_use sub))
                        ((ร FOR) (ร ((ร int i =) (:in_use sub)) (< i subidx) (ร i++))
                            ((ร sub.rs_multi[i].start_lnum =) -1)
                            ((ร sub.rs_multi[i].end_lnum =) -1)
                        )
                        ((ร sub.in_use =) (inc subidx))
                    ))
                    (cond (== off -1)
                    (do
                        ((ร sub.rs_multi[subidx].start_lnum =) (inc @reglnum))
                        ((ร sub.rs_multi[subidx].start_col =) 0)
                    )
                    :else
                    (do
                        ((ร sub.rs_multi[subidx].start_lnum =) @reglnum)
                        ((ร sub.rs_multi[subidx].start_col =) (+ (BDIFF @reginput, @regline) off))
                    ))
                )
                :else
                (do
                    (cond (< subidx (:in_use sub))
                    (do
                        ((ร save_ptr =) (:start (... (:rs_line sub) subidx)))
                        ((ร save_in_use =) -1)
                    )
                    :else
                    (do
                        ((ร save_in_use =) (:in_use sub))
                        ((ร FOR) (ร ((ร int i =) (:in_use sub)) (< i subidx) (ร i++))
                            ((ร sub.rs_line[i].start =) nil)
                            ((ร sub.rs_line[i].end =) nil)
                        )
                        ((ร sub.in_use =) (inc subidx))
                    ))
                    ((ร sub.rs_line[subidx].start =) (.plus @reginput off))
                ))

                ((ร subs =) (addstate nfl, (.out0 state), subs, pim, off))
                ;; "subs" may have changed, need to set "sub" again
                ((ร sub =) (if (<= NFA_ZOPEN (:c state) NFA_ZOPEN9) (:rs_synt subs) (:rs_norm subs)))

                (cond (== save_in_use -1)
                (do
                    (cond (nil? @reg_match)
                    (do
                        ((ร sub.rs_multi[subidx].start_lnum =) (:lnum save_lpos))
                        ((ร sub.rs_multi[subidx].start_col =) (:col save_lpos))
                    )
                    :else
                    (do
                        ((ร sub.rs_line[subidx].start =) save_ptr)
                    ))
                )
                :else
                (do
                    ((ร sub.in_use =) save_in_use)
                ))

                (ร BREAK)
            )

            ((ร CASE) NFA_MCLOSE)
            (do
                (when (and @nfa_has_zend (if (nil? @reg_match)) (<= 0 (:end_lnum (... (:rs_multi (:rs_norm subs)) 0))) (non-nil? (:end (... (:rs_line (:rs_norm subs)) 0))))
                    ;; Do not overwrite the position set by \ze.
                    ((ร subs =) (addstate nfl, (.out0 state), subs, pim, off))
                    (ร BREAK)
                )
            )
            ((ร CASE) NFA_MCLOSE1)
            ((ร CASE) NFA_MCLOSE2)
            ((ร CASE) NFA_MCLOSE3)
            ((ร CASE) NFA_MCLOSE4)
            ((ร CASE) NFA_MCLOSE5)
            ((ร CASE) NFA_MCLOSE6)
            ((ร CASE) NFA_MCLOSE7)
            ((ร CASE) NFA_MCLOSE8)
            ((ร CASE) NFA_MCLOSE9)
            ((ร CASE) NFA_ZCLOSE)
            ((ร CASE) NFA_ZCLOSE1)
            ((ร CASE) NFA_ZCLOSE2)
            ((ร CASE) NFA_ZCLOSE3)
            ((ร CASE) NFA_ZCLOSE4)
            ((ร CASE) NFA_ZCLOSE5)
            ((ร CASE) NFA_ZCLOSE6)
            ((ร CASE) NFA_ZCLOSE7)
            ((ร CASE) NFA_ZCLOSE8)
            ((ร CASE) NFA_ZCLOSE9)
            ((ร CASE) NFA_ZEND)
            (do
                (ร int subidx)
                (ร regsub_C sub)
                (cond (== (:c state) NFA_ZEND)
                (do
                    ((ร subidx =) 0)
                    ((ร sub =) (:rs_norm subs))
                )
                (and (<= NFA_ZCLOSE (:c state)) (<= (:c state) NFA_ZCLOSE9))
                (do
                    ((ร subidx =) (- (:c state) NFA_ZCLOSE))
                    ((ร sub =) (:rs_synt subs))
                )
                :else
                (do
                    ((ร subidx =) (- (:c state) NFA_MCLOSE))
                    ((ร sub =) (:rs_norm subs))
                ))

                ((ร lpos_C save_lpos =) (NEW_lpos_C))
                (ร Bytes save_ptr)

                ;; We don't fill in gaps here, there must have been an MOPEN that has done that.
                ((ร int save_in_use =) (:in_use sub))
                (if (<= (:in_use sub) subidx)
                    ((ร sub.in_use =) (inc subidx))
                )
                (cond (nil? @reg_match)
                (do
                    ((ร save_lpos.lnum =) (:end_lnum (... (:rs_multi sub) subidx)))
                    ((ร save_lpos.col =) (:end_col (... (:rs_multi sub) subidx)))
                    (cond (== off -1)
                    (do
                        ((ร sub.rs_multi[subidx].end_lnum =) (inc @reglnum))
                        ((ร sub.rs_multi[subidx].end_col =) 0)
                    )
                    :else
                    (do
                        ((ร sub.rs_multi[subidx].end_lnum =) @reglnum)
                        ((ร sub.rs_multi[subidx].end_col =) (+ (BDIFF @reginput, @regline) off))
                    ))
                    ((ร save_ptr =) nil)
                )
                :else
                (do
                    ((ร save_ptr =) (:end (... (:rs_line sub) subidx)))
                    ((ร sub.rs_line[subidx].end =) (.plus @reginput off))

                    ((ร save_lpos.lnum =) 0)
                    ((ร save_lpos.col =) 0)
                ))

                ((ร subs =) (addstate nfl, (.out0 state), subs, pim, off))
                ;; "subs" may have changed, need to set "sub" again
                ((ร sub =) (if (<= NFA_ZCLOSE (:c state) NFA_ZCLOSE9) (:rs_synt subs) (:rs_norm subs)))

                (cond (nil? @reg_match)
                (do
                    ((ร sub.rs_multi[subidx].end_lnum =) (:lnum save_lpos))
                    ((ร sub.rs_multi[subidx].end_col =) (:col save_lpos))
                )
                :else
                (do
                    ((ร sub.rs_line[subidx].end =) save_ptr)
                ))
                ((ร sub.in_use =) save_in_use)

                (ร BREAK)
            )
        )

        subs
    ))

;; Like addstate(), but the new state(s) are put at position "*ip".
;; Used for zero-width matches, next state to use is the added one.
;; This makes sure the order of states to be tried does not change,
;; which matters for alternatives.

(defn- #_void addstate-here [#_nfa_list_C nfl, #_nfa_state_C state, #_regsubs_C subs, #_nfa_pim_C pim, #_int* ip]
    ;; nfl: runtime state list
    ;; state: state to update
    ;; subs: pointers to subexpressions
    ;; pim: postponed look-behind match
    (ยง
        ((ร int tlen =) (:n nfl))
        ((ร int lidx =) (... ip 0))

        ;; first add the state(s) at the end, so that we know how many there are
        (addstate nfl, state, subs, pim, 0)

        ;; when "*ip" was at the end of the list, nothing to do
        (if (== (inc lidx) tlen)
            ((ร RETURN) nil)
        )

        ;; re-order to put the new state at the current position
        ((ร int count =) (- (:n nfl) tlen))
        (if (zero? count)
            ((ร RETURN) nil) ;; no state got added
        )

        (cond (== count 1)
        (do
            ;; overwrite the current state
            (COPY-nfa-thread (... (:threads nfl) lidx), (... (:threads nfl) (- (:n nfl) 1)))
        )
        (< 1 count)
        (do
            (cond (<= (:len nfl) (- (+ (:n nfl) count) 1))
            (do
                ;; not enough space to move the new states,
                ;; reallocate the list and move the states to the right position
                ((ร int newlen =) (+ (/ (* (:len nfl) 3) 2) 50))
                ((ร nfa_thread_C[] a =) (ARRAY-nfa-thread newlen))
                (dotimes [#_int i lidx]
                    (COPY-nfa-thread (... a i), (... (:threads nfl) i))
                )
                (dotimes [#_int i count]
                    (COPY-nfa-thread (... a (+ lidx i)), (... (:threads nfl) (+ (- (:n nfl) count) i)))
                )
                ((ร FOR) (ร ((ร int i =) 0) (< i (- (:n nfl) count lidx 1)) (ร i++))
                    (COPY-nfa-thread (... a (+ lidx count i)), (... (:threads nfl) (+ lidx 1 i)))
                )
                ((ร nfl.threads =) a)
                ((ร nfl.len =) newlen)
            )
            :else
            (do
                ;; make space for new states, then move them from the end to the current position
                ((ร FOR) (ร ((ร int i =) (:n nfl)) (<= (inc lidx) (ร --i)) nil)
                    (COPY-nfa-thread (... (:threads nfl) (dec (+ i count))), (... (:threads nfl) i))
                )
                (dotimes [#_int i count]
                    (COPY-nfa-thread (... (:threads nfl) (+ lidx i)), (... (:threads nfl) (+ (dec (:n nfl)) i)))
                )
            ))
        ))

        (ร --nfl.n)
        ((ร ip[0] =) (dec lidx))
        nil
    ))

;; Check character class "class" against current character c.

(defn- #_boolean check-char-class [#_int klass, #_int c]
    (ยง
        ((ร SWITCH) klass
            ((ร CASE) NFA_CLASS_ALNUM)
            (do
                (if (and (<= 1 c) (<= c 255) (asc-isalnum c))
                    ((ร RETURN) true)
                )
                (ร BREAK)
            )

            ((ร CASE) NFA_CLASS_ALPHA)
            (do
                (if (and (<= 1 c) (<= c 255) (asc-isalpha c))
                    ((ร RETURN) true)
                )
                (ร BREAK)
            )

            ((ร CASE) NFA_CLASS_BLANK)
            (do
                (if (or (== c (byte \space)) (== c TAB))
                    ((ร RETURN) true)
                )
                (ร BREAK)
            )

            ((ร CASE) NFA_CLASS_CNTRL)
            (do
                (if (and (<= 1 c) (<= c 255) (asc-iscntrl c))
                    ((ร RETURN) true)
                )
                (ร BREAK)
            )

            ((ร CASE) NFA_CLASS_DIGIT)
            (do
                (if (asc-isdigit c)
                    ((ร RETURN) true)
                )
                (ร BREAK)
            )

            ((ร CASE) NFA_CLASS_GRAPH)
            (do
                (if (and (<= 1 c) (<= c 255) (asc-isgraph c))
                    ((ร RETURN) true)
                )
                (ร BREAK)
            )

            ((ร CASE) NFA_CLASS_LOWER)
            (do
                (if (utf-islower c)
                    ((ร RETURN) true)
                )
                (ร BREAK)
            )

            ((ร CASE) NFA_CLASS_PRINT)
            (do
                (if (vim-isprintc c)
                    ((ร RETURN) true)
                )
                (ร BREAK)
            )

            ((ร CASE) NFA_CLASS_PUNCT)
            (do
                (if (and (<= 1 c) (<= c 255) (asc-ispunct c))
                    ((ร RETURN) true)
                )
                (ร BREAK)
            )

            ((ร CASE) NFA_CLASS_SPACE)
            (do
                (if (or (<= 9 c 13) (== c (byte \space)))
                    ((ร RETURN) true)
                )
                (ร BREAK)
            )

            ((ร CASE) NFA_CLASS_UPPER)
            (do
                (if (utf-isupper c)
                    ((ร RETURN) true)
                )
                (ร BREAK)
            )

            ((ร CASE) NFA_CLASS_XDIGIT)
            (do
                (if (asc-isxdigit c)
                    ((ร RETURN) true)
                )
                (ร BREAK)
            )

            ((ร CASE) NFA_CLASS_TAB)
            (do
                (if (== c TAB)
                    ((ร RETURN) true)
                )
                (ร BREAK)
            )

            ((ร CASE) NFA_CLASS_RETURN)
            (do
                (if (== c (byte \return))
                    ((ร RETURN) true)
                )
                (ร BREAK)
            )

            ((ร CASE) NFA_CLASS_BACKSPACE)
            (do
                (if (== c (byte \backspace))
                    ((ร RETURN) true)
                )
                (ร BREAK)
            )

            ((ร CASE) NFA_CLASS_ESCAPE)
            (do
                (if (== c ESC)
                    ((ร RETURN) true)
                )
                (ร BREAK)
            )

            (ร DEFAULT)
            (do
                ;; should not be here :P
                (emsgn e_ill_char_class, (long klass))
                ((ร RETURN) false)
            )
        )

        false
    ))

;; Check for a match with subexpression "subidx".
;; Return true if it matches.

(defn- #_boolean match-backref [#_regsub_C sub, #_int subidx, #_int* bytelen]
    ;; sub: pointers to subexpressions
    ;; bytelen: out: length of match in bytes
    (ยง
        (when (<= (:in_use sub) subidx)
            ;; backref was not set, match an empty string
            ((ร bytelen[0] =) 0)
            ((ร RETURN) true)
        )

        (cond (nil? @reg_match)
        (do
            (when (or (< (:start_lnum (... (:rs_multi sub) subidx)) 0) (< (:end_lnum (... (:rs_multi sub) subidx)) 0))
                ;; backref was not set, match an empty string
                ((ร bytelen[0] =) 0)
                ((ร RETURN) true)
            )
            (cond (and (== (:start_lnum (... (:rs_multi sub) subidx)) @reglnum) (== (:end_lnum (... (:rs_multi sub) subidx)) @reglnum))
            (do
; %%            ((ร int[] len =) (ร { (sub.rs_multi[subidx].end_col) - (sub.rs_multi[subidx].start_col) }))
                (when (zero? (cstrncmp (.plus @regline (:start_col (... (:rs_multi sub) subidx))), @reginput, len))
                    ((ร bytelen[0] =) (... len 0))
                    ((ร RETURN) true)
                )
            )
            :else
            (do
                (when (== (match-with-backref (:start_lnum (... (:rs_multi sub) subidx)), (:start_col (... (:rs_multi sub) subidx)), (:end_lnum (... (:rs_multi sub) subidx)), (:end_col (... (:rs_multi sub) subidx)), bytelen) RA_MATCH)
                    ((ร RETURN) true)
                )
            ))
        )
        :else
        (do
            (when (or (nil? (:start (... (:rs_line sub) subidx))) (nil? (:end (... (:rs_line sub) subidx))))
                ;; backref was not set, match an empty string
                ((ร bytelen[0] =) 0)
                ((ร RETURN) true)
            )
; %%        ((ร int[] len =) (ร { BDIFF(sub.rs_line[subidx].end, sub.rs_line[subidx].start) }))
            (when (zero? (cstrncmp (:start (... (:rs_line sub) subidx)), @reginput, len))
                ((ร bytelen[0] =) (... len 0))
                ((ร RETURN) true)
            )
        ))

        false
    ))

;; Check for a match with \z subexpression "subidx".
;; Return true if it matches.

(defn- #_boolean match-zref [#_int subidx, #_int* bytelen]
    ;; bytelen: out: length of match in bytes
    (ยง
        (cleanup-zsubexpr)

        (when (or (nil? @re_extmatch_in) (nil? (... (:matches @re_extmatch_in) subidx)))
            ;; backref was not set, match an empty string
            ((ร bytelen[0] =) 0)
            ((ร RETURN) true)
        )

; %%    ((ร int[] len =) (ร { STRLEN(@re_extmatch_in.matches[subidx]) }))
        (when (zero? (cstrncmp (... (:matches @re_extmatch_in) subidx), @reginput, len))
            ((ร bytelen[0] =) (... len 0))
            ((ร RETURN) true)
        )

        false
    ))

;; Save list IDs for all NFA states of "prog" into "list".
;; Also reset the IDs to zero.
;; Only used for the recursive value lastlist[1].

(defn- #_void nfa-save-listids [#_nfa_regprog_C prog, #_int* list]
    (ยง
        ;; Order in the list is reverse, it's a bit faster that way.
        ((ร FOR) (ร ((ร int i =) (ร 0, n = (prog.nstate))) (<= 0 (ร --n)) (ร i++))
            ((ร nfa_state_C state =) (... (:states prog) i))
            (when (nil? state)
                ((ร list[n] =) 0)
                (ร CONTINUE)
            )

            ((ร list[n] =) (... (:lastlist state) 1))
            ((ร state.lastlist[1] =) 0)
        )
        nil
    ))

;; Restore list IDs from "list" to all NFA states.

(defn- #_void nfa-restore-listids [#_nfa_regprog_C prog, #_int* list]
    (ยง
        ((ร FOR) (ร ((ร int i =) (ร 0, n = (prog.nstate))) (<= 0 (ร --n)) (ร i++))
            ((ร nfa_state_C state =) (... (:states prog) i))
            (if (nil? state)
                (ร CONTINUE)
            )

            ((ร state.lastlist[1] =) (... list n))
        )
        nil
    ))

(defn- #_boolean nfa-re-num-cmp [#_long val, #_int op, #_long pos]
    (ยง
        (if (== op 1)
            ((ร RETURN) (< val pos))
        )
        (if (== op 2)
            ((ร RETURN) (< pos val))
        )

        (== val pos)
    ))

;; Recursively call nfa-regmatch()
;; "pim" is null or contains info about a Postponed Invisible Match (start position).

(defn- #_int recursive-regmatch [#_nfa_state_C state, #_nfa_pim_C pim, #_nfa_regprog_C prog, #_regsubs_C submatch, #_regsubs_C m, #_int** listids]
    (ยง
        ((ร int save_reginput_col =) (BDIFF @reginput, @regline))
        ((ร long save_reglnum =) @reglnum)
        ((ร int save_nfa_match =) @nfa_match)
        ((ร int save_nfa_listid =) @nfa_listid)
        ((ร save_se_C save_nfa_endp =) @nfa_endp)
        ((ร save_se_C endpos =) (NEW_save_se_C))
        ((ร save_se_C endposp =) nil)
        ((ร boolean need_restore =) false)

        (when (non-nil? pim)
            ;; start at the position where the postponed match was
            (if (nil? @reg_match)
                (reset! reginput (.plus @regline (:col (:end_pos pim))))
                (reset! reginput (:end_ptr pim)))
        )

        (when (or (== (:c state) NFA_START_INVISIBLE_BEFORE) (== (:c state) NFA_START_INVISIBLE_BEFORE_FIRST) (== (:c state) NFA_START_INVISIBLE_BEFORE_NEG) (== (:c state) NFA_START_INVISIBLE_BEFORE_NEG_FIRST))
            ;; The recursive match must end at the current position.
            ;; When "pim" is not null it specifies the current position.
            ((ร endposp =) endpos)
            (cond (nil? @reg_match)
            (do
                (cond (nil? pim)
                (do
                    ((ร endpos.se_pos.col =) (BDIFF @reginput, @regline))
                    ((ร endpos.se_pos.lnum =) @reglnum)
                )
                :else
                (do
                    (COPY-lpos (:se_pos endpos), (:end_pos pim))
                ))
            )
            :else
            (do
                ((ร endpos.se_ptr =) (if (nil? pim) @reginput (:end_ptr pim)))
            ))

            ;; Go back the specified number of bytes, or as far as the start of
            ;; the previous line, to try matching "\@<=" or not matching "\@<!".
            ;; This is very inefficient, limit the number of bytes if possible.

            (cond (<= (:val state) 0)
            (do
                (when (nil? @reg_match)
                    (reset! regline (reg-getline (ร --@reglnum)))
                    (when (nil? @regline)
                        ;; can't go before the first line
                        (reset! regline (reg-getline (ร ++@reglnum)))
                    )
                )
                (reset! reginput @regline)
            )
            :else
            (do
                (when (and (nil? @reg_match) (< (BDIFF @reginput, @regline) (:val state)))
                    ;; Not enough bytes in this line, go to end of previous line.
                    (reset! regline (reg-getline (ร --@reglnum)))
                    (cond (nil? @regline)
                    (do
                        ;; can't go before the first line
                        (reset! regline (reg-getline (ร ++@reglnum)))
                        (reset! reginput @regline)
                    )
                    :else
                    (do
                        (reset! reginput (.plus @regline (STRLEN @regline)))
                    ))
                )
                (cond (<= (:val state) (BDIFF @reginput, @regline))
                (do
                    (reset! reginput (.minus @reginput (:val state)))
                    (reset! reginput (.minus @reginput (us-head-off @regline, @reginput)))
                )
                :else
                (do
                    (reset! reginput @regline)
                ))
            ))
        )

        ;; Have to clear the lastlist field of the NFA nodes, so that
        ;; nfa-regmatch() and addstate() can run properly after recursion.
        (cond (== @nfa_ll_index 1)
        (do
            ;; Already calling nfa-regmatch() recursively.
            ;; Save the lastlist[1] values and clear them.
            (if (nil? (... listids 0))
                ((ร listids[0] =) (ร new int[prog.nstate]))
            )
            (nfa-save-listids prog, (... listids 0))
            ((ร need_restore =) true)
            ;; any value of nfa_listid will do
        )
        :else
        (do
            ;; First recursive nfa-regmatch() call, switch to the second lastlist entry.
            ;; Make sure nfa_listid is different from a previous recursive call,
            ;; because some states may still have this ID.
            (swap! nfa_ll_index inc)
            (if (<= @nfa_listid @nfa_alt_listid)
                (reset! nfa_listid @nfa_alt_listid))
        ))

        ;; Call nfa-regmatch() to check if the current concat matches at this position.
        ;; The concat ends with the node NFA_END_INVISIBLE.
        (reset! nfa_endp endposp)
        ((ร int result =) (nfa-regmatch prog, (.out0 state), submatch, m))

        (cond need_restore
        (do
            (nfa-restore-listids prog, (... listids 0))
        )
        :else
        (do
            (swap! nfa_ll_index dec)
            (reset! nfa_alt_listid @nfa_listid)
        ))

        ;; restore position in input text
        (reset! reglnum save_reglnum)
        (if (nil? @reg_match)
            (reset! regline (reg-getline @reglnum)))
        (reset! reginput (.plus @regline save_reginput_col))
        (reset! nfa_match save_nfa_match)
        (reset! nfa_endp save_nfa_endp)
        (reset! nfa_listid save_nfa_listid)

        result
    ))

;; Estimate the chance of a match with "state" failing.
;; empty match: 0
;; NFA_ANY: 1
;; specific character: 99

(defn- #_int failure-chance [#_nfa_state_C state, #_int depth]
    (ยง
        ;; detect looping
        (if (< 4 depth)
            ((ร RETURN) 1)
        )

        ((ร int c =) (:c state))

        ((ร SWITCH) c
            ((ร CASE) NFA_SPLIT)
            (do
                (when (or (== (.. state (out0) c) NFA_SPLIT) (== (.. state (out1) c) NFA_SPLIT))
                    ;; avoid recursive stuff
                    ((ร RETURN) 1)
                )

                ;; two alternatives, use the lowest failure chance
                ((ร int l =) (failure-chance (.out0 state), (inc depth)))
                ((ร int r =) (failure-chance (.out1 state), (inc depth)))
                ((ร RETURN) (if (< l r) l r))
            )

            ((ร CASE) NFA_ANY)
            (do
                ;; matches anything, unlikely to fail
                ((ร RETURN) 1)
            )

            ((ร CASE) NFA_MATCH)
            ((ร CASE) NFA_MCLOSE)
            ((ร CASE) NFA_ANY_COMPOSING)
            (do
                ;; empty match works always
                ((ร RETURN) 0)
            )

            ((ร CASE) NFA_START_INVISIBLE)
            ((ร CASE) NFA_START_INVISIBLE_FIRST)
            ((ร CASE) NFA_START_INVISIBLE_NEG)
            ((ร CASE) NFA_START_INVISIBLE_NEG_FIRST)
            ((ร CASE) NFA_START_INVISIBLE_BEFORE)
            ((ร CASE) NFA_START_INVISIBLE_BEFORE_FIRST)
            ((ร CASE) NFA_START_INVISIBLE_BEFORE_NEG)
            ((ร CASE) NFA_START_INVISIBLE_BEFORE_NEG_FIRST)
            ((ร CASE) NFA_START_PATTERN)
            (do
                ;; recursive regmatch is expensive, use low failure chance
                ((ร RETURN) 5)
            )

            ((ร CASE) NFA_BOL)
            ((ร CASE) NFA_EOL)
            ((ร CASE) NFA_BOF)
            ((ร CASE) NFA_EOF)
            ((ร CASE) NFA_NEWL)
            (do
                ((ร RETURN) 99)
            )

            ((ร CASE) NFA_BOW)
            ((ร CASE) NFA_EOW)
            (do
                ((ร RETURN) 90)
            )

            ((ร CASE) NFA_MOPEN)
            ((ร CASE) NFA_MOPEN1)
            ((ร CASE) NFA_MOPEN2)
            ((ร CASE) NFA_MOPEN3)
            ((ร CASE) NFA_MOPEN4)
            ((ร CASE) NFA_MOPEN5)
            ((ร CASE) NFA_MOPEN6)
            ((ร CASE) NFA_MOPEN7)
            ((ร CASE) NFA_MOPEN8)
            ((ร CASE) NFA_MOPEN9)
            ((ร CASE) NFA_ZOPEN)
            ((ร CASE) NFA_ZOPEN1)
            ((ร CASE) NFA_ZOPEN2)
            ((ร CASE) NFA_ZOPEN3)
            ((ร CASE) NFA_ZOPEN4)
            ((ร CASE) NFA_ZOPEN5)
            ((ร CASE) NFA_ZOPEN6)
            ((ร CASE) NFA_ZOPEN7)
            ((ร CASE) NFA_ZOPEN8)
            ((ร CASE) NFA_ZOPEN9)
            ((ร CASE) NFA_ZCLOSE)
            ((ร CASE) NFA_ZCLOSE1)
            ((ร CASE) NFA_ZCLOSE2)
            ((ร CASE) NFA_ZCLOSE3)
            ((ร CASE) NFA_ZCLOSE4)
            ((ร CASE) NFA_ZCLOSE5)
            ((ร CASE) NFA_ZCLOSE6)
            ((ร CASE) NFA_ZCLOSE7)
            ((ร CASE) NFA_ZCLOSE8)
            ((ร CASE) NFA_ZCLOSE9)
            ((ร CASE) NFA_NOPEN)
            ((ร CASE) NFA_MCLOSE1)
            ((ร CASE) NFA_MCLOSE2)
            ((ร CASE) NFA_MCLOSE3)
            ((ร CASE) NFA_MCLOSE4)
            ((ร CASE) NFA_MCLOSE5)
            ((ร CASE) NFA_MCLOSE6)
            ((ร CASE) NFA_MCLOSE7)
            ((ร CASE) NFA_MCLOSE8)
            ((ร CASE) NFA_MCLOSE9)
            ((ร CASE) NFA_NCLOSE)
            (do
                ((ร RETURN) (failure-chance (.out0 state), (inc depth)))
            )

            ((ร CASE) NFA_BACKREF1)
            ((ร CASE) NFA_BACKREF2)
            ((ร CASE) NFA_BACKREF3)
            ((ร CASE) NFA_BACKREF4)
            ((ร CASE) NFA_BACKREF5)
            ((ร CASE) NFA_BACKREF6)
            ((ร CASE) NFA_BACKREF7)
            ((ร CASE) NFA_BACKREF8)
            ((ร CASE) NFA_BACKREF9)
            ((ร CASE) NFA_ZREF1)
            ((ร CASE) NFA_ZREF2)
            ((ร CASE) NFA_ZREF3)
            ((ร CASE) NFA_ZREF4)
            ((ร CASE) NFA_ZREF5)
            ((ร CASE) NFA_ZREF6)
            ((ร CASE) NFA_ZREF7)
            ((ร CASE) NFA_ZREF8)
            ((ร CASE) NFA_ZREF9)
            (do
                ;; backreferences don't match in many places
                ((ร RETURN) 94)
            )

            ((ร CASE) NFA_LNUM_GT)
            ((ร CASE) NFA_LNUM_LT)
            ((ร CASE) NFA_COL_GT)
            ((ร CASE) NFA_COL_LT)
            ((ร CASE) NFA_VCOL_GT)
            ((ร CASE) NFA_VCOL_LT)
            ((ร CASE) NFA_MARK_GT)
            ((ร CASE) NFA_MARK_LT)
            ((ร CASE) NFA_VISUAL)
            (do
                ;; before/after positions don't match very often
                ((ร RETURN) 85)
            )

            ((ร CASE) NFA_LNUM)
            (do
                ((ร RETURN) 90)
            )

            ((ร CASE) NFA_CURSOR)
            ((ร CASE) NFA_COL)
            ((ร CASE) NFA_VCOL)
            ((ร CASE) NFA_MARK)
            (do
                ;; specific positions rarely match
                ((ร RETURN) 98)
            )

            ((ร CASE) NFA_COMPOSING)
            (do
                ((ร RETURN) 95)
            )

            (ร DEFAULT)
            (do
                (when (< 0 c)
                    ;; character match fails often
                    ((ร RETURN) 95)
                )
            )
        )

        ;; something else, includes character classes
        50
    ))

;; Skip until the char "c" we know a match must start with.

(defn- #_boolean skip-to-start [#_int c, #_int* colp]
    (ยง
        ;; Used often, do some work to avoid call overhead.
        ((ร Bytes s =) (cstrchr (.plus @regline (... colp 0)), c))
        (if (nil? s)
            ((ร RETURN) false)
        )

        ((ร colp[0] =) (BDIFF s, @regline))
        true
    ))

;; Check for a match with match_text.
;; Called after skip-to-start() has found regstart.
;; Returns zero for no match, 1 for a match.

(defn- #_long find-match-text [#_int startcol, #_int regstart, #_Bytes match_text]
    (ยง
; %%    ((ร FOR) (ร ((ร int[] col =) (ร { startcol })) true nil)
            ((ร boolean match =) true)
            ((ร int len2 =) (utf-char2len regstart))                      ;; skip regstart

            (ร int c1, c2)
            ((ร FOR) (ร ((ร int len1 =) 0) (non-eos? match_text len1) ((ร len1 =) (+ len1 (utf-char2len c1))))
                ((ร c1 =) (us-ptr2char (.plus match_text len1)))
                ((ร c2 =) (us-ptr2char (.plus @regline (+ (... col 0) len2))))
                (when (and (!= c1 c2) (or (not @ireg_ic) (!= (utf-tolower c1) (utf-tolower c2))))
                    ((ร match =) false)
                    (ร BREAK)
                )
                ((ร len2 =) (+ len2 (utf-char2len c2)))
            )

            ;; check that no composing char follows
            (when (and match (not (utf-iscomposing (us-ptr2char (.plus @regline (+ (... col 0) len2))))))
                (cleanup-subexpr)
                (cond (nil? @reg_match)
                (do
                    ((ร @reg_startpos[0].lnum =) @reglnum)
                    ((ร @reg_startpos[0].col =) (... col 0))
                    ((ร @reg_endpos[0].lnum =) @reglnum)
                    ((ร @reg_endpos[0].col =) (+ (... col 0) len2))
                )
                :else
                (do
                    ((ร @reg_startp[0] =) (.plus @regline (... col 0)))
                    ((ร @reg_endp[0] =) (.plus @regline (+ (... col 0) len2)))
                ))
                ((ร RETURN) 1)
            )

            ;; Try finding regstart after the current match.
            ((ร col[0] =) (+ (... col 0) (utf-char2len regstart)))                          ;; skip regstart
            (if (not (skip-to-start regstart, col))
                (ร BREAK)
            )
; %%    )

        0
    ))

;; Main matching routine.
;;
;; Run NFA to determine whether it matches reginput.
;;
;; When "nfa_endp" is not null it is a required end-of-match position.
;;
;; Return true if there is a match, false otherwise.
;; When there is a match "submatch" contains the positions.
;; Note: Caller must ensure that: start != null.

(defn- #_int nfa-regmatch [#_nfa_regprog_C prog, #_nfa_state_C start, #_regsubs_C submatch, #_regsubs_C m]
    (ยง
        ((ร boolean toplevel =) (== (:c start) NFA_MOPEN))

        ;; Some patterns may take a long time to match, especially when using recursive-regmatch().
        ;; Allow interrupting them with CTRL-C.
        (fast-breakcheck)
        (if @got_int
            ((ร RETURN) FALSE)
        )
        (if (and (non-zero? @nfa_time_limit) (profile-passed-limit @nfa_time_limit))
            ((ร RETURN) FALSE)
        )

        (reset! nfa_match FALSE)

        ((ร nfa_list_C[] list =) (ARRAY-nfa-list 2))
        ((ร list[0].threads =) (ARRAY-nfa-thread ((ร list[0].len =) (+ (:nstate prog) 1))))
        ((ร list[1].threads =) (ARRAY-nfa-thread ((ร list[1].len =) (+ (:nstate prog) 1))))

        ((ร nfa_list_C thislist =) (... list 0))
        ((ร thislist.n =) 0)
        ((ร thislist.has_pim =) false)
        ((ร nfa_list_C nextlist =) (... list 1))
        ((ร nextlist.n =) 0)
        ((ร nextlist.has_pim =) false)
        ((ร thislist.id =) (inc @nfa_listid))

        ;; Inline optimized code for addstate(thislist, start, m, 0) if we know it's the first MOPEN.
        (cond toplevel
        (do
            (cond (nil? @reg_match)
            (do
                ((ร m.rs_norm.rs_multi[0].start_lnum =) @reglnum)
                ((ร m.rs_norm.rs_multi[0].start_col =) (BDIFF @reginput, @regline))
            )
            :else
            (do
                ((ร m.rs_norm.rs_line[0].start =) @reginput)
            ))
            ((ร m.rs_norm.in_use =) 1)
            (addstate thislist, (.out0 start), m, nil, 0)
        )
        :else
        (do
            (addstate thislist, start, m, nil, 0)
        ))

        ((ร boolean go_to_nextline =) false)
        ((ร int flag =) 0)
; %%    ((ร int[][] listids =) (ร { null }))
        ((ร int add_off =) 0)

        ;; Run for each character.

        (while true
            ((ร int curc =) (us-ptr2char @reginput))
            ((ร int clen =) (us-ptr2len-cc @reginput))
            (when (== curc NUL)
                ((ร clen =) 0)
                ((ร go_to_nextline =) false)
            )

            ;; swap lists
            ((ร thislist =) (... list flag))
            ((ร nextlist =) (... list ((ร flag =) (bit-xor flag 1))))
            ((ร nextlist.n =) 0)                 ;; clear nextlist
            ((ร nextlist.has_pim =) false)
            (swap! nfa_listid inc)
            (when (and (== (:re_engine prog) AUTOMATIC_ENGINE) (<= NFA_MAX_STATES @nfa_listid))
                ;; too many states, retry with old engine
                (reset! nfa_match NFA_TOO_EXPENSIVE)
                ((ร RETURN) @nfa_match)
            )

            ((ร thislist.id =) @nfa_listid)
            ((ร nextlist.id =) (inc @nfa_listid))

            ;; If the state lists are empty we can stop.

            (if (zero? (:n thislist))
                (ร BREAK)
            )

;           nextchar:
;           {
                ;; compute nextlist
; %%            ((ร FOR) (ร ((ร int[] lidx =) (ร { 0 })) (< (... lidx 0) (:n thislist)) (ร lidx[0]++))
                    ((ร nfa_thread_C thread =) (... (:threads thislist) (... lidx 0)))

                    ;; Handle the possible codes of the current state.
                    ;; The most important is NFA_MATCH.

                    ((ร nfa_state_C add_state =) nil)
                    ((ร boolean add_here =) false)
                    ((ร int add_count =) 0)

                    ((ร SWITCH) (:c (:state thread))
                        ((ร CASE) NFA_MATCH)
                        (do
                            ;; If the match ends before a composing characters and
                            ;; ireg_icombine is not set, that is not really a match.
                            (if (and (not @ireg_icombine) (utf-iscomposing curc))
                                (ร BREAK)
                            )
                            (reset! nfa_match TRUE)
                            (copy-sub (:rs_norm submatch), (:rs_norm (:th_subs thread)))
                            (if @nfa_has_zsubexpr
                                (copy-sub (:rs_synt submatch), (:rs_synt (:th_subs thread))))
                            ;; Found the left-most longest match, do not look at any other states
                            ;; at this position.  When the list of states is going to be empty
                            ;; quit without advancing, so that "reginput" is correct.
                            (if (zero? (:n nextlist))
                                ((ร clen =) 0)
                            )
                            (ร BREAK nextchar)
                        )

                        ((ร CASE) NFA_END_INVISIBLE)
                        ((ร CASE) NFA_END_INVISIBLE_NEG)
                        ((ร CASE) NFA_END_PATTERN)
                        (do
                            ;; This is only encountered after a NFA_START_INVISIBLE or
                            ;; NFA_START_INVISIBLE_BEFORE node.
                            ;; They surround a zero-width group, used with "\@=", "\&",
                            ;; "\@!", "\@<=" and "\@<!".
                            ;; If we got here, it means that the current "invisible" group
                            ;; finished successfully, so return control to the parent
                            ;; nfa-regmatch().  For a look-behind match only when it ends
                            ;; in the position in "nfa_endp".
                            ;; Submatches are stored in *m, and used in the parent call.

                            ;; If "nfa_endp" is set it's only a match if it ends at "nfa_endp".
                            (if (and (non-nil? @nfa_endp) (if (nil? @reg_match) (or (!= @reglnum (:lnum (:se_pos @nfa_endp))) (!= (BDIFF @reginput, @regline) (:col (:se_pos @nfa_endp)))) (BNE @reginput, (:se_ptr @nfa_endp))))
                                (ร BREAK)
                            )

                            ;; do not set submatches for \@!
                            (when (!= (:c (:state thread)) NFA_END_INVISIBLE_NEG)
                                (copy-sub (:rs_norm m), (:rs_norm (:th_subs thread)))
                                (if @nfa_has_zsubexpr
                                    (copy-sub (:rs_synt m), (:rs_synt (:th_subs thread))))
                            )
                            (reset! nfa_match TRUE)
                            ;; See comment above at "goto nextchar".
                            (if (zero? (:n nextlist))
                                ((ร clen =) 0)
                            )
                            (ร BREAK nextchar)
                        )

                        ((ร CASE) NFA_START_INVISIBLE)
                        ((ร CASE) NFA_START_INVISIBLE_FIRST)
                        ((ร CASE) NFA_START_INVISIBLE_NEG)
                        ((ร CASE) NFA_START_INVISIBLE_NEG_FIRST)
                        ((ร CASE) NFA_START_INVISIBLE_BEFORE)
                        ((ร CASE) NFA_START_INVISIBLE_BEFORE_FIRST)
                        ((ร CASE) NFA_START_INVISIBLE_BEFORE_NEG)
                        ((ร CASE) NFA_START_INVISIBLE_BEFORE_NEG_FIRST)
                        (do
                            ;; Do it directly if there already is a PIM or when
                            ;; nfa-postprocess() detected it will work better.
                            (cond (or (!= (:result (:th_pim thread)) NFA_PIM_UNUSED) (== (:c (:state thread)) NFA_START_INVISIBLE_FIRST) (== (:c (:state thread)) NFA_START_INVISIBLE_NEG_FIRST) (== (:c (:state thread)) NFA_START_INVISIBLE_BEFORE_FIRST) (== (:c (:state thread)) NFA_START_INVISIBLE_BEFORE_NEG_FIRST))
                            (do
                                ((ร int in_use =) (:in_use (:rs_norm m)))

                                ;; Copy submatch info for the recursive call,
                                ;; opposite of what happens on success below.
                                (copy-sub-off (:rs_norm m), (:rs_norm (:th_subs thread)))
                                (if @nfa_has_zsubexpr
                                    (copy-sub-off (:rs_synt m), (:rs_synt (:th_subs thread))))

                                ;; First try matching the invisible match, then what follows.

                                ((ร int result =) (recursive-regmatch (:state thread), nil, prog, submatch, m, listids))
                                (when (== result NFA_TOO_EXPENSIVE)
                                    (reset! nfa_match result)
                                    ((ร RETURN) @nfa_match)
                                )

                                ;; for \@! and \@<! it is a match when the result is false
                                (when (!= (!= result FALSE) (or (== (:c (:state thread)) NFA_START_INVISIBLE_NEG) (== (:c (:state thread)) NFA_START_INVISIBLE_NEG_FIRST) (== (:c (:state thread)) NFA_START_INVISIBLE_BEFORE_NEG) (== (:c (:state thread)) NFA_START_INVISIBLE_BEFORE_NEG_FIRST)))
                                    ;; Copy submatch info from the recursive call.
                                    (copy-sub-off (:rs_norm (:th_subs thread)), (:rs_norm m))
                                    (if @nfa_has_zsubexpr
                                        (copy-sub-off (:rs_synt (:th_subs thread)), (:rs_synt m)))
                                    ;; If the pattern has \ze and it matched in the sub pattern, use it.
                                    (copy-ze-off (:rs_norm (:th_subs thread)), (:rs_norm m))

                                    ;; thread.state.out1 is the corresponding END_INVISIBLE node.
                                    ;; Add its out0 to the current list (zero-width match).
                                    ((ร add_here =) true)
                                    ((ร add_state =) (.. thread state (out1) (out0)))
                                )
                                ((ร m.rs_norm.in_use =) in_use)
                            )
                            :else
                            (do
                                ((ร nfa_pim_C pim =) (NEW_nfa_pim_C))

                                ;; First try matching what follows.  Only if a match
                                ;; is found verify the invisible match matches.  Add a
                                ;; nfa_pim_C to the following states, it contains info
                                ;; about the invisible match.

                                ((ร pim.state =) (:state thread))
                                ((ร pim.result =) NFA_PIM_TODO)
                                ((ร pim.np_subs.rs_norm.in_use =) 0)
                                ((ร pim.np_subs.rs_synt.in_use =) 0)
                                (cond (nil? @reg_match)
                                (do
                                    ((ร pim.end_pos.col =) (BDIFF @reginput, @regline))
                                    ((ร pim.end_pos.lnum =) @reglnum)
                                )
                                :else
                                (do
                                    ((ร pim.end_ptr =) @reginput)
                                ))

                                ;; thread.state.out1 is the corresponding END_INVISIBLE node.
                                ;; Add its out0 to the current list (zero-width match).
                                (addstate-here thislist, (.. thread state (out1) (out0)), (:th_subs thread), pim, lidx)
                            ))
                            (ร BREAK)
                        )

                        ((ร CASE) NFA_START_PATTERN)
                        (do
                            ((ร nfa_state_C skip =) nil)

                            ;; There is no point in trying to match the pattern
                            ;; if the output state is not going to be added to the list.
                            (cond (state-in-list nextlist, (.. thread state (out1) (out0)), (:th_subs thread))
                            (do
                                ((ร skip =) (.. thread state (out1) (out0)))
                            )
                            (state-in-list nextlist, (.. thread state (out1) (out0) (out0)), (:th_subs thread))
                            (do
                                ((ร skip =) (.. thread state (out1) (out0) (out0)))
                            )
                            (state-in-list thislist, (.. thread state (out1) (out0) (out0)), (:th_subs thread))
                            (do
                                ((ร skip =) (.. thread state (out1) (out0) (out0)))
                            ))

                            (if (non-nil? skip)
                                (ร BREAK)
                            )

                            ;; Copy submatch info to the recursive call, opposite of what happens afterwards.
                            (copy-sub-off (:rs_norm m), (:rs_norm (:th_subs thread)))
                            (if @nfa_has_zsubexpr
                                (copy-sub-off (:rs_synt m), (:rs_synt (:th_subs thread))))

                            ;; First try matching the pattern.
                            ((ร int result =) (recursive-regmatch (:state thread), nil, prog, submatch, m, listids))
                            (when (== result NFA_TOO_EXPENSIVE)
                                (reset! nfa_match result)
                                ((ร RETURN) @nfa_match)
                            )
                            (when (!= result FALSE)
                                (ร int bytelen)

                                ;; Copy submatch info from the recursive call.
                                (copy-sub-off (:rs_norm (:th_subs thread)), (:rs_norm m))
                                (if @nfa_has_zsubexpr
                                    (copy-sub-off (:rs_synt (:th_subs thread)), (:rs_synt m)))
                                ;; Now we need to skip over the matched text and
                                ;; then continue with what follows.
                                (cond (nil? @reg_match)
                                (do
                                    ;; TODO: multi-line match
                                    ((ร bytelen =) (- (:end_col (... (:rs_multi (:rs_norm m)) 0)) (BDIFF @reginput, @regline)))
                                )
                                :else
                                (do
                                    ((ร bytelen =) (BDIFF (:end (... (:rs_line (:rs_norm m)) 0)), @reginput))
                                ))

                                (cond (zero? bytelen)
                                (do
                                    ;; Empty match: output of corresponding NFA_END_PATTERN/NFA_SKIP
                                    ;; to be used at current position.
                                    ((ร add_here =) true)
                                    ((ร add_state =) (.. thread state (out1) (out0) (out0)))
                                )
                                (<= bytelen clen)
                                (do
                                    ;; Match current character, output of corresponding
                                    ;; NFA_END_PATTERN to be used at next position.
                                    ((ร add_state =) (.. thread state (out1) (out0) (out0)))
                                    ((ร add_off =) clen)
                                )
                                :else
                                (do
                                    ;; Skip over the matched characters, set character count in NFA_SKIP.
                                    ((ร add_state =) (.. thread state (out1) (out0)))
                                    ((ร add_off =) bytelen)
                                    ((ร add_count =) (- bytelen clen))
                                ))
                            )
                            (ร BREAK)
                        )

                        ((ร CASE) NFA_BOL)
                        (do
                            (when (BEQ @reginput, @regline)
                                ((ร add_here =) true)
                                ((ร add_state =) (.. thread state (out0)))
                            )
                            (ร BREAK)
                        )

                        ((ร CASE) NFA_EOL)
                        (do
                            (when (== curc NUL)
                                ((ร add_here =) true)
                                ((ร add_state =) (.. thread state (out0)))
                            )
                            (ร BREAK)
                        )

                        ((ร CASE) NFA_BOW)
                        (do
                            ((ร boolean result =) true)
                            (cond (== curc NUL)
                            (do
                                ((ร result =) false)
                            )
                            :else
                            (do
                                (ร int this_class)

                                ;; Get class of current and previous char (if it exists).
                                ((ร this_class =) (us-get-class @reginput, @reg_buf))
                                (cond (<= this_class 1)
                                (do
                                    ((ร result =) false)
                                )
                                (== (reg-prev-class) this_class)
                                (do
                                    ((ร result =) false)
                                ))
                            ))
                            (when result
                                ((ร add_here =) true)
                                ((ร add_state =) (.. thread state (out0)))
                            )
                            (ร BREAK)
                        )

                        ((ร CASE) NFA_EOW)
                        (do
                            ((ร boolean result =) true)
                            (cond (BEQ @reginput, @regline)
                            (do
                                ((ร result =) false)
                            )
                            :else
                            (do
                                (ร int this_class, prev_class)

                                ;; Get class of current and previous char (if it exists).
                                ((ร this_class =) (us-get-class @reginput, @reg_buf))
                                ((ร prev_class =) (reg-prev-class))
                                (if (or (== this_class prev_class) (zero? prev_class) (== prev_class 1))
                                    ((ร result =) false)
                                )
                            ))
                            (when result
                                ((ร add_here =) true)
                                ((ร add_state =) (.. thread state (out0)))
                            )
                            (ร BREAK)
                        )

                        ((ร CASE) NFA_BOF)
                        (do
                            (when (and (zero? @reglnum) (BEQ @reginput, @regline) (or (non-nil? @reg_match) (== @reg_firstlnum 1)))
                                ((ร add_here =) true)
                                ((ร add_state =) (.. thread state (out0)))
                            )
                            (ร BREAK)
                        )

                        ((ร CASE) NFA_EOF)
                        (do
                            (when (and (== @reglnum @reg_maxline) (== curc NUL))
                                ((ร add_here =) true)
                                ((ร add_state =) (.. thread state (out0)))
                            )
                            (ร BREAK)
                        )

                        ((ร CASE) NFA_COMPOSING)
                        (do
                            ((ร int mc =) curc)
                            ((ร int[] cchars =) (ร new int[MAX_MCO]))
                            ((ร int ccount =) 0)

                            ((ร nfa_state_C sta =) (.. thread state (out0)))
                            ((ร int len =) 0)
                            (when (utf-iscomposing (:c sta))
                                ;; Only match composing character(s), ignore base character.
                                ;; Used for ".{composing}" and "{composing}" (no preceding character).
                                ((ร len =) (+ len (utf-char2len mc)))
                            )

                            (ร boolean result)
                            (cond (and @ireg_icombine (zero? len))
                            (do
                                ;; If \Z was present, then ignore composing characters.
                                ;; When ignoring the base character this always matches.
                                ((ร result =) (not (and (zero? len) (!= (:c sta) curc))))
                                (while (!= (:c sta) NFA_END_COMPOSING)
                                    ((ร sta =) (.out0 sta))
                                )
                            )
                            ;; Check base character matches first, unless ignored.
                            (or (< 0 len) (== mc (:c sta)))
                            (do
                                (when (zero? len)
                                    ((ร len =) (+ len (utf-char2len mc)))
                                    ((ร sta =) (.out0 sta))
                                )

                                ;; We don't care about the order of composing characters.
                                ;; Get them into cchars[] first.
                                (while (< len clen)
                                    ((ร mc =) (us-ptr2char (.plus @reginput len)))
                                    ((ร cchars[ccount++] =) mc)
                                    ((ร len =) (+ len (utf-char2len mc)))
                                    (if (== ccount MAX_MCO)
                                        (ร BREAK)
                                    )
                                )

                                ;; Check that each composing char in the pattern matches
                                ;; a composing char in the text.
                                ;; We do not check if all composing chars are matched.
                                ((ร result =) true)
                                (while (!= (:c sta) NFA_END_COMPOSING)
                                    (ร int j)
                                    ((ร FOR) (ร ((ร j =) 0) (< j ccount) (ร j++))
                                        (if (== (... cchars j) (:c sta))
                                            (ร BREAK)
                                        )
                                    )
                                    (when (== j ccount)
                                        ((ร result =) false)
                                        (ร BREAK)
                                    )
                                    ((ร sta =) (.out0 sta))
                                )
                            )
                            :else
                            (do
                                ((ร result =) false)
                            ))

                            ((ร nfa_state_C end =) (.. thread state (out1)))    ;; NFA_END_COMPOSING

                            (when result
                                ((ร add_state =) (.out0 end))
                                ((ร add_off =) clen)
                            )
                            (ร BREAK)
                        )

                        ((ร CASE) NFA_NEWL)
                        (do
                            (cond (and (== curc NUL) (not @reg_line_lbr) (nil? @reg_match) (<= @reglnum @reg_maxline))
                            (do
                                ((ร go_to_nextline =) true)
                                ;; Pass -1 for the offset, which means
                                ;; taking the position at the start of the next line.
                                ((ร add_state =) (.. thread state (out0)))
                                ((ร add_off =) -1)
                            )
                            (and (== curc (byte \newline)) @reg_line_lbr)
                            (do
                                ;; match \n as if it is an ordinary character
                                ((ร add_state =) (.. thread state (out0)))
                                ((ร add_off =) 1)
                            ))
                            (ร BREAK)
                        )

                        ((ร CASE) NFA_START_COLL)
                        ((ร CASE) NFA_START_NEG_COLL)
                        (do
                            ;; What follows is a list of characters, until NFA_END_COLL.
                            ;; One of them must match or none of them must match.

                            ;; Never match EOL.
                            ;; If it's part of the collection it is added as a separate state with an OR.
                            (if (== curc NUL)
                                (ร BREAK)
                            )

                            ((ร boolean result_if_matched =) (== (:c (:state thread)) NFA_START_COLL))

;                           boolean result = false;	// %% anno dunno
                            ((ร FOR) (ร ((ร nfa_state_C state =) (.. thread state (out0))) true ((ร state =) (.out0 state)))
                                (when (== (:c state) NFA_END_COLL)
                                    ((ร result =) (not result_if_matched))
                                    (ร BREAK)
                                )
                                (cond (== (:c state) NFA_RANGE_MIN)
                                (do
                                    ((ร int c1 =) (:val state))
                                    ((ร state =) (.out0 state)) ;; advance to NFA_RANGE_MAX
                                    ((ร int c2 =) (:val state))
                                    (when (<= c1 curc c2)
                                        ((ร result =) result_if_matched)
                                        (ร BREAK)
                                    )
                                    (when @ireg_ic
                                        ((ร int curc_low =) (utf-tolower curc))
                                        ((ร boolean done =) false)

                                        ((ร FOR) (ร nil (<= c1 c2) (ร ++c1))
                                            (when (== (utf-tolower c1) curc_low)
                                                ((ร result =) result_if_matched)
                                                ((ร done =) true)
                                                (ร BREAK)
                                            )
                                        )
                                        (if done
                                            (ร BREAK)
                                        )
                                    )
                                )
                                (if (< (:c state) 0) (check-char-class (:c state), curc) (or (== curc (:c state)) (and @ireg_ic (== (utf-tolower curc) (utf-tolower (:c state))))))
                                (do
                                    ((ร result =) result_if_matched)
                                    (ร BREAK)
                                ))
                            )
                            (when result
                                ;; next state is in out of the NFA_END_COLL,
                                ;; out1 of START points to the END state
                                ((ร add_state =) (.. thread state (out1) (out0)))
                                ((ร add_off =) clen)
                            )
                            (ร BREAK)
                        )

                        ((ร CASE) NFA_ANY)
                        (do
                            ;; Any char except NUL, (end of input) does not match.
                            (when (< 0 curc)
                                ((ร add_state =) (.. thread state (out0)))
                                ((ร add_off =) clen)
                            )
                            (ร BREAK)
                        )

                        ((ร CASE) NFA_ANY_COMPOSING)
                        (do
                            ;; On a composing character skip over it.
                            ;; Otherwise do nothing.
                            ;; Always matches.
                            (cond (utf-iscomposing curc)
                            (do
                                ((ร add_off =) clen)
                            )
                            :else
                            (do
                                ((ร add_here =) true)
                                ((ร add_off =) 0)
                            ))
                            ((ร add_state =) (.. thread state (out0)))
                            (ร BREAK)
                        )

                        ;; Character classes like \a for alpha, \d for digit etc.

                        ((ร CASE) NFA_IDENT)     ;;  \i
                        (do
                            ((ร boolean result =) (vim-isIDc curc))
                            (when result
                                ((ร add_state =) (.. thread state (out0)))
                                ((ร add_off =) clen)
                            )
                            (ร BREAK)
                        )

                        ((ร CASE) NFA_SIDENT)    ;;  \I
                        (do
                            ((ร boolean result =) (and (not (asc-isdigit curc)) (vim-isIDc curc)))
                            (when result
                                ((ร add_state =) (.. thread state (out0)))
                                ((ร add_off =) clen)
                            )
                            (ร BREAK)
                        )

                        ((ร CASE) NFA_KWORD)     ;;  \k
                        (do
                            ((ร boolean result =) (us-iswordp @reginput, @reg_buf))
                            (when result
                                ((ร add_state =) (.. thread state (out0)))
                                ((ร add_off =) clen)
                            )
                            (ร BREAK)
                        )

                        ((ร CASE) NFA_SKWORD)    ;;  \K
                        (do
                            ((ร boolean result =) (and (not (asc-isdigit curc)) (us-iswordp @reginput, @reg_buf)))
                            (when result
                                ((ร add_state =) (.. thread state (out0)))
                                ((ร add_off =) clen)
                            )
                            (ร BREAK)
                        )

                        ((ร CASE) NFA_FNAME)     ;;  \f
                        (do
                            ((ร boolean result =) (vim-isfilec curc))
                            (when result
                                ((ร add_state =) (.. thread state (out0)))
                                ((ร add_off =) clen)
                            )
                            (ร BREAK)
                        )

                        ((ร CASE) NFA_SFNAME)    ;;  \F
                        (do
                            ((ร boolean result =) (and (not (asc-isdigit curc)) (vim-isfilec curc)))
                            (when result
                                ((ร add_state =) (.. thread state (out0)))
                                ((ร add_off =) clen)
                            )
                            (ร BREAK)
                        )

                        ((ร CASE) NFA_PRINT)     ;;  \p
                        (do
                            ((ร boolean result =) (vim-isprintc (us-ptr2char @reginput)))
                            (when result
                                ((ร add_state =) (.. thread state (out0)))
                                ((ร add_off =) clen)
                            )
                            (ร BREAK)
                        )

                        ((ร CASE) NFA_SPRINT)    ;;  \P
                        (do
                            ((ร boolean result =) (and (not (asc-isdigit curc)) (vim-isprintc (us-ptr2char @reginput))))
                            (when result
                                ((ร add_state =) (.. thread state (out0)))
                                ((ร add_off =) clen)
                            )
                            (ร BREAK)
                        )

                        ((ร CASE) NFA_WHITE)     ;;  \s
                        (do
                            ((ร boolean result =) (vim-iswhite curc))
                            (when result
                                ((ร add_state =) (.. thread state (out0)))
                                ((ร add_off =) clen)
                            )
                            (ร BREAK)
                        )

                        ((ร CASE) NFA_NWHITE)    ;;  \S
                        (do
                            ((ร boolean result =) (and (!= curc NUL) (not (vim-iswhite curc))))
                            (when result
                                ((ร add_state =) (.. thread state (out0)))
                                ((ร add_off =) clen)
                            )
                            (ร BREAK)
                        )

                        ((ร CASE) NFA_DIGIT)     ;;  \d
                        (do
                            ((ร boolean result =) (ri-digit curc))
                            (when result
                                ((ร add_state =) (.. thread state (out0)))
                                ((ร add_off =) clen)
                            )
                            (ร BREAK)
                        )

                        ((ร CASE) NFA_NDIGIT)    ;;  \D
                        (do
                            ((ร boolean result =) (and (!= curc NUL) (not (ri-digit curc))))
                            (when result
                                ((ร add_state =) (.. thread state (out0)))
                                ((ร add_off =) clen)
                            )
                            (ร BREAK)
                        )

                        ((ร CASE) NFA_HEX)       ;;  \x
                        (do
                            ((ร boolean result =) (ri-hex curc))
                            (when result
                                ((ร add_state =) (.. thread state (out0)))
                                ((ร add_off =) clen)
                            )
                            (ร BREAK)
                        )

                        ((ร CASE) NFA_NHEX)      ;;  \X
                        (do
                            ((ร boolean result =) (and (!= curc NUL) (not (ri-hex curc))))
                            (when result
                                ((ร add_state =) (.. thread state (out0)))
                                ((ร add_off =) clen)
                            )
                            (ร BREAK)
                        )

                        ((ร CASE) NFA_OCTAL)     ;;  \o
                        (do
                            ((ร boolean result =) (ri-octal curc))
                            (when result
                                ((ร add_state =) (.. thread state (out0)))
                                ((ร add_off =) clen)
                            )
                            (ร BREAK)
                        )

                        ((ร CASE) NFA_NOCTAL)    ;;  \O
                        (do
                            ((ร boolean result =) (and (!= curc NUL) (not (ri-octal curc))))
                            (when result
                                ((ร add_state =) (.. thread state (out0)))
                                ((ร add_off =) clen)
                            )
                            (ร BREAK)
                        )

                        ((ร CASE) NFA_WORD)      ;;  \w
                        (do
                            ((ร boolean result =) (ri-word curc))
                            (when result
                                ((ร add_state =) (.. thread state (out0)))
                                ((ร add_off =) clen)
                            )
                            (ร BREAK)
                        )

                        ((ร CASE) NFA_NWORD)     ;;  \W
                        (do
                            ((ร boolean result =) (and (!= curc NUL) (not (ri-word curc))))
                            (when result
                                ((ร add_state =) (.. thread state (out0)))
                                ((ร add_off =) clen)
                            )
                            (ร BREAK)
                        )

                        ((ร CASE) NFA_HEAD)      ;;  \h
                        (do
                            ((ร boolean result =) (ri-head curc))
                            (when result
                                ((ร add_state =) (.. thread state (out0)))
                                ((ร add_off =) clen)
                            )
                            (ร BREAK)
                        )

                        ((ร CASE) NFA_NHEAD)     ;;  \H
                        (do
                            ((ร boolean result =) (and (!= curc NUL) (not (ri-head curc))))
                            (when result
                                ((ร add_state =) (.. thread state (out0)))
                                ((ร add_off =) clen)
                            )
                            (ร BREAK)
                        )

                        ((ร CASE) NFA_ALPHA)     ;;  \a
                        (do
                            ((ร boolean result =) (ri-alpha curc))
                            (when result
                                ((ร add_state =) (.. thread state (out0)))
                                ((ร add_off =) clen)
                            )
                            (ร BREAK)
                        )

                        ((ร CASE) NFA_NALPHA)    ;;  \A
                        (do
                            ((ร boolean result =) (and (!= curc NUL) (not (ri-alpha curc))))
                            (when result
                                ((ร add_state =) (.. thread state (out0)))
                                ((ร add_off =) clen)
                            )
                            (ร BREAK)
                        )

                        ((ร CASE) NFA_LOWER)     ;;  \l
                        (do
                            ((ร boolean result =) (ri-lower curc))
                            (when result
                                ((ร add_state =) (.. thread state (out0)))
                                ((ร add_off =) clen)
                            )
                            (ร BREAK)
                        )

                        ((ร CASE) NFA_NLOWER)    ;;  \L
                        (do
                            ((ร boolean result =) (and (!= curc NUL) (not (ri-lower curc))))
                            (when result
                                ((ร add_state =) (.. thread state (out0)))
                                ((ร add_off =) clen)
                            )
                            (ร BREAK)
                        )

                        ((ร CASE) NFA_UPPER)     ;;  \\u (sic!)
                        (do
                            ((ร boolean result =) (ri-upper curc))
                            (when result
                                ((ร add_state =) (.. thread state (out0)))
                                ((ร add_off =) clen)
                            )
                            (ร BREAK)
                        )

                        ((ร CASE) NFA_NUPPER)    ;;  \U
                        (do
                            ((ร boolean result =) (and (!= curc NUL) (not (ri-upper curc))))
                            (when result
                                ((ร add_state =) (.. thread state (out0)))
                                ((ร add_off =) clen)
                            )
                            (ร BREAK)
                        )

                        ((ร CASE) NFA_LOWER_IC)  ;; [a-z]
                        (do
                            ((ร boolean result =) (or (ri-lower curc) (and @ireg_ic (ri-upper curc))))
                            (when result
                                ((ร add_state =) (.. thread state (out0)))
                                ((ร add_off =) clen)
                            )
                            (ร BREAK)
                        )

                        ((ร CASE) NFA_NLOWER_IC) ;; [^a-z]
                        (do
                            ((ร boolean result =) (and (!= curc NUL) (not (or (ri-lower curc) (and @ireg_ic (ri-upper curc))))))
                            (when result
                                ((ร add_state =) (.. thread state (out0)))
                                ((ร add_off =) clen)
                            )
                            (ร BREAK)
                        )

                        ((ร CASE) NFA_UPPER_IC)  ;; [A-Z]
                        (do
                            ((ร boolean result =) (or (ri-upper curc) (and @ireg_ic (ri-lower curc))))
                            (when result
                                ((ร add_state =) (.. thread state (out0)))
                                ((ร add_off =) clen)
                            )
                            (ร BREAK)
                        )

                        ((ร CASE) NFA_NUPPER_IC) ;; ^[A-Z]
                        (do
                            ((ร boolean result =) (and (!= curc NUL) (not (or (ri-upper curc) (and @ireg_ic (ri-lower curc))))))
                            (when result
                                ((ร add_state =) (.. thread state (out0)))
                                ((ร add_off =) clen)
                            )
                            (ร BREAK)
                        )

                        ((ร CASE) NFA_BACKREF1)
                        ((ร CASE) NFA_BACKREF2)
                        ((ร CASE) NFA_BACKREF3)
                        ((ร CASE) NFA_BACKREF4)
                        ((ร CASE) NFA_BACKREF5)
                        ((ร CASE) NFA_BACKREF6)
                        ((ร CASE) NFA_BACKREF7)
                        ((ร CASE) NFA_BACKREF8)
                        ((ร CASE) NFA_BACKREF9)
                        ((ร CASE) NFA_ZREF1)
                        ((ร CASE) NFA_ZREF2)
                        ((ร CASE) NFA_ZREF3)
                        ((ร CASE) NFA_ZREF4)
                        ((ร CASE) NFA_ZREF5)
                        ((ร CASE) NFA_ZREF6)
                        ((ร CASE) NFA_ZREF7)
                        ((ร CASE) NFA_ZREF8)
                        ((ร CASE) NFA_ZREF9) ;; \1 .. \9  \z1 .. \z9
                        (do
                            (ร int subidx)
                            ((ร int[] bytelen =) (ร new int[1]))

                            (ร boolean result)
                            (cond (<= (:c (:state thread)) NFA_BACKREF9)
                            (do
                                ((ร subidx =) (+ (- (:c (:state thread)) NFA_BACKREF1) 1))
                                ((ร result =) (match-backref (:rs_norm (:th_subs thread)), subidx, bytelen))
                            )
                            :else
                            (do
                                ((ร subidx =) (+ (- (:c (:state thread)) NFA_ZREF1) 1))
                                ((ร result =) (match-zref subidx, bytelen))
                            ))

                            (when result
                                (cond (zero? (... bytelen 0))
                                (do
                                    ;; Empty match always works, output of NFA_SKIP to be used next.
                                    ((ร add_here =) true)
                                    ((ร add_state =) (.. thread state (out0) (out0)))
                                )
                                (<= (... bytelen 0) clen)
                                (do
                                    ;; Match current character, jump ahead to out of NFA_SKIP.
                                    ((ร add_state =) (.. thread state (out0) (out0)))
                                    ((ร add_off =) clen)
                                )
                                :else
                                (do
                                    ;; Skip over the matched characters, set character count in NFA_SKIP.
                                    ((ร add_state =) (.. thread state (out0)))
                                    ((ร add_off =) (... bytelen 0))
                                    ((ร add_count =) (- (... bytelen 0) clen))
                                ))
                            )
                            (ร BREAK)
                        )

                        ((ร CASE) NFA_SKIP)
                        (do
                            ;; character of previous matching \1 .. \9  or \@>
                            (cond (<= (- (:count thread) clen) 0)
                            (do
                                ;; end of match, go to what follows
                                ((ร add_state =) (.. thread state (out0)))
                                ((ร add_off =) clen)
                            )
                            :else
                            (do
                                ;; add state again with decremented count
                                ((ร add_state =) (:state thread))
                                ((ร add_off =) 0)
                                ((ร add_count =) (- (:count thread) clen))
                            ))
                            (ร BREAK)
                        )

                        ((ร CASE) NFA_LNUM)
                        ((ร CASE) NFA_LNUM_GT)
                        ((ร CASE) NFA_LNUM_LT)
                        (do
                            ((ร boolean result =) (and (nil? @reg_match) (nfa-re-num-cmp (:val (:state thread)), (- (:c (:state thread)) NFA_LNUM), (+ @reglnum @reg_firstlnum))))
                            (when result
                                ((ร add_here =) true)
                                ((ร add_state =) (.. thread state (out0)))
                            )
                            (ร BREAK)
                        )

                        ((ร CASE) NFA_COL)
                        ((ร CASE) NFA_COL_GT)
                        ((ร CASE) NFA_COL_LT)
                        (do
                            ((ร boolean result =) (nfa-re-num-cmp (:val (:state thread)), (- (:c (:state thread)) NFA_COL), (+ (BDIFF @reginput, @regline) 1)))
                            (when result
                                ((ร add_here =) true)
                                ((ร add_state =) (.. thread state (out0)))
                            )
                            (ร BREAK)
                        )

                        ((ร CASE) NFA_VCOL)
                        ((ร CASE) NFA_VCOL_GT)
                        ((ร CASE) NFA_VCOL_LT)
                        (do
                            ((ร int op =) (- (:c (:state thread)) NFA_VCOL))
                            ((ร int col =) (BDIFF @reginput, @regline))
                            ((ร window_C wp =) (if (nil? @reg_win) @curwin @reg_win))

                            ;; Bail out quickly when there can't be a match,
                            ;; avoid the overhead of win-linetabsize() on long lines.
                            (if (and (!= op 1) (< (* (:val (:state thread)) MB_MAXBYTES) col))
                                (ร BREAK)
                            )

                            ((ร boolean result =) false)
                            (when (and (== op 1) (< (:val (:state thread)) (dec col)) (< 100 col))
                                ((ร int ts =) (int @(:b_p_ts @curbuf)))

                                ;; Guess that a character won't use more columns than 'tabstop',
                                ;; with a minimum of 4.
                                (if (< ts 4)
                                    ((ร ts =) 4)
                                )
                                ((ร result =) (< (* (:val (:state thread)) ts) col))
                            )
                            (if (not result)
                                ((ร result =) (nfa-re-num-cmp (:val (:state thread)), op, (+ (long (win-linetabsize wp, @regline, col)) 1)))
                            )
                            (when result
                                ((ร add_here =) true)
                                ((ร add_state =) (.. thread state (out0)))
                            )
                            (ร BREAK)
                        )

                        ((ร CASE) NFA_MARK)
                        ((ร CASE) NFA_MARK_GT)
                        ((ร CASE) NFA_MARK_LT)
                        (do
                            ((ร pos_C pos =) (getmark-buf @reg_buf, (:val (:state thread)), false))

                            ;; Compare the mark position to the match position.
                                                                    ;; mark doesn't exist
                                                                    ;; mark isn't set in reg_buf
                            ((ร boolean result =) (and (non-nil? pos) (< 0 (:lnum pos)) (if (== (:lnum pos) (+ @reglnum @reg_firstlnum)) (if (== (:col pos) (BDIFF @reginput, @regline)) (== (:c (:state thread)) NFA_MARK) (if (< (:col pos) (BDIFF @reginput, @regline)) (== (:c (:state thread)) NFA_MARK_GT) (== (:c (:state thread)) NFA_MARK_LT))) (if (< (:lnum pos) (+ @reglnum @reg_firstlnum)) (== (:c (:state thread)) NFA_MARK_GT) (== (:c (:state thread)) NFA_MARK_LT)))))
                            (when result
                                ((ร add_here =) true)
                                ((ร add_state =) (.. thread state (out0)))
                            )
                            (ร BREAK)
                        )

                        ((ร CASE) NFA_CURSOR)
                        (do
                            ((ร boolean result =) (and (non-nil? @reg_win) (== (+ @reglnum @reg_firstlnum) (:lnum (:w_cursor @reg_win))) (== (BDIFF @reginput, @regline) (:col (:w_cursor @reg_win)))))
                            (when result
                                ((ร add_here =) true)
                                ((ร add_state =) (.. thread state (out0)))
                            )
                            (ร BREAK)
                        )

                        ((ร CASE) NFA_VISUAL)
                        (do
                            ((ร boolean result =) (reg-match-visual))
                            (when result
                                ((ร add_here =) true)
                                ((ร add_state =) (.. thread state (out0)))
                            )
                            (ร BREAK)
                        )

                        ((ร CASE) NFA_MOPEN1)
                        ((ร CASE) NFA_MOPEN2)
                        ((ร CASE) NFA_MOPEN3)
                        ((ร CASE) NFA_MOPEN4)
                        ((ร CASE) NFA_MOPEN5)
                        ((ร CASE) NFA_MOPEN6)
                        ((ร CASE) NFA_MOPEN7)
                        ((ร CASE) NFA_MOPEN8)
                        ((ร CASE) NFA_MOPEN9)
                        ((ร CASE) NFA_ZOPEN)
                        ((ร CASE) NFA_ZOPEN1)
                        ((ร CASE) NFA_ZOPEN2)
                        ((ร CASE) NFA_ZOPEN3)
                        ((ร CASE) NFA_ZOPEN4)
                        ((ร CASE) NFA_ZOPEN5)
                        ((ร CASE) NFA_ZOPEN6)
                        ((ร CASE) NFA_ZOPEN7)
                        ((ร CASE) NFA_ZOPEN8)
                        ((ร CASE) NFA_ZOPEN9)
                        ((ร CASE) NFA_NOPEN)
                        ((ร CASE) NFA_ZSTART)
                        (do
                            ;; These states are only added to be able to bail out when
                            ;; they are added again, nothing is to be done.
                            (ร BREAK)
                        )

                        (ร DEFAULT)    ;; regular character
                        (do
                            ((ร int c =) (:c (:state thread)))

                            ((ร boolean result =) (== c curc))
                            (if (and (not result) @ireg_ic)
                                ((ร result =) (== (utf-tolower c) (utf-tolower curc)))
                            )

                            ;; If ireg_icombine is not set only skip over the character itself.
                            ;; When it is set skip over composing characters.
                            (if (and result (not @ireg_icombine))
                                ((ร clen =) (utf-char2len curc))
                            )

                            (when result
                                ((ร add_state =) (.. thread state (out0)))
                                ((ร add_off =) clen)
                            )
                            (ร BREAK)
                        )
                    )

                    (when (non-nil? add_state)
                        ((ร nfa_pim_C pim =) (if (!= (:result (:th_pim thread)) NFA_PIM_UNUSED) (:th_pim thread) nil))

                        ;; Handle the postponed invisible match if the match might end
                        ;; without advancing and before the end of the line.
                        (when (and (non-nil? pim) (or (zero? clen) (match-follows add_state, 0)))
                            (ร int result)
                            (cond (== (:result pim) NFA_PIM_TODO)
                            (do
                                ((ร result =) (recursive-regmatch (:state pim), pim, prog, submatch, m, listids))
                                ((ร pim.result =) (if (!= result FALSE) NFA_PIM_MATCH NFA_PIM_NOMATCH))
                                ;; for \@! and \@<! it is a match when the result is false
                                (when (!= (!= result FALSE) (or (== (:c (:state pim)) NFA_START_INVISIBLE_NEG) (== (:c (:state pim)) NFA_START_INVISIBLE_NEG_FIRST) (== (:c (:state pim)) NFA_START_INVISIBLE_BEFORE_NEG) (== (:c (:state pim)) NFA_START_INVISIBLE_BEFORE_NEG_FIRST)))
                                    ;; Copy submatch info from the recursive call.
                                    (copy-sub-off (:rs_norm (:np_subs pim)), (:rs_norm m))
                                    (if @nfa_has_zsubexpr
                                        (copy-sub-off (:rs_synt (:np_subs pim)), (:rs_synt m)))
                                )
                            )
                            :else
                            (do
                                ((ร result =) (if (== (:result pim) NFA_PIM_MATCH) TRUE FALSE))
                            ))

                            ;; for \@! and \@<! it is a match when result is false
                            (cond (!= (!= result FALSE) (or (== (:c (:state pim)) NFA_START_INVISIBLE_NEG) (== (:c (:state pim)) NFA_START_INVISIBLE_NEG_FIRST) (== (:c (:state pim)) NFA_START_INVISIBLE_BEFORE_NEG) (== (:c (:state pim)) NFA_START_INVISIBLE_BEFORE_NEG_FIRST)))
                            (do
                                ;; Copy submatch info from the recursive call.
                                (copy-sub-off (:rs_norm (:th_subs thread)), (:rs_norm (:np_subs pim)))
                                (if @nfa_has_zsubexpr
                                    (copy-sub-off (:rs_synt (:th_subs thread)), (:rs_synt (:np_subs pim))))
                            )
                            :else
                            (do
                                ;; look-behind match failed, don't add the state
                                (ร CONTINUE)
                            ))

                            ;; Postponed invisible match was handled, don't add it to following states.
                            ((ร pim =) nil)
                        )

                        ((ร nfa_pim_C pim_copy =) (NEW_nfa_pim_C))

                        ;; If "pim" points into nfl.threads,
                        ;; it will become invalid when adding the state causes the list to be reallocated.
                        ;; Make a local copy to avoid that.
                        (when (== pim (:th_pim thread))
                            (copy-pim pim_copy, pim)
                            ((ร pim =) pim_copy)
                        )

                        (cond add_here
                        (do
                            (addstate-here thislist, add_state, (:th_subs thread), pim, lidx)
                        )
                        :else
                        (do
                            (addstate nextlist, add_state, (:th_subs thread), pim, add_off)
                            (if (< 0 add_count)
                                ((ร nextlist.threads[nextlist.n - 1].count =) add_count)
                            )
                        ))
                    )
; %%            )

                ;; Look for the start of a match in the current position
                ;; by adding the start state to the list of states.
                ;; The first found match is the leftmost one, thus the order of states matters!
                ;; Do not add the start state in recursive calls of nfa-regmatch(),
                ;; because recursive calls should only start in the first position.
                ;; Unless "nfa_endp" is not null, then we match the end position.
                ;; Also don't start a match past the first line.

                (when (and (== @nfa_match FALSE) (or (and toplevel (== @reglnum 0) (non-zero? clen) (or (== @ireg_maxcol 0) (< (BDIFF @reginput, @regline) @ireg_maxcol))) (and (non-nil? @nfa_endp) (if (nil? @reg_match) (or (< @reglnum (:lnum (:se_pos @nfa_endp))) (and (== @reglnum (:lnum (:se_pos @nfa_endp))) (< (BDIFF @reginput, @regline) (:col (:se_pos @nfa_endp))))) (BLT @reginput, (:se_ptr @nfa_endp))))))
                    ;; Inline optimized code for addstate() if we know the state is the first MOPEN.
                    (cond toplevel
                    (do
                        ((ร boolean add =) true)

                        (when (and (!= (:regstart prog) NUL) (non-zero? clen))
                            (cond (zero? (:n nextlist))
                            (do
; %%                            ((ร int[] col =) (ร { BDIFF(@reginput, @regline) + clen }))

                                ;; Nextlist is empty, we can skip ahead to the
                                ;; character that must appear at the start.
                                (if (not (skip-to-start (:regstart prog), col))
                                    (ร BREAK)
                                )
                                (reset! reginput (.plus @regline (- (... col 0) clen)))
                            )
                            :else
                            (do
                                ;; Checking if the required start character matches is
                                ;; cheaper than adding a state that won't match.
                                ((ร int c =) (us-ptr2char (.plus @reginput clen)))
                                (when (and (!= c (:regstart prog)) (or (not @ireg_ic) (!= (utf-tolower c) (utf-tolower (:regstart prog)))))
                                    ((ร add =) false)
                                )
                            ))
                        )

                        (when add
                            (if (nil? @reg_match)
                                ((ร m.rs_norm.rs_multi[0].start_col =) (+ (BDIFF @reginput, @regline) clen))
                                ((ร m.rs_norm.rs_line[0].start =) (.plus @reginput clen))
                            )
                            (addstate nextlist, (.out0 start), m, nil, clen)
                        )
                    )
                    :else
                    (do
                        (addstate nextlist, start, m, nil, clen)
                    ))
                )
;           }

            ;; Advance to the next character, or advance to the next line, or finish.
            (cond (non-zero? clen)
            (do
                (reset! reginput (.plus @reginput clen))
            )
            (or go_to_nextline (and (non-nil? @nfa_endp) (nil? @reg_match) (< @reglnum (:lnum (:se_pos @nfa_endp)))))
            (do
                (reg-nextline)
            )
            :else
            (do
                (ร BREAK)
            ))

            ;; Allow interrupting with CTRL-C.
            (line-breakcheck)
            (if @got_int
                (ร BREAK)
            )

            ;; Check for timeout once in a twenty times to avoid overhead.
            (when (and (non-zero? @nfa_time_limit) (== (ร ++@nfa_time_count) 20))
                (reset! nfa_time_count 0)
                (if (profile-passed-limit @nfa_time_limit)
                    (ร BREAK)
                )
            )
        )

        @nfa_match
    ))

;; Try match of "prog" with at regline[col].
;; Returns <= 0 for failure, number of lines contained in the match otherwise.

(defn- #_long nfa-regtry [#_nfa_regprog_C prog, #_int col, #_long nsec]
    ;; nsec: timeout limit or 0
    (ยง
        ((ร regsubs_C subs =) (NEW_regsubs_C))
        ((ร regsubs_C m =) (NEW_regsubs_C))
        ((ร nfa_state_C start =) (:start prog))

        (reset! reginput (.plus @regline col))
        (reset! nfa_time_limit nsec)
        (reset! nfa_time_count 0)

        (clear-sub (:rs_norm subs))
        (clear-sub (:rs_norm m))
        (clear-sub (:rs_synt subs))
        (clear-sub (:rs_synt m))

        ((ร int result =) (nfa-regmatch prog, start, subs, m))
        (cond (== result FALSE)
        (do
            ((ร RETURN) 0)
        )
        (== result NFA_TOO_EXPENSIVE)
        (do
            ((ร RETURN) result)
        ))

        (cleanup-subexpr)
        (cond (nil? @reg_match)
        (do
            ((ร FOR) (ร ((ร int i =) 0) (< i (:in_use (:rs_norm subs))) (ร i++))
                ((ร @reg_startpos[i].lnum =) (:start_lnum (... (:rs_multi (:rs_norm subs)) i)))
                ((ร @reg_startpos[i].col =) (:start_col (... (:rs_multi (:rs_norm subs)) i)))

                ((ร @reg_endpos[i].lnum =) (:end_lnum (... (:rs_multi (:rs_norm subs)) i)))
                ((ร @reg_endpos[i].col =) (:end_col (... (:rs_multi (:rs_norm subs)) i)))
            )

            (when (< (:lnum (... @reg_startpos 0)) 0)
                ((ร @reg_startpos[0].lnum =) 0)
                ((ร @reg_startpos[0].col =) col)
            )
            (cond (< (:lnum (... @reg_endpos 0)) 0)
            (do
                ;; pattern has a \ze but it didn't match, use current end
                ((ร @reg_endpos[0].lnum =) @reglnum)
                ((ร @reg_endpos[0].col =) (BDIFF @reginput, @regline))
            )
            :else
            (do
                ;; Use line number of "\ze".
                (reset! reglnum (:lnum (... @reg_endpos 0)))
            ))
        )
        :else
        (do
            ((ร FOR) (ร ((ร int i =) 0) (< i (:in_use (:rs_norm subs))) (ร i++))
                ((ร @reg_startp[i] =) (:start (... (:rs_line (:rs_norm subs)) i)))
                ((ร @reg_endp[i] =) (:end (... (:rs_line (:rs_norm subs)) i)))
            )

            (if (nil? (... @reg_startp 0))
                ((ร @reg_startp[0] =) (.plus @regline col))
            )
            (if (nil? (... @reg_endp 0))
                ((ร @reg_endp[0] =) @reginput)
            )
        ))

        ;; Package any found \z(...\) matches for export.  Default is none.
        (reset! re_extmatch_out nil)

        (when (== (:reghasz prog) REX_SET)
            (cleanup-zsubexpr)
            (reset! re_extmatch_out (make-extmatch))
            ((ร FOR) (ร ((ร int i =) 0) (< i (:in_use (:rs_synt subs))) (ร i++))
                (cond (nil? @reg_match)
                (do
                    ((ร multipos_C mp =) (... (:rs_multi (:rs_synt subs)) i))

                    ;; Only accept single line matches that are valid.
                    (if (and (<= 0 (:start_lnum mp)) (== (:start_lnum mp) (:end_lnum mp)) (<= (:start_col mp) (:end_col mp)))
                        ((ร @re_extmatch_out.matches[i] =) (STRNDUP (.plus (reg-getline (:start_lnum mp)) (:start_col mp)), (- (:end_col mp) (:start_col mp))))
                    )
                )
                :else
                (do
                    ((ร linepos_C lp =) (... (:rs_line (:rs_synt subs)) i))

                    (if (and (non-nil? (:start lp)) (non-nil? (:end lp)))
                        ((ร @re_extmatch_out.matches[i] =) (STRNDUP (:start lp), (BDIFF (:end lp), (:start lp))))
                    )
                ))
            )
        )

        (+ 1 @reglnum)
    ))

;; Match a regexp against
;;  a string ("line" points to the string)
;;  or multiple lines ("line" is null, use reg-getline()).
;;
;; Returns <= 0 for failure, number of lines contained in the match otherwise.

(defn- #_long nfa-regexec-both [#_Bytes line, #_int startcol, #_long nsec]
    ;; startcol: column to start looking for match
    ;; nsec: timeout limit or 0
    (ยง
; %%    ((ร int[] col =) (ร { startcol }))

        (ร nfa_regprog_C prog)
        (cond (nil? @reg_match)
        (do
            ((ร prog =) (ร (nfa_regprog_C)(@reg_mmatch.regprog)))
            ((ร line =) (reg-getline 0))              ;; relative to the cursor
            (reset! reg_startpos (:startpos @reg_mmatch))
            (reset! reg_endpos (:endpos @reg_mmatch))
        )
        :else
        (do
            ((ร prog =) (ร (nfa_regprog_C)(@reg_match.regprog)))
            (reset! reg_startp (:startp @reg_match))
            (reset! reg_endp (:endp @reg_match))
        ))

        ;; Be paranoid...
        (when (or (nil? prog) (nil? line))
            (emsg e_null)
            ((ร RETURN) 0)
        )

        ;; If pattern contains "\c" or "\C": overrule value of ireg_ic.
        (cond (flag? (:regflags prog) RF_ICASE)
        (do
            (reset! ireg_ic true)
        )
        (flag? (:regflags prog) RF_NOICASE)
        (do
            (reset! ireg_ic false)
        ))

        ;; If pattern contains "\Z" overrule value of ireg_icombine.
        (if (flag? (:regflags prog) RF_ICOMBINE)
            (reset! ireg_icombine true))

        (reset! regline line)
        (reset! reglnum 0)    ;; relative to line

        (reset! nfa_has_zend (:has_zend prog))
        (reset! nfa_has_backref (:has_backref prog))
        (reset! nfa_nsubexpr (:nsubexp prog))
        (reset! nfa_listid 1)
        (reset! nfa_alt_listid 2)
        ((ร nfa_regengine.expr =) (:pattern prog))

        (if (and (non-zero? (:reganch prog)) (< 0 (... col 0)))
            ((ร RETURN) 0)
        )

        (reset! need_clear_subexpr true)
        ;; Clear the external match subpointers if necessary.
        (cond (== (:reghasz prog) REX_SET)
        (do
            (reset! nfa_has_zsubexpr true)
            (reset! need_clear_zsubexpr true)
        )
        :else
        (do
            (reset! nfa_has_zsubexpr false)
        ))

        (when (!= (:regstart prog) NUL)
            ;; Skip ahead until a character we know the match must start with.
            ;; When there is none there is no match.
            (if (not (skip-to-start (:regstart prog), col))
                ((ร RETURN) 0)
            )

            ;; If match_text is set, it contains the full text that must match.
            ;; Nothing else to try.  Doesn't handle combining chars well.
            (if (and (non-nil? (:match_text prog)) (not @ireg_icombine))
                ((ร RETURN) (find-match-text (... col 0), (:regstart prog), (:match_text prog)))
            )
        )

        ;; If the start column is past the maximum column: no need to try.
        (if (and (< 0 @ireg_maxcol) (<= @ireg_maxcol (... col 0)))
            ((ร RETURN) 0)
        )

        (dotimes [#_int i (:nstate prog)]
            ((ร nfa_state_C state =) (... (:states prog) i))
            (if (nil? state)
                (ร CONTINUE)
            )

            ((ร state.id =) i)
            ((ร state.lastlist[0] =) 0)
            ((ร state.lastlist[1] =) 0)
        )

        ((ร long retval =) (nfa-regtry prog, (... col 0), nsec))

        ((ร nfa_regengine.expr =) nil)

        retval
    ))

;; Compile a regular expression into internal code for the NFA matcher.
;; Returns the program in allocated space.  Returns null for an error.

(defn- #_regprog_C nfa-regcomp [#_Bytes expr, #_int re_flags]
    (ยง
        (if (nil? expr)
            ((ร RETURN) nil)
        )

        (ร nfa_regprog_C prog)

        ((ร nfa_regengine.expr =) expr)
        (reset! nfa_re_flags re_flags)

        (init-class-tab)

        (nfa-regcomp-start expr, re_flags)

;       theend:
;       {
;           fail:
;           {
                ;; Build postfix form of the regexp.  Needed to build the NFA (and count its size).
                ((ร int[] postfix =) (re2post))
                (when (nil? postfix)
                    ;; TODO: only give this error for debugging?
                    (if (<= (:length @post_array) @post_index)
                        (emsgn (u8 "Internal error: estimated max number of states insufficient: %d"), (:length @post_array)))
                    (ร BREAK fail)         ;; cascaded (syntax?) error
                )

                ;; In order to build the NFA, we parse the input regexp twice:
                ;; 1. first pass to count size (so we can allocate space)
                ;; 2. second to emit code

                ((ร prog =) (new nfa_regprog_C))
                ((ร prog.nstate =) 0)

                ;; PASS 1
                ;; Count number of NFA states in "prog.nstate".  Do not build the NFA.

                (post2nfa postfix, @post_index, prog, true)

                ;; allocate space for the compiled regexp
                (reset! nfa_states ((ร prog.states =) (ร new nfa_state_C[prog.nstate])))
                ((ร prog.istate =) 0)

                ;; PASS 2
                ;; Build the NFA

                ((ร prog.start =) (post2nfa postfix, @post_index, prog, false))
                (if (nil? (:start prog))
                    (ร BREAK fail)
                )

                ((ร prog.regflags =) @regflags)
                ((ร prog.engine =) nfa_regengine)
                ((ร prog.has_zend =) @nfa_has_zend)
                ((ร prog.has_backref =) @nfa_has_backref)
                ((ร prog.nsubexp =) @regnpar)

                (nfa-postprocess prog)

                ((ร prog.reganch =) (if (nfa-get-reganch (:start prog), 0) 1 0))
                ((ร prog.regstart =) (nfa-get-regstart (:start prog), 0))
                ((ร prog.match_text =) (nfa-get-match-text (:start prog)))

                ;; Remember whether this pattern has any \z specials in it.
                ((ร prog.reghasz =) @re_has_z)
                ((ร prog.pattern =) (STRDUP expr))
                ((ร nfa_regengine.expr =) nil)
                (ร BREAK theend)
;           }

            ((ร prog =) nil)
            ((ร nfa_regengine.expr =) nil)
;       }

        (reset! post_array nil)
        (reset! post_index 0)
        (reset! nfa_states nil)

        (ร (regprog_C)prog)
    ))

;; Match a regexp against a string.
;; "rmp.regprog" is a compiled regexp as returned by nfa-regcomp().
;; Uses curbuf for line count and 'iskeyword'.
;; If "line_lbr" is true, consider a "\n" in "line" to be a line break.
;;
;; Returns <= 0 for failure, number of lines contained in the match otherwise.

(defn- #_long nfa-regexec-nl [#_regmatch_C rmp, #_Bytes line, #_int col, #_boolean line_lbr]
    ;; line: string to match against
    ;; col: column to start looking for match
    (reset! reg_match rmp)
    (reset! reg_mmatch nil)
    (reset! reg_maxline 0)
    (reset! reg_line_lbr line_lbr)
    (reset! reg_buf @curbuf)
    (reset! reg_win nil)
    (reset! ireg_ic (:rm_ic rmp))
    (reset! ireg_icombine false)
    (reset! ireg_maxcol 0)

    (nfa-regexec-both line, col, nil))

;; Match a regexp against multiple lines.
;; "rmp.regprog" is a compiled regexp as returned by vim-regcomp().
;; Uses curbuf for line count and 'iskeyword'.
;;
;; Return <= 0 if there is no match.  Return number of lines contained in the match otherwise.
;;
;; Note: the body is the same as bt_regexec() except for nfa-regexec-both()
;;
;; ! Also NOTE : match may actually be in another line. e.g.:
;; when r.e. is \nc, cursor is at 'a' and the text buffer looks like
;;
;; +-------------------------+
;; |a                        |
;; |b                        |
;; |c                        |
;; |                         |
;; +-------------------------+
;;
;; then nfa-regexec-multi() returns 3. while the original
;; vim-regexec-multi() returns 0 and a second call at line 2 will return 2.
;;
;; FIXME if this behavior is not compatible.

(defn- #_long nfa-regexec-multi [#_regmmatch_C rmp, #_window_C win, #_buffer_C buf, #_long lnum, #_int col, #_long nsec]
    ;; win: window in which to search or null
    ;; buf: buffer in which to search
    ;; lnum: nr of line to start looking for match
    ;; col: column to start looking for match
    ;; nsec: timeout limit or 0
    (reset! reg_match nil)
    (reset! reg_mmatch rmp)
    (reset! reg_buf buf)
    (reset! reg_win win)
    (reset! reg_firstlnum lnum)
    (reset! reg_maxline (- (:ml_line_count (:b_ml @reg_buf)) lnum))
    (reset! reg_line_lbr false)
    (reset! ireg_ic (:rmm_ic rmp))
    (reset! ireg_icombine false)
    (reset! ireg_maxcol (:rmm_maxcol rmp))

    (nfa-regexec-both nil, col, nsec))

;; ----------------------------------------------------------------------- ;;

;; Which regexp engine to use?  Needed for vim-regcomp().
;; Must match with 'regexpengine'.

(atom! int regexp_engine)

;; Compile a regular expression into internal code.
;; Returns the program in allocated memory.
;; Returns null for an error.

(defn- #_regprog_C vim-regcomp [#_Bytes expr_arg, #_int re_flags]
    (ยง
        ((ร regprog_C prog =) nil)
        ((ร Bytes expr =) expr_arg)

        (reset! regexp_engine (int @p_re))

        ;; Check for prefix "\%#=", that sets the regexp engine.
        (when (zero? (STRNCMP expr, (u8 "\\%#="), 4))
            ((ร int newengine =) (- (.at expr 4) (byte \0)))

            (cond (or (== newengine AUTOMATIC_ENGINE) (== newengine BACKTRACKING_ENGINE) (== newengine NFA_ENGINE))
            (do
                (reset! regexp_engine (- (.at expr 4) (byte \0)))
                ((ร expr =) (.plus expr 5))
            )
            :else
            (do
                (emsg (u8 "E864: \\%#= can only be followed by 0, 1, or 2. The automatic engine will be used."))
                (reset! regexp_engine AUTOMATIC_ENGINE)
            ))
        )

        ((ร bt_regengine.expr =) expr)
        ((ร nfa_regengine.expr =) expr)

        ;; First try the NFA engine, unless backtracking was requested.

        ((ร prog =) (if (!= @regexp_engine BACKTRACKING_ENGINE)
            (.regcomp nfa_regengine expr, (+ re_flags (if (== @regexp_engine AUTOMATIC_ENGINE) RE_AUTO 0)))
            (.regcomp bt_regengine expr, re_flags)
        ))

        ;; Check for error compiling regexp with initial engine.
        (when (nil? prog)
            ;; If the NFA engine failed, try the backtracking engine.
            ;; The NFA engine also fails for patterns that it can't handle well
            ;; but are still valid patterns, thus a retry should work.

            (when (== @regexp_engine AUTOMATIC_ENGINE)
                (reset! regexp_engine BACKTRACKING_ENGINE)
                ((ร prog =) (.regcomp bt_regengine expr, re_flags))
            )
        )

        (when (non-nil? prog)
            ;; Store the info needed to call regcomp() again when
            ;; the engine turns out to be very slow executing it.
            ((ร prog.re_engine =) @regexp_engine)
            ((ร prog.re_flags =) re_flags)
        )

        prog
    ))

(defn- #_void report-re-switch [#_Bytes pat]
    (when (< 0 @p_verbose)
        (msg-puts (u8 "Switching to backtracking RE engine for pattern: "))
        (msg-puts pat)
    )
    nil)

;; Match a regexp against a string.
;; "rmp.regprog" is a compiled regexp as returned by vim-regcomp().
;; Note: "rmp.regprog" may be freed and changed.
;; Uses curbuf for line count and 'iskeyword'.
;; When "nl" is true, consider a "\n" in "line" to be a line break.
;;
;; Return true if there is a match, false if not.

(defn- #_boolean vim-regexec-both [#_regmatch_C rmp, #_Bytes line, #_int col, #_boolean nl]
    ;; line: string to match against
    ;; col: column to start looking for match
    (ยง
        ((ร long result =) (.regexec_nl (:engine (:regprog rmp)) rmp, line, col, nl))

        ;; NFA engine aborted because it's very slow.
        (when (and (== (:re_engine (:regprog rmp)) AUTOMATIC_ENGINE) (== result NFA_TOO_EXPENSIVE))
            ((ร long save_p_re =) @p_re)
            ((ร int re_flags =) (:re_flags (:regprog rmp)))
            ((ร Bytes pat =) (STRDUP (:pattern (ร (nfa_regprog_C)(rmp.regprog)))))

            (reset! p_re BACKTRACKING_ENGINE)
            ((ร rmp.regprog =) nil)
            (when (non-nil? pat)
                (report-re-switch pat)
                ((ร rmp.regprog =) (vim-regcomp pat, re_flags))
                (if (non-nil? (:regprog rmp))
                    ((ร result =) (.regexec_nl (:engine (:regprog rmp)) rmp, line, col, nl))
                )
            )
            (reset! p_re save_p_re)
        )

        (< 0 result)
    ))

;; Note: "*prog" may be freed and changed.
;; Return true if there is a match, false if not.

(defn- #_boolean vim-regexec-prog [#_regprog_C* prog, #_boolean ignore_case, #_Bytes line, #_int col]
    (ยง
        ((ร regmatch_C regmatch =) (NEW_regmatch_C))
        ((ร regmatch.regprog =) (... prog 0))
        ((ร regmatch.rm_ic =) ignore_case)

        ((ร boolean r =) (vim-regexec-both regmatch, line, col, false))

        ((ร prog[0] =) (:regprog regmatch))
        r
    ))

;; Note: "rmp.regprog" may be freed and changed.
;; Return true if there is a match, false if not.

(defn- #_boolean vim-regexec [#_regmatch_C rmp, #_Bytes line, #_int col]
    (vim-regexec-both rmp, line, col, false))

;; Like vim-regexec(), but consider a "\n" in "line" to be a line break.
;; Note: "rmp.regprog" may be freed and changed.
;; Return true if there is a match, false if not.

(defn- #_boolean vim-regexec-nl [#_regmatch_C rmp, #_Bytes line, #_int col]
    (vim-regexec-both rmp, line, col, true))

;; Match a regexp against multiple lines.
;; "rmp.regprog" is a compiled regexp as returned by vim-regcomp().
;; Note: "rmp.regprog" may be freed and changed.
;; Uses curbuf for line count and 'iskeyword'.
;;
;; Return zero if there is no match.  Return number of lines contained in the match otherwise.

(defn- #_long vim-regexec-multi [#_regmmatch_C rmp, #_window_C win, #_buffer_C buf, #_long lnum, #_int col, #_long nsec]
    ;; win: window in which to search or null
    ;; buf: buffer in which to search
    ;; lnum: nr of line to start looking for match
    ;; col: column to start looking for match
    ;; nsec: timeout limit or 0
    (ยง
        ((ร long result =) (.regexec_multi (:engine (:regprog rmp)) rmp, win, buf, lnum, col, nsec))

        ;; NFA engine aborted because it's very slow.
        (when (and (== (:re_engine (:regprog rmp)) AUTOMATIC_ENGINE) (== result NFA_TOO_EXPENSIVE))
            ((ร long save_p_re =) @p_re)
            ((ร int re_flags =) (:re_flags (:regprog rmp)))
            ((ร Bytes pat =) (STRDUP (:pattern (ร (nfa_regprog_C)(rmp.regprog)))))

            (reset! p_re BACKTRACKING_ENGINE)
            ((ร rmp.regprog =) nil)
            (when (non-nil? pat)
                (report-re-switch pat)
                ((ร rmp.regprog =) (vim-regcomp pat, re_flags))
                (if (non-nil? (:regprog rmp))
                    ((ร result =) (.regexec_multi (:engine (:regprog rmp)) rmp, win, buf, lnum, col, nsec))
                )
            )
            (reset! p_re save_p_re)
        )

        (Math/max 0, result)
    ))

;;; ============================================================================================== VimP

;; search.c: code for normal mode searching commands ----------------------------------------------

;; This file contains various searching-related routines.  These fall into
;; three groups:
;; 1. string searches (for /, ?, n, and N)
;; 2. character searches within a single line (for f, F, t, T, etc)
;; 3. "other" kinds of searches like the '%' command, and 'word' searches.

;; String searches
;;
;; The string search functions are divided into two levels:
;; lowest:  searchit(); uses an pos_C for starting position and found match.
;; Highest: do-search(); uses curwin.w_cursor; calls searchit().
;;
;; The last search pattern is remembered for repeating the same search.
;; This pattern is shared between the :g, :s, ? and / commands.
;; This is in search-regcomp().
;;
;; The actual string matching is done using a heavily modified version of
;; Henry Spencer's regular expression library.  See regexp.c.

;; The offset for a search command is store in a soff struct.
;; Note: only spats[0].sp_off is really used.
(class! #_final soffset_C
    [
        (field byte         dir)            ;; search direction, '/' or '?'
        (field boolean      line)           ;; search has line offset
        (field boolean      end)            ;; search set cursor at end
        (field long         off)            ;; line or char offset
    ])

(defn- #_void COPY-soffset [#_soffset_C so1, #_soffset_C so0]
    (ยง
        ((ร so1.dir =) (:dir so0))
        ((ร so1.line =) (:line so0))
        ((ร so1.end =) (:end so0))
        ((ร so1.off =) (:off so0))
        nil
    ))

;; A search pattern and its attributes are stored in a spat struct.
(class! #_final spat_C
    [
        (field Bytes        pat)            ;; the pattern (in allocated memory) or null
        (field boolean      magic)          ;; magicness of the pattern
        (field boolean      no_scs)         ;; no smartcase for this pattern
        (field soffset_C    sp_off      (NEW_soffset_C))
    ])

(defn- #_spat_C new-spat []
    (ยง
        ((ร spat_C sp =) (NEW_spat_C))

        ((ร sp.magic =) true)
        ((ร sp.sp_off.dir =) (byte \/))

        sp
    ))

;; Two search patterns are remembered: one for the :substitute command and one for other searches.
;; last_idx points to the one that was used the last time.

(atom! spat_C* #_"/*[2]*/" spats
    [
        new-spat(),                     ;; last used search pat
        new-spat()                      ;; last used substitute pat
    ])
(atom! int last_idx)        ;; index in spats[] for RE_LAST

(atom! Bytes mr_pattern)   ;; pattern used by search-regcomp()

;; translate search pattern for vim-regcomp()
;;
;; pat_save == RE_SEARCH: save pat in spats[RE_SEARCH].pat (normal search cmd)
;; pat_save == RE_SUBST: save pat in spats[RE_SUBST].pat (:substitute command)
;; pat_save == RE_BOTH: save pat in both patterns (:global command)
;; pat_use  == RE_SEARCH: use previous search pattern if "pat" is null
;; pat_use  == RE_SUBST: use previous substitute pattern if "pat" is null
;; pat_use  == RE_LAST: use last used pattern if "pat" is null
;; options & SEARCH_HIS: put search string in history
;; options & SEARCH_KEEP: keep previous search pattern
;;
;; returns false if failed, true otherwise.

(defn- #_boolean search-regcomp [#_Bytes pat, #_int pat_save, #_int pat_use, #_int options, #_regmmatch_C regmatch]
    ;; regmatch: return: pattern and ignore-case flag
    (ยง
        (reset! rc_did_emsg false)
        ((ร boolean magic =) @p_magic)

        ;; If no pattern given, use a previously defined pattern.

        (cond (or (nil? pat) (eos? pat))
        (do
            ((ร int i =) (if (== pat_use RE_LAST) @last_idx pat_use))
            (when (nil? (:pat (... @spats i)))           ;; pattern was never defined
                (emsg (if (== pat_use RE_SUBST) e_nopresub e_noprevre))
                (reset! rc_did_emsg true)
                ((ร RETURN) false)
            )
            ((ร pat =) (:pat (... @spats i)))
            ((ร magic =) (:magic (... @spats i)))
            (reset! no_smartcase (:no_scs (... @spats i)))
        )
        (flag? options SEARCH_HIS)   ;; put new pattern in history
        (do
            (add-to-history HIST_SEARCH, pat, NUL)
        ))

        (reset! mr_pattern pat)

        ;; Save the currently used pattern in the appropriate place,
        ;; unless the pattern should not be remembered.

        (when (non-flag? options SEARCH_KEEP)
            ;; search or global command
            (if (or (== pat_save RE_SEARCH) (== pat_save RE_BOTH))
                (save-re-pat RE_SEARCH, pat, magic))
            ;; substitute or global command
            (if (or (== pat_save RE_SUBST) (== pat_save RE_BOTH))
                (save-re-pat RE_SUBST, pat, magic))
        )

        ((ร regmatch.rmm_ic =) (ignorecase pat))
        ((ร regmatch.rmm_maxcol =) 0)
        ((ร regmatch.regprog =) (vim-regcomp pat, (if magic RE_MAGIC 0)))

        (non-nil? (:regprog regmatch))
    ))

;; Get search pattern used by search-regcomp().

(defn- #_Bytes get-search-pat []
    @mr_pattern)

(defn- #_void save-re-pat [#_int idx, #_Bytes pat, #_boolean magic]
    (ยง
        (when (BNE (:pat (... @spats idx)), pat)
            ((ร @spats[idx].pat =) (STRDUP pat))
            ((ร @spats[idx].magic =) magic)
            ((ร @spats[idx].no_scs =) @no_smartcase)
            (reset! last_idx idx)
            ;; If 'hlsearch' set and search 'pat' changed: need redraw.
            (if @p_hls
                (redraw-all-later SOME_VALID))
            (reset! no_hlsearch false)
        )
        nil
    ))

;; Return true when case should be ignored for search pattern "pat".
;; Uses the 'ignorecase' and 'smartcase' options.

(defn- #_boolean ignorecase [#_Bytes pat]
    (ยง
        ((ร boolean ic =) @p_ic)

        (if (and ic (not @no_smartcase) @p_scs)
            ((ร ic =) (not (pat-has-uppercase pat)))
        )
        (reset! no_smartcase false)

        ic
    ))

;; Return true if patter "pat" has an uppercase character.

(defn- #_boolean pat-has-uppercase [#_Bytes pat]
    (ยง
        ((ร Bytes p =) pat)

        (while (non-eos? p)
            ((ร int len =) (us-ptr2len-cc p))
            (cond (< 1 len)
            (do
                (if (utf-isupper (us-ptr2char p))
                    ((ร RETURN) true)
                )
                ((ร p =) (.plus p len))
            )
            (== (.at p 0) (byte \\))
            (do
                (cond (and (== (.at p 1) (byte \_)) (non-eos? p 2))         ;; skip "\_X"
                (do
                    ((ร p =) (.plus p 3))
                )
                (and (== (.at p 1) (byte \%)) (non-eos? p 2))    ;; skip "\%X"
                (do
                    ((ร p =) (.plus p 3))
                )
                (non-eos? p 1)                   ;; skip "\X"
                (do
                    ((ร p =) (.plus p 2))
                )
                :else
                (do
                    ((ร p =) (.plus p 1))
                ))
            )
            (utf-isupper (.at p 0))
            (do
                ((ร RETURN) true)
            )
            :else
            (do
                ((ร p =) (.plus p 1))
            ))
        )
        false
    ))

(defn- #_Bytes last-search-pat []
    (:pat (... @spats @last_idx)))

;; Get a regexp program for the last used search pattern.
;; This is used for highlighting all matches in a window.
;; Values returned in regmatch.regprog and regmatch.rmm_ic.

(defn- #_void last-pat-prog [#_regmmatch_C regmatch]
    (ยง
        (when (nil? (:pat (... @spats @last_idx)))
            ((ร regmatch.regprog =) nil)
            ((ร RETURN) nil)
        )

        (swap! emsg_off inc)         ;; So it doesn't beep if bad expr
        (search-regcomp (u8 ""), 0, @last_idx, SEARCH_KEEP, regmatch)
        (swap! emsg_off dec)
        nil
    ))

(final Bytes top_bot_msg (u8 "search hit TOP, continuing at BOTTOM"))
(final Bytes bot_top_msg (u8 "search hit BOTTOM, continuing at TOP"))

;; Lowest level search function.
;; Search for 'count'th occurrence of pattern 'pat' in direction 'dir'.
;; Start at position 'pos' and return the found position in 'pos'.
;;
;; if (options & SEARCH_MSG) == 0 don't give any messages
;; if (options & SEARCH_MSG) == SEARCH_NFMSG don't give 'notfound' messages
;; if (options & SEARCH_MSG) == SEARCH_MSG give all messages
;; if (options & SEARCH_HIS) put search pattern in history
;; if (options & SEARCH_END) return position at end of match
;; if (options & SEARCH_START) accept match at pos itself
;; if (options & SEARCH_KEEP) keep previous search pattern
;; if (options & SEARCH_FOLD) match only once in a closed fold
;; if (options & SEARCH_PEEK) check for typed char, cancel search
;;
;; Return false (zero) for failure, non-zero for success.
;; When FEAT_EVAL is defined, returns the index of the first matching
;; subpattern plus one; one if there was none.

(defn- #_int searchit [#_window_C win, #_buffer_C buf, #_pos_C pos, #_int dir, #_Bytes pat, #_long count, #_int options, #_int pat_use, #_long stop_lnum, #_long nsec]
    ;; win: window to search in; can be null for a buffer without a window!
    ;; pat_use: which pattern to use when "pat" is empty
    ;; stop_lnum: stop after this line number when != 0
    ;; nsec: timeout limit or 0
    (ยง
        ((ร int submatch =) 0)

        ((ร boolean first_match =) true)
        ((ร boolean save_called_emsg =) @called_emsg)
        ((ร boolean break_loop =) false)

        ((ร regmmatch_C regmatch =) (NEW_regmmatch_C))
        (when (not (search-regcomp pat, RE_SEARCH, pat_use, (& options (+ SEARCH_HIS SEARCH_KEEP)), regmatch))
            (if (and (flag? options SEARCH_MSG) (not @rc_did_emsg))
                (emsg2 (u8 "E383: Invalid search string: %s"), @mr_pattern))
            ((ร RETURN) 0)
        )

        (ร boolean found)
        (ร long lnum)

        ((ร pos_C start_pos =) (NEW_pos_C))
        ((ร lpos_C matchpos =) (NEW_lpos_C))
        ((ร lpos_C endpos =) (NEW_lpos_C))

        ;; find the string

        (reset! called_emsg false)
;       do  ;; loop for count
;       {
            ;; When not accepting a match at the start position, set "extra_col" to a non-zero value.
            ;; Don't do that when starting at MAXCOL, since MAXCOL + 1 is zero.
            (ร int extra_col)
            (cond (or (flag? options SEARCH_START) (== (:col pos) MAXCOL))
            (do
                ((ร extra_col =) 0)
            )
            ;; Watch out for the "col" being MAXCOL - 2, used in a closed fold.
            (and (!= dir BACKWARD) (<= 1 (:lnum pos)) (<= (:lnum pos) (:ml_line_count (:b_ml buf))) (< (:col pos) (- MAXCOL 2)))
            (do
                ((ร Bytes ptr =) (.plus (ml-get-buf buf, (:lnum pos)) (:col pos)))
                ((ร extra_col =) (if (eos? ptr) 1 (us-ptr2len-cc ptr)))
            )
            :else
            (do
                ((ร extra_col =) 1)
            ))

            (COPY-pos start_pos, pos)       ;; remember start pos for detecting no match
            ((ร found =) false)                  ;; default: not found
            ((ร boolean at_first_line =) true)   ;; default: start in first line
            (when (zero? (:lnum pos))              ;; correct lnum for when starting in line 0
                ((ร pos.lnum =) 1)
                ((ร pos.col =) 0)
                ((ร at_first_line =) false)      ;; not in first line now
            )

            ;; Start searching in current line, unless searching backwards and we're in column 0.
            ;; If we are searching backwards, in column 0, and not including the
            ;; current position, gain some efficiency by skipping back a line.
            ;; Otherwise begin the search in the current line.

            (cond (and (== dir BACKWARD) (zero? (:col start_pos)) (non-flag? options SEARCH_START))
            (do
                ((ร lnum =) (- (:lnum pos) 1))
                ((ร at_first_line =) false)
            )
            :else
            (do
                ((ร lnum =) (:lnum pos))
            ))

            ((ร FOR) (ร ((ร int loop =) 0) (<= loop 1) (ร loop++))   ;; loop twice if 'wrapscan' set
                ((ร FOR) (ร nil (and (< 0 lnum) (<= lnum (:ml_line_count (:b_ml buf)))) ((ร lnum =) (+ lnum (ร dir, at_first_line = false))))
                    ;; Stop after checking "stop_lnum", if it's set.
                    (if (and (non-zero? stop_lnum) (if (== dir FORWARD) (< stop_lnum lnum) (< lnum stop_lnum)))
                        (ร BREAK)
                    )
                    ;; Stop after passing the 'nsec' time limit.
                    (if (and (non-zero? nsec) (profile-passed-limit nsec))
                        (ร BREAK)
                    )

                    ;; Look for a match somewhere in line "lnum".

                    ((ร long nmatched =) (vim-regexec-multi regmatch, win, buf, lnum, 0, nsec))
                    ;; Abort searching on an error (e.g., out of stack).
                    (if @called_emsg
                        (ร BREAK)
                    )
                    (when (< 0 nmatched)
                        ;; match may actually be in another line when using \zs
                        (COPY-lpos matchpos, (... (:startpos regmatch) 0))
                        (COPY-lpos endpos, (... (:endpos regmatch) 0))
                        ((ร submatch =) (first-submatch regmatch))
                        ;; "lnum" may be past end of buffer for "\n\zs".
                        ((ร Bytes ptr =) (if (< (:ml_line_count (:b_ml buf)) (+ lnum (:lnum matchpos))) (u8 "") (ml-get-buf buf, (+ lnum (:lnum matchpos)))))

                        ;; Forward search in the first line: match should be after
                        ;; the start position.  If not, continue at the end of the
                        ;; match (this is vi compatible) or on the next char.

                        (when (and (== dir FORWARD) at_first_line)
                            ((ร boolean match_ok =) true)

                            ;; When the match starts in a next line it's certainly
                            ;; past the start position.
                            ;; When match lands on a NUL the cursor will be put
                            ;; one back afterwards, compare with that position,
                            ;; otherwise "/$" will get stuck on end of line.

                            (while (and (zero? (:lnum matchpos)) (if (and (flag? options SEARCH_END) first_match) (and (== nmatched 1) (< (- (:col endpos) 1) (+ (:col start_pos) extra_col))) (< (- (:col matchpos) (if (== (.at ptr (:col matchpos)) NUL) 1 0)) (+ (:col start_pos) extra_col))))
                                ;; If vi-compatible searching, continue at the end
                                ;; of the match, otherwise continue one position forward.

                                (ร int matchcol)
                                (cond (non-nil? (vim-strbyte @p_cpo, CPO_SEARCH))
                                (do
                                    (when (< 1 nmatched)
                                        ;; end is in next line, thus no match in this line
                                        ((ร match_ok =) false)
                                        (ร BREAK)
                                    )
                                    ((ร matchcol =) (:col endpos))
                                    ;; for empty match: advance one char
                                    (if (and (== matchcol (:col matchpos)) (non-eos? ptr matchcol))
                                        ((ร matchcol =) (+ matchcol (us-ptr2len-cc (.plus ptr matchcol))))
                                    )
                                )
                                :else
                                (do
                                    ((ร matchcol =) (:col matchpos))
                                    (if (non-eos? ptr matchcol)
                                        ((ร matchcol =) (+ matchcol (us-ptr2len-cc (.plus ptr matchcol))))
                                    )
                                ))
                                (if (and (zero? matchcol) (flag? options SEARCH_START))
                                    (ร BREAK)
                                )
                                (when (or (eos? ptr matchcol) (zero? ((ร nmatched =) (vim-regexec-multi regmatch, win, buf, (+ lnum (:lnum matchpos)), matchcol, nsec))))
                                    ((ร match_ok =) false)
                                    (ร BREAK)
                                )
                                (COPY-lpos matchpos, (... (:startpos regmatch) 0))
                                (COPY-lpos endpos, (... (:endpos regmatch) 0))
                                ((ร submatch =) (first-submatch regmatch))

                                ;; Need to get the line pointer again,
                                ;; a multi-line search may have made it invalid.
                                ((ร ptr =) (ml-get-buf buf, (+ lnum (:lnum matchpos))))
                            )
                            (if (not match_ok)
                                (ร CONTINUE)
                            )
                        )
                        (when (== dir BACKWARD)
                            ;; Now, if there are multiple matches on this line,
                            ;; we have to get the last one.  Or the last one before
                            ;; the cursor, if we're on that line.
                            ;; When putting the new cursor at the end, compare
                            ;; relative to the end of the match.

                            ((ร boolean match_ok =) false)
                            (while true
                                ;; Remember a position that is before the start
                                ;; position, we use it if it's the last match in
                                ;; the line.  Always accept a position after
                                ;; wrapping around.
                                (cond (or (non-zero? loop) (if (flag? options SEARCH_END) (or (< (+ lnum (:lnum (... (:endpos regmatch) 0))) (:lnum start_pos)) (and (== (+ lnum (:lnum (... (:endpos regmatch) 0))) (:lnum start_pos)) (<= (+ (- (:col (... (:endpos regmatch) 0)) 1) extra_col) (:col start_pos)))) (or (< (+ lnum (:lnum (... (:startpos regmatch) 0))) (:lnum start_pos)) (and (== (+ lnum (:lnum (... (:startpos regmatch) 0))) (:lnum start_pos)) (<= (+ (:col (... (:startpos regmatch) 0)) extra_col) (:col start_pos))))))
                                (do
                                    ((ร match_ok =) true)
                                    (COPY-lpos matchpos, (... (:startpos regmatch) 0))
                                    (COPY-lpos endpos, (... (:endpos regmatch) 0))
                                    ((ร submatch =) (first-submatch regmatch))
                                )
                                :else
                                (do
                                    (ร BREAK)
                                ))

                                ;; We found a valid match, now check if there is another one after it.
                                ;; If vi-compatible searching, continue at the end of the match,
                                ;; otherwise continue one position forward.

                                (ร int matchcol)
                                (cond (non-nil? (vim-strbyte @p_cpo, CPO_SEARCH))
                                (do
                                    (if (< 1 nmatched)
                                        (ร BREAK)
                                    )
                                    ((ร matchcol =) (:col endpos))
                                    ;; for empty match: advance one char
                                    (if (and (== matchcol (:col matchpos)) (non-eos? ptr matchcol))
                                        ((ร matchcol =) (+ matchcol (us-ptr2len-cc (.plus ptr matchcol))))
                                    )
                                )
                                :else
                                (do
                                    ;; Stop when the match is in a next line.
                                    (if (< 0 (:lnum matchpos))
                                        (ร BREAK)
                                    )
                                    ((ร matchcol =) (:col matchpos))
                                    (if (non-eos? ptr matchcol)
                                        ((ร matchcol =) (+ matchcol (us-ptr2len-cc (.plus ptr matchcol))))
                                    )
                                ))
                                (when (or (eos? ptr matchcol) (zero? ((ร nmatched =) (vim-regexec-multi regmatch, win, buf, (+ lnum (:lnum matchpos)), matchcol, nsec))))
                                    (ร BREAK)
                                )

                                ;; Need to get the line pointer again,
                                ;; a multi-line search may have made it invalid.
                                ((ร ptr =) (ml-get-buf buf, (+ lnum (:lnum matchpos))))
                            )

                            ;; If there is only a match after the cursor, skip this match.

                            (if (not match_ok)
                                (ร CONTINUE)
                            )
                        )

                        ;; With the SEARCH_END option move to the last character of the match.
                        ;; Don't do it for an empty match, end should be same as start then.
                        (cond (and (flag? options SEARCH_END) (non-flag? options SEARCH_NOOF) (or (!= (:lnum matchpos) (:lnum endpos)) (!= (:col matchpos) (:col endpos))))
                        (do
                            ;; For a match in the first column,
                            ;; set the position on the NUL in the previous line.
                            ((ร pos.lnum =) (+ lnum (:lnum endpos)))
                            ((ร pos.col =) (:col endpos))
                            (cond (zero? (:col endpos))
                            (do
                                (when (< 1 (:lnum pos))   ;; just in case
                                    (ร --pos.lnum)
                                    ((ร pos.col =) (STRLEN (ml-get-buf buf, (:lnum pos))))
                                )
                            )
                            :else
                            (do
                                (ร --pos.col)
                                (when (<= (:lnum pos) (:ml_line_count (:b_ml buf)))
                                    ((ร ptr =) (ml-get-buf buf, (:lnum pos)))
                                    ((ร pos.col =) (- (:col pos) (us-head-off ptr, (.plus ptr (:col pos)))))
                                )
                            ))
                        )
                        :else
                        (do
                            ((ร pos.lnum =) (+ lnum (:lnum matchpos)))
                            ((ร pos.col =) (:col matchpos))
                        ))
                        ((ร pos.coladd =) 0)
                        ((ร found =) true)
                        ((ร first_match =) false)

                        ;; Set variables used for 'incsearch' highlighting.
                        (reset! search_match_lines (- (:lnum endpos) (:lnum matchpos)))
                        (reset! search_match_endcol (:col endpos))
                        (ร BREAK)
                    )
                    (line-breakcheck)      ;; stop if ctrl-C typed
                    (if @got_int
                        (ร BREAK)
                    )

                    ;; Cancel searching if a character was typed.  Used for 'incsearch'.
                    ;; Don't check too often, that would slowdown searching too much.
                    (when (and (flag? options SEARCH_PEEK) (zero? (& (- lnum (:lnum pos)) 0x3f)) (char-avail))
                        ((ร break_loop =) true)
                        (ร BREAK)
                    )

                    (if (and (non-zero? loop) (== lnum (:lnum start_pos)))
                        (ร BREAK)              ;; if second loop, stop where started
                    )
                )
                ((ร at_first_line =) false)

                ;; Stop the search if wrapscan isn't set, "stop_lnum" is specified,
                ;; after an interrupt, after a match and after looping twice.

                (if (or (not @p_ws) (non-zero? stop_lnum) @got_int @called_emsg break_loop found (non-zero? loop))
                    (ร BREAK)
                )

                ;; If 'wrapscan' is set we continue at the other end of the file.
                ;; This message is also remembered in "keep_msg" for when the screen is redrawn.
                ;; The "keep_msg" is cleared whenever another message is written.

                ((ร lnum =) (if (== dir BACKWARD) (:ml_line_count (:b_ml buf)) 1))    ;; start second loop at the other end
                (if (flag? options SEARCH_MSG)
                    (give-warning (if (== dir BACKWARD) top_bot_msg bot_top_msg), true))
            )
            (if (or @got_int @called_emsg break_loop)
                (ร BREAK)
            )
;       } while (0 < --count && found);     ;; stop after count matches or no match

        ((ร @called_emsg =) (| @called_emsg save_called_emsg))

        (when (not found)             ;; did not find it
            (cond @got_int
            (do
                (emsg e_interr)
            )
            (== (& options SEARCH_MSG) SEARCH_MSG)
            (do
                (cond @p_ws
                (do
                    (emsg2 e_patnotf2, @mr_pattern)
                )
                (zero? lnum)
                (do
                    (emsg2 (u8 "E384: search hit TOP without match for: %s"), @mr_pattern)
                )
                :else
                (do
                    (emsg2 (u8 "E385: search hit BOTTOM without match for: %s"), @mr_pattern)
                ))
            ))
            ((ร RETURN) 0)
        )

        ;; A pattern like "\n\zs" may go past the last line.
        (when (> (:lnum pos) (:ml_line_count (:b_ml buf)))
            ((ร pos.lnum =) (:ml_line_count (:b_ml buf)))
            ((ร pos.col =) (STRLEN (ml-get-buf buf, (:lnum pos))))
            (if (< 0 (:col pos))
                (ร --pos.col)
            )
        )

        (+ 1 submatch)
    ))

;; Return the number of the first subpat that matched.

(defn- #_int first-submatch [#_regmmatch_C rp]
    (ยง
        (ร int submatch)

        ((ร FOR) (ร ((ร submatch =) 1) true (ร submatch++))
            (if (<= 0 (:lnum (... (:startpos rp) submatch)))
                (ร BREAK)
            )
            (when (== submatch 9)
                ((ร submatch =) 0)
                (ร BREAK)
            )
        )

        submatch
    ))

;; Highest level string search function.
;; Search for the 'count'th occurrence of pattern 'pat' in direction 'dirc'
;;                If 'dirc' is 0: use previous dir.
;;    If 'pat' is null or empty : use previous string.
;;    If 'options & SEARCH_REV' : go in reverse of previous dir.
;;    If 'options & SEARCH_ECHO': echo the search command and handle options
;;    If 'options & SEARCH_MSG' : may give error message
;;    If 'options & SEARCH_OPT' : interpret optional flags
;;    If 'options & SEARCH_HIS' : put search pattern in history
;;    If 'options & SEARCH_NOOF': don't add offset to position
;;    If 'options & SEARCH_MARK': set previous context mark
;;    If 'options & SEARCH_KEEP': keep previous search pattern
;;    If 'options & SEARCH_START': accept match at curpos itself
;;    If 'options & SEARCH_PEEK': check for typed char, cancel search
;;
;; Careful: If spats[0].sp_off.line == true and spats[0].sp_off.off == 0,
;; this makes the movement linewise without moving the match position.
;;
;; Return 0 for failure, 1 for found, 2 for found and line offset added.

(defn- #_int do-search [#_oparg_C oap, #_byte dirc, #_Bytes pat, #_long count, #_int options, #_long nsec]
    ;; oap: can be null
    ;; dirc: '/' or '?'
    ;; nsec: timeout limit or 0
    (ยง
        (ร int retval)

        ;; A line offset is not remembered, this is vi compatible.

        (when (and (:line (:sp_off (... @spats 0))) (non-nil? (vim-strbyte @p_cpo, CPO_LINEOFF)))
            ((ร @spats[0].sp_off.line =) false)
            ((ร @spats[0].sp_off.off =) 0)
        )

        ;; Save the values for when (options & SEARCH_KEEP) is used.
        ;; (there is no "if ()" around this because gcc wants them initialized)

        ((ร soffset_C old_off =) (NEW_soffset_C))
        (COPY-soffset old_off, (:sp_off (... @spats 0)))

        ;; position of the last match
        ((ร pos_C pos =) (NEW_pos_C))
        (COPY-pos pos, (:w_cursor @curwin)) ;; start searching at the cursor position

        ;; Find out the direction of the search.

        (if (zero? dirc)
            ((ร dirc =) (:dir (:sp_off (... @spats 0))))
            ((ร @spats[0].sp_off.dir =) dirc)
        )

        (when (flag? options SEARCH_REV)
            ((ร dirc =) (if (== dirc (byte \/)) (byte \?) (byte \/)))
        )

        ;; Turn 'hlsearch' highlighting back on.

        (when (and @no_hlsearch (non-flag? options SEARCH_KEEP))
            (redraw-all-later SOME_VALID)
            (reset! no_hlsearch false)
        )

;       end_do_search:
;       {
; %%        ((ร Bytes[] strcopy =) (ร { null }))

            ;; Repeat the search when pattern followed by ';', e.g. "/foo/;?bar".

            (while true
                ((ร Bytes searchstr =) pat)                     ;; use previous pattern
                ((ร Bytes dircp =) nil)

                (when (or (nil? pat) (eos? pat) (== (.at pat 0) dirc))
                    (cond (nil? (:pat (... @spats RE_SEARCH)))       ;; no previous pattern
                    (do
                        ((ร pat =) (:pat (... @spats RE_SUBST)))
                        (when (nil? pat)
                            (emsg e_noprevre)
                            ((ร retval =) 0)
                            (ร BREAK end_do_search)
                        )
                        ((ร searchstr =) pat)
                    )
                    :else
                    (do
                        ;; make search-regcomp() use spats[RE_SEARCH].pat
                        ((ร searchstr =) (u8 ""))
                    ))
                )

                (when (and (non-nil? pat) (non-eos? pat))            ;; look for (new) offset
                    ;; Find end of regular expression.
                    ;; If there is a matching '/' or '?', toss it.

                    ((ร Bytes ps =) (... strcopy 0))
                    ((ร Bytes p =) (skip-regexp pat, dirc, @p_magic, strcopy))
                    (when (BNE (... strcopy 0), ps)
                        ;; made a copy of "pat" to change "\?" to "?"
                        ((ร @searchcmdlen =) (+ @searchcmdlen (- (STRLEN pat) (STRLEN (... strcopy 0)))))
                        ((ร pat =) (... strcopy 0))
                        ((ร searchstr =) (... strcopy 0))
                    )
                    (when (== (.at p 0) dirc)
                        ((ร dircp =) p)                  ;; remember where we put the NUL
                        (.be ((ร p =) (.plus p 1)) -1, NUL)
                    )
                    ((ร @spats[0].sp_off.line =) false)
                    ((ร @spats[0].sp_off.end =) false)
                    ((ร @spats[0].sp_off.off =) 0)

                    ;; Check for a line offset or a character offset.
                    ;; For get-address (echo off) we don't check for a character offset,
                    ;; because it is meaningless and the 's' could be a substitute command.

                    (cond (or (== (.at p 0) (byte \+)) (== (.at p 0) (byte \-)) (asc-isdigit (.at p 0)))
                    (do
                        ((ร @spats[0].sp_off.line =) true)
                    )
                    (and (flag? options SEARCH_OPT) (or (== (.at p 0) (byte \e)) (== (.at p 0) (byte \s)) (== (.at p 0) (byte \b))))
                    (do
                        (if (== (.at p 0) (byte \e))                           ;; end
                            ((ร @spats[0].sp_off.end =) (!= SEARCH_END 0))
                        )
                        ((ร p =) (.plus p 1))
                    ))
                    (when (or (asc-isdigit (.at p 0)) (== (.at p 0) (byte \+)) (== (.at p 0) (byte \-)))      ;; got an offset
                        (cond (or (asc-isdigit (.at p 0)) (asc-isdigit (.at p 1)))   ;; 'nr' or '+nr' or '-nr'
                        (do
                            ((ร @spats[0].sp_off.off =) (.atol libC p))
                        )
                        (== (.at p 0) (byte \-))                      ;; single '-'
                        (do
                            ((ร @spats[0].sp_off.off =) -1)
                        )
                        :else                                                ;; single '+'
                        (do
                            ((ร @spats[0].sp_off.off =) 1)
                        ))
                        ((ร p =) (.plus p 1))
                        (while (asc-isdigit (.at p 0))                        ;; skip number
                            ((ร p =) (.plus p 1))
                        )
                    )

                    ;; compute length of search command for get-address()
                    ((ร @searchcmdlen =) (+ @searchcmdlen (BDIFF p, pat)))

                    ((ร pat =) p)                        ;; put "pat" after search command
                )

                (when (and (flag? options SEARCH_ECHO) (messaging))
                    ((ร Bytes p =) (if (eos? searchstr) (:pat (... @spats @last_idx)) searchstr))

                    ((ร Bytes msgbuf =) (Bytes. (+ (STRLEN p) 40)))

                    (.be msgbuf 0, dirc)
                    (cond (utf-iscomposing (us-ptr2char p))
                    (do
                        ;; Use a space to draw the composing char on.
                        (.be msgbuf 1, (byte \space))
                        (STRCPY (.plus msgbuf 2), p)
                    )
                    :else
                    (do
                        (STRCPY (.plus msgbuf 1), p)
                    ))

                    (when (or (:line (:sp_off (... @spats 0))) (:end (:sp_off (... @spats 0))) (non-zero? (:off (:sp_off (... @spats 0)))))
                        ((ร p =) (.plus msgbuf (STRLEN msgbuf)))
                        (.be ((ร p =) (.plus p 1)) -1, dirc)
                        (cond (:end (:sp_off (... @spats 0)))
                        (do
                            (.be ((ร p =) (.plus p 1)) -1, (byte \e))
                        )
                        (not (:line (:sp_off (... @spats 0))))
                        (do
                            (.be ((ร p =) (.plus p 1)) -1, (byte \s))
                        ))
                        (if (or (< 0 (:off (:sp_off (... @spats 0)))) (:line (:sp_off (... @spats 0))))
                            (.be ((ร p =) (.plus p 1)) -1, (byte \+))
                        )
                        (if (or (non-zero? (:off (:sp_off (... @spats 0)))) (:line (:sp_off (... @spats 0))))
                            (.sprintf libC p, (u8 "%ld"), (:off (:sp_off (... @spats 0))))
                            (eos! p)
                        )
                    )

                    (msg-start)
                    ((ร Bytes trunc =) (msg-strtrunc msgbuf, false))

                    (if (non-nil? trunc)
                        (msg-outtrans trunc)
                        (msg-outtrans msgbuf))
                    (msg-clr-eos)
                    (msg-check)

                    (gotocmdline false)
                    (out-flush)
                    (reset! msg_nowait true)              ;; don't wait for this message
                )

                ;; If there is a character offset, subtract it from the current
                ;; position, so we don't get stuck at "?pat?e+2" or "/pat/s-2".
                ;; Skip this if pos.col is near MAXCOL (closed fold).
                ;; This is not done for a line offset, because then we would not be vi compatible.

                (when (and (not (:line (:sp_off (... @spats 0)))) (non-zero? (:off (:sp_off (... @spats 0)))) (< (:col pos) (- MAXCOL 2)))
                    (cond (< 0 (:off (:sp_off (... @spats 0))))
                    (do
                        (ร long c)
                        ((ร FOR) (ร ((ร c =) (:off (:sp_off (... @spats 0)))) (non-zero? c) (ร --c))
                            (if (== (decl pos) -1)
                                (ร BREAK)
                            )
                        )
                        (when (non-zero? c)                 ;; at start of buffer
                            ((ร pos.lnum =) 0)           ;; allow lnum == 0 here
                            ((ร pos.col =) MAXCOL)
                        )
                    )
                    :else
                    (do
                        (ร long c)
                        ((ร FOR) (ร ((ร c =) (:off (:sp_off (... @spats 0)))) (non-zero? c) (ร c++))
                            (if (== (incl pos) -1)
                                (ร BREAK)
                            )
                        )
                        (when (non-zero? c)                 ;; at end of buffer
                            ((ร pos.lnum =) (+ (:ml_line_count (:b_ml @curbuf)) 1))
                            ((ร pos.col =) 0)
                        )
                    ))
                )

                ((ร int i =) (searchit @curwin, @curbuf, pos, (if (== dirc (byte \/)) FORWARD BACKWARD), searchstr, count, (+ (if (:end (:sp_off (... @spats 0))) SEARCH_REV 0) (& options (+ SEARCH_KEEP SEARCH_PEEK SEARCH_HIS SEARCH_MSG SEARCH_START (if (and (non-nil? pat) (== (.at pat 0) (byte \;))) 0 SEARCH_NOOF)))), RE_LAST, 0, nsec))

                (if (non-nil? dircp)
                    (.be dircp 0, dirc)          ;; restore second '/' or '?' for normal-cmd()
                )
                (when (zero? i)
                    ((ร retval =) 0)
                    (ร BREAK end_do_search)
                )
                (if (and (:end (:sp_off (... @spats 0))) (non-nil? oap))
                    ((ร oap.inclusive =) true)           ;; 'e' includes last character
                )

                ((ร retval =) 1)                         ;; pattern found

                ;; Add character and/or line offset

                (when (or (non-flag? options SEARCH_NOOF) (and (non-nil? pat) (== (.at pat 0) (byte \;))))
                    (cond (:line (:sp_off (... @spats 0)))       ;; add the offset to the line number
                    (do
                        ((ร long c =) (+ (:lnum pos) (:off (:sp_off (... @spats 0)))))
                        (cond (< c 1)
                        (do
                            ((ร pos.lnum =) 1)
                        )
                        (< (:ml_line_count (:b_ml @curbuf)) c)
                        (do
                            ((ร pos.lnum =) (:ml_line_count (:b_ml @curbuf)))
                        )
                        :else
                        (do
                            ((ร pos.lnum =) c)
                        ))
                        ((ร pos.col =) 0)

                        ((ร retval =) 2)                 ;; pattern found, line offset added
                    )
                    (< (:col pos) (- MAXCOL 2)) ;; just in case
                    (do
                        ((ร long c =) (:off (:sp_off (... @spats 0))))
                        (cond (< 0 c)                  ;; to the right, check for end of file
                        (do
                            (while (< 0 (ร c--))
                                (if (== (incl pos) -1)
                                    (ร BREAK)
                                )
                            )
                        )
                        :else                        ;; to the left, check for start of file
                        (do
                            (while (< (ร c++) 0)
                                (if (== (decl pos) -1)
                                    (ร BREAK)
                                )
                            )
                        ))
                    ))
                )

                ;; The search command can be followed by a ';' to do another search.
                ;; For example: "/pat/;/foo/+3;?bar"
                ;; This is like doing another search command, except:
                ;; - The remembered direction '/' or '?' is from the first search.
                ;; - When an error happens the cursor isn't moved at all.
                ;; Don't do this when called by get-address() (it handles ';' itself).

                (if (or (non-flag? options SEARCH_OPT) (nil? pat) (!= (.at pat 0) (byte \;)))
                    (ร BREAK)
                )

                ((ร dirc =) (.at ((ร pat =) (.plus pat 1)) 0))
                (when (and (!= dirc (byte \?)) (!= dirc (byte \/)))
                    ((ร retval =) 0)
                    (emsg (u8 "E386: Expected '?' or '/'  after ';'"))
                    (ร BREAK end_do_search)
                )
                ((ร pat =) (.plus pat 1))
            )

            (if (flag? options SEARCH_MARK)
                (setpcmark))
            (COPY-pos (:w_cursor @curwin), pos)
            ((ร @curwin.w_set_curswant =) true)
;       }

        (if (flag? options SEARCH_KEEP)
            (COPY-soffset (:sp_off (... @spats 0)), old_off))

        retval
    ))

;; Character Searches

(atom! int sc__lastc NUL)         ;; last character searched for
(atom! int sc__lastcdir)            ;; last direction of character search
(atom! boolean sc__last_t_cmd)      ;; last search t_cmd

(final Bytes sc__bytes (Bytes. (inc MB_MAXBYTES)))
(atom! int sc__bytelen 1)         ;; >1 for multi-byte char

;; Search for a character in a line.  If "t_cmd" is false, move to the
;; position of the character, otherwise move to just before the char.
;; Do this "cap.count1" times.
;; Return false or true.

(defn- #_boolean searchc [#_cmdarg_C cap, #_boolean t_cmd]
    (ยง
        ((ร int c =) @(:nchar cap))                      ;; char to search for
        ((ร int dir =) (:arg cap))                      ;; true for searching forward
        ((ร long count =) (:count1 cap))                ;; repeat count

        ((ร boolean stop =) true)

        (cond (!= c NUL)                           ;; normal search: remember args for repeat
        (do
            (when (not @keyStuffed)                    ;; don't remember when redoing
                (reset! sc__lastc c)
                (reset! sc__lastcdir dir)
                (reset! sc__last_t_cmd t_cmd)
                (reset! sc__bytelen (utf-char2bytes c, sc__bytes))
                (when (non-zero? (:ncharC1 cap))
                    ((ร @sc__bytelen =) (+ @sc__bytelen (utf-char2bytes (:ncharC1 cap), (.plus sc__bytes @sc__bytelen))))
                    (if (non-zero? (:ncharC2 cap))
                        ((ร @sc__bytelen =) (+ @sc__bytelen (utf-char2bytes (:ncharC2 cap), (.plus sc__bytes @sc__bytelen))))
                    )
                )
            )
        )
        :else                                    ;; repeat previous search
        (do
            (if (== @sc__lastc NUL)
                ((ร RETURN) false)
            )
            ((ร dir =) (if (non-zero? dir) (- @sc__lastcdir) @sc__lastcdir))        ;; repeat in opposite direction
            ((ร t_cmd =) @sc__last_t_cmd)
            ((ร c =) @sc__lastc)

            ;; For multi-byte re-use last sc__bytes[] and sc__bytelen.

            ;; Force a move of at least one char, so ";" and "," will move the cursor,
            ;; even if the cursor is right in front of char we are looking at.
            (if (and (nil? (vim-strbyte @p_cpo, CPO_SCOLON)) (== count 1) t_cmd)
                ((ร stop =) false)
            )
        ))

        ((ร cap.oap.inclusive =) (!= dir BACKWARD))

        ((ร Bytes p =) (ml-get-curline))
        ((ร int col =) (:col (:w_cursor @curwin)))
        ((ร int len =) (STRLEN p))

        (while (< 0 (ร count--))
            (while true
                (cond (< 0 dir)
                (do
                    ((ร col =) (+ col (us-ptr2len-cc (.plus p col))))
                    (if (<= len col)
                        ((ร RETURN) false)
                    )
                )
                :else
                (do
                    (if (zero? col)
                        ((ร RETURN) false)
                    )
                    ((ร col =) (- col (+ (us-head-off p, (.plus p (dec col))) 1)))
                ))
                (cond (== @sc__bytelen 1)
                (do
                    (if (and (== (.at p col) c) stop)
                        (ร BREAK)
                    )
                )
                :else
                (do
                    (if (and (zero? (MEMCMP (.plus p col), sc__bytes, @sc__bytelen)) stop)
                        (ร BREAK)
                    )
                ))
                ((ร stop =) true)
            )
        )

        (when t_cmd
            ;; backup to before the character (possibly double-byte)
            ((ร col =) (- col dir))

            (cond (< dir 0)
            (do
                ;; Landed on the search char which is sc__bytelen long.
                ((ร col =) (+ col (dec @sc__bytelen)))
            )
            :else
            (do
                ;; To previous char, which may be multi-byte.
                ((ร col =) (- col (us-head-off p, (.plus p col))))
            ))
        )
        ((ร @curwin.w_cursor.col =) col)

        true
    ))

;; "Other" Searches

;; findmatch - find the matching paren or brace
;;
;; Improvement over vi: Braces inside quotes are ignored.

(defn- #_pos_C findmatch [#_oparg_C oap, #_int initc]
    (findmatchlimit oap, initc, 0, 0))

;; Return true if the character before "linep[col]" equals "ch".
;; Return false if "col" is zero.
;; Update "*prevcol" to the column of the previous character, unless "prevcol" is null.
;; Handles multibyte string correctly.

(defn- #_boolean check-prevcol [#_Bytes linep, #_int col, #_int ch, #_int* prevcol]
    (ยง
        (ร --col)
        (if (< 0 col)
            ((ร col =) (- col (us-head-off linep, (.plus linep col))))
        )
        (if (non-nil? prevcol)
            ((ร prevcol[0] =) col)
        )
        (and (<= 0 col) (== (.at linep col) ch))
    ))

(atom! pos_C _2_pos (NEW_pos_C)) ;; current search position

;; findmatchlimit -- find the matching paren or brace, if it exists within
;; maxtravel lines of here.  A maxtravel of 0 means search until falling off
;; the edge of the file.
;;
;; "initc" is the character to find a match for.  NUL means to find the
;; character at or after the cursor.
;;
;; flags: FM_BACKWARD   search backwards (when initc is '/', '*' or '#')
;;        FM_FORWARD    search forwards (when initc is '/', '*' or '#')
;;        FM_BLOCKSTOP  stop at start/end of block ({ or } in column 0)
;;
;; "oap" is only used to set oap.motion_type for a linewise motion, it be null

(defn- #_pos_C findmatchlimit [#_oparg_C oap, #_int _initc, #_int flags, #_int maxtravel]
    (ยง
; %%    ((ร int[] initc =) (ร { _initc }))
; %%    ((ร int[] findc =) (ร { 0 }))                    ;; matching brace
        ((ร int count =) 0)                          ;; cumulative number of braces
; %%    ((ร boolean[] backwards =) (ร { false }))
        ((ร boolean inquote =) false)                ;; true when inside quotes
        ((ร int hash_dir =) 0)                       ;; Direction searched for # things
        ((ร int comment_dir =) 0)                    ;; Direction searched for comments
        ((ร int traveled =) 0)                       ;; how far we've searched so far
        ((ร boolean ignore_cend =) false)            ;; ignore comment end
        ((ร int match_escaped =) 0)                  ;; search for escaped match
        ((ร int comment_col =) MAXCOL)               ;; start of / / comment

        (COPY-pos @_2_pos, (:w_cursor @curwin))
        ((ร @_2_pos.coladd =) 0)
        ((ร Bytes linep =) (ml-get (:lnum @_2_pos))) ;; pointer to current line

        ((ร boolean cpo_match =) (non-nil? (vim-strbyte @p_cpo, CPO_MATCH)))    ;; vi compatible matching
        ((ร boolean cpo_bsl =) (non-nil? (vim-strbyte @p_cpo, CPO_MATCHBSL)))   ;; don't recognize backslashes

        ;; Direction to search when initc is '/', '*' or '#'.
        (ร int dir)
        (cond (flag? flags FM_BACKWARD)
        (do
            ((ร dir =) BACKWARD)
        )
        (flag? flags FM_FORWARD)
        (do
            ((ร dir =) FORWARD)
        )
        :else
        (do
            ((ร dir =) 0)
        ))

        ;; if initc given, look in the table for the matching character
        ;; '/' and '*' are special cases: look for start or end of comment.
        ;; When '/' is used, we ignore running backwards into an star-slash,
        ;; for "[*" command, we just want to find any comment.

        (cond (or (== (... initc 0) (byte \/)) (== (... initc 0) (byte \*)))
        (do
            ((ร comment_dir =) dir)
            (if (== (... initc 0) (byte \/))
                ((ร ignore_cend =) true)
            )
            ((ร backwards[0] =) (!= dir FORWARD))
            ((ร initc[0] =) NUL)
        )
        (and (!= (... initc 0) (byte \#)) (!= (... initc 0) NUL))
        (do
            (find-mps-values initc, findc, backwards, true)
            (if (== (... findc 0) NUL)
                ((ร RETURN) nil)
            )
        )
        :else ;; Either initc is '#', or no initc was given and we need to look under the cursor.
        (do
            (cond (== (... initc 0) (byte \#))
            (do
                ((ร hash_dir =) dir)
            )
            :else
            (do
                ;; initc was not given, must look for something to match under or near the cursor.
                ;; Only check for special things when 'cpo' doesn't have '%'.

                (when (not cpo_match)
                    ;; Are we before or at #if, #else etc.?
                    ((ร Bytes p =) (skipwhite linep))
                    (cond (and (== (.at p 0) (byte \#)) (<= (:col @_2_pos) (BDIFF p, linep)))
                    (do
                        ((ร p =) (skipwhite (.plus p 1)))
                        (if (or (zero? (STRNCMP p, (u8 "if"), 2)) (zero? (STRNCMP p, (u8 "endif"), 5)) (zero? (STRNCMP p, (u8 "el"), 2)))
                            ((ร hash_dir =) 1)
                        )
                    )
                    ;; Are we on a comment?
                    (== (.at linep (:col @_2_pos)) (byte \/))
                    (do
                        (cond (== (.at linep (+ (:col @_2_pos) 1)) (byte \*))
                        (do
                            ((ร comment_dir =) FORWARD)
                            ((ร backwards[0] =) false)
                            (ร @_2_pos.col++)
                        )
                        (and (< 0 (:col @_2_pos)) (== (.at linep (- (:col @_2_pos) 1)) (byte \*)))
                        (do
                            ((ร comment_dir =) BACKWARD)
                            ((ร backwards[0] =) true)
                            (ร @_2_pos.col--)
                        ))
                    )
                    (== (.at linep (:col @_2_pos)) (byte \*))
                    (do
                        (cond (== (.at linep (+ (:col @_2_pos) 1)) (byte \/))
                        (do
                            ((ร comment_dir =) BACKWARD)
                            ((ร backwards[0] =) true)
                        )
                        (and (< 0 (:col @_2_pos)) (== (.at linep (- (:col @_2_pos) 1)) (byte \/)))
                        (do
                            ((ร comment_dir =) FORWARD)
                            ((ร backwards[0] =) false)
                        ))
                    ))
                )

                ;; If we are not on a comment or the # at the start of a line,
                ;; then look for brace anywhere on this line after the cursor.

                (when (and (zero? hash_dir) (zero? comment_dir))
                    ;; Find the brace under or after the cursor.
                    ;; If beyond the end of the line, use the last character in the line.

                    (if (and (== (.at linep (:col @_2_pos)) NUL) (non-zero? (:col @_2_pos)))
                        (ร --@_2_pos.col)
                    )
                    (while true
                        ((ร initc[0] =) (us-ptr2char (.plus linep (:col @_2_pos))))
                        (if (== (... initc 0) NUL)
                            (ร BREAK)
                        )

                        (find-mps-values initc, findc, backwards, false)
                        (if (!= (... findc 0) NUL)
                            (ร BREAK)
                        )
                        ((ร @_2_pos.col =) (+ (:col @_2_pos) (us-ptr2len-cc (.plus linep (:col @_2_pos)))))
                    )
                    (cond (== (... findc 0) NUL)
                    (do
                        ;; no brace in the line, maybe use "  #if" then
                        (if (and (not cpo_match) (== (.at (skipwhite linep) 0) (byte \#)))
                            ((ร hash_dir =) 1)
                            ((ร RETURN) nil)
                        )
                    )
                    (not cpo_bsl)
                    (do
                        ((ร int bslcnt =) 0)

                        ;; Set "match_escaped" if there are an odd number of backslashes.
; %%                    ((ร FOR) (ร ((ร int[] col =) (ร { (@_2_pos.col) })) (check-prevcol linep, (... col 0), (byte \\), col) nil)
                            (ร bslcnt++)
; %%                    )
                        ((ร match_escaped =) (& bslcnt 1))
                    ))
                )
            ))

            (when (non-zero? hash_dir)
                ;; Look for matching #if, #else, #elif, or #endif

                (if (non-nil? oap)
                    ((ร oap.motion_type =) MLINE)    ;; linewise for this case only
                )
                (when (!= (... initc 0) (byte \#))
                    ((ร Bytes p =) (skipwhite (.plus (skipwhite linep) 1)))
                    (cond (or (zero? (STRNCMP p, (u8 "if"), 2)) (zero? (STRNCMP p, (u8 "el"), 2)))
                    (do
                        ((ร hash_dir =) 1)
                    )
                    (zero? (STRNCMP p, (u8 "endif"), 5))
                    (do
                        ((ร hash_dir =) -1)
                    )
                    :else
                    (do
                        ((ร RETURN) nil)
                    ))
                )
                ((ร @_2_pos.col =) 0)
                (while (not @got_int)
                    (cond (< 0 hash_dir)
                    (do
                        (if (== (:lnum @_2_pos) (:ml_line_count (:b_ml @curbuf)))
                            (ร BREAK)
                        )
                    )
                    (== (:lnum @_2_pos) 1)
                    (do
                        (ร BREAK)
                    ))
                    ((ร @_2_pos.lnum =) (+ (:lnum @_2_pos) hash_dir))
                    ((ร linep =) (ml-get (:lnum @_2_pos)))
                    (line-breakcheck)          ;; check for CTRL-C typed
                    ((ร Bytes p =) (skipwhite linep))
                    (if (!= (.at p 0) (byte \#))
                        (ร CONTINUE)
                    )
                    ((ร @_2_pos.col =) (BDIFF p, linep))
                    ((ร p =) (skipwhite (.plus p 1)))
                    (cond (< 0 hash_dir)
                    (do
                        (cond (zero? (STRNCMP p, (u8 "if"), 2))
                        (do
                            (ร count++)
                        )
                        (zero? (STRNCMP p, (u8 "el"), 2))
                        (do
                            (if (zero? count)
                                ((ร RETURN) @_2_pos)
                            )
                        )
                        (zero? (STRNCMP p, (u8 "endif"), 5))
                        (do
                            (if (zero? count)
                                ((ร RETURN) @_2_pos)
                            )
                            (ร count--)
                        ))
                    )
                    :else
                    (do
                        (cond (zero? (STRNCMP p, (u8 "if"), 2))
                        (do
                            (if (zero? count)
                                ((ร RETURN) @_2_pos)
                            )
                            (ร count--)
                        )
                        (and (== (... initc 0) (byte \#)) (zero? (STRNCMP p, (u8 "el"), 2)))
                        (do
                            (if (zero? count)
                                ((ร RETURN) @_2_pos)
                            )
                        )
                        (zero? (STRNCMP p, (u8 "endif"), 5))
                        (do
                            (ร count++)
                        ))
                    ))
                )
                ((ร RETURN) nil)
            )
        ))

        ((ร int do_quotes =) -1)                 ;; check for quotes in current line
        ((ร maybean start_in_quotes =) MAYBE)    ;; start position is in quotes
        ((ร pos_C match_pos =) (NEW_pos_C))      ;; where last slash-star was found

        ;; backward search: Check if this line contains a single-line comment
        (if (and (... backwards 0) (non-zero? comment_dir))
            ((ร comment_col =) (check-linecomment linep))
        )

        (while (not @got_int)
            ;; Go to the next position, forward or backward.
            ;; We could use incp() and decp() here, but that is much slower.

            (cond (... backwards 0)
            (do
                (cond (zero? (:col @_2_pos))                    ;; at start of line, go to prev. one
                (do
                    (if (== (:lnum @_2_pos) 1)               ;; start of file
                        (ร BREAK)
                    )
                    (ร --@_2_pos.lnum)

                    (if (and (< 0 maxtravel) (< maxtravel (ร ++traveled)))
                        (ร BREAK)
                    )

                    ((ร linep =) (ml-get (:lnum @_2_pos)))
                    ((ร @_2_pos.col =) (STRLEN linep))    ;; _2_pos.col on trailing NUL
                    ((ร do_quotes =) -1)
                    (line-breakcheck)

                    ;; Check if this line contains a single-line comment.
                    (if (non-zero? comment_dir)
                        ((ร comment_col =) (check-linecomment linep))
                    )
                )
                :else
                (do
                    (ร --@_2_pos.col)
                    ((ร @_2_pos.col =) (- (:col @_2_pos) (us-head-off linep, (.plus linep (:col @_2_pos)))))
                ))
            )
            :else                            ;; forward search
            (do
                (cond (== (.at linep (:col @_2_pos)) NUL)
                (do
                    (if (== (:lnum @_2_pos) (:ml_line_count (:b_ml @curbuf)))    ;; end of file
                        (ร BREAK)
                    )
                    (ร @_2_pos.lnum++)

                    (if (and (non-zero? maxtravel) (< maxtravel (ร traveled++)))
                        (ร BREAK)
                    )

                    ((ร linep =) (ml-get (:lnum @_2_pos)))
                    ((ร @_2_pos.col =) 0)
                    ((ร do_quotes =) -1)
                    (line-breakcheck)
                )
                :else
                (do
                    ((ร @_2_pos.col =) (+ (:col @_2_pos) (us-ptr2len-cc (.plus linep (:col @_2_pos)))))
                ))
            ))

            ;; If FM_BLOCKSTOP given, stop at a '{' or '}' in column 0.

            (when (and (zero? (:col @_2_pos)) (flag? flags FM_BLOCKSTOP) (or (== (.at linep 0) (byte \{)) (== (.at linep 0) (byte \}))))
                (if (and (== (.at linep 0) (... findc 0)) (zero? count))        ;; match!
                    ((ร RETURN) @_2_pos)
                )
                (ร BREAK)                                      ;; out of scope
            )

            (when (non-zero? comment_dir)
                ;; Note: comments do not nest, and we ignore quotes in them.
                ;; TODO: ignore comment brackets inside strings.
                (cond (== comment_dir FORWARD)
                (do
                    (when (and (== (.at linep (:col @_2_pos)) (byte \*)) (== (.at linep (+ (:col @_2_pos) 1)) (byte \/)))
                        (ร @_2_pos.col++)
                        ((ร RETURN) @_2_pos)
                    )
                )
                :else    ;; searching backwards
                (do
                    ;; A comment may contain / * or / /, it may also start or end
                    ;; with / * /.  Ignore a / * after / /.

                    (cond (zero? (:col @_2_pos))
                    (do
                        (ร CONTINUE)
                    )
                    (and (== (.at linep (- (:col @_2_pos) 1)) (byte \/)) (== (.at linep (:col @_2_pos)) (byte \*)) (< (:col @_2_pos) comment_col))
                    (do
                        (ร count++)
                        (COPY-pos match_pos, @_2_pos)
                        (ร match_pos.col--)
                    )
                    (and (== (.at linep (- (:col @_2_pos) 1)) (byte \*)) (== (.at linep (:col @_2_pos)) (byte \/)))
                    (do
                        (cond (< 0 count)
                        (do
                            (COPY-pos @_2_pos, match_pos)
                        )
                        (and (< 1 (:col @_2_pos)) (== (.at linep (- (:col @_2_pos) 2)) (byte \/)) (<= (:col @_2_pos) comment_col))
                        (do
                            ((ร @_2_pos.col =) (- (:col @_2_pos) 2))
                        )
                        ignore_cend
                        (do
                            (ร CONTINUE)
                        )
                        :else
                        (do
                            ((ร RETURN) nil)
                        ))

                        ((ร RETURN) @_2_pos)
                    ))
                ))
                (ร CONTINUE)
            )

            ;; If smart matching ('cpoptions' does not contain '%'), braces inside
            ;; of quotes are ignored, but only if there is an even number of
            ;; quotes in the line.

            (cond cpo_match
            (do
                ((ร do_quotes =) 0)
            )
            (== do_quotes -1)
            (do
                ;; Count the number of quotes in the line, skipping \" and '"'.
                ;; Watch out for "\\".

                ((ร int @at_start =) do_quotes)       ;; do_quotes value at start position
                (ร Bytes p)
                ((ร FOR) (ร ((ร p =) linep) (non-eos? p) ((ร p =) (.plus p 1)))
                    (if (BEQ p, (.plus linep (+ (:col @_2_pos) (if (... backwards 0) 1 0))))
                        (reset! at_start (& do_quotes 1)))
                    (if (and (== (.at p 0) (byte \")) (or (BEQ p, linep) (!= (.at p -1) (byte \')) (!= (.at p 1) (byte \'))))   ;; """
                        (ร do_quotes++)
                    )
                    (if (and (== (.at p 0) (byte \\)) (non-eos? p 1))
                        ((ร p =) (.plus p 1))
                    )
                )
                ((ร do_quotes =) (& do_quotes 1))                 ;; result is 1 with even number of quotes

                ;; If we find an uneven count, check current line and previous one for a '\' at the end.

                (when (zero? do_quotes)
                    ((ร inquote =) false)
                    (when (== (.at p -1) (byte \\))
                        ((ร do_quotes =) 1)
                        (cond (== start_in_quotes MAYBE)
                        (do
                            ;; Do we need to use at_start here?
                            ((ร inquote =) true)
                            ((ร start_in_quotes =) TRUE)
                        )
                        (... backwards 0)
                        (do
                            ((ร inquote =) true)
                        ))
                    )
                    (when (< 1 (:lnum @_2_pos))
                        ((ร p =) (ml-get (- (:lnum @_2_pos) 1)))
                        (when (and (non-eos? p) (== (.at p (- (STRLEN p) 1)) (byte \\)))
                            ((ร do_quotes =) 1)
                            (cond (== start_in_quotes MAYBE)
                            (do
                                ((ร inquote =) (!= @at_start 0))
                                (if inquote
                                    ((ร start_in_quotes =) TRUE)
                                )
                            )
                            (not (... backwards 0))
                            (do
                                ((ร inquote =) true)
                            ))
                        )

                        ;; ml-get() only keeps one line, need to get "linep" again
                        ((ร linep =) (ml-get (:lnum @_2_pos)))
                    )
                )
            ))
            (when (== start_in_quotes MAYBE)
                ((ร start_in_quotes =) FALSE)
            )

            ;; If 'smartmatch' is set:
            ;;   Things inside quotes are ignored by setting 'inquote'.
            ;;   If we find a quote without a preceding '\' invert 'inquote'.
            ;;   At the end of a line not ending in '\' we reset 'inquote'.
            ;;
            ;;   In lines with an uneven number of quotes (without preceding '\')
            ;;   we do not know which part to ignore.  Therefore we only set
            ;;   inquote if the number of quotes in a line is even, unless this
            ;;   line or the previous one ends in a '\'.  Complicated, isn't it?

            ((ร int c =) (us-ptr2char (.plus linep (:col @_2_pos))))
            ((ร SWITCH) c
                ((ร CASE) NUL)
                (do
                    ;; at end of line without trailing backslash, reset inquote
                    (when (or (zero? (:col @_2_pos)) (!= (.at linep (- (:col @_2_pos) 1)) (byte \\)))
                        ((ร inquote =) false)
                        ((ร start_in_quotes =) FALSE)
                    )
                    (ร BREAK)
                )

                ((ร CASE) (byte \"))  ;; """
                (do
                    ;; a quote that is preceded with an odd number of backslashes is ignored
                    (when (non-zero? do_quotes)
                        (ร int col)

                        ((ร FOR) (ร ((ร col =) (- (:col @_2_pos) 1)) (<= 0 col) (ร --col))
                            (if (!= (.at linep col) (byte \\))
                                (ร BREAK)
                            )
                        )
                        (when (zero? (& (- (:col @_2_pos) 1 col) 1))
                            ((ร inquote =) (not inquote))
                            ((ร start_in_quotes =) FALSE)
                        )
                    )
                    (ร BREAK)
                )

                ;; If smart matching ('cpoptions' does not contain '%'):
                ;;   Skip things in single quotes: 'x' or '\x'.  Be careful for single
                ;;   single quotes, e.g. jon's.  Things like '\233' or '\x3f' are not
                ;;   skipped, there is never a brace in them.
                ;;   Ignore this when finding matches for `'.

                ((ร CASE) (byte \'))
                (do
                    (when (and (not cpo_match) (!= (... initc 0) (byte \')) (!= (... findc 0) (byte \')))
                        (cond (... backwards 0)
                        (do
                            (when (< 1 (:col @_2_pos))
                                (cond (== (.at linep (- (:col @_2_pos) 2)) (byte \'))
                                (do
                                    ((ร @_2_pos.col =) (- (:col @_2_pos) 2))
                                    (ร BREAK)
                                )
                                (and (== (.at linep (- (:col @_2_pos) 2)) (byte \\)) (< 2 (:col @_2_pos)) (== (.at linep (- (:col @_2_pos) 3)) (byte \')))
                                (do
                                    ((ร @_2_pos.col =) (- (:col @_2_pos) 3))
                                    (ร BREAK)
                                ))
                            )
                        )
                        (!= (.at linep (+ (:col @_2_pos) 1)) NUL) ;; forward search
                        (do
                            (cond (and (== (.at linep (+ (:col @_2_pos) 1)) (byte \\)) (!= (.at linep (+ (:col @_2_pos) 2)) NUL) (== (.at linep (+ (:col @_2_pos) 3)) (byte \')))
                            (do
                                ((ร @_2_pos.col =) (+ (:col @_2_pos) 3))
                                (ร BREAK)
                            )
                            (== (.at linep (+ (:col @_2_pos) 2)) (byte \'))
                            (do
                                ((ร @_2_pos.col =) (+ (:col @_2_pos) 2))
                                (ร BREAK)
                            ))
                        ))
                    )
                    (ร FALLTHROUGH)
                )

                (ร DEFAULT)
                (do
                    ;; Check for match outside of quotes, and inside of
                    ;; quotes when the start is also inside of quotes.

                    (when (and (or (not inquote) (== start_in_quotes TRUE)) (or (== c (... initc 0)) (== c (... findc 0))))
                        ((ร int bslcnt =) 0)

                        (when (not cpo_bsl)
; %%                        ((ร FOR) (ร ((ร int[] col =) (ร { (@_2_pos.col) })) (check-prevcol linep, (... col 0), (byte \\), col) nil)
                                (ร bslcnt++)
; %%                        )
                        )
                        ;; Only accept a match when 'M' is in 'cpo'
                        ;; or when escaping is what we expect.
                        (when (or cpo_bsl (== (& bslcnt 1) match_escaped))
                            (cond (== c (... initc 0))
                            (do
                                (ร count++)
                            )
                            :else
                            (do
                                (if (zero? count)
                                    ((ร RETURN) @_2_pos)
                                )
                                (ร count--)
                            ))
                        )
                    )
                    (ร BREAK)
                )
            )
        )

        (when (and (== comment_dir BACKWARD) (< 0 count))
            (COPY-pos @_2_pos, match_pos)
            ((ร RETURN) @_2_pos)
        )

        nil    ;; never found it
    ))

;; Check if line[] contains a / / comment.
;; Return MAXCOL if not, otherwise return the column.
;; TODO: skip strings.

(defn- #_int check-linecomment [#_Bytes line]
    (ยง
        ((ร Bytes p =) line)

        (while (!= ((ร p =) (vim-strchr p, (byte \/))) nil)
            ;; Accept a double /, unless it's preceded with * and followed by *,
            ;; because * / / * is an end and start of a C comment.
            (if (and (== (.at p 1) (byte \/)) (or (BEQ p, line) (!= (.at p -1) (byte \*)) (!= (.at p 2) (byte \*))))
                (ร BREAK)
            )
            ((ร p =) (.plus p 1))
        )

        (if (nil? p)
            ((ร RETURN) MAXCOL)
        )

        (BDIFF p, line)
    ))

;; Move cursor briefly to character matching the one under the cursor.
;; Used for Insert mode and "r" command.
;; Show the match only if it is visible on the screen.
;; If there isn't a match, then beep.

(defn- #_void showmatch [#_int c]
    ;; c: char to show match for
    (ยง
        ;; Only show match for chars in the 'matchpairs' option.

        ;; 'matchpairs' is "x:y,x:y"
        ((ร FOR) (ร ((ร Bytes p =) @(:b_p_mps @curbuf)) (non-eos? p) ((ร p =) (.plus p 1)))
            ((ร p =) (.plus p (+ (us-ptr2len-cc p) 1)))
            (if (== (us-ptr2char p) c)
                (ร BREAK)
            )
            ((ร p =) (.plus p (us-ptr2len-cc p)))
            (if (eos? p)
                ((ร RETURN) nil)
            )
        )

        ((ร pos_C lpos =) (findmatch nil, NUL))
        (cond (nil? lpos)                   ;; no match, so beep
        (do
            (vim-beep)
        )
        (and (<= (:w_topline @curwin) (:lnum lpos)) (< (:lnum lpos) (:w_botline @curwin)))
        (do
            ((ร int[] vcol =) (ร new int[1]))
            (if (not @(:wo_wrap (:w_options @curwin)))
                (getvcol @curwin, lpos, nil, vcol, nil))
            (when (or @(:wo_wrap (:w_options @curwin)) (and (<= (:w_leftcol @curwin) (... vcol 0)) (< (... vcol 0) (+ (:w_leftcol @curwin) (:w_width @curwin)))))
                ((ร pos_C save_cursor =) (NEW_pos_C))
                ((ร pos_C mpos =) (NEW_pos_C))

                (COPY-pos mpos, lpos)               ;; save the pos, update-screen() may change it
                (COPY-pos save_cursor, (:w_cursor @curwin))
                ((ร long save_so =) @p_so)
                ((ร long save_siso =) @p_siso)
                (ร @curwin.w_virtcol++)                 ;; do display ')' just before "$"
                (update-screen VALID)               ;; show the new char first

                ((ร int save_state =) @State)
                (reset! State SHOWMATCH)
                (ui-cursor-shape)                  ;; may show different cursor shape
                (COPY-pos (:w_cursor @curwin), mpos)    ;; move to matching char
                (reset! p_so 0)                        ;; don't use 'scrolloff' here
                (reset! p_siso 0)                      ;; don't use 'sidescrolloff' here
                (showruler false)
                (setcursor)
                (cursor-on)                        ;; make sure that the cursor is shown
                (out-flush)

                ;; brief pause, unless 'm' is present in 'cpo' and a character is available

                (cond (non-nil? (vim-strbyte @p_cpo, CPO_SHOWMATCH))
                (do
                    (ui-delay (* @p_mat 100), true)
                )
                (not (char-avail))
                (do
                    (ui-delay (* @p_mat 100), false)
                ))

                (COPY-pos (:w_cursor @curwin), save_cursor) ;; restore cursor position
                (reset! p_so save_so)
                (reset! p_siso save_siso)
                (reset! State save_state)
                (ui-cursor-shape)          ;; may show different cursor shape
            )
        ))
        nil
    ))

;; The following routines do the word searches performed
;; by the 'w', 'W', 'b', 'B', 'e', and 'E' commands.

;; To perform these searches, characters are placed into one of three
;; classes, and transitions between classes determine word boundaries.
;;
;; The classes are:
;;
;; 0 - white space
;; 1 - punctuation
;; 2 or higher - keyword characters (letters, digits and underscore)

(atom! boolean cls_bigword)     ;; true for "W", "B" or "E"

;; cls() - returns the class of character at curwin.w_cursor
;;
;; If a 'W', 'B', or 'E' motion is being done (cls_bigword == true),
;; chars from class 2 and higher are reported as class 1 since only
;; white space boundaries are of interest.

(defn- #_int cls []
    (ยง
        ((ร int c =) (gchar-cursor))
        (if (or (== c (byte \space)) (== c TAB) (== c NUL))
            ((ร RETURN) 0)
        )

        ((ร c =) (utf-class c))
        (if (and (non-zero? c) @cls_bigword)
            ((ร RETURN) 1)
        )

        c
    ))

;; fwd-word(count, type, eol) - move forward one word
;;
;; Returns false if the cursor was already at the end of the file.
;; If eol is true, last word stops at end of line (for operators).

(defn- #_boolean fwd-word [#_long count, #_boolean bigword, #_boolean eol]
    ;; bigword: "W", "E" or "B"
    (ยง
        ((ร @curwin.w_cursor.coladd =) 0)
        (reset! cls_bigword bigword)

        (while (< 0 (ร count--))
            ((ร int sclass =) (cls))         ;; starting class

            ;; We always move at least one character,
            ;; unless on the last character in the buffer.

            ((ร boolean last_line =) (== (:lnum (:w_cursor @curwin)) (:ml_line_count (:b_ml @curbuf))))
            ((ร int i =) (inc-cursor))
            (if (or (== i -1) (and (<= 1 i) last_line))   ;; started at last char in file
                ((ร RETURN) false)
            )
            (if (and (<= 1 i) eol (zero? count))        ;; started at last char in line
                ((ร RETURN) true)
            )

            ;; Go one char past end of current word (if any).

            (when (non-zero? sclass)
                (while (== (cls) sclass)
                    ((ร i =) (inc-cursor))
                    (if (or (== i -1) (and (<= 1 i) eol (zero? count)))
                        ((ร RETURN) true)
                    )
                )
            )

            ;; go to next non-white

            (while (== (cls) 0)
                ;; We'll stop if we land on a blank line

                (if (and (zero? (:col (:w_cursor @curwin))) (eos? (ml-get-curline)))
                    (ร BREAK)
                )

                ((ร i =) (inc-cursor))
                (if (or (== i -1) (and (<= 1 i) eol (zero? count)))
                    ((ร RETURN) true)
                )
            )
        )

        true
    ))

;; bck-word() - move backward 'count' words
;;
;; If stop is true and we are already on the start of a word, move one less.
;;
;; Returns false if top of the file was reached.

(defn- #_boolean bck-word [#_long count, #_boolean bigword, #_boolean stop]
    (ยง
        ((ร @curwin.w_cursor.coladd =) 0)
        (reset! cls_bigword bigword)

        (while (< 0 (ร count--))
            ((ร int sclass =) (cls))             ;; starting class

            (if (== (dec-cursor) -1)         ;; started at start of file
                ((ร RETURN) false)
            )

;           finished:
;           {
                (when (or (not stop) (== sclass (cls)) (zero? sclass))
                    ;; Skip white space before the word.
                    ;; Stop on an empty line.

                    (while (== (cls) 0)
                        (if (and (zero? (:col (:w_cursor @curwin))) (lineempty (:lnum (:w_cursor @curwin))))
                            (ร BREAK finished)
                        )
                        (if (== (dec-cursor) -1) ;; hit start of file, stop here
                            ((ร RETURN) true)
                        )
                    )

                    ;; Move backward to start of this word.

                    (if (skip-chars (cls), BACKWARD)
                        ((ร RETURN) true)
                    )
                )

                (inc-cursor)                   ;; overshot - forward one
;           }

            ((ร stop =) false)
        )

        true
    ))

;; end-word() - move to the end of the word
;;
;; There is an apparent bug in the 'e' motion of the real vi.  At least on the
;; System V Release 3 version for the 80386.  Unlike 'b' and 'w', the 'e'
;; motion crosses blank lines.  When the real vi crosses a blank line in an
;; 'e' motion, the cursor is placed on the FIRST character of the next
;; non-blank line. The 'E' command, however, works correctly.  Since this
;; appears to be a bug, I have not duplicated it here.
;;
;; Returns false if end of the file was reached.
;;
;; If stop is true and we are already on the end of a word, move one less.
;; If empty is true stop on an empty line.

(defn- #_boolean end-word [#_long count, #_boolean bigword, #_boolean stop, #_boolean empty]
    (ยง
        ((ร @curwin.w_cursor.coladd =) 0)
        (reset! cls_bigword bigword)

        (while (< 0 (ร count--))
            ((ร int sclass =) (cls))         ;; starting class

            (if (== (inc-cursor) -1)
                ((ร RETURN) false)
            )

;           finished:
;           {
                ;; If we're in the middle of a word, we just have to move to the end of it.

                (cond (and (== (cls) sclass) (non-zero? sclass))
                (do
                    ;; Move forward to end of the current word

                    (if (skip-chars sclass, FORWARD)
                        ((ร RETURN) false)
                    )
                )
                (or (not stop) (zero? sclass))
                (do
                    ;; We were at the end of a word.  Go to the end of the next word.
                    ;; First skip white space, if 'empty' is true, stop at empty line.

                    (while (== (cls) 0)
                        (if (and empty (zero? (:col (:w_cursor @curwin))) (lineempty (:lnum (:w_cursor @curwin))))
                            (ร BREAK finished)
                        )
                        (if (== (inc-cursor) -1)     ;; hit end of file, stop here
                            ((ร RETURN) false)
                        )
                    )

                    ;; Move forward to the end of this word.

                    (if (skip-chars (cls), FORWARD)
                        ((ร RETURN) false)
                    )
                ))
                (dec-cursor)                   ;; overshot - one char backward
;           }

            ((ร stop =) false)                   ;; we move only one word less
        )

        true
    ))

;; Move back to the end of the word.
;;
;; Returns false if start of the file was reached.

(defn- #_boolean bckend-word [#_long count, #_boolean bigword, #_boolean eol]
    ;; bigword: true for "B"
    ;; eol: true: stop at end of line.
    (ยง
        ((ร @curwin.w_cursor.coladd =) 0)
        (reset! cls_bigword bigword)

        (while (< 0 (ร count--))
            ((ร int sclass =) (cls))         ;; starting class

            ((ร int i =) (dec-cursor))
            (if (== i -1)
                ((ร RETURN) false)
            )
            (if (and eol (== i 1))
                ((ร RETURN) true)
            )

            ;; Move backward to before the start of this word.

            (when (non-zero? sclass)
                (while (== (cls) sclass)
                    (if (or (== ((ร i =) (dec-cursor)) -1) (and eol (== i 1)))
                        ((ร RETURN) true)
                    )
                )
            )

            ;; Move backward to end of the previous word

            (while (== (cls) 0)
                (if (and (zero? (:col (:w_cursor @curwin))) (lineempty (:lnum (:w_cursor @curwin))))
                    (ร BREAK)
                )
                (if (or (== ((ร i =) (dec-cursor)) -1) (and eol (== i 1)))
                    ((ร RETURN) true)
                )
            )
        )

        true
    ))

;; Skip a row of characters of the same class.
;; Return true when end-of-file reached, false otherwise.

(defn- #_boolean skip-chars [#_int cclass, #_int dir]
    (ยง
        (while (== (cls) cclass)
            (if (== (if (== dir FORWARD) (inc-cursor) (dec-cursor)) -1)
                ((ร RETURN) true)
            )
        )

        false
    ))

;; Go back to the start of the word or the start of white space

(defn- #_void back-in-line []
    (ยง
        ((ร int sclass =) (cls))                     ;; starting class

        (while true
            (if (zero? (:col (:w_cursor @curwin)))       ;; stop at start of line
                (ร BREAK)
            )
            (dec-cursor)
            (when (!= (cls) sclass)                ;; stop at start of word
                (inc-cursor)
                (ร BREAK)
            )
        )
        nil
    ))

;; Find word under cursor, cursor at end.
;; Used while an operator is pending, and in Visual mode.

(defn- #_boolean current-word [#_oparg_C oap, #_long count, #_boolean include, #_boolean bigword]
    ;; include: true: include word and white space
    ;; bigword: false == word, true == WORD
    (ยง
        ((ร boolean inclusive =) true)
        ((ร boolean include_white =) false)

        (reset! cls_bigword bigword)

        ((ร pos_C start_pos =) (NEW_pos_C))

        ;; Correct cursor when 'selection' is exclusive.
        (if (and @VIsual_active (== (.at @p_sel 0) (byte \e)) (ltpos @VIsual, (:w_cursor @curwin)))
            (dec-cursor))

        ;; When Visual mode is not active, or when the VIsual area is only one
        ;; character, select the word and/or white space under the cursor.

        (when (or (not @VIsual_active) (eqpos (:w_cursor @curwin), @VIsual))
            ;; Go to start of current word or white space.

            (back-in-line)
            (COPY-pos start_pos, (:w_cursor @curwin))

            ;; If the start is on white space, and white space should be included
            ;; ("   word"), or start is not on white space, and white space should
            ;; not be included ("word"), find end of word.

            (cond (== (zero? (cls)) include)
            (do
                (if (not (end-word 1, bigword, true, true))
                    ((ร RETURN) false)
                )
            )
            :else
            (do
                ;; If the start is not on white space, and white space should be included ("word   "),
                ;; or start is on white space and white space should not be included ("   "),
                ;; find start of word.
                ;; If we end up in the first column of the next line (single char word)
                ;; back up to end of the line.

                (fwd-word 1, bigword, true)
                (if (zero? (:col (:w_cursor @curwin)))
                    (decl (:w_cursor @curwin))
                    (oneleft))

                (if include
                    ((ร include_white =) true)
                )
            ))

            (cond @VIsual_active
            (do
                ;; should do something when inclusive == false !
                (COPY-pos @VIsual, start_pos)
                (redraw-curbuf-later INVERTED)      ;; update the inversion
            )
            :else
            (do
                (COPY-pos (:op_start oap), start_pos)
                ((ร oap.motion_type =) MCHAR)
            ))
            (ร --count)
        )

        ;; When count is still > 0, extend with more objects.

        (while (< 0 count)
            ((ร inclusive =) true)
            (cond (and @VIsual_active (ltpos (:w_cursor @curwin), @VIsual))
            (do
                ;; In Visual mode, with cursor at start: move cursor back.

                (if (== (decl (:w_cursor @curwin)) -1)
                    ((ร RETURN) false)
                )

                (cond (!= include (!= (cls) 0))
                (do
                    (if (not (bck-word 1, bigword, true))
                        ((ร RETURN) false)
                    )
                )
                :else
                (do
                    (if (not (bckend-word 1, bigword, true))
                        ((ร RETURN) false)
                    )
                    (incl (:w_cursor @curwin))
                ))
            )
            :else
            (do
                ;; Move cursor forward one word and/or white area.

                (if (== (incl (:w_cursor @curwin)) -1)
                    ((ร RETURN) false)
                )

                (cond (!= include (== (cls) 0))
                (do
                    (if (and (not (fwd-word 1, bigword, true)) (< 1 count))
                        ((ร RETURN) false)
                    )

                    ;; If end is just past a new-line,
                    ;; we don't want to include the first character on the line.
                    ;; Put cursor on last char of white.

                    (if (not (oneleft))
                        ((ร inclusive =) false)
                    )
                )
                :else
                (do
                    (if (not (end-word 1, bigword, true, true))
                        ((ร RETURN) false)
                    )
                ))
            ))
            (ร --count)
        )

        (when (and include_white (or (non-zero? (cls)) (and (zero? (:col (:w_cursor @curwin))) (not inclusive))))
            ;; If we don't include white space at the end, move the start to include
            ;; some white space there.  This makes "daw" work better on the last word in
            ;; a sentence (and "2daw" on last-but-one word).  Also when "2daw" deletes
            ;; "word." at the end of the line (cursor is at start of next line).
            ;; But don't delete white space at start of line (indent).

            ((ร pos_C pos =) (NEW_pos_C))
            (COPY-pos pos, (:w_cursor @curwin)) ;; save cursor position
            (COPY-pos (:w_cursor @curwin), start_pos)
            (when (oneleft)
                (back-in-line)
                (when (and (zero? (cls)) (< 0 (:col (:w_cursor @curwin))))
                    (if @VIsual_active
                        (COPY-pos @VIsual, (:w_cursor @curwin))
                        (COPY-pos (:op_start oap), (:w_cursor @curwin)))
                )
            )
            (COPY-pos (:w_cursor @curwin), pos) ;; put cursor back at end
        )

        (cond @VIsual_active
        (do
            (if (and (== (.at @p_sel 0) (byte \e)) inclusive (ltoreq @VIsual, (:w_cursor @curwin)))
                (inc-cursor))
            (when (== @VIsual_mode (byte \V))
                (reset! VIsual_mode (byte \v))
                (reset! redraw_cmdline true)              ;; show mode later
            )
        )
        :else
        (do
            ((ร oap.inclusive =) inclusive)
        ))

        true
    ))

;; Find block under the cursor, cursor at end.
;; "what" and "other" are two matching parenthesis/brace/etc.

(defn- #_boolean current-block [#_oparg_C oap, #_long count, #_boolean include, #_int what, #_int other]
    ;; include: true == include white space
    ;; what: '(', '{', etc.
    ;; other: ')', '}', etc.
    (ยง
        ((ร pos_C pos =) nil)
        ((ร pos_C start_pos =) (NEW_pos_C))
        (ร pos_C end_pos)
        ((ร boolean sol =) false)                    ;; '{' at start of line

        ((ร pos_C old_pos =) (NEW_pos_C))
        (COPY-pos old_pos, (:w_cursor @curwin))
        ((ร pos_C old_end =) (NEW_pos_C))
        (COPY-pos old_end, (:w_cursor @curwin))     ;; remember where we started
        ((ร pos_C old_start =) (NEW_pos_C))
        (COPY-pos old_start, old_end)

        ;; If we start on '(', '{', ')', '}', etc., use the whole block inclusive.

        (cond (or (not @VIsual_active) (eqpos @VIsual, (:w_cursor @curwin)))
        (do
            (setpcmark)
            (when (== what (byte \{))                    ;; ignore indent
                (while (inindent 1)
                    (if (non-zero? (inc-cursor))
                        (ร BREAK)
                    )
                )
            )
            (when (== (gchar-cursor) what)
                ;; cursor on '(' or '{', move cursor just after it
                (ร @curwin.w_cursor.col++)
            )
        )
        (ltpos @VIsual, (:w_cursor @curwin))
        (do
            (COPY-pos old_start, @VIsual)
            (COPY-pos (:w_cursor @curwin), @VIsual) ;; cursor at low end of Visual
        )
        :else
        (do
            (COPY-pos old_end, @VIsual)
        ))

        ;; Search backwards for unclosed '(', '{', etc..
        ;; Put this position in start_pos.
        ;; Ignore quotes here.  Keep the "M" flag in 'cpo', as that is what the user wants.

        ((ร Bytes save_cpo =) @p_cpo)
        (reset! p_cpo (if (non-nil? (vim-strbyte @p_cpo, CPO_MATCHBSL)) (u8 "%M") (u8 "%")))
        (while (< 0 (ร count--))
            (if (nil? ((ร pos =) (findmatch nil, what)))
                (ร BREAK)
            )
            (COPY-pos (:w_cursor @curwin), pos)
            (COPY-pos start_pos, pos) ;; the findmatch for end_pos will overwrite *pos
        )
        (reset! p_cpo save_cpo)

        ;; Search for matching ')', '}', etc.
        ;; Put this position in curwin.w_cursor.

        (when (or (nil? pos) (nil? ((ร end_pos =) (findmatch nil, other))))
            (COPY-pos (:w_cursor @curwin), old_pos)
            ((ร RETURN) false)
        )
        (COPY-pos (:w_cursor @curwin), end_pos)

        ;; Try to exclude the '(', '{', ')', '}', etc. when "include" is false.
        ;; If the ending '}', ')' or ']' is only preceded by indent, skip that indent.
        ;; But only if the resulting area is not smaller than what we started with.

        (while (not include)
            (incl start_pos)
            ((ร sol =) (== (:col (:w_cursor @curwin)) 0))
            (decl (:w_cursor @curwin))
            (while (inindent 1)
                ((ร sol =) true)
                (if (!= (decl (:w_cursor @curwin)) 0)
                    (ร BREAK)
                )
            )

            ;; In Visual mode, when the resulting area is not bigger than what we
            ;; started with, extend it to the next block, and then exclude again.

            (cond (and (not (ltpos start_pos, old_start)) (not (ltpos old_end, (:w_cursor @curwin))) @VIsual_active)
            (do
                (COPY-pos (:w_cursor @curwin), old_start)
                (decl (:w_cursor @curwin))
                (when (nil? ((ร pos =) (findmatch nil, what)))
                    (COPY-pos (:w_cursor @curwin), old_pos)
                    ((ร RETURN) false)
                )
                (COPY-pos start_pos, pos)
                (COPY-pos (:w_cursor @curwin), pos)
                (when (nil? ((ร end_pos =) (findmatch nil, other)))
                    (COPY-pos (:w_cursor @curwin), old_pos)
                    ((ร RETURN) false)
                )
                (COPY-pos (:w_cursor @curwin), end_pos)
            )
            :else
            (do
                (ร BREAK)
            ))
        )

        (cond @VIsual_active
        (do
            (if (== (.at @p_sel 0) (byte \e))
                (ร @curwin.w_cursor.col++)
            )
            (if (and sol (!= (gchar-cursor) NUL))
                (incp (:w_cursor @curwin)))               ;; include the line break
            (COPY-pos @VIsual, start_pos)
            (reset! VIsual_mode (byte \v))
            (redraw-curbuf-later INVERTED)          ;; update the inversion
            (showmode)
        )
        :else
        (do
            (COPY-pos (:op_start oap), start_pos)
            ((ร oap.motion_type =) MCHAR)
            ((ร oap.inclusive =) false)
            (cond sol
            (do
                (incl (:w_cursor @curwin))
            )
            (ltoreq start_pos, (:w_cursor @curwin))
            (do
                ;; Include the character under the cursor.
                ((ร oap.inclusive =) true)
            )
            :else
            (do
                ;; End is before the start (no text in between <>, [], etc.): don't operate on any text.
                (COPY-pos (:w_cursor @curwin), start_pos)
            ))
        ))

        true
    ))

;; Search quote char from string line[col].
;; Quote character escaped by one of the characters in "escape" is not counted as a quote.
;; Returns column number of "quotechar" or -1 when not found.

(defn- #_int find-next-quote [#_Bytes line, #_int col, #_int quotechar, #_Bytes escape]
    ;; escape: escape characters, can be null
    (ยง
        (while true
            ((ร int c =) (.at line col))
            (cond (== c NUL)
            (do
                ((ร RETURN) -1)
            )
            (and (non-nil? escape) (non-nil? (vim-strchr escape, c)))
            (do
                (ร col++)
            )
            (== c quotechar)
            (do
                (ร BREAK)
            ))
            ((ร col =) (+ col (us-ptr2len-cc (.plus line col))))
        )
        col
    ))

;; Search backwards in "line" from column "col_start" to find "quotechar".
;; Quote character escaped by one of the characters in "escape" is not counted as a quote.
;; Return the found column or zero.

(defn- #_int find-prev-quote [#_Bytes line, #_int col_start, #_int quotechar, #_Bytes escape]
    ;; escape: escape characters, can be null
    (ยง
        (ร int n)

        (while (< 0 col_start)
            (ร --col_start)
            ((ร col_start =) (- col_start (us-head-off line, (.plus line col_start))))
            ((ร n =) 0)
            (when (non-nil? escape)
                (while (and (< 0 (- col_start n)) (!= (vim-strchr escape, (.at line (- col_start n 1))) nil))
                    (ร n++)
                )
            )
            (cond (non-zero? (& n 1))
            (do
                ((ร col_start =) (- col_start n))     ;; uneven number of escape chars, skip it
            )
            (== (.at line col_start) quotechar)
            (do
                (ร BREAK)
            ))
        )
        col_start
    ))

;; Find quote under the cursor, cursor at end.
;; Returns true if found, else false.

(defn- #_boolean current-quote [#_oparg_C oap, #_long count, #_boolean include, #_int quotechar]
    ;; include: true == include quote char
    ;; quotechar: Quote character
    (ยง
        ((ร Bytes line =) (ml-get-curline))
        (ร int col_end)
        ((ร int col_start =) (:col (:w_cursor @curwin)))

        ((ร boolean inclusive =) false)
        ((ร boolean vis_empty =) true)           ;; Visual selection <= 1 char
        ((ร boolean vis_bef_curs =) false)       ;; Visual starts before cursor
        ((ร boolean inside_quotes =) false)      ;; Looks like "i'" done before
        ((ร boolean selected_quote =) false)     ;; Has quote inside selection

        ;; Correct cursor when 'selection' is exclusive.
        (when @VIsual_active
            ((ร vis_bef_curs =) (ltpos @VIsual, (:w_cursor @curwin)))
            (if (and (== (.at @p_sel 0) (byte \e)) vis_bef_curs)
                (dec-cursor))
            ((ร vis_empty =) (eqpos @VIsual, (:w_cursor @curwin)))
        )

        (when (not vis_empty)
            (ร int i)
            ;; Check if the existing selection exactly spans the text inside quotes.
            (cond vis_bef_curs
            (do
                ((ร inside_quotes =) (and (< 0 (:col @VIsual)) (and (== (.at line (- (:col @VIsual) 1)) quotechar) (!= (.at line (:col (:w_cursor @curwin))) NUL) (== (.at line (+ (:col (:w_cursor @curwin)) 1)) quotechar))))
                ((ร i =) (:col @VIsual))
                ((ร col_end =) (:col (:w_cursor @curwin)))
            )
            :else
            (do
                ((ร inside_quotes =) (and (< 0 (:col (:w_cursor @curwin))) (and (== (.at line (- (:col (:w_cursor @curwin)) 1)) quotechar) (!= (.at line (:col @VIsual)) NUL) (== (.at line (+ (:col @VIsual) 1)) quotechar))))
                ((ร i =) (:col (:w_cursor @curwin)))
                ((ร col_end =) (:col @VIsual))
            ))

            ;; Find out if we have a quote in the selection.
            (while (<= i col_end)
                (when (== (.at line (ร i++)) quotechar)
                    ((ร selected_quote =) true)
                    (ร BREAK)
                )
            )
        )

        (cond (and (not vis_empty) (== (.at line col_start) quotechar))
        (do
            ;; Already selecting something and on a quote character.
            ;; Find the next quoted string.
            (cond vis_bef_curs
            (do
                ;; Assume we are on a closing quote: move to after the next opening quote.
                ((ร col_start =) (find-next-quote line, (inc col_start), quotechar, nil))
                (if (< col_start 0)
                    ((ร RETURN) false)
                )
                ((ร col_end =) (find-next-quote line, (inc col_start), quotechar, @(:b_p_qe @curbuf)))
                (when (< col_end 0)
                    ;; We were on a starting quote perhaps?
                    ((ร col_end =) col_start)
                    ((ร col_start =) (:col (:w_cursor @curwin)))
                )
            )
            :else
            (do
                ((ร col_end =) (find-prev-quote line, col_start, quotechar, nil))
                (if (!= (.at line col_end) quotechar)
                    ((ร RETURN) false)
                )
                ((ร col_start =) (find-prev-quote line, col_end, quotechar, @(:b_p_qe @curbuf)))
                (when (!= (.at line col_start) quotechar)
                    ;; We were on an ending quote perhaps?
                    ((ร col_start =) col_end)
                    ((ร col_end =) (:col (:w_cursor @curwin)))
                )
            ))
        )
        (or (== (.at line col_start) quotechar) (not vis_empty))
        (do
            ((ร int first_col =) col_start)

            (when (not vis_empty)
                ((ร first_col =) (if vis_bef_curs
                    (find-next-quote line, col_start, quotechar, nil)
                    (find-prev-quote line, col_start, quotechar, nil)
                ))
            )

            ;; The cursor is on a quote, we don't know if it's the opening or
            ;; closing quote.  Search from the start of the line to find out.
            ;; Also do this when there is a Visual area, a' may leave the cursor
            ;; in between two strings.
            ((ร col_start =) 0)
            (while true
                ;; Find open quote character.
                ((ร col_start =) (find-next-quote line, col_start, quotechar, nil))
                (if (or (< col_start 0) (< first_col col_start))
                    ((ร RETURN) false)
                )
                ;; Find close quote character.
                ((ร col_end =) (find-next-quote line, (inc col_start), quotechar, @(:b_p_qe @curbuf)))
                (if (< col_end 0)
                    ((ร RETURN) false)
                )
                ;; If is cursor between start and end quote character,
                ;; it is target text object.
                (if (<= col_start first_col col_end)
                    (ร BREAK)
                )
                ((ร col_start =) (inc col_end))
            )
        )
        :else
        (do
            ;; Search backward for a starting quote.
            ((ร col_start =) (find-prev-quote line, col_start, quotechar, @(:b_p_qe @curbuf)))
            (when (!= (.at line col_start) quotechar)
                ;; No quote before the cursor, look after the cursor.
                ((ร col_start =) (find-next-quote line, col_start, quotechar, nil))
                (if (< col_start 0)
                    ((ร RETURN) false)
                )
            )

            ;; Find close quote character.
            ((ร col_end =) (find-next-quote line, (inc col_start), quotechar, @(:b_p_qe @curbuf)))
            (if (< col_end 0)
                ((ร RETURN) false)
            )
        ))

        ;; When "include" is true,
        ;; include spaces after closing quote or before the starting quote.
        (when include
            (cond (vim-iswhite (.at line (inc col_end)))
            (do
                (while (vim-iswhite (.at line (inc col_end)))
                    (ร col_end++)
                )
            )
            :else
            (do
                (while (and (< 0 col_start) (vim-iswhite (.at line (dec col_start))))
                    (ร --col_start)
                )
            ))
        )

        ;; Set start position.  After vi" another i" must include the ".
        ;; For v2i" include the quotes.
        (if (and (not include) (< count 2) (or vis_empty (not inside_quotes)))
            (ร col_start++)
        )
        ((ร @curwin.w_cursor.col =) col_start)
        (cond @VIsual_active
        (do
            ;; Set the start of the Visual area when the Visual area was empty, we
            ;; were just inside quotes or the Visual area didn't start at a quote
            ;; and didn't include a quote.

            (when (or vis_empty (and vis_bef_curs (not selected_quote) (or inside_quotes (and (!= (.at line (:col @VIsual)) quotechar) (or (zero? (:col @VIsual)) (!= (.at line (- (:col @VIsual) 1)) quotechar))))))
                (COPY-pos @VIsual, (:w_cursor @curwin))
                (redraw-curbuf-later INVERTED)
            )
        )
        :else
        (do
            (COPY-pos (:op_start oap), (:w_cursor @curwin))
            ((ร oap.motion_type =) MCHAR)
        ))

        ;; Set end position.
        ((ร @curwin.w_cursor.col =) col_end)
        ;; After vi" another i" must include the ".
        (if (and (or include (< 1 count) (and (not vis_empty) inside_quotes)) (== (inc-cursor) 2))
            ((ร inclusive =) true)
        )
        (cond @VIsual_active
        (do
            (cond (or vis_empty vis_bef_curs)
            (do
                ;; decrement cursor when 'selection' is not exclusive
                (if (!= (.at @p_sel 0) (byte \e))
                    (dec-cursor))
            )
            :else
            (do
                ;; Cursor is at start of Visual area.  Set the end of the Visual area
                ;; when it was just inside quotes or it didn't end at a quote.
                (when (or inside_quotes (and (not selected_quote) (!= (.at line (:col @VIsual)) quotechar) (or (== (.at line (:col @VIsual)) NUL) (!= (.at line (+ (:col @VIsual) 1)) quotechar))))
                    (dec-cursor)
                    (COPY-pos @VIsual, (:w_cursor @curwin))
                )
                ((ร @curwin.w_cursor.col =) col_start)
            ))
            (when (== @VIsual_mode (byte \V))
                (reset! VIsual_mode (byte \v))
                (reset! redraw_cmdline true)              ;; show mode later
            )
        )
        :else
        (do
            ;; Set inclusive and other oap's flags.
            ((ร oap.inclusive =) inclusive)
        ))

        true
    ))

;; Find next search match under cursor, cursor at end.
;; Used while an operator is pending, and in Visual mode.

(defn- #_boolean current-search [#_long count, #_boolean forward]
    ;; forward: move forward or backwards
    (ยง
        ((ร pos_C save_VIsual =) (NEW_pos_C))
        (COPY-pos save_VIsual, @VIsual)

        ;; wrapping should not occur
        ((ร boolean old_p_ws =) @p_ws)
        (reset! p_ws false)

        ;; Correct cursor when 'selection' is exclusive.
        (if (and @VIsual_active (== (.at @p_sel 0) (byte \e)) (ltpos @VIsual, (:w_cursor @curwin)))
            (dec-cursor))

        ((ร pos_C orig_pos =) (NEW_pos_C))       ;; position of the cursor at beginning
        (COPY-pos orig_pos, (:w_cursor @curwin))
        ((ร pos_C pos =) (NEW_pos_C))            ;; position after the pattern
        (COPY-pos pos, (:w_cursor @curwin))
        ((ร pos_C start_pos =) (NEW_pos_C))      ;; position before the pattern
        (COPY-pos start_pos, (:w_cursor @curwin))

        (when @VIsual_active
            (COPY-pos start_pos, @VIsual)

            ;; make sure, searching further will extend the match
            (when @VIsual_active
                (if forward
                    (incl pos)
                    (decl pos))
            )
        )

        ;; Is the pattern is zero-width?
        ((ร int one_char =) (is-one-char (:pat (... @spats @last_idx)), true))
        (when (== one_char -1)
            (reset! p_ws old_p_ws)
            ((ร RETURN) false)                   ;; pattern not found
        )

        ;; The trick is to first search backwards and then search forward again,
        ;; so that a match at the current cursor position will be correctly captured.

        (dotimes [#_int round 2]
            ((ร boolean dir =) (if forward (non-zero? round) (zero? round)))

            ((ร int flags =) 0)
            (if (and (not dir) (zero? one_char))
                ((ร flags =) SEARCH_END)
            )

            ((ร int result =) (searchit @curwin, @curbuf, pos, (if dir FORWARD BACKWARD), (:pat (... @spats @last_idx)), (if (non-zero? round) count 1), (| flags SEARCH_KEEP), RE_SEARCH, 0, nil))

            ;; First search may fail, but then start searching from the beginning of
            ;; the file (cursor might be on the search match) except when Visual mode
            ;; is active, so that extending the visual selection works.
            (when (zero? result)
                (when (non-zero? round)     ;; not found, abort
                    (COPY-pos (:w_cursor @curwin), orig_pos)
                    (if @VIsual_active
                        (COPY-pos @VIsual, save_VIsual))
                    (reset! p_ws old_p_ws)
                    ((ร RETURN) false)
                )

                (cond forward        ;; try again from start of buffer
                (do
                    (clearpos pos)
                )
                :else                ;; try again from end of buffer
                (do
                    ;; searching backwards, so set pos to last line and col
                    ((ร pos.lnum =) (:ml_line_count (:b_ml @curbuf)))
                    ((ร pos.col =) (STRLEN (ml-get (:ml_line_count (:b_ml @curbuf)))))
                ))
            )
            (reset! p_ws old_p_ws)
        )

        (COPY-pos start_pos, pos)
        ((ร int flags =) (if forward SEARCH_END 0))

        ;; Check again from the current cursor position,
        ;; since the next match might actually be only one char wide.
        ((ร one_char =) (is-one-char (:pat (... @spats @last_idx)), false))

        ;; Move to match, except for zero-width matches,
        ;; in which case, we are already on the next match.
        (if (zero? one_char)
            (searchit @curwin, @curbuf, pos, (if forward FORWARD BACKWARD), (:pat (... @spats @last_idx)), 0, (| flags SEARCH_KEEP), RE_SEARCH, 0, nil)
        )

        (if (not @VIsual_active)
            (COPY-pos @VIsual, start_pos))

        (COPY-pos (:w_cursor @curwin), pos)
        (reset! VIsual_active true)
        (reset! VIsual_mode (byte \v))

        (when @VIsual_active
            (redraw-curbuf-later INVERTED)  ;; update the inversion
            (when (== (.at @p_sel 0) (byte \e))
                ;; Correction for exclusive selection depends on the direction.
                (cond (and forward (ltoreq @VIsual, (:w_cursor @curwin)))
                (do
                    (inc-cursor)
                )
                (and (not forward) (ltoreq (:w_cursor @curwin), @VIsual))
                (do
                    (incp @VIsual)
                ))
            )
        )

        (may-start-select (byte \c))

        (redraw-curbuf-later INVERTED)
        (showmode)

        true
    ))

;; Check if the pattern is one character or zero-width.
;; If move is true, check from the beginning of the buffer, else from the current cursor position.
;; Returns true, false or -1 for failure.

(defn- #_int is-one-char [#_Bytes pattern, #_boolean move]
    (ยง
        ((ร int result =) -1)

        ((ร boolean save_called_emsg =) @called_emsg)

        ((ร regmmatch_C regmatch =) (NEW_regmmatch_C))
        (if (not (search-regcomp pattern, RE_SEARCH, RE_SEARCH, SEARCH_KEEP, regmatch))
            ((ร RETURN) -1)
        )

        ((ร pos_C pos =) (NEW_pos_C))
        ((ร int flags =) 0)
        ;; move to match
        (when (not move)
            (COPY-pos pos, (:w_cursor @curwin))
            ;; accept a match at the cursor position
            ((ร flags =) SEARCH_START)
        )

        (when (non-zero? (searchit @curwin, @curbuf, pos, FORWARD, (:pat (... @spats @last_idx)), 1, (| flags SEARCH_KEEP), RE_SEARCH, 0, nil))
            ;; Zero-width pattern should match somewhere,
            ;; then we can check if start and end are in the same position.
            (reset! called_emsg false)
            ((ร long nmatched =) (vim-regexec-multi regmatch, @curwin, @curbuf, (:lnum pos), 0, nil))

            (when (not @called_emsg)
                ((ร result =) (if (and (!= nmatched 0) (== (:lnum (... (:startpos regmatch) 0)) (:lnum (... (:endpos regmatch) 0))) (== (:col (... (:startpos regmatch) 0)) (:col (... (:endpos regmatch) 0)))) TRUE FALSE))
            )

            (if (and (== result FALSE) (<= 0 (incp pos)) (== (:col pos) (:col (... (:endpos regmatch) 0))))
                ((ร result =) TRUE)
            )
        )

        ((ร @called_emsg =) (| @called_emsg save_called_emsg))

        result
    ))

;; Return true if line 'lnum' is empty or has white chars only.

(defn- #_boolean linewhite [#_long lnum]
    (eos? (skipwhite (ml-get lnum))))

;; memline.c: Contains the functions for appending, deleting and changing the text lines.

;; Open a new memline.

(defn- #_memline_C ml-open []
    (ยง
        ((ร memline_C ml =) (NEW_memline_C))

        ((ร ml.ml_flags =) ML_EMPTY)
        ((ร ml.ml_line_count =) 1)

        ;; Create an empty line 1.

;       %% insert @0 (u8 "")

        ml
    ))

;; Return a pointer to a (read-only copy of a) line.
;;
;; On failure an error message is given and ioBuff is returned
;; (to avoid having to check for error everywhere).

(defn- #_Bytes ml-get [#_long lnum]
    (ml-get-buf @curbuf, lnum))

;; Return pointer to position "pos".

(defn- #_Bytes ml-get-pos [#_pos_C pos]
    (.plus (ml-get-buf @curbuf, (:lnum pos)) (:col pos)))

;; Return pointer to cursor line.

(defn- #_Bytes ml-get-curline []
    (ml-get-buf @curbuf, (:lnum (:w_cursor @curwin))))

;; Return pointer to cursor position.

(defn- #_Bytes ml-get-cursor []
    (let [cursor (:w_cursor @curwin)]
        (.plus (ml-get-buf @curbuf, (:lnum cursor)) (:col cursor))
    ))

;; Return a pointer to a line in a specific buffer

(defn- #_Bytes ml-get-buf [#_buffer_C buf, #_long lnum]
    (ยง
        (when (< (:ml_line_count (:b_ml buf)) lnum)  ;; invalid line number
            (emsgn (u8 "E315: ml-get: invalid lnum: %ld"), lnum)

            (STRCPY @ioBuff, (u8 "???"))
            ((ร RETURN) @ioBuff)
        )

        (if (<= lnum 0)                      ;; pretend line 0 is line 1
            ((ร lnum =) 1)
        )

;       %% return @(lnum - 1)
    ))

;; Append a line after lnum (may be 0 to insert a line in front of the file).
;; "line" does not need to be allocated, but can't be another line in a buffer,
;; unlocking may make it invalid.
;;
;; Check: The caller of this function should probably also call appended-lines().
;;
;; return false for failure, true otherwise

(defn- #_boolean ml-append [#_long lnum, #_Bytes line]
    ;; lnum: append after this line (can be 0)
    ;; line: text of the new line
    (ยง
        (if (< (:ml_line_count (:b_ml @curbuf)) lnum) ;; lnum out of range
            ((ร RETURN) false)
        )

;       %% insert @lnum STRDUP(line)

        (ร @curbuf.b_ml.ml_line_count++)
        ((ร @curbuf.b_ml.ml_flags =) (& (:ml_flags (:b_ml @curbuf)) (bit-not ML_EMPTY)))

        true
    ))

;; Replace line lnum in current buffer.
;;
;; Check: The caller of this function should probably also call
;; changed-lines(), unless update-screen(NOT_VALID) is used.
;;
;; return false for failure, true otherwise

(defn- #_boolean ml-replace [#_long lnum, #_Bytes line]
    (ยง
        (if (or (zero? lnum) (nil? line))           ;; just checking...
            ((ร RETURN) false)
        )

;       %% replace @(lnum - 1) STRDUP(line)

        ((ร @curbuf.b_ml.ml_flags =) (& (:ml_flags (:b_ml @curbuf)) (bit-not ML_EMPTY)))

        true
    ))

;; Delete line 'lnum' in the current buffer.
;;
;; Check: The caller of this function should probably also call
;; deleted-lines() after this.
;;
;; return false for failure, true otherwise

(defn- #_boolean ml-delete [#_long lnum, #_boolean message]
    (ยง
        (if (or (< lnum 1) (< (:ml_line_count (:b_ml @curbuf)) lnum))
            ((ร RETURN) false)
        )

        ;; If the file becomes empty the last line is replaced by an empty line.

        (when (== (:ml_line_count (:b_ml @curbuf)) 1)    ;; file becomes empty
            (if message
                (set-keep-msg no_lines_msg, 0))

;           %% replace @0 (u8 "")

            ((ร @curbuf.b_ml.ml_flags =) (| (:ml_flags (:b_ml @curbuf)) ML_EMPTY))

            ((ร RETURN) true)
        )

;       %% delete @(lnum - 1)

        (ร --@curbuf.b_ml.ml_line_count)

        true
    ))

;; buffer.c: functions for dealing with the buffer structure --------------------------------------

;; The buffer list is a double linked list of all buffers.
;; Each buffer can be in one of these states:
;;       hidden: b_nwindows == 0, loaded but not displayed in a window
;;       normal: loaded and displayed in a window

;; Close the link to a buffer.

(defn- #_void close-buffer [#_window_C win]
    (ยง
        ((ร buffer_C buf =) @curbuf)

        ;; Set b_last_cursor when closing the last window for the buffer.
        ;; Remember the last cursor position and window options of the buffer.
        ;; This used to be only for the current window, but then options like
        ;; 'foldmethod' may be lost with a ":only" command.

        (if (== (:b_nwindows buf) 1)
            (set-last-cursor win))

        ;; decrease the link count from windows (unless not in any window)
        (when (< 0 (:b_nwindows buf))
            (ร --buf.b_nwindows)
        )
        nil
    ))

;; This is the ONLY way to create a new buffer.

(defn- #_buffer_C newBuffer []
    (ยง
        ((ร buffer_C buf =) (NEW_buffer_C))

        ((ร buf.b_ml =) (ml-open))

        ((ร @curwin.w_nrwidth_line_count =) 0)

        ((ร buf.b_namedm =) (ARRAY-pos NMARKS))
        ((ร buf.b_visual =) (NEW_visualinfo_C))
        ((ร buf.b_last_cursor =) (NEW_pos_C))
        ((ร buf.b_last_insert =) (NEW_pos_C))
        ((ร buf.b_last_change =) (NEW_pos_C))
        ((ร buf.b_changelist =) (ARRAY-pos JUMPLISTSIZE))
        ((ร buf.b_chartab =) (ร new int[8]))
        ((ร buf.b_op_start =) (NEW_pos_C))
        ((ร buf.b_op_start_orig =) (NEW_pos_C))
        ((ร buf.b_op_end =) (NEW_pos_C))

        (buf-init-chartab buf, false)

        ((ร buf.b_u_synced =) true)

        (unchanged buf)
        (clrallmarks buf)

        buf
    ))

;; Print info about the current buffer.

(defn- #_void fileinfo [#_int _fullname, #_boolean dont_truncate]
    (ยง
        ((ร Bytes buffer =) (Bytes. IOSIZE))

        ((ร Bytes p =) buffer)

        (.be ((ร p =) (.plus p 1)) -1, (byte \"))   ;; """
        (vim-strncpy p, (buf-spname @curbuf), (- IOSIZE (BDIFF p, buffer) 1))

        (vim_snprintf_add buffer, IOSIZE, (u8 "\"%s"), (if @(:b_changed @curbuf) (u8 " [Modified] ") (u8 " ")))

        ((ร int n =) (int (/ (* (:lnum (:w_cursor @curwin)) 100) (:ml_line_count (:b_ml @curbuf)))))

        (cond (non-zero? (& (:ml_flags (:b_ml @curbuf)) ML_EMPTY))
        (do
            (vim_snprintf_add buffer, IOSIZE, (u8 "%s"), no_lines_msg)
        )
        @p_ru
        (do
            ;; Current line and column are already on the screen.
            (if (== (:ml_line_count (:b_ml @curbuf)) 1)
                (vim_snprintf_add buffer, IOSIZE, (u8 "1 line --%d%%--"), n)
                (vim_snprintf_add buffer, IOSIZE, (u8 "%ld lines --%d%%--"), (:ml_line_count (:b_ml @curbuf)), n)
            )
        )
        :else
        (do
            (vim_snprintf_add buffer, IOSIZE, (u8 "line %ld of %ld --%d%%-- col "), (:lnum (:w_cursor @curwin)), (:ml_line_count (:b_ml @curbuf)), n)
            (validate-virtcol)
            ((ร int len =) (STRLEN buffer))
            (col-print (.plus buffer len), (- IOSIZE len), (+ (:col (:w_cursor @curwin)) 1), (+ (:w_virtcol @curwin) 1))
        ))

        (cond dont_truncate
        (do
            ;; Temporarily set msg_scroll to avoid the message being truncated.
            ;; First call msg-start() to get the message in the right place.
            (msg-start)
            ((ร boolean m =) @msg_scroll)
            (reset! msg_scroll true)
            (msg buffer)
            (reset! msg_scroll m)
        )
        :else
        (do
            ((ร p =) (msg-trunc-attr buffer, false, 0))
            (when (or (non-zero? @restart_edit) (and (non-zero? @msg_scrolled) (not @need_wait_return)))
                ;; Need to repeat the message after redrawing when:
                ;; - When restart_edit is set (otherwise there will be a delay before redrawing).
                ;; - When the screen was scrolled but there is no wait-return prompt.
                (set-keep-msg p, 0)
            )
        ))
        nil
    ))

(defn- #_void col-print [#_Bytes buf, #_int buflen, #_int col, #_int vcol]
    (ยง
        (if (== col vcol)
;%%         (vim_snprintf buf, buflen, (u8 "%d"), col)
;%%         (vim_snprintf buf, buflen, (u8 "%d-%d"), col, vcol)
        )
        nil
    ))

;; Get relative cursor position in window into "buf[buflen]", in the form 99%,
;; using "Top", "Bot" or "All" when appropriate.

(defn- #_void get-rel-pos [#_window_C wp, #_Bytes buf, #_int buflen]
    (ยง
        (if (< buflen 3) ;; need at least 3 chars for writing
            ((ร RETURN) nil)
        )

        ;; number of lines above/below window
        ((ร long above =) (- (:w_topline wp) 1))
        ((ร long below =) (+ (- (:ml_line_count (:b_ml @curbuf)) (:w_botline wp)) 1))

        (cond (<= below 0)
        (do
            (vim-strncpy buf, (if (zero? above) (u8 "All") (u8 "Bot")), (dec buflen))
        )
        (<= above 0)
        (do
            (vim-strncpy buf, (u8 "Top"), (dec buflen))
        )
        :else
        (do
            ((ร int cent =) (if (< 1000000 above) (int (/ above (/ (+ above below) 100))) (int (/ (* above 100) (+ above below)))))
;%%         (vim_snprintf buf, buflen, (u8 "%2d%%"), cent)
        ))
        nil
    ))

;; Return special buffer name.

(defn- #_Bytes buf-spname [#_buffer_C buf]
    (u8 "[No Name]"))

;;; ============================================================================================== VimQ

;; charset.c --------------------------------------------------------------------------------------

(atom! boolean chartab_initialized)

;; b_chartab[] is an array of 8 ints, each bit representing one of the characters 0-255.
(defn- #_void set-chartab [#_buffer_C buf, #_int c]
    (ยง
        ((ร buf.b_chartab[c >>> 5] =) (| (... (:b_chartab buf) (>>> c 5)) (<< 1 (& c 0x1f))))
        nil
    ))

(defn- #_void reset-chartab [#_buffer_C buf, #_int c]
    (ยง
        ((ร buf.b_chartab[c >>> 5] =) (& (... (:b_chartab buf) (>>> c 5)) (bit-not (<< 1 (& c 0x1f)))))
        nil
    ))

(defn- #_int get-chartab [#_buffer_C buf, #_int c]
    (& (... (:b_chartab buf) (>>> c 5)) (<< 1 (& c 0x1f))))

;; Fill chartab[].  Also fills curbuf.b_chartab[] with flags for keyword
;; characters for current buffer.
;;
;; Depends on the option settings 'iskeyword', 'isident', 'isfname',
;; 'isprint' and 'encoding'.
;;
;; The index in chartab[] depends on 'encoding':
;; - For non-multi-byte index with the byte (same as the character).
;; - For UTF-8 index with the character (when first byte is up to 0x80 it is
;;   the same as the character, if the first byte is 0x80 and above it depends
;;   on further bytes).
;;
;; The contents of chartab[]:
;; - The lower two bits, masked by CT_CELL_MASK, give the number of display
;;   cells the character occupies (1 or 2).  Not valid for UTF-8 above 0x80.
;; - CT_PRINT_CHAR bit is set when the character is printable (no need to
;;   translate the character before displaying it).
;; - CT_FNAME_CHAR bit is set when the character can be in a file name.
;; - CT_ID_CHAR bit is set when the character can be in an identifier.
;;
;; Return false if 'iskeyword', 'isident', 'isfname' or 'isprint' option has
;; an error, true otherwise.

(defn- #_boolean init-chartab []
    (buf-init-chartab @curbuf, true))

(defn- #_boolean buf-init-chartab [#_buffer_C buf, #_boolean global]
    ;; global: false: only set buf.b_chartab[]
    (ยง
        (when global
            ;; Set the default size for printable characters:
            ;; From <Space> to '~' is 1 (printable), others are 2 (not printable).
            ;; This also inits all 'isident' and 'isfname' flags to false.

            ((ร int c =) 0)
            (while (< c (byte \space))
                ((ร chartab[c++] =) (if (flag? @dy_flags DY_UHEX) (byte 4) (byte 2)))
            )
            (while (<= c (byte \~))
                ((ร chartab[c++] =) (inc CT_PRINT_CHAR))
            )
            (while (< c 256)
                (if (<= 0xa0 c)
                    ((ร chartab[c++] =) (inc CT_PRINT_CHAR))    ;; bytes 0xa0 - 0xff are printable (latin1)
                    ((ร chartab[c++] =) (if (flag? @dy_flags DY_UHEX) (byte 4) (byte 2)))   ;; the rest is unprintable by default
                )
            )

            ;; Assume that every multi-byte char is a filename character.
            ((ร FOR) (ร ((ร c =) 1) (< c 256) (ร c++))
                (if (<= 0xa0 c)
                    ((ร chartab[c] =) (| (... chartab c) CT_FNAME_CHAR))
                )
            )
        )

        ;; Init word char flags all to false.

        (AFILL (:b_chartab buf), 0)

        ;; Walk through the 'isident', 'iskeyword', 'isfname' and 'isprint' options.
        ;; Each option is a list of characters, character numbers or ranges,
        ;; separated by commas, e.g.: "200-210,x,#-178,-"

        ((ร FOR) (ร ((ร int i =) (if global 0 3)) (<= i 3) (ร i++))
            (ร Bytes p)
            (cond (zero? i)
            (do
                ((ร p =) @p_isi)          ;; first round: 'isident'
            )
            (== i 1)
            (do
                ((ร p =) @p_isp)          ;; second round: 'isprint'
            )
            (== i 2)
            (do
                ((ร p =) @p_isf)          ;; third round: 'isfname'
            )
            :else    ;; i == 3
            (do
                ((ร p =) @(:b_p_isk buf))    ;; fourth round: 'iskeyword'
            ))

            (while (non-eos? p)
                ((ร boolean tilde =) false)
                ((ร boolean do_isalpha =) false)
                (when (and (== (.at p 0) (byte \^)) (non-eos? p 1))
                    ((ร tilde =) true)
                    ((ร p =) (.plus p 1))
                )
                (ร int c)
                (cond (asc-isdigit (.at p 0))
                (do
;                   Bytes[] __ = { p }; c = (int)getdigits(__); p = __[0];
                )
                :else
                (do
;                   Bytes[] __ = { p }; c = us-ptr2char-adv(__, true); p = __[0];
                ))
                ((ร int c2 =) -1)
                (when (and (== (.at p 0) (byte \-)) (non-eos? p 1))
                    ((ร p =) (.plus p 1))
                    (cond (asc-isdigit (.at p 0))
                    (do
;                       Bytes[] __ = { p }; c2 = (int)getdigits(__); p = __[0];
                    )
                    :else
                    (do
;                       Bytes[] __ = { p }; c2 = us-ptr2char-adv(__, true); p = __[0];
                    ))
                )
                (if (or (<= c 0) (<= 256 c) (and (< c2 c) (!= c2 -1)) (<= 256 c2) (not (or (eos? p) (== (.at p 0) (byte \,)))))
                    ((ร RETURN) false)
                )

                (when (== c2 -1)       ;; not a range
                    ;; A single '@' (not "@-@"):
                    ;; Decide on letters being ID/printable/keyword chars with
                    ;; standard function isalpha().  This takes care of locale
                    ;; for single-byte characters.

                    (cond (== c (byte \@))
                    (do
                        ((ร do_isalpha =) true)
                        ((ร c =) 1)
                        ((ร c2 =) 255)
                    )
                    :else
                    (do
                        ((ร c2 =) c)
                    ))
                )
                (while (<= c c2)
                    ;; Use the MB_ functions here, because isalpha() doesn't work properly
                    ;; when 'encoding' is "latin1" and the locale is "C".
                    (when (or (not do_isalpha) (utf-islower c) (utf-isupper c))
                        (cond (zero? i)                 ;; (re)set ID flag
                        (do
                            (if tilde
                                ((ร chartab[c] =) (& (... chartab c) (bit-not CT_ID_CHAR)))
                                ((ร chartab[c] =) (| (... chartab c) CT_ID_CHAR))
                            )
                        )
                        (== i 1)            ;; (re)set printable
                        (do
                            (when (or (< c (byte \space)) (< (byte \~) c))
                                (cond tilde
                                (do
                                    ((ร chartab[c] =) (byte (+ (& (... chartab c) (bit-not CT_CELL_MASK)) (if (flag? @dy_flags DY_UHEX) 4 2))))
                                    ((ร chartab[c] =) (& (... chartab c) (bit-not CT_PRINT_CHAR)))
                                )
                                :else
                                (do
                                    ((ร chartab[c] =) (byte (+ (& (... chartab c) (bit-not CT_CELL_MASK)) 1)))
                                    ((ร chartab[c] =) (| (... chartab c) CT_PRINT_CHAR))
                                ))
                            )
                        )
                        (== i 2)            ;; (re)set fname flag
                        (do
                            (if tilde
                                ((ร chartab[c] =) (& (... chartab c) (bit-not CT_FNAME_CHAR)))
                                ((ร chartab[c] =) (| (... chartab c) CT_FNAME_CHAR))
                            )
                        )
                        :else #_"/* i == 3 */"           ;; (re)set keyword flag
                        (do
                            (if tilde
                                (reset-chartab buf, c)
                                (set-chartab buf, c))
                        ))
                    )
                    (ร c++)
                )

                ((ร c =) (.at p 0))
                ((ร p =) (skip-to-option-part p))
                (when (and (== c (byte \,)) (eos? p))
                    ;; Trailing comma is not allowed.
                    ((ร RETURN) false)
                )
            )
        )

        (reset! chartab_initialized true)
        true
    ))

;; Translate any special characters in buf[bufsize] in-place.
;; The result is a string with only printable characters, but if there is not
;; enough room, not all characters will be translated.

(defn- #_void trans-characters [#_Bytes buf, #_int bufsize]
    (ยง
        ((ร int len =) (STRLEN buf))
        ((ร int room =) (- bufsize len))                           ;; room in buffer after string

        (while (!= (.at buf 0) 0)
            ((ร int trs_len =) (us-ptr2len-cc buf))

            ;; Assume a multi-byte character doesn't need translation.
            (cond (< 1 trs_len)
            (do
                ((ร len =) (- len trs_len))
            )
            :else
            (do
                ((ร Bytes trs =) (transchar-byte (.at buf 0)))          ;; translated character
                ((ร trs_len =) (STRLEN trs))
                (when (< 1 trs_len)
                    ((ร room =) (- room (dec trs_len)))
                    (if (<= room 0)
                        ((ร RETURN) nil)
                    )
                    (BCOPY buf, trs_len, buf, 1, len)
                )
                (BCOPY buf, trs, trs_len)
                (ร --len)
            ))

            ((ร buf =) (.plus buf trs_len))
        )
        nil
    ))

;; Catch 22: chartab[] can't be initialized before the options are initialized,
;; and initializing options may cause transchar() to be called!
;; When !chartab_initialized, don't use chartab[].
;; Does NOT work for multi-byte characters, c must be <= 255.
;; Also doesn't work for the first byte of a multi-byte, "c" must be a character!

(final Bytes transchar_buf (Bytes. 7))

(defn- #_Bytes transchar [#_int c]
    (ยง
        ((ร int i =) 0)

        (when (is-special c)      ;; special key code, display as ~@ char
            (.be transchar_buf 0, (byte \~))
            (.be transchar_buf 1, (byte \@))
            ((ร i =) 2)
            ((ร c =) (char_u (KB-SECOND c)))
        )

        (cond (or (and (not @chartab_initialized) (<= (byte \space) c) (<= c (byte \~))) (and (< c 256) (vim-isprintc c)))
        (do
            ;; printable character
            (.be transchar_buf i, c)
            (.be transchar_buf (inc i), NUL)
        )
        :else
        (do
            (transchar-nonprint (.plus transchar_buf i), c)
        ))

        transchar_buf
    ))

;; Like transchar(), but called with a byte instead of a character.
;; Checks for an illegal UTF-8 byte.

(defn- #_Bytes transchar-byte [#_byte b]
    (ยง
        (when (<= 0x80 (char_u b))
            (transchar-nonprint transchar_buf, (char_u b))
            ((ร RETURN) transchar_buf)
        )
        (transchar (char_u b))
    ))

;; Convert non-printable character to two or more printable characters in "buf[]".
;; "buf" needs to be able to hold five bytes.
;; Does NOT work for multi-byte characters, c must be <= 255.

(defn- #_void transchar-nonprint [#_Bytes buf, #_int c]
    (ยง
        (if (== c NL)
            ((ร c =) NUL)                                    ;; we use newline in place of a NUL
        )

        (cond (flag? @dy_flags DY_UHEX)                  ;; 'display' has "uhex"
        (do
            (transchar-hex buf, c)
        )
        (<= c 0x7f)                             ;; 0x00 - 0x1f and 0x7f
        (do
            (.be buf 0, (byte \^))
            (.be buf 1, (byte (bit-xor c 0x40)))                          ;; DEL displayed as ^?

            (eos! buf 2)
        )
        (<= 0x80 c)
        (do
            (transchar-hex buf, c)
        )
        (and (<= (+ (byte \space) 0x80) c) (<= c (+ (byte \~) 0x80)))    ;; 0xa0 - 0xfe
        (do
            (.be buf 0, (byte \|))
            (.be buf 1, (byte (- c 0x80)))
            (eos! buf 2)
        )
        :else                                            ;; 0x80 - 0x9f and 0xff
        (do
            (.be buf 0, (byte \~))
            (.be buf 1, (byte (bit-xor (- c 0x80) 0x40)))                 ;; 0xff displayed as ~?
            (eos! buf 2)
        ))
        nil
    ))

(defn- #_void transchar-hex [#_Bytes buf, #_int c]
    (ยง
        ((ร int i =) 0)

        (.be buf i, (byte \<))
        (when (< 0xff c)
            (.be buf (ร ++i), (nr2hex (>>> c 12)))
            (.be buf (ร ++i), (nr2hex (>>> c 8)))
        )
        (.be buf (ร ++i), (nr2hex (>>> c 4)))
        (.be buf (ร ++i), (nr2hex c))
        (.be buf (ร ++i), (byte \>))
        (.be buf (ร ++i), NUL)
        nil
    ))

;; Convert the lower 4 bits of byte "c" to its hex character.
;; Lower case letters are used to avoid the confusion of <F1> being 0xf1 or function key 1.

(defn- #_int nr2hex [#_int c]
    (let [n (& c 0xf)]
        (if (< n 10) (+ (byte \0) n) (+ (byte \a) (- n 10)))
    ))

;; Return number of display cells occupied by byte "b".
;; For multi-byte mode "b" must be the first byte of a character.
;; A TAB is counted as two cells: "^I".
;; For UTF-8 mode this will return 0 for bytes >= 0x80, because the number of cells depends on further bytes.

(defn- #_int mb-byte2cells [#_byte b]
    (let [i (char_u b)]
        (if (< i 0x80) (& (... chartab i) CT_CELL_MASK) 0)
    ))

;; Return number of display cells occupied by character "c".
;; "c" can be a special key (negative number) in which case 3 or 4 is returned.
;; A TAB is counted as two cells: "^I" or four: "<09>".

(defn- #_int mb-char2cells [#_int c]
    (ยง
        (if (is-special c)
            ((ร RETURN) (+ (mb-char2cells (char_u (KB-SECOND c))) 2))
        )

        ;; UTF-8: above 0x80 need to check the value.
        (if (<= 0x80 c)
            ((ร RETURN) (utf-char2cells c))
        )

        (& (... chartab (& c 0xff)) CT_CELL_MASK)
    ))

;; Return number of display cells occupied by character at "*p".
;; A TAB is counted as two cells: "^I" or four: "<09>".

(defn- #_int mb-ptr2cells [#_Bytes p]
    (ยง
        ;; For UTF-8 we need to look at more bytes if the first byte is >= 0x80.
        (if (<= 0x80 (char_u (.at p 0)))
            ((ร RETURN) (us-ptr2cells p))
        )

        (& (... chartab (char_u (.at p 0))) CT_CELL_MASK)
    ))

;; Return the number of character cells string "s[len]" will take on the screen,
;; counting TABs as two characters: "^I".

(defn- #_int mb-string2cells [#_Bytes p, #_int len]
    (ยง
        ((ร int cells =) 0)

        ((ร FOR) (ร ((ร int i =) 0) (and (or (< len 0) (< i len)) (non-eos? p i)) ((ร i =) (+ i (us-ptr2len-cc (.plus p i)))))
            ((ร cells =) (+ cells (mb-ptr2cells (.plus p i))))
        )

        cells
    ))

;; Return the number of characters 'c' will take on the screen,
;; taking into account the size of a tab.
;; Use a define to make it fast, this is used very often!!!
;; Also see getvcol() below.

(defn- #_int win-buf-chartabsize [#_window_C wp, #_buffer_C buf, #_Bytes p, #_int col]
    (ยง
        (when (== (.at p 0) TAB)
            ((ร int ts =) (int @(:b_p_ts buf)))
            ((ร RETURN) (- ts (% col ts)))
        )

        (mb-ptr2cells p)
    ))

(defn- #_int chartabsize [#_Bytes p, #_int col]
    (win-buf-chartabsize @curwin, @curbuf, p, col))

;; Return the number of characters the string 's' will take on the screen,
;; taking into account the size of a tab.

(defn- #_int linetabsize [#_Bytes s]
    (linetabsize-col s, 0))

;; Like linetabsize(), but starting at column "startcol".

(defn- #_int linetabsize-col [#_Bytes _s, #_int startcol]
    (ยง
; %%    ((ร Bytes[] s =) (ร { _s }))

        ((ร int col =) startcol)

        ((ร Bytes line =) (... s 0))        ;; pointer to start of line, for breakindent
        (while (non-eos? (... s 0))
            ((ร col =) (+ col (lbr-chartabsize-adv line, s, col)))
        )

        col
    ))

;; Like linetabsize(), but for a given window instead of the current one.

(defn- #_int win-linetabsize [#_window_C wp, #_Bytes line, #_int len]
    (ยง
        ((ร int col =) 0)

        ((ร FOR) (ร ((ร Bytes s =) line) (and (non-eos? s) (or (== len MAXCOL) (BLT s, (.plus line len)))) ((ร s =) (.plus s (us-ptr2len-cc s))))
            ((ร col =) (+ col (win-lbr-chartabsize wp, line, s, col, nil)))
        )

        col
    ))

;; Return true if 'c' is a normal identifier character:
;; Letters and characters from the 'isident' option.

(defn- #_boolean vim-isIDc [#_int c]
    (and (< 0 c 0x100) (flag? (... chartab c) CT_ID_CHAR)))

;; Return true if 'c' is a keyword character:
;; Letters and characters from 'iskeyword' option for current buffer.
;; For multi-byte characters us-get-class() is used (builtin rules).

(defn- #_boolean vim-iswordc [#_int c, #_buffer_C buf]
    (if (<= 0x100 c) (<= 2 (utf-class c)) (and (< 0 c 0x100) (non-zero? (get-chartab buf, c)))))

(defn- #_boolean us-iswordb [#_byte b, #_buffer_C buf]
    (and (non-zero? b) (non-zero? (get-chartab buf, (char_u b)))))

(defn- #_boolean us-iswordp [#_Bytes p, #_buffer_C buf]
    (if (< 1 (us-byte2len (.at p 0), false)) (<= 2 (us-get-class p, buf)) (us-iswordb (.at p 0), buf)))

;; Return true if 'c' is a valid file-name character.
;; Assume characters above 0x100 are valid (multi-byte).

(defn- #_boolean vim-isfilec [#_int c]
    (or (<= 0x100 c) (and (< 0 c) (flag? (... chartab c) CT_FNAME_CHAR))))

;; Return true if 'c' is a printable character.
;; Assume characters above 0x100 are printable (multi-byte), except for Unicode.

(defn- #_boolean vim-isprintc [#_int c]
    (if (<= 0x100 c) (utf-printable c) (or (<= 0x100 c) (and (< 0 c) (flag? (... chartab c) CT_PRINT_CHAR)))))

;; like chartabsize(), but also check for line breaks on the screen

(defn- #_int lbr-chartabsize [#_Bytes line, #_Bytes s, #_int col]
    ;; line: start of the line
    (let [options (:w_options @curwin)] (cond
        (or @(:wo_lbr options) (non-eos? @p_sbr) @(:wo_bri options))
            (win-lbr-chartabsize @curwin, (if (nil? line) s line), s, col, nil)
        @(:wo_wrap options)
            (win-nolbr-chartabsize @curwin, s, col, nil)
        :else
            (win-buf-chartabsize @curwin, @curbuf, s, col)
    )))

;; Call lbr-chartabsize() and advance the pointer.

(defn- #_int lbr-chartabsize-adv [#_Bytes line, #_Bytes* s, #_int col]
    ;; line: start of the line
    (ยง
        ((ร int retval =) (lbr-chartabsize line, (... s 0), col))
        ((ร s[0] =) (.plus (... s 0) (us-ptr2len-cc (... s 0))))
        retval
    ))

;; This function is used very often, keep it fast!!!!
;;
;; If "headp" not null, set "*headp" to the size of what we for 'showbreak' string at start of line.
;; Warning: "*headp" is only set if it's a non-zero value, init to 0 before calling.

(defn- #_int win-lbr-chartabsize [#_window_C wp, #_Bytes line, #_Bytes s, #_int col, #_int* headp]
    ;; line: start of the line
    (ยง
        ((ร int col_adj =) 0)                ;; col + screen size of tab
        ((ร int mb_added =) 0)
        ((ร boolean tab_corr =) (== (.at s 0) TAB))

        ;; No 'linebreak', 'showbreak' and 'breakindent': return quickly.

        (when (and (not @(:wo_lbr (:w_options wp))) (not @(:wo_bri (:w_options wp))) (eos? @p_sbr))
            (if @(:wo_wrap (:w_options wp))
                ((ร RETURN) (win-nolbr-chartabsize wp, s, col, headp))
            )

            ((ร RETURN) (win-buf-chartabsize wp, @curbuf, s, col))
        )

        ;; First get normal size, without 'linebreak'.

        ((ร int size =) (win-buf-chartabsize wp, @curbuf, s, col))
        ((ร byte c =) (.at s 0))
        (if tab_corr
            ((ร col_adj =) (dec size))
        )

        ;; If 'linebreak' set check at a blank before a non-blank if the line needs a break here.

        (cond (and @(:wo_lbr (:w_options wp)) (... @breakat_flags (char_u c)) (not (... @breakat_flags (char_u (.at s 1)))) @(:wo_wrap (:w_options wp)) (non-zero? (:w_width wp)))
        (do
            ;; Count all characters from first non-blank after a blank up to next non-blank after a blank.

            ((ร int numberextra =) (win-col-off wp))
            ((ร int col2 =) col)
            ((ร int colmax =) (- (:w_width wp) numberextra col_adj))
            (when (<= colmax col)
                ((ร colmax =) (+ colmax col_adj))
                ((ร int n =) (+ colmax (win-col-off2 wp)))
                (if (< 0 n)
                    ((ร colmax =) (+ colmax (- (* (+ (/ (- col colmax) n) 1) n) col_adj)))
                )
            )

            (while true
                ((ร Bytes ps =) s)
                ((ร s =) (.plus s (us-ptr2len-cc s)))
                ((ร c =) (.at s 0))
                (when (not (and (!= c NUL) (or (... @breakat_flags (char_u c)) (and (not (... @breakat_flags (char_u c))) (or (== col2 col) (not (... @breakat_flags (char_u (.at ps 0)))))))))
                    (ร BREAK)
                )

                ((ร col2 =) (+ col2 (win-buf-chartabsize wp, @curbuf, s, col2)))
                (when (<= colmax col2)         ;; doesn't fit
                    ((ร size =) (+ (- colmax col) col_adj))
                    ((ร tab_corr =) false)
                    (ร BREAK)
                )
            )
        )
        (and (== size 2) (< 1 (us-byte2len (.at s 0), false)) @(:wo_wrap (:w_options wp)) (in-win-border wp, col))
        (do
            (ร size++)         ;; Count the ">" in the last column.
            ((ร mb_added =) 1)
        ))

        ;; May have to add something for 'breakindent' and/or 'showbreak' string at start of line.
        ;; Set "*headp" to the size of what we add.

        ((ร int added =) 0)
        (when (and (or (non-eos? @p_sbr) @(:wo_bri (:w_options wp))) (and @(:wo_wrap (:w_options wp)) (non-zero? col)))
            ((ร int sbrlen =) 0)
            ((ร int numberwidth =) (win-col-off wp))

            ((ร int numberextra =) numberwidth)
            ((ร col =) (+ col (+ numberextra mb_added)))
            (when (<= (:w_width wp) col)
                ((ร col =) (- col (:w_width wp)))
                ((ร numberextra =) (- (:w_width wp) (- numberextra (win-col-off2 wp))))
                (if (and (>= col numberextra) (< 0 numberextra))
                    ((ร col =) (% col numberextra))
                )
                (when (non-eos? @p_sbr)
                    ((ร sbrlen =) (us-charlen @p_sbr))
                    (if (<= sbrlen col)
                        ((ร col =) (- col sbrlen))
                    )
                )
                (cond (and (>= col numberextra) (< 0 numberextra))
                (do
                    ((ร col =) (% col numberextra))
                )
                (and (< 0 col) (< 0 numberextra))
                (do
                    ((ร col =) (+ col (- numberwidth (win-col-off2 wp))))
                ))

                ((ร numberwidth =) (- numberwidth (win-col-off2 wp)))
            )
            (when (or (zero? col) (< (:w_width wp) (+ col size sbrlen)))
                ((ร added =) 0)
                (when (non-eos? @p_sbr)
                    (cond (< (:w_width wp) (+ size sbrlen numberwidth))
                    (do
                        ;; calculate effective window width
                        ((ร int width =) (- (:w_width wp) sbrlen numberwidth))
                        ((ร int prev_width =) (if (non-zero? col) (- (:w_width wp) (+ sbrlen col)) 0))
                        (if (zero? width)
                            ((ร width =) (:w_width wp))
                        )
                        ((ร added =) (+ added (* (/ (- size prev_width) width) (mb-string2cells @p_sbr, -1))))
                        (when (non-zero? (% (- size prev_width) width))
                            ;; wrapped, add another length of 'sbr'
                            ((ร added =) (+ added (mb-string2cells @p_sbr, -1)))
                        )
                    )
                    :else
                    (do
                        ((ร added =) (+ added (mb-string2cells @p_sbr, -1)))
                    ))
                )
                (if @(:wo_bri (:w_options wp))
                    ((ร added =) (+ added (get-breakindent-win wp, line)))
                )

                ((ร size =) (+ size added))
                (if (non-zero? col)
                    ((ร added =) 0)
                )
            )
        )
        (if (non-nil? headp)
            ((ร headp[0] =) (+ added mb_added))
        )

        size
    ))

;; Like win-lbr-chartabsize(), except that we know 'linebreak' is off and 'wrap' is on.
;; This means we need to check for a double-byte character that doesn't fit
;; at the end of the screen line.

(defn- #_int win-nolbr-chartabsize [#_window_C wp, #_Bytes p, #_int col, #_int* headp]
    (ยง
        (when (== (.at p 0) TAB)
            ((ร int ts =) (int @(:b_p_ts @curbuf)))
            ((ร RETURN) (- ts (% col ts)))
        )

        ((ร int n =) (mb-ptr2cells p))
        ;; Add one cell for a double-width character in the last column of the window,
        ;; displayed with a ">".
        (when (and (== n 2) (< 1 (us-byte2len (.at p 0), false)) (in-win-border wp, col))
            (if (non-nil? headp)
                ((ร headp[0] =) 1)
            )
            ((ร RETURN) 3)
        )
        n
    ))

;; Return true if virtual column "vcol" is in the rightmost column of window "wp".

(defn- #_boolean in-win-border [#_window_C wp, #_int vcol]
    (ยง
        (if (zero? (:w_width wp))                            ;; there is no border
            ((ร RETURN) false)
        )
        ((ร int width1 =) (- (:w_width wp) (win-col-off wp)))      ;; width of first line (after line number)
        (if (< vcol (dec width1))
            ((ร RETURN) false)
        )
        (if (== vcol (dec width1))
            ((ร RETURN) true)
        )
        ((ร int width2 =) (+ width1 (win-col-off2 wp)))         ;; width of further lines
        (if (<= width2 0)
            ((ร RETURN) false)
        )

        (== (% (- vcol width1) width2) (dec width2))
    ))

;; Get virtual column number of pos.
;;  start: on the first position of this character (TAB, ctrl)
;; cursor: where the cursor is on this character (first char, except for TAB)
;;    end: on the last position of this character (TAB, ctrl)
;;
;; This is used very often, keep it fast!

(defn- #_void getvcol [#_window_C wp, #_pos_C pos, #_int* start, #_int* cursor, #_int* end]
    (ยง
        ((ร Bytes p =) (ml-get-buf @curbuf, (:lnum pos)))
        ((ร Bytes line =) p)
        ((ร Bytes posptr =) (if (== (:col pos) MAXCOL) nil (.plus p (:col pos))))

        ((ร int vcol =) 0)
        ((ร int ts =) (int @(:b_p_ts @curbuf)))

        ((ร int[] head =) (ร new int[1]))
        (ร int incr)

        ;; This function is used very often, do some speed optimizations.
        ;; When 'list', 'linebreak', 'showbreak' and 'breakindent' are not set use a simple loop.
        ;; Also use this when 'list' is set but tabs take their normal size.

        (cond (and (not @(:wo_lbr (:w_options wp))) (eos? @p_sbr) (not @(:wo_bri (:w_options wp))))
        (do
            ((ร FOR) (ร nil true ((ร p =) (.plus p (us-ptr2len-cc p))))
                ((ร head[0] =) 0)
                ;; make sure we don't go past the end of the line
                (when (eos? p)
                    ((ร incr =) 1)       ;; NUL at end of line only takes one column
                    (ร BREAK)
                )
                ;; A tab gets expanded, depending on the current column.
                (cond (== (.at p 0) TAB)
                (do
                    ((ร incr =) (- ts (% vcol ts)))
                )
                :else
                (do
                    ((ร incr =) (mb-ptr2cells p))

                    ;; If a double-cell char doesn't fit at the end of a line,
                    ;; it wraps to the next line, it's like this char is three cells wide.
                    (when (and (== incr 2) @(:wo_wrap (:w_options wp)) (< 1 (us-byte2len (.at p 0), false)) (in-win-border wp, vcol))
                        (ร incr++)
                        ((ร head[0] =) 1)
                    )
                ))

                (if (and (non-nil? posptr) (BLE posptr, p))  ;; character at pos.col
                    (ร BREAK)
                )

                ((ร vcol =) (+ vcol incr))
            )
        )
        :else
        (do
            ((ร FOR) (ร nil true ((ร p =) (.plus p (us-ptr2len-cc p))))
                ;; A tab gets expanded, depending on the current column.
                ((ร head[0] =) 0)
                ((ร incr =) (win-lbr-chartabsize wp, line, p, vcol, head))
                ;; make sure we don't go past the end of the line
                (when (eos? p)
                    ((ร incr =) 1)       ;; NUL at end of line only takes one column
                    (ร BREAK)
                )

                (if (and (non-nil? posptr) (BLE posptr, p))  ;; character at pos.col
                    (ร BREAK)
                )

                ((ร vcol =) (+ vcol incr))
            )
        ))
        (if (non-nil? start)
            ((ร start[0] =) (+ vcol (... head 0)))
        )
        (if (non-nil? end)
            ((ร end[0] =) (- (+ vcol incr) 1))
        )
        (when (non-nil? cursor)
            (cond (and (== (.at p 0) TAB) (flag? @State NORMAL) (not (virtual-active)) (not (and @VIsual_active (or (== (.at @p_sel 0) (byte \e)) (ltoreq pos, @VIsual)))))
            (do
                ((ร cursor[0] =) (- (+ vcol incr) 1))        ;; cursor at end
            )
            :else
            (do
                ((ร cursor[0] =) (+ vcol (... head 0)))         ;; cursor at start
            ))
        )
        nil
    ))

;; Get virtual cursor column in the current window, pretending 'list' is off.

(defn- #_int getvcol-nolist [#_pos_C posp]
    (ยง
        ((ร int[] vcol =) (ร new int[1]))
        (getvcol @curwin, posp, nil, vcol, nil)
        (... vcol 0)
    ))

;; Get virtual column in virtual mode.

(defn- #_void getvvcol [#_window_C wp, #_pos_C pos, #_int* start, #_int* cursor, #_int* end]
    (ยง
        (cond (virtual-active)
        (do
            ;; For virtual mode, only want one value.
            ((ร int[] col =) (ร new int[1]))
            (getvcol wp, pos, col, nil, nil)
            ((ร int coladd =) (:coladd pos))
            ((ร int endadd =) 0)

            ;; Cannot put the cursor on part of a wide character.
            ((ร Bytes ptr =) (ml-get-buf @curbuf, (:lnum pos)))
            (when (< (:col pos) (STRLEN ptr))
                ((ร int c =) (us-ptr2char (.plus ptr (:col pos))))

                (when (and (!= c TAB) (vim-isprintc c))
                    ((ร endadd =) (- (mb-char2cells c) 1))
                    (if (< endadd coladd)    ;; past end of line
                        ((ร endadd =) 0)
                        ((ร coladd =) 0)
                    )
                )
            )
            ((ร col[0] =) (+ (... col 0) coladd))
            (if (non-nil? start)
                ((ร start[0] =) (... col 0))
            )
            (if (non-nil? cursor)
                ((ร cursor[0] =) (... col 0))
            )
            (if (non-nil? end)
                ((ร end[0] =) (+ (... col 0) endadd))
            )
        )
        :else
        (do
            (getvcol wp, pos, start, cursor, end)
        ))
        nil
    ))

;; Get the leftmost and rightmost virtual column of pos1 and pos2.
;; Used for Visual block mode.

(defn- #_void getvcols [#_window_C wp, #_pos_C pos1, #_pos_C pos2, #_int* left, #_int* right]
    (ยง
        ((ร int[] from1 =) (ร new int[1]))
        ((ร int[] from2 =) (ร new int[1]))
        ((ร int[] to1 =) (ร new int[1]))
        ((ร int[] to2 =) (ร new int[1]))

        (cond (ltpos pos1, pos2)
        (do
            (getvvcol wp, pos1, from1, nil, to1)
            (getvvcol wp, pos2, from2, nil, to2)
        )
        :else
        (do
            (getvvcol wp, pos2, from1, nil, to1)
            (getvvcol wp, pos1, from2, nil, to2)
        ))
        ((ร left[0] =) (if (< (... from2 0) (... from1 0)) (... from2 0) (... from1 0)))
        (cond (< (... to1 0) (... to2 0))
        (do
            ((ร right[0] =) (if (and (== (.at @p_sel 0) (byte \e)) (<= (... to1 0) (- (... from2 0) 1))) (- (... from2 0) 1) (... to2 0)))
        )
        :else
        (do
            ((ร right[0] =) (... to1 0))
        ))
        nil
    ))

;; Skip over ' ' and '\t'.

(defn- #_Bytes skipwhite [#_Bytes q]
    (ยง
        ((ร Bytes p =) q)

        (while (vim-iswhite (.at p 0))
            ((ร p =) (.plus p 1))
        )    ;; skip to next non-white
        p
    ))

;; skip over digits

(defn- #_Bytes skipdigits [#_Bytes q]
    (ยง
        ((ร Bytes p =) q)

        (while (asc-isdigit (.at p 0))
            ((ร p =) (.plus p 1))
        )    ;; skip to next non-digit
        p
    ))

(defn- #_boolean asc-isdigit  [#_int c] (<= (byte \0) c (byte \9)))
(defn- #_boolean asc-isodigit [#_int c] (<= (byte \0) c (byte \7)))
(defn- #_boolean asc-isxdigit [#_int c] (or (<= (byte \0) c (byte \9)) (<= (byte \a) c (byte \f)) (<= (byte \A) c (byte \F))))

;; Getdigits: Get a number from a string and skip over it.
;; Note: the argument is a pointer to a byte pointer!

(defn- #_long getdigits [#_Bytes* pp]
    (ยง
        ((ร Bytes p =) (... pp 0))
        ((ร long retval =) (.atol libC p))
        (if (== (.at p 0) (byte \-))                  ;; skip negative sign
            ((ร p =) (.plus p 1))
        )
        ((ร p =) (skipdigits p))              ;; skip to next non-digit
        ((ร pp[0] =) p)

        retval
    ))

;; Convert a string into a long and/or unsigned long, taking care of
;; hexadecimal and octal numbers.  Accepts a '-' sign.
;; If "hexp" is not null, returns a flag to indicate the type of the number:
;;  0       decimal
;;  '0'     octal
;;  'X'     hex
;;  'x'     hex
;; If "len" is not null, the length of the number in characters is returned.
;; If "nptr" is not null, the signed result is returned in it.
;; If "unptr" is not null, the unsigned result is returned in it.
;; If "dooct" is non-zero recognize octal numbers, when > 1 always assume octal number.
;; If "dohex" is non-zero recognize hex numbers, when > 1 always assume hex number.

(defn- #_void vim-str2nr [#_Bytes start, #_int* hexp, #_int* len, #_int dooct, #_int dohex, #_long* nptr]
    ;; hexp: return: type of number 0 = decimal, 'x' or 'X' is hex, '0' = octal
    ;; len: return: detected length of number
    ;; dooct: recognize octal number
    ;; dohex: recognize hex number
    ;; nptr: return: signed result
    (ยง
        ((ร Bytes ptr =) start)

        ((ร boolean negative =) false)
        (when (== (.at ptr 0) (byte \-))
            ((ร negative =) true)
            ((ร ptr =) (.plus ptr 1))
        )

        ((ร int hex =) 0)                        ;; default is decimal

        ;; Recognize hex and octal.
        (when (and (== (.at ptr 0) (byte \0)) (!= (.at ptr 1) (byte \8)) (!= (.at ptr 1) (byte \9)))
            ((ร hex =) (.at ptr 1))
            (cond (and (non-zero? dohex) (or (== hex (byte \X)) (== hex (byte \x))) (asc-isxdigit (.at ptr 2)))
            (do
                ((ร ptr =) (.plus ptr 2))          ;; hexadecimal
            )
            :else
            (do
                ((ร hex =) 0)                    ;; default is decimal
                (when (non-zero? dooct)
                    ;; Don't interpret "0", "08" or "0129" as octal.
                    ((ร FOR) (ร ((ร int n =) 1) (asc-isdigit (.at ptr n)) (ร n++))
                        (when (< (byte \7) (.at ptr n))
                            ((ร hex =) 0)        ;; can't be octal
                            (ร BREAK)
                        )
                        (if (<= (byte \0) (.at ptr n))
                            ((ร hex =) (byte \0))      ;; assume octal
                        )
                    )
                )
            ))
        )

        ((ร long nr =) 0)

        ;; Do the string-to-numeric conversion "manually" to avoid sscanf quirks.

        (cond (or (== hex (byte \0)) (< 1 dooct))
        (do
            ((ร FOR) (ร nil (asc-isodigit (.at ptr 0)) ((ร ptr =) (.plus ptr 1)))         ;; octal
                ((ร long l =) (+ (* 8 nr) (long (- (.at ptr 0) (byte \0)))))
                (if (< l nr)
                    (ร BREAK)
                )
                ((ร nr =) l)
            )
        )
        (or (non-zero? hex) (< 1 dohex))
        (do
            ((ร FOR) (ร nil (asc-isxdigit (.at ptr 0)) ((ร ptr =) (.plus ptr 1)))         ;; hex
                ((ร long l =) (+ (* 16 nr) (long (hex2nr (.at ptr 0)))))
                (if (< l nr)
                    (ร BREAK)
                )
                ((ร nr =) l)
            )
        )
        :else
        (do
            ((ร FOR) (ร nil (asc-isdigit (.at ptr 0)) ((ร ptr =) (.plus ptr 1)))          ;; decimal
                ((ร long l =) (+ (* 10 nr) (long (- (.at ptr 0) (byte \0)))))
                (if (< l nr)
                    (ร BREAK)
                )
                ((ร nr =) l)
            )
        ))

        (if (non-nil? hexp)
            ((ร hexp[0] =) hex)
        )
        (if (non-nil? len)
            ((ร len[0] =) (BDIFF ptr, start))
        )
        (when (non-nil? nptr)
            ((ร nptr[0] =) (if negative (- nr) nr))               ;; account for leading '-' for decimal numbers
        )
        nil
    ))

;; Return the value of a single hex character.
;; Only valid when the argument is '0' - '9', 'A' - 'F' or 'a' - 'f'.

(defn- #_int hex2nr [#_int c]
    (cond
        (<= (byte \a) c (byte \f)) (+ (- c (byte \a)) 10)
        (<= (byte \A) c (byte \F)) (+ (- c (byte \A)) 10)
        :else (- c (byte \0))
    ))

;;; ============================================================================================== VimR

;; digraph.c: code for digraphs -------------------------------------------------------------------

(class! #_final digr_C
    [
        (field byte     char1)
        (field byte     char2)
        (field int      result)
    ])

(defn- #_final #_digr_C digr [#_"/*byte*/char" char1, #_"/*byte*/char" char2, #_int result]
    (new digr_C (byte char1), (byte char2), result))

;; digraphs for Unicode from RFC1345 (also work for ISO-8859-1 aka latin1)
(final digr_C* digraphdefault
    [
        (digr \N, \U, 0x0a),       ;; LF for NUL
        (digr \S, \H, 0x01),
        (digr \S, \X, 0x02),
        (digr \E, \X, 0x03),
        (digr \E, \T, 0x04),
        (digr \E, \Q, 0x05),
        (digr \A, \K, 0x06),
        (digr \B, \L, 0x07),
        (digr \B, \S, 0x08),
        (digr \H, \T, 0x09),
        (digr \L, \F, 0x0a),
        (digr \V, \T, 0x0b),
        (digr \F, \F, 0x0c),
        (digr \C, \R, 0x0d),
        (digr \S, \O, 0x0e),
        (digr \S, \I, 0x0f),
        (digr \D, \L, 0x10),
        (digr \D, \1, 0x11),
        (digr \D, \2, 0x12),
        (digr \D, \3, 0x13),
        (digr \D, \4, 0x14),
        (digr \N, \K, 0x15),
        (digr \S, \Y, 0x16),
        (digr \E, \B, 0x17),
        (digr \C, \N, 0x18),
        (digr \E, \M, 0x19),
        (digr \S, \B, 0x1a),
        (digr \E, \C, 0x1b),
        (digr \F, \S, 0x1c),
        (digr \G, \S, 0x1d),
        (digr \R, \S, 0x1e),
        (digr \U, \S, 0x1f),
        (digr \S, \P, 0x20),
        (digr \N, \b, 0x23),
        (digr \D, \O, 0x24),
        (digr \A, \t, 0x40),
        (digr \<, \(, 0x5b),
        (digr \/, \/, 0x5c),
        (digr \), \>, 0x5d),
        (digr \', \>, 0x5e),
        (digr \', \!, 0x60),
        (digr \(, \!, 0x7b),
        (digr \!, \!, 0x7c),
        (digr \!, \), 0x7d),
        (digr \', \?, 0x7e),
        (digr \D, \T, 0x7f),
        (digr \P, \A, 0x80),
        (digr \H, \O, 0x81),
        (digr \B, \H, 0x82),
        (digr \N, \H, 0x83),
        (digr \I, \N, 0x84),
        (digr \N, \L, 0x85),
        (digr \S, \A, 0x86),
        (digr \E, \S, 0x87),
        (digr \H, \S, 0x88),
        (digr \H, \J, 0x89),
        (digr \V, \S, 0x8a),
        (digr \P, \D, 0x8b),
        (digr \P, \U, 0x8c),
        (digr \R, \I, 0x8d),
        (digr \S, \2, 0x8e),
        (digr \S, \3, 0x8f),
        (digr \D, \C, 0x90),
        (digr \P, \1, 0x91),
        (digr \P, \2, 0x92),
        (digr \T, \S, 0x93),
        (digr \C, \C, 0x94),
        (digr \M, \W, 0x95),
        (digr \S, \G, 0x96),
        (digr \E, \G, 0x97),
        (digr \S, \S, 0x98),
        (digr \G, \C, 0x99),
        (digr \S, \C, 0x9a),
        (digr \C, \I, 0x9b),
        (digr \S, \T, 0x9c),
        (digr \O, \C, 0x9d),
        (digr \P, \M, 0x9e),
        (digr \A, \C, 0x9f),
        (digr \N, \S, 0xa0),
        (digr \!, \I, 0xa1),
        (digr \C, \t, 0xa2),
        (digr \P, \d, 0xa3),
        (digr \C, \u, 0xa4),
        (digr \Y, \e, 0xa5),
        (digr \B, \B, 0xa6),
        (digr \S, \E, 0xa7),
        (digr \', \:, 0xa8),
        (digr \C, \o, 0xa9),
        (digr \-, \a, 0xaa),
        (digr \<, \<, 0xab),
        (digr \N, \O, 0xac),
        (digr \-, \-, 0xad),
        (digr \R, \g, 0xae),
        (digr \', \m, 0xaf),
        (digr \D, \G, 0xb0),
        (digr \+, \-, 0xb1),
        (digr \2, \S, 0xb2),
        (digr \3, \S, 0xb3),
        (digr \', \', 0xb4),
        (digr \M, \y, 0xb5),
        (digr \P, \I, 0xb6),
        (digr \., \M, 0xb7),
        (digr \', \,, 0xb8),
        (digr \1, \S, 0xb9),
        (digr \-, \o, 0xba),
        (digr \>, \>, 0xbb),
        (digr \1, \4, 0xbc),
        (digr \1, \2, 0xbd),
        (digr \3, \4, 0xbe),
        (digr \?, \I, 0xbf),
        (digr \A, \!, 0xc0),
        (digr \A, \', 0xc1),
        (digr \A, \>, 0xc2),
        (digr \A, \?, 0xc3),
        (digr \A, \:, 0xc4),
        (digr \A, \A, 0xc5),
        (digr \A, \E, 0xc6),
        (digr \C, \,, 0xc7),
        (digr \E, \!, 0xc8),
        (digr \E, \', 0xc9),
        (digr \E, \>, 0xca),
        (digr \E, \:, 0xcb),
        (digr \I, \!, 0xcc),
        (digr \I, \', 0xcd),
        (digr \I, \>, 0xce),
        (digr \I, \:, 0xcf),
        (digr \D, \-, 0xd0),
        (digr \N, \?, 0xd1),
        (digr \O, \!, 0xd2),
        (digr \O, \', 0xd3),
        (digr \O, \>, 0xd4),
        (digr \O, \?, 0xd5),
        (digr \O, \:, 0xd6),
        (digr \*, \X, 0xd7),
        (digr \O, \/, 0xd8),
        (digr \U, \!, 0xd9),
        (digr \U, \', 0xda),
        (digr \U, \>, 0xdb),
        (digr \U, \:, 0xdc),
        (digr \Y, \', 0xdd),
        (digr \T, \H, 0xde),
        (digr \s, \s, 0xdf),
        (digr \a, \!, 0xe0),
        (digr \a, \', 0xe1),
        (digr \a, \>, 0xe2),
        (digr \a, \?, 0xe3),
        (digr \a, \:, 0xe4),
        (digr \a, \a, 0xe5),
        (digr \a, \e, 0xe6),
        (digr \c, \,, 0xe7),
        (digr \e, \!, 0xe8),
        (digr \e, \', 0xe9),
        (digr \e, \>, 0xea),
        (digr \e, \:, 0xeb),
        (digr \i, \!, 0xec),
        (digr \i, \', 0xed),
        (digr \i, \>, 0xee),
        (digr \i, \:, 0xef),
        (digr \d, \-, 0xf0),
        (digr \n, \?, 0xf1),
        (digr \o, \!, 0xf2),
        (digr \o, \', 0xf3),
        (digr \o, \>, 0xf4),
        (digr \o, \?, 0xf5),
        (digr \o, \:, 0xf6),
        (digr \-, \:, 0xf7),
        (digr \o, \/, 0xf8),
        (digr \u, \!, 0xf9),
        (digr \u, \', 0xfa),
        (digr \u, \>, 0xfb),
        (digr \u, \:, 0xfc),
        (digr \y, \', 0xfd),
        (digr \t, \h, 0xfe),
        (digr \y, \:, 0xff),

        (digr \A, \-, 0x0100),
        (digr \a, \-, 0x0101),
        (digr \A, \(, 0x0102),
        (digr \a, \(, 0x0103),
        (digr \A, \;, 0x0104),
        (digr \a, \;, 0x0105),
        (digr \C, \', 0x0106),
        (digr \c, \', 0x0107),
        (digr \C, \>, 0x0108),
        (digr \c, \>, 0x0109),
        (digr \C, \., 0x010a),
        (digr \c, \., 0x010b),
        (digr \C, \<, 0x010c),
        (digr \c, \<, 0x010d),
        (digr \D, \<, 0x010e),
        (digr \d, \<, 0x010f),
        (digr \D, \/, 0x0110),
        (digr \d, \/, 0x0111),
        (digr \E, \-, 0x0112),
        (digr \e, \-, 0x0113),
        (digr \E, \(, 0x0114),
        (digr \e, \(, 0x0115),
        (digr \E, \., 0x0116),
        (digr \e, \., 0x0117),
        (digr \E, \;, 0x0118),
        (digr \e, \;, 0x0119),
        (digr \E, \<, 0x011a),
        (digr \e, \<, 0x011b),
        (digr \G, \>, 0x011c),
        (digr \g, \>, 0x011d),
        (digr \G, \(, 0x011e),
        (digr \g, \(, 0x011f),
        (digr \G, \., 0x0120),
        (digr \g, \., 0x0121),
        (digr \G, \,, 0x0122),
        (digr \g, \,, 0x0123),
        (digr \H, \>, 0x0124),
        (digr \h, \>, 0x0125),
        (digr \H, \/, 0x0126),
        (digr \h, \/, 0x0127),
        (digr \I, \?, 0x0128),
        (digr \i, \?, 0x0129),
        (digr \I, \-, 0x012a),
        (digr \i, \-, 0x012b),
        (digr \I, \(, 0x012c),
        (digr \i, \(, 0x012d),
        (digr \I, \;, 0x012e),
        (digr \i, \;, 0x012f),
        (digr \I, \., 0x0130),
        (digr \i, \., 0x0131),
        (digr \I, \J, 0x0132),
        (digr \i, \j, 0x0133),
        (digr \J, \>, 0x0134),
        (digr \j, \>, 0x0135),
        (digr \K, \,, 0x0136),
        (digr \k, \,, 0x0137),
        (digr \k, \k, 0x0138),
        (digr \L, \', 0x0139),
        (digr \l, \', 0x013a),
        (digr \L, \,, 0x013b),
        (digr \l, \,, 0x013c),
        (digr \L, \<, 0x013d),
        (digr \l, \<, 0x013e),
        (digr \L, \., 0x013f),
        (digr \l, \., 0x0140),
        (digr \L, \/, 0x0141),
        (digr \l, \/, 0x0142),
        (digr \N, \', 0x0143),
        (digr \n, \', 0x0144),
        (digr \N, \,, 0x0145),
        (digr \n, \,, 0x0146),
        (digr \N, \<, 0x0147),
        (digr \n, \<, 0x0148),
        (digr \', \n, 0x0149),
        (digr \N, \G, 0x014a),
        (digr \n, \g, 0x014b),
        (digr \O, \-, 0x014c),
        (digr \o, \-, 0x014d),
        (digr \O, \(, 0x014e),
        (digr \o, \(, 0x014f),
        (digr \O, \", 0x0150),  ;; """
        (digr \o, \", 0x0151),  ;; """
        (digr \O, \E, 0x0152),
        (digr \o, \e, 0x0153),
        (digr \R, \', 0x0154),
        (digr \r, \', 0x0155),
        (digr \R, \,, 0x0156),
        (digr \r, \,, 0x0157),
        (digr \R, \<, 0x0158),
        (digr \r, \<, 0x0159),
        (digr \S, \', 0x015a),
        (digr \s, \', 0x015b),
        (digr \S, \>, 0x015c),
        (digr \s, \>, 0x015d),
        (digr \S, \,, 0x015e),
        (digr \s, \,, 0x015f),
        (digr \S, \<, 0x0160),
        (digr \s, \<, 0x0161),
        (digr \T, \,, 0x0162),
        (digr \t, \,, 0x0163),
        (digr \T, \<, 0x0164),
        (digr \t, \<, 0x0165),
        (digr \T, \/, 0x0166),
        (digr \t, \/, 0x0167),
        (digr \U, \?, 0x0168),
        (digr \u, \?, 0x0169),
        (digr \U, \-, 0x016a),
        (digr \u, \-, 0x016b),
        (digr \U, \(, 0x016c),
        (digr \u, \(, 0x016d),
        (digr \U, \0, 0x016e),
        (digr \u, \0, 0x016f),
        (digr \U, \", 0x0170),  ;; """
        (digr \u, \", 0x0171),  ;; """
        (digr \U, \;, 0x0172),
        (digr \u, \;, 0x0173),
        (digr \W, \>, 0x0174),
        (digr \w, \>, 0x0175),
        (digr \Y, \>, 0x0176),
        (digr \y, \>, 0x0177),
        (digr \Y, \:, 0x0178),
        (digr \Z, \', 0x0179),
        (digr \z, \', 0x017a),
        (digr \Z, \., 0x017b),
        (digr \z, \., 0x017c),
        (digr \Z, \<, 0x017d),
        (digr \z, \<, 0x017e),
        (digr \O, \9, 0x01a0),
        (digr \o, \9, 0x01a1),
        (digr \O, \I, 0x01a2),
        (digr \o, \i, 0x01a3),
        (digr \y, \r, 0x01a6),
        (digr \U, \9, 0x01af),
        (digr \u, \9, 0x01b0),
        (digr \Z, \/, 0x01b5),
        (digr \z, \/, 0x01b6),
        (digr \E, \D, 0x01b7),
        (digr \A, \<, 0x01cd),
        (digr \a, \<, 0x01ce),
        (digr \I, \<, 0x01cf),
        (digr \i, \<, 0x01d0),
        (digr \O, \<, 0x01d1),
        (digr \o, \<, 0x01d2),
        (digr \U, \<, 0x01d3),
        (digr \u, \<, 0x01d4),
        (digr \A, \1, 0x01de),
        (digr \a, \1, 0x01df),
        (digr \A, \7, 0x01e0),
        (digr \a, \7, 0x01e1),
        (digr \A, \3, 0x01e2),
        (digr \a, \3, 0x01e3),
        (digr \G, \/, 0x01e4),
        (digr \g, \/, 0x01e5),
        (digr \G, \<, 0x01e6),
        (digr \g, \<, 0x01e7),
        (digr \K, \<, 0x01e8),
        (digr \k, \<, 0x01e9),
        (digr \O, \;, 0x01ea),
        (digr \o, \;, 0x01eb),
        (digr \O, \1, 0x01ec),
        (digr \o, \1, 0x01ed),
        (digr \E, \Z, 0x01ee),
        (digr \e, \z, 0x01ef),
        (digr \j, \<, 0x01f0),
        (digr \G, \', 0x01f4),
        (digr \g, \', 0x01f5),
        (digr \;, \S, 0x02bf),
        (digr \', \<, 0x02c7),
        (digr \', \(, 0x02d8),
        (digr \', \., 0x02d9),
        (digr \', \0, 0x02da),
        (digr \', \;, 0x02db),
        (digr \', \", 0x02dd),  ;; """
        (digr \A, \%, 0x0386),
        (digr \E, \%, 0x0388),
        (digr \Y, \%, 0x0389),
        (digr \I, \%, 0x038a),
        (digr \O, \%, 0x038c),
        (digr \U, \%, 0x038e),
        (digr \W, \%, 0x038f),
        (digr \i, \3, 0x0390),
        (digr \A, \*, 0x0391),
        (digr \B, \*, 0x0392),
        (digr \G, \*, 0x0393),
        (digr \D, \*, 0x0394),
        (digr \E, \*, 0x0395),
        (digr \Z, \*, 0x0396),
        (digr \Y, \*, 0x0397),
        (digr \H, \*, 0x0398),
        (digr \I, \*, 0x0399),
        (digr \K, \*, 0x039a),
        (digr \L, \*, 0x039b),
        (digr \M, \*, 0x039c),
        (digr \N, \*, 0x039d),
        (digr \C, \*, 0x039e),
        (digr \O, \*, 0x039f),
        (digr \P, \*, 0x03a0),
        (digr \R, \*, 0x03a1),
        (digr \S, \*, 0x03a3),
        (digr \T, \*, 0x03a4),
        (digr \U, \*, 0x03a5),
        (digr \F, \*, 0x03a6),
        (digr \X, \*, 0x03a7),
        (digr \Q, \*, 0x03a8),
        (digr \W, \*, 0x03a9),
        (digr \J, \*, 0x03aa),
        (digr \V, \*, 0x03ab),
        (digr \a, \%, 0x03ac),
        (digr \e, \%, 0x03ad),
        (digr \y, \%, 0x03ae),
        (digr \i, \%, 0x03af),
        (digr \u, \3, 0x03b0),
        (digr \a, \*, 0x03b1),
        (digr \b, \*, 0x03b2),
        (digr \g, \*, 0x03b3),
        (digr \d, \*, 0x03b4),
        (digr \e, \*, 0x03b5),
        (digr \z, \*, 0x03b6),
        (digr \y, \*, 0x03b7),
        (digr \h, \*, 0x03b8),
        (digr \i, \*, 0x03b9),
        (digr \k, \*, 0x03ba),
        (digr \l, \*, 0x03bb),
        (digr \m, \*, 0x03bc),
        (digr \n, \*, 0x03bd),
        (digr \c, \*, 0x03be),
        (digr \o, \*, 0x03bf),
        (digr \p, \*, 0x03c0),
        (digr \r, \*, 0x03c1),
        (digr \*, \s, 0x03c2),
        (digr \s, \*, 0x03c3),
        (digr \t, \*, 0x03c4),
        (digr \u, \*, 0x03c5),
        (digr \f, \*, 0x03c6),
        (digr \x, \*, 0x03c7),
        (digr \q, \*, 0x03c8),
        (digr \w, \*, 0x03c9),
        (digr \j, \*, 0x03ca),
        (digr \v, \*, 0x03cb),
        (digr \o, \%, 0x03cc),
        (digr \u, \%, 0x03cd),
        (digr \w, \%, 0x03ce),
        (digr \', \G, 0x03d8),
        (digr \,, \G, 0x03d9),
        (digr \T, \3, 0x03da),
        (digr \t, \3, 0x03db),
        (digr \M, \3, 0x03dc),
        (digr \m, \3, 0x03dd),
        (digr \K, \3, 0x03de),
        (digr \k, \3, 0x03df),
        (digr \P, \3, 0x03e0),
        (digr \p, \3, 0x03e1),
        (digr \', \%, 0x03f4),
        (digr \j, \3, 0x03f5),
        (digr \I, \O, 0x0401),
        (digr \D, \%, 0x0402),
        (digr \G, \%, 0x0403),
        (digr \I, \E, 0x0404),
        (digr \D, \S, 0x0405),
        (digr \I, \I, 0x0406),
        (digr \Y, \I, 0x0407),
        (digr \J, \%, 0x0408),
        (digr \L, \J, 0x0409),
        (digr \N, \J, 0x040a),
        (digr \T, \s, 0x040b),
        (digr \K, \J, 0x040c),
        (digr \V, \%, 0x040e),
        (digr \D, \Z, 0x040f),
        (digr \A, \=, 0x0410),
        (digr \B, \=, 0x0411),
        (digr \V, \=, 0x0412),
        (digr \G, \=, 0x0413),
        (digr \D, \=, 0x0414),
        (digr \E, \=, 0x0415),
        (digr \Z, \%, 0x0416),
        (digr \Z, \=, 0x0417),
        (digr \I, \=, 0x0418),
        (digr \J, \=, 0x0419),
        (digr \K, \=, 0x041a),
        (digr \L, \=, 0x041b),
        (digr \M, \=, 0x041c),
        (digr \N, \=, 0x041d),
        (digr \O, \=, 0x041e),
        (digr \P, \=, 0x041f),
        (digr \R, \=, 0x0420),
        (digr \S, \=, 0x0421),
        (digr \T, \=, 0x0422),
        (digr \U, \=, 0x0423),
        (digr \F, \=, 0x0424),
        (digr \H, \=, 0x0425),
        (digr \C, \=, 0x0426),
        (digr \C, \%, 0x0427),
        (digr \S, \%, 0x0428),
        (digr \S, \c, 0x0429),
        (digr \=, \", 0x042a),  ;; """
        (digr \Y, \=, 0x042b),
        (digr \%, \", 0x042c),  ;; """
        (digr \J, \E, 0x042d),
        (digr \J, \U, 0x042e),
        (digr \J, \A, 0x042f),
        (digr \a, \=, 0x0430),
        (digr \b, \=, 0x0431),
        (digr \v, \=, 0x0432),
        (digr \g, \=, 0x0433),
        (digr \d, \=, 0x0434),
        (digr \e, \=, 0x0435),
        (digr \z, \%, 0x0436),
        (digr \z, \=, 0x0437),
        (digr \i, \=, 0x0438),
        (digr \j, \=, 0x0439),
        (digr \k, \=, 0x043a),
        (digr \l, \=, 0x043b),
        (digr \m, \=, 0x043c),
        (digr \n, \=, 0x043d),
        (digr \o, \=, 0x043e),
        (digr \p, \=, 0x043f),
        (digr \r, \=, 0x0440),
        (digr \s, \=, 0x0441),
        (digr \t, \=, 0x0442),
        (digr \u, \=, 0x0443),
        (digr \f, \=, 0x0444),
        (digr \h, \=, 0x0445),
        (digr \c, \=, 0x0446),
        (digr \c, \%, 0x0447),
        (digr \s, \%, 0x0448),
        (digr \s, \c, 0x0449),
        (digr \=, \', 0x044a),
        (digr \y, \=, 0x044b),
        (digr \%, \', 0x044c),
        (digr \j, \e, 0x044d),
        (digr \j, \u, 0x044e),
        (digr \j, \a, 0x044f),
        (digr \i, \o, 0x0451),
        (digr \d, \%, 0x0452),
        (digr \g, \%, 0x0453),
        (digr \i, \e, 0x0454),
        (digr \d, \s, 0x0455),
        (digr \i, \i, 0x0456),
        (digr \y, \i, 0x0457),
        (digr \j, \%, 0x0458),
        (digr \l, \j, 0x0459),
        (digr \n, \j, 0x045a),
        (digr \t, \s, 0x045b),
        (digr \k, \j, 0x045c),
        (digr \v, \%, 0x045e),
        (digr \d, \z, 0x045f),
        (digr \Y, \3, 0x0462),
        (digr \y, \3, 0x0463),
        (digr \O, \3, 0x046a),
        (digr \o, \3, 0x046b),
        (digr \F, \3, 0x0472),
        (digr \f, \3, 0x0473),
        (digr \V, \3, 0x0474),
        (digr \v, \3, 0x0475),
        (digr \C, \3, 0x0480),
        (digr \c, \3, 0x0481),
        (digr \G, \3, 0x0490),
        (digr \g, \3, 0x0491),
        (digr \A, \+, 0x05d0),
        (digr \B, \+, 0x05d1),
        (digr \G, \+, 0x05d2),
        (digr \D, \+, 0x05d3),
        (digr \H, \+, 0x05d4),
        (digr \W, \+, 0x05d5),
        (digr \Z, \+, 0x05d6),
        (digr \X, \+, 0x05d7),
        (digr \T, \j, 0x05d8),
        (digr \J, \+, 0x05d9),
        (digr \K, \%, 0x05da),
        (digr \K, \+, 0x05db),
        (digr \L, \+, 0x05dc),
        (digr \M, \%, 0x05dd),
        (digr \M, \+, 0x05de),
        (digr \N, \%, 0x05df),
        (digr \N, \+, 0x05e0),
        (digr \S, \+, 0x05e1),
        (digr \E, \+, 0x05e2),
        (digr \P, \%, 0x05e3),
        (digr \P, \+, 0x05e4),
        (digr \Z, \j, 0x05e5),
        (digr \Z, \J, 0x05e6),
        (digr \Q, \+, 0x05e7),
        (digr \R, \+, 0x05e8),
        (digr \S, \h, 0x05e9),
        (digr \T, \+, 0x05ea),
        (digr \,, \+, 0x060c),
        (digr \;, \+, 0x061b),
        (digr \?, \+, 0x061f),
        (digr \H, \', 0x0621),
        (digr \a, \M, 0x0622),
        (digr \a, \H, 0x0623),
        (digr \w, \H, 0x0624),
        (digr \a, \h, 0x0625),
        (digr \y, \H, 0x0626),
        (digr \a, \+, 0x0627),
        (digr \b, \+, 0x0628),
        (digr \t, \m, 0x0629),
        (digr \t, \+, 0x062a),
        (digr \t, \k, 0x062b),
        (digr \g, \+, 0x062c),
        (digr \h, \k, 0x062d),
        (digr \x, \+, 0x062e),
        (digr \d, \+, 0x062f),
        (digr \d, \k, 0x0630),
        (digr \r, \+, 0x0631),
        (digr \z, \+, 0x0632),
        (digr \s, \+, 0x0633),
        (digr \s, \n, 0x0634),
        (digr \c, \+, 0x0635),
        (digr \d, \d, 0x0636),
        (digr \t, \j, 0x0637),
        (digr \z, \H, 0x0638),
        (digr \e, \+, 0x0639),
        (digr \i, \+, 0x063a),
        (digr \+, \+, 0x0640),
        (digr \f, \+, 0x0641),
        (digr \q, \+, 0x0642),
        (digr \k, \+, 0x0643),
        (digr \l, \+, 0x0644),
        (digr \m, \+, 0x0645),
        (digr \n, \+, 0x0646),
        (digr \h, \+, 0x0647),
        (digr \w, \+, 0x0648),
        (digr \j, \+, 0x0649),
        (digr \y, \+, 0x064a),
        (digr \:, \+, 0x064b),
        (digr \", \+, 0x064c),  ;; """
        (digr \=, \+, 0x064d),
        (digr \/, \+, 0x064e),
        (digr \', \+, 0x064f),
        (digr \1, \+, 0x0650),
        (digr \3, \+, 0x0651),
        (digr \0, \+, 0x0652),
        (digr \a, \S, 0x0670),
        (digr \p, \+, 0x067e),
        (digr \v, \+, 0x06a4),
        (digr \g, \f, 0x06af),
        (digr \0, \a, 0x06f0),
        (digr \1, \a, 0x06f1),
        (digr \2, \a, 0x06f2),
        (digr \3, \a, 0x06f3),
        (digr \4, \a, 0x06f4),
        (digr \5, \a, 0x06f5),
        (digr \6, \a, 0x06f6),
        (digr \7, \a, 0x06f7),
        (digr \8, \a, 0x06f8),
        (digr \9, \a, 0x06f9),
        (digr \B, \., 0x1e02),
        (digr \b, \., 0x1e03),
        (digr \B, \_, 0x1e06),
        (digr \b, \_, 0x1e07),
        (digr \D, \., 0x1e0a),
        (digr \d, \., 0x1e0b),
        (digr \D, \_, 0x1e0e),
        (digr \d, \_, 0x1e0f),
        (digr \D, \,, 0x1e10),
        (digr \d, \,, 0x1e11),
        (digr \F, \., 0x1e1e),
        (digr \f, \., 0x1e1f),
        (digr \G, \-, 0x1e20),
        (digr \g, \-, 0x1e21),
        (digr \H, \., 0x1e22),
        (digr \h, \., 0x1e23),
        (digr \H, \:, 0x1e26),
        (digr \h, \:, 0x1e27),
        (digr \H, \,, 0x1e28),
        (digr \h, \,, 0x1e29),
        (digr \K, \', 0x1e30),
        (digr \k, \', 0x1e31),
        (digr \K, \_, 0x1e34),
        (digr \k, \_, 0x1e35),
        (digr \L, \_, 0x1e3a),
        (digr \l, \_, 0x1e3b),
        (digr \M, \', 0x1e3e),
        (digr \m, \', 0x1e3f),
        (digr \M, \., 0x1e40),
        (digr \m, \., 0x1e41),
        (digr \N, \., 0x1e44),
        (digr \n, \., 0x1e45),
        (digr \N, \_, 0x1e48),
        (digr \n, \_, 0x1e49),
        (digr \P, \', 0x1e54),
        (digr \p, \', 0x1e55),
        (digr \P, \., 0x1e56),
        (digr \p, \., 0x1e57),
        (digr \R, \., 0x1e58),
        (digr \r, \., 0x1e59),
        (digr \R, \_, 0x1e5e),
        (digr \r, \_, 0x1e5f),
        (digr \S, \., 0x1e60),
        (digr \s, \., 0x1e61),
        (digr \T, \., 0x1e6a),
        (digr \t, \., 0x1e6b),
        (digr \T, \_, 0x1e6e),
        (digr \t, \_, 0x1e6f),
        (digr \V, \?, 0x1e7c),
        (digr \v, \?, 0x1e7d),
        (digr \W, \!, 0x1e80),
        (digr \w, \!, 0x1e81),
        (digr \W, \', 0x1e82),
        (digr \w, \', 0x1e83),
        (digr \W, \:, 0x1e84),
        (digr \w, \:, 0x1e85),
        (digr \W, \., 0x1e86),
        (digr \w, \., 0x1e87),
        (digr \X, \., 0x1e8a),
        (digr \x, \., 0x1e8b),
        (digr \X, \:, 0x1e8c),
        (digr \x, \:, 0x1e8d),
        (digr \Y, \., 0x1e8e),
        (digr \y, \., 0x1e8f),
        (digr \Z, \>, 0x1e90),
        (digr \z, \>, 0x1e91),
        (digr \Z, \_, 0x1e94),
        (digr \z, \_, 0x1e95),
        (digr \h, \_, 0x1e96),
        (digr \t, \:, 0x1e97),
        (digr \w, \0, 0x1e98),
        (digr \y, \0, 0x1e99),
        (digr \A, \2, 0x1ea2),
        (digr \a, \2, 0x1ea3),
        (digr \E, \2, 0x1eba),
        (digr \e, \2, 0x1ebb),
        (digr \E, \?, 0x1ebc),
        (digr \e, \?, 0x1ebd),
        (digr \I, \2, 0x1ec8),
        (digr \i, \2, 0x1ec9),
        (digr \O, \2, 0x1ece),
        (digr \o, \2, 0x1ecf),
        (digr \U, \2, 0x1ee6),
        (digr \u, \2, 0x1ee7),
        (digr \Y, \!, 0x1ef2),
        (digr \y, \!, 0x1ef3),
        (digr \Y, \2, 0x1ef6),
        (digr \y, \2, 0x1ef7),
        (digr \Y, \?, 0x1ef8),
        (digr \y, \?, 0x1ef9),
        (digr \;, \', 0x1f00),
        (digr \,, \', 0x1f01),
        (digr \;, \!, 0x1f02),
        (digr \,, \!, 0x1f03),
        (digr \?, \;, 0x1f04),
        (digr \?, \,, 0x1f05),
        (digr \!, \:, 0x1f06),
        (digr \?, \:, 0x1f07),
        (digr \1, \N, 0x2002),
        (digr \1, \M, 0x2003),
        (digr \3, \M, 0x2004),
        (digr \4, \M, 0x2005),
        (digr \6, \M, 0x2006),
        (digr \1, \T, 0x2009),
        (digr \1, \H, 0x200a),
        (digr \-, \1, 0x2010),
        (digr \-, \N, 0x2013),
        (digr \-, \M, 0x2014),
        (digr \-, \3, 0x2015),
        (digr \!, \2, 0x2016),
        (digr \=, \2, 0x2017),
        (digr \', \6, 0x2018),
        (digr \', \9, 0x2019),
        (digr \., \9, 0x201a),
        (digr \9, \', 0x201b),
        (digr \", \6, 0x201c),  ;; """
        (digr \", \9, 0x201d),  ;; """
        (digr \:, \9, 0x201e),
        (digr \9, \", 0x201f),  ;; """
        (digr \/, \-, 0x2020),
        (digr \/, \=, 0x2021),
        (digr \., \., 0x2025),
        (digr \%, \0, 0x2030),
        (digr \1, \', 0x2032),
        (digr \2, \', 0x2033),
        (digr \3, \', 0x2034),
        (digr \1, \", 0x2035),  ;; """
        (digr \2, \", 0x2036),  ;; """
        (digr \3, \", 0x2037),  ;; """
        (digr \C, \a, 0x2038),
        (digr \<, \1, 0x2039),
        (digr \>, \1, 0x203a),
        (digr \:, \X, 0x203b),
        (digr \', \-, 0x203e),
        (digr \/, \f, 0x2044),
        (digr \0, \S, 0x2070),
        (digr \4, \S, 0x2074),
        (digr \5, \S, 0x2075),
        (digr \6, \S, 0x2076),
        (digr \7, \S, 0x2077),
        (digr \8, \S, 0x2078),
        (digr \9, \S, 0x2079),
        (digr \+, \S, 0x207a),
        (digr \-, \S, 0x207b),
        (digr \=, \S, 0x207c),
        (digr \(, \S, 0x207d),
        (digr \), \S, 0x207e),
        (digr \n, \S, 0x207f),
        (digr \0, \s, 0x2080),
        (digr \1, \s, 0x2081),
        (digr \2, \s, 0x2082),
        (digr \3, \s, 0x2083),
        (digr \4, \s, 0x2084),
        (digr \5, \s, 0x2085),
        (digr \6, \s, 0x2086),
        (digr \7, \s, 0x2087),
        (digr \8, \s, 0x2088),
        (digr \9, \s, 0x2089),
        (digr \+, \s, 0x208a),
        (digr \-, \s, 0x208b),
        (digr \=, \s, 0x208c),
        (digr \(, \s, 0x208d),
        (digr \), \s, 0x208e),
        (digr \L, \i, 0x20a4),
        (digr \P, \t, 0x20a7),
        (digr \W, \=, 0x20a9),
        (digr \=, \e, 0x20ac), ;; euro
        (digr \E, \u, 0x20ac), ;; euro
        (digr \=, \R, 0x20bd), ;; rouble
        (digr \=, \P, 0x20bd), ;; rouble
        (digr \o, \C, 0x2103),
        (digr \c, \o, 0x2105),
        (digr \o, \F, 0x2109),
        (digr \N, \0, 0x2116),
        (digr \P, \O, 0x2117),
        (digr \R, \x, 0x211e),
        (digr \S, \M, 0x2120),
        (digr \T, \M, 0x2122),
        (digr \O, \m, 0x2126),
        (digr \A, \O, 0x212b),
        (digr \1, \3, 0x2153),
        (digr \2, \3, 0x2154),
        (digr \1, \5, 0x2155),
        (digr \2, \5, 0x2156),
        (digr \3, \5, 0x2157),
        (digr \4, \5, 0x2158),
        (digr \1, \6, 0x2159),
        (digr \5, \6, 0x215a),
        (digr \1, \8, 0x215b),
        (digr \3, \8, 0x215c),
        (digr \5, \8, 0x215d),
        (digr \7, \8, 0x215e),
        (digr \1, \R, 0x2160),
        (digr \2, \R, 0x2161),
        (digr \3, \R, 0x2162),
        (digr \4, \R, 0x2163),
        (digr \5, \R, 0x2164),
        (digr \6, \R, 0x2165),
        (digr \7, \R, 0x2166),
        (digr \8, \R, 0x2167),
        (digr \9, \R, 0x2168),
        (digr \a, \R, 0x2169),
        (digr \b, \R, 0x216a),
        (digr \c, \R, 0x216b),
        (digr \1, \r, 0x2170),
        (digr \2, \r, 0x2171),
        (digr \3, \r, 0x2172),
        (digr \4, \r, 0x2173),
        (digr \5, \r, 0x2174),
        (digr \6, \r, 0x2175),
        (digr \7, \r, 0x2176),
        (digr \8, \r, 0x2177),
        (digr \9, \r, 0x2178),
        (digr \a, \r, 0x2179),
        (digr \b, \r, 0x217a),
        (digr \c, \r, 0x217b),
        (digr \<, \-, 0x2190),
        (digr \-, \!, 0x2191),
        (digr \-, \>, 0x2192),
        (digr \-, \v, 0x2193),
        (digr \<, \>, 0x2194),
        (digr \U, \D, 0x2195),
        (digr \<, \=, 0x21d0),
        (digr \=, \>, 0x21d2),
        (digr \=, \=, 0x21d4),
        (digr \F, \A, 0x2200),
        (digr \d, \P, 0x2202),
        (digr \T, \E, 0x2203),
        (digr \/, \0, 0x2205),
        (digr \D, \E, 0x2206),
        (digr \N, \B, 0x2207),
        (digr \(, \-, 0x2208),
        (digr \-, \), 0x220b),
        (digr \*, \P, 0x220f),
        (digr \+, \Z, 0x2211),
        (digr \-, \2, 0x2212),
        (digr \-, \+, 0x2213),
        (digr \*, \-, 0x2217),
        (digr \O, \b, 0x2218),
        (digr \S, \b, 0x2219),
        (digr \R, \T, 0x221a),
        (digr \0, \(, 0x221d),
        (digr \0, \0, 0x221e),
        (digr \-, \L, 0x221f),
        (digr \-, \V, 0x2220),
        (digr \P, \P, 0x2225),
        (digr \A, \N, 0x2227),
        (digr \O, \R, 0x2228),
        (digr \(, \U, 0x2229),
        (digr \), \U, 0x222a),
        (digr \I, \n, 0x222b),
        (digr \D, \I, 0x222c),
        (digr \I, \o, 0x222e),
        (digr \., \:, 0x2234),
        (digr \:, \., 0x2235),
        (digr \:, \R, 0x2236),
        (digr \:, \:, 0x2237),
        (digr \?, \1, 0x223c),
        (digr \C, \G, 0x223e),
        (digr \?, \-, 0x2243),
        (digr \?, \=, 0x2245),
        (digr \?, \2, 0x2248),
        (digr \=, \?, 0x224c),
        (digr \H, \I, 0x2253),
        (digr \!, \=, 0x2260),
        (digr \=, \3, 0x2261),
        (digr \=, \<, 0x2264),
        (digr \>, \=, 0x2265),
        (digr \<, \*, 0x226a),
        (digr \*, \>, 0x226b),
        (digr \!, \<, 0x226e),
        (digr \!, \>, 0x226f),
        (digr \(, \C, 0x2282),
        (digr \), \C, 0x2283),
        (digr \(, \_, 0x2286),
        (digr \), \_, 0x2287),
        (digr \0, \., 0x2299),
        (digr \0, \2, 0x229a),
        (digr \-, \T, 0x22a5),
        (digr \., \P, 0x22c5),
        (digr \:, \3, 0x22ee),
        (digr \., \3, 0x22ef),
        (digr \E, \h, 0x2302),
        (digr \<, \7, 0x2308),
        (digr \>, \7, 0x2309),
        (digr \7, \<, 0x230a),
        (digr \7, \>, 0x230b),
        (digr \N, \I, 0x2310),
        (digr \(, \A, 0x2312),
        (digr \T, \R, 0x2315),
        (digr \I, \u, 0x2320),
        (digr \I, \l, 0x2321),
        (digr \<, \/, 0x2329),
        (digr \/, \>, 0x232a),
        (digr \V, \s, 0x2423),
        (digr \1, \h, 0x2440),
        (digr \3, \h, 0x2441),
        (digr \2, \h, 0x2442),
        (digr \4, \h, 0x2443),
        (digr \1, \j, 0x2446),
        (digr \2, \j, 0x2447),
        (digr \3, \j, 0x2448),
        (digr \4, \j, 0x2449),
        (digr \1, \., 0x2488),
        (digr \2, \., 0x2489),
        (digr \3, \., 0x248a),
        (digr \4, \., 0x248b),
        (digr \5, \., 0x248c),
        (digr \6, \., 0x248d),
        (digr \7, \., 0x248e),
        (digr \8, \., 0x248f),
        (digr \9, \., 0x2490),
        (digr \h, \h, 0x2500),
        (digr \H, \H, 0x2501),
        (digr \v, \v, 0x2502),
        (digr \V, \V, 0x2503),
        (digr \3, \-, 0x2504),
        (digr \3, \_, 0x2505),
        (digr \3, \!, 0x2506),
        (digr \3, \/, 0x2507),
        (digr \4, \-, 0x2508),
        (digr \4, \_, 0x2509),
        (digr \4, \!, 0x250a),
        (digr \4, \/, 0x250b),
        (digr \d, \r, 0x250c),
        (digr \d, \R, 0x250d),
        (digr \D, \r, 0x250e),
        (digr \D, \R, 0x250f),
        (digr \d, \l, 0x2510),
        (digr \d, \L, 0x2511),
        (digr \D, \l, 0x2512),
        (digr \L, \D, 0x2513),
        (digr \u, \r, 0x2514),
        (digr \u, \R, 0x2515),
        (digr \U, \r, 0x2516),
        (digr \U, \R, 0x2517),
        (digr \u, \l, 0x2518),
        (digr \u, \L, 0x2519),
        (digr \U, \l, 0x251a),
        (digr \U, \L, 0x251b),
        (digr \v, \r, 0x251c),
        (digr \v, \R, 0x251d),
        (digr \V, \r, 0x2520),
        (digr \V, \R, 0x2523),
        (digr \v, \l, 0x2524),
        (digr \v, \L, 0x2525),
        (digr \V, \l, 0x2528),
        (digr \V, \L, 0x252b),
        (digr \d, \h, 0x252c),
        (digr \d, \H, 0x252f),
        (digr \D, \h, 0x2530),
        (digr \D, \H, 0x2533),
        (digr \u, \h, 0x2534),
        (digr \u, \H, 0x2537),
        (digr \U, \h, 0x2538),
        (digr \U, \H, 0x253b),
        (digr \v, \h, 0x253c),
        (digr \v, \H, 0x253f),
        (digr \V, \h, 0x2542),
        (digr \V, \H, 0x254b),
        (digr \F, \D, 0x2571),
        (digr \B, \D, 0x2572),
        (digr \T, \B, 0x2580),
        (digr \L, \B, 0x2584),
        (digr \F, \B, 0x2588),
        (digr \l, \B, 0x258c),
        (digr \R, \B, 0x2590),
        (digr \., \S, 0x2591),
        (digr \:, \S, 0x2592),
        (digr \?, \S, 0x2593),
        (digr \f, \S, 0x25a0),
        (digr \O, \S, 0x25a1),
        (digr \R, \O, 0x25a2),
        (digr \R, \r, 0x25a3),
        (digr \R, \F, 0x25a4),
        (digr \R, \Y, 0x25a5),
        (digr \R, \H, 0x25a6),
        (digr \R, \Z, 0x25a7),
        (digr \R, \K, 0x25a8),
        (digr \R, \X, 0x25a9),
        (digr \s, \B, 0x25aa),
        (digr \S, \R, 0x25ac),
        (digr \O, \r, 0x25ad),
        (digr \U, \T, 0x25b2),
        (digr \u, \T, 0x25b3),
        (digr \P, \R, 0x25b6),
        (digr \T, \r, 0x25b7),
        (digr \D, \t, 0x25bc),
        (digr \d, \T, 0x25bd),
        (digr \P, \L, 0x25c0),
        (digr \T, \l, 0x25c1),
        (digr \D, \b, 0x25c6),
        (digr \D, \w, 0x25c7),
        (digr \L, \Z, 0x25ca),
        (digr \0, \m, 0x25cb),
        (digr \0, \o, 0x25ce),
        (digr \0, \M, 0x25cf),
        (digr \0, \L, 0x25d0),
        (digr \0, \R, 0x25d1),
        (digr \S, \n, 0x25d8),
        (digr \I, \c, 0x25d9),
        (digr \F, \d, 0x25e2),
        (digr \B, \d, 0x25e3),
        (digr \*, \2, 0x2605),
        (digr \*, \1, 0x2606),
        (digr \<, \H, 0x261c),
        (digr \>, \H, 0x261e),
        (digr \0, \u, 0x263a),
        (digr \0, \U, 0x263b),
        (digr \S, \U, 0x263c),
        (digr \F, \m, 0x2640),
        (digr \M, \l, 0x2642),
        (digr \c, \S, 0x2660),
        (digr \c, \H, 0x2661),
        (digr \c, \D, 0x2662),
        (digr \c, \C, 0x2663),
        (digr \M, \d, 0x2669),
        (digr \M, \8, 0x266a),
        (digr \M, \2, 0x266b),
        (digr \M, \b, 0x266d),
        (digr \M, \x, 0x266e),
        (digr \M, \X, 0x266f),
        (digr \O, \K, 0x2713),
        (digr \X, \X, 0x2717),
        (digr \-, \X, 0x2720),
        (digr \I, \S, 0x3000),
        (digr \,, \_, 0x3001),
        (digr \., \_, 0x3002),
        (digr \+, \", 0x3003),  ;; """
        (digr \+, \_, 0x3004),
        (digr \*, \_, 0x3005),
        (digr \;, \_, 0x3006),
        (digr \0, \_, 0x3007),
        (digr \<, \+, 0x300a),
        (digr \>, \+, 0x300b),
        (digr \<, \', 0x300c),
        (digr \>, \', 0x300d),
        (digr \<, \", 0x300e),  ;; """
        (digr \>, \", 0x300f),  ;; """
        (digr \(, \", 0x3010),  ;; """
        (digr \), \", 0x3011),  ;; """
        (digr \=, \T, 0x3012),
        (digr \=, \_, 0x3013),
        (digr \(, \', 0x3014),
        (digr \), \', 0x3015),
        (digr \(, \I, 0x3016),
        (digr \), \I, 0x3017),
        (digr \-, \?, 0x301c),
        (digr \A, \5, 0x3041),
        (digr \a, \5, 0x3042),
        (digr \I, \5, 0x3043),
        (digr \i, \5, 0x3044),
        (digr \U, \5, 0x3045),
        (digr \u, \5, 0x3046),
        (digr \E, \5, 0x3047),
        (digr \e, \5, 0x3048),
        (digr \O, \5, 0x3049),
        (digr \o, \5, 0x304a),
        (digr \k, \a, 0x304b),
        (digr \g, \a, 0x304c),
        (digr \k, \i, 0x304d),
        (digr \g, \i, 0x304e),
        (digr \k, \u, 0x304f),
        (digr \g, \u, 0x3050),
        (digr \k, \e, 0x3051),
        (digr \g, \e, 0x3052),
        (digr \k, \o, 0x3053),
        (digr \g, \o, 0x3054),
        (digr \s, \a, 0x3055),
        (digr \z, \a, 0x3056),
        (digr \s, \i, 0x3057),
        (digr \z, \i, 0x3058),
        (digr \s, \u, 0x3059),
        (digr \z, \u, 0x305a),
        (digr \s, \e, 0x305b),
        (digr \z, \e, 0x305c),
        (digr \s, \o, 0x305d),
        (digr \z, \o, 0x305e),
        (digr \t, \a, 0x305f),
        (digr \d, \a, 0x3060),
        (digr \t, \i, 0x3061),
        (digr \d, \i, 0x3062),
        (digr \t, \U, 0x3063),
        (digr \t, \u, 0x3064),
        (digr \d, \u, 0x3065),
        (digr \t, \e, 0x3066),
        (digr \d, \e, 0x3067),
        (digr \t, \o, 0x3068),
        (digr \d, \o, 0x3069),
        (digr \n, \a, 0x306a),
        (digr \n, \i, 0x306b),
        (digr \n, \u, 0x306c),
        (digr \n, \e, 0x306d),
        (digr \n, \o, 0x306e),
        (digr \h, \a, 0x306f),
        (digr \b, \a, 0x3070),
        (digr \p, \a, 0x3071),
        (digr \h, \i, 0x3072),
        (digr \b, \i, 0x3073),
        (digr \p, \i, 0x3074),
        (digr \h, \u, 0x3075),
        (digr \b, \u, 0x3076),
        (digr \p, \u, 0x3077),
        (digr \h, \e, 0x3078),
        (digr \b, \e, 0x3079),
        (digr \p, \e, 0x307a),
        (digr \h, \o, 0x307b),
        (digr \b, \o, 0x307c),
        (digr \p, \o, 0x307d),
        (digr \m, \a, 0x307e),
        (digr \m, \i, 0x307f),
        (digr \m, \u, 0x3080),
        (digr \m, \e, 0x3081),
        (digr \m, \o, 0x3082),
        (digr \y, \A, 0x3083),
        (digr \y, \a, 0x3084),
        (digr \y, \U, 0x3085),
        (digr \y, \u, 0x3086),
        (digr \y, \O, 0x3087),
        (digr \y, \o, 0x3088),
        (digr \r, \a, 0x3089),
        (digr \r, \i, 0x308a),
        (digr \r, \u, 0x308b),
        (digr \r, \e, 0x308c),
        (digr \r, \o, 0x308d),
        (digr \w, \A, 0x308e),
        (digr \w, \a, 0x308f),
        (digr \w, \i, 0x3090),
        (digr \w, \e, 0x3091),
        (digr \w, \o, 0x3092),
        (digr \n, \5, 0x3093),
        (digr \v, \u, 0x3094),
        (digr \", \5, 0x309b),  ;; """
        (digr \0, \5, 0x309c),
        (digr \*, \5, 0x309d),
        (digr \+, \5, 0x309e),
        (digr \a, \6, 0x30a1),
        (digr \A, \6, 0x30a2),
        (digr \i, \6, 0x30a3),
        (digr \I, \6, 0x30a4),
        (digr \u, \6, 0x30a5),
        (digr \U, \6, 0x30a6),
        (digr \e, \6, 0x30a7),
        (digr \E, \6, 0x30a8),
        (digr \o, \6, 0x30a9),
        (digr \O, \6, 0x30aa),
        (digr \K, \a, 0x30ab),
        (digr \G, \a, 0x30ac),
        (digr \K, \i, 0x30ad),
        (digr \G, \i, 0x30ae),
        (digr \K, \u, 0x30af),
        (digr \G, \u, 0x30b0),
        (digr \K, \e, 0x30b1),
        (digr \G, \e, 0x30b2),
        (digr \K, \o, 0x30b3),
        (digr \G, \o, 0x30b4),
        (digr \S, \a, 0x30b5),
        (digr \Z, \a, 0x30b6),
        (digr \S, \i, 0x30b7),
        (digr \Z, \i, 0x30b8),
        (digr \S, \u, 0x30b9),
        (digr \Z, \u, 0x30ba),
        (digr \S, \e, 0x30bb),
        (digr \Z, \e, 0x30bc),
        (digr \S, \o, 0x30bd),
        (digr \Z, \o, 0x30be),
        (digr \T, \a, 0x30bf),
        (digr \D, \a, 0x30c0),
        (digr \T, \i, 0x30c1),
        (digr \D, \i, 0x30c2),
        (digr \T, \U, 0x30c3),
        (digr \T, \u, 0x30c4),
        (digr \D, \u, 0x30c5),
        (digr \T, \e, 0x30c6),
        (digr \D, \e, 0x30c7),
        (digr \T, \o, 0x30c8),
        (digr \D, \o, 0x30c9),
        (digr \N, \a, 0x30ca),
        (digr \N, \i, 0x30cb),
        (digr \N, \u, 0x30cc),
        (digr \N, \e, 0x30cd),
        (digr \N, \o, 0x30ce),
        (digr \H, \a, 0x30cf),
        (digr \B, \a, 0x30d0),
        (digr \P, \a, 0x30d1),
        (digr \H, \i, 0x30d2),
        (digr \B, \i, 0x30d3),
        (digr \P, \i, 0x30d4),
        (digr \H, \u, 0x30d5),
        (digr \B, \u, 0x30d6),
        (digr \P, \u, 0x30d7),
        (digr \H, \e, 0x30d8),
        (digr \B, \e, 0x30d9),
        (digr \P, \e, 0x30da),
        (digr \H, \o, 0x30db),
        (digr \B, \o, 0x30dc),
        (digr \P, \o, 0x30dd),
        (digr \M, \a, 0x30de),
        (digr \M, \i, 0x30df),
        (digr \M, \u, 0x30e0),
        (digr \M, \e, 0x30e1),
        (digr \M, \o, 0x30e2),
        (digr \Y, \A, 0x30e3),
        (digr \Y, \a, 0x30e4),
        (digr \Y, \U, 0x30e5),
        (digr \Y, \u, 0x30e6),
        (digr \Y, \O, 0x30e7),
        (digr \Y, \o, 0x30e8),
        (digr \R, \a, 0x30e9),
        (digr \R, \i, 0x30ea),
        (digr \R, \u, 0x30eb),
        (digr \R, \e, 0x30ec),
        (digr \R, \o, 0x30ed),
        (digr \W, \A, 0x30ee),
        (digr \W, \a, 0x30ef),
        (digr \W, \i, 0x30f0),
        (digr \W, \e, 0x30f1),
        (digr \W, \o, 0x30f2),
        (digr \N, \6, 0x30f3),
        (digr \V, \u, 0x30f4),
        (digr \K, \A, 0x30f5),
        (digr \K, \E, 0x30f6),
        (digr \V, \a, 0x30f7),
        (digr \V, \i, 0x30f8),
        (digr \V, \e, 0x30f9),
        (digr \V, \o, 0x30fa),
        (digr \., \6, 0x30fb),
        (digr \-, \6, 0x30fc),
        (digr \*, \6, 0x30fd),
        (digr \+, \6, 0x30fe),
        (digr \b, \4, 0x3105),
        (digr \p, \4, 0x3106),
        (digr \m, \4, 0x3107),
        (digr \f, \4, 0x3108),
        (digr \d, \4, 0x3109),
        (digr \t, \4, 0x310a),
        (digr \n, \4, 0x310b),
        (digr \l, \4, 0x310c),
        (digr \g, \4, 0x310d),
        (digr \k, \4, 0x310e),
        (digr \h, \4, 0x310f),
        (digr \j, \4, 0x3110),
        (digr \q, \4, 0x3111),
        (digr \x, \4, 0x3112),
        (digr \z, \h, 0x3113),
        (digr \c, \h, 0x3114),
        (digr \s, \h, 0x3115),
        (digr \r, \4, 0x3116),
        (digr \z, \4, 0x3117),
        (digr \c, \4, 0x3118),
        (digr \s, \4, 0x3119),
        (digr \a, \4, 0x311a),
        (digr \o, \4, 0x311b),
        (digr \e, \4, 0x311c),
        (digr \a, \i, 0x311e),
        (digr \e, \i, 0x311f),
        (digr \a, \u, 0x3120),
        (digr \o, \u, 0x3121),
        (digr \a, \n, 0x3122),
        (digr \e, \n, 0x3123),
        (digr \a, \N, 0x3124),
        (digr \e, \N, 0x3125),
        (digr \e, \r, 0x3126),
        (digr \i, \4, 0x3127),
        (digr \u, \4, 0x3128),
        (digr \i, \u, 0x3129),
        (digr \v, \4, 0x312a),
        (digr \n, \G, 0x312b),
        (digr \g, \n, 0x312c),
        (digr \1, \c, 0x3220),
        (digr \2, \c, 0x3221),
        (digr \3, \c, 0x3222),
        (digr \4, \c, 0x3223),
        (digr \5, \c, 0x3224),
        (digr \6, \c, 0x3225),
        (digr \7, \c, 0x3226),
        (digr \8, \c, 0x3227),
        (digr \9, \c, 0x3228),
        ;; Code points 0xe000 - 0xefff excluded;
        ;; they have no assigned characters, only used in proposals.
        (digr \f, \f, 0xfb00),
        (digr \f, \i, 0xfb01),
        (digr \f, \l, 0xfb02),
        (digr \f, \t, 0xfb05),
        (digr \s, \t, 0xfb06),

        ;; Vim 5.x compatible digraphs that don't conflict with the above.
        (digr \~, \!, 161),
        (digr \c, \|, 162),
        (digr \$, \$, 163),
        (digr \o, \x, 164),
        (digr \Y, \-, 165),
        (digr \|, \|, 166),
        (digr \c, \O, 169),
        (digr \-, \,, 172),
        (digr \-, \=, 175),
        (digr \~, \o, 176),
        (digr \2, \2, 178),
        (digr \3, \3, 179),
        (digr \p, \p, 182),
        (digr \~, \., 183),
        (digr \1, \1, 185),
        (digr \~, \?, 191),
        (digr \A, \`, 192),
        (digr \A, \^, 194),
        (digr \A, \~, 195),
        (digr \A, \", 196), ;; """
        (digr \A, \@, 197),
        (digr \E, \`, 200),
        (digr \E, \^, 202),
        (digr \E, \", 203), ;; """
        (digr \I, \`, 204),
        (digr \I, \^, 206),
        (digr \I, \", 207), ;; """
        (digr \N, \~, 209),
        (digr \O, \`, 210),
        (digr \O, \^, 212),
        (digr \O, \~, 213),
        (digr \/, \\, 215),
        (digr \U, \`, 217),
        (digr \U, \^, 219),
        (digr \I, \p, 222),
        (digr \a, \`, 224),
        (digr \a, \^, 226),
        (digr \a, \~, 227),
        (digr \a, \", 228), ;; """
        (digr \a, \@, 229),
        (digr \e, \`, 232),
        (digr \e, \^, 234),
        (digr \e, \", 235), ;; """
        (digr \i, \`, 236),
        (digr \i, \^, 238),
        (digr \n, \~, 241),
        (digr \o, \`, 242),
        (digr \o, \^, 244),
        (digr \o, \~, 245),
        (digr \u, \`, 249),
        (digr \u, \^, 251),
        (digr \y, \", 255)  ;; """
    ])

(atom! int backspaced)  ;; character before K_BS
(atom! int lastchar)    ;; last typed character

;; handle digraphs after typing a character

(defn- #_int do-digraph [#_int c]
    (ยง
        (cond (== c -1)                ;; init values
        (do
            (reset! backspaced -1)
        )
        @p_dg
        (do
            (if (<= 0 @backspaced)
                ((ร c =) (getdigraph @backspaced, c, false))
            )
            (reset! backspaced -1)
            (if (and (or (== c K_BS) (== c Ctrl_H)) (<= 0 @lastchar))
                (reset! backspaced @lastchar))
        ))
        (reset! lastchar c)
        c
    ))

;; Get a digraph.  Used after typing CTRL-K on the command line or in normal mode.
;; Returns composed character, or NUL when ESC was used.

(defn- #_int get-digraph [#_boolean cmdline]
    ;; cmdline: true when called from the cmdline
    (ยง
        (ร int c, cc)

        (swap! no_mapping inc)
        (swap! allow_keys inc)
        ((ร c =) (plain-vgetc))
        (swap! no_mapping dec)
        (swap! allow_keys dec)
        (when (!= c ESC)               ;; ESC cancels CTRL-K
            (if (is-special c)      ;; insert special key code
                ((ร RETURN) c)
            )
            (cond cmdline
            (do
                (if (and (== (mb-char2cells c) 1) (zero? @cmdline_star))
                    (putcmdline c, true))
            )
            :else
            (do
                (add-to-showcmd c)
            ))
            (swap! no_mapping inc)
            (swap! allow_keys inc)
            ((ร cc =) (plain-vgetc))
            (swap! no_mapping dec)
            (swap! allow_keys dec)
            (if (!= cc ESC)      ;; ESC cancels CTRL-K
                ((ร RETURN) (getdigraph c, cc, true))
            )
        )
        NUL
    ))

;; Lookup the pair "char1", "char2" in the digraph tables.
;; If no match, return "char2".
;; If "meta_char" is true and "char1" is a space, return "char2" | 0x80.

(defn- #_int getexactdigraph [#_int char1, #_int char2, #_boolean meta_char]
    (ยง
        ((ร int retval =) 0)

        (if (or (is-special char1) (is-special char2))
            ((ร RETURN) char2)
        )

        ((ร digr_C[] dgs =) digraphdefault)
        (dotimes [#_int i (:length dgs)]
            (when (and (== (int (:char1 (... dgs i))) char1) (== (int (:char2 (... dgs i))) char2))
                ((ร retval =) (:result (... dgs i)))
                (ร BREAK)
            )
        )

        (when (zero? retval)            ;; digraph deleted or not found
            (if (and (== char1 (byte \space)) meta_char)  ;; <space> <char> --> meta-char
                ((ร RETURN) (| char2 0x80))
            )

            ((ร RETURN) char2)
        )

        retval
    ))

;; Get digraph.
;; Allow for both char1-char2 and char2-char1

(defn- #_int getdigraph [#_int char1, #_int char2, #_boolean meta_char]
    (ยง
        (ร int retval)

        (when (and (== ((ร retval =) (getexactdigraph char1, char2, meta_char)) char2) (!= char1 char2) (== ((ร retval =) (getexactdigraph char2, char1, meta_char)) char1))
            ((ร RETURN) char2)
        )

        retval
    ))

;; mbyte.c: Code specifically for handling multi-byte characters.
;;
;; "enc_utf8"   Use Unicode characters in UTF-8 encoding.
;;              The cell width on the display needs to be determined from the character value.
;;              Recognizing bytes is easy: 0xxx.xxxx is a single-byte char, 10xx.xxxx is a
;;              trailing byte, 11xx.xxxx is a leading byte of a multi-byte character.
;;              To make things complicated, up to six composing characters are allowed.
;;              These are drawn on top of the first char.
;;              For most editing the sequence of bytes with composing
;;              characters included is considered to be one character.
;;
;; 'encoding' specifies the encoding used in the core.  This is in registers,
;; text manipulation, buffers, etc.  Conversion has to be done when characters
;; in another encoding are received or send:
;;
;;                     clipboard
;;                         ^
;;                         | (2)
;;                         V
;;                 +---------------+
;;            (1)  |               | (3)
;;  keyboard ----->|     core      |-----> display
;;                 |               |
;;                 +---------------+
;;                         ^
;;                         | (4)
;;                         V
;;                       file
;;
;; (1) Typed characters arrive in the current locale.  Conversion is to be
;;     done when 'encoding' is different from 'termencoding'.
;; (2) Text will be made available with the encoding specified with
;;     'encoding'.  If this is not sufficient, system-specific conversion
;;     might be required.
;; (3) For the GUI the correct font must be selected, no conversion done.
;;     Otherwise, conversion is to be done when 'encoding' differs from
;;     'termencoding'.
;; (4) The encoding of the file is specified with 'fileencoding'.  Conversion
;;     is to be done when it's different from 'encoding'.

;; Lookup table to quickly get the length in bytes of a UTF-8 sequence from the first byte.
;; Bytes which are illegal when used as the first byte have a 0.
;; The NUL byte has length 1.

(final byte* #_"[/*256*/]" utf8len_tab_zero
    [
        1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
        1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
        1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
        1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
        2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
        3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,4,4,4,4,4,4,4,4,5,5,5,5,6,6,0,0
    ])

;; Returns the length of a UTF-8 sequence, obtained from the first byte.
;; For an invalid first byte returns zero ? 0 : 1.

(defn- #_int us-byte2len [#_byte b, #_boolean zero]
    (let [#_int len (... utf8len_tab_zero (char_u b))]
        (if (or zero (< 0 len)) len 1)
    ))

;; Return byte length of character that starts with byte "b".
;; Returns 1 for a single-byte character.
;; mb-byte2len() can be used to count a special key as one byte.

(defn- #_int mb-byte2len [#_int b]
    (if (<= 0 b 0xff) (us-byte2len (byte b), false) 1))

;; Get class of pointer:
;;  0 for blank or NUL
;;  1 for punctuation
;;  2 for an (ASCII) word character
;; >2 for other word characters

(defn- #_int us-get-class [#_Bytes p, #_buffer_C buf]
    (let [#_byte b (.at p 0)]
        (cond (!= (us-byte2len b, false) 1) (utf-class (us-ptr2char p)) (or (eos? p) (vim-iswhite b)) 0 (us-iswordb b, buf) 2 :else 1)
    ))

(defn- #_boolean intable [#_int* table, #_int c]
    (ยง
        ;; first quick check for Latin1 etc. characters
        (if (< c (... table 0))
            ((ร RETURN) false)
        )

        ;; binary search in table
        ((ร FOR) (ร ((ร int bot =) (ร 0, top = (table.length) / 2 - 1)) (<= bot top) nil)
            ((ร int mid =) (/ (+ bot top) 2))
            (cond (< (... table (+ (* 2 mid) 1)) c)
            (do
                ((ร bot =) (inc mid))
            )
            (< c (... table (* 2 mid)))
            (do
                ((ร top =) (dec mid))
            )
            :else
            (do
                ((ร RETURN) true)
            ))
        )

        false
    ))

;; Sorted list of non-overlapping intervals of East Asian double width characters,
;; generated with tools/unicode.vim.

(final int* doublewidth
    [
        0x1100, 0x115f,
        0x2329, 0x232a,
        0x2e80, 0x2e99,
        0x2e9b, 0x2ef3,
        0x2f00, 0x2fd5,
        0x2ff0, 0x2ffb,
        0x3000, 0x303e,
        0x3041, 0x3096,
        0x3099, 0x30ff,
        0x3105, 0x312d,
        0x3131, 0x318e,
        0x3190, 0x31ba,
        0x31c0, 0x31e3,
        0x31f0, 0x321e,
        0x3220, 0x3247,
        0x3250, 0x32fe,
        0x3300, 0x4dbf,
        0x4e00, 0xa48c,
        0xa490, 0xa4c6,
        0xa960, 0xa97c,
        0xac00, 0xd7a3,
        0xf900, 0xfaff,
        0xfe10, 0xfe19,
        0xfe30, 0xfe52,
        0xfe54, 0xfe66,
        0xfe68, 0xfe6b,
        0xff01, 0xff60,
        0xffe0, 0xffe6,
        0x1b000, 0x1b001,
        0x1f200, 0x1f202,
        0x1f210, 0x1f23a,
        0x1f240, 0x1f248,
        0x1f250, 0x1f251,
        0x20000, 0x2fffd,
        0x30000, 0x3fffd
    ])

;; Sorted list of non-overlapping intervals of East Asian Ambiguous characters,
;; generated with tools/unicode.vim.

(final int* ambiguous
    [
        0x00a1, 0x00a1,
        0x00a4, 0x00a4,
        0x00a7, 0x00a8,
        0x00aa, 0x00aa,
        0x00ad, 0x00ae,
        0x00b0, 0x00b4,
        0x00b6, 0x00ba,
        0x00bc, 0x00bf,
        0x00c6, 0x00c6,
        0x00d0, 0x00d0,
        0x00d7, 0x00d8,
        0x00de, 0x00e1,
        0x00e6, 0x00e6,
        0x00e8, 0x00ea,
        0x00ec, 0x00ed,
        0x00f0, 0x00f0,
        0x00f2, 0x00f3,
        0x00f7, 0x00fa,
        0x00fc, 0x00fc,
        0x00fe, 0x00fe,
        0x0101, 0x0101,
        0x0111, 0x0111,
        0x0113, 0x0113,
        0x011b, 0x011b,
        0x0126, 0x0127,
        0x012b, 0x012b,
        0x0131, 0x0133,
        0x0138, 0x0138,
        0x013f, 0x0142,
        0x0144, 0x0144,
        0x0148, 0x014b,
        0x014d, 0x014d,
        0x0152, 0x0153,
        0x0166, 0x0167,
        0x016b, 0x016b,
        0x01ce, 0x01ce,
        0x01d0, 0x01d0,
        0x01d2, 0x01d2,
        0x01d4, 0x01d4,
        0x01d6, 0x01d6,
        0x01d8, 0x01d8,
        0x01da, 0x01da,
        0x01dc, 0x01dc,
        0x0251, 0x0251,
        0x0261, 0x0261,
        0x02c4, 0x02c4,
        0x02c7, 0x02c7,
        0x02c9, 0x02cb,
        0x02cd, 0x02cd,
        0x02d0, 0x02d0,
        0x02d8, 0x02db,
        0x02dd, 0x02dd,
        0x02df, 0x02df,
        0x0300, 0x036f,
        0x0391, 0x03a1,
        0x03a3, 0x03a9,
        0x03b1, 0x03c1,
        0x03c3, 0x03c9,
        0x0401, 0x0401,
        0x0410, 0x044f,
        0x0451, 0x0451,
        0x2010, 0x2010,
        0x2013, 0x2016,
        0x2018, 0x2019,
        0x201c, 0x201d,
        0x2020, 0x2022,
        0x2024, 0x2027,
        0x2030, 0x2030,
        0x2032, 0x2033,
        0x2035, 0x2035,
        0x203b, 0x203b,
        0x203e, 0x203e,
        0x2074, 0x2074,
        0x207f, 0x207f,
        0x2081, 0x2084,
        0x20ac, 0x20ac,
        0x2103, 0x2103,
        0x2105, 0x2105,
        0x2109, 0x2109,
        0x2113, 0x2113,
        0x2116, 0x2116,
        0x2121, 0x2122,
        0x2126, 0x2126,
        0x212b, 0x212b,
        0x2153, 0x2154,
        0x215b, 0x215e,
        0x2160, 0x216b,
        0x2170, 0x2179,
        0x2189, 0x2189,
        0x2190, 0x2199,
        0x21b8, 0x21b9,
        0x21d2, 0x21d2,
        0x21d4, 0x21d4,
        0x21e7, 0x21e7,
        0x2200, 0x2200,
        0x2202, 0x2203,
        0x2207, 0x2208,
        0x220b, 0x220b,
        0x220f, 0x220f,
        0x2211, 0x2211,
        0x2215, 0x2215,
        0x221a, 0x221a,
        0x221d, 0x2220,
        0x2223, 0x2223,
        0x2225, 0x2225,
        0x2227, 0x222c,
        0x222e, 0x222e,
        0x2234, 0x2237,
        0x223c, 0x223d,
        0x2248, 0x2248,
        0x224c, 0x224c,
        0x2252, 0x2252,
        0x2260, 0x2261,
        0x2264, 0x2267,
        0x226a, 0x226b,
        0x226e, 0x226f,
        0x2282, 0x2283,
        0x2286, 0x2287,
        0x2295, 0x2295,
        0x2299, 0x2299,
        0x22a5, 0x22a5,
        0x22bf, 0x22bf,
        0x2312, 0x2312,
        0x2460, 0x24e9,
        0x24eb, 0x254b,
        0x2550, 0x2573,
        0x2580, 0x258f,
        0x2592, 0x2595,
        0x25a0, 0x25a1,
        0x25a3, 0x25a9,
        0x25b2, 0x25b3,
        0x25b6, 0x25b7,
        0x25bc, 0x25bd,
        0x25c0, 0x25c1,
        0x25c6, 0x25c8,
        0x25cb, 0x25cb,
        0x25ce, 0x25d1,
        0x25e2, 0x25e5,
        0x25ef, 0x25ef,
        0x2605, 0x2606,
        0x2609, 0x2609,
        0x260e, 0x260f,
        0x2614, 0x2615,
        0x261c, 0x261c,
        0x261e, 0x261e,
        0x2640, 0x2640,
        0x2642, 0x2642,
        0x2660, 0x2661,
        0x2663, 0x2665,
        0x2667, 0x266a,
        0x266c, 0x266d,
        0x266f, 0x266f,
        0x269e, 0x269f,
        0x26be, 0x26bf,
        0x26c4, 0x26cd,
        0x26cf, 0x26e1,
        0x26e3, 0x26e3,
        0x26e8, 0x26ff,
        0x273d, 0x273d,
        0x2757, 0x2757,
        0x2776, 0x277f,
        0x2b55, 0x2b59,
        0x3248, 0x324f,
        0xe000, 0xf8ff,
        0xfe00, 0xfe0f,
        0xfffd, 0xfffd,
        0x1f100, 0x1f10a,
        0x1f110, 0x1f12d,
        0x1f130, 0x1f169,
        0x1f170, 0x1f19a,
        0xe0100, 0xe01ef,
        0xf0000, 0xffffd,
        0x100000, 0x10fffd
    ])

;; For UTF-8 character "c" return 2 for a double-width character, 1 for others.
;; Returns 4 or 6 for an unprintable character.
;; Is only correct for characters >= 0x80.

(defn- #_int utf-char2cells [#_int c]
    (ยง
        (when (<= 0x80 c)
            ;; Characters below 0x100 are influenced by 'isprint' option.
            (cond (< c 0x100)
            (do
                (if (not (vim-isprintc c))
                    ((ร RETURN) 4)                           ;; unprintable, displays <xx>
                )
            )
            :else
            (do
                (if (not (utf-printable c))
                    ((ร RETURN) 6)                           ;; unprintable, displays <xxxx>
                )
                (if (intable doublewidth, c)
                    ((ร RETURN) 2)
                )
            ))

            (if (and (ร hamis) (intable ambiguous, c))
                ((ร RETURN) 2)
            )
        )

        1
    ))

(defn- #_int us-ptr2cells [#_Bytes p]
    (if (<= 0x80 (char_u (.at p 0)))
        ;; Need to convert to a wide character.
        (let [#_int c (us-ptr2char p)] (cond
            ;; An illegal byte is displayed as <xx>.
            (or (== (us-ptr2len p) 1) (== c NUL))
                4
            ;; If the char is ASCII it must be an overlong sequence.
            (< c 0x80)
                (mb-char2cells c)
            :else
                (utf-char2cells c)
        ))
        1
    ))

;; Return the number of cells occupied by string "p".
;; Stop at a NUL character.  When "len" >= 0 stop at character "p[len]".

(defn- #_int us-string2cells [#_Bytes p, #_int len]
    (ยง
        ((ร int cells =) 0)

        ((ร FOR) (ร ((ร int i =) 0) (and (or (< len 0) (< i len)) (non-eos? p i)) ((ร i =) (+ i (us-ptr2len-cc (.plus p i)))))
            ((ร cells =) (+ cells (us-ptr2cells (.plus p i))))
        )

        cells
    ))

(defn- #_int utf-off2cells [#_int off, #_int max_off]
    (if (and (< (inc off) max_off) (== (.at @screenLines (inc off)) 0)) 2 1))

;; Convert a UTF-8 byte sequence to a wide character.
;; If the sequence is illegal or truncated by a NUL the first byte is returned.
;; Does not include composing characters, of course.

(defn- #_int us-ptr2char [#_Bytes p]
    (ยง
        (if (< (char_u (.at p 0)) 0x80)    ;; be quick for ASCII
            ((ร RETURN) (.at p 0))
        )

        ((ร int len =) (us-byte2len (.at p 0), true))
        (when (and (< 1 len) (== (& (char_u (.at p 1)) 0xc0) 0x80))
            (if (== len 2)
                ((ร RETURN) (+ (<< (& (.at p 0) 0x1f) 6) (& (.at p 1) 0x3f)))
            )

            (when (== (& (char_u (.at p 2)) 0xc0) 0x80)
                (if (== len 3)
                    ((ร RETURN) (+ (<< (& (.at p 0) 0x0f) 12) (<< (& (.at p 1) 0x3f) 6) (& (.at p 2) 0x3f)))
                )

                (when (== (& (char_u (.at p 3)) 0xc0) 0x80)
                    (when (== len 4)
                        ((ร RETURN) (+ (<< (& (.at p 0) 0x07) 18) (<< (& (.at p 1) 0x3f) 12) (<< (& (.at p 2) 0x3f) 6) (& (.at p 3) 0x3f)))
                    )

                    (when (== (& (char_u (.at p 4)) 0xc0) 0x80)
                        (when (== len 5)
                            ((ร RETURN) (+ (<< (& (.at p 0) 0x03) 24) (<< (& (.at p 1) 0x3f) 18) (<< (& (.at p 2) 0x3f) 12) (<< (& (.at p 3) 0x3f) 6) (& (.at p 4) 0x3f)))
                        )

                        (when (and (== (& (char_u (.at p 5)) 0xc0) 0x80) (== len 6))
                            ((ร RETURN) (+ (<< (& (.at p 0) 0x01) 30) (<< (& (.at p 1) 0x3f) 24) (<< (& (.at p 2) 0x3f) 18) (<< (& (.at p 3) 0x3f) 12) (<< (& (.at p 4) 0x3f) 6) (& (.at p 5) 0x3f)))
                        )
                    )
                )
            )
        )

        ;; Illegal value, just return the first byte.
        (char_u (.at p 0))
    ))

;; Convert a UTF-8 byte sequence to a wide character.
;; String is assumed to be terminated by NUL or after "n" bytes, whichever comes first.
;; The function is safe in the sense that it never accesses memory beyond the first "n" bytes of "s".
;;
;; On success, returns decoded codepoint,
;; advances "s" to the beginning of next character and decreases "n" accordingly.
;;
;; If end of string was reached, returns 0 and, if "n" > 0, advances "s" past NUL byte.
;;
;; If byte sequence is illegal or incomplete, returns -1 and does not advance "s".

(defn- #_int us-safe-read-char-adv [#_Bytes* s, #_int* n]
    (ยง
        (if (zero? (... n 0))    ;; end of buffer
            ((ร RETURN) 0)
        )

        ((ร int k =) (us-byte2len (.at (... s 0) 0), true))

        (when (== k 1)     ;; ASCII character or NUL
            (ร n[0]--)
            ((ร RETURN) (.at ((ร s[0] =) (.plus (... s 0) 1)) -1))
        )

        (when (<= k (... n 0))
            ;; We have a multibyte sequence and it isn't truncated by buffer
            ;; limits so us-ptr2char() is safe to use.  Or the first byte is
            ;; illegal (k=0), and it's also safe to use us-ptr2char().
            ((ร int c =) (us-ptr2char (... s 0)))

            ;; On failure, us-ptr2char() returns the first byte, so here we
            ;; check equality with the first byte.  The only non-ASCII character
            ;; which equals the first byte of its own UTF-8 representation is
            ;; U+00C3 (UTF-8: 0xC3 0x83), so need to check that special case too.
            ;; It's safe even if n=1, else we would have k=2 > n.
            (when (or (!= c (char_u (.at (... s 0) 0))) (and (== c 0xc3) (== (char_u (.at (... s 0) 1)) 0x83)))
                ;; byte sequence was successfully decoded
                ((ร s[0] =) (.plus (... s 0) k))
                ((ร n[0] =) (- (... n 0) k))
                ((ร RETURN) c)
            )
        )

        ;; byte sequence is incomplete or illegal
        -1
    ))

;; Get character at **pp and advance *pp to the next character.
;; skip: composing characters are skipped!
;; !skip: composing characters are returned as separate characters.

(defn- #_int us-ptr2char-adv [#_Bytes* pp, #_boolean skip]
    (ยง
        ((ร int c =) (us-ptr2char (... pp 0)))
        ((ร pp[0] =) (.plus (... pp 0) (if skip (us-ptr2len-cc (... pp 0)) (us-ptr2len (... pp 0)))))
        c
    ))

;; Convert a UTF-8 byte string to a wide character.
;; Also get up to MAX_MCO composing characters.

(defn- #_int us-ptr2char-cc [#_Bytes p, #_int* pcc]
    ;; pcc: return: composing chars, last one is 0
    (ยง
        ((ร int j =) 0)

        ;; Only accept a composing char when the first char isn't illegal.
        ((ร int i =) (us-ptr2len p))
        (when (or (< 1 i) (< (char_u (.at p 0)) 0x80))
            ((ร FOR) (ร (ร int cc) (and (<= 0x80 (char_u (.at p i))) (utf-iscomposing ((ร cc =) (us-ptr2char (.plus p i))))) ((ร i =) (+ i (us-ptr2len (.plus p i)))))
                ((ร pcc[j++] =) cc)
                (if (== j MAX_MCO)
                    (ร BREAK)
                )
            )
        )

        (if (< j MAX_MCO)    ;; last composing char must be 0
            ((ร pcc[j] =) 0)
        )

        (us-ptr2char p)
    ))

;; Convert a UTF-8 byte string to a wide character.
;; Also get up to MAX_MCO composing characters.
;; Use no more than p[maxlen].

(defn- #_int us-ptr2char-cc-len [#_Bytes p, #_int* pcc, #_int maxlen]
    ;; pcc: return: composing chars, last one is 0
    (ยง
        ((ร int j =) 0)

        ;; Only accept a composing char when the first char isn't illegal.
        ((ร int i =) (us-ptr2len-len p, maxlen))
        (when (or (< 1 i) (< (char_u (.at p 0)) 0x80))
            ((ร FOR) (ร (ร int cc) (and (< i maxlen) (<= 0x80 (char_u (.at p i))) (utf-iscomposing ((ร cc =) (us-ptr2char (.plus p i))))) ((ร i =) (+ i (us-ptr2len-len (.plus p i), (- maxlen i)))))
                ((ร pcc[j++] =) cc)
                (if (== j MAX_MCO)
                    (ร BREAK)
                )
            )
        )

        (if (< j MAX_MCO)    ;; last composing char must be 0
            ((ร pcc[j] =) 0)
        )

        (us-ptr2char p)
    ))

;; Convert the character at screen position "off" to a sequence of bytes.
;; Includes the composing characters.
;; "buf" must at least have the length MB_MAXBYTES + 1.
;; Only to be used when screenLinesUC[off] != 0.
;; Returns the produced number of bytes.

(defn- #_int utfc-char2bytes [#_int off, #_Bytes buf]
    (ยง
        ((ร int len =) (utf-char2bytes (... @screenLinesUC off), buf))
        (dotimes [#_int i @screen_mco]
            (if (zero? (... (... @screenLinesC i) off))
                (ร BREAK)
            )
            ((ร len =) (+ len (utf-char2bytes (... (... @screenLinesC i) off), (.plus buf len))))
        )
        len
    ))

;; Get the length of a UTF-8 byte sequence, not including any following composing characters.
;; Returns 0 for "".
;; Returns 1 for an illegal byte sequence.

(defn- #_int us-ptr2len [#_Bytes p]
    (ยง
        (if (eos? p)
            ((ร RETURN) 0)
        )

        ((ร int len =) (us-byte2len (.at p 0), false))
        ((ร FOR) (ร ((ร int i =) 1) (< i len) (ร i++))
            (if (!= (& (char_u (.at p i)) 0xc0) 0x80)
                ((ร RETURN) 1)
            )
        )

        len
    ))

;; Get the length of UTF-8 byte sequence "p[size]".
;; Does not include any following composing characters.
;; Returns 1 for "".
;; Returns 1 for an illegal byte sequence (also in incomplete byte seq.).
;; Returns number > "size" for an incomplete byte sequence.
;; Never returns zero.

(defn- #_int us-ptr2len-len [#_Bytes p, #_int size]
    (ยง
        ((ร int len =) (us-byte2len (.at p 0), false))
        (if (== len 1)
            ((ร RETURN) 1)       ;; NUL, ASCII or illegal lead byte
        )

        ((ร int m =) (if (< size len) size len))  ;; incomplete byte sequence?
        ((ร FOR) (ร ((ร int i =) 1) (< i m) (ร i++))
            (if (!= (& (char_u (.at p i)) 0xc0) 0x80)
                ((ร RETURN) 1)
            )
        )

        len
    ))

;; Return the number of bytes the UTF-8 encoding of the character at "p" takes.
;; This includes following composing characters.

(defn- #_int us-ptr2len-cc [#_Bytes p]
    (ยง
        (if (eos? p)
            ((ร RETURN) 0)
        )
        (if (and (< (char_u (.at p 0)) 0x80) (< (char_u (.at p 1)) 0x80))     ;; be quick for ASCII
            ((ร RETURN) 1)
        )

        ;; Skip over first UTF-8 char, stopping at a NUL byte.
        ((ร int len =) (us-ptr2len p))

        ;; Check for illegal byte.
        (if (and (== len 1) (<= 0x80 (char_u (.at p 0))))
            ((ร RETURN) 1)
        )

        ;; Check for composing characters.  We can handle only the first six,
        ;; but skip all of them (otherwise the cursor would get stuck).

        (while (and (<= 0x80 (char_u (.at p len))) (utf-iscomposing (us-ptr2char (.plus p len))))
            ;; Skip over composing char.
            ((ร len =) (+ len (us-ptr2len (.plus p len))))
        )

        len
    ))

;; Return the number of bytes the UTF-8 encoding of the character at "p[size]" takes.
;; This includes following composing characters.
;; Returns 0 for an empty string.
;; Returns 1 for an illegal char or an incomplete byte sequence.

(defn- #_int us-ptr2len-cc-len [#_Bytes p, #_int size]
    (ยง
        (if (or (< size 1) (eos? p))
            ((ร RETURN) 0)
        )
        (if (and (< (char_u (.at p 0)) 0x80) (or (== size 1) (< (char_u (.at p 1)) 0x80)))    ;; be quick for ASCII
            ((ร RETURN) 1)
        )

        ;; Skip over first UTF-8 char, stopping at a NUL byte.
        ((ร int len =) (us-ptr2len-len p, size))

        ;; Check for illegal byte and incomplete byte sequence.
        (if (or (and (== len 1) (<= 0x80 (char_u (.at p 0)))) (< size len))
            ((ร RETURN) 1)
        )

        ;; Check for composing characters.  We can handle only the first six,
        ;; but skip all of them (otherwise the cursor would get stuck).

        (while (and (< len size) (<= 0x80 (char_u (.at p len))))
            ;; Next character length should not go beyond size to ensure
            ;; that UTF_COMPOSINGLIKE(...) does not read beyond size.

            ((ร int len_next_char =) (us-ptr2len-len (.plus p len), (- size len)))
            (if (< (- size len) len_next_char)
                (ร BREAK)
            )

            (if (not (utf-iscomposing (us-ptr2char (.plus p len))))
                (ร BREAK)
            )

            ;; Skip over composing char.
            ((ร len =) (+ len len_next_char))
        )

        len
    ))

;; Return the number of bytes the UTF-8 encoding of character "c" takes.
;; This does not include composing characters.

(defn- #_int utf-char2len [#_int c]
    (ยง
        (if (< c 0x80)
            ((ร RETURN) 1)
        )
        (if (< c 0x800)
            ((ร RETURN) 2)
        )
        (if (< c 0x10000)
            ((ร RETURN) 3)
        )
        (if (< c 0x200000)
            ((ร RETURN) 4)
        )
        (if (< c 0x4000000)
            ((ร RETURN) 5)
        )

        6
    ))

;; Convert Unicode character "c" to UTF-8 string in "buf[]".
;; Returns the number of bytes.
;; This does not include composing characters.

(defn- #_int utf-char2bytes [#_int c, #_Bytes buf]
    (ยง
        (when (< c 0x80)               ;; 7 bits
            (.be buf 0, c)
            ((ร RETURN) 1)
        )

        (when (< c 0x800)              ;; 11 bits
            (.be buf 0, (+ 0xc0 (>>> c 6)))
            (.be buf 1, (+ 0x80 (& c 0x3f)))
            ((ร RETURN) 2)
        )

        (when (< c 0x10000)            ;; 16 bits
            (.be buf 0, (+ 0xe0 (>>> c 12)))
            (.be buf 1, (+ 0x80 (& (>>> c 6) 0x3f)))
            (.be buf 2, (+ 0x80 (& c 0x3f)))
            ((ร RETURN) 3)
        )

        (when (< c 0x200000)           ;; 21 bits
            (.be buf 0, (+ 0xf0 (>>> c 18)))
            (.be buf 1, (+ 0x80 (& (>>> c 12) 0x3f)))
            (.be buf 2, (+ 0x80 (& (>>> c 6) 0x3f)))
            (.be buf 3, (+ 0x80 (& c 0x3f)))
            ((ร RETURN) 4)
        )

        (when (< c 0x4000000)          ;; 26 bits
            (.be buf 0, (+ 0xf8 (>>> c 24)))
            (.be buf 1, (+ 0x80 (& (>>> c 18) 0x3f)))
            (.be buf 2, (+ 0x80 (& (>>> c 12) 0x3f)))
            (.be buf 3, (+ 0x80 (& (>>> c 6) 0x3f)))
            (.be buf 4, (+ 0x80 (& c 0x3f)))
            ((ร RETURN) 5)
        )

                                    ;; 31 bits
;       {
            (.be buf 0, (+ 0xfc (>>> c 30)))
            (.be buf 1, (+ 0x80 (& (>>> c 24) 0x3f)))
            (.be buf 2, (+ 0x80 (& (>>> c 18) 0x3f)))
            (.be buf 3, (+ 0x80 (& (>>> c 12) 0x3f)))
            (.be buf 4, (+ 0x80 (& (>>> c 6) 0x3f)))
            (.be buf 5, (+ 0x80 (& c 0x3f)))
            ((ร RETURN) 6)
;       }
    ))

;; Sorted list of non-overlapping intervals.
;; Generated by tools/unicode.vim.

(final int* combining
    [
        0x0300, 0x036f,
        0x0483, 0x0489,
        0x0591, 0x05bd,
        0x05bf, 0x05bf,
        0x05c1, 0x05c2,
        0x05c4, 0x05c5,
        0x05c7, 0x05c7,
        0x0610, 0x061a,
        0x064b, 0x065f,
        0x0670, 0x0670,
        0x06d6, 0x06dc,
        0x06df, 0x06e4,
        0x06e7, 0x06e8,
        0x06ea, 0x06ed,
        0x0711, 0x0711,
        0x0730, 0x074a,
        0x07a6, 0x07b0,
        0x07eb, 0x07f3,
        0x0816, 0x0819,
        0x081b, 0x0823,
        0x0825, 0x0827,
        0x0829, 0x082d,
        0x0859, 0x085b,
        0x08e4, 0x0903,
        0x093a, 0x093c,
        0x093e, 0x094f,
        0x0951, 0x0957,
        0x0962, 0x0963,
        0x0981, 0x0983,
        0x09bc, 0x09bc,
        0x09be, 0x09c4,
        0x09c7, 0x09c8,
        0x09cb, 0x09cd,
        0x09d7, 0x09d7,
        0x09e2, 0x09e3,
        0x0a01, 0x0a03,
        0x0a3c, 0x0a3c,
        0x0a3e, 0x0a42,
        0x0a47, 0x0a48,
        0x0a4b, 0x0a4d,
        0x0a51, 0x0a51,
        0x0a70, 0x0a71,
        0x0a75, 0x0a75,
        0x0a81, 0x0a83,
        0x0abc, 0x0abc,
        0x0abe, 0x0ac5,
        0x0ac7, 0x0ac9,
        0x0acb, 0x0acd,
        0x0ae2, 0x0ae3,
        0x0b01, 0x0b03,
        0x0b3c, 0x0b3c,
        0x0b3e, 0x0b44,
        0x0b47, 0x0b48,
        0x0b4b, 0x0b4d,
        0x0b56, 0x0b57,
        0x0b62, 0x0b63,
        0x0b82, 0x0b82,
        0x0bbe, 0x0bc2,
        0x0bc6, 0x0bc8,
        0x0bca, 0x0bcd,
        0x0bd7, 0x0bd7,
        0x0c00, 0x0c03,
        0x0c3e, 0x0c44,
        0x0c46, 0x0c48,
        0x0c4a, 0x0c4d,
        0x0c55, 0x0c56,
        0x0c62, 0x0c63,
        0x0c81, 0x0c83,
        0x0cbc, 0x0cbc,
        0x0cbe, 0x0cc4,
        0x0cc6, 0x0cc8,
        0x0cca, 0x0ccd,
        0x0cd5, 0x0cd6,
        0x0ce2, 0x0ce3,
        0x0d01, 0x0d03,
        0x0d3e, 0x0d44,
        0x0d46, 0x0d48,
        0x0d4a, 0x0d4d,
        0x0d57, 0x0d57,
        0x0d62, 0x0d63,
        0x0d82, 0x0d83,
        0x0dca, 0x0dca,
        0x0dcf, 0x0dd4,
        0x0dd6, 0x0dd6,
        0x0dd8, 0x0ddf,
        0x0df2, 0x0df3,
        0x0e31, 0x0e31,
        0x0e34, 0x0e3a,
        0x0e47, 0x0e4e,
        0x0eb1, 0x0eb1,
        0x0eb4, 0x0eb9,
        0x0ebb, 0x0ebc,
        0x0ec8, 0x0ecd,
        0x0f18, 0x0f19,
        0x0f35, 0x0f35,
        0x0f37, 0x0f37,
        0x0f39, 0x0f39,
        0x0f3e, 0x0f3f,
        0x0f71, 0x0f84,
        0x0f86, 0x0f87,
        0x0f8d, 0x0f97,
        0x0f99, 0x0fbc,
        0x0fc6, 0x0fc6,
        0x102b, 0x103e,
        0x1056, 0x1059,
        0x105e, 0x1060,
        0x1062, 0x1064,
        0x1067, 0x106d,
        0x1071, 0x1074,
        0x1082, 0x108d,
        0x108f, 0x108f,
        0x109a, 0x109d,
        0x135d, 0x135f,
        0x1712, 0x1714,
        0x1732, 0x1734,
        0x1752, 0x1753,
        0x1772, 0x1773,
        0x17b4, 0x17d3,
        0x17dd, 0x17dd,
        0x180b, 0x180d,
        0x18a9, 0x18a9,
        0x1920, 0x192b,
        0x1930, 0x193b,
        0x19b0, 0x19c0,
        0x19c8, 0x19c9,
        0x1a17, 0x1a1b,
        0x1a55, 0x1a5e,
        0x1a60, 0x1a7c,
        0x1a7f, 0x1a7f,
        0x1ab0, 0x1abe,
        0x1b00, 0x1b04,
        0x1b34, 0x1b44,
        0x1b6b, 0x1b73,
        0x1b80, 0x1b82,
        0x1ba1, 0x1bad,
        0x1be6, 0x1bf3,
        0x1c24, 0x1c37,
        0x1cd0, 0x1cd2,
        0x1cd4, 0x1ce8,
        0x1ced, 0x1ced,
        0x1cf2, 0x1cf4,
        0x1cf8, 0x1cf9,
        0x1dc0, 0x1df5,
        0x1dfc, 0x1dff,
        0x20d0, 0x20f0,
        0x2cef, 0x2cf1,
        0x2d7f, 0x2d7f,
        0x2de0, 0x2dff,
        0x302a, 0x302f,
        0x3099, 0x309a,
        0xa66f, 0xa672,
        0xa674, 0xa67d,
        0xa69f, 0xa69f,
        0xa6f0, 0xa6f1,
        0xa802, 0xa802,
        0xa806, 0xa806,
        0xa80b, 0xa80b,
        0xa823, 0xa827,
        0xa880, 0xa881,
        0xa8b4, 0xa8c4,
        0xa8e0, 0xa8f1,
        0xa926, 0xa92d,
        0xa947, 0xa953,
        0xa980, 0xa983,
        0xa9b3, 0xa9c0,
        0xa9e5, 0xa9e5,
        0xaa29, 0xaa36,
        0xaa43, 0xaa43,
        0xaa4c, 0xaa4d,
        0xaa7b, 0xaa7d,
        0xaab0, 0xaab0,
        0xaab2, 0xaab4,
        0xaab7, 0xaab8,
        0xaabe, 0xaabf,
        0xaac1, 0xaac1,
        0xaaeb, 0xaaef,
        0xaaf5, 0xaaf6,
        0xabe3, 0xabea,
        0xabec, 0xabed,
        0xfb1e, 0xfb1e,
        0xfe00, 0xfe0f,
        0xfe20, 0xfe2d,
        0x101fd, 0x101fd,
        0x102e0, 0x102e0,
        0x10376, 0x1037a,
        0x10a01, 0x10a03,
        0x10a05, 0x10a06,
        0x10a0c, 0x10a0f,
        0x10a38, 0x10a3a,
        0x10a3f, 0x10a3f,
        0x10ae5, 0x10ae6,
        0x11000, 0x11002,
        0x11038, 0x11046,
        0x1107f, 0x11082,
        0x110b0, 0x110ba,
        0x11100, 0x11102,
        0x11127, 0x11134,
        0x11173, 0x11173,
        0x11180, 0x11182,
        0x111b3, 0x111c0,
        0x1122c, 0x11237,
        0x112df, 0x112ea,
        0x11301, 0x11303,
        0x1133c, 0x1133c,
        0x1133e, 0x11344,
        0x11347, 0x11348,
        0x1134b, 0x1134d,
        0x11357, 0x11357,
        0x11362, 0x11363,
        0x11366, 0x1136c,
        0x11370, 0x11374,
        0x114b0, 0x114c3,
        0x115af, 0x115b5,
        0x115b8, 0x115c0,
        0x11630, 0x11640,
        0x116ab, 0x116b7,
        0x16af0, 0x16af4,
        0x16b30, 0x16b36,
        0x16f51, 0x16f7e,
        0x16f8f, 0x16f92,
        0x1bc9d, 0x1bc9e,
        0x1d165, 0x1d169,
        0x1d16d, 0x1d172,
        0x1d17b, 0x1d182,
        0x1d185, 0x1d18b,
        0x1d1aa, 0x1d1ad,
        0x1d242, 0x1d244,
        0x1e8d0, 0x1e8d6,
        0xe0100, 0xe01ef
    ])

;; Return true if "c" is a composing UTF-8 character.
;; This means it will be drawn on top of the preceding character.

(defn- #_boolean utf-iscomposing [#_int c]
    (intable combining, c))

;; Sorted list of non-overlapping intervals.
;; 0xd800-0xdfff is reserved for UTF-16, actually illegal.

(final int* nonprint
    [
        0x070f, 0x070f,
        0x180b, 0x180e,
        0x200b, 0x200f,
        0x202a, 0x202e,
        0x206a, 0x206f,
        0xd800, 0xdfff,
        0xfeff, 0xfeff,
        0xfff9, 0xfffb,
        0xfffe, 0xffff
    ])

;; Return true for characters that can be displayed in a normal way.
;; Only for characters of 0x100 and above!

(defn- #_boolean utf-printable [#_int c]
    (not (intable nonprint, c)))

;; sorted list of non-overlapping intervals
(final int* classes
    [
        0x037e, 0x037e, 1,          ;; Greek question mark
        0x0387, 0x0387, 1,          ;; Greek ano teleia
        0x055a, 0x055f, 1,          ;; Armenian punctuation
        0x0589, 0x0589, 1,          ;; Armenian full stop
        0x05be, 0x05be, 1,
        0x05c0, 0x05c0, 1,
        0x05c3, 0x05c3, 1,
        0x05f3, 0x05f4, 1,
        0x060c, 0x060c, 1,
        0x061b, 0x061b, 1,
        0x061f, 0x061f, 1,
        0x066a, 0x066d, 1,
        0x06d4, 0x06d4, 1,
        0x0700, 0x070d, 1,          ;; Syriac punctuation
        0x0964, 0x0965, 1,
        0x0970, 0x0970, 1,
        0x0df4, 0x0df4, 1,
        0x0e4f, 0x0e4f, 1,
        0x0e5a, 0x0e5b, 1,
        0x0f04, 0x0f12, 1,
        0x0f3a, 0x0f3d, 1,
        0x0f85, 0x0f85, 1,
        0x104a, 0x104f, 1,          ;; Myanmar punctuation
        0x10fb, 0x10fb, 1,          ;; Georgian punctuation
        0x1361, 0x1368, 1,          ;; Ethiopic punctuation
        0x166d, 0x166e, 1,          ;; Canadian Syl. punctuation
        0x1680, 0x1680, 0,
        0x169b, 0x169c, 1,
        0x16eb, 0x16ed, 1,
        0x1735, 0x1736, 1,
        0x17d4, 0x17dc, 1,          ;; Khmer punctuation
        0x1800, 0x180a, 1,          ;; Mongolian punctuation
        0x2000, 0x200b, 0,          ;; spaces
        0x200c, 0x2027, 1,          ;; punctuation and symbols
        0x2028, 0x2029, 0,
        0x202a, 0x202e, 1,          ;; punctuation and symbols
        0x202f, 0x202f, 0,
        0x2030, 0x205e, 1,          ;; punctuation and symbols
        0x205f, 0x205f, 0,
        0x2060, 0x27ff, 1,          ;; punctuation and symbols
        0x2070, 0x207f, 0x2070,     ;; superscript
        0x2080, 0x2094, 0x2080,     ;; subscript
        0x20a0, 0x27ff, 1,          ;; all kinds of symbols
        0x2800, 0x28ff, 0x2800,     ;; braille
        0x2900, 0x2998, 1,          ;; arrows, brackets, etc.
        0x29d8, 0x29db, 1,
        0x29fc, 0x29fd, 1,
        0x2e00, 0x2e7f, 1,          ;; supplemental punctuation
        0x3000, 0x3000, 0,          ;; ideographic space
        0x3001, 0x3020, 1,          ;; ideographic punctuation
        0x3030, 0x3030, 1,
        0x303d, 0x303d, 1,
        0x3040, 0x309f, 0x3040,     ;; Hiragana
        0x30a0, 0x30ff, 0x30a0,     ;; Katakana
        0x3300, 0x9fff, 0x4e00,     ;; CJK Ideographs
        0xac00, 0xd7a3, 0xac00,     ;; Hangul Syllables
        0xf900, 0xfaff, 0x4e00,     ;; CJK Ideographs
        0xfd3e, 0xfd3f, 1,
        0xfe30, 0xfe6b, 1,          ;; punctuation forms
        0xff00, 0xff0f, 1,          ;; half/fullwidth ASCII
        0xff1a, 0xff20, 1,          ;; half/fullwidth ASCII
        0xff3b, 0xff40, 1,          ;; half/fullwidth ASCII
        0xff5b, 0xff65, 1,          ;; half/fullwidth ASCII
        0x20000, 0x2a6df, 0x4e00,   ;; CJK Ideographs
        0x2a700, 0x2b73f, 0x4e00,   ;; CJK Ideographs
        0x2b740, 0x2b81f, 0x4e00,   ;; CJK Ideographs
        0x2f800, 0x2fa1f, 0x4e00    ;; CJK Ideographs
    ])

;; Get class of a Unicode character.
;;  0: white space
;;  1: punctuation
;;  2 or bigger: some class of word character.

(defn- #_int utf-class [#_int c]
    (ยง
        ;; First quick check for Latin1 characters, use 'iskeyword'.
        (when (< c 0x100)
            (if (or (== c (byte \space)) (== c TAB) (== c NUL) (== c 0xa0))
                ((ร RETURN) 0)       ;; blank
            )
            (if (vim-iswordc c, @curbuf)
                ((ร RETURN) 2)       ;; word character
            )

            ((ร RETURN) 1)           ;; punctuation
        )

        ;; binary search in table
        ((ร FOR) (ร ((ร int bot =) (ร 0, top = (classes.length) / 3 - 1)) (<= bot top) nil)
            ((ร int mid =) (/ (+ bot top) 2))
            (cond (< (... classes (+ (* 3 mid) 1)) c)
            (do
                ((ร bot =) (inc mid))
            )
            (< c (... classes (* 3 mid)))
            (do
                ((ร top =) (dec mid))
            )
            :else
            (do
                ((ร RETURN) (... classes (+ (* 3 mid) 2)))
            ))
        )

        ;; most other characters are "word" characters
        2
    ))

;; Code for Unicode case-dependent operations.  Based on notes in
;; http://www.unicode.org/Public/UNIDATA/CaseFolding.txt
;; This code uses simple case folding, not full case folding.
;; Last updated for Unicode 5.2.

;; Generic conversion function for case operations.
;; Return the converted equivalent of "c", which is a UCS-4 character.
;; Use the given conversion "table".
;; Uses binary search on "table".

(defn- #_int utf-convert [#_int c, #_int* table]
    (ยง
        ((ร int start =) 0)
        ((ร int entries =) (/ (:length table) 4))

        ((ร FOR) (ร ((ร int end =) entries) (< start end) nil)
            ;; need to search further
            ((ร int mid =) (/ (+ start end) 2))
            (if (< (... table (+ (* 4 mid) 1)) c)
                ((ร start =) (inc mid))
                ((ร end =) mid)
            )
        )

        (when (< start entries)
            ((ร int i =) (* 4 start))
            (if (and (<= (... table i) c) (<= c (... table (inc i))) (zero? (% (- c (... table i)) (... table (+ i 2)))))
                ((ร RETURN) (+ c (... table (+ i 3))))
            )
        )

        c
    ))

;; The following tables are built by tools/unicode.vim.
;; They must be in numeric order, because we use binary search.
;; An entry such as {0x41,0x5a,1,32} means that Unicode characters in the
;; range from 0x41 to 0x5a inclusive, stepping by 1, are changed to
;; folded/upper/lower by adding 32.

(final int* foldCase
    [
        0x41, 0x5a, 1, 32,
        0xb5, 0xb5,-1, 775,
        0xc0, 0xd6, 1, 32,
        0xd8, 0xde, 1, 32,
        0x100, 0x12e, 2, 1,
        0x132, 0x136, 2, 1,
        0x139, 0x147, 2, 1,
        0x14a, 0x176, 2, 1,
        0x178, 0x178,-1,-121,
        0x179, 0x17d, 2, 1,
        0x17f, 0x17f,-1,-268,
        0x181, 0x181,-1, 210,
        0x182, 0x184, 2, 1,
        0x186, 0x186,-1, 206,
        0x187, 0x187,-1, 1,
        0x189, 0x18a, 1, 205,
        0x18b, 0x18b,-1, 1,
        0x18e, 0x18e,-1, 79,
        0x18f, 0x18f,-1, 202,
        0x190, 0x190,-1, 203,
        0x191, 0x191,-1, 1,
        0x193, 0x193,-1, 205,
        0x194, 0x194,-1, 207,
        0x196, 0x196,-1, 211,
        0x197, 0x197,-1, 209,
        0x198, 0x198,-1, 1,
        0x19c, 0x19c,-1, 211,
        0x19d, 0x19d,-1, 213,
        0x19f, 0x19f,-1, 214,
        0x1a0, 0x1a4, 2, 1,
        0x1a6, 0x1a6,-1, 218,
        0x1a7, 0x1a7,-1, 1,
        0x1a9, 0x1a9,-1, 218,
        0x1ac, 0x1ac,-1, 1,
        0x1ae, 0x1ae,-1, 218,
        0x1af, 0x1af,-1, 1,
        0x1b1, 0x1b2, 1, 217,
        0x1b3, 0x1b5, 2, 1,
        0x1b7, 0x1b7,-1, 219,
        0x1b8, 0x1bc, 4, 1,
        0x1c4, 0x1c4,-1, 2,
        0x1c5, 0x1c5,-1, 1,
        0x1c7, 0x1c7,-1, 2,
        0x1c8, 0x1c8,-1, 1,
        0x1ca, 0x1ca,-1, 2,
        0x1cb, 0x1db, 2, 1,
        0x1de, 0x1ee, 2, 1,
        0x1f1, 0x1f1,-1, 2,
        0x1f2, 0x1f4, 2, 1,
        0x1f6, 0x1f6,-1,-97,
        0x1f7, 0x1f7,-1,-56,
        0x1f8, 0x21e, 2, 1,
        0x220, 0x220,-1,-130,
        0x222, 0x232, 2, 1,
        0x23a, 0x23a,-1, 10795,
        0x23b, 0x23b,-1, 1,
        0x23d, 0x23d,-1,-163,
        0x23e, 0x23e,-1, 10792,
        0x241, 0x241,-1, 1,
        0x243, 0x243,-1,-195,
        0x244, 0x244,-1, 69,
        0x245, 0x245,-1, 71,
        0x246, 0x24e, 2, 1,
        0x345, 0x345,-1, 116,
        0x370, 0x372, 2, 1,
        0x376, 0x376,-1, 1,
        0x37f, 0x37f,-1, 116,
        0x386, 0x386,-1, 38,
        0x388, 0x38a, 1, 37,
        0x38c, 0x38c,-1, 64,
        0x38e, 0x38f, 1, 63,
        0x391, 0x3a1, 1, 32,
        0x3a3, 0x3ab, 1, 32,
        0x3c2, 0x3c2,-1, 1,
        0x3cf, 0x3cf,-1, 8,
        0x3d0, 0x3d0,-1,-30,
        0x3d1, 0x3d1,-1,-25,
        0x3d5, 0x3d5,-1,-15,
        0x3d6, 0x3d6,-1,-22,
        0x3d8, 0x3ee, 2, 1,
        0x3f0, 0x3f0,-1,-54,
        0x3f1, 0x3f1,-1,-48,
        0x3f4, 0x3f4,-1,-60,
        0x3f5, 0x3f5,-1,-64,
        0x3f7, 0x3f7,-1, 1,
        0x3f9, 0x3f9,-1,-7,
        0x3fa, 0x3fa,-1, 1,
        0x3fd, 0x3ff, 1,-130,
        0x400, 0x40f, 1, 80,
        0x410, 0x42f, 1, 32,
        0x460, 0x480, 2, 1,
        0x48a, 0x4be, 2, 1,
        0x4c0, 0x4c0,-1, 15,
        0x4c1, 0x4cd, 2, 1,
        0x4d0, 0x52e, 2, 1,
        0x531, 0x556, 1, 48,
        0x10a0, 0x10c5, 1, 7264,
        0x10c7, 0x10cd, 6, 7264,
        0x1e00, 0x1e94, 2, 1,
        0x1e9b, 0x1e9b,-1,-58,
        0x1e9e, 0x1e9e,-1,-7615,
        0x1ea0, 0x1efe, 2, 1,
        0x1f08, 0x1f0f, 1,-8,
        0x1f18, 0x1f1d, 1,-8,
        0x1f28, 0x1f2f, 1,-8,
        0x1f38, 0x1f3f, 1,-8,
        0x1f48, 0x1f4d, 1,-8,
        0x1f59, 0x1f5f, 2,-8,
        0x1f68, 0x1f6f, 1,-8,
        0x1f88, 0x1f8f, 1,-8,
        0x1f98, 0x1f9f, 1,-8,
        0x1fa8, 0x1faf, 1,-8,
        0x1fb8, 0x1fb9, 1,-8,
        0x1fba, 0x1fbb, 1,-74,
        0x1fbc, 0x1fbc,-1,-9,
        0x1fbe, 0x1fbe,-1,-7173,
        0x1fc8, 0x1fcb, 1,-86,
        0x1fcc, 0x1fcc,-1,-9,
        0x1fd8, 0x1fd9, 1,-8,
        0x1fda, 0x1fdb, 1,-100,
        0x1fe8, 0x1fe9, 1,-8,
        0x1fea, 0x1feb, 1,-112,
        0x1fec, 0x1fec,-1,-7,
        0x1ff8, 0x1ff9, 1,-128,
        0x1ffa, 0x1ffb, 1,-126,
        0x1ffc, 0x1ffc,-1,-9,
        0x2126, 0x2126,-1,-7517,
        0x212a, 0x212a,-1,-8383,
        0x212b, 0x212b,-1,-8262,
        0x2132, 0x2132,-1, 28,
        0x2160, 0x216f, 1, 16,
        0x2183, 0x2183,-1, 1,
        0x24b6, 0x24cf, 1, 26,
        0x2c00, 0x2c2e, 1, 48,
        0x2c60, 0x2c60,-1, 1,
        0x2c62, 0x2c62,-1,-10743,
        0x2c63, 0x2c63,-1,-3814,
        0x2c64, 0x2c64,-1,-10727,
        0x2c67, 0x2c6b, 2, 1,
        0x2c6d, 0x2c6d,-1,-10780,
        0x2c6e, 0x2c6e,-1,-10749,
        0x2c6f, 0x2c6f,-1,-10783,
        0x2c70, 0x2c70,-1,-10782,
        0x2c72, 0x2c75, 3, 1,
        0x2c7e, 0x2c7f, 1,-10815,
        0x2c80, 0x2ce2, 2, 1,
        0x2ceb, 0x2ced, 2, 1,
        0x2cf2, 0xa640, 31054, 1,
        0xa642, 0xa66c, 2, 1,
        0xa680, 0xa69a, 2, 1,
        0xa722, 0xa72e, 2, 1,
        0xa732, 0xa76e, 2, 1,
        0xa779, 0xa77b, 2, 1,
        0xa77d, 0xa77d,-1,-35332,
        0xa77e, 0xa786, 2, 1,
        0xa78b, 0xa78b,-1, 1,
        0xa78d, 0xa78d,-1,-42280,
        0xa790, 0xa792, 2, 1,
        0xa796, 0xa7a8, 2, 1,
        0xa7aa, 0xa7aa,-1,-42308,
        0xa7ab, 0xa7ab,-1,-42319,
        0xa7ac, 0xa7ac,-1,-42315,
        0xa7ad, 0xa7ad,-1,-42305,
        0xa7b0, 0xa7b0,-1,-42258,
        0xa7b1, 0xa7b1,-1,-42282,
        0xff21, 0xff3a, 1, 32,
        0x10400, 0x10427, 1, 40,
        0x118a0, 0x118bf, 1, 32
    ])

;; Return the folded-case equivalent of "c", which is a UCS-4 character.  Uses simple case folding.

(defn- #_int utf-fold [#_int c]
    (utf-convert c, foldCase))

(final int* toLower
    [
        0x41, 0x5a, 1, 32,
        0xc0, 0xd6, 1, 32,
        0xd8, 0xde, 1, 32,
        0x100, 0x12e, 2, 1,
        0x130, 0x130,-1,-199,
        0x132, 0x136, 2, 1,
        0x139, 0x147, 2, 1,
        0x14a, 0x176, 2, 1,
        0x178, 0x178,-1,-121,
        0x179, 0x17d, 2, 1,
        0x181, 0x181,-1, 210,
        0x182, 0x184, 2, 1,
        0x186, 0x186,-1, 206,
        0x187, 0x187,-1, 1,
        0x189, 0x18a, 1, 205,
        0x18b, 0x18b,-1, 1,
        0x18e, 0x18e,-1, 79,
        0x18f, 0x18f,-1, 202,
        0x190, 0x190,-1, 203,
        0x191, 0x191,-1, 1,
        0x193, 0x193,-1, 205,
        0x194, 0x194,-1, 207,
        0x196, 0x196,-1, 211,
        0x197, 0x197,-1, 209,
        0x198, 0x198,-1, 1,
        0x19c, 0x19c,-1, 211,
        0x19d, 0x19d,-1, 213,
        0x19f, 0x19f,-1, 214,
        0x1a0, 0x1a4, 2, 1,
        0x1a6, 0x1a6,-1, 218,
        0x1a7, 0x1a7,-1, 1,
        0x1a9, 0x1a9,-1, 218,
        0x1ac, 0x1ac,-1, 1,
        0x1ae, 0x1ae,-1, 218,
        0x1af, 0x1af,-1, 1,
        0x1b1, 0x1b2, 1, 217,
        0x1b3, 0x1b5, 2, 1,
        0x1b7, 0x1b7,-1, 219,
        0x1b8, 0x1bc, 4, 1,
        0x1c4, 0x1c4,-1, 2,
        0x1c5, 0x1c5,-1, 1,
        0x1c7, 0x1c7,-1, 2,
        0x1c8, 0x1c8,-1, 1,
        0x1ca, 0x1ca,-1, 2,
        0x1cb, 0x1db, 2, 1,
        0x1de, 0x1ee, 2, 1,
        0x1f1, 0x1f1,-1, 2,
        0x1f2, 0x1f4, 2, 1,
        0x1f6, 0x1f6,-1,-97,
        0x1f7, 0x1f7,-1,-56,
        0x1f8, 0x21e, 2, 1,
        0x220, 0x220,-1,-130,
        0x222, 0x232, 2, 1,
        0x23a, 0x23a,-1, 10795,
        0x23b, 0x23b,-1, 1,
        0x23d, 0x23d,-1,-163,
        0x23e, 0x23e,-1, 10792,
        0x241, 0x241,-1, 1,
        0x243, 0x243,-1,-195,
        0x244, 0x244,-1, 69,
        0x245, 0x245,-1, 71,
        0x246, 0x24e, 2, 1,
        0x370, 0x372, 2, 1,
        0x376, 0x376,-1, 1,
        0x37f, 0x37f,-1, 116,
        0x386, 0x386,-1, 38,
        0x388, 0x38a, 1, 37,
        0x38c, 0x38c,-1, 64,
        0x38e, 0x38f, 1, 63,
        0x391, 0x3a1, 1, 32,
        0x3a3, 0x3ab, 1, 32,
        0x3cf, 0x3cf,-1, 8,
        0x3d8, 0x3ee, 2, 1,
        0x3f4, 0x3f4,-1,-60,
        0x3f7, 0x3f7,-1, 1,
        0x3f9, 0x3f9,-1,-7,
        0x3fa, 0x3fa,-1, 1,
        0x3fd, 0x3ff, 1,-130,
        0x400, 0x40f, 1, 80,
        0x410, 0x42f, 1, 32,
        0x460, 0x480, 2, 1,
        0x48a, 0x4be, 2, 1,
        0x4c0, 0x4c0,-1, 15,
        0x4c1, 0x4cd, 2, 1,
        0x4d0, 0x52e, 2, 1,
        0x531, 0x556, 1, 48,
        0x10a0, 0x10c5, 1, 7264,
        0x10c7, 0x10cd, 6, 7264,
        0x1e00, 0x1e94, 2, 1,
        0x1e9e, 0x1e9e,-1,-7615,
        0x1ea0, 0x1efe, 2, 1,
        0x1f08, 0x1f0f, 1,-8,
        0x1f18, 0x1f1d, 1,-8,
        0x1f28, 0x1f2f, 1,-8,
        0x1f38, 0x1f3f, 1,-8,
        0x1f48, 0x1f4d, 1,-8,
        0x1f59, 0x1f5f, 2,-8,
        0x1f68, 0x1f6f, 1,-8,
        0x1f88, 0x1f8f, 1,-8,
        0x1f98, 0x1f9f, 1,-8,
        0x1fa8, 0x1faf, 1,-8,
        0x1fb8, 0x1fb9, 1,-8,
        0x1fba, 0x1fbb, 1,-74,
        0x1fbc, 0x1fbc,-1,-9,
        0x1fc8, 0x1fcb, 1,-86,
        0x1fcc, 0x1fcc,-1,-9,
        0x1fd8, 0x1fd9, 1,-8,
        0x1fda, 0x1fdb, 1,-100,
        0x1fe8, 0x1fe9, 1,-8,
        0x1fea, 0x1feb, 1,-112,
        0x1fec, 0x1fec,-1,-7,
        0x1ff8, 0x1ff9, 1,-128,
        0x1ffa, 0x1ffb, 1,-126,
        0x1ffc, 0x1ffc,-1,-9,
        0x2126, 0x2126,-1,-7517,
        0x212a, 0x212a,-1,-8383,
        0x212b, 0x212b,-1,-8262,
        0x2132, 0x2132,-1, 28,
        0x2160, 0x216f, 1, 16,
        0x2183, 0x2183,-1, 1,
        0x24b6, 0x24cf, 1, 26,
        0x2c00, 0x2c2e, 1, 48,
        0x2c60, 0x2c60,-1, 1,
        0x2c62, 0x2c62,-1,-10743,
        0x2c63, 0x2c63,-1,-3814,
        0x2c64, 0x2c64,-1,-10727,
        0x2c67, 0x2c6b, 2, 1,
        0x2c6d, 0x2c6d,-1,-10780,
        0x2c6e, 0x2c6e,-1,-10749,
        0x2c6f, 0x2c6f,-1,-10783,
        0x2c70, 0x2c70,-1,-10782,
        0x2c72, 0x2c75, 3, 1,
        0x2c7e, 0x2c7f, 1,-10815,
        0x2c80, 0x2ce2, 2, 1,
        0x2ceb, 0x2ced, 2, 1,
        0x2cf2, 0xa640, 31054, 1,
        0xa642, 0xa66c, 2, 1,
        0xa680, 0xa69a, 2, 1,
        0xa722, 0xa72e, 2, 1,
        0xa732, 0xa76e, 2, 1,
        0xa779, 0xa77b, 2, 1,
        0xa77d, 0xa77d,-1,-35332,
        0xa77e, 0xa786, 2, 1,
        0xa78b, 0xa78b,-1, 1,
        0xa78d, 0xa78d,-1,-42280,
        0xa790, 0xa792, 2, 1,
        0xa796, 0xa7a8, 2, 1,
        0xa7aa, 0xa7aa,-1,-42308,
        0xa7ab, 0xa7ab,-1,-42319,
        0xa7ac, 0xa7ac,-1,-42315,
        0xa7ad, 0xa7ad,-1,-42305,
        0xa7b0, 0xa7b0,-1,-42258,
        0xa7b1, 0xa7b1,-1,-42282,
        0xff21, 0xff3a, 1, 32,
        0x10400, 0x10427, 1, 40,
        0x118a0, 0x118bf, 1, 32
    ])

(final int* toUpper
    [
        0x61, 0x7a, 1,-32,
        0xb5, 0xb5,-1, 743,
        0xe0, 0xf6, 1,-32,
        0xf8, 0xfe, 1,-32,
        0xff, 0xff,-1, 121,
        0x101, 0x12f, 2,-1,
        0x131, 0x131,-1,-232,
        0x133, 0x137, 2,-1,
        0x13a, 0x148, 2,-1,
        0x14b, 0x177, 2,-1,
        0x17a, 0x17e, 2,-1,
        0x17f, 0x17f,-1,-300,
        0x180, 0x180,-1, 195,
        0x183, 0x185, 2,-1,
        0x188, 0x18c, 4,-1,
        0x192, 0x192,-1,-1,
        0x195, 0x195,-1, 97,
        0x199, 0x199,-1,-1,
        0x19a, 0x19a,-1, 163,
        0x19e, 0x19e,-1, 130,
        0x1a1, 0x1a5, 2,-1,
        0x1a8, 0x1ad, 5,-1,
        0x1b0, 0x1b4, 4,-1,
        0x1b6, 0x1b9, 3,-1,
        0x1bd, 0x1bd,-1,-1,
        0x1bf, 0x1bf,-1, 56,
        0x1c5, 0x1c5,-1,-1,
        0x1c6, 0x1c6,-1,-2,
        0x1c8, 0x1c8,-1,-1,
        0x1c9, 0x1c9,-1,-2,
        0x1cb, 0x1cb,-1,-1,
        0x1cc, 0x1cc,-1,-2,
        0x1ce, 0x1dc, 2,-1,
        0x1dd, 0x1dd,-1,-79,
        0x1df, 0x1ef, 2,-1,
        0x1f2, 0x1f2,-1,-1,
        0x1f3, 0x1f3,-1,-2,
        0x1f5, 0x1f9, 4,-1,
        0x1fb, 0x21f, 2,-1,
        0x223, 0x233, 2,-1,
        0x23c, 0x23c,-1,-1,
        0x23f, 0x240, 1, 10815,
        0x242, 0x247, 5,-1,
        0x249, 0x24f, 2,-1,
        0x250, 0x250,-1, 10783,
        0x251, 0x251,-1, 10780,
        0x252, 0x252,-1, 10782,
        0x253, 0x253,-1,-210,
        0x254, 0x254,-1,-206,
        0x256, 0x257, 1,-205,
        0x259, 0x259,-1,-202,
        0x25b, 0x25b,-1,-203,
        0x25c, 0x25c,-1, 42319,
        0x260, 0x260,-1,-205,
        0x261, 0x261,-1, 42315,
        0x263, 0x263,-1,-207,
        0x265, 0x265,-1, 42280,
        0x266, 0x266,-1, 42308,
        0x268, 0x268,-1,-209,
        0x269, 0x269,-1,-211,
        0x26b, 0x26b,-1, 10743,
        0x26c, 0x26c,-1, 42305,
        0x26f, 0x26f,-1,-211,
        0x271, 0x271,-1, 10749,
        0x272, 0x272,-1,-213,
        0x275, 0x275,-1,-214,
        0x27d, 0x27d,-1, 10727,
        0x280, 0x283, 3,-218,
        0x287, 0x287,-1, 42282,
        0x288, 0x288,-1,-218,
        0x289, 0x289,-1,-69,
        0x28a, 0x28b, 1,-217,
        0x28c, 0x28c,-1,-71,
        0x292, 0x292,-1,-219,
        0x29e, 0x29e,-1, 42258,
        0x345, 0x345,-1, 84,
        0x371, 0x373, 2,-1,
        0x377, 0x377,-1,-1,
        0x37b, 0x37d, 1, 130,
        0x3ac, 0x3ac,-1,-38,
        0x3ad, 0x3af, 1,-37,
        0x3b1, 0x3c1, 1,-32,
        0x3c2, 0x3c2,-1,-31,
        0x3c3, 0x3cb, 1,-32,
        0x3cc, 0x3cc,-1,-64,
        0x3cd, 0x3ce, 1,-63,
        0x3d0, 0x3d0,-1,-62,
        0x3d1, 0x3d1,-1,-57,
        0x3d5, 0x3d5,-1,-47,
        0x3d6, 0x3d6,-1,-54,
        0x3d7, 0x3d7,-1,-8,
        0x3d9, 0x3ef, 2,-1,
        0x3f0, 0x3f0,-1,-86,
        0x3f1, 0x3f1,-1,-80,
        0x3f2, 0x3f2,-1, 7,
        0x3f3, 0x3f3,-1,-116,
        0x3f5, 0x3f5,-1,-96,
        0x3f8, 0x3fb, 3,-1,
        0x430, 0x44f, 1,-32,
        0x450, 0x45f, 1,-80,
        0x461, 0x481, 2,-1,
        0x48b, 0x4bf, 2,-1,
        0x4c2, 0x4ce, 2,-1,
        0x4cf, 0x4cf,-1,-15,
        0x4d1, 0x52f, 2,-1,
        0x561, 0x586, 1,-48,
        0x1d79, 0x1d79,-1, 35332,
        0x1d7d, 0x1d7d,-1, 3814,
        0x1e01, 0x1e95, 2,-1,
        0x1e9b, 0x1e9b,-1,-59,
        0x1ea1, 0x1eff, 2,-1,
        0x1f00, 0x1f07, 1, 8,
        0x1f10, 0x1f15, 1, 8,
        0x1f20, 0x1f27, 1, 8,
        0x1f30, 0x1f37, 1, 8,
        0x1f40, 0x1f45, 1, 8,
        0x1f51, 0x1f57, 2, 8,
        0x1f60, 0x1f67, 1, 8,
        0x1f70, 0x1f71, 1, 74,
        0x1f72, 0x1f75, 1, 86,
        0x1f76, 0x1f77, 1, 100,
        0x1f78, 0x1f79, 1, 128,
        0x1f7a, 0x1f7b, 1, 112,
        0x1f7c, 0x1f7d, 1, 126,
        0x1f80, 0x1f87, 1, 8,
        0x1f90, 0x1f97, 1, 8,
        0x1fa0, 0x1fa7, 1, 8,
        0x1fb0, 0x1fb1, 1, 8,
        0x1fb3, 0x1fb3,-1, 9,
        0x1fbe, 0x1fbe,-1,-7205,
        0x1fc3, 0x1fc3,-1, 9,
        0x1fd0, 0x1fd1, 1, 8,
        0x1fe0, 0x1fe1, 1, 8,
        0x1fe5, 0x1fe5,-1, 7,
        0x1ff3, 0x1ff3,-1, 9,
        0x214e, 0x214e,-1,-28,
        0x2170, 0x217f, 1,-16,
        0x2184, 0x2184,-1,-1,
        0x24d0, 0x24e9, 1,-26,
        0x2c30, 0x2c5e, 1,-48,
        0x2c61, 0x2c61,-1,-1,
        0x2c65, 0x2c65,-1,-10795,
        0x2c66, 0x2c66,-1,-10792,
        0x2c68, 0x2c6c, 2,-1,
        0x2c73, 0x2c76, 3,-1,
        0x2c81, 0x2ce3, 2,-1,
        0x2cec, 0x2cee, 2,-1,
        0x2cf3, 0x2cf3,-1,-1,
        0x2d00, 0x2d25, 1,-7264,
        0x2d27, 0x2d2d, 6,-7264,
        0xa641, 0xa66d, 2,-1,
        0xa681, 0xa69b, 2,-1,
        0xa723, 0xa72f, 2,-1,
        0xa733, 0xa76f, 2,-1,
        0xa77a, 0xa77c, 2,-1,
        0xa77f, 0xa787, 2,-1,
        0xa78c, 0xa791, 5,-1,
        0xa793, 0xa797, 4,-1,
        0xa799, 0xa7a9, 2,-1,
        0xff41, 0xff5a, 1,-32,
        0x10428, 0x1044f, 1,-40,
        0x118c0, 0x118df, 1,-32
    ])

;; Return the lower-case equivalent of "c", which is a UCS-4 character.  Use simple case folding.

(defn- #_int utf-tolower [#_int c]
    (ยง
        (if (< c 0x80)
            ((ร RETURN) (asc_tolower c))
        )

        (utf-convert c, toLower)
    ))

;; Return the upper-case equivalent of "c", which is a UCS-4 character.  Use simple case folding.

(defn- #_int utf-toupper [#_int c]
    (ยง
        (if (< c 0x80)
            ((ร RETURN) (asc_toupper c))
        )

        (utf-convert c, toUpper)
    ))

(defn- #_boolean utf-islower [#_int c]
    (ยง
        (if (< c 0x80)
            ((ร RETURN) (asc-islower c))
        )

        ;; German sharp s is lower case but has no upper case equivalent.
        (or (!= (utf-toupper c) c) (== c 0xdf))
    ))

(defn- #_boolean utf-isupper [#_int c]
    (ยง
        (if (< c 0x80)
            ((ร RETURN) (asc-isupper c))
        )

        (!= (utf-tolower c) c)
    ))

(defn- #_int us--strnicmp [#_Bytes _s1, #_Bytes _s2, #_int _n1, #_int _n2]
    (ยง
        (ร int c1, c2)
; %%    ((ร Bytes[] s1 =) (ร { _s1 }, s2 = { _s2 }))
; %%    ((ร int[] n1 =) (ร { _n1 }, n2 = { _n2 }))

        (while true
            ((ร c1 =) (us-safe-read-char-adv s1, n1))
            ((ร c2 =) (us-safe-read-char-adv s2, n2))

            (if (or (<= c1 0) (<= c2 0))
                (ร BREAK)
            )

            (if (== c1 c2)
                (ร CONTINUE)
            )

            ((ร int cmp =) (- (utf-fold c1) (utf-fold c2)))
            (if (non-zero? cmp)
                ((ร RETURN) cmp)
            )
        )

        ;; some string ended or has an incomplete/illegal character sequence

        (when (or (zero? c1) (zero? c2))
            ;; some string ended. shorter string is smaller
            (if (and (zero? c1) (zero? c2))
                ((ร RETURN) 0)
            )

            ((ร RETURN) (if (zero? c1) -1 1))
        )

        ;; Continue with bytewise comparison to produce some result that
        ;; would make comparison operations involving this function transitive.
        ;;
        ;; If only one string had an error, comparison should be made with
        ;; folded version of the other string.  In this case it is enough
        ;; to fold just one character to determine the result of comparison.

        ((ร Bytes buffer =) (Bytes. 6))

        (cond (and (!= c1 -1) (== c2 -1))
        (do
            ((ร n1[0] =) (utf-char2bytes (utf-fold c1), buffer))
            ((ร s1[0] =) buffer)
        )
        (and (!= c2 -1) (== c1 -1))
        (do
            ((ร n2[0] =) (utf-char2bytes (utf-fold c2), buffer))
            ((ร s2[0] =) buffer)
        ))

        (while (and (< 0 (... n1 0)) (< 0 (... n2 0)) (non-eos? (... s1 0)) (non-eos? (... s2 0)))
            ((ร int cmp =) (- (int (.at (... s1 0) 0)) (int (.at (... s2 0) 0))))
            (if (non-zero? cmp)
                ((ร RETURN) cmp)
            )

            ((ร s1[0] =) (.plus (... s1 0) 1))
            ((ร s2[0] =) (.plus (... s2 0) 1))
            (ร n1[0]--)
            (ร n2[0]--)
        )

        (if (and (< 0 (... n1 0)) (eos? (... s1 0)))
            ((ร n1[0] =) 0)
        )
        (if (and (< 0 (... n2 0)) (eos? (... s2 0)))
            ((ร n2[0] =) 0)
        )

        (if (and (zero? (... n1 0)) (zero? (... n2 0)))
            ((ร RETURN) 0)
        )

        (if (zero? (... n1 0)) -1 1)
    ))

;; Version of strnicmp() that handles multi-byte characters.
;; Needed for Big5, Shift-JIS and UTF-8 encoding.
;; Returns zero if s1 and s2 are equal (ignoring case),
;; the difference between two characters otherwise.

(defn- #_int us-strnicmp [#_Bytes s1, #_Bytes s2, #_int nn]
    (us--strnicmp s1, s2, nn, nn))

;; "g8": show bytes of the UTF-8 char under the cursor.
;; Doesn't matter what 'encoding' has been set to.

(defn- #_void show-utf8 []
    (ยง
        ((ร Bytes p =) (ml-get-cursor))

        ;; Get the byte length of the char under the cursor, including composing characters.
        ((ร int len =) (us-ptr2len-cc p))
        (when (zero? len)
            (msg (u8 "NUL"))
            ((ร RETURN) nil)
        )

        ((ร int clen =) (ร 0, rlen = 0))

        (dotimes [#_int i len]
            (when (zero? clen)
                ;; start of (composing) character, get its length
                (when (< 0 i)
                    (STRCPY (.plus @ioBuff rlen), (u8 "+ "))
                    ((ร rlen =) (+ rlen 2))
                )
                ((ร clen =) (us-ptr2len (.plus p i)))
            )
            ;; NUL is stored as NL
            (.sprintf libC (.plus @ioBuff rlen), (u8 "%02x "), (if (== (.at p i) NL) NUL (.at p i)))
            (ร --clen)
            ((ร rlen =) (+ rlen (STRLEN @ioBuff, rlen)))
            (if (< (- IOSIZE 20) rlen)
                (ร BREAK)
            )
        )

        (msg @ioBuff)
        nil
    ))

(defn- #_int us-head-off [#_Bytes base, #_Bytes p]
    (ยง
        (if (< (char_u (.at p 0)) 0x80)        ;; be quick for ASCII
            ((ร RETURN) 0)
        )

        (ร Bytes q)

        ;; Skip backwards over trailing bytes: 10xx.xxxx
        ;; Skip backwards again if on a composing char.
        ((ร FOR) (ร ((ร q =) p) true ((ร q =) (.minus q 1)))
            (ร Bytes s)
            ;; Move 's' to the last byte of this char.
            ((ร FOR) (ร ((ร s =) q) (== (& (char_u (.at s 1)) 0xc0) 0x80) ((ร s =) (.plus s 1)))
                ;
            )
            ;; Move 'q' to the first byte of this char.
            (while (and (BLT base, q) (== (& (char_u (.at q 0)) 0xc0) 0x80))
                ((ร q =) (.minus q 1))
            )
            ;; Check for illegal sequence.  Do allow an illegal byte after where we started.
            ((ร int len =) (us-byte2len (.at q 0), false))
            (if (and (!= len (+ (BDIFF s, q) 1)) (!= len (+ (BDIFF p, q) 1)))
                ((ร RETURN) 0)
            )

            (if (or (BLE q, base) (not (utf-iscomposing (us-ptr2char q))))
                (ร BREAK)
            )
        )

        (BDIFF p, q)
    ))

;; Return the offset from "p" to the first byte of a character.  When "p" is
;; at the start of a character 0 is returned, otherwise the offset to the next
;; character.  Can start anywhere in a stream of bytes.

(defn- #_int us-off-next [#_Bytes base, #_Bytes p]
    (ยง
        (if (< (char_u (.at p 0)) 0x80)        ;; be quick for ASCII
            ((ร RETURN) 0)
        )

        ;; Find the next character that isn't 10xx.xxxx.
        (ร int i)
        ((ร FOR) (ร ((ร i =) 0) (== (& (char_u (.at p i)) 0xc0) 0x80) (ร i++))
            ;
        )
        (when (< 0 i)
            ;; Check for illegal sequence.
            (ร int j)
            ((ร FOR) (ร ((ร j =) 0) (BLT base, (.minus p j)) (ร j++))
                (if (!= (& (char_u (.at p (- j))) 0xc0) 0x80)
                    (ร BREAK)
                )
            )
            (if (!= (us-byte2len (.at p (- j)), false) (+ i j))
                ((ร RETURN) 0)
            )
        )
        i
    ))

;; Return the offset from "p" to the last byte of the character it points into.
;; Can start anywhere in a stream of bytes.

(defn- #_int us-tail-off [#_Bytes base, #_Bytes p]
    (ยง
        (if (eos? p)
            ((ร RETURN) 0)
        )

        (ร int i, j)

        ;; Find the last character that is 10xx.xxxx.
        ((ร FOR) (ร ((ร i =) 0) (== (& (char_u (.at p (inc i))) 0xc0) 0x80) (ร i++))
            ;
        )

        ;; Check for illegal sequence.
        ((ร FOR) (ร ((ร j =) 0) (BLT base, (.minus p j)) (ร j++))
            (if (!= (& (char_u (.at p (- j))) 0xc0) 0x80)
                (ร BREAK)
            )
        )

        (if (!= (us-byte2len (.at p (- j)), false) (+ i j 1))
            ((ร RETURN) 0)
        )

        i
    ))

;; Find the next illegal byte sequence.

(defn- #_void utf-find-illegal []
    (ยง
        ((ร pos_C cursor =) (:w_cursor @curwin))
        ((ร pos_C save_pos =) (NEW_pos_C))
        (COPY-pos save_pos, cursor)

        ((ร FOR) (ร ((ร cursor.coladd =) 0) true (ร cursor.lnum++, (cursor.col) = 0))
            ((ร FOR) (ร ((ร Bytes p =) (ml-get-cursor)) (non-eos? p) nil)
                ;; Illegal means that there are not enough trail bytes (checked
                ;; by us-ptr2len()) or too many of them (overlong sequence).
                ((ร int len =) (us-ptr2len p))
                (when (and (<= 0x80 (char_u (.at p 0))) (or (== len 1) (!= (utf-char2len (us-ptr2char p)) len)))
                    ((ร cursor.col =) (+ (:col cursor) (BDIFF p, (ml-get-cursor))))
                    ((ร RETURN) nil)
                )
                ((ร p =) (.plus p len))
            )

            (if (== (:lnum cursor) (:ml_line_count (:b_ml @curbuf)))
                (ร BREAK)
            )
        )

        ;; didn't find it: don't move and beep
        (COPY-pos cursor, save_pos)
        (beep-flush)
        nil
    ))

;; Adjust position "*posp" to point to the first byte of a multi-byte character.
;; If it points to a tail byte it's moved backwards to the head byte.

(defn- #_void mb-adjust-pos [#_buffer_C buf, #_pos_C posp]
    (ยง
        (when (or (< 0 (:col posp)) (< 1 (:coladd posp)))
            ((ร Bytes p =) (ml-get-buf buf, (:lnum posp)))
            ((ร posp.col =) (- (:col posp) (us-head-off p, (.plus p (:col posp)))))
            ;; Reset "coladd" when the cursor would be on the right half of a double-wide character.
            (when (and (== (:coladd posp) 1) (!= (.at p (:col posp)) TAB) (vim-isprintc (us-ptr2char (.plus p (:col posp)))) (< 1 (mb-ptr2cells (.plus p (:col posp)))))
                ((ร posp.coladd =) 0)
            )
        )
        nil
    ))

;; Backup multi-byte pointer.  Only use with "base" < "p" !
(defn- #_int us-ptr-back [#_Bytes base, #_Bytes p]
    (inc (us-head-off base, (.minus p 1))))

;; Return a pointer to the character before "*p", if there is one.

(defn- #_Bytes us-prevptr [#_Bytes base, #_Bytes p]
    ;; base: start of the string
    (if (BLT base, p) (.minus p (us-ptr-back base, p)) p))

;; Return the character length of "p".
;; Each multi-byte character (with following composing characters) counts as one.

(defn- #_int us-charlen [#_Bytes p]
    (ยง
        ((ร int count =) 0)

        (when (non-nil? p)
            ((ร FOR) (ร nil (non-eos? p) ((ร p =) (.plus p (us-ptr2len-cc p))))
                (ร count++)
            )
        )

        count
    ))

;; Return true if the character at "row"/"col" on the screen
;; is the left side of a double-width character.
;; Caller must make sure "row" and "col" are not invalid!

(defn- #_boolean mb-lefthalve [#_int row, #_int col]
    (let [offset (... @lineOffset row)]
        (< 1 (utf-off2cells (+ offset col), (+ offset @screenCols)))
    ))

;; Correct a position on the screen,
;; if it's the right half of a double-wide char move it to the left half.
;; Returns the corrected column.

(defn- #_int mb-fix-col [#_int col, #_int row]
    (let [col (check-col col) row (check-row row)]
        (if (and (non-nil? @screenLines) (< 0 col) (== (.at @screenLines (+ (... @lineOffset row) col)) 0))
            (dec col)
            col
        )
    ))

;; misc.c: functions that didn't seem to fit elsewhere --------------------------------------------

;; Count the size (in window cells) of the indent in the current line.

(defn- #_int get-indent []
    (get-indent-str (ml-get-curline), (int @(:b_p_ts @curbuf))))

;; count the size (in window cells) of the indent in line "ptr", with 'tabstop' at "ts"

(defn- #_int get-indent-str [#_Bytes ptr, #_int ts]
    (ยง
        ((ร int count =) 0)

        ((ร FOR) (ร nil (non-eos? ptr) ((ร ptr =) (.plus ptr 1)))
            (cond (== (.at ptr 0) TAB)
            (do
                ((ร count =) (+ count (- ts (% count ts))))         ;; count a tab for what it is worth
            )
            (== (.at ptr 0) (byte \space))
            (do
                (ร count++)                            ;; count a space for one
            )
            :else
            (do
                (ร BREAK)
            ))
        )

        count
    ))

;; Set the indent of the current line.
;; Leaves the cursor on the first non-blank in the line.
;; Caller must take care of undo.
;; "flags":
;;      SIN_CHANGED:    call changed-bytes() if the line was changed.
;;      SIN_INSERT:     insert the indent in front of the line.
;;      SIN_UNDO:       save line for undo before changing it.
;; Returns true if the line was changed.

(defn- #_boolean set-indent [#_int size, #_int flags]
    ;; size: measured in spaces
    (ยง
        ((ร boolean doit =) false)
        ((ร int ind_done =) 0)                       ;; measured in spaces
        ((ร boolean retval =) false)
        ((ร int orig_char_len =) -1)                 ;; number of initial whitespace chars
                                                ;; when 'et' and 'pi' are both set

        ;; First check if there is anything to do and compute
        ;; the number of characters needed for the indent.

        ((ร int todo =) size)
        ((ร int ind_len =) 0)                        ;; measured in characters
        ((ร Bytes oldline =) (ml-get-curline))
        ((ร Bytes p =) oldline)

        ;; Calculate the buffer size for the new indent and check if it isn't already set.

        ;; If 'expandtab' isn't set: use TABs; if both 'expandtab' and
        ;; 'preserveindent' are set: count the number of characters at
        ;; the beginning of the line to be copied.
        (when (or (not @(:b_p_et @curbuf)) (and (non-flag? flags SIN_INSERT) @(:b_p_pi @curbuf)))
            ;; If 'preserveindent' is set, then reuse as much as possible
            ;; of the existing indent structure for the new indent.
            (when (and (non-flag? flags SIN_INSERT) @(:b_p_pi @curbuf))
                ((ร ind_done =) 0)

                ;; count as many characters as we can use
                (while (and (< 0 todo) (vim-iswhite (.at p 0)))
                    (cond (== (.at p 0) TAB)
                    (do
                        ((ร int tab_pad =) (- (int @(:b_p_ts @curbuf)) (% ind_done (int @(:b_p_ts @curbuf)))))
                        ;; stop if this tab will overshoot the target
                        (if (< todo tab_pad)
                            (ร BREAK)
                        )
                        ((ร todo =) (- todo tab_pad))
                        (ร ind_len++)
                        ((ร ind_done =) (+ ind_done tab_pad))
                    )
                    :else
                    (do
                        (ร --todo)
                        (ร ind_len++)
                        (ร ind_done++)
                    ))
                    ((ร p =) (.plus p 1))
                )

                ;; Set initial number of whitespace chars to copy
                ;; if we are preserving indent but expandtab is set.
                (if @(:b_p_et @curbuf)
                    ((ร orig_char_len =) ind_len)
                )

                ;; Fill to next tabstop with a tab, if possible.
                ((ร int tab_pad =) (- (int @(:b_p_ts @curbuf)) (% ind_done (int @(:b_p_ts @curbuf)))))
                (when (and (<= tab_pad todo) (== orig_char_len -1))
                    ((ร doit =) true)
                    ((ร todo =) (- todo tab_pad))
                    (ร ind_len++)
                    ;; ind_done += tab_pad;
                )
            )

            ;; count tabs required for indent
            (while (<= (int @(:b_p_ts @curbuf)) todo)
                (if (!= (.at p 0) TAB)
                    ((ร doit =) true)
                    ((ร p =) (.plus p 1))
                )
                ((ร todo =) (- todo (int @(:b_p_ts @curbuf))))
                (ร ind_len++)
                ;; ind_done += (int)curbuf.b_p_ts[0];
            )
        )
        ;; count spaces required for indent
        (while (< 0 todo)
            (if (!= (.at p 0) (byte \space))
                ((ร doit =) true)
                ((ร p =) (.plus p 1))
            )
            (ร --todo)
            (ร ind_len++)
            ;; ++ind_done;
        )

        ;; Return if the indent is OK already.
        (if (and (not doit) (not (vim-iswhite (.at p 0))) (non-flag? flags SIN_INSERT))
            ((ร RETURN) false)
        )

        ;; Allocate memory for the new line.
        ((ร p =) (if (flag? flags SIN_INSERT) oldline (skipwhite p)))
        ((ร int line_len =) (+ (STRLEN p) 1))

        ;; If 'preserveindent' and 'expandtab' are both set keep the original
        ;; characters and allocate accordingly.  We will fill the rest with spaces
        ;; after the if (!curbuf.b_p_et) below.
        (ร Bytes newline)
        (ร Bytes s)
        (cond (!= orig_char_len -1)
        (do
            ((ร newline =) (Bytes. (+ (- (+ orig_char_len size) ind_done) line_len)))

            ((ร todo =) (- size ind_done))
            ((ร ind_len =) (+ orig_char_len todo))     ;; Set total length of indent in characters,
                                                ;; which may have been undercounted until now
            ((ร p =) oldline)
            ((ร s =) newline)
            (while (< 0 orig_char_len)
                (.be ((ร s =) (.plus s 1)) -1, (.at ((ร p =) (.plus p 1)) -1))
                (ร orig_char_len--)
            )

            ;; Skip over any additional white space (useful when newindent is less than old).
            (while (vim-iswhite (.at p 0))
                ((ร p =) (.plus p 1))
            )
        )
        :else
        (do
            ((ร todo =) size)
            ((ร newline =) (Bytes. (+ ind_len line_len)))
            ((ร s =) newline)
        ))

        ;; Put the characters in the new line.
        ;; If 'expandtab' isn't set: use TABs.
        (when (not @(:b_p_et @curbuf))
            ;; If 'preserveindent' is set, then reuse as much as possible
            ;; of the existing indent structure for the new indent.
            (when (and (non-flag? flags SIN_INSERT) @(:b_p_pi @curbuf))
                ((ร p =) oldline)
                ((ร ind_done =) 0)

                (while (and (< 0 todo) (vim-iswhite (.at p 0)))
                    (cond (== (.at p 0) TAB)
                    (do
                        ((ร int tab_pad =) (- (int @(:b_p_ts @curbuf)) (% ind_done (int @(:b_p_ts @curbuf)))))
                        ;; stop if this tab will overshoot the target
                        (if (< todo tab_pad)
                            (ร BREAK)
                        )
                        ((ร todo =) (- todo tab_pad))
                        ((ร ind_done =) (+ ind_done tab_pad))
                    )
                    :else
                    (do
                        (ร --todo)
                        (ร ind_done++)
                    ))
                    (.be ((ร s =) (.plus s 1)) -1, (.at ((ร p =) (.plus p 1)) -1))
                )

                ;; Fill to next tabstop with a tab, if possible.
                ((ร int tab_pad =) (- (int @(:b_p_ts @curbuf)) (% ind_done (int @(:b_p_ts @curbuf)))))
                (when (<= tab_pad todo)
                    (.be ((ร s =) (.plus s 1)) -1, TAB)
                    ((ร todo =) (- todo tab_pad))
                )

                ((ร p =) (skipwhite p))
            )

            (while (<= (int @(:b_p_ts @curbuf)) todo)
                (.be ((ร s =) (.plus s 1)) -1, TAB)
                ((ร todo =) (- todo (int @(:b_p_ts @curbuf))))
            )
        )
        (while (< 0 todo)
            (.be ((ร s =) (.plus s 1)) -1, (byte \space))
            (ร --todo)
        )
        (BCOPY s, p, line_len)

        ;; Replace the line (unless undo fails).
        (when (or (non-flag? flags SIN_UNDO) (u-savesub (:lnum (:w_cursor @curwin))))
            (ml-replace (:lnum (:w_cursor @curwin)), newline)
            (if (flag? flags SIN_CHANGED)
                (changed-bytes (:lnum (:w_cursor @curwin)), 0))
            ;; Correct saved cursor position if it is in this line.
            (when (== (:lnum @saved_cursor) (:lnum (:w_cursor @curwin)))
                (cond (<= (BDIFF p, oldline) (:col @saved_cursor))
                (do
                    ;; cursor was after the indent, adjust for the number of bytes added/removed
                    ((ร @saved_cursor.col =) (+ (:col @saved_cursor) (- ind_len (BDIFF p, oldline))))
                )
                (<= (BDIFF s, newline) (:col @saved_cursor))
                (do
                    ;; cursor was in the indent and is now after it; put it back
                    ;; at the start of the indent (replacing spaces with TAB)
                    ((ร @saved_cursor.col =) (BDIFF s, newline))
                ))
            )
            ((ร retval =) true)
        )

        ((ร @curwin.w_cursor.col =) ind_len)
        retval
    ))

;; Copy the indent from ptr to the current line (and fill to size)
;; Leaves the cursor on the first non-blank in the line.
;; Returns true if the line was changed.

(defn- #_boolean copy-indent [#_int size, #_Bytes src]
    (ยง
        ((ร Bytes p =) nil)
        ((ร Bytes line =) nil)
;       int ind_len = 0;	// %% red.
        ((ร int line_len =) 0)

        ;; Round 1: compute the number of characters needed for the indent.
        ;; Round 2: copy the characters.
        ((ร FOR) (ร ((ร int round =) 1) (<= round 2) (ร round++))
            ((ร int todo =) size)
            ((ร ind_len =) 0)
            ((ร int ind_done =) 0)
            ((ร Bytes s =) src)

            ;; Count/copy the usable portion of the source line.
            (while (and (< 0 todo) (vim-iswhite (.at s 0)))
                (cond (== (.at s 0) TAB)
                (do
                    ((ร int tab_pad =) (- (int @(:b_p_ts @curbuf)) (% ind_done (int @(:b_p_ts @curbuf)))))
                    ;; Stop if this tab will overshoot the target.
                    (if (< todo tab_pad)
                        (ร BREAK)
                    )
                    ((ร todo =) (- todo tab_pad))
                    ((ร ind_done =) (+ ind_done tab_pad))
                )
                :else
                (do
                    (ร --todo)
                    (ร ind_done++)
                ))
                (ร ind_len++)
                (if (non-nil? p)
                    (.be ((ร p =) (.plus p 1)) -1, (.at s 0))
                )
                ((ร s =) (.plus s 1))
            )

            ;; Fill to next tabstop with a tab, if possible.
            ((ร int tab_pad =) (- (int @(:b_p_ts @curbuf)) (% ind_done (int @(:b_p_ts @curbuf)))))
            (when (and (<= tab_pad todo) (not @(:b_p_et @curbuf)))
                ((ร todo =) (- todo tab_pad))
                (ร ind_len++)
                (if (non-nil? p)
                    (.be ((ร p =) (.plus p 1)) -1, TAB)
                )
            )

            ;; Add tabs required for indent.
            (while (and (<= (int @(:b_p_ts @curbuf)) todo) (not @(:b_p_et @curbuf)))
                ((ร todo =) (- todo (int @(:b_p_ts @curbuf))))
                (ร ind_len++)
                (if (non-nil? p)
                    (.be ((ร p =) (.plus p 1)) -1, TAB)
                )
            )

            ;; Count/add spaces required for indent.
            (while (< 0 todo)
                (ร --todo)
                (ร ind_len++)
                (if (non-nil? p)
                    (.be ((ร p =) (.plus p 1)) -1, (byte \space))
                )
            )

            (when (nil? p)
                ;; Allocate memory for the result:
                ;; the copied indent, new indent and the rest of the line.
                ((ร line_len =) (+ (STRLEN (ml-get-curline)) 1))
                ((ร line =) (Bytes. (+ ind_len line_len)))
                ((ร p =) line)
            )
        )

        ;; Append the original line.
        (BCOPY p, (ml-get-curline), line_len)

        ;; Replace the line.
        (ml-replace (:lnum (:w_cursor @curwin)), line)

        ;; Put the cursor after the indent.
        ((ร @curwin.w_cursor.col =) ind_len)
        true
    ))

(atom! int      bri_prev_indent)    ;; cached indent value
(atom! long     bri_prev_ts)        ;; cached tabstop value
(atom! Bytes    bri_prev_line)      ;; cached pointer to line
(atom! int      bri_prev_tick)      ;; changedtick of cached value

;; Return appropriate space number for breakindent, taking influencing
;; parameters into account.  Window must be specified, since it is not
;; necessarily always the current one.

(defn- #_int get-breakindent-win [#_window_C wp, #_Bytes line]
    ;; line: start of the line
    (ยง
        ((ร int bri =) 0)
        ;; window width minus window margin space, i.e. what rests for text
        ((ร int eff_wwidth =) (- (:w_width wp) (if (and (or @(:wo_nu (:w_options wp)) @(:wo_rnu (:w_options wp))) (nil? (vim-strbyte @p_cpo, CPO_NUMCOL))) (+ (number-width wp) 1) 0)))

        ;; used cached indent, unless pointer or 'tabstop' changed
        (when (or (BNE @bri_prev_line, line) (!= @bri_prev_ts @(:b_p_ts @curbuf)) (!= @bri_prev_tick (:b_changedtick @curbuf)))
            (reset! bri_prev_line line)
            (reset! bri_prev_ts @(:b_p_ts @curbuf))
            (reset! bri_prev_tick (:b_changedtick @curbuf))
            (reset! bri_prev_indent (get-indent-str line, (int @(:b_p_ts @curbuf))))
        )
        ((ร bri =) (+ @bri_prev_indent (:w_p_brishift wp)))

        ;; indent minus the length of the showbreak string
        (if (:w_p_brisbr wp)
            ((ร bri =) (- bri (mb-string2cells @p_sbr, -1)))
        )

        ;; add offset for number column, if 'n' is in 'cpoptions'
        ((ร bri =) (+ bri (win-col-off2 wp)))

        ;; never indent past left window margin
        (cond (< bri 0)
        (do
            ((ร bri =) 0)
        )
        ;; always leave at least bri_min characters on the left, if text width is sufficient
        (< (- eff_wwidth (:w_p_brimin wp)) bri)
        (do
            ((ร bri =) (if (< (- eff_wwidth (:w_p_brimin wp)) 0) 0 (- eff_wwidth (:w_p_brimin wp))))
        ))

        bri
    ))

;; Return true if the string "line" starts with a word from 'cinwords'.

(defn- #_boolean cin-is-cinword [#_Bytes line]
    (ยง
        ((ร boolean retval =) false)

        ((ร int cinw_len =) (+ (STRLEN @(:b_p_cinw @curbuf)) 1))
        ((ร Bytes cinw_buf =) (Bytes. cinw_len))

        ((ร line =) (skipwhite line))

; %%    ((ร FOR) (ร ((ร Bytes[] cinw =) (ร { @curbuf.@b_p_cinw })) (non-eos? (... cinw 0)) nil)
            ((ร int len =) (copy-option-part cinw, cinw_buf, cinw_len, (u8 ",")))
            (when (and (zero? (STRNCMP line, cinw_buf, len)) (or (not (us-iswordb (.at line len), @curbuf)) (not (us-iswordb (.at line (dec len)), @curbuf))))
                ((ร retval =) true)
                (ร BREAK)
            )
; %%    )

        retval
    ))

;; open-line: Add a new line below or above the current line.
;;
;; For VREPLACE mode, we only add a new line when we get to the end of the
;; file, otherwise we just start replacing the next line.
;;
;; Caller must take care of undo.  Since VREPLACE may affect any number of
;; lines however, it may call u-save-cursor() again when starting to change a new line.
;;
;; "second_line_indent": indent for after ^^D in Insert mode
;;
;; Return true for success, false for failure

(defn- #_boolean open-line [#_int dir, #_int flags, #_int second_line_indent]
    ;; dir: FORWARD or BACKWARD
    (ยง
        ((ร boolean retval =) false)             ;; return value, default is FAIL

        ((ร boolean do_si =) (and (not @p_paste) @(:b_p_si @curbuf)))
        ((ร boolean no_si =) false)              ;; reset did_si afterwards
        ((ร boolean saved_pi =) @(:b_p_pi @curbuf))       ;; copy of preserveindent setting

        ;; make a copy of the current line so we can mess with it

        ((ร Bytes saved_line =) (STRDUP (ml-get-curline)))
        ((ร Bytes next_line =) nil)            ;; copy of the next line

        (when (flag? @State VREPLACE_FLAG)
            ;; With VREPLACE we make a copy of the next line, which we will be starting to replace.
            ;; First make the new line empty and let vim play with the indenting and comment leader
            ;; to its heart's content.  Then we grab what it ended up putting on the new line, put
            ;; back the original line, and call ins-char() to put each new character onto the line,
            ;; replacing what was there before and pushing the right stuff onto the replace stack.

            ((ร next_line =) (if (< (:lnum (:w_cursor @curwin)) @orig_line_count)
                (STRDUP (ml-get (inc (:lnum (:w_cursor @curwin)))))
                (STRDUP (u8 ""))
            ))

            ;; In VREPLACE mode, a NL replaces the rest of the line, and starts replacing the next line,
            ;; so push all of the characters left on the line onto the replace stack.  We'll push any other
            ;; characters that might be replaced at the start of the next line (due to autoindent, etc.)
            ;; a bit later.

            (replace-push NUL)      ;; call twice because BS over NL expects it
            (replace-push NUL)
            ((ร FOR) (ร ((ร Bytes s =) (.plus saved_line (:col (:w_cursor @curwin)))) (non-eos? s) nil)
                ((ร s =) (.plus s (replace-push-mb s)))
            )
            (.be saved_line (:col (:w_cursor @curwin)), NUL)
        )

        ((ร Bytes p_extra =) nil)              ;; what goes to next line
        ((ร int first_char =) NUL)
        ((ร int extra_len =) 0)                  ;; length of "p_extra" string
        ((ร int saved_char =) NUL)

        (when (and (flag? @State INSERT) (non-flag? @State VREPLACE_FLAG))
            ((ร p_extra =) (.plus saved_line (:col (:w_cursor @curwin))))
            (when do_si              ;; need first char after new line break
                ((ร Bytes p =) (skipwhite p_extra))
                ((ร first_char =) (.at p 0))
            )
            ((ร extra_len =) (STRLEN p_extra))
            ((ร saved_char =) (.at p_extra 0))
            (eos! p_extra)
        )

        (u-clearline)              ;; cannot do "U" command when adding lines
        (reset! did_si false)
        (reset! ai_col 0)

        ;; If we just did an auto-indent, then we didn't type anything on the
        ;; prior line, and it should be truncated.  Do this even if 'ai' is not set
        ;; because automatically inserting a comment leader also sets did_ai.

        ((ร boolean trunc_line =) false)         ;; truncate current line afterwards
        (if (and (== dir FORWARD) @did_ai)
            ((ร trunc_line =) true)
        )

        ((ร pos_C old_cursor =) (NEW_pos_C))     ;; old cursor position

        ((ร int newindent =) 0)                  ;; auto-indent of the new line

        ;; If 'autoindent' and/or 'smartindent' is set, try to figure out what
        ;; indent to use for the new line.

        (when (or @(:b_p_ai @curbuf) do_si)
            ;; count white space on current line

            ((ร newindent =) (get-indent-str saved_line, (int @(:b_p_ts @curbuf))))
            (if (zero? newindent)
                ((ร newindent =) second_line_indent) ;; for ^^D command in insert mode
            )

            ;; Do smart indenting.
            ;; In insert/replace mode (only when dir == FORWARD)
            ;; we may move some text to the next line.  If it starts with '{'
            ;; don't add an indent.  Fixes inserting a NL before '{' in line
            ;;      "if (condition) {"

            (when (and (not trunc_line) do_si (non-eos? saved_line) (or (nil? p_extra) (!= first_char (byte \{))))
                (COPY-pos old_cursor, (:w_cursor @curwin))

                ((ร Bytes s =) saved_line)

                (cond (== dir FORWARD)
                (do
                    ;; Skip preprocessor directives, unless they are recognised as comments.

                    (when (== (.at s 0) (byte \#))
                        (while (and (== (.at s 0) (byte \#)) (< 1 (:lnum (:w_cursor @curwin))))
                            ((ร s =) (ml-get (ร --@curwin.w_cursor.lnum)))
                        )
                        ((ร newindent =) (get-indent))
                    )

                    ;; Find last non-blank in line.
                    ((ร Bytes p =) (.plus s (- (STRLEN s) 1)))
                    (while (and (BLT s, p) (vim-iswhite (.at p 0)))
                        ((ร p =) (.minus p 1))
                    )
                    ((ร byte last_char =) (.at p 0))

                    ;; find the character just before the '{' or ';'

                    (when (or (== last_char (byte \{)) (== last_char (byte \;)))
                        (if (BLT s, p)
                            ((ร p =) (.minus p 1))
                        )
                        (while (and (BLT s, p) (vim-iswhite (.at p 0)))
                            ((ร p =) (.minus p 1))
                        )
                    )

                    ;; Try to catch lines that are split over multiple
                    ;; lines.  eg:
                    ;;      if (condition &&
                    ;;                  condition) {
                    ;;          Should line up here!
                    ;;      }

                    (when (== (.at p 0) (byte \)))
                        ((ร @curwin.w_cursor.col =) (BDIFF p, s))
                        ((ร pos_C pos =) (findmatch nil, (byte \()))
                        (when (non-nil? pos)
                            ((ร @curwin.w_cursor.lnum =) (:lnum pos))
                            ((ร newindent =) (get-indent))
                            ((ร s =) (ml-get-curline))
                        )
                    )

                    ;; If last character is '{' do indent, without checking for "if" and the like.

                    (cond (== last_char (byte \{))
                    (do
                        (reset! did_si true)  ;; do indent
                        ((ร no_si =) true)   ;; don't delete it when '{' typed
                    )

                    ;; Look for "if" and the like, use 'cinwords'.
                    ;; Don't do this if the previous line ended in ';' or '}'.

                    (and (!= last_char (byte \;)) (!= last_char (byte \})) (cin-is-cinword s))
                    (do
                        (reset! did_si true)
                    ))
                )
                :else ;; dir == BACKWARD
                (do
                    ;; Skip preprocessor directives, unless they are recognised as comments.

                    (when (== (.at s 0) (byte \#))
                        ((ร boolean was_backslashed =) false)

                        (while (and (or (== (.at s 0) (byte \#)) was_backslashed) (< (:lnum (:w_cursor @curwin)) (:ml_line_count (:b_ml @curbuf))))
                            ((ร was_backslashed =) (and (non-eos? s) (== (.at s (- (STRLEN s) 1)) (byte \\))))
                            ((ร s =) (ml-get (ร ++@curwin.w_cursor.lnum)))
                        )
                        ((ร newindent =) (if was_backslashed 0 (get-indent)))
                    )

                    ((ร Bytes p =) (skipwhite s))
                    (if (== (.at p 0) (byte \}))
                        (reset! did_si true)                ;; if line starts with '}': do indent
                        (reset! can_si_back true))           ;; can delete indent when '{' typed
                ))

                (COPY-pos (:w_cursor @curwin), old_cursor)
            )
            (if do_si
                (reset! can_si true))

            (reset! did_ai true)
        )

        ((ร Bytes allocated =) nil)            ;; allocated memory

        ((ร Bytes[] lead_flags =) (ร new Bytes[1]))                  ;; position in 'comments' for comment leader
        ((ร Bytes leader =) nil)               ;; copy of comment leader

        ((ร int newcol =) 0)                     ;; new cursor column

        ((ร int less_cols_off =) 0)              ;; columns to skip for mark adjust
        ((ร int less_cols =) 0)                  ;; less columns for mark in new line

        ;; (State == INSERT || State == REPLACE), only when dir == FORWARD
        (when (non-nil? p_extra)
            (.be p_extra 0, saved_char)          ;; restore char that NUL replaced

            ;; When 'ai' set, skip to the first non-blank.
            ;;
            ;; When in REPLACE mode, put the deleted blanks on the replace stack,
            ;; preceded by a NUL, so they can be put back when a BS is entered.

            (if (and (flag? @State REPLACE_FLAG) (non-flag? @State VREPLACE_FLAG))
                (replace-push NUL))      ;; end of extra blanks
            (when @(:b_p_ai @curbuf)
                (while (and (or (== (.at p_extra 0) (byte \space)) (== (.at p_extra 0) TAB)) (not (utf-iscomposing (us-ptr2char (.plus p_extra 1)))))
                    (if (and (flag? @State REPLACE_FLAG) (non-flag? @State VREPLACE_FLAG))
                        (replace-push (.at p_extra 0)))
                    ((ร p_extra =) (.plus p_extra 1))
                    (ร less_cols_off++)
                )
            )
            (if (non-eos? p_extra)
                (reset! did_ai false))             ;; append some text, don't truncate now

            ;; columns for marks adjusted for removed columns
            ((ร less_cols =) (BDIFF p_extra, saved_line))
        )

        (if (nil? p_extra)
            ((ร p_extra =) (u8 ""))                   ;; append empty line
        )

        (COPY-pos old_cursor, (:w_cursor @curwin))
        (if (== dir BACKWARD)
            (ร --@curwin.w_cursor.lnum)
        )

;       theend:
;       {
            (ร boolean did_append)
            (cond (or (non-flag? @State VREPLACE_FLAG) (<= @orig_line_count (:lnum old_cursor)))
            (do
                (if (not (ml-append (:lnum (:w_cursor @curwin)), p_extra))
                    (ร BREAK theend)
                )
                ;; Postpone calling changed-lines(), because it would mess up folding with markers.
                (mark-adjust (+ (:lnum (:w_cursor @curwin)) 1), MAXLNUM, 1, 0)
                ((ร did_append =) true)
            )
            :else
            (do
                ;; In VREPLACE mode we are starting to replace the next line.

                (ร @curwin.w_cursor.lnum++)
                (when (<= (+ (:lnum @insStart) @vr_lines_changed) (:lnum (:w_cursor @curwin)))
                    ;; In case we NL to a new line, BS to the previous one, and NL
                    ;; again, we don't want to save the new line for undo twice.

                    (u-save-cursor)            ;; errors are ignored!
                    (swap! vr_lines_changed inc)
                )
                (ml-replace (:lnum (:w_cursor @curwin)), p_extra)
                (changed-bytes (:lnum (:w_cursor @curwin)), 0)
                (ร --@curwin.w_cursor.lnum)
                ((ร did_append =) false)
            ))

            (when (or (non-zero? newindent) @did_si)
                (ร @curwin.w_cursor.lnum++)
                (when @did_si
                    ((ร int sw =) (int (get-sw-value @curbuf)))

                    (if @p_sr
                        ((ร newindent =) (- newindent (% newindent sw)))
                    )
                    ((ร newindent =) (+ newindent sw))
                )
                ;; Copy the indent.
                (cond @(:b_p_ci @curbuf)
                (do
                    (copy-indent newindent, saved_line)

                    ;; Set the 'preserveindent' option so that any further screwing
                    ;; with the line doesn't entirely destroy our efforts to preserve it.
                    ;; It gets restored at the function end.

                    ((ร @curbuf.@b_p_pi =) true)
                )
                :else
                (do
                    (set-indent newindent, SIN_INSERT)
                ))
                ((ร less_cols =) (- less_cols (:col (:w_cursor @curwin))))

                (reset! ai_col (:col (:w_cursor @curwin)))

                ;; In REPLACE mode, for each character in the new indent, there must
                ;; be a NUL on the replace stack, for when it is deleted with BS.

                (when (and (flag? @State REPLACE_FLAG) (non-flag? @State VREPLACE_FLAG))
                    ((ร FOR) (ร ((ร int n =) 0) (< n (:col (:w_cursor @curwin))) (ร n++))
                        (replace-push NUL)
                    )
                )
                ((ร newcol =) (+ newcol (:col (:w_cursor @curwin))))
                (if no_si
                    (reset! did_si false))
            )

            (COPY-pos (:w_cursor @curwin), old_cursor)

            (when (== dir FORWARD)
                (when (or trunc_line (flag? @State INSERT))
                    ;; truncate current line at cursor
                    (.be saved_line (:col (:w_cursor @curwin)), NUL)
                    ;; Remove trailing white space.
                    (if trunc_line
                        (truncate-spaces saved_line))
                    (ml-replace (:lnum (:w_cursor @curwin)), saved_line)
                    ((ร saved_line =) nil)
                    (cond did_append
                    (do
                        (changed-lines (:lnum (:w_cursor @curwin)), (:col (:w_cursor @curwin)), (+ (:lnum (:w_cursor @curwin)) 1), 1)
                        ((ร did_append =) false)
                    )
                    :else
                    (do
                        (changed-bytes (:lnum (:w_cursor @curwin)), (:col (:w_cursor @curwin)))
                    ))
                )

                ;; Put the cursor on the new line.
                ;; Careful: the scrollup() above may have moved w_cursor, we must use old_cursor.

                ((ร @curwin.w_cursor.lnum =) (+ (:lnum old_cursor) 1))
            )
            (if did_append
                (changed-lines (:lnum (:w_cursor @curwin)), 0, (:lnum (:w_cursor @curwin)), 1))

            ((ร @curwin.w_cursor.col =) newcol)
            ((ร @curwin.w_cursor.coladd =) 0)

            ;; In VREPLACE mode, we are handling the replace stack ourselves,
            ;; so stop fixthisline() from doing it (via change-indent()) by
            ;; telling it we're in normal INSERT mode.

            (ร int vreplace_mode)
            (cond (flag? @State VREPLACE_FLAG)
            (do
                ((ร vreplace_mode =) @State)          ;; so we know to put things right later
                (reset! State INSERT)
            )
            :else
            (do
                ((ร vreplace_mode =) 0)
            ))

            (if (non-zero? vreplace_mode)
                (reset! State vreplace_mode))

            ;; Finally, VREPLACE gets the stuff on the new line, then puts back the
            ;; original line, and inserts the new stuff char by char, pushing old stuff
            ;; onto the replace stack (via ins-char()).

            (when (flag? @State VREPLACE_FLAG)
                ;; Put new line in "p_extra".
                ((ร p_extra =) (STRDUP (ml-get-curline)))

                ;; Put back original line.
                (ml-replace (:lnum (:w_cursor @curwin)), next_line)

                ;; Insert new stuff into line again.
                ((ร @curwin.w_cursor.col =) 0)
                ((ร @curwin.w_cursor.coladd =) 0)
                (ins-bytes p_extra)             ;; will call changed-bytes()
                ((ร next_line =) nil)
            )

            ((ร retval =) true)              ;; success!
;       }

        ((ร @curbuf.@b_p_pi =) saved_pi)
        retval
    ))

;; Return the number of window lines occupied by buffer line "lnum".

(defn- #_int plines [#_long lnum]
    (plines-win @curwin, lnum, true))

(defn- #_int plines-win [#_window_C wp, #_long lnum, #_boolean winheight]
    ;; winheight: when true limit to window height
    (ยง
        (if (not @(:wo_wrap (:w_options wp)))
            ((ร RETURN) 1)
        )

        (if (zero? (:w_width wp))
            ((ร RETURN) 1)
        )

        ((ร int lines =) (plines-win-nofold wp, lnum))
        (if (and winheight (< (:w_height wp) lines))
            ((ร RETURN) (:w_height wp))
        )

        lines
    ))

;; Return number of window lines physical line "lnum" will occupy in window "wp".
;; Does not care about folding, 'wrap' or 'diff'.

(defn- #_int plines-win-nofold [#_window_C wp, #_long lnum]
    (ยง
        ((ร Bytes s =) (ml-get-buf @curbuf, lnum))
        (if (eos? s)     ;; empty line
            ((ร RETURN) 1)
        )

        ((ร int col =) (win-linetabsize wp, s, MAXCOL))

        ;; Add column offset for 'number', 'relativenumber' and 'foldcolumn'.

        ((ร int width =) (- (:w_width wp) (win-col-off wp)))
        (if (<= width 0)
            ((ร RETURN) 32000)
        )

        (if (<= col width)
            ((ร RETURN) 1)
        )

        ((ร col =) (- col width))
        ((ร width =) (+ width (win-col-off2 wp)))
        (+ (/ (+ col (dec width)) width) 1)
    ))

;; Like plines-win(), but only reports the number of physical screen lines
;; used from the start of the line to the given column number.

(defn- #_int plines-win-col [#_window_C wp, #_long lnum, #_long column]
    (ยง
        ((ร int lines =) 0)

        (if (not @(:wo_wrap (:w_options wp)))
            ((ร RETURN) (inc lines))
        )

        (if (zero? (:w_width wp))
            ((ร RETURN) (inc lines))
        )

        ((ร Bytes line =) (ml-get-buf @curbuf, lnum))
        ((ร Bytes s =) line)

        ((ร long col =) 0)
        (while (and (non-eos? s) (<= 0 (ร --column)))
            ((ร col =) (+ col (win-lbr-chartabsize wp, line, s, (int col), nil)))
            ((ร s =) (.plus s (us-ptr2len-cc s)))
        )

        ;; If s[0] is a TAB, and the TAB is not displayed as ^I, and we're not in INSERT mode,
        ;; then col must be adjusted so that it represents the last screen position of the TAB.
        ;; This only fixes an error when the TAB wraps from one screen line to the next
        ;; (when 'columns' is not a multiple of 'ts').

        (if (and (== (.at s 0) TAB) (flag? @State NORMAL))
            ((ร col =) (+ col (- (win-lbr-chartabsize wp, line, s, (int col), nil) 1)))
        )

        ;; Add column offset for 'number', 'relativenumber', 'foldcolumn', etc.

        ((ร int width =) (- (:w_width wp) (win-col-off wp)))
        (if (<= width 0)
            ((ร RETURN) 9999)
        )

        ((ร lines =) (+ lines 1))
        (if (< width col)
            ((ร lines =) (+ lines (+ (/ (- col width) (+ width (win-col-off2 wp))) 1)))
        )
        lines
    ))

(defn- #_int plines-m-win [#_window_C wp, #_long first, #_long last]
    (ยง
        ((ร int count =) 0)

        (while (<= first last)
            ((ร count =) (+ count (plines-win wp, first, true)))
            (ร first++)
        )

        count
    ))

;; Insert string "p" at the cursor position.  Stops at a NUL byte.
;; Handles Replace mode and multi-byte characters.

(defn- #_void ins-bytes [#_Bytes p]
    (ins-bytes-len p, (STRLEN p))
    nil)

;; Insert string "p" with length "len" at the cursor position.
;; Handles Replace mode and multi-byte characters.

(defn- #_void ins-bytes-len [#_Bytes p, #_int len]
    (ยง
        ((ร FOR) (ร ((ร int i =) (ร 0, n)) (< i len) ((ร i =) (+ i n)))
            ;; avoid reading past p[len]
            ((ร n =) (us-ptr2len-cc-len (.plus p i), (- len i)))
            (ins-char-bytes (.plus p i), n)
        )
        nil
    ))

;; Insert or replace a single character at the cursor position.
;; When in REPLACE or VREPLACE mode, replace any existing character.
;; Caller must have prepared for undo.
;; For multi-byte characters we get the whole character,
;; the caller must convert bytes to a character.

(defn- #_void ins-char [#_int c]
    (ยง
        ((ร Bytes buf =) (Bytes. (inc MB_MAXBYTES)))
        ((ร int n =) (utf-char2bytes c, buf))

        ;; When "c" is 0x100, 0x200, etc. we don't want to insert a NUL byte.
        ;; Happens for CTRL-Vu9900.
        (if (zero? (.at buf 0))
            (.be buf 0, (byte \newline))
        )

        (ins-char-bytes buf, n)
        nil
    ))

(defn- #_void ins-char-bytes [#_Bytes buf, #_int charlen]
    (ยง
        ((ร long lnum =) (:lnum (:w_cursor @curwin)))

        ;; Break tabs if needed.
        (if (and (virtual-active) (< 0 (:coladd (:w_cursor @curwin))))
            (coladvance-force (getviscol)))

        ((ร int col =) (:col (:w_cursor @curwin)))
        ((ร Bytes oldp =) (ml-get lnum))
        ((ร int linelen =) (+ (STRLEN oldp) 1))        ;; length of old line including NUL

        ;; The lengths default to the values for when not replacing.
        ((ร int oldlen =) 0)                             ;; nr of bytes deleted (0 when not replacing)
        ((ร int newlen =) charlen)                       ;; nr of bytes inserted

        (when (flag? @State REPLACE_FLAG)
            (cond (flag? @State VREPLACE_FLAG)
            (do
                ;; In virtual replace mode each character may replace one or more
                ;; characters (zero if it's a TAB).  Count the number of bytes to
                ;; be deleted to make room for the new character, counting screen
                ;; cells.  May result in adding spaces to fill a gap.

                ((ร int[] vcol =) (ร new int[1]))
                (getvcol @curwin, (:w_cursor @curwin), nil, vcol, nil)

                ((ร int new_vcol =) (+ (... vcol 0) (chartabsize buf, (... vcol 0))))
                (while (and (!= (.at oldp (+ col oldlen)) NUL) (< (... vcol 0) new_vcol))
                    ((ร vcol[0] =) (+ (... vcol 0) (chartabsize (.plus oldp (+ col oldlen)), (... vcol 0))))
                    ;; Don't need to remove a TAB that takes us to the right position.
                    (if (and (< new_vcol (... vcol 0)) (== (.at oldp (+ col oldlen)) TAB))
                        (ร BREAK)
                    )
                    ((ร oldlen =) (+ oldlen (us-ptr2len-cc (.plus oldp (+ col oldlen)))))
                    ;; Deleted a bit too much, insert spaces.
                    (if (< new_vcol (... vcol 0))
                        ((ร newlen =) (+ newlen (- (... vcol 0) new_vcol)))
                    )
                )
            )
            (non-eos? oldp col)
            (do
                ;; normal replace
                ((ร oldlen =) (us-ptr2len-cc (.plus oldp col)))
            ))

            ;; Push the replaced bytes onto the replace stack, so that they can be
            ;; put back when BS is used.  The bytes of a multi-byte character are
            ;; done the other way around, so that the first byte is popped off
            ;; first (it tells the byte length of the character).
            (replace-push NUL)
            ((ร FOR) (ร ((ร int i =) 0) (< i oldlen) (ร i++))
                ((ร i =) (+ i (dec (replace-push-mb (.plus oldp (+ col i))))))
            )
        )

        ((ร Bytes newp =) (Bytes. (- (+ linelen newlen) oldlen)))

        ;; Copy bytes before the cursor.
        (if (< 0 col)
            (BCOPY newp, oldp, col))

        ;; Copy bytes after the changed character(s).
        ((ร Bytes p =) (.plus newp col))
        (BCOPY p, newlen, oldp, (+ col oldlen), (- linelen col oldlen))

        ;; Insert or overwrite the new character.
        (BCOPY p, buf, charlen)
        ((ร int i =) charlen)

        ;; Fill with spaces when necessary.
        (while (< i newlen)
            (.be p (ร i++), (byte \space))
        )

        ;; Replace the line in the buffer.
        (ml-replace lnum, newp)

        ;; mark the buffer as changed and prepare for displaying
        (changed-bytes lnum, col)

        ;; If we're in Insert or Replace mode and 'showmatch' is set,
        ;; then briefly show the match for right parens and braces.

        (when (and @p_sm (flag? @State INSERT))
            (showmatch (us-ptr2char buf))
        )

        ;; Normal insert: move cursor right.
        ((ร @curwin.w_cursor.col =) (+ (:col (:w_cursor @curwin)) charlen))

        ;; TODO: should try to update w_row here, to avoid recomputing it later.

        nil
    ))

;; Insert a string at the cursor position.
;; Note: Does NOT handle Replace mode.
;; Caller must have prepared for undo.

(defn- #_void ins-str [#_Bytes s]
    (ยง
        ((ร int newlen =) (STRLEN s))
        ((ร long lnum =) (:lnum (:w_cursor @curwin)))

        (if (and (virtual-active) (< 0 (:coladd (:w_cursor @curwin))))
            (coladvance-force (getviscol)))

        ((ร int col =) (:col (:w_cursor @curwin)))
        ((ร Bytes oldp =) (ml-get lnum))
        ((ร int oldlen =) (STRLEN oldp))

        ((ร Bytes newp =) (Bytes. (+ oldlen newlen 1)))

        (if (< 0 col)
            (BCOPY newp, oldp, col))
        (BCOPY newp, col, s, 0, newlen)
        (BCOPY newp, (+ col newlen), oldp, col, (+ (- oldlen col) 1))
        (ml-replace lnum, newp)
        (changed-bytes lnum, col)
        ((ร @curwin.w_cursor.col =) (+ (:col (:w_cursor @curwin)) newlen))
        nil
    ))

;; Delete one character under the cursor.
;; If "fixpos" is true, don't leave the cursor on the NUL after the line.
;; Caller must have prepared for undo.
;;
;; Return false for failure, true otherwise.

(defn- #_boolean del-char [#_boolean fixpos]
    (ยง
        ;; Make sure the cursor is at the start of a character.
        (mb-adjust-pos @curbuf, (:w_cursor @curwin))
        (if (eos? (ml-get-cursor))
            ((ร RETURN) false)
        )

        (del-chars 1, fixpos)
    ))

;; Like del-bytes(), but delete characters instead of bytes.

(defn- #_boolean del-chars [#_int count, #_boolean fixpos]
    (ยง
        ((ร int bytes =) 0)

        ((ร Bytes p =) (ml-get-cursor))
        ((ร FOR) (ร ((ร int i =) 0) (and (< i count) (non-eos? p)) (ร i++))
            ((ร int l =) (us-ptr2len-cc p))
            ((ร bytes =) (+ bytes l))
            ((ร p =) (.plus p l))
        )

        (del-bytes bytes, fixpos, true)
    ))

;; Delete "count" bytes under the cursor.
;; If "fixpos" is true, don't leave the cursor on the NUL after the line.
;; Caller must have prepared for undo.
;;
;; return false for failure, true otherwise

(defn- #_boolean del-bytes [#_int count, #_boolean fixpos, #_boolean use_delcombine]
    ;; use_delcombine: 'delcombine' option applies
    (ยง
        ((ร long lnum =) (:lnum (:w_cursor @curwin)))
        ((ร int col =) (:col (:w_cursor @curwin)))

        ((ร Bytes oldp =) (ml-get lnum))
        ((ร int oldlen =) (STRLEN oldp))

        ;; Can't do anything when the cursor is on the NUL after the line.

        (if (<= oldlen col)
            ((ร RETURN) false)
        )

        ;; If 'delcombine' is set and deleting (less than) one character,
        ;; only delete the last combining character.
        (when (and @p_deco use_delcombine (<= count (us-ptr2len-cc (.plus oldp col))))
            ((ร int[] cc =) (ร new int[MAX_MCO]))

            (us-ptr2char-cc (.plus oldp col), cc)
            (when (!= (... cc 0) NUL)
                ;; Find the last composing char, there can be several.
                ((ร int n =) col)
;               do
;               {
                    ((ร col =) n)
                    ((ร count =) (us-ptr2len (.plus oldp n)))
                    ((ร n =) (+ n count))
;               } while (utf-iscomposing(us-ptr2char(oldp.plus(n))));
                ((ร fixpos =) false)
            )
        )

        ;; When count is too big, reduce it.

        ((ร int movelen =) (+ (- oldlen col count) 1)) ;; includes trailing NUL
        (when (<= movelen 1)
            ;; If we just took off the last character of a non-blank line, and
            ;; fixpos is true, we don't want to end up positioned at the NUL,
            ;; unless "restart_edit" is set or 'virtualedit' contains "onemore".

            (when (and (< 0 col) fixpos (zero? @restart_edit) (non-flag? @ve_flags VE_ONEMORE))
                (ร --@curwin.w_cursor.col)
                ((ร @curwin.w_cursor.coladd =) 0)
                ((ร @curwin.w_cursor.col =) (- (:col (:w_cursor @curwin)) (us-head-off oldp, (.plus oldp (:col (:w_cursor @curwin))))))
            )
            ((ร count =) (- oldlen col))
            ((ร movelen =) 1)
        )

        ((ร Bytes newp =) (Bytes. (- (inc oldlen) count)))
        (BCOPY newp, oldp, col)
        (BCOPY newp, col, oldp, (+ col count), movelen)
        (ml-replace lnum, newp)

        ;; mark the buffer as changed and prepare for displaying
        (changed-bytes lnum, (:col (:w_cursor @curwin)))

        true
    ))

;; Delete from cursor to end of line.
;; Caller must have prepared for undo.

(defn- #_void truncate-line [#_boolean fixpos]
    ;; fixpos: if true fix the cursor position when done
    (ยง
        ((ร long lnum =) (:lnum (:w_cursor @curwin)))
        ((ร int col =) (:col (:w_cursor @curwin)))

        ((ร Bytes newp =) (if (zero? col) (STRDUP (u8 "")) (STRNDUP (ml-get lnum), col)))

        (ml-replace lnum, newp)

        ;; mark the buffer as changed and prepare for displaying
        (changed-bytes lnum, (:col (:w_cursor @curwin)))

        ;; If "fixpos" is true we don't want to end up positioned at the NUL.

        (when (and fixpos (< 0 (:col (:w_cursor @curwin))))
            (ร --@curwin.w_cursor.col)
        )
        nil
    ))

;; Delete "nlines" lines at the cursor.
;; Saves the lines for undo first if "undo" is true.

(defn- #_void del-lines [#_long nlines, #_boolean undo]
    ;; nlines: number of lines to delete
    ;; undo: if true, prepare for undo
    (ยง
        ((ร long first =) (:lnum (:w_cursor @curwin)))

        (if (<= nlines 0)
            ((ร RETURN) nil)
        )

        ;; save the deleted lines for undo
        (if (and undo (not (u-savedel first, nlines)))
            ((ร RETURN) nil)
        )

        (ร long n)
        ((ร FOR) (ร ((ร n =) 0) (< n nlines) nil)
            (if (non-zero? (& (:ml_flags (:b_ml @curbuf)) ML_EMPTY)) ;; nothing to delete
                (ร BREAK)
            )

            (ml-delete first, true)
            (ร n++)

            ;; If we delete the last line in the file, stop.
            (if (< (:ml_line_count (:b_ml @curbuf)) first)
                (ร BREAK)
            )
        )

        ;; Correct the cursor position before calling deleted-lines-mark(),
        ;; it may trigger a callback to display the cursor.
        ((ร @curwin.w_cursor.col =) 0)
        (check-cursor-lnum)

        ;; Adjust marks, mark the buffer as changed and prepare for displaying.
        (deleted-lines-mark first, n)
        nil
    ))

(defn- #_int gchar-pos [#_pos_C pos]
    (ยง
        ((ร Bytes ptr =) (ml-get-pos pos))

        (us-ptr2char ptr)
    ))

(defn- #_int gchar-cursor []
    (us-ptr2char (ml-get-cursor)))

;; When extra == 0: Return true if the cursor is before or on the first non-blank in the line.
;; When extra == 1: Return true if the cursor is before the first non-blank in the line.

(defn- #_boolean inindent [#_int extra]
    (ยง
        ((ร int col =) 0)

        ((ร FOR) (ร ((ร Bytes p =) (ml-get-curline)) (vim-iswhite (.at p 0)) (ร col++))
            ((ร p =) (.plus p 1))
        )

        (<= (+ (:col (:w_cursor @curwin)) extra) col)
    ))

;; Skip to next part of an option argument: Skip space and comma.

(defn- #_Bytes skip-to-option-part [#_Bytes p]
    (ยง
        (if (== (.at p 0) (byte \,))
            ((ร p =) (.plus p 1))
        )
        (while (== (.at p 0) (byte \space))
            ((ร p =) (.plus p 1))
        )
        p
    ))

;; Call this function when something in the current buffer is changed.
;;
;; Most often called through changed-bytes() and changed-lines(),
;; which also mark the area of the display to be redrawn.

(defn- #_void changed []
    (ยง
        (when (not @(:b_changed @curbuf))
            ((ร @curbuf.@b_changed =) true)
            (check-status @curbuf)
        )
        (ร @curbuf.b_changedtick++)
        nil
    ))

;; Changed bytes within a single line for the current buffer.
;; - marks the windows on this buffer to be redisplayed
;; - marks the buffer changed by calling changed()
;; - invalidates cached values

(defn- #_void changed-bytes [#_long lnum, #_int col]
    (changed-one-line @curbuf, lnum)
    (changed-common lnum, col, (inc lnum), 0)
    nil)

(defn- #_void changed-one-line [#_buffer_C buf, #_long lnum]
    (ยง
        (cond (:b_mod_set buf)
        (do
            ;; find the maximum area that must be redisplayed
            (cond (< lnum (:b_mod_top buf))
            (do
                ((ร buf.b_mod_top =) lnum)
            )
            (<= (:b_mod_bot buf) lnum)
            (do
                ((ร buf.b_mod_bot =) (inc lnum))
            ))
        )
        :else
        (do
            ;; set the area that must be redisplayed to one line
            ((ร buf.b_mod_set =) true)
            ((ร buf.b_mod_top =) lnum)
            ((ร buf.b_mod_bot =) (inc lnum))
            ((ร buf.b_mod_xlines =) 0)
        ))
        nil
    ))

;; Appended "count" lines below line "lnum" in the current buffer.
;; Must be called AFTER the change and after mark-adjust().
;; Takes care of marking the buffer to be redrawn and sets the changed flag.

(defn- #_void appended-lines [#_long lnum, #_long count]
    (changed-lines (inc lnum), 0, (inc lnum), count)
    nil)

;; Like appended-lines(), but adjust marks first.

(defn- #_void appended-lines-mark [#_long lnum, #_long count]
    (mark-adjust (inc lnum), MAXLNUM, count, 0)
    (changed-lines (inc lnum), 0, (inc lnum), count)
    nil)

;; Deleted "count" lines at line "lnum" in the current buffer.
;; Must be called AFTER the change and after mark-adjust().
;; Takes care of marking the buffer to be redrawn and sets the changed flag.

(defn- #_void deleted-lines [#_long lnum, #_long count]
    (changed-lines lnum, 0, (+ lnum count), (- count))
    nil)

;; Like deleted-lines(), but adjust marks first.
;; Make sure the cursor is on a valid line before calling,
;; a GUI callback may be triggered to display the cursor.

(defn- #_void deleted-lines-mark [#_long lnum, #_long count]
    (mark-adjust lnum, (dec (+ lnum count)), MAXLNUM, (- count))
    (changed-lines lnum, 0, (+ lnum count), (- count))
    nil)

;; Changed lines for the current buffer.
;; Must be called AFTER the change and after mark-adjust().
;; - mark the buffer changed by calling changed()
;; - mark the windows on this buffer to be redisplayed
;; - invalidate cached values
;; "lnum" is the first line that needs displaying,
;; "lnume" the first line below the changed lines (BEFORE the change).
;; When only inserting lines, "lnum" and "lnume" are equal.
;; Takes care of calling changed() and updating b_mod_*.

(defn- #_void changed-lines [#_long lnum, #_int col, #_long lnume, #_long xtra]
    ;; lnum: first line with change
    ;; col: column in first line with change
    ;; lnume: line below last changed line
    ;; xtra: number of extra lines (negative when deleting)
    (changed-lines-buf @curbuf, lnum, lnume, xtra)
    (changed-common lnum, col, lnume, xtra)
    nil)

(defn- #_void changed-lines-buf [#_buffer_C buf, #_long lnum, #_long lnume, #_long xtra]
    ;; lnum: first line with change
    ;; lnume: line below last changed line
    ;; xtra: number of extra lines (negative when deleting)
    (ยง
        (cond (:b_mod_set buf)
        (do
            ;; find the maximum area that must be redisplayed
            (if (< lnum (:b_mod_top buf))
                ((ร buf.b_mod_top =) lnum)
            )
            (when (< lnum (:b_mod_bot buf))
                ;; adjust old bot position for xtra lines
                ((ร buf.b_mod_bot =) (+ (:b_mod_bot buf) xtra))
                (if (< (:b_mod_bot buf) lnum)
                    ((ร buf.b_mod_bot =) lnum)
                )
            )
            (if (< (:b_mod_bot buf) (+ lnume xtra))
                ((ร buf.b_mod_bot =) (+ lnume xtra))
            )
            ((ร buf.b_mod_xlines =) (+ (:b_mod_xlines buf) xtra))
        )
        :else
        (do
            ;; set the area that must be redisplayed
            ((ร buf.b_mod_set =) true)
            ((ร buf.b_mod_top =) lnum)
            ((ร buf.b_mod_bot =) (+ lnume xtra))
            ((ร buf.b_mod_xlines =) xtra)
        ))
        nil
    ))

;; Common code for when a change is was made.
;; See changed-lines() for the arguments.

(defn- #_void changed-common [#_long lnum, #_int col, #_long lnume, #_long xtra]
    (ยง
        ;; mark the buffer as modified
        (changed)

        ;; set the '. mark
;       {
            ((ร @curbuf.b_last_change.lnum =) lnum)
            ((ร @curbuf.b_last_change.col =) col)

            ;; Create a new entry if a new undo-able change was started
            ;; or we don't have an entry yet.
            (when (or (:b_new_change @curbuf) (zero? (:b_changelistlen @curbuf)))
                (ร boolean add)
                (cond (zero? (:b_changelistlen @curbuf))
                (do
                    ((ร add =) true)
                )
                :else
                (do
                    ;; Don't create a new entry when the line number is the
                    ;; same as the last one and the column is not too far away.
                    ;; Avoids creating many entries for typing "xxxxx".
                    ((ร pos_C p =) (... (:b_changelist @curbuf) (- (:b_changelistlen @curbuf) 1)))
                    (cond (!= (:lnum p) lnum)
                    (do
                        ((ร add =) true)
                    )
                    :else
                    (do
                        ((ร int cols =) 79)
                        ((ร add =) (or (< (+ (:col p) cols) col) (< (+ col cols) (:col p))))
                    ))
                ))

                (when add
                    ;; This is the first of a new sequence of undo-able changes
                    ;; and it's at some distance of the last change.  Use a new
                    ;; position in the changelist.
                    ((ร @curbuf.b_new_change =) false)

                    (when (== (:b_changelistlen @curbuf) JUMPLISTSIZE)
                        ;; changelist is full: remove oldest entry
                        ((ร @curbuf.b_changelistlen =) (dec JUMPLISTSIZE))
                        (dotimes [#_int i (dec JUMPLISTSIZE)]
                            (COPY-pos (... (:b_changelist @curbuf) i), (... (:b_changelist @curbuf) (inc i)))
                        )
                        ((ร FOR) (ร ((ร window_C wp =) @firstwin) (non-nil? wp) ((ร wp =) (:w_next wp)))
                            ;; Correct position in changelist for other windows on this buffer.
                            (if (< 0 (:w_changelistidx wp))
                                (ร --wp.w_changelistidx)
                            )
                        )
                    )

                    ((ร FOR) (ร ((ร window_C wp =) @firstwin) (non-nil? wp) ((ร wp =) (:w_next wp)))
                        ;; For other windows, if the position in the changelist is at the end,
                        ;; it stays at the end.
                        (if (== (:w_changelistidx wp) (:b_changelistlen @curbuf))
                            (ร wp.w_changelistidx++)
                        )
                    )

                    (ร @curbuf.b_changelistlen++)
                )
            )
            (COPY-pos (... (:b_changelist @curbuf) (- (:b_changelistlen @curbuf) 1)), (:b_last_change @curbuf))
            ;; The current window is always after the last change, so that "g," takes you back to it.
            ((ร @curwin.w_changelistidx =) (:b_changelistlen @curbuf))
;       }

        ((ร FOR) (ร ((ร window_C wp =) @firstwin) (non-nil? wp) ((ร wp =) (:w_next wp)))
            ;; Mark this window to be redrawn later.
            (if (< (:w_redr_type wp) VALID)
                ((ร wp.w_redr_type =) VALID)
            )

            ;; Check if a change in the buffer has invalidated the cached values for the cursor.
            (cond (< lnum (:lnum (:w_cursor wp)))
            (do
                (changed-line-abv-curs-win wp)
            )
            (and (== (:lnum (:w_cursor wp)) lnum) (<= col (:col (:w_cursor wp))))
            (do
                (changed-cline-bef-curs-win wp)
            ))

            (when (<= lnum (:w_botline wp))
                ;; Assume that botline doesn't change
                ;; (inserted lines make other lines scroll down below botline).
                (approximate-botline-win wp)
            )

            ;; Check if any w_lines[] entries have become invalid.
            ;; For entries below the change: Correct the lnums for inserted/deleted lines.
            ;; Makes it possible to stop displaying after the change.
            (dotimes [#_int i (:w_lines_valid wp)]
                (when (and (:wl_valid (... (:w_lines wp) i)) (<= lnum (:wl_lnum (... (:w_lines wp) i))))
                    (cond (< (:wl_lnum (... (:w_lines wp) i)) lnume)
                    (do
                        ;; line included in change
                        ((ร wp.w_lines[i].wl_valid =) false)
                    )
                    (non-zero? xtra)
                    (do
                        ;; line below change
                        ((ร wp.w_lines[i].wl_lnum =) (+ (:wl_lnum (... (:w_lines wp) i)) xtra))
                    ))
                )
            )

            ;; relative numbering may require updating more
            (if @(:wo_rnu (:w_options wp))
                (redraw-win-later wp, SOME_VALID))
        )

        ;; Call update-screen() later, which checks out what needs to be redrawn,
        ;; since it notices b_mod_set and then uses b_mod_*.
        (if (< @must_redraw VALID)
            (reset! must_redraw VALID))

        ;; When the cursor line is changed, always trigger CursorMoved.
        (when (and (<= lnum (:lnum (:w_cursor @curwin))) (< (:lnum (:w_cursor @curwin)) (+ lnume (if (< xtra 0) (- xtra) xtra))))
            ((ร @last_cursormoved.lnum =) 0)
        )
        nil
    ))

;; called when the changed flag must be reset for buffer 'buf'

(defn- #_void unchanged [#_buffer_C buf]
    (ยง
        (when @(:b_changed buf)
            ((ร buf.@b_changed =) false)
            (check-status buf)
        )
        (ร buf.b_changedtick++)
        nil
    ))

;; called when the status bars for buffer 'buf' need to be updated

(defn- #_void check-status [#_buffer_C buf]
    (ยง
        ((ร FOR) (ร ((ร window_C wp =) @firstwin) (non-nil? wp) ((ร wp =) (:w_next wp)))
            (when (and (== @curbuf buf) (non-zero? (:w_status_height wp)))
                ((ร wp.w_redr_status =) true)
                (if (< @must_redraw VALID)
                    (reset! must_redraw VALID))
            )
        )
        nil
    ))

;; Ask for a reply from the user, a 'y' or a 'n'.
;; No other characters are accepted, the message is repeated
;; until a valid reply is entered or CTRL-C is hit.
;; If direct is true, don't use vgetc() but ui-inchar(),
;; don't get characters from any buffers but directly from the user.
;;
;; Answer 'y' or 'n'.

(defn- #_int ask-yesno [#_Bytes q, #_boolean direct]
    (ยง
        ((ร int c =) (byte \space))

        ((ร int save_State =) @State)

        (if @exiting                ;; put terminal in raw mode for this question
            (settmode TMODE_RAW))

        (swap! no_wait_return inc)
        (reset! State CONFIRM)            ;; mouse behaves like with :confirm
        (swap! no_mapping inc)
        (swap! allow_keys inc)               ;; no mapping here, but recognize keys

        (while (and (!= c (byte \y)) (!= c (byte \n)))
            ;; same highlighting as for wait-return
            (smsg-attr (hl-attr HLF_R), (u8 "%s (y/n)?"), q)

            ((ร c =) (if direct (get-keystroke) (plain-vgetc)))
            (if (or (== c Ctrl_C) (== c ESC))
                ((ร c =) (byte \n))
            )

            (msg-putchar c)         ;; show what you typed
            (out-flush)
        )

        (swap! no_wait_return dec)
        (reset! State save_State)
        (swap! no_mapping dec)
        (swap! allow_keys dec)

        c
    ))

;; Get a key stroke directly from the user.
;; Ignores mouse clicks and scrollbar events, except a click for the left button (used at the more prompt).
;; Doesn't use vgetc(), because it syncs undo and eats mapped characters.
;; Disadvantage: typeahead is ignored.
;; Translates the interrupt character for unix to ESC.

(defn- #_int get-keystroke []
    (ยง
        (ร int c)

        ((ร Bytes buf =) nil)

        ((ร int buflen =) 150)
; %%    ((ร int[] len =) (ร { 0 }))
        ((ร int waited =) 0)

        (while true
            (cursor-on)
            (out-flush)

            ;; Leave some room for check-termcode() to insert a key code into (max 5 chars plus NUL).
            ;; And fix-input-buffer() can triple the number of bytes.
            ((ร int maxlen =) (/ (- buflen 6 (... len 0)) 3))
            (cond (nil? buf)
            (do
                ((ร buf =) (Bytes. buflen))
            )
            (< maxlen 10)
            (do
                ;; Need some more space.
                ;; This might happen when receiving a long escape sequence.
                ((ร buflen =) (+ buflen 100))
                ((ร Bytes p =) (Bytes. buflen))
                (BCOPY p, buf, (... len 0))
                ((ร buf =) p)
                ((ร maxlen =) (/ (- buflen 6 (... len 0)) 3))
            ))

            ;; First time: blocking wait.
            ;; Second time: wait up to 100ms for a terminal code to complete.
            ((ร int n =) (ui-inchar (.plus buf (... len 0)), maxlen, (if (zero? (... len 0)) -1 100), 0))
            (cond (< 0 n)
            (do
                ;; Replace zero by a special key code.
                ((ร n =) (fix-input-buffer (.plus buf (... len 0)), n))
                ((ร len[0] =) (+ (... len 0) n))
                ((ร waited =) 0)
            )
            (< 0 (... len 0))
            (do
                (ร waited++)                   ;; keep track of the waiting time
            ))

            ;; Incomplete termcode and not timed out yet: get more characters.
            ((ร n =) (check-termcode buf, buflen, len))
            (if (and (< n 0) (or (not @p_ttimeout) (< (* waited 100) (if (< @p_ttm 0) @p_tm @p_ttm))))
                (ร CONTINUE)
            )

            (when (== n KEYLEN_REMOVED)        ;; key code removed
                (when (and (non-zero? @must_redraw) (not @need_wait_return) (non-flag? @State CMDLINE))
                    ;; Redrawing was postponed, do it now.
                    (update-screen 0)
                    (setcursor)            ;; put cursor back where it belongs
                )
                (ร CONTINUE)
            )
            (if (< 0 n)                      ;; found a termcode: adjust length
                ((ร len[0] =) n)
            )
            (if (zero? (... len 0))                   ;; nothing typed yet
                (ร CONTINUE)
            )

            ;; Handle modifier and/or special key code.
            (when (== (.at buf 0) KB_SPECIAL)
                ((ร c =) (toSpecial (.at buf 1), (.at buf 2)))
                (when (or (== (.at buf 1) KS_MODIFIER) (== c K_IGNORE))
                    (if (== (.at buf 1) KS_MODIFIER)
                        (reset! mod_mask (char_u (.at buf 2))))
                    ((ร len[0] =) (- (... len 0) 3))
                    (if (< 0 (... len 0))
                        (BCOPY buf, 0, buf, 3, (... len 0)))
                    (ร CONTINUE)
                )
                (ร BREAK)
            )

            (if (< (... len 0) (mb-byte2len (char_u (.at buf 0))))
                (ร CONTINUE)                   ;; more bytes to get
            )

            (.be buf (if (<= buflen (... len 0)) (dec buflen) (... len 0)), NUL)
            ((ร c =) (us-ptr2char buf))

            (if (== c @intr_char)
                ((ร c =) ESC)
            )
            (ร BREAK)
        )

        c
    ))

(defn- #_void msgmore [#_long n]
    (ยง
        (if (not (messaging))        ;; 'lazyredraw' set, don't do messages now
            ((ร RETURN) nil)
        )

        ;; We don't want to overwrite another important message, but do overwrite
        ;; a previous "more lines" or "fewer lines" message, so that "5dd" and
        ;; then "put" reports the last action.

        (if (and (non-nil? @keep_msg) (not @keep_msg_more))
            ((ร RETURN) nil)
        )

        ((ร long pn =) (if (< 0 n) n (- n)))

        (when (< @p_report pn)
            ((ร Bytes msg_buf =) (Bytes. MSG_BUF_LEN))
            (cond (== pn 1)
            (do
                (vim-strncpy msg_buf, (if (< 0 n) (u8 "1 more line") (u8 "1 line less")), (dec MSG_BUF_LEN))
            )
            :else
            (do
;%%             (vim_snprintf msg_buf, MSG_BUF_LEN, (if (< 0 n) (u8 "%ld more lines") (u8 "%ld fewer lines")), pn)
            ))
            (if @got_int
                (vim-strcat msg_buf, (u8 " (Interrupted)"), MSG_BUF_LEN))
            (when (msg msg_buf)
                (set-keep-msg msg_buf, 0)
                (reset! keep_msg_more true)
            )
        )
        nil
    ))

;; flush map and typeahead buffers and give a warning for an error

(defn- #_void beep-flush []
    (flush-buffers false)
    (vim-beep)
    nil)

;; give a warning for an error

(defn- #_void vim-beep []
    (if @p_vb
        (out-str @T_VB)
        (out-char BELL))
    nil)

(defn- #_void prepare-to-exit []
    ;; Ignore SIGHUP, because a dropped connection causes a read error, which
    ;; makes Vim exit and then handling SIGHUP causes various reentrance problems.

;%% (.sigset libC SIGHUP, #_"/*SIG_IGN*/"nil)

    (windgoto (dec (int @Rows)), 0)

    ;; Switch terminal mode back now, so messages end up on the "normal"
    ;; screen (if there are two screens).

    (settmode TMODE_COOK)
    (stoptermcap)
    (out-flush)
    nil)

;; Preserve files and exit.
;; When called ioBuff must contain a message.
;; NOTE: This may be called from deathtrap() in a signal handler,
;; avoid unsafe functions, such as allocating memory.

(defn- #_void preserve-exit []
    (prepare-to-exit)

    (out-str @ioBuff)
    (screen-start)                 ;; don't know where cursor is now
    (out-flush)

    (out-str (u8 "Vim: Finished.\n"))

    (getout 1)
    nil)

;; Check for CTRL-C pressed, but only once in a while.
;; Should be used instead of ui-breakcheck() for functions that check for each line in the file.
;; Calling ui-breakcheck() each time takes too much time, because it can be a system call.

(final int BREAKCHECK_SKIP 32)

(atom! int      breakcheck_count)

(defn- #_void line-breakcheck []
    (ยง
        (when (<= BREAKCHECK_SKIP (ร ++@breakcheck_count))
            (reset! breakcheck_count 0)
            (ui-breakcheck)
        )
        nil
    ))

;; Like line-breakcheck() but check 10 times less often.

(defn- #_void fast-breakcheck []
    (ยง
        (when (<= (* BREAKCHECK_SKIP 10) (ร ++@breakcheck_count))
            (reset! breakcheck_count 0)
            (ui-breakcheck)
        )
        nil
    ))

;; Return true when need to go to Insert mode because of 'insertmode'.
;; Don't do this when still processing a command or a mapping.
;; Don't do this when inside a ":normal" command.

(defn- #_boolean goto-im []
    (and @p_im (stuff-empty)))

;; Return true if in the current mode we need to use virtual.

(defn- #_boolean virtual-active []
    ;; While an operator is being executed we return "virtual_op",
    ;; because VIsual_active has already been reset,
    ;; thus we can't check for "block" being used.
    (if (!= @virtual_op MAYBE)
        (!= @virtual_op FALSE)
        (or (== @ve_flags VE_ALL) (and (flag? @ve_flags VE_BLOCK) @VIsual_active (== @VIsual_mode Ctrl_V)) (and (flag? @ve_flags VE_INSERT) (flag? @State INSERT)))
    ))

;; Get the screen position of the cursor.

(defn- #_int getviscol []
    (ยง
        ((ร int[] x =) (ร new int[1]))
        (getvvcol @curwin, (:w_cursor @curwin), x, nil, nil)
        (... x 0)
    ))

;; Get the screen position of character col with a coladd in the cursor line.

(defn- #_int getviscol2 [#_int col, #_int coladd]
    (ยง
        ((ร pos_C pos =) (NEW_pos_C))
        ((ร pos.lnum =) (:lnum (:w_cursor @curwin)))
        ((ร pos.col =) col)
        ((ร pos.coladd =) coladd)

        ((ร int[] x =) (ร new int[1]))
        (getvvcol @curwin, pos, x, nil, nil)
        (... x 0)
    ))

;; Go to column "wcol", and add/insert white space as necessary to get the
;; cursor in that column.
;; The caller must have saved the cursor line for undo!

(defn- #_boolean coladvance-force [#_int wcol]
    (ยง
        ((ร boolean rc =) (coladvance2 (:w_cursor @curwin), true, false, wcol))

        (cond (== wcol MAXCOL)
        (do
            ((ร @curwin.w_valid =) (& (:w_valid @curwin) (bit-not VALID_VIRTCOL)))
        )
        :else
        (do
            ;; Virtcol is valid.
            ((ร @curwin.w_valid =) (| (:w_valid @curwin) VALID_VIRTCOL))
            ((ร @curwin.w_virtcol =) wcol)
        ))
        rc
    ))

;; Try to advance the Cursor to the specified screen column.
;; If virtual editing: fine tune the cursor position.
;; Note that all virtual positions off the end of a line should share
;; a curwin.w_cursor.col value (n.b. this is equal to STRLEN(line)),
;; beginning at coladd 0.
;;
;; return true if desired column is reached, false if not

(defn- #_boolean coladvance [#_int wcol]
    (ยง
        ((ร boolean rc =) (getvpos (:w_cursor @curwin), wcol))

        (cond (or (== wcol MAXCOL) (not rc))
        (do
            ((ร @curwin.w_valid =) (& (:w_valid @curwin) (bit-not VALID_VIRTCOL)))
        )
        (!= (.at (ml-get-cursor) 0) TAB)
        (do
            ;; Virtcol is valid when not on a TAB.
            ((ร @curwin.w_valid =) (| (:w_valid @curwin) VALID_VIRTCOL))
            ((ร @curwin.w_virtcol =) wcol)
        ))
        rc
    ))

;; Return in "pos" the position of the cursor advanced to screen column "wcol".
;; return true if desired column is reached, false if not

(defn- #_boolean getvpos [#_pos_C pos, #_int wcol]
    (coladvance2 pos, false, (virtual-active), wcol))

(defn- #_boolean coladvance2 [#_pos_C pos, #_boolean addspaces, #_boolean finetune, #_int wcol]
    ;; addspaces: change the text to achieve our goal?
    ;; finetune: change char offset for the exact column
    ;; wcol: column to move to
    (ยง
        ((ร int col =) 0)
        ((ร int csize =) 0)
; %%    ((ร int[] head =) (ร { 0 }))

        ((ร boolean one_more =) (or (flag? @State INSERT) (!= @restart_edit NUL) (and @VIsual_active (!= (.at @p_sel 0) (byte \o))) (and (flag? @ve_flags VE_ONEMORE) (< wcol MAXCOL))))

        ((ร Bytes line =) (ml-get-buf @curbuf, (:lnum pos)))

        (ร int idx)
        (cond (<= MAXCOL wcol)
        (do
            ((ร idx =) (+ (- (STRLEN line) 1) (if one_more 1 0)))
            ((ร col =) wcol)

            (when (and (or addspaces finetune) (not @VIsual_active))
                ((ร @curwin.w_curswant =) (+ (linetabsize line) (if one_more 1 0)))
                (if (< 0 (:w_curswant @curwin))
                    (ร --@curwin.w_curswant)
                )
            )
        )
        :else
        (do
            ((ร int width =) (- (:w_width @curwin) (win-col-off @curwin)))

            (when (and finetune @(:wo_wrap (:w_options @curwin)) (non-zero? (:w_width @curwin)) (<= width wcol))
                ((ร csize =) (linetabsize line))
                (if (< 0 csize)
                    (ร csize--)
                )

                (when (and (< (/ csize width) (/ wcol width)) (or (non-flag? @State INSERT) (< (inc csize) wcol)))
                    ;; In case of line wrapping don't move the cursor beyond the
                    ;; right screen edge.  In Insert mode allow going just beyond
                    ;; the last character (like what happens when typing and
                    ;; reaching the right window edge).
                    ((ร wcol =) (- (* (+ (/ csize width) 1) width) 1))
                )
            )

            ((ร Bytes ptr =) line)
            (while (and (<= col wcol) (non-eos? ptr))
                ;; Count a tab for what it's worth (if list mode not on).
                ((ร csize =) (win-lbr-chartabsize @curwin, line, ptr, col, head))
                ((ร ptr =) (.plus ptr (us-ptr2len-cc ptr)))
                ((ร col =) (+ col csize))
            )
            ((ร idx =) (BDIFF ptr, line))

            ;; Handle all the special cases.  The virtual-active() check
            ;; is needed to ensure that a virtual position off the end of
            ;; a line has the correct indexing.  The one_more comparison
            ;; replaces an explicit add of one_more later on.

            (when (or (< wcol col) (and (not (virtual-active)) (not one_more)))
                ((ร idx =) (- idx 1))
                ;; Don't count the chars from 'showbreak'.
                ((ร csize =) (- csize (... head 0)))
                ((ร col =) (- col csize))
            )

            (when (and (virtual-active) addspaces (or (and (!= col wcol) (!= col (inc wcol))) (< 1 csize)))
                ;; 'virtualedit' is set: The difference between wcol and col is filled with spaces.

                (cond (eos? line idx)
                (do
                    ;; Append spaces.
                    ((ร int correct =) (- wcol col))
                    ((ร Bytes newline =) (Bytes. (+ idx correct 1)))

                    (dotimes [#_int t idx]
                        (.be newline t, (.at line t))
                    )

                    (dotimes [#_int t correct]
                        (.be newline (+ t idx), (byte \space))
                    )

                    (.be newline (+ idx correct), NUL)

                    (ml-replace (:lnum pos), newline)
                    (changed-bytes (:lnum pos), idx)
                    ((ร idx =) (+ idx correct))
                    ((ร col =) wcol)
                )
                :else
                (do
                    ;; Break a tab.
                    ((ร int linelen =) (STRLEN line))
                    ((ร int correct =) (+ (- wcol col csize) 1)) ;; negative!!

                    (if (< csize (- correct))
                        ((ร RETURN) false)
                    )

                    ((ร Bytes newline =) (Bytes. (+ linelen csize)))

                    ((ร int s =) 0)
                    (dotimes [#_int t linelen]
                        (cond (!= t idx)
                        (do
                            (.be newline (ร s++), (.at line t))
                        )
                        :else
                        (do
                            (dotimes [_ csize]
                                (.be newline (ร s++), (byte \space))
                            )
                        ))
                    )

                    (.be newline (- (+ linelen csize) 1), NUL)

                    (ml-replace (:lnum pos), newline)
                    (changed-bytes (:lnum pos), idx)
                    ((ร idx =) (+ idx (+ (dec csize) correct)))
                    ((ร col =) (+ col correct))
                ))
            )
        ))

        ((ร pos.col =) (if (< idx 0) 0 idx))
        ((ร pos.coladd =) 0)

        (when finetune
            (cond (== wcol MAXCOL)
            (do
                ;; The width of the last character is used to set coladd.
                (when (not one_more)
                    ((ร int[] scol =) (ร new int[1]))
                    ((ร int[] ecol =) (ร new int[1]))

                    (getvcol @curwin, pos, scol, nil, ecol)
                    ((ร pos.coladd =) (- (... ecol 0) (... scol 0)))
                )
            )
            :else
            (do
                ((ร int b =) (- wcol col))

                ;; The difference between wcol and col is used to set coladd.
                (if (and (< 0 b) (< b (- MAXCOL (* 2 (:w_width @curwin)))))
                    ((ร pos.coladd =) b)
                )

                ((ร col =) (+ col b))
            ))
        )

        ;; prevent from moving onto a trail byte
        (mb-adjust-pos @curbuf, pos)

        (not (< col wcol))
    ))

;; Increment the cursor position.  See incp() for return values.

(defn- #_int inc-cursor []
    (incp (:w_cursor @curwin)))

;; Increment the line pointer "lp" crossing line boundaries as necessary.
;; Return 1 when going to the next line.
;; Return 2 when moving forward onto a NUL at the end of the line.
;; Return -1 when at the end of file.
;; Return 0 otherwise.

(defn- #_int incp [#_pos_C lp]
    (ยง
        ((ร Bytes p =) (ml-get-pos lp))

        (when (non-eos? p)     ;; still within line, move to next char (may be NUL)
            ((ร int l =) (us-ptr2len-cc p))

            ((ร lp.col =) (+ (:col lp) l))
            ((ร RETURN) (if (non-eos? p l) 0 2))
        )
        (when (!= (:lnum lp) (:ml_line_count (:b_ml @curbuf)))   ;; there is a next line
            ((ร lp.col =) 0)
            (ร lp.lnum++)
            ((ร lp.coladd =) 0)
            ((ร RETURN) 1)
        )
        -1
    ))

;; incl(lp): same as incp(), but skip the NUL at the end of non-empty lines

(defn- #_int incl [#_pos_C lp]
    (ยง
        ((ร int r =) (incp lp))

        (if (and (<= 1 r) (non-zero? (:col lp)))
            ((ร r =) (incp lp))
        )

        r
    ))

;; decp(p)
;;
;; Decrement the line pointer 'p' crossing line boundaries as necessary.
;; Return 1 when crossing a line, -1 when at start of file, 0 otherwise.

(defn- #_int dec-cursor []
    (decp (:w_cursor @curwin)))

(defn- #_int decp [#_pos_C lp]
    (ยง
        ((ร lp.coladd =) 0)

        (when (< 0 (:col lp))         ;; still within line
            (ร lp.col--)
            ((ร Bytes p =) (ml-get (:lnum lp)))
            ((ร lp.col =) (- (:col lp) (us-head-off p, (.plus p (:col lp)))))
            ((ร RETURN) 0)
        )

        (when (< 1 (:lnum lp))        ;; there is a prior line
            (ร lp.lnum--)
            ((ร Bytes p =) (ml-get (:lnum lp)))
            ((ร lp.col =) (STRLEN p))
            ((ร lp.col =) (- (:col lp) (us-head-off p, (.plus p (:col lp)))))
            ((ร RETURN) 1)
        )

        -1                  ;; at start of file
    ))

;; decl(lp): same as decp(), but skip the NUL at the end of non-empty lines

(defn- #_int decl [#_pos_C lp]
    (ยง
        ((ร int r =) (decp lp))

        (if (and (== r 1) (non-zero? (:col lp)))
            ((ร r =) (decp lp))
        )

        r
    ))

;; Get the line number relative to the current cursor position,
;; i.e. the difference between line number and cursor position.
;; Only look for lines that can be visible, folded lines don't count.

(defn- #_long get-cursor-rel-lnum [#_window_C wp, #_long lnum]
    ;; lnum: line number to get the result for
    (- lnum (:lnum (:w_cursor wp))))

;; Make sure curwin.w_cursor.lnum is valid.

(defn- #_void check-cursor-lnum []
    (ยง
        (if (> (:lnum (:w_cursor @curwin)) (:ml_line_count (:b_ml @curbuf)))
            ((ร @curwin.w_cursor.lnum =) (:ml_line_count (:b_ml @curbuf)))
        )

        (when (<= (:lnum (:w_cursor @curwin)) 0)
            ((ร @curwin.w_cursor.lnum =) 1)
        )
        nil
    ))

;; Make sure curwin.w_cursor.col is valid.

(defn- #_void check-cursor-col []
    (check-cursor-col-win @curwin)
    nil)

;; Make sure win.w_cursor.col is valid.

(defn- #_void check-cursor-col-win [#_window_C win]
    (ยง
        ((ร int oldcol =) (:col (:w_cursor win)))
        ((ร int oldcoladd =) (+ (:col (:w_cursor win)) (:coladd (:w_cursor win))))

        ((ร int len =) (STRLEN (ml-get-buf @curbuf, (:lnum (:w_cursor win)))))
        (cond (zero? len)
        (do
            ((ร win.w_cursor.col =) 0)
        )
        (<= len (:col (:w_cursor win)))
        (do
            ;; Allow cursor past end-of-line when:
            ;; - in Insert mode or restarting Insert mode
            ;; - in Visual mode and 'selection' isn't "old"
            ;; - 'virtualedit' is set
            (cond (or (flag? @State INSERT) (non-zero? @restart_edit) (and @VIsual_active (!= (.at @p_sel 0) (byte \o))) (flag? @ve_flags VE_ONEMORE) (virtual-active))
            (do
                ((ร win.w_cursor.col =) len)
            )
            :else
            (do
                ((ร win.w_cursor.col =) (dec len))
                ;; Move the cursor to the head byte.
                (mb-adjust-pos @curbuf, (:w_cursor win))
            ))
        )
        (< (:col (:w_cursor win)) 0)
        (do
            ((ร win.w_cursor.col =) 0)
        ))

        ;; If virtual editing is on, we can leave the cursor on the old position,
        ;; only we must set it to virtual.  But don't do it when at the end of the line.
        (cond (== oldcol MAXCOL)
        (do
            ((ร win.w_cursor.coladd =) 0)
        )
        (== @ve_flags VE_ALL)
        (do
            (cond (< (:col (:w_cursor win)) oldcoladd)
            (do
                ((ร win.w_cursor.coladd =) (- oldcoladd (:col (:w_cursor win))))
            )
            :else
            (do
                ;; avoid weird number when there is a miscalculation or overflow
                ((ร win.w_cursor.coladd =) 0)
            ))
        ))
        nil
    ))

;; make sure curwin.w_cursor in on a valid character

(defn- #_void check-cursor []
    (check-cursor-lnum)
    (check-cursor-col)
    nil)

;; Make sure curwin.w_cursor is not on the NUL at the end of the line.
;; Allow it when in Visual mode and 'selection' is not "old".

(defn- #_void adjust-cursor-col []
    (ยง
        (when (and (< 0 (:col (:w_cursor @curwin))) (or (not @VIsual_active) (== (.at @p_sel 0) (byte \o))) (== (gchar-cursor) NUL))
            (ร --@curwin.w_cursor.col)
        )
        nil
    ))

;; When curwin.w_leftcol has changed, adjust the cursor position.
;; Return true if the cursor was moved.

(defn- #_boolean leftcol-changed []
    (ยง
        ((ร boolean retval =) false)

        (changed-cline-bef-curs)
        ((ร long lastcol =) (- (- (+ (:w_leftcol @curwin) (:w_width @curwin)) (curwin-col-off)) 1))
        (validate-virtcol)

        ;; If the cursor is right or left of the screen, move it to last or first character.

        (cond (< (int (- lastcol @p_siso)) (:w_virtcol @curwin))
        (do
            ((ร retval =) true)
            (coladvance (int (- lastcol @p_siso)))
        )
        (< (:w_virtcol @curwin) (+ (:w_leftcol @curwin) @p_siso))
        (do
            ((ร retval =) true)
            (coladvance (int (+ (:w_leftcol @curwin) @p_siso)))
        ))

        ;; If the start of the character under the cursor is not on the screen,
        ;; advance the cursor one more char.  If this fails (last char of the line),
        ;; adjust the scrolling.

        ((ร int[] s =) (ร new int[1]))
        ((ร int[] e =) (ร new int[1]))
        (getvvcol @curwin, (:w_cursor @curwin), s, nil, e)
        (cond (< (int lastcol) (... e 0))
        (do
            ((ร retval =) true)
            (coladvance (- (... s 0) 1))
        )
        (< (... s 0) (:w_leftcol @curwin))
        (do
            ((ร retval =) true)
            (when (not (coladvance (+ (... e 0) 1)))     ;; there isn't another character
                ((ร @curwin.w_leftcol =) (... s 0))           ;; adjust w_leftcol instead
                (changed-cline-bef-curs)
            )
        ))

        (if retval
            ((ร @curwin.w_set_curswant =) true)
        )
        (redraw-later NOT_VALID)
        retval
    ))

;; Various routines dealing with allocation and deallocation of memory.

;; Copy "string" into newly allocated memory.

(defn- #_Bytes STRDUP [#_Bytes string]
    (let [#_int len (inc (STRLEN string)) #_Bytes s (Bytes. len)]
        (BCOPY s, string, len)
        s
    ))

;; Copy up to "len" bytes of "string" into newly allocated memory and terminate with a NUL.
;; The allocated memory always has size "len + 1", also when "string" is shorter.

(defn- #_Bytes STRNDUP [#_Bytes string, #_int len]
    (let [#_Bytes s (Bytes. (inc len))]
        (STRNCPY s, string, len)
        (eos! s len)
        s
    ))

;; Same as STRDUP(), but any characters found in esc_chars are preceded by a backslash.

(defn- #_Bytes vim-strsave-escaped [#_Bytes string, #_Bytes esc_chars]
    (vim-strsave-escaped-ext string, esc_chars, (byte \\)))

;; Same as vim-strsave-escaped().
;; Escape the characters with "cc".

(defn- #_Bytes vim-strsave-escaped-ext [#_Bytes string, #_Bytes esc_chars, #_int cc]
    (ยง
        ;; First count the number of backslashes required.
        ;; Then allocate the memory and insert them.

        ((ร int length =) 1)                         ;; count the trailing NUL
        ((ร FOR) (ร ((ร Bytes p =) string) (non-eos? p) ((ร p =) (.plus p 1)))
            ((ร int l =) (us-ptr2len-cc p))
            (when (< 1 l)
                ((ร length =) (+ length l))                    ;; count a multibyte char
                ((ร p =) (.plus p (dec l)))
                (ร CONTINUE)
            )
            (if (non-nil? (vim-strchr esc_chars, (.at p 0)))
                (ร length++)                       ;; count a backslash
            )
            (ร length++)                           ;; count an ordinary char
        )

        ((ร Bytes escaped_string =) (Bytes. length))

        ((ร Bytes p2 =) escaped_string)
        ((ร FOR) (ร ((ร Bytes p =) string) (non-eos? p) ((ร p =) (.plus p 1)))
            ((ร int l =) (us-ptr2len-cc p))
            (when (< 1 l)
                (BCOPY p2, p, l)
                ((ร p2 =) (.plus p2 l))
                ((ร p =) (.plus p (dec l)))                     ;; skip multibyte char
                (ร CONTINUE)
            )
            (if (non-nil? (vim-strchr esc_chars, (.at p 0)))
                (.be ((ร p2 =) (.plus p2 1)) -1, cc)
            )
            (.be ((ร p2 =) (.plus p2 1)) -1, (.at p 0))
        )
        (eos! p2)

        escaped_string
    ))

;; ASCII lower-to-upper case translation, language independent.

(defn- #_void vim-strup [#_Bytes p]
    (ยง
        (when (non-nil? p)
            ((ร FOR) (ร (ร int c) (!= ((ร c =) (.at p 0)) NUL) nil)
                (.be ((ร p =) (.plus p 1)) -1, (if (or (< c (byte \a)) (< (byte \z) c)) c (- c 0x20)))
            )
        )
        nil
    ))

;; Like STRDUP(), but make all characters uppercase.
;; This uses ASCII lower-to-upper case translation, language independent.

(defn- #_Bytes vim-strsave-up [#_Bytes s]
    (let [#_Bytes p (STRDUP s)]
        (vim-strup p)
        p
    ))

;; copy a space a number of times

(defn- #_void copy-spaces [#_Bytes s, #_int n]
    (dotimes [#_int i n]
        (.be s i, (byte \space))
    )
    nil)

;; Copy a character a number of times.
;; Does not work for multi-byte characters!

(defn- #_void copy-chars [#_Bytes s, #_int n, #_int c]
    (dotimes [#_int i n]
        (.be s i, c)
    )
    nil)

;; Like strncpy(), but always terminate the result with one NUL.
;; "dst" must be "len + 1" long!

(defn- #_void vim-strncpy [#_Bytes dst, #_Bytes src, #_int len]
    (STRNCPY dst, src, len)
    (eos! dst len)
    nil)

;; Like strcat(), but make sure the result fits in "size" bytes
;; and is always NUL terminated.

(defn- #_void vim-strcat [#_Bytes dst, #_Bytes src, #_int size]
    (ยง
        ((ร int dlen =) (STRLEN dst))
        ((ร int slen =) (STRLEN src))

        (cond (< size (+ dlen slen 1))
        (do
            (BCOPY dst, dlen, src, 0, (- size dlen 1))
            (.be dst (dec size), NUL)
        )
        :else
        (do
            (STRCPY (.plus dst dlen), src)
        ))
        nil
    ))

;; Isolate one part of a string option where parts are separated with "sep_chars".
;; The part is copied into "buf[maxlen]".
;; "*option" is advanced to the next part.
;; The length is returned.

(defn- #_int copy-option-part [#_Bytes* option, #_Bytes buf, #_int maxlen, #_Bytes sep_chars]
    (ยง
        ((ร int len =) 0)
        ((ร Bytes p =) (... option 0))

        ;; skip '.' at start of option part, for 'suffixes'
        (if (== (.at p 0) (byte \.))
            (.be buf (ร len++), (.at ((ร p =) (.plus p 1)) -1))
        )
        (while (and (non-eos? p) (nil? (vim-strchr sep_chars, (.at p 0))))
            ;; Skip backslash before a separator character and space.

            (if (and (== (.at p 0) (byte \\)) (non-nil? (vim-strchr sep_chars, (.at p 1))))
                ((ร p =) (.plus p 1))
            )
            (if (< len (dec maxlen))
                (.be buf (ร len++), (.at p 0))
            )
            ((ร p =) (.plus p 1))
        )
        (eos! buf len)

        (if (and (non-eos? p) (!= (.at p 0) (byte \,))) ;; skip non-standard separator
            ((ร p =) (.plus p 1))
        )
        ((ร p =) (skip-to-option-part p)) ;; "p" points to next file name

        ((ร option[0] =) p)
        len
    ))

;; Version of strchr() and strrchr() that handle unsigned char strings
;; with characters from 128 to 255 correctly.  It also doesn't return
;; a pointer to the NUL at the end of the string.

(defn- #_Bytes vim-strchr [#_Bytes string, #_int c]
    (ยง
        ((ร FOR) (ร ((ร Bytes p =) string) (non-eos? p) ((ร p =) (.plus p (us-ptr2len-cc p))))
            (if (== (us-ptr2char p) c)
                ((ร RETURN) p)
            )
        )

        nil
    ))

;; Version of strchr() that only works for bytes and handles unsigned char
;; strings with characters above 128 correctly.  It also doesn't return a
;; pointer to the NUL at the end of the string.

(defn- #_Bytes vim-strbyte [#_Bytes string, #_byte b]
    (ยง
        ((ร FOR) (ร ((ร Bytes p =) string) (non-eos? p) ((ร p =) (.plus p 1)))
            (if (== (.at p 0) b)
                ((ร RETURN) p)
            )
        )

        nil
    ))

;; Search for last occurrence of "b" in "string".
;; Return null if not found.
;; Does not handle multi-byte char for "b"!

(defn- #_Bytes vim-strrchr [#_Bytes string, #_byte b]
    (ยง
        ((ร Bytes q =) nil)

        ((ร FOR) (ร ((ร Bytes p =) string) (non-eos? p) ((ร p =) (.plus p (us-ptr2len-cc p))))
            (if (== (.at p 0) b)
                ((ร q =) p)
            )
        )

        q
    ))

;; Vim has its own isspace() function, because on some machines isspace()
;; can't handle characters above 128.

(defn- #_boolean vim-isspace [#_int x]
    (or (<= 9 x 13) (== x (byte \space))))

;; Some useful tables.

(class! #_final modmasktable_C
    [
        (field int      mod_mask)       ;; bit-mask for particular key modifier
        (field int      mod_flag)       ;; bit(s) for particular key modifier
        (field byte     name)           ;; single letter name of modifier
    ])

(final modmasktable_C* mod_mask_table
    [
        (->modmasktable_C MOD_MASK_ALT,         MOD_MASK_ALT,    (byte \M)),
        (->modmasktable_C MOD_MASK_META,        MOD_MASK_META,   (byte \T)),
        (->modmasktable_C MOD_MASK_CTRL,        MOD_MASK_CTRL,   (byte \C)),
        (->modmasktable_C MOD_MASK_SHIFT,       MOD_MASK_SHIFT,  (byte \S)),
        (->modmasktable_C MOD_MASK_MULTI_CLICK, MOD_MASK_2CLICK, (byte \2)),
        (->modmasktable_C MOD_MASK_MULTI_CLICK, MOD_MASK_3CLICK, (byte \3)),
        (->modmasktable_C MOD_MASK_MULTI_CLICK, MOD_MASK_4CLICK, (byte \4)),
        ;; 'A' must be the last one
        (->modmasktable_C MOD_MASK_ALT,         MOD_MASK_ALT,    (byte \A))
    ])

;; Shifted key terminal codes and their unshifted equivalent.

(final int MOD_KEYS_ENTRY_SIZE 5)

(final byte* modifier_keys_table
    [
     ;; mod mask            with modifier           without modifier
        MOD_MASK_SHIFT,     (byte \&), (byte \9),   (byte \@), (byte \1),   ;; begin
        MOD_MASK_SHIFT,     (byte \&), (byte \0),   (byte \@), (byte \2),   ;; cancel
        MOD_MASK_SHIFT,     (byte \*), (byte \1),   (byte \@), (byte \4),   ;; command
        MOD_MASK_SHIFT,     (byte \*), (byte \2),   (byte \@), (byte \5),   ;; copy
        MOD_MASK_SHIFT,     (byte \*), (byte \3),   (byte \@), (byte \6),   ;; create
        MOD_MASK_SHIFT,     (byte \*), (byte \4),   (byte \k), (byte \D),   ;; delete char
        MOD_MASK_SHIFT,     (byte \*), (byte \5),   (byte \k), (byte \L),   ;; delete line
        MOD_MASK_SHIFT,     (byte \*), (byte \7),   (byte \@), (byte \7),   ;; end
        MOD_MASK_CTRL,      KS_EXTRA, KE_C_END,     (byte \@), (byte \7),   ;; end
        MOD_MASK_SHIFT,     (byte \*), (byte \9),   (byte \@), (byte \9),   ;; exit
        MOD_MASK_SHIFT,     (byte \*), (byte \0),   (byte \@), (byte \0),   ;; find
        MOD_MASK_SHIFT,     (byte \#), (byte \1),   (byte \%), (byte \1),   ;; help
        MOD_MASK_SHIFT,     (byte \#), (byte \2),   (byte \k), (byte \h),   ;; home
        MOD_MASK_CTRL,      KS_EXTRA, KE_C_HOME,    (byte \k), (byte \h),   ;; home
        MOD_MASK_SHIFT,     (byte \#), (byte \3),   (byte \k), (byte \I),   ;; insert
        MOD_MASK_SHIFT,     (byte \#), (byte \4),   (byte \k), (byte \l),   ;; left arrow
        MOD_MASK_CTRL,      KS_EXTRA, KE_C_LEFT,    (byte \k), (byte \l),   ;; left arrow
        MOD_MASK_SHIFT,     (byte \%), (byte \a),   (byte \%), (byte \3),   ;; message
        MOD_MASK_SHIFT,     (byte \%), (byte \b),   (byte \%), (byte \4),   ;; move
        MOD_MASK_SHIFT,     (byte \%), (byte \c),   (byte \%), (byte \5),   ;; next
        MOD_MASK_SHIFT,     (byte \%), (byte \d),   (byte \%), (byte \7),   ;; options
        MOD_MASK_SHIFT,     (byte \%), (byte \e),   (byte \%), (byte \8),   ;; previous
        MOD_MASK_SHIFT,     (byte \%), (byte \f),   (byte \%), (byte \9),   ;; print
        MOD_MASK_SHIFT,     (byte \%), (byte \g),   (byte \%), (byte \0),   ;; redo
        MOD_MASK_SHIFT,     (byte \%), (byte \h),   (byte \&), (byte \3),   ;; replace
        MOD_MASK_SHIFT,     (byte \%), (byte \i),   (byte \k), (byte \r),   ;; right arrow
        MOD_MASK_CTRL,      KS_EXTRA, KE_C_RIGHT,   (byte \k), (byte \r),   ;; right arrow
        MOD_MASK_SHIFT,     (byte \%), (byte \j),   (byte \&), (byte \5),   ;; resume
        MOD_MASK_SHIFT,     (byte \!), (byte \1),   (byte \&), (byte \6),   ;; save
        MOD_MASK_SHIFT,     (byte \!), (byte \2),   (byte \&), (byte \7),   ;; suspend
        MOD_MASK_SHIFT,     (byte \!), (byte \3),   (byte \&), (byte \8),   ;; undo
        MOD_MASK_SHIFT,     KS_EXTRA, KE_S_UP,      (byte \k), (byte \u),   ;; up arrow
        MOD_MASK_SHIFT,     KS_EXTRA, KE_S_DOWN,    (byte \k), (byte \d),   ;; down arrow

                                                                            ;; vt100 F1
        MOD_MASK_SHIFT,     KS_EXTRA, KE_S_XF1,     KS_EXTRA, KE_XF1,
        MOD_MASK_SHIFT,     KS_EXTRA, KE_S_XF2,     KS_EXTRA, KE_XF2,
        MOD_MASK_SHIFT,     KS_EXTRA, KE_S_XF3,     KS_EXTRA, KE_XF3,
        MOD_MASK_SHIFT,     KS_EXTRA, KE_S_XF4,     KS_EXTRA, KE_XF4,

        MOD_MASK_SHIFT,     KS_EXTRA, KE_S_F1,      (byte \k), (byte \1),   ;; F1
        MOD_MASK_SHIFT,     KS_EXTRA, KE_S_F2,      (byte \k), (byte \2),
        MOD_MASK_SHIFT,     KS_EXTRA, KE_S_F3,      (byte \k), (byte \3),
        MOD_MASK_SHIFT,     KS_EXTRA, KE_S_F4,      (byte \k), (byte \4),
        MOD_MASK_SHIFT,     KS_EXTRA, KE_S_F5,      (byte \k), (byte \5),
        MOD_MASK_SHIFT,     KS_EXTRA, KE_S_F6,      (byte \k), (byte \6),
        MOD_MASK_SHIFT,     KS_EXTRA, KE_S_F7,      (byte \k), (byte \7),
        MOD_MASK_SHIFT,     KS_EXTRA, KE_S_F8,      (byte \k), (byte \8),
        MOD_MASK_SHIFT,     KS_EXTRA, KE_S_F9,      (byte \k), (byte \9),
        MOD_MASK_SHIFT,     KS_EXTRA, KE_S_F10,     (byte \k), (byte \;),   ;; F10

        MOD_MASK_SHIFT,     KS_EXTRA, KE_S_F11,     (byte \F), (byte \1),
        MOD_MASK_SHIFT,     KS_EXTRA, KE_S_F12,     (byte \F), (byte \2),

        MOD_MASK_SHIFT,     (byte \k), (byte \B),   KS_EXTRA, KE_TAB,       ;; TAB pseudo code

        NUL
    ])

(class! #_final key_name_C
    [
        (field int      key)        ;; special key code or ascii value
        (field Bytes    name)       ;; name of key
    ])

(final key_name_C* key_names_table
    [
        (->key_name_C (int \space),     (u8 "Space")           ),
        (->key_name_C TAB,              (u8 "Tab")             ),
        (->key_name_C K_TAB,            (u8 "Tab")             ),
        (->key_name_C NL,               (u8 "NL")              ),
        (->key_name_C NL,               (u8 "NewLine")         ),  ;; alternative name
        (->key_name_C NL,               (u8 "LineFeed")        ),  ;; alternative name
        (->key_name_C NL,               (u8 "LF")              ),  ;; alternative name
        (->key_name_C CAR,              (u8 "CR")              ),
        (->key_name_C CAR,              (u8 "Return")          ),  ;; alternative name
        (->key_name_C CAR,              (u8 "Enter")           ),  ;; alternative name
        (->key_name_C K_BS,             (u8 "BS")              ),
        (->key_name_C K_BS,             (u8 "BackSpace")       ),  ;; alternative name
        (->key_name_C ESC,              (u8 "Esc")             ),
        (->key_name_C (int \|),         (u8 "Bar")             ),
        (->key_name_C (int \\),         (u8 "Bslash")          ),
        (->key_name_C K_DEL,            (u8 "Del")             ),
        (->key_name_C K_DEL,            (u8 "Delete")          ),  ;; alternative name
        (->key_name_C K_KDEL,           (u8 "kDel")            ),
        (->key_name_C K_UP,             (u8 "Up")              ),
        (->key_name_C K_DOWN,           (u8 "Down")            ),
        (->key_name_C K_LEFT,           (u8 "Left")            ),
        (->key_name_C K_RIGHT,          (u8 "Right")           ),
        (->key_name_C K_XUP,            (u8 "xUp")             ),
        (->key_name_C K_XDOWN,          (u8 "xDown")           ),
        (->key_name_C K_XLEFT,          (u8 "xLeft")           ),
        (->key_name_C K_XRIGHT,         (u8 "xRight")          ),

        (->key_name_C K_F1,             (u8 "F1")              ),
        (->key_name_C K_F2,             (u8 "F2")              ),
        (->key_name_C K_F3,             (u8 "F3")              ),
        (->key_name_C K_F4,             (u8 "F4")              ),
        (->key_name_C K_F5,             (u8 "F5")              ),
        (->key_name_C K_F6,             (u8 "F6")              ),
        (->key_name_C K_F7,             (u8 "F7")              ),
        (->key_name_C K_F8,             (u8 "F8")              ),
        (->key_name_C K_F9,             (u8 "F9")              ),
        (->key_name_C K_F10,            (u8 "F10")             ),

        (->key_name_C K_F11,            (u8 "F11")             ),
        (->key_name_C K_F12,            (u8 "F12")             ),

        (->key_name_C K_XF1,            (u8 "xF1")             ),
        (->key_name_C K_XF2,            (u8 "xF2")             ),
        (->key_name_C K_XF3,            (u8 "xF3")             ),
        (->key_name_C K_XF4,            (u8 "xF4")             ),

        (->key_name_C K_HELP,           (u8 "Help")            ),
        (->key_name_C K_UNDO,           (u8 "Undo")            ),
        (->key_name_C K_INS,            (u8 "Insert")          ),
        (->key_name_C K_INS,            (u8 "Ins")             ),  ;; alternative name
        (->key_name_C K_KINS,           (u8 "kInsert")         ),
        (->key_name_C K_HOME,           (u8 "Home")            ),
        (->key_name_C K_KHOME,          (u8 "kHome")           ),
        (->key_name_C K_XHOME,          (u8 "xHome")           ),
        (->key_name_C K_ZHOME,          (u8 "zHome")           ),
        (->key_name_C K_END,            (u8 "End")             ),
        (->key_name_C K_KEND,           (u8 "kEnd")            ),
        (->key_name_C K_XEND,           (u8 "xEnd")            ),
        (->key_name_C K_ZEND,           (u8 "zEnd")            ),
        (->key_name_C K_PAGEUP,         (u8 "PageUp")          ),
        (->key_name_C K_PAGEDOWN,       (u8 "PageDown")        ),
        (->key_name_C K_KPAGEUP,        (u8 "kPageUp")         ),
        (->key_name_C K_KPAGEDOWN,      (u8 "kPageDown")       ),

        (->key_name_C K_KPLUS,          (u8 "kPlus")           ),
        (->key_name_C K_KMINUS,         (u8 "kMinus")          ),
        (->key_name_C K_KDIVIDE,        (u8 "kDivide")         ),
        (->key_name_C K_KMULTIPLY,      (u8 "kMultiply")       ),
        (->key_name_C K_KENTER,         (u8 "kEnter")          ),
        (->key_name_C K_KPOINT,         (u8 "kPoint")          ),

        (->key_name_C K_K0,             (u8 "k0")              ),
        (->key_name_C K_K1,             (u8 "k1")              ),
        (->key_name_C K_K2,             (u8 "k2")              ),
        (->key_name_C K_K3,             (u8 "k3")              ),
        (->key_name_C K_K4,             (u8 "k4")              ),
        (->key_name_C K_K5,             (u8 "k5")              ),
        (->key_name_C K_K6,             (u8 "k6")              ),
        (->key_name_C K_K7,             (u8 "k7")              ),
        (->key_name_C K_K8,             (u8 "k8")              ),
        (->key_name_C K_K9,             (u8 "k9")              ),

        (->key_name_C (int \<),         (u8 "lt")              ),

        (->key_name_C K_DROP,           (u8 "Drop")            ),
        (->key_name_C K_ZERO,           (u8 "Nul")             ),

        (->key_name_C K_CURSORHOLD,     (u8 "CursorHold")      ),
    ])

;; Check if if there is a special key code for "key" that includes the modifiers specified.

(defn- #_int simplify-key [#_int key, #_int* modifiers]
    (ยง
        (when (flag? (... modifiers 0) (| MOD_MASK_SHIFT MOD_MASK_CTRL MOD_MASK_ALT))
            ;; TAB is a special case.
            (when (and (== key TAB) (flag? (... modifiers 0) MOD_MASK_SHIFT))
                ((ร modifiers[0] =) (& (... modifiers 0) (bit-not MOD_MASK_SHIFT)))
                ((ร RETURN) K_S_TAB)
            )

            ((ร byte[] mkt =) modifier_keys_table)
            ((ร byte key0 =) (KEY2TERMCAP0 key))
            ((ร byte key1 =) (KEY2TERMCAP1 key))

            ((ร FOR) (ร ((ร int i =) 0) (!= (... mkt i) NUL) ((ร i =) (+ i MOD_KEYS_ENTRY_SIZE)))
                (when (and (== key0 (... mkt (+ i 3))) (== key1 (... mkt (+ i 4))) (non-zero? (& (... modifiers 0) (char_u (... mkt i)))))
                    ((ร modifiers[0] =) (& (... modifiers 0) (bit-not (char_u (... mkt i)))))
                    ((ร RETURN) (TERMCAP2KEY (... mkt (inc i)), (... mkt (+ i 2))))
                )
            )
        )

        key
    ))

;; Change <xHome> to <Home>, <xUp> to <Up>, etc.

(defn- #_int handle-x-keys [#_int key]
    (ยง
        ((ร SWITCH) key
            ((ร CASE) K_XUP)
            (do
                ((ร RETURN) K_UP)
            )
            ((ร CASE) K_XDOWN)
            (do
                ((ร RETURN) K_DOWN)
            )
            ((ร CASE) K_XLEFT)
            (do
                ((ร RETURN) K_LEFT)
            )
            ((ร CASE) K_XRIGHT)
            (do
                ((ร RETURN) K_RIGHT)
            )
            ((ร CASE) K_XHOME)
            (do
                ((ร RETURN) K_HOME)
            )
            ((ร CASE) K_ZHOME)
            (do
                ((ร RETURN) K_HOME)
            )
            ((ร CASE) K_XEND)
            (do
                ((ร RETURN) K_END)
            )
            ((ร CASE) K_ZEND)
            (do
                ((ร RETURN) K_END)
            )
            ((ร CASE) K_XF1)
            (do
                ((ร RETURN) K_F1)
            )
            ((ร CASE) K_XF2)
            (do
                ((ร RETURN) K_F2)
            )
            ((ร CASE) K_XF3)
            (do
                ((ร RETURN) K_F3)
            )
            ((ร CASE) K_XF4)
            (do
                ((ร RETURN) K_F4)
            )
            ((ร CASE) K_S_XF1)
            (do
                ((ร RETURN) K_S_F1)
            )
            ((ร CASE) K_S_XF2)
            (do
                ((ร RETURN) K_S_F2)
            )
            ((ร CASE) K_S_XF3)
            (do
                ((ร RETURN) K_S_F3)
            )
            ((ร CASE) K_S_XF4)
            (do
                ((ร RETURN) K_S_F4)
            )
        )
        key
    ))

;; Return a string which contains the name of the given key when the given modifiers are down.

(defn- #_Bytes get-special-key-name [#_int c, #_int modifiers]
    (ยง
        ;; Key that stands for a normal character.
        (if (and (is-special c) (== (KEY2TERMCAP0 c) KS_KEY))
            ((ร c =) (char_u (KEY2TERMCAP1 c)))
        )

        ;; Translate shifted special keys into unshifted keys and set modifier.
        ;; Same for CTRL and ALT modifiers.

        (when (is-special c)
            ((ร byte[] mkt =) modifier_keys_table)
            ((ร byte key0 =) (KEY2TERMCAP0 c))
            ((ร byte key1 =) (KEY2TERMCAP1 c))

            ((ร FOR) (ร ((ร int i =) 0) (!= (... mkt i) NUL) ((ร i =) (+ i MOD_KEYS_ENTRY_SIZE)))
                (when (and (== key0 (... mkt (inc i))) (== key1 (... mkt (+ i 2))))
                    ((ร modifiers =) (| modifiers (char_u (... mkt i))))
                    ((ร c =) (TERMCAP2KEY (... mkt (+ i 3)), (... mkt (+ i 4))))
                    (ร BREAK)
                )
            )
        )

        ;; try to find the key in the special key table
        ((ร int table_idx =) (find-special-key-in-table c))

        ;; When not a known special key, and not a printable character, try to extract modifiers.

        (when (and (< 0 c) (== (utf-char2len c) 1))
            (when (and (< table_idx 0) (or (not (vim-isprintc c)) (== (& c 0x7f) (byte \space))) (!= (& c 0x80) NUL))
                ((ร c =) (& c 0x7f))
                ((ร modifiers =) (| modifiers MOD_MASK_ALT))
                ;; try again, to find the un-alted key in the special key table
                ((ร table_idx =) (find-special-key-in-table c))
            )
            (when (and (< table_idx 0) (not (vim-isprintc c)) (< c (byte \space)))
                ((ร c =) (+ c (byte \@)))
                ((ร modifiers =) (| modifiers MOD_MASK_CTRL))
            )
        )

        ((ร Bytes key__name =) (Bytes. (inc MAX_KEY_NAME_LEN)))
        ((ร int idx =) 0)

        (.be key__name (ร idx++), (byte \<))

        ;; translate the modifier into a string
        ((ร FOR) (ร ((ร int i =) 0) (and (< i (:length mod_mask_table)) (!= (:name (... mod_mask_table i)) (byte \A))) (ร i++))
            (when (== (& modifiers (:mod_mask (... mod_mask_table i))) (:mod_flag (... mod_mask_table i)))
                (.be key__name (ร idx++), (:name (... mod_mask_table i)))
                (.be key__name (ร idx++), (byte \-))
            )
        )

        (cond (< table_idx 0)          ;; unknown special key, may output t_xx
        (do
            (cond (is-special c)
            (do
                (.be key__name (ร idx++), (byte \t))
                (.be key__name (ร idx++), (byte \_))
                (.be key__name (ร idx++), (KEY2TERMCAP0 c))
                (.be key__name (ร idx++), (KEY2TERMCAP1 c))
            )
            ;; Not a special key, only modifiers, output directly.
            :else
            (do
                (cond (< 1 (utf-char2len c))
                (do
                    ((ร idx =) (+ idx (utf-char2bytes c, (.plus key__name idx))))
                )
                (vim-isprintc c)
                (do
                    (.be key__name (ร idx++), c)
                )
                :else
                (do
                    ((ร Bytes s =) (transchar c))
                    (while (non-eos? s)
                        (.be key__name (ร idx++), (.at ((ร s =) (.plus s 1)) -1))
                    )
                ))
            ))
        )
        :else                        ;; use name of special key
        (do
            (STRCPY (.plus key__name idx), (:name (... key_names_table table_idx)))
            ((ร idx =) (STRLEN key__name))
        ))

        (.be key__name (ร idx++), (byte \>))
        (eos! key__name idx)

        key__name
    ))

;; Try to find key "c" in the special key table.
;; Return the index when found, -1 when not found.

(defn- #_int find-special-key-in-table [#_int c]
    (ยง
        (dotimes [#_int i (:length key_names_table)]
            (if (== (:key (... key_names_table i)) c)
                ((ร RETURN) i)
            )
        )

        -1
    ))

;; VISUAL, SELECTMODE and OP_PENDING State are never set, they are equal to
;; NORMAL State with a condition.  This function returns the real State.

(defn- #_int get-real-state []
    (ยง
        (when (flag? @State NORMAL)
            (cond @VIsual_active
            (do
                (if @VIsual_select
                    ((ร RETURN) SELECTMODE)
                )

                ((ร RETURN) VISUAL)
            )
            @finish_op
            (do
                ((ร RETURN) OP_PENDING)
            ))
        )
        @State
    ))

;; Print an error message with one or two "%s" and one or two string arguments.
;; This is not in message.c to avoid a warning for prototypes.

(defn- #_boolean emsg3 [#_Bytes s, #_Bytes a1, #_Bytes a2]
    (ยง
        (if (emsg-not-now)
            ((ร RETURN) true)            ;; no error messages at the moment
        )

;%%     (vim_snprintf @ioBuff, IOSIZE, s, a1, a2)
        (emsg @ioBuff)
    ))

;; Print an error message with one "%ld" and one long int argument.
;; This is not in message.c to avoid a warning for prototypes.

(defn- #_boolean emsgn [#_Bytes s, #_long n]
    (ยง
        (if (emsg-not-now)
            ((ร RETURN) true)            ;; no error messages at the moment
        )

;%%     (vim_snprintf @ioBuff, IOSIZE, s, n)
        (emsg @ioBuff)
    ))

;;; ============================================================================================== VimT

;; Return true if the CursorHold event can be triggered.

(defn- #_boolean trigger-cursorhold []
    (ยง
        (when (and (not @did_cursorhold) (ร hamis) (not @Recording) (zero? (:tb_len @typebuf)))
            ((ร int state =) (get-real-state))
            (if (or (== state NORMAL_BUSY) (flag? state INSERT))
                ((ร RETURN) true)
            )
        )
        false
    ))

;;; ============================================================================================== VimU

;; undo.c: multi level undo facility
;;
;; The saved lines are stored in a list of lists (one for each buffer):
;;
;; b_u_oldhead------------------------------------------------+
;;                                                            |
;;                                                            V
;;                +--------------+    +--------------+    +--------------+
;; b_u_newhead--->| u_header     |    | u_header     |    | u_header     |
;;                |     uh_next------>|     uh_next------>|     uh_next---->null
;;         null<--------uh_prev  |<---------uh_prev  |<---------uh_prev  |
;;                |     uh_entry |    |     uh_entry |    |     uh_entry |
;;                +--------|-----+    +--------|-----+    +--------|-----+
;;                         |                   |                   |
;;                         V                   V                   V
;;                +--------------+    +--------------+    +--------------+
;;                | u_entry      |    | u_entry      |    | u_entry      |
;;                |     ue_next  |    |     ue_next  |    |     ue_next  |
;;                +--------|-----+    +--------|-----+    +--------|-----+
;;                         |                   |                   |
;;                         V                   V                   V
;;                +--------------+            null                null
;;                | u_entry      |
;;                |     ue_next  |
;;                +--------|-----+
;;                         |
;;                         V
;;                        etc.
;;
;; Each u_entry list contains the information for one undo or redo.
;; curbuf.b_u_curhead points to the header of the last undo (the next redo),
;; or is null if nothing has been undone (end of the branch).
;;
;; For keeping alternate undo/redo branches the uh_alt field is used.  Thus at
;; each point in the list a branch may appear for an alternate to redo.  The
;; uh_seq field is numbered sequentially to be able to find a newer or older
;; branch.
;;
;;                 +---------------+    +---------------+
;; b_u_oldhead --->| u_header      |    | u_header      |
;;                 |   uh_alt_next ---->|   uh_alt_next ----> null
;;         null <----- uh_alt_prev |<------ uh_alt_prev |
;;                 |   uh_prev     |    |   uh_prev     |
;;                 +-----|---------+    +-----|---------+
;;                       |                    |
;;                       V                    V
;;                 +---------------+    +---------------+
;;                 | u_header      |    | u_header      |
;;                 |   uh_alt_next |    |   uh_alt_next |
;; b_u_newhead --->|   uh_alt_prev |    |   uh_alt_prev |
;;                 |   uh_prev     |    |   uh_prev     |
;;                 +-----|---------+    +-----|---------+
;;                       |                    |
;;                       V                    V
;;                     null             +---------------+    +---------------+
;;                                      | u_header      |    | u_header      |
;;                                      |   uh_alt_next ---->|   uh_alt_next |
;;                                      |   uh_alt_prev |<------ uh_alt_prev |
;;                                      |   uh_prev     |    |   uh_prev     |
;;                                      +-----|---------+    +-----|---------+
;;                                            |                    |
;;                                           etc.                 etc.
;;
;; All data is allocated and will all be freed when the buffer is unloaded.

;; used in undo_end() to report number of added and deleted lines
(atom! long     u_newcount)
(atom! long     u_oldcount)

;; When 'u' flag included in 'cpoptions', we behave like vi.
;; Need to remember the action that "u" should do.

(atom! boolean  undo_undoes)

(atom! int      lastmark)

;; Save the current line for both the "u" and "U" command.
;; Returns true or false.

(defn- #_boolean u-save-cursor []
    (let [lnum (-> @curwin :w_cursor :lnum)]
        (u-save (dec lnum), (inc lnum))
    ))

;; Save the lines between "top" and "bot" for both the "u" and "U" command.
;; "top" may be 0 and bot may be curbuf.b_ml.ml_line_count + 1.
;; Returns false when lines could not be saved, true otherwise.

(defn- #_boolean u-save [#_long top, #_long bot]
    (ยง
        (if (or (< (:ml_line_count (:b_ml @curbuf)) top) (<= bot top) (< (+ (:ml_line_count (:b_ml @curbuf)) 1) bot))
            ((ร RETURN) false)   ;; rely on caller to do error messages
        )

        (if (== (+ top 2) bot)
            (u-saveline (inc top)))

        (u-savecommon top, bot, 0, false)
    ))

;; Save the line "lnum" (used by ":s" and "~" command).
;; The line is replaced, so the new bottom line is lnum + 1.
;; Returns false when lines could not be saved, true otherwise.

(defn- #_boolean u-savesub [#_long lnum]
    (u-savecommon (dec lnum), (inc lnum), (inc lnum), false))

;; A new line is inserted before line "lnum" (used by :s command).
;; The line is inserted, so the new bottom line is lnum + 1.
;; Returns false when lines could not be saved, true otherwise.

(defn- #_boolean u-inssub [#_long lnum]
    (u-savecommon (dec lnum), lnum, (inc lnum), false))

;; Save the lines "lnum" - "lnum" + nlines (used by delete command).
;; The lines are deleted, so the new bottom line is lnum, unless the buffer becomes empty.
;; Returns false when lines could not be saved, true otherwise.

(defn- #_boolean u-savedel [#_long lnum, #_long nlines]
    (u-savecommon (dec lnum), (+ lnum nlines), (if (== nlines (:ml_line_count (:b_ml @curbuf))) 2 lnum), false))

;; Return true when undo is allowed.
;; Otherwise give an error message and return false.

(defn- #_boolean undo-allowed []
    (ยง
        ;; Don't allow changes in the buffer while editing the cmdline.
        ;; The caller of getcmdline() may get confused.
        (when (non-zero? @textlock)
            (emsg e_secure)
            ((ร RETURN) false)
        )

        true
    ))

;; Get the undolevle value for the current buffer.

(defn- #_long get-undolevel []
    @(:b_p_ul @curbuf))

;; Common code for various ways to save text before a change.
;; "top" is the line above the first changed line.
;; "bot" is the line below the last changed line.
;; "newbot" is the new bottom line.  Use zero when not known.
;; "reload" is true when saving for a buffer reload.
;; Returns false when lines could not be saved, true otherwise.

(defn- #_boolean u-savecommon [#_long top, #_long bot, #_long newbot, #_boolean reload]
    (ยง
        (when (not reload)
            ;; When making changes is not allowed, return false.
            ;; It's a crude way to make all change commands fail.
            (if (not (undo-allowed))
                ((ร RETURN) false)
            )

            (when (< (+ (:ml_line_count (:b_ml @curbuf)) 1) bot)
                ;; This happens when the FileChangedRO autocommand changes
                ;; the file in a way it becomes shorter.
                (emsg (u8 "E881: Line count changed unexpectedly"))
                ((ร RETURN) false)
            )
        )

        ((ร long size =) (- bot top 1))

        ;; If curbuf.b_u_synced == true make a new header.

        (cond (:b_u_synced @curbuf)
        (do
            ;; Need to create new entry in b_changelist.
            ((ร @curbuf.b_new_change =) true)

            ((ร u_header_C uhp =) (if (<= 0 (get-undolevel)) (NEW_u_header_C) nil))

            ;; If we undid more than we redid, move the entry lists before
            ;; and including curbuf.b_u_curhead to an alternate branch.

; %%        ((ร u_header_C[] old_curhead =) (ร { (@curbuf.b_u_curhead) }))
            (when (non-nil? (... old_curhead 0))
                ((ร @curbuf.b_u_newhead =) (:ptr (:uh_next (... old_curhead 0))))
                ((ร @curbuf.b_u_curhead =) nil)
            )

            ;; free headers to keep the size right

            (while (and (< (get-undolevel) (:b_u_numhead @curbuf)) (non-nil? (:b_u_oldhead @curbuf)))
                ((ร u_header_C uhfree =) (:b_u_oldhead @curbuf))

                (cond (== uhfree (... old_curhead 0))
                (do
                    ;; Can't reconnect the branch, delete all of it.
                    (u-freebranch @curbuf, uhfree, old_curhead)
                )
                (nil? (:ptr (:uh_alt_next uhfree)))
                (do
                    ;; There is no branch, only free one header.
                    (u-freeheader @curbuf, uhfree, old_curhead)
                )
                :else
                (do
                    ;; Free the oldest alternate branch as a whole.
                    (while (non-nil? (:ptr (:uh_alt_next uhfree)))
                        ((ร uhfree =) (:ptr (:uh_alt_next uhfree)))
                    )
                    (u-freebranch @curbuf, uhfree, old_curhead)
                ))
            )

            (when (nil? uhp)                ;; no undo at all
                (if (non-nil? (... old_curhead 0))
                    (u-freebranch @curbuf, (... old_curhead 0), nil))
                ((ร @curbuf.b_u_synced =) false)
                ((ร RETURN) true)
            )

            ((ร uhp.uh_prev.ptr =) nil)
            ((ร uhp.uh_next.ptr =) (:b_u_newhead @curbuf))
            ((ร uhp.uh_alt_next.ptr =) (... old_curhead 0))
            (cond (non-nil? (... old_curhead 0))
            (do
                ((ร uhp.uh_alt_prev.ptr =) (:ptr (:uh_alt_prev (... old_curhead 0))))
                (if (non-nil? (:ptr (:uh_alt_prev uhp)))
                    ((ร uhp.uh_alt_prev.ptr.uh_alt_next.ptr =) uhp)
                )
                ((ร old_curhead[0].uh_alt_prev.ptr =) uhp)
                (if (== (:b_u_oldhead @curbuf) (... old_curhead 0))
                    ((ร @curbuf.b_u_oldhead =) uhp)
                )
            )
            :else
            (do
                ((ร uhp.uh_alt_prev.ptr =) nil)
            ))
            (if (non-nil? (:b_u_newhead @curbuf))
                ((ร @curbuf.b_u_newhead.uh_prev.ptr =) uhp)
            )

            ((ร uhp.uh_seq =) (ร ++@curbuf.b_u_seq_last))
            ((ร @curbuf.b_u_seq_cur =) (:uh_seq uhp))
            ((ร uhp.uh_time =) (._time libC))
            ((ร @curbuf.b_u_time_cur =) (+ (:uh_time uhp) 1))

            ((ร uhp.uh_walk =) 0)
            ((ร uhp.uh_entry =) nil)
            ((ร uhp.uh_getbot_entry =) nil)
            (COPY-pos (:uh_cursor uhp), (:w_cursor @curwin)) ;; save cursor pos. for undo
            ((ร uhp.uh_cursor_vcol =) (if (and (virtual-active) (< 0 (:coladd (:w_cursor @curwin)))) (getviscol) -1))

            ;; save changed and buffer empty flag for undo
            ((ร uhp.uh_flags =) (+ (if @(:b_changed @curbuf) UH_CHANGED 0) (if (!= (& (:ml_flags (:b_ml @curbuf)) ML_EMPTY) 0) UH_EMPTYBUF 0)))

            ;; save named marks and Visual marks for undo
            (dotimes [#_int i NMARKS]
                (COPY-pos (... (:uh_namedm uhp) i), (... (:b_namedm @curbuf) i))
            )
            (COPY-visualinfo (:uh_visual uhp), (:b_visual @curbuf))

            ((ร @curbuf.b_u_newhead =) uhp)
            (if (nil? (:b_u_oldhead @curbuf))
                ((ร @curbuf.b_u_oldhead =) uhp)
            )
            (ร @curbuf.b_u_numhead++)
        )
        :else
        (do
            (if (< (get-undolevel) 0)        ;; no undo at all
                ((ร RETURN) true)
            )

            ;; When saving a single line, and it has been saved just before, it
            ;; doesn't make sense saving it again.  Saves a lot of memory when
            ;; making lots of changes inside the same line.
            ;; This is only possible if the previous change didn't increase or
            ;; decrease the number of lines.
            ;; Check the ten last changes.  More doesn't make sense and takes too long.

            (when (== size 1)
                ((ร u_entry_C uep =) (u-get-headentry))
                ((ร u_entry_C prev_uep =) nil)
                (dotimes [#_int i 10]
                    (if (nil? uep)
                        (ร BREAK)
                    )

                    ;; If lines have been inserted/deleted we give up.
                    ;; Also when the line was included in a multi-line save.
                    (if (or (if (!= (:uh_getbot_entry (:b_u_newhead @curbuf)) uep) (!= (+ (:ue_top uep) (:ue_size uep) 1) (if (zero? (:ue_bot uep)) (+ (:ml_line_count (:b_ml @curbuf)) 1) (:ue_bot uep))) (!= (:ue_lcount uep) (:ml_line_count (:b_ml @curbuf)))) (and (< 1 (:ue_size uep)) (<= (:ue_top uep) top) (<= (+ top 2) (+ (:ue_top uep) (:ue_size uep) 1))))
                        (ร BREAK)
                    )

                    ;; If it's the same line we can skip saving it again.
                    (when (and (== (:ue_size uep) 1) (== (:ue_top uep) top))
                        (when (< 0 i)
                            ;; It's not the last entry: get ue_bot for the last entry now.
                            ;; Following deleted/inserted lines go to the re-used entry.
                            (u-getbot)
                            ((ร @curbuf.b_u_synced =) false)

                            ;; Move the found entry to become the last entry.
                            ;; The order of undo/redo doesn't matter for the entries we move it over,
                            ;; since they don't change the line count and don't include this line.
                            ;; It does matter for the found entry if the line count is changed
                            ;; by the executed command.
                            ((ร prev_uep.ue_next =) (:ue_next uep))
                            ((ร uep.ue_next =) (:uh_entry (:b_u_newhead @curbuf)))
                            ((ร @curbuf.b_u_newhead.uh_entry =) uep)
                        )

                        ;; The executed command may change the line count.
                        (cond (non-zero? newbot)
                        (do
                            ((ร uep.ue_bot =) newbot)
                        )
                        (< (:ml_line_count (:b_ml @curbuf)) bot)
                        (do
                            ((ร uep.ue_bot =) 0)
                        )
                        :else
                        (do
                            ((ร uep.ue_lcount =) (:ml_line_count (:b_ml @curbuf)))
                            ((ร @curbuf.b_u_newhead.uh_getbot_entry =) uep)
                        ))
                        ((ร RETURN) true)
                    )
                    ((ร prev_uep =) uep)
                    ((ร uep =) (:ue_next uep))
                )
            )

            ;; find line number for ue_bot for previous u-save()
            (u-getbot)
        ))

        ;; add lines in front of entry list

        ((ร u_entry_C uep =) (NEW_u_entry_C))

        ((ร uep.ue_size =) size)
        ((ร uep.ue_top =) top)
        (cond (non-zero? newbot)
        (do
            ((ร uep.ue_bot =) newbot)
        )

        ;; Use 0 for ue_bot if bot is below last line.
        ;; Otherwise we have to compute ue_bot later.

        (< (:ml_line_count (:b_ml @curbuf)) bot)
        (do
            ((ร uep.ue_bot =) 0)
        )
        :else
        (do
            ((ร uep.ue_lcount =) (:ml_line_count (:b_ml @curbuf)))
            ((ร @curbuf.b_u_newhead.uh_getbot_entry =) uep)
        ))

        (cond (< 0 size)
        (do
            ((ร uep.ue_array =) (ร new Bytes[(int)size]))
            ((ร long lnum =) (inc top))
            (dotimes [#_int i size]
                (fast-breakcheck)
                (if @got_int
                    ((ร RETURN) false)
                )
                ((ร uep.ue_array[i] =) (STRDUP (ml-get (ร lnum++))))
            )
        )
        :else
        (do
            ((ร uep.ue_array =) nil)
        ))
        ((ร uep.ue_next =) (:uh_entry (:b_u_newhead @curbuf)))
        ((ร @curbuf.b_u_newhead.uh_entry =) uep)
        ((ร @curbuf.b_u_synced =) false)
        (reset! undo_undoes false)

        true
    ))

;; If 'cpoptions' contains 'u': Undo the previous undo or redo (vi compatible).
;; If 'cpoptions' does not contain 'u': Always undo.

(defn- #_void u-undo [#_int count]
    (ยง
        ;; If we get an undo command while executing a macro, we behave like the original vi.
        ;; If this happens twice in one macro the result will not be compatible.

        (when (not (:b_u_synced @curbuf))
            (u-sync true)
            ((ร count =) 1)
        )

        (if (nil? (vim-strbyte @p_cpo, CPO_UNDO))
            (reset! undo_undoes true)
            (reset! undo_undoes (not @undo_undoes)))

        (u-doit count)
        nil
    ))

;; If 'cpoptions' contains 'u': Repeat the previous undo or redo.
;; If 'cpoptions' does not contain 'u': Always redo.

(defn- #_void u-redo [#_int count]
    (if (nil? (vim-strbyte @p_cpo, CPO_UNDO))
        (reset! undo_undoes false))
    (u-doit count)
    nil)

;; Undo or redo, depending on 'undo_undoes', 'count' times.

(defn- #_void u-doit [#_int startcount]
    (ยง
        (if (not (undo-allowed))
            ((ร RETURN) nil)
        )

        (reset! u_newcount 0)
        (reset! u_oldcount 0)
        (if (non-zero? (& (:ml_flags (:b_ml @curbuf)) ML_EMPTY))
            (reset! u_oldcount -1))

        ((ร FOR) (ร ((ร int count =) startcount) (< 0 (ร count--)) nil)
            (cond @undo_undoes
            (do
                (cond (nil? (:b_u_curhead @curbuf))             ;; first undo
                (do
                    ((ร @curbuf.b_u_curhead =) (:b_u_newhead @curbuf))
                )
                (< 0 (get-undolevel))               ;; multi level undo
                (do
                    ;; get next undo
                    ((ร @curbuf.b_u_curhead =) (:ptr (:uh_next (:b_u_curhead @curbuf))))
                ))
                ;; nothing to undo
                (when (or (zero? (:b_u_numhead @curbuf)) (nil? (:b_u_curhead @curbuf)))
                    ;; stick curbuf.b_u_curhead at end
                    ((ร @curbuf.b_u_curhead =) (:b_u_oldhead @curbuf))
                    (beep-flush)
                    (when (== count (dec startcount))
                        (msg (u8 "Already at oldest change"))
                        ((ร RETURN) nil)
                    )
                    (ร BREAK)
                )

                (u-undoredo true)
            )
            :else
            (do
                (when (or (nil? (:b_u_curhead @curbuf)) (<= (get-undolevel) 0))
                    (beep-flush)   ;; nothing to redo
                    (when (== count (dec startcount))
                        (msg (u8 "Already at newest change"))
                        ((ร RETURN) nil)
                    )
                    (ร BREAK)
                )

                (u-undoredo false)

                ;; Advance for next redo.
                ;; Set "newhead" when at the end of the redoable changes.
                (if (nil? (:ptr (:uh_prev (:b_u_curhead @curbuf))))
                    ((ร @curbuf.b_u_newhead =) (:b_u_curhead @curbuf))
                )
                ((ร @curbuf.b_u_curhead =) (:ptr (:uh_prev (:b_u_curhead @curbuf))))
            ))
        )

        (u-undo-end @undo_undoes, false)
        nil
    ))

;; Undo or redo over the timeline.
;; When "step" is negative go back in time, otherwise goes forward in time.
;; When "sec" is false make "step" steps, when "sec" is true use "step" as seconds.
;; When "absolute" is true use "step" as the sequence number to jump to.
;; "sec" must be false then.

(defn- #_void undo-time [#_long step, #_boolean sec, #_boolean absolute]
    (ยง
        ((ร boolean dosec =) sec)
        ((ร boolean above =) false)
        ((ร boolean did_undo =) true)

        ;; First make sure the current undoable change is synced.
        (if (not (:b_u_synced @curbuf))
            (u-sync true))

        (reset! u_newcount 0)
        (reset! u_oldcount 0)
        (if (non-zero? (& (:ml_flags (:b_ml @curbuf)) ML_EMPTY))
            (reset! u_oldcount -1))

;       u_header_C uhp = null;	// %% anno dunno

        (ร long target)
        (ร long closest)
        ;; "target" is the node below which we want to be.
        ;; Init "closest" to a value we can't reach.
        (cond absolute
        (do
            ((ร target =) step)
            ((ร closest =) -1)
        )
        :else
        (do
            ;; When doing computations with time_t subtract starttime, because
            ;; time_t converted to a long may result in a wrong number.
            ((ร target =) (+ (if dosec (- (:b_u_time_cur @curbuf) @starttime) (:b_u_seq_cur @curbuf)) step))
            (cond (< step 0)
            (do
                (if (< target 0)
                    ((ร target =) 0)
                )
                ((ร closest =) -1)
            )
            :else
            (do
                ((ร closest =) (if dosec (inc (- (._time libC) @starttime)) (+ (:b_u_seq_last @curbuf) 2)))
                (if (<= closest target)
                    ((ร target =) (dec closest))
                )
            ))
        ))
        ((ร long closest_start =) closest)
        ((ร long closest_seq =) (:b_u_seq_cur @curbuf))

;       int mark = 0, nomark = 0;	// %% anno dunno

        ;; May do this twice:
        ;; 1. Search for "target", update "closest" to the best match found.
        ;; 2. If "target" not found search for "closest".
        ;;
        ;; When using the closest time we use the sequence number in the second
        ;; round, because there may be several entries with the same time.

        ((ร FOR) (ร ((ร int round =) 1) (<= round 2) (ร round++))
            ;; Find the path from the current state to where we want to go.  The
            ;; desired state can be anywhere in the undo tree, need to go all over
            ;; it.  We put "nomark" in uh_walk where we have been without success,
            ;; "mark" where it could possibly be.
            ((ร mark =) (ร ++@lastmark))
            ((ร nomark =) (ร ++@lastmark))

            ((ร uhp =) (if (nil? (:b_u_curhead @curbuf)) (:b_u_newhead @curbuf) (:b_u_curhead @curbuf)))

            (while (non-nil? uhp)
                ((ร uhp.uh_walk =) mark)
                ((ร long val =) (if dosec (- (:uh_time uhp) @starttime) (:uh_seq uhp)))

                (when (== round 1)
                    ;; Remember the header that is closest to the target.
                    ;; It must be at least in the right direction (checked with "b_u_seq_cur").
                    ;; When the timestamp is equal find the highest/lowest sequence number.
                    (when (and (if (< step 0) (<= (:uh_seq uhp) (:b_u_seq_cur @curbuf)) (> (:uh_seq uhp) (:b_u_seq_cur @curbuf))) (if (and dosec (== val closest)) (if (< step 0) (< (:uh_seq uhp) closest_seq) (> (:uh_seq uhp) closest_seq)) (or (== closest closest_start) (if (< target val) (if (< target closest) (<= (- val target) (- closest target)) (<= (- val target) (- target closest))) (if (< target closest) (<= (- target val) (- closest target)) (<= (- target val) (- target closest)))))))
                        ((ร closest =) val)
                        ((ร closest_seq =) (:uh_seq uhp))
                    )
                )

                ;; Quit searching when we found a match.  But when searching for a time,
                ;; we need to continue looking for the best uh_seq.
                (when (and (== target val) (not dosec))
                    ((ร target =) (:uh_seq uhp))
                    (ร BREAK)
                )

                ;; go down in the tree if we haven't been there
                (cond (and (non-nil? (:ptr (:uh_prev uhp))) (!= (:uh_walk (:ptr (:uh_prev uhp))) nomark) (!= (:uh_walk (:ptr (:uh_prev uhp))) mark))
                (do
                    ((ร uhp =) (:ptr (:uh_prev uhp)))
                )
                ;; go to alternate branch if we haven't been there
                (and (non-nil? (:ptr (:uh_alt_next uhp))) (!= (:uh_walk (:ptr (:uh_alt_next uhp))) nomark) (!= (:uh_walk (:ptr (:uh_alt_next uhp))) mark))
                (do
                    ((ร uhp =) (:ptr (:uh_alt_next uhp)))
                )
                ;; go up in the tree if we haven't been there and we are at the start of alternate branches
                (and (non-nil? (:ptr (:uh_next uhp))) (nil? (:ptr (:uh_alt_prev uhp))) (!= (:uh_walk (:ptr (:uh_next uhp))) nomark) (!= (:uh_walk (:ptr (:uh_next uhp))) mark))
                (do
                    ;; If still at the start we don't go through this change.
                    (if (== uhp (:b_u_curhead @curbuf))
                        ((ร uhp.uh_walk =) nomark)
                    )
                    ((ร uhp =) (:ptr (:uh_next uhp)))
                )
                :else
                (do
                    ;; need to backtrack; mark this node as useless
                    ((ร uhp.uh_walk =) nomark)
                    ((ร uhp =) (if (non-nil? (:ptr (:uh_alt_prev uhp))) (:ptr (:uh_alt_prev uhp)) (:ptr (:uh_next uhp))))
                ))
            )

            (if (non-nil? uhp)    ;; found it
                (ร BREAK)
            )

            (when absolute
                (emsgn (u8 "E830: Undo number %ld not found"), step)
                ((ร RETURN) nil)
            )

            (when (== closest closest_start)
                (msg (if (< step 0) (u8 "Already at oldest change") (u8 "Already at newest change")))
                ((ร RETURN) nil)
            )

            ((ร target =) closest_seq)
            ((ร dosec =) false)
            (if (< step 0)
                ((ร above =) true)       ;; stop above the header
            )
        )

        ;; If we found it: Follow the path to go to where we want to be.
        (when (non-nil? uhp)
            ;; First go up the tree as much as needed.

            (while (not @got_int)
                ((ร uhp =) (:b_u_curhead @curbuf))
                ((ร uhp =) (if (nil? uhp) (:b_u_newhead @curbuf) (:ptr (:uh_next uhp))))
                (if (or (nil? uhp) (!= (:uh_walk uhp) mark) (and (== (:uh_seq uhp) target) (not above)))
                    (ร BREAK)
                )
                ((ร @curbuf.b_u_curhead =) uhp)
                (u-undoredo true)
                ((ร uhp.uh_walk =) nomark)   ;; don't go back down here
            )

            ;; And now go down the tree (redo), branching off where needed.

            (while (not @got_int)
                ((ร uhp =) (:b_u_curhead @curbuf))
                (if (nil? uhp)
                    (ร BREAK)
                )

                ;; Go back to the first branch with a mark.
                (while (and (non-nil? (:ptr (:uh_alt_prev uhp))) (== (:uh_walk (:ptr (:uh_alt_prev uhp))) mark))
                    ((ร uhp =) (:ptr (:uh_alt_prev uhp)))
                )

                ;; Find the last branch with a mark, that's the one.
                ((ร u_header_C last =) uhp)
                (while (and (non-nil? (:ptr (:uh_alt_next last))) (== (:uh_walk (:ptr (:uh_alt_next last))) mark))
                    ((ร last =) (:ptr (:uh_alt_next last)))
                )
                (when (!= last uhp)
                    ;; Make the used branch the first entry in the list of
                    ;; alternatives to make "u" and CTRL-R take this branch.
                    (while (non-nil? (:ptr (:uh_alt_prev uhp)))
                        ((ร uhp =) (:ptr (:uh_alt_prev uhp)))
                    )
                    (if (non-nil? (:ptr (:uh_alt_next last)))
                        ((ร last.uh_alt_next.ptr.uh_alt_prev.ptr =) (:ptr (:uh_alt_prev last)))
                    )
                    ((ร last.uh_alt_prev.ptr.uh_alt_next.ptr =) (:ptr (:uh_alt_next last)))
                    ((ร last.uh_alt_prev.ptr =) nil)
                    ((ร last.uh_alt_next.ptr =) uhp)
                    ((ร uhp.uh_alt_prev.ptr =) last)

                    (if (== (:b_u_oldhead @curbuf) uhp)
                        ((ร @curbuf.b_u_oldhead =) last)
                    )
                    ((ร uhp =) last)
                    (if (non-nil? (:ptr (:uh_next uhp)))
                        ((ร uhp.uh_next.ptr.uh_prev.ptr =) uhp)
                    )
                )
                ((ร @curbuf.b_u_curhead =) uhp)

                (if (!= (:uh_walk uhp) mark)
                    (ร BREAK)      ;; must have reached the target
                )

                ;; Stop when going backwards in time and didn't find
                ;; the exact header we were looking for.
                (when (and (== (:uh_seq uhp) target) above)
                    ((ร @curbuf.b_u_seq_cur =) (dec target))
                    (ร BREAK)
                )

                (u-undoredo false)

                ;; Advance "curhead" to below the header we last used.
                ;; If it becomes null, then we need to set "newhead" to this leaf.
                (if (nil? (:ptr (:uh_prev uhp)))
                    ((ร @curbuf.b_u_newhead =) uhp)
                )
                ((ร @curbuf.b_u_curhead =) (:ptr (:uh_prev uhp)))
                ((ร did_undo =) false)

                (if (== (:uh_seq uhp) target)   ;; found it!
                    (ร BREAK)
                )

                ((ร uhp =) (:ptr (:uh_prev uhp)))
                (when (or (nil? uhp) (!= (:uh_walk uhp) mark))
                    ;; Need to redo more but can't find it...
                    (emsg2 e_intern2, (u8 "undo-time()"))
                    (ร BREAK)
                )
            )
        )

        (u-undo-end did_undo, absolute)
        nil
    ))

;; u-undoredo: common code for undo and redo
;;
;; The lines in the file are replaced by the lines in the entry list at
;; curbuf.b_u_curhead.  The replaced lines in the file are saved in the entry
;; list for the next undo/redo.
;;
;; When "undo" is true we go up in the tree, when false we go down.

(defn- #_void u-undoredo [#_boolean undo]
    (ยง
        ((ร Bytes[] newarray =) nil)
        ((ร long newlnum =) MAXLNUM)
        ((ร u_entry_C newlist =) nil)
        ((ร u_header_C curhead =) (:b_u_curhead @curbuf))

        ((ร int old_flags =) (:uh_flags curhead))
        ((ร int new_flags =) (+ (if @(:b_changed @curbuf) UH_CHANGED 0) (if (!= (& (:ml_flags (:b_ml @curbuf)) ML_EMPTY) 0) UH_EMPTYBUF 0)))
        (setpcmark)

        ;; save marks before undo/redo

        ((ร pos_C[] namedm =) (ARRAY-pos NMARKS))
        (dotimes [#_int i NMARKS]
            (COPY-pos (... namedm i), (... (:b_namedm @curbuf) i))
        )

        ((ร visualinfo_C visualinfo =) (NEW_visualinfo_C))
        (COPY-visualinfo visualinfo, (:b_visual @curbuf))

        ((ร @curbuf.b_op_start.lnum =) (:ml_line_count (:b_ml @curbuf)))
        ((ร @curbuf.b_op_start.col =) 0)
        ((ร @curbuf.b_op_end.lnum =) 0)
        ((ร @curbuf.b_op_end.col =) 0)

        ((ร FOR) (ร ((ร u_entry_C uep =) (ร curhead.uh_entry, nuep)) (non-nil? uep) ((ร uep =) nuep))
            ((ร long top =) (:ue_top uep))
            ((ร long bot =) (:ue_bot uep))
            (if (zero? bot)
                ((ร bot =) (+ (:ml_line_count (:b_ml @curbuf)) 1))
            )
            (when (or (> top (:ml_line_count (:b_ml @curbuf))) (<= bot top) (> bot (+ (:ml_line_count (:b_ml @curbuf)) 1)))
                (emsg (u8 "E438: u-undo: line numbers wrong"))
                (changed)          ;; don't want UNCHANGED now
                ((ร RETURN) nil)
            )

            ((ร int oldsize =) (int (- bot top 1)))       ;; number of lines before undo
            ((ร int newsize =) (int (:ue_size uep)))         ;; number of lines after undo

            (when (< top newlnum)
                ;; If the saved cursor is somewhere in this undo block,
                ;; move it to the remembered position.
                ;; Makes "gwap" put the cursor back where it was.
                ((ร long lnum =) (:lnum (:uh_cursor curhead)))
                (cond (and (<= top lnum) (<= lnum (+ top newsize 1)))
                (do
                    (COPY-pos (:w_cursor @curwin), (:uh_cursor curhead))
                    ((ร newlnum =) (- (:lnum (:w_cursor @curwin)) 1))
                )
                :else
                (do
                    ;; Use the first line that actually changed.
                    ;; Avoids that undoing auto-formatting puts the cursor in the previous line.
                    (ร int i)
                    ((ร FOR) (ร ((ร i =) 0) (and (< i newsize) (< i oldsize)) (ร i++))
                        (if (non-zero? (STRCMP (... (:ue_array uep) i), (ml-get (+ top 1 i))))
                            (ร BREAK)
                        )
                    )
                    (cond (and (== i newsize) (== newlnum MAXLNUM) (nil? (:ue_next uep)))
                    (do
                        ((ร newlnum =) top)
                        ((ร @curwin.w_cursor.lnum =) (inc newlnum))
                    )
                    (< i newsize)
                    (do
                        ((ร newlnum =) (+ top i))
                        ((ร @curwin.w_cursor.lnum =) (inc newlnum))
                    ))
                ))
            )

            ((ร boolean empty_buffer =) false)   ;; buffer became empty

            ;; delete the lines between top and bot and save them in "newarray"
            (cond (< 0 oldsize)
            (do
                ((ร newarray =) (ร new Bytes[oldsize]))

                ;; delete backwards, it goes faster in most cases
                ((ร long lnum =) (dec bot))
                ((ร FOR) (ร ((ร int i =) oldsize) (< 0 (ร i--)) (ร lnum--))
                    ((ร newarray[i] =) (STRDUP (ml-get lnum)))
                    ;; remember we deleted the last line in the buffer,
                    ;; and a dummy empty line will be inserted
                    (if (== (:ml_line_count (:b_ml @curbuf)) 1)
                        ((ร empty_buffer =) true)
                    )
                    (ml-delete lnum, false)
                )
            )
            :else
            (do
                ((ร newarray =) nil)
            ))

            ;; insert the lines in u_array between top and bot
            ((ร long lnum =) top)
            ((ร FOR) (ร ((ร int i =) 0) (< i newsize) (ร i++, lnum++))
                ;; If the file is empty, there is an empty line 1 that we
                ;; should get rid of, by replacing it with the new line.

                (if (and empty_buffer (zero? lnum))
                    (ml-replace 1, (... (:ue_array uep) i))
                    (ml-append lnum, (... (:ue_array uep) i)))
            )

            ;; adjust marks
            (when (!= oldsize newsize)
                (mark-adjust (inc top), (+ top oldsize), MAXLNUM, (- newsize oldsize))
                (if (> (:lnum (:b_op_start @curbuf)) (+ top oldsize))
                    ((ร @curbuf.b_op_start.lnum =) (+ (:lnum (:b_op_start @curbuf)) (- newsize oldsize)))
                )
                (if (> (:lnum (:b_op_end @curbuf)) (+ top oldsize))
                    ((ร @curbuf.b_op_end.lnum =) (+ (:lnum (:b_op_end @curbuf)) (- newsize oldsize)))
                )
            )

            (changed-lines (inc top), 0, bot, (- newsize oldsize))

            ;; set '[ and '] mark
            (if (< (inc top) (:lnum (:b_op_start @curbuf)))
                ((ร @curbuf.b_op_start.lnum =) (inc top))
            )
            (cond (and (zero? newsize) (< (:lnum (:b_op_end @curbuf)) (inc top)))
            (do
                ((ร @curbuf.b_op_end.lnum =) (inc top))
            )
            (< (:lnum (:b_op_end @curbuf)) (+ top newsize))
            (do
                ((ร @curbuf.b_op_end.lnum =) (+ top newsize))
            ))

            ((ร @u_newcount =) (+ @u_newcount newsize))
            ((ร @u_oldcount =) (+ @u_oldcount oldsize))
            ((ร uep.ue_size =) oldsize)
            ((ร uep.ue_array =) newarray)
            ((ร uep.ue_bot =) (+ top newsize 1))

            ;; insert this entry in front of the new entry list

            ((ร nuep =) (:ue_next uep))
            ((ร uep.ue_next =) newlist)
            ((ร newlist =) uep)
        )

        ((ร curhead.uh_entry =) newlist)
        ((ร curhead.uh_flags =) new_flags)
        (if (and (flag? old_flags UH_EMPTYBUF) (bufempty))
            ((ร @curbuf.b_ml.ml_flags =) (| (:ml_flags (:b_ml @curbuf)) ML_EMPTY))
        )
        (if (flag? old_flags UH_CHANGED)
            (changed)
            (unchanged @curbuf))

        ;; restore marks from before undo/redo

        (dotimes [#_int i NMARKS]
            (if (non-zero? (:lnum (... (:uh_namedm curhead) i)))
                (COPY-pos (... (:b_namedm @curbuf) i), (... (:uh_namedm curhead) i)))
            (if (non-zero? (:lnum (... namedm i)))
                (COPY-pos (... (:uh_namedm curhead) i), (... namedm i))
                ((ร curhead.uh_namedm[i].lnum =) 0)
            )
        )
        (when (non-zero? (:lnum (:vi_start (:uh_visual curhead))))
            (COPY-visualinfo (:b_visual @curbuf), (:uh_visual curhead))
            (COPY-visualinfo (:uh_visual curhead), visualinfo)
        )

        ;; If the cursor is only off by one line,
        ;; put it at the same position as before starting the change (for the "o" command).
        ;; Otherwise the cursor should go to the first undone line.

        (if (and (== (+ (:lnum (:uh_cursor curhead)) 1) (:lnum (:w_cursor @curwin))) (< 1 (:lnum (:w_cursor @curwin))))
            (ร --@curwin.w_cursor.lnum)
        )
        (cond (<= (:lnum (:w_cursor @curwin)) (:ml_line_count (:b_ml @curbuf)))
        (do
            (cond (== (:lnum (:uh_cursor curhead)) (:lnum (:w_cursor @curwin)))
            (do
                ((ร @curwin.w_cursor.col =) (:col (:uh_cursor curhead)))
                (if (and (virtual-active) (<= 0 (:uh_cursor_vcol curhead)))
                    (coladvance (int (:uh_cursor_vcol curhead)))
                    ((ร @curwin.w_cursor.coladd =) 0)
                )
            )
            :else
            (do
                (beginline (| BL_SOL BL_FIX))
            ))
        )
        :else
        (do
            ;; We get here with the current cursor line being past the end (eg
            ;; after adding lines at the end of the file, and then undoing it).
            ;; check-cursor() will move the cursor to the last line.  Move it to
            ;; the first column here.
            ((ร @curwin.w_cursor.col =) 0)
            ((ร @curwin.w_cursor.coladd =) 0)
        ))

        ;; Make sure the cursor is on an existing line and column.
        (check-cursor)

        ;; Remember where we are for "g-" and ":earlier 10s".
        ((ร @curbuf.b_u_seq_cur =) (:uh_seq curhead))
        (when undo
            ;; We are below the previous undo.  However, to make ":earlier 1s"
            ;; work we compute this as being just above the just undone change.
            (ร --@curbuf.b_u_seq_cur)
        )

        ;; The timestamp can be the same for multiple changes,
        ;; just use the one of the undone/redone change.
        ((ร @curbuf.b_u_time_cur =) (:uh_time curhead))
        nil
    ))

;; If we deleted or added lines, report the number of less/more lines.
;; Otherwise, report the number of changes
;; (this may be incorrect in some cases, but it's better than nothing).

(defn- #_void u-undo-end [#_boolean did_undo, #_boolean absolute]
    ;; did_undo: just did an undo
    ;; absolute: used ":undo N"
    (ยง
        (if (not (messaging))        ;; 'lazyredraw' set, don't do messages now
            ((ร RETURN) nil)
        )

        (if (non-zero? (& (:ml_flags (:b_ml @curbuf)) ML_EMPTY))
            (swap! u_newcount dec))

        ((ร @u_oldcount =) (- @u_oldcount @u_newcount))

        (ร Bytes msgstr)
        (cond (== @u_oldcount -1)
        (do
            ((ร msgstr =) (u8 "more line"))
        )
        (< @u_oldcount 0)
        (do
            ((ร msgstr =) (u8 "more lines"))
        )
        (== @u_oldcount 1)
        (do
            ((ร msgstr =) (u8 "line less"))
        )
        (< 1 @u_oldcount)
        (do
            ((ร msgstr =) (u8 "fewer lines"))
        )
        :else
        (do
            (reset! u_oldcount @u_newcount)

            ((ร msgstr =) (if (== @u_newcount 1) (u8 "change") (u8 "changes")))
        ))

        (ร u_header_C uhp)
        (cond (non-nil? (:b_u_curhead @curbuf))
        (do
            ;; For ":undo N" we prefer a "after #N" message.
            (cond (and absolute (non-nil? (:ptr (:uh_next (:b_u_curhead @curbuf)))))
            (do
                ((ร uhp =) (:ptr (:uh_next (:b_u_curhead @curbuf))))
                ((ร did_undo =) false)
            )
            did_undo
            (do
                ((ร uhp =) (:b_u_curhead @curbuf))
            )
            :else
            (do
                ((ร uhp =) (:ptr (:uh_next (:b_u_curhead @curbuf))))
            ))
        )
        :else
        (do
            ((ร uhp =) (:b_u_newhead @curbuf))
        ))

        ((ร Bytes msgbuf =) (Bytes. 80))
        (if (nil? uhp)
            (eos! msgbuf)
            (u-add-time msgbuf, (.size msgbuf), (:uh_time uhp)))

        ((ร FOR) (ร ((ร window_C wp =) @firstwin) (non-nil? wp) ((ร wp =) (:w_next wp)))
            (if (< 0 @(:wo_cole (:w_options wp)))
                (redraw-win-later wp, NOT_VALID))
        )

        (smsg (u8 "%ld %s; %s #%ld  %s"), (if (< @u_oldcount 0) (- @u_oldcount) @u_oldcount), msgstr, (if did_undo (u8 "before") (u8 "after")), (if (nil? uhp) 0 (:uh_seq uhp)), msgbuf)
        nil
    ))

;; u-sync: stop adding to the current entry list

(defn- #_void u-sync [#_boolean force]
    ;; force: Also sync when no_u_sync is set.
    (ยง
        ;; Skip it when already synced or syncing is disabled.
        (if (or (:b_u_synced @curbuf) (and (not force) (< 0 @no_u_sync)))
            ((ร RETURN) nil)
        )

        (cond (< (get-undolevel) 0)
        (do
            ((ร @curbuf.b_u_synced =) true)   ;; no entries, nothing to do
        )
        :else
        (do
            (u-getbot)                 ;; compute ue_bot of previous u-save()
            ((ร @curbuf.b_u_curhead =) nil)
        ))
        nil
    ))

;; Put the timestamp of an undo header in "buf[buflen]" in a nice format.

(defn- #_void u-add-time [#_Bytes buf, #_int buflen, #_long seconds]
    (ยง
        (cond (<= 100 (- (._time libC) seconds))
        (do
            ((ร tm_C curtime =) (._localtime libC seconds))
            (cond (< (- (._time libC) seconds) (* 60 60 12))
            (do
                ;; within 12 hours
                (.strftime libC buf, buflen, (u8 "%H:%M:%S"), curtime)
            )
            :else
            (do
                ;; longer ago
                (.strftime libC buf, buflen, (u8 "%Y/%m/%d %H:%M:%S"), curtime)
            ))
        )
        :else
        (do
;%%         (vim_snprintf buf, buflen, (u8 "%ld seconds ago"), (- (._time libC) seconds))
        ))
        nil
    ))

;; Get pointer to last added entry.
;; If it's not valid, give an error message and return null.

(defn- #_u_entry_C u-get-headentry []
    (ยง
        (when (or (nil? (:b_u_newhead @curbuf)) (nil? (:uh_entry (:b_u_newhead @curbuf))))
            (emsg (u8 "E439: undo list corrupt"))
            ((ร RETURN) nil)
        )
        (:uh_entry (:b_u_newhead @curbuf))
    ))

;; u-getbot(): compute the line number of the previous u-save()
;;              It is called only when b_u_synced is false.

(defn- #_void u-getbot []
    (ยง
        ((ร u_entry_C uep =) (u-get-headentry)) ;; check for corrupt undo list
        (if (nil? uep)
            ((ร RETURN) nil)
        )

        ((ร uep =) (:uh_getbot_entry (:b_u_newhead @curbuf)))
        (when (non-nil? uep)
            ;; the new ue_bot is computed from the number of lines that has been
            ;; inserted (0 - deleted) since calling u-save().  This is equal to the
            ;; old line count subtracted from the current line count.

            ((ร long extra =) (- (:ml_line_count (:b_ml @curbuf)) (:ue_lcount uep)))
            ((ร uep.ue_bot =) (+ (:ue_top uep) (:ue_size uep) 1 extra))
            (when (or (< (:ue_bot uep) 1) (< (:ml_line_count (:b_ml @curbuf)) (:ue_bot uep)))
                (emsg (u8 "E440: undo line missing"))
                ((ร uep.ue_bot =) (+ (:ue_top uep) 1))    ;; assume all lines deleted, will
                                                ;; get all the old lines back
                                                ;; without deleting the current ones
            )

            ((ร @curbuf.b_u_newhead.uh_getbot_entry =) nil)
        )

        ((ร @curbuf.b_u_synced =) true)
        nil
    ))

;; Free one header "uhp" and its entry list and adjust the pointers.

(defn- #_void u-freeheader [#_buffer_C buf, #_u_header_C uhp, #_u_header_C* uhpp]
    ;; uhpp: if not null reset when freeing this header
    (ยง
        ;; When there is an alternate redo list free that branch completely,
        ;; because we can never go there.
        (if (non-nil? (:ptr (:uh_alt_next uhp)))
            (u-freebranch buf, (:ptr (:uh_alt_next uhp)), uhpp))

        (if (non-nil? (:ptr (:uh_alt_prev uhp)))
            ((ร uhp.uh_alt_prev.ptr.uh_alt_next.ptr =) nil)
        )

        ;; Update the links in the list to remove the header.
        (if (nil? (:ptr (:uh_next uhp)))
            ((ร buf.b_u_oldhead =) (:ptr (:uh_prev uhp)))
            ((ร uhp.uh_next.ptr.uh_prev.ptr =) (:ptr (:uh_prev uhp)))
        )

        (cond (nil? (:ptr (:uh_prev uhp)))
        (do
            ((ร buf.b_u_newhead =) (:ptr (:uh_next uhp)))
        )
        :else
        (do
            ((ร FOR) (ร ((ร u_header_C uhap =) (:ptr (:uh_prev uhp))) (non-nil? uhap) ((ร uhap =) (:ptr (:uh_alt_next uhap))))
                ((ร uhap.uh_next.ptr =) (:ptr (:uh_next uhp)))
            )
        ))

        (u-freeentries buf, uhp, uhpp)
        nil
    ))

;; Free an alternate branch and any following alternate branches.

(defn- #_void u-freebranch [#_buffer_C buf, #_u_header_C uhp, #_u_header_C* uhpp]
    ;; uhpp: if not null reset when freeing this header
    (ยง
        ;; If this is the top branch we may need to use u-freeheader() to update all the pointers.
        (when (== uhp (:b_u_oldhead buf))
            (while (non-nil? (:b_u_oldhead buf))
                (u-freeheader buf, (:b_u_oldhead buf), uhpp)
            )
            ((ร RETURN) nil)
        )

        (if (non-nil? (:ptr (:uh_alt_prev uhp)))
            ((ร uhp.uh_alt_prev.ptr.uh_alt_next.ptr =) nil)
        )

        ((ร FOR) (ร ((ร u_header_C next =) uhp) (non-nil? next) nil)
            ((ร u_header_C tofree =) next)
            (if (non-nil? (:ptr (:uh_alt_next tofree)))
                (u-freebranch buf, (:ptr (:uh_alt_next tofree)), uhpp))    ;; recursive
            ((ร next =) (:ptr (:uh_prev tofree)))
            (u-freeentries buf, tofree, uhpp)
        )
        nil
    ))

;; Free all the undo entries for one header and the header itself.
;; This means that "uhp" is invalid when returning.

(defn- #_void u-freeentries [#_buffer_C buf, #_u_header_C uhp, #_u_header_C* uhpp]
    ;; uhpp: if not null reset when freeing this header
    (ยง
        ;; Check for pointers to the header that become invalid now.
        (if (== (:b_u_curhead buf) uhp)
            ((ร buf.b_u_curhead =) nil)
        )
        (if (== (:b_u_newhead buf) uhp)
            ((ร buf.b_u_newhead =) nil)         ;; freeing the newest entry
        )
        (if (and (non-nil? uhpp) (== uhp (... uhpp 0)))
            ((ร uhpp[0] =) nil)
        )

        (ร --buf.b_u_numhead)
        nil
    ))

;; save the line "lnum" for the "U" command

(defn- #_void u-saveline [#_long lnum]
    (ยง
        (if (== lnum (:b_u_line_lnum @curbuf))                   ;; line is already saved
            ((ร RETURN) nil)
        )
        (if (or (< lnum 1) (< (:ml_line_count (:b_ml @curbuf)) lnum))   ;; should never happen
            ((ร RETURN) nil)
        )

        (u-clearline)

        ((ร @curbuf.b_u_line_lnum =) lnum)
        ((ร @curbuf.b_u_line_colnr =) (if (== (:lnum (:w_cursor @curwin)) lnum) (:col (:w_cursor @curwin)) 0))
        ((ร @curbuf.b_u_line_ptr =) (STRDUP (ml-get lnum)))
        nil
    ))

;; clear the line saved for the "U" command
;; (this is used externally for crossing a line while in insert mode)

(defn- #_void u-clearline []
    (ยง
        (when (non-nil? (:b_u_line_ptr @curbuf))
            ((ร @curbuf.b_u_line_ptr =) nil)
            ((ร @curbuf.b_u_line_lnum =) 0)
        )
        nil
    ))

;; Implementation of the "U" command.
;; Differentiation from vi: "U" can be undone with the next "U".
;; We also allow the cursor to be in another line.

(defn- #_void u-undoline []
    (ยง
        (when (or (nil? (:b_u_line_ptr @curbuf)) (< (:ml_line_count (:b_ml @curbuf)) (:b_u_line_lnum @curbuf)))
            (beep-flush)
            ((ร RETURN) nil)
        )

        ;; first save the line for the 'u' command
        (if (not (u-savecommon (- (:b_u_line_lnum @curbuf) 1), (+ (:b_u_line_lnum @curbuf) 1), 0, false))
            ((ร RETURN) nil)
        )

        ((ร Bytes oldp =) (STRDUP (ml-get (:b_u_line_lnum @curbuf))))

        (ml-replace (:b_u_line_lnum @curbuf), (:b_u_line_ptr @curbuf))
        (changed-bytes (:b_u_line_lnum @curbuf), 0)
        ((ร @curbuf.b_u_line_ptr =) oldp)

        ((ร int t =) (:b_u_line_colnr @curbuf))
        (if (== (:lnum (:w_cursor @curwin)) (:b_u_line_lnum @curbuf))
            ((ร @curbuf.b_u_line_colnr =) (:col (:w_cursor @curwin)))
        )
        ((ร @curwin.w_cursor.col =) t)
        ((ร @curwin.w_cursor.lnum =) (:b_u_line_lnum @curbuf))
        (check-cursor-col)
        nil
    ))

;;; ============================================================================================== VimV

;; term.c: functions for controlling the terminal -------------------------------------------------

;; Each termcap is a list of btcap_C structures.
;; 'bt_key' is either a KS_xxx code (>= 0), or a K_xxx code.

(class! #_final btcap_C
    [
        (field int      bt_key)
        (field Bytes    bt_seq)
    ])

(final btcap_C* xterm_tcaps
    [
        (->btcap_C KS_NAME,      (u8 "xterm")                ),

        (->btcap_C KS_CE,        (u8 "\033[K")               ),
        (->btcap_C KS_AL,        (u8 "\033[L")               ),
        (->btcap_C KS_CAL,       (u8 "\033[%p1%dL")          ),
        (->btcap_C KS_DL,        (u8 "\033[M")               ),
        (->btcap_C KS_CDL,       (u8 "\033[%p1%dM")          ),
        (->btcap_C KS_CS,        (u8 "\033[%i%p1%d;%p2%dr")  ),
        (->btcap_C KS_CL,        (u8 "\033[H\033[2J")        ),
        (->btcap_C KS_CD,        (u8 "\033[J")               ),
        (->btcap_C KS_ME,        (u8 "\033[m")               ),
        (->btcap_C KS_MR,        (u8 "\033[7m")              ),
        (->btcap_C KS_MD,        (u8 "\033[1m")              ),
        (->btcap_C KS_UE,        (u8 "\033[m")               ),
        (->btcap_C KS_US,        (u8 "\033[4m")              ),
        (->btcap_C KS_MS,        (u8 "y")                    ),
        (->btcap_C KS_UT,        (u8 "y")                    ),
        (->btcap_C KS_LE,        (u8 "\b")                   ),
        (->btcap_C KS_CM,        (u8 "\033[%i%p1%d;%p2%dH")  ),
        (->btcap_C KS_SR,        (u8 "\033M")                ),
        (->btcap_C KS_CRI,       (u8 "\033[%p1%dC")          ),
        (->btcap_C KS_KS,        (u8 "\033[?1h\033=")        ),
        (->btcap_C KS_KE,        (u8 "\033[?1l\033>")        ),
        (->btcap_C KS_TI,        (u8 "\0337\033[?47h")       ),
        (->btcap_C KS_TE,        (u8 "\033[2J\033[?47l\0338")),
        (->btcap_C KS_CWS,       (u8 "\033[8;%p1%d;%p2%dt")  ),

        (->btcap_C K_UP,         (u8 "\033O*A")              ),
        (->btcap_C K_DOWN,       (u8 "\033O*B")              ),
        (->btcap_C K_RIGHT,      (u8 "\033O*C")              ),
        (->btcap_C K_LEFT,       (u8 "\033O*D")              ),
        ;; An extra set of cursor keys for vt100 mode.
        (->btcap_C K_XUP,        (u8 "\033[1;*A")            ),
        (->btcap_C K_XDOWN,      (u8 "\033[1;*B")            ),
        (->btcap_C K_XRIGHT,     (u8 "\033[1;*C")            ),
        (->btcap_C K_XLEFT,      (u8 "\033[1;*D")            ),
        ;; An extra set of function keys for vt100 mode.
        (->btcap_C K_XF1,        (u8 "\033O*P")              ),
        (->btcap_C K_XF2,        (u8 "\033O*Q")              ),
        (->btcap_C K_XF3,        (u8 "\033O*R")              ),
        (->btcap_C K_XF4,        (u8 "\033O*S")              ),
        (->btcap_C K_F1,         (u8 "\033[11;*~")           ),
        (->btcap_C K_F2,         (u8 "\033[12;*~")           ),
        (->btcap_C K_F3,         (u8 "\033[13;*~")           ),
        (->btcap_C K_F4,         (u8 "\033[14;*~")           ),
        (->btcap_C K_F5,         (u8 "\033[15;*~")           ),
        (->btcap_C K_F6,         (u8 "\033[17;*~")           ),
        (->btcap_C K_F7,         (u8 "\033[18;*~")           ),
        (->btcap_C K_F8,         (u8 "\033[19;*~")           ),
        (->btcap_C K_F9,         (u8 "\033[20;*~")           ),
        (->btcap_C K_F10,        (u8 "\033[21;*~")           ),
        (->btcap_C K_F11,        (u8 "\033[23;*~")           ),
        (->btcap_C K_F12,        (u8 "\033[24;*~")           ),
        (->btcap_C K_S_TAB,      (u8 "\033[Z")               ),
        (->btcap_C K_HELP,       (u8 "\033[28;*~")           ),
        (->btcap_C K_UNDO,       (u8 "\033[26;*~")           ),
        (->btcap_C K_INS,        (u8 "\033[2;*~")            ),
        (->btcap_C K_HOME,       (u8 "\033[1;*H")            ),
     ;; (->btcap_C K_S_HOME,     (u8 "\033O2H")              ),
     ;; (->btcap_C K_C_HOME,     (u8 "\033O5H")              ),
        (->btcap_C K_KHOME,      (u8 "\033[1;*~")            ),
        (->btcap_C K_XHOME,      (u8 "\033O*H")              ),      ;; other Home
        (->btcap_C K_ZHOME,      (u8 "\033[7;*~")            ),      ;; other Home
        (->btcap_C K_END,        (u8 "\033[1;*F")            ),
     ;; (->btcap_C K_S_END,      (u8 "\033O2F")              ),
     ;; (->btcap_C K_C_END,      (u8 "\033O5F")              ),
        (->btcap_C K_KEND,       (u8 "\033[4;*~")            ),
        (->btcap_C K_XEND,       (u8 "\033O*F")              ),      ;; other End
        (->btcap_C K_ZEND,       (u8 "\033[8;*~")            ),
        (->btcap_C K_PAGEUP,     (u8 "\033[5;*~")            ),
        (->btcap_C K_PAGEDOWN,   (u8 "\033[6;*~")            ),
        (->btcap_C K_KPLUS,      (u8 "\033O*k")              ),      ;; keypad plus
        (->btcap_C K_KMINUS,     (u8 "\033O*m")              ),      ;; keypad minus
        (->btcap_C K_KDIVIDE,    (u8 "\033O*o")              ),      ;; keypad /
        (->btcap_C K_KMULTIPLY,  (u8 "\033O*j")              ),      ;; keypad *
        (->btcap_C K_KENTER,     (u8 "\033O*M")              ),      ;; keypad Enter
        (->btcap_C K_KPOINT,     (u8 "\033O*n")              ),      ;; keypad .
        (->btcap_C K_KDEL,       (u8 "\033[3;*~")            ),      ;; keypad Del
    ])

(atom! boolean need_gather)                     ;; need to fill termleader[]
(final Bytes termleader (Bytes. (inc 256)))     ;; for check-termcode()

;; Parsing of the builtin termcap entries.

(defn- #_void parse-builtin-tcap []
    (ยง
        ((ร btcap_C[] tcaps =) xterm_tcaps)

        ((ร FOR) (ร ((ร int i =) 1) (< i (:length tcaps)) (ร i++))
            ((ร int k =) (:bt_key (... tcaps i)))
            (cond (< k 0)
            (do
                ((ร Bytes name =) (Bytes. 2))
                (.be name 0, (KEY2TERMCAP0 k))
                (.be name 1, (KEY2TERMCAP1 k))

                (if (nil? (find-termcode name))
                    (add-termcode name, (:bt_seq (... tcaps i))))
            )
            :else ;; KS_xx entry
            (do
                ;; Only set the value if it wasn't set yet.
                (when (or (nil? (... (... term_strings k) 0)) (== (... (... term_strings k) 0) EMPTY_OPTION))
                    ((ร term_strings[k][0] =) (:bt_seq (... tcaps i)))
                )
            ))
        )
        nil
    ))

;; Set terminal options.
;;
;; While doing this, until ttest(), some options may be null, be careful.

(defn- #_void set-term []
    (ยง
        (out-flush)

        ;; Reset a few things before clearing the old options.  This may cause
        ;; outputting a few things that the terminal doesn't understand, but the
        ;; screen will be cleared later, so this is OK.

        (stoptermcap)                  ;; stop termcap mode

        (clear-termcodes)
        (parse-builtin-tcap)

        ;; Any "stty" settings override the default for t_kb from the termcap.

        (get-stty)

        ;; If the termcap has no entry for 'bs' and/or 'del' and the ioctl()
        ;; also didn't work, use the default CTRL-H.
        ;; The default for t_kD is DEL, unless t_kb is DEL.

        ((ร Bytes bs_p =) (find-termcode (u8 "kb")))
        (if (or (nil? bs_p) (eos? bs_p))
            (add-termcode (u8 "kb"), ((ร bs_p =) CTRL_H_STR)))

        ((ร Bytes del_p =) (find-termcode (u8 "kD")))
        (if (and (or (nil? del_p) (eos? del_p)) (or (nil? bs_p) (!= (.at bs_p 0) DEL)))
            (add-termcode (u8 "kD"), DEL_STR))

        (ttest true)                ;; make sure we have a valid set of terminal codes

        (reset! full_screen true)             ;; we can use termcap codes from now on

        ;; Initialize the terminal with the appropriate termcap codes.

        (when (!= @starting NO_SCREEN)
            (starttermcap)             ;; may change terminal mode
        )

        (set-shellsize 80, 24, false)    ;; may change Rows

        (when (!= @starting NO_SCREEN)
            (if @scroll_region
                (scroll-region-reset))          ;; in case Rows changed
        )
        nil
    ))

;; the number of calls to ui-write is reduced by using the buffer "out_buf"

(final int OUT_SIZE      2047)

(final Bytes out_buf (Bytes. (inc OUT_SIZE)))
(atom! int out_pos)         ;; number of chars in "out_buf"

;; out-flush(): flush the output buffer

(defn- #_void out-flush []
    (ยง
        (when (non-zero? @out_pos)
            ;; set out_pos to 0 before ui-write, to avoid recursiveness
            ((ร int len =) @out_pos)
            (reset! out_pos 0)
            (ui-write out_buf, len)
        )
        nil
    ))

;; Sometimes a byte out of a multi-byte character is written with out-char().
;; To avoid flushing half of the character, call this function first.

(defn- #_void out-flush-check []
    nil)

;; out-char(c): put a byte into the output buffer.
;;              Flush it if it becomes full.
;; This should not be used for outputting text on the screen
;; (use functions like msg-puts() and screen-putchar() for that).

(defn- #_void out-char [#_byte c]
    (ยง
        (if (== c (byte \newline))      ;; turn LF into CR-LF (CRMOD doesn't seem to do this)
            (out-char (byte \return)))

        (.be out_buf (ร @out_pos++), c)

        ;; For testing we flush each time.
        (when (or (<= OUT_SIZE @out_pos) (non-zero? @p_wd))
            (out-flush)
        )
        nil
    ))

;; out-char-nf(c): like out-char(), but don't flush when "p_wd" is set

(defn- #_void out-char-nf [#_byte c]
    (ยง
        (if (== c (byte \newline))      ;; turn LF into CR-LF (CRMOD doesn't seem to do this)
            (out-char-nf (byte \return)))

        (.be out_buf (ร @out_pos++), c)

        (when (<= OUT_SIZE @out_pos)
            (out-flush)
        )
        nil
    ))

(defn- #_Bytes _addfmt [#_Bytes buf, #_Bytes fmt, #_int val]
    (ยง
        (.sprintf libC buf, fmt, val)
        (while (non-eos? buf)
            ((ร buf =) (.plus buf 1))
        )
        buf
    ))

(final Bytes tgoto_UP)	;; %% nada!
(final Bytes tgoto_BC)	;; %% nada!
(final Bytes tgoto_buffer (Bytes. 32))

;; Decode cm cursor motion string.
;; cm is cursor motion string, row and col are the desired destination.
;; Returns a pointer to the decoded string, or "OOPS" if it cannot be decoded.
;;
;; Accepted escapes are:
;;      %d       as in printf, 0 origin.
;;      %2, %3   like %02d, %03d in printf.
;;      %.       like %c
;;      %+x      adds <x> to value, then %.
;;      %>xy     if value > x, adds y. No output.
;;      %i       increments row & col. No output.
;;      %r       reverses order of row & col. No output.
;;      %%       prints as a single %.
;;      %n       exclusive or row & col with 0140.
;;      %B       BCD, no output.
;;      %D       reverse coding (x-2*(x%16)), no output.

(defn- #_Bytes _tgoto [#_Bytes cm, #_int col, #_int row]
    ;; cm: string, from termcap
    ;; col: x position
    ;; row: y position
    (ยง
        (if (nil? cm)
            ((ร RETURN) (u8 "OOPS"))                          ;; kludge, but standard
        )

        ((ร boolean reverse =) false)                    ;; reverse flag
        ((ร boolean addup =) false)                      ;; add upline
        ((ร boolean addbak =) false)                     ;; add backup

        ((ร Bytes p =) tgoto_buffer)                    ;; pointer in returned string

        (while (non-eos? cm)
            ((ร byte b =) (.at ((ร cm =) (.plus cm 1)) -1))
            (when (!= b (byte \%))                           ;; normal char
                (.be ((ร p =) (.plus p 1)) -1, b)
                (ร CONTINUE)
            )

            ((ร b =) (.at ((ร cm =) (.plus cm 1)) -1))
            ((ร SWITCH) b                              ;; % escape
                ((ร CASE) (byte \d))                           ;; decimal
                (do
                    ((ร p =) (_addfmt p, (u8 "%d"), row))
                    ((ร row =) col)
                    (ร BREAK)
                )

                ((ร CASE) (byte \2))                           ;; 2 digit decimal
                (do
                    ((ร p =) (_addfmt p, (u8 "%02d"), row))
                    ((ร row =) col)
                    (ร BREAK)
                )

                ((ร CASE) (byte \3))                           ;; 3 digit decimal
                (do
                    ((ร p =) (_addfmt p, (u8 "%03d"), row))
                    ((ร row =) col)
                    (ร BREAK)
                )

                ((ร CASE) (byte \>))                           ;; %>xy: if >x, add y
                (do
                    ((ร byte x =) (ร (cm = cm.plus(1)).at(-1), y = (cm = cm.plus(1)).at(-1)))
                    (if (> col x)
                        ((ร col =) (+ col y))
                    )
                    (if (> row x)
                        ((ร row =) (+ row y))
                    )
                    (ร BREAK)
                )

                ((ร CASE) (byte \+))                           ;; %+c: add c
                (do
                    ((ร row =) (+ row (.at ((ร cm =) (.plus cm 1)) -1)))
                )

                ((ร CASE) (byte \.))                           ;; print x/y
                (do
                                                          ;; these are chars that UNIX hates
                    (when (or (== row TAB) (== row (byte \newline)) (== row (byte \u0004)) (== row (byte \u0000)))
                        (ร row++)                      ;; so go to next pos
                        (if (== reverse (== row col))
                            ((ร addup =) true)           ;; and mark UP
                            ((ร addbak =) true)          ;; or BC
                        )
                    )
                    (.be ((ร p =) (.plus p 1)) -1, row)
                    ((ร row =) col)
                    (ร BREAK)
                )

                ((ร CASE) (byte \r))                           ;; r: reverse
                (do
                    ((ร int r =) row)
                    ((ร row =) col)
                    ((ร col =) r)
                    ((ร reverse =) true)
                    (ร BREAK)
                )

                ((ร CASE) (byte \i))                           ;; increment (1-origin screen)
                (do
                    (ร col++)
                    (ร row++)
                    (ร BREAK)
                )

                ((ร CASE) (byte \%))                           ;; %%=% literally
                (do
                    (.be ((ร p =) (.plus p 1)) -1, (byte \%))
                    (ร BREAK)
                )

                ((ร CASE) (byte \n))                           ;; magic DM2500 code
                (do
                    ((ร row =) (bit-xor row 0140))
                    ((ร col =) (bit-xor col 0140))
                    (ร BREAK)
                )

                ((ร CASE) (byte \B))                           ;; bcd encoding
                (do
                    ((ร row =) (+ (<< (/ row 10) 4) (% row 10)))
                    ((ร col =) (+ (<< (/ col 10) 4) (% col 10)))
                    (ร BREAK)
                )

                ((ร CASE) (byte \D))                           ;; magic Delta Data code
                (do
                    ((ร row =) (- row (* 2 (& row 15))))
                    ((ร col =) (- col (* 2 (& col 15))))
                    (ร BREAK)
                )

                ((ร CASE) (byte \p))                           ;; so, what?
                (do
                    ((ร byte d =) (.at ((ร cm =) (.plus cm 1)) -1))
                    (if (or (== d (byte \1)) (== d (byte \2)))       ;; ignore %p1 and %p2
                        (ร BREAK)
                    )
                    (ร FALLTHROUGH)
                )

                (ร DEFAULT)                            ;; unknown escape
                (do
                    ((ร RETURN) (u8 "OOPS"))
                )
            )
        )

        (when addup                                  ;; add upline
            (when (non-nil? tgoto_UP)
                ((ร cm =) tgoto_UP)
                (while (or (asc-isdigit (.at cm 0)) (== (.at cm 0) (byte \.)))
                    ((ร cm =) (.plus cm 1))
                )
                (if (== (.at cm 0) (byte \*))
                    ((ร cm =) (.plus cm 1))
                )
                (while (non-eos? cm)
                    (.be ((ร p =) (.plus p 1)) -1, (.at ((ร cm =) (.plus cm 1)) -1))
                )
            )
        )

        (when addbak                                 ;; add backspace
            (cond (non-nil? tgoto_BC)
            (do
                ((ร cm =) tgoto_BC)
                (while (or (asc-isdigit (.at cm 0)) (== (.at cm 0) (byte \.)))
                    ((ร cm =) (.plus cm 1))
                )
                (if (== (.at cm 0) (byte \*))
                    ((ร cm =) (.plus cm 1))
                )
                (while (non-eos? cm)
                    (.be ((ร p =) (.plus p 1)) -1, (.at ((ร cm =) (.plus cm 1)) -1))
                )
            )
            :else
            (do
                (.be ((ร p =) (.plus p 1)) -1, (byte \backspace))
            ))
        )

        (eos! p)

        tgoto_buffer
    ))

;; Note: "s" may have padding information ahead of it, in the form of nnnTEXT or nnn*TEXT.
;;  nnn is the number of milliseconds to delay, and may be a decimal fraction (nnn.mmm).
;;  In case an asterisk is given, the delay is to be multiplied by "_affcnt".

(defn- #_int _tputs [#_Bytes s, #_int _affcnt]
    ;; s: string to print
    ;; affcnt: number of lines affected
    (ยง
        ((ร int i =) 0)

        (when (asc-isdigit (.at s i))
            (while (asc-isdigit (.at s (ร ++i)))
                ;
            )
            (when (== (.at s i) (byte \.))
                (while (asc-isdigit (.at s (ร ++i)))
                    ;
                )
            )
            (if (== (.at s i) (byte \*))
                (ร i++)
            )
        )

        (while (non-eos? s i)
            (out-char-nf (.at s (ร i++)))
        )

        0
    ))

;; A never-padding out-str:
;; use this whenever you don't want to run the string through tputs.
;; tputs above is harmless,
;; but tputs from the termcap library is likely to strip off leading digits,
;; that it mistakes for padding information, and "%i", "%d", etc.
;; This should only be used for writing terminal codes, not for outputting
;; normal text: use functions like msg-puts() and screen-putchar() for that.

(defn- #_void out-str-nf [#_Bytes s]
    (ยง
        (if (< (- OUT_SIZE 20) @out_pos)    ;; avoid terminal strings being split up
            (out-flush))

        ((ร FOR) (ร ((ร int i =) 0) (non-eos? s i) nil)
            (out-char-nf (.at s (ร i++)))
        )

        ;; For testing we write one string at a time.
        (when (non-zero? @p_wd)
            (out-flush)
        )
        nil
    ))

;; out-str(s): Put a character string a byte at a time into the output buffer.
;; This should only be used for writing terminal codes, not for outputting
;; normal text: use functions like msg-puts() and screen-putchar() for that.

(defn- #_void out-str [#_Bytes s]
    (when (and (non-nil? s) (non-eos? s))
        ;; avoid terminal strings being split up
        (if (< (- OUT_SIZE 20) @out_pos)
            (out-flush))

        (_tputs s, 1)

        ;; For testing we write one string at a time.
        (if (non-zero? @p_wd)
            (out-flush))
    )
    nil)

;; cursor positioning using termcap parser

(defn- #_void term-windgoto [#_int row, #_int col]
    (out-str (_tgoto @T_CM, col, row))
    nil)

(defn- #_void term-cursor-right [#_int i]
    (out-str (_tgoto @T_CRI, 0, i))
    nil)

(defn- #_void term-append-lines [#_int line_count]
    (out-str (_tgoto @T_CAL, 0, line_count))
    nil)

(defn- #_void term-delete-lines [#_int line_count]
    (out-str (_tgoto @T_CDL, 0, line_count))
    nil)

(defn- #_void term-set-winsize [#_int width, #_int height]
    (out-str (_tgoto @T_CWS, height, width))
    nil)

(defn- #_void term-fg-color [#_int n]
    (ยง
        ;; Use "AF" termcap entry if present, "Sf" entry otherwise.
        (cond (non-eos? @T_CAF)
        (do
            (term-color @T_CAF, n)
        )
        (non-eos? @T_CSF)
        (do
            (term-color @T_CSF, n)
        ))
        nil
    ))

(defn- #_void term-bg-color [#_int n]
    (ยง
        ;; Use "AB" termcap entry if present, "Sb" entry otherwise.
        (cond (non-eos? @T_CAB)
        (do
            (term-color @T_CAB, n)
        )
        (non-eos? @T_CSB)
        (do
            (term-color @T_CSB, n)
        ))
        nil
    ))

(defn- #_void term-color [#_Bytes s, #_int n]
    (ยง
        ((ร int i =) 2)  ;; index in s just after <Esc>[

        ;; Special handling of 16 colors, because termcap can't handle it.
        ;; Also accept "\e[3%dm" for TERMINFO, it is sometimes used.
        (when (and (<= 8 n) (<= 16 @t_colors) (== (.at s 0) ESC) (== (.at s 1) (byte \[)) (non-eos? s i) (or (== (STRCMP (.plus s (inc i)), (u8 "%p1%dm")) 0) (== (STRCMP (.plus s (inc i)), (u8 "%dm")) 0)) (or (== (.at s i) (byte \3)) (== (.at s i) (byte \4))))
            ((ร Bytes buf =) (Bytes. 20))
            (.sprintf libC buf, (u8 "%s%s%%p1%%dm"), (if (== i 2) (u8 "\033[") (u8 "\233")), (if (== (.at s i) (byte \3)) (if (<= 16 n) (u8 "38;5;") (u8 "9")) (if (<= 16 n) (u8 "48;5;") (u8 "10"))))
            ((ร s =) buf)
            ((ร n =) (if (<= 16 n) n (- n 8)))
        )

        (out-str (_tgoto s, 0, n))
        nil
    ))

;; Make sure we have a valid set or terminal options.
;; Replace all entries that are null by EMPTY_OPTION.

(defn- #_void ttest [#_boolean pairs]
    (ยง
        (check-options)            ;; make sure no options are null

        ;; MUST have "cm": cursor motion.

        (if (eos? @T_CM)
            (emsg (u8 "E437: terminal capability \"cm\" required")))

        ;; If "cs" defined, use a scroll region, it's faster.

        (reset! scroll_region (non-eos? @T_CS))

        ;; optional pairs

        (when pairs
            ;; TP goes to normal mode for TI (invert) and TB (bold).
            (if (eos? @T_ME)
                (reset! T_ME ((ร @T_MR =) ((ร @T_MD =) EMPTY_OPTION))))
            (if (or (eos? @T_SO) (eos? @T_SE))
                (reset! T_SO ((ร @T_SE =) EMPTY_OPTION)))
            (if (or (eos? @T_US) (eos? @T_UE))
                (reset! T_US ((ร @T_UE =) EMPTY_OPTION)))
            (if (or (eos? @T_CZH) (eos? @T_CZR))
                (reset! T_CZH ((ร @T_CZR =) EMPTY_OPTION)))

            ;; T_VE is needed even though T_VI is not defined.
            (if (eos? @T_VE)
                (reset! T_VI EMPTY_OPTION))

            ;; If 'mr' or 'me' is not defined use 'so' and 'se'.
            (when (eos? @T_ME)
                (reset! T_ME @T_SE)
                (reset! T_MR ((ร @T_MD =) @T_SO))
            )

            ;; If 'so' or 'se' is not defined use 'mr' and 'me'.
            (when (eos? @T_SO)
                (reset! T_SE @T_ME)
                (reset! T_SO (if (eos? @T_MR) @T_MD @T_MR))
            )

            ;; If 'ZH' or 'ZR' is not defined use 'mr' and 'me'.
            (when (eos? @T_CZH)
                (reset! T_CZR @T_ME)
                (reset! T_CZH (if (eos? @T_MR) @T_MD @T_MR))
            )

            ;; "Sb" and "Sf" come in pairs.
            (when (or (eos? @T_CSB) (eos? @T_CSF))
                (reset! T_CSB EMPTY_OPTION)
                (reset! T_CSF EMPTY_OPTION)
            )

            ;; "AB" and "AF" come in pairs.
            (when (or (eos? @T_CAB) (eos? @T_CAF))
                (reset! T_CAB EMPTY_OPTION)
                (reset! T_CAF EMPTY_OPTION)
            )

            ;; If 'Sb' and 'AB' are not defined, reset "Co".
            (if (and (eos? @T_CSB) (eos? @T_CAB))
                (reset! T_CCO EMPTY_OPTION))
        )

        (reset! need_gather true)

        (reset! t_colors (.atoi libC @T_CCO))
        nil
    ))

;; Check if the new shell size is valid, correct it if it's too small or way too big.

(defn- #_void check-shellsize []
    (ยง
        ((ร int min =) (min-rows))
        (if (< @Rows min)         ;; need room for one window and command line
            (reset! Rows min))
        (limit-screen-size)
        nil
    ))

;; Limit Rows and Cols to avoid an overflow in Rows * Cols.

(defn- #_void limit-screen-size []
    (ยง
        (cond (< @Cols MIN_COLUMNS)
        (do
            (reset! Cols MIN_COLUMNS)
        )
        (< 10000 @Cols)
        (do
            (reset! Cols 10000)
        ))

        (when (< 1000 @Rows)
            (reset! Rows 1000)
        )
        nil
    ))

(atom! long old__Rows)
(atom! long old__Columns)

;; Invoked just before the screen structures are going to be (re)allocated.

(defn- #_void win-new-shellsize []
    (if (or (!= @old__Rows @Rows) (!= @old__Columns @Cols))
        (ui-new-shellsize))
    (when (!= @old__Rows @Rows)
        (reset! old__Rows @Rows)
        (shell-new-rows)       ;; update window sizes
    )
    (when (!= @old__Columns @Cols)
        (reset! old__Columns @Cols)
        (shell-new-columns)    ;; update window sizes
    )
    nil)

;; Call this function when the Vim shell has been resized in any way.
;; Will obtain the current size and redraw (also when size didn't change).

(defn- #_void shell-resized []
    (set-shellsize 0, 0, false)
    nil)

(atom! int _2_busy)

;; Set size of the Vim shell.
;; If 'mustset' is true, we must set Rows and Cols,
;; do not get the real window size (this is used for the :win command).
;; If 'mustset' is false, we may try to get the real window size
;; and if it fails, use 'width' and 'height'.

(defn- #_void set-shellsize [#_int width, #_int height, #_boolean mustset]
    (ยง
        ;; Avoid recursiveness, can happen when setting the window size causes
        ;; another window-changed signal.

        (if (non-zero? @_2_busy)
            ((ร RETURN) nil)
        )

        (if (or (< width 0) (< height 0))    ;; just checking...
            ((ร RETURN) nil)
        )

        (when (or (== @State HITRETURN) (== @State SETWSIZE))
            ;; postpone the resizing
            (reset! State SETWSIZE)
            ((ร RETURN) nil)
        )

        (swap! _2_busy inc)

        (cond (or mustset (and (not (ui-get-shellsize)) (non-zero? height)))
        (do
            (reset! Rows height)
            (reset! Cols width)
            (check-shellsize)
            (ui-set-shellsize mustset)
        )
        :else
        (do
            (check-shellsize)
        ))

        ;; The window layout used to be adjusted here, but it now happens in
        ;; screenalloc() (also invoked from screenclear()).  That is because
        ;; the "_2_busy" check above may skip this, but not screenalloc().

        (if (and (!= @State ASKMORE) (!= @State CONFIRM))
            (screenclear)
            (screen-start))     ;; don't know where cursor is now

        (when (!= @starting NO_SCREEN)
            (changed-line-abv-curs)
            (invalidate-botline)

            ;; We only redraw when it's needed:
            ;; - While at the more prompt or executing an external command, don't
            ;;   redraw, but position the cursor.
            ;; - While editing the command line, only redraw that.
            ;; - Otherwise, redraw right now, and position the cursor.
            ;; Always need to call update-screen() or screenalloc(), to make
            ;; sure Rows/Cols and the size of screenLines[] is correct!

            (cond (or (== @State ASKMORE) (== @State CONFIRM))
            (do
                (screenalloc false)
                (repeat-message)
            )
            :else
            (do
                (if @(:wo_scb (:w_options @curwin))
                    (do-check-scrollbind true))
                (cond (flag? @State CMDLINE)
                (do
                    (update-screen NOT_VALID)
                    (redrawcmdline)
                )
                :else
                (do
                    (update-topline)
                    (update-screen NOT_VALID)
                    (if (redrawing)
                        (setcursor))
                ))
            ))
            (cursor-on)        ;; redrawing may have switched it off
        )

        (out-flush)

        (swap! _2_busy dec)
        nil
    ))

;; Set the terminal to TMODE_RAW (for Normal mode)
;; or TMODE_COOK (for external commands and Ex mode).

(defn- #_void settmode [#_int tmode]
    (when @full_screen
        ;; When returning after calling a shell we want to really set the
        ;; terminal to raw mode, even though we think it already is, because
        ;; the shell program may have reset the terminal mode.
        ;; When we think the terminal is normal, don't try to set it to
        ;; normal again, because that causes problems (logout!) on some machines.

        (when (or (!= tmode TMODE_COOK) (!= @cur_tmode TMODE_COOK))
            (out-flush)
            (mch-settmode tmode)                ;; machine specific function
            (reset! cur_tmode tmode)
            (out-flush)
        )
    )
    nil)

(defn- #_void starttermcap []
    (when (and @full_screen (not @termcap_active))
        (out-str @T_TI)                  ;; start termcap mode
        (out-str @T_KS)                  ;; start "keypad transmit" mode
        (out-flush)
        (reset! termcap_active true)
        (screen-start)                 ;; don't know where cursor is now
    )
    nil)

(defn- #_void stoptermcap []
    (screen-stop-highlight)
    (reset-cterm-colors)
    (when @termcap_active
        (out-str @T_KE)                  ;; stop "keypad transmit" mode
        (out-flush)
        (reset! termcap_active false)
        (cursor-on)                    ;; just in case it is still off
        (out-str @T_TE)                  ;; stop termcap mode
        (screen-start)                 ;; don't know where cursor is now
        (out-flush)
    )
    nil)

;; Return true when saving and restoring the screen.

(defn- #_boolean swapping-screen []
    (and @full_screen (non-eos? @T_TI)))

;; By outputting the 'cursor very visible' termcap code, for some windowed
;; terminals this makes the screen scrolled to the correct position.
;; Used when starting Vim or returning from a shell.

(defn- #_void scroll-start []
    (when (non-eos? @T_VS)
        (out-str @T_VS)
        (out-str @T_VE)
        (screen-start)                 ;; don't know where cursor is now
    )
    nil)

(atom! boolean cursor_is_off)

;; Enable the cursor.

(defn- #_void cursor-on []
    (when @cursor_is_off
        (out-str @T_VE)
        (reset! cursor_is_off false)
    )
    nil)

;; Disable the cursor.

(defn- #_void cursor-off []
    (when @full_screen
        (if (not @cursor_is_off)
            (out-str @T_VI))          ;; disable cursor
        (reset! cursor_is_off true)
    )
    nil)

(atom! int showing_mode NORMAL)

;; Set cursor shape to match Insert or Replace mode.

(defn- #_void term-cursor-shape []
    (ยง
        ;; Only do something when redrawing the screen and we can restore the mode.
        (if (or (not @full_screen) (eos? @T_CEI))
            ((ร RETURN) nil)
        )

        (cond (== (& @State REPLACE) REPLACE)
        (do
            (when (!= @showing_mode REPLACE)
                ((ร Bytes p =) (if (non-eos? @T_CSR)
                    @T_CSR                  ;; Replace mode cursor
                    @T_CSI                  ;; fall back to Insert mode cursor
                ))
                (when (non-eos? p)
                    (out-str p)
                    (reset! showing_mode REPLACE)
                )
            )
        )
        (flag? @State INSERT)
        (do
            (when (and (!= @showing_mode INSERT) (non-eos? @T_CSI))
                (out-str @T_CSI)                 ;; Insert mode cursor
                (reset! showing_mode INSERT)
            )
        )
        (!= @showing_mode NORMAL)
        (do
            (out-str @T_CEI)                     ;; non-Insert mode cursor
            (reset! showing_mode NORMAL)
        ))
        nil
    ))

;; Set scrolling region for window 'wp'.
;; The region starts 'off' lines from the start of the window.
;; Also set the vertical scroll region for a vertically split window.
;; Always the full width of the window, excluding the vertical separator.

(defn- #_void scroll-region-set [#_window_C wp, #_int off]
    (out-str (_tgoto @T_CS, (- (+ (:w_winrow wp) (:w_height wp)) 1), (+ (:w_winrow wp) off)))

    (if (and (non-eos? @T_CSV) (!= (:w_width wp) (int @Cols)))
        (out-str (_tgoto @T_CSV, (- (+ (:w_wincol wp) (:w_width wp)) 1), (:w_wincol wp)))
    )

    (screen-start)                 ;; don't know where cursor is now
    nil)

;; Reset scrolling region to the whole screen.

(defn- #_void scroll-region-reset []
    (out-str (_tgoto @T_CS, (dec (int @Rows)), 0))

    (if (non-eos? @T_CSV)
        (out-str (_tgoto @T_CSV, (dec (int @Cols)), 0))
    )

    (screen-start)                 ;; don't know where cursor is now
    nil)

;; List of terminal codes that are currently recognized.

(class! #_final termcode_C
    [
        (field Bytes    name    (Bytes. 2))     ;; termcap name of entry
        (field Bytes    code)                   ;; terminal code (in allocated memory)
        (field int      len)                    ;; STRLEN(code)
        (field int      modlen)                 ;; length of part before ";*~".
    ])

(defn- #_void COPY-termcode [#_termcode_C tc1, #_termcode_C tc0]
    (ยง
        (BCOPY (:name tc1), (:name tc0), 2)
        ((ร tc1.code =) (:code tc0))
        ((ร tc1.len =) (:len tc0))
        ((ร tc1.modlen =) (:modlen tc0))
        nil
    ))

(defn- #_termcode_C* ARRAY-termcode [#_int n]
    (vec (repeatedly n NEW_termcode_C)))

(atom! termcode_C* termcodes)

(atom! int tc_max_len)  ;; number of entries that termcodes[] can hold
(atom! int tc_len)      ;; current number of entries in termcodes[]

(defn- #_void clear-termcodes []
    (reset! tc_len 0)
    (reset! tc_max_len 0)
    (reset! termcodes nil)

    (reset! need_gather true)         ;; need to fill termleader[]
    nil)

;; Add a new entry to the list of terminal codes.
;; The list is kept alphabetical for ":set termcap"

(defn- #_void add-termcode [#_Bytes name, #_Bytes string]
    (ยง
        (when (or (nil? string) (eos? string))
            (del-termcode name)
            ((ร RETURN) nil)
        )

        ((ร Bytes code =) (STRDUP string))

        ((ร int len =) (STRLEN code))

        (reset! need_gather true)         ;; need to fill termleader[]

        ;; need to make space for more entries

        (when (== @tc_len @tc_max_len)
            ((ร @tc_max_len =) (+ @tc_max_len 20))
            ((ร termcode_C[] new_tc =) (ARRAY-termcode @tc_max_len))
            (dotimes [#_int i @tc_len]
                (COPY-termcode (... new_tc i), (... @termcodes i))
            )
            (reset! termcodes new_tc)
        )

        ;; Look for existing entry with the same name, it is replaced.
        ;; Look for an existing entry that is alphabetical higher, the new entry is inserted in front of it.

        (ร int i)
        ((ร FOR) (ร ((ร i =) 0) (< i @tc_len) (ร i++))
            (if (< (char_u (.at (:name (... @termcodes i)) 0)) (char_u (.at name 0)))
                (ร CONTINUE)
            )
            (when (== (.at (:name (... @termcodes i)) 0) (.at name 0))
                (if (< (char_u (.at (:name (... @termcodes i)) 1)) (char_u (.at name 1)))
                    (ร CONTINUE)
                )

                ;; Exact match: May replace old code.

                (when (== (.at (:name (... @termcodes i)) 1) (.at name 1))
                    ;; Replace old code.
                    ((ร @termcodes[i].code =) nil)
                    (swap! tc_len dec)
                    (ร BREAK)
                )
            )

            ;; Found alphabetical larger entry, move rest to insert new entry

            ((ร FOR) (ร ((ร int j =) @tc_len) (< i j) (ร --j))
                (COPY-termcode (... @termcodes j), (... @termcodes (dec j)))
            )
            (ร BREAK)
        )

;       @termcodes[i].name.be(0, name.at(0));
;       @termcodes[i].name.be(1, name.at(1));
        ((ร @termcodes[i].code =) code)
        ((ร @termcodes[i].len =) len)

        ;; For xterm we recognize special codes like "ESC[42;*X" and "ESC O*X" that accept modifiers.
        ((ร @termcodes[i].modlen =) 0)
        ((ร int j =) (termcode-star code, len))
        (if (< 0 j)
            ((ร @termcodes[i].modlen =) (- len 1 j))
        )
        (swap! tc_len inc)
        nil
    ))

;; Check termcode "code[len]" for ending in ;*X, <Esc>O*X or <M-O>*X.
;; The "X" can be any character.
;; Return 0 if not found, 2 for ;*X and 1 for O*X and <M-O>*X.

(defn- #_int termcode-star [#_Bytes code, #_int len]
    (ยง
        ;; Shortest is <M-O>*X.  With ; shortest is <CSI>1;*X.
        (when (and (<= 3 len) (== (.at code (- len 2)) (byte \*)))
            (if (and (<= 5 len) (== (.at code (- len 3)) (byte \;)))
                ((ร RETURN) 2)
            )
            (if (or (and (<= 4 len) (== (.at code (- len 3)) (byte \O))) (== (char_u (.at code (- len 3))) (+ (byte \O) 0x80)))
                ((ร RETURN) 1)
            )
        )
        0
    ))

(defn- #_Bytes find-termcode [#_Bytes name]
    (ยง
        (dotimes [#_int i @tc_len]
            (if (and (== (.at (:name (... @termcodes i)) 0) (.at name 0)) (== (.at (:name (... @termcodes i)) 1) (.at name 1)))
                ((ร RETURN) (:code (... @termcodes i)))
            )
        )

        nil
    ))

(defn- #_void del-termcode [#_Bytes name]
    (ยง
        (if (nil? @termcodes)      ;; nothing there yet
            ((ร RETURN) nil)
        )

        (reset! need_gather true)         ;; need to fill termleader[]

        (dotimes [#_int i @tc_len]
            (when (and (== (.at (:name (... @termcodes i)) 0) (.at name 0)) (== (.at (:name (... @termcodes i)) 1) (.at name 1)))
                (del-termcode-idx i)
                ((ร RETURN) nil)
            )
        )
        ;; Not found.  Give error message?
        nil
    ))

(defn- #_void del-termcode-idx [#_int idx]
    (ยง
        ((ร @termcodes[idx].code =) nil)
        (swap! tc_len dec)
        ((ร FOR) (ร ((ร int i =) idx) (< i @tc_len) (ร i++))
            (COPY-termcode (... @termcodes i), (... @termcodes (inc i)))
        )
        nil
    ))

;; Check if typebuf.tb_buf[] contains a terminal key code.
;; Check at typebuf.tb_buf[typebuf.tb_off].
;; Return 0 for no match, -1 for partial match, > 0 for full match.
;; Return KEYLEN_REMOVED when a key code was deleted.
;; With a match, the match is removed, the replacement code is inserted in
;; typebuf.tb_buf[] and the number of characters in typebuf.tb_buf[] is returned.
;; When "buf" is not null, buf[bufsize] is used instead of typebuf.tb_buf[].
;; "buflen" is then the length of the string in buf[] and is updated for inserts and deletes.

(defn- #_int check-termcode [#_Bytes buf, #_int bufsize, #_int* buflen]
    (ยง
        ;; Speed up the checks for terminal codes by gathering all first bytes used in termleader[].
        ;; Often this is just a single <Esc>.

        (if @need_gather
            (gather-termleader))

        (ร Bytes tp)
        (ร int len)

        (cond (nil? buf)
        (do
            (if (<= (:tb_len @typebuf) 0)
                ((ร RETURN) 0)
            )
            ((ร tp =) (.plus (:tb_buf @typebuf) (:tb_off @typebuf)))
            ((ร len =) (:tb_len @typebuf))      ;; length of the input
        )
        :else
        (do
            (if (<= (... buflen 0) 0)
                ((ร RETURN) 0)
            )
            ((ร tp =) buf)
            ((ร len =) (... buflen 0))
        ))

        ;; Don't check characters after KB_SPECIAL, those are already
        ;; translated terminal chars (avoid translating ~@^Hx).

        (if (== (.at tp 0) KB_SPECIAL)        ;; there are always 2 extra characters
            ((ร RETURN) 0)
        )

        ;; Skip this position if the character does not appear as the first character in 'term_strings'.
        ;; This speeds up a lot, since most termcodes start with the same character (ESC).

        (ร Bytes q)
        ((ร FOR) (ร ((ร q =) termleader) (and (non-eos? q) (!= (.at q 0) (.at tp 0))) ((ร q =) (.plus q 1)))
            ;
        )
        (if (eos? q)
            ((ร RETURN) 0)
        )

        ;; Skip this position if "p_ek" is not set and *tp is an ESC and we are in Insert mode.

        (if (and (== (.at tp 0) ESC) (not @p_ek) (flag? @State INSERT))
            ((ร RETURN) 0)
        )

        ((ร Bytes key_name =) (Bytes. 2))
; %%    ((ร int[] modifiers =) (ร { 0 }))      ;; no modifiers yet

        ((ร int slen =) 0)

        ((ร FOR) (ร ((ร int idx =) 0) (< idx @tc_len) (ร idx++))
            ((ร slen =) (:len (... @termcodes idx)))

            (when (== (STRNCMP (:code (... @termcodes idx)), tp, (if (< len slen) len slen)) 0)
                (if (< len slen)             ;; got a partial sequence
                    ((ร RETURN) -1)              ;; need to get more chars
                )

                ;; When found a keypad key, check if there is another key that matches and use that one.
                ;; This makes <Home> to be found instead of <kHome> when they produce the same key code.

                (when (and (== (.at (:name (... @termcodes idx)) 0) (byte \K)) (asc-isdigit (.at (:name (... @termcodes idx)) 1)))
                    ((ร FOR) (ร ((ร int j =) (inc idx)) (< j @tc_len) (ร j++))
                        (when (and (== (:len (... @termcodes j)) slen) (zero? (STRNCMP (:code (... @termcodes idx)), (:code (... @termcodes j)), slen)))
                            ((ร idx =) j)
                            (ร BREAK)
                        )
                    )
                )

                (.be key_name 0, (.at (:name (... @termcodes idx)) 0))
                (.be key_name 1, (.at (:name (... @termcodes idx)) 1))
                (ร BREAK)
            )

            ;; Check for code with modifier, like xterm uses:
            ;; <Esc>[123;*X (modslen == slen - 3), also <Esc>O*X and <M-O>*X (modslen == slen - 2).
            ;; When there is a modifier the * matches a number.
            ;; When there is no modifier the ;* or * is omitted.

            (when (< 0 (:modlen (... @termcodes idx)))
                ((ร int modslen =) (:modlen (... @termcodes idx)))

                (when (== (STRNCMP (:code (... @termcodes idx)), tp, (if (< len modslen) len modslen)) 0)
                    (if (<= len modslen)     ;; got a partial sequence
                        ((ร RETURN) -1)          ;; need to get more chars
                    )

                    (cond (== (.at tp modslen) (.at (:code (... @termcodes idx)) (dec slen)))
                    (do
                        ((ร slen =) (inc modslen)) ;; no modifiers
                    )
                    (and (!= (.at tp modslen) (byte \;)) (== modslen (- slen 3)))
                    (do
                        (ร CONTINUE)   ;; no match
                    )
                    :else
                    (do
                        ;; Skip over the digits, the final char must follow.
                        (ร int j)
                        ((ร FOR) (ร ((ร j =) (- slen 2)) (and (< j len) (asc-isdigit (.at tp j))) (ร j++))
                            ;
                        )
                        (ร j++)
                        (if (< len j)        ;; got a partial sequence
                            ((ร RETURN) -1)      ;; need to get more chars
                        )
                        (if (!= (.at tp (dec j)) (.at (:code (... @termcodes idx)) (dec slen)))
                            (ร CONTINUE)       ;; no match
                        )

                        ;; Match!  Convert modifier bits.
                        ((ร int n =) (- (.atoi libC (.plus tp (- slen 2))) 1))
                        (if (non-zero? (& n 1))
                            ((ร modifiers[0] =) (| (... modifiers 0) MOD_MASK_SHIFT))
                        )
                        (if (non-zero? (& n 2))
                            ((ร modifiers[0] =) (| (... modifiers 0) MOD_MASK_ALT))
                        )
                        (if (non-zero? (& n 4))
                            ((ร modifiers[0] =) (| (... modifiers 0) MOD_MASK_CTRL))
                        )
                        (if (non-zero? (& n 8))
                            ((ร modifiers[0] =) (| (... modifiers 0) MOD_MASK_META))
                        )

                        ((ร slen =) j)
                    ))

                    (.be key_name 0, (.at (:name (... @termcodes idx)) 0))
                    (.be key_name 1, (.at (:name (... @termcodes idx)) 1))
                    (ร BREAK)
                )
            )
        )

        (when (eos? key_name)
            ((ร RETURN) 0)               ;; no match found
        )

        ;; We only get here when we have a complete termcode match.

        ;; Change <xHome> to <Home>, <xUp> to <Up>, etc.

        ((ร int key =) (handle-x-keys (TERMCAP2KEY (.at key_name 0), (.at key_name 1))))

        ((ร Bytes string =) (Bytes. (inc MAX_KEY_CODE_LEN)))

        ;; Add any modifier codes to our string.

        ((ร int new_slen =) 0)           ;; length of what will replace the termcode
        (when (non-zero? (... modifiers 0))
            ;; Some keys have the modifier included.
            ;; Need to handle that here to make mappings work.
            ((ร key =) (simplify-key key, modifiers))
            (when (non-zero? (... modifiers 0))
                (.be string (ร new_slen++), KB_SPECIAL)
                (.be string (ร new_slen++), KS_MODIFIER)
                (.be string (ร new_slen++), (... modifiers 0))
            )
        )

        ((ร int retval =) 0)

        ;; Finally, add the special key code to our string.
        (.be key_name 0, (KEY2TERMCAP0 key))
        (.be key_name 1, (KEY2TERMCAP1 key))
        (cond (== (.at key_name 0) KS_KEY)
        (do
            ;; from ":set <M-b>=xx"
            ((ร new_slen =) (+ new_slen (utf-char2bytes (char_u (.at key_name 1)), (.plus string new_slen))))
        )
        (and (zero? new_slen) (== (.at key_name 0) KS_EXTRA) (== (.at key_name 1) KE_IGNORE))
        (do
            ;; Do not put K_IGNORE into the buffer, do return KEYLEN_REMOVED to indicate what happened.
            ((ร retval =) KEYLEN_REMOVED)
        )
        :else
        (do
            (.be string (ร new_slen++), KB_SPECIAL)
            (.be string (ร new_slen++), (.at key_name 0))
            (.be string (ร new_slen++), (.at key_name 1))
        ))
        (eos! string new_slen)

        ((ร int extra =) (- new_slen slen))
        (cond (nil? buf)
        (do
            (cond (< extra 0)
            (do
                ;; remove matched chars, taking care of noremap
                (del-typebuf (- extra))
            )
            (< 0 extra)
            (do
                ;; insert the extra space we need
                (ins-typebuf (.plus string slen))
            ))

            (BCOPY (:tb_buf @typebuf), (:tb_off @typebuf), string, 0, new_slen)
        )
        :else
        (do
            (cond (< extra 0)
            (do
                ;; remove matched characters
                (BCOPY buf, 0, buf, (- extra), (+ (... buflen 0) extra))
            )
            (< 0 extra)
            (do
                ;; Insert the extra space we need.  If there is insufficient space return -1.
                (if (<= bufsize (+ (... buflen 0) extra new_slen))
                    ((ร RETURN) -1)
                )
                (BCOPY buf, extra, buf, 0, (... buflen 0))
            ))

            (BCOPY buf, 0, string, 0, new_slen)
            ((ร buflen[0] =) (+ (... buflen 0) (+ extra new_slen)))
        ))

        (if (non-zero? retval) retval (+ len extra))
    ))

;; Gather the first characters in the terminal key codes into a string.
;; Used to speed up check-termcode().

(defn- #_void gather-termleader []
    (ยง
        ((ร int len =) 0)

        (eos! termleader len)

        (dotimes [#_int i @tc_len]
            (when (nil? (vim-strchr termleader, (.at (:code (... @termcodes i)) 0)))
                (.be termleader (ร len++), (.at (:code (... @termcodes i)) 0))
                (eos! termleader len)
            )
        )

        (reset! need_gather false)
        nil
    ))

;; ui.c: functions that handle the user interface.
;; 1. Keyboard input stuff, and a bit of windowing stuff.  These are called
;;    before the machine specific stuff (mch_*) so that we can call the GUI
;;    stuff instead if the GUI is running.
;; 2. Clipboard stuff.
;; 3. Input buffer stuff.

(defn- #_void ui-write [#_Bytes s, #_int len]
    (mch-write s, len)
    nil)

;; ui-inchar(): low level input function.
;; Get characters from the keyboard.
;; Return the number of characters that are available.
;; If "wtime" == 0 do not wait for characters.
;; If "wtime" == -1 wait forever for characters.
;; If "wtime" > 0 wait "wtime" milliseconds for a character.
;;
;; "tb_change_cnt" is the value of typebuf.tb_change_cnt if "buf" points into it.
;; When typebuf.tb_change_cnt changes (e.g., when a message is received from a remote client)
;; "buf" can no longer be used.  "tb_change_cnt" is null otherwise.

(defn- #_int ui-inchar [#_Bytes buf, #_int maxlen, #_long wtime, #_int tb_change_cnt]
    (ยง
        ;; If we are going to wait for some time or block...
        (when (or (== wtime -1) (< 100 wtime))
            ;; ... allow signals to kill us.
            (vim-handle-signal SIGNAL_UNBLOCK)
        )

        ((ร int len =) (mch-inchar buf, maxlen, wtime, tb_change_cnt))

        (when (or (== wtime -1) (< 100 wtime))
            ;; block SIGHUP et al.
            (vim-handle-signal SIGNAL_BLOCK)
        )

        len
    ))

;; Delay for the given number of milliseconds.
;; If ignoreinput is false then we cancel the delay if a key is hit.

(defn- #_void ui-delay [#_long msec, #_boolean ignoreinput]
    (mch-delay msec, ignoreinput)
    nil)

;; If the machine has job control, use it to suspend the program,
;; otherwise fake it by starting a new shell.
;; When running the GUI iconify the window.

(defn- #_void ui-suspend []
    (mch-suspend)
    nil)

;; Try to get the current Vim shell size.
;; Put the result in Rows and Cols.
;; Use the new sizes as defaults for 'columns' and 'lines'.
;; Return true when size could be determined, false otherwise.

(defn- #_boolean ui-get-shellsize []
    (ยง
        ((ร boolean got =) (mch-get-shellsize))

        (check-shellsize)

        got
    ))

;; Set the size of the Vim shell according to Rows and Cols, if possible.
;; The gui_set_shellsize() or mch-set-shellsize() function will try to set the new size.
;; If this is not possible, it will adjust Rows and Cols.

(defn- #_void ui-set-shellsize [#_boolean _mustset]
    ;; mustset: set by the user
    (mch-set-shellsize)
    nil)

;; Called when Rows and/or Cols changed.

(defn- #_void ui-new-shellsize []
    (when (and @full_screen (not @exiting))
        (mch-new-shellsize)
    )
    nil)

(defn- #_void ui-breakcheck []
    (mch-breakcheck)
    nil)

;; Functions that handle the input buffer.
;; This is used for any GUI version, and the unix terminal version.
;;
;; For Unix, the input characters are buffered to be able to check for a CTRL-C.
;; This should be done with signals, but I don't know how to do that in a portable way
;; for a tty in RAW mode.
;;
;; For the client-server code in the console the received keys are put in the input buffer.

;; Internal typeahead buffer.
;; Includes extra space for long key code descriptions which would otherwise overflow.
;; The buffer is considered full when only this extra space (or part of it) remains.

(final int INBUFLEN 250)

(final Bytes    inbuf (Bytes. (+ INBUFLEN MAX_KEY_CODE_LEN)))
(atom! int      inbufcount)     ;; number of chars in inbuf[]

(defn- #_boolean is-input-buf-full  [] (<= INBUFLEN @inbufcount))
(defn- #_boolean is-input-buf-empty [] (zero? @inbufcount))

;; Read as much data from the input buffer as possible up to maxlen, and store it in buf.
;; Note: this function used to be Read() in unix.c

(defn- #_int read-from-input-buf [#_Bytes buf, #_int maxlen]
    (ยง
        (if (zero? @inbufcount)            ;; if the buffer is empty, fill it
            (fill-input-buf true))
        (if (< @inbufcount maxlen)
            ((ร maxlen =) @inbufcount)
        )
        (BCOPY buf, inbuf, maxlen)
        ((ร @inbufcount =) (- @inbufcount maxlen))
        (if (non-zero? @inbufcount)
            (BCOPY inbuf, 0, inbuf, maxlen, @inbufcount))
        maxlen
    ))

(atom! boolean did_read_something)
(atom! Bytes fib__rest)    ;; unconverted rest of previous read
(atom! int fib__restlen)

(defn- #_void fill-input-buf [#_boolean exit_on_error]
    (ยง
        (if (is-input-buf-full)
            ((ร RETURN) nil)
        )

        ;; Fill_input_buf() is only called when we really need a character.
        ;; If we can't get any, but there is some in the buffer, just return.
        ;; If we can't get any, and there isn't any in the buffer, we give up and exit Vim.

        (ร int unconverted)

        (cond (non-nil? @fib__rest)
        (do
            ;; Use remainder of previous call, starts with an invalid character
            ;; that may become valid when reading more.
            ((ร unconverted =) (if (< (- INBUFLEN @inbufcount) @fib__restlen) (- INBUFLEN @inbufcount) @fib__restlen))
            (BCOPY inbuf, @inbufcount, @fib__rest, 0, unconverted)
            (cond (== unconverted @fib__restlen)
            (do
                (reset! fib__rest nil)
            )
            :else
            (do
                ((ร @fib__restlen =) (- @fib__restlen unconverted))
                (BCOPY @fib__rest, 0, @fib__rest, unconverted, @fib__restlen)
            ))
            ((ร @inbufcount =) (+ @inbufcount unconverted))
        )
        :else
        (do
            ((ร unconverted =) 0)
        ))

        ((ร int len =) 0)

        (dotimes [_ 100]
            ((ร len =) (int (.read libC @read_cmd_fd, (.plus inbuf @inbufcount), (- INBUFLEN @inbufcount))))

            (if (or (< 0 len) @got_int)
                (ร BREAK)
            )

            ;; If reading stdin results in an error, continue reading stderr.
            ;; This helps when using "foo | xargs vim".

            (when (and (not @did_read_something) (== (.isatty libc @read_cmd_fd) 0) (zero? @read_cmd_fd))
                ((ร int m =) @cur_tmode)

                ;; We probably set the wrong file descriptor to raw mode.
                ;; Switch back to cooked mode, use another descriptor
                ;; and set the mode to what it was.
                (settmode TMODE_COOK)
                ;; Use stderr for stdin, also works for shell commands.
                (.close libc 0)
                (.dup libc 2)
                (settmode m)
            )
            (if (not exit_on_error)
                ((ร RETURN) nil)
            )
        )

        (when (and (<= len 0) (not @got_int))
            (STRCPY @ioBuff, (u8 "Vim: Error reading input, exiting...\n"))
            (preserve-exit)
        )

        (if (< 0 len)
            (reset! did_read_something true))
        (cond @got_int
        (do
            ;; Interrupted, pretend a CTRL-C was typed.
            (.be inbuf 0, 3)
            (reset! inbufcount 1)
        )
        :else
        (do
            ;; May perform conversion on the input characters.
            ;; Include the unconverted rest of the previous call.
            ;; If there is an incomplete char at the end it is kept for the next
            ;; time, reading more bytes should make conversion possible.
            ;; Don't do this in the unlikely event that the input buffer is too
            ;; small ("fib__rest" still contains more bytes).

            (while (< 0 (ร len--))
                ;; if a CTRL-C was typed, remove it from the buffer and set got_int

                (when (== (.at inbuf @inbufcount) 3)
                    ;; remove everything typed before the CTRL-C
                    (BCOPY inbuf, 0, inbuf, @inbufcount, (inc len))
                    (reset! inbufcount 0)
                    (reset! got_int true)
                )
                (swap! inbufcount inc)
            )
        ))
        nil
    ))

;; May update the shape of the cursor.

(defn- #_void ui-cursor-shape []
    (term-cursor-shape)
    (conceal-check-cursor-line)
    nil)

;; Check bounds for column number

(defn- #_int check-col [#_int col]
    (cond (< col 0) 0 (<= @screenCols col) (dec @screenCols) :else col))

;; Check bounds for row number

(defn- #_int check-row [#_int row]
    (cond (< row 0) 0 (<= @screenRows row) (dec @screenRows) :else row))

;; screen.c: code for displaying on the screen
;;
;; Output to the screen (console, terminal emulator or GUI window) is minimized
;; by remembering what is already on the screen, and only updating the parts
;; that changed.
;;
;; screenLines[off]  Contains a copy of the whole screen, as it is currently
;;                   displayed (excluding text written by external commands).
;; screenAttrs[off]  Contains the associated attributes.
;; lineOffset[row]   Contains the offset into screenLines*[] and screenAttrs[]
;;                   for each line.
;; lineWraps[row]    Flag for each line whether it wraps to the next line.
;;
;; For double-byte characters, two consecutive bytes in screenLines[] can form one character
;; which occupies two display cells.  For UTF-8 a multi-byte character is converted to Unicode
;; and stored in screenLinesUC[].  screenLines[] contains the first byte only.  For an ASCII
;; character without composing chars screenLinesUC[] will be 0 and screenLinesC[][] is not used.
;; When the character occupies two display cells the next byte in screenLines[] is 0.
;; screenLinesC[][] contain up to 'maxcombine' composing characters
;; (drawn on top of the first character).  There is 0 after the last one used.
;;
;; The screen_*() functions write to the screen and handle updating screenLines[].
;;
;; update-screen() is the function that updates all windows and status lines.
;; It is called form the main loop when must_redraw is non-zero.  It may be
;; called from other places when an immediate screen update is needed.
;;
;; The part of the buffer that is displayed in a window is set with:
;; - w_topline (first buffer line in window)
;; - w_topfill (filler lines above the first line)
;; - w_leftcol (leftmost window cell in window),
;; - w_skipcol (skipped window cells of first line)
;;
;; Commands that only move the cursor around in a window, do not need to take
;; action to update the display.  The main loop will check if w_topline is
;; valid and update it (scroll the window) when needed.
;;
;; Commands that scroll a window change w_topline and must call
;; check-cursor() to move the cursor into the visible part of the window, and
;; call redraw-later(VALID) to have the window displayed by update-screen() later.
;;
;; Commands that change text in the buffer must call changed-bytes() or
;; changed-lines() to mark the area that changed and will require updating
;; later.  The main loop will call update-screen(), which will update each
;; window that shows the changed buffer.  This assumes text above the change
;; can remain displayed as it is.  Text after the change may need updating for
;; scrolling, folding and syntax highlighting.
;;
;; Commands that change how a window is displayed (e.g., setting 'list') or
;; invalidate the contents of a window in another way (e.g., change fold
;; settings), must call redraw-later(NOT_VALID) to have the whole window
;; redisplayed by update-screen() later.
;;
;; Commands that change how a buffer is displayed (e.g., setting 'tabstop')
;; must call redraw-curbuf-later(NOT_VALID) to have all the windows for the
;; buffer redisplayed by update-screen() later.
;;
;; Commands that change highlighting and possibly cause a scroll too must call
;; redraw-later(SOME_VALID) to update the whole window but still use scrolling
;; to avoid redrawing everything.  But the length of displayed lines must not
;; change, use NOT_VALID then.
;;
;; Commands that move the window position must call redraw-later(NOT_VALID).
;; TODO: should minimize redrawing by scrolling when possible.
;;
;; Commands that change everything (e.g., resizing the screen) must call
;; redraw-all-later(NOT_VALID) or redraw-all-later(CLEAR).
;;
;; Things that are handled indirectly:
;; - When messages scroll the screen up, msg_scrolled will be set and
;;   update-screen() called to redraw.

(final byte MB_FILLER_CHAR \<)     ;; character used when a double-width character doesn't fit.

;; The attributes that are actually active for writing to the screen.

(atom! int screen_attr)

;; Positioning the cursor is reduced by remembering the last position.
;; Mostly used by windgoto() and screen-char().

;; last known cursor position
(atom! int screen_cur_row)
(atom! int screen_cur_col)

(atom! match_C search_hl    (NEW_match_C))   ;; used for 'hlsearch' highlight matching

;; Buffer for one screen line (characters and attributes).

(atom! Bytes current_ScreenLine)

(final int SEARCH_HL_PRIORITY 0)

;; Ugly global: overrule attribute used by screen-char().
(atom! int screen_char_attr)

;; Redraw the current window later, with update-screen(type).
;; Set must_redraw only if not already set to a higher value.
;; e.g. if must_redraw is CLEAR, type NOT_VALID will do nothing.

(defn- #_void redraw-later [#_int type]
    (redraw-win-later @curwin, type)
    nil)

(defn- #_void redraw-win-later [#_window_C wp, #_int type]
    (ยง
        (when (< (:w_redr_type wp) type)
            ((ร wp.w_redr_type =) type)
            (if (<= NOT_VALID type)
                ((ร wp.w_lines_valid =) 0)
            )
            (if (< @must_redraw type) ;; must_redraw is the maximum of all windows
                (reset! must_redraw type))
        )
        nil
    ))

;; Force a complete redraw later.  Also resets the highlighting.
;; To be used after executing a shell command that messes up the screen.

(defn- #_void redraw-later-clear []
    (redraw-all-later CLEAR)
    ;; Use attributes that is very unlikely to appear in text.
    (reset! screen_attr (| HL_BOLD HL_UNDERLINE HL_INVERSE))
    nil)

;; Mark all windows to be redrawn later.

(defn- #_void redraw-all-later [#_int type]
    (ยง
        ((ร FOR) (ร ((ร window_C wp =) @firstwin) (non-nil? wp) ((ร wp =) (:w_next wp)))
            (redraw-win-later wp, type)
        )
        nil
    ))

;; Mark all windows that are editing the current buffer to be updated later.

(defn- #_void redraw-curbuf-later [#_int type]
    (redraw-buf-later @curbuf, type)
    nil)

(defn- #_void redraw-buf-later [#_buffer_C buf, #_int type]
    (ยง
        ((ร FOR) (ร ((ร window_C wp =) @firstwin) (non-nil? wp) ((ร wp =) (:w_next wp)))
            (when (== @curbuf buf)
                (redraw-win-later wp, type)
            )
        )
        nil
    ))

;; Changed something in the current window, at buffer line "lnum", that
;; requires that line and possibly other lines to be redrawn.
;; Used when entering/leaving Insert mode with the cursor on a folded line.
;; Used to remove the "$" from a change command.
;; Note that when also inserting/deleting lines w_redraw_top and w_redraw_bot
;; may become invalid and the whole window will have to be redrawn.

(defn- #_void redrawWinline [#_long lnum]
    (ยง
        (if (or (zero? (:w_redraw_top @curwin)) (> (:w_redraw_top @curwin) lnum))
            ((ร @curwin.w_redraw_top =) lnum)
        )
        (if (or (zero? (:w_redraw_bot @curwin)) (< (:w_redraw_bot @curwin) lnum))
            ((ร @curwin.w_redraw_bot =) lnum)
        )

        (redraw-later VALID)
        nil
    ))

;; update all windows that are editing the current buffer

(defn- #_void update-curbuf [#_int type]
    (redraw-curbuf-later type)
    (update-screen type)
    nil)

;; update-screen()
;;
;; Based on the current value of curwin.w_topline, transfer a screenfull
;; of stuff from Filemem to screenLines[], and update curwin.w_botline.

(defn- #_void update-screen [#_int type]
    (ยง
        ;; Don't do anything if the screen structures are (not yet) valid.
        (if (not (screen-valid true))
            ((ร RETURN) nil)
        )

        (when (non-zero? @must_redraw)
            (if (< type @must_redraw)             ;; use maximal type
                ((ร type =) @must_redraw)
            )

            ;; must_redraw is reset here, so that when we run into some weird
            ;; reason to redraw while busy redrawing (e.g., asynchronous
            ;; scrolling), or update-topline() in win-update() will cause a
            ;; scroll, the screen will be redrawn later or in win-update().
            (reset! must_redraw 0)
        )

        ;; Need to update w_lines[].
        (if (and (zero? (:w_lines_valid @curwin)) (< type NOT_VALID))
            ((ร type =) NOT_VALID)
        )

        ;; Postpone the redrawing when it's not needed and when being called recursively.
        (when (or (not (redrawing)) @updating_screen)
            (redraw-later type)                 ;; remember type for next time
            (reset! must_redraw type)
            (if (< INVERTED_ALL type)
                ((ร @curwin.w_lines_valid =) 0)       ;; don't use w_lines[].wl_size now
            )
            ((ร RETURN) nil)
        )

        (reset! updating_screen true)

        ;; if the screen was scrolled up when displaying a message, scroll it down

        (when (non-zero? @msg_scrolled)
            (reset! clear_cmdline true)
            (cond (< (- @Rows 5) @msg_scrolled)        ;; clearing is faster
            (do
                ((ร type =) CLEAR)
            )
            (!= type CLEAR)
            (do
                (check-for-delay false)
                (if (not (screen-ins-lines 0, 0, @msg_scrolled, (int @Rows), nil))
                    ((ร type =) CLEAR)
                )
                ((ร FOR) (ร ((ร window_C wp =) @firstwin) (non-nil? wp) ((ร wp =) (:w_next wp)))
                    (when (< (:w_winrow wp) @msg_scrolled)
                        (cond (and (< @msg_scrolled (+ (:w_winrow wp) (:w_height wp))) (< (:w_redr_type wp) REDRAW_TOP) (< 0 (:w_lines_valid wp)) (== (:w_topline wp) (:wl_lnum (... (:w_lines wp) 0))))
                        (do
                            ((ร wp.w_upd_rows =) (- @msg_scrolled (:w_winrow wp)))
                            ((ร wp.w_redr_type =) REDRAW_TOP)
                        )
                        :else
                        (do
                            ((ร wp.w_redr_type =) NOT_VALID)
                            (if (<= (+ (:w_winrow wp) (:w_height wp) (:w_status_height wp)) @msg_scrolled)
                                ((ร wp.w_redr_status =) true)
                            )
                        ))
                    )
                )
                (reset! redraw_cmdline true)
            ))
            (reset! msg_scrolled 0)
            (reset! need_wait_return false)
        )

        ;; reset cmdline_row now (may have been changed temporarily)
        (compute-cmdrow)

        ;; Check for changed highlighting.
        (if @need_highlight_changed
            (highlight-changed))

        (when (== type CLEAR)              ;; first clear screen
            (screenclear)              ;; will reset clear_cmdline
            ((ร type =) NOT_VALID)
        )

        (if @clear_cmdline              ;; going to clear cmdline (done below)
            (check-for-delay false))

        ;; Force redraw when width of 'number' or 'relativenumber' column changes.
        (when (and (< (:w_redr_type @curwin) NOT_VALID) (!= (:w_nrwidth @curwin) (if (or @(:wo_nu (:w_options @curwin)) @(:wo_rnu (:w_options @curwin))) (number-width @curwin) 0)))
            ((ร @curwin.w_redr_type =) NOT_VALID)
        )

        ;; Only start redrawing if there is really something to do.

        (if (== type INVERTED)
            (update-curswant))
        (if (and (< (:w_redr_type @curwin) type) (not (or (and (== type VALID) (:wl_valid (... (:w_lines @curwin) 0)) (== (:w_topline @curwin) (:wl_lnum (... (:w_lines @curwin) 0)))) (and (== type INVERTED) @VIsual_active (== (:w_old_cursor_lnum @curwin) (:lnum (:w_cursor @curwin))) (== (:w_old_visual_mode @curwin) @VIsual_mode) (flag? (:w_valid @curwin) VALID_VIRTCOL) (== (:w_old_curswant @curwin) (:w_curswant @curwin))))))
            ((ร @curwin.w_redr_type =) type)
        )

        ;; Go from top to bottom through the windows, redrawing the ones that need it.

        ((ร boolean did_one =) false)
        ((ร @search_hl.rmm.regprog =) nil)

        ((ร FOR) (ร ((ร window_C wp =) @firstwin) (non-nil? wp) ((ร wp =) (:w_next wp)))
            (when (non-zero? (:w_redr_type wp))
                (cursor-off)
                (when (not did_one)
                    ((ร did_one =) true)
                    (start-search-hl)
                )
                (win-update wp)
            )

            ;; redraw status line after the window to minimize cursor movement
            (when (:w_redr_status wp)
                (cursor-off)
                (win-redr-status wp)
            )
        )
        (end-search-hl)

        ;; Reset b_mod_set flags.  Going through all windows is probably faster
        ;; than going through all buffers (there could be many buffers).
        ((ร FOR) (ร ((ร window_C wp =) @firstwin) (non-nil? wp) ((ร wp =) (:w_next wp)))
            ((ร @curbuf.b_mod_set =) false)
        )

        (reset! updating_screen false)

        ;; Clear or redraw the command line.
        ;; Done last, because scrolling may mess up the command line.
        (when (or @clear_cmdline @redraw_cmdline)
            (showmode)
        )
        nil
    ))

;; Return true if the cursor line in window "wp" may be concealed, according
;; to the 'concealcursor' option.

(defn- #_boolean conceal-cursor-line [#_window_C wp]
    (ยง
        (if (== (.at @(:wo_cocu (:w_options wp)) 0) NUL)
            ((ร RETURN) false)
        )

        (ร int c)
        (cond (flag? (get-real-state) VISUAL)
        (do
            ((ร c =) (byte \v))
        )
        (flag? @State INSERT)
        (do
            ((ร c =) (byte \i))
        )
        (flag? @State NORMAL)
        (do
            ((ร c =) (byte \n))
        )
        (flag? @State CMDLINE)
        (do
            ((ร c =) (byte \c))
        )
        :else
        (do
            ((ร RETURN) false)
        ))

        (non-nil? (vim-strchr @(:wo_cocu (:w_options wp)), c))
    ))

;; Check if the cursor line needs to be redrawn because of 'concealcursor'.

(defn- #_void conceal-check-cursor-line []
    (when (and (< 0 @(:wo_cole (:w_options @curwin))) (conceal-cursor-line @curwin))
        (reset! need_cursor_line_redraw true)
        ;; Need to recompute cursor column, e.g., when starting Visual mode without concealing.
        (curs-columns true)
    )
    nil)

(defn- #_void update-single-line [#_window_C wp, #_long lnum]
    (ยง
        (when (and (<= (:w_topline wp) lnum) (< lnum (:w_botline wp)))
            ((ร int row =) 0)
            (dotimes [#_int j (:w_lines_valid wp)]
                (when (== lnum (:wl_lnum (... (:w_lines wp) j)))
                    (screen-start) ;; not sure of screen cursor
                    (init-search-hl wp)
                    (start-search-hl)
                    (prepare-search-hl wp, lnum)
                    (win-line wp, lnum, row, (+ row (:wl_size (... (:w_lines wp) j))), false)
                    (end-search-hl)
                    (ร BREAK)
                )
                ((ร row =) (+ row (:wl_size (... (:w_lines wp) j))))
            )
        )

        (reset! need_cursor_line_redraw false)
        nil
    ))

(atom! boolean _2_recursive)    ;; being called recursively

;; Update a single window.
;;
;; This may cause the windows below it also to be redrawn (when clearing the
;; screen or scrolling lines).
;;
;; How the window is redrawn depends on wp.w_redr_type.  Each type also
;; implies the one below it.
;; NOT_VALID    redraw the whole window
;; SOME_VALID   redraw the whole window but do scroll when possible
;; REDRAW_TOP   redraw the top w_upd_rows window lines, otherwise like VALID
;; INVERTED     redraw the changed part of the Visual area
;; INVERTED_ALL redraw the whole Visual area
;; VALID        1. scroll up/down to adjust for a changed w_topline
;;              2. update lines at the top when scrolled down
;;              3. redraw changed text:
;;                 - if @curbuf.b_mod_set set, update lines between
;;                   b_mod_top and b_mod_bot.
;;                 - if wp.w_redraw_top non-zero, redraw lines between
;;                   wp.w_redraw_top and wp.w_redr_bot.
;;                 - continue redrawing when syntax status is invalid.
;;              4. if scrolled up, update lines at the bottom.
;; This results in three areas that may need updating:
;; top: from first row to top_end (when scrolled down)
;; mid: from mid_start to mid_end (update inversion or changed text)
;; bot: from bot_start to last row (when scrolled up)

(final int
    DID_NONE 1,     ;; didn't update a line
    DID_LINE 2,     ;; updated a normal line
    DID_FOLD 3)     ;; updated a folded line

(defn- #_void win-update [#_window_C wp]
    (ยง
        ((ร buffer_C buf =) @curbuf)

        ((ร int top_end =) 0)                    ;; Below last row of the top area that needs updating.  0 when no top area updating.
        ((ร int mid_start =) 999)                ;; First row of the mid area that needs updating.     999 when no mid area updating.
        ((ร int mid_end =) 0)                    ;; Below last row of the mid area that needs updating.  0 when no mid area updating.
        ((ร int bot_start =) 999)                ;; First row of the bot area that needs updating.     999 when no bot area updating.

        ((ร boolean scrolled_down =) false)      ;; true when scrolled down when w_topline got smaller a bit
        ((ร boolean top_to_mod =) false)         ;; redraw above mod_top

        ((ร boolean eof =) false)                ;; if true, we hit the end of the file
        ((ร boolean didline =) false)            ;; if true, we finished the last line

        ((ร long old_botline =) (:w_botline wp))

        ;; remember what happened to the previous line,
        ;; to know if check-visual-highlight() can be used

        ((ร int did_update =) DID_NONE)

        ((ร long mod_top =) 0)
        ((ร long mod_bot =) 0)

        ((ร int type =) (:w_redr_type wp))

        (when (== type NOT_VALID)
            ((ร wp.w_redr_status =) true)
            ((ร wp.w_lines_valid =) 0)
        )

        ;; Window is zero-height: nothing to draw.
        (when (zero? (:w_height wp))
            ((ร wp.w_redr_type =) 0)
            ((ร RETURN) nil)
        )

        ;; Window is zero-width: Only need to draw the separator.
        (when (zero? (:w_width wp))
            ;; draw the vertical separator right of this window
            (draw-vsep-win wp, 0)
            ((ร wp.w_redr_type =) 0)
            ((ร RETURN) nil)
        )

        (init-search-hl wp)

        ;; Force redraw when width of 'number' or 'relativenumber' column changes.
        ((ร int i =) (if (or @(:wo_nu (:w_options wp)) @(:wo_rnu (:w_options wp))) (number-width wp) 0))
        (cond (!= (:w_nrwidth wp) i)
        (do
            ((ร type =) NOT_VALID)
            ((ร wp.w_nrwidth =) i)
        )
        (and (:b_mod_set buf) (non-zero? (:b_mod_xlines buf)) (non-zero? (:w_redraw_top wp)))
        (do
            ;; When there are both inserted/deleted lines and specific lines to be
            ;; redrawn, w_redraw_top and w_redraw_bot may be invalid, just redraw
            ;; everything (only happens when redrawing is off for while).

            ((ร type =) NOT_VALID)
        )
        :else
        (do
            ;; Set mod_top to the first line that needs displaying because of changes.
            ;; Set mod_bot to the first line after the changes.

            ((ร mod_top =) (:w_redraw_top wp))
            ((ร mod_bot =) (if (non-zero? (:w_redraw_bot wp)) (inc (:w_redraw_bot wp)) 0))
            ((ร wp.w_redraw_top =) 0)    ;; reset for next time
            ((ร wp.w_redraw_bot =) 0)
            (when (:b_mod_set buf)
                (if (or (zero? mod_top) (< (:b_mod_top buf) mod_top))
                    ((ร mod_top =) (:b_mod_top buf))
                )
                (if (or (zero? mod_bot) (< mod_bot (:b_mod_bot buf)))
                    ((ร mod_bot =) (:b_mod_bot buf))
                )

                ;; When 'hlsearch' is on and using a multi-line search pattern,
                ;; a change in one line may make the Search highlighting in a previous line invalid.
                ;; Simple solution: redraw all visible lines above the change.
                ;; Same for a match pattern.

                (cond (and (non-nil? (:regprog (:rmm @search_hl))) (re-multiline (:regprog (:rmm @search_hl))))
                (do
                    ((ร top_to_mod =) true)
                )
                :else
                (do
                    ((ร FOR) (ร ((ร matchitem_C mi =) (:w_match_head wp)) (non-nil? mi) ((ร mi =) (:next mi)))
                        (when (and (non-nil? (:regprog (:mi_match mi))) (re-multiline (:regprog (:mi_match mi))))
                            ((ร top_to_mod =) true)
                            (ร BREAK)
                        )
                    )
                ))
            )

            ;; When a change starts above w_topline and the end is below w_topline,
            ;; start redrawing at w_topline.
            ;; If the end of the change is above w_topline: do like no change was made,
            ;; but redraw the first line to find changes in syntax.
            (when (and (non-zero? mod_top) (< mod_top (:w_topline wp)))
                (if (> mod_bot (:w_topline wp))
                    ((ร mod_top =) (:w_topline wp))
                )
            )

            ;; When line numbers are displayed, need to redraw all lines below
            ;; inserted/deleted lines.
            (if (and (non-zero? mod_top) (non-zero? (:b_mod_xlines buf)) @(:wo_nu (:w_options wp)))
                ((ร mod_bot =) MAXLNUM)
            )
        ))

        ;; When only displaying the lines at the top, set top_end.
        ;; Used when window has scrolled down for msg_scrolled.

        (when (== type REDRAW_TOP)
            ((ร int j =) 0)
            ((ร FOR) (ร ((ร i =) 0) (< i (:w_lines_valid wp)) (ร i++))
                ((ร j =) (+ j (:wl_size (... (:w_lines wp) i))))
                (when (<= (:w_upd_rows wp) j)
                    ((ร top_end =) j)
                    (ร BREAK)
                )
            )
            (cond (zero? top_end)
            (do
                ;; not found (cannot happen?): redraw everything
                ((ร type =) NOT_VALID)
            )
            :else
            (do
                ;; top area defined, the rest is VALID
                ((ร type =) VALID)
            ))
        )

        ;; Trick: we want to avoid clearing the screen twice.  screenclear() will set
        ;; "screen_cleared" to true.  The special value MAYBE (which is still non-zero
        ;; and thus not false) will indicate that screenclear() was not called.
        (if (!= @screen_cleared FALSE)
            (reset! screen_cleared MAYBE))

        ;; If there are no changes on the screen that require a complete redraw,
        ;; handle three cases:
        ;; 1: we are off the top of the screen by a few lines: scroll down
        ;; 2: wp.w_topline is below wp.w_lines[0].wl_lnum: may scroll up
        ;; 3: wp.w_topline is wp.w_lines[0].wl_lnum: find first entry in w_lines[] that needs updating.

        (cond (or (== type VALID) (== type SOME_VALID) (== type INVERTED) (== type INVERTED_ALL))
        (do
            (cond (and (non-zero? mod_top) (== (:w_topline wp) mod_top))
            (do
                ;; w_topline is the first changed line, the scrolling will be done further down.
            )
            (and (:wl_valid (... (:w_lines wp) 0)) (< (:w_topline wp) (:wl_lnum (... (:w_lines wp) 0))))
            (do
                ;; New topline is above old topline: may scroll down.
                ((ร int j =) (int (- (:wl_lnum (... (:w_lines wp) 0)) (:w_topline wp))))

                (cond (< j (- (:w_height wp) 2))        ;; not too far off
                (do
                    ((ร i =) (plines-m-win wp, (:w_topline wp), (- (:wl_lnum (... (:w_lines wp) 0)) 1)))

                    (cond (< i (- (:w_height wp) 2))    ;; less than a screen off
                    (do
                        ;; Try to insert the correct number of lines.
                        ;; If not the last window, delete the lines at the bottom.
                        ;; win-ins-lines may fail when the terminal can't do it.

                        (if (< 0 i)
                            (check-for-delay false))
                        (cond (win-ins-lines wp, 0, i, false, (== wp @firstwin))
                        (do
                            (when (non-zero? (:w_lines_valid wp))
                                ;; Need to update rows that are new,
                                ;; stop at the first one that scrolled down.
                                ((ร top_end =) i)
                                ((ร scrolled_down =) true)

                                ;; Move the entries that were scrolled,
                                ;; disable the entries for the lines to be redrawn.
                                (if (> ((ร wp.w_lines_valid =) (+ (:w_lines_valid wp) j)) (:w_height wp))
                                    ((ร wp.w_lines_valid =) (:w_height wp))
                                )
                                (ร int idx)
                                ((ร FOR) (ร ((ร idx =) (:w_lines_valid wp)) (<= 0 (- idx j)) (ร --idx))
                                    (COPY-wline (... (:w_lines wp) idx), (... (:w_lines wp) (- idx j)))
                                )
                                (while (<= 0 idx)
                                    ((ร wp.w_lines[idx--].wl_valid =) false)
                                )
                            )
                        )
                        :else
                        (do
                            ((ร mid_start =) 0)          ;; redraw all lines
                        ))
                    )
                    :else
                    (do
                        ((ร mid_start =) 0)              ;; redraw all lines
                    ))
                )
                :else
                (do
                    ((ร mid_start =) 0)                  ;; redraw all lines
                ))
            )
            :else
            (do
                ;; New topline is at or below old topline: May scroll up.
                ;; When topline didn't change, find first entry in w_lines[] that needs updating.

                ;; try to find wp.w_topline in wp.w_lines[].wl_lnum
                ((ร int j =) -1)
                ((ร int row =) 0)
                ((ร FOR) (ร ((ร i =) 0) (< i (:w_lines_valid wp)) (ร i++))
                    (when (and (:wl_valid (... (:w_lines wp) i)) (== (:wl_lnum (... (:w_lines wp) i)) (:w_topline wp)))
                        ((ร j =) i)
                        (ร BREAK)
                    )
                    ((ร row =) (+ row (:wl_size (... (:w_lines wp) i))))
                )
                (cond (== j -1)
                (do
                    ;; if wp.w_topline is not in wp.w_lines[].wl_lnum redraw all lines
                    ((ร mid_start =) 0)
                )
                :else
                (do
                    ;; Try to delete the correct number of lines.
                    ;; wp.w_topline is at wp.w_lines[i].wl_lnum.

                    (when (< 0 row)
                        (check-for-delay false)
                        (if (win-del-lines wp, 0, row, false, (== wp @firstwin))
                            ((ร bot_start =) (- (:w_height wp) row))
                            ((ร mid_start =) 0)          ;; redraw all lines
                        )
                    )
                    (when (and (or (zero? row) (< bot_start 999)) (non-zero? (:w_lines_valid wp)))
                        ;; Skip the lines (below the deleted lines) that are still valid and
                        ;; don't need redrawing.  Copy their info upwards, to compensate for the
                        ;; deleted lines.  Set bot_start to the first row that needs redrawing.

                        ((ร bot_start =) 0)
                        ((ร int idx =) 0)                ;; current index in w_lines[]
                        (while true
                            (COPY-wline (... (:w_lines wp) idx), (... (:w_lines wp) j))
                            ;; stop at line that didn't fit,
                            ;; unless it is still valid (no lines deleted)
                            (when (and (< 0 row) (< (:w_height wp) (+ bot_start row (:wl_size (... (:w_lines wp) j)))))
                                ((ร wp.w_lines_valid =) (inc idx))
                                (ร BREAK)
                            )
                            ((ร bot_start =) (+ bot_start (:wl_size (... (:w_lines wp) (ร idx++)))))

                            ;; stop at the last valid entry in w_lines[].wl_size
                            (when (<= (:w_lines_valid wp) (ร ++j))
                                ((ร wp.w_lines_valid =) idx)
                                (ร BREAK)
                            )
                        )
                    )
                ))
            ))

            ;; When starting redraw in the first line, redraw all lines.
            ;; When there is only one window it's probably faster to clear the screen first.
            (when (zero? mid_start)
                ((ร mid_end =) (:w_height wp))
                (when (== @lastwin @firstwin)
                    ;; Clear the screen when it was not done by win-del-lines() or
                    ;; win-ins-lines() above, "screen_cleared" is false or MAYBE then.
                    (if (!= @screen_cleared TRUE)
                        (screenclear))
                )
            )

            ;; When win-del-lines() or win-ins-lines() caused the screen to be
            ;; cleared (only happens for the first window) or when screenclear()
            ;; was called directly above, "must_redraw" will have been set to
            ;; NOT_VALID, need to reset it here to avoid redrawing twice.
            (if (== @screen_cleared TRUE)
                (reset! must_redraw 0))
        )
        :else
        (do
            ;; Not VALID or INVERTED: redraw all lines.
            ((ร mid_start =) 0)
            ((ร mid_end =) (:w_height wp))
        ))

        (when (== type SOME_VALID)
            ;; SOME_VALID: redraw all lines.
            ((ร mid_start =) 0)
            ((ร mid_end =) (:w_height wp))
            ((ร type =) NOT_VALID)
        )

        ;; check if we are updating or removing the inverted part
        (when (or @VIsual_active (and (non-zero? (:w_old_cursor_lnum wp)) (!= type NOT_VALID)))
            (ร long from, to)

            (cond @VIsual_active
            (do
                (cond (and @VIsual_active (or (!= @VIsual_mode (:w_old_visual_mode wp)) (== type INVERTED_ALL)))
                (do
                    ;; If the type of Visual selection changed, redraw the whole selection.
                    ;; Also when the ownership of the X selection is gained or lost.

                    (cond (< (:lnum (:w_cursor @curwin)) (:lnum @VIsual))
                    (do
                        ((ร from =) (:lnum (:w_cursor @curwin)))
                        ((ร to =) (:lnum @VIsual))
                    )
                    :else
                    (do
                        ((ร from =) (:lnum @VIsual))
                        ((ร to =) (:lnum (:w_cursor @curwin)))
                    ))
                    ;; redraw more when the cursor moved as well
                    (if (< (:w_old_cursor_lnum wp) from)
                        ((ร from =) (:w_old_cursor_lnum wp))
                    )
                    (if (< to (:w_old_cursor_lnum wp))
                        ((ร to =) (:w_old_cursor_lnum wp))
                    )
                    (if (< (:w_old_visual_lnum wp) from)
                        ((ร from =) (:w_old_visual_lnum wp))
                    )
                    (if (< to (:w_old_visual_lnum wp))
                        ((ร to =) (:w_old_visual_lnum wp))
                    )
                )
                :else
                (do
                    ;; Find the line numbers that need to be updated: The lines
                    ;; between the old cursor position and the current cursor
                    ;; position.  Also check if the Visual position changed.

                    (cond (< (:lnum (:w_cursor @curwin)) (:w_old_cursor_lnum wp))
                    (do
                        ((ร from =) (:lnum (:w_cursor @curwin)))
                        ((ร to =) (:w_old_cursor_lnum wp))
                    )
                    :else
                    (do
                        ((ร from =) (:w_old_cursor_lnum wp))
                        ((ร to =) (:lnum (:w_cursor @curwin)))
                        (if (zero? from)              ;; Visual mode just started
                            ((ร from =) to)
                        )
                    ))

                    (when (or (!= (:lnum @VIsual) (:w_old_visual_lnum wp)) (!= (:col @VIsual) (:w_old_visual_col wp)))
                        (if (and (< (:w_old_visual_lnum wp) from) (non-zero? (:w_old_visual_lnum wp)))
                            ((ร from =) (:w_old_visual_lnum wp))
                        )
                        (if (< to (:w_old_visual_lnum wp))
                            ((ร to =) (:w_old_visual_lnum wp))
                        )
                        (if (< (:lnum @VIsual) from)
                            ((ร from =) (:lnum @VIsual))
                        )
                        (if (< to (:lnum @VIsual))
                            ((ร to =) (:lnum @VIsual))
                        )
                    )
                ))

                ;; If in block mode and changed column or curwin.w_curswant: update all lines.
                ;; First compute the actual start and end column.

                (when (== @VIsual_mode Ctrl_V)
                    ((ร int[] fromc =) (ร new int[1]))
                    ((ร int[] toc =) (ร new int[1]))
                    ((ร int save_ve_flags =) @ve_flags)

                    (if @(:wo_lbr (:w_options @curwin))
                        (reset! ve_flags VE_ALL))
                    (getvcols wp, @VIsual, (:w_cursor @curwin), fromc, toc)
                    (reset! ve_flags save_ve_flags)
                    (ร toc[0]++)
                    (if (== (:w_curswant @curwin) MAXCOL)
                        ((ร toc[0] =) MAXCOL)
                    )

                    (when (or (!= (... fromc 0) (:w_old_cursor_fcol wp)) (!= (... toc 0) (:w_old_cursor_lcol wp)))
                        (if (< (:lnum @VIsual) from)
                            ((ร from =) (:lnum @VIsual))
                        )
                        (if (< to (:lnum @VIsual))
                            ((ร to =) (:lnum @VIsual))
                        )
                    )
                    ((ร wp.w_old_cursor_fcol =) (... fromc 0))
                    ((ร wp.w_old_cursor_lcol =) (... toc 0))
                )
            )
            :else
            (do
                ;; Use the line numbers of the old Visual area.
                (cond (< (:w_old_cursor_lnum wp) (:w_old_visual_lnum wp))
                (do
                    ((ร from =) (:w_old_cursor_lnum wp))
                    ((ร to =) (:w_old_visual_lnum wp))
                )
                :else
                (do
                    ((ร from =) (:w_old_visual_lnum wp))
                    ((ร to =) (:w_old_cursor_lnum wp))
                ))
            ))

            ;; There is no need to update lines above the top of the window.

            (if (< from (:w_topline wp))
                ((ร from =) (:w_topline wp))
            )

            ;; If we know the value of w_botline,
            ;; use it to restrict the update to the lines that are visible in the window.

            (when (flag? (:w_valid wp) VALID_BOTLINE)
                (if (>= from (:w_botline wp))
                    ((ร from =) (- (:w_botline wp) 1))
                )
                (if (>= to (:w_botline wp))
                    ((ร to =) (- (:w_botline wp) 1))
                )
            )

            ;; Find the minimal part to be updated.
            ;; Watch out for scrolling that made entries in w_lines[] invalid.
            ;; E.g., CTRL-U makes the first half of w_lines[] invalid and sets top_end;
            ;; need to redraw from top_end to the "to" line.
            ;; A middle mouse click with a Visual selection may change the text above
            ;; the Visual area and reset wl_valid, do count these for mid_end (in srow).

            (when (< 0 mid_start)
                ((ร long lnum =) (:w_topline wp))       ;; current buffer lnum to display
                ((ร int idx =) 0)                    ;; current index in w_lines[]
                ((ร int srow =) 0)                   ;; starting row of the current line
                ((ร mid_start =) (if scrolled_down top_end 0))
                (while (and (< lnum from) (< idx (:w_lines_valid wp)))   ;; find start
                    (cond (:wl_valid (... (:w_lines wp) idx))
                    (do
                        ((ร mid_start =) (+ mid_start (:wl_size (... (:w_lines wp) idx))))
                    )
                    (not scrolled_down)
                    (do
                        ((ร srow =) (+ srow (:wl_size (... (:w_lines wp) idx))))
                    ))
                    (ร idx++)
                    (ร lnum++)
                )
                ((ร srow =) (+ srow mid_start))
                ((ร mid_end =) (:w_height wp))
                ((ร FOR) (ร nil (< idx (:w_lines_valid wp)) (ร idx++))          ;; find end
                    (when (and (:wl_valid (... (:w_lines wp) idx)) (<= (inc to) (:wl_lnum (... (:w_lines wp) idx))))
                        ;; Only update until first row of this line.
                        ((ร mid_end =) srow)
                        (ร BREAK)
                    )
                    ((ร srow =) (+ srow (:wl_size (... (:w_lines wp) idx))))
                )
            )
        )

        (cond @VIsual_active
        (do
            ((ร wp.w_old_visual_mode =) @VIsual_mode)
            ((ร wp.w_old_cursor_lnum =) (:lnum (:w_cursor @curwin)))
            ((ร wp.w_old_visual_lnum =) (:lnum @VIsual))
            ((ร wp.w_old_visual_col =) (:col @VIsual))
            ((ร wp.w_old_curswant =) (:w_curswant @curwin))
        )
        :else
        (do
            ((ร wp.w_old_visual_mode =) 0)
            ((ร wp.w_old_cursor_lnum =) 0)
            ((ร wp.w_old_visual_lnum =) 0)
            ((ร wp.w_old_visual_col =) 0)
        ))

        ;; reset got_int, otherwise regexp won't work
        ((ร boolean save_got_int =) @got_int)
        (reset! got_int false)

        ;; Update all the window rows.

        ((ร int idx =) 0)                    ;; first entry in w_lines[].wl_size
        ((ร int row =) 0)                    ;; current window row to display
        ((ร int srow =) 0)                   ;; starting row of the current line
        ((ร long lnum =) (:w_topline wp))       ;; first line shown in window
        (while true
            ;; stop updating when reached the end of the window
            ;; (check for _past_ the end of the window is at the end of the loop)
            (when (== row (:w_height wp))
                ((ร didline =) true)
                (ร BREAK)
            )

            ;; stop updating when hit the end of the file
            (when (< (:ml_line_count (:b_ml buf)) lnum)
                ((ร eof =) true)
                (ร BREAK)
            )

            ;; Remember the starting row of the line that is going to be dealt with.
            ;; It is used further down when the line doesn't fit.
            ((ร srow =) row)

            ;; Update a line when it is in an area that needs updating,
            ;; when it has changes or w_lines[idx] is invalid.
            ;; bot_start may be halfway a wrapped line after using win-del-lines(),
            ;; check if the current line includes it.
            ;; When syntax folding is being used, the saved syntax states will
            ;; already have been updated, we can't see where the syntax state is
            ;; the same again, just update until the end of the window.

                                    ;; match in fixed position might need redraw
                                    ;; if lines were inserted or deleted
            (cond (or (< row top_end) (and (<= mid_start row) (< row mid_end)) top_to_mod (<= (:w_lines_valid wp) idx) (< bot_start (+ row (:wl_size (... (:w_lines wp) idx)))) (and (!= mod_top 0) (or (== lnum mod_top) (and (<= mod_top lnum) (or (< lnum mod_bot) (== did_update DID_FOLD) (and (non-nil? (:w_match_head wp)) (!= (:b_mod_xlines buf) 0)))))))
            (do
                (if (== lnum mod_top)
                    ((ร top_to_mod =) false)
                )

                ;; When at start of changed lines:
                ;; may scroll following lines up or down to minimize redrawing.
                ;; Don't do this when the change continues until the end.

                (when (and (== lnum mod_top) (!= mod_bot MAXLNUM))
                    ((ร int old_rows =) 0)
                    ((ร int new_rows =) 0)
                    (ร int xtra_rows)
                    (ร long l)

                    ;; Count the old number of window rows, using w_lines[], which should
                    ;; still contain the sizes for the lines as they are currently displayed.

                    ((ร FOR) (ร ((ร i =) idx) (< i (:w_lines_valid wp)) (ร i++))
                        ;; Only valid lines have a meaningful wl_lnum.
                        ;; Invalid lines are part of the changed area.
                        (if (and (:wl_valid (... (:w_lines wp) i)) (== (:wl_lnum (... (:w_lines wp) i)) mod_bot))
                            (ร BREAK)
                        )
                        ((ร old_rows =) (+ old_rows (:wl_size (... (:w_lines wp) i))))
                    )

                    (cond (<= (:w_lines_valid wp) i)
                    (do
                        ;; We can't find a valid line below the changed lines,
                        ;; need to redraw until the end of the window.
                        ;; Inserting/deleting lines has no use.
                        ((ร bot_start =) 0)
                    )
                    :else
                    (do
                        ;; Able to count old number of rows:
                        ;; count new window rows, and may insert/delete lines.
                        ((ร int j =) idx)
                        ((ร FOR) (ร ((ร l =) lnum) (< l mod_bot) (ร l++))
                            ((ร new_rows =) (+ new_rows (plines-win wp, l, true)))
                            (ร j++)
                            (when (< (- (:w_height wp) row 2) new_rows)
                                ;; it's getting too much, must redraw the rest
                                ((ร new_rows =) 9999)
                                (ร BREAK)
                            )
                        )
                        ((ร xtra_rows =) (- new_rows old_rows))
                        (cond (< xtra_rows 0)
                        (do
                            ;; May scroll text up.
                            ;; If there is not enough remaining text or scrolling fails,
                            ;; must redraw the rest.
                            ;; If scrolling works,
                            ;; must redraw the text below the scrolled text.
                            (cond (<= (- (:w_height wp) 2) (- row xtra_rows))
                            (do
                                ((ร mod_bot =) MAXLNUM)
                            )
                            :else
                            (do
                                (check-for-delay false)
                                (if (not (win-del-lines wp, row, (- xtra_rows), false, false))
                                    ((ร mod_bot =) MAXLNUM)
                                    ((ร bot_start =) (+ (:w_height wp) xtra_rows))
                                )
                            ))
                        )
                        (< 0 xtra_rows)
                        (do
                            ;; May scroll text down.
                            ;; If there is not enough remaining text of scrolling fails,
                            ;; must redraw the rest.
                            (cond (<= (- (:w_height wp) 2) (+ row xtra_rows))
                            (do
                                ((ร mod_bot =) MAXLNUM)
                            )
                            :else
                            (do
                                (check-for-delay false)
                                (cond (not (win-ins-lines wp, (+ row old_rows), xtra_rows, false, false))
                                (do
                                    ((ร mod_bot =) MAXLNUM)
                                )
                                (< (+ row old_rows) top_end)
                                (do
                                    ;; Scrolled the part at the top that requires updating down.
                                    ((ร top_end =) (+ top_end xtra_rows))
                                ))
                            ))
                        ))

                        ;; When not updating the rest, may need to move w_lines[] entries.
                        (when (and (!= mod_bot MAXLNUM) (!= i j))
                            (cond (< j i)
                            (do
                                ((ร int x =) (+ row new_rows))

                                ;; move entries in w_lines[] upwards
                                (while true
                                    ;; stop at last valid entry in w_lines[]
                                    (when (<= (:w_lines_valid wp) i)
                                        ((ร wp.w_lines_valid =) j)
                                        (ร BREAK)
                                    )
                                    (COPY-wline (... (:w_lines wp) j), (... (:w_lines wp) i))
                                    ;; stop at a line that won't fit
                                    (when (< (:w_height wp) (+ x (:wl_size (... (:w_lines wp) j))))
                                        ((ร wp.w_lines_valid =) (inc j))
                                        (ร BREAK)
                                    )
                                    ((ร x =) (+ x (:wl_size (... (:w_lines wp) (ร j++)))))
                                    (ร i++)
                                )
                                (if (< x bot_start)
                                    ((ร bot_start =) x)
                                )
                            )
                            :else ;; j > i
                            (do
                                ;; move entries in w_lines[] downwards
                                ((ร j =) (- j i))
                                ((ร wp.w_lines_valid =) (+ (:w_lines_valid wp) j))
                                (if (> (:w_lines_valid wp) (:w_height wp))
                                    ((ร wp.w_lines_valid =) (:w_height wp))
                                )
                                ((ร FOR) (ร ((ร i =) (:w_lines_valid wp)) (<= idx (- i j)) (ร --i))
                                    (COPY-wline (... (:w_lines wp) i), (... (:w_lines wp) (- i j)))
                                )

                                ;; The w_lines[] entries for inserted lines are now invalid,
                                ;; but wl_size may be used above.
                                ;; Reset to zero.
                                (while (<= idx i)
                                    ((ร wp.w_lines[i].wl_size =) 0)
                                    ((ร wp.w_lines[i--].wl_valid =) false)
                                )
                            ))
                        )
                    ))
                )

                (cond (and (< idx (:w_lines_valid wp)) (:wl_valid (... (:w_lines wp) idx)) (== (:wl_lnum (... (:w_lines wp) idx)) lnum) (< (:w_topline wp) lnum) (non-flag? @dy_flags DY_LASTLINE) (< (:w_height wp) (+ srow (:wl_size (... (:w_lines wp) idx)))))
                (do
                    ;; This line is not going to fit.
                    ;; Don't draw anything here, will draw "@  " lines below.
                    ((ร row =) (+ (:w_height wp) 1))
                )
                :else
                (do
                    (prepare-search-hl wp, lnum)

                    ;; Display one line.

                    ((ร row =) (win-line wp, lnum, srow, (:w_height wp), (== mod_top 0)))

                    ((ร did_update =) DID_LINE)
                ))

                ((ร wp.w_lines[idx].wl_lnum =) lnum)
                ((ร wp.w_lines[idx].wl_valid =) true)
                (when (< (:w_height wp) row)              ;; past end of screen
                    ;; we may need the size of that too long line later on
                    ((ร wp.w_lines[idx].wl_size =) (plines-win wp, lnum, true))
                    (ร idx++)
                    (ร BREAK)
                )
                ((ร wp.w_lines[idx].wl_size =) (- row srow))
                (ร idx++)
                (ร lnum++)
            )
            :else
            (do
                ;; This line does not need updating, advance to the next one.
                ((ร row =) (+ row (:wl_size (... (:w_lines wp) (ร idx++)))))
                (if (< (:w_height wp) row)              ;; past end of screen
                    (ร BREAK)
                )
                (ร lnum++)
                ((ร did_update =) DID_NONE)
            ))

            (when (< (:ml_line_count (:b_ml buf)) lnum)
                ((ร eof =) true)
                (ร BREAK)
            )
        )

        ;; End of loop over all window lines.

        (if (< (:w_lines_valid wp) idx)
            ((ร wp.w_lines_valid =) idx)
        )

        ;; If we didn't hit the end of the file, and we didn't finish the last
        ;; line we were working on, then the line didn't fit.

        ((ร wp.w_empty_rows =) 0)
        (cond (and (not eof) (not didline))
        (do
            (cond (== lnum (:w_topline wp))
            (do
                ;; Single line that does not fit!
                ;; Don't overwrite it, it can be edited.

                ((ร wp.w_botline =) (inc lnum))
            )
            (flag? @dy_flags DY_LASTLINE)     ;; 'display' has "lastline"
            (do
                ;; Last line isn't finished: Display "@@@" at the end.

                (screen-fill (- (+ (:w_winrow wp) (:w_height wp)) 1), (+ (:w_winrow wp) (:w_height wp)), (- (+ (:w_wincol wp) (:w_width wp)) 3), (+ (:w_wincol wp) (:w_width wp)), (byte \@), (byte \@), (hl-attr HLF_AT))
                (set-empty-rows wp, srow)
                ((ร wp.w_botline =) lnum)
            )
            :else
            (do
                (win-draw-end wp, (byte \@), (byte \space), srow, (:w_height wp), HLF_AT)
                ((ร wp.w_botline =) lnum)
            ))
        )
        :else
        (do
            (draw-vsep-win wp, row)
            (cond eof                                ;; we hit the end of the file
            (do
                ((ร wp.w_botline =) (+ (:ml_line_count (:b_ml buf)) 1))
            )
            :else
            (do
                ((ร wp.w_botline =) lnum)
            ))

            ;; Make sure the rest of the screen is blank,
            ;; put '~'s on rows that aren't part of the file.
            (win-draw-end wp, (byte \~), (byte \space), row, (:w_height wp), HLF_AT)
        ))

        ;; Reset the type of redrawing required, the window has been updated.
        ((ร wp.w_redr_type =) 0)

        ;; There is a trick with w_botline.  If we invalidate it on each
        ;; change that might modify it, this will cause a lot of expensive
        ;; calls to plines() in update-topline() each time.  Therefore the
        ;; value of w_botline is often approximated, and this value is used to
        ;; compute the value of w_topline.  If the value of w_botline was
        ;; wrong, check that the value of w_topline is correct (cursor is on
        ;; the visible part of the text).  If it's not, we need to redraw
        ;; again.  Mostly this just means scrolling up a few lines, so it
        ;; doesn't look too bad.  Only do this for the current window (where
        ;; changes are relevant).

        ((ร wp.w_valid =) (| (:w_valid wp) VALID_BOTLINE))
        (when (and (== wp @curwin) (!= (:w_botline wp) old_botline) (not @_2_recursive))
            (reset! _2_recursive true)
            ((ร @curwin.w_valid =) (& (:w_valid @curwin) (bit-not VALID_TOPLINE)))
            (update-topline)   ;; may invalidate w_botline again
            (when (non-zero? @must_redraw)
                ;; Don't update for changes in buffer again.
                ((ร boolean b =) (:b_mod_set @curbuf))
                ((ร @curbuf.b_mod_set =) false)
                (win-update @curwin)
                (reset! must_redraw 0)
                ((ร @curbuf.b_mod_set =) b)
            )
            (reset! _2_recursive false)
        )

        ;; restore got_int, unless CTRL-C was hit while redrawing
        (when (not @got_int)
            (reset! got_int save_got_int)
        )
        nil
    ))

;; Clear the rest of the window and mark the unused lines with "c1".
;; Use "c2" as the filler character.

(defn- #_void win-draw-end [#_window_C wp, #_int c1, #_int c2, #_int row, #_int endrow, #_int hl]
    (ยง
        ((ร int n =) 0)

        (when (and (non-zero? @cmdwin_type) (== wp @curwin))
            ;; draw the cmdline character in the leftmost column
            ((ร n =) 1)
            (if (> n (:w_width wp))
                ((ร n =) (:w_width wp))
            )
            (screen-fill (+ (:w_winrow wp) row), (+ (:w_winrow wp) endrow), (:w_wincol wp), (+ (:w_wincol wp) n), @cmdwin_type, (byte \space), (hl-attr HLF_AT))
        )
        (screen-fill (+ (:w_winrow wp) row), (+ (:w_winrow wp) endrow), (+ (:w_wincol wp) n), (+ (:w_wincol wp) (:w_width wp)), c1, c2, (hl-attr hl))

        (set-empty-rows wp, row)
        nil
    ))

;; Advance **color_cols and return true when there are columns to draw.

(defn- #_boolean advance-color-col [#_int vcol, #_int* color_cols, #_int* cci]
    (ยง
        (while (and (<= 0 (... color_cols (... cci 0))) (< (... color_cols (... cci 0)) vcol))
            (ร cci[0]++)
        )

        (<= 0 (... color_cols (... cci 0)))
    ))

;; used for p_extra when displaying lcs_eol at end-of-line
(final Bytes at_end_str (u8 ""))

;; draw_state: items that are drawn in sequence:
(final int
    WL_START   0,   ;; nothing done yet
    WL_CMDLINE 1,   ;; cmdline window column
    WL_NR      2,   ;; line number
    WL_BRI     3,   ;; 'breakindent'
    WL_SBR     4,   ;; 'showbreak' or 'diff'
    WL_LINE    5)   ;; text in the line

;; Display line "lnum" of window 'wp' on the screen.
;; Start at row "startrow", stop when "endrow" is reached.
;; wp.w_virtcol needs to be valid.
;;
;; Return the number of last row the line occupies.

(defn- #_int win-line [#_window_C wp, #_long lnum, #_int startrow, #_int endrow, #_boolean _nochange]
    ;; nochange: not updating for changed text
    (ยง
        ((ร int c =) 0)
        ((ร int vcol =) 0)                          ;; virtual column (for tabs)
        ((ร int vcol_sbr =) -1)                     ;; virtual column after showbreak
        ((ร int vcol_prev =) -1)                    ;; "vcol" of previous character

        ((ร Bytes extra =) (Bytes. 18))            ;; "%ld" and 'fdc' must fit in here
        ((ร int n_extra =) 0)                        ;; number of extra chars
        ((ร Bytes p_extra =) nil)                  ;; string of extra chars, plus NUL
        ((ร Bytes p_extra_free =) nil)             ;; "p_extra" needs to be freed
        ((ร int c_extra =) NUL)                      ;; extra chars, all the same
        ((ร int extra_attr =) 0)                     ;; attributes when n_extra != 0

        ((ร int lcs_eol_one =) @lcs_eol)              ;; lcs_eol until it's been used

        ((ร int saved_n_extra =) 0)  ;; saved "extra" items for when draw_state becomes WL_LINE (again)
        ((ร Bytes saved_p_extra =) nil)
        ((ร int saved_c_extra =) 0)
        ((ร int saved_char_attr =) 0)

        ((ร int n_attr =) 0)                         ;; chars with special attr
        ((ร int saved_attr2 =) 0)                    ;; char_attr saved for n_attr
        ((ร int n_attr3 =) 0)                        ;; chars with overruling special attr
        ((ร int saved_attr3 =) 0)                    ;; char_attr saved for n_attr3

        ((ร int n_skip =) 0)                         ;; nr of chars to skip for 'nowrap'

        ((ร int fromcol_prev =) -2)                  ;; start of inverting after cursor
        ((ร boolean noinvcur =) false)               ;; don't invert the cursor
        (ร pos_C top, bot)
        ((ร boolean lnum_in_visual_area =) false)

        ((ร int char_attr =) 0)                      ;; attributes for next character
        ((ร boolean attr_pri =) false)               ;; char_attr has priority
        ((ร boolean area_highlighting =) false)      ;; Visual or incsearch highlighting in this line
        ((ร int attr =) 0)                           ;; attributes for area highlighting
        ((ร int area_attr =) 0)                      ;; attributes desired by highlighting
        ((ร int search_attr =) 0)                    ;; attributes desired by 'hlsearch'
        ((ร int vcol_save_attr =) 0)                 ;; saved attr for 'cursorcolumn'
        ((ร int syntax_attr =) 0)                    ;; attributes desired by syntax
        ((ร int eol_hl_off =) 0)                     ;; 1 if highlighted char after EOL
        ((ร int multi_attr =) 0)                     ;; attributes desired by multibyte
        ((ร int mb_l =) 1)                           ;; multi-byte byte length
        ((ร int mb_c =) 0)                           ;; decoded multi-byte character
        ((ร boolean mb_utf8 =) false)                ;; screen char is UTF-8 char
        ((ร int[] u8cc =) (ร new int[MAX_MCO]))          ;; composing UTF-8 chars
        ((ร int trailcol =) MAXCOL)                  ;; start of trailing spaces
        ((ร boolean need_showbreak =) false)

        ((ร int line_attr =) 0)                      ;; attribute for the whole line
        ((ร int did_line_attr =) 0)

        ((ร int draw_state =) WL_START)              ;; what to draw next

        ((ร int syntax_flags =) 0)
; %%    ((ร int[] syntax_seqnr =) (ร { 0 }))
        ((ร int prev_syntax_id =) 0)
        ((ร int conceal_attr =) (hl-attr HLF_CONCEAL))
        ((ร boolean is_concealing =) false)
        ((ร int boguscols =) 0)                      ;; nonexistent columns added to force wrapping
        ((ร int vcol_off =) 0)                       ;; offset for concealed characters
        ((ร boolean did_wcol =) false)
        ((ร int old_boguscols =) 0)

        (if (< endrow startrow)                  ;; past the end already!
            ((ร RETURN) startrow)
        )

        ((ร int row =) startrow)                     ;; row in the window, excl w_winrow
        ((ร int screen_row =) (+ row (:w_winrow wp)))     ;; row on the screen, incl w_winrow

        ;; To speed up the loop below, set extra_check when there is linebreak,
        ;; trailing white space and/or syntax processing to be done.

        ((ร boolean extra_check =) @(:wo_lbr (:w_options wp)))  ;; has syntax or linebreak

        ;; Check for columns to display for 'colorcolumn'.
; %%    ((ร int[] color_cols =) (ร wp.w_p_cc_cols, cci = { 0 }))         ;; pointer to according columns array
        ((ร boolean draw_color_col =) false)                         ;; highlight colorcolumn
        (if (non-nil? color_cols)
            ((ร draw_color_col =) (advance-color-col (- vcol vcol_off), color_cols, cci))
        )

        ;; handle visual active in this window

; %%    ((ร int[] fromcol =) (ร { -10 }, tocol = { MAXCOL }))            ;; start/end of inverting
        (cond @VIsual_active
        (do
            (cond (ltoreq (:w_cursor @curwin), @VIsual)                ;; Visual is after curwin.w_cursor
            (do
                ((ร top =) (:w_cursor @curwin))
                ((ร bot =) @VIsual)
            )
            :else                                                ;; Visual is before curwin.w_cursor
            (do
                ((ร top =) @VIsual)
                ((ร bot =) (:w_cursor @curwin))
            ))

            ((ร lnum_in_visual_area =) (and (<= (:lnum top) lnum) (<= lnum (:lnum bot))))

            (cond (== @VIsual_mode Ctrl_V)                          ;; block mode
            (do
                (when lnum_in_visual_area
                    ((ร fromcol[0] =) (:w_old_cursor_fcol wp))
                    ((ร tocol[0] =) (:w_old_cursor_lcol wp))
                )
            )
            :else                                        ;; non-block mode
            (do
                (cond (and (< (:lnum top) lnum) (<= lnum (:lnum bot)))
                (do
                    ((ร fromcol[0] =) 0)
                )
                (== lnum (:lnum top))
                (do
                    (cond (== @VIsual_mode (byte \V))             ;; linewise
                    (do
                        ((ร fromcol[0] =) 0)
                    )
                    :else
                    (do
                        (getvvcol wp, top, fromcol, nil, nil)
                        (if (== (gchar-pos top) NUL)
                            ((ร tocol[0] =) (+ (... fromcol 0) 1))
                        )
                    ))
                ))
                (when (and (!= @VIsual_mode (byte \V)) (== lnum (:lnum bot)))
                    (cond (and (== (.at @p_sel 0) (byte \e)) (zero? (:col bot)) (zero? (:coladd bot)))
                    (do
                        ((ร fromcol[0] =) -10)
                        ((ร tocol[0] =) MAXCOL)
                    )
                    (== (:col bot) MAXCOL)
                    (do
                        ((ร tocol[0] =) MAXCOL)
                    )
                    :else
                    (do
                        ((ร pos_C pos =) (NEW_pos_C))
                        (COPY-pos pos, bot)
                        (cond (== (.at @p_sel 0) (byte \e))
                        (do
                            (getvvcol wp, pos, tocol, nil, nil)
                        )
                        :else
                        (do
                            (getvvcol wp, pos, nil, nil, tocol)
                            (ร tocol[0]++)
                        ))
                    ))
                )
            ))

            ;; Check if the character under the cursor should not be inverted.
            (if (and (not @highlight_match) (== lnum (:lnum (:w_cursor @curwin))) (== wp @curwin))
                ((ร noinvcur =) true)
            )

            ;; if inverting in this line set area_highlighting
            (when (<= 0 (... fromcol 0))
                ((ร area_highlighting =) true)
                ((ร attr =) (hl-attr HLF_V))
            )
        )

        ;; handle 'incsearch' and ":s///c" highlighting

        (and @highlight_match (== wp @curwin) (<= (:lnum (:w_cursor @curwin)) lnum) (<= lnum (+ (:lnum (:w_cursor @curwin)) @search_match_lines)))
        (do
            (if (== lnum (:lnum (:w_cursor @curwin)))
                (getvcol @curwin, (:w_cursor @curwin), fromcol, nil, nil)
                ((ร fromcol[0] =) 0)
            )
            (cond (== lnum (+ (:lnum (:w_cursor @curwin)) @search_match_lines))
            (do
                ((ร pos_C pos =) (NEW_pos_C))
                ((ร pos.lnum =) lnum)
                ((ร pos.col =) @search_match_endcol)

                (getvcol @curwin, pos, tocol, nil, nil)
            )
            :else
            (do
                ((ร tocol[0] =) MAXCOL)
            ))
            ;; do at least one character; happens when past end of line
            (if (== (... fromcol 0) (... tocol 0))
                ((ร tocol[0] =) (+ (... fromcol 0) 1))
            )
            ((ร area_highlighting =) true)
            ((ร attr =) (hl-attr HLF_I))
        ))

        (if (non-zero? line_attr)
            ((ร area_highlighting =) true)
        )

        ((ร Bytes line =) (ml-get-buf @curbuf, lnum)) ;; current line
        ((ร Bytes ptr =) line)                                  ;; current position in "line"

        ;; 'nowrap' or 'wrap' and a single line that doesn't fit:
        ;; advance to the first character to be displayed.

        ((ร int v =) (if @(:wo_wrap (:w_options wp)) (:w_skipcol wp) (:w_leftcol wp)))
        (when (< 0 v)
            ((ร Bytes prev_ptr =) ptr)
            (while (and (< vcol v) (non-eos? ptr))
                ((ร c =) (win-lbr-chartabsize wp, line, ptr, vcol, nil))
                ((ร vcol =) (+ vcol c))
                ((ร prev_ptr =) ptr)
                ((ร ptr =) (.plus ptr (us-ptr2len-cc ptr)))
            )

            ;; When:
            ;; - 'cuc' is set, or
            ;; - 'colorcolumn' is set, or
            ;; - 'virtualedit' is set, or
            ;; - the visual mode is active,
            ;; the end of the line may be before the start of the displayed part.

            (when (and (< vcol v) (or @(:wo_cuc (:w_options wp)) draw_color_col (virtual-active) @VIsual_active))
                ((ร vcol =) v)
            )

            ;; Handle a character that's not completely on the screen:
            ;; put 'ptr' at that character, but skip the first few screen characters.
            (when (< v vcol)
                ((ร vcol =) (- vcol c))
                ((ร ptr =) prev_ptr)
                ((ร n_skip =) (- v vcol))
            )

            ;; Adjust for when the inverted text is before the screen,
            ;; and when the start of the inverted text is before the screen.

            (cond (<= (... tocol 0) vcol)
            (do
                ((ร fromcol[0] =) 0)
            )
            (and (<= 0 (... fromcol 0)) (< (... fromcol 0) vcol))
            (do
                ((ร fromcol[0] =) vcol)
            ))

            ;; When w_skipcol is non-zero, first line needs 'showbreak'.
            (if @(:wo_wrap (:w_options wp))
                ((ร need_showbreak =) true)
            )
        )

        ;; Correct highlighting for cursor that can't be disabled.
        ;; Avoids having to check this for each character.

        (when (<= 0 (... fromcol 0))
            (when noinvcur
                (cond (== (... fromcol 0) (:w_virtcol wp))
                (do
                    ;; highlighting starts at cursor, let it start just after the cursor
                    ((ร fromcol_prev =) (... fromcol 0))
                    ((ร fromcol[0] =) -1)
                )
                (< (... fromcol 0) (:w_virtcol wp))
                (do
                    ;; restart highlighting after the cursor
                    ((ร fromcol_prev =) (:w_virtcol wp))
                ))
            )
            (if (<= (... tocol 0) (... fromcol 0))
                ((ร fromcol[0] =) -1)
            )
        )

        ;; Handle highlighting the last used search pattern and matches.
        ;; Do this for both search_hl and the match list.

        ((ร matchitem_C mi =) (:w_match_head wp))   ;; points to the match list
        ((ร boolean shl_flag =) false)           ;; whether search_hl has been processed
        (while (or (non-nil? mi) (not shl_flag))
            (ร match_C shl)                    ;; points to search_hl or a match
            (cond (not shl_flag)
            (do
                ((ร shl =) @search_hl)
                ((ร shl_flag =) true)
            )
            :else
            (do
                ((ร shl =) (:mi_hl mi))
            ))
            ((ร shl.startcol =) MAXCOL)
            ((ร shl.endcol =) MAXCOL)
            ((ร shl.attr_cur =) 0)
            ((ร v =) (BDIFF ptr, line))
            (if (non-nil? mi)
                ((ร mi.mi_pos.cur =) 0)
            )
            (next-search-hl wp, shl, lnum, v, mi)

            ;; Need to get the line again, a multi-line regexp may have made it invalid.
            ((ร line =) (ml-get-buf @curbuf, lnum))
            ((ร ptr =) (.plus line v))

            (when (and (non-zero? (:lnum shl)) (<= (:lnum shl) lnum))
                ((ร shl.startcol =) (if (== (:lnum shl) lnum) (:col (... (:startpos (:rmm shl)) 0)) 0))
                ((ร shl.endcol =) (if (== lnum (- (+ (:lnum shl) (:lnum (... (:endpos (:rmm shl)) 0))) (:lnum (... (:startpos (:rmm shl)) 0)))) (:col (... (:endpos (:rmm shl)) 0)) MAXCOL))
                ;; Highlight one character for an empty match.
                (when (== (:startcol shl) (:endcol shl))
                    (if (!= (.at line (:endcol shl)) NUL)
                        ((ร shl.endcol =) (+ (:endcol shl) (us-ptr2len-cc (.plus line (:endcol shl)))))
                        (ร shl.endcol++)
                    )
                )
                (when (< (long (:startcol shl)) v) ;; match at leftcol
                    ((ร shl.attr_cur =) (:attr shl))
                    ((ร search_attr =) (:attr shl))
                )
                ((ร area_highlighting =) true)
            )
            (if (and (!= shl @search_hl) (non-nil? mi))
                ((ร mi =) (:next mi))
            )
        )

        ;; Cursor line highlighting for 'cursorline' in the current window.
        ;; Not when Visual mode is active, because it's not clear what is selected then.
        (when (and @(:wo_cul (:w_options wp)) (== lnum (:lnum (:w_cursor wp))) (not (and (== wp @curwin) @VIsual_active)))
            ((ร line_attr =) (hl-attr HLF_CUL))
            ((ร area_highlighting =) true)
        )

        ((ร int col =) 0)                                        ;; visual column on screen
        ((ร int off =) (BDIFF @current_ScreenLine, @screenLines))  ;; offset in screenLines/screenAttrs

        ;; Repeat for the whole displayed line.

        (while true
            ;; Skip this quickly when working on the text.
            (when (!= draw_state WL_LINE)
                (when (and (== draw_state (dec WL_CMDLINE)) (zero? n_extra))
                    ((ร draw_state =) WL_CMDLINE)
                    (when (and (non-zero? @cmdwin_type) (== wp @curwin))
                        ;; Draw the cmdline character.
                        ((ร n_extra =) 1)
                        ((ร c_extra =) @cmdwin_type)
                        ((ร char_attr =) (hl-attr HLF_AT))
                    )
                )

                (when (and (== draw_state (dec WL_NR)) (zero? n_extra))
                    ((ร draw_state =) WL_NR)
                    ;; Display the absolute or relative line number.
                    ;; After the first fill with blanks when the 'n' flag isn't in 'cpo'.
                    (when (and (or @(:wo_nu (:w_options wp)) @(:wo_rnu (:w_options wp))) (or (== row startrow) (nil? (vim-strbyte @p_cpo, CPO_NUMCOL))))
                        ;; Draw the line number (empty space after wrapping).
                        (cond (== row startrow)
                        (do
                            (ร long num)
                            ((ร Bytes fmt =) (u8 "%*ld "))

                            (cond (and @(:wo_nu (:w_options wp)) (not @(:wo_rnu (:w_options wp))))
                            (do
                                ;; 'number' + 'norelativenumber'
                                ((ร num =) lnum)
                            )
                            :else
                            (do
                                ;; 'relativenumber', don't use negative numbers
                                ((ร num =) (Math/abs (get-cursor-rel-lnum wp, lnum)))
                                (when (and (zero? num) @(:wo_nu (:w_options wp)) @(:wo_rnu (:w_options wp)))
                                    ;; 'number' + 'relativenumber'
                                    ((ร num =) lnum)
                                    ((ร fmt =) (u8 "%-*ld "))
                                )
                            ))

                            (.sprintf libC extra, fmt, (number-width wp), num)
                            (when (< 0 (:w_skipcol wp))
                                ((ร FOR) (ร ((ร p_extra =) extra) (== (.at p_extra 0) (byte \space)) ((ร p_extra =) (.plus p_extra 1)))
                                    (.be p_extra 0, (byte \-))
                                )
                            )
                            ((ร p_extra =) extra)
                            ((ร c_extra =) NUL)
                        )
                        :else
                        (do
                            ((ร c_extra =) (byte \space))
                        ))
                        ((ร n_extra =) (+ (number-width wp) 1))
                        ((ร char_attr =) (hl-attr HLF_N))
                        ;; When 'cursorline' is set, highlight the line number of the current line differently.
                        ;; TODO: Can we use CursorLine instead of CursorLineNr when CursorLineNr isn't set?
                        (if (and (or @(:wo_cul (:w_options wp)) @(:wo_rnu (:w_options wp))) (== lnum (:lnum (:w_cursor wp))))
                            ((ร char_attr =) (hl-attr HLF_CLN))
                        )
                    )
                )

                (cond (and (:w_p_brisbr wp) (== draw_state (dec WL_BRI)) (zero? n_extra) (non-eos? @p_sbr))
                (do
                    ;; draw indent after showbreak value
                    ((ร draw_state =) WL_BRI)
                )
                (and (:w_p_brisbr wp) (== draw_state WL_SBR) (zero? n_extra))
                (do
                    ;; After the showbreak, draw the breakindent.
                    ((ร draw_state =) (dec WL_BRI))
                ))

                ;; draw 'breakindent': indent wrapped text accordingly
                (when (and (== draw_state (dec WL_BRI)) (zero? n_extra))
                    ((ร draw_state =) WL_BRI)
                    (when (and @(:wo_bri (:w_options wp)) (zero? n_extra) (!= row startrow))
                        ((ร char_attr =) 0) ;; was: hl-attr(HLF_AT);
                        ((ร p_extra =) nil)
                        ((ร c_extra =) (byte \space))
                        ((ร n_extra =) (get-breakindent-win wp, (ml-get-buf @curbuf, lnum)))
                        ;; Correct end of highlighted area for 'breakindent',
                        ;; required when 'linebreak' is also set.
                        (if (== (... tocol 0) vcol)
                            ((ร tocol[0] =) (+ (... tocol 0) n_extra))
                        )
                    )
                )

                (when (and (== draw_state (dec WL_SBR)) (zero? n_extra))
                    ((ร draw_state =) WL_SBR)
                    (when (and (non-eos? @p_sbr) need_showbreak)
                        ;; Draw 'showbreak' at the start of each broken line.
                        ((ร p_extra =) @p_sbr)
                        ((ร c_extra =) NUL)
                        ((ร n_extra =) (STRLEN @p_sbr))
                        ((ร char_attr =) (hl-attr HLF_AT))
                        ((ร need_showbreak =) false)
                        ((ร vcol_sbr =) (+ vcol (us-charlen @p_sbr)))
                        ;; Correct end of highlighted area for 'showbreak',
                        ;; required when 'linebreak' is also set.
                        (if (== (... tocol 0) vcol)
                            ((ร tocol[0] =) (+ (... tocol 0) n_extra))
                        )
                        ;; combine 'showbreak' with 'cursorline'
                        (if (and @(:wo_cul (:w_options wp)) (== lnum (:lnum (:w_cursor wp))))
                            ((ร char_attr =) (hl-combine-attr char_attr, (hl-attr HLF_CUL)))
                        )
                    )
                )

                (when (and (== draw_state (dec WL_LINE)) (zero? n_extra))
                    ((ร draw_state =) WL_LINE)
                    (cond (non-zero? saved_n_extra)
                    (do
                        ;; Continue item from end of wrapped line.
                        ((ร n_extra =) saved_n_extra)
                        ((ร c_extra =) saved_c_extra)
                        ((ร p_extra =) saved_p_extra)
                        ((ร char_attr =) saved_char_attr)
                    )
                    :else
                    (do
                        ((ร char_attr =) 0)
                    ))
                )
            )

            (when (and (== draw_state WL_LINE) area_highlighting)
                ;; handle Visual or match highlighting in this line
                                                            ;; not at margin
                (cond (or (== vcol (... fromcol 0)) (and (== (inc vcol) (... fromcol 0)) (== n_extra 0) (< 1 (us-ptr2cells ptr))) (and (== vcol_prev fromcol_prev) (< vcol_prev vcol) (< vcol (... tocol 0))))
                (do
                    ((ร area_attr =) attr)                       ;; start highlighting
                )
                (and (!= area_attr 0) (or (== vcol (... tocol 0)) (and noinvcur (== vcol (:w_virtcol wp)))))
                (do
                    ((ร area_attr =) 0)                          ;; stop highlighting
                ))

                (when (zero? n_extra)
                    ;; Check for start/end of search pattern match.
                    ;; After end, check for start/end of next match.
                    ;; When another match, have to check for start again.
                    ;; Watch out for matching an empty string!
                    ;; Do this for 'search_hl' and the match list (ordered by priority).

                    ((ร v =) (BDIFF ptr, line))
                    ((ร mi =) (:w_match_head wp))
                    ((ร shl_flag =) false)
                    (while (or (non-nil? mi) (not shl_flag))
                        (ร match_C shl)        ;; points to search_hl or a match
                        (cond (and (not shl_flag) (or (and (non-nil? mi) (< SEARCH_HL_PRIORITY (:priority mi))) (nil? mi)))
                        (do
                            ((ร shl =) @search_hl)
                            ((ร shl_flag =) true)
                        )
                        :else
                        (do
                            ((ร shl =) (:mi_hl mi))
                        ))
                        (if (non-nil? mi)
                            ((ร mi.mi_pos.cur =) 0)
                        )
                        ;; marks that position match search is in progress
                        ((ร boolean pos_inprogress =) true)
                        (while (or (non-nil? (:regprog (:rmm shl))) (and (non-nil? mi) pos_inprogress))
                            (cond (and (!= (:startcol shl) MAXCOL) (<= (:startcol shl) v) (< v (:endcol shl)))
                            (do
                                ((ร int tmp_col =) (+ v (us-ptr2len-cc ptr)))

                                (if (< (:endcol shl) tmp_col)
                                    ((ร shl.endcol =) tmp_col)
                                )
                                ((ร shl.attr_cur =) (:attr shl))
                            )
                            (== v (:endcol shl))
                            (do
                                ((ร shl.attr_cur =) 0)
                                (next-search-hl wp, shl, lnum, v, mi)
                                ((ร pos_inprogress =) (and (non-nil? mi) (!= (:cur (:mi_pos mi)) 0)))

                                ;; Need to get the line again, a multi-line regexp may have made it invalid.
                                ((ร line =) (ml-get-buf @curbuf, lnum))
                                ((ร ptr =) (.plus line v))

                                (when (== (:lnum shl) lnum)
                                    ((ร shl.startcol =) (:col (... (:startpos (:rmm shl)) 0)))
                                    ((ร shl.endcol =) (if (zero? (:lnum (... (:endpos (:rmm shl)) 0))) (:col (... (:endpos (:rmm shl)) 0)) MAXCOL))

                                    (when (== (:startcol shl) (:endcol shl))
                                        ;; highlight empty match, try again after it
                                        ((ร shl.endcol =) (+ (:endcol shl) (us-ptr2len-cc (.plus line (:endcol shl)))))
                                    )

                                    ;; Loop to check if the match starts at the current position.
                                    (ร CONTINUE)
                                )
                            ))
                            (ร BREAK)
                        )
                        (if (and (!= shl @search_hl) (non-nil? mi))
                            ((ร mi =) (:next mi))
                        )
                    )

                    ;; Use attributes from match with highest priority
                    ;; among 'search_hl' and the match list.
                    ((ร search_attr =) (:attr_cur @search_hl))
                    ((ร mi =) (:w_match_head wp))
                    ((ร shl_flag =) false)
                    (while (or (non-nil? mi) (not shl_flag))
                        (ร match_C shl)        ;; points to search_hl or a match
                        (cond (and (not shl_flag) (or (and (non-nil? mi) (< SEARCH_HL_PRIORITY (:priority mi))) (nil? mi)))
                        (do
                            ((ร shl =) @search_hl)
                            ((ร shl_flag =) true)
                        )
                        :else
                        (do
                            ((ร shl =) (:mi_hl mi))
                        ))
                        (if (non-zero? (:attr_cur shl))
                            ((ร search_attr =) (:attr_cur shl))
                        )
                        (if (and (!= shl @search_hl) (non-nil? mi))
                            ((ร mi =) (:next mi))
                        )
                    )
                )

                ;; Decide which of the highlight attributes to use.
                ((ร attr_pri =) true)

                (cond (non-zero? area_attr)
                (do
                    ((ร char_attr =) (hl-combine-attr line_attr, area_attr))
                )
                (non-zero? search_attr)
                (do
                    ((ร char_attr =) (hl-combine-attr line_attr, search_attr))
                )
                ;; Use line_attr when not in the Visual or 'incsearch' area
                ;; (area_attr may be 0 when "noinvcur" is set).
                (and (non-zero? line_attr) (or (and (== (... fromcol 0) -10) (== (... tocol 0) MAXCOL)) (< vcol (... fromcol 0)) (< vcol_prev fromcol_prev) (<= (... tocol 0) vcol)))
                (do
                    ((ร char_attr =) line_attr)
                )
                :else
                (do
                    ((ร attr_pri =) false)
                    ((ร char_attr =) 0)
                ))
            )

            ;; Get the next character to put on the screen.

            ;; The "p_extra" points to the extra stuff that is inserted to represent
            ;; special characters (non-printable stuff) and other things.
            ;; When all characters are the same, c_extra is used.
            ;; "p_extra" must end in a NUL to avoid us-ptr2len-cc() reads past "p_extra[n_extra]".
            ;; For the '$' of the 'list' option, n_extra == 1, p_extra == "".

            (cond (< 0 n_extra)
            (do
                (cond (!= c_extra NUL)
                (do
                    ((ร c =) c_extra)
                    ((ร mb_c =) c)       ;; doesn't handle non-utf-8 multi-byte!
                    (cond (< 1 (utf-char2len c))
                    (do
                        ((ร mb_utf8 =) true)
                        ((ร u8cc[0] =) 0)
                        ((ร c =) 0xc0)
                    )
                    :else
                    (do
                        ((ร mb_utf8 =) false)
                    ))
                )
                :else
                (do
                    ((ร c =) (.at p_extra 0))

                    ((ร mb_c =) c)

                    ;; If the UTF-8 character is more than one byte, decode it into "mb_c".
                    ((ร mb_l =) (us-ptr2len-cc p_extra))
                    ((ร mb_utf8 =) false)
                    (cond (< n_extra mb_l)
                    (do
                        ((ร mb_l =) 1)
                    )
                    (< 1 mb_l)
                    (do
                        ((ร mb_c =) (us-ptr2char-cc p_extra, u8cc))
                        ((ร mb_utf8 =) true)
                        ((ร c =) 0xc0)
                    ))

                    (if (zero? mb_l)  ;; at the NUL at end-of-line
                        ((ร mb_l =) 1)
                    )

                    ;; If a double-width char doesn't fit display a '>' in the last column.
                    (cond (and (<= (- (:w_width wp) 1) col) (== (utf-char2cells mb_c) 2))
                    (do
                        ((ร c =) (byte \>))
                        ((ร mb_c =) c)
                        ((ร mb_l =) 1)
                        ((ร mb_utf8 =) false)
                        ((ร multi_attr =) (hl-attr HLF_AT))
                        ;; put the pointer back to output the double-width
                        ;; character at the start of the next line
                        (ร n_extra++)
                        ((ร p_extra =) (.minus p_extra 1))
                    )
                    :else
                    (do
                        ((ร n_extra =) (- n_extra (dec mb_l)))
                        ((ร p_extra =) (.plus p_extra (dec mb_l)))
                    ))

                    ((ร p_extra =) (.plus p_extra 1))
                ))
                (ร --n_extra)
            )
            :else
            (do
                (if (non-nil? p_extra_free)
                    ((ร p_extra_free =) nil)
                )

                ;; Get a character from the line itself.

                ((ร c =) (.at ptr 0))

                ((ร mb_c =) c)

                ;; If the UTF-8 character is more than one byte, decode it into "mb_c".
                ((ร mb_l =) (us-ptr2len-cc ptr))
                ((ร mb_utf8 =) false)
                (when (< 1 mb_l)
                    ((ร mb_c =) (us-ptr2char-cc ptr, u8cc))
                    ;; Overlong encoded ASCII or ASCII with composing char
                    ;; is displayed normally, except a NUL.
                    (if (< mb_c 0x80)
                        ((ร c =) mb_c)
                    )
                    ((ร mb_utf8 =) true)

                    ;; At start of the line we can have a composing char.
                    ;; Draw it as a space with a composing char.
                    (when (utf-iscomposing mb_c)
                        ((ร FOR) (ร ((ร int i =) (dec @screen_mco)) (< 0 i) (ร --i))
                            ((ร u8cc[i] =) (... u8cc (dec i)))
                        )
                        ((ร u8cc[0] =) mb_c)
                        ((ร mb_c =) (byte \space))
                    )
                )

                (cond (or (and (== mb_l 1) (<= 0x80 c)) (and (<= 1 mb_l) (zero? mb_c)) (and (< 1 mb_l) (not (vim-isprintc mb_c))))
                (do
                    ;; Illegal UTF-8 byte: display as <xx>.
                    ;; Non-BMP character : display as ? or fullwidth ?.

                    (transchar-hex extra, mb_c)

                    ((ร p_extra =) extra)
                    ((ร c =) (.at p_extra 0))
;                   { Bytes[] __ = { p_extra }; mb_c = us-ptr2char-adv(__, true); p_extra = __[0]; }
                    ((ร mb_utf8 =) (<= 0x80 c))
                    ((ร n_extra =) (STRLEN p_extra))
                    ((ร c_extra =) NUL)
                    (when (and (zero? area_attr) (zero? search_attr))
                        ((ร n_attr =) (inc n_extra))
                        ((ร extra_attr =) (hl-attr HLF_8))
                        ((ร saved_attr2 =) char_attr)    ;; save current attr
                    )
                )
                (zero? mb_l)                 ;; at the NUL at end-of-line
                (do
                    ((ร mb_l =) 1)
                ))

                ;; If a double-width char doesn't fit, display a '>' in the last column;
                ;; the character is displayed at the start of the next line.
                (cond (and (<= (- (:w_width wp) 1) col) (== (utf-char2cells mb_c) 2))
                (do
                    ((ร c =) (byte \>))
                    ((ร mb_c =) c)
                    ((ร mb_utf8 =) false)
                    ((ร mb_l =) 1)
                    ((ร multi_attr =) (hl-attr HLF_AT))
                    ;; Put pointer back so that the character will be
                    ;; displayed at the start of the next line.
                    ((ร ptr =) (.minus ptr 1))
                )
                (non-eos? ptr)
                (do
                    ((ร ptr =) (.plus ptr (dec mb_l)))
                ))

                ;; If a double-width char doesn't fit at the left side, display a '<'
                ;; in the first column.  Don't do this for unprintable characters.
                (when (and (< 0 n_skip) (< 1 mb_l) (zero? n_extra))
                    ((ร n_extra =) 1)
                    ((ร c_extra =) MB_FILLER_CHAR)
                    ((ร c =) (byte \space))
                    (when (and (zero? area_attr) (zero? search_attr))
                        ((ร n_attr =) (inc n_extra))
                        ((ร extra_attr =) (hl-attr HLF_AT))
                        ((ร saved_attr2 =) char_attr)    ;; save current attr
                    )
                    ((ร mb_c =) c)
                    ((ร mb_utf8 =) false)
                    ((ร mb_l =) 1)
                )

                ((ร ptr =) (.plus ptr 1))

                (when extra_check
                    ;; Get syntax attribute, unless still at the start of the line
                    ;; (double-wide char that doesn't fit).
                    ((ร v =) (BDIFF ptr, line))

                    ;; Found last space before word: check for line break.

                    (when (and @(:wo_lbr (:w_options wp)) (... @breakat_flags (char_u (byte c))) (not (... @breakat_flags (char_u (.at ptr 0)))))
                        ((ร int mb_off =) (us-head-off line, (.minus ptr 1)))
                        ((ร Bytes p =) (.minus ptr (inc mb_off)))

                        ;; TODO: is passing 'p' for start of the line OK?
                        ((ร n_extra =) (- (win-lbr-chartabsize wp, line, p, vcol, nil) 1))
                        (if (and (== c TAB) (< (:w_width wp) (+ n_extra col)))
                            ((ร n_extra =) (- (int @(:b_p_ts @curbuf)) (% vcol (int @(:b_p_ts @curbuf))) 1))
                        )

                        ((ร c_extra =) (if (< 0 mb_off) MB_FILLER_CHAR (byte \space)))
                        (when (vim-iswhite c)
                            (when (== c TAB)       ;; See "Tab alignment" below.
                                ((ร n_extra =) (+ n_extra vcol_off))
                                ((ร vcol =) (- vcol vcol_off))
                                ((ร vcol_off =) 0)
                                ((ร col =) (- col boguscols))
                                ((ร old_boguscols =) boguscols)
                                ((ร boguscols =) 0)
                            )
                            ((ร c =) (byte \space))
                        )
                    )

                    (when (and (!= trailcol MAXCOL) (BLT (.plus line trailcol), ptr) (== c (byte \space)))
                        ((ร c =) @lcs_trail)
                        (when (not attr_pri)
                            ((ร n_attr =) 1)
                            ((ร extra_attr =) (hl-attr HLF_8))
                            ((ร saved_attr2 =) char_attr)    ;; save current attr
                        )
                        ((ร mb_c =) c)
                        (cond (< 1 (utf-char2len c))
                        (do
                            ((ร mb_utf8 =) true)
                            ((ร u8cc[0] =) 0)
                            ((ร c =) 0xc0)
                        )
                        :else
                        (do
                            ((ร mb_utf8 =) false)
                        ))
                    )
                )

                ;; Handling of non-printable characters.

                (when (zero? (& (... chartab (& c 0xff)) CT_PRINT_CHAR))
                    ;; When getting a character from the file, we may have to turn it
                    ;; into something else on the way to putting it into "screenLines".

                    (cond (== c TAB)
                    (do
                        ((ร int tab_len =) 0)
                        ((ร int vcol_adjusted =) vcol) ;; removed showbreak length
                        ;; Only adjust the "tab_len" when at the first column
                        ;; after the showbreak value was drawn.
                        (if (and (non-eos? @p_sbr) (== vcol vcol_sbr) @(:wo_wrap (:w_options wp)))
                            ((ร vcol_adjusted =) (- vcol (us-charlen @p_sbr)))
                        )
                        ;; tab amount depends on current column
                        ((ร tab_len =) (- (int @(:b_p_ts @curbuf)) (% vcol_adjusted (int @(:b_p_ts @curbuf))) 1))

                        ;; tab amount depends on current column
                        ((ร n_extra =) tab_len)

                        ;; Tab alignment should be identical regardless of
                        ;; 'conceallevel' value.  So tab compensates of all
                        ;; previous concealed characters, and thus resets
                        ;; vcol_off and boguscols accumulated so far in the
                        ;; line.  Note that the tab can be longer than
                        ;; 'tabstop' when there are concealed characters.

                        ((ร n_extra =) (+ n_extra vcol_off))
                        ((ร vcol =) (- vcol vcol_off))
                        ((ร vcol_off =) 0)
                        ((ร col =) (- col boguscols))
                        ((ร old_boguscols =) boguscols)
                        ((ร boguscols =) 0)

                        ((ร mb_utf8 =) false)                    ;; don't draw as UTF-8

                        ((ร c_extra =) (byte \space))
                        ((ร c =) (byte \space))
                    )
                    (and (== c NUL) (and (or (<= 0 (... fromcol 0)) (<= 0 fromcol_prev)) (< vcol (... tocol 0)) (!= @VIsual_mode Ctrl_V) (< col (:w_width wp)) (not (and noinvcur (== lnum (:lnum (:w_cursor wp))) (== vcol (:w_virtcol wp))))) (<= 0 lcs_eol_one))
                    (do
                        ;; Display a '$' after the line or highlight an extra character if the line break is included.

                        ;; For a diff line the highlighting continues after the "$".
                        (when (zero? line_attr)
                            ;; In virtualedit, visual selections may extend beyond end of line.
                            (cond (and area_highlighting (virtual-active) (!= (... tocol 0) MAXCOL) (< vcol (... tocol 0)))
                            (do
                                ((ร n_extra =) 0)
                            )
                            :else
                            (do
                                ((ร p_extra =) at_end_str)
                                ((ร n_extra =) 1)
                                ((ร c_extra =) NUL)
                            ))
                        )
                        ((ร c =) (byte \space))
                        ((ร lcs_eol_one =) -1)
                        ((ร ptr =) (.minus ptr 1))                 ;; put it back at the NUL
                        (when (not attr_pri)
                            ((ร extra_attr =) (hl-attr HLF_AT))
                            ((ร n_attr =) 1)
                        )
                        ((ร mb_c =) c)
                        (cond (< 1 (utf-char2len c))
                        (do
                            ((ร mb_utf8 =) true)
                            ((ร u8cc[0] =) 0)
                            ((ร c =) 0xc0)
                        )
                        :else
                        (do
                            ((ร mb_utf8 =) false)                ;; don't draw as UTF-8
                        ))
                    )
                    (!= c NUL)
                    (do
                        ((ร p_extra =) (transchar c))
                        (if (zero? n_extra)
                            ((ร n_extra =) (- (mb-byte2cells (byte c)) 1))
                        )
                        ((ร c_extra =) NUL)
                        (cond @(:wo_lbr (:w_options wp))
                        (do
                            (ร Bytes p)

                            ((ร c =) (.at p_extra 0))
                            ((ร p =) (Bytes. (inc n_extra)))
                            (BFILL p, 0, (byte \space), n_extra)
                            (STRNCPY p, (.plus p_extra 1), (- (STRLEN p_extra) 1))
                            (eos! p n_extra)
                            ((ร p_extra_free =) ((ร p_extra =) p))
                        )
                        :else
                        (do
                            ((ร n_extra =) (- (mb-byte2cells (byte c)) 1))
                            ((ร c =) (.at ((ร p_extra =) (.plus p_extra 1)) -1))
                        ))
                        (when (not attr_pri)
                            ((ร n_attr =) (inc n_extra))
                            ((ร extra_attr =) (hl-attr HLF_8))
                            ((ร saved_attr2 =) char_attr)        ;; save current attr
                        )
                        ((ร mb_utf8 =) false)                    ;; don't draw as UTF-8
                    )
                    (and @VIsual_active (or (== @VIsual_mode Ctrl_V) (== @VIsual_mode (byte \v))) (virtual-active) (!= (... tocol 0) MAXCOL) (< vcol (... tocol 0)) (< col (:w_width wp)))
                    (do
                        ((ร c =) (byte \space))
                        ((ร ptr =) (.minus ptr 1))                             ;; put it back at the NUL
                    )
                    (and (!= line_attr 0) (< (- col boguscols) (:w_width wp)))
                    (do
                        ;; Highlight until the right side of the window.
                        ((ร c =) (byte \space))
                        ((ร ptr =) (.minus ptr 1))                             ;; put it back at the NUL

                        ;; Remember we do the char for line highlighting.
                        (ร did_line_attr++)

                        ;; don't do search HL for the rest of the line
                        (if (and (non-zero? line_attr) (== char_attr search_attr) (< 0 col))
                            ((ร char_attr =) line_attr)
                        )
                    ))
                )

                (cond (and (< 0 @(:wo_cole (:w_options wp))) (or (!= wp @curwin) (!= lnum (:lnum (:w_cursor wp))) (conceal-cursor-line wp)) (flag? syntax_flags HL_CONCEAL) (not (and lnum_in_visual_area (== (vim-strchr @(:wo_cocu (:w_options wp)), (byte \v)) nil))))
                (do
                    ((ร char_attr =) conceal_attr)
                    (cond (and (!= prev_syntax_id (... syntax_seqnr 0)) (or (!= (syn-get-sub-char) NUL) (== @(:wo_cole (:w_options wp)) 1)) (!= @(:wo_cole (:w_options wp)) 3))
                    (do
                        ;; First time at this concealed item: display one character.
                        (cond (!= (syn-get-sub-char) NUL)
                        (do
                            ((ร c =) (syn-get-sub-char))
                        )
                        (!= @lcs_conceal NUL)
                        (do
                            ((ร c =) @lcs_conceal)
                        )
                        :else
                        (do
                            ((ร c =) (byte \space))
                        ))

                        ((ร prev_syntax_id =) (... syntax_seqnr 0))

                        (if (< 0 n_extra)
                            ((ร vcol_off =) (+ vcol_off n_extra))
                        )
                        ((ร vcol =) (+ vcol n_extra))
                        (when (and @(:wo_wrap (:w_options wp)) (< 0 n_extra))
                            ((ร boguscols =) (+ boguscols n_extra))
                            ((ร col =) (+ col n_extra))
                        )
                        ((ร n_extra =) 0)
                        ((ร n_attr =) 0)
                    )
                    (zero? n_skip)
                    (do
                        ((ร is_concealing =) true)
                        ((ร n_skip =) 1)
                    ))
                    ((ร mb_c =) c)
                    (cond (< 1 (utf-char2len c))
                    (do
                        ((ร mb_utf8 =) true)
                        ((ร u8cc[0] =) 0)
                        ((ร c =) 0xc0)
                    )
                    :else
                    (do
                        ((ร mb_utf8 =) false)    ;; don't draw as UTF-8
                    ))
                )
                :else
                (do
                    ((ร prev_syntax_id =) 0)
                    ((ร is_concealing =) false)
                ))
            ))

            ;; In the cursor line and we may be concealing characters:
            ;; correct the cursor column when we reach its position.
            (when (and (not did_wcol) (== draw_state WL_LINE) (== wp @curwin) (== lnum (:lnum (:w_cursor wp))) (conceal-cursor-line wp) (<= (:w_virtcol wp) (+ vcol n_skip)))
                ((ร wp.w_wcol =) (- col boguscols))
                ((ร wp.w_wrow =) row)
                ((ร did_wcol =) true)
            )

            ;; Don't override visual selection highlighting.
            (when (and (< 0 n_attr) (== draw_state WL_LINE) (not attr_pri))
                ((ร char_attr =) extra_attr)
            )

            ;; At end of the text line or just after the last character.

            (when (or (== c NUL) (== did_line_attr 1))
                ((ร long prevcol =) (- (BDIFF ptr, line) (if (== c NUL) 1 0)))

                ;; we're not really at that column when skipping some text
                (if (< prevcol (long (if @(:wo_wrap (:w_options wp)) (:w_skipcol wp) (:w_leftcol wp))))
                    (ร prevcol++)
                )

                ;; Invert at least one char, used for Visual and empty line or highlight
                ;; match at end of line.  If it's beyond the last char on the screen,
                ;; just overwrite that one (tricky!)
                ;; Not needed when a '$' was displayed for 'list'.

                ((ร boolean prevcol_hl_flag =) false)                ;; whether prevcol equals startcol of
                                                                ;; search_hl or one of the matches
                (cond (== prevcol (long (:startcol @search_hl)))
                (do
                    ((ร prevcol_hl_flag =) true)
                )
                :else
                (do
                    ((ร FOR) (ร ((ร mi =) (:w_match_head wp)) (non-nil? mi) ((ร mi =) (:next mi)))
                        (when (== prevcol (long (:startcol (:mi_hl mi))))
                            ((ร prevcol_hl_flag =) true)
                            (ร BREAK)
                        )
                    )
                ))
                                ;; highlight 'hlsearch' match at end of line
                (when (and (== @lcs_eol lcs_eol_one) (or (and (!= area_attr 0) (== vcol (... fromcol 0)) (or (!= @VIsual_mode Ctrl_V) (== lnum (:lnum @VIsual)) (== lnum (:lnum (:w_cursor @curwin)))) (== c NUL)) (and prevcol_hl_flag (<= did_line_attr 1))))
                    ((ร int n =) 0)

                    (if (<= (:w_width wp) col)
                        ((ร n =) -1)
                    )

                    (cond (non-zero? n)
                    (do
                        ;; At the window boundary, highlight the last character
                        ;; instead (better than nothing).
                        ((ร off =) (+ off n))
                        ((ร col =) (+ col n))
                    )
                    :else
                    (do
                        ;; Add a blank character to highlight.
                        (.be @screenLines off, (byte \space))
                        ((ร @screenLinesUC[off] =) 0)
                    ))
                    (when (zero? area_attr)
                        ;; Use attributes from match with highest priority
                        ;; among 'search_hl' and the match list.
                        ((ร char_attr =) (:attr @search_hl))
                        ((ร mi =) (:w_match_head wp))
                        ((ร shl_flag =) false)
                        (while (or (non-nil? mi) (not shl_flag))
                            (ร match_C shl)        ;; points to search_hl or a match
                            (cond (and (not shl_flag) (or (and (non-nil? mi) (< SEARCH_HL_PRIORITY (:priority mi))) (nil? mi)))
                            (do
                                ((ร shl =) @search_hl)
                                ((ร shl_flag =) true)
                            )
                            :else
                            (do
                                ((ร shl =) (:mi_hl mi))
                            ))
                            (if (== (- (BDIFF ptr, line) 1) (:startcol shl))
                                ((ร char_attr =) (:attr shl))
                            )
                            (if (and (!= shl @search_hl) (non-nil? mi))
                                ((ร mi =) (:next mi))
                            )
                        )
                    )
                    ((ร @screenAttrs[off] =) char_attr)
                    (ร col++)
                    (ร off++)
                    (ร vcol++)
                    ((ร eol_hl_off =) 1)
                )
            )

            ;; At end of the text line.

            (when (== c NUL)
                (when (and (< 0 eol_hl_off) (== (- vcol eol_hl_off) (:w_virtcol wp)) (== lnum (:lnum (:w_cursor wp))))
                    ;; highlight last char after line
                    (ร --col)
                    (ร --off)
                    (ร --vcol)
                )

                ;; Highlight 'cursorcolumn' & 'colorcolumn' past end of the line.
                ((ร v =) (if @(:wo_wrap (:w_options wp)) (:w_skipcol wp) (:w_leftcol wp)))

                ;; check if line ends before left margin
                (if (< vcol (- (+ v col) (win-col-off wp)))
                    ((ร vcol =) (- (+ v col) (win-col-off wp)))
                )
                ;; Get rid of the boguscols now,
                ;; we want to draw until the right edge for 'cursorcolumn'.
                ((ร col =) (- col boguscols))
                ((ร boguscols =) 0)

                (if draw_color_col
                    ((ร draw_color_col =) (advance-color-col (- vcol vcol_off), color_cols, cci))
                )

                (when (or (and @(:wo_cuc (:w_options wp)) (<= (- vcol vcol_off eol_hl_off) (:w_virtcol wp)) (< (:w_virtcol wp) (+ (* (:w_width wp) (+ (- row startrow) 1)) v)) (!= lnum (:lnum (:w_cursor wp)))) draw_color_col)
                    ((ร int rightmost_vcol =) 0)

                    (if @(:wo_cuc (:w_options wp))
                        ((ร rightmost_vcol =) (:w_virtcol wp))
                    )
                    (when draw_color_col
                        ;; determine rightmost colorcolumn to possibly draw
                        ((ร FOR) (ร ((ร int i =) 0) (<= 0 (... color_cols (+ (... cci 0) i))) (ร i++))
                            (if (< rightmost_vcol (... color_cols (+ (... cci 0) i)))
                                ((ร rightmost_vcol =) (... color_cols (+ (... cci 0) i)))
                            )
                        )
                    )

                    (while (< col (:w_width wp))
                        (.be @screenLines off, (byte \space))
                        ((ร @screenLinesUC[off] =) 0)
                        (ร col++)
                        (if draw_color_col
                            ((ร draw_color_col =) (advance-color-col (- vcol vcol_off), color_cols, cci))
                        )

                        (cond (and @(:wo_cuc (:w_options wp)) (== (- vcol vcol_off) (:w_virtcol wp)))
                        (do
                            ((ร @screenAttrs[off++] =) (hl-attr HLF_CUC))
                        )
                        (and draw_color_col (== (- vcol vcol_off) (... color_cols (... cci 0))))
                        (do
                            ((ร @screenAttrs[off++] =) (hl-attr HLF_MC))
                        )
                        :else
                        (do
                            ((ร @screenAttrs[off++] =) 0)
                        ))

                        (if (<= rightmost_vcol (- vcol vcol_off))
                            (ร BREAK)
                        )

                        (ร vcol++)
                    )
                )

                (screen-line screen_row, (:w_wincol wp), col, (:w_width wp), false)
                (ร row++)

                ;; Update w_cline_height and w_cline_folded if the cursor line was
                ;; updated (saves a call to plines() later).

                (when (and (== wp @curwin) (== lnum (:lnum (:w_cursor @curwin))))
                    ((ร @curwin.w_cline_row =) startrow)
                    ((ร @curwin.w_cline_height =) (- row startrow))
                    ((ร @curwin.w_valid =) (| (:w_valid @curwin) (| VALID_CHEIGHT VALID_CROW)))
                )

                (ร BREAK)
            )

            ;; line continues beyond line end
            (when (and (!= @lcs_ext NUL) (not @(:wo_wrap (:w_options wp))) (== col (- (:w_width wp) 1)) (or (non-eos? ptr) (and (non-zero? n_extra) (or (!= c_extra NUL) (non-eos? p_extra)))))
                ((ร c =) @lcs_ext)
                ((ร char_attr =) (hl-attr HLF_AT))
                ((ร mb_c =) c)
                (cond (< 1 (utf-char2len c))
                (do
                    ((ร mb_utf8 =) true)
                    ((ร u8cc[0] =) 0)
                    ((ร c =) 0xc0)
                )
                :else
                (do
                    ((ร mb_utf8 =) false)
                ))
            )

            ;; advance to the next 'colorcolumn'
            (if draw_color_col
                ((ร draw_color_col =) (advance-color-col (- vcol vcol_off), color_cols, cci))
            )

            ;; Highlight the cursor column if 'cursorcolumn' is set.
            ;; But don't highlight the cursor position itself.
            ;; Also highlight the 'colorcolumn' if it is different than 'cursorcolumn'.
            ((ร vcol_save_attr =) -1)
            (when (and (== draw_state WL_LINE) (not lnum_in_visual_area))
                (cond (and @(:wo_cuc (:w_options wp)) (== (- vcol vcol_off) (:w_virtcol wp)) (!= lnum (:lnum (:w_cursor wp))))
                (do
                    ((ร vcol_save_attr =) char_attr)
                    ((ร char_attr =) (hl-combine-attr char_attr, (hl-attr HLF_CUC)))
                )
                (and draw_color_col (== (- vcol vcol_off) (... color_cols (... cci 0))))
                (do
                    ((ร vcol_save_attr =) char_attr)
                    ((ร char_attr =) (hl-combine-attr char_attr, (hl-attr HLF_MC)))
                ))
            )

            ;; Store character to be displayed.
            ;; Skip characters that are left of the screen for 'nowrap'.

            ((ร vcol_prev =) vcol)
            (cond (or (< draw_state WL_LINE) (<= n_skip 0))
            (do
                ;; Store the character.

                (.be @screenLines off, c)
                (cond mb_utf8
                (do
                    ((ร @screenLinesUC[off] =) mb_c)
                    (if (zero? (& c 0xff))
                        (.be @screenLines off, 0x80)    ;; avoid storing zero
                    )
                    (dotimes [#_int i @screen_mco]
                        ((ร @screenLinesC[i][off] =) (... u8cc i))
                        (if (zero? (... u8cc i))
                            (ร BREAK)
                        )
                    )
                )
                :else
                (do
                    ((ร @screenLinesUC[off] =) 0)
                ))
                (cond (non-zero? multi_attr)
                (do
                    ((ร @screenAttrs[off] =) multi_attr)
                    ((ร multi_attr =) 0)
                )
                :else
                (do
                    ((ร @screenAttrs[off] =) char_attr)
                ))

                (when (< 1 (utf-char2cells mb_c))
                    ;; Need to fill two screen columns.
                    (ร off++)
                    (ร col++)
                    ;; UTF-8: Put a 0 in the second screen char.
                    (eos! @screenLines off)
                    (ร vcol++)
                    ;; When "tocol" is halfway a character, set it to the end
                    ;; of the character, otherwise highlighting won't stop.
                    (if (== (... tocol 0) vcol)
                        (ร tocol[0]++)
                    )
                )
                (ร off++)
                (ร col++)
            )
            (and (< 0 @(:wo_cole (:w_options wp))) is_concealing)
            (do
                (ร --n_skip)
                (ร vcol_off++)
                (if (< 0 n_extra)
                    ((ร vcol_off =) (+ vcol_off n_extra))
                )
                (cond @(:wo_wrap (:w_options wp))
                (do
                    ;; Special voodoo required if 'wrap' is on.
                    ;;
                    ;; Advance the column indicator to force the line drawing to wrap early.
                    ;; This will make the line take up the same screen space when parts are concealed,
                    ;; so that cursor line computations aren't messed up.
                    ;;
                    ;; To avoid the fictitious advance of 'col' causing trailing junk to be written
                    ;; out of the screen line we are building, 'boguscols' keeps track of the number
                    ;; of bad columns we have advanced.

                    (when (< 0 n_extra)
                        ((ร vcol =) (+ vcol n_extra))
                        ((ร col =) (+ col n_extra))
                        ((ร boguscols =) (+ boguscols n_extra))
                        ((ร n_extra =) 0)
                        ((ร n_attr =) 0)
                    )

                    (when (< 1 (utf-char2cells mb_c))
                        ;; Need to fill two screen columns.
                        (ร boguscols++)
                        (ร col++)
                    )

                    (ร boguscols++)
                    (ร col++)
                )
                :else
                (do
                    (when (< 0 n_extra)
                        ((ร vcol =) (+ vcol n_extra))
                        ((ร n_extra =) 0)
                        ((ร n_attr =) 0)
                    )
                ))
            )
            :else
            (do
                (ร --n_skip)
            ))

            ;; Only advance the "vcol" when after the 'number' or 'relativenumber' column.
            (if (< WL_NR draw_state)
                (ร vcol++)
            )

            (if (<= 0 vcol_save_attr)
                ((ร char_attr =) vcol_save_attr)
            )

            ;; restore attributes after "predeces" in 'listchars'
            (if (and (< WL_NR draw_state) (< 0 n_attr3) (zero? (ร --n_attr3)))
                ((ร char_attr =) saved_attr3)
            )

            ;; restore attributes after last 'listchars' or 'number' char
            (if (and (< 0 n_attr) (== draw_state WL_LINE) (zero? (ร --n_attr)))
                ((ร char_attr =) saved_attr2)
            )

            ;; At end of screen line and there is more to come:
            ;; display the line so far.
            ;; If there is no more to display it is caught above.

            (when (and (<= (:w_width wp) col) (or (non-eos? ptr) (and (non-zero? n_extra) (or (!= c_extra NUL) (non-eos? p_extra)))))
                (screen-line screen_row, (:w_wincol wp), (- col boguscols), (:w_width wp), false)
                ((ร boguscols =) 0)
                (ร row++)
                (ร screen_row++)

                ;; When not wrapping and finished diff lines, or when displayed
                ;; '$' and highlighting until last column, break here.
                (if (or (not @(:wo_wrap (:w_options wp))) (== lcs_eol_one -1))
                    (ร BREAK)
                )

                ;; When the window is too narrow draw all "@" lines.
                (when (!= draw_state WL_LINE)
                    (win-draw-end wp, (byte \@), (byte \space), row, (:w_height wp), HLF_AT)
                    (draw-vsep-win wp, row)
                    ((ร row =) endrow)
                )

                ;; When line got too long for screen break here.
                (when (== row endrow)
                    (ร row++)
                    (ร BREAK)
                )

                (when (and (== @screen_cur_row (dec screen_row)) (== (:w_width wp) (int @Cols)))
                    ;; Remember that the line wraps, used for modeless copy.
                    ((ร @lineWraps[screen_row - 1] =) true)

                    ;; Special trick to make copy/paste of wrapped lines work with xterm/screen:
                    ;; write an extra character beyond the end of the line.
                    ;; This will work with all terminal types (regardless of the xn,am settings).
                    ;; Only do this if the cursor is on the current line (something has been written in it).
                    ;; Don't do this for the GUI.
                    ;; Don't do this for double-width characters.
                    ;; Don't do this for a window not at the right screen border.

                    (when (not (or (== (utf-off2cells (... @lineOffset screen_row), (+ (... @lineOffset screen_row) @screenCols)) 2) (== (utf-off2cells (+ (... @lineOffset (dec screen_row)) (- (int @Cols) 2)), (+ (... @lineOffset screen_row) @screenCols)) 2)))
                        ((ร int eoff =) (+ (... @lineOffset (dec screen_row)) (dec (int @Cols))))

                        ;; First make sure we are at the end of the screen line,
                        ;; then output the same character again to let the terminal know about the wrap.
                        ;; If the terminal doesn't auto-wrap, we overwrite the character.
                        (if (!= @screen_cur_col (:w_width wp))
                            (screen-char eoff, (dec screen_row), (dec (int @Cols))))

                        ;; When there is a multi-byte character,
                        ;; just output a space to keep it simple.
                        (if (< 1 (us-byte2len (.at @screenLines eoff), false))
                            (out-char (byte \space))
                            (out-char (.at @screenLines eoff)))
                        ;; force a redraw of the first char on the next line
                        ((ร @screenAttrs[@lineOffset[screen_row]] =) -1)
                        (screen-start)     ;; don't know where cursor is now
                    )
                )

                ((ร col =) 0)
                ((ร off =) (BDIFF @current_ScreenLine, @screenLines))

                ;; reset the drawing state for the start of a wrapped line
                ((ร draw_state =) WL_START)
                ((ร saved_n_extra =) n_extra)
                ((ร saved_p_extra =) p_extra)
                ((ร saved_c_extra =) c_extra)
                ((ร saved_char_attr =) char_attr)
                ((ร n_extra =) 0)
                ((ร need_showbreak =) true)
            )
        )

        row
    ))

;; Return if the composing characters at "off_from" and "off_to" differ.
;; Only to be used when screenLinesUC[off_from] != 0.

(defn- #_boolean comp-char-differs [#_int off_from, #_int off_to]
    (ยง
        (dotimes [#_int i @screen_mco]
            (if (!= (... (... @screenLinesC i) off_from) (... (... @screenLinesC i) off_to))
                ((ร RETURN) true)
            )
            (if (zero? (... (... @screenLinesC i) off_from))
                (ร BREAK)
            )
        )
        false
    ))

;; Check whether the given character needs redrawing:
;; - the (first byte of the) character is different
;; - the attributes are different
;; - the character is multi-byte and the next byte is different
;; - the character is two cells wide and the second cell differs.

(defn- #_boolean char-needs-redraw [#_int from, #_int to, #_int cols]
    (and (< 0 cols)
         (or (!= (.at @screenLines from) (.at @screenLines to))
             (!= (... @screenAttrs from) (... @screenAttrs to))
             (!= (... @screenLinesUC from) (... @screenLinesUC to))
             (and (!= (... @screenLinesUC from) 0)
                  (comp-char-differs from, to))
             (and (< 1 (utf-off2cells from, (+ from cols)))
                  (!= (.at @screenLines (inc from)) (.at @screenLines (inc to)))))))

;; Move one "cooked" screen line to the screen, but only the characters that
;; have actually changed.  Handle insert/delete character.
;; "coloff" gives the first column on the screen for this line.
;; "endcol" gives the columns where valid characters are.
;; "clear_width" is the width of the window.  It's > 0 if the rest of the line
;; needs to be cleared, negative otherwise.
;; "rlflag" is true in a rightleft window:
;;    When true and "clear_width" > 0, clear columns 0 to "endcol"
;;    When false and "clear_width" > 0, clear columns "endcol" to "clear_width"

(defn- #_void screen-line [#_int row, #_int coloff, #_int endcol, #_int clear_width, #_boolean rlflag]
    (ยง
        ((ร int col =) 0)
        ((ร boolean force =) false)              ;; force update rest of the line
        ((ร boolean clear_next =) false)

        ;; Check for illegal row and col, just in case.
        (if (<= @Rows row)
            ((ร row =) (dec (int @Rows)))
        )
        (if (< @Cols endcol)
            ((ร endcol =) (int @Cols))
        )

        ((ร int off_from =) (BDIFF @current_ScreenLine, @screenLines))
        ((ร int off_to =) (+ (... @lineOffset row) coloff))
        ((ร int max_off_from =) (+ off_from @screenCols))
        ((ร int max_off_to =) (+ (... @lineOffset row) @screenCols))

        (when rlflag
            ;; Clear rest first, because it's left of the text.
            (when (< 0 clear_width)
                (while (and (<= col endcol) (== (.at @screenLines off_to) (byte \space)) (== (... @screenAttrs off_to) 0) (== (... @screenLinesUC off_to) 0))
                    (ร off_to++)
                    (ร col++)
                )
                (if (<= col endcol)
                    (screen-fill row, (inc row), (+ col coloff), (+ endcol coloff 1), (byte \space), (byte \space), 0))
            )
            ((ร col =) (inc endcol))
            ((ร off_to =) (+ (... @lineOffset row) col coloff))
            ((ร off_from =) (+ off_from col))
            ((ร endcol =) (if (< 0 clear_width) clear_width (- clear_width)))
        )

        ((ร boolean redraw_next =) (char-needs-redraw off_from, off_to, (- endcol col)))

        (while (< col endcol)
            ((ร int char_cells =) (if (< (inc col) endcol) (utf-off2cells off_from, max_off_from) 1))             ;; 1: normal char; 2: occupies two display cells

            ;; bool: does character need redraw?
            ((ร boolean redraw_this =) redraw_next)
            ;; redraw_this for next character
            ((ร redraw_next =) (or force (char-needs-redraw (+ off_from char_cells), (+ off_to char_cells), (- endcol col char_cells))))

            (when redraw_this
                ;; When writing a single-width character over a double-width
                ;; character and at the end of the redrawn text, need to clear out
                ;; the right halve of the old character.
                ;; Also required when writing the right halve of a double-width
                ;; char over the left halve of an existing one.
                (if (and (== (+ col char_cells) endcol) (or (and (== char_cells 1) (< 1 (utf-off2cells off_to, max_off_to))) (and (== char_cells 2) (== (utf-off2cells off_to, max_off_to) 1) (< 1 (utf-off2cells (inc off_to), max_off_to)))))
                    ((ร clear_next =) true)
                )

                (.be @screenLines off_to, (.at @screenLines off_from))
                ((ร @screenLinesUC[off_to] =) (... @screenLinesUC off_from))
                (when (non-zero? (... @screenLinesUC off_from))
                    (dotimes [#_int i @screen_mco]
                        ((ร @screenLinesC[i][off_to] =) (... (... @screenLinesC i) off_from))
                    )
                )
                (if (== char_cells 2)
                    (.be @screenLines (inc off_to), (.at @screenLines (inc off_from)))
                )

                ;; The bold trick makes a single column of pixels appear in the
                ;; next character.  When a bold character is removed, the next
                ;; character should be redrawn too.  This happens for our own GUI
                ;; and for some xterms.
                (when @term_is_xterm
                    ((ร int hl =) (... @screenAttrs off_to))
                    (if (< HL_ALL hl)
                        ((ร hl =) (syn-attr2attr hl))
                    )
                    (if (flag? hl HL_BOLD)
                        ((ร redraw_next =) true)
                    )
                )
                ((ร @screenAttrs[off_to] =) (... @screenAttrs off_from))
                ;; For simplicity, set the attributes of second half
                ;; of a double-wide character equal to the first half.
                (if (== char_cells 2)
                    ((ร @screenAttrs[off_to + 1] =) (... @screenAttrs off_from))
                )

                (screen-char off_to, row, (+ col coloff))
            )

            ((ร off_to =) (+ off_to char_cells))
            ((ร off_from =) (+ off_from char_cells))
            ((ร col =) (+ col char_cells))
        )

        (when clear_next
            ;; Clear the second half of a double-wide character of which
            ;; the left half was overwritten with a single-wide character.
            (.be @screenLines off_to, (byte \space))
            ((ร @screenLinesUC[off_to] =) 0)
            (screen-char off_to, row, (+ col coloff))
        )

        (when (and (< 0 clear_width) (not rlflag))
            ;; blank out the rest of the line
            (while (and (< col clear_width) (== (.at @screenLines off_to) (byte \space)) (== (... @screenAttrs off_to) 0) (== (... @screenLinesUC off_to) 0))
                (ร off_to++)
                (ร col++)
            )
            (when (< col clear_width)
                (screen-fill row, (inc row), (+ col coloff), (+ clear_width coloff), (byte \space), (byte \space), 0)
                ((ร off_to =) (+ off_to (- clear_width col)))
                ((ร col =) clear_width)
            )
        )

        (when (< 0 clear_width)
            ;; For a window that's left of another, draw the separator char.
            (cond (< (+ col coloff) (int @Cols))
            (do
                ((ร int[] hl =) (ร new int[1]))
                ((ร int c =) (fillchar-vsep hl))
                (when (or (!= (.at @screenLines off_to) c) (!= (... @screenLinesUC off_to) (if (<= 0x80 c) c 0)) (!= (... @screenAttrs off_to) (... hl 0)))
                    (.be @screenLines off_to, c)
                    ((ร @screenAttrs[off_to] =) (... hl 0))
                    (cond (<= 0x80 c)
                    (do
                        ((ร @screenLinesUC[off_to] =) c)
                        ((ร @screenLinesC[0][off_to] =) 0)
                    )
                    :else
                    (do
                        ((ร @screenLinesUC[off_to] =) 0)
                    ))
                    (screen-char off_to, row, (+ col coloff))
                )
            )
            :else
            (do
                ((ร @lineWraps[row] =) false)
            ))
        )
        nil
    ))

;; mark all status lines for redraw

(defn- #_void status-redraw-all []
    (ยง
        ((ร FOR) (ร ((ร window_C wp =) @firstwin) (non-nil? wp) ((ร wp =) (:w_next wp)))
            (when (non-zero? (:w_status_height wp))
                ((ร wp.w_redr_status =) true)
                (redraw-later VALID)
            )
        )
        nil
    ))

;; Redraw all status lines that need to be redrawn.

(defn- #_void redraw-statuslines []
    (ยง
        ((ร FOR) (ร ((ร window_C wp =) @firstwin) (non-nil? wp) ((ร wp =) (:w_next wp)))
            (when (:w_redr_status wp)
                (win-redr-status wp)
            )
        )
        nil
    ))

;; Draw the verticap separator right of window "wp" starting with line "row".

(defn- #_void draw-vsep-win [#_window_C wp, #_int row]
    (ยง
        (when (non-zero? (:w_vsep_width wp))
            ;; draw the vertical separator right of this window
            ((ร int[] hl =) (ร new int[1]))
            ((ร int c =) (fillchar-vsep hl))
            (screen-fill (+ (:w_winrow wp) row), (+ (:w_winrow wp) (:w_height wp)), (+ (:w_wincol wp) (:w_width wp)), (+ (:w_wincol wp) (:w_width wp) 1), c, (byte \space), (... hl 0))
        )
        nil
    ))

(atom! boolean _3_busy)

;; Redraw the status line of window wp.
;;
;; If inversion is possible we use it.  Else '=' characters are used.

(defn- #_void win-redr-status [#_window_C wp]
    (ยง
        ;; It's possible to get here recursively when 'statusline' (indirectly)
        ;; invokes ":redrawstatus".  Simply ignore the call then.
        (if @_3_busy
            ((ร RETURN) nil)
        )
        (reset! _3_busy true)

        ((ร wp.w_redr_status =) false)
        (cond (zero? (:w_status_height wp))
        (do
            ;; no status line, can only be last window
            (reset! redraw_cmdline true)
        )
        (not (redrawing))
        (do
            ;; Don't redraw right now, do it later.
            ((ร wp.w_redr_status =) true)
        )
        :else
        (do
            ((ร int[] attr =) (ร new int[1]))
            ((ร int fillchar =) (fillchar-status attr, (== wp @curwin)))

            (get-trans-bufname @curbuf)
            ((ร Bytes p =) @nameBuff)
            ((ร int len =) (STRLEN p))

            (when @(:b_changed @curbuf)
                (.be p (ร len++), (byte \space))
                (STRCPY (.plus p len), (u8 "[+]"))
                ((ร len =) (+ len 3))
            )

            ((ร int this_ru_col =) (- @ru_col (- (int @Cols) (:w_width wp))))
            (if (< this_ru_col (/ (+ (:w_width wp) 1) 2))
                ((ร this_ru_col =) (/ (+ (:w_width wp) 1) 2))
            )
            (cond (<= this_ru_col 1)
            (do
                ((ร p =) (u8 "<"))                    ;; No room for file name!
                ((ร len =) 1)
            )
            :else
            (do
                ;; Count total number of display cells.
                ((ร len =) (us-string2cells p, -1))

                ;; Find first character that will fit.
                ;; Going from start to end is much faster for DBCS.
                (ร int i)
                ((ร FOR) (ร ((ร i =) 0) (and (non-eos? p i) (<= (dec this_ru_col) len)) ((ร i =) (+ i (us-ptr2len-cc (.plus p i)))))
                    ((ร len =) (- len (us-ptr2cells (.plus p i))))
                )
                (when (< 0 i)
                    ((ร p =) (.plus p (dec i)))
                    (.be p 0, (byte \<))
                    (ร len++)
                )
            ))

            ((ร int row =) (+ (:w_winrow wp) (:w_height wp)))
            (screen-puts p, row, (:w_wincol wp), (... attr 0))
            (screen-fill row, (inc row), (+ len (:w_wincol wp)), (+ this_ru_col (:w_wincol wp)), fillchar, fillchar, (... attr 0))

            (win-redr-ruler wp, true)
        ))

        ;; May need to draw the character below the vertical separator.

        (when (and (non-zero? (:w_vsep_width wp)) (non-zero? (:w_status_height wp)) (redrawing))
            ((ร int[] attr =) (ร new int[1]))
            ((ร int fillchar =) (if (stl-connected wp) (fillchar-status attr, (== wp @curwin)) (fillchar-vsep attr)))
            (screen-putchar fillchar, (+ (:w_winrow wp) (:w_height wp)), (+ (:w_wincol wp) (:w_width wp)), (... attr 0))
        )
        (reset! _3_busy false)
        nil
    ))

;; Return true if the status line of window "wp" is connected to the status
;; line of the window right of it.  If not, then it's a vertical separator.
;; Only call if (wp.w_vsep_width != 0).

(defn- #_boolean stl-connected [#_window_C wp]
    (ยง
        ((ร FOR) (ร ((ร frame_C fr =) (:w_frame wp)) (non-nil? (:fr_parent fr)) ((ร fr =) (:fr_parent fr)))
            (cond (== (:fr_layout (:fr_parent fr)) FR_COL)
            (do
                (if (non-nil? (:fr_next fr))
                    (ร BREAK)
                )
            )
            :else
            (do
                (if (non-nil? (:fr_next fr))
                    ((ร RETURN) true)
                )
            ))
        )
        false
    ))

;; Output a single character directly to the screen and update "screenLines".

(defn- #_void screen-putchar [#_int c, #_int row, #_int col, #_int attr]
    (ยง
        ((ร Bytes buf =) (Bytes. (inc MB_MAXBYTES)))

        (.be buf (utf-char2bytes c, buf), NUL)
        (screen-puts buf, row, col, attr)
        nil
    ))

;; Get a single character directly from "screenLines" into "bytes[]".
;; Also return its attribute in "*attrp".

(defn- #_void screen-getbytes [#_int row, #_int col, #_Bytes bytes, #_int* attrp]
    (ยง
        ;; safety check
        (when (and (non-nil? @screenLines) (< row @screenRows) (< col @screenCols))
            ((ร int off =) (+ (... @lineOffset row) col))

            ((ร attrp[0] =) (... @screenAttrs off))
            (.be bytes 0, (.at @screenLines off))
            (eos! bytes 1)

            (if (non-zero? (... @screenLinesUC off))
                (.be bytes (utfc-char2bytes off, bytes), NUL)
            )
        )
        nil
    ))

;; Return true if composing characters for screen posn "off"
;; differs from composing characters in "u8cc".
;; Only to be used when screenLinesUC[off] != 0.

(defn- #_boolean screen-comp-differs [#_int off, #_int* u8cc]
    (ยง
        (dotimes [#_int i @screen_mco]
            (if (!= (... (... @screenLinesC i) off) (... u8cc i))
                ((ร RETURN) true)
            )
            (if (zero? (... u8cc i))
                (ร BREAK)
            )
        )
        false
    ))

;; Put string '*text' on the screen at position 'row' and 'col', with
;; attributes 'attr', and update screenLines[] and screenAttrs[].
;; Note: only outputs within one row, message is truncated at screen boundary!
;; Note: if screenLines[], row and/or col is invalid, nothing is done.

(defn- #_void screen-puts [#_Bytes text, #_int row, #_int col, #_int attr]
    (screen-puts-len text, -1, row, col, attr)
    nil)

;; Like screen-puts(), but output "text[len]".  When "len" is -1 output up to a NUL.

(defn- #_void screen-puts-len [#_Bytes text, #_int textlen, #_int row, #_int col, #_int attr]
    (ยง
        ((ร boolean clear_next_cell =) false)
        ((ร boolean force_redraw_next =) false)

        (if (or (nil? @screenLines) (<= @screenRows row))       ;; safety check
            ((ร RETURN) nil)
        )

        ((ร int off =) (+ (... @lineOffset row) col))

        ;; When drawing over the right halve of a double-wide char clear out the left halve.
        ;; Only needed in a terminal.
        (when (and (< 0 col) (< col @screenCols) (!= (mb-fix-col col, row) col))
            (.be @screenLines (dec off), (byte \space))
            ((ร @screenAttrs[off - 1] =) 0)
            ((ร @screenLinesUC[off - 1] =) 0)
            ((ร @screenLinesC[0][off - 1] =) 0)
            ;; redraw the previous cell, make it empty
            (screen-char (dec off), row, (dec col))
            ;; force the cell at "col" to be redrawn
            ((ร force_redraw_next =) true)
        )

        ((ร Bytes ptr =) text)
        ((ร int len =) textlen)
        ((ร int[] u8cc =) (ร new int[MAX_MCO]))

        ((ร int max_off =) (+ (... @lineOffset row) @screenCols))
        (while (and (< col @screenCols) (or (< len 0) (< (BDIFF ptr, text) len)) (non-eos? ptr))
            ((ร byte c =) (.at ptr 0))

            ;; check if this is the first byte of a multibyte
            ((ร int mbyte_blen =) (if (< 0 len) (us-ptr2len-cc-len ptr, (BDIFF (.plus text len), ptr)) (us-ptr2len-cc ptr)))

            ((ร int u8c =) (if (<= 0 len) (us-ptr2char-cc-len ptr, u8cc, (BDIFF (.plus text len), ptr)) (us-ptr2char-cc ptr, u8cc)))

            ((ร int mbyte_cells =) (utf-char2cells u8c))

            (when (< @screenCols (+ col mbyte_cells))
                ;; Only 1 cell left, but character requires 2 cells:
                ;; display a '>' in the last column to avoid wrapping.
                ((ร c =) (byte \>))
                ((ร mbyte_cells =) 1)
            )

            ((ร boolean force_redraw_this =) force_redraw_next)
            ((ร force_redraw_next =) false)

            ((ร boolean need_redraw =) (or (!= (.at @screenLines off) c) (and (== mbyte_cells 2) (!= (.at @screenLines (inc off)) 0)) (or (!= (... @screenLinesUC off) (if (and (< (char_u c) 0x80) (zero? (... u8cc 0))) 0 u8c)) (and (non-zero? (... @screenLinesUC off)) (screen-comp-differs off, u8cc))) (!= (... @screenAttrs off) attr)))

            (when (or need_redraw force_redraw_this)
                ;; The bold trick makes a single row of pixels appear in the next character.
                ;; When a bold character is removed, the next character should be redrawn too.
                ;; This happens for our own GUI and for some xterms.
                (when (and need_redraw (!= (.at @screenLines off) (byte \space)) @term_is_xterm)
                    ((ร int n =) (... @screenAttrs off))

                    (if (< HL_ALL n)
                        ((ร n =) (syn-attr2attr n))
                    )
                    (if (flag? n HL_BOLD)
                        ((ร force_redraw_next =) true)
                    )
                )
                ;; When at the end of the text and overwriting a two-cell character with
                ;; a one-cell character, need to clear the next cell.  Also when overwriting
                ;; the left halve of a two-cell char with the right halve of a two-cell char.
                ;; Do this only once (utf-off2cells() may return 2 on the right halve).
                (cond clear_next_cell
                (do
                    ((ร clear_next_cell =) false)
                )
                (and (if (< len 0) (eos? ptr mbyte_blen) (BLE (.plus text len), (.plus ptr mbyte_blen))) (or (and (== mbyte_cells 1) (< 1 (utf-off2cells off, max_off))) (and (== mbyte_cells 2) (== (utf-off2cells off, max_off) 1) (< 1 (utf-off2cells (inc off), max_off)))))
                (do
                    ((ร clear_next_cell =) true)
                ))

                (.be @screenLines off, c)
                ((ร @screenAttrs[off] =) attr)

                (cond (and (< (char_u c) 0x80) (zero? (... u8cc 0)))
                (do
                    ((ร @screenLinesUC[off] =) 0)
                )
                :else
                (do
                    ((ร @screenLinesUC[off] =) u8c)
                    (dotimes [#_int i @screen_mco]
                        ((ร @screenLinesC[i][off] =) (... u8cc i))
                        (if (zero? (... u8cc i))
                            (ร BREAK)
                        )
                    )
                ))
                (when (== mbyte_cells 2)
                    (.be @screenLines (inc off), NUL)
                    ((ร @screenAttrs[off + 1] =) attr)
                )
                (screen-char off, row, col)
            )

            ((ร off =) (+ off mbyte_cells))
            ((ร col =) (+ col mbyte_cells))
            ((ร ptr =) (.plus ptr mbyte_blen))
            (when clear_next_cell
                ;; This only happens at the end, display one space next.
                ((ร ptr =) (u8 " "))
                ((ร len =) -1)
            )
        )

        ;; If we detected the next character needs to be redrawn,
        ;; but the text doesn't extend up to there, update the character here.
        (when (and force_redraw_next (< col @screenCols))
            (screen-char off, row, col)
        )
        nil
    ))

;; Prepare for 'hlsearch' highlighting.

(defn- #_void start-search-hl []
    (ยง
        (when (and @p_hls (not @no_hlsearch))
            (last-pat-prog (:rmm @search_hl))
            ((ร @search_hl.attr =) (hl-attr HLF_L))
            ;; Set the time limit to 'redrawtime'.
            ((ร @search_hl.nsec =) (profile-setlimit @p_rdt))
        )
        nil
    ))

;; Clean up for 'hlsearch' highlighting.

(defn- #_void end-search-hl []
    (ยง
        (when (non-nil? (:regprog (:rmm @search_hl)))
            ((ร @search_hl.rmm.regprog =) nil)
        )
        nil
    ))

;; Init for calling prepare-search-hl().

(defn- #_void init-search-hl [#_window_C wp]
    (ยง
        ;; Setup for match and 'hlsearch' highlighting.  Disable any previous match.
        ((ร FOR) (ร ((ร matchitem_C mi =) (:w_match_head wp)) (non-nil? mi) ((ร mi =) (:next mi)))
            (COPY-regmmatch (:rmm (:mi_hl mi)), (:mi_match mi))
            ((ร mi.mi_hl.attr =) (if (non-zero? (:hlg_id mi)) (syn-id2attr (:hlg_id mi)) 0))
            ((ร mi.mi_hl.buf =) @curbuf)
            ((ร mi.mi_hl.lnum =) 0)
            ((ร mi.mi_hl.first_lnum =) 0)
            ;; Set the time limit to 'redrawtime'.
            ((ร mi.mi_hl.nsec =) (profile-setlimit @p_rdt))
        )
        ((ร @search_hl.buf =) @curbuf)
        ((ร @search_hl.lnum =) 0)
        ((ร @search_hl.first_lnum =) 0)
        ;; time limit is set at the toplevel, for all windows
        nil
    ))

;; Advance to the match in window "wp" line "lnum" or past it.

(defn- #_void prepare-search-hl [#_window_C wp, #_long lnum]
    (ยง
        ;; When using a multi-line pattern, start searching at the top
        ;; of the window or just after a closed fold.
        ;; Do this both for search_hl and the match list.

        ((ร matchitem_C mi =) (:w_match_head wp))
        ((ร boolean shl_flag =) false)               ;; whether search_hl has been processed
        (while (or (non-nil? mi) (not shl_flag))
            (ร match_C shl)                        ;; points to search_hl or a match
            (cond (not shl_flag)
            (do
                ((ร shl =) @search_hl)
                ((ร shl_flag =) true)
            )
            :else
            (do
                ((ร shl =) (:mi_hl mi))
            ))
            (when (and (non-nil? (:regprog (:rmm shl))) (zero? (:lnum shl)) (re-multiline (:regprog (:rmm shl))))
                (if (zero? (:first_lnum shl))
                    ((ร shl.first_lnum =) (:w_topline wp))
                )
                (if (non-nil? mi)
                    ((ร mi.mi_pos.cur =) 0)
                )
                ((ร boolean pos_inprogress =) true)  ;; marks that position match search is in progress
                ((ร int n =) 0)
                (while (and (< (:first_lnum shl) lnum) (or (non-nil? (:regprog (:rmm shl))) (and (non-nil? mi) pos_inprogress)))
                    (next-search-hl wp, shl, (:first_lnum shl), n, mi)
                    ((ร pos_inprogress =) (and (non-nil? mi) (!= (:cur (:mi_pos mi)) 0)))
                    (cond (non-zero? (:lnum shl))
                    (do
                        ((ร shl.first_lnum =) (- (+ (:lnum shl) (:lnum (... (:endpos (:rmm shl)) 0))) (:lnum (... (:startpos (:rmm shl)) 0))))
                        ((ร n =) (:col (... (:endpos (:rmm shl)) 0)))
                    )
                    :else
                    (do
                        (ร shl.first_lnum++)
                        ((ร n =) 0)
                    ))
                )
            )
            (if (and (!= shl @search_hl) (non-nil? mi))
                ((ร mi =) (:next mi))
            )
        )
        nil
    ))

;; Search for a next 'hlsearch' or match.
;; Uses shl.buf.
;; Sets shl.lnum and shl.rmm contents.
;; Note: Assumes a previous match is always before "lnum", unless shl.lnum is zero.
;; Careful: Any pointers for buffer lines will become invalid.

(defn- #_void next-search-hl [#_window_C win, #_match_C shl, #_long lnum, #_int mincol, #_matchitem_C mi]
    ;; shl: points to search_hl or a match
    ;; mincol: minimal column for a match
    ;; mi: to retrieve match positions if any
    (ยง
        (when (non-zero? (:lnum shl))
            ;; Check for three situations:
            ;; 1. If the "lnum" is below a previous match, start a new search.
            ;; 2. If the previous match includes "mincol", use it.
            ;; 3. Continue after the previous match.

            ((ร long l =) (+ (:lnum shl) (- (:lnum (... (:endpos (:rmm shl)) 0)) (:lnum (... (:startpos (:rmm shl)) 0)))))
            (cond (< l lnum)
            (do
                ((ร shl.lnum =) 0)
            )
            (or (< lnum l) (< mincol (:col (... (:endpos (:rmm shl)) 0))))
            (do
                ((ร RETURN) nil)
            ))
        )

        ;; Repeat searching for a match until one is found that includes "mincol"
        ;; or none is found in this line.

        (reset! called_emsg false)
        (while true
            ;; Stop searching after passing the time limit.
            (when (profile-passed-limit (:nsec shl))
                ((ร shl.lnum =) 0)   ;; no match found in time
                (ร BREAK)
            )
            ;; Three situations:
            ;; 1. No useful previous match: search from start of line.
            ;; 2. Not Vi compatible or empty match: continue at next character.
            ;;    Break the loop if this is beyond the end of the line.
            ;; 3. Vi compatible searching: continue at end of previous match.

            (ร int matchcol)
            (cond (zero? (:lnum shl))
            (do
                ((ร matchcol =) 0)
            )
            (or (nil? (vim-strbyte @p_cpo, CPO_SEARCH)) (and (zero? (:lnum (... (:endpos (:rmm shl)) 0))) (<= (:col (... (:endpos (:rmm shl)) 0)) (:col (... (:startpos (:rmm shl)) 0)))))
            (do
                ((ร matchcol =) (:col (... (:startpos (:rmm shl)) 0)))
                ((ร Bytes ml =) (.plus (ml-get-buf (:buf shl), lnum) matchcol))
                (when (eos? ml)
                    (ร matchcol++)
                    ((ร shl.lnum =) 0)
                    (ร BREAK)
                )
                ((ร matchcol =) (+ matchcol (us-ptr2len-cc ml)))
            )
            :else
            (do
                ((ร matchcol =) (:col (... (:endpos (:rmm shl)) 0)))
            ))

            (ร long nmatched)

            ((ร shl.lnum =) lnum)
            (cond (non-nil? (:regprog (:rmm shl)))
            (do
                ;; Remember whether shl.rmm is using a copy of the regprog in mi.mi_match.
                ((ร boolean regprog_is_copy =) (and (!= shl @search_hl) (non-nil? mi) (== shl (:mi_hl mi)) (== (:regprog (:mi_match mi)) (:regprog (:rmm (:mi_hl mi))))))

                ((ร nmatched =) (vim-regexec-multi (:rmm shl), win, (:buf shl), lnum, matchcol, (:nsec shl)))
                ;; Copy the regprog, in case it got freed and recompiled.
                (if regprog_is_copy
                    ((ร mi.mi_match.regprog =) (:regprog (:rmm (:mi_hl mi))))
                )

                (when (or @called_emsg @got_int)
                    ;; Error while handling regexp: stop using this regexp.
                    (when (== shl @search_hl)
                        (reset! no_hlsearch true)
                    )
                    ((ร shl.rmm.regprog =) nil)
                    ((ร shl.lnum =) 0)
                    (reset! got_int false)    ;; avoid the "Type :quit to exit Vim" message
                    (ร BREAK)
                )
            )
            (non-nil? mi)
            (do
                ((ร nmatched =) (if (next-search-hl-pos shl, lnum, (:mi_pos mi), matchcol) 1 0))
            )
            :else
            (do
                ((ร nmatched =) 0)
            ))
            (when (zero? nmatched)
                ((ร shl.lnum =) 0)           ;; no match found
                (ร BREAK)
            )
            (when (or (< 0 (:lnum (... (:startpos (:rmm shl)) 0))) (<= mincol (:col (... (:startpos (:rmm shl)) 0))) (< 1 nmatched) (< mincol (:col (... (:endpos (:rmm shl)) 0))))
                ((ร shl.lnum =) (+ (:lnum shl) (:lnum (... (:startpos (:rmm shl)) 0))))
                (ร BREAK)                  ;; useful match found
            )
        )
        nil
    ))

(defn- #_boolean next-search-hl-pos [#_match_C shl, #_long lnum, #_posmatch_C posmatch, #_int mincol]
    ;; shl: points to a match
    ;; posmatch: match positions
    ;; mincol: minimal column for a match
    (ยง
        ((ร int bot =) -1)

        ((ร llpos_C tmp =) (NEW_llpos_C))

        ((ร shl.lnum =) 0)
        ((ร FOR) (ร ((ร int i =) (:cur posmatch)) (< i MAXPOSMATCH) (ร i++))
            (if (zero? (:lnum (... (:pm_pos posmatch) i)))
                (ร BREAK)
            )
            (if (< (:col (... (:pm_pos posmatch) i)) mincol)
                (ร CONTINUE)
            )
            (when (== (:lnum (... (:pm_pos posmatch) i)) lnum)
                (cond (== (:lnum shl) lnum)
                (do
                    ;; partially sort positions by column numbers on the same line
                    (when (< (:col (... (:pm_pos posmatch) i)) (:col (... (:pm_pos posmatch) bot)))
                        (COPY-llpos tmp, (... (:pm_pos posmatch) i))
                        (COPY-llpos (... (:pm_pos posmatch) i), (... (:pm_pos posmatch) bot))
                        (COPY-llpos (... (:pm_pos posmatch) bot), tmp)
                    )
                )
                :else
                (do
                    ((ร bot =) i)
                    ((ร shl.lnum =) lnum)
                ))
            )
        )
        ((ร posmatch.cur =) 0)

        (when (== (:lnum shl) lnum)
            ((ร int start =) (if (zero? (:col (... (:pm_pos posmatch) bot))) 0 (- (:col (... (:pm_pos posmatch) bot)) 1)))
            ((ร int end =) (if (zero? (:col (... (:pm_pos posmatch) bot))) MAXCOL (+ start (:len (... (:pm_pos posmatch) bot)))))

            ((ร shl.rmm.startpos[0].lnum =) 0)
            ((ร shl.rmm.startpos[0].col =) start)
            ((ร shl.rmm.endpos[0].lnum =) 0)
            ((ร shl.rmm.endpos[0].col =) end)
            ((ร posmatch.cur =) (inc bot))

            ((ร RETURN) true)
        )

        false
    ))

(defn- #_void screen-start-highlight [#_int attr]
    (ยง
        ((ร attrentry_C aep =) nil)

        (reset! screen_attr attr)
        (when @full_screen
            (when (< HL_ALL attr)                                  ;; special HL attr.
                ((ร aep =) (if (< 1 @t_colors) (syn-cterm-attr2entry attr) (syn-term-attr2entry attr)))
                ((ร attr =) (if (nil? aep) 0 (:ae_attr aep)))
            )
            (cond (and (flag? attr HL_BOLD) (non-nil? @T_MD))          ;; bold
            (do
                (out-str @T_MD)
            )
            (and (non-nil? aep) (< 1 @t_colors) (non-zero? (:ae_fg_color aep)) (non-zero? @cterm_normal_fg_bold))
            (do
                ;; If the Normal FG color has BOLD attribute
                ;; and the new HL has a FG color defined, clear BOLD.
                (out-str @T_ME)
            ))
            (if (and (flag? attr HL_STANDOUT) (non-nil? @T_SO))      ;; standout
                (out-str @T_SO))
            (if (and (flag? attr (| HL_UNDERLINE HL_UNDERCURL)) (non-nil? @T_US)) ;; underline or undercurl
                (out-str @T_US))
            (if (and (flag? attr HL_ITALIC) (non-nil? @T_CZH))       ;; italic
                (out-str @T_CZH))
            (if (and (flag? attr HL_INVERSE) (non-nil? @T_MR))       ;; inverse (reverse)
                (out-str @T_MR))

            ;; Output the color or start string after bold etc.,
            ;; in case the bold etc. override the color setting.

            (when (non-nil? aep)
                (cond (< 1 @t_colors)
                (do
                    (if (non-zero? (:ae_fg_color aep))
                        (term-fg-color (- (:ae_fg_color aep) 1)))
                    (if (non-zero? (:ae_bg_color aep))
                        (term-bg-color (- (:ae_bg_color aep) 1)))
                )
                :else
                (do
                    (if (non-nil? (:ae_esc_start aep))
                        (out-str (:ae_esc_start aep)))
                ))
            )
        )
        nil
    ))

(defn- #_void screen-stop-highlight []
    (ยง
        ((ร boolean do_ME =) false)                          ;; output T_ME code

        (when (non-zero? @screen_attr)
            (when (< HL_ALL @screen_attr)                   ;; special HL attr.
                (ร attrentry_C aep)

                (cond (< 1 @t_colors)
                (do
                    ;; Assume that t_me restores the original colors!

                    ((ร aep =) (syn-cterm-attr2entry @screen_attr))
                    (if (and (non-nil? aep) (or (non-zero? (:ae_fg_color aep)) (non-zero? (:ae_bg_color aep))))
                        ((ร do_ME =) true)
                    )
                )
                :else
                (do
                    ((ร aep =) (syn-term-attr2entry @screen_attr))
                    (when (and (non-nil? aep) (non-nil? (:ae_esc_stop aep)))
                        (if (zero? (STRCMP (:ae_esc_stop aep), @T_ME))
                            ((ร do_ME =) true)
                            (out-str (:ae_esc_stop aep)))
                    )
                ))
                (if (nil? aep)                        ;; did ":syntax clear"
                    (reset! screen_attr 0)
                    (reset! screen_attr (:ae_attr aep)))
            )

            ;; Often all ending-codes are equal to T_ME.
            ;; Avoid outputting the same sequence several times.

            (when (flag? @screen_attr HL_STANDOUT)
                (if (zero? (STRCMP @T_SE, @T_ME))
                    ((ร do_ME =) true)
                    (out-str @T_SE))
            )
            (when (flag? @screen_attr (| HL_UNDERLINE HL_UNDERCURL))
                (if (zero? (STRCMP @T_UE, @T_ME))
                    ((ร do_ME =) true)
                    (out-str @T_UE))
            )
            (when (flag? @screen_attr HL_ITALIC)
                (if (zero? (STRCMP @T_CZR, @T_ME))
                    ((ร do_ME =) true)
                    (out-str @T_CZR))
            )
            (if (or do_ME (flag? @screen_attr (| HL_BOLD HL_INVERSE)))
                (out-str @T_ME))

            (when (< 1 @t_colors)
                ;; set Normal cterm colors
                (if (non-zero? @cterm_normal_fg_color)
                    (term-fg-color (dec @cterm_normal_fg_color)))
                (if (non-zero? @cterm_normal_bg_color)
                    (term-bg-color (dec @cterm_normal_bg_color)))
                (if (non-zero? @cterm_normal_fg_bold)
                    (out-str @T_MD))
            )
        )
        (reset! screen_attr 0)
        nil
    ))

;; Reset the colors for a cterm.  Used when leaving Vim.
;; The machine specific code may override this again.

(defn- #_void reset-cterm-colors []
    (when (< 1 @t_colors)
        ;; set Normal cterm colors
        (when (or (< 0 @cterm_normal_fg_color) (< 0 @cterm_normal_bg_color))
            (out-str @T_OP)
            (reset! screen_attr -1)
        )
        (when (non-zero? @cterm_normal_fg_bold)
            (out-str @T_ME)
            (reset! screen_attr -1)
        )
    )
    nil)

;; Put character screenLines["off"] on the screen at position "row" and "col",
;; using the attributes from screenAttrs["off"].

(defn- #_void screen-char [#_int off, #_int row, #_int col]
    (ยง
        ;; Check for illegal values, just in case (could happen just after resizing).
        (if (or (<= @screenRows row) (<= @screenCols col))
            ((ร RETURN) nil)
        )

        ;; Outputting a character in the last cell on the screen may scroll the
        ;; screen up.  Only do it when the "xn" termcap property is set, otherwise
        ;; mark the character invalid (update it when scrolled up).
        (when (and (eos? @T_XN) (== row (dec @screenRows)) (== col (dec @screenCols)))
            ((ร @screenAttrs[off] =) -1)
            ((ร RETURN) nil)
        )

        ;; Stop highlighting first, so it's easier to move the cursor.

        ((ร int attr =) (if (non-zero? @screen_char_attr) @screen_char_attr (... @screenAttrs off)))
        (if (!= @screen_attr attr)
            (screen-stop-highlight))

        (windgoto row, col)

        (if (!= @screen_attr attr)
            (screen-start-highlight attr))

        (cond (non-zero? (... @screenLinesUC off))
        (do
            ((ร Bytes buf =) (Bytes. (inc MB_MAXBYTES)))

            ;; Convert UTF-8 character to bytes and write it.
            (.be buf (utfc-char2bytes off, buf), NUL)

            (out-str buf)
            (if (< 1 (utf-char2cells (... @screenLinesUC off)))
                (swap! screen_cur_col inc))
        )
        :else
        (do
            (out-flush-check)
            (out-char (.at @screenLines off))
        ))

        (swap! screen_cur_col inc)
        nil
    ))

;; Draw a rectangle of the screen, inverted when "invert" is true.
;; This uses the contents of screenLines[] and doesn't change it.

(defn- #_void screen-draw-rectangle [#_int row, #_int col, #_int height, #_int width, #_boolean invert]
    (ยง
        ;; Can't use "screenLines" unless initialized.
        (if (nil? @screenLines)
            ((ร RETURN) nil)
        )

        (if invert
            (reset! screen_char_attr HL_INVERSE))
        ((ร FOR) (ร ((ร int r =) row) (< r (+ row height)) (ร r++))
            ((ร int off =) (... @lineOffset r))
            ((ร int max_off =) (+ off @screenCols))
            ((ร FOR) (ร ((ร int c =) col) (< c (+ col width)) (ร c++))
                (screen-char (+ off c), r, c)
                (if (< 1 (utf-off2cells (+ off c), max_off))
                    (ร c++)
                )
            )
        )
        (reset! screen_char_attr 0)
        nil
    ))

;; Redraw the characters for a vertically split window.

(defn- #_void redraw-block [#_int row, #_int end, #_window_C wp]
    (ยง
        (ร int col)
        (ร int width)

        (cond (nil? wp)
        (do
            ((ร col =) 0)
            ((ร width =) (int @Cols))
        )
        :else
        (do
            ((ร col =) (:w_wincol wp))
            ((ร width =) (:w_width wp))
        ))

        (screen-draw-rectangle row, col, (- end row), width, false)
        nil
    ))

;; Fill the screen from 'start_row' to 'end_row', from 'start_col' to 'end_col'
;; with character 'c1' in first column followed by 'c2' in the other columns.
;; Use attributes 'attr'.

(defn- #_void screen-fill [#_int start_row, #_int end_row, #_int start_col, #_int end_col, #_int c1, #_int c2, #_int attr]
    (ยง
        ((ร boolean force_next =) false)

        (if (< @screenRows end_row)               ;; safety check
            ((ร end_row =) @screenRows)
        )
        (if (< @screenCols end_col)            ;; safety check
            ((ร end_col =) @screenCols)
        )
        (when (or (nil? @screenLines) (<= end_row start_row) (<= end_col start_col))        ;; nothing to do
            ((ร RETURN) nil)
        )

        ;; it's a "normal" terminal when not in a GUI or cterm
        ((ร boolean norm_term =) (<= @t_colors 1))

        ((ร FOR) (ร ((ร int row =) start_row) (< row end_row) (ร row++))
            ;; When drawing over the right halve of a double-wide char clear out the left halve.
            ;; When drawing over the left halve of a double wide-char clear out the right halve.
            ;; Only needed in a terminal.
            (if (and (< 0 start_col) (!= (mb-fix-col start_col, row) start_col))
                (screen-puts-len (u8 " "), 1, row, (dec start_col), 0))
            (if (and (< end_col @screenCols) (!= (mb-fix-col end_col, row) end_col))
                (screen-puts-len (u8 " "), 1, row, end_col, 0))

            ;; Try to use delete-line termcap code, when no attributes or in a
            ;; "normal" terminal, where a bold/italic space is just a space.

            ((ร boolean did_delete =) false)
            (when (and (== c2 (byte \space)) (== end_col (int @Cols)) (can-clear @T_CE) (or (zero? attr) (and norm_term (<= attr HL_ALL) (zero? (& attr (bit-not (| HL_BOLD HL_ITALIC)))))))
                ;; check if we really need to clear something

                ((ร int col =) start_col)
                (if (!= c1 (byte \space))                      ;; don't clear first char
                    (ร col++)
                )

                ((ร int off =) (+ (... @lineOffset row) col))
                ((ร int end_off =) (+ (... @lineOffset row) end_col))

                ;; skip blanks (used often, keep it fast!)
                (while (and (< off end_off) (== (.at @screenLines off) (byte \space)) (== (... @screenAttrs off) 0) (== (... @screenLinesUC off) 0))
                    (ร off++)
                )
                (when (< off end_off)                  ;; something to be cleared
                    ((ร col =) (- off (... @lineOffset row)))
                    (screen-stop-highlight)
                    (term-windgoto row, col)        ;; clear rest of this screen line
                    (out-str @T_CE)
                    (screen-start)                 ;; don't know where cursor is now
                    ((ร col =) (- end_col col))
                    (while (< 0 (ร col--))                   ;; clear chars in "screenLines"
                        (.be @screenLines off, (byte \space))
                        ((ร @screenLinesUC[off] =) 0)
                        ((ร @screenAttrs[off] =) 0)
                        (ร off++)
                    )
                )
                ((ร did_delete =) true)                  ;; the chars are cleared now
            )

            ((ร int off =) (+ (... @lineOffset row) start_col))
            ((ร int c =) c1)
            ((ร FOR) (ร ((ร int col =) start_col) (< col end_col) (ร col++))
                (when (or (!= (.at @screenLines off) c) (!= (... @screenLinesUC off) (if (<= 0x80 c) c 0)) (!= (... @screenAttrs off) attr) force_next)
                    ;; The bold trick may make a single row of pixels appear in
                    ;; the next character.  When a bold character is removed, the
                    ;; next character should be redrawn too.  This happens for our
                    ;; own GUI and for some xterms.
                    (when @term_is_xterm
                        (cond (and (!= (.at @screenLines off) (byte \space)) (or (< HL_ALL (... @screenAttrs off)) (flag? (... @screenAttrs off) HL_BOLD)))
                        (do
                            ((ร force_next =) true)
                        )
                        :else
                        (do
                            ((ร force_next =) false)
                        ))
                    )
                    (.be @screenLines off, c)
                    (cond (<= 0x80 c)
                    (do
                        ((ร @screenLinesUC[off] =) c)
                        ((ร @screenLinesC[0][off] =) 0)
                    )
                    :else
                    (do
                        ((ร @screenLinesUC[off] =) 0)
                    ))
                    ((ร @screenAttrs[off] =) attr)
                    (if (or (not did_delete) (!= c (byte \space)))
                        (screen-char off, row, col))
                )
                (ร off++)
                (when (== col start_col)
                    (if did_delete
                        (ร BREAK)
                    )
                    ((ร c =) c2)
                )
            )
            (if (== end_col (int @Cols))
                ((ร @lineWraps[row] =) false)
            )
            (when (== row (dec (int @Rows)))                ;; overwritten the command line
                (reset! redraw_cmdline true)
                (if (and (== c1 (byte \space)) (== c2 (byte \space)))
                    (reset! clear_cmdline false))      ;; command line has been cleared
                (if (zero? start_col)
                    (reset! mode_displayed false))     ;; mode cleared or overwritten
            )
        )
        nil
    ))

;; Check if there should be a delay.
;; Used before clearing or redrawing the screen or the command line.

(defn- #_void check-for-delay [#_boolean check_msg_scroll]
    (when (and (or @emsg_on_display (and check_msg_scroll @msg_scroll)) (not @did_wait_return))
        (out-flush)
        (ui-delay 1000, true)
        (reset! emsg_on_display false)
        (if check_msg_scroll
            (reset! msg_scroll false))
    )
    nil)

;; screen-valid -  allocate screen buffers if size changed
;;   If "doclear" is true: clear screen if it has been resized.
;;      Returns true if there is a valid screen to write to.
;;      Returns false when starting up and screen not initialized yet.

(defn- #_boolean screen-valid [#_boolean doclear]
    (screenalloc doclear)           ;; allocate screen buffers if size changed
    (non-nil? @screenLines))

(atom! boolean _4_entered)  ;; avoid recursiveness

;; Resize the shell to Rows and Cols.
;; Allocate screenLines[] and associated items.
;;
;; There may be some time between setting Rows and Cols and (re)allocating
;; screenLines[].  This happens when starting up and when (manually) changing
;; the shell size.  Always use screenRows and screenCols to access items
;; in screenLines[].  Use Rows and Cols for positioning text etc. where the
;; final size of the shell is needed.

(defn- #_void screenalloc [#_boolean doclear]
    (ยง
        ((ร int[][] smco =) (ร new int[MAX_MCO][]))

        ((ร int retry_count =) 0)

;       retry:
        (while true
            ;; Allocation of the screen buffers is done only when the size changes and
            ;; when Rows and Cols have been set and we have started doing full screen stuff.

            (if (or (and (non-nil? @screenLines) (== (int @Rows) @screenRows) (== (int @Cols) @screenCols) (non-nil? @screenLinesUC) (== @p_mco @screen_mco)) (== (int @Rows) 0) (== (int @Cols) 0) (and (not @full_screen) (nil? @screenLines)))
                ((ร RETURN) nil)
            )

            ;; It's possible that we produce an out-of-memory message below, which
            ;; will cause this function to be called again.  To break the loop, just return here.

            (if @_4_entered
                ((ร RETURN) nil)
            )
            (reset! _4_entered true)

            ;; Note that the window sizes are updated before reallocating the arrays,
            ;; thus we must not redraw here!

            (swap! redrawingDisabled inc)

            (win-new-shellsize)    ;; fit the windows in the new sized shell

            (comp-col)             ;; recompute columns for shown command and ruler

            ;; We're changing the size of the screen.
            ;; - Allocate new arrays for "screenLines" and "screenAttrs".
            ;; - Move lines from the old arrays into the new arrays, clear extra
            ;;   lines (unless the screen is going to be cleared).
            ;; - Free the old arrays.
            ;;
            ;; If anything fails, make "screenLines" null, so we don't do anything!
            ;; Continuing with the old "screenLines" may result in a crash, because the size is wrong.

            ((ร FOR) (ร ((ร window_C wp =) @firstwin) (non-nil? wp) ((ร wp =) (:w_next wp)))
                (win-free-lines wp)
            )

            ((ร Bytes slis =) (Bytes. (* (int (inc @Rows)) (int @Cols))))
            (dotimes [#_int i MAX_MCO]
                ((ร smco[i] =) nil)
            )
            ((ร int[] sluc =) (ร new int[((int)(@Rows + 1)) * ((int)@Cols)]))
            (dotimes [#_int i @p_mco]
                ((ร smco[i] =) (ร new int[((int)(@Rows + 1)) * ((int)@Cols)]))
            )

            ((ร int[] sats =) (ร new int[((int)(@Rows + 1)) * ((int)@Cols)]))
            ((ร int[] lofs =) (ร new int[(int)@Rows]))
            ((ร boolean[] lwrs =) (ร new boolean[(int)@Rows]))

            ((ร FOR) (ร ((ร window_C wp =) @firstwin) (non-nil? wp) ((ร wp =) (:w_next wp)))
                (win-alloc-lines wp)
            )

            (dotimes [#_int r @Rows]
                ((ร lofs[r] =) (* r (int @Cols)))
                ((ร lwrs[r] =) false)

                ;; If the screen is not going to be cleared, copy as much as
                ;; possible from the old screen to the new one and clear the rest
                ;; (used when resizing the window at the "--more--" prompt or
                ;; when executing an external command, for the GUI).

                (when (not doclear)
                    (BFILL slis, (... lofs r), (byte \space), (int @Cols))
                    (AFILL sluc, (... lofs r), 0, (int @Cols))
                    (dotimes [#_int i @p_mco]
                        (AFILL (... smco i), (... lofs r), 0, (int @Cols))
                    )
                    (AFILL sats, (... lofs r), 0, (int @Cols))

                    ((ร int r0 =) (+ r (- @screenRows (int @Rows))))
                    (when (and (<= 0 r0) (non-nil? @screenLines))
                        ((ร int off =) (... @lineOffset r0))
                        ((ร int len =) (if (< @screenCols (int @Cols)) @screenCols (int @Cols)))

                        ;; When switching to utf-8 don't copy characters, they
                        ;; may be invalid now.  Also when "p_mco" changes.
                        (when (and (non-nil? @screenLinesUC) (== @p_mco @screen_mco))
                            (BCOPY slis, (... lofs r), @screenLines, off, len)
                            (ACOPY sluc, (... lofs r), @screenLinesUC, off, len)
                            (dotimes [#_int i @p_mco]
                                (ACOPY (... smco i), (... lofs r), (... @screenLinesC i), off, len)
                            )
                        )
                        (ACOPY sats, (... lofs r), @screenAttrs, off, len)
                    )
                )
            )

            ;; Use the last line of the screen for the current line.
            (reset! current_ScreenLine (.plus slis (* (int @Rows) (int @Cols))))

            (reset! screenLines slis)
            (reset! screenLinesUC sluc)
            (dotimes [#_int i @p_mco]
                ((ร @screenLinesC[i] =) (... smco i))
            )
            (reset! screen_mco (int @p_mco))
            (reset! screenAttrs sats)
            (reset! lineOffset lofs)
            (reset! lineWraps lwrs)

            ;; It's important that screenRows and screenCols reflect the actual
            ;; size of screenLines[].  Set them before calling anything.
            (reset! screenRows (int @Rows))
            (reset! screenCols (int @Cols))

            (reset! must_redraw CLEAR)        ;; need to clear the screen later
            (if doclear
                (screenclear2)
            )

            (reset! _4_entered false)
            (swap! redrawingDisabled dec)

            ;; Do not apply autocommands more than 3 times to avoid an endless loop
            ;; in case applying autocommands always changes Rows or Cols.

            (when (and (zero? @starting) (<= (ร ++retry_count) 3))
                ;; In rare cases, autocommands may have altered Rows or Cols,
                ;; jump back to check if we need to allocate the screen again.
                (ร CONTINUE retry)
            )

            (ร BREAK)
        )
        nil
    ))

(defn- #_void screenclear []
    (check-for-delay false)
    (screenalloc false)             ;; allocate screen buffers if size changed
    (screenclear2)                 ;; clear the screen
    nil)

(defn- #_void screenclear2 []
    (ยง
        (if (or (== @starting NO_SCREEN) (nil? @screenLines))
            ((ร RETURN) nil)
        )

        (reset! screen_attr -1)               ;; force setting the Normal colors
        (screen-stop-highlight)        ;; don't want highlighting here

        ;; blank out "screenLines"
        (dotimes [#_int i @Rows]
            (lineclear (... @lineOffset i), (int @Cols))
            ((ร @lineWraps[i] =) false)
        )

        (cond (can-clear @T_CL)
        (do
            (out-str @T_CL)              ;; clear the display
            (reset! clear_cmdline false)
            (reset! mode_displayed false)
        )
        :else
        (do
            ;; can't clear the screen, mark all chars with invalid attributes
            (dotimes [#_int i @Rows]
                (lineinvalid (... @lineOffset i), (int @Cols))
            )
            (reset! clear_cmdline true)
        ))

        (reset! screen_cleared TRUE)          ;; can use contents of "screenLines" now

        (win-rest-invalid @firstwin)
        (reset! redraw_cmdline true)
        (if (== @must_redraw CLEAR)       ;; no need to clear again
            (reset! must_redraw NOT_VALID))
        (compute-cmdrow)
        (reset! msg_row @cmdline_row)          ;; put cursor on last line for messages
        (reset! msg_col 0)
        (screen-start)                 ;; don't know where cursor is now
        (reset! msg_scrolled 0)               ;; can't scroll back
        (reset! msg_didany false)
        (reset! msg_didout false)
        nil
    ))

;; Clear one line in "screenLines".

(defn- #_void lineclear [#_int off, #_int width]
    (BFILL @screenLines, off, (byte \space), width)
    (AFILL @screenLinesUC, off, 0, width)
    (AFILL @screenAttrs, off, 0, width)
    nil)

;; Mark one line in "screenLines" invalid by setting the attributes to an invalid value.

(defn- #_void lineinvalid [#_int off, #_int width]
    (AFILL @screenAttrs, off, -1, width)
    nil)

;; Copy part of a Screenline for vertically split window "wp".

(defn- #_void linecopy [#_int to, #_int from, #_window_C wp]
    (ยง
        ((ร int off_to =) (+ (... @lineOffset to) (:w_wincol wp)))
        ((ร int off_from =) (+ (... @lineOffset from) (:w_wincol wp)))

        (BCOPY @screenLines, off_to, @screenLines, off_from, (:w_width wp))
        (ACOPY @screenLinesUC, off_to, @screenLinesUC, off_from, (:w_width wp))
        (dotimes [#_int i @p_mco]
            (ACOPY (... @screenLinesC i), off_to, (... @screenLinesC i), off_from, (:w_width wp))
        )
        (ACOPY @screenAttrs, off_to, @screenAttrs, off_from, (:w_width wp))
        nil
    ))

;; Return true if clearing with term string "p" would work.
;; It can't work when the string is empty or it won't set the right background.

(defn- #_boolean can-clear [#_Bytes p]
    (and (non-eos? p) (or (<= @t_colors 1) (zero? @cterm_normal_bg_color) (non-eos? @T_UT))))

;; Reset cursor position.  Use whenever cursor was moved because of outputting
;; something directly to the screen (shell commands) or a terminal control code.

(defn- #_void screen-start []
    (reset! screen_cur_row (reset! screen_cur_col 9999))
    nil)

;; Move the cursor to position "row","col" in the screen.
;; This tries to find the most efficient way to move, minimizing the number of
;; characters sent to the terminal.

(final int
    GOTO_COST  7,   ;; assume a term-windgoto() takes about 7 chars
    HIGHL_COST 5)   ;; assume unhighlight takes 5 chars

(final int
    PLAN_LE    1,
    PLAN_CR    2,
    PLAN_NL    3,
    PLAN_WRITE 4)

(defn- #_void windgoto [#_int row, #_int col]
    (ยง
        ;; Can't use "screenLines" unless initialized.
        (if (nil? @screenLines)
            ((ร RETURN) nil)
        )

        (when (or (!= col @screen_cur_col) (!= row @screen_cur_row))
            (ร int cost)

            ;; Check for valid position.
            (if (< row 0)    ;; window without text lines?
                ((ร row =) 0)
            )
            (if (<= @screenRows row)
                ((ร row =) (dec @screenRows))
            )
            (if (<= @screenCols col)
                ((ร col =) (dec @screenCols))
            )

            ;; check if no cursor movement is allowed in highlight mode
            ((ร int noinvcurs =) (if (and (non-zero? @screen_attr) (eos? @T_MS)) HIGHL_COST 0))
            ((ร int goto_cost =) (+ GOTO_COST noinvcurs))

            ;; Plan how to do the positioning:
            ;;
            ;; 1. Use CR to move it to column 0, same row.
            ;; 2. Use T_LE to move it a few columns to the left.
            ;; 3. Use NL to move a few lines down, column 0.
            ;; 4. Move a few columns to the right with T_ND or by writing chars.
            ;;
            ;; Don't do this if the cursor went beyond the last column,
            ;; the cursor position is unknown then (some terminals wrap, some don't).
            ;;
            ;; First check if the highlighting attributes allow us to write
            ;; characters to move the cursor to the right.

            (cond (and (<= @screen_cur_row row) (< @screen_cur_col (int @Cols)))
            (do
                (ร int plan)
                (ร int wouldbe_col)

                ;; If the cursor is in the same row, bigger col, we can use CR or T_LE.

                ((ร Bytes bs =) nil)
                ((ร int attr =) @screen_attr)
                (cond (and (== row @screen_cur_row) (< col @screen_cur_col))
                (do
                    ;; "le" is preferred over "bc", because "bc" is obsolete
                    ((ร bs =) (if (non-eos? @T_LE)
                        @T_LE              ;; "cursor left"
                        @T_BC              ;; "backspace character (old)
                    ))
                    ((ร cost =) (if (non-eos? bs) (* (- @screen_cur_col col) (STRLEN bs)) 999))
                    (cond (< (inc col) cost)             ;; using CR is less characters
                    (do
                        ((ร plan =) PLAN_CR)
                        ((ร wouldbe_col =) 0)
                        ((ร cost =) 1)                   ;; CR is just one character
                    )
                    :else
                    (do
                        ((ร plan =) PLAN_LE)
                        ((ร wouldbe_col =) col)
                    ))
                    (when (non-zero? noinvcurs)             ;; will stop highlighting
                        ((ร cost =) (+ cost noinvcurs))
                        ((ร attr =) 0)
                    )
                )

                ;; If the cursor is above where we want to be, we can use CR LF.

                (< @screen_cur_row row)
                (do
                    ((ร plan =) PLAN_NL)
                    ((ร wouldbe_col =) 0)
                    ((ร cost =) (* (- row @screen_cur_row) 2))  ;; CR LF
                    (when (non-zero? noinvcurs)                 ;; will stop highlighting
                        ((ร cost =) (+ cost noinvcurs))
                        ((ร attr =) 0)
                    )
                )

                ;; If the cursor is in the same row, smaller col, just use write.

                :else
                (do
                    ((ร plan =) PLAN_WRITE)
                    ((ร wouldbe_col =) @screen_cur_col)
                    ((ร cost =) 0)
                ))

                ;; Check if any characters that need to be written have the
                ;; correct attributes.  Also avoid UTF-8 characters.

                ((ร int i =) (- col wouldbe_col))
                (if (< 0 i)
                    ((ร cost =) (+ cost i))
                )
                (when (and (< cost goto_cost) (< 0 i))
                    ;; Check if the attributes are correct without additionally
                    ;; stopping highlighting.

                    ((ร int ai =) (+ (... @lineOffset row) wouldbe_col))
                    (while (and (!= i 0) (== (... @screenAttrs (ร ai++)) attr))
                        (ร --i)
                    )
                    (when (non-zero? i)
                        ;; Try if it works when highlighting is stopped here.

                        (when (zero? (... @screenAttrs (ร --ai)))
                            ((ร cost =) (+ cost noinvcurs))
                            (while (and (!= i 0) (== (... @screenAttrs (ร ai++)) 0))
                                (ร --i)
                            )
                        )
                        (if (non-zero? i)
                            ((ร cost =) 999)     ;; different attributes, don't do it
                        )
                    )

                    ;; Don't use an UTF-8 char for positioning, it's slow.
                    ((ร FOR) (ร ((ร i =) wouldbe_col) (< i col) (ร i++))
                        (when (!= (... @screenLinesUC (+ (... @lineOffset row) i)) 0)
                            ((ร cost =) 999)
                            (ร BREAK)
                        )
                    )
                )

                ;; We can do it without term-windgoto()!

                (when (< cost goto_cost)
                    (cond (== plan PLAN_LE)
                    (do
                        (if (non-zero? noinvcurs)
                            (screen-stop-highlight))
                        (while (< col @screen_cur_col)
                            (out-str bs)
                            (swap! screen_cur_col dec)
                        )
                    )
                    (== plan PLAN_CR)
                    (do
                        (if (non-zero? noinvcurs)
                            (screen-stop-highlight))
                        (out-char (byte \return))
                        (reset! screen_cur_col 0)
                    )
                    (== plan PLAN_NL)
                    (do
                        (if (non-zero? noinvcurs)
                            (screen-stop-highlight))
                        (while (< @screen_cur_row row)
                            (out-char (byte \newline))
                            (swap! screen_cur_row inc)
                        )
                        (reset! screen_cur_col 0)
                    ))

                    ((ร i =) (- col @screen_cur_col))
                    (when (< 0 i)
                        ;; Use cursor-right if it's one character only.
                        ;; Avoids removing a line of pixels from the last bold char,
                        ;; when using the bold trick in the GUI.

                        (cond (and (non-eos? @T_ND) (eos? @T_ND 1))
                        (do
                            (while (< 0 (ร i--))
                                (out-char (.at @T_ND 0))
                            )
                        )
                        :else
                        (do
                            ((ร int off =) (+ (... @lineOffset row) @screen_cur_col))

                            (while (< 0 (ร i--))
                                (if (!= (... @screenAttrs off) @screen_attr)
                                    (screen-stop-highlight))
                                (out-flush-check)
                                (out-char (.at @screenLines off))
                                (ร off++)
                            )
                        ))
                    )
                )
            )
            :else
            (do
                ((ร cost =) 999)
            ))

            (when (<= goto_cost cost)
                (if (non-zero? noinvcurs)
                    (screen-stop-highlight))
                (if (and (== row @screen_cur_row) (< @screen_cur_col col) (non-eos? @T_CRI))
                    (term-cursor-right (- col @screen_cur_col))
                    (term-windgoto row, col))
            )
            (reset! screen_cur_row row)
            (reset! screen_cur_col col)
        )
        nil
    ))

;; Set cursor to its position in the current window.

(defn- #_void setcursor []
    (when (redrawing)
        (validate-cursor)

        (windgoto (+ (:w_winrow @curwin) (:w_wrow @curwin)), (+ (:w_wincol @curwin) (:w_wcol @curwin)))
    )
    nil)

;; insert 'line_count' lines at 'row' in window 'wp'
;; if 'invalid' is true the wp.w_lines[].wl_lnum is invalidated.
;; if 'mayclear' is true the screen will be cleared if it is faster than scrolling.
;; Returns false if the lines are not inserted, true for success.

(defn- #_boolean win-ins-lines [#_window_C wp, #_int row, #_int line_count, #_boolean invalid, #_boolean mayclear]
    (ยง
        (if invalid
            ((ร wp.w_lines_valid =) 0)
        )

        (if (< (:w_height wp) 5)
            ((ร RETURN) false)
        )

        (if (> line_count (- (:w_height wp) row))
            ((ร line_count =) (- (:w_height wp) row))
        )

        ((ร maybean maybe =) (win-do-lines wp, row, line_count, mayclear, false))
        (if (!= maybe MAYBE)
            ((ร RETURN) (!= maybe FALSE))
        )

        ;; If there is a next window or a status line, we first try to delete the
        ;; lines at the bottom to avoid messing what is after the window.
        ;; If this fails and there are following windows, don't do anything to avoid
        ;; messing up those windows, better just redraw.

        ((ร boolean did_delete =) false)
        (when (or (non-nil? (:w_next wp)) (non-zero? (:w_status_height wp)))
            (cond (screen-del-lines 0, (- (+ (:w_winrow wp) (:w_height wp)) line_count), line_count, (int @Rows), false, nil)
            (do
                ((ร did_delete =) true)
            )
            (non-nil? (:w_next wp))
            (do
                ((ร RETURN) false)
            ))
        )

        ;; if no lines deleted, blank the lines that will end up below the window

        (when (not did_delete)
            ((ร wp.w_redr_status =) true)
            (reset! redraw_cmdline true)
            ((ร int nextrow =) (+ (:w_winrow wp) (:w_height wp) (:w_status_height wp)))
            ((ร int lastrow =) (+ nextrow line_count))
            (if (< @Rows lastrow)
                ((ร lastrow =) (int @Rows))
            )
            (screen-fill (- nextrow line_count), (- lastrow line_count), (:w_wincol wp), (+ (:w_wincol wp) (:w_width wp)), (byte \space), (byte \space), 0)
        )

        (when (not (screen-ins-lines 0, (+ (:w_winrow wp) row), line_count, (int @Rows), nil))
            ;; deletion will have messed up other windows
            (when did_delete
                ((ร wp.w_redr_status =) true)
                (win-rest-invalid (:w_next wp))
            )
            ((ร RETURN) false)
        )

        true
    ))

;; delete "line_count" window lines at "row" in window "wp"
;; If "invalid" is true curwin.w_lines[] is invalidated.
;; If "mayclear" is true the screen will be cleared if it is faster than scrolling
;; Return true for success, false if the lines are not deleted.

(defn- #_boolean win-del-lines [#_window_C wp, #_int row, #_int line_count, #_boolean invalid, #_boolean mayclear]
    (ยง
        (if invalid
            ((ร wp.w_lines_valid =) 0)
        )

        (if (> line_count (- (:w_height wp) row))
            ((ร line_count =) (- (:w_height wp) row))
        )

        ((ร maybean maybe =) (win-do-lines wp, row, line_count, mayclear, true))
        (if (!= maybe MAYBE)
            ((ร RETURN) (!= maybe FALSE))
        )

        (if (not (screen-del-lines 0, (+ (:w_winrow wp) row), line_count, (int @Rows), false, nil))
            ((ร RETURN) false)
        )

        ;; If there are windows or status lines below, try to put them at the
        ;; correct place.  If we can't do that, they have to be redrawn.

        (cond (or (non-nil? (:w_next wp)) (non-zero? (:w_status_height wp)) (< @cmdline_row (dec @Rows)))
        (do
            (when (not (screen-ins-lines 0, (- (+ (:w_winrow wp) (:w_height wp)) line_count), line_count, (int @Rows), nil))
                ((ร wp.w_redr_status =) true)
                (win-rest-invalid (:w_next wp))
            )
        )
        ;; If this is the last window and there is no status line, redraw the command line later.
        :else
        (do
            (reset! redraw_cmdline true)
        ))

        true
    ))

;; Common code for win-ins-lines() and win-del-lines().
;; Returns true or false when the work has been done.
;; Returns MAYBE when not finished yet.

(defn- #_maybean win-do-lines [#_window_C wp, #_int row, #_int line_count, #_boolean mayclear, #_boolean del]
    (ยง
        (if (or (not (redrawing)) (<= line_count 0))
            ((ร RETURN) FALSE)
        )

        ;; only a few lines left: redraw is faster
        (when (and mayclear (< (- @Rows line_count) 5) (== (:w_width wp) (int @Cols)))
            (screenclear)      ;; will set wp.w_lines_valid to 0
            ((ร RETURN) FALSE)
        )

        ;; Delete all remaining lines

        (when (<= (:w_height wp) (+ row line_count))
            (screen-fill (+ (:w_winrow wp) row), (+ (:w_winrow wp) (:w_height wp)), (:w_wincol wp), (+ (:w_wincol wp) (:w_width wp)), (byte \space), (byte \space), 0)
            ((ร RETURN) TRUE)
        )

        ;; when scrolling, the message on the command line should be cleared,
        ;; otherwise it will stay there forever.

        (reset! clear_cmdline true)

        ;; If the terminal can set a scroll region, use that.
        ;; Always do this in a vertically split window.  This will redraw from
        ;; screenLines[] when t_CV isn't defined.  That's faster than using win-line().
        ;; Don't use a scroll region when we are going to redraw the text.

        (when (or @scroll_region (!= (:w_width wp) (int @Cols)))
            (if (and @scroll_region (or (== (:w_width wp) (int @Cols)) (non-eos? @T_CSV)))
                (scroll-region-set wp, row))

            ((ร boolean r =) (if del
                (screen-del-lines (+ (:w_winrow wp) row), 0, line_count, (- (:w_height wp) row), false, wp)
                (screen-ins-lines (+ (:w_winrow wp) row), 0, line_count, (- (:w_height wp) row), wp)
            ))

            (if (and @scroll_region (or (== (:w_width wp) (int @Cols)) (non-eos? @T_CSV)))
                (scroll-region-reset))

            ((ร RETURN) (if r TRUE FALSE))
        )

        (if (non-nil? (:w_next wp))
            ((ร RETURN) FALSE)
        )

        MAYBE
    ))

;; window 'wp' and everything after it is messed up, mark it for redraw

(defn- #_void win-rest-invalid [#_window_C wp]
    (ยง
        (while (non-nil? wp)
            (redraw-win-later wp, NOT_VALID)
            ((ร wp.w_redr_status =) true)
            ((ร wp =) (:w_next wp))
        )
        (reset! redraw_cmdline true)
        nil
    ))

;; The rest of the routines in this file perform screen manipulations.
;; The given operation is performed physically on the screen.
;; The corresponding change is also made to the internal screen image.
;; In this way, the editor anticipates the effect of editing changes
;; on the appearance of the screen.
;; That way, when we call screenupdate a complete redraw isn't usually necessary.
;; Another advantage is that we can keep adding code to anticipate screen changes,
;; and in the meantime, everything still works.

;; types for inserting or deleting lines

(final int USE_T_CAL   1)
(final int USE_T_CDL   2)
(final int USE_T_AL    3)
(final int USE_T_CE    4)
(final int USE_T_DL    5)
(final int USE_T_SR    6)
(final int USE_NL      7)
(final int USE_T_CD    8)
(final int USE_REDRAW  9)

;; insert lines on the screen and update screenLines[]
;; 'end' is the line after the scrolled part.  Normally it is Rows.
;; When scrolling region used 'off' is the offset from the top for the region.
;; 'row' and 'end' are relative to the start of the region.
;;
;; return false for failure, true for success.

(defn- #_boolean screen-ins-lines [#_int off, #_int row, #_int line_count, #_int end, #_window_C wp]
    ;; wp: null or window to use width from
    (ยง
        ((ร boolean can_ce =) (can-clear @T_CE))

        ;; FAIL if
        ;; - there is no valid screen
        ;; - the screen has to be redrawn completely
        ;; - the line count is less than one
        ;; - the line count is more than 'ttyscroll'

        (when (or (not (screen-valid true)) (<= line_count 0) (< @p_ttyscroll line_count))
            ((ร RETURN) false)
        )

        ;; There are seven ways to insert lines:
        ;;
        ;; 0. When in a vertically split window and t_CV isn't set, redraw the characters from screenLines[].
        ;; 1. Use T_CD (clear to end of display) if it exists and the result of the insert is just empty lines.
        ;; 2. Use T_CAL (insert multiple lines) if it exists and T_AL is not present or line_count > 1.
        ;;    It looks better if we do all the inserts at once.
        ;; 3. Use T_CDL (delete multiple lines) if it exists and the result of the
        ;;    insert is just empty lines and T_CE is not present or line_count > 1.
        ;; 4. Use T_AL (insert line) if it exists.
        ;; 5. Use T_CE (erase line) if it exists and the result of the insert is just empty lines.
        ;; 6. Use T_DL (delete line) if it exists and the result of the insert is just empty lines.
        ;; 7. Use T_SR (scroll reverse) if it exists and inserting at row 0
        ;;    and the 'da' flag is not set or we have clear line capability.
        ;; 8. Redraw the characters from screenLines[].
        ;;
        ;; Careful: In a hpterm scroll reverse doesn't work as expected, it moves
        ;; the scrollbar for the window.  It does have insert line, use that if it exists.

        ((ร boolean result_empty =) (<= end (+ row line_count)))

        (ร int type)
        (cond (and (non-nil? wp) (!= (:w_width wp) (int @Cols)) (eos? @T_CSV))
        (do
            ((ร type =) USE_REDRAW)
        )
        (and (can-clear @T_CD) result_empty)
        (do
            ((ร type =) USE_T_CD)
        )
        (and (non-eos? @T_CAL) (or (< 1 line_count) (eos? @T_AL)))
        (do
            ((ร type =) USE_T_CAL)
        )
        (and (non-eos? @T_CDL) result_empty (or (< 1 line_count) (not can_ce)))
        (do
            ((ร type =) USE_T_CDL)
        )
        (non-eos? @T_AL)
        (do
            ((ร type =) USE_T_AL)
        )
        (and can_ce result_empty)
        (do
            ((ร type =) USE_T_CE)
        )
        (and (non-eos? @T_DL) result_empty)
        (do
            ((ร type =) USE_T_DL)
        )
        (and (non-eos? @T_SR) (zero? row) (or (eos? @T_DA) can_ce))
        (do
            ((ร type =) USE_T_SR)
        )
        :else
        (do
            ((ร RETURN) false)
        ))

        ;; For clearing the lines screen-del-lines() is used.  This will also take
        ;; care of t_db if necessary.

        (if (or (== type USE_T_CD) (== type USE_T_CDL) (== type USE_T_CE) (== type USE_T_DL))
            ((ร RETURN) (screen-del-lines off, row, line_count, end, false, wp))
        )

        ;; If text is retained below the screen, first clear or delete as many
        ;; lines at the bottom of the window as are about to be inserted so that
        ;; the deleted lines won't later surface during a screen-del-lines.

        (if (non-eos? @T_DB)
            (screen-del-lines off, (- end line_count), line_count, end, false, wp))

        ((ร int cursor_row =) (+ row off))

        ;; Shift lineOffset[] line_count down to reflect the inserted lines.
        ;; Clear the inserted lines in screenLines[].

        ((ร row =) (+ row off))
        ((ร end =) (+ end off))
        (dotimes [#_int i line_count]
            (cond (and (non-nil? wp) (!= (:w_width wp) (int @Cols)))
            (do
                ;; need to copy part of a line
                ((ร int j =) (- end 1 i))
                (while (<= row ((ร j =) (- j line_count)))
                    (linecopy (+ j line_count), j, wp)
                )
                ((ร j =) (+ j line_count))
                (if (can-clear (u8 " "))
                    (lineclear (+ (... @lineOffset j) (:w_wincol wp)), (:w_width wp))
                    (lineinvalid (+ (... @lineOffset j) (:w_wincol wp)), (:w_width wp)))
                ((ร @lineWraps[j] =) false)
            )
            :else
            (do
                ((ร int j =) (- end 1 i))
                ((ร int temp =) (... @lineOffset j))
                (while (<= row ((ร j =) (- j line_count)))
                    ((ร @lineOffset[j + line_count] =) (... @lineOffset j))
                    ((ร @lineWraps[j + line_count] =) (... @lineWraps j))
                )
                ((ร @lineOffset[j + line_count] =) temp)
                ((ร @lineWraps[j + line_count] =) false)
                (if (can-clear (u8 " "))
                    (lineclear temp, (int @Cols))
                    (lineinvalid temp, (int @Cols)))
            ))
        )

        (screen-stop-highlight)
        (windgoto cursor_row, 0)

        ;; redraw the characters
        (cond (== type USE_REDRAW)
        (do
            (redraw-block row, end, wp)
        )
        (== type USE_T_CAL)
        (do
            (term-append-lines line_count)
            (screen-start)         ;; don't know where cursor is now
        )
        :else
        (do
            (dotimes [#_int i line_count]
                (cond (== type USE_T_AL)
                (do
                    (if (and (non-zero? i) (non-zero? cursor_row))
                        (windgoto cursor_row, 0))
                    (out-str @T_AL)
                )
                :else ;; type == USE_T_SR
                (do
                    (out-str @T_SR)
                ))
                (screen-start)         ;; don't know where cursor is now
            )
        ))

        ;; With scroll-reverse and 'da' flag set we need to clear the lines that
        ;; have been scrolled down into the region.

        (when (and (== type USE_T_SR) (non-eos? @T_DA))
            (dotimes [#_int i line_count]
                (windgoto (+ off i), 0)
                (out-str @T_CE)
                (screen-start)         ;; don't know where cursor is now
            )
        )

        true
    ))

;; delete lines on the screen and update screenLines[]
;; 'end' is the line after the scrolled part.  Normally it is Rows.
;; When scrolling region used 'off' is the offset from the top for the region.
;; 'row' and 'end' are relative to the start of the region.
;;
;; Return true for success, false if the lines are not deleted.

(defn- #_boolean screen-del-lines [#_int off, #_int row, #_int line_count, #_int end, #_boolean force, #_window_C wp]
    ;; force: even when line_count > p_ttyscroll
    ;; wp: null or window to use width from
    (ยง
        ;; FAIL if
        ;; - there is no valid screen
        ;; - the screen has to be redrawn completely
        ;; - the line count is less than one
        ;; - the line count is more than 'ttyscroll'

        (if (or (not (screen-valid true)) (<= line_count 0) (and (not force) (< @p_ttyscroll line_count)))
            ((ร RETURN) false)
        )

        ;; Check if the rest of the current region will become empty.

        ((ร boolean result_empty =) (<= end (+ row line_count)))

        ;; We can delete lines only when 'db' flag not set or when 'ce' option available.

        ((ร boolean can_delete =) (or (eos? @T_DB) (can-clear @T_CE)))

        (ร int type)

        ;; There are six ways to delete lines:
        ;;
        ;; 0. When in a vertically split window and t_CV isn't set, redraw the characters from screenLines[].
        ;; 1. Use T_CD if it exists and the result is empty.
        ;; 2. Use newlines if row == 0 and count == 1 or T_CDL does not exist.
        ;; 3. Use T_CDL (delete multiple lines) if it exists and line_count > 1 or none of the other ways work.
        ;; 4. Use T_CE (erase line) if the result is empty.
        ;; 5. Use T_DL (delete line) if it exists.
        ;; 6. Redraw the characters from screenLines[].

        (cond (and (non-nil? wp) (!= (:w_width wp) (int @Cols)) (eos? @T_CSV))
        (do
            ((ร type =) USE_REDRAW)
        )
        (and (can-clear @T_CD) result_empty)
        (do
            ((ร type =) USE_T_CD)
        )
        (and (zero? row) (or (== line_count 1) (eos? @T_CDL)))
        (do
            ((ร type =) USE_NL)
        )
        (and (non-eos? @T_CDL) (< 1 line_count) can_delete)
        (do
            ((ร type =) USE_T_CDL)
        )
        (and (can-clear @T_CE) result_empty (or (nil? wp) (== (:w_width wp) (int @Cols))))
        (do
            ((ร type =) USE_T_CE)
        )
        (and (non-eos? @T_DL) can_delete)
        (do
            ((ร type =) USE_T_DL)
        )
        (and (non-eos? @T_CDL) can_delete)
        (do
            ((ร type =) USE_T_CDL)
        )
        :else
        (do
            ((ร RETURN) false)
        ))

        ((ร int cursor_row =) (+ row off))
        ((ร int cursor_end =) (+ end off))

        ;; Now shift lineOffset[] line_count up to reflect the deleted lines.
        ;; Clear the inserted lines in screenLines[].

        ((ร row =) (+ row off))
        ((ร end =) (+ end off))
        (dotimes [#_int i line_count]
            (cond (and (non-nil? wp) (!= (:w_width wp) (int @Cols)))
            (do
                ;; need to copy part of a line
                ((ร int j =) (+ row i))
                (while (<= ((ร j =) (+ j line_count)) (dec end))
                    (linecopy (- j line_count), j, wp)
                )
                ((ร j =) (- j line_count))
                (if (can-clear (u8 " "))
                    (lineclear (+ (... @lineOffset j) (:w_wincol wp)), (:w_width wp))
                    (lineinvalid (+ (... @lineOffset j) (:w_wincol wp)), (:w_width wp)))
                ((ร @lineWraps[j] =) false)
            )
            :else
            (do
                ;; whole width, moving the line pointers is faster
                ((ร int j =) (+ row i))
                ((ร int temp =) (... @lineOffset j))
                (while (<= ((ร j =) (+ j line_count)) (dec end))
                    ((ร @lineOffset[j - line_count] =) (... @lineOffset j))
                    ((ร @lineWraps[j - line_count] =) (... @lineWraps j))
                )
                ((ร @lineOffset[j - line_count] =) temp)
                ((ร @lineWraps[j - line_count] =) false)
                (if (can-clear (u8 " "))
                    (lineclear temp, (int @Cols))
                    (lineinvalid temp, (int @Cols)))
            ))
        )

        (screen-stop-highlight)

        (cond (== type USE_REDRAW)                 ;; redraw the characters
        (do
            (redraw-block row, end, wp)
        )
        (== type USE_T_CD)              ;; delete the lines
        (do
            (windgoto cursor_row, 0)
            (out-str @T_CD)
            (screen-start)                      ;; don't know where cursor is now
        )
        (== type USE_T_CDL)
        (do
            (windgoto cursor_row, 0)
            (term-delete-lines line_count)
            (screen-start)                      ;; don't know where cursor is now
        )

        ;; Deleting lines at top of the screen or scroll region: Just scroll
        ;; the whole screen (scroll region) up by outputting newlines on the last line.

        (== type USE_NL)
        (do
            (windgoto (dec cursor_end), 0)
            ((ร FOR) (ร ((ร int i =) line_count) (<= 0 (ร --i)) nil)
                (out-char (byte \newline))           ;; cursor will remain on same line
            )
        )
        :else
        (do
            ((ร FOR) (ร ((ร int i =) line_count) (<= 0 (ร --i)) nil)
                (cond (== type USE_T_DL)
                (do
                    (windgoto cursor_row, 0)
                    (out-str @T_DL)             ;; delete a line
                )
                :else ;; type == USE_T_CE
                (do
                    (windgoto (+ cursor_row i), 0)
                    (out-str @T_CE)             ;; erase a line
                ))
                (screen-start)                  ;; don't know where cursor is now
            )
        ))

        ;; If the 'db' flag is set, we need to clear the lines that have been
        ;; scrolled up at the bottom of the region.

        (when (and (non-eos? @T_DB) (or (== type USE_T_DL) (== type USE_T_CDL)))
            ((ร FOR) (ร ((ร int i =) line_count) (< 0 i) (ร --i))
                (windgoto (- cursor_end i), 0)
                (out-str @T_CE)                 ;; erase a line
                (screen-start)                  ;; don't know where cursor is now
            )
        )

        true
    ))

;; show the current mode and ruler
;;
;; If clear_cmdline is true, clear the rest of the cmdline.
;; If clear_cmdline is false there may be a message there that needs to be
;; cleared only if a mode is shown.
;; Return the length of the message (0 if no message).

(defn- #_int showmode []
    (ยง
        ((ร int length =) 0)

        ((ร boolean do_mode =) (and @p_smd (or (flag? @State INSERT) (!= @restart_edit 0) @VIsual_active)))
        (cond (or do_mode @Recording)
        (do
            ;; Don't show mode right now, when not redrawing or inside a mapping.
            ;; Call char-avail() only when we are going to show something, because
            ;; it takes a bit of time.

            (when (or (not (redrawing)) (and (char-avail) (not @keyTyped)))
                (reset! redraw_cmdline true)              ;; show mode later
                ((ร RETURN) 0)
            )

            ((ร boolean nwr_save =) @need_wait_return)

            ;; wait a bit before overwriting an important message
            (check-for-delay false)

            ;; if the cmdline is more than one line high, erase top lines
            ((ร boolean need_clear =) @clear_cmdline)
            (if (and @clear_cmdline (< @cmdline_row (dec @Rows)))
                (msg-clr-cmdline))                  ;; will reset clear_cmdline

            ;; Position on the last line in the window, column 0.
            (msg-pos-mode)
            (cursor-off)
            ((ร int attr =) (hl-attr HLF_CM))                 ;; Highlight mode
            (when do_mode
                (msg-puts-attr (u8 "--"), attr)

                (cond (flag? @State VREPLACE_FLAG)
                (do
                    (msg-puts-attr (u8 " VREPLACE"), attr)
                )
                (flag? @State REPLACE_FLAG)
                (do
                    (msg-puts-attr (u8 " REPLACE"), attr)
                )
                (flag? @State INSERT)
                (do
                    (msg-puts-attr (u8 " INSERT"), attr)
                )
                (== @restart_edit (byte \I))
                (do
                    (msg-puts-attr (u8 " (insert)"), attr)
                )
                (== @restart_edit (byte \R))
                (do
                    (msg-puts-attr (u8 " (replace)"), attr)
                )
                (== @restart_edit (byte \V))
                (do
                    (msg-puts-attr (u8 " (vreplace)"), attr)
                ))

                (if (and (flag? @State INSERT) @p_paste)
                    (msg-puts-attr (u8 " (paste)"), attr))

                (when @VIsual_active
                    (ร Bytes p)

                    ;; Don't concatenate separate words to avoid translation problems.
                    ((ร SWITCH) (+ (if @VIsual_select 4 0) (if (== @VIsual_mode Ctrl_V) 2 0) (if (== @VIsual_mode (byte \V)) 1 0))
                        ((ร CASE) 0)
                        (do
                            ((ร p =) (u8 " VISUAL"))
                            (ร BREAK)
                        )
                        ((ร CASE) 1)
                        (do
                            ((ร p =) (u8 " VISUAL LINE"))
                            (ร BREAK)
                        )
                        ((ร CASE) 2)
                        (do
                            ((ร p =) (u8 " VISUAL BLOCK"))
                            (ร BREAK)
                        )
                        ((ร CASE) 4)
                        (do
                            ((ร p =) (u8 " SELECT"))
                            (ร BREAK)
                        )
                        ((ร CASE) 5)
                        (do
                            ((ร p =) (u8 " SELECT LINE"))
                            (ร BREAK)
                        )
                        (ร DEFAULT)
                        (do
                            ((ร p =) (u8 " SELECT BLOCK"))
                            (ร BREAK)
                        )
                    )
                    (msg-puts-attr p, attr)
                )
                (msg-puts-attr (u8 " --"), attr)

                ((ร need_clear =) true)
            )
            (when @Recording
                (msg-puts-attr (u8 "recording"), attr)
                ((ร need_clear =) true)
            )

            (reset! mode_displayed true)
            (if (or need_clear @clear_cmdline)
                (msg-clr-eos))
            (reset! msg_didout false)             ;; overwrite this message
            ((ร length =) @msg_col)
            (reset! msg_col 0)
            (reset! need_wait_return nwr_save)    ;; never ask for hit-return for this
        )
        @clear_cmdline
        (do
            ;; Clear the whole command line.  Will reset "clear_cmdline".
            (msg-clr-cmdline)
        ))

        ;; In Visual mode the size of the selected area must be redrawn.
        (if @VIsual_active
            (clear-showcmd))

        ;; If the last window has no status line,
        ;; the ruler is after the mode message and must be redrawn.
        (if (and (redrawing) (zero? (:w_status_height @lastwin)))
            (win-redr-ruler @lastwin, true))
        (reset! redraw_cmdline false)
        (reset! clear_cmdline false)

        length
    ))

;; Position for a mode message.

(defn- #_void msg-pos-mode []
    (reset! msg_col 0)
    (reset! msg_row (dec (int @Rows)))
    nil)

;; Delete mode message.  Used when ESC is typed which is expected to end
;; Insert mode (but Insert mode didn't end yet!).
;; Caller should check "mode_displayed".

(defn- #_void unshowmode [#_boolean force]
    (ยง
        ;; Don't delete it right now, when not redrawing or inside a mapping.

        (cond (or (not (redrawing)) (and (not force) (char-avail) (not @keyTyped)))
        (do
            (reset! redraw_cmdline true)          ;; delete mode later
        )
        :else
        (do
            (msg-pos-mode)
            (if @Recording
                (msg-puts-attr (u8 "recording"), (hl-attr HLF_CM)))
            (msg-clr-eos)
        ))
        nil
    ))

;; Get buffer name for "buf" into nameBuff[].
;; Takes care of special buffer names and translates special characters.

(defn- #_void get-trans-bufname [#_buffer_C buf]
    (vim-strncpy @nameBuff, (buf-spname buf), (dec MAXPATHL))
    (trans-characters @nameBuff, MAXPATHL)
    nil)

;; Get the character to use in a status line.  Get its attributes in "*attr".

(defn- #_int fillchar-status [#_int* attr, #_boolean is_curwin]
    (ยง
        (ร int fill)
        (cond is_curwin
        (do
            ((ร attr[0] =) (hl-attr HLF_S))
            ((ร fill =) @fill_stl)
        )
        :else
        (do
            ((ร attr[0] =) (hl-attr HLF_SNC))
            ((ร fill =) @fill_stlnc)
        ))

        ;; Use fill when there is highlighting, and highlighting of current window differs,
        ;; or the fillchars differ, or this is not the current window.
        (if (and (non-zero? (... attr 0)) (or (!= (hl-attr HLF_S) (hl-attr HLF_SNC)) (not is_curwin) (== @firstwin @lastwin) (!= @fill_stl @fill_stlnc)))
            ((ร RETURN) fill)
        )
        (if is_curwin
            ((ร RETURN) (byte \^))
        )

        (byte \=)
    ))

;; Get the character to use in a separator between vertically split windows.
;; Get its attributes in "*attr".

(defn- #_int fillchar-vsep [#_int* attr]
    (ยง
        ((ร attr[0] =) (hl-attr HLF_C))
        (if (and (zero? (... attr 0)) (== @fill_vert (byte \space))) (byte \|) @fill_vert)
    ))

;; Return true if redrawing should currently be done.

(defn- #_boolean redrawing []
    (and (zero? @redrawingDisabled) (not (and @p_lz (char-avail) (not @keyTyped) (not @do_redraw)))))

;; Return true if printing messages should currently be done.

(defn- #_boolean messaging []
    (not (and @p_lz (char-avail) (not @keyTyped))))

;; Show current status info in ruler and various other places.
;; If always is false, only show ruler if position has changed.

(defn- #_void showruler [#_boolean always]
    (if (or always (redrawing))
        (win-redr-ruler @curwin, always)
    )
    nil)

(defn- #_void win-redr-ruler [#_window_C wp, #_boolean always]
    (ยง
        ;; If 'ruler' off or redrawing disabled, don't do anything.
        (if (not @p_ru)
            ((ร RETURN) nil)
        )

        ;; Check if cursor.lnum is valid, since win-redr-ruler() may be called
        ;; after deleting lines, before cursor.lnum is corrected.

        (if (< (:ml_line_count (:b_ml @curbuf)) (:lnum (:w_cursor wp)))
            ((ร RETURN) nil)
        )

        ;; Check if not in Insert mode and the line is empty (will show "0-1").

        ((ร boolean empty_line =) false)
        (if (and (non-flag? @State INSERT) (== (.at (ml-get-buf @curbuf, (:lnum (:w_cursor wp))) 0) NUL))
            ((ร empty_line =) true)
        )

        ;; Only draw the ruler when something changed.

        (validate-virtcol-win wp)
        (when (or @redraw_cmdline always (!= (:lnum (:w_cursor wp)) (:lnum (:w_ru_cursor wp))) (!= (:col (:w_cursor wp)) (:col (:w_ru_cursor wp))) (!= (:w_virtcol wp) (:w_ru_virtcol wp)) (!= (:coladd (:w_cursor wp)) (:coladd (:w_ru_cursor wp))) (!= (:w_topline wp) (:w_ru_topline wp)) (!= (:ml_line_count (:b_ml @curbuf)) (:w_ru_line_count wp)) (!= empty_line (:w_ru_empty wp)))
            (cursor-off)

            (ร int row, fillchar, off, width)
            ((ร int[] attr =) (ร new int[1]))
            (cond (non-zero? (:w_status_height wp))
            (do
                ((ร row =) (+ (:w_winrow wp) (:w_height wp)))
                ((ร fillchar =) (fillchar-status attr, (== wp @curwin)))
                ((ร off =) (:w_wincol wp))
                ((ร width =) (:w_width wp))
            )
            :else
            (do
                ((ร row =) (dec (int @Rows)))
                ((ร fillchar =) (byte \space))
                ((ร attr[0] =) 0)
                ((ร off =) 0)
                ((ร width =) (int @Cols))
            ))

            ((ร final int RULER_BUF_LEN =) 70)
            ((ร Bytes buffer =) (Bytes. RULER_BUF_LEN))

            ;; Some sprintfs return the length, some return a pointer.
            ;; To avoid portability problems we use STRLEN() here.

;%%         (vim_snprintf buffer, RULER_BUF_LEN, (u8 "%ld,"), (if (!= (& (:ml_flags (:b_ml @curbuf)) ML_EMPTY) 0) 0 (:lnum (:w_cursor wp))))
            ((ร int len =) (STRLEN buffer))
            (col-print (.plus buffer len), (- RULER_BUF_LEN len), (if empty_line 0 (+ (:col (:w_cursor wp)) 1)), (+ (:w_virtcol wp) 1))

            ;; Add a "50%" if there is room for it.
            ;; On the last line, don't print in the last column
            ;; (scrolls the screen up on some terminals).

            ((ร int ii =) (STRLEN buffer))
            (get-rel-pos wp, (.plus buffer (inc ii)), (- RULER_BUF_LEN ii 1))
            ((ร int oo =) (+ ii (mb-string2cells (.plus buffer (inc ii)), -1)))
            (if (zero? (:w_status_height wp))    ;; can't use last char of screen
                (ร oo++)
            )
            ((ร int this_ru_col =) (- @ru_col (- (int @Cols) width)))
            (if (< this_ru_col 0)
                ((ร this_ru_col =) 0)
            )
            ;; Never use more than half the window/screen width,
            ;; leave the other half for the filename.
            (if (< this_ru_col (/ (inc width) 2))
                ((ร this_ru_col =) (/ (inc width) 2))
            )
            (when (< (+ this_ru_col oo) width)
                ;; need at least 3 chars left for get-rel-pos() + NUL
                (while (and (< (+ this_ru_col oo) width) (< (+ ii 4) RULER_BUF_LEN))
                    ((ร ii =) (+ ii (utf-char2bytes fillchar, (.plus buffer ii))))
                    (ร oo++)
                )
                (get-rel-pos wp, (.plus buffer ii), (- RULER_BUF_LEN ii))
            )

            ;; Truncate at window boundary.
            ((ร int ooo =) 0)
            ((ร FOR) (ร ((ร int i =) 0) (non-eos? buffer i) ((ร i =) (+ i (us-ptr2len-cc (.plus buffer i)))))
                ((ร ooo =) (+ ooo (us-ptr2cells (.plus buffer i))))
                (when (< width (+ this_ru_col ooo))
                    (eos! buffer i)
                    (ร BREAK)
                )
            )

            (screen-puts buffer, row, (+ this_ru_col off), (... attr 0))
            ((ร boolean iii =) @redraw_cmdline)
            (screen-fill row, (inc row), (+ this_ru_col off (STRLEN buffer)), (+ off width), fillchar, fillchar, (... attr 0))
            ;; don't redraw the cmdline because of showing the ruler
            (reset! redraw_cmdline iii)
            (COPY-pos (:w_ru_cursor wp), (:w_cursor wp))
            ((ร wp.w_ru_virtcol =) (:w_virtcol wp))
            ((ร wp.w_ru_empty =) empty_line)
            ((ร wp.w_ru_topline =) (:w_topline wp))
            ((ร wp.w_ru_line_count =) (:ml_line_count (:b_ml @curbuf)))
        )
        nil
    ))

;; Return the width of the 'number' and 'relativenumber' column.
;; Caller may need to check if 'number' or 'relativenumber' is set.
;; Otherwise it depends on 'numberwidth' and the line count.

(defn- #_int number-width [#_window_C wp]
    (ยง
        (ร long lnum)
        (cond (and @(:wo_rnu (:w_options wp)) (not @(:wo_nu (:w_options wp))))
        (do
            ;; cursor line shows "0"
            ((ร lnum =) (:w_height wp))
        )
        :else
        (do
            ;; cursor line shows absolute line number
            ((ร lnum =) (:ml_line_count (:b_ml @curbuf)))
        ))

        (if (and (== lnum (:w_nrwidth_line_count wp)) (== (:w_nuw_cached wp) @(:wo_nuw (:w_options wp))))
            ((ร RETURN) (:w_nrwidth_width wp))
        )

        ((ร wp.w_nrwidth_line_count =) lnum)

        ((ร int n =) 0)
;       do
;       {
            ((ร lnum =) (/ lnum 10))
            (ร n++)
;       } while (0 < lnum);

        ;; 'numberwidth' gives the minimal width plus one
        (if (< n (- @(:wo_nuw (:w_options wp)) 1))
            ((ร n =) (- (int @(:wo_nuw (:w_options wp))) 1))
        )

        ((ร wp.w_nrwidth_width =) n)
        ((ร wp.w_nuw_cached =) @(:wo_nuw (:w_options wp)))
        n
    ))

;; Return the current cursor column.  This is the actual position on the screen.
;; First column is 0.

(defn- #_int screen-screencol []
    @screen_cur_col)

;; Return the current cursor row.  This is the actual position on the screen.
;; First row is 0.

(defn- #_int screen-screenrow []
    @screen_cur_row)

;;; ============================================================================================== VimW

;; window.c ---------------------------------------------------------------------------------------

(final window_C NOWIN (NEW_window_C))         ;; non-existing window

(final Bytes m_onlyone (u8 "Already only one window"))

;; all CTRL-W window commands are handled here, called from normal-cmd().

(defn- #_void do-window [#_int nchar, #_long Prenum, #_int xchar]
    ;; xchar: extra char from ":wincmd gx" or NUL
    (ยง
        ((ร Bytes cbuf =) (Bytes. 40))

        ((ร long Prenum1 =) (if (zero? Prenum) 1 Prenum))

        ((ร SWITCH) nchar
            ;; split current window in two parts, horizontally
            ((ร CASE) (byte \S))
            ((ร CASE) Ctrl_S)
            ((ร CASE) (byte \s))
            (do
                (when (non-zero? @cmdwin_type)
                    (emsg e_cmdwin)
                    (ร BREAK)
                )
                (reset-VIsual-and-resel)
                (win-split (int Prenum), 0)
                (ร BREAK)
            )

            ;; split current window in two parts, vertically
            ((ร CASE) Ctrl_V)
            ((ร CASE) (byte \v))
            (do
                (when (non-zero? @cmdwin_type)
                    (emsg e_cmdwin)
                    (ร BREAK)
                )
                (reset-VIsual-and-resel)
                (win-split (int Prenum), WSP_VERT)
                (ร BREAK)
            )

            ;; quit current window
            ((ร CASE) Ctrl_Q)
            ((ร CASE) (byte \q))
            (do
                (reset-VIsual-and-resel)
                (cmd-with-count (u8 "quit"), cbuf, (.size cbuf), Prenum)
                (do-cmdline-cmd cbuf)
                (ร BREAK)
            )

            ;; close current window
            ((ร CASE) Ctrl_C)
            ((ร CASE) (byte \c))
            (do
                (reset-VIsual-and-resel)
                (cmd-with-count (u8 "close"), cbuf, (.size cbuf), Prenum)
                (do-cmdline-cmd cbuf)
                (ร BREAK)
            )

            ;; close all but current window
            ((ร CASE) Ctrl_O)
            ((ร CASE) (byte \o))
            (do
                (when (non-zero? @cmdwin_type)
                    (emsg e_cmdwin)
                    (ร BREAK)
                )
                (reset-VIsual-and-resel)
                (cmd-with-count (u8 "only"), cbuf, (.size cbuf), Prenum)
                (do-cmdline-cmd cbuf)
                (ร BREAK)
            )

            ;; cursor to next window with wrap around
            ((ร CASE) Ctrl_W)
            ((ร CASE) (byte \w))
            ;; cursor to previous window with wrap around
            ((ร CASE) (byte \W))
            (do
                (when (non-zero? @cmdwin_type)
                    (emsg e_cmdwin)
                    (ร BREAK)
                )
                (cond (and (== @firstwin @lastwin) (!= Prenum 1)) ;; just one window
                (do
                    (beep-flush)
                )
                :else
                (do
                    (ร window_C wp)
                    (cond (non-zero? Prenum)                    ;; go to specified window
                    (do
                        ((ร FOR) (ร ((ร wp =) @firstwin) (< 0 (ร --Prenum)) nil)
                            (if (nil? (:w_next wp))
                                (ร BREAK)
                                ((ร wp =) (:w_next wp))
                            )
                        )
                    )
                    :else
                    (do
                        (cond (== nchar (byte \W))           ;; go to previous window
                        (do
                            ((ร wp =) (:w_prev @curwin))
                            (if (nil? wp)
                                ((ร wp =) @lastwin)       ;; wrap around
                            )
                        )
                        :else                        ;; go to next window
                        (do
                            ((ร wp =) (:w_next @curwin))
                            (if (nil? wp)
                                ((ร wp =) @firstwin)      ;; wrap around
                            )
                        ))
                    ))
                    (win-goto wp)
                ))
                (ร BREAK)
            )

            ;; cursor to window below
            ((ร CASE) (byte \j))
            ((ร CASE) K_DOWN)
            ((ร CASE) Ctrl_J)
            (do
                (when (non-zero? @cmdwin_type)
                    (emsg e_cmdwin)
                    (ร BREAK)
                )
                (win-goto-ver false, Prenum1)
                (ร BREAK)
            )

            ;; cursor to window above
            ((ร CASE) (byte \k))
            ((ร CASE) K_UP)
            ((ร CASE) Ctrl_K)
            (do
                (when (non-zero? @cmdwin_type)
                    (emsg e_cmdwin)
                    (ร BREAK)
                )
                (win-goto-ver true, Prenum1)
                (ร BREAK)
            )

            ;; cursor to left window
            ((ร CASE) (byte \h))
            ((ร CASE) K_LEFT)
            ((ร CASE) Ctrl_H)
            ((ร CASE) K_BS)
            (do
                (when (non-zero? @cmdwin_type)
                    (emsg e_cmdwin)
                    (ร BREAK)
                )
                (win-goto-hor true, Prenum1)
                (ร BREAK)
            )

            ;; cursor to right window
            ((ร CASE) (byte \l))
            ((ร CASE) K_RIGHT)
            ((ร CASE) Ctrl_L)
            (do
                (when (non-zero? @cmdwin_type)
                    (emsg e_cmdwin)
                    (ร BREAK)
                )
                (win-goto-hor false, Prenum1)
                (ร BREAK)
            )

            ;; cursor to top-left window
            ((ร CASE) (byte \t))
            ((ร CASE) Ctrl_T)
            (do
                (win-goto @firstwin)
                (ร BREAK)
            )

            ;; cursor to bottom-right window
            ((ร CASE) (byte \b))
            ((ร CASE) Ctrl_B)
            (do
                (win-goto @lastwin)
                (ร BREAK)
            )

            ;; cursor to last accessed (previous) window
            ((ร CASE) (byte \p))
            ((ร CASE) Ctrl_P)
            (do
                (if (nil? @prevwin)
                    (beep-flush)
                    (win-goto @prevwin))
                (ร BREAK)
            )

            ;; exchange current and next window
            ((ร CASE) (byte \x))
            ((ร CASE) Ctrl_X)
            (do
                (when (non-zero? @cmdwin_type)
                    (emsg e_cmdwin)
                    (ร BREAK)
                )
                (win-exchange Prenum)
                (ร BREAK)
            )

            ;; rotate windows downwards
            ((ร CASE) Ctrl_R)
            ((ร CASE) (byte \r))
            (do
                (when (non-zero? @cmdwin_type)
                    (emsg e_cmdwin)
                    (ร BREAK)
                )
                (reset-VIsual-and-resel)
                (win-rotate false, (int Prenum1))
                (ร BREAK)
            )

            ;; rotate windows upwards
            ((ร CASE) (byte \R))
            (do
                (when (non-zero? @cmdwin_type)
                    (emsg e_cmdwin)
                    (ร BREAK)
                )
                (reset-VIsual-and-resel)
                (win-rotate true, (int Prenum1))
                (ร BREAK)
            )

            ;; move window to the very top/bottom/left/right
            ((ร CASE) (byte \K))
            ((ร CASE) (byte \J))
            ((ร CASE) (byte \H))
            ((ร CASE) (byte \L))
            (do
                (when (non-zero? @cmdwin_type)
                    (emsg e_cmdwin)
                    (ร BREAK)
                )
                (win-totop (int Prenum), (| (if (or (== nchar (byte \H)) (== nchar (byte \L))) WSP_VERT 0) (if (or (== nchar (byte \H)) (== nchar (byte \K))) WSP_TOP WSP_BOT)))
                (ร BREAK)
            )

            ;; make all windows the same height
            ((ร CASE) (byte \=))
            (do
                (win-equal nil, false, (byte \b))
                (ร BREAK)
            )

            ;; increase current window height
            ((ร CASE) (byte \+))
            (do
                (win-setheight (+ (:w_height @curwin) (int Prenum1)))
                (ร BREAK)
            )

            ;; decrease current window height
            ((ร CASE) (byte \-))
            (do
                (win-setheight (- (:w_height @curwin) (int Prenum1)))
                (ร BREAK)
            )

            ;; set current window height
            ((ร CASE) Ctrl__)
            ((ร CASE) (byte \_))
            (do
                (win-setheight (if (non-zero? Prenum) (int Prenum) 9999))
                (ร BREAK)
            )

            ;; increase current window width
            ((ร CASE) (byte \>))
            (do
                (win-setwidth (+ (:w_width @curwin) (int Prenum1)))
                (ร BREAK)
            )

            ;; decrease current window width
            ((ร CASE) (byte \<))
            (do
                (win-setwidth (- (:w_width @curwin) (int Prenum1)))
                (ร BREAK)
            )

            ;; set current window width
            ((ร CASE) (byte \|))
            (do
                (win-setwidth (if (non-zero? Prenum) (int Prenum) 9999))
                (ร BREAK)
            )

            ;; jump to tag and split window if tag exists (in preview window)
            ((ร CASE) (byte \]))
            ((ร CASE) Ctrl_RSB)
            (do
                (when (non-zero? @cmdwin_type)
                    (emsg e_cmdwin)
                    (ร BREAK)
                )
                ;; keep Visual mode, can select words to use as a tag
                (if (non-zero? Prenum)
                    (reset! postponed_split (int Prenum))
                    (reset! postponed_split -1))

                ;; Execute the command right here,
                ;; required when "wincmd ]" was used in a function.
                (do-nv-ident Ctrl_RSB, NUL)
                (ร BREAK)
            )

            ((ร CASE) K_KENTER)
            ((ร CASE) CAR)
            (do
                (ร BREAK)
            )

            ;; CTRL-W g extended commands.
            ((ร CASE) (byte \g))
            ((ร CASE) Ctrl_G)
            (do
                (when (non-zero? @cmdwin_type)
                    (emsg e_cmdwin)
                    (ร BREAK)
                )
                (swap! no_mapping inc)
                (swap! allow_keys inc)       ;; no mapping for xchar, but allow key codes
                (if (== xchar NUL)
                    ((ร xchar =) (plain-vgetc))
                )
                (swap! no_mapping dec)
                (swap! allow_keys dec)
                (add-to-showcmd xchar)
                ((ร SWITCH) xchar
                    ((ร CASE) (byte \]))
                    ((ร CASE) Ctrl_RSB)
                    (do
                        ;; keep Visual mode, can select words to use as a tag
                        (if (non-zero? Prenum)
                            (reset! postponed_split (int Prenum))
                            (reset! postponed_split -1))

                        ;; Execute the command right here,
                        ;; required when "wincmd g}" was used in a function.
                        (do-nv-ident (byte \g), xchar)
                        (ร BREAK)
                    )

                    (ร DEFAULT)
                    (do
                        (beep-flush)
                        (ร BREAK)
                    )
                )
                (ร BREAK)
            )

            (ร DEFAULT)
            (do
                (beep-flush)
                (ร BREAK)
            )
        )
        nil
    ))

(defn- #_void cmd-with-count [#_Bytes cmd, #_Bytes bufp, #_int bufsize, #_long Prenum]
    (ยง
        ((ร int len =) (STRLEN cmd))

        (STRCPY bufp, cmd)
        (when (< 0 Prenum)
;%%         (vim_snprintf (.plus bufp len), (- bufsize len), (u8 "%ld"), Prenum)
        )
        nil
    ))

;; split the current window, implements CTRL-W s and :split
;;
;; "size" is the height or width for the new window, 0 to use half of current height or width.
;;
;; "flags":
;; WSP_VERT: vertical split.
;; WSP_TOP:  open window at the top-left of the shell (help window).
;; WSP_BOT:  open window at the bottom-right of the shell (quickfix window).
;;
;; return false for failure, true otherwise

(defn- #_boolean win-split [#_int size, #_int flags]
    (ยง
        (when (and (flag? flags WSP_TOP) (flag? flags WSP_BOT))
            (emsg (u8 "E442: Can't split topleft and botright at the same time"))
            ((ร RETURN) false)
        )

        (win-split-ins size, flags, nil, 0)
    ))

;; When "new_wp" is null: split the current window in two.
;; When "new_wp" is not null: insert this window at the far top/left/right/bottom.
;; return false for failure, true otherwise

(defn- #_boolean win-split-ins [#_int size, #_int flags, #_window_C new_wp, #_int dir]
    (ยง
        ((ร int new_size =) size)
        ((ร boolean do_equal =) false)
        ((ร int oldwin_height =) 0)

        (ร window_C oldwin)
        (cond (flag? flags WSP_TOP)
        (do
            ((ร oldwin =) @firstwin)
        )
        (flag? flags WSP_BOT)
        (do
            ((ร oldwin =) @lastwin)
        )
        :else
        (do
            ((ร oldwin =) @curwin)
        ))

        ((ร int need_status =) 0)
        ;; add a status line when p_ls == 1 and splitting the first window
        (when (and (== @lastwin @firstwin) (== @p_ls 1) (zero? (:w_status_height oldwin)))
            (when (and (<= (:w_height oldwin) @p_wmh) (nil? new_wp))
                (emsg e_noroom)
                ((ร RETURN) false)
            )
            ((ร need_status =) STATUS_HEIGHT)
        )

        (ร byte layout)
        (cond (flag? flags WSP_VERT)
        (do
            ((ร layout =) FR_ROW)

            ;; Check if we are able to split the current window and compute its width.

            ;; Current window requires at least 1 space.
            ((ร int wmw1 =) (if (== @p_wmw 0) 1 (int @p_wmw)))
            ((ร int needed =) (inc wmw1))
            (ร int minwidth)
            (ร int available)
            (cond (flag? flags (| WSP_BOT WSP_TOP))
            (do
                ((ร minwidth =) (frame-minwidth @topframe, NOWIN))
                ((ร available =) (:fr_width @topframe))
                ((ร needed =) (+ needed minwidth))
            )
            @p_ea
            (do
                ((ร minwidth =) (frame-minwidth (:w_frame oldwin), NOWIN))
                ((ร frame_C prevfrp =) (:w_frame oldwin))
                ((ร FOR) (ร ((ร frame_C frp =) (:fr_parent (:w_frame oldwin))) (non-nil? frp) ((ร frp =) (:fr_parent frp)))
                    (when (== (:fr_layout frp) FR_ROW)
                        ((ร FOR) (ร ((ร frame_C frp2 =) (:fr_child frp)) (non-nil? frp2) ((ร frp2 =) (:fr_next frp2)))
                            (if (!= frp2 prevfrp)
                                ((ร minwidth =) (+ minwidth (frame-minwidth frp2, NOWIN)))
                            )
                        )
                    )
                    ((ร prevfrp =) frp)
                )
                ((ร available =) (:fr_width @topframe))
                ((ร needed =) (+ needed minwidth))
            )
            :else
            (do
                ((ร minwidth =) (frame-minwidth (:w_frame oldwin), NOWIN))
                ((ร available =) (:fr_width (:w_frame oldwin)))
                ((ร needed =) (+ needed minwidth))
            ))
            (when (and (< available needed) (nil? new_wp))
                (emsg e_noroom)
                ((ร RETURN) false)
            )
            (if (zero? new_size)
                ((ร new_size =) (/ (:w_width oldwin) 2))
            )
            (if (> new_size (- available minwidth 1))
                ((ร new_size =) (- available minwidth 1))
            )
            (if (< new_size wmw1)
                ((ร new_size =) wmw1)
            )

            ;; if it doesn't fit in the current window, need win-equal()
            (if (< (- (:w_width oldwin) new_size 1) @p_wmw)
                ((ร do_equal =) true)
            )

            ;; We don't like to take lines for the new window from a 'winfixwidth' window.
            ;; Take them from a window to the left or right instead, if possible.
            (if @(:wo_wfw (:w_options oldwin))
                (win-setwidth-win (+ (:w_width oldwin) new_size), oldwin))

            ;; Only make all windows the same width if one of them (except oldwin)
            ;; is wider than one of the split windows.
            (when (and (not do_equal) @p_ea (zero? size) (!= (.at @p_ead 0) (byte \v)) (non-nil? (:fr_parent (:w_frame oldwin))))
                ((ร frame_C frp =) (:fr_child (:fr_parent (:w_frame oldwin))))
                (while (non-nil? frp)
                    (when (and (!= (:fr_win frp) oldwin) (non-nil? (:fr_win frp)) (or (< new_size (:w_width (:fr_win frp))) (< (- (:w_width oldwin) new_size 1) (:w_width (:fr_win frp)))))
                        ((ร do_equal =) true)
                        (ร BREAK)
                    )
                    ((ร frp =) (:fr_next frp))
                )
            )
        )
        :else
        (do
            ((ร layout =) FR_COL)

            ;; Check if we are able to split the current window and compute its height.

            ;; Current window requires at least 1 space.
            ((ร int wmh1 =) (if (== @p_wmh 0) 1 (int @p_wmh)))
            ((ร int needed =) (+ wmh1 STATUS_HEIGHT))
            (ร int minheight)
            (ร int available)
            (cond (flag? flags (| WSP_BOT WSP_TOP))
            (do
                ((ร minheight =) (+ (frame-minheight @topframe, NOWIN) need_status))
                ((ร available =) (:fr_height @topframe))
                ((ร needed =) (+ needed minheight))
            )
            @p_ea
            (do
                ((ร minheight =) (+ (frame-minheight (:w_frame oldwin), NOWIN) need_status))
                ((ร frame_C prevfrp =) (:w_frame oldwin))
                ((ร FOR) (ร ((ร frame_C frp =) (:fr_parent (:w_frame oldwin))) (non-nil? frp) ((ร frp =) (:fr_parent frp)))
                    (when (== (:fr_layout frp) FR_COL)
                        ((ร FOR) (ร ((ร frame_C frp2 =) (:fr_child frp)) (non-nil? frp2) ((ร frp2 =) (:fr_next frp2)))
                            (if (!= frp2 prevfrp)
                                ((ร minheight =) (+ minheight (frame-minheight frp2, NOWIN)))
                            )
                        )
                    )
                    ((ร prevfrp =) frp)
                )
                ((ร available =) (:fr_height @topframe))
                ((ร needed =) (+ needed minheight))
            )
            :else
            (do
                ((ร minheight =) (+ (frame-minheight (:w_frame oldwin), NOWIN) need_status))
                ((ร available =) (:fr_height (:w_frame oldwin)))
                ((ร needed =) (+ needed minheight))
            ))
            (when (and (< available needed) (nil? new_wp))
                (emsg e_noroom)
                ((ร RETURN) false)
            )
            ((ร oldwin_height =) (:w_height oldwin))
            (when (non-zero? need_status)
                ((ร oldwin.w_status_height =) STATUS_HEIGHT)
                ((ร oldwin_height =) (- oldwin_height STATUS_HEIGHT))
            )
            (if (zero? new_size)
                ((ร new_size =) (/ oldwin_height 2))
            )
            (if (> new_size (- available minheight STATUS_HEIGHT))
                ((ร new_size =) (- available minheight STATUS_HEIGHT))
            )
            (if (< new_size wmh1)
                ((ร new_size =) wmh1)
            )

            ;; if it doesn't fit in the current window, need win-equal()
            (if (< (- oldwin_height new_size STATUS_HEIGHT) @p_wmh)
                ((ร do_equal =) true)
            )

            ;; We don't like to take lines for the new window from a 'winfixheight' window.
            ;; Take them from a window above or below instead, if possible.
            (when @(:wo_wfh (:w_options oldwin))
                (win-setheight-win (+ (:w_height oldwin) new_size STATUS_HEIGHT), oldwin)
                ((ร oldwin_height =) (:w_height oldwin))
                (if (non-zero? need_status)
                    ((ร oldwin_height =) (- oldwin_height STATUS_HEIGHT))
                )
            )

            ;; Only make all windows the same height if one of them (except oldwin)
            ;; is higher than one of the split windows.
            (when (and (not do_equal) @p_ea (zero? size) (!= (.at @p_ead 0) (byte \h)) (non-nil? (:fr_parent (:w_frame oldwin))))
                ((ร frame_C frp =) (:fr_child (:fr_parent (:w_frame oldwin))))
                (while (non-nil? frp)
                    (when (and (!= (:fr_win frp) oldwin) (non-nil? (:fr_win frp)) (or (< new_size (:w_height (:fr_win frp))) (< (- oldwin_height new_size STATUS_HEIGHT) (:w_height (:fr_win frp)))))
                        ((ร do_equal =) true)
                        (ร BREAK)
                    )
                    ((ร frp =) (:fr_next frp))
                )
            )
        ))

        ((ร window_C wp =) new_wp)

        ;; allocate new window structure and link it in the window list

        (cond (and (non-flag? flags WSP_TOP) (or (flag? flags WSP_BOT) (flag? flags WSP_BELOW) (and (non-flag? flags WSP_ABOVE) (if (flag? flags WSP_VERT) @p_spr @p_sb))))
        (do
            ;; new window below/right of current one
            (if (nil? new_wp)
                ((ร wp =) (newWindow oldwin))
                (win-append oldwin, wp))
        )
        :else
        (do
            (if (nil? new_wp)
                ((ร wp =) (newWindow (:w_prev oldwin)))
                (win-append (:w_prev oldwin), wp))
        ))

        (when (nil? new_wp)
            (if (nil? wp)
                ((ร RETURN) false)
            )

            ((ร wp.w_frame =) (newFrame wp))

            ;; make the contents of the new window the same as the current one
            (win-init wp, @curwin)
        )

        ;; Reorganise the tree of frames to insert the new window.

        (ร frame_C curfrp)
        (ร boolean before)
        (cond (flag? flags (| WSP_TOP WSP_BOT))
        (do
            (cond (or (and (== (:fr_layout @topframe) FR_COL) (non-flag? flags WSP_VERT)) (and (== (:fr_layout @topframe) FR_ROW) (flag? flags WSP_VERT)))
            (do
                ((ร curfrp =) (:fr_child @topframe))
                (when (flag? flags WSP_BOT)
                    (while (non-nil? (:fr_next curfrp))
                        ((ร curfrp =) (:fr_next curfrp))
                    )
                )
            )
            :else
            (do
                ((ร curfrp =) @topframe)
            ))
            ((ร before =) (flag? flags WSP_TOP))
        )
        :else
        (do
            ((ร curfrp =) (:w_frame oldwin))
            (cond (flag? flags WSP_BELOW)
            (do
                ((ร before =) false)
            )
            (flag? flags WSP_ABOVE)
            (do
                ((ร before =) true)
            )
            (flag? flags WSP_VERT)
            (do
                ((ร before =) (not @p_spr))
            )
            :else
            (do
                ((ร before =) (not @p_sb))
            ))
        ))

        (when (or (nil? (:fr_parent curfrp)) (!= (:fr_layout (:fr_parent curfrp)) layout))
            ;; Need to create a new frame in the tree to make a branch.
            ((ร frame_C frp =) (NEW_frame_C))
            (COPY-frame frp, curfrp)
            ((ร curfrp.fr_layout =) layout)
            ((ร frp.fr_parent =) curfrp)
            ((ร frp.fr_next =) nil)
            ((ร frp.fr_prev =) nil)
            ((ร curfrp.fr_child =) frp)
            ((ร curfrp.fr_win =) nil)
            ((ร curfrp =) frp)
            (cond (non-nil? (:fr_win frp))
            (do
                ((ร oldwin.w_frame =) frp)
            )
            :else
            (do
                ((ร FOR) (ร ((ร frp =) (:fr_child frp)) (non-nil? frp) ((ร frp =) (:fr_next frp)))
                    ((ร frp.fr_parent =) curfrp)
                )
            ))
        )

        ((ร frame_C frp =) (if (nil? new_wp) (:w_frame wp) (:w_frame new_wp)))
        ((ร frp.fr_parent =) (:fr_parent curfrp))

        ;; Insert the new frame at the right place in the frame list.
        (if before
            (frame-insert curfrp, frp)
            (frame-append curfrp, frp))

        ;; Set w_fraction now so that the cursor keeps the same relative vertical position.
        (if (< 0 (:w_height oldwin))
            (set-fraction oldwin))
        ((ร wp.w_fraction =) (:w_fraction oldwin))

        (cond (flag? flags WSP_VERT)
        (do
            ((ร wp.w_options.@wo_scr =) @(:wo_scr (:w_options @curwin)))

            (when (non-zero? need_status)
                (win-new-height oldwin, (- (:w_height oldwin) 1))
                ((ร oldwin.w_status_height =) need_status)
            )
            (cond (flag? flags (| WSP_TOP WSP_BOT))
            (do
                ;; set height and row of new window to full height
                ((ร wp.w_winrow =) 0)
                (win-new-height wp, (- (:fr_height curfrp) (if (< 0 @p_ls) 1 0)))
                ((ร wp.w_status_height =) (if (< 0 @p_ls) 1 0))
            )
            :else
            (do
                ;; height and row of new window is same as current window
                ((ร wp.w_winrow =) (:w_winrow oldwin))
                (win-new-height wp, (:w_height oldwin))
                ((ร wp.w_status_height =) (:w_status_height oldwin))
            ))
            ((ร frp.fr_height =) (:fr_height curfrp))

            ;; "new_size" of the current window goes to the new window,
            ;; use one column for the vertical separator
            (win-new-width wp, new_size)
            (cond before
            (do
                ((ร wp.w_vsep_width =) 1)
            )
            :else
            (do
                ((ร wp.w_vsep_width =) (:w_vsep_width oldwin))
                ((ร oldwin.w_vsep_width =) 1)
            ))
            (cond (flag? flags (| WSP_TOP WSP_BOT))
            (do
                (if (flag? flags WSP_BOT)
                    (frame-add-vsep curfrp))
                ;; Set width of neighbor frame.
                (frame-new-width curfrp, (- (:fr_width curfrp) (+ new_size (if (flag? flags WSP_TOP) 1 0))), (flag? flags WSP_TOP), false)
            )
            :else
            (do
                (win-new-width oldwin, (- (:w_width oldwin) (inc new_size)))
            ))
            (cond before     ;; new window left of current one
            (do
                ((ร wp.w_wincol =) (:w_wincol oldwin))
                ((ร oldwin.w_wincol =) (+ (:w_wincol oldwin) (inc new_size)))
            )
            :else            ;; new window right of current one
            (do
                ((ร wp.w_wincol =) (+ (:w_wincol oldwin) (:w_width oldwin) 1))
            ))
            (frame-fix-width oldwin)
            (frame-fix-width wp)
        )
        :else
        (do
            ;; width and column of new window is same as current window
            (cond (flag? flags (| WSP_TOP WSP_BOT))
            (do
                ((ร wp.w_wincol =) 0)
                (win-new-width wp, (int @Cols))
                ((ร wp.w_vsep_width =) 0)
            )
            :else
            (do
                ((ร wp.w_wincol =) (:w_wincol oldwin))
                (win-new-width wp, (:w_width oldwin))
                ((ร wp.w_vsep_width =) (:w_vsep_width oldwin))
            ))
            ((ร frp.fr_width =) (:fr_width curfrp))

            ;; "new_size" of the current window goes to the new window,
            ;; use one row for the status line
            (win-new-height wp, new_size)
            (if (flag? flags (| WSP_TOP WSP_BOT))
                (frame-new-height curfrp, (- (:fr_height curfrp) (+ new_size STATUS_HEIGHT)), (flag? flags WSP_TOP), false)
                (win-new-height oldwin, (- oldwin_height (+ new_size STATUS_HEIGHT))))
            (cond before     ;; new window above current one
            (do
                ((ร wp.w_winrow =) (:w_winrow oldwin))
                ((ร wp.w_status_height =) STATUS_HEIGHT)
                ((ร oldwin.w_winrow =) (+ (:w_winrow oldwin) (+ (:w_height wp) STATUS_HEIGHT)))
            )
            :else            ;; new window below current one
            (do
                ((ร wp.w_winrow =) (+ (:w_winrow oldwin) (:w_height oldwin) STATUS_HEIGHT))
                ((ร wp.w_status_height =) (:w_status_height oldwin))
                ((ร oldwin.w_status_height =) STATUS_HEIGHT)
            ))
            (if (flag? flags WSP_BOT)
                (frame-add-statusline curfrp))
            (frame-fix-height wp)
            (frame-fix-height oldwin)
        ))

        (if (flag? flags (| WSP_TOP WSP_BOT))
            (win-comp-pos))

        ;; Both windows need redrawing

        (redraw-win-later wp, NOT_VALID)
        ((ร wp.w_redr_status =) true)
        (redraw-win-later oldwin, NOT_VALID)
        ((ร oldwin.w_redr_status =) true)

        (when (non-zero? need_status)
            (reset! msg_row (dec (int @Rows)))
            (reset! msg_col @sc_col)
            (msg-clr-eos-force)    ;; old command/ruler may still be there
            (comp-col)
            (reset! msg_row (dec (int @Rows)))
            (reset! msg_col 0)            ;; put position back at start of line
        )

        ;; equalize the window sizes.

        (if (or do_equal (non-zero? dir))
            (win-equal wp, true, (if (flag? flags WSP_VERT) (if (== dir (byte \v)) (byte \b) (byte \h)) (if (== dir (byte \h)) (byte \b) (byte \v)))))

        ;; Don't change the window height/width to 'winheight' / 'winwidth' if a size was given.
        (ร int i)
        (cond (flag? flags WSP_VERT)
        (do
            ((ร i =) (int @p_wiw))
            (if (non-zero? size)
                (reset! p_wiw size))
        )
        :else
        (do
            ((ร i =) (int @p_wh))
            (if (non-zero? size)
                (reset! p_wh size))
        ))

        ;; Keep same changelist position in new window.
        ((ร wp.w_changelistidx =) (:w_changelistidx oldwin))

        ;; make the new window the current window

        (win-enter wp)
        (if (flag? flags WSP_VERT)
            (reset! p_wiw i)
            (reset! p_wh i))

        true
    ))

;; Initialize window "newp" from window "oldp".
;; Used when splitting a window and when creating a new tab page.
;; The windows will both edit the same buffer.

(defn- #_void win-init [#_window_C newp, #_window_C oldp]
    (ยง
        (ร @curbuf.b_nwindows++)

        (COPY-pos (:w_cursor newp), (:w_cursor oldp))
        ((ร newp.w_valid =) 0)
        ((ร newp.w_curswant =) (:w_curswant oldp))
        ((ร newp.w_set_curswant =) (:w_set_curswant oldp))
        ((ร newp.w_topline =) (:w_topline oldp))
        ((ร newp.w_leftcol =) (:w_leftcol oldp))
        (COPY-pos (:w_pcmark newp), (:w_pcmark oldp))
        (COPY-pos (:w_prev_pcmark newp), (:w_prev_pcmark oldp))
        ((ร newp.w_wrow =) (:w_wrow oldp))
        ((ร newp.w_fraction =) (:w_fraction oldp))
        ((ร newp.w_prev_fraction_row =) (:w_prev_fraction_row oldp))
        (copy-jumplist oldp, newp)

        ;; copy options from existing window
        (win-copy-options oldp, newp)

        (check-colorcolumn newp)
        nil
    ))

;; Check if "win" is a pointer to an existing window.

(defn- #_boolean win-valid [#_window_C win]
    (ยง
        (if (nil? win)
            ((ร RETURN) false)
        )

        ((ร FOR) (ร ((ร window_C wp =) @firstwin) (non-nil? wp) ((ร wp =) (:w_next wp)))
            (if (== wp win)
                ((ร RETURN) true)
            )
        )

        false
    ))

;; Exchange current and next window

(defn- #_void win-exchange [#_long Prenum]
    (ยง
        (when (== @lastwin @firstwin)        ;; just one window
            (beep-flush)
            ((ร RETURN) nil)
        )

        (ร frame_C frp)

        ;; find window to exchange with

        (cond (non-zero? Prenum)
        (do
            ((ร frp =) (:fr_child (:fr_parent (:w_frame @curwin))))
            (while (and (non-nil? frp) (< 0 (ร --Prenum)))
                ((ร frp =) (:fr_next frp))
            )
        )
        (non-nil? (:fr_next (:w_frame @curwin)))    ;; Swap with next.
        (do
            ((ร frp =) (:fr_next (:w_frame @curwin)))
        )
        :else    ;; Swap last window in row/col with previous.
        (do
            ((ร frp =) (:fr_prev (:w_frame @curwin)))
        ))

        ;; We can only exchange a window with another window, not with a frame containing windows.
        (if (or (nil? frp) (nil? (:fr_win frp)) (== (:fr_win frp) @curwin))
            ((ร RETURN) nil)
        )

        ((ร window_C wp =) (:fr_win frp))

        ;; 1. remove curwin from the list.  Remember after which window it was in wp2
        ;; 2. insert curwin before wp in the list
        ;; if wp != wp2
        ;;    3. remove wp from the list
        ;;    4. insert wp after wp2
        ;; 5. exchange the status line height and vsep width.

        ((ร window_C wp2 =) (:w_prev @curwin))
        ((ร frame_C frp2 =) (:fr_prev (:w_frame @curwin)))
        (when (!= (:w_prev wp) @curwin)
            (win-remove @curwin)
            (frame-remove (:w_frame @curwin))
            (win-append (:w_prev wp), @curwin)
            (frame-insert frp, (:w_frame @curwin))
        )
        (when (!= wp wp2)
            (win-remove wp)
            (frame-remove (:w_frame wp))
            (win-append wp2, wp)
            (if (nil? frp2)
                (frame-insert (:fr_child (:fr_parent (:w_frame wp))), (:w_frame wp))
                (frame-append frp2, (:w_frame wp)))
        )

        ((ร int temp =) (:w_status_height @curwin))
        ((ร @curwin.w_status_height =) (:w_status_height wp))
        ((ร wp.w_status_height =) temp)
        ((ร temp =) (:w_vsep_width @curwin))
        ((ร @curwin.w_vsep_width =) (:w_vsep_width wp))
        ((ร wp.w_vsep_width =) temp)

        ;; If the windows are not in the same frame, exchange the sizes to avoid
        ;; messing up the window layout.  Otherwise fix the frame sizes.
        (cond (!= (:fr_parent (:w_frame @curwin)) (:fr_parent (:w_frame wp)))
        (do
            ((ร temp =) (:w_height @curwin))
            ((ร @curwin.w_height =) (:w_height wp))
            ((ร wp.w_height =) temp)
            ((ร temp =) (:w_width @curwin))
            ((ร @curwin.w_width =) (:w_width wp))
            ((ร wp.w_width =) temp)
        )
        :else
        (do
            (frame-fix-height @curwin)
            (frame-fix-height wp)
            (frame-fix-width @curwin)
            (frame-fix-width wp)
        ))

        (win-comp-pos)                 ;; recompute window positions

        (win-enter wp)
        (redraw-later CLEAR)
        nil
    ))

;; rotate windows: if upwards true the second window becomes the first one
;;                 if upwards false the first window becomes the second one

(defn- #_void win-rotate [#_boolean upwards, #_int count]
    (ยง
        (when (== @firstwin @lastwin)            ;; nothing to do
            (beep-flush)
            ((ร RETURN) nil)
        )

        (ร frame_C frp)
        ;; Check if all frames in this row/col have one window.
        ((ร FOR) (ร ((ร frp =) (:fr_child (:fr_parent (:w_frame @curwin)))) (non-nil? frp) ((ร frp =) (:fr_next frp)))
            (when (nil? (:fr_win frp))
                (emsg (u8 "E443: Cannot rotate when another window is split"))
                ((ร RETURN) nil)
            )
        )

        (while (< 0 (ร count--))
            (ร window_C wp1, wp2)

            (cond upwards            ;; first window becomes last window
            (do
                ;; remove first window/frame from the list
                ((ร frp =) (:fr_child (:fr_parent (:w_frame @curwin))))
                ((ร wp1 =) (:fr_win frp))
                (win-remove wp1)
                (frame-remove frp)

                ;; find last frame and append removed window/frame after it
                ((ร FOR) (ร nil (non-nil? (:fr_next frp)) ((ร frp =) (:fr_next frp)))
                    ;
                )
                (win-append (:fr_win frp), wp1)
                (frame-append frp, (:w_frame wp1))

                ((ร wp2 =) (:fr_win frp))   ;; previously last window
            )
            :else                    ;; last window becomes first window
            (do
                ;; find last window/frame in the list and remove it
                ((ร FOR) (ร ((ร frp =) (:w_frame @curwin)) (non-nil? (:fr_next frp)) ((ร frp =) (:fr_next frp)))
                    ;
                )
                ((ร wp1 =) (:fr_win frp))
                ((ร wp2 =) (:w_prev wp1))   ;; will become last window
                (win-remove wp1)
                (frame-remove frp)

                ;; append the removed window/frame before the first in the list
                (win-append (:w_prev (:fr_win (:fr_child (:fr_parent frp)))), wp1)
                (frame-insert (:fr_child (:fr_parent frp)), frp)
            ))

            ;; exchange status height and vsep width of old and new last window
            ((ร int n =) (:w_status_height wp2))
            ((ร wp2.w_status_height =) (:w_status_height wp1))
            ((ร wp1.w_status_height =) n)
            (frame-fix-height wp1)
            (frame-fix-height wp2)

            ((ร n =) (:w_vsep_width wp2))
            ((ร wp2.w_vsep_width =) (:w_vsep_width wp1))
            ((ร wp1.w_vsep_width =) n)
            (frame-fix-width wp1)
            (frame-fix-width wp2)

            ;; recompute w_winrow and w_wincol for all windows
            (win-comp-pos)
        )

        (redraw-later CLEAR)
        nil
    ))

;; Move the current window to the very top/bottom/left/right of the screen.

(defn- #_void win-totop [#_int size, #_int flags]
    (ยง
        ((ร int height =) (:w_height @curwin))

        (when (== @lastwin @firstwin)
            (beep-flush)
            ((ร RETURN) nil)
        )

        ;; Remove the window and frame from the tree of frames.
        ((ร int[] dir =) (ร new int[1]))
        (winframe-remove @curwin, dir)
        (win-remove @curwin)
        (last-status false)             ;; may need to remove last status line
        (win-comp-pos)                 ;; recompute window positions

        ;; Split a window on the desired side and put the window there.
        (win-split-ins size, flags, @curwin, (... dir 0))
        (when (non-flag? flags WSP_VERT)
            (win-setheight height)
            (if @p_ea
                (win-equal @curwin, true, (byte \v)))
        )
        nil
    ))

;; Make all windows the same height.
;; 'next_curwin' will soon be the current window, make sure it has enough rows.

(defn- #_void win-equal [#_window_C next_curwin, #_boolean current, #_int dir]
    ;; next_curwin: pointer to current window to be or null
    ;; current: do only frame with current window
    ;; dir: 'v' for vertically, 'h' for horizontally, 'b' for both, 0 for using "p_ead"
    (ยง
        (if (zero? dir)
            ((ร dir =) (.at @p_ead 0))
        )
        (win-equal-rec (if (nil? next_curwin) @curwin next_curwin), current, @topframe, dir, 0, 0, (int @Cols), (:fr_height @topframe))
        nil
    ))

;; Set a frame to a new position and height, spreading the available room
;; equally over contained frames.
;; The window "next_curwin" (if not null) should at least get the size from
;; 'winheight' and 'winwidth' if possible.

(defn- #_void win-equal-rec [#_window_C next_curwin, #_boolean current, #_frame_C topfr, #_int dir, #_int col, #_int row, #_int width, #_int height]
    ;; next_curwin: pointer to current window to be or null
    ;; current: do only frame with current window
    ;; topfr: frame to set size off
    ;; dir: 'v', 'h' or 'b', see win-equal()
    ;; col: horizontal position for frame
    ;; row: vertical position for frame
    ;; width: new width of frame
    ;; height: new height of frame
    (ยง
        ((ร int extra_sep =) 0)
        (ร int wincount, totwincount = 0)
        ((ร int next_curwin_size =) 0)
        ((ร int room =) 0)
        ((ร boolean has_next_curwin =) false)

        (cond (== (:fr_layout topfr) FR_LEAF)
        (do
            ;; Set the width/height of this frame.
            ;; Redraw when size or position changes
            (when (or (!= (:fr_height topfr) height) (!= (:w_winrow (:fr_win topfr)) row) (!= (:fr_width topfr) width) (!= (:w_wincol (:fr_win topfr)) col))
                ((ร topfr.fr_win.w_winrow =) row)
                (frame-new-height topfr, height, false, false)
                ((ร topfr.fr_win.w_wincol =) col)
                (frame-new-width topfr, width, false, false)
                (redraw-all-later CLEAR)
            )
        )
        (== (:fr_layout topfr) FR_ROW)
        (do
            ((ร topfr.fr_width =) width)
            ((ร topfr.fr_height =) height)

            (when (!= dir (byte \v))                 ;; equalize frame widths
                ;; Compute the maximum number of windows horizontally in this frame.
                ((ร int n =) (frame-minwidth topfr, NOWIN))
                ;; add one for the rightmost window, it doesn't have a separator
                ((ร extra_sep =) (if (== (+ col width) (int @Cols)) 1 0))
                ((ร totwincount =) (/ (+ n extra_sep) (inc (int @p_wmw))))
                ((ร has_next_curwin =) (frame-has-win topfr, next_curwin))

                ;; Compute width for "next_curwin" window and room available for other windows.
                ;; "m" is the minimal width when counting "p_wiw" for "next_curwin".

                ((ร int m =) (frame-minwidth topfr, next_curwin))
                ((ร room =) (- width m))
                (cond (< room 0)
                (do
                    ((ร next_curwin_size =) (+ (int @p_wiw) room))
                    ((ร room =) 0)
                )
                :else
                (do
                    ((ร next_curwin_size =) -1)
                    ((ร FOR) (ร ((ร frame_C fr =) (:fr_child topfr)) (non-nil? fr) ((ร fr =) (:fr_next fr)))
                        ;; If 'winfixwidth' set keep the window width if possible.
                        ;; Watch out for this window being the next_curwin.
                        (when (frame-fixed-width fr)
                            ((ร n =) (frame-minwidth fr, NOWIN))
                            ((ร int new_size =) (:fr_width fr))
                            (cond (frame-has-win fr, next_curwin)
                            (do
                                ((ร room =) (+ room (- @p_wiw @p_wmw)))
                                ((ร next_curwin_size =) 0)
                                (if (< new_size @p_wiw)
                                    ((ร new_size =) (int @p_wiw))
                                )
                            )
                            :else
                            (do
                                ;; These windows don't use up room.
                                ((ร totwincount =) (- totwincount (/ (+ n (if (nil? (:fr_next fr)) extra_sep 0)) (inc @p_wmw))))
                            ))
                            ((ร room =) (- room (- new_size n)))
                            (when (< room 0)
                                ((ร new_size =) (+ new_size room))
                                ((ร room =) 0)
                            )
                            ((ร fr.fr_newwidth =) new_size)
                        )
                    )
                    (when (== next_curwin_size -1)
                        (cond (not has_next_curwin)
                        (do
                            ((ร next_curwin_size =) 0)
                        )
                        (and (< 1 totwincount) (< @p_wiw (/ (+ room (- totwincount 2)) (dec totwincount))))
                        (do
                            ;; Can make all windows wider than 'winwidth', spread the room equally.
                            ((ร next_curwin_size =) (/ (+ room (int @p_wiw) (* (dec totwincount) (int @p_wmw)) (dec totwincount)) totwincount))
                            ((ร room =) (- room (- next_curwin_size @p_wiw)))
                        )
                        :else
                        (do
                            ((ร next_curwin_size =) (int @p_wiw))
                        ))
                    )
                ))

                (if has_next_curwin
                    (ร --totwincount)          ;; don't count curwin
                )
            )

            ((ร FOR) (ร ((ร frame_C fr =) (:fr_child topfr)) (non-nil? fr) ((ร fr =) (:fr_next fr)))
                ((ร wincount =) 1)
                (ร int new_size)
                (cond (nil? (:fr_next fr))
                (do
                    ;; last frame gets all that remains (avoid roundoff error)
                    ((ร new_size =) width)
                )
                (== dir (byte \v))
                (do
                    ((ร new_size =) (:fr_width fr))
                )
                (frame-fixed-width fr)
                (do
                    ((ร new_size =) (:fr_newwidth fr))
                    ((ร wincount =) 0)       ;; doesn't count as a sizeable window
                )
                :else
                (do
                    ;; Compute the maximum number of windows horiz. in "fr".
                    ((ร int n =) (frame-minwidth fr, NOWIN))
                    ((ร wincount =) (/ (+ n (if (nil? (:fr_next fr)) extra_sep 0)) (inc (int @p_wmw))))
                    ((ร int m =) (frame-minwidth fr, next_curwin))
                    ((ร boolean hnc =) (if has_next_curwin (frame-has-win fr, next_curwin) false))
                    (if hnc            ;; don't count next_curwin
                        (ร --wincount)
                    )
                    ((ร new_size =) (if (zero? totwincount) room (/ (+ (* wincount room) (>>> totwincount 1)) totwincount)))
                    (cond hnc            ;; add next_curwin size
                    (do
                        ((ร next_curwin_size =) (- next_curwin_size (- @p_wiw (- m n))))
                        ((ร new_size =) (+ new_size next_curwin_size))
                        ((ร room =) (- room (- new_size next_curwin_size)))
                    )
                    :else
                    (do
                        ((ร room =) (- room new_size))
                    ))
                    ((ร new_size =) (+ new_size n))
                ))

                ;; Skip frame that is full width when splitting or closing a window,
                ;; unless equalizing all frames.
                (if (or (not current) (!= dir (byte \v)) (non-nil? (:fr_parent topfr)) (!= new_size (:fr_width fr)) (frame-has-win fr, next_curwin))
                    (win-equal-rec next_curwin, current, fr, dir, col, row, new_size, height))
                ((ร col =) (+ col new_size))
                ((ร width =) (- width new_size))
                ((ร totwincount =) (- totwincount wincount))
            )
        )
        :else ;; topfr.fr_layout == FR_COL
        (do
            ((ร topfr.fr_width =) width)
            ((ร topfr.fr_height =) height)

            (when (!= dir (byte \h))                 ;; equalize frame heights
                ;; Compute maximum number of windows vertically in this frame.
                ((ร int n =) (frame-minheight topfr, NOWIN))
                ;; add one for the bottom window if it doesn't have a statusline
                ((ร extra_sep =) (if (and (== (+ row height) @cmdline_row) (zero? @p_ls)) 1 0))
                ((ร totwincount =) (/ (+ n extra_sep) (inc (int @p_wmh))))
                ((ร has_next_curwin =) (frame-has-win topfr, next_curwin))

                ;; Compute height for "next_curwin" window and room available for other windows.
                ;; "m" is the minimal height when counting "p_wh" for "next_curwin".

                ((ร int m =) (frame-minheight topfr, next_curwin))
                ((ร room =) (- height m))
                (cond (< room 0)
                (do
                    ;; The room is less then 'winheight', use all space for the current window.
                    ((ร next_curwin_size =) (+ (int @p_wh) room))
                    ((ร room =) 0)
                )
                :else
                (do
                    ((ร next_curwin_size =) -1)
                    ((ร FOR) (ร ((ร frame_C fr =) (:fr_child topfr)) (non-nil? fr) ((ร fr =) (:fr_next fr)))
                        ;; If 'winfixheight' set keep the window height if possible.
                        ;; Watch out for this window being the next_curwin.
                        (when (frame-fixed-height fr)
                            ((ร n =) (frame-minheight fr, NOWIN))
                            ((ร int new_size =) (:fr_height fr))
                            (cond (frame-has-win fr, next_curwin)
                            (do
                                ((ร room =) (+ room (- @p_wh @p_wmh)))
                                ((ร next_curwin_size =) 0)
                                (if (< new_size @p_wh)
                                    ((ร new_size =) (int @p_wh))
                                )
                            )
                            :else
                            (do
                                ;; These windows don't use up room.
                                ((ร totwincount =) (- totwincount (/ (+ n (if (nil? (:fr_next fr)) extra_sep 0)) (inc @p_wmh))))
                            ))
                            ((ร room =) (- room (- new_size n)))
                            (when (< room 0)
                                ((ร new_size =) (+ new_size room))
                                ((ร room =) 0)
                            )
                            ((ร fr.fr_newheight =) new_size)
                        )
                    )
                    (when (== next_curwin_size -1)
                        (cond (not has_next_curwin)
                        (do
                            ((ร next_curwin_size =) 0)
                        )
                        (and (< 1 totwincount) (< @p_wh (/ (+ room (- totwincount 2)) (dec totwincount))))
                        (do
                            ;; Can make all windows higher than 'winheight', spread the room equally.
                            ((ร next_curwin_size =) (/ (+ room (int @p_wh) (* (dec totwincount) (int @p_wmh)) (dec totwincount)) totwincount))
                            ((ร room =) (- room (- next_curwin_size @p_wh)))
                        )
                        :else
                        (do
                            ((ร next_curwin_size =) (int @p_wh))
                        ))
                    )
                ))

                (if has_next_curwin
                    (ร --totwincount)          ;; don't count curwin
                )
            )

            ((ร FOR) (ร ((ร frame_C fr =) (:fr_child topfr)) (non-nil? fr) ((ร fr =) (:fr_next fr)))
                ((ร wincount =) 1)
                (ร int new_size)
                (cond (nil? (:fr_next fr))
                (do
                    ;; last frame gets all that remains (avoid roundoff error)
                    ((ร new_size =) height)
                )
                (== dir (byte \h))
                (do
                    ((ร new_size =) (:fr_height fr))
                )
                (frame-fixed-height fr)
                (do
                    ((ร new_size =) (:fr_newheight fr))
                    ((ร wincount =) 0)       ;; doesn't count as a sizeable window
                )
                :else
                (do
                    ;; Compute the maximum number of windows vert. in "fr".
                    ((ร int n =) (frame-minheight fr, NOWIN))
                    ((ร wincount =) (/ (+ n (if (nil? (:fr_next fr)) extra_sep 0)) (inc (int @p_wmh))))
                    ((ร int m =) (frame-minheight fr, next_curwin))
                    ((ร boolean hnc =) (if has_next_curwin (frame-has-win fr, next_curwin) false))
                    (if hnc            ;; don't count next_curwin
                        (ร --wincount)
                    )
                    ((ร new_size =) (if (zero? totwincount) room (/ (+ (* wincount room) (>>> totwincount 1)) totwincount)))
                    (cond hnc            ;; add next_curwin size
                    (do
                        ((ร next_curwin_size =) (- next_curwin_size (- @p_wh (- m n))))
                        ((ร new_size =) (+ new_size next_curwin_size))
                        ((ร room =) (- room (- new_size next_curwin_size)))
                    )
                    :else
                    (do
                        ((ร room =) (- room new_size))
                    ))
                    ((ร new_size =) (+ new_size n))
                ))
                ;; Skip frame that is full width when splitting or closing a window,
                ;; unless equalizing all frames.
                (when (or (not current) (!= dir (byte \h)) (non-nil? (:fr_parent topfr)) (!= new_size (:fr_height fr)) (frame-has-win fr, next_curwin))
                    (win-equal-rec next_curwin, current, fr, dir, col, row, width, new_size)
                )
                ((ร row =) (+ row new_size))
                ((ร height =) (- height new_size))
                ((ร totwincount =) (- totwincount wincount))
            )
        ))
        nil
    ))

;; Return true if there is only one window.

(defn- #_boolean one-window []
    (ยง
        ((ร boolean seen_one =) false)

        ((ร FOR) (ร ((ร window_C wp =) @firstwin) (non-nil? wp) ((ร wp =) (:w_next wp)))
            (if seen_one
                ((ร RETURN) false)
            )
            ((ร seen_one =) true)
        )

        true
    ))

;; Close window "win".  Only works for the current tab page.
;; If "_unload" is true related buffer may be unloaded.
;;
;; Returns false when the window was not closed.

(defn- #_boolean win-close [#_window_C win, #_boolean _unload]
    (ยง
        (when (one-window)
            (emsg (u8 "E444: Cannot close last window"))
            ((ร RETURN) false)
        )

        (if (== @firstwin @lastwin)
            ((ร RETURN) false)
        )

        ;; Close the link to the buffer.

        (close-buffer win)

        ;; Free the memory used for the window and get the window that received the screen space.
        ((ร int[] dir =) (ร new int[1]))
        ((ร window_C wp =) (win-free-mem win, dir))

        ((ร boolean close_curwin =) false)

        ;; Make sure curwin isn't invalid.
        ;; It can cause severe trouble when printing an error message.
        ;; For win-equal() curbuf needs to be valid too.
        (when (== win @curwin)
            (reset! curwin wp)
            ((ร close_curwin =) true)
        )

        (if (and @p_ea (or (== (.at @p_ead 0) (byte \b)) (== (.at @p_ead 0) (... dir 0))))
            (win-equal @curwin, true, (... dir 0))
            (win-comp-pos))

        (if close_curwin
            (win-enter-ext wp, true))

        ;; If last window has a status line now and we don't want one,
        ;; remove the status line.

        (last-status false)

        (redraw-all-later NOT_VALID)
        true
    ))

;; Free the memory used for a window.
;; Returns a pointer to the window that got the freed up space.

(defn- #_window_C win-free-mem [#_window_C win, #_int* dirp]
    ;; dirp: set to 'v' or 'h' for direction if 'ea'
    (ยง
        ;; Remove the window and its frame from the tree of frames.
        ((ร window_C wp =) (winframe-remove win, dirp))
        (win-free win)

        wp
    ))

;; Remove a window and its frame from the tree of frames.
;; Returns a pointer to the window that got the freed up space.

(defn- #_window_C winframe-remove [#_window_C win, #_int* dirp]
    ;; dirp: set to 'v' or 'h' for direction if 'ea'
    (ยง
        ((ร frame_C frp_close =) (:w_frame win))

        ;; If there is only one window there is nothing to remove.

        (if (== @firstwin @lastwin)
            ((ร RETURN) nil)
        )

        ;; Remove the window from its frame.

        ((ร frame_C frp2 =) (win-altframe win))
        ((ร window_C wp =) (frame2win frp2))

        ;; Remove this frame from the list of frames.
        (frame-remove frp_close)

        (cond (== (:fr_layout (:fr_parent frp_close)) FR_COL)
        (do
            ;; When 'winfixheight' is set, try to find another frame in the column
            ;; (as close to the closed frame as possible) to distribute the height to.
            (when (and (non-nil? (:fr_win frp2)) @(:wo_wfh (:w_options (:fr_win frp2))))
                ((ร frame_C frp =) (:fr_prev frp_close))
                ((ร frame_C frp3 =) (:fr_next frp_close))
                (while (or (non-nil? frp) (non-nil? frp3))
                    (when (non-nil? frp)
                        (when (and (non-nil? (:fr_win frp)) (not @(:wo_wfh (:w_options (:fr_win frp)))))
                            ((ร frp2 =) frp)
                            ((ร wp =) (:fr_win frp))
                            (ร BREAK)
                        )
                        ((ร frp =) (:fr_prev frp))
                    )
                    (when (non-nil? frp3)
                        (when (and (non-nil? (:fr_win frp3)) (not @(:wo_wfh (:w_options (:fr_win frp3)))))
                            ((ร frp2 =) frp3)
                            ((ร wp =) (:fr_win frp3))
                            (ร BREAK)
                        )
                        ((ร frp3 =) (:fr_next frp3))
                    )
                )
            )
            (frame-new-height frp2, (+ (:fr_height frp2) (:fr_height frp_close)), (== frp2 (:fr_next frp_close)), false)
            ((ร dirp[0] =) (byte \v))
        )
        :else
        (do
            ;; When 'winfixwidth' is set, try to find another frame in the column
            ;; (as close to the closed frame as possible) to distribute the width to.
            (when (and (non-nil? (:fr_win frp2)) @(:wo_wfw (:w_options (:fr_win frp2))))
                ((ร frame_C frp =) (:fr_prev frp_close))
                ((ร frame_C frp3 =) (:fr_next frp_close))
                (while (or (non-nil? frp) (non-nil? frp3))
                    (when (non-nil? frp)
                        (when (and (non-nil? (:fr_win frp)) (not @(:wo_wfw (:w_options (:fr_win frp)))))
                            ((ร frp2 =) frp)
                            ((ร wp =) (:fr_win frp))
                            (ร BREAK)
                        )
                        ((ร frp =) (:fr_prev frp))
                    )
                    (when (non-nil? frp3)
                        (when (and (non-nil? (:fr_win frp3)) (not @(:wo_wfw (:w_options (:fr_win frp3)))))
                            ((ร frp2 =) frp3)
                            ((ร wp =) (:fr_win frp3))
                            (ร BREAK)
                        )
                        ((ร frp3 =) (:fr_next frp3))
                    )
                )
            )
            (frame-new-width frp2, (+ (:fr_width frp2) (:fr_width frp_close)), (== frp2 (:fr_next frp_close)), false)
            ((ร dirp[0] =) (byte \h))
        ))

        ;; If rows/columns go to a window below/right its positions need to be updated.
        ;; Can only be done after the sizes have been updated.
        (when (== frp2 (:fr_next frp_close))
; %%        ((ร int[] row =) (ร { (win.w_winrow) }))
; %%        ((ร int[] col =) (ร { (win.w_wincol) }))

            (frame-comp-pos frp2, row, col)
        )

        (when (and (nil? (:fr_next frp2)) (nil? (:fr_prev frp2)))
            ;; There is no other frame in this list, move its info to the parent and remove it.
            ((ร frp2.fr_parent.fr_layout =) (:fr_layout frp2))
            ((ร frp2.fr_parent.fr_child =) (:fr_child frp2))
            ((ร FOR) (ร ((ร frame_C frp =) (:fr_child frp2)) (non-nil? frp) ((ร frp =) (:fr_next frp)))
                ((ร frp.fr_parent =) (:fr_parent frp2))
            )
            ((ร frp2.fr_parent.fr_win =) (:fr_win frp2))
            (if (non-nil? (:fr_win frp2))
                ((ร frp2.fr_win.w_frame =) (:fr_parent frp2))
            )
            ((ร frame_C frp =) (:fr_parent frp2))

            ((ร frp2 =) (:fr_parent frp))
            (when (and (non-nil? frp2) (== (:fr_layout frp2) (:fr_layout frp)))
                ;; The frame above the parent has the same layout,
                ;; have to merge the frames into this list.
                (if (== (:fr_child frp2) frp)
                    ((ร frp2.fr_child =) (:fr_child frp))
                )
                ((ร frp.fr_child.fr_prev =) (:fr_prev frp))
                (if (non-nil? (:fr_prev frp))
                    ((ร frp.fr_prev.fr_next =) (:fr_child frp))
                )
                ((ร FOR) (ร ((ร frame_C frp3 =) (:fr_child frp)) true ((ร frp3 =) (:fr_next frp3)))
                    ((ร frp3.fr_parent =) frp2)
                    (when (nil? (:fr_next frp3))
                        ((ร frp3.fr_next =) (:fr_next frp))
                        (if (non-nil? (:fr_next frp))
                            ((ร frp.fr_next.fr_prev =) frp3)
                        )
                        (ร BREAK)
                    )
                )
            )
        )

        wp
    ))

;; Find out which frame is going to get the freed up space when "win" is closed.
;; if 'splitbelow'/'splitleft' the space goes to the window above/left.
;; if 'nosplitbelow'/'nosplitleft' the space goes to the window below/right.
;; This makes opening a window and closing it immediately keep the same window layout.

(defn- #_frame_C win-altframe [#_window_C win]
    (ยง
        (if (== @firstwin @lastwin)
            ((ร RETURN) (:w_frame @curwin))
        )

        ((ร frame_C frp =) (:w_frame win))
        ((ร boolean b =) (if (and (non-nil? (:fr_parent frp)) (== (:fr_layout (:fr_parent frp)) FR_ROW)) @p_spr @p_sb))
        (if (or (and (not b) (non-nil? (:fr_next frp))) (nil? (:fr_prev frp)))
            ((ร RETURN) (:fr_next frp))
        )

        (:fr_prev frp)
    ))

;; Find the left-upper window in frame "frp".

(defn- #_window_C frame2win [#_frame_C frp]
    (ยง
        (while (nil? (:fr_win frp))
            ((ร frp =) (:fr_child frp))
        )
        (:fr_win frp)
    ))

;; Return true if frame "frp" contains window "wp".

(defn- #_boolean frame-has-win [#_frame_C frp, #_window_C wp]
    (ยง
        (if (== (:fr_layout frp) FR_LEAF)
            ((ร RETURN) (== (:fr_win frp) wp))
        )

        ((ร FOR) (ร ((ร frame_C p =) (:fr_child frp)) (non-nil? p) ((ร p =) (:fr_next p)))
            (if (frame-has-win p, wp)
                ((ร RETURN) true)
            )
        )

        false
    ))

;; Set a new height for a frame.  Recursively sets the height for contained
;; frames and windows.  Caller must take care of positions.

(defn- #_void frame-new-height [#_frame_C topfrp, #_int height, #_boolean topfirst, #_boolean wfh]
    ;; topfirst: resize topmost contained frame first
    ;; wfh: obey 'winfixheight' when there is a choice; may cause the height not to be set
    (ยง
        (cond (non-nil? (:fr_win topfrp))
        (do
            ;; Simple case: just one window.
            (win-new-height (:fr_win topfrp), (- height (:w_status_height (:fr_win topfrp))))
        )
        (== (:fr_layout topfrp) FR_ROW)
        (do
            (ร frame_C frp)
;           do
;           {
                ;; All frames in this row get the same new height.
                ((ร FOR) (ร ((ร frp =) (:fr_child topfrp)) (non-nil? frp) ((ร frp =) (:fr_next frp)))
                    (frame-new-height frp, height, topfirst, wfh)
                    (when (< height (:fr_height frp))
                        ;; Could not fit the windows, make the whole row higher.
                        ((ร height =) (:fr_height frp))
                        (ร BREAK)
                    )
                )
;           } while (frp != null);
        )
        :else    ;; fr_layout == FR_COL
        (do
            ;; Complicated case: resize a column of frames.
            ;; Resize the bottom frame first, frames above that when needed.

            ((ร frame_C frp =) (:fr_child topfrp))
            (when wfh
                ;; Advance past frames with one window with 'wfh' set.
                (while (frame-fixed-height frp)
                    ((ร frp =) (:fr_next frp))
                    (if (nil? frp)
                        ((ร RETURN) nil)         ;; no frame without 'wfh', give up
                    )
                )
            )
            (when (not topfirst)
                ;; Find the bottom frame of this column.
                (while (non-nil? (:fr_next frp))
                    ((ร frp =) (:fr_next frp))
                )
                (when wfh
                    ;; Advance back for frames with one window with 'wfh' set.
                    (while (frame-fixed-height frp)
                        ((ร frp =) (:fr_prev frp))
                    )
                )
            )

            ((ร int extra_lines =) (- height (:fr_height topfrp)))
            (cond (< extra_lines 0)
            (do
                ;; reduce height of contained frames, bottom or top frame first
                (while (non-nil? frp)
                    ((ร int h =) (frame-minheight frp, nil))
                    (cond (< (+ (:fr_height frp) extra_lines) h)
                    (do
                        ((ร extra_lines =) (+ extra_lines (- (:fr_height frp) h)))
                        (frame-new-height frp, h, topfirst, wfh)
                    )
                    :else
                    (do
                        (frame-new-height frp, (+ (:fr_height frp) extra_lines), topfirst, wfh)
                        (ร BREAK)
                    ))
                    (cond topfirst
                    (do
;                       do
;                       {
                            ((ร frp =) (:fr_next frp))
;                       } while (wfh && frp != null && frame-fixed-height(frp));
                    )
                    :else
                    (do
;                       do
;                       {
                            ((ร frp =) (:fr_prev frp))
;                       } while (wfh && frp != null && frame-fixed-height(frp));
                    ))
                    ;; Increase "height" if we could not reduce enough frames.
                    (if (nil? frp)
                        ((ร height =) (- height extra_lines))
                    )
                )
            )
            (< 0 extra_lines)
            (do
                ;; increase height of bottom or top frame
                (frame-new-height frp, (+ (:fr_height frp) extra_lines), topfirst, wfh)
            ))
        ))
        ((ร topfrp.fr_height =) height)
        nil
    ))

;; Return true if height of frame "frp" should not be changed because of
;; the 'winfixheight' option.

(defn- #_boolean frame-fixed-height [#_frame_C frp]
    (ยง
        ;; frame with one window: fixed height if 'winfixheight' set.
        (if (non-nil? (:fr_win frp))
            ((ร RETURN) @(:wo_wfh (:w_options (:fr_win frp))))
        )

        (when (== (:fr_layout frp) FR_ROW)
            ;; The frame is fixed height if one of the frames in the row is fixed height.
            ((ร FOR) (ร ((ร frp =) (:fr_child frp)) (non-nil? frp) ((ร frp =) (:fr_next frp)))
                (if (frame-fixed-height frp)
                    ((ร RETURN) true)
                )
            )

            ((ร RETURN) false)
        )

        ;; frp.fr_layout == FR_COL: the frame is fixed height
        ;; if all of the frames in the row are fixed height.
        ((ร FOR) (ร ((ร frp =) (:fr_child frp)) (non-nil? frp) ((ร frp =) (:fr_next frp)))
            (if (not (frame-fixed-height frp))
                ((ร RETURN) false)
            )
        )

        true
    ))

;; Return true if width of frame "frp" should not be changed
;; because of the 'winfixwidth' option.

(defn- #_boolean frame-fixed-width [#_frame_C frp]
    (ยง
        ;; frame with one window: fixed width if 'winfixwidth' set.
        (if (non-nil? (:fr_win frp))
            ((ร RETURN) @(:wo_wfw (:w_options (:fr_win frp))))
        )

        (when (== (:fr_layout frp) FR_COL)
            ;; The frame is fixed width if one of the frames in the row is fixed width.
            ((ร FOR) (ร ((ร frp =) (:fr_child frp)) (non-nil? frp) ((ร frp =) (:fr_next frp)))
                (if (frame-fixed-width frp)
                    ((ร RETURN) true)
                )
            )

            ((ร RETURN) false)
        )

        ;; frp.fr_layout == FR_ROW: the frame is fixed width
        ;; if all of the frames in the row are fixed width.
        ((ร FOR) (ร ((ร frp =) (:fr_child frp)) (non-nil? frp) ((ร frp =) (:fr_next frp)))
            (if (not (frame-fixed-width frp))
                ((ร RETURN) false)
            )
        )

        true
    ))

;; Add a status line to windows at the bottom of "frp".
;; Note: Does not check if there is room!

(defn- #_void frame-add-statusline [#_frame_C frp]
    (ยง
        (cond (== (:fr_layout frp) FR_LEAF)
        (do
            ((ร window_C wp =) (:fr_win frp))
            (when (zero? (:w_status_height wp))
                (if (< 0 (:w_height wp))    ;; don't make it negative
                    (ร --wp.w_height)
                )
                ((ร wp.w_status_height =) STATUS_HEIGHT)
            )
        )
        (== (:fr_layout frp) FR_ROW)
        (do
            ;; Handle all the frames in the row.
            ((ร FOR) (ร ((ร frp =) (:fr_child frp)) (non-nil? frp) ((ร frp =) (:fr_next frp)))
                (frame-add-statusline frp)
            )
        )
        :else ;; frp.fr_layout == FR_COL
        (do
            ;; Only need to handle the last frame in the column.
            ((ร FOR) (ร ((ร frp =) (:fr_child frp)) (non-nil? (:fr_next frp)) ((ร frp =) (:fr_next frp)))
                ;
            )
            (frame-add-statusline frp)
        ))
        nil
    ))

;; Set width of a frame.  Handles recursively going through contained frames.
;; May remove separator line for windows at the right side (for win-close()).

(defn- #_void frame-new-width [#_frame_C topfrp, #_int width, #_boolean leftfirst, #_boolean wfw]
    ;; leftfirst: resize leftmost contained frame first
    ;; wfw: obey 'winfixwidth' when there is a choice; may cause the width not to be set
    (ยง
        (cond (== (:fr_layout topfrp) FR_LEAF)
        (do
            ;; Simple case: just one window.
            ((ร window_C wp =) (:fr_win topfrp))
            ;; Find out if there are any windows right of this one.
            (ร frame_C frp)
            ((ร FOR) (ร ((ร frp =) topfrp) (non-nil? (:fr_parent frp)) ((ร frp =) (:fr_parent frp)))
                (if (and (== (:fr_layout (:fr_parent frp)) FR_ROW) (non-nil? (:fr_next frp)))
                    (ร BREAK)
                )
            )
            (if (nil? (:fr_parent frp))
                ((ร wp.w_vsep_width =) 0)
            )
            (win-new-width wp, (- width (:w_vsep_width wp)))
        )
        (== (:fr_layout topfrp) FR_COL)
        (do
            (ร frame_C frp)
;           do
;           {
                ;; All frames in this column get the same new width.
                ((ร FOR) (ร ((ร frp =) (:fr_child topfrp)) (non-nil? frp) ((ร frp =) (:fr_next frp)))
                    (frame-new-width frp, width, leftfirst, wfw)
                    (when (< width (:fr_width frp))
                        ;; Could not fit the windows, make whole column wider.
                        ((ร width =) (:fr_width frp))
                        (ร BREAK)
                    )
                )
;           } while (frp != null);
        )
        :else    ;; fr_layout == FR_ROW
        (do
            ;; Complicated case: resize a row of frames.
            ;; Resize the rightmost frame first, frames left of it when needed.

            ((ร frame_C frp =) (:fr_child topfrp))
            (when wfw
                ;; Advance past frames with one window with 'wfw' set.
                (while (frame-fixed-width frp)
                    ((ร frp =) (:fr_next frp))
                    (if (nil? frp)
                        ((ร RETURN) nil)         ;; no frame without 'wfw', give up
                    )
                )
            )
            (when (not leftfirst)
                ;; Find the rightmost frame of this row.
                (while (non-nil? (:fr_next frp))
                    ((ร frp =) (:fr_next frp))
                )
                (when wfw
                    ;; Advance back for frames with one window with 'wfw' set.
                    (while (frame-fixed-width frp)
                        ((ร frp =) (:fr_prev frp))
                    )
                )
            )

            ((ร int extra_cols =) (- width (:fr_width topfrp)))
            (cond (< extra_cols 0)
            (do
                ;; reduce frame width, rightmost frame first
                (while (non-nil? frp)
                    ((ร int w =) (frame-minwidth frp, nil))
                    (cond (< (+ (:fr_width frp) extra_cols) w)
                    (do
                        ((ร extra_cols =) (+ extra_cols (- (:fr_width frp) w)))
                        (frame-new-width frp, w, leftfirst, wfw)
                    )
                    :else
                    (do
                        (frame-new-width frp, (+ (:fr_width frp) extra_cols), leftfirst, wfw)
                        (ร BREAK)
                    ))
                    (cond leftfirst
                    (do
;                       do
;                       {
                            ((ร frp =) (:fr_next frp))
;                       } while (wfw && frp != null && frame-fixed-width(frp));
                    )
                    :else
                    (do
;                       do
;                       {
                            ((ร frp =) (:fr_prev frp))
;                       } while (wfw && frp != null && frame-fixed-width(frp));
                    ))
                    ;; Increase "width" if we could not reduce enough frames.
                    (if (nil? frp)
                        ((ร width =) (- width extra_cols))
                    )
                )
            )
            (< 0 extra_cols)
            (do
                ;; increase width of rightmost frame
                (frame-new-width frp, (+ (:fr_width frp) extra_cols), leftfirst, wfw)
            ))
        ))
        ((ร topfrp.fr_width =) width)
        nil
    ))

;; Add the vertical separator to windows at the right side of "frp".
;; Note: Does not check if there is room!

(defn- #_void frame-add-vsep [#_frame_C frp]
    (ยง
        (cond (== (:fr_layout frp) FR_LEAF)
        (do
            ((ร window_C wp =) (:fr_win frp))
            (when (zero? (:w_vsep_width wp))
                (if (< 0 (:w_width wp))     ;; don't make it negative
                    (ร --wp.w_width)
                )
                ((ร wp.w_vsep_width =) 1)
            )
        )
        (== (:fr_layout frp) FR_COL)
        (do
            ;; Handle all the frames in the column.
            ((ร FOR) (ร ((ร frp =) (:fr_child frp)) (non-nil? frp) ((ร frp =) (:fr_next frp)))
                (frame-add-vsep frp)
            )
        )
        :else ;; frp.fr_layout == FR_ROW
        (do
            ;; Only need to handle the last frame in the row.
            ((ร frp =) (:fr_child frp))
            (while (non-nil? (:fr_next frp))
                ((ร frp =) (:fr_next frp))
            )
            (frame-add-vsep frp)
        ))
        nil
    ))

;; Set frame width from the window it contains.

(defn- #_void frame-fix-width [#_window_C wp]
    (ยง
        ((ร wp.w_frame.fr_width =) (+ (:w_width wp) (:w_vsep_width wp)))
        nil
    ))

;; Set frame height from the window it contains.

(defn- #_void frame-fix-height [#_window_C wp]
    (ยง
        ((ร wp.w_frame.fr_height =) (+ (:w_height wp) (:w_status_height wp)))
        nil
    ))

;; Compute the minimal height for frame "topfrp".
;; Uses the 'winminheight' option.
;; When "next_curwin" isn't null, use "p_wh" for this window.
;; When "next_curwin" is NOWIN, don't use at least one line for the current window.

(defn- #_int frame-minheight [#_frame_C topfrp, #_window_C next_curwin]
    (ยง
        (ร int m)

        (cond (non-nil? (:fr_win topfrp))
        (do
            (cond (== (:fr_win topfrp) next_curwin)
            (do
                ((ร m =) (+ (int @p_wh) (:w_status_height (:fr_win topfrp))))
            )
            :else
            (do
                ;; window: minimal height of the window plus status line
                ((ร m =) (+ (int @p_wmh) (:w_status_height (:fr_win topfrp))))
                ;; Current window is minimal one line high.
                (if (and (zero? @p_wmh) (== (:fr_win topfrp) @curwin) (nil? next_curwin))
                    (ร m++)
                )
            ))
        )
        (== (:fr_layout topfrp) FR_ROW)
        (do
            ;; get the minimal height from each frame in this row
            ((ร m =) 0)
            ((ร FOR) (ร ((ร frame_C frp =) (:fr_child topfrp)) (non-nil? frp) ((ร frp =) (:fr_next frp)))
                ((ร int n =) (frame-minheight frp, next_curwin))
                (if (< m n)
                    ((ร m =) n)
                )
            )
        )
        :else
        (do
            ;; Add up the minimal heights for all frames in this column.
            ((ร m =) 0)
            ((ร FOR) (ร ((ร frame_C frp =) (:fr_child topfrp)) (non-nil? frp) ((ร frp =) (:fr_next frp)))
                ((ร m =) (+ m (frame-minheight frp, next_curwin)))
            )
        ))

        m
    ))

;; Compute the minimal width for frame "topfrp".
;; When "next_curwin" isn't null, use "p_wiw" for this window.
;; When "next_curwin" is NOWIN, don't use at least one column for the current window.

(defn- #_int frame-minwidth [#_frame_C topfrp, #_window_C next_curwin]
    ;; next_curwin: use "p_wh" and "p_wiw" for next_curwin
    (ยง
        (ร int m)

        (cond (non-nil? (:fr_win topfrp))
        (do
            (cond (== (:fr_win topfrp) next_curwin)
            (do
                ((ร m =) (+ (int @p_wiw) (:w_vsep_width (:fr_win topfrp))))
            )
            :else
            (do
                ;; window: minimal width of the window plus separator column
                ((ร m =) (+ (int @p_wmw) (:w_vsep_width (:fr_win topfrp))))
                ;; Current window is minimal one column wide.
                (if (and (zero? @p_wmw) (== (:fr_win topfrp) @curwin) (nil? next_curwin))
                    (ร m++)
                )
            ))
        )
        (== (:fr_layout topfrp) FR_COL)
        (do
            ;; get the minimal width from each frame in this column
            ((ร m =) 0)
            ((ร FOR) (ร ((ร frame_C frp =) (:fr_child topfrp)) (non-nil? frp) ((ร frp =) (:fr_next frp)))
                ((ร int n =) (frame-minwidth frp, next_curwin))
                (if (< m n)
                    ((ร m =) n)
                )
            )
        )
        :else
        (do
            ;; Add up the minimal widths for all frames in this row.
            ((ร m =) 0)
            ((ร FOR) (ร ((ร frame_C frp =) (:fr_child topfrp)) (non-nil? frp) ((ร frp =) (:fr_next frp)))
                ((ร m =) (+ m (frame-minwidth frp, next_curwin)))
            )
        ))

        m
    ))

;; Try to close all windows except current one.
;; Buffers in the other windows become hidden if 'hidden' is set,
;; or '!' is used and the buffer was modified.

(defn- #_void close-others [#_boolean message, #_boolean forceit]
    ;; forceit: always hide all other windows
    (ยง
        (when (one-window)
            (if message
                (msg m_onlyone))
            ((ร RETURN) nil)
        )

        ;; Be very careful here: autocommands may change the window layout.
        ((ร FOR) (ร ((ร window_C wp =) (ร @firstwin, nextwp)) (win-valid wp) ((ร wp =) nextwp))
            ((ร nextwp =) (:w_next wp))
            (when (!= wp @curwin)               ;; don't close current window
                ;; Check if it's allowed to abandon this window.
                ((ร boolean r =) (can-abandon @curbuf, forceit))
                (when (not (win-valid wp))         ;; autocommands messed wp up
                    ((ร nextwp =) @firstwin)
                    (ร CONTINUE)
                )
                (when (not r)
                    (if @(:b_changed @curbuf)
                        (ร CONTINUE)
                    )
                )
                (win-close wp, (not @(:b_changed @curbuf)))
            )
        )

        (when (and message (!= @lastwin @firstwin))
            (emsg (u8 "E445: Other window contains changes"))
        )
        nil
    ))

(defn- #_void win-init-empty [#_window_C wp]
    (ยง
        (redraw-win-later wp, NOT_VALID)

        ((ร wp.w_lines_valid =) 0)
        ((ร wp.w_cursor.lnum =) 1)
        ((ร wp.w_curswant =) (ร wp.w_cursor.col =) 0)
        ((ร wp.w_cursor.coladd =) 0)
        ((ร wp.w_pcmark.lnum =) 1)       ;; pcmark not cleared but set to line 1
        ((ร wp.w_pcmark.col =) 0)
        ((ร wp.w_prev_pcmark.lnum =) 0)
        ((ร wp.w_prev_pcmark.col =) 0)
        ((ร wp.w_topline =) 1)
        ((ร wp.w_botline =) 2)
        nil
    ))

;; Allocate the first window and put an empty buffer in it.
;; Called from main().

(defn- #_void win-alloc-first []
    (ยง
        (reset! curwin (newWindow nil))

        (reset! curbuf (newBuffer))

        ((ร @curbuf.b_nwindows =) 1)          ;; there is one window

        ;; mark cursor position as being invalid
        ((ร @curwin.w_valid =) 0)

        ;; need to set w_topline
        ((ร @curwin.w_topline =) 1)

        (win-init-empty @curwin)

        ((ร @curwin.w_frame =) (newFrame @curwin))

        (reset! topframe (:w_frame @curwin))
        ((ร @topframe.fr_width =) (int @Cols))
        ((ร @topframe.fr_height =) (int (- @Rows @p_ch)))
        ((ร @topframe.fr_win =) @curwin)

        (reset! ch_used @p_ch)
        nil
    ))

;; Create a frame for window "wp".

(defn- #_frame_C newFrame [#_window_C wp]
    (ยง
        ((ร frame_C frp =) (NEW_frame_C))

        ((ร frp.fr_layout =) FR_LEAF)
        ((ร frp.fr_win =) wp)

        frp
    ))

;; Initialize the window and frame size to the maximum.

(defn- #_void win-init-size []
    (ยง
        ((ร long rows_avail =) (- @Rows @p_ch))

        ((ร @firstwin.w_height =) (int rows_avail))
        ((ร @topframe.fr_height =) (int rows_avail))
        ((ร @firstwin.w_width =) (int @Cols))
        ((ร @topframe.fr_width =) (int @Cols))
        nil
    ))

;; Go to another window.
;; When jumping to another buffer, stop Visual mode.  Do this before
;; changing windows so we can yank the selection into the '*' register.
;; When jumping to another window on the same buffer, adjust its cursor
;; position to keep the same Visual area.

(defn- #_void win-goto [#_window_C wp]
    (ยง
        ((ร window_C owp =) @curwin)

        (when (text-locked)
            (beep-flush)
            (text-locked-msg)
            ((ร RETURN) nil)
        )

        (if @VIsual_active
            (COPY-pos (:w_cursor wp), (:w_cursor @curwin)))

        (win-enter wp)

        ;; Conceal cursor line in previous window, unconceal in current window.
        (if (and (win-valid owp) (< 0 @(:wo_cole (:w_options owp))) (zero? @msg_scrolled))
            (update-single-line owp, (:lnum (:w_cursor owp))))
        (when (and (< 0 @(:wo_cole (:w_options @curwin))) (zero? @msg_scrolled))
            (reset! need_cursor_line_redraw true)
        )
        nil
    ))

;; Move to window above or below "count" times.

(defn- #_void win-goto-ver [#_boolean up, #_long count]
    ;; up: true to go to win above
    (ยง
        ((ร frame_C foundfr =) (:w_frame @curwin))

;       end:
        (while (< 0 (ร count--))
            (ร frame_C nfr)

            ;; First go upwards in the tree of frames until we find a upwards or downwards neighbor.

            ((ร FOR) (ร ((ร frame_C fr =) foundfr) true ((ร fr =) (:fr_parent fr)))
                (if (== fr @topframe)
                    (ร BREAK end)
                )
                ((ร nfr =) (if up (:fr_prev fr) (:fr_next fr)))
                (if (and (== (:fr_layout (:fr_parent fr)) FR_COL) (non-nil? nfr))
                    (ร BREAK)
                )
            )

            ;; Now go downwards to find the bottom or top frame in it.

            (while true
                (when (== (:fr_layout nfr) FR_LEAF)
                    ((ร foundfr =) nfr)
                    (ร BREAK)
                )
                ((ร frame_C fr =) (:fr_child nfr))
                (when (== (:fr_layout nfr) FR_ROW)
                    ;; Find the frame at the cursor row.
                    (while (and (non-nil? (:fr_next fr)) (<= (+ (:w_wincol (frame2win fr)) (:fr_width fr)) (+ (:w_wincol @curwin) (:w_wcol @curwin))))
                        ((ร fr =) (:fr_next fr))
                    )
                )
                (when (and (== (:fr_layout nfr) FR_COL) up)
                    (while (non-nil? (:fr_next fr))
                        ((ร fr =) (:fr_next fr))
                    )
                )
                ((ร nfr =) fr)
            )
        )

        (when (non-nil? foundfr)
            (win-goto (:fr_win foundfr))
        )
        nil
    ))

;; Move to left or right window.

(defn- #_void win-goto-hor [#_boolean left, #_long count]
    ;; left: true to go to left win
    (ยง
        ((ร frame_C foundfr =) (:w_frame @curwin))

;       end:
        (while (< 0 (ร count--))
            (ร frame_C nfr)

            ;; First go upwards in the tree of frames until we find a left or right neighbor.

            ((ร FOR) (ร ((ร frame_C fr =) foundfr) true ((ร fr =) (:fr_parent fr)))
                (if (== fr @topframe)
                    (ร BREAK end)
                )
                ((ร nfr =) (if left (:fr_prev fr) (:fr_next fr)))
                (if (and (== (:fr_layout (:fr_parent fr)) FR_ROW) (non-nil? nfr))
                    (ร BREAK)
                )
            )

            ;; Now go downwards to find the leftmost or rightmost frame in it.

            (while true
                (when (== (:fr_layout nfr) FR_LEAF)
                    ((ร foundfr =) nfr)
                    (ร BREAK)
                )
                ((ร frame_C fr =) (:fr_child nfr))
                (when (== (:fr_layout nfr) FR_COL)
                    ;; Find the frame at the cursor row.
                    (while (and (non-nil? (:fr_next fr)) (<= (+ (:w_winrow (frame2win fr)) (:fr_height fr)) (+ (:w_winrow @curwin) (:w_wrow @curwin))))
                        ((ร fr =) (:fr_next fr))
                    )
                )
                (when (and (== (:fr_layout nfr) FR_ROW) left)
                    (while (non-nil? (:fr_next fr))
                        ((ร fr =) (:fr_next fr))
                    )
                )
                ((ร nfr =) fr)
            )
        )

        (when (non-nil? foundfr)
            (win-goto (:fr_win foundfr))
        )
        nil
    ))

;; Make window "wp" the current window.

(defn- #_void win-enter [#_window_C wp]
    (win-enter-ext wp, false)
    nil)

;; Make window wp the current window.
;; Can be called with "curwin_invalid" true, which means that curwin has just
;; been closed and isn't valid.

(defn- #_void win-enter-ext [#_window_C wp, #_boolean curwin_invalid]
    (ยง
        (if (and (== wp @curwin) (not curwin_invalid))        ;; nothing to do
            ((ร RETURN) nil)
        )

        ;; Might need to scroll the old window before switching, e.g., when the cursor was moved.
        (update-topline)

        (when (not curwin_invalid)
            (reset! prevwin @curwin)       ;; remember for CTRL-W p
            ((ร @curwin.w_redr_status =) true)
        )
        (reset! curwin wp)
        (check-cursor)
        (if (not (virtual-active))
            ((ร @curwin.w_cursor.coladd =) 0)
        )
        (changed-line-abv-curs)    ;; assume cursor position needs updating

        ((ร @curwin.w_redr_status =) true)
        (if (non-zero? @restart_edit)
            (redraw-later VALID))    ;; causes status line redraw

        ;; set window height to desired minimal value
        (cond (and (< (:w_height @curwin) @p_wh) (not @(:wo_wfh (:w_options @curwin))))
        (do
            (win-setheight (int @p_wh))
        )
        (zero? (:w_height @curwin))
        (do
            (win-setheight 1)
        ))

        ;; set window width to desired minimal value
        (when (and (< (:w_width @curwin) @p_wiw) (not @(:wo_wfw (:w_options @curwin))))
            (win-setwidth (int @p_wiw))
        )
        nil
    ))

;; Allocate a window structure and link it in the window list.

(defn- #_window_C newWindow [#_window_C after]
    (ยง
        ;; allocate window structure and linesizes arrays
        ((ร window_C wp =) (NEW_window_C))

        (win-alloc-lines wp)

        ;; link the window in the window list
        (win-append after, wp)
        ((ร wp.w_wincol =) 0)
        ((ร wp.w_width =) (int @Cols))

        ;; position the display and the cursor at the top of the file
        ((ร wp.w_topline =) 1)
        ((ร wp.w_botline =) 2)
        ((ร wp.w_cursor.lnum =) 1)
        ((ร wp.w_scbind_pos =) 1)

        ;; We won't calculate w_fraction until resizing the window.
        ((ร wp.w_fraction =) 0)
        ((ร wp.w_prev_fraction_row =) -1)

        ((ร wp.w_match_head =) nil)
        ((ร wp.w_next_match_id =) 4)

        wp
    ))

;; Remove window 'wp' from the window list and free the structure.

(defn- #_void win-free [#_window_C wp]
    (ยง
        (clear-winopt (:w_options wp))

        (if (== @prevwin wp)
            (reset! prevwin nil))

        (win-free-lines wp)

        (clear-matches wp)

        ((ร wp.w_p_cc_cols =) nil)

        (win-remove wp)
        nil
    ))

;; Append window "wp" in the window list after window "after".

(defn- #_void win-append [#_window_C after, #_window_C wp]
    (ยง
        ((ร window_C before =) (if (nil? after) @firstwin (:w_next after)))      ;; after null is in front of the first

        ((ร wp.w_next =) before)
        ((ร wp.w_prev =) after)
        (if (nil? after)
            (reset! firstwin wp)
            ((ร after.w_next =) wp)
        )
        (if (nil? before)
            (reset! lastwin wp)
            ((ร before.w_prev =) wp)
        )
        nil
    ))

;; Remove a window from the window list.

(defn- #_void win-remove [#_window_C wp]
    (ยง
        (if (non-nil? (:w_prev wp))
            ((ร wp.w_prev.w_next =) (:w_next wp))
            (reset! firstwin (:w_next wp)))

        (if (non-nil? (:w_next wp))
            ((ร wp.w_next.w_prev =) (:w_prev wp))
            (reset! lastwin (:w_prev wp)))
        nil
    ))

;; Append frame "frp" in a frame list after frame "after".

(defn- #_void frame-append [#_frame_C after, #_frame_C frp]
    (ยง
        ((ร frp.fr_next =) (:fr_next after))
        ((ร after.fr_next =) frp)
        (if (non-nil? (:fr_next frp))
            ((ร frp.fr_next.fr_prev =) frp)
        )
        ((ร frp.fr_prev =) after)
        nil
    ))

;; Insert frame "frp" in a frame list before frame "before".

(defn- #_void frame-insert [#_frame_C before, #_frame_C frp]
    (ยง
        ((ร frp.fr_next =) before)
        ((ร frp.fr_prev =) (:fr_prev before))
        ((ร before.fr_prev =) frp)
        (if (non-nil? (:fr_prev frp))
            ((ร frp.fr_prev.fr_next =) frp)
            ((ร frp.fr_parent.fr_child =) frp)
        )
        nil
    ))

;; Remove a frame from a frame list.

(defn- #_void frame-remove [#_frame_C frp]
    (ยง
        (if (non-nil? (:fr_prev frp))
            ((ร frp.fr_prev.fr_next =) (:fr_next frp))
            ((ร frp.fr_parent.fr_child =) (:fr_next frp))
        )
        (when (non-nil? (:fr_next frp))
            ((ร frp.fr_next.fr_prev =) (:fr_prev frp))
        )
        nil
    ))

;; Allocate w_lines[] for window "wp".

(defn- #_void win-alloc-lines [#_window_C wp]
    (ยง
        ((ร wp.w_lines_valid =) 0)
        ((ร wp.w_lines_len =) (int @Rows))
        ((ร wp.w_lines =) (ARRAY-wline (:w_lines_len wp)))
        nil
    ))

;; Free w_lines[] for window "wp".

(defn- #_void win-free-lines [#_window_C wp]
    (ยง
        ((ร wp.w_lines_len =) 0)
        ((ร wp.w_lines =) nil)
        nil
    ))

;; Called from win-new-shellsize() after Rows changed.
;; This only does the current tab page, others must be done when made active.

(defn- #_void shell-new-rows []
    (ยง
        ((ร long rows_avail =) (- @Rows @p_ch))

        ((ร int h =) (int rows_avail))

        (if (nil? @firstwin)           ;; not initialized yet
            ((ร RETURN) nil)
        )
        (if (< h (frame-minheight @topframe, nil))
            ((ร h =) (frame-minheight @topframe, nil))
        )

        ;; First try setting the heights of windows with 'winfixheight'.
        ;; If that doesn't result in the right height, forget about that option.
        (frame-new-height @topframe, h, false, true)
        (if (not (frame-check-height @topframe, h))
            (frame-new-height @topframe, h, false, false))

        (win-comp-pos)                 ;; recompute w_winrow and w_wincol
        (compute-cmdrow)
        (reset! ch_used @p_ch)
        nil
    ))

;; Called from win-new-shellsize() after Cols changed.

(defn- #_void shell-new-columns []
    (ยง
        (if (nil? @firstwin)           ;; not initialized yet
            ((ร RETURN) nil)
        )

        ;; First try setting the widths of windows with 'winfixwidth'.
        ;; If that doesn't result in the right width, forget about that option.
        (frame-new-width @topframe, (int @Cols), false, true)
        (if (not (frame-check-width @topframe, (int @Cols)))
            (frame-new-width @topframe, (int @Cols), false, false))

        (win-comp-pos)                 ;; recompute w_winrow and w_wincol
        nil
    ))

;; Update the position for all windows, using the width and height of the frames.
;; Returns the row just after the last window.

(defn- #_int win-comp-pos []
    (ยง
; %%    ((ร int[] row =) (ร { 0 }))
; %%    ((ร int[] col =) (ร { 0 }))

        (frame-comp-pos @topframe, row, col)
        (... row 0)
    ))

;; Update the position of the windows in frame "topfrp",
;; using the width and height of the frames.
;; "*row" and "*col" are the top-left position of the frame.
;; They are updated to the bottom-right position plus one.

(defn- #_void frame-comp-pos [#_frame_C topfrp, #_int* row, #_int* col]
    (ยง
        ((ร window_C wp =) (:fr_win topfrp))
        (cond (non-nil? wp)
        (do
            (when (or (!= (:w_winrow wp) (... row 0)) (!= (:w_wincol wp) (... col 0)))
                ;; position changed, redraw
                ((ร wp.w_winrow =) (... row 0))
                ((ร wp.w_wincol =) (... col 0))
                (redraw-win-later wp, NOT_VALID)
                ((ร wp.w_redr_status =) true)
            )
            ((ร row[0] =) (+ (... row 0) (+ (:w_height wp) (:w_status_height wp))))
            ((ร col[0] =) (+ (... col 0) (+ (:w_width wp) (:w_vsep_width wp))))
        )
        :else
        (do
            ((ร int startrow =) (... row 0))
            ((ร int startcol =) (... col 0))
            ((ร FOR) (ร ((ร frame_C frp =) (:fr_child topfrp)) (non-nil? frp) ((ร frp =) (:fr_next frp)))
                (if (== (:fr_layout topfrp) FR_ROW)
                    ((ร row[0] =) startrow)        ;; all frames are at the same row
                    ((ร col[0] =) startcol)        ;; all frames are at the same col
                )
                (frame-comp-pos frp, row, col)
            )
        ))
        nil
    ))

;; Set current window height and take care of repositioning other windows to fit around it.

(defn- #_void win-setheight [#_int height]
    (win-setheight-win height, @curwin)
    nil)

;; Set the window height of window "win" and take care of repositioning other windows to fit around it.

(defn- #_void win-setheight-win [#_int height, #_window_C win]
    (ยง
        (when (== win @curwin)
            ;; Always keep current window at least one line high, even when 'winminheight' is zero.
            (if (< height @p_wmh)
                ((ร height =) (int @p_wmh))
            )
            (if (zero? height)
                ((ร height =) 1)
            )
        )

        (frame-setheight (:w_frame win), (+ height (:w_status_height win)))

        ;; recompute the window positions
        ((ร int row =) (win-comp-pos))

        ;; If there is extra space created between the last window and the command line, clear it.

        (if (and @full_screen (zero? @msg_scrolled) (< row @cmdline_row))
            (screen-fill row, @cmdline_row, 0, (int @Cols), (byte \space), (byte \space), 0))
        (reset! cmdline_row row)
        (reset! msg_row row)
        (reset! msg_col 0)

        (redraw-all-later NOT_VALID)
        nil
    ))

;; Set the height of a frame to "height" and take care that all frames and
;; windows inside it are resized.  Also resize frames on the left and right
;; if the are in the same FR_ROW frame.
;;
;; Strategy:
;; If the frame is part of a FR_COL frame, try fitting the frame in that frame.
;; If that doesn't work (the FR_COL frame is too small), recursively go to
;; containing frames to resize them and make room.
;; If the frame is part of a FR_ROW frame, all frames must be resized as well.
;; Check for the minimal height of the FR_ROW frame.
;; At the top level we can also use change the command line height.

(defn- #_void frame-setheight [#_frame_C curfrp, #_int height]
    (ยง
        ;; If the height already is the desired value, nothing to do.
        (if (== (:fr_height curfrp) height)
            ((ร RETURN) nil)
        )

        (cond (nil? (:fr_parent curfrp))
        (do
            ((ร long rows_avail =) (- @Rows @p_ch))

            ;; topframe: can only change the command line
            (if (< rows_avail height)
                ((ร height =) (int rows_avail))
            )
            (if (< 0 height)
                (frame-new-height curfrp, height, false, false))
        )
        (== (:fr_layout (:fr_parent curfrp)) FR_ROW)
        (do
            ;; Row of frames: also need to resize frames left and right of this one.
            ;; First check for the minimal height of these.
            ((ร int h =) (frame-minheight (:fr_parent curfrp), nil))
            (if (< height h)
                ((ร height =) h)
            )
            (frame-setheight (:fr_parent curfrp), height)
        )
        :else
        (do
;           // %% red. 3x
            ((ร int room =) 0)                       ;; total number of lines available
            ((ร int room_reserved =) 0)
            ((ร int room_cmdline =) 0)               ;; lines available from cmdline

            ;; Column of frames: try to change only frames in this column.
            ;; Do this twice:
            ;; 1: compute room available, if it's not enough try resizing the containing frame.
            ;; 2: compute the room available and adjust the height to it.
            ;; Try not to reduce the height of a window with 'winfixheight' set.

            ((ร FOR) (ร ((ร int run =) 1) (<= run 2) (ร run++))
                ((ร room =) 0)                   ;; total number of lines available
                ((ร room_reserved =) 0)

                ((ร FOR) (ร ((ร frame_C frp =) (:fr_child (:fr_parent curfrp))) (non-nil? frp) ((ร frp =) (:fr_next frp)))
                    (if (and (!= frp curfrp) (non-nil? (:fr_win frp)) @(:wo_wfh (:w_options (:fr_win frp))))
                        ((ร room_reserved =) (+ room_reserved (:fr_height frp)))
                    )
                    ((ร room =) (+ room (:fr_height frp)))
                    (if (!= frp curfrp)
                        ((ร room =) (- room (frame-minheight frp, nil)))
                    )
                )
                (cond (!= (:fr_width curfrp) (int @Cols))
                (do
                    ((ร room_cmdline =) 0)
                )
                :else
                (do
                    ((ร room_cmdline =) (- (int (- @Rows @p_ch)) (+ (:w_winrow @lastwin) (:w_height @lastwin) (:w_status_height @lastwin))))
                    (if (< room_cmdline 0)
                        ((ร room_cmdline =) 0)
                    )
                ))

                (if (<= height (+ room room_cmdline))
                    (ร BREAK)
                )
                (when (or (== run 2) (== (:fr_width curfrp) (int @Cols)))
                    (if (> height (+ room room_cmdline))
                        ((ร height =) (+ room room_cmdline))
                    )
                    (ร BREAK)
                )

                (frame-setheight (:fr_parent curfrp), (- (+ height (frame-minheight (:fr_parent curfrp), NOWIN)) (int @p_wmh) 1))
            )

            ;; Compute the number of lines we will take from others frames (can be negative!).

            ((ร int take =) (- height (:fr_height curfrp)))

            ;; If there is not enough room,
            ;; also reduce the height of a window with 'winfixheight' set.

            (if (< (- (+ room room_cmdline) room_reserved) height)
                ((ร room_reserved =) (- (+ room room_cmdline) height))
            )

            ;; If there is only a 'winfixheight' window and making the window smaller,
            ;; need to make the other window taller.

            (if (and (< take 0) (< (- room (:fr_height curfrp)) room_reserved))
                ((ร room_reserved =) 0)
            )

            (when (and (< 0 take) (< 0 room_cmdline))
                ;; use lines from cmdline first
                (if (< take room_cmdline)
                    ((ร room_cmdline =) take)
                )
                ((ร take =) (- take room_cmdline))
                ((ร @topframe.fr_height =) (+ (:fr_height @topframe) room_cmdline))
            )

            ;; set the current frame to the new height

            (frame-new-height curfrp, height, false, false)

            ;; First take lines from the frames after the current frame.
            ;; If that is not enough, takes lines from frames above the current frame.

            (dotimes [#_int run 2]
                ((ร frame_C frp =) (if (zero? run)
                    (:fr_next curfrp)   ;; 1st run: start with next window
                    (:fr_prev curfrp)   ;; 2nd run: start with prev window
                ))
                (while (and (non-nil? frp) (!= take 0))
                    ((ร int h =) (frame-minheight frp, nil))
                    (cond (and (< 0 room_reserved) (non-nil? (:fr_win frp)) @(:wo_wfh (:w_options (:fr_win frp))))
                    (do
                        (cond (>= room_reserved (:fr_height frp))
                        (do
                            ((ร room_reserved =) (- room_reserved (:fr_height frp)))
                        )
                        :else
                        (do
                            (if (< take (- (:fr_height frp) room_reserved))
                                ((ร room_reserved =) (- (:fr_height frp) take))
                            )
                            ((ร take =) (- take (- (:fr_height frp) room_reserved)))
                            (frame-new-height frp, room_reserved, false, false)
                            ((ร room_reserved =) 0)
                        ))
                    )
                    :else
                    (do
                        (cond (< (- (:fr_height frp) take) h)
                        (do
                            ((ร take =) (- take (- (:fr_height frp) h)))
                            (frame-new-height frp, h, false, false)
                        )
                        :else
                        (do
                            (frame-new-height frp, (- (:fr_height frp) take), false, false)
                            ((ร take =) 0)
                        ))
                    ))
                    ((ร frp =) (if (zero? run) (:fr_next frp) (:fr_prev frp)))
                )
            )
        ))
        nil
    ))

;; Set current window width and take care of repositioning other windows to fit around it.

(defn- #_void win-setwidth [#_int width]
    (win-setwidth-win width, @curwin)
    nil)

(defn- #_void win-setwidth-win [#_int width, #_window_C win]
    (ยง
        ;; Always keep current window at least one column wide, even when 'winminwidth' is zero.
        (when (== win @curwin)
            (if (< width @p_wmw)
                ((ร width =) (int @p_wmw))
            )
            (if (zero? width)
                ((ร width =) 1)
            )
        )

        (frame-setwidth (:w_frame win), (+ width (:w_vsep_width win)))

        ;; recompute the window positions
        (win-comp-pos)

        (redraw-all-later NOT_VALID)
        nil
    ))

;; Set the width of a frame to "width"
;; and take care that all frames and windows inside it are resized.
;; Also resize frames above and below if the are in the same FR_ROW frame.
;;
;; Strategy is similar to frame-setheight().

(defn- #_void frame-setwidth [#_frame_C curfrp, #_int width]
    (ยง
        ;; If the width already is the desired value, nothing to do.
        (if (== (:fr_width curfrp) width)
            ((ร RETURN) nil)
        )

        (when (nil? (:fr_parent curfrp))
            ;; topframe: can't change width
            ((ร RETURN) nil)
        )

        (cond (== (:fr_layout (:fr_parent curfrp)) FR_COL)
        (do
            ;; Column of frames: also need to resize frames above and below of this one.
            ;; First check for the minimal width of these.
            ((ร int w =) (frame-minwidth (:fr_parent curfrp), nil))
            (if (< width w)
                ((ร width =) w)
            )
            (frame-setwidth (:fr_parent curfrp), width)
        )
        :else
        (do
;           // %% red. 2x
            ((ร int room =) 0)                       ;; total number of lines available
            ((ร int room_reserved =) 0)

            ;; Row of frames: try to change only frames in this row.
            ;; Do this twice:
            ;; 1: compute room available, if it's not enough try resizing the containing frame.
            ;; 2: compute the room available and adjust the width to it.

            ((ร FOR) (ร ((ร int run =) 1) (<= run 2) (ร run++))
                ((ร room =) 0)
                ((ร room_reserved =) 0)

                ((ร FOR) (ร ((ร frame_C frp =) (:fr_child (:fr_parent curfrp))) (non-nil? frp) ((ร frp =) (:fr_next frp)))
                    (if (and (!= frp curfrp) (non-nil? (:fr_win frp)) @(:wo_wfw (:w_options (:fr_win frp))))
                        ((ร room_reserved =) (+ room_reserved (:fr_width frp)))
                    )
                    ((ร room =) (+ room (:fr_width frp)))
                    (if (!= frp curfrp)
                        ((ร room =) (- room (frame-minwidth frp, nil)))
                    )
                )

                (if (<= width room)
                    (ร BREAK)
                )

                ((ร long rows_avail =) (- @Rows @p_ch))

                (when (or (== run 2) (<= rows_avail (:fr_height curfrp)))
                    (if (< room width)
                        ((ร width =) room)
                    )
                    (ร BREAK)
                )

                (frame-setwidth (:fr_parent curfrp), (- (+ width (frame-minwidth (:fr_parent curfrp), NOWIN)) (int @p_wmw) 1))
            )

            ;; Compute the number of lines we will take from others frames (can be negative!).

            ((ร int take =) (- width (:fr_width curfrp)))

            ;; If there is not enough room,
            ;; also reduce the width of a window with 'winfixwidth' set.

            (if (< (- room room_reserved) width)
                ((ร room_reserved =) (- room width))
            )

            ;; If there is only a 'winfixwidth' window and making the window smaller,
            ;; need to make the other window narrower.

            (if (and (< take 0) (< (- room (:fr_width curfrp)) room_reserved))
                ((ร room_reserved =) 0)
            )

            ;; set the current frame to the new width

            (frame-new-width curfrp, width, false, false)

            ;; First take lines from the frames right of the current frame.
            ;; If that is not enough, takes lines from frames left of the current frame.

            (dotimes [#_int run 2]
                ((ร frame_C frp =) (if (zero? run)
                    (:fr_next curfrp)   ;; 1st run: start with next window
                    (:fr_prev curfrp)   ;; 2nd run: start with prev window
                ))
                (while (and (non-nil? frp) (!= take 0))
                    ((ร int w =) (frame-minwidth frp, nil))
                    (cond (and (< 0 room_reserved) (non-nil? (:fr_win frp)) @(:wo_wfw (:w_options (:fr_win frp))))
                    (do
                        (cond (>= room_reserved (:fr_width frp))
                        (do
                            ((ร room_reserved =) (- room_reserved (:fr_width frp)))
                        )
                        :else
                        (do
                            (if (< take (- (:fr_width frp) room_reserved))
                                ((ร room_reserved =) (- (:fr_width frp) take))
                            )
                            ((ร take =) (- take (- (:fr_width frp) room_reserved)))
                            (frame-new-width frp, room_reserved, false, false)
                            ((ร room_reserved =) 0)
                        ))
                    )
                    :else
                    (do
                        (cond (< (- (:fr_width frp) take) w)
                        (do
                            ((ร take =) (- take (- (:fr_width frp) w)))
                            (frame-new-width frp, w, false, false)
                        )
                        :else
                        (do
                            (frame-new-width frp, (- (:fr_width frp) take), false, false)
                            ((ร take =) 0)
                        ))
                    ))
                    ((ร frp =) (if (zero? run) (:fr_next frp) (:fr_prev frp)))
                )
            )
        ))
        nil
    ))

;; Check 'winminheight' for a valid value.

(defn- #_void win-setminheight []
    (ยง
        ((ร boolean first =) true)

        ;; loop until there is a 'winminheight' that is possible
        (while (< 0 @p_wmh)
            ;; TODO: handle vertical splits
            ((ร int room =) (int (- @p_wh)))
            ((ร FOR) (ร ((ร window_C wp =) @firstwin) (non-nil? wp) ((ร wp =) (:w_next wp)))
                ((ร room =) (+ room (- (:w_height wp) @p_wmh)))
            )
            (if (<= 0 room)
                (ร BREAK)
            )
            (swap! p_wmh dec)
            (when first
                (emsg e_noroom)
                ((ร first =) false)
            )
        )
        nil
    ))

(final long FRACTION_MULT 16384)

;; Set wp.w_fraction for the current w_wrow and w_height.

(defn- #_void set-fraction [#_window_C wp]
    (ยง
        ((ร wp.w_fraction =) (int (/ (+ (* (long (:w_wrow wp)) FRACTION_MULT) (/ (long (:w_height wp)) 2)) (long (:w_height wp)))))
        nil
    ))

;; Set the height of a window.
;; This takes care of the things inside the window, not what happens to the
;; window position, the frame or to other windows.

(defn- #_void win-new-height [#_window_C wp, #_int height]
    (ยง
        ((ร int prev_height =) (:w_height wp))

        ;; Don't want a negative height.  Happens when splitting a tiny window.
        ;; Will equalize heights soon to fix it.
        (if (< height 0)
            ((ร height =) 0)
        )
        (if (== (:w_height wp) height)
            ((ร RETURN) nil)                             ;; nothing to do
        )

        (when (< 0 (:w_height wp))
            (when (== wp @curwin)
                ;; w_wrow needs to be valid.  When setting 'laststatus' this may
                ;; call win-new-height() recursively.
                (validate-cursor)
            )

            (if (!= (:w_height wp) prev_height)
                ((ร RETURN) nil)                         ;; Recursive call already changed the size,
            )
                                                ;; bail out here to avoid the following to mess things up.

            (if (!= (:w_wrow wp) (:w_prev_fraction_row wp))
                (set-fraction wp))
        )

        ((ร wp.w_height =) height)
        ((ร wp.w_skipcol =) 0)

        ;; Don't change w_topline when height is zero.  Don't set w_topline
        ;; when 'scrollbind' is set and this isn't the current window.
        (when (and (< 0 height) (or (not @(:wo_scb (:w_options wp))) (== wp @curwin)))
            ;; Find a value for w_topline that shows the cursor at the same
            ;; relative position in the window as before (more or less).

            ((ร long lnum =) (:lnum (:w_cursor wp)))
            (if (< lnum 1)           ;; can happen when starting up
                ((ร lnum =) 1)
            )
            ((ร wp.w_wrow =) (int (/ (+ (- (* (long (:w_fraction wp)) (long height)) 1) (/ FRACTION_MULT 2)) FRACTION_MULT)))
            ((ร int line_size =) (- (plines-win-col wp, lnum, (long (:col (:w_cursor wp)))) 1))
            ((ร int sline =) (- (:w_wrow wp) line_size))

            (when (<= 0 sline)
                ;; Make sure the whole cursor line is visible, if possible.
                ((ร int rows =) (plines-win wp, lnum, false))

                (when (> sline (- (:w_height wp) rows))
                    ((ร sline =) (- (:w_height wp) rows))
                    ((ร wp.w_wrow =) (- (:w_wrow wp) (- rows line_size)))
                )
            )

            (cond (< sline 0)
            (do
                ;; Cursor line would go off top of screen if w_wrow was this high.
                ;; Make cursor line the first line in the window.  If not enough
                ;; room use w_skipcol;

                ((ร wp.w_wrow =) line_size)
                (when (and (<= (:w_height wp) (:w_wrow wp)) (< 0 (- (:w_width wp) (win-col-off wp))))
                    ((ร wp.w_skipcol =) (+ (:w_skipcol wp) (- (:w_width wp) (win-col-off wp))))
                    (ร --wp.w_wrow)
                    (while (<= (:w_height wp) (:w_wrow wp))
                        ((ร wp.w_skipcol =) (+ (:w_skipcol wp) (+ (- (:w_width wp) (win-col-off wp)) (win-col-off2 wp))))
                        (ร --wp.w_wrow)
                    )
                )
                (set-topline wp, lnum)
            )
            (< 0 sline)
            (do
                (while (and (< 0 sline) (< 1 lnum))
                    (ร --lnum)
                        ((ร line_size =) (plines-win wp, lnum, true))
                    ((ร sline =) (- sline line_size))
                )

                (cond (< sline 0)
                (do
                    ;; Line we want at top would go off top of screen.  Use next line instead.

                    (ร lnum++)
                    ((ร wp.w_wrow =) (- (:w_wrow wp) (+ line_size sline)))
                )
                (< 0 sline)
                (do
                    ;; First line of file reached, use that as topline.
                    ((ร lnum =) 1)
                    ((ร wp.w_wrow =) (- (:w_wrow wp) sline))
                ))

                (set-topline wp, lnum)
            ))
        )

        (when (== wp @curwin)
            (if (non-zero? @p_so)
                (update-topline))
            (curs-columns false)    ;; validate w_wrow
        )
        (if (< 0 prev_height)
            ((ร wp.w_prev_fraction_row =) (:w_wrow wp))
        )

        (win-comp-scroll wp)
        (redraw-win-later wp, SOME_VALID)
        ((ร wp.w_redr_status =) true)
        (invalidate-botline-win wp)
        nil
    ))

;; Set the width of a window.

(defn- #_void win-new-width [#_window_C wp, #_int width]
    (ยง
        ((ร wp.w_width =) width)
        ((ร wp.w_lines_valid =) 0)
        (changed-line-abv-curs-win wp)
        (invalidate-botline-win wp)
        (when (== wp @curwin)
            (update-topline)
            (curs-columns true)     ;; validate w_wrow
        )
        (redraw-win-later wp, NOT_VALID)
        ((ร wp.w_redr_status =) true)
        nil
    ))

(defn- #_void win-comp-scroll [#_window_C wp]
    (ยง
        ((ร wp.w_options.@wo_scr =) (>>> (:w_height wp) 1))
        (when (zero? @(:wo_scr (:w_options wp)))
            ((ร wp.w_options.@wo_scr =) 1)
        )
        nil
    ))

;; command-height: called whenever "p_ch" has been changed

(defn- #_void command-height []
    (ยง
        ((ร long old_p_ch =) @ch_used)

        ;; Use the value of "p_ch" that we remembered.  This is needed for when the
        ;; GUI starts up, we can't be sure in what order things happen.  And when
        ;; "p_ch" was changed in another tab page.
        (reset! ch_used @p_ch)

        ;; Find bottom frame with width of screen.
        ((ร frame_C frp =) (:w_frame @lastwin))
        (while (and (!= (:fr_width frp) (int @Cols)) (non-nil? (:fr_parent frp)))
            ((ร frp =) (:fr_parent frp))
        )

        ;; Avoid changing the height of a window with 'winfixheight' set.
        (while (and (non-nil? (:fr_prev frp)) (== (:fr_layout frp) FR_LEAF) @(:wo_wfh (:w_options (:fr_win frp))))
            ((ร frp =) (:fr_prev frp))
        )

        (when (!= @starting NO_SCREEN)
            (reset! cmdline_row (int (- @Rows @p_ch)))

            (when (< old_p_ch @p_ch)                ;; "p_ch" got bigger
                (while (< old_p_ch @p_ch)
                    (when (nil? frp)
                        (emsg e_noroom)
                        (reset! p_ch old_p_ch)
                        (reset! ch_used @p_ch)
                        (reset! cmdline_row (int (- @Rows @p_ch)))
                        (ร BREAK)
                    )
                    ((ร int h =) (- (:fr_height frp) (frame-minheight frp, nil)))
                    (if (> h (- @p_ch old_p_ch))
                        ((ร h =) (int (- @p_ch old_p_ch)))
                    )
                    ((ร old_p_ch =) (+ old_p_ch h))
                    (frame-add-height frp, (- h))
                    ((ร frp =) (:fr_prev frp))
                )

                ;; Recompute window positions.
                (win-comp-pos)

                ;; clear the lines added to cmdline
                (if @full_screen
                    (screen-fill @cmdline_row, (int @Rows), 0, (int @Cols), (byte \space), (byte \space), 0))
                (reset! msg_row @cmdline_row)
                (reset! redraw_cmdline true)
                ((ร RETURN) nil)
            )

            (if (< @msg_row @cmdline_row)
                (reset! msg_row @cmdline_row))
            (reset! redraw_cmdline true)
        )
        (frame-add-height frp, (int (- old_p_ch @p_ch)))

        ;; Recompute window positions.
        (when (!= frp (:w_frame @lastwin))
            (win-comp-pos)
        )
        nil
    ))

;; Resize frame "frp" to be "n" lines higher (negative for less high).
;; Also resize the frames it is contained in.

(defn- #_void frame-add-height [#_frame_C frp, #_int n]
    (ยง
        (frame-new-height frp, (+ (:fr_height frp) n), false, false)
        (while true
            ((ร frp =) (:fr_parent frp))
            (if (nil? frp)
                (ร BREAK)
            )
            ((ร frp.fr_height =) (+ (:fr_height frp) n))
        )
        nil
    ))

;; Add or remove a status line for the bottom window(s), according to the value of 'laststatus'.
;; Don't make a difference between horizontal or vertical split.

(defn- #_void last-status [#_boolean morewin]
    ;; morewin: pretend there are two or more windows
    (last-status-rec @topframe, (or (== @p_ls 2) (and (== @p_ls 1) (or morewin (!= @lastwin @firstwin)))))
    nil)

(defn- #_void last-status-rec [#_frame_C fr, #_boolean statusline]
    (ยง
        (cond (== (:fr_layout fr) FR_LEAF)
        (do
            ((ร window_C wp =) (:fr_win fr))
            (cond (and (non-zero? (:w_status_height wp)) (not statusline))
            (do
                ;; remove status line
                (win-new-height wp, (+ (:w_height wp) 1))
                ((ร wp.w_status_height =) 0)
                (comp-col)
            )
            (and (zero? (:w_status_height wp)) statusline)
            (do
                ;; Find a frame to take a line from.
                ((ร frame_C fp =) fr)
                (while (<= (:fr_height fp) (frame-minheight fp, nil))
                    (when (== fp @topframe)
                        (emsg e_noroom)
                        ((ร RETURN) nil)
                    )
                    ;; In a column of frames: go to frame above.
                    ;; If already at the top or in a row of frames: go to parent.
                    ((ร fp =) (if (and (== (:fr_layout (:fr_parent fp)) FR_COL) (non-nil? (:fr_prev fp))) (:fr_prev fp) (:fr_parent fp)))
                )
                ((ร wp.w_status_height =) 1)
                (cond (!= fp fr)
                (do
                    (frame-new-height fp, (- (:fr_height fp) 1), false, false)
                    (frame-fix-height wp)
                    (win-comp-pos)
                )
                :else
                (do
                    (win-new-height wp, (- (:w_height wp) 1))
                ))
                (comp-col)
                (redraw-all-later SOME_VALID)
            ))
        )
        (== (:fr_layout fr) FR_ROW)
        (do
            ;; vertically split windows, set status line for each one
            ((ร FOR) (ร ((ร frame_C fp =) (:fr_child fr)) (non-nil? fp) ((ร fp =) (:fr_next fp)))
                (last-status-rec fp, statusline)
            )
        )
        :else
        (do
            ;; horizontally split window, set status line for last one
            (ร frame_C fp)
            ((ร FOR) (ร ((ร fp =) (:fr_child fr)) (non-nil? (:fr_next fp)) ((ร fp =) (:fr_next fp)))
                ;
            )
            (last-status-rec fp, statusline)
        ))
        nil
    ))

;; Return the minimal number of rows that is needed on the screen to display
;; the current number of windows.

(defn- #_int min-rows []
    (ยง
        (if (nil? @firstwin)       ;; not initialized yet
            ((ร RETURN) MIN_LINES)
        )

        ((ร int total =) 0)

        ((ร int n =) (frame-minheight @topframe, nil))
        (if (< total n)
            ((ร total =) n)
        )

        ((ร total =) (+ total 1))         ;; count the room for the command line

        total
    ))

;; Delete all matches in the match list of window 'wp'.

(defn- #_void clear-matches [#_window_C wp]
    (ยง
        (while (non-nil? (:w_match_head wp))
            ((ร matchitem_C mi =) (:next (:w_match_head wp)))
            ((ร wp.w_match_head.mi_match.regprog =) nil)
            ((ร wp.w_match_head =) mi)
        )

        (redraw-later SOME_VALID)
        nil
    ))

;; Return true if "topfrp" and its children are at the right height.

(defn- #_boolean frame-check-height [#_frame_C topfrp, #_int height]
    (ยง
        (if (!= (:fr_height topfrp) height)
            ((ร RETURN) false)
        )

        (when (== (:fr_layout topfrp) FR_ROW)
            ((ร FOR) (ร ((ร frame_C frp =) (:fr_child topfrp)) (non-nil? frp) ((ร frp =) (:fr_next frp)))
                (if (!= (:fr_height frp) height)
                    ((ร RETURN) false)
                )
            )
        )

        true
    ))

;; Return true if "topfrp" and its children are at the right width.

(defn- #_boolean frame-check-width [#_frame_C topfrp, #_int width]
    (ยง
        (if (!= (:fr_width topfrp) width)
            ((ร RETURN) false)
        )

        (when (== (:fr_layout topfrp) FR_COL)
            ((ร FOR) (ร ((ร frame_C frp =) (:fr_child topfrp)) (non-nil? frp) ((ร frp =) (:fr_next frp)))
                (if (!= (:fr_width frp) width)
                    ((ร RETURN) false)
                )
            )
        )

        true
    ))

;; move.c: Functions for moving the cursor and scrolling text.
;;
;; There are two ways to move the cursor:
;; 1. Move the cursor directly, the text is scrolled to keep the cursor in the window.
;; 2. Scroll the text, the cursor is moved into the text visible in the window.
;; The 'scrolloff' option makes this a bit complicated.

(class! #_final lineoff_C
    [
        (field long     lnum)       ;; line number
        (field int      height)     ;; height of added line
    ])

(defn- #_void COPY-lineoff [#_lineoff_C lo1, #_lineoff_C lo0]
    (ยง
        ((ร lo1.lnum =) (:lnum lo0))
        ((ร lo1.height =) (:height lo0))
        nil
    ))

;; Compute wp.w_botline for the current wp.w_topline.
;; Can be called after wp.w_topline changed.

(defn- #_void comp-botline [#_window_C wp]
    (ยง
        (ร long lnum)
        (ร int done)

        ;; If w_cline_row is valid, start there.
        ;; Otherwise have to start at w_topline.

        (check-cursor-moved wp)
        (cond (flag? (:w_valid wp) VALID_CROW)
        (do
            ((ร lnum =) (:lnum (:w_cursor wp)))
            ((ร done =) (:w_cline_row wp))
        )
        :else
        (do
            ((ร lnum =) (:w_topline wp))
            ((ร done =) 0)
        ))

        ((ร FOR) (ร nil (<= lnum (:ml_line_count (:b_ml @curbuf))) (ร lnum++))
            ((ร int n =) (plines-win wp, lnum, true))
            (when (== lnum (:lnum (:w_cursor wp)))
                ((ร wp.w_cline_row =) done)
                ((ร wp.w_cline_height =) n)
                (redraw-for-cursorline wp)
                ((ร wp.w_valid =) (| (:w_valid wp) (| VALID_CROW VALID_CHEIGHT)))
            )
            (if (< (:w_height wp) (+ done n))
                (ร BREAK)
            )
            ((ร done =) (+ done n))
        )

        ;; wp.w_botline is the line that is just below the window
        ((ร wp.w_botline =) lnum)
        ((ร wp.w_valid =) (| (:w_valid wp) (| VALID_BOTLINE VALID_BOTLINE_AP)))

        (set-empty-rows wp, done)
        nil
    ))

;; Redraw when w_cline_row changes and 'relativenumber' or 'cursorline' is set.

(defn- #_void redraw-for-cursorline [#_window_C wp]
    (let [options (:w_options wp)]
        (when (and (or @(:wo_rnu options) @(:wo_cul options)) (non-flag? (:w_valid wp) VALID_CROW))
            (redraw-win-later wp, SOME_VALID)
        )
        nil
    ))

;; Update curwin.w_topline and redraw if necessary.
;; Used to update the screen before printing a message.

(defn- #_void update-topline-redraw []
    (update-topline)
    (when (non-zero? @must_redraw)
        (update-screen 0)
    )
    nil)

;; Update curwin.w_topline to move the cursor onto the screen.

(defn- #_void update-topline []
    (ยง
        ((ร boolean check_topline =) false)
        ((ร boolean check_botline =) false)
        ((ร long save_so =) @p_so)

        (if (not (screen-valid true))
            ((ร RETURN) nil)
        )

        ;; If the window height is zero just use the cursor line.
        (when (zero? (:w_height @curwin))
            ((ร @curwin.w_topline =) (:lnum (:w_cursor @curwin)))
            ((ร @curwin.w_botline =) (:w_topline @curwin))
            ((ร @curwin.w_valid =) (| (:w_valid @curwin) (| VALID_BOTLINE VALID_BOTLINE_AP)))
            ((ร @curwin.w_scbind_pos =) 1)
            ((ร RETURN) nil)
        )

        (check-cursor-moved @curwin)
        (if (flag? (:w_valid @curwin) VALID_TOPLINE)
            ((ร RETURN) nil)
        )

        ((ร long old_topline =) (:w_topline @curwin))

        ;; If the buffer is empty, always set topline to 1.

        (cond (bufempty)             ;; special case - file is empty
        (do
            (if (!= (:w_topline @curwin) 1)
                (redraw-later NOT_VALID))
            ((ร @curwin.w_topline =) 1)
            ((ร @curwin.w_botline =) 2)
            ((ร @curwin.w_valid =) (| (:w_valid @curwin) (| VALID_BOTLINE VALID_BOTLINE_AP)))
            ((ร @curwin.w_scbind_pos =) 1)
        )

        ;; If the cursor is above or near the top of the window, scroll the window
        ;; to show the line the cursor is in, with 'scrolloff' context.

        :else
        (do
            (when (< 1 (:w_topline @curwin))
                ;; If the cursor is above topline, scrolling is always needed.
                ;; If the cursor is far below topline and there is no folding,
                ;; scrolling down is never needed.
                (cond (< (:lnum (:w_cursor @curwin)) (:w_topline @curwin))
                (do
                    ((ร check_topline =) true)
                )
                (check-top-offset)
                (do
                    ((ร check_topline =) true)
                ))
            )

            (cond check_topline
            (do
                ((ร int halfheight =) (- (/ (:w_height @curwin) 2) 1))
                (if (< halfheight 2)
                    ((ร halfheight =) 2)
                )

                ((ร int n =) (int (- (+ (:w_topline @curwin) @p_so) (:lnum (:w_cursor @curwin)))))

                ;; If we weren't very close to begin with, we scroll to put the
                ;; cursor in the middle of the window.  Otherwise put the cursor
                ;; near the top of the window.
                (cond (<= halfheight n)
                (do
                    (scroll-cursor-halfway false)
                )
                :else
                (do
                    (scroll-cursor-top (scrolljump-value), false)
                    ((ร check_botline =) true)
                ))
            )
            :else
            (do
                ((ร check_botline =) true)
            ))
        ))

        ;; If the cursor is below the bottom of the window, scroll the window
        ;; to put the cursor on the window.
        ;; When w_botline is invalid, recompute it first, to avoid a redraw later.
        ;; If w_botline was approximated, we might need a redraw later in a few
        ;; cases, but we don't want to spend (a lot of) time recomputing w_botline
        ;; for every small change.

        (when check_botline
            (if (non-flag? (:w_valid @curwin) VALID_BOTLINE_AP)
                (validate-botline))

            (when (<= (:w_botline @curwin) (:ml_line_count (:b_ml @curbuf)))
                (when (< (:lnum (:w_cursor @curwin)) (:w_botline @curwin))
                    (cond (<= (- (:w_botline @curwin) @p_so) (:lnum (:w_cursor @curwin)))
                    (do
                        ;; Cursor is (a few lines) above botline,
                        ;; check if there are 'scrolloff' window lines below the cursor.
                        ;; If not, need to scroll.
                        ((ร int n =) (:w_empty_rows @curwin))
                        ((ร lineoff_C loff =) (NEW_lineoff_C))
                        ((ร loff.lnum =) (:lnum (:w_cursor @curwin)))
                        ((ร loff.height =) 0)
                        (while (< (:lnum loff) (:w_botline @curwin))
                            ((ร n =) (+ n (:height loff)))
                            (if (<= @p_so n)
                                (ร BREAK)
                            )
                            (botline-forw loff)
                        )
                        (when (<= @p_so n)
                            ;; sufficient context, no need to scroll
                            ((ร check_botline =) false)
                        )
                    )
                    :else
                    (do
                        ;; sufficient context, no need to scroll
                        ((ร check_botline =) false)
                    ))
                )
                (when check_botline
                    ((ร long line_count =) (+ (+ (- (:lnum (:w_cursor @curwin)) (:w_botline @curwin)) 1) @p_so))
                    (if (<= line_count (+ (:w_height @curwin) 1))
                        (scroll-cursor-bot (scrolljump-value), false)
                        (scroll-cursor-halfway false))
                )
            )
        )
        ((ร @curwin.w_valid =) (| (:w_valid @curwin) VALID_TOPLINE))

        ;; Need to redraw when topline changed.

        (when (!= (:w_topline @curwin) old_topline)
            (cond (non-zero? (:w_skipcol @curwin))
            (do
                ((ร @curwin.w_skipcol =) 0)
                (redraw-later NOT_VALID)
            )
            :else
            (do
                (redraw-later VALID)
            ))
            ;; May need to set w_skipcol when cursor in w_topline.
            (if (== (:lnum (:w_cursor @curwin)) (:w_topline @curwin))
                (validate-cursor))
        )

        (reset! p_so save_so)
        nil
    ))

;; Return the scrolljump value to use for the current window.
;; When 'scrolljump' is positive use it as-is.
;; When 'scrolljump' is negative use it as a percentage of the window height.

(defn- #_int scrolljump-value []
    (if (<= 0 @p_sj) (int @p_sj) (/ (* (:w_height @curwin) (int (- @p_sj))) 100)))

;; Return true when there are not 'scrolloff' lines above the cursor for the current window.

(defn- #_boolean check-top-offset []
    (ยง
        (when (< (:lnum (:w_cursor @curwin)) (+ (:w_topline @curwin) @p_so))
            ((ร lineoff_C loff =) (NEW_lineoff_C))
            ((ร loff.lnum =) (:lnum (:w_cursor @curwin)))

            ((ร int n =) 0)
            ;; Count the visible screen lines above the cursor line.
            ((ร FOR) (ร nil (< n @p_so) ((ร n =) (+ n (:height loff))))
                (topline-back loff)
                ;; Stop when included a line above the window.
                (if (< (:lnum loff) (:w_topline @curwin))
                    (ร BREAK)
                )
            )

            (if (< n @p_so)
                ((ร RETURN) true)
            )
        )

        false
    ))

(defn- #_void update-curswant []
    (ยง
        (when (:w_set_curswant @curwin)
            (validate-virtcol)
            ((ร @curwin.w_curswant =) (:w_virtcol @curwin))
            ((ร @curwin.w_set_curswant =) false)
        )
        nil
    ))

;; Check if the cursor has moved.  Set the w_valid flag accordingly.

(defn- #_void check-cursor-moved [#_window_C wp]
    (ยง
        (cond (!= (:lnum (:w_cursor wp)) (:lnum (:w_valid_cursor wp)))
        (do
            ((ร wp.w_valid =) (& (:w_valid wp) (bit-not (| VALID_WROW VALID_WCOL VALID_VIRTCOL VALID_CHEIGHT VALID_CROW VALID_TOPLINE))))
            (COPY-pos (:w_valid_cursor wp), (:w_cursor wp))
            ((ร wp.w_valid_leftcol =) (:w_leftcol wp))
        )
        (or (!= (:col (:w_cursor wp)) (:col (:w_valid_cursor wp))) (!= (:w_leftcol wp) (:w_valid_leftcol wp)) (!= (:coladd (:w_cursor wp)) (:coladd (:w_valid_cursor wp))))
        (do
            ((ร wp.w_valid =) (& (:w_valid wp) (bit-not (| VALID_WROW VALID_WCOL VALID_VIRTCOL))))
            ((ร wp.w_valid_cursor.col =) (:col (:w_cursor wp)))
            ((ร wp.w_valid_leftcol =) (:w_leftcol wp))
            ((ร wp.w_valid_cursor.coladd =) (:coladd (:w_cursor wp)))
        ))
        nil
    ))

;; Call this function when some window settings have changed, which require
;; the cursor position, botline and topline to be recomputed and the window
;; to be redrawn.  E.g, when changing the 'wrap' option or folding.

(defn- #_void changed-window-setting []
    (changed-window-setting-win @curwin)
    nil)

(defn- #_void changed-window-setting-win [#_window_C wp]
    (ยง
        ((ร wp.w_lines_valid =) 0)
        (changed-line-abv-curs-win wp)
        ((ร wp.w_valid =) (& (:w_valid wp) (bit-not (| VALID_BOTLINE VALID_BOTLINE_AP VALID_TOPLINE))))
        (redraw-win-later wp, NOT_VALID)
        nil
    ))

;; Set wp.w_topline to a certain number.

(defn- #_void set-topline [#_window_C wp, #_long lnum]
    (ยง
        ;; Approximate the value of w_botline.
        ((ร wp.w_botline =) (+ (:w_botline wp) (- lnum (:w_topline wp))))
        ((ร wp.w_topline =) lnum)
        ((ร wp.w_topline_was_set =) true)
        ((ร wp.w_valid =) (& (:w_valid wp) (bit-not (| VALID_WROW VALID_CROW VALID_BOTLINE VALID_TOPLINE))))
        ;; Don't set VALID_TOPLINE here, 'scrolloff' needs to be checked.
        (redraw-later VALID)
        nil
    ))

;; Call this function when the length of the cursor line (in screen
;; characters) has changed, and the change is before the cursor.
;; Need to take care of w_botline separately!

(defn- #_void changed-cline-bef-curs []
    (ยง
        ((ร @curwin.w_valid =) (& (:w_valid @curwin) (bit-not (| VALID_WROW VALID_WCOL VALID_VIRTCOL VALID_CHEIGHT VALID_TOPLINE))))
        nil
    ))

(defn- #_void changed-cline-bef-curs-win [#_window_C wp]
    (ยง
        ((ร wp.w_valid =) (& (:w_valid wp) (bit-not (| VALID_WROW VALID_WCOL VALID_VIRTCOL VALID_CHEIGHT VALID_TOPLINE))))
        nil
    ))

;; Call this function when the length of a line (in screen characters) above
;; the cursor have changed.
;; Need to take care of w_botline separately!

(defn- #_void changed-line-abv-curs []
    (ยง
        ((ร @curwin.w_valid =) (& (:w_valid @curwin) (bit-not (| VALID_WROW VALID_WCOL VALID_VIRTCOL VALID_CROW VALID_CHEIGHT VALID_TOPLINE))))
        nil
    ))

(defn- #_void changed-line-abv-curs-win [#_window_C wp]
    (ยง
        ((ร wp.w_valid =) (& (:w_valid wp) (bit-not (| VALID_WROW VALID_WCOL VALID_VIRTCOL VALID_CROW VALID_CHEIGHT VALID_TOPLINE))))
        nil
    ))

;; Make sure the value of curwin.w_botline is valid.

(defn- #_void validate-botline []
    (when (non-flag? (:w_valid @curwin) VALID_BOTLINE)
        (comp-botline @curwin)
    )
    nil)

;; Mark curwin.w_botline as invalid (because of some change in the buffer).

(defn- #_void invalidate-botline []
    (ยง
        ((ร @curwin.w_valid =) (& (:w_valid @curwin) (bit-not (| VALID_BOTLINE VALID_BOTLINE_AP))))
        nil
    ))

(defn- #_void invalidate-botline-win [#_window_C wp]
    (ยง
        ((ร wp.w_valid =) (& (:w_valid wp) (bit-not (| VALID_BOTLINE VALID_BOTLINE_AP))))
        nil
    ))

(defn- #_void approximate-botline-win [#_window_C wp]
    (ยง
        ((ร wp.w_valid =) (& (:w_valid wp) (bit-not VALID_BOTLINE)))
        nil
    ))

;; Return true if curwin.w_wrow and curwin.w_wcol are valid.

(defn- #_boolean cursor-valid []
    (let [row|col (| VALID_WROW VALID_WCOL)]
        (check-cursor-moved @curwin)
        (== (& (:w_valid @curwin) row|col) row|col)
    ))

;; Validate cursor position.  Makes sure w_wrow and w_wcol are valid.
;; w_topline must be valid, you may need to call update-topline() first!

(defn- #_void validate-cursor []
    (when (not (cursor-valid))
        (curs-columns true)
    )
    nil)

;; Compute wp.w_cline_row and wp.w_cline_height, based on the current value of wp.w_topline.

(defn- #_void curs-rows [#_window_C wp]
    (ยง
        ;; check if wp.w_lines[].wl_size is invalid
        ((ร boolean all_invalid =) (or (not (redrawing)) (== (:w_lines_valid wp) 0) (< (:w_topline wp) (:wl_lnum (... (:w_lines wp) 0)))))
        ((ร int i =) 0)
        ((ร wp.w_cline_row =) 0)
        ((ร FOR) (ร ((ร long lnum =) (:w_topline wp)) (< lnum (:lnum (:w_cursor wp))) (ร i++))
            ((ร boolean valid =) false)
            (when (and (not all_invalid) (< i (:w_lines_valid wp)))
                (if (or (< (:wl_lnum (... (:w_lines wp) i)) lnum) (not (:wl_valid (... (:w_lines wp) i))))
                    (ร CONTINUE)               ;; skip changed or deleted lines
                )
                (cond (== (:wl_lnum (... (:w_lines wp) i)) lnum)
                (do
                    ((ร valid =) true)
                )
                (< lnum (:wl_lnum (... (:w_lines wp) i)))
                (do
                    (ร --i)                    ;; hold at inserted lines
                ))
            )
            (cond valid
            (do
                (ร lnum++)
                ((ร wp.w_cline_row =) (+ (:w_cline_row wp) (:wl_size (... (:w_lines wp) i))))
            )
            :else
            (do
                ((ร wp.w_cline_row =) (+ (:w_cline_row wp) (plines-win wp, (ร lnum++), true)))
            ))
        )

        (check-cursor-moved wp)
        (when (non-flag? (:w_valid wp) VALID_CHEIGHT)
            (cond (or all_invalid (== i (:w_lines_valid wp)) (and (< i (:w_lines_valid wp)) (or (not (:wl_valid (... (:w_lines wp) i))) (!= (:wl_lnum (... (:w_lines wp) i)) (:lnum (:w_cursor wp))))))
            (do
                ((ร wp.w_cline_height =) (plines-win wp, (:lnum (:w_cursor wp)), true))
            )
            (< (:w_lines_valid wp) i)
            (do
                ;; a line that is too long to fit on the last screen line
                ((ร wp.w_cline_height =) 0)
            )
            :else
            (do
                ((ร wp.w_cline_height =) (:wl_size (... (:w_lines wp) i)))
            ))
        )

        (redraw-for-cursorline @curwin)
        ((ร wp.w_valid =) (| (:w_valid wp) (| VALID_CROW VALID_CHEIGHT)))
        nil
    ))

;; Validate curwin.w_virtcol only.

(defn- #_void validate-virtcol []
    (validate-virtcol-win @curwin)
    nil)

;; Validate wp.w_virtcol only.

(defn- #_void validate-virtcol-win [#_window_C wp]
    (ยง
        (check-cursor-moved wp)
        (when (non-flag? (:w_valid wp) VALID_VIRTCOL)
; %%        ((ร int[] vcol =) (ร { (wp.w_virtcol) }))
            (getvvcol wp, (:w_cursor wp), nil, vcol, nil)
            ((ร wp.w_virtcol =) (... vcol 0))
            ((ร wp.w_valid =) (| (:w_valid wp) VALID_VIRTCOL))
            (if @(:wo_cuc (:w_options wp))
                (redraw-win-later wp, SOME_VALID))
        )
        nil
    ))

;; Validate curwin.w_cline_height only.

(defn- #_void validate-cheight []
    (ยง
        (check-cursor-moved @curwin)
        (when (non-flag? (:w_valid @curwin) VALID_CHEIGHT)
            ((ร @curwin.w_cline_height =) (plines (:lnum (:w_cursor @curwin))))
            ((ร @curwin.w_valid =) (| (:w_valid @curwin) VALID_CHEIGHT))
        )
        nil
    ))

;; Validate w_wcol and w_virtcol only.

(defn- #_void validate-cursor-col []
    (ยง
        (validate-virtcol)
        (when (non-flag? (:w_valid @curwin) VALID_WCOL)
            ((ร int col =) (:w_virtcol @curwin))
            ((ร int off =) (curwin-col-off))
            ((ร col =) (+ col off))
            ((ร int width =) (+ (- (:w_width @curwin) off) (curwin-col-off2)))

            ;; long line wrapping, adjust curwin.w_wrow
            (when (and @(:wo_wrap (:w_options @curwin)) (<= (:w_width @curwin) col) (< 0 width))
                ;; use same formula as what is used in curs-columns()
                ((ร col =) (- col (* (+ (/ (- col (:w_width @curwin)) width) 1) width)))
            )
            (if (< (:w_leftcol @curwin) col)
                ((ร col =) (- col (:w_leftcol @curwin)))
                ((ร col =) 0)
            )
            ((ร @curwin.w_wcol =) col)

            ((ร @curwin.w_valid =) (| (:w_valid @curwin) VALID_WCOL))
        )
        nil
    ))

;; Compute offset of a window, occupied by absolute or relative line number,
;; fold column and sign column (these don't move when scrolling horizontally).

(defn- #_int win-col-off [#_window_C wp]
    (let [options (:w_options wp)]
        (+ (if (or @(:wo_nu options) @(:wo_rnu options)) (+ (number-width wp) 1) 0) (if (or (zero? @cmdwin_type) (!= wp @curwin)) 0 1))
    ))

(defn- #_int curwin-col-off []
    (win-col-off @curwin))

;; Return the difference in column offset for the second screen line of a wrapped line.
;; It's 8 if 'number' or 'relativenumber' is on and 'n' is in 'cpoptions'.

(defn- #_int win-col-off2 [#_window_C wp]
    (let [options (:w_options wp)]
        (if (and (or @(:wo_nu options) @(:wo_rnu options)) (non-nil? (vim-strbyte @p_cpo, CPO_NUMCOL)))
            (+ (number-width wp) 1)
            0
        )
    ))

(defn- #_int curwin-col-off2 []
    (win-col-off2 @curwin))

;; compute curwin.w_wcol and curwin.w_virtcol.
;; Also updates curwin.w_wrow and curwin.w_cline_row.
;; Also updates curwin.w_leftcol.

(defn- #_void curs-columns [#_boolean may_scroll]
    ;; may_scroll: when true, may scroll horizontally
    (ยง
        ;; First make sure that w_topline is valid (after moving the cursor).

        (update-topline)

        ;; Next make sure that w_cline_row is valid.

        (if (non-flag? (:w_valid @curwin) VALID_CROW)
            (curs-rows @curwin))

        ;; Compute the number of virtual columns.

        ((ร int[] startcol =) (ร new int[1]))
; %%    ((ร int[] vcol =) (ร { (@curwin.w_virtcol) }))
        ((ร int[] endcol =) (ร new int[1]))
        (getvvcol @curwin, (:w_cursor @curwin), startcol, vcol, endcol)
        ((ร @curwin.w_virtcol =) (... vcol 0))

        ;; offset for first screen line
        ((ร int extra =) (curwin-col-off))
        ((ร @curwin.w_wcol =) (+ (:w_virtcol @curwin) extra))
        ((ร endcol[0] =) (+ (... endcol 0) extra))

        ;; Now compute w_wrow, counting screen lines from w_cline_row.

        ((ร @curwin.w_wrow =) (:w_cline_row @curwin))

        ((ร int width =) 0)

        ((ร int textwidth =) (- (:w_width @curwin) extra))
        (cond (<= textwidth 0)
        (do
            ;; No room for text, put cursor in last char of window.
            ((ร @curwin.w_wcol =) (- (:w_width @curwin) 1))
            ((ร @curwin.w_wrow =) (- (:w_height @curwin) 1))
        )
        (and @(:wo_wrap (:w_options @curwin)) (non-zero? (:w_width @curwin)))
        (do
            ((ร width =) (+ textwidth (curwin-col-off2)))

            ;; long line wrapping, adjust curwin.w_wrow
            (when (<= (:w_width @curwin) (:w_wcol @curwin))
                ;; this same formula is used in validate-cursor-col()
                ((ร int n =) (+ (/ (- (:w_wcol @curwin) (:w_width @curwin)) width) 1))
                ((ร @curwin.w_wcol =) (- (:w_wcol @curwin) (* n width)))
                ((ร @curwin.w_wrow =) (+ (:w_wrow @curwin) n))

                ;; When cursor wraps to first char of next line in Insert mode,
                ;; the 'showbreak' string isn't shown, backup to first column.
                (if (and (non-eos? @p_sbr) (eos? (ml-get-cursor)) (== (:w_wcol @curwin) (mb-string2cells @p_sbr, -1)))
                    ((ร @curwin.w_wcol =) 0)
                )
            )
        )
        ;; No line wrapping: compute curwin.w_leftcol if scrolling is on and line is not folded.
        ;; If scrolling is off, curwin.w_leftcol is assumed to be 0.
        may_scroll
        (do
            ;; If Cursor is left of the screen, scroll rightwards.
            ;; If Cursor is right of the screen, scroll leftwards.
            ;; If we get closer to the edge than 'sidescrolloff', scroll a little extra.

            ((ร int off_left =) (- (... startcol 0) (:w_leftcol @curwin) (int @p_siso)))
            ((ร int off_right =) (+ (- (... endcol 0) (- (+ (:w_leftcol @curwin) (:w_width @curwin)) (int @p_siso))) 1))
            (when (or (< off_left 0) (< 0 off_right))
                ((ร int diff =) (if (< off_left 0) (- off_left) off_right))

                ;; When far off or not enough room on either side, put cursor in middle of window.
                (ร int new_leftcol)
                (cond (or (zero? @p_ss) (<= (/ textwidth 2) diff) (<= off_left off_right))
                (do
                    ((ร new_leftcol =) (- (:w_wcol @curwin) extra (/ textwidth 2)))
                )
                :else
                (do
                    (if (< diff @p_ss)
                        ((ร diff =) (int @p_ss))
                    )
                    ((ร new_leftcol =) (if (< off_left 0) (- (:w_leftcol @curwin) diff) (+ (:w_leftcol @curwin) diff)))
                ))
                (if (< new_leftcol 0)
                    ((ร new_leftcol =) 0)
                )
                (when (!= new_leftcol (:w_leftcol @curwin))
                    ((ร @curwin.w_leftcol =) new_leftcol)
                    ;; screen has to be redrawn with new curwin.w_leftcol
                    (redraw-later NOT_VALID)
                )
            )
            ((ร @curwin.w_wcol =) (- (:w_wcol @curwin) (:w_leftcol @curwin)))
        )
        (< (:w_leftcol @curwin) (:w_wcol @curwin))
        (do
            ((ร @curwin.w_wcol =) (- (:w_wcol @curwin) (:w_leftcol @curwin)))
        )
        :else
        (do
            ((ร @curwin.w_wcol =) 0)
        ))

        ((ร int prev_skipcol =) (:w_skipcol @curwin))

        ((ร int p_lines =) 0)
        (cond (and (or (<= (:w_height @curwin) (:w_wrow @curwin)) (and (or (< 0 prev_skipcol) (<= (:w_height @curwin) (+ (:w_wrow @curwin) @p_so))) (<= (:w_height @curwin) (- ((ร p_lines =) (plines-win @curwin, (:lnum (:w_cursor @curwin)), false)) 1)))) (!= (:w_height @curwin) 0) (== (:lnum (:w_cursor @curwin)) (:w_topline @curwin)) (< 0 width) (!= (:w_width @curwin) 0))
        (do
            ;; Cursor past end of screen.  Happens with a single line that does
            ;; not fit on screen.  Find a skipcol to show the text around the
            ;; cursor.  Avoid scrolling all the time. compute value of "extra":
            ;; 1: less than "p_so" lines above
            ;; 2: less than "p_so" lines below
            ;; 3: both of them
            ((ร extra =) 0)
            (if (< (:w_virtcol @curwin) (+ (:w_skipcol @curwin) (* @p_so width)))
                ((ร extra =) 1)
            )
            ;; Compute last display line of the buffer line that we want at the bottom of the window.
            (if (zero? p_lines)
                ((ร p_lines =) (plines-win @curwin, (:lnum (:w_cursor @curwin)), false))
            )
            (ร --p_lines)
            ((ร int n =) (if (< (+ (:w_wrow @curwin) @p_so) p_lines) (+ (:w_wrow @curwin) (int @p_so)) p_lines))
            (if (<= (+ (:w_height @curwin) (/ (:w_skipcol @curwin) width)) n)
                ((ร extra =) (+ extra 2))
            )

            (cond (or (== extra 3) (< p_lines (* @p_so 2)))
            (do
                ;; not enough room for 'scrolloff', put cursor in the middle
                ((ร n =) (/ (:w_virtcol @curwin) width))
                (if (< (/ (:w_height @curwin) 2) n)
                    ((ร n =) (- n (/ (:w_height @curwin) 2)))
                    ((ร n =) 0)
                )
                ;; don't skip more than necessary
                (if (> n (+ (- p_lines (:w_height @curwin)) 1))
                    ((ร n =) (+ (- p_lines (:w_height @curwin)) 1))
                )
                ((ร @curwin.w_skipcol =) (* n width))
            )
            (== extra 1)
            (do
                ;; less then 'scrolloff' lines above, decrease skipcol
                ((ร extra =) (/ (- (+ (- (+ (:w_skipcol @curwin) (* (int @p_so) width)) (:w_virtcol @curwin)) width) 1) width))
                (when (< 0 extra)
                    (if (< (:w_skipcol @curwin) (* extra width))
                        ((ร extra =) (/ (:w_skipcol @curwin) width))
                    )
                    ((ร @curwin.w_skipcol =) (- (:w_skipcol @curwin) (* extra width)))
                )
            )
            (== extra 2)
            (do
                ;; less then 'scrolloff' lines below, increase skipcol
                ((ร endcol[0] =) (* (+ (- n (:w_height @curwin)) 1) width))
                (while (< (:w_virtcol @curwin) (... endcol 0))
                    ((ร endcol[0] =) (- (... endcol 0) width))
                )
                (if (< (:w_skipcol @curwin) (... endcol 0))
                    ((ร @curwin.w_skipcol =) (... endcol 0))
                )
            ))

            ((ร @curwin.w_wrow =) (- (:w_wrow @curwin) (/ (:w_skipcol @curwin) width)))
            (when (<= (:w_height @curwin) (:w_wrow @curwin))
                ;; small window, make sure cursor is in it
                ((ร extra =) (+ (- (:w_wrow @curwin) (:w_height @curwin)) 1))
                ((ร @curwin.w_skipcol =) (+ (:w_skipcol @curwin) (* extra width)))
                ((ร @curwin.w_wrow =) (- (:w_wrow @curwin) extra))
            )

            ((ร extra =) (/ (- prev_skipcol (:w_skipcol @curwin)) width))
            (cond (< 0 extra)
            (do
                (win-ins-lines @curwin, 0, extra, false, false)
            )
            (< extra 0)
            (do
                (win-del-lines @curwin, 0, (- extra), false, false)
            ))
        )
        :else
        (do
            ((ร @curwin.w_skipcol =) 0)
        ))
        (if (!= prev_skipcol (:w_skipcol @curwin))
            (redraw-later NOT_VALID))

        ;; Redraw when w_virtcol changes and 'cursorcolumn' is set.
        (if (and @(:wo_cuc (:w_options @curwin)) (non-flag? (:w_valid @curwin) VALID_VIRTCOL))
            (redraw-later SOME_VALID))

        ((ร @curwin.w_valid =) (| (:w_valid @curwin) (| VALID_WCOL VALID_WROW VALID_VIRTCOL)))
        nil
    ))

;; Scroll the current window down by "line_count" logical lines.  "CTRL-Y"

(defn- #_void scrolldown [#_long line_count]
    (ยง
        ((ร long done =) 0)              ;; total # of physical lines done
        ((ร boolean moved =) false)

        (validate-cursor)          ;; w_wrow needs to be valid
        (while (< 0 (ร line_count--))
            (if (== (:w_topline @curwin) 1)
                (ร BREAK)
            )
            (ร --@curwin.w_topline)
            ((ร done =) (+ done (plines (:w_topline @curwin))))

            (ร --@curwin.w_botline)         ;; approximate w_botline
            (invalidate-botline)
        )
        ((ร @curwin.w_wrow =) (+ (:w_wrow @curwin) done))          ;; keep w_wrow updated
        ((ร @curwin.w_cline_row =) (+ (:w_cline_row @curwin) done))     ;; keep w_cline_row updated

        ;; Compute the row number of the last row of the cursor line
        ;; and move the cursor onto the displayed part of the window.

        ((ร int wrow =) (:w_wrow @curwin))
        (when (and @(:wo_wrap (:w_options @curwin)) (non-zero? (:w_width @curwin)))
            (validate-virtcol)
            (validate-cheight)
            ((ร wrow =) (+ wrow (- (:w_cline_height @curwin) 1 (/ (:w_virtcol @curwin) (:w_width @curwin)))))
        )
        (while (and (<= (:w_height @curwin) wrow) (< 1 (:lnum (:w_cursor @curwin))))
            ((ร wrow =) (- wrow (plines (ร @curwin.w_cursor.lnum--))))
            ((ร @curwin.w_valid =) (& (:w_valid @curwin) (bit-not (| VALID_WROW VALID_WCOL VALID_CHEIGHT VALID_CROW VALID_VIRTCOL))))
            ((ร moved =) true)
        )
        (when moved
            (coladvance (:w_curswant @curwin))
        )
        nil
    ))

;; Scroll the current window up by "line_count" logical lines.  "CTRL-E"

(defn- #_void scrollup [#_long line_count]
    (ยง
        ((ร @curwin.w_topline =) (+ (:w_topline @curwin) line_count))
        ((ร @curwin.w_botline =) (+ (:w_botline @curwin) line_count))     ;; approximate w_botline

        (if (> (:w_topline @curwin) (:ml_line_count (:b_ml @curbuf)))
            ((ร @curwin.w_topline =) (:ml_line_count (:b_ml @curbuf)))
        )
        (if (> (:w_botline @curwin) (+ (:ml_line_count (:b_ml @curbuf)) 1))
            ((ร @curwin.w_botline =) (+ (:ml_line_count (:b_ml @curbuf)) 1))
        )

        ((ร @curwin.w_valid =) (& (:w_valid @curwin) (bit-not (| VALID_WROW VALID_CROW VALID_BOTLINE))))
        (when (< (:lnum (:w_cursor @curwin)) (:w_topline @curwin))
            ((ร @curwin.w_cursor.lnum =) (:w_topline @curwin))
            ((ร @curwin.w_valid =) (& (:w_valid @curwin) (bit-not (| VALID_WROW VALID_WCOL VALID_CHEIGHT VALID_CROW VALID_VIRTCOL))))
            (coladvance (:w_curswant @curwin))
        )
        nil
    ))

;; Add one line above "lp.lnum".  This can be a filler line, a closed fold or
;; a (wrapped) text line.  Uses and sets "lp.fill".
;; Returns the height of the added line in "lp.height".
;; Lines above the first one are incredibly high: MAXCOL.

(defn- #_void topline-back [#_lineoff_C lp]
    (ยง
        (ร --lp.lnum)
        (cond (< (:lnum lp) 1)
        (do
            ((ร lp.height =) MAXCOL)
        )
        :else
        (do
            ((ร lp.height =) (plines (:lnum lp)))
        ))
        nil
    ))

;; Add one line below "lp.lnum".
;; This can be a filler line, a closed fold or a (wrapped) text line.
;; Uses and sets "lp.fill".
;; Returns the height of the added line in "lp.height".
;; Lines below the last one are incredibly high.

(defn- #_void botline-forw [#_lineoff_C lp]
    (ยง
        (ร lp.lnum++)
        ((ร lp.height =) (if (< (:ml_line_count (:b_ml @curbuf)) (:lnum lp)) MAXCOL (plines (:lnum lp))))
        nil
    ))

;; Recompute topline to put the cursor at the top of the window.
;; Scroll at least "min_scroll" lines.
;; If "always" is true, always set topline (for "zt").

(defn- #_void scroll-cursor-top [#_int min_scroll, #_boolean always]
    (ยง
        ((ร int scrolled =) 0)
        ((ร int extra =) 0)
        ((ร long old_topline =) (:w_topline @curwin))

        ((ร int off =) (int @p_so))

        ;; Decrease topline until:
        ;; - it has become 1
        ;; - (part of) the cursor line is moved off the screen or
        ;; - moved at least 'scrolljump' lines and
        ;; - at least 'scrolloff' lines above and below the cursor

        (validate-cheight)
        ((ร int used =) (:w_cline_height @curwin))
        (if (< (:lnum (:w_cursor @curwin)) (:w_topline @curwin))
            ((ร scrolled =) used)
        )

        ((ร long top =) (- (:lnum (:w_cursor @curwin)) 1))    ;; just above displayed lines
        ((ร long bot =) (+ (:lnum (:w_cursor @curwin)) 1))    ;; just below displayed lines
        ((ร long new_topline =) (inc top))

        ;; Check if the lines from "top" to "bot" fit in the window.  If they do,
        ;; set new_topline and advance "top" and "bot" to include more lines.

        (while (< 0 top)
            ((ร int i =) (plines top))
            ((ร used =) (+ used i))
            (when (and (<= (+ extra i) off) (< bot (:ml_line_count (:b_ml @curbuf))))
                ((ร used =) (+ used (plines bot)))
            )
            (if (< (:w_height @curwin) used)
                (ร BREAK)
            )
            (if (< top (:w_topline @curwin))
                ((ร scrolled =) (+ scrolled i))
            )

            ;; If scrolling is needed, scroll at least 'sj' lines.

            (if (and (or (<= (:w_topline @curwin) new_topline) (< min_scroll scrolled)) (<= off extra))
                (ร BREAK)
            )

            ((ร extra =) (+ extra i))
            ((ร new_topline =) top)
            (ร --top)
            (ร bot++)
        )

        ;; If we don't have enough space, put cursor in the middle.
        ;; This makes sure we get the same position when using "k" and "j" in a small window.

        (cond (< (:w_height @curwin) used)
        (do
            (scroll-cursor-halfway false)
        )
        :else
        (do
            ;; If "always" is false, only adjust topline to a lower value, higher
            ;; value may happen with wrapping lines

            (if (or (< new_topline (:w_topline @curwin)) always)
                ((ร @curwin.w_topline =) new_topline)
            )
            (if (> (:w_topline @curwin) (:lnum (:w_cursor @curwin)))
                ((ร @curwin.w_topline =) (:lnum (:w_cursor @curwin)))
            )
            (if (!= (:w_topline @curwin) old_topline)
                ((ร @curwin.w_valid =) (& (:w_valid @curwin) (bit-not (| VALID_WROW VALID_CROW VALID_BOTLINE VALID_BOTLINE_AP))))
            )
            ((ร @curwin.w_valid =) (| (:w_valid @curwin) VALID_TOPLINE))
        ))
        nil
    ))

;; Set w_empty_rows and w_filler_rows for window "wp", having used up "used"
;; screen lines for text lines.

(defn- #_void set-empty-rows [#_window_C wp, #_int used]
    (ยง
        ((ร wp.w_empty_rows =) (if (zero? used)
            0    ;; single line that doesn't fit
            (- (:w_height wp) used)
        ))
        nil
    ))

;; Recompute topline to put the cursor at the bottom of the window.
;; Scroll at least "min_scroll" lines.
;; If "set_topbot" is true, set topline and botline first (for "zb").
;; This is messy stuff!!!

(defn- #_void scroll-cursor-bot [#_int min_scroll, #_boolean set_topbot]
    (ยง
        ((ร int scrolled =) 0)
        ((ร int extra =) 0)
        ((ร long old_topline =) (:w_topline @curwin))
        ((ร long old_botline =) (:w_botline @curwin))
        ((ร int old_valid =) (:w_valid @curwin))
        ((ร int old_empty_rows =) (:w_empty_rows @curwin))

        ((ร lineoff_C loff =) (NEW_lineoff_C))
        ((ร lineoff_C boff =) (NEW_lineoff_C))

        ((ร long cln =) (:lnum (:w_cursor @curwin)))            ;; Cursor Line Number
        (cond set_topbot
        (do
            ((ร int used =) 0)
            ((ร @curwin.w_botline =) (inc cln))
            ((ร FOR) (ร ((ร @curwin.w_topline =) (:w_botline @curwin)) (< 1 (:w_topline @curwin)) ((ร @curwin.w_topline =) (:lnum loff)))
                ((ร loff.lnum =) (:w_topline @curwin))
                (topline-back loff)
                (if (or (== (:height loff) MAXCOL) (< (:w_height @curwin) (+ used (:height loff))))
                    (ร BREAK)
                )
                ((ร used =) (+ used (:height loff)))
            )
            (set-empty-rows @curwin, used)
            ((ร @curwin.w_valid =) (| (:w_valid @curwin) (| VALID_BOTLINE VALID_BOTLINE_AP)))
            (if (!= (:w_topline @curwin) old_topline)
                ((ร @curwin.w_valid =) (& (:w_valid @curwin) (bit-not (| VALID_WROW VALID_CROW))))
            )
        )
        :else
        (do
            (validate-botline)
        ))

        ;; The lines of the cursor line itself are always used.
        (validate-cheight)
        ((ร int used =) (:w_cline_height @curwin))

        ;; If the cursor is below botline, we will at least scroll by the height of the cursor line.
        ;; Correct for empty lines, which are really part of botline.
        (when (<= (:w_botline @curwin) cln)
            ((ร scrolled =) used)
            (if (== cln (:w_botline @curwin))
                ((ร scrolled =) (- scrolled (:w_empty_rows @curwin)))
            )
        )

        ;; Stop counting lines to scroll when
        ;; - hitting start of the file
        ;; - scrolled nothing or at least 'sj' lines
        ;; - at least 'so' lines below the cursor
        ;; - lines between botline and cursor have been counted

        ((ร loff.lnum =) cln)
        ((ร boff.lnum =) cln)

        (while (< 1 (:lnum loff))
            ;; Stop when scrolled nothing or at least "min_scroll", found "extra"
            ;; context for 'scrolloff' and counted all lines below the window.
            (when (and (or (and (or (<= scrolled 0) (<= min_scroll scrolled)) (<= @p_so extra)) (< (:ml_line_count (:b_ml @curbuf)) (+ (:lnum boff) 1))) (<= (:lnum loff) (:w_botline @curwin)))
                (ร BREAK)
            )

            ;; Add one line above.
            (topline-back loff)
            (if (== (:height loff) MAXCOL)
                ((ร used =) MAXCOL)
                ((ร used =) (+ used (:height loff)))
            )
            (if (< (:w_height @curwin) used)
                (ร BREAK)
            )
            (when (<= (:w_botline @curwin) (:lnum loff))
                ;; Count screen lines that are below the window.
                ((ร scrolled =) (+ scrolled (:height loff)))
                (if (== (:lnum loff) (:w_botline @curwin))
                    ((ร scrolled =) (- scrolled (:w_empty_rows @curwin)))
                )
            )

            (when (< (:lnum boff) (:ml_line_count (:b_ml @curbuf)))
                ;; Add one line below.
                (botline-forw boff)
                ((ร used =) (+ used (:height boff)))
                (if (< (:w_height @curwin) used)
                    (ร BREAK)
                )
                (when (or (< extra @p_so) (< scrolled min_scroll))
                    ((ร extra =) (+ extra (:height boff)))
                    (when (<= (:w_botline @curwin) (:lnum boff))
                        ;; Count screen lines that are below the window.
                        ((ร scrolled =) (+ scrolled (:height boff)))
                        (if (== (:lnum boff) (:w_botline @curwin))
                            ((ร scrolled =) (- scrolled (:w_empty_rows @curwin)))
                        )
                    )
                )
            )
        )

        (ร long line_count)
        ;; curwin.w_empty_rows is larger, no need to scroll
        (cond (<= scrolled 0)
        (do
            ((ร line_count =) 0)
        )
        ;; more than a screenfull, don't scroll but redraw
        (< (:w_height @curwin) used)
        (do
            ((ร line_count =) used)
        )
        ;; scroll minimal number of lines
        :else
        (do
            ((ร line_count =) 0)
            ((ร boff.lnum =) (- (:w_topline @curwin) 1))
            (ร int i)
            ((ร FOR) (ร ((ร i =) 0) (and (< i scrolled) (< (:lnum boff) (:w_botline @curwin))) nil)
                (botline-forw boff)
                ((ร i =) (+ i (:height boff)))
                (ร line_count++)
            )
            (if (< i scrolled)       ;; below curwin.w_botline, don't scroll
                ((ร line_count =) 9999)
            )
        ))

        ;; Scroll up if the cursor is off the bottom of the screen a bit.
        ;; Otherwise put it at 1/2 of the screen.

        (if (and (<= (:w_height @curwin) line_count) (< min_scroll line_count))
            (scroll-cursor-halfway false)
            (scrollup line_count))

        ;; If topline didn't change we need to restore w_botline and w_empty_rows (we changed them).
        ;; If topline did change, update-screen() will set botline.

        (when (and (== (:w_topline @curwin) old_topline) set_topbot)
            ((ร @curwin.w_botline =) old_botline)
            ((ร @curwin.w_empty_rows =) old_empty_rows)
            ((ร @curwin.w_valid =) old_valid)
        )
        ((ร @curwin.w_valid =) (| (:w_valid @curwin) VALID_TOPLINE))
        nil
    ))

;; Recompute topline to put the cursor halfway the window
;; If "atend" is true, also put it halfway at the end of the file.

(defn- #_void scroll-cursor-halfway [#_boolean atend]
    (ยง
        ((ร lineoff_C loff =) (NEW_lineoff_C))
        ((ร lineoff_C boff =) (NEW_lineoff_C))

        ((ร loff.lnum =) (ร boff.lnum =) (:lnum (:w_cursor @curwin)))
        ((ร int used =) (plines (:lnum loff)))
        ((ร long topline =) (:lnum loff))

        ((ร FOR) (ร ((ร int above =) (ร 0, below = 0)) (< 1 topline) nil)
            (when (<= below above)         ;; add a line below the cursor first
                (cond (< (:lnum boff) (:ml_line_count (:b_ml @curbuf)))
                (do
                    (botline-forw boff)
                    ((ร used =) (+ used (:height boff)))
                    (if (< (:w_height @curwin) used)
                        (ร BREAK)
                    )
                    ((ร below =) (+ below (:height boff)))
                )
                :else
                (do
                    (ร below++)            ;; count a "~" line
                    (if atend
                        (ร used++)
                    )
                ))
            )

            (when (< above below)          ;; add a line above the cursor
                (topline-back loff)
                (if (== (:height loff) MAXCOL)
                    ((ร used =) MAXCOL)
                    ((ร used =) (+ used (:height loff)))
                )
                (if (< (:w_height @curwin) used)
                    (ร BREAK)
                )
                ((ร above =) (+ above (:height loff)))
                ((ร topline =) (:lnum loff))
            )
        )

        ((ร @curwin.w_topline =) topline)
        ((ร @curwin.w_valid =) (& (:w_valid @curwin) (bit-not (| VALID_WROW VALID_CROW VALID_BOTLINE VALID_BOTLINE_AP))))
        ((ร @curwin.w_valid =) (| (:w_valid @curwin) VALID_TOPLINE))
        nil
    ))

;; Correct the cursor position so that it is in a part of the screen at least
;; 'so' lines from the top and bottom, if possible.
;; If not possible, put it at the same position as scroll-cursor-halfway().
;; When called topline must be valid!

(defn- #_void cursor-correct []
    (ยง
        ;; How many lines we would like to have above/below the cursor depends on
        ;; whether the first/last line of the file is on screen.

        ((ร int above_wanted =) (int @p_so))
        ((ร int below_wanted =) (int @p_so))
        (when (== (:w_topline @curwin) 1)
            ((ร above_wanted =) 0)
            ((ร int max_off =) (/ (:w_height @curwin) 2))
            (if (< max_off below_wanted)
                ((ร below_wanted =) max_off)
            )
        )
        (validate-botline)
        (when (== (:w_botline @curwin) (+ (:ml_line_count (:b_ml @curbuf)) 1))
            ((ร below_wanted =) 0)
            ((ร int max_off =) (/ (- (:w_height @curwin) 1) 2))
            (if (< max_off above_wanted)
                ((ร above_wanted =) max_off)
            )
        )

        ;; If there are sufficient file-lines above and below the cursor, we can return now.

        ((ร long cln =) (:lnum (:w_cursor @curwin)))    ;; Cursor Line Number
        (if (and (<= (+ (:w_topline @curwin) above_wanted) cln) (< cln (- (:w_botline @curwin) below_wanted)))
            ((ร RETURN) nil)
        )

        ((ร int above =) 0)          ;; screen lines above topline
        ((ร int below =) 0)          ;; screen lines below botline

        ;; Narrow down the area where the cursor can be put by taking lines from
        ;; the top and the bottom until:
        ;; - the desired context lines are found
        ;; - the lines from the top is past the lines from the bottom

        ((ร long topline =) (:w_topline @curwin))
        ((ร long botline =) (- (:w_botline @curwin) 1))
        (while (and (or (< above above_wanted) (< below below_wanted)) (< topline botline))
            (when (and (< below below_wanted) (or (<= below above) (<= above_wanted above)))
                ((ร below =) (+ below (plines botline)))
                (ร --botline)
            )
            (when (and (< above above_wanted) (or (< above below) (<= below_wanted below)))
                ((ร above =) (+ above (plines topline)))
                (ร topline++)
            )
        )
        (cond (or (== topline botline) (zero? botline))
        (do
            ((ร @curwin.w_cursor.lnum =) topline)
        )
        (< botline topline)
        (do
            ((ร @curwin.w_cursor.lnum =) botline)
        )
        :else
        (do
            (when (and (< cln topline) (< 1 (:w_topline @curwin)))
                ((ร @curwin.w_cursor.lnum =) topline)
                ((ร @curwin.w_valid =) (& (:w_valid @curwin) (bit-not (| VALID_WROW VALID_WCOL VALID_CHEIGHT VALID_CROW))))
            )
            (when (and (< botline cln) (<= (:w_botline @curwin) (:ml_line_count (:b_ml @curbuf))))
                ((ร @curwin.w_cursor.lnum =) botline)
                ((ร @curwin.w_valid =) (& (:w_valid @curwin) (bit-not (| VALID_WROW VALID_WCOL VALID_CHEIGHT VALID_CROW))))
            )
        ))
        ((ร @curwin.w_valid =) (| (:w_valid @curwin) VALID_TOPLINE))
        nil
    ))

;; move screen 'count' pages up or down and update screen
;;
;; return false for failure, true otherwise

(defn- #_boolean onepage [#_int dir, #_long count]
    (ยง
        ((ร boolean retval =) true)

        ((ร long old_topline =) (:w_topline @curwin))

        (when (== (:ml_line_count (:b_ml @curbuf)) 1) ;; nothing to do
            (beep-flush)
            ((ร RETURN) false)
        )

        ((ร lineoff_C loff =) (NEW_lineoff_C))

        ((ร FOR) (ร nil (< 0 count) (ร --count))
            (validate-botline)

            ;; It's an error to move a page up when the first line is already on
            ;; the screen.  It's an error to move a page down when the last line
            ;; is on the screen and the topline is 'scrolloff' lines from the last line.

            (when (if (== dir FORWARD) (and (<= (- (:ml_line_count (:b_ml @curbuf)) @p_so) (:w_topline @curwin)) (< (:ml_line_count (:b_ml @curbuf)) (:w_botline @curwin))) (== (:w_topline @curwin) 1))
                (beep-flush)
                ((ร retval =) false)
                (ร BREAK)
            )

            (cond (== dir FORWARD)
            (do
                (cond (< (:ml_line_count (:b_ml @curbuf)) (:w_botline @curwin))
                (do
                    ;; at end of file
                    ((ร @curwin.w_topline =) (:ml_line_count (:b_ml @curbuf)))
                    ((ร @curwin.w_valid =) (& (:w_valid @curwin) (bit-not (| VALID_WROW VALID_CROW))))
                )
                :else
                (do
                    ;; For the overlap, start with the line just below the window and go upwards.
                    ((ร loff.lnum =) (:w_botline @curwin))
                    (get-scroll-overlap loff, -1)
                    ((ร @curwin.w_topline =) (:lnum loff))
                    ((ร @curwin.w_cursor.lnum =) (:w_topline @curwin))
                    ((ร @curwin.w_valid =) (& (:w_valid @curwin) (bit-not (| VALID_WCOL VALID_CHEIGHT VALID_WROW VALID_CROW VALID_BOTLINE VALID_BOTLINE_AP))))
                ))
            )
            :else    ;; dir == BACKWARDS
            (do
                ;; Find the line at the top of the window that is going to be the line at the bottom of the window.
                ;; Make sure this results in the same line as before doing CTRL-F.
                ((ร loff.lnum =) (- (:w_topline @curwin) 1))
                (get-scroll-overlap loff, 1)

                (if (> (:lnum loff) (:ml_line_count (:b_ml @curbuf)))
                    ((ร loff.lnum =) (:ml_line_count (:b_ml @curbuf)))
                )
                ((ร @curwin.w_cursor.lnum =) (:lnum loff))

                ;; Find the line just above the new topline to get the right line at the bottom of the window.
                ((ร long n =) 0)
                (while (and (<= n (:w_height @curwin)) (<= 1 (:lnum loff)))
                    (topline-back loff)
                    (if (== (:height loff) MAXCOL)
                        ((ร n =) MAXCOL)
                        ((ร n =) (+ n (:height loff)))
                    )
                )
                (cond (< (:lnum loff) 1)      ;; at begin of file
                (do
                    ((ร @curwin.w_topline =) 1)
                    ((ร @curwin.w_valid =) (& (:w_valid @curwin) (bit-not (| VALID_WROW VALID_CROW VALID_BOTLINE))))
                )
                :else
                (do
                    ;; Go two lines forward again.
                    (botline-forw loff)
                    (botline-forw loff)

                    ;; Always scroll at least one line.  Avoid getting stuck on very long lines.
                    (cond (<= (:w_topline @curwin) (:lnum loff))
                    (do
                        (ร --@curwin.w_topline)

                        (comp-botline @curwin)
                        ((ร @curwin.w_cursor.lnum =) (- (:w_botline @curwin) 1))
                        ((ร @curwin.w_valid =) (& (:w_valid @curwin) (bit-not (| VALID_WCOL VALID_CHEIGHT VALID_WROW VALID_CROW))))
                    )
                    :else
                    (do
                        ((ร @curwin.w_topline =) (:lnum loff))
                        ((ร @curwin.w_valid =) (& (:w_valid @curwin) (bit-not (| VALID_WROW VALID_CROW VALID_BOTLINE))))
                    ))
                ))
            ))
        )

        (cursor-correct)
        (if retval
            (beginline (| BL_SOL BL_FIX)))
        ((ร @curwin.w_valid =) (& (:w_valid @curwin) (bit-not (| VALID_WCOL VALID_WROW VALID_VIRTCOL))))

        ;; Avoid the screen jumping up and down when 'scrolloff' is non-zero.
        ;; But make sure we scroll at least one line (happens with mix of long
        ;; wrapping lines and non-wrapping line).

        (when (and retval (== dir FORWARD) (check-top-offset))
            (scroll-cursor-top 1, false)
            (when (and (<= (:w_topline @curwin) old_topline) (< old_topline (:ml_line_count (:b_ml @curbuf))))
                ((ร @curwin.w_topline =) (inc old_topline))
            )
        )

        (redraw-later VALID)
        retval
    ))

;; Decide how much overlap to use for page-up or page-down scrolling.
;; This is symmetric, so that doing both keeps the same lines displayed.
;; Three lines are examined:
;;
;;  before CTRL-F           after CTRL-F / before CTRL-B
;;     etc.                     l1
;;  l1 last but one line        ------------
;;  l2 last text line           l2 top text line
;;  -------------               l3 second text line
;;  l3                             etc.

(defn- #_void get-scroll-overlap [#_lineoff_C lp, #_int dir]
    (ยง
        ((ร int min_height =) (- (:w_height @curwin) 2))

        ((ร lp.height =) (plines (:lnum lp)))
        ((ร int h1 =) (:height lp))
        (if (< min_height h1)
            ((ร RETURN) nil)         ;; no overlap
        )

        ((ร lineoff_C loff0 =) (NEW_lineoff_C))
        (COPY-lineoff loff0, lp)
        (if (< 0 dir)
            (botline-forw lp)
            (topline-back lp))
        ((ร int h2 =) (:height lp))
        (when (or (== h2 MAXCOL) (< min_height (+ h2 h1)))
            (COPY-lineoff lp, loff0)    ;; no overlap
            ((ร RETURN) nil)
        )

        ((ร lineoff_C loff1 =) (NEW_lineoff_C))
        (COPY-lineoff loff1, lp)
        (if (< 0 dir)
            (botline-forw lp)
            (topline-back lp))
        ((ร int h3 =) (:height lp))
        (when (or (== h3 MAXCOL) (< min_height (+ h3 h2)))
            (COPY-lineoff lp, loff0)    ;; no overlap
            ((ร RETURN) nil)
        )

        ((ร lineoff_C loff2 =) (NEW_lineoff_C))
        (COPY-lineoff loff2, lp)
        (if (< 0 dir)
            (botline-forw lp)
            (topline-back lp))
        ((ร int h4 =) (:height lp))
        (if (or (== h4 MAXCOL) (< min_height (+ h4 h3 h2)) (< min_height (+ h3 h2 h1)))
            (COPY-lineoff lp, loff1)    ;; 1 line overlap
            (COPY-lineoff lp, loff2))    ;; 2 lines overlap
        nil
    ))

;; Scroll 'scroll' lines up or down.

(defn- #_void halfpage [#_boolean flag, #_long Prenum]
    (ยง
        ((ร long scrolled =) 0)

        (if (non-zero? Prenum)
            ((ร @curwin.w_options.@wo_scr =) (if (< (:w_height @curwin) Prenum) (:w_height @curwin) Prenum))
        )
        ((ร int n =) (if (<= (int @(:wo_scr (:w_options @curwin))) (:w_height @curwin)) (int @(:wo_scr (:w_options @curwin))) (:w_height @curwin)))

        (validate-botline)
        ((ร int room =) (:w_empty_rows @curwin))
        (cond flag
        (do
            ;; scroll the text up

            (while (and (< 0 n) (<= (:w_botline @curwin) (:ml_line_count (:b_ml @curbuf))))
                ((ร int i =) (plines (:w_topline @curwin)))
                ((ร n =) (- n i))
                (if (and (< n 0) (< 0 scrolled))
                    (ร BREAK)
                )
                (ร @curwin.w_topline++)

                (when (< (:lnum (:w_cursor @curwin)) (:ml_line_count (:b_ml @curbuf)))
                    (ร @curwin.w_cursor.lnum++)
                    ((ร @curwin.w_valid =) (& (:w_valid @curwin) (bit-not (| VALID_VIRTCOL VALID_CHEIGHT VALID_WCOL))))
                )

                ((ร @curwin.w_valid =) (& (:w_valid @curwin) (bit-not (| VALID_CROW VALID_WROW))))
                ((ร scrolled =) (+ scrolled i))

                ;; Correct w_botline for changed w_topline.
                ;; Won't work when there are filler lines.

                ((ร room =) (+ room i))
;               do
;               {
                    ((ร i =) (plines (:w_botline @curwin)))
                    (if (< room i)
                        (ร BREAK)
                    )
                    (ร @curwin.w_botline++)
                    ((ร room =) (- room i))
;               } while (@curwin.w_botline <= @curbuf.b_ml.ml_line_count);
            )

            ;; When hit bottom of the file: move cursor down.

            (when (< 0 n)
                ((ร @curwin.w_cursor.lnum =) (+ (:lnum (:w_cursor @curwin)) n))
                (check-cursor-lnum)
            )
        )
        :else
        (do
            ;; scroll the text down

            (while (and (< 0 n) (< 1 (:w_topline @curwin)))
                ((ร int i =) (plines (- (:w_topline @curwin) 1)))
                ((ร n =) (- n i))
                (if (and (< n 0) (< 0 scrolled))
                    (ร BREAK)
                )
                (ร --@curwin.w_topline)

                ((ร @curwin.w_valid =) (& (:w_valid @curwin) (bit-not (| VALID_CROW VALID_WROW VALID_BOTLINE VALID_BOTLINE_AP))))
                ((ร scrolled =) (+ scrolled i))
                (when (< 1 (:lnum (:w_cursor @curwin)))
                    (ร --@curwin.w_cursor.lnum)
                    ((ร @curwin.w_valid =) (& (:w_valid @curwin) (bit-not (| VALID_VIRTCOL VALID_CHEIGHT VALID_WCOL))))
                )
            )

            ;; When hit top of the file: move cursor up.

            (when (< 0 n)
                (if (<= (:lnum (:w_cursor @curwin)) (long n))
                    ((ร @curwin.w_cursor.lnum =) 1)
                    ((ร @curwin.w_cursor.lnum =) (- (:lnum (:w_cursor @curwin)) n))
                )
            )
        ))
        (cursor-correct)
        (beginline (| BL_SOL BL_FIX))
        (redraw-later VALID)
        nil
    ))

(defn- #_void do-check-cursorbind []
    (ยง
        ((ร long line =) (:lnum (:w_cursor @curwin)))
        ((ร int col =) (:col (:w_cursor @curwin)))
        ((ร int coladd =) (:coladd (:w_cursor @curwin)))
        ((ร int curswant =) (:w_curswant @curwin))
        ((ร boolean set_curswant =) (:w_set_curswant @curwin))

        ((ร window_C old_curwin =) @curwin)
        ((ร boolean old_VIsual_select =) @VIsual_select)
        ((ร boolean old_VIsual_active =) @VIsual_active)

        ;; loop through the cursorbound windows

        (reset! VIsual_select ((ร @VIsual_active =) false))
        ((ร FOR) (ร ((ร @curwin =) @firstwin) (non-nil? @curwin) ((ร @curwin =) (:w_next @curwin)))
            ;; skip original window  and windows with 'noscrollbind'
            (when (and (!= @curwin old_curwin) @(:wo_crb (:w_options @curwin)))
                ((ร @curwin.w_cursor.lnum =) line)
                ((ร @curwin.w_cursor.col =) col)
                ((ร @curwin.w_cursor.coladd =) coladd)
                ((ร @curwin.w_curswant =) curswant)
                ((ร @curwin.w_set_curswant =) set_curswant)

                ;; Make sure the cursor is in a valid position.  Temporarily set
                ;; "restart_edit" to allow the cursor to be beyond the EOL.
                ((ร int restart_edit_save =) @restart_edit)
                (reset! restart_edit TRUE)
                (check-cursor)
                (reset! restart_edit restart_edit_save)
                ;; Correct cursor for multi-byte character.
                (mb-adjust-pos @curbuf, (:w_cursor @curwin))
                (redraw-later VALID)

                ;; Only scroll when 'scrollbind' hasn't done this.
                (if (not @(:wo_scb (:w_options @curwin)))
                    (update-topline))
                ((ร @curwin.w_redr_status =) true)
            )
        )

        ;; reset current-window

        (reset! VIsual_select old_VIsual_select)
        (reset! VIsual_active old_VIsual_active)
        (reset! curwin old_curwin)
        nil
    ))

;;; ============================================================================================== VimX

;; syntax.c: code for syntax highlighting ---------------------------------------------------------

;; Structure that stores information about a highlight group.
;; The ID of a highlight group is also called group ID.
;; It is the index in the highlight_ga array PLUS ONE.

(class! #_final hl_group_C
    [
        (field Bytes        sg_name)            ;; highlight group name
        (field Bytes        sg_name_u)          ;; uppercase of "sg_name"
;; for normal terminals
        (field int          sg_term)            ;; "term=" highlighting attributes
        (field Bytes        sg_start)           ;; terminal string for start highl
        (field Bytes        sg_stop)            ;; terminal string for stop highl
        (field int          sg_term_attr)       ;; screen attr for term mode
;; for color terminals
        (field int          sg_cterm)           ;; "cterm=" highlighting attr
        (field boolean      sg_cterm_bold)      ;; bold attr was set for light color
        (field int          sg_cterm_fg)        ;; terminal fg color number + 1
        (field int          sg_cterm_bg)        ;; terminal bg color number + 1
        (field int          sg_cterm_attr)      ;; screen attr for color term mode
;; Store the sp color name for the GUI or synIDattr().
        (field int          sg_gui)             ;; "gui=" highlighting attributes
        (field Bytes        sg_gui_fg_name)     ;; GUI foreground color name
        (field Bytes        sg_gui_bg_name)     ;; GUI background color name
        (field Bytes        sg_gui_sp_name)     ;; GUI special color name
        (field int          sg_link)            ;; link to this highlight group ID
        (field int          sg_set)             ;; combination of SG_* flags
    ])

(defn- #_void COPY-hl-group [#_hl_group_C sg1, #_hl_group_C sg0]
    (ยง
        ((ร sg1.sg_name =) (:sg_name sg0))
        ((ร sg1.sg_name_u =) (:sg_name_u sg0))
        ((ร sg1.sg_term =) (:sg_term sg0))
        ((ร sg1.sg_start =) (:sg_start sg0))
        ((ร sg1.sg_stop =) (:sg_stop sg0))
        ((ร sg1.sg_term_attr =) (:sg_term_attr sg0))
        ((ร sg1.sg_cterm =) (:sg_cterm sg0))
        ((ร sg1.sg_cterm_bold =) (:sg_cterm_bold sg0))
        ((ร sg1.sg_cterm_fg =) (:sg_cterm_fg sg0))
        ((ร sg1.sg_cterm_bg =) (:sg_cterm_bg sg0))
        ((ร sg1.sg_cterm_attr =) (:sg_cterm_attr sg0))
        ((ร sg1.sg_gui =) (:sg_gui sg0))
        ((ร sg1.sg_gui_fg_name =) (:sg_gui_fg_name sg0))
        ((ร sg1.sg_gui_bg_name =) (:sg_gui_bg_name sg0))
        ((ร sg1.sg_gui_sp_name =) (:sg_gui_sp_name sg0))
        ((ร sg1.sg_link =) (:sg_link sg0))
        ((ร sg1.sg_set =) (:sg_set sg0))
        nil
    ))

;; highlight groups for 'highlight' option
(atom! hl_group_C*  highlight_ga    0)

(final int MAX_HL_ID       20000)       ;; maximum value for a highlight ID.

;; An attribute number is the index in attr_table plus ATTR_OFF.

(final int ATTR_OFF (inc HL_ALL))

;; The attributes of the syntax item that has been recognized.

(atom! int current_sub_char)

;; Return conceal substitution character

(defn- #_int syn-get-sub-char []
    @current_sub_char)

;; Reset the cterm colors to what they were before Vim was started,
;; if possible.  Otherwise reset them to zero.

(defn- #_void restore-cterm-colors []
    (reset! cterm_normal_fg_color 0)
    (reset! cterm_normal_fg_bold 0)
    (reset! cterm_normal_bg_color 0)
    nil)

;; Table with the specifications for an attribute number.
;; Note that this table is used by ALL buffers.
;; This is required because the GUI can redraw at any time for any buffer.

(atom! attrentry_C* term_attr_table     0)
(atom! attrentry_C* cterm_attr_table    0)

(atom! boolean _4_recursive)

;; Return the attr number for a set of colors and font.
;; Add a new entry to the term_attr_table, cterm_attr_table or gui_attr_table, if the combination is new.
;; Return 0 for error (no more room).

(defn- #_int get-attr-entry [#_attrentry_C* table, #_attrentry_C aep]
    (ยง
        ;; Try to find an entry with the same specifications.

        (dotimes [#_int i (:ga_len table)]
            ((ร attrentry_C taep =) (... (:ga_data table) i))
            (if (and (== (:ae_attr aep) (:ae_attr taep)) (or (and (== table @term_attr_table) (== (nil? (:ae_esc_start aep)) (nil? (:ae_esc_start taep))) (or (nil? (:ae_esc_start aep)) (== (STRCMP (:ae_esc_start aep), (:ae_esc_start taep)) 0)) (== (nil? (:ae_esc_stop aep)) (nil? (:ae_esc_stop taep))) (or (nil? (:ae_esc_stop aep)) (== (STRCMP (:ae_esc_stop aep), (:ae_esc_stop taep)) 0))) (and (== table @cterm_attr_table) (== (:ae_fg_color aep) (:ae_fg_color taep)) (== (:ae_bg_color aep) (:ae_bg_color taep)))))
                ((ร RETURN) (+ i ATTR_OFF))
            )
        )

        ((ร final int MAX_TYPENR =) 65535)

        (when (< MAX_TYPENR (+ (:ga_len table) ATTR_OFF))
            ;; Running out of attribute entries!
            ;; Remove all attributes, and compute new ones for all groups.
            ;; When called recursively, we are really out of numbers.

            (when @_4_recursive
                (emsg (u8 "E424: Too many different highlighting attributes in use"))
                ((ร RETURN) 0)
            )
            (reset! _4_recursive true)

            (clear-hl-tables)

            (reset! must_redraw CLEAR)

            (dotimes [#_int i (:ga_len @highlight_ga)]
                (set-hl-attr i)
            )

            (reset! _4_recursive false)
        )

        ;; This is a new combination of colors and font, add an entry.

        (.ga_grow table 1)

        ((ร attrentry_C taep =) (ร table.ga_data[table.ga_len++] =) (NEW_attrentry_C))

        ((ร taep.ae_attr =) (:ae_attr aep))
        (cond (== table @term_attr_table)
        (do
            ((ร taep.ae_esc_start =) (if (nil? (:ae_esc_start aep)) nil (STRDUP (:ae_esc_start aep))))
            ((ร taep.ae_esc_stop =) (if (nil? (:ae_esc_stop aep)) nil (STRDUP (:ae_esc_stop aep))))
        )
        (== table @cterm_attr_table)
        (do
            ((ร taep.ae_fg_color =) (:ae_fg_color aep))
            ((ร taep.ae_bg_color =) (:ae_bg_color aep))
        ))

        (+ (- (:ga_len table) 1) ATTR_OFF)
    ))

;; Clear all highlight tables.

(defn- #_void clear-hl-tables []
    (ยง
        (dotimes [#_int i (:ga_len @term_attr_table)]
            ((ร attrentry_C taep =) (... (:ga_data @term_attr_table) i))
            ((ร taep.ae_esc_start =) nil)
            ((ร taep.ae_esc_stop =) nil)
        )
        (.ga_clear @term_attr_table)
        (.ga_clear @cterm_attr_table)
        nil
    ))

;; Combine special attributes (e.g., for spelling)
;; with other attributes (e.g., for syntax highlighting).
;; "prim_attr" overrules "char_attr".
;; This creates a new group when required.
;; Since we expect there to be few spelling mistakes we don't cache the result.
;; Return the resulting attributes.

(defn- #_int hl-combine-attr [#_int char_attr, #_int prim_attr]
    (ยง
        ((ร attrentry_C char_aep =) nil)
        (ร attrentry_C spell_aep)

        (if (zero? char_attr)
            ((ร RETURN) prim_attr)
        )
        (if (and (<= char_attr HL_ALL) (<= prim_attr HL_ALL))
            ((ร RETURN) (| char_attr prim_attr))
        )

        ((ร attrentry_C new_en =) (NEW_attrentry_C))

        (when (< 1 @t_colors)
            (if (< HL_ALL char_attr)
                ((ร char_aep =) (syn-cterm-attr2entry char_attr))
            )
            (cond (non-nil? char_aep)
            (do
                (COPY-attrentry new_en, char_aep)
            )
            :else
            (do
                (ZER0-attrentry new_en)
                (if (<= char_attr HL_ALL)
                    ((ร new_en.ae_attr =) char_attr)
                )
            ))

            (cond (<= prim_attr HL_ALL)
            (do
                ((ร new_en.ae_attr =) (| (:ae_attr new_en) prim_attr))
            )
            :else
            (do
                ((ร spell_aep =) (syn-cterm-attr2entry prim_attr))
                (when (non-nil? spell_aep)
                    ((ร new_en.ae_attr =) (| (:ae_attr new_en) (:ae_attr spell_aep)))
                    (if (< 0 (:ae_fg_color spell_aep))
                        ((ร new_en.ae_fg_color =) (:ae_fg_color spell_aep))
                    )
                    (if (< 0 (:ae_bg_color spell_aep))
                        ((ร new_en.ae_bg_color =) (:ae_bg_color spell_aep))
                    )
                )
            ))

            ((ร RETURN) (get-attr-entry @cterm_attr_table, new_en))
        )

        (if (< HL_ALL char_attr)
            ((ร char_aep =) (syn-term-attr2entry char_attr))
        )
        (cond (non-nil? char_aep)
        (do
            (COPY-attrentry new_en, char_aep)
        )
        :else
        (do
            (ZER0-attrentry new_en)
            (if (<= char_attr HL_ALL)
                ((ร new_en.ae_attr =) char_attr)
            )
        ))

        (cond (<= prim_attr HL_ALL)
        (do
            ((ร new_en.ae_attr =) (| (:ae_attr new_en) prim_attr))
        )
        :else
        (do
            ((ร spell_aep =) (syn-term-attr2entry prim_attr))
            (when (non-nil? spell_aep)
                ((ร new_en.ae_attr =) (| (:ae_attr new_en) (:ae_attr spell_aep)))
                (when (non-nil? (:ae_esc_start spell_aep))
                    ((ร new_en.ae_esc_start =) (:ae_esc_start spell_aep))
                    ((ร new_en.ae_esc_stop =) (:ae_esc_stop spell_aep))
                )
            )
        ))

        (get-attr-entry @term_attr_table, new_en)
    ))

;; Get the highlight attributes (HL_BOLD etc.) from an attribute nr.
;; Only to be used when "attr" > HL_ALL.

(defn- #_int syn-attr2attr [#_int attr]
    (let [#_attrentry_C aep (if (< 1 @t_colors) (syn-cterm-attr2entry attr) (syn-term-attr2entry attr))]
        (if (nil? aep) 0 (:ae_attr aep))
    ))

(defn- #_attrentry_C syn-term-attr2entry [#_int attr]
    (let [attr (- attr ATTR_OFF)]
        (if (< attr (:ga_len @term_attr_table)) (... (:ga_data @term_attr_table) attr) nil)
    ))

(defn- #_attrentry_C syn-cterm-attr2entry [#_int attr]
    (let [attr (- attr ATTR_OFF)]
        (if (< attr (:ga_len @cterm_attr_table)) (... (:ga_data @cterm_attr_table) attr) nil)
    ))

;; Set the attribute numbers for a highlight group.
;; Called after one of the attributes has changed.

(defn- #_void set-hl-attr [#_int idx]
    ;; idx: index in array
    (ยง
        ((ร hl_group_C[] hlt =) (:ga_data @highlight_ga))
        ((ร hl_group_C sgp =) (... hlt idx))

        ;; The "Normal" group doesn't need an attribute number.
        (if (and (non-nil? (:sg_name_u sgp)) (zero? (STRCMP (:sg_name_u sgp), (u8 "NORMAL"))))
            ((ร RETURN) nil)
        )

        ;; For the term mode: If there are other than "normal" highlighting
        ;; attributes, need to allocate an attr number.

        (cond (and (nil? (:sg_start sgp)) (nil? (:sg_stop sgp)))
        (do
            ((ร sgp.sg_term_attr =) (:sg_term sgp))
        )
        :else
        (do
            ((ร attrentry_C at_en =) (NEW_attrentry_C))
            ((ร at_en.ae_attr =) (:sg_term sgp))
            ((ร at_en.ae_esc_start =) (:sg_start sgp))
            ((ร at_en.ae_esc_stop =) (:sg_stop sgp))
            ((ร sgp.sg_term_attr =) (get-attr-entry @term_attr_table, at_en))
        ))

        ;; For the color term mode: If there are other than "normal"
        ;; highlighting attributes, need to allocate an attr number.

        (cond (and (zero? (:sg_cterm_fg sgp)) (zero? (:sg_cterm_bg sgp)))
        (do
            ((ร sgp.sg_cterm_attr =) (:sg_cterm sgp))
        )
        :else
        (do
            ((ร attrentry_C at_en =) (NEW_attrentry_C))
            ((ร at_en.ae_attr =) (:sg_cterm sgp))
            ((ร at_en.ae_fg_color =) (:sg_cterm_fg sgp))
            ((ร at_en.ae_bg_color =) (:sg_cterm_bg sgp))
            ((ร sgp.sg_cterm_attr =) (get-attr-entry @cterm_attr_table, at_en))
        ))
        nil
    ))

;; Lookup a highlight group name and return it's ID.
;; If it is not found, 0 is returned.

(defn- #_int syn-name2id [#_Bytes name]
    (ยง
        ((ร Bytes name_u =) (vim-strsave-up name))

        ((ร hl_group_C[] hlt =) (:ga_data @highlight_ga))

        (ร int i)
        ((ร FOR) (ร ((ร i =) (:ga_len @highlight_ga)) (<= 0 (ร --i)) nil)
            (if (and (non-nil? (:sg_name_u (... hlt i))) (zero? (STRCMP name_u, (:sg_name_u (... hlt i)))))
                (ร BREAK)
            )
        )
        (inc i)
    ))

;; Find highlight group name in the table and return it's ID.
;; The argument is a pointer to the name and the length of the name.
;; If it doesn't exist yet, a new entry is created.
;; Return 0 for failure.

(defn- #_int syn-check-group [#_Bytes pp, #_int len]
    (let [#_Bytes name (STRNDUP pp, len) #_int id (syn-name2id name)]
        (if (zero? id) (syn-add-group name) id)
    ))

;; Add new highlight group and return it's ID.
;; "name" must be an allocated string, it will be consumed.
;; Return 0 for failure.

(defn- #_int syn-add-group [#_Bytes name]
    (ยง
        ;; Check that the name is ASCII letters, digits and underscore.
        ((ร FOR) (ร ((ร Bytes p =) name) (non-eos? p) ((ร p =) (.plus p 1)))
            (cond (not (vim-isprintc (.at p 0)))
            (do
                (emsg (u8 "E669: Unprintable character in group name"))
                ((ร RETURN) 0)
            )
            (and (not (asc-isalnum (.at p 0))) (!= (.at p 0) (byte \_)))
            (do
                ;; This is an error, but since there previously was no check only give a warning.
                (msg (u8 "W18: Invalid character in group name"))
                (ร BREAK)
            ))
        )

        (when (<= MAX_HL_ID (:ga_len @highlight_ga))
            (emsg (u8 "E849: Too many highlight and syntax groups"))
            ((ร RETURN) 0)
        )

        ;; Make room for at least one other syntax_highlight entry.

        ((ร hl_group_C[] hlt =) (.ga_grow @highlight_ga 1))

        ((ร hlt[@highlight_ga.ga_len] =) (NEW_hl_group_C))
        ((ร hlt[@highlight_ga.ga_len].sg_name =) name)
        ((ร hlt[@highlight_ga.ga_len].sg_name_u =) (vim-strsave-up name))

        (ร @highlight_ga.ga_len++)

        (:ga_len @highlight_ga) ;; ID is index plus one
    ))

;; Translate a group ID to highlight attributes.

(defn- #_int syn-id2attr [#_int hl_id]
    (let [hl_id (syn-get-final-id hl_id) #_hl_group_C sgp (... (:ga_data @highlight_ga) (dec hl_id))]       ;; index is ID minus one
        (if (< 1 @t_colors) (:sg_cterm_attr sgp) (:sg_term_attr sgp))
    ))

;; Translate a group ID to the final group ID (following links).

(defn- #_int syn-get-final-id [#_int hl_id]
    (ยง
        (if (or (< (:ga_len @highlight_ga) hl_id) (< hl_id 1))
            ((ร RETURN) 0)                                           ;; Can be called from eval!!
        )

        ((ร hl_group_C[] hlt =) (:ga_data @highlight_ga))

        ;; Follow links until there is no more.
        ;; Look out for loops!  Break after 100 links.

        ((ร FOR) (ร ((ร int count =) 100) (<= 0 (ร --count)) nil)
            ((ร hl_group_C sgp =) (... hlt (dec hl_id)))                    ;; index is ID minus one
            (if (or (zero? (:sg_link sgp)) (< (:ga_len @highlight_ga) (:sg_link sgp)))
                (ร BREAK)
            )
            ((ร hl_id =) (:sg_link sgp))
        )

        hl_id
    ))

;; The HL_FLAGS must be in the same order as the HLF_ enums!
;; When changing this also adjust the default for 'highlight'.

(final int* #_"[/*HLF_COUNT*/]" hl_flags
    [
        \8, \@, \e, \i, \l, \m, \M, \n, \N, \r, \s, \S, \c, \t, \v, \w, \-, \!, \., \o
    ])

;; Translate the 'highlight' option into attributes in highlight_attr[] and
;; set up the user highlights User1..9.  If FEAT_STL_OPT is in use, a set of
;; corresponding highlights to use on top of HLF_SNC is computed.
;; Called only when the 'highlight' option has been changed and upon first
;; screen redraw after any :highlight command.
;; Return false when an invalid flag is found in 'highlight'; true otherwise.

(defn- #_boolean highlight-changed []
    (ยง
        ((ร int id_SNC =) -1)
        ((ร int id_S =) -1)

        (reset! need_highlight_changed false)

        ;; Clear all attributes.

        (dotimes [#_int hlf HLF_COUNT]
            ((ร @highlight_attr[hlf] =) 0)
        )

        ;; First set all attributes to their default value.
        ;; Then use the attributes from the 'highlight' option.

        (dotimes [#_int i 2]
            ((ร Bytes p =) (if (non-zero? i) @p_hl (get-highlight-default)))
            (if (nil? p)      ;; just in case
                (ร CONTINUE)
            )

            (while (non-eos? p)
                (ร int hlf)
                ((ร FOR) (ร ((ร hlf =) 0) (< hlf HLF_COUNT) (ร hlf++))
                    (if (== (... hl_flags hlf) (.at p 0))
                        (ร BREAK)
                    )
                )
                ((ร p =) (.plus p 1))
                (if (or (== hlf HLF_COUNT) (eos? p))
                    ((ร RETURN) false)
                )

                ;; Allow several hl_flags to be combined, like "bu" for bold-underlined.

                ((ร int attr =) 0)
                ((ร FOR) (ร nil (and (non-eos? p) (!= (.at p 0) (byte \,))) ((ร p =) (.plus p 1)))            ;; parse upto comma
                    (if (vim-iswhite (.at p 0))           ;; ignore white space
                        (ร CONTINUE)
                    )

                    (if (< HL_ALL attr)  ;; Combination with ':' is not allowed.
                        ((ร RETURN) false)
                    )

                    ((ร SWITCH) (.at p 0)
                        ((ร CASE) (byte \b))
                        (do
                            ((ร attr =) (| attr HL_BOLD))
                            (ร BREAK)
                        )
                        ((ร CASE) (byte \i))
                        (do
                            ((ร attr =) (| attr HL_ITALIC))
                            (ร BREAK)
                        )
                        ((ร CASE) (byte \-))
                        ((ร CASE) (byte \n))                       ;; no highlighting
                        (do
                            (ร BREAK)
                        )
                        ((ร CASE) (byte \r))
                        (do
                            ((ร attr =) (| attr HL_INVERSE))
                            (ร BREAK)
                        )
                        ((ร CASE) (byte \s))
                        (do
                            ((ร attr =) (| attr HL_STANDOUT))
                            (ร BREAK)
                        )
                        ((ร CASE) (byte \u))
                        (do
                            ((ร attr =) (| attr HL_UNDERLINE))
                            (ร BREAK)
                        )
                        ((ร CASE) (byte \c))
                        (do
                            ((ร attr =) (| attr HL_UNDERCURL))
                            (ร BREAK)
                        )
                        ((ร CASE) (byte \:))
                        (do
                            ((ร p =) (.plus p 1))                        ;; highlight group name
                            (if (or (non-zero? attr) (eos? p))      ;; no combinations
                                ((ร RETURN) false)
                            )
                            ((ร Bytes end =) (vim-strchr p, (byte \,)))
                            (if (nil? end)
                                ((ร end =) (.plus p (STRLEN p)))
                            )
                            ((ร int id =) (syn-check-group p, (BDIFF end, p)))
                            (if (zero? id)
                                ((ร RETURN) false)
                            )
                            ((ร attr =) (syn-id2attr id))
                            ((ร p =) (.minus end 1))
                            (cond (== hlf HLF_SNC)
                            (do
                                ((ร id_SNC =) (syn-get-final-id id))
                            )
                            (== hlf HLF_S)
                            (do
                                ((ร id_S =) (syn-get-final-id id))
                            ))
                            (ร BREAK)
                        )
                        (ร DEFAULT)
                        (do
                            ((ร RETURN) false)
                        )
                    )
                )
                ((ร @highlight_attr[hlf] =) attr)

                ((ร p =) (skip-to-option-part p))             ;; skip comma and spaces
            )
        )

        ;; Setup the user highlights
        ;;
        ;; Temporarily utilize 10 more hl entries.  Have to be in there
        ;; simultaneously in case of table overflows in get-attr-entry()

        ((ร hl_group_C[] hlt =) (.ga_grow @highlight_ga 10))

        ((ร int n =) (:ga_len @highlight_ga))
        (dotimes [#_int i 10]
            ((ร hlt[n + i] =) (NEW_hl_group_C))
        )

        ;; Make sure id_S is always valid to simplify code below.
        (when (zero? id_S)
            ((ร hlt[n + 9].sg_term =) (... @highlight_attr HLF_S))
            ((ร id_S =) (+ n 10))
        )

        (dotimes [#_int i 9]
            ((ร Bytes userhl =) (Bytes. 10))
            (.sprintf libC userhl, (u8 "User%d"), (inc i))

            ((ร int id =) (syn-name2id userhl))
            (when (non-zero? id)
                (cond (zero? id_SNC)
                (do
                    ((ร hlt[n + i].sg_term =) (... @highlight_attr HLF_SNC))
                    ((ร hlt[n + i].sg_cterm =) (... @highlight_attr HLF_SNC))
                    ((ร hlt[n + i].sg_gui =) (... @highlight_attr HLF_SNC))
                )
                :else
                (do
                    (COPY-hl-group (... hlt (+ n i)), (... hlt (dec id_SNC)))
                ))
                ((ร hlt[n + i].sg_link =) 0)

                ;; Apply difference between UserX and HLF_S to HLF_SNC.
                ((ร hlt[n + i].sg_term =) (bit-xor (:sg_term (... hlt (+ n i))) (bit-xor (:sg_term (... hlt (dec id))) (:sg_term (... hlt (dec id_S))))))
                (if (BNE (:sg_start (... hlt (dec id))), (:sg_start (... hlt (dec id_S))))
                    ((ร hlt[n + i].sg_start =) (:sg_start (... hlt (dec id))))
                )
                (if (BNE (:sg_stop (... hlt (dec id))), (:sg_stop (... hlt (dec id_S))))
                    ((ร hlt[n + i].sg_stop =) (:sg_stop (... hlt (dec id))))
                )
                ((ร hlt[n + i].sg_cterm =) (bit-xor (:sg_cterm (... hlt (+ n i))) (bit-xor (:sg_cterm (... hlt (dec id))) (:sg_cterm (... hlt (dec id_S))))))
                (if (!= (:sg_cterm_fg (... hlt (dec id))) (:sg_cterm_fg (... hlt (dec id_S))))
                    ((ร hlt[n + i].sg_cterm_fg =) (:sg_cterm_fg (... hlt (dec id))))
                )
                (if (!= (:sg_cterm_bg (... hlt (dec id))) (:sg_cterm_bg (... hlt (dec id_S))))
                    ((ร hlt[n + i].sg_cterm_bg =) (:sg_cterm_bg (... hlt (dec id))))
                )
                ((ร hlt[n + i].sg_gui =) (bit-xor (:sg_gui (... hlt (+ n i))) (bit-xor (:sg_gui (... hlt (dec id))) (:sg_gui (... hlt (dec id_S))))))
                ((ร @highlight_ga.ga_len =) (+ n i 1))
                (set-hl-attr (+ n i))         ;; at long last we can apply
            )
        )

        ((ร @highlight_ga.ga_len =) n)
        (dotimes [#_int i 10]
            ((ร hlt[n + i] =) nil)
        )

        true
    ))

;;; ============================================================================================== VimY

;; oops!

(final cmdname_C* cmdnames
    [
        (->cmdname_C (u8 "close"),         ex-close,         (| BANG RANGE NOTADR COUNT CMDWIN),                           ADDR_WINDOWS),
        (->cmdname_C (u8 "fixdel"),        ex-fixdel,           CMDWIN,                                                    ADDR_LINES),
        (->cmdname_C (u8 "only"),          ex-only,          (| BANG NOTADR RANGE COUNT),                                  ADDR_WINDOWS),
        (->cmdname_C (u8 "retab"),         ex-retab,         (| RANGE DFLALL BANG WORD1 CMDWIN),                           ADDR_LINES),
        (->cmdname_C (u8 "substitute"),    ex-sub,           (| RANGE EXTRA CMDWIN),                                       ADDR_LINES),
        (->cmdname_C (u8 "set"),           ex-set,           (| EXTRA CMDWIN),                                             ADDR_LINES),
        (->cmdname_C (u8 "stop"),          ex-stop,          (| BANG CMDWIN),                                              ADDR_LINES),
        (->cmdname_C (u8 "suspend"),       ex-stop,          (| BANG CMDWIN),                                              ADDR_LINES),
        (->cmdname_C (u8 "syncbind"),      ex-syncbind,         0,                                                         ADDR_LINES),
    ])

;;; ============================================================================================== VimG

;; Main loop: Execute Normal mode commands until exiting Vim.
;; Also used to handle commands in the command-line window, until the window is closed.

(defn- #_void main-loop [#_boolean cmdwin]
    ;; cmdwin: true when working in the command-line window
    (ยง
        ((ร #_"/*volatile*//*transient */"boolean previous_got_int =) false)     ;; "got_int" was true

        ((ร long conceal_old_cursor_line =) 0)
        ((ร long conceal_new_cursor_line =) 0)
        ((ร boolean conceal_update_lines =) false)

        ((ร oparg_C oa =) (NEW_oparg_C))                     ;; operator arguments

        (while (or (not cmdwin) (zero? @cmdwin_result))
            (when (stuff-empty)
                (if @need_wait_return                   ;; if wait-return still needed ...
                    (wait-return FALSE))                 ;; ... call it now
                (when (and @need_start_insertmode (goto-im) (not @VIsual_active))
                    (reset! need_start_insertmode false)
                    (stuffReadbuff (u8 "i"))                 ;; start insert mode next
                    ;; skip the fileinfo message now,
                    ;; because it would be shown after insert mode finishes!
                    (reset! need_fileinfo false)
                )
            )

            ;; Reset "got_int" now that we got back to the main loop.  Except when inside
            ;; a ":g/pat/cmd" command, then the "got_int" needs to abort the ":g" command.
            ;; For ":g/pat/vi" we reset "got_int" when used once.  When used
            ;; a second time we go back to Ex mode and abort the ":g" command.
            (cond @got_int
            (do
                (if (not @quit_more)
                    (vgetc))                ;; flush all buffers
                (reset! got_int false)

                ((ร previous_got_int =) true)
            )
            :else
            (do
                ((ร previous_got_int =) false)
            ))

            (reset! msg_scroll false)
            (reset! quit_more false)

            ;; If skip redraw is set (for ":" in wait-return()), don't redraw now.
            ;; If there is nothing in the stuff_buffer or do_redraw is true, update cursor and redraw.

            (cond @skip_redraw
            (do
                (reset! skip_redraw false)
            )
            (or @do_redraw (stuff-empty))
            (do
                ;; Trigger CursorMoved if the cursor moved.
                (when (and (not @finish_op) (< 0 @(:wo_cole (:w_options @curwin))) (not (eqpos @last_cursormoved, (:w_cursor @curwin))))
                    ((ร conceal_old_cursor_line =) (:lnum @last_cursormoved))
                    ((ร conceal_new_cursor_line =) (:lnum (:w_cursor @curwin)))
                    ((ร conceal_update_lines =) true)

                    (COPY-pos @last_cursormoved, (:w_cursor @curwin))
                )

                ;; Before redrawing, make sure w_topline is correct,
                ;; and w_leftcol if lines don't wrap, and w_skipcol if lines wrap.

                (update-topline)
                (validate-cursor)

                (cond @VIsual_active
                (do
                    (update-curbuf INVERTED)    ;; update inverted part
                )
                (non-zero? @must_redraw)
                (do
                    (update-screen 0)
                )
                (or @redraw_cmdline @clear_cmdline)
                (do
                    (showmode)
                ))
                (redraw-statuslines)
                ;; display message after redraw
                (when (non-nil? @keep_msg)
                    ;; msg-attr-keep() will set "keep_msg" to null, must free the string here.
                    ;; Don't reset "keep_msg", msg-attr-keep() uses it to check for duplicates.
                    (msg-attr @keep_msg, @keep_msg_attr)
                )
                (when @need_fileinfo          ;; show file info after redraw
                    (fileinfo 0, false)
                    (reset! need_fileinfo false)
                )

                (reset! emsg_on_display false)    ;; can delete error message now
                (reset! did_emsg false)
                (reset! msg_didany false)         ;; reset lines_left in msg-start()
                (may-clear-sb-text)        ;; clear scroll-back text on next msg
                (showruler false)

                (when (and conceal_update_lines (or (!= conceal_old_cursor_line conceal_new_cursor_line) (conceal-cursor-line @curwin) @need_cursor_line_redraw))
                    (if (and (!= conceal_old_cursor_line conceal_new_cursor_line) (<= conceal_old_cursor_line (:ml_line_count (:b_ml @curbuf))))
                        (update-single-line @curwin, conceal_old_cursor_line))
                    (update-single-line @curwin, conceal_new_cursor_line)
                    ((ร @curwin.w_valid =) (& (:w_valid @curwin) (bit-not VALID_CROW)))
                )
                (setcursor)
                (cursor-on)

                (reset! do_redraw false)
            ))

            ;; Update w_curswant if w_set_curswant has been set.
            ;; Postponed until here to avoid computing w_virtcol too often.

            (update-curswant)

            ;; Get and execute a normal mode command.

            (normal-cmd oa, true)
        )
        nil
    ))

;; Exit properly.
(defn- #_void getout [#_int exitval]
    (reset! exiting true)

    ;; Position the cursor on the last screen line, below all the text.
    (windgoto (dec (int @Rows)), 0)

    (when @did_emsg
        ;; give the user a chance to read the (error) message
        (reset! no_wait_return FALSE)
        (wait-return FALSE)
    )

    (mch-exit exitval))

;;; ============================================================================================== VimZ

(defn #_void -main [& #_String* args]
;%% (reset! starttime (._time libC))

    ;; Allocate the first window and buffer.
    ;; Can't do anything without it, exit when it fails.

    (win-alloc-first)

    (init-yank)                            ;; init yank buffers

    ;; Set the default values for the options.

    (set-init-1)

    ;; Don't redraw until much later.
    (swap! redrawingDisabled inc)

    ;; mch-init() sets up the terminal (window) for use.
    ;; This must be done after resetting full_screen, otherwise it may move the cursor (MSDOS).
    ;; Note that we may use mch-exit() before mch-init()!

    (mch-init)

    (set-term)                             ;; set terminal capabilities (will set full_screen)
    (screen-start)                         ;; don't know where cursor is now

    ;; Set the default values for the options that use Rows and Cols.

    (ui-get-shellsize)                     ;; inits Rows and Cols
    (win-init-size)

    (reset! cmdline_row (int (- @Rows @p_ch)))
    (reset! msg_row @cmdline_row)
    (screenalloc false)                     ;; allocate screen buffers

    (set-init-2)

    (reset! msg_scroll true)
    (reset! no_wait_return TRUE)

    ;; Start putting things on the screen.
    ;; Scroll screen down before drawing over it.
    ;; Clear screen now, so file message will not be cleared.

    (reset! starting NO_BUFFERS)
    (reset! no_wait_return FALSE)
    (reset! msg_scroll false)

    ;; When switching screens and something caused a message from a vimrc script,
    ;; need to output an extra newline on exit.
    (if (and (or @did_emsg @msg_didout) (non-eos? @T_TI))
        (reset! newline_on_exit true))

    ;; When done something that is not allowed or error message call wait-return.
    ;; This must be done before starttermcap(), because it may switch to another screen.
    ;; It must be done after settmode(TMODE_RAW), because we want to react on a single key stroke.
    ;; Call settmode and starttermcap here, so the T_KS and T_TI may be defined by set-term().

    (settmode TMODE_RAW)

    (if (or @need_wait_return @msg_didany)
        (wait-return TRUE))

    (starttermcap)                         ;; start termcap if not done by wait-return()

    (if @scroll_region
        (scroll-region-reset))              ;; in case Rows changed
    (scroll-start)                         ;; may scroll the screen to the right position

    (screenclear)                      ;; clear screen

    (reset! no_wait_return TRUE)

    (setpcmark)

    ;; If opened more than one window, start editing files in the other windows.

    ;; make the first window the current window
    (win-enter @firstwin)

    (reset! redrawingDisabled 0)
    (redraw-all-later NOT_VALID)
    (reset! no_wait_return FALSE)
    (reset! starting 0)

    ;; start in insert mode
    (if @p_im
        (reset! need_start_insertmode true))

    ;; If ":startinsert" command used, stuff a dummy command to be
    ;; able to call normal-cmd(), which will then start Insert mode.
    (if (non-zero? @restart_edit)
        (stuffcharReadbuff K_NOP))

    ;; Call the main command loop.  This never returns.

    (main-loop false)

    #_nil 0)
