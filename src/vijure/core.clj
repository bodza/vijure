(ns vijure.core
    (:refer-clojure :exclude [/ boolean byte short int long])
    (:require [org.baznex.imports :refer [import-static]])
    (:import [java.util Arrays])
    (:gen-class))

(org.baznex.imports/rename {vijure.VimA$Bytes 'Bytes})

(import-static vijure.VimA char_u u8 BEQ BNE BDIFF BLT BLE asc_toupper asc_tolower MEMCMP ACOPY BCOPY AFILL BFILL STRCAT STRCMP STRCPY STRLEN STRNCASECMP STRNCMP STRNCPY)
; %% (import-static vijure.VimB SIGHUP SIGQUIT SIGILL SIGTRAP SIGABRT SIGFPE SIGBUS SIGSEGV SIGSYS SIGALRM SIGTERM SIGVTALRM SIGPROF SIGXCPU SIGXFSZ SIGUSR1 SIGUSR2 SIGINT SIGWINCH SIGTSTP SIGPIPE)

(defmacro ยง [& _])
(defmacro ร [& _])

(defmacro def- [s i] `(def ~(vary-meta s assoc :private true) ~i))

(def- null nil)

(defmacro != [x y] `(not (== ~x ~y)))

(defmacro non-zero? [x] `(not (zero? ~x)))

(defmacro ... [a i] `(~a ~i))

(defmacro any
    ([f x y] `(~f ~x ~y))
    ([f x y & z] `(let [f# ~f x# ~x _# (any f# x# ~y)] (if _# _# (any f# x# ~@z)))))

(defn- ==?
    ([x y] (if (sequential? x) (if (seq x) (or (==? (first x) y) (recur (rest x) y)) false) (if (sequential? y) (recur y x) (== x y))))
    ([x y & z] (==? x (cons y z))))

(defmacro when' [y & w]
    (let [[_ & w] (if (= '=> (first w)) (rest w) (cons nil w))]
        `(if ~y (do ~@w) ~_)))
(defmacro let-when [x y & w]
    (let [[_ & w] (if (= '=> (first w)) (rest w) (cons nil w))]
        `(let [~@x] (if ~y (do ~@w) ~_))))

(letfn [(l' [x y z w]
    (let [x (cond (vector? x) x (symbol? x) [x x] :else [`_# x]) z (cond (vector? z) `((recur ~@z)) (some? z) `((recur ~z))) [_ & w] (if (= '=> (first w)) (rest w) (cons nil w))]
        `(loop [~@x] (if ~y (do ~@w ~@z) ~_))))]
            (defmacro loop-when [x y & w] (l' x y nil w))
            (defmacro loop-when-recur [x y z & w] (l' x y z w)))
(defmacro recur-if [y z & w]
    (let [z (cond (vector? z) `(recur ~@z) (some? z) `(recur ~z)) _ (if (= '=> (first w)) (second w))]
        `(if ~y ~z ~_)))

(def- / quot)
(def- % rem)

(def- & bit-and)
(def- | bit-or)
(def- << bit-shift-left)
(def- >>> unsigned-bit-shift-right)

(defmacro flag? [x y] `(non-zero? (& ~x ~y)))
(defmacro non-flag? [x y] `(zero? (& ~x ~y)))

(defn- boolean? [b] (instance? Boolean b))

(def- byte! unchecked-byte)

(defn- boolean ([] (boolean nil)) ([b] (cond (nil? b) false (boolean? b) b :else (throw (IllegalArgumentException. (str "fuzzy boolean " b))))))
(defn- byte    ([] (byte nil))    ([n] (clojure.core/byte (if (nil? n) 0 n))))
(defn- short   ([] (short nil))   ([n] (clojure.core/short (if (nil? n) 0 n))))
(defn- int     ([] (int nil))     ([n] (clojure.core/int (if (nil? n) 0 n))))
(defn- long    ([] (long nil))    ([n] (clojure.core/long (if (nil? n) 0 n))))
(defn- object  ([] (object nil))  ([o] o))

(def- maybean int)

(defmacro def'type* [& types] (cons 'do
    (map (fn [t] (let [t* (symbol (str t \*))]
        `(defn- ~t* [v#] (cond (sequential? v#) (mapv ~t v#) (number? v#) (recur (repeat v# nil)) :else (assert (nil? v#) (str "fuzzy " '~t* " " v#))))
    )) types)))
(def'type* boolean byte byte* int int* long object object*)

(def- frag_C* object*)

(def- C (map #(symbol (str % "_C")) '(buffer cmdline_info frame lpos match matcher memline nfa_pim nfa_state oparg pattern pos regsave regsubs soffset termios typebuf u_entry u_header visualinfo window winopt yankreg)))

(def- C* (map #(symbol (str % "_C*")) '(backpos btcap cmdname decomp digr frag frame key_name lpos modmasktable nfa_state nfa_thread nv_cmd pos signalinfo spat termcode typebuf vimoption wline yankreg)))

(def- C** (map #(symbol (str % "_C**")) '()))

(def- F (map #(symbol (str % "_F")) '(ex_func nv_func re_func)))

(let [I '(byte byte! byte* byte** int int* long maybean) O (concat '(Bytes Object) C) O* (concat '(Bytes* Bytes'*) C*)
      T (merge (zipmap I I) (zipmap O (repeat 'object)) (zipmap O* (repeat 'object*)))]
    (letfn [(f [t s] (if s (cons `(def- ~(first s) (~t ~(second s))) (f t (nnext s))) '(nil)))]
        (defmacro final [t & s] (let [t' (T t)] (assert t' (str "unexpected type: " t)) (when s (cons 'do (f t' s)))))))

(let [I '(boolean boolean* byte* int int* int** long long* maybean) O (cons 'Bytes C) O* (concat '(Bytes* Object*) C*) O** (concat '(Bytes**) C**)
      T (merge (zipmap I I) (zipmap O (repeat 'object)) (zipmap O* (repeat 'object*)) (zipmap O** (repeat 'object**)))]
    (letfn [(f [t s] (if s (cons `(def- ~(first s) (atom (~t ~(second s)))) (f t (nnext s))) '(nil)))]
        (defmacro atom! [t & s] (let [t' (T t)] (assert t' (str "unexpected type: " t)) (when s (cons 'do (f t' s)))))))

(let [I '#{boolean byte int long} A '(byte* int*) O (concat '(Bytes Object) C F) O* (concat '(Bytes* Object*) C*) O** C**
      T (merge (zipmap I I) (zipmap A A) (zipmap O (repeat 'object)) (zipmap O* (repeat 'object*)) (zipmap O** (repeat 'object**)))]
    (letfn [(f' [[f t n & [v]]] (let [t' (T t)] (assert t' (str "unexpected type: " t))
            (case f atom' `[~n (atom (~t' ~v))]
                    field `[~(if (I t) (vary-meta n assoc :tag t) n) (~t' ~v)])))]
        (defmacro class! [c [& fs] & _] (let [fs' (map f' fs)]
            `(do (defrecord ~c ~(mapv first fs') ~@_)
                 (defn- ~(symbol (str "NEW_" c)) [] (new ~c ~@(map second fs'))) nil)))))

(defn- #_Bytes* Bytes* [#_int n] (vec (repeat n #_Bytes nil)))

;;; ============================================================================================== VimA

(final maybean FALSE 0, TRUE 1, MAYBE 2)

#_(final Bytes VIMVERSION (u8 "VIM - Vi IMproved 7.4.692"))

(declare alphaOrd lowerOrd upperOrd rot13 ctrl-key is-special TERMCAP2KEY KEY2TERMCAP0 KEY2TERMCAP1 KB-SECOND KB-THIRD toSpecial vim-iswhite ARRAY-pos ARRAY-lpos ARRAY-wline asc-islower asc-isupper asc-isalpha asc-isalnum asc-iscntrl asc-isgraph asc-isprint asc-ispunct hl-attr ltpos eqpos ltoreq lineempty bufempty mch-write mch-inchar? handle-resize mch-delay sig-winch catch-sigint catch-sigpwr may-core-dump deathtrap mch-suspend mch-init set-signals catch-int-signal reset-signals catch-signals vim-handle-signal exit-scroll mch-exit mch-settmode get-stty mch-get-shellsize mch-set-shellsize mch-new-shellsize mch-breakcheck waitForChar realWaitForChar msg* msg? msg msg-attr? msg-attr msg-attr-keep? msg-strtrunc trunc-string emsg-allowed emsg? emsg emsg* wait-return hit-return-msg set-keep-msg msg-start msg-starthere msg-putchar msg-putchar-attr msg-outtrans msg-outtrans-attr msg-outtrans-len msg-outtrans-len-attr screen-puts-mbyte msg-puts msg-puts-title msg-puts-attr msg-puts-attr-len msg-puts-display msg-scroll-up t-puts msg-use-printf msg-puts-printf msg-screen-putchar msg-check-screen msg-clr-eos msg-clr-eos-force msg-clr-cmdline msg-end? msg-check give-warning bool-opt long-opt utf8-opt set-init-1 set-option-default set-options-default do-set? illegal-char didset-options did-set-string-option? check-colorcolumn? set-bool-option? set-num-option? check-redraw findoption showoneopt comp-col get-varp win-copy-options copy-winopt paste-option-changed fill-breakat-flags check-opt-strings opt-strings-flags can-bs get-sw-value get-sts-value find-mps-values briopt-check? do-ascii linelen ex-retab ex-fixdel ex-sub do-sub-msg? getcmdline text-locked text-locked-msg cmdline-charsize set-cmdspos set-cmdspos-cursor correct-cmdspos getexline alloc-cmdbuff realloc-cmdbuff draw-cmdline putcmdline unputcmdline put-on-cmdline save-cmdline restore-cmdline cmdline-paste? cmdline-paste-str redrawcmdline redrawcmdprompt redrawcmd compute-cmdrow cursorcmd gotocmdline hist-char2type init-history in-history add-to-history ex-window? do-cmdline-cmd do-cmdline? current-win-nr do-one-cmd append-command find-command skip-range get-address? invalid-range correct-range ex-close ex-win-close ex-only ex-stop do-sleep ex-set eval-to-string profile-setlimit profile-passed-limit find--command normal-cmd do-pending-operator op-colon op-function check-visual-highlight end-visual-mode reset-VIsual-and-resel reset-VIsual find-ident-under-cursor? prep-redo-cmd prep-redo checkclearop? checkclearopq? clearop' clearopbeep' clearop clearopbeep unshift-special clear-showcmd add-to-showcmd? add-to-showcmd add-to-showcmd-c del-from-showcmd push-showcmd pop-showcmd display-showcmd nv-ignore nv-nop nv-error nv-addsub nv-page nv-screengo nv-scroll-line scroll-redraw nv-zet nv-colon nv-ctrlg nv-ctrlh nv-clear nv-ctrlo nv-Zet nv-ident get-visual-text? nv-scroll nv-right nv-left nv-up nv-down nv-end nv-dollar nv-search nv-next normal-search? nv-csearch nv-brackets nv-percent nv-mark nv-undo nv-kundo nv-replace v-swap-corners nv-Replace nv-vreplace n-swapchar nv-cursormark v-visop nv-subst nv-abbrev nv-optrans nv-gomark nv-pcmark nv-regname nv-visual start-selection may-start-select n-start-visual-mode nv-window nv-suspend nv-g-cmd n-opencmd nv-dot nv-redo nv-Undo nv-tilde nv-operator nv-lineop nv-home nv-pipe nv-bck-word nv-wordcmd adjust-cursor nv-beginline adjust-for-sel unadjust-for-sel? nv-select nv-goto nv-normal nv-esc nv-edit invoke-edit nv-object nv-record nv-at nv-halfpage nv-join nv-put nv-open nv-drop nv-cursorhold ARRAY-yankreg get-op-type op-on-lines get-op-char get-extra-op-char op-shift shift-line shift-block block-insert op-reindent get-expr-register? get-expr-line valid-yank-reg get-yank-register get-register put-register do-record? stuff-yank do-execreg? put-reedit-in-typebuf put-in-typebuf insert-reg? stuffescaped get-spec-reg? cmdline-paste-reg adjust-clip-reg may-get-selection op-delete? mb-adjust-opend op-replace? op-tilde swapchars swapchar op-insert op-change? op-yank? yank-copy-line do-put adjust-cursor-eol do-join? do-join block-prep char-prep do-addsub line-count-info cursor-pos-info set-mark? setpcmark checkpcmark movemark movechangelist getmark getnextmark check-mark? one-adjust one-adjust-nodel mark-adjust col-adjust mark-col-adjust dedupe-jumplist copy-jumplist get-buffcont get-recorded get-inserted add-buff add-num-buff add-char-buff read-readbuf read-readbuffers stuff-empty flush-buffers reset-redo cancel-redo append-redo append-redo-lit append-redo-char append-redo-number stuff-string stuff-redo stuff-char stuff-num init-redo read-redo start-redo start-redo-ins stop-redo-ins init-typebuf ins-typebuf ins-char-typebuf typebuf-changed del-typebuf gotchars may-sync-undo before-blocking updatescript vgetc? vflush safe-vgetc? plain-vgetc? vpeekc? char-avail vungetc vgetorpeek? inchar? fix-input-buffer input-available vim-strsave-escape-special vim-unescape-special edit? ins-redraw ins-ctrl-v edit-putchar edit-unputchar change-indent truncate-spaces backspace-until-column del-char-after-col? del-char-after-col get-literal? insert-special isspecial? insert-char redo-literal start-arrow stop-arrow stop-insert set-last-insert add-char2buf beginline oneright? oneright oneleft? oneleft cursor-up? cursor-up cursor-down? cursor-down stuff-inserted? get-last-insert get-last-insert-save replace-push replace-push-mb replace-pop replace-join replace-pop-ins mb-replace-pop-ins replace-flush replace-do-bs ins-reg ins-ctrl-g ins-esc? ins-start-select? ins-insert ins-ctrl-o ins-shift ins-del ins-bs-one ins-bs? ins-left ins-home ins-end ins-s-left ins-right ins-s-right ins-up ins-pageup ins-down ins-pagedown ins-drop ins-tab? ins-eol? ins-eol ins-digraph ins-copychar ins-ctrl-ey ins-try-si do-insert-char-pre with-nl Magic un-Magic is-Magic no-Magic toggle-Magic re-op re-next operand operand-min operand-max operand-cmp re-multi-type backslash-trans get-char-class init-class-tab ri-digit ri-hex ri-octal ri-word ri-head ri-alpha ri-lower ri-upper ri-white re-multiline re-lookbehind get-equi-class reg-equi-class get-coll-element get-cpo-flags skip-anyof skip-regexp bt-regcomp? regcomp-start bt-reg? bt-regbranch? bt-regconcat? bt-regpiece? bt-regatom? do-multibyte use-multibytecode regnode regc regmbc reginsert reginsert-nr reginsert-limits re-put-long regtail regoptail init-parse-state save-parse-state restore-parse-state peekchr skipchr skipchr-keepstart getchr ungetchr gethexchrs getdecchrs getoctchrs coll-get-char read-limits? reg-getline bt-regexec? bt-regtry? reg-prev-class reg-match-visual bt-regmatch? reg-item pop-regitem drop-regbehind drop-regstar regrepeat regnext cleanup-subexpr save-subexpr restore-subexpr reg-nextchar reg-nextline reg-save reg-restore reg-save-equal re-num-cmp match-with-backref re-mult-next? mb-decompose cstrncmp cstrchr regtilde vim-regsub? nfa-regcomp-start nfa-get-reganch nfa-get-regstart nfa-get-match-text nfa-recognize-char-class emc1 emc2 nfa-emit-equi-class nfa-regatom? nfa-do-multibyte nfa-regpiece? nfa-regconcat? nfa-regbranch? nfa-reg? re2post? alloc-state? nfa-max-width alloc-frag fr-single fr-patch fr-append fr-push fr-pop post2nfa? nfa-postprocess new-regsubs copy-sub-off copy-ze-off sub-equal pim-equal has-state-with-pos match-follows state-in-list addstate addstate-here check-char-class match-backref nfa-re-num-cmp recursive-regmatch? failure-chance skip-to-start find-match-text nfa-regmatch? nfa-regtry? nfa-regcomp? nfa-regexec? vim-regcomp? report-re-switch vim-regexec? new-spat search-regcomp? save-re-pat re-ignorecase? re-has-uppercase? last-search-expr last-search-matcher? searchit? first-submatch do-search? searchc? findmatch findmatchlimit check-prevcol showmatch cls-cursor fwd-word? fwd-word bck-word? bck-word end-word? end-word bckend-word? bckend-word skip-chars? back-in-line current-word? current-block? find-next-quote find-prev-quote current-quote? current-search? is-one-char? linewhite ml-open ml-get ml-get-pos ml-get-cursor ml-append ml-replace ml-delete close-buffer newBuffer fileinfo col-print get-rel-pos set-chartab reset-chartab get-chartab init-chartab trans-characters transchar transchar-byte transchar-nonprint transchar-hex nr2hex mb-byte2cells mb-char2cells mb-ptr2cells mb-string2cells chartabsize linetabsize linetabsize-col win-linetabsize vim-isidentc vim-iswordc us-iswordb us-iswordp vim-isfnamec vim-isprintc lbr-chartabsize lbr-chartabsize-adv win-lbr-chartabsize win-nolbr-chartabsize in-win-border getvcol getvcol-nolist getvvcol getvcols skipwhite skipdigits asc-isdigit asc-isodigit asc-isxdigit getdigits vim-str2nr hex2nr digr do-digraph get-digraph? getexactdigraph getdigraph us-byte2len mb-byte2len us-get-class intable utf-char2cells us-ptr2cells us-string2cells utf-off2cells us-ptr2char us-safe-read-char-adv us-ptr2char-adv us-ptr2char-cc us-ptr2char-cc-len utfc-char2bytes us-ptr2len us-ptr2len-len us-ptr2len-cc us-ptr2len-cc-len utf-char2len utf-char2bytes utf-iscomposing utf-printable utf-class utf-convert utf-fold utf-tolower utf-toupper utf-islower utf-isupper us--strnicmp us-strnicmp show-utf8 us-head-off us-off-next us-tail-off utf-find-illegal mb-adjust-pos us-ptr-back us-prevptr us-charlen mb-lefthalve mb-fix-col get-indent get-indent-str set-indent? set-indent copy-indent get-breakindent cin-is-cinword open-line? plines plines-nowrap plines-col plines-many ins-bytes ins-bytes-len ins-char ins-char-bytes ins-str del-char? del-char del-chars? del-chars del-bytes? del-bytes truncate-line del-lines gchar-pos gchar-cursor inindent skip-to-option-part changed changed-bytes changed-one-line appended-lines appended-lines-mark deleted-lines deleted-lines-mark changed-lines changed-lines-buf changed-common unchanged check-status get-keystroke? msgmore beep-flush beep prepare-to-exit preserve-exit slow-breakcheck fast-breakcheck goto-im virtual-active getviscol getviscol2 coladvance-force coladvance? coladvance getvpos coladvance3 inc-cursor? inc-cursor incp? incp incl? incl dec-cursor? dec-cursor decp? decp decl? decl get-cursor-rel-lnum check-cursor-lnum check-cursor-col check-cursor adjust-cursor-col leftcol-changed? leftcol-changed STRDUP STRNDUP vim-strsave-escaped vim-strncpy vim-strcat copy-option-part vim-strchr vim-strbyte vim-strrchr vim-isspace simplify-key handle-x-keys get-special-key-name find-special-key-name get-real-state trigger-cursorhold u-save-cursor u-save u-savesub u-inssub u-savedel undo-allowed? get-undolevels u-savecommon? u-undo u-redo u-doit u-undoredo u-undo-end u-sync u-add-time u-getbot u-saveline u-clearline u-undoline parse-builtin-tcap set-term out-flush out-flush-check out-char out-char-nf _addfmt _tgoto _tputs out-str-nf out-str term-windgoto term-cursor-right term-append-lines term-delete-lines term-set-winsize term-fg-color term-bg-color term-color ttest check-shellsize limit-screen-size win-new-shellsize shell-resized set-shellsize settmode start-termcap stop-termcap swapping-screen scroll-start cursor-on cursor-off term-cursor-shape scroll-region-set scroll-region-reset ARRAY-termcode clear-termcodes add-termcode termcode-star find-termcode del-termcode del-termcode-idx check-termcode gather-termleader ui-write ui-inchar? ui-delay ui-suspend ui-get-shellsize ui-set-shellsize ui-new-shellsize ui-breakcheck is-input-buf-full is-input-buf-empty read-from-input-buf fill-input-buf ui-cursor-shape check-col check-row redraw-later redraw-later-clear redraw-all-later redraw-curbuf-later redraw-winline update-curbuf update-screen update-single-line win-update win-draw-end advance-color-col win-line comp-char-differs char-needs-redraw screen-line status-redraw-all redraw-statuslines draw-vsep-win win-redr-status stl-connected screen-putchar screen-getbytes screen-comp-differs screen-puts screen-puts-len start-search-hl end-search-hl init-search-hl prepare-search-hl next-search-hl? screen-start-highlight screen-stop-highlight reset-cterm-colors screen-char screen-draw-rectangle redraw-block screen-fill check-for-delay screen-valid screen-alloc screen-clear screenclear2 lineclear lineinvalid linecopy can-clear screen-start windgoto setcursor win-ins-lines? win-del-lines? win-do-lines win-rest-invalid screen-ins-lines screen-del-lines showmode? showmode msg-pos-mode unshowmode fillchar-status fillchar-vsep redrawing messaging showruler win-redr-ruler number-width? screen-screencol screen-screenrow do-window cmd-with-count win-split? win-split win-split-ins? win-split-ins win-init win-exchange win-rotate win-totop win-equal win-equal-rec one-window win-close? win-free-mem winframe-remove' win-altframe frame2win frame-has-win frame-new-height frame-fixed-height frame-fixed-width frame-add-statusline frame-new-width frame-add-vsep frame-fix-width frame-fix-height frame-minheight frame-minwidth close-others newFrame win-init-size win-goto win-goto-ver win-goto-hor win-enter win-enter-ext newWindow win-free win-append win-remove frame-append frame-insert frame-remove win-alloc-lines win-free-lines shell-new-rows shell-new-columns win-comp-pos frame-comp-pos win-setheight frame-setheight win-setwidth frame-setwidth win-setminheight win-setminwidth set-fraction win-new-height win-new-width win-comp-scroll command-height frame-add-height last-status last-status-rec min-rows frame-check-height frame-check-width comp-botline redraw-for-cursorline update-topline-redraw update-topline scrolljump-value check-top-offset update-curswant check-cursor-moved changed-window-setting set-topline changed-cline-bef-curs changed-line-abv-curs validate-botline invalidate-botline approximate-botline validate-cursor curs-rows validate-virtcol validate-cheight validate-cursor-col win-col-off win-col-off2 curs-columns scrolldown scrollup topline-back botline-forw scroll-cursor-top set-empty-rows scroll-cursor-bot scroll-cursor-halfway cursor-correct onepage? onepage get-scroll-overlap halfpage restore-cterm-colors hl-combine-attr main-loop getout)

;;; ============================================================================================== VimC

;; Definitions of various common control characters.

(final byte NUL     000)    ;; %% VimA/NUL
(final byte BELL    007)
(final byte BS      010)
(final byte TAB     (byte \tab))
(final byte NL      012)
(final byte FF      014)
(final byte CAR     015)    ;; CR is used by Mac OS X
(final byte ESC     033)
(final byte DEL    0x7f)

(final byte! POUND 0xa3)

(final Bytes
    NL_STR   (u8 "\012")
    ESC_STR  (u8 "\033")
    DEL_STR  (u8 "\177"))

(defmacro at
    ([x] (at x 0))
    ([x y] (.at x y)))

(defn- at?
    ([x z] (at? x 0 z))
    ([x y z] (== (.at x y) z)))
(defn- not-at?
    ([x z] (not-at? x 0 z))
    ([x y z] (!= (.at x y) z)))

(defn- eos?
    ([x] (eos? x 0))
    ([x y] (== (.at x y) NUL)))
(defn- non-eos?
    ([x] (non-eos? x 0))
    ([x y] (!= (.at x y) NUL)))
(defn- eos!
    ([x] (eos! x 0))
    ([x y] (.be x y, NUL)))

(defn- plus [x y] (.plus x y))
(defn- minus [x y] (.minus x y))

(defn- #_int alphaOrd [#_int x] (- x (if (< x (byte \a)) (byte \A) (byte \a))))
(defn- #_int lowerOrd [#_int x] (- x (byte \a)))
(defn- #_int upperOrd [#_int x] (- x (byte \A)))

(defn- #_int rot13 [#_int c, #_int a]
    (+ (% (+ (- c a) 13) 26) a))

(defn- #_int ctrl-key [#_byte c]
    (if (< c NUL) (char_u c) (bit-xor (asc_toupper c) 0x40)))       ;; '?' -> DEL, '@' -> ^@, etc.

(final Bytes
    CTRL_H_STR (u8 "\010")
    CTRL_V_STR (u8 "\026"))

(final byte
    Ctrl_AT   0,        ;; @
    Ctrl_A    1,
    Ctrl_B    2,
    Ctrl_C    3,
    Ctrl_D    4,
    Ctrl_E    5,
    Ctrl_F    6,
    Ctrl_G    7,
    Ctrl_H    8,
    Ctrl_I    9,
    Ctrl_J   10,
    Ctrl_K   11,
    Ctrl_L   12,
    Ctrl_M   13,
    Ctrl_N   14,
    Ctrl_O   15,
    Ctrl_P   16,
    Ctrl_Q   17,
    Ctrl_R   18,
    Ctrl_S   19,
    Ctrl_T   20,
    Ctrl_U   21,
    Ctrl_V   22,
    Ctrl_W   23,
    Ctrl_X   24,
    Ctrl_Y   25,
    Ctrl_Z   26,
                        ;; CTRL- [ Left Square Bracket == ESC
    Ctrl_BSL 28,        ;; \ BackSLash
    Ctrl_RSB 29,        ;; ] Right Square Bracket
    Ctrl_HAT 30,        ;; ^
    Ctrl__   31)

;; ----------------------------------------------------------------------- ;;

;; Keycode definitions for special keys.
;;
;; Any special key code sequences are replaced by these codes.

;; KB_SPECIAL is the first byte of a special key code and is always followed by two bytes.
;; The second byte can have any value.  ASCII is used for normal termcap entries,
;; 0x80 and higher for special keys, see below.
;; The third byte is guaranteed to be between 0x02 and 0x7f.

(final byte! KB_SPECIAL         0x80)

;; Positive characters are "normal" characters.
;; Negative characters are special key codes.  Only characters below -0x200 are used,
;; so that the absolute value can't be mistaken for a single-byte character.

(defn- #_boolean is-special [#_int c]
    (< c 0))

;; NUL cannot be in the input string, therefore it is replaced by
;;      KB_SPECIAL  KS_ZERO     KE_FILLER

(final byte! KS_ZERO            255)

;; KB_SPECIAL cannot be in the input string, therefore it is replaced by
;;      KB_SPECIAL  KS_SPECIAL  KE_FILLER

(final byte! KS_SPECIAL         254)

;; KS_EXTRA is used for keys that have no termcap name
;;      KB_SPECIAL  KS_EXTRA    KE_xxx

(final byte! KS_EXTRA           253)

;; KS_MODIFIER is used when a modifier is given for a (special) key
;;      KB_SPECIAL  KS_MODIFIER bitmask

(final byte! KS_MODIFIER        252)

;; These are used for the GUI
;;      KB_SPECIAL  KS_xxx      KE_FILLER

(final byte! KS_VER_SCROLLBAR   249)
(final byte! KS_HOR_SCROLLBAR   248)

;; Used for switching Select mode back on after a mapping or menu.

(final byte! KS_SELECT          245)

;; Used a termcap entry that produces a normal character.

(final byte! KS_KEY             242)

;; Filler used after KS_SPECIAL and others.

(final byte KE_FILLER            \X)

;; Translation of three byte code "KB_SPECIAL a b" into int "K_xxx" and back.

(defn- #_int TERMCAP2KEY [#_byte a, #_byte b]
    (int (- (+ (char_u a) (<< (char_u b) 8)))))

(defn- #_byte KEY2TERMCAP0 [#_int x]
    (byte! (& (- x) 0xff)))

(defn- #_byte KEY2TERMCAP1 [#_int x]
    (byte! (& (>>> (- x) 8) 0xff)))

;; Get second or third byte when translating special key code into three bytes.

(defn- #_byte KB-SECOND [#_int c]
    (cond (== c (char_u KB_SPECIAL)) KS_SPECIAL (== c NUL) KS_ZERO :else (KEY2TERMCAP0 c)))

(defn- #_byte KB-THIRD [#_int c]
    (if (any == c (char_u KB_SPECIAL) NUL) KE_FILLER (KEY2TERMCAP1 c)))

;; Codes for keys that do not have a termcap name.
;;
;; KB_SPECIAL KS_EXTRA KE_xxx

(final byte
    KE_S_UP 4,            ;; shift-up
    KE_S_DOWN 5,          ;; shift-down

    KE_S_F1 6,            ;; shifted function keys
    KE_S_F2 7,
    KE_S_F3 8,
    KE_S_F4 9,
    KE_S_F5 10,
    KE_S_F6 11,
    KE_S_F7 12,
    KE_S_F8 13,
    KE_S_F9 14,
    KE_S_F10 15,

    KE_S_F11 16,
    KE_S_F12 17,

;; Symbols for pseudo keys which are translated from the real key symbols above.

    KE_IGNORE 53,         ;; ignored mouse drag/release

    KE_TAB 54,            ;; unshifted TAB key

    KE_XF1 56,            ;; extra vt100 function keys for xterm
    KE_XF2 57,
    KE_XF3 58,
    KE_XF4 59,
    KE_XEND 60,           ;; extra (vt100) end key for xterm
    KE_ZEND 61,           ;; extra (vt100) end key for xterm
    KE_XHOME 62,          ;; extra (vt100) home key for xterm
    KE_ZHOME 63,          ;; extra (vt100) home key for xterm
    KE_XUP 64,            ;; extra vt100 cursor keys for xterm
    KE_XDOWN 65,
    KE_XLEFT 66,
    KE_XRIGHT 67,

    KE_S_XF1 70,          ;; extra vt100 shifted function keys for xterm
    KE_S_XF2 71,
    KE_S_XF3 72,
    KE_S_XF4 73,

    KE_KINS 78,           ;; keypad Insert key
    KE_KDEL 79,           ;; keypad Delete key

    KE_CMDWIN 83,         ;; open command-line window from Command-line Mode

    KE_C_LEFT 84,         ;; control-left
    KE_C_RIGHT 85,        ;; control-right
    KE_C_HOME 86,         ;; control-home
    KE_C_END 87,          ;; control-end

    KE_DROP 94,           ;; DnD data is available
    KE_CURSORHOLD 95,     ;; CursorHold event

    KE_NOP 98)            ;; doesn't do anything

;; the three byte codes are replaced with the following int when using vgetc()

(final int
    K_ZERO          (TERMCAP2KEY KS_ZERO KE_FILLER),

    K_UP            (TERMCAP2KEY (byte \k) (byte \u)),
    K_DOWN          (TERMCAP2KEY (byte \k) (byte \d)),
    K_LEFT          (TERMCAP2KEY (byte \k) (byte \l)),
    K_RIGHT         (TERMCAP2KEY (byte \k) (byte \r)),
    K_S_UP          (TERMCAP2KEY KS_EXTRA KE_S_UP),
    K_S_DOWN        (TERMCAP2KEY KS_EXTRA KE_S_DOWN),
    K_S_LEFT        (TERMCAP2KEY (byte \#) (byte \4)),
    K_C_LEFT        (TERMCAP2KEY KS_EXTRA KE_C_LEFT),
    K_S_RIGHT       (TERMCAP2KEY (byte \%) (byte \i)),
    K_C_RIGHT       (TERMCAP2KEY KS_EXTRA KE_C_RIGHT),
    K_S_HOME        (TERMCAP2KEY (byte \#) (byte \2)),
    K_C_HOME        (TERMCAP2KEY KS_EXTRA KE_C_HOME),
    K_S_END         (TERMCAP2KEY (byte \*) (byte \7)),
    K_C_END         (TERMCAP2KEY KS_EXTRA KE_C_END),
    K_TAB           (TERMCAP2KEY KS_EXTRA KE_TAB),
    K_S_TAB         (TERMCAP2KEY (byte \k) (byte \B)),

;; extra set of function keys F1-F4, for vt100 compatible xterm
    K_XF1           (TERMCAP2KEY KS_EXTRA KE_XF1),
    K_XF2           (TERMCAP2KEY KS_EXTRA KE_XF2),
    K_XF3           (TERMCAP2KEY KS_EXTRA KE_XF3),
    K_XF4           (TERMCAP2KEY KS_EXTRA KE_XF4),

;; extra set of cursor keys for vt100 compatible xterm
    K_XUP           (TERMCAP2KEY KS_EXTRA KE_XUP),
    K_XDOWN         (TERMCAP2KEY KS_EXTRA KE_XDOWN),
    K_XLEFT         (TERMCAP2KEY KS_EXTRA KE_XLEFT),
    K_XRIGHT        (TERMCAP2KEY KS_EXTRA KE_XRIGHT),

    K_F1            (TERMCAP2KEY (byte \k) (byte \1)),   ;; function keys
    K_F2            (TERMCAP2KEY (byte \k) (byte \2)),
    K_F3            (TERMCAP2KEY (byte \k) (byte \3)),
    K_F4            (TERMCAP2KEY (byte \k) (byte \4)),
    K_F5            (TERMCAP2KEY (byte \k) (byte \5)),
    K_F6            (TERMCAP2KEY (byte \k) (byte \6)),
    K_F7            (TERMCAP2KEY (byte \k) (byte \7)),
    K_F8            (TERMCAP2KEY (byte \k) (byte \8)),
    K_F9            (TERMCAP2KEY (byte \k) (byte \9)),
    K_F10           (TERMCAP2KEY (byte \k) (byte \;)),

    K_F11           (TERMCAP2KEY (byte \F) (byte \1)),
    K_F12           (TERMCAP2KEY (byte \F) (byte \2)),

;; extra set of shifted function keys F1-F4, for vt100 compatible xterm
    K_S_XF1         (TERMCAP2KEY KS_EXTRA KE_S_XF1),
    K_S_XF2         (TERMCAP2KEY KS_EXTRA KE_S_XF2),
    K_S_XF3         (TERMCAP2KEY KS_EXTRA KE_S_XF3),
    K_S_XF4         (TERMCAP2KEY KS_EXTRA KE_S_XF4),

    K_S_F1          (TERMCAP2KEY KS_EXTRA KE_S_F1),  ;; shifted func. keys
    K_S_F2          (TERMCAP2KEY KS_EXTRA KE_S_F2),
    K_S_F3          (TERMCAP2KEY KS_EXTRA KE_S_F3),
    K_S_F4          (TERMCAP2KEY KS_EXTRA KE_S_F4),
    K_S_F5          (TERMCAP2KEY KS_EXTRA KE_S_F5),
    K_S_F6          (TERMCAP2KEY KS_EXTRA KE_S_F6),
    K_S_F7          (TERMCAP2KEY KS_EXTRA KE_S_F7),
    K_S_F8          (TERMCAP2KEY KS_EXTRA KE_S_F8),
    K_S_F9          (TERMCAP2KEY KS_EXTRA KE_S_F9),
    K_S_F10         (TERMCAP2KEY KS_EXTRA KE_S_F10),

    K_S_F11         (TERMCAP2KEY KS_EXTRA KE_S_F11),
    K_S_F12         (TERMCAP2KEY KS_EXTRA KE_S_F12),

    K_HELP          (TERMCAP2KEY (byte \%) (byte \1)),
    K_UNDO          (TERMCAP2KEY (byte \&) (byte \8)),

    K_BS            (TERMCAP2KEY (byte \k) (byte \b)),

    K_INS           (TERMCAP2KEY (byte \k) (byte \I)),
    K_KINS          (TERMCAP2KEY KS_EXTRA KE_KINS),
    K_DEL           (TERMCAP2KEY (byte \k) (byte \D)),
    K_KDEL          (TERMCAP2KEY KS_EXTRA KE_KDEL),
    K_HOME          (TERMCAP2KEY (byte \k) (byte \h)),
    K_KHOME         (TERMCAP2KEY (byte \K) (byte \1)),   ;; keypad home (upper left)
    K_XHOME         (TERMCAP2KEY KS_EXTRA KE_XHOME),
    K_ZHOME         (TERMCAP2KEY KS_EXTRA KE_ZHOME),
    K_END           (TERMCAP2KEY (byte \@) (byte \7)),
    K_KEND          (TERMCAP2KEY (byte \K) (byte \4)),   ;; keypad end (lower left)
    K_XEND          (TERMCAP2KEY KS_EXTRA KE_XEND),
    K_ZEND          (TERMCAP2KEY KS_EXTRA KE_ZEND),
    K_PAGEUP        (TERMCAP2KEY (byte \k) (byte \P)),
    K_PAGEDOWN      (TERMCAP2KEY (byte \k) (byte \N)),
    K_KPAGEUP       (TERMCAP2KEY (byte \K) (byte \3)),   ;; keypad pageup (upper R.)
    K_KPAGEDOWN     (TERMCAP2KEY (byte \K) (byte \5)),   ;; keypad pagedown (lower R.)

    K_KPLUS         (TERMCAP2KEY (byte \K) (byte \6)),   ;; keypad plus
    K_KMINUS        (TERMCAP2KEY (byte \K) (byte \7)),   ;; keypad minus
    K_KDIVIDE       (TERMCAP2KEY (byte \K) (byte \8)),   ;; keypad /
    K_KMULTIPLY     (TERMCAP2KEY (byte \K) (byte \9)),   ;; keypad *
    K_KENTER        (TERMCAP2KEY (byte \K) (byte \A)),   ;; keypad Enter
    K_KPOINT        (TERMCAP2KEY (byte \K) (byte \B)),   ;; keypad . or ,

    K_K0            (TERMCAP2KEY (byte \K) (byte \C)),   ;; keypad 0
    K_K1            (TERMCAP2KEY (byte \K) (byte \D)),   ;; keypad 1
    K_K2            (TERMCAP2KEY (byte \K) (byte \E)),   ;; keypad 2
    K_K3            (TERMCAP2KEY (byte \K) (byte \F)),   ;; keypad 3
    K_K4            (TERMCAP2KEY (byte \K) (byte \G)),   ;; keypad 4
    K_K5            (TERMCAP2KEY (byte \K) (byte \H)),   ;; keypad 5
    K_K6            (TERMCAP2KEY (byte \K) (byte \I)),   ;; keypad 6
    K_K7            (TERMCAP2KEY (byte \K) (byte \J)),   ;; keypad 7
    K_K8            (TERMCAP2KEY (byte \K) (byte \K)),   ;; keypad 8
    K_K9            (TERMCAP2KEY (byte \K) (byte \L)),   ;; keypad 9

    K_VER_SCROLLBAR (TERMCAP2KEY KS_VER_SCROLLBAR KE_FILLER),
    K_HOR_SCROLLBAR (TERMCAP2KEY KS_HOR_SCROLLBAR KE_FILLER),

    K_SELECT        (TERMCAP2KEY KS_SELECT KE_FILLER),

;; Symbols for pseudo keys which are translated from the real key symbols above.

    K_IGNORE        (TERMCAP2KEY KS_EXTRA KE_IGNORE),
    K_NOP           (TERMCAP2KEY KS_EXTRA KE_NOP),

    K_CMDWIN        (TERMCAP2KEY KS_EXTRA KE_CMDWIN),

    K_DROP          (TERMCAP2KEY KS_EXTRA KE_DROP),

    K_CURSORHOLD    (TERMCAP2KEY KS_EXTRA KE_CURSORHOLD))

;; Bits for modifier mask.
;; 0x01 cannot be used, because the modifier must be 0x02 or higher

(final int
    MOD_MASK_SHIFT      0x02,
    MOD_MASK_CTRL       0x04,
    MOD_MASK_ALT        0x08,        ;; aka META
    MOD_MASK_META       0x10,        ;; META when it's different from ALT
    MOD_MASK_2CLICK     0x20,        ;; use MOD_MASK_MULTI_CLICK
    MOD_MASK_3CLICK     0x40,        ;; use MOD_MASK_MULTI_CLICK
    MOD_MASK_4CLICK     0x60)        ;; use MOD_MASK_MULTI_CLICK

(final int MOD_MASK_MULTI_CLICK (| MOD_MASK_2CLICK MOD_MASK_3CLICK MOD_MASK_4CLICK))

;; The length of the longest special key name, including modifiers.
;; Current longest is <M-C-S-T-4-MiddleRelease> (length includes '<' and '>').

(final int MAX_KEY_NAME_LEN    25)

;; Maximum length of a special key event as tokens.  This includes modifiers.
;; The longest event is something like <M-C-S-T-4-LeftDrag> which would be the
;; following string of tokens:
;;
;; <KB_SPECIAL> <KS_MODIFIER> bitmask <KB_SPECIAL> <KS_EXTRA> <KE_LEFTDRAG>.
;;
;; This is a total of 6 tokens, and is currently the longest one possible.

(final int MAX_KEY_CODE_LEN    6)

;; Get single int code from second byte after KB_SPECIAL.

(defn- #_int toSpecial [#_byte a, #_byte b]
    (cond (== a KS_SPECIAL) (char_u KB_SPECIAL) (== a KS_ZERO) K_ZERO :else (TERMCAP2KEY a, b)))

;; ----------------------------------------------------------------------- ;;

;; This file contains the defines for the machine dependent escape sequences
;; that the editor needs to perform various operations.  All of the sequences
;; here are optional, except "cm" (cursor motion).

;; Index of the termcap codes in the 'term_strings' array.

(final int
    KS_NAME  0,     ;; name of this terminal entry
    KS_CE    1,     ;; clear to end of line
    KS_AL    2,     ;; add new blank line
    KS_CAL   3,     ;; add number of blank lines
    KS_DL    4,     ;; delete line
    KS_CDL   5,     ;; delete number of lines
    KS_CS    6,     ;; scroll region
    KS_CL    7,     ;; clear screen
    KS_CD    8,     ;; clear to end of display
    KS_UT    9,     ;; clearing uses current background color
    KS_DA   10,     ;; text may be scrolled down from up
    KS_DB   11,     ;; text may be scrolled up from down
    KS_VI   12,     ;; cursor invisible
    KS_VE   13,     ;; cursor visible
    KS_VS   14,     ;; cursor very visible
    KS_ME   15,     ;; normal mode
    KS_MR   16,     ;; reverse mode
    KS_MD   17,     ;; bold mode
    KS_SE   18,     ;; normal mode
    KS_SO   19,     ;; standout mode
    KS_CZH  20,     ;; italic mode start
    KS_CZR  21,     ;; italic mode end
    KS_UE   22,     ;; exit underscore (underline) mode
    KS_US   23,     ;; underscore (underline) mode
    KS_MS   24,     ;; save to move cur in reverse mode
    KS_CM   25,     ;; cursor motion
    KS_SR   26,     ;; scroll reverse (backward)
    KS_CRI  27,     ;; cursor number of chars right
    KS_VB   28,     ;; visual bell
    KS_KS   29,     ;; put term in "keypad transmit" mode
    KS_KE   30,     ;; out of "keypad transmit" mode
    KS_TI   31,     ;; put terminal in termcap mode
    KS_TE   32,     ;; out of termcap mode
    KS_BC   33,     ;; backspace character (cursor left)
    KS_CCO  34,     ;; number of colors
    KS_CSF  35,     ;; set foreground color
    KS_CSB  36,     ;; set background color
    KS_XN   37,     ;; newline glitch
    KS_CAF  38,     ;; set foreground color (ANSI)
    KS_CAB  39,     ;; set background color (ANSI)
    KS_LE   40,     ;; cursor left (mostly backspace)
    KS_ND   41,     ;; cursor right
    KS_CWS  42,     ;; set window size in characters
    KS_CSI  43,     ;; start insert mode (bar cursor)
    KS_CEI  44,     ;; end insert mode (block cursor)
    KS_CSR  45,     ;; start replace mode (underline cursor)
    KS_CSV  46,     ;; scroll region vertical
    KS_OP   47)     ;; original color pair

;; The terminal capabilities are stored in this array.
;; IMPORTANT: When making changes, note the following:
;; - there should be an entry for each code in the builtin termcaps
;; - there should be an option for each code in option.c
;; - there should be code in term.c to obtain the value from the termcap

;; strings used for terminal

(atom! Bytes
    T_NAME  nil,    ;; terminal name
    T_CE    nil,    ;; clear to end of line
    T_AL    nil,    ;; add new blank line
    T_CAL   nil,    ;; add number of blank lines
    T_DL    nil,    ;; delete line
    T_CDL   nil,    ;; delete number of lines
    T_CS    nil,    ;; scroll region
    T_CL    nil,    ;; clear screen
    T_CD    nil,    ;; clear to end of display
    T_UT    nil,    ;; clearing uses background color
    T_DA    nil,    ;; text may be scrolled down from up
    T_DB    nil,    ;; text may be scrolled up from down
    T_VI    nil,    ;; cursor invisible
    T_VE    nil,    ;; cursor visible
    T_VS    nil,    ;; cursor very visible
    T_ME    nil,    ;; normal mode
    T_MR    nil,    ;; reverse mode
    T_MD    nil,    ;; bold mode
    T_SE    nil,    ;; normal mode
    T_SO    nil,    ;; standout mode
    T_CZH   nil,    ;; italic mode start
    T_CZR   nil,    ;; italic mode end
    T_UE    nil,    ;; exit underscore (underline) mode
    T_US    nil,    ;; underscore (underline) mode
    T_MS    nil,    ;; save to move cur in reverse mode
    T_CM    nil,    ;; cursor motion
    T_SR    nil,    ;; scroll reverse (backward)
    T_CRI   nil,    ;; cursor number of chars right
    T_VB    nil,    ;; visual bell
    T_KS    nil,    ;; put term in "keypad transmit" mode
    T_KE    nil,    ;; out of "keypad transmit" mode
    T_TI    nil,    ;; put terminal in termcap mode
    T_TE    nil,    ;; out of termcap mode
    T_BC    nil,    ;; backspace character
    T_CCO   nil,    ;; number of colors
    T_CSF   nil,    ;; set foreground color
    T_CSB   nil,    ;; set background color
    T_XN    nil,    ;; newline glitch
    T_CAF   nil,    ;; set foreground color (ANSI)
    T_CAB   nil,    ;; set background color (ANSI)
    T_LE    nil,    ;; cursor left
    T_ND    nil,    ;; cursor right
    T_CWS   nil,    ;; window size
    T_CSI   nil,    ;; start insert mode
    T_CEI   nil,    ;; end insert mode
    T_CSR   nil,    ;; start replace mode
    T_CSV   nil,    ;; scroll region vertical
    T_OP    nil)    ;; original color pair

;; 'term_strings' contains currently used terminal output strings.
;; It is initialized with the default values by parse-builtin-tcap().
;; The values can be changed by setting the option with the same name.

(final Bytes'* term_strings [ T_NAME T_CE T_AL  T_CAL T_DL  T_CDL T_CS  T_CL
                              T_CD   T_UT T_DA  T_DB  T_VI  T_VE  T_VS  T_ME
                              T_MR   T_MD T_SE  T_SO  T_CZH T_CZR T_UE  T_US
                              T_MS   T_CM T_SR  T_CRI T_VB  T_KS  T_KE  T_TI
                              T_TE   T_BC T_CCO T_CSF T_CSB T_XN  T_CAF T_CAB
                              T_LE   T_ND T_CWS T_CSI T_CEI T_CSR T_CSV T_OP ])

(final int TMODE_COOK  0)   ;; terminal mode for external cmds and Ex mode
(final int TMODE_SLEEP 1)   ;; terminal mode for sleeping (cooked but no echo)
(final int TMODE_RAW   2)   ;; terminal mode for Normal and Insert mode

;; ----------------------------------------------------------------------- ;;

;; flags for update-screen()
;; The higher the value, the higher the priority

(final int
    VALID           10,     ;; buffer not changed, or changes marked with b_mod_*
    INVERTED        20,     ;; redisplay inverted part that changed
    INVERTED_ALL    25,     ;; redisplay whole inverted part
    REDRAW_TOP      30,     ;; display first "w_upd_rows" screen lines
    SOME_VALID      35,     ;; like NOT_VALID but may scroll
    NOT_VALID       40,     ;; buffer needs complete redraw
    CLEAR           50)     ;; screen messed up, clear it

;; Flags for "w_valid".
;; These are set when something in a window structure becomes invalid, except when the cursor is moved.
;; Call check-cursor-moved() before testing one of the flags.
;; These are reset when that thing has been updated and is valid again.
;;
;; Every function that invalidates one of these must call one of the invalidate_* functions.
;;
;; "w_valid" is supposed to be encapsulated: use the functions that set or reset the flags, instead.
;;
;; VALID_BOTLINE    VALID_BOTLINE_AP
;;     on               on             "w_botline" valid
;;     off              on             "w_botline" approximated
;;     off              off            "w_botline" not valid
;;     on               off            not possible

(final int
    VALID_WROW          0x01,       ;; "w_wrow" (window row) is valid
    VALID_WCOL          0x02,       ;; "w_wcol" (window col) is valid
    VALID_VIRTCOL       0x04,       ;; "w_virtcol" (file col) is valid
    VALID_CHEIGHT       0x08,       ;; "w_cline_height" is valid
    VALID_CROW          0x10,       ;; "w_cline_row" is valid
    VALID_BOTLINE       0x20,       ;; "w_botine" and "w_empty_rows" are valid
    VALID_BOTLINE_AP    0x40,       ;; "w_botine" is approximated
    VALID_TOPLINE       0x80)       ;; "w_topline" is valid (for cursor position)

;; Terminal highlighting attribute bits.
;; Attributes above HL_ALL are used for syntax highlighting.

(final int
    HL_NORMAL           0x00,
    HL_INVERSE          0x01,
    HL_BOLD             0x02,
    HL_ITALIC           0x04,
    HL_UNDERLINE        0x08,
    HL_UNDERCURL        0x10,
    HL_STANDOUT         0x20,
    HL_ALL              0x3f)

;; values for State
;;
;; The lower bits up to 0x20 are used to distinguish normal/visual/op_pending
;; and cmdline/insert+replace mode.  This is used for mapping.
;; If none of these bits are set, no mapping is done.
;; The upper bits are used to distinguish between other states.

(final int
    NORMAL          0x01,           ;; normal mode, command expected
    VISUAL          0x02,           ;; visual mode - use get-real-state()
    OP_PENDING      0x04,           ;; normal mode, operator is pending - use get-real-state()
    CMDLINE         0x08,           ;; editing command line
    INSERT          0x10,           ;; insert mode

    REPLACE_FLAG    0x40,           ;; replace mode flag
    REPLACE      (+ REPLACE_FLAG INSERT),
    VREPLACE_FLAG   0x80,           ;; virtual-replace mode flag
    VREPLACE     (+ REPLACE_FLAG VREPLACE_FLAG INSERT),

    NORMAL_BUSY  (+ 0x100 NORMAL),  ;; normal mode, busy with a command
    HITRETURN    (+ 0x200 NORMAL),  ;; waiting for return or command
    SETWSIZE        0x400,          ;; window size has changed
    SHOWMATCH    (+ 0x700 INSERT),  ;; show matching paren
    SELECTMODE      0x1000)         ;; select mode, only for mappings

;; directions
(final int FORWARD        1)
(final int BACKWARD       -1)

;; Values for 'options' argument in do-search() and searchit().
(final int
    SEARCH_REV          0x01,       ;; go in reverse of previous dir.
    SEARCH_ECHO         0x02,       ;; echo the search command and handle options
    SEARCH_MSG          0x0c,       ;; give messages (yes, it's not 0x04)
    SEARCH_OPT          0x10,       ;; interpret optional flags
    SEARCH_HIST         0x20,       ;; put search pattern in history
    SEARCH_END          0x40,       ;; put cursor at end of match
    SEARCH_NOOF         0x80,       ;; don't add offset to position
    SEARCH_START       0x100,       ;; start search without col offset
    SEARCH_MARK        0x200,       ;; set previous context mark
    SEARCH_KEEP        0x400,       ;; keep previous search pattern
    SEARCH_PEEK        0x800)       ;; peek for typed char, cancel search

;; Values for find-ident-under-cursor().
(final int FIND_IDENT      1)       ;; find identifier (word)
(final int FIND_STRING     2)       ;; find any string (WORD)

;; Values for change-indent().
(final int INDENT_SET      1)       ;; set indent
(final int INDENT_INC      2)       ;; increase indent
(final int INDENT_DEC      3)       ;; decrease indent

;; Values for flags argument for findmatchlimit().
(final int
    FM_BACKWARD         0x01,       ;; search backwards
    FM_FORWARD          0x02,       ;; search forwards
    FM_BLOCKSTOP        0x04)       ;; stop at start/end of block

;; Values for sub_cmd and which_pat argument for search-regcomp().
;; Also used for which_pat argument for searchit().
(final int RE_SEARCH       0)       ;; save/use pat in/from search_pattern
(final int RE_SUBST        1)       ;; save/use pat in/from subst_pattern
(final int RE_BOTH         2)       ;; save pat in both patterns
(final int RE_LAST         2)       ;; use last used pattern if "pat" is null

;; Second argument for vim-regcomp().
(final int RE_MAGIC        1)       ;; 'magic' option
(final int RE_STRING       2)       ;; match in string instead of buffer text
(final int RE_STRICT       4)       ;; don't allow [abc] without ]
(final int RE_AUTO         8)       ;; automatic engine selection

;; flags for do-cmdline()
(final int
    DOCMD_VERBOSE       0x01,       ;; included command in error message
    DOCMD_NOWAIT        0x02,       ;; don't call wait-return() and friends
    DOCMD_KEYTYPED      0x08,       ;; don't reset "key_typed"
    DOCMD_KEEPLINE      0x20)       ;; keep typed line for repeating with "."

;; flags for beginline()
(final int BL_WHITE        1)       ;; cursor on first non-white in the line
(final int BL_SOL          2)       ;; use 'sol' option
(final int BL_FIX          4)       ;; don't leave cursor on a NUL

;; flags for do-put()
(final int
    PUT_FIXINDENT       0x01,       ;; make indent look nice
    PUT_CURSEND         0x02,       ;; leave cursor after end of new text
    PUT_CURSLINE        0x04,       ;; leave cursor on last line of new text
    PUT_LINE            0x08,       ;; put register as lines
    PUT_LINE_SPLIT      0x10,       ;; split line for linewise register
    PUT_LINE_FORWARD    0x20)       ;; put linewise register below Visual sel.

;; flags for set-indent()
(final int SIN_CHANGED     1)       ;; call changed-bytes() when line changed
(final int SIN_INSERT      2)       ;; insert indent before existing text
(final int SIN_UNDO        4)       ;; save line for undo before changing it

;; There are four history tables:

(final int HIST_CMD        0)       ;; colon commands
(final int HIST_SEARCH     1)       ;; search commands
(final int HIST_EXPR       2)       ;; expressions (from entering = register)
(final int HIST_INPUT      3)       ;; input() lines
(final int HIST_COUNT      4)       ;; number of history tables

;; Flags for chartab[].

(final int
    CT_CELL_MASK        0x07,       ;; mask: nr of display cells (1, 2 or 4)
    CT_PRINT_CHAR       0x10,       ;; flag: set for printable chars
    CT_IDENT_CHAR       0x20,       ;; flag: set for ID chars
    CT_FNAME_CHAR       0x40)       ;; flag: set for file name chars

;; arguments for win-split()

(final int
    WSP_VERT            0x02,       ;; split vertically
    WSP_TOP             0x04,       ;; window at top-left of shell
    WSP_BOT             0x08,       ;; window at bottom-right of shell
    WSP_BELOW           0x20,       ;; put new window below/right
    WSP_ABOVE           0x40)       ;; put new window above/left

;; Values for "starting".
(final int NO_SCREEN       2)       ;; no screen updating yet
(final int NO_BUFFERS      1)       ;; not all buffers loaded yet
;;                         0           not starting anymore

;; Values for index in highlight_attr[].

(final int
    HLF_8        0,     ;; meta & special keys listed with ":map", text that is displayed different from what it is
    HLF_AT       1,     ;; @ and ~ characters at end of screen, characters that don't really exist in the text
    HLF_E        2,     ;; error messages
    HLF_I        3,     ;; incremental search
    HLF_L        4,     ;; last search string
    HLF_M        5,     ;; "--More--" message
    HLF_CM       6,     ;; mode (e.g. "-- INSERT --")
    HLF_N        7,     ;; line number for ":number" and ":#" commands
    HLF_CLN      8,     ;; current line number
    HLF_R        9,     ;; return to continue message and yes/no questions
    HLF_S       10,     ;; status lines
    HLF_SNC     11,     ;; status lines of not-current windows
    HLF_C       12,     ;; column to separate vertically split windows
    HLF_T       13,     ;; titles for output from ":set all", etc.
    HLF_V       14,     ;; Visual mode
    HLF_W       15,     ;; warning messages
    HLF_CUC     16,     ;; 'cursorcolumn'
    HLF_CUL     17,     ;; 'cursorline'
    HLF_MC      18,     ;; 'colorcolumn'

    HLF_COUNT   19)     ;; MUST be the last one

;; Operator IDs; The order must correspond to opchars[] in ops.c!

(final int
    OP_NOP       0,     ;; no pending operation
    OP_DELETE    1,     ;; "d"  delete operator
    OP_YANK      2,     ;; "y"  yank operator
    OP_CHANGE    3,     ;; "c"  change operator
    OP_LSHIFT    4,     ;; "<"  left shift operator
    OP_RSHIFT    5,     ;; ">"  right shift operator
    OP_FILTER    6,     ;; "!"  filter operator
    OP_TILDE     7,     ;; "g~" switch case operator
    OP_INDENT    8,     ;; "="  indent operator
    OP_FORMAT    9,     ;; "gq" format operator
    OP_COLON    10,     ;; ":"  colon operator
    OP_UPPER    11,     ;; "gU" make upper case operator
    OP_LOWER    12,     ;; "gu" make lower case operator
    OP_JOIN     13,     ;; "J"  join operator, only for Visual mode
    OP_JOIN_NS  14,     ;; "gJ"  join operator, only for Visual mode
    OP_ROT13    15,     ;; "g?" rot-13 encoding
    OP_REPLACE  16,     ;; "r"  replace chars, only for Visual mode
    OP_INSERT   17,     ;; "I"  Insert column, only for Visual mode
    OP_APPEND   18,     ;; "A"  Append column, only for Visual mode
    OP_FORMAT2  19,     ;; "gw" format operator, keeps cursor pos
    OP_FUNCTION 20)     ;; "g@" call 'operatorfunc'

;; Motion types, used for operators and for yank/delete registers.

(final byte!
    MCHAR   0,          ;; character-wise movement/register
    MLINE   1,          ;; line-wise movement/register
    MBLOCK  2,          ;; block-wise register
    MAUTO   0xff)       ;; decide between MLINE/MCHAR

;; Minimum screen size.

(final int MIN_COLS       12)           ;; minimal columns for screen
(final int MIN_ROWS        2)           ;; minimal lines for screen
(final int STATUS_HEIGHT   1)           ;; height of a status line under a window

(final int IOSIZE          (inc 1024))  ;; file i/o and sprintf buffer size
(final int MAXPATHL         4096)

(final int
    MSG_BUF_LEN     480,                ;; length of buffer for small messages
    MSG_BUF_CLEN    (/ MSG_BUF_LEN 6))  ;; cell length (worst case: utf-8 takes 6 bytes for one cell)

;; Maximum length of key sequence to be mapped.

(final int MAXMAPLEN 50)

(final long MAXLNUM 0x7fffffff)      ;; maximum (invalid) line number
(final int MAXCOL 0x7fffffff)           ;; maximum column number, 31 bits

(final int SHOWCMD_COLS 10)             ;; columns needed by shown command

;; vim-iswhite() is used for "^" and the like.  It differs from isspace()
;; because it doesn't include <CR> and <LF> and the like.

(defn- #_boolean vim-iswhite [#_int x]
    (any == x (byte \space) TAB))

(final int MAX_MCO        6)        ;; maximum value for 'maxcombine'

;; Maximum number of bytes in a multi-byte character.  It can be one 32-bit
;; character of up to 6 bytes, or one 16-bit character of up to three bytes
;; plus six following composing characters of three bytes each.

(final int MB_MAXBYTES    21)

;;; ============================================================================================== VimD

;; option.h: definition of global variables for settable options

;; characters for the "p_cpo" option:
(final byte
    CPO_SEARCH      \c,
    CPO_DIGRAPH     \D,  ;; no digraph after "r", "f", etc.
    CPO_EMPTYREGION \E,  ;; operating on empty region is an error
    CPO_INSEND      \H,  ;; "I" inserts before last blank in line
    CPO_INDENT      \I,  ;; remove auto-indent more often
    CPO_JOINSP      \j,  ;; only use two spaces for join after '.'
    CPO_LITERAL     \l,  ;; take char after backslash in [] literal
    CPO_SHOWMATCH   \m,
    CPO_MATCHBSL    \M,  ;; "%" ignores use of backslashes
    CPO_NUMCOL      \n,  ;; 'number' column also used for text
    CPO_LINEOFF     \o,
    CPO_JOINCOL     \q,  ;; with "3J" use column after first join
    CPO_REDO        \r,
    CPO_UNDO        \u,  ;; "u" undoes itself
    CPO_CW          \w,  ;; "cw" only changes one blank
    CPO_ESC         \x,
    CPO_REPLCNT     \X,  ;; "R" with a count only deletes chars once
    CPO_YANK        \y,
    CPO_FILTER      \!,
    CPO_MATCH       \%,
    CPO_MINUS       \-,  ;; "9-" fails at and before line 9
    CPO_REGAPPEND   \>,  ;; insert NL when appending to a register
;; POSIX flags
    CPO_HASH        \#,  ;; "D", "o" and "O" do not use a count
    CPO_SUBPERCENT  \/,  ;; % in :s string uses previous one
    CPO_BACKSL      \\,  ;; \ is not special in []
    CPO_SCOLON      \;)  ;; using "," and ";" will skip over char if cursor would not move

;; default values for Vim, Vi and POSIX
(final Bytes CPO_VIM  (u8 "c"))
(final Bytes CPO_ALL  (u8 "cDEHIjlmMnoqruwxXy!%->#/\\;"))

;; characters for "p_ww" option:
(final Bytes WW_ALL   (u8 "bshl<>[],~"))

;; arguments for can-bs()
(final byte BS_INDENT     \i)      ;; "Indent"
(final byte BS_EOL        \o)      ;; "eOl"
(final byte BS_START      \s)      ;; "Start"

;; The following are actual variables for the options:

(atom! Bytes   p_bs)        ;; 'backspace'
(atom! Bytes   p_breakat)   ;; 'breakat'
(atom! long    p_ch)        ;; 'cmdheight'
(atom! long    p_cwh)       ;; 'cmdwinheight'
(atom! Bytes   p_cpo)       ;; 'cpoptions'
(atom! boolean p_deco)      ;; 'delcombine'
(atom! boolean p_dg)        ;; 'digraph'
(atom! Bytes   p_dy)        ;; 'display'

(final int
    DY_LASTLINE 0x001,
    DY_UHEX     0x002)
(atom! int    dy_flags)
(final Bytes* p_dy_values [ (u8 "lastline"), (u8 "uhex"), nil ])

(atom! Bytes   p_ead)       ;; 'eadirection'
(atom! boolean p_ea)        ;; 'equalalways'
(atom! boolean p_eb)        ;; 'errorbells'
(atom! boolean p_ek)        ;; 'esckeys'
(atom! boolean p_gd)        ;; 'gdefault'
(atom! long    p_hi)        ;; 'history'
(atom! boolean p_hls)       ;; 'hlsearch'
(atom! boolean p_ic)        ;; 'ignorecase'
(atom! boolean p_is)        ;; 'incsearch'
(atom! boolean p_im)        ;; 'insertmode'
(atom! Bytes   p_isf)       ;; 'isfname'
(atom! Bytes   p_isi)       ;; 'isident'
(atom! Bytes   p_isp)       ;; 'isprint'
(atom! boolean p_js)        ;; 'joinspaces'
(atom! Bytes   p_km)        ;; 'keymodel'
(atom! long    p_ls)        ;; 'laststatus'
(atom! boolean p_lz)        ;; 'lazyredraw'
(atom! boolean p_magic)     ;; 'magic'
(atom! long    p_mat)       ;; 'matchtime'
(atom! long    p_mco)       ;; 'maxcombine'
(atom! long    p_mmp)       ;; 'maxmempattern'
(atom! Bytes   p_opfunc)    ;; 'operatorfunc'
(atom! boolean p_paste)     ;; 'paste'
(atom! boolean p_prompt)    ;; 'prompt'
(atom! long    p_rdt)       ;; 'redrawtime'
(atom! long    p_re)        ;; 'regexpengine'
(atom! long    p_report)    ;; 'report'
(atom! boolean p_ru)        ;; 'ruler'
(atom! long    p_sj)        ;; 'scrolljump'
(atom! long    p_so)        ;; 'scrolloff'
(atom! Bytes   p_sel)       ;; 'selection'
(atom! Bytes   p_slm)       ;; 'selectmode'
(atom! boolean p_sr)        ;; 'shiftround'
(atom! Bytes   p_sbr)       ;; 'showbreak'
(atom! boolean p_sc)        ;; 'showcmd'
(atom! boolean p_sm)        ;; 'showmatch'
(atom! boolean p_smd)       ;; 'showmode'
(atom! long    p_ss)        ;; 'sidescroll'
(atom! long    p_siso)      ;; 'sidescrolloff'
(atom! boolean p_scs)       ;; 'smartcase'
(atom! boolean p_sta)       ;; 'smarttab'
(atom! boolean p_sb)        ;; 'splitbelow'
(atom! boolean p_spr)       ;; 'splitright'
(atom! boolean p_sol)       ;; 'startofline'
(atom! boolean p_to)        ;; 'tildeop'
(atom! boolean p_timeout)   ;; 'timeout'
(atom! long    p_tm)        ;; 'timeoutlen'
(atom! boolean p_ttimeout)  ;; 'ttimeout'
(atom! long    p_ttm)       ;; 'ttimeoutlen'
(atom! long    p_ttyscroll) ;; 'ttyscroll'
(atom! long    p_ut)        ;; 'updatetime'
(atom! long    p_verbose)   ;; 'verbose'
(atom! Bytes   p_ve)        ;; 'virtualedit'

(final int
    VE_BLOCK   5,       ;; includes "all"
    VE_INSERT  6,       ;; includes "all"
    VE_ALL     4,
    VE_ONEMORE 8)
(atom! int    ve_flags)
(final Bytes* p_ve_values [ (u8 "block"), (u8 "insert"), (u8 "all"), (u8 "onemore"), nil ])

(atom! boolean p_vb)        ;; 'visualbell'
(atom! Bytes   p_ww)        ;; 'whichwrap'
(atom! long    p_wh)        ;; 'winheight'
(atom! long    p_wmh)       ;; 'winminheight'
(atom! long    p_wmw)       ;; 'winminwidth'
(atom! long    p_wiw)       ;; 'winwidth'
(atom! boolean p_ws)        ;; 'wrapscan'
(atom! long    p_wd)        ;; 'writedelay'

;; "indir" values for buffer-local opions.

(final int
    BV_AI     0,
    BV_CI     5,
    BV_CINW   9,
    BV_ET    14,
    BV_ISK   26,
    BV_KP    27,
    BV_MOD   31,
    BV_MPS   32,
    BV_NF    33,
    BV_PI    34,
    BV_QE    35,
    BV_SI    37,
    BV_STS   40,
    BV_SW    41,
    BV_TS    42,
    BV_UL    46)

;; "indir" values for window-local options.

(final int
    WV_BRI     4,
    WV_BRIOPT  5,
    WV_LBR     6,
    WV_NU      7,
    WV_RNU     8,
    WV_NUW     9,
    WV_SCROLL 13,
    WV_CUC    14,
    WV_CUL    15,
    WV_CC     16,
    WV_WFH    18,
    WV_WFW    19,
    WV_WRAP   20)

;; ----------------------------------------------------------------------- ;;

;; position in file or buffer

(class! #_final pos_C
    [
        (field long     lnum)       ;; line number
        (field int      col)        ;; column number
        (field int      coladd)
    ])

(defn- #_pos_C* ARRAY-pos [#_int n]
    (vec (repeatedly n NEW_pos_C)))

;; Same, but without coladd.

(class! #_final lpos_C
    [
        (field long     lnum)       ;; line number
        (field int      col)        ;; column number
    ])

(final lpos_C LPOS-1 (lpos_C. -1 -1))

(defn- #_lpos_C* ARRAY-lpos [#_int n]
    (vec (repeatedly n NEW_lpos_C)))

;; ----------------------------------------------------------------------- ;;

;; The number of sub-matches is limited to 10.
;; The first one (index 0) is the whole match, referenced with "\0".
;; The second one (index 1) is the first sub-match, referenced with "\1".
;; This goes up to the tenth (index 9), referenced with "\9".

(final int NSUBEXP  10)

;; In the NFA engine: how many states are allowed.

(final int NFA_MAX_STATES 100000)
(final int NFA_TOO_EXPENSIVE -1)

;; Which regexp engine to use?  Needed for vim-regcomp().
;; Must match with 'regexpengine'.

(final int
    AUTOMATIC_ENGINE    0,
    BACKTRACKING_ENGINE 1,
    NFA_ENGINE          2)

;; Structure used by the backtrack matcher.
;; These fields are only to be used in regexp.c!
;; See regexp.c for an explanation.

(class! #_final bt_pattern_C ;; extends pattern_C
    [
        (field re_func_F    regexec)
        (field int          regflags)
        (field int          re_engine)  ;; automatic, backtracking or nfa engine
        (field int          re_flags)   ;; second argument for vim-regcomp()

        (field boolean      reganch)
        (field int          regstart)
        (field Bytes        regmust)
        (field int          regmlen)
        (field Bytes        program)
    ])

;; Structure representing a NFA state.
;; A NFA state may have no outgoing edge, when it is a NFA_MATCH state.

(class! #_final nfa_state_C
    [
        (field int          c)
        (atom' nfa_state_C  out0)
        (atom' nfa_state_C  out1)
        (field int          id)
        (field int          val)
    ])

(defn- #_nfa_state_C out0 [#_nfa_state_C state] @(:out0 state))
(defn- #_nfa_state_C out1 [#_nfa_state_C state] @(:out1 state))

(defn- #_void out0! [#_nfa_state_C state, #_nfa_state_C out0] (reset! (:out0 state) out0) nil)
(defn- #_void out1! [#_nfa_state_C state, #_nfa_state_C out1] (reset! (:out1 state) out1) nil)

;; Structure used by the NFA matcher.

(class! #_final nfa_pattern_C ;; extends pattern_C
    [
        (field re_func_F    regexec)
        (field int          regflags)
        (field int          re_engine)      ;; automatic, backtracking or nfa engine
        (field int          re_flags)       ;; second argument for vim-regcomp()

        (field nfa_state_C* states)
        (field nfa_state_C  start)          ;; points into "states"

        (field boolean      reganch)        ;; pattern starts with ^
        (field int          regstart)       ;; char at start of pattern
        (field Bytes        match_text)     ;; plain text to match with

        (field boolean      has_zend)       ;; pattern contains \ze
        (field boolean      has_backref)    ;; pattern contains \1 .. \9
        (field Bytes        rex)
    ])

;; Structure to be used for multi-line matching.
;; Sub-match "i" starts in line "m_startpos[i].lnum" column "m_startpos[i].col" and ends in line "m_endpos[i].lnum" just before column "m_endpos[i].col".
;; The line numbers are relative to the first line, thus "m_startpos[0].lnum" is always 0.
;; When there is no match, the line number is -1.

(class! #_final matcher_C
    [
        (field pattern_C    m_pattern)
        (field lpos_C*      m_startpos      (ARRAY-lpos NSUBEXP))
        (field lpos_C*      m_endpos        (ARRAY-lpos NSUBEXP))
        (field boolean      m_icase)
        (field int          m_maxcol)   ;; when not zero: maximum column
    ])

;; ----------------------------------------------------------------------- ;;

;; marks: positions in a file
;; (a normal mark is a lnum/col pair, the same as a file position)

(final int NMARKS (inc (- (int \z) (int \a))))  ;; max. # of named marks
(final int JUMPLISTSIZE 100)        ;; max. # of marks in jump list

;; When a string option is null (which only happens in out-of-memory situations),
;; it is set to EMPTY_OPTION to avoid having to check for null everywhere.

(final Bytes EMPTY_OPTION (u8 ""))

;; Structure that contains all options that are local to a window.
;; Used twice in a window: for the current buffer and for all buffers.

(class! #_final winopt_C
    [
        (atom' boolean wo_bri)                 ;; 'breakindent'
        (atom' Bytes   wo_briopt EMPTY_OPTION) ;; 'breakindentopt'
        (atom' Bytes   wo_cc     EMPTY_OPTION) ;; 'colorcolumn'
        (atom' boolean wo_cuc)                 ;; 'cursorcolumn'
        (atom' boolean wo_cul)                 ;; 'cursorline'
        (atom' boolean wo_lbr)                 ;; 'linebreak'
        (atom' boolean wo_nu)                  ;; 'number'
        (atom' long    wo_nuw)                 ;; 'numberwidth'
        (atom' boolean wo_rnu)                 ;; 'relativenumber'
        (atom' long    wo_scr)                 ;; 'scroll'
        (atom' boolean wo_wfh)                 ;; 'winfixheight'
        (atom' boolean wo_wfw)                 ;; 'winfixwidth'
        (atom' boolean wo_wrap)                ;; 'wrap'
    ])

;; Structure to store info about the Visual area.

(class! #_final visualinfo_C
    [
        (field pos_C        vi_start    (NEW_pos_C))      ;; start pos of last VIsual
        (field pos_C        vi_end      (NEW_pos_C))      ;; end position of last VIsual
        (field int          vi_mode)                    ;; VIsual_mode of last VIsual
        (field int          vi_curswant)                ;; MAXCOL from "w_curswant"
    ])

;; Structures used for undo.

(class! #_final u_entry_C
    [
        (field long         ue_top)         ;; number of line above undo block
        (field long         ue_bot)         ;; number of line below undo block
        (field long         ue_lcount)      ;; line count when u-save() called
        (field Bytes*       ue_array)       ;; array of lines in undo block
        (field long         ue_size)        ;; number of lines in "ue_array"
    ])

(class! #_final u_header_C
    [
        (field long         uh_seq)         ;; sequence number, higher == newer undo
        (field u_entry_C*   uh_entries)     ;; pointer to first entry
        (field u_entry_C    uh_getbot)      ;; pointer to where "ue_bot" must be set
        (field pos_C        uh_cursor)      ;; cursor position before saving
        (field long         uh_vcol)
        (field int          uh_flags)       ;; see below
        (field pos_C*       uh_namedm)      ;; marks before undo/after redo
        (field visualinfo_C uh_visual)      ;; Visual areas before undo/after redo
        (field long         uh_time)        ;; timestamp when the change was made
    ])

;; values for "uh_flags"
(final int UH_CHANGED  0x01)            ;; "b_changed" flag before undo/after redo
(final int UH_EMPTYBUF 0x02)            ;; buffer was empty

;; The memline structure holds all the information about a memline.

(class! #_final memline_C
    [
        (field long         ml_line_count)      ;; number of lines in the buffer
        (field boolean      ml_empty)
    ])

;; Used for the typeahead buffer: typebuf.

(class! #_final typebuf_C
    [
        (field Bytes        tb_buf)             ;; buffer for typed characters
        (field int          tb_buflen)          ;; size of "tb_buf"
        (field int          tb_off)             ;; current position in "tb_buf"
        (field int          tb_len)             ;; number of valid bytes in "tb_buf"
        (field int          tb_change_cnt)      ;; nr of time "tb_buf" was changed; never zero
    ])

;; buffer: structure that holds information about one file
;;
;; Several windows can share a single Buffer.

(class! #_final buffer_C
    [
        (field memline_C    b_ml                (ml-open))      ;; associated memline (also contains line count)

        (field int          b_nwindows)         ;; nr of windows open on this buffer

        (atom' boolean      b_changed)          ;; 'modified'
        (field int          b_changedtick)      ;; incremented for each change, also for undo

        ;; Changes to a buffer require updating of the display.
        ;; To minimize the work, remember changes made and update everything at once.

        (field boolean      b_mod_set)          ;; true when there are changes since the last time the display was updated
        (field long         b_mod_top)          ;; topmost lnum that was changed
        (field long         b_mod_bot)          ;; lnum below last changed line, AFTER the change
        (field long         b_mod_xlines)       ;; number of extra buffer lines inserted; negative when lines were deleted

        (field pos_C*       b_namedm            (ARRAY-pos NMARKS))     ;; current named marks (mark.c)

        ;; These variables are set when VIsual_active becomes false.

        (field visualinfo_C b_visual            (NEW_visualinfo_C))

        (field pos_C        b_last_cursor       (NEW_pos_C))    ;; cursor position when last unloading this buffer
        (field pos_C        b_last_insert       (NEW_pos_C))    ;; where Insert mode was left
        (field pos_C        b_last_change       (NEW_pos_C))    ;; position of last change: '. mark

        ;; the changelist contains old change positions

        (field pos_C*       b_changelist        (ARRAY-pos JUMPLISTSIZE))
        (field int          b_changelistlen)    ;; number of active entries
        (field boolean      b_new_change)       ;; set by u-savecommon()

        ;; Character table, only used in charset.c for 'iskeyword'.
        ;; 8 bytes of 32 bits: 1 bit per character 0-255.

        (field int*         b_chartab           8)

        ;; start and end of an operator, also used for '[ and ']

        (field pos_C        b_op_start          (NEW_pos_C))
        (field pos_C        b_op_start_orig     (NEW_pos_C))    ;; used for "insStart_orig"
        (field pos_C        b_op_end            (NEW_pos_C))

        ;; the following is only used in undo.c

        (field u_header_C*  b_u_headers         [])
        (field int          b_u_current)
        (field boolean      b_u_synced)         ;; entry lists are synced
        (field long         b_u_seq_last)       ;; last used undo sequence number

        ;; variables for "U" command in undo.c

        (field Bytes        b_u_line_ptr)       ;; saved line for "U" command
        (field long         b_u_line_lnum)      ;; line number of line in u_line
        (field int          b_u_line_colnr)     ;; optional column number

        ;; Options local to a buffer.
        ;; They are here because their value depends on the type of file
        ;; or contents of the file being edited.

        (atom' boolean      b_p_ai)                     ;; 'autoindent'
        (field boolean      b_p_ai_nopaste)             ;; "b_p_ai" saved for paste mode
        (atom' boolean      b_p_ci)                     ;; 'copyindent'
        (atom' Bytes        b_p_cinw    EMPTY_OPTION)   ;; 'cinwords'
        (atom' boolean      b_p_et)                     ;; 'expandtab'
        (atom' Bytes        b_p_isk     EMPTY_OPTION)   ;; 'iskeyword'
        (atom' Bytes        b_p_kp      EMPTY_OPTION)   ;; 'keywordprg'
        (atom' Bytes        b_p_mps     EMPTY_OPTION)   ;; 'matchpairs'
        (atom' Bytes        b_p_nf      EMPTY_OPTION)   ;; 'nrformats'
        (atom' boolean      b_p_pi)                     ;; 'preserveindent'
        (atom' Bytes        b_p_qe      EMPTY_OPTION)   ;; 'quoteescape'
        (atom' boolean      b_p_si)                     ;; 'smartindent'
        (atom' long         b_p_sts)                    ;; 'softtabstop'
        (field long         b_p_sts_nopaste)            ;; "b_p_sts" saved for paste mode
        (atom' long         b_p_sw)                     ;; 'shiftwidth'
        (atom' long         b_p_ts)                     ;; 'tabstop'
        (atom' long         b_p_ul)                     ;; 'undolevels'
    ])

(atom! long         ch_used)         ;; value of 'cmdheight' when frame size was set

;; Structure to cache info for displayed lines in w_lines[].
;; Each logical line has one entry.
;; The entry tells how the logical line is currently displayed in the window.
;; This is updated when displaying the window.
;; When the display is changed (e.g., when clearing the screen) "w_lines_valid"
;; is changed to exclude invalid entries.
;; When making changes to the buffer, wl_valid is reset to indicate wl_size
;; may not reflect what is actually in the buffer.  When wl_valid is false,
;; the entries can only be used to count the number of displayed lines used.
;; wl_lnum and wl_lastlnum are invalid too.

(class! #_final wline_C
    [
        (field long         wl_lnum)        ;; buffer line number for logical line
        (field int          wl_size)        ;; height in screen lines
        (field boolean      wl_valid)       ;; true values are valid for text in buffer
    ])

(defn- #_wline_C* ARRAY-wline [#_int n]
    (vec (repeatedly n NEW_wline_C)))

;; Windows are kept in a tree of frames.  Each frame has a column (FR_COL)
;; or row (FR_ROW) layout or is a leaf, which has a window.

(class! #_final frame_C
    [
        (field byte         fr_layout)      ;; FR_LEAF, FR_COL or FR_ROW
        (field int          fr_width)
        (field int          fr_newwidth)    ;; new width used in win-equal-rec()
        (field int          fr_height)
        (field int          fr_newheight)   ;; new height used in win-equal-rec()
        (field frame_C      fr_parent)      ;; containing frame or null
        (field frame_C      fr_next)        ;; frame right or below in same parent, null for first
        (field frame_C      fr_prev)        ;; frame left or above in same parent, null for last
                                            ;; fr_child and fr_win are mutually exclusive
        (field frame_C      fr_child)       ;; first contained frame
        (field window_C     fr_win)         ;; window that fills this frame
    ])

(final byte
    FR_LEAF 0,            ;; frame is a leaf
    FR_ROW  1,            ;; frame with a row of windows
    FR_COL  2)            ;; frame with a column of windows

;; Struct used for highlighting 'hlsearch' matches, matches defined by ":match" and
;; matches defined by match functions.  For 'hlsearch' there is one pattern for all windows.
;; For ":match" and the match functions there is a different pattern for each window.

(class! #_final match_C
    [
        (field matcher_C    matcher (NEW_matcher_C))    ;; points to the regexp program; contains last found match (may continue in next line)
        (field long         lnum)                       ;; the line to search for a match
        (field int          attr)                       ;; attributes to be used for a match
        (field int          attr_cur)                   ;; attributes currently active in win-line()
        (field long         first_lnum)                 ;; first lnum to search for multi-line pat
        (field int          startcol)                   ;; in win-line() points to char where HL starts
        (field int          endcol)                     ;; in win-line() points to char where HL ends
        (field long         nsec)                       ;; for a time limit
    ])

;; Structure which contains all information that belongs to a window
;;
;; All row numbers are relative to the start of the window, except "w_winrow".

(class! #_final window_C
    [
        (field window_C     w_prev)             ;; link to previous window
        (field window_C     w_next)             ;; link to next window

        (field frame_C      w_frame)            ;; frame containing this window

        (field boolean      w_focused)          ;; ~ "curwin"
        (field pos_C        w_cursor            (pos_C. 1 0 0)) ;; cursor position in buffer
        (field int          w_curswant)         ;; column we'd like to be at: used to try to stay in the same column for up/down cursor motions
        (field boolean      w_set_curswant)     ;; if set, update "w_curswant" the next time through cursupdate() to the current virtual column

        ;; the next six are used to update the visual part

        (field int          w_old_visual_mode)  ;; last known VIsual_mode
        (field long         w_old_cursor_lnum)  ;; last known end of visual part
        (field int          w_old_cursor_fcol)  ;; first column for block visual part
        (field int          w_old_cursor_lcol)  ;; last column for block visual part
        (field long         w_old_visual_lnum)  ;; last known start of visual part
        (field int          w_old_visual_col)   ;; last known start of visual part
        (field int          w_old_curswant)     ;; last known value of curswant

        ;; "w_topline", "w_leftcol" and "w_skipcol" specify the offsets for displaying the buffer.

        (field long         w_topline       1)  ;; buffer line number of the line at the top of the window
        (field int          w_leftcol)          ;; window column of the leftmost character in the window; used when 'wrap' is off
        (field int          w_skipcol)          ;; starting column when a single line doesn't fit in the window

        ;; Layout of the window in the screen.
        ;; May need to add "msg_scrolled" to "w_winrow" in rare situations.

        (field int          w_winrow)           ;; first row of window in screen
        (field int          w_height)           ;; number of rows in window, excluding status/command line(s)
        (field int          w_status_height)    ;; number of status lines (0 or 1)
        (field int          w_wincol)           ;; leftmost column of window in screen
        (field int          w_width)            ;; width of window, excluding separation
        (field int          w_vsep_width)       ;; number of separator columns (0 or 1)

        ;; === start of cached values ====

        ;; Recomputing is minimized by storing the result of computations.
        ;; Use functions in screen.c to check if they are valid and to update.
        ;; "w_valid" is a bitfield of flags, which indicate if specific values are
        ;; valid or need to be recomputed.  See screen.c for values.

        (field int          w_valid)
        (field pos_C        w_valid_cursor      (NEW_pos_C))  ;; last known position of "w_cursor", used to adjust "w_valid"
        (field int          w_valid_leftcol)    ;; last known "w_leftcol"

        ;; "w_cline_height" is the number of physical lines taken by the buffer line
        ;; that the cursor is on.  We use this to avoid extra calls to plines().

        (field int          w_cline_height)     ;; current size of cursor line
        (field int          w_cline_row)        ;; starting row of the cursor line

        (field int          w_virtcol)          ;; Column number of the cursor in the buffer line,
                                                ;; as opposed to the column number we're at on the screen.
                                                ;; This makes a difference on lines which span more than
                                                ;; one screen line or when "w_leftcol" is non-zero.

        ;; "w_wrow" and "w_wcol" specify the cursor position in the window.
        ;; This is related to positions in the window, not in the display
        ;; or buffer, thus "w_wrow" is relative to "w_winrow".

        (field int          w_wrow)
        (field int          w_wcol)

        (field long         w_botline       2)  ;; number of the line below the bottom of the screen
        (field int          w_empty_rows)       ;; number of ~ rows in window

        ;; Info about the lines currently in the window is remembered to avoid
        ;; recomputing it every time.  The allocated size of w_lines[] is Rows.
        ;; Only the "w_lines_valid" entries are actually valid.
        ;; When the display is up-to-date w_lines[0].wl_lnum is equal to "w_topline"
        ;; and w_lines[w_lines_valid - 1].wl_lnum is equal to "w_botline".
        ;; Between changing text and updating the display w_lines[] represents
        ;; what is currently displayed.  wl_valid is reset to indicated this.
        ;; This is used for efficient redrawing.

        (field int          w_lines_valid)      ;; number of valid entries
        (field wline_C*     w_lines)

        (field int          w_nrwidth)          ;; width of 'number' and 'relativenumber' column being used

        ;; === end of cached values ===

        (field int          w_redr_type)        ;; type of redraw to be performed on win
        (field int          w_upd_rows)         ;; number of window lines to update when "w_redr_type" is REDRAW_TOP
        (field long         w_redraw_top)       ;; when != 0: first line needing redraw
        (field long         w_redraw_bot)       ;; when != 0: last line needing redraw
        (field boolean      w_redr_status)      ;; if true status line must be redrawn

        ;; remember what is shown in the ruler for this window (if 'ruler' set)
        (field pos_C        w_ru_cursor         (NEW_pos_C))  ;; cursor position shown in ruler
        (field int          w_ru_virtcol)       ;; virtcol shown in ruler
        (field long         w_ru_topline)       ;; topline shown in ruler
        (field long         w_ru_line_count)    ;; line count used for ruler
        (field boolean      w_ru_empty)         ;; true if ruler shows 0-1 (empty line)

        ;; Options local to a window.
        ;; They are local because they influence the layout of the window or depend on the window layout.

        (field winopt_C     w_options    (NEW_winopt_C))

        (field int*         w_p_cc_cols)        ;; array of columns to highlight or null
        (field int          w_p_brimin)         ;; minimum width for breakindent
        (field int          w_p_brishift)       ;; additional shift for breakindent
        (field boolean      w_p_brisbr)         ;; sbr in 'briopt'

        ;; "w_prev_pcmark" is used to check whether we really did jump to a new line after setting "w_pcmark".
        ;; If not, we revert to using the previous "w_pcmark".

        (field pos_C        w_pcmark            (pos_C. 1 0 0)) ;; previous context mark
        (field pos_C        w_prev_pcmark       (NEW_pos_C))  ;; previous "w_pcmark"

        ;; the jumplist contains old cursor positions

        (field pos_C*       w_jumplist          (ARRAY-pos JUMPLISTSIZE))
        (field int          w_jumplistlen)      ;; number of active entries
        (field int          w_jumplistidx)      ;; current position

        (field int          w_changelistidx)    ;; current position in b_changelist

        ;; "w_fraction" is the fractional row of the cursor within the window,
        ;; from 0 at the top row to FRACTION_MULT at the last row.
        ;; "w_prev_fraction_row" was the actual cursor row when "w_fraction" was last calculated.

        (field int          w_fraction)
        (field int          w_prev_fraction_row)

        (field long         w_nrwidth_line_count)   ;; line count when ml_nrwidth_width was computed
        (field long         w_nuw_cached)           ;; 'numberwidth' option cached
        (field int          w_nrwidth_width)        ;; nr of chars to print line count
    ])

;; Arguments for operators.

(class! #_final oparg_C
    [
        (field int          op_type)            ;; current pending operator type
        (field int          regname)            ;; register to use for the operator
        (field byte         motion_type)        ;; type of the current cursor motion
        (field int          motion_force)       ;; force motion type: 'v', 'V' or CTRL-V
        (field boolean      use_reg_one)        ;; true if delete uses reg 1 even when not linewise
        (field boolean      inclusive)          ;; true if char motion is inclusive (only valid when motion_type is MCHAR)
        (field boolean      end_adjusted)       ;; backuped b_op_end one char (only used by do_format())
        (field pos_C        op_start        (NEW_pos_C))  ;; start of the operator
        (field pos_C        op_end          (NEW_pos_C))  ;; end of the operator
        (field pos_C        cursor_start    (NEW_pos_C))  ;; cursor position before motion for "gw"
        (field long         line_count)         ;; number of lines from op_start to op_end (inclusive)
        (field boolean      empty)              ;; op_start and op_end the same (only used by do_change())
        (field boolean      is_VIsual)          ;; operator on Visual area
        (field boolean      block_mode)         ;; current operator is Visual block mode
        (field int          start_vcol)         ;; start col for block mode operator
        (field int          end_vcol)           ;; end col for block mode operator
        (field long         prev_opcount)       ;; ca.opcount saved for K_CURSORHOLD
        (field long         prev_count0)        ;; ca.count0 saved for K_CURSORHOLD
    ])

;; Arguments for Normal mode commands.

(class! #_final cmdarg_C
    [
        (field oparg_C      oap)                ;; operator arguments
        (field int          prechar)            ;; prefix character (optional, always 'g')
        (field int          cmdchar)            ;; command character
        (field int          nchar)              ;; next command character (optional)
        (field int          ncharC1)            ;; first composing character (optional)
        (field int          ncharC2)            ;; second composing character (optional)
        (field int          extra_char)         ;; yet another character (optional)
        (field long         opcount)            ;; count before an operator
        (field long         count0)             ;; count before command, default 0
        (field long         count1)             ;; count before command, default 1
        (field int          arg)                ;; extra argument from nv_cmds[]
        (field int          retval)             ;; return: CA_* values
        (field Bytes        searchbuf)          ;; return: pointer to search pattern or null
    ])

;; values for retval:
(final int CA_COMMAND_BUSY  1)  ;; skip restarting edit() once
(final int CA_NO_ADJ_OP_END 2)  ;; don't adjust operator end

;;; ============================================================================================== VimE

;; ex_cmds.h --------------------------------------------------------------------------------------

(final int
    RANGE           0x001,   ;; allow a linespecs
    BANG            0x002,   ;; allow a ! after the command name
    EXTRA           0x004,   ;; allow extra args after command name
    NOSPC           0x010,   ;; no spaces allowed in the extra part
    DFLALL          0x020,   ;; default file range is 1,$
    NEEDARG         0x080,   ;; argument required
    COUNT           0x400,   ;; allow count in argument, after command
    ZEROR          0x1000,   ;; zero line number allowed
    NOTADR         0x4000,   ;; number before command is not an address
    CMDWIN       0x100000,   ;; allowed in cmdline window

    WORD1 (| EXTRA NOSPC))   ;; one extra word allowed

;; values for cmd_addr_type
(final byte
    ADDR_LINES          0,
    ADDR_WINDOWS        1)

(final int
    CMD_close 0,
    CMD_fixdel 1,
    CMD_only 2,
    CMD_retab 3,
    CMD_substitute 4,
    CMD_set 5,
    CMD_stop 6,
    CMD_suspend 7,

    CMD_SIZE 8)     ;; MUST be after all real commands!

;; Arguments used for Ex commands.

(class! #_final exarg_C
    [
        (field Bytes        arg)            ;; argument of the command
        (field Bytes        cmd)            ;; the name of the command (except for :make)
        (field int          cmdidx)         ;; the index for the command
        (field long         argt)           ;; flags for the command
        (field boolean      skip)           ;; don't execute the command, only parse it
        (field boolean      forceit)        ;; true if ! present
        (field int          addr_count)     ;; the number of addresses given
        (field long         line1)          ;; the first line number
        (field long         line2)          ;; the second line number or count
        (field int          addr_type)      ;; type of the count/range
        (field int          regname)        ;; register name (NUL if none)
        (field Bytes        errmsg)         ;; returned error message
    ])

;; ----------------------------------------------------------------------- ;;

(defn- #_boolean asc-islower [#_int c] (<= (byte \a) c (byte \z)))
(defn- #_boolean asc-isupper [#_int c] (<= (byte \A) c (byte \Z)))
(defn- #_boolean asc-isalpha [#_int c] (or (asc-isupper c) (asc-islower c)))
(defn- #_boolean asc-isalnum [#_int c] (or (asc-isalpha c) (asc-isdigit c)))
(defn- #_boolean asc-iscntrl [#_int c] (or (<= 0x00 c 0x1f) (== c 0x7f)))
(defn- #_boolean asc-isgraph [#_int c] (<= 0x21 c 0x7e))
(defn- #_boolean asc-isprint [#_int c] (<= 0x20 c 0x7e))
(defn- #_boolean asc-ispunct [#_int c] (or (<= 0x21 c 0x2f) (<= 0x3a c 0x40) (<= 0x5b c 0x60) (<= 0x7b c 0x7e)))

;;; ============================================================================================== VimF

;; #include "globals.h"             ;; global variables and messages

;; Number of Rows and Cols in the screen.
;; Must be long to be able to use them as options in option.c.
;; Note: Use screenRows and screenCols to access items in screenLines[].
;; They may have different values when the screen wasn't (re)allocated yet
;; after setting Rows or Cols (e.g., when starting up).

(atom! long   Rows      24)      ;; nr of rows in the screen
(atom! long   Cols      80)      ;; nr of columns in the screen

;; The characters that are currently on the screen are kept in screenLines[].
;; It is a single block of characters, the size of the screen plus one line.
;; The attributes for those characters are kept in screenAttrs[].
;;
;; lineOffset[n] is the offset from screenLines[] for the start of line 'n'.
;; The same value is used for screenLinesUC[] and screenAttrs[].
;;
;; Note: before the screen is initialized and when out of memory these can be null.

(atom! Bytes    screenLines)
(atom! int*     screenAttrs)
(atom! int*     lineOffset)
(atom! boolean* lineWraps)          ;; line wraps to next line

;; When using Unicode characters (in UTF-8 encoding) the character in
;; screenLinesUC[] contains the Unicode for the character at this position,
;; or NUL when the character in screenLines[] is to be used (ASCII char).
;; The composing characters are to be drawn on top of the original character.
;; screenLinesC[0][off] is only to be used when screenLinesUC[off] != 0.

(atom! int*     screenLinesUC)      ;; decoded UTF-8 characters
(atom! int**    screenLinesC    MAX_MCO)    ;; composing characters
(atom! int      screen_mco)         ;; value of "p_mco" used when allocating screenLinesC**

(atom! int      screenRows)         ;; actual size of screenLines*
(atom! int      screenCols)         ;; actual size of screenLines*

;; When vgetc() is called, it sets mod_mask to the set of modifiers that are
;; held down based on the MOD_MASK_* symbols that are read first.

(atom! int      mod_mask)           ;; current key modifiers

;; Cmdline_row is the row where the command line starts, just below the last window.
;; When the cmdline gets longer than the available space the screen gets scrolled up.
;; After a CTRL-D (show matches), after hitting ':' after "hit return",
;; and for the :global command, the command line is temporarily moved.
;; The old position is restored with the next call to update-screen().

(atom! int      cmdline_row)

(atom! boolean  redraw_cmdline)     ;; cmdline must be redrawn
(atom! boolean  clear_cmdline)      ;; cmdline must be cleared
(atom! boolean  mode_displayed)     ;; mode is being displayed

(atom! maybean  screen_cleared FALSE)     ;; screen has been cleared

;; Functions for putting characters in the command line,
;; while keeping screenLines[] updated.

(atom! int      msg_col)
(atom! int      msg_row)
(atom! int      msg_scrolled)       ;; number of screen lines that windows have scrolled because of printing messages

(atom! Bytes    keep_msg)           ;; msg to be shown after redraw
(atom! int      keep_msg_attr)      ;; highlight attr for "keep_msg"
(atom! boolean  keep_msg_more)      ;; "keep_msg" was set by msgmore()
(atom! boolean  msg_scroll)         ;; msg-start() will scroll
(atom! boolean  msg_didout)         ;; msg_outstr() was used in line
(atom! boolean  msg_didany)         ;; msg_outstr() was used at all
(atom! boolean  msg_nowait)         ;; don't wait for this msg
(atom! int      emsg_off)           ;; don't display errors for now
(atom! boolean  info_message)       ;; printing informative message
(atom! boolean  did_emsg)           ;; set by emsg() when the message is displayed or thrown
(atom! boolean  called_emsg)        ;; always set by emsg()
(atom! boolean  emsg_on_display)    ;; there is an error message
(atom! boolean  rc_did_emsg)        ;; vim-regcomp() called emsg()

(atom! int      no_wait_return)     ;; don't wait for return for now
(atom! boolean  need_wait_return)   ;; need to wait for return later
(atom! boolean  did_wait_return)    ;; wait-return() was used and nothing written since then

(atom! boolean  newline_on_exit)    ;; did msg in altern. screen
(atom! int      intr_char)          ;; extra interrupt character
(atom! int      vgetc_busy)         ;; when inside vgetc() then > 0

;; Lines left before a "more" message.
;; Ex mode needs to be able to reset this after you type something.

(atom! int      lines_left      -1)     ;; lines left for listing
(atom! boolean  msg_no_more)            ;; don't use more prompt, truncate messages

(atom! boolean  scroll_region)                  ;; term supports scroll region
(atom! int      t_colors)                       ;; int value of T_CCO

;; When "highlight_match" is true, highlight a match, starting at the cursor position.
;; "search_match_lines" is the number of lines after the match (0 for a match within one line),
;; "search_match_endcol" the column number of the character just after the match in the last line.

(atom! boolean  highlight_match)                ;; show search match pos
(atom! long     search_match_lines)             ;; lines of of matched string
(atom! int      search_match_endcol)            ;; col nr of match end

(atom! boolean  no_smartcase)                   ;; don't use 'smartcase' once

(atom! int*     highlight_attr      HLF_COUNT)  ;; highl. attr. for each context
(atom! int      cterm_normal_fg_color)
(atom! int      cterm_normal_fg_bold)
(atom! int      cterm_normal_bg_color)

(defn- #_int hl-attr [#_int n]
    (... @highlight_attr n))

;; While redrawing the screen this flag is set.
;; It means the screen size ('lines' and 'rows') must not be changed.

(atom! boolean  updating_screen)

;; All windows are linked in a list.  "firstwin" points to the first entry,
;; "lastwin" to the last entry (can be the same as "firstwin") and "curwin"
;; to the currently active window.

(atom! window_C firstwin)               ;; first window
(atom! window_C lastwin)                ;; last window
(atom! window_C prevwin)                ;; previous window
(atom! window_C curwin)                 ;; currently active window

;; The window layout is kept in a tree of frames.  "topframe" points to the top of the tree.

(atom! frame_C  topframe)               ;; top of the window frame tree

(atom! buffer_C curbuf)                 ;; currently active buffer

(atom! int      ru_col)                 ;; column for ruler
(atom! int      ru_wid)                 ;; 'rulerfmt' width of ruler when non-zero
(atom! int      sc_col)                 ;; column for shown command

;; When starting or exiting some things are done differently (e.g. screen updating).

(atom! int      starting NO_SCREEN)     ;; first NO_SCREEN, then NO_BUFFERS and then set to 0 when starting up finished
(atom! boolean  exiting)                ;; true when planning to exit Vim.  Might still keep on running if there is a changed buffer.

;; volatile because it is used in signal handler deathtrap().
(atom! #_"/*volatile*/transient" boolean full_screen)   ;; true when doing full-screen output
                                                        ;; otherwise only writing some messages

(atom! int      textlock)               ;; non-zero when changing text and jumping to another window or buffer is not allowed

(atom! pos_C    VIsual_cursor           (NEW_pos_C))    ;; start position of active Visual selection
(atom! boolean  VIsual_active)          ;; whether Visual mode is active
(atom! boolean  VIsual_select)          ;; whether Select mode is active
(atom! boolean  VIsual_reselect)        ;; whether to restart the selection after a Select mode mapping or menu

(atom! int      VIsual_mode \v)         ;; type of Visual mode

(atom! boolean  redo_VIsual_busy)       ;; true when redoing Visual

;; When pasting text with the middle mouse button in visual mode with
;; "restart_edit" set, remember where it started so we can set "insStart".

(atom! pos_C    where_paste_started     (NEW_pos_C))

;; This flag is used to make auto-indent work right on lines where only a
;; <RETURN> or <ESC> is typed.  It is set when an auto-indent is done, and
;; reset when any other editing is done on the line.  If an <ESC> or <RETURN>
;; is received, and "did_ai" is true, the line is truncated.

(atom! boolean  did_ai)

;; Column of first char after autoindent.  0 when no autoindent done.
;; Used when 'backspace' is 0, to avoid backspacing over autoindent.

(atom! int      ai_col)

;; This flag is set when a smart indent has been performed.
;; When the next typed character is a '{' the inserted tab will be deleted again.

(atom! boolean  did_si)

;; This flag is set after an auto indent.
;; If the next typed character is a '}' one indent will be removed.

(atom! boolean  can_si)

;; This flag is set after an "O" command.
;; If the next typed character is a '{' one indent will be removed.

(atom! boolean  can_si_back)

;; Stuff for Insert mode.
;; This is where the latest insert/append mode started.

(atom! pos_C    insStart        (NEW_pos_C))

;; This is where the latest insert/append mode started.  In contrast to
;; "insStart", this won't be reset by certain keys and is needed for
;; op-insert(), to detect correctly where inserting by the user started.

(atom! pos_C    insStart_orig   (NEW_pos_C))

;; Stuff for VREPLACE mode.

(atom! long     orig_line_count)    ;; line count when "gR" started
(atom! int      vr_lines_changed)   ;; #lines changed by "gR" so far

;; "State" is the main state of Vim.
;; There are other variables that modify the state:
;; "Visual_mode"    When State is NORMAL or INSERT.
;; "finish_op"      When State is NORMAL, after typing the operator and before typing the motion command.

(atom! int      State NORMAL)       ;; This is the current state of the command interpreter.

(atom! boolean  finish_op)          ;; true while an operator is pending
(atom! long     opcount)            ;; count for pending operator

(atom! boolean  Recording)          ;; true when recording into a register
(atom! boolean  exec_reg)           ;; true when executing a register

(atom! int      no_mapping)         ;; currently no mapping allowed
(atom! int      allow_keys)         ;; allow key codes when no_mapping is set
(atom! int      no_u_sync)          ;; don't call u-sync()
(atom! int      u_sync_once)        ;; Call u-sync() once when evaluating an expression.

(atom! int      restart_edit)       ;; call edit() when next cmd finished
(atom! boolean  arrow_used)         ;; Normally false, set to true after hitting cursor key in Insert mode.
                                    ;; Used by vgetorpeek() to decide when to call u-sync().
(atom! boolean  ins_at_eol)         ;; put cursor after eol when restarting edit after CTRL-O

(final Bytes    ioBuff      (Bytes. IOSIZE))        ;; sprintf's are done in this buffer, size is IOSIZE

(atom! int      no_redraw)          ;; When non-zero, postpone redrawing.

(atom! typebuf_C typebuf    (NEW_typebuf_C))  ;; typeahead buffer
(atom! boolean  stop_insert_mode)           ;; for ":stopinsert" and 'insertmode'

(atom! boolean  key_typed)                  ;; true if user typed current char
(atom! boolean  key_stuffed)                ;; true if current char from stuffbuf

(atom! byte*    chartab     256)            ;; table used in charset.c; see init-chartab()

(atom! int      must_redraw)                ;; type of redraw necessary
(atom! boolean  skip_redraw)                ;; skip redraw once
(atom! boolean  do_redraw)                  ;; extra redraw once

(atom! int      read_cmd_fd)                ;; fd to read commands from

;; volatile because it is used in signal handler catch-sigint().
(atom! #_"/*volatile*/transient" boolean got_int) ;; set to true when interrupt signal occurred

(atom! boolean  termcap_active)             ;; set by start-termcap()
(atom! int      cur_tmode       TMODE_COOK) ;; input terminal mode
(atom! boolean  bangredo)                   ;; set to true with ! command
(atom! int      searchcmdlen)               ;; length of previous search cmd

(atom! boolean  need_start_insertmode)      ;; start insert mode soon
(atom! Bytes    last_cmdline)               ;; last command line (for ":)
(atom! Bytes    repeat_cmdline)             ;; command line for "."
(atom! Bytes    new_last_cmdline)           ;; new value for "last_cmdline"
(atom! boolean  did_cursorhold)             ;; set when CursorHold t'gerd
(atom! int      last_changedtick)           ;; for TextChanged event
(atom! buffer_C last_changedtick_buf)

(atom! int      postponed_split)            ;; for CTRL-W CTRL-] command
(atom! int      postponed_split_flags)      ;; args for win-split()
(atom! int      replace_offset)             ;; offset for replace-push()

(atom! boolean* breakat_flags   256)        ;; which characters are in 'breakat'

;; Characters from 'fillchars' option.
(atom! int
    fill_stl    \space,
    fill_stlnc  \space,
    fill_vert   \|)

;; Whether 'keymodel' contains "stopsel" and "startsel".
(atom! boolean  km_stopsel)
(atom! boolean  km_startsel)

(atom! int      cedit_key       Ctrl_F) ;; key value of 'cedit' option
(atom! int      cmdwin_type)            ;; type of cmdline window or 0
(atom! int      cmdwin_result)          ;; result of cmdline window or 0

(final Bytes    no_lines_msg    (u8 "--No lines in buffer--"))

;; don't use 'hlsearch' temporarily
(atom! boolean  no_hlsearch)

(atom! boolean  term_is_xterm   true)   ;; xterm-like 'term'

;; Set to TRUE when an operator is being executed with virtual editing,
;; MAYBE when no operator is being executed, FALSE otherwise.

(atom! maybean  virtual_op  MAYBE)

;; The error messages that can be shared are included here.
;; Excluded are errors that are only used once.

(final Bytes
    e_abort           (u8 "E470: Command aborted"),
    e_argreq          (u8 "E471: Argument required"),
    e_backslash       (u8 "E10: \\ should be followed by /, ? or &"),
    e_cmdwin          (u8 "E11: Invalid in command-line window; <CR> executes, CTRL-C quits"),
    e_internal        (u8 "E473: Internal error"),
    e_interr          (u8 "Interrupted"),
    e_invaddr         (u8 "E14: Invalid address"),
    e_invarg          (u8 "E474: Invalid argument"),
    e_invarg2         (u8 "E475: Invalid argument: %s"),
    e_invrange        (u8 "E16: Invalid range"),
    e_invcmd          (u8 "E476: Invalid command"),
    e_markinval       (u8 "E19: Mark has invalid line number"),
    e_marknotset      (u8 "E20: Mark not set"),
    e_nobang          (u8 "E477: No ! allowed"),
    e_noinstext       (u8 "E29: No inserted text yet"),
    e_nolastcmd       (u8 "E30: No previous command line"),
    e_nopresub        (u8 "E33: No previous substitute regular expression"),
    e_noprevre        (u8 "E35: No previous regular expression"),
    e_norange         (u8 "E481: No range allowed"),
    e_noroom          (u8 "E36: Not enough room"),
    e_nowrtmsg        (u8 "E37: No write since last change (add ! to override)"),
    e_null            (u8 "E38: Null argument"),
    e_number_exp      (u8 "E39: Number expected"),
    e_patnotf2        (u8 "E486: Pattern not found: %s"),
    e_positive        (u8 "E487: Argument must be positive"),
    e_re_damg         (u8 "E43: Damaged match string"),
    e_re_corr         (u8 "E44: Corrupted regexp program"),
    e_secure          (u8 "E523: Not allowed here"),
    e_scroll          (u8 "E49: Invalid scroll size"),
    e_toomsbra        (u8 "E76: Too many ["),
    e_trailing        (u8 "E488: Trailing characters"),
    e_umark           (u8 "E78: Unknown mark"),
    e_winheight       (u8 "E591: 'winheight' cannot be smaller than 'winminheight'"),
    e_winwidth        (u8 "E592: 'winwidth' cannot be smaller than 'winminwidth'"),
    e_zerocount       (u8 "Zero count"),
    e_intern2         (u8 "E685: Internal error: %s"),
    e_maxmempat       (u8 "E363: pattern uses more memory than 'maxmempattern'"),
    e_emptybuf        (u8 "E749: empty buffer"))

;; For undo we need to know the lowest time possible.
(atom! long starttime)

;; ----------------------------------------------------------------------- ;;

;; values for vim-handle-signal() that are not a signal
(final int SIGNAL_BLOCK    -1)
(final int SIGNAL_UNBLOCK  -2)

(final int KEYLEN_PART_KEY -1)      ;; keylen value for incomplete key-code
(final int KEYLEN_REMOVED  9999)    ;; keylen value for removed sequence

;; Position comparisons

(defn- #_boolean ltpos [#_pos_C a, #_pos_C b]
    (cond (!= (:lnum a) (:lnum b)) (< (:lnum a) (:lnum b)) (!= (:col a) (:col b)) (< (:col a) (:col b)) :else (< (:coladd a) (:coladd b))))

(defn- #_boolean eqpos [#_pos_C a, #_pos_C b]
    (and (== (:lnum a) (:lnum b)) (== (:col a) (:col b)) (== (:coladd a) (:coladd b))))

(defn- #_boolean ltoreq [#_pos_C a, #_pos_C b]
    (or (ltpos a, b) (eqpos a, b)))

;; true if the line is empty

(defn- #_boolean lineempty [#_long lnum]
    (eos? (ml-get lnum)))

;; true if the current buffer is empty

(defn- #_long line-count [#_buffer_C buf] (:ml_line_count (:b_ml buf)))

(defn- #_boolean bufempty []
    (and (== (line-count @curbuf) 1) (lineempty 1)))

;;; ============================================================================================== VimH

;; os_unix.c --------------------------------------------------------------------------------------

;; volatile because it is used in signal handler sig-winch().
(atom! #_"/*volatile*/transient" boolean do_resize)
;; volatile because it is used in signal handler deathtrap().
(atom! #_"/*volatile*/transient" int deadly_signal)                     ;; the signal we caught
;; volatile because it is used in signal handler deathtrap().
(atom! #_"/*volatile*/transient" boolean in_mch_delay)                  ;; sleeping in mch-delay()

(atom! int curr_tmode TMODE_COOK)                 ;; contains current terminal mode

(class! #_final signalinfo_C
    [
        (field int      sig)        ;; Signal number, e.g. SIGSEGV etc.
        (field Bytes    name)       ;; Signal name.
        (field boolean  deadly)     ;; Catch as a deadly signal?
    ])

(final signalinfo_C* signal_info
    [
; %%    (signalinfo_C. SIGHUP,    (u8 "HUP"),      true ),
; %%    (signalinfo_C. SIGQUIT,   (u8 "QUIT"),     true ),
; %%    (signalinfo_C. SIGILL,    (u8 "ILL"),      true ),
; %%    (signalinfo_C. SIGTRAP,   (u8 "TRAP"),     true ),
; %%    (signalinfo_C. SIGABRT,   (u8 "ABRT"),     true ),
; %%    (signalinfo_C. SIGFPE,    (u8 "FPE"),      true ),
; %%    (signalinfo_C. SIGBUS,    (u8 "BUS"),      true ),
; %%    (signalinfo_C. SIGSEGV,   (u8 "SEGV"),     true ),
; %%    (signalinfo_C. SIGSYS,    (u8 "SYS"),      true ),
; %%    (signalinfo_C. SIGALRM,   (u8 "ALRM"),     false),
; %%    (signalinfo_C. SIGTERM,   (u8 "TERM"),     true ),
; %%    (signalinfo_C. SIGVTALRM, (u8 "VTALRM"),   true ),
; %%    (signalinfo_C. SIGPROF,   (u8 "PROF"),     true ),
; %%    (signalinfo_C. SIGXCPU,   (u8 "XCPU"),     true ),
; %%    (signalinfo_C. SIGXFSZ,   (u8 "XFSZ"),     true ),
; %%    (signalinfo_C. SIGUSR1,   (u8 "USR1"),     true ),
; %%    (signalinfo_C. SIGUSR2,   (u8 "USR2"),     true ),
; %%    (signalinfo_C. SIGINT,    (u8 "INT"),      false),
; %%    (signalinfo_C. SIGWINCH,  (u8 "WINCH"),    false),
; %%    (signalinfo_C. SIGTSTP,   (u8 "TSTP"),     false),
; %%    (signalinfo_C. SIGPIPE,   (u8 "PIPE"),     false),

        (signalinfo_C. -1,        (u8 "Unknown!"), false)
    ])

;; Write s[len] to the screen.

(defn- #_void mch-write [#_Bytes s, #_int len]
    (ร .write libC 1, s, len)
    (when (non-zero? @p_wd)           ;; Unix is too fast, slow down a bit more
        (realWaitForChar @read_cmd_fd, @p_wd))
    nil)

;; Low level input function.
;; Get a characters from the keyboard.
;; Return the number of characters that are available.
;; If "wtime" == 0, do not wait for characters.
;; If "wtime" == n, wait a short time for characters.
;; If "wtime" == -1, wait forever for characters.

(defn- #_[window_C int] mch-inchar? [#_window_C win, #_Bytes buf, #_int maxlen, #_long wtime, #_int tb_change_cnt]
    ;; Check if window changed size while we were busy, perhaps the ":set columns=99" command was used.
    (let-when [win (loop-when-recur win @do_resize (handle-resize win) => win)
          [win #_int n]
            (cond (<= 0 wtime)
                (loop-when win (not (waitForChar wtime)) => [win nil]               ;; no character available
                    (recur-if @do_resize (handle-resize win) => [win 0]))           ;; return if not interrupted by resize
            (not (waitForChar @p_ut))
                ;; If there is no character available within 'updatetime' seconds, flush all the swap files to disk.
                ;; Also done when interrupted by SIGWINCH.
                (if (and (trigger-cursorhold) (<= 3 maxlen) (not (typebuf-changed tb_change_cnt)))
                    (do (-> buf (.be 0, KB_SPECIAL) (.be 1, KS_EXTRA) (.be 2, KE_CURSORHOLD)) [win 3])
                    (do (before-blocking) [win nil]))
            :else
                [win nil]
            )] (nil? n) => [win n]

        (loop [win win]                                                             ;; repeat until we got a character
            (let [win (loop-when-recur win @do_resize (handle-resize win) => win)]  ;; window changed size
                ;; We want to be interrupted by the SIGWINCH signal
                ;; or by an event on the monitored file descriptors.
                (cond (not (waitForChar -1))
                    [(if @do_resize (handle-resize win) win) 0]                     ;; interrupted by SIGWINCH signal
                ;; If input was put directly in typeahead buffer bail out here.
                (typebuf-changed tb_change_cnt)
                    [win 0]
                ;; For some terminals we only get one character at a time.
                ;; We want the get all available characters, so we could keep on trying until none is available.
                ;; For some other terminals this is quite slow, that's why we don't do it.
                :else
                    (let [#_int len (read-from-input-buf buf, maxlen)]
                        (if (< 0 len) [win len] (recur win))
                    ))
            ))
    ))

(defn- #_window_C handle-resize [#_window_C win]
    (reset! do_resize false)
    (when (some? win) (shell-resized win)))

(defn- #_void mch-delay [#_long msec, #_boolean ignoreinput]
    (if ignoreinput
        (do ;; Go to cooked mode without echo, to allow SIGINT interrupting us here.
            ;; But we don't want QUIT to kill us (CTRL-\ used in a shell may produce SIGQUIT).
            (reset! in_mch_delay true)
            (let [o'tmode @curr_tmode]
                (when (== @curr_tmode TMODE_RAW)
                    (settmode TMODE_SLEEP))
                ;; Everybody sleeps in a different way...
                ;; Prefer nanosleep(), some versions of usleep() can only sleep up to one second.
                (let [#_timespec_C ts (ร new timespec_C)]
                    (ร .tv_sec ts (/ msec 1000))
                    (ร .tv_nsec ts (* (% msec 1000) 1000000))
                    (ร .nanosleep libc ts, nil))
                (settmode o'tmode)
                (reset! in_mch_delay false)
            ))
        (waitForChar msec))
    nil)

;; We need correct prototypes for a signal function, otherwise mean compilers
;; will barf when the second argument to sigset() is ``wrong''.

(defn- #_void sig-winch [#_int _sigarg]
    ;; this is not required on all systems, but it doesn't hurt anybody
    (ร .sigset libC SIGWINCH, #_"/*(void (*)())sig-winch*/"nil)
    (reset! do_resize true)
    nil)

(defn- #_void catch-sigint [#_int _sigarg]
    ;; this is not required on all systems, but it doesn't hurt anybody
    (ร .sigset libC SIGINT, #_"/*(void (*)())catch-sigint*/"nil)
    (reset! got_int true)
    nil)

(defn- #_void catch-sigpwr [#_int _sigarg]
    ;; this is not required on all systems, but it doesn't hurt anybody
    (ร .sigset libC SIGPWR, #_"/*(void (*)())catch-sigpwr*/"nil)
    nil)

(atom! int trap__entered) ;; count the number of times we got here

(defn- #_void may-core-dump []
    (when (non-zero? @deadly_signal)
        (ร .sigset libC @deadly_signal, #_"/*SIG_DFL*/"nil)
        (ร .kill libc (.getpid libc), @deadly_signal) ;; die using the signal we caught
    )
    nil)

;; This function handles deadly signals.
;; It tries to preserve any swap files and exit properly.
;; NOTE: Avoid unsafe functions, such as allocating memory, they can result in a deadlock.

(defn- #_void deathtrap [#_int sigarg]
    (ยง cond (and @in_mch_delay (== sigarg SIGQUIT))
        ;; While in mch-delay() we go to cooked mode to allow a CTRL-C to interrupt us.
        ;; But in cooked mode we may also get SIGQUIT, e.g., when pressing CTRL-\,
        ;; but we don't want Vim to exit then.
        nil
    (and (zero? @trap__entered) (any == sigarg SIGHUP SIGQUIT SIGTERM SIGPWR SIGUSR1 SIGUSR2) (not (vim-handle-signal sigarg)))
        ;; When SIGHUP, SIGQUIT, etc. are blocked: postpone the effect and return here.
        ;; This avoids that a non-reentrant function is interrupted, e.g. free().
        ;; Calling free() again may then cause a crash.
        nil
    :else
        (do ;; Remember how often we have been called.
            (swap! trap__entered inc)
            ;; Try to find the name of this signal.
            (let [#_int i (loop-when-recur [i 0] (and (!= (:sig (... signal_info i)) -1) (!= sigarg (:sig (... signal_info i)))) [(inc i)] => i)]
                (reset! deadly_signal sigarg)
                (reset! full_screen false)    ;; don't write message to the GUI, it might be part of the problem...

                ;; If something goes wrong after entering here, we may get here again.
                ;; When this happens, give a message and try to exit nicely (resetting the terminal mode, etc.)
                ;; When this happens twice, just exit, don't even try to give a message,
                ;; stack may be corrupt or something weird.
                ;; When this still happens again (or memory was corrupted in such a way
                ;; that "trap__entered" was clobbered) use _exit(), don't try freeing resources.

                (cond (<= 3 @trap__entered)
                (do
                    (reset-signals)        ;; don't catch any signals anymore
                    (may-core-dump)
                    (if (<= 4 @trap__entered) (._exit libc 8) (.exit libc 7))
                )
                (== @trap__entered 2)
                (do
                    (out-str (u8 "Vim: Double signal, exiting\n"))
                    (out-flush)
                    (getout 1)
                )
                :else
                (do
                    (.sprintf libC ioBuff, (u8 "Vim: Caught deadly signal %s\n"), (:name (... signal_info i)))
                    ;; Preserve files and exit.
                    (preserve-exit ioBuff)
                ))
            )
        nil)
    ))

;; If the machine has job control, use it to suspend the program,
;; otherwise fake it by starting a new shell.

(defn- #_void mch-suspend []
    (out-flush)                 ;; needed to make cursor visible on some systems
    (settmode TMODE_COOK)
    (out-flush)                 ;; needed to disable mouse on some systems

    (ร .kill libc 0, SIGTSTP)   ;; send ourselves a STOP signal

    (settmode TMODE_RAW)
    nil)

(defn- #_void mch-init []
    (reset! Cols 80)
    (reset! Rows 24)

    (out-flush)
    (set-signals)
    nil)

(defn- #_void set-signals []
    ;; WINDOW CHANGE signal is handled with sig-winch().
    (ร .sigset libC SIGWINCH, #_"/*(void (*)())sig-winch*/"nil)
    ;; We want the STOP signal to work, to make mch-suspend() work.
    ;; For "rvim" the STOP signal is ignored.
    (ร .sigset libC SIGTSTP, #_"/*SIG_DFL*/"nil)
    ;; We want to ignore breaking of PIPEs.
    (ร .sigset libC SIGPIPE, #_"/*SIG_IGN*/"nil)

    (catch-int-signal)

    ;; Ignore alarm signals (Perl's alarm() generates it).
    (ร .sigset libC SIGALRM, #_"/*SIG_IGN*/"nil)
    ;; Catch SIGPWR (power failure?) to preserve the swap files, so that no work will be lost.
    (ร .sigset libC SIGPWR, #_"/*(void (*)())catch-sigpwr*/"nil)
    ;; Arrange for other signals to gracefully shutdown Vim.
    (ร catch-signals #_"/*deathtrap*//*null*/"0, SIG_ERR)
    nil)

;; Catch CTRL-C (only works while in Cooked mode).

(defn- #_void catch-int-signal []
    (ร .sigset libC SIGINT, #_"/*(void (*)())catch-sigint*/"nil)
    nil)

(defn- #_void reset-signals []
    (ร catch-signals SIG_DFL, SIG_DFL)
    nil)

(defn- #_void catch-signals #_"/*(void (*func_deadly)(), void (*func_other)())*/" [#_@sighandler_t #_long func_deadly, #_@sighandler_t #_long func_other]
    (loop-when-recur [#_int i 0] (!= (:sig (... signal_info i)) -1) [(inc i)]
        (cond (:deadly (... signal_info i))
            ;; Setup to use the alternate stack for the signal function.
            (do ;; let [#_sigaction_C sa (ร new sigaction_C)]
             ;; (ร .sa_handler sa func_deadly)
                (ร .sigemptyset libC #_"/*&sa.sa_mask*/"nil)
             ;; (ร .sa_flags sa SA_ONSTACK)
                (ร .sigaction libC (:sig (... signal_info i)), #_"/*sa*/"nil, nil))
        (ร != func_other SIG_ERR)
            (ร .sigset libC (:sig (... signal_info i)), #_"/*func_other*/"nil)
        ))
    nil)

(atom! int got_signal)
(atom! boolean __blocked true)

;; Handling of SIGHUP, SIGQUIT and SIGTERM:
;;
;; "when" == a signal:       when busy, postpone and return false, otherwise return true
;; "when" == SIGNAL_BLOCK:   going to be busy, block signals
;; "when" == SIGNAL_UNBLOCK: going to wait, unblock signals, use postponed signal
;;
;; Returns true when Vim should exit.

(defn- #_boolean vim-handle-signal [#_int sig]
    (cond (== sig SIGNAL_BLOCK)
        (do (reset! __blocked true)
            false)
    (== sig SIGNAL_UNBLOCK)
        (do (reset! __blocked false)
            (when (non-zero? @got_signal)
                (ร .kill libc (.getpid libc), @got_signal)
                (reset! got_signal 0))
            false)
    @__blocked
        (do (reset! got_signal sig)
            (ร when (!= sig SIGPWR)
                (reset! got_int true)) ;; break any loops
            false)
    :else
        true ;; exit!
    ))

;; Output a newline when exiting.
;; Make sure the newline goes to the same stream as the text.

(defn- #_void exit-scroll []
    (if (or @newline_on_exit @msg_didout)
        (if (msg-use-printf)
            (if @info_message
                (ร .fprintf libC stdout, (u8 "\n"))
                (ร .fprintf libC stderr, (u8 "\r\n")))
            (out-char (byte \newline)))
        (do
            (restore-cterm-colors)      ;; get original colors back
            (msg-clr-eos-force)         ;; clear the rest of the display
            (windgoto (dec @Rows), 0)   ;; may have moved the cursor
        ))
    nil)

(defn- #_void mch-exit [#_int r]
    (reset! exiting true)
    (settmode TMODE_COOK)
    ;; When t_ti is not empty, but it doesn't cause swapping terminal pages,
    ;; need to output a newline when msg_didout is set.
    ;; But when t_ti does swap pages, it should not go to the shell page.
    ;; Do this before stop-termcap().
    (when (and (swapping-screen) (not @newline_on_exit))
        (exit-scroll))
    (stop-termcap)
    ;; A newline is only required after a message in the alternate screen.
    ;; This is set to true by wait-return().
    (when (or (not (swapping-screen)) @newline_on_exit)
        (exit-scroll))
    ;; Cursor may have been switched off without calling start-termcap()
    ;; when doing "vim -u vimrc" and vimrc contains ":q".
    (when @full_screen
        (cursor-on))
    (out-flush)
    (may-core-dump)
    (ร .exit libc r)
    nil)

;; for "new" tty systems

(atom! termios_C stm__told)

(defn- #_void mch-settmode [#_int tmode]
    (when (nil? @stm__told)
        (reset! stm__told (ร new termios_C))
        (ร .tcgetattr libc @read_cmd_fd, @stm__told))
    (let [#_termios_C tnew (ร new termios_C)]
        (ร COPY_termios tnew, @stm__told)
        (cond (== tmode TMODE_RAW)
            (do ;; ~ICRNL enables typing ^V^M
                (ร .c_iflag tnew (& (.c_iflag tnew) (bit-not ICRNL)))
                (ร .c_lflag tnew (& (.c_lflag tnew) (bit-not (| ICANON ECHO ISIG ECHOE IEXTEN))))
                (ร .c_oflag tnew (& (.c_oflag tnew) (bit-not ONLCR)))
                (ร .c_vmin tnew (short 1))      ;; return after 1 char
                (ร .c_vtime tnew (short 0)))    ;; don't wait
        (== tmode TMODE_SLEEP)
            (ร .c_lflag tnew (& (.c_lflag tnew) (bit-not ECHO))))
        ;; A signal may cause tcsetattr() to fail (e.g. SIGCONT).  Retry a few times.
        (loop-when-recur [#_int n 10] (and (== (ร .tcsetattr libc @read_cmd_fd, TCSANOW, tnew) -1) (ร == (ร .errno libC) EINTR) (< 0 n)) [(dec n)])
        (reset! curr_tmode tmode))
    nil)

;; Try to get the code for "t_kb" from the stty setting.
;;
;; Even if termcap claims a backspace key, the user's setting *should* prevail.
;; stty knows more about reality than termcap does, and if somebody's usual erase
;; key is DEL (which, for most BSD users, it will be), they're going to get really
;; annoyed if their erase key starts doing forward deletes for no reason.

(defn- #_void do-fixdel []
    (let [#_Bytes code (find-termcode (u8 "kb"))]
        (add-termcode (u8 "kD"), (if (and (some? code) (at? code DEL)) CTRL_H_STR DEL_STR))
    ))

(defn- #_void get-stty []
    (let-when [#_termios_C keys (ร new termios_C)] (!= (ร .tcgetattr libc @read_cmd_fd, keys) -1)
        (let [#_Bytes t (-> (Bytes. 2) (.be 0, (ร .c_verase keys)) (eos! 1))]
            (reset! intr_char (ร .c_vintr keys))
            (add-termcode (u8 "kb"), t)
            ;; If <BS> and <DEL> are now the same, redefine <DEL>.
            (let-when [#_Bytes s (find-termcode (u8 "kD"))] (and (some? s) (at? s 0 (.at t 0)) (at? s 1 (.at t 1)))
                (do-fixdel)
            )))
    nil)

;; Try to get the current window size.
;;
;; 1. with an ioctl(), most accurate method
;; 2. from the environment variables LINES and COLUMNS
;; x. keep using the old values
;;
;; Return true when size could be determined, false otherwise.

(defn- #_boolean mch-get-shellsize []
    (let [#_long rows 0 #_long cols 0
          ;; 1.  Try using an ioctl().  It is the most accurate method.
          #_int fd 1
          ;; When stdout is not a tty, use stdin for the ioctl().
          fd (if (and (zero? (ร .isatty libc fd)) (non-zero? (ร .isatty libc @read_cmd_fd))) @read_cmd_fd fd)
          [rows cols] (let [#_winsize_C ws (ร new winsize_C)] (if (zero? (ร .ioctl libc fd, TIOCGWINSZ, ws)) [(ร .ws_row ws) (ร .ws_col ws)] [rows cols]))
          ;; 2.  Get size from environment.
          [rows cols] (if (or (zero? cols) (zero? rows))
                            (let [#_Bytes p (ร .getenv libC (u8 "LINES"))   rows (if (some? p) (ร .atoi libC p) rows)
                                          p (ร .getenv libC (u8 "COLUMNS")) cols (if (some? p) (ร .atoi libC p) cols)]
                            [rows cols]) [rows cols])
        ] ;; 4.  If everything fails, use the old values.
        (and (< 0 cols) (< 0 rows)
            (do
                (reset! Rows rows)
                (reset! Cols cols)
                (limit-screen-size)
                true
            ))
    ))

;; Try to set the window size to Rows and Cols.

(defn- #_void mch-set-shellsize []
    (when (non-eos? @T_CWS)
        (term-set-winsize @Rows, @Cols)
        (out-flush)
        (screen-start)) ;; don't know where cursor is now
    nil)

;; Rows and/or Cols has changed.

(defn- #_void mch-new-shellsize []
    ;; Nothing to do.
    nil)

;; Check for CTRL-C typed by reading all available characters.
;; In cooked mode we should get SIGINT, no need to check.

(defn- #_void mch-breakcheck []
    (when (and (== @curr_tmode TMODE_RAW) (realWaitForChar @read_cmd_fd, 0))
        (fill-input-buf false))
    nil)

;; Wait "msec" msec until a character is available from the keyboard or from inbuf[].
;; "msec" == -1 will block forever.

(defn- #_boolean waitForChar [#_long msec]
    (or (input-available) (realWaitForChar @read_cmd_fd, msec)))

;; Wait "msec" msec until a character is available from file descriptor "fd".
;; "msec" == 0 will check for characters once.
;; "msec" == -1 will block until a character is available.

(defn- #_boolean realWaitForChar [#_int fd, #_long msec]
    (let [#_timeval_C tv (ร new timeval_C)
          _ (when (<= 0 msec)
                (ร .tv_sec tv (/ msec 1000))
                (ร .tv_usec tv (* (% msec 1000) 1000)))
          ;; Select on ready for reading and exceptional condition (end of file).
          #_long* rfds (ร long-array FD_SET_LENGTH) #_long* efds (ร long-array FD_SET_LENGTH)]
        (loop []
            (let [_ (ร FD_ZERO rfds) _ (ร FD_SET fd, rfds) _ (ร FD_ZERO efds) _ (ร FD_SET fd, efds)
                  #_int ret (ร .select libc (inc fd), rfds, nil, efds, (if (< msec 0) nil tv))]
                (if (and (== ret -1) (ร == (ร .errno libC) EINTR))
                    (do ;; Check whether window has been resized, EINTR may be caused by SIGWINCH.
                        (when @do_resize (let [_ (handle-resize (ยง @curwin))] (ยง reset! curwin _)))
                        ;; Interrupted by a signal, need to try again.  We ignore "msec" here,
                        ;; because we do want to check even after a timeout if characters are available.
                        ;; Needed for reading output of an external command after the process has finished.
                        (recur))
                    (< 0 ret)
                )))
    ))

;; message.c: functions for displaying messages on the command line -------------------------------

;; When writing messages to the screen, there are many different situations.
;; A number of variables is used to remember the current state:
;; msg_didany       true when messages were written since the last time the user reacted to a prompt.
;;                  Reset: After hitting a key for the hit-return prompt,
;;                  hitting <CR> for the command line or input().
;;                  Set: When any message is written to the screen.
;; msg_didout       true when something was written to the current line.
;;                  Reset: When advancing to the next line, when the current text can be overwritten.
;;                  Set: When any message is written to the screen.
;; msg_nowait       No extra delay for the last drawn message.
;;                  Used in normal-cmd() before the mode message is drawn.
;; emsg_on_display  There was an error message recently.
;;                  Indicates that there should be a delay before redrawing.
;; msg_scroll       The next message should not overwrite the current one.
;; msg_scrolled     How many lines the screen has been scrolled (because of messages).
;;                  Used in update-screen() to scroll the screen back.
;;                  Incremented each time the screen scrolls a line.
;; lines_left       Number of lines available for messages before the more-prompt is to be given.
;;                  -1 when not set.
;; need_wait_return true when the hit-return prompt is needed.
;;                  Reset: After giving the hit-return prompt, when the user has answered some other prompt.
;;                  Set: When the ruler or typeahead display is overwritten,
;;                  scrolling the screen for some message.
;; keep_msg         Message to be displayed after redrawing the screen, in main-loop().
;;                  This is an allocated string or null when not used.

(defn- #_window_C msg* [#_window_C win, #_Bytes s, #_Object... args]
    (ร .sprintf libC ioBuff, s, args)
    (msg win, ioBuff))

;; Display "s" on the status line.
;; Return true if wait-return() not called.

(defn- #_[window_C boolean] msg? [#_window_C win, #_Bytes s]
    (msg-attr-keep? win, s, 0, false))

(defn- #_window_C msg [#_window_C win, #_Bytes s]
    (let [[win _] (msg? win, s)]
        win
    ))

(defn- #_[window_C boolean] msg-attr? [#_window_C win, #_Bytes s, #_int attr]
    (msg-attr-keep? win, s, attr, false))

(defn- #_window_C msg-attr [#_window_C win, #_Bytes s, #_int attr]
    (let [[win _] (msg-attr? win, s, attr)]
        win
    ))

(atom! int msg__entered)

(defn- #_[window_C boolean] msg-attr-keep? [#_window_C win, #_Bytes s, #_int attr, #_boolean keep] ;; keep: true: set "keep_msg" if it doesn't scroll
    ;; It is possible that displaying a message causes a problem
    ;; (e.g. when redrawing the window), which causes another message, etc.
    ;; To break this loop, limit the recursiveness to 3 levels.
    (when' (< @msg__entered 3) => [win true]
        (swap! msg__entered inc)
        ;; When displaying "keep_msg", don't let msg-start() free it, caller must do that.
        (when (BEQ s, @keep_msg)
            (reset! keep_msg nil))
        ;; Truncate the message if needed.
        (msg-start)
        (let [#_Bytes buf (msg-strtrunc s) s (if (some? buf) buf s)
              _ (msg-outtrans-attr s, attr)
              _ (msg-clr-eos)
              [win ?] (msg-end? win)]
            (when (and keep ? (< (mb-string2cells s) (+ (* (- @Rows @cmdline_row 1) @Cols) @sc_col)))
                (set-keep-msg s, 0))
            (swap! msg__entered dec)
            [win ?]
        )
    ))

;; Truncate a string such that it can be printed without causing a scroll.
;; Returns an allocated string or null when no truncating is done.

(defn- #_Bytes msg-strtrunc [#_Bytes s]
    ;; May truncate message to avoid a hit-return prompt.
    (when (and (not @msg_scroll) (not @need_wait_return))
        (let [m (if (non-zero? @msg_scrolled)
                (dec    (* (- @Rows @msg_row)   @Cols)) ;; Use all the columns.
                (dec (+ (* (- @Rows @msg_row 1) @Cols) @sc_col)))] ;; Use up to 'showcmd' column.
            (when (< 0 m (mb-string2cells s))
                ;; may have up to 18 bytes per cell (6 per char, up to two composing chars)
                (let [n (* (+ m 2) 18) buf (Bytes. n)]
                    (trunc-string s, buf, m, n)
                    buf)
            ))
    ))

;; Truncate a string "s" to "buf" with cell width "room".
;; "s" and "buf" may be equal.

(defn- #_void trunc-string [#_Bytes s, #_Bytes buf, #_int room, #_int buflen]
    (let-when [room (- room 3) #_int half (/ room 2)
          [#_int len #_int e :as _]
            (loop-when [len 0 e 0] (and (< len half) (< e buflen)) => [len e]
                (if (eos? s e)
                    (do (eos! buf e) nil) ;; text fits without truncating!
                    (let [#_int n (mb-ptr2cells s, e)]
                        (if (<= half (+ len n))
                            [len e]
                            (let [len (+ len n)]
                                (.be buf e, (.at s e))
                                (let [e (loop-when [e e #_int n (dec (us-ptr2len-cc s, e))] (< 0 n) => e
                                            (let [e (inc e)] (if (< e buflen) (do (.be buf e, (.at s e)) (recur e (dec n))) e))
                                        )]
                                    (recur len (inc e))
                                ))
                        ))
                ))] (some? _)
        (let [#_int i ;; For UTF-8 we can go backwards easily.
                (loop [half (STRLEN s) len len i half]
                    (let [half (loop [half half] (let [half (- half (us-head-off s, (.plus s (dec half))) 1)]
                            (recur-if (and (utf-iscomposing (us-ptr2char s, half)) (< 0 half)) half => half)))
                          #_int n (mb-ptr2cells s, half)]
                        (if (< room (+ len n)) i (recur half (+ len n) half))
                    ))]
            ;; Set the middle and copy the last part.
            (if (< (+ e 3) buflen)
                (let [#_int len (min (inc (STRLEN s, i)) (- buflen e 3 1))]
                    (BCOPY buf, e, (u8 "..."), 0, 3)
                    (BCOPY buf, (+ e 3), s, i, len)
                    (eos! buf (dec (+ e 3 len))))
                (eos! buf (dec e))     ;; make sure it is truncated
            )))
    nil)

;; Return false if not giving error messages right now.

(defn- #_boolean emsg-allowed []
    (<= @emsg_off 0))

;; Display an error message.
;;
;; Rings the bell, if appropriate, and calls message() to do the real work.
;;
;; Return true if wait-return() not called.

(defn- #_[window_C boolean] emsg? [#_window_C win, #_Bytes s]
    (when' (emsg-allowed) => [win true]
        (let [_ (reset! called_emsg true)
              win (when' (zero? @emsg_off) => win
                    (let [win (if @p_eb (beep-flush win) (flush-buffers win, false))]
                        (reset! did_emsg true)          ;; flag for do-one-cmd()
                        win)
                )]
            (reset! emsg_on_display true)               ;; remember there is an error message
            (reset! msg_scroll true)                    ;; don't overwrite a previous message
            ;; Needed in case emsg() is called after
            ;; wait-return() has reset "need_wait_return"
            ;; and a redraw is expected because "msg_scrolled" is non-zero.
            (when (non-zero? @msg_scrolled)
                (reset! need_wait_return true))
            (reset! msg_nowait false)                   ;; wait for this msg
            (msg-attr? win, s, (hl-attr HLF_E)))        ;; highlight mode for error messages
    ))

(defn- #_window_C emsg [#_window_C win, #_Bytes s]
    (let [[win _] (emsg? win, s)]
        win
    ))

(defn- #_window_C emsg* [#_window_C win, #_Bytes s, #_Object... args]
    (when' (emsg-allowed) => win
        (ร .sprintf libC ioBuff, s, args)
        (emsg win, ioBuff)
    ))

;; Wait for the user to hit a key (normally a RETURN).
;;
;; If "redraw" is TRUE, clear and redraw the screen;
;; if "redraw" is FALSE, just redraw the screen;
;; if "redraw" is -1, don't redraw at all.

(defn- #_window_C wait-return [#_window_C win, #_int redraw]
    (when (== redraw TRUE)
        (reset! must_redraw CLEAR))
    ;; When inside vgetc(), we can't wait for a typed character at all.
    ;; With the global command (and some others) we only need one return at the end.
    ;; Adjust cmdline_row to avoid the next message overwriting the last one.
    (if (< 0 @vgetc_busy)
        win
        (do (reset! need_wait_return true)
            (if (non-zero? @no_wait_return)
                (do (reset! cmdline_row @msg_row) win)
                (let [#_int o'State @State
                      [win #_int c]
                        (do ;; Make sure the hit-return prompt is on screen when 'guioptions' was just changed.
                            (screen-alloc false)
                            (reset! State HITRETURN)
                            (hit-return-msg)
                            (let [[win c]
                                    (loop [win win]
                                        ;; Remember "got_int": if it is set, vgetc() probably returns a CTRL-C, but we need to loop then.
                                        ;; Temporarily disable Recording.  If Recording is active, the character will be recorded later,
                                        ;; since it will be added to the typebuf after the loop.
                                        (let [o'got_int @got_int o'Recording @Recording
                                              _ (reset! Recording false)
                                              ;; Don't do mappings here, we put the character back in the typeahead buffer.
                                              _ (swap! no_mapping inc) _ (swap! allow_keys inc) [win c] (safe-vgetc? win) _ (swap! no_mapping dec) _ (swap! allow_keys dec)
                                              _ (reset! Recording o'Recording)]
                                            (when o'got_int
                                                (reset! got_int false))
                                            (recur-if (or (and o'got_int (== c Ctrl_C)) (== c K_IGNORE)) [win] => [win c]))
                                    )]
                                (ui-breakcheck)
                                (when-not (any == c (byte \return) (byte \newline) (byte \space) Ctrl_C)
                                    ;; Put the character back in the typeahead buffer.
                                    ;; Don't use the stuff buffer, because lmaps wouldn't work.
                                    (ins-char-typebuf c)
                                    (reset! do_redraw true))    ;; need a redraw even though there is typeahead
                                [win c])
                        )]
                    ;; If the user hits ':', '?' or '/' we get a command line from the next line.
                    (when (any == c (byte \:) (byte \?) (byte \/))
                        (reset! cmdline_row @msg_row)
                        (reset! skip_redraw true)                   ;; skip redraw once
                        (reset! do_redraw false))
                    ;; If the window size changed, set-shellsize() will redraw the screen.
                    ;; Otherwise the screen is only redrawn if 'redraw' is set and no ':' typed.
                    (let [state' @State _ (reset! State o'State)]   ;; restore State before set-shellsize()
                        (msg-check)
                        ;; When switching screens, we need to output an extra newline on exit.
                        (when (and (swapping-screen) (not @termcap_active))
                            (reset! newline_on_exit true))
                        (reset! need_wait_return false)
                        (reset! did_wait_return true)
                        (reset! emsg_on_display false)              ;; can delete error message now
                        (reset! lines_left -1)                      ;; reset lines_left at next msg-start()
                        (when (and (some? @keep_msg) (<= (+ (* (- @Rows @cmdline_row 1) @Cols) @sc_col) (mb-string2cells @keep_msg)))
                            (reset! keep_msg nil))                  ;; don't redisplay message, it's too long
                        (cond (== state' SETWSIZE)                  ;; got resize event while in vgetc()
                            (do (start-termcap)                     ;; start termcap before redrawing
                                (shell-resized win))
                        (and (not @skip_redraw) (or (== redraw TRUE) (and (non-zero? @msg_scrolled) (!= redraw -1))))
                            (do (start-termcap)                     ;; start termcap before redrawing
                                (redraw-later win, VALID))
                        :else
                            win)
                    ))
            ))
    ))

;; Write the hit-return prompt.

(defn- #_void hit-return-msg []
    (when @msg_didout
        (msg-putchar (byte \newline)))          ;; start on a new line
    (when @got_int
        (msg-puts (u8 "Interrupt: ")))
    (msg-puts-attr (u8 "Press ENTER or type command to continue"), (hl-attr HLF_R))
    (when (not (msg-use-printf))
        (msg-clr-eos))
    nil)

;; Set "keep_msg" to "s".  Free the old value and check for null pointer.

(defn- #_void set-keep-msg [#_Bytes s, #_int attr]
    (reset! keep_msg (if (some? s) (STRDUP s) nil))
    (reset! keep_msg_more false)
    (reset! keep_msg_attr attr)
    nil)

;; Prepare for outputting characters in the command line.

(defn- #_void msg-start []
    (reset! keep_msg nil)                       ;; don't display old message now
    (cond (and (not @msg_scroll) @full_screen)  ;; overwrite last message
    (do
        (reset! msg_row @cmdline_row)
        (reset! msg_col 0)
    )
    @msg_didout                                 ;; start message on next line
    (do
        (msg-putchar (byte \newline))
        (reset! cmdline_row @msg_row)
    ))
    (when (or (not @msg_didany) (< @lines_left 0))
        (msg-starthere))
    (reset! msg_didout false)                   ;; no output on current line yet
    (cursor-off)
    nil)

;; Note that the current msg position is where messages start.

(defn- #_void msg-starthere []
    (reset! lines_left @cmdline_row)
    (reset! msg_didany false)
    nil)

(defn- #_void msg-putchar [#_int c]
    (msg-putchar-attr c, 0))

(defn- #_void msg-putchar-attr [#_int c, #_int attr]
    (let [#_Bytes buf (Bytes. (inc MB_MAXBYTES))]
        (if (is-special c)
            (-> buf (.be 0, KB_SPECIAL) (.be 1, (KB-SECOND c)) (.be 2, (KB-THIRD c)) (eos! 3))
            (eos! buf (utf-char2bytes c, buf)))
        (msg-puts-attr buf, attr)
        nil))

;; Output 'len' characters in 'p' (including NULs) with translation
;; if 'len' is -1, output upto a NUL character.
;; Use attributes 'attr'.
;; Return the number of characters it takes on the screen.

(defn- #_int msg-outtrans [#_Bytes p]
    (msg-outtrans-attr p, 0))

(defn- #_int msg-outtrans-attr [#_Bytes p, #_int attr]
    (msg-outtrans-len-attr p, (STRLEN p), attr))

(defn- #_int msg-outtrans-len [#_Bytes p, #_int len]
    (msg-outtrans-len-attr p, len, 0))

(defn- #_int msg-outtrans-len-attr [#_Bytes p, #_int len, #_int attr]
    ;; If the string starts with a composing character,
    ;; first draw a space on which the composing char can be drawn.
    (when (utf-iscomposing (us-ptr2char p))
        (msg-puts-attr (u8 " "), attr))
    ;; Go over the string.  Special characters are translated and printed.
    ;; Normal characters are printed several at a time.
    (let [[#_int cells #_Bytes q p]
            (loop-when [cells 0 q p p p len len] (< 0 len) => [cells q p]
                ;; Don't include composing chars after the end.
                (let [#_int l (us-ptr2len-cc-len p, len)]
                    (cond (< 1 l)
                        (let [#_int c (us-ptr2char p)
                              [cells q]
                                (if (vim-isprintc c) ;; printable multi-byte char: count the cells
                                    [(+ cells (us-ptr2cells p)) q]
                                    (do ;; unprintable multi-byte char: print the printable chars
                                        ;; so far and the translation of the unprintable char
                                        (when (BLT q, p)
                                            (msg-puts-attr-len q, (BDIFF p, q), attr))
                                        (msg-puts-attr (transchar c), (if (zero? attr) (hl-attr HLF_8) attr))
                                        [(+ cells (mb-char2cells c)) (.plus p l)])
                                )]
                            (recur cells q (.plus p l) (- len l)))
                    :else
                        (let [#_Bytes s (transchar-byte (.at p 0))
                              [cells q]
                                (if (eos? s 1)
                                    [(inc cells) q]
                                    (do ;; unprintable char: print the printable chars so far
                                        ;; and the translation of the unprintable char
                                        (when (BLT q, p)
                                            (msg-puts-attr-len q, (BDIFF p, q), attr))
                                        (msg-puts-attr s, (if (zero? attr) (hl-attr HLF_8) attr))
                                        [(+ cells (STRLEN s)) (.plus p 1)])
                                )]
                            (recur cells q (.plus p 1) (dec len)))
                    ))
            )]
        (when (BLT q, p)
            ;; print the printable chars at the end
            (msg-puts-attr-len q, (BDIFF p, q), attr))
        cells
    ))

;; Use screen-puts() to output one multi-byte character.
;; Return the pointer "s" advanced to the next character.

(defn- #_Bytes screen-puts-mbyte [#_Bytes s, #_int len, #_int attr]
    (reset! msg_didout true) ;; remember that line is not empty
    (let [#_int cells (us-ptr2cells s)]
        (if (and (< 1 cells) (== @msg_col (dec @Cols)))
            ;; Doesn't fit, print a highlighted '>' to fill it up.
            (do (msg-screen-putchar (byte \>), (hl-attr HLF_AT)) s)
            (do
                (screen-puts-len s, len, @msg_row, @msg_col, attr)
                (swap! msg_col + cells)
                (when (<= @Cols @msg_col)
                    (reset! msg_col 0)
                    (swap! msg_row inc))
                (.plus s len)
            ))
    ))

;; Output a string to the screen at position msg_row, msg_col.
;; Update msg_row and msg_col for the next message.

(defn- #_void msg-puts [#_Bytes s]
    (msg-puts-attr s, 0)
    nil)

(defn- #_void msg-puts-title [#_Bytes s]
    (msg-puts-attr s, (hl-attr HLF_T))
    nil)

;; Basic function for writing a message with highlight attributes.

(defn- #_void msg-puts-attr [#_Bytes s, #_int attr]
    (msg-puts-attr-len s, -1, attr)
    nil)

;; Like msg-puts-attr(), but with a maximum length "maxlen" (in bytes).
;; When "maxlen" is -1 there is no maximum length.
;; When "maxlen" is >= 0 the message is not put in the history.

(defn- #_void msg-puts-attr-len [#_Bytes str, #_int maxlen, #_int attr]
    ;; When writing something to the screen after it has scrolled, requires
    ;; a wait-return() prompt later.  Needed when scrolling, resetting need_wait_return
    ;; after some prompt, and then outputting something without scrolling.

    (when (non-zero? @msg_scrolled)
        (reset! need_wait_return true))
    (reset! msg_didany true) ;; remember that something was outputted

    ;; If there is no valid screen, use fprintf so we can see error messages.
    ;; If termcap is not active, we may be writing in an alternate console window,
    ;; cursor positioning may not work correctly (window size may be different,
    ;; e.g. for Win32 console) or we just don't know where the cursor is.

    (if (msg-use-printf)
        (msg-puts-printf str, maxlen)
        (msg-puts-display str, maxlen, attr, false))
    nil)

;; The display part of msg-puts-attr-len().
;; May be called recursively to display scroll-back text.

(defn- #_void msg-puts-display [#_Bytes str, #_int maxlen, #_int attr, #_boolean recurse]
    (reset! did_wait_return false)
    (let-when [[#_int t_col #_Bytes t_s #_Bytes s :as _]
            (loop-when [t_col 0 t_s str s str] (and (or (< maxlen 0) (< (BDIFF s, str) maxlen)) (non-eos? s)) => [t_col t_s s]
                ;; We are at the end of the screen line when: outputting a newline; outputting a character in the last column.
                (let [[t_col s _]
                        (if (and (not recurse)
                                 (<= (dec @Rows) @msg_row)
                                 (or (at? s (byte \newline))
                                     (<= (dec @Cols) (+ @msg_col t_col))
                                     (and (at? s TAB) (<= (& (dec @Cols) (bit-not 7)) (+ @msg_col t_col)))
                                     (and (< 1 (us-ptr2cells s)) (<= (- @Cols 2) (+ @msg_col t_col)))))
                                  ;; output any postponed text
                            (let [t_col (if (< 0 t_col) (t-puts t_col, t_s, s, attr) t_col)]
                                ;; When no more prompt and no more room, truncate here.
                                (if (and @msg_no_more (zero? @lines_left))
                                    [t_col s :break]
                                    (do ;; Scroll the screen up one line.
                                        (msg-scroll-up)
                                        (reset! msg_row (- @Rows 2))
                                        (when (<= @Cols @msg_col)     ;; can happen after screen resize
                                            (reset! msg_col (dec @Cols)))
                                        ;; Display char in last column before showing more-prompt.
                                        (let [[s #_boolean did_last_char]
                                                (if (<= (byte \space) (.at s 0))
                                                    (let [#_int len
                                                            (if (<= 0 maxlen) ;; avoid including composing chars after the end
                                                                (us-ptr2len-cc-len s, (BDIFF (.plus str maxlen), s))
                                                                (us-ptr2len-cc s)
                                                            )]
                                                        [(screen-puts-mbyte s, len, attr) true])
                                                    [s false]
                                                )]
                                            (swap! msg_scrolled inc)
                                            (reset! need_wait_return true)    ;; may need wait-return() in main()
                                            (when (< @must_redraw VALID)
                                                (reset! must_redraw VALID))
                                            (reset! redraw_cmdline true)
                                            (when (< 0 @cmdline_row)
                                                (swap! cmdline_row dec))
                                            ;; If screen is completely filled and 'more' is set, then wait for a character.
                                            (when (< 0 @lines_left)
                                                (swap! lines_left dec))
                                            ;; When we displayed a char in last column need to check if there is still more.
                                            [t_col s (when did_last_char :continue)]
                                        ))
                                ))
                            [t_col s nil]
                        )]
                    (condp == _
                        :break [t_col t_s s]
                        :return nil
                        :continue (recur t_col t_s s)
                        (let [#_boolean wrap (or (at? s (byte \newline)) (<= @Cols (+ @msg_col t_col)) (and (< 1 (us-ptr2cells s)) (<= (dec @Cols) (+ @msg_col t_col))))
                              ;; output any postponed text
                              t_col (if (and (< 0 t_col) (or wrap (any == (.at s 0) (byte \return) (byte \backspace) TAB BELL))) (t-puts t_col, t_s, s, attr) t_col)
                              [t_col t_s s] (let [t* [t_col t_s (.plus s 1)]]
                                (condp == (.at s 0)
                                    (byte \newline)                                 ;; go to next line
                                        (do (reset! msg_didout false)               ;; remember that line is empty
                                            (reset! msg_col 0)
                                            (when (<= @Rows (swap! msg_row inc))    ;; safety check
                                                (reset! msg_row (dec @Rows)))
                                            t*)
                                    (byte \return)                                  ;; go to column 0
                                        (do (reset! msg_col 0)
                                            t*)
                                    (byte \backspace)                               ;; go to previous char
                                        (do (when (< 0 @msg_col)
                                                (swap! msg_col dec))
                                            t*)
                                    TAB                                             ;; translate Tab into spaces
                                        (do (loop [] (msg-screen-putchar (byte \space), attr) (recur-if (non-zero? (& @msg_col 7)) []))
                                            t*)
                                    BELL                                            ;; beep (from ":sh")
                                        (do (beep)
                                            t*)
                                    (let [#_int cells (us-ptr2cells s)
                                          #_int len (if (<= 0 maxlen) ;; avoid including composing chars after the end
                                                (us-ptr2len-cc-len s, (BDIFF (.plus str maxlen), s))
                                                (us-ptr2len-cc s)
                                            )]
                                        ;; When a double-wide character doesn't fit, draw a single character here.
                                        ;; Otherwise collect characters and draw them all at once later.
                                        (if (and (< 1 cells) (<= (dec @Cols) (+ @msg_col t_col)))
                                            (let [s (if (< 1 len) (screen-puts-mbyte s, len, attr) (do (msg-screen-putchar (.at s 0), attr) (.plus s 1)))]
                                                [t_col t_s s])
                                            ;; postpone this character until later
                                            (let [t_s (if (zero? t_col) s t_s)]
                                                [(+ t_col cells) t_s (.plus s len)])
                                        ))
                                ))]
                            (recur t_col t_s s)
                        ))
                ))
    ] (some? _)
        ;; output any postponed text
        (when (pos? t_col)
            (t-puts t_col, t_s, s, attr))
        (msg-check))
    nil)

;; Scroll the screen up one line for displaying the next message line.

(defn- #_void msg-scroll-up []
    (let [rows @Rows cols @Cols]
        ;; scrolling up always works
        (screen-del-lines 0, 0, 1, rows, true, nil)

        (when (not (can-clear (u8 " ")))
            ;; Scrolling up doesn't result in the right background.
            ;; Set the background here.  It's not efficient,
            ;; but avoids that we have to do it all over the code.
            (screen-fill (- rows 1), rows, 0, cols, (byte \space), (byte \space), 0)

            ;; Also clear the last char of the last but one line
            ;; if it was not cleared before to avoid a scroll-up.
            (when (== (aget @screenAttrs (+ (aget @lineOffset (- rows 2)) (- cols 1))) -1)
                (screen-fill (- rows 2), (- rows 1), (- cols 1), cols, (byte \space), (byte \space), 0))
        ))
    nil)

;; Output any postponed text for msg-puts-attr-len().

(defn- #_int t-puts [#_int t_col, #_Bytes t_s, #_Bytes s, #_int attr]
    (reset! msg_didout true)          ;; remember that line is not empty
    (screen-puts-len t_s, (BDIFF s, t_s), @msg_row, @msg_col, attr)
    ;; If the string starts with a composing character, don't increment the column position for it.
    (let [n (if (utf-iscomposing (us-ptr2char t_s)) (dec t_col) t_col)]
        (swap! msg_col + n))
    (when (<= @Cols @msg_col)
        (reset! msg_col 0)
        (swap! msg_row inc))
    0)

;; Returns true when messages should be printed with mch_errmsg().
;; This is used when there is no valid screen, so we can see error messages.
;; If termcap is not active, we may be writing in an alternate console window,
;; cursor positioning may not work correctly (window size may be different)
;; or we just don't know where the cursor is.

(defn- #_boolean msg-use-printf []
    (or (not (msg-check-screen)) (and (swapping-screen) (not @termcap_active))))

;; Print a message when there is no valid screen.

(defn- #_void msg-puts-printf [#_Bytes s, #_int maxlen]
    (let [#_Bytes buf (Bytes. 3)]
        (loop-when-recur [#_int i 0] (and (non-eos? s i) (or (< maxlen 0) (< i maxlen))) [(inc i)]
            (let [#_int n 0 ;; NL --> CR NL translation (for Unix, not for "--version")
                  n (if (and (at? s i (byte \newline)) (not @info_message)) (do (.be buf n, (byte \return)) (inc n)) n)]
                (-> buf (.be n, (.at s i)) (eos! (inc n)))
                (if @info_message ;; informative message, not an error
                    (ร .fprintf libC stdout, (u8 "%s"), buf)
                    (ร .fprintf libC stderr, (u8 "%s"), buf))
                ;; primitive way to compute the current column
                (if (or (at? s i (byte \return)) (at? s i (byte \newline)))
                    (reset! msg_col 0)
                    (swap! msg_col inc))
            )))
    (reset! msg_didout true) ;; assume that line is not empty
    nil)

;; Put a character on the screen at the current message position and advance to the next position.
;; Only for printable ASCII!

(defn- #_void msg-screen-putchar [#_int c, #_int attr]
    (reset! msg_didout true) ;; remember that line is not empty
    (screen-putchar c, @msg_row, @msg_col, attr)
    (when (<= @Cols (swap! msg_col inc))
        (reset! msg_col 0)
        (swap! msg_row inc))
    nil)

;; Check if the screen is initialized.
;; Also check msg_row and msg_col, if they are too big it may cause a crash.
;; While starting the GUI the terminal codes will be set for the GUI, but the
;; output goes to the terminal.  Don't use the terminal codes then.

(defn- #_boolean msg-check-screen []
    (and (and @full_screen (screen-valid false))
        (do (swap! msg_row min (dec @Rows))
            (swap! msg_col min (dec @Cols))
            true)
    ))

;; Clear from current message position to end of screen.
;; Skip this when ":silent" was used, no need to clear for redirection.

(defn- #_void msg-clr-eos []
    (msg-clr-eos-force)
    nil)

;; Clear from current message position to end of screen.
;; Note: msg_col is not updated, so we remember the end of the message for msg-check().

(defn- #_void msg-clr-eos-force []
    (if (msg-use-printf)
        (when @full_screen ;; only when termcap codes are valid
            (cond
                (non-eos? @T_CD) (out-str @T_CD)  ;; clear to end of display
                (non-eos? @T_CE) (out-str @T_CE)  ;; clear to end of line
            ))
        (do
            (screen-fill @msg_row, (inc @msg_row), @msg_col, @Cols, (byte \space), (byte \space), 0)
            (screen-fill (inc @msg_row), @Rows, 0, @Cols, (byte \space), (byte \space), 0)
        ))
    nil)

;; Clear the command line.

(defn- #_void msg-clr-cmdline []
    (reset! msg_row @cmdline_row)
    (reset! msg_col 0)
    (msg-clr-eos-force)
    nil)

;; End putting a message on the screen.
;; Call wait-return() if the message does not fit in the available space.
;; Return true if wait-return() not called.

(defn- #_[window_C boolean] msg-end? [#_window_C win]
    ;; If the string is larger than the window, or the ruler option is set and we run into it, we have to redraw the window.
    ;; Do not do this if we are abandoning the file or editing the command line.
    (if (and (not @exiting) @need_wait_return (non-flag? @State CMDLINE))
        [(wait-return win, FALSE) false]
        (do (out-flush) [win true])
    ))

;; If the written message runs into the shown command or ruler, we have to wait for hit-return and redraw the window later.

(defn- #_void msg-check []
    (when (and (== @msg_row (dec @Rows)) (<= @sc_col @msg_col))
        (reset! need_wait_return true)
        (reset! redraw_cmdline true))
    nil)

;; Give a warning message (for searching).
;; Use 'w' highlighting and may repeat the message after redrawing.

(defn- #_window_C give-warning [#_window_C win, #_Bytes message, #_boolean hl?]
    ;; Don't want a hit-enter prompt here.
    (let [_ (swap! no_wait_return inc)
          _ (reset! keep_msg nil)
          _ (reset! keep_msg_attr (if hl? (hl-attr HLF_W) 0))
          [win ?] (msg-attr? win, message, @keep_msg_attr)
          _ (when (and ? (zero? @msg_scrolled))
                (set-keep-msg message, @keep_msg_attr))
          _ (reset! msg_didout false)   ;; overwrite this message
          _ (reset! msg_nowait true)    ;; don't wait for this message
          _ (reset! msg_col 0)
          _ (swap! no_wait_return dec)]
        win
    ))

;; Code to handle user-settable options.  This is all pretty much table-
;; driven.  Checklist for adding a new option:
;; - Put it in the options array below (copy an existing entry).
;; - For a global option: Add a variable for it in option.h.
;; - For a buffer or window local option:
;;   - Add a PV_XX entry to the enum below.
;;   - Add a variable to the window or buffer struct in structs.h.
;;   - For a window option, add some code to copy-winopt().
;; - If it's a numeric option, add any necessary bounds checks to do-set().
;; - If it's a list of flags, add some code in do-set(), search for WW_ALL.
;; When making changes:
;; - When an entry has the P_VIM flag, or is lacking the P_VI_DEF flag,
;;   add a comment at the help for the 'compatible' option.

;; The options that are local to a window or buffer have "indir" set to
;; one of these values.  Special values:
;; 0: global option.
;; PV_WIN is added: window-local option.
;; PV_BUF is added: buffer-local option.

(final int
    PV_WIN  0x2000,
    PV_BUF  0x4000)

;; Definition of the PV_ values for buffer-local options.
;; The BV_ values are defined in option.h.

(final int
    PV_AI   (| BV_AI   PV_BUF),
    PV_CI   (| BV_CI   PV_BUF),
    PV_CINW (| BV_CINW PV_BUF),
    PV_ET   (| BV_ET   PV_BUF),
    PV_ISK  (| BV_ISK  PV_BUF),
    PV_KP   (| BV_KP   PV_BUF),
    PV_MOD  (| BV_MOD  PV_BUF),
    PV_MPS  (| BV_MPS  PV_BUF),
    PV_NF   (| BV_NF   PV_BUF),
    PV_PI   (| BV_PI   PV_BUF),
    PV_QE   (| BV_QE   PV_BUF),
    PV_SI   (| BV_SI   PV_BUF),
    PV_STS  (| BV_STS  PV_BUF),
    PV_SW   (| BV_SW   PV_BUF),
    PV_TS   (| BV_TS   PV_BUF),
    PV_UL   (| BV_UL   PV_BUF))

;; Definition of the PV_ values for window-local options.
;; The WV_ values are defined in option.h.

(final int
    PV_BRI    (| WV_BRI    PV_WIN),
    PV_BRIOPT (| WV_BRIOPT PV_WIN),
    PV_LBR    (| WV_LBR    PV_WIN),
    PV_NU     (| WV_NU     PV_WIN),
    PV_RNU    (| WV_RNU    PV_WIN),
    PV_NUW    (| WV_NUW    PV_WIN),
    PV_SCROLL (| WV_SCROLL PV_WIN),
    PV_CUC    (| WV_CUC    PV_WIN),
    PV_CUL    (| WV_CUL    PV_WIN),
    PV_CC     (| WV_CC     PV_WIN),
    PV_WFH    (| WV_WFH    PV_WIN),
    PV_WFW    (| WV_WFW    PV_WIN),
    PV_WRAP   (| WV_WRAP   PV_WIN))

(class! #_final vimoption_C
    [
        (field Bytes    fullname)   ;; full option name
        (field Bytes    shortname)  ;; permissible abbreviation
        (field long     flags)      ;; see below
        (field Object   var)        ;; pointer to variable
        (field int      indir)      ;; indirect option index
        (field Object   def_val)    ;; default value for variable
    ])

;; Flags

(final int P_BOOL               0x01)   ;; the option is boolean
(final int P_NUM                0x02)   ;; the option is numeric
(final int P_STRING             0x04)   ;; the option is a string

                                        ;; when option changed, what to display:
(final int P_RSTAT            0x1000)   ;; redraw status lines
(final int P_RWIN             0x2000)   ;; redraw current window
(final int P_RBUF             0x4000)   ;; redraw current buffer
(final int P_RALL             0x6000)   ;; redraw all windows
(final int P_RCLR             0x7000)   ;; clear and redraw all

(final int P_COMMA            0x8000)   ;; comma separated list
(final int P_NODUP           0x10000)   ;; don't allow duplicate strings
(final int P_FLAGLIST        0x20000)   ;; list of single-char flags

(final int P_CURSWANT      0x2000000)   ;; update curswant required; not needed when there is a redraw flag

(defn- #_vimoption_C bool-opt [#_Bytes fname, #_Bytes sname, #_long flags, #_boolean' var, #_int indir, #_boolean def]
    (vimoption_C. fname, sname, (| P_BOOL flags), var, indir, def))

(defn- #_vimoption_C long-opt [#_Bytes fname, #_Bytes sname, #_long flags, #_long' var, #_int indir, #_long def]
    (vimoption_C. fname, sname, (| P_NUM flags), var, indir, def))

(defn- #_vimoption_C utf8-opt [#_Bytes fname, #_Bytes sname, #_long flags, #_Bytes' var, #_int indir, #_Bytes def]
    (vimoption_C. fname, sname, (| P_STRING flags), var, indir, def))

;; vimoptions[] are initialized here.
;;
;; The order of the options MUST be alphabetic for ":set all" and findoption().
;; All option names MUST start with a lowercase letter (for findoption()).

(final vimoption_C* vimoptions
    [
        (bool-opt (u8 "autoindent"),     (u8 "ai"),        0,                           nil,         PV_AI,      false),
        (utf8-opt (u8 "backspace"),      (u8 "bs"),     (| P_COMMA P_NODUP),            p_bs,        0,         (u8 "")),
        (utf8-opt (u8 "breakat"),        (u8 "brk"),    (| P_RALL P_FLAGLIST),          p_breakat,   0,         (u8 " \t!@*-+;:,./?")),
        (bool-opt (u8 "breakindent"),    (u8 "bri"),       P_RWIN,                      nil,         PV_BRI,     false),
        (utf8-opt (u8 "breakindentopt"), (u8 "briopt"), (| P_RBUF P_COMMA P_NODUP),     nil,         PV_BRIOPT, (u8 "")),
        (utf8-opt (u8 "cinwords"),       (u8 "cinw"),   (| P_COMMA P_NODUP),            nil,         PV_CINW,   (u8 "if,else,while,do,for,switch")),
        (long-opt (u8 "cmdheight"),      (u8 "ch"),        P_RALL,                      p_ch,        0,          1),
        (long-opt (u8 "cmdwinheight"),   (u8 "cwh"),       0,                           p_cwh,       0,          7),
        (utf8-opt (u8 "colorcolumn"),    (u8 "cc"),     (| P_COMMA P_NODUP P_RWIN),     nil,         PV_CC,     (u8 "")),
        (bool-opt (u8 "copyindent"),     (u8 "ci"),        0,                           nil,         PV_CI,      false),
        (utf8-opt (u8 "cpoptions"),      (u8 "cpo"),    (| P_RALL P_FLAGLIST),          p_cpo,       0,          CPO_VIM),
        (bool-opt (u8 "cursorcolumn"),   (u8 "cuc"),       P_RWIN,                      nil,         PV_CUC,     false),
        (bool-opt (u8 "cursorline"),     (u8 "cul"),       P_RWIN,                      nil,         PV_CUL,     false),
        (bool-opt (u8 "delcombine"),     (u8 "deco"),      0,                           p_deco,      0,          false),
        (bool-opt (u8 "digraph"),        (u8 "dg"),        0,                           p_dg,        0,          false),
        (utf8-opt (u8 "display"),        (u8 "dy"),     (| P_COMMA P_RALL P_NODUP),     p_dy,        0,         (u8 "")),
        (utf8-opt (u8 "eadirection"),    (u8 "ead"),       0,                           p_ead,       0,         (u8 "both")),
        (bool-opt (u8 "equalalways"),    (u8 "ea"),        P_RALL,                      p_ea,        0,          true),
        (bool-opt (u8 "errorbells"),     (u8 "eb"),        0,                           p_eb,        0,          false),
        (bool-opt (u8 "esckeys"),        (u8 "ek"),        0,                           p_ek,        0,          true),
        (bool-opt (u8 "expandtab"),      (u8 "et"),        0,                           nil,         PV_ET,      false),
        (bool-opt (u8 "gdefault"),       (u8 "gd"),        0,                           p_gd,        0,          false),
        (long-opt (u8 "history"),        (u8 "hi"),        0,                           p_hi,        0,          50),
        (bool-opt (u8 "hlsearch"),       (u8 "hls"),       P_RALL,                      p_hls,       0,          false),
        (bool-opt (u8 "ignorecase"),     (u8 "ic"),        0,                           p_ic,        0,          false),
        (bool-opt (u8 "incsearch"),      (u8 "is"),        0,                           p_is,        0,          false),
        (bool-opt (u8 "insertmode"),     (u8 "im"),        0,                           p_im,        0,          false),
        (utf8-opt (u8 "isfname"),        (u8 "isf"),    (| P_COMMA P_NODUP),            p_isf,       0,         (u8 "@,48-57,/,.,-,_,+,,,#,$,%,~,=")),
        (utf8-opt (u8 "isident"),        (u8 "isi"),    (| P_COMMA P_NODUP),            p_isi,       0,         (u8 "@,48-57,_,192-255")),
        (utf8-opt (u8 "iskeyword"),      (u8 "isk"),    (| P_COMMA P_NODUP),            nil,         PV_ISK,    (u8 "@,48-57,_,192-255")),
        (utf8-opt (u8 "isprint"),        (u8 "isp"),    (| P_RALL P_COMMA P_NODUP),     p_isp,       0,         (u8 "@,161-255")),
        (bool-opt (u8 "joinspaces"),     (u8 "js"),        0,                           p_js,        0,          true),
        (utf8-opt (u8 "keymodel"),       (u8 "km"),     (| P_COMMA P_NODUP),            p_km,        0,         (u8 "")),
        (utf8-opt (u8 "keywordprg"),     (u8 "kp"),        0,                           nil,         PV_KP,     (u8 ":echo")),
        (long-opt (u8 "laststatus"),     (u8 "ls"),        P_RALL,                      p_ls,        0,          1),
        (bool-opt (u8 "lazyredraw"),     (u8 "lz"),        0,                           p_lz,        0,          false),
        (bool-opt (u8 "linebreak"),      (u8 "lbr"),       P_RWIN,                      nil,         PV_LBR,     false),
        (bool-opt (u8 "magic"),           nil,             0,                           p_magic,     0,          true),
        (utf8-opt (u8 "matchpairs"),     (u8 "mps"),    (| P_COMMA P_NODUP),            nil,         PV_MPS,    (u8 "(:),{:},[:]")),
        (long-opt (u8 "matchtime"),      (u8 "mat"),       0,                           p_mat,       0,          5),
        (long-opt (u8 "maxcombine"),     (u8 "mco"),       P_CURSWANT,                  p_mco,       0,          2),
        (long-opt (u8 "maxmempattern"),  (u8 "mmp"),       0,                           p_mmp,       0,          1000),
        (bool-opt (u8 "modified"),       (u8 "mod"),       P_RSTAT,                     nil,         PV_MOD,     false),
        (utf8-opt (u8 "nrformats"),      (u8 "nf"),     (| P_COMMA P_NODUP),            nil,         PV_NF,     (u8 "octal,hex")),
        (bool-opt (u8 "number"),         (u8 "nu"),        P_RWIN,                      nil,         PV_NU,      false),
        (long-opt (u8 "numberwidth"),    (u8 "nuw"),       P_RWIN,                      nil,         PV_NUW,     4),
        (utf8-opt (u8 "operatorfunc"),   (u8 "opfunc"),    0,                           p_opfunc,    0,         (u8 "")),
        (bool-opt (u8 "paste"),           nil,             0,                           p_paste,     0,          false),
        (bool-opt (u8 "preserveindent"), (u8 "pi"),        0,                           nil,         PV_PI,      false),
        (bool-opt (u8 "prompt"),          nil,             0,                           p_prompt,    0,          true),
        (utf8-opt (u8 "quoteescape"),    (u8 "qe"),        0,                           nil,         PV_QE,     (u8 "\\")),
        (long-opt (u8 "redrawtime"),     (u8 "rdt"),       0,                           p_rdt,       0,          2000),
        (long-opt (u8 "regexpengine"),   (u8 "re"),        0,                           p_re,        0,          0),
        (bool-opt (u8 "relativenumber"), (u8 "rnu"),       P_RWIN,                      nil,         PV_RNU,     false),
        (long-opt (u8 "report"),          nil,             0,                           p_report,    0,          2),
        (bool-opt (u8 "ruler"),          (u8 "ru"),        P_RSTAT,                     p_ru,        0,          false),
        (long-opt (u8 "scroll"),         (u8 "scr"),       0,                           nil,         PV_SCROLL,  1),
        (long-opt (u8 "scrolljump"),     (u8 "sj"),        0,                           p_sj,        0,          1),
        (long-opt (u8 "scrolloff"),      (u8 "so"),        P_RALL,                      p_so,        0,          0),
        (utf8-opt (u8 "selection"),      (u8 "sel"),       0,                           p_sel,       0,         (u8 "inclusive")),
        (utf8-opt (u8 "selectmode"),     (u8 "slm"),    (| P_COMMA P_NODUP),            p_slm,       0,         (u8 "")),
        (bool-opt (u8 "shiftround"),     (u8 "sr"),        0,                           p_sr,        0,          false),
        (long-opt (u8 "shiftwidth"),     (u8 "sw"),        0,                           nil,         PV_SW,      8),
        (utf8-opt (u8 "showbreak"),      (u8 "sbr"),       P_RALL,                      p_sbr,       0,         (u8 "")),
        (bool-opt (u8 "showcmd"),        (u8 "sc"),        0,                           p_sc,        0,          false),
        (bool-opt (u8 "showmatch"),      (u8 "sm"),        0,                           p_sm,        0,          false),
        (bool-opt (u8 "showmode"),       (u8 "smd"),       0,                           p_smd,       0,          true),
        (long-opt (u8 "sidescroll"),     (u8 "ss"),        0,                           p_ss,        0,          0),
        (long-opt (u8 "sidescrolloff"),  (u8 "siso"),      P_RBUF,                      p_siso,      0,          0),
        (bool-opt (u8 "smartcase"),      (u8 "scs"),       0,                           p_scs,       0,          false),
        (bool-opt (u8 "smartindent"),    (u8 "si"),        0,                           nil,         PV_SI,      false),
        (bool-opt (u8 "smarttab"),       (u8 "sta"),       0,                           p_sta,       0,          false),
        (long-opt (u8 "softtabstop"),    (u8 "sts"),       0,                           nil,         PV_STS,     0),
        (bool-opt (u8 "splitbelow"),     (u8 "sb"),        0,                           p_sb,        0,          false),
        (bool-opt (u8 "splitright"),     (u8 "spr"),       0,                           p_spr,       0,          false),
        (bool-opt (u8 "startofline"),    (u8 "sol"),       0,                           p_sol,       0,          true),
        (long-opt (u8 "tabstop"),        (u8 "ts"),        P_RBUF,                      nil,         PV_TS,      8),
        (bool-opt (u8 "tildeop"),        (u8 "top"),       0,                           p_to,        0,          false),
        (bool-opt (u8 "timeout"),        (u8 "to"),        0,                           p_timeout,   0,          true),
        (long-opt (u8 "timeoutlen"),     (u8 "tm"),        0,                           p_tm,        0,          1000),
        (bool-opt (u8 "ttimeout"),        nil,             0,                           p_ttimeout,  0,          false),
        (long-opt (u8 "ttimeoutlen"),    (u8 "ttm"),       0,                           p_ttm,       0,          -1),
        (long-opt (u8 "ttyscroll"),      (u8 "tsl"),       0,                           p_ttyscroll, 0,          999),
        (long-opt (u8 "undolevels"),     (u8 "ul"),        0,                           nil,         PV_UL,      1000),
        (long-opt (u8 "updatetime"),     (u8 "ut"),        0,                           p_ut,        0,          4000),
        (long-opt (u8 "verbose"),        (u8 "vbs"),       0,                           p_verbose,   0,          0),
        (utf8-opt (u8 "virtualedit"),    (u8 "ve"),     (| P_COMMA P_NODUP P_CURSWANT), p_ve,        0,         (u8 "")),
        (bool-opt (u8 "visualbell"),     (u8 "vb"),        0,                           p_vb,        0,          false),
        (utf8-opt (u8 "whichwrap"),      (u8 "ww"),     (| P_COMMA P_FLAGLIST),         p_ww,        0,         (u8 "b,s")),
        (long-opt (u8 "winheight"),      (u8 "wh"),        0,                           p_wh,        0,          1),
        (bool-opt (u8 "winfixheight"),   (u8 "wfh"),       P_RSTAT,                     nil,         PV_WFH,     false),
        (bool-opt (u8 "winfixwidth"),    (u8 "wfw"),       P_RSTAT,                     nil,         PV_WFW,     false),
        (long-opt (u8 "winminheight"),   (u8 "wmh"),       0,                           p_wmh,       0,          1),
        (long-opt (u8 "winminwidth"),    (u8 "wmw"),       0,                           p_wmw,       0,          1),
        (long-opt (u8 "winwidth"),       (u8 "wiw"),       0,                           p_wiw,       0,          20),
        (bool-opt (u8 "wrap"),            nil,             P_RWIN,                      nil,         PV_WRAP,    true),
        (bool-opt (u8 "wrapscan"),       (u8 "ws"),        0,                           p_ws,        0,          true),
        (long-opt (u8 "writedelay"),     (u8 "wd"),        0,                           p_wd,        0,          0),
    ])

(final Bytes*
    p_nf_values  [ (u8 "octal"), (u8 "hex"), (u8 "alpha"), nil ],
    p_sel_values [ (u8 "inclusive"), (u8 "exclusive"), (u8 "old"), nil ],
    p_slm_values [ (u8 "key"), (u8 "cmd"), nil ],
    p_km_values  [ (u8 "startsel"), (u8 "stopsel"), nil ],
    p_ead_values [ (u8 "both"), (u8 "ver"), (u8 "hor"), nil ],
    p_bs_values  [ (u8 "indent"), (u8 "eol"), (u8 "start"), nil ])

;; Initialize the options, first part.
;;
;; Called only once from main(), just after creating the first buffer.

(defn- #_window_C set-init-1 [#_window_C win]
    ;; Set all the options (except the terminal options) to their default value.
    ;; Also set the global value for local options.
    (set-options-default win)
    (let [win (didset-options win)]
        (fill-breakat-flags)
        (init-chartab true)
        (screen-alloc false)
        win
    ))

;; Set an option to its default value.
;; This does not take care of side effects!

(defn- #_void set-option-default [#_window_C win, #_vimoption_C v]
    (let [#_Object' varp (get-varp win, v)]
        (cond
            (flag? (:flags v) P_STRING)                                                  (reset! varp (STRDUP (#_Bytes object (:def_val v))))
            (flag? (:flags v) P_NUM) (if (== (:indir v) PV_SCROLL) (win-comp-scroll win) (reset! varp (long (:def_val v))))
            (flag? (:flags v) P_BOOL)                                                    (reset! varp (boolean (:def_val v)))
        ))
    nil)

;; Set all options (except terminal options) to their default value.

(defn- #_void set-options-default [#_window_C win]
    (doseq [#_vimoption_C v vimoptions]
        (set-option-default win, v))
    ;; The 'scroll' option must be computed for all windows.
    (loop-when-recur [#_window_C w @firstwin] (some? w) [(:w_next w)]
        (win-comp-scroll w))
    nil)

;; Parse "arg" for option settings.
;;
;; Returns false if an error is detected, true otherwise.

(defn- #_[window_C boolean] do-set? [#_window_C win, #_Bytes arg]           ;; arg: option string (may be written to!)
    (let [a'did_show (atom (boolean false))]                                ;; already showed one value
        (loop-when [win win arg arg] (non-eos? arg) => [win true]           ;; loop to process all options
            (let-when [#_Bytes startarg arg                                 ;; remember for error message
                  [#_int prefix arg]                                        ;; 1: nothing, 0: "no", 2: "inv" in front of name
                    (cond
                        (zero? (STRNCMP arg, (u8 "no"), 2))  [0 (.plus arg 2)]
                        (zero? (STRNCMP arg, (u8 "inv"), 3)) [2 (.plus arg 3)]
                        :else                                [1 arg]
                    )
                  [win arg #_Bytes errmsg]
                    (if (at? arg (byte \<))
                        [win arg e_invarg]

                        (let-when [#_int x (loop-when-recur [x 0] (or (asc-isalnum (.at arg x)) (at? arg x (byte \_))) [(inc x)] => x)
                              #_int nextchar (.at arg x)                        ;; next non-white char after option name
                              _ (eos! arg x)                                    ;; put NUL after name
                              #_vimoption_C v (findoption arg)
                              _ (.be arg x, nextchar)                           ;; restore nextchar
                        ] (some? v) => [win arg (u8 "E518: Unknown option")]    ;; found a mismatch: skip

                            (let-when [#_byte afterchar (.at arg x)             ;; remember character after option name
                                  ;; skip white space, allow ":set ai  ?"
                                  x (loop-when-recur x (vim-iswhite (.at arg x)) (inc x) => x)
                                  nextchar (.at arg x)
                            ] (or (== nextchar NUL) (not-at? arg (inc x) (byte \=))) => [win arg e_invarg]

                                (let-when [[arg ?]
                                        (if (some? (vim-strchr (u8 "?=:!&<"), nextchar))
                                            (let [arg (.plus arg x)]
                                                [arg (when (and (some? (vim-strchr (u8 "?!&<"), nextchar)) (non-eos? arg 1) (not (vim-iswhite (.at arg 1)))) e_trailing)])
                                            [arg nil])
                                ] (not ?) => [win arg ?]

                                    (let [#_Object' varp (get-varp win, v)]
                                        (cond (or (== nextchar (byte \?)) (and (== prefix 1) (nil? (vim-strchr (u8 "=:&<"), nextchar)) (non-flag? (:flags v) P_BOOL)))
                                            (do ;; print value
                                                (if @a'did_show
                                                    (msg-putchar (byte \newline))   ;; cursor below last one
                                                    (do (gotocmdline true)          ;; cursor at status line
                                                        (reset! a'did_show true)    ;; remember that we did a line
                                                    ))
                                                (showoneopt win, v)
                                                [win arg (when (and (!= nextchar (byte \?)) (!= nextchar NUL) (not (vim-iswhite afterchar))) e_trailing)])

                                        (flag? (:flags v) P_BOOL)
                                            (if (any == nextchar (byte \=) (byte \:) (byte \<))
                                                [win arg e_invarg]

                                                ;; ":set opt!": invert
                                                ;; ":set opt&": reset to default value
                                                (let-when [[#_boolean value ?]
                                                        (condp == nextchar
                                                            (byte \!) [(not (boolean @varp)) nil]
                                                            (byte \&) [(boolean (:def_val v)) nil]
                                                            ;; ":set invopt": invert
                                                            ;; ":set opt" or ":set noopt": set or reset
                                                            (if (and (!= nextchar NUL) (not (vim-iswhite afterchar)))
                                                                [nil e_trailing]
                                                                [(if (== prefix 2) (not (boolean @varp)) (!= prefix 0)) nil]
                                                            ))
                                                ] (not ?) => [win arg ?]

                                                    (let [[win ?] (set-bool-option? win, v, #_boolean' varp, value)] [win arg ?])
                                                ))

                                        (or (nil? (vim-strchr (u8 "=:&"), nextchar)) (!= prefix 1))
                                            [win arg e_invarg]

                                        (flag? (:flags v) P_NUM)
                                            (let-when [arg (.plus arg 1)
                                                  ;; Different ways to set a number option:
                                                  ;; &        set to default value
                                                  ;; [-]0-9   set number
                                                  ;; other    error
                                                  [#_long value ?]
                                                    (cond (== nextchar (byte \&))
                                                        [(long (:def_val v)) nil]
                                                    (or (at? arg (byte \-)) (asc-isdigit (.at arg 0)))
                                                        ;; Allow negative (for 'undolevels'), octal and hex numbers.
                                                        (let [a'i (atom (int)) value (let [__ (atom (long))] (vim-str2nr arg, nil, a'i, true, true, __) @__)]
                                                            (if (and (non-eos? arg @a'i) (not (vim-iswhite (.at arg @a'i))))
                                                                [nil e_invarg]
                                                                [value nil]
                                                            ))
                                                    :else
                                                        [nil (u8 "E521: Number required after =")])
                                            ] (not ?) => [win arg ?]

                                                (let [[win ?] (set-num-option? win, v, #_long' varp, value)] [win arg ?]))

                                        :else ;; (flag? (:flags v) P_STRING)
                                            (let [o'value #_Bytes @varp
                                                  [#_Bytes value arg]
                                                    (if (== nextchar (byte \&)) ;; set to default val
                                                        [(STRDUP #_Bytes (:def_val v)) arg]

                                                        (let [arg (.plus arg 1) ;; jump to after the '=' or ':'
                                                              ;; Set 'keywordprg' to ":echo" if an empty value was passed to :set by the user.
                                                              [o'arg arg]
                                                                (if (and (== varp (:b_p_kp @curbuf)) (or (eos? arg) (at? arg (byte \space))))
                                                                    [arg (u8 ":echo")]
                                                                    [nil arg])
                                                              value (Bytes. (inc (STRLEN arg)))
                                                              ;; Copy the string, skip over escaped chars.
                                                              arg (loop-when [#_Bytes s value arg arg] (and (non-eos? arg) (not (vim-iswhite (.at arg 0)))) => (do (eos! s) arg)
                                                                    (let [arg (if (and (at? arg (byte \\)) (non-eos? arg 1)) (.plus arg 1) arg) ;; remove backslash
                                                                          #_int i (us-ptr2len-cc arg)]
                                                                        (if (< 1 i) ;; copy multi-byte char
                                                                            (do (BCOPY s, arg, i)      (recur (.plus s i) (.plus arg i)))
                                                                            (do (.be s 0, (.at arg 0)) (recur (.plus s 1) (.plus arg 1)))
                                                                        ))
                                                                )]
                                                            ;; Locate "value" in "o'value" when removing it and when adding to avoid duplicates.
                                                            (when (flag? (:flags v) P_NODUP)
                                                                (let [#_int n (STRLEN value) comma? (flag? (:flags v) P_COMMA)]
                                                                    (loop-when [#_int bs 0 #_Bytes s o'value] (non-eos? s)
                                                                        (when-not (and (or (not comma?) (BEQ s, o'value) (and (at? s -1 (byte \,)) (zero? (& bs 1))))
                                                                                       (zero? (STRNCMP s, value, n))
                                                                                       (or (not comma?) (at? s n (byte \,)) (eos? s n)))
                                                                            ;; Count backslashes.
                                                                            ;; Only a comma with an even number of backslashes before it is recognized as a separator.
                                                                            (recur (if (and (BLT o'value, s) (at? s -1 (byte \\))) (inc bs) 0) (.plus s 1))
                                                                        ))
                                                                ))
                                                            (when (flag? (:flags v) P_FLAGLIST)
                                                                (let [comma? (flag? (:flags v) P_COMMA)]
                                                                    ;; Remove flags that appear twice.
                                                                    (loop-when [#_Bytes s value] (non-eos? s)
                                                                        (if (and (not (and comma? (at? s (byte \,)))) (some? (vim-strbyte (.plus s 1), (.at s 0))))
                                                                            (do (BCOPY s, 0, s, 1, (inc (STRLEN s, 1))) (recur s))
                                                                            (recur (.plus s 1))
                                                                        ))
                                                                ))
                                                            [value (if (some? o'arg) o'arg arg)])
                                                    )]
                                                ;; Set the new value.
                                                (reset! #_Bytes' varp value)
                                                ;; Handle side effects, and set the global value for ":set" on local options.
                                                (let [[win ?] (did-set-string-option? win, v, #_Bytes' varp, o'value)] [win arg ?]))
                                        ))
                                ))
                        ))
                  ;; Advance to next argument.
                  ;; - skip until a blank found, taking care of backslashes
                  ;; - skip blanks
                  ;; - skip one "=val" argument
                  arg (loop-when [arg arg #_int i 0] (< i 2) => arg
                        (let [arg (loop-when arg (and (non-eos? arg) (not (vim-iswhite (.at arg 0)))) => arg
                                    (let [arg (.plus arg 1)]
                                        (recur (if (and (at? arg -1 (byte \\)) (non-eos? arg)) (.plus arg 1) arg))
                                    ))
                              arg (skipwhite arg)]
                            (recur-if (at? arg (byte \=)) [arg (inc i)] => arg)
                        ))
            ] (some? errmsg) => (recur win (skipwhite arg))

                (let [_ (vim-strncpy ioBuff, errmsg, (dec IOSIZE)) #_int i (+ (STRLEN ioBuff) 2)]
                    (when (< (+ i (BDIFF arg, startarg)) IOSIZE)
                        ;; append the argument with the error
                        (STRCAT ioBuff, (u8 ": "))
                        (BCOPY ioBuff, i, startarg, 0, (BDIFF arg, startarg))
                        (eos! ioBuff (+ i (BDIFF arg, startarg))))
                    ;; make sure all characters are printable
                    (trans-characters ioBuff, IOSIZE)
                    (let [_ (swap! no_wait_return inc) win (emsg win, ioBuff) _ (swap! no_wait_return dec)]
                        [win false]
                    ))
            ))
    ))

(defn- #_Bytes illegal-char [#_int c]
    (let [#_Bytes errbuf (Bytes. 80)]
        (ร .sprintf libC errbuf, (u8 "E539: Illegal character <%s>"), (transchar c))
        errbuf
    ))

;; After setting various option values: recompute variables that depend on option values.

(defn- #_window_C didset-options [#_window_C win]
    ;; initialize the table for 'iskeyword' et al.
    (init-chartab true)

    (opt-strings-flags @p_dy, p_dy_values, dy_flags, true)
    (opt-strings-flags @p_ve, p_ve_values, ve_flags, true)

    (let [[win _] (briopt-check? win)] win))

;; Handle string options that need some action to perform when changed.
;; Returns null for success, or an error message for an error.

(defn- #_[window_C Bytes] did-set-string-option? [#_window_C win, #_vimoption_C v, #_Bytes' varp, #_Bytes oldval]
    (let [a'undo_chartab (atom (boolean false))
          [win #_Bytes errmsg]
            (condp ==? varp

                (:wo_briopt (:w_options win)) ;; 'breakindentopt'
                    (let [[win ?] (briopt-check? win)] [win (when-not ? e_invarg)])

               [p_isi p_isp p_isf (:b_p_isk @curbuf)] ;; 'isident', 'isprint', 'isfname' or 'iskeyword'
                    [win (when-not (init-chartab true) (reset! a'undo_chartab true) e_invarg)]

                (:wo_cc (:w_options win)) ;; 'colorcolumn'
                    (check-colorcolumn? win)

                (:b_p_nf @curbuf) ;; 'nrformats'
                    [win (when-not (check-opt-strings @varp, p_nf_values, true) e_invarg)]

                (:b_p_mps @curbuf) ;; 'matchpairs'
                    (let [? (loop-when [#_Bytes s @varp] (non-eos? s)
                                (let [s (.plus s (us-ptr2len-cc s))
                                      [#_int x2 s] (if (non-eos? s) [(.at s 0) (.plus s 1)] [-1 s])
                                      [#_int x3 s] (if (non-eos? s) [(us-ptr2char s) (.plus s (us-ptr2len-cc s))] [-1 s])]
                                    (cond (or (!= x2 (byte \:)) (== x3 -1) (and (non-eos? s) (not-at? s (byte \,)))) e_invarg (non-eos? s) (recur (.plus s 1)))
                                ))]
                        [win ?])

                p_sbr ;; 'showbreak'
                    (let [? (loop-when [#_Bytes s @p_sbr] (non-eos? s)
                                (recur-if (== (mb-ptr2cells s) 1) [(.plus s (us-ptr2len-cc s))] => (u8 "E595: contains unprintable or wide character"))
                            )]
                        [win ?])

                p_breakat ;; 'breakat'
                    [win (do (fill-breakat-flags) nil)]

                p_sel ;; 'selection'
                    [win (when (or (eos? @p_sel) (not (check-opt-strings @p_sel, p_sel_values, false))) e_invarg)]

                p_slm ;; 'selectmode'
                    [win (when-not (check-opt-strings @p_slm, p_slm_values, true) e_invarg)]

                p_km ;; 'keymodel'
                    (let [? (check-opt-strings @p_km, p_km_values, true)]
                        (when ?
                            (reset! km_stopsel (some? (vim-strchr @p_km, (byte \o))))
                            (reset! km_startsel (some? (vim-strchr @p_km, (byte \a)))))
                        [win (when-not ? e_invarg)])

                p_dy ;; 'display'
                    (let [? (opt-strings-flags @p_dy, p_dy_values, dy_flags, true)]
                        (when ?
                            (init-chartab true))
                        [win (when-not ? e_invarg)])

                p_ead ;; 'eadirection'
                    [win (when-not (check-opt-strings @p_ead, p_ead_values, false) e_invarg)]

                p_bs ;; 'backspace'
                    [win (when-not (check-opt-strings @p_bs, p_bs_values, true) e_invarg)]

                p_ve ;; 'virtualedit'
                    (when' (opt-strings-flags @p_ve, p_ve_values, ve_flags, true) => [win e_invarg]
                        ;; Recompute cursor position in case the new 've' setting changes something.
                        (let [win (when' (non-zero? (STRCMP @p_ve, oldval)) => win
                                    (let [win (validate-virtcol win)]
                                        (coladvance win, (:w_virtcol win))
                                    ))]
                            [win nil]
                        ))

                ;; Options that are a list of flags.
                (let [? (let-when [#_Bytes p (condp == varp p_ww WW_ALL p_cpo CPO_ALL nil)] (some? p)
                            (loop-when [#_Bytes s @varp] (non-eos? s)
                                (recur-if (some? (vim-strchr p, (.at s 0))) [(.plus s 1)] => (illegal-char (.at s 0)))
                            ))]
                    [win ?]
                )
            )]

        ;; If error detected, restore the previous value.
        (when (some? errmsg)
            (reset! varp oldval)
            ;; When resetting some values, need to act on it.
            (when @a'undo_chartab
                (init-chartab true)
            ))

        (let [win (when' (and (!= (:w_curswant win) MAXCOL) (flag? (:flags v) (| P_CURSWANT P_RALL))) => win
                    (assoc win :w_set_curswant true)
                )]
            [(check-redraw win, (:flags v)) errmsg]
        )
    ))

;; Handle setting 'colorcolumn' in window "win".
;; Returns error message, null if it's OK.

(defn- #_[window_C Bytes] check-colorcolumn? [#_window_C win]
    (let-when [#_int* color_cols (int-array 256) #_int n
            (loop-when [#_Bytes s @(:wo_cc (:w_options win)) n 0] (and (non-eos? s) (< n 256)) => n
                (when (asc-isdigit (.at s 0))
                    (let [[#_int c s] (let [__ (atom (#_Bytes object s))] [(getdigits __) @__])
                          _ (aset color_cols n (dec c)) n (inc n)] ;; 1-based to 0-based
                        (cond (eos? s)
                            n
                        (at? s (byte \,))
                            (let [s (.plus s 1)]
                                (recur-if (non-eos? s) [s n]) ;; => illegal trailing comma as in "set cc=80,"
                            ))
                    ))
            )] (some? n) => [win e_invarg]

        (let [win (if (zero? n)
                    (assoc win :w_p_cc_cols nil)
                    ;; sort the columns for faster usage on screen redraw inside win-line()
                    (let [_ (Arrays/sort color_cols, 0, n)
                          a (loop-when [a [] #_int i 0] (< i n) => a ;; skip duplicates
                                (let [#_int c (aget color_cols i)] (recur (if (not= (peek a) c) (conj a c) a) (inc i)))
                            )]
                        (assoc win :w_p_cc_cols (conj a -1))) ;; end marker
                )]
            [win nil]) ;; no error
    ))

;; Set the value of a boolean option, and take care of side effects.
;; Returns null for success, or an error message for an error.

(defn- #_[window_C Bytes] set-bool-option? [#_window_C win, #_vimoption_C v, #_boolean' varp, #_boolean value]
    (let [o'value @varp _ (reset! varp value)
          win (cond
            (== varp p_paste)                                   ;; when 'paste' is set or reset, also change other options
                (do (paste-option-changed) win)

            (== varp p_im)                                      ;; when 'insertmode' is set from an autocommand, need to do work here
                (do (if @p_im
                        (do (when (non-flag? @State INSERT)
                                (reset! need_start_insertmode true))
                            (reset! stop_insert_mode false))
                        (do
                            (reset! need_start_insertmode false)
                            (reset! stop_insert_mode true)
                            (when (and (non-zero? @restart_edit) @mode_displayed) ;; remove "(insert)"
                                (reset! clear_cmdline true))
                            (reset! restart_edit 0)
                        ))
                    win)

            (and (== varp p_ic) @p_hls)                         ;; when 'ignorecase' is set or reset and 'hlsearch' is set, redraw
                (do (redraw-all-later SOME_VALID) win)

            (== varp p_hls)                                     ;; when 'hlsearch' is set or reset, reset "no_hlsearch"
                (do (reset! no_hlsearch false) win)

            (== varp (:wo_wrap (:w_options win)))               ;; when 'wrap' is set, set "w_leftcol" to zero
                (when' @varp => win
                    (assoc win :w_leftcol 0))

            (== varp p_ea)
                (when' (and @p_ea (not o'value)) => win
                    (win-equal win, nil, false, 0)
                ))
          _ (comp-col) ;; in case 'ruler' or 'showcmd' changed
          win (when' (and (!= (:w_curswant win) MAXCOL) (flag? (:flags v) (| P_CURSWANT P_RALL))) => win
                (assoc win :w_set_curswant true)
            )]
        (check-redraw win, (:flags v))
    ))

;; Set the value of a number option, and take care of side effects.
;; Returns null for success, or an error message for an error.

(defn- #_[window_C Bytes] set-num-option? [#_window_C win, #_vimoption_C v, #_long' varp, #_long value]
    (let [a'errmsg (atom (#_Bytes object nil)) o'Rows @Rows o'Cols @Cols o'value @varp _ (reset! varp value)]

        (when (< @(:b_p_ts @curbuf) 1)  (reset! (:b_p_ts @curbuf) 8)                  (reset! a'errmsg e_positive))
        (when (< @(:b_p_sw @curbuf) 0)  (reset! (:b_p_sw @curbuf) @(:b_p_ts @curbuf)) (reset! a'errmsg e_positive))

        (let [win (condp == varp

                    p_ch ;; 'cmdheight'
                        (let [m (inc (- @Rows (min-rows)))]
                            (when (< @p_ch 1)       (reset! p_ch 1)       (reset! a'errmsg e_positive))
                            (when (< m @p_ch)       (reset! p_ch m))
                            ;; Only compute the new window layout when startup has been completed,
                            ;; otherwise the frame sizes may be wrong.
                            (when' (and (!= @p_ch o'value) @full_screen) => win
                                (command-height win)
                            ))

                    p_cwh ;; 'cmdwinheight'
                        (do (when (< @p_cwh 1)      (reset! p_cwh 1)      (reset! a'errmsg e_positive))
                            win)

                    p_wh ;; 'winheight'
                        (do (when (< @p_wh 1)       (reset! p_wh 1)       (reset! a'errmsg e_positive))
                            (when (< @p_wh @p_wmh)  (reset! p_wh @p_wmh)  (reset! a'errmsg e_winheight))
                            ;; Change window height NOW.
                            (when' (and (!= @lastwin @firstwin) (< (:w_height win) @p_wh)) => win
                                (win-setheight win, @p_wh)
                            ))

                    p_wiw ;; 'winwidth'
                        (do (when (< @p_wiw 1)      (reset! p_wiw 1)      (reset! a'errmsg e_positive))
                            (when (< @p_wiw @p_wmw) (reset! p_wiw @p_wmw) (reset! a'errmsg e_winwidth))
                            ;; Change window width NOW.
                            (when' (and (!= @lastwin @firstwin) (< (:w_width win) @p_wiw)) => win
                                (win-setwidth win, @p_wiw)
                            ))

                    p_wmh ;; 'winminheight'
                        (do (when (< @p_wmh 0)      (reset! p_wmh 0)      (reset! a'errmsg e_positive))
                            (when (< @p_wh @p_wmh)  (reset! p_wmh @p_wh)  (reset! a'errmsg e_winheight))
                            (win-setminheight win))

                    p_wmw ;; 'winminwidth'
                        (do (when (< @p_wmw 0)      (reset! p_wmw 0)      (reset! a'errmsg e_positive))
                            (when (< @p_wiw @p_wmw) (reset! p_wmw @p_wiw) (reset! a'errmsg e_winwidth))
                            (win-setminwidth win))

                    p_hi ;; 'history'
                        (do (cond
                                (< @p_hi 0)     (do (reset! p_hi 0)       (reset! a'errmsg e_positive))
                                (< 10000 @p_hi) (do (reset! p_hi 10000)   (reset! a'errmsg e_invarg)))
                            win)

                    p_ls ;; (re)set last window status line
                        (last-status win, false)

                    p_mco ;; 'maxcombine'
                        (do (swap! p_mco #(max 0 (min % MAX_MCO)))
                            (screen-clear) ;; will re-allocate the screen
                            win)

                    p_re ;; 'regexpengine'
                        (do (when-not (<= 0 @p_re 2) (reset! p_re 0)      (reset! a'errmsg e_invarg))
                            win)

                    p_report ;; 'report'
                        (do (when (< @p_report 0)   (reset! p_report 1)   (reset! a'errmsg e_positive))
                            win)

                    p_ss ;; 'sidescroll'
                        (do (when (< @p_ss 0)       (reset! p_ss 0)       (reset! a'errmsg e_positive))
                            win)

                    p_tm ;; 'timeoutlen'
                        (do (when (< @p_tm 0)       (reset! p_tm 0)       (reset! a'errmsg e_positive))
                            win)

                    (:wo_nuw (:w_options win)) ;; 'numberwidth'
                        (do (when (< @varp 1)       (reset! varp 1)       (reset! a'errmsg e_positive))
                            (when (< 10 @varp)      (reset! varp 10)      (reset! a'errmsg e_invarg))
                            (assoc win :w_nrwidth_line_count 0)) ;; trigger a redraw

                    (:b_p_ul @curbuf) ;; sync undo before 'undolevels' changes
                        ;; use the old value, otherwise u-sync() may not work properly
                        (let [_ (reset! (:b_p_ul @curbuf) o'value) win (u-sync win, true) _ (reset! (:b_p_ul @curbuf) value)]
                            win)

                    p_ut ;; 'updatetime'
                        (do (when (< @p_ut 0)       (reset! p_ut 2000)    (reset! a'errmsg e_positive))
                            win)

                    win)

              _ (when @full_screen
                    (let-when [m (min-rows)] (< @Rows m)
                        (reset! Rows m)
                        (let [#_Bytes errbuf (Bytes. 80)]
                            (ร .sprintf libC errbuf, (u8 "E593: Need at least %ld lines"), m)
                            (reset! a'errmsg errbuf)
                        ))
                    (let-when [m MIN_COLS] (< @Cols m)
                        (reset! Cols m)
                        (let [#_Bytes errbuf (Bytes. 80)]
                            (ร .sprintf libC errbuf, (u8 "E594: Need at least %ld columns"), m)
                            (reset! a'errmsg errbuf)
                        )))
              _ (limit-screen-size)
              ;; If the screen (shell) height has been changed, assume it is the physical screen height.
              win (when' (or (!= o'Rows @Rows) (!= o'Cols @Cols)) => win
                    ;; Changing the screen size is not allowed while updating the screen.
                    (cond @updating_screen
                        (do (reset! varp o'value) win)
                    @full_screen
                        (set-shellsize win, @Cols, @Rows, true)
                    :else
                        (do ;; Postpone the resizing; check the size and cmdline position for messages.
                            (check-shellsize)
                            (when (and (< (- @Rows @p_ch) @cmdline_row) (< @p_ch @Rows))
                                (reset! cmdline_row (- @Rows @p_ch)))
                            win
                        ))
                )]

            (when @full_screen
                (let-when [a'scr (:wo_scr (:w_options win))] (or (< @a'scr 1) (< 0 (:w_height win) @a'scr))
                    (cond (== varp a'scr)
                        (do (when (!= @a'scr 0)
                                (reset! a'errmsg e_scroll))
                            (win-comp-scroll win))
                    ;; If 'scroll' became invalid because of a side effect, silently adjust it.
                    (< @a'scr 1)
                        (reset! a'scr 1)
                    (< (:w_height win) @a'scr)
                        (reset! a'scr (:w_height win))
                    ))

                (when-not (and (<= -100 @p_sj) (< @p_sj @Rows))
                    (if (!= @Rows o'Rows) ;; Rows changed, just adjust 'scrolljump'
                        (reset! p_sj (/ @Rows 2))
                        (do (reset! p_sj 1) (reset! a'errmsg e_scroll))
                    ))

                (when (< @p_so 0)   (reset! p_so 0)   (reset! a'errmsg e_scroll))   ;; 'scrolloff'
                (when (< @p_siso 0) (reset! p_siso 0) (reset! a'errmsg e_positive)) ;; 'sidescrolloff'
            )

            (let [_ (comp-col) ;; in case 'columns' or 'ls' changed
                  win (when' (and (!= (:w_curswant win) MAXCOL) (flag? (:flags v) (| P_CURSWANT P_RALL))) => win
                        (assoc win :w_set_curswant true)
                    )]
                [(check-redraw win, (:flags v)) @a'errmsg]
            ))
    ))

;; Called after an option changed: check if something needs to be redrawn.

(defn- #_window_C check-redraw [#_window_C win, #_long flags]
    ;; Careful: P_RCLR and P_RALL are a combination of other P_ flags.
    (let [#_boolean doclear (== (& flags P_RCLR) P_RCLR)
          #_boolean all (or (== (& flags P_RALL) P_RALL) doclear)
          _ (when (or (flag? flags P_RSTAT) all) ;; mark all status lines dirty
                (status-redraw-all))
          win (when' (or (flag? flags P_RBUF) (flag? flags P_RWIN) all) => win
                (changed-window-setting win)
            )]
        (when (flag? flags P_RBUF)
            (redraw-curbuf-later NOT_VALID))
        (cond
            doclear (redraw-all-later CLEAR)
            all (redraw-all-later NOT_VALID)
        )
        win
    ))

(defn- #_vimoption_C findoption [#_Bytes name]
    (when (<= (byte \a) (.at name 0) (byte \z))
        (let [n (count vimoptions)]
            (or
                ;; match full name
                (loop-when [#_int i 0] (< i n) => nil
                    (let [v (... vimoptions i) #_Bytes s (:fullname v)] (if (zero? (STRCMP name, s)) v (recur (inc i)))))
                ;; match short name
                (loop-when [#_int i 0] (< i n) => nil
                    (let [v (... vimoptions i) #_Bytes s (:shortname v)] (if (and (some? s) (zero? (STRCMP name, s))) v (recur (inc i)))))
            ))
    ))

;; Show the value of one option.

(defn- #_void showoneopt [#_window_C win, #_vimoption_C v]
    (reset! info_message true)
    (let [#_Object' varp (get-varp win, v)]
        (if (and (flag? (:flags v) P_BOOL) (not (boolean @varp)))
            (msg-puts (u8 "no"))
            (msg-puts (u8 "  ")))
        (msg-puts (:fullname v))
        (when (non-flag? (:flags v) P_BOOL)
            (msg-putchar (byte \=))
            (let [#_Bytes s (Bytes. MAXPATHL)]
                (cond (flag? (:flags v) P_NUM)
                    (ร .sprintf libC s, (u8 "%ld"), (long @varp))
                (flag? (:flags v) P_STRING)
                    (if (nil? @varp) ;; just in case
                        (eos! s)
                        (vim-strncpy s, #_Bytes @varp, (dec MAXPATHL))
                    ))
                (msg-outtrans s)
            ))
        (reset! info_message false))
    nil)

;; Compute columns for ruler and shown command. 'sc_col' is also used to
;; decide what the maximum length of a message on the status line can be.
;; If there is a status line for the last window, 'sc_col' is independent
;; of 'ru_col'.

(final int COL_RULER 17)        ;; columns needed by standard ruler

(defn- #_void comp-col []
    (let [#_boolean last_has_status (or (== @p_ls 2) (and (== @p_ls 1) (!= @firstwin @lastwin)))]
        (reset! sc_col 0)
        (reset! ru_col 0)
        (when @p_ru
            (reset! ru_col (inc (if (non-zero? @ru_wid) @ru_wid COL_RULER)))
            ;; no last status line, adjust sc_col
            (when (not last_has_status)
                (reset! sc_col @ru_col)
            ))
        (when @p_sc
            (swap! sc_col + SHOWCMD_COLS)
            (when (or (not @p_ru) last_has_status) ;; no need for separating space
                (swap! sc_col inc)
            ))
        (swap! sc_col #(max 1 (- @Cols %)))
        (swap! ru_col #(max 1 (- @Cols %))))
    nil)

;; Get pointer to option variable.

(defn- #_Object' get-varp [#_window_C win, #_vimoption_C v]
    (let [wops (:w_options win)]
        (condp == (:indir v)
            PV_BRI    (:wo_bri wops)
            PV_BRIOPT (:wo_briopt wops)
            PV_CC     (:wo_cc wops)
            PV_CUC    (:wo_cuc wops)
            PV_CUL    (:wo_cul wops)
            PV_LBR    (:wo_lbr wops)
            PV_NU     (:wo_nu wops)
            PV_NUW    (:wo_nuw wops)
            PV_RNU    (:wo_rnu wops)
            PV_SCROLL (:wo_scr wops)
            PV_WFH    (:wo_wfh wops)
            PV_WFW    (:wo_wfw wops)
            PV_WRAP   (:wo_wrap wops)

            PV_AI     (:b_p_ai @curbuf)
            PV_CI     (:b_p_ci @curbuf)
            PV_CINW   (:b_p_cinw @curbuf)
            PV_ET     (:b_p_et @curbuf)
            PV_ISK    (:b_p_isk @curbuf)
            PV_KP     (:b_p_kp @curbuf)
            PV_MOD    (:b_changed @curbuf)
            PV_MPS    (:b_p_mps @curbuf)
            PV_NF     (:b_p_nf @curbuf)
            PV_PI     (:b_p_pi @curbuf)
            PV_QE     (:b_p_qe @curbuf)
            PV_SI     (:b_p_si @curbuf)
            PV_STS    (:b_p_sts @curbuf)
            PV_SW     (:b_p_sw @curbuf)
            PV_TS     (:b_p_ts @curbuf)
            PV_UL     (:b_p_ul @curbuf)

            (:var v)
        )
    ))

;; Copy options from one window to another.
;; Used when splitting a window.

(defn- #_window_C win-copy-options [#_window_C win, #_window_C won]
    (copy-winopt (:w_options win), (:w_options won))
    (let [[win _] (briopt-check? win)] win))

;; Copy the options from one winopt_C to another.

(defn- #_void copy-winopt [#_winopt_C win, #_winopt_C won]
    (reset! (:wo_bri win)            @(:wo_bri won))
    (reset! (:wo_briopt win) (STRDUP @(:wo_briopt won)))
    (reset! (:wo_cc win)     (STRDUP @(:wo_cc won)))
    (reset! (:wo_cuc win)            @(:wo_cuc won))
    (reset! (:wo_cul win)            @(:wo_cul won))
    (reset! (:wo_lbr win)            @(:wo_lbr won))
    (reset! (:wo_nu win)             @(:wo_nu won))
    (reset! (:wo_nuw win)            @(:wo_nuw won))
    (reset! (:wo_rnu win)            @(:wo_rnu won))
    ;; 'scroll' is omitted as it depends on window height
    ;; 'winfixheight' ... ?
    ;; 'winfixwidth' ... ?
    (reset! (:wo_wrap win)           @(:wo_wrap won))
    nil)

(atom! boolean old_p_paste)
(atom! boolean save_sm)
(atom! boolean save_ru)

;; Called after 'paste' was set or reset.

(defn- #_void paste-option-changed []
    (cond @p_paste
    (do ;; Paste switched from off to on.
        (when (not @old_p_paste)
            ;; save options
            (swap! curbuf assoc :b_p_sts_nopaste @(:b_p_sts @curbuf))
            (swap! curbuf assoc :b_p_ai_nopaste @(:b_p_ai @curbuf))
            ;; save global options
            (reset! save_sm @p_sm)
            (reset! save_ru @p_ru)
        )
        ;; Always set the option values, also when 'paste' is set when it is already on.
        ;; set options
        (reset! (:b_p_sts @curbuf) 0)       ;; softtabstop is 0
        (reset! (:b_p_ai @curbuf) false)    ;; no auto-indent
        ;; set global options
        (reset! p_sm false)                 ;; no showmatch
        (when @p_ru
            (status-redraw-all))            ;; redraw to remove the ruler
        (reset! p_ru false)                 ;; no ruler
    )
    @old_p_paste
    (do ;; Paste switched from on to off.
        ;; restore options
        (reset! (:b_p_sts @curbuf) (:b_p_sts_nopaste @curbuf))
        (reset! (:b_p_ai @curbuf) (:b_p_ai_nopaste @curbuf))
        ;; restore global options
        (reset! p_sm @save_sm)
        (when (!= @p_ru @save_ru)
            (status-redraw-all))            ;; redraw to draw the ruler
        (reset! p_ru @save_ru)
    ))
    (reset! old_p_paste @p_paste)
    nil)

;; Called when 'breakat' changes value.

(defn- #_void fill-breakat-flags []
    (swap! breakat_flags #(into (empty %) (map (constantly false) %)))
    (let-when [#_Bytes p @p_breakat] (some? p)
        (loop-when-recur [#_int i 0] (non-eos? p i) [(inc i)]
            (swap! breakat_flags assoc (char_u (.at p i)) true)
        ))
    nil)

;; Check an option that can be a range of string values.
;;
;; Return true for correct value, false otherwise.
;; Empty is always OK.

(defn- #_boolean check-opt-strings [#_Bytes val, #_Bytes* values, #_boolean list]
    ;; list: when true: accept a list of values
    (opt-strings-flags val, values, nil, list))

;; Handle an option that can be a range of string values.
;; Set a flag in "*flags" for each value present.
;;
;; Return false for a malformed "val", true otherwise.
;; Empty "val" is OK.

(defn- #_boolean opt-strings-flags [#_Bytes val, #_Bytes* values, #_int' a'flags, #_boolean list?]
    ;; val: new value
    ;; values: array of valid string values
    ;; list?: when true: accept a list of values
    (let-when [#_int flags
            (loop-when [#_Bytes s val flags 0] (non-eos? s) => flags
                (let-when [[s flags :as _]
                        (loop-when [#_int i 0] (some? (... values i)) => nil
                            (let [#_int n (STRLEN (... values i))]
                                (if (and (zero? (STRNCMP (... values i), s, n)) (or (and list? (at? s n (byte \,))) (eos? s n)))
                                    [(.plus s (+ n (if (at? s n (byte \,)) 1 0))) (| flags (<< 1 i))]
                                    (recur (inc i))
                                ))
                        )] (some? _) => nil
                    (recur s flags))
            )] (some? flags) => false
        (when (some? a'flags)
            (reset! a'flags flags))
        true
    ))

;; Check if backspacing over something is allowed.

(defn- #_boolean can-bs [#_int what]
    ;; what: BS_INDENT, BS_EOL or BS_START
    (some? (vim-strchr @p_bs, what)))

;; Return the effective shiftwidth value for current buffer,
;; using the 'tabstop' value when 'shiftwidth' is zero.

(defn- #_long get-sw-value []
    (let [sw @(:b_p_sw @curbuf)]
        (if (non-zero? sw) sw @(:b_p_ts @curbuf))
    ))

;; Return the effective softtabstop value for the current buffer,
;; using the 'tabstop' value when 'softtabstop' is negative.

(defn- #_long get-sts-value []
    (let [sts @(:b_p_sts @curbuf)]
        (if (neg? sts) (get-sw-value) sts)
    ))

;; Check matchpairs option for "*initc".
;; If there is a match set "*initc" to the matching character and "*findc" to the opposite.
;; Set "*backwards" to the direction.
;; When "switchit" is true, swap the direction.

(defn- #_void find-mps-values [#_int' a'initc, #_int' a'findc, #_boolean' a'backwards, #_boolean switchit]
    (loop-when [#_Bytes s @(:b_p_mps @curbuf)] (non-eos? s)
        (if (== (us-ptr2char s) @a'initc)
            (let [c (us-ptr2char s, (inc (us-ptr2len-cc s)))]
                (if switchit
                    (do (reset! a'findc @a'initc) (reset! a'initc c) (reset! a'backwards true))
                    (do (reset! a'findc c) (reset! a'backwards false))
                ))
            (let [c (us-ptr2char s) s (.plus s (inc (us-ptr2len-cc s)))]
                (if (== (us-ptr2char s) @a'initc)
                    (if switchit
                        (do (reset! a'findc @a'initc) (reset! a'initc c) (reset! a'backwards false))
                        (do (reset! a'findc c) (reset! a'backwards true)))
                    (let [s (.plus s (us-ptr2len-cc s)) s (if (at? s (byte \,)) (.plus s 1) s)]
                        (recur s))
                ))
        ))
    nil)

;; Called when 'breakindentopt' is changed.

(defn- #_[window_C boolean] briopt-check? [#_window_C win]
    (let [o'win win win (assoc win :w_p_brishift 0 :w_p_brimin 20 :w_p_brisbr false)
          win (loop-when [win win #_Bytes s @(:wo_briopt (:w_options win))] (non-eos? s) => win
                (let [[win s]
                        (cond (and (zero? (STRNCMP s, (u8 "shift:"), 6)) (or (and (at? s 6 (byte \-)) (asc-isdigit (.at s 7))) (asc-isdigit (.at s 6))))
                            (let [a's (atom (.plus s 6))] [(assoc win :w_p_brishift (getdigits a's)) @a's])
                        (and (zero? (STRNCMP s, (u8 "min:"), 4)) (asc-isdigit (.at s 4)))
                            (let [a's (atom (.plus s 4))] [(assoc win :w_p_brimin (getdigits a's)) @a's])
                        (zero? (STRNCMP s, (u8 "sbr"), 3))
                            [(assoc win :w_p_brisbr true) (.plus s 3)]
                        :else
                            [win s]
                        )]
                    (let-when [comma? (at? s (byte \,))] (or comma? (eos? s)) => nil
                        (recur win (if comma? (.plus s 1) s))
                    ))
            )]
        (if (some? win) [win true] [o'win false])
    ))

;; ex_cmds.c: some functions for command line commands --------------------------------------------

;; ":ascii" and "ga".

(defn- #_window_C do-ascii [#_window_C win]
    (let-when [#_int* cc (int-array MAX_MCO) #_int c (us-ptr2char-cc (ml-get-cursor win), cc)] (!= c NUL) => (msg win, (u8 "NUL"))
        (let [#_Bytes buf (Bytes. IOSIZE)
              [c #_int ci]
                (when' (< c 0x80) => [c 0]
                    (let [#_Bytes buf1 (Bytes. 20) #_Bytes buf2 (Bytes. 20) c (if (== c NL) NUL c)] ;; NUL is stored as NL
                        (if (and (vim-isprintc c) (or (< c (byte \space)) (< (byte \~) c)))
                            (let [#_Bytes buf3 (Bytes. 7)]
                                (transchar-nonprint buf3, c)
                                (ร .sprintf libC buf1, (u8 "  <%s>"), buf3))
                            (eos! buf1))
                        (if (<= 0x80 c)
                            (ร .sprintf libC buf2, (u8 "  <M-%s>"), (transchar (& c 0x7f)))
                            (eos! buf2))
                        (ร .sprintf libC buf, (u8 "<%s>%s%s  %ld,  Hex %02x,  Octal %03o"), (transchar c), buf1, buf2, c, c, c)
                        [(aget cc 0) 1]
                    )
                )]
            ;; Repeat for combining characters.
            (loop-when [c c ci ci] (<= 0x80 c)
                (let [#_int n (STRLEN buf)
                      ;; This assumes every multi-byte char is printable...
                      n (if (pos? n)            (do (.be buf n, (byte \space)) (inc n)) n)
                      n                         (do (.be buf n, (byte \<))     (inc n))
                      n (if (utf-iscomposing c) (do (.be buf n, (byte \space)) (inc n)) n) ;; draw composing char on top of a space
                      n (+ n (utf-char2bytes c, (.plus buf n)))]
                    (ร .sprintf libC (.plus buf n), (if (< c 0x10000) (u8 "> %ld, Hex %04x, Octal %o") (u8 "> %ld, Hex %08x, Octal %o")), c, c, c)
                    (recur-if (< ci MAX_MCO) [(aget cc ci) (inc ci)])
                ))
            (msg win, buf)
        )
    ))

;; ":retab".

(defn- #_[window_C exarg_C] ex-retab [#_window_C win, #_exarg_C eap]
    (let-when [__ (atom (#_Bytes object (:arg eap))) #_int ts (getdigits __) eap (assoc eap :arg @__)] (<= 0 ts) => [(emsg win, e_positive) eap]
        (let [ts (if (zero? ts) @(:b_p_ts @curbuf) ts)
              m { #_boolean :got_tab false, #_int :num_spaces 0, #_int :start_vcol 0, #_int :start_col 0, #_long :first_line 0, #_long :last_line 0 }
              m (loop-when [m m #_long lnum (:line1 eap)] (and (not @got_int) (<= lnum (:line2 eap))) => m
                    (let-when [[m abort]
                        (loop [m m #_Bytes s (ml-get lnum) x { #_int :vcol 0, #_int :col 0, #_boolean :did_undo false }]
                            (let [[m s x abort]
                                    (if (vim-iswhite (.at s (:col x)))
                                        (let [m (if (and (not (:got_tab m)) (zero? (:num_spaces m)))
                                                    ;; First consecutive white-space.
                                                    (assoc m :start_vcol (:vcol x) :start_col (:col x))
                                                    m)
                                              m (if (at? s (:col x) (byte \space))
                                                    (update m :num_spaces inc)
                                                    (assoc m :got_tab true)
                                                )]
                                            [m s x false])
                                        (let [[m s x abort] ;; Retabulate this string of white-space.
                                                (if (or (:got_tab m) (and (:forceit eap) (< 1 (:num_spaces m))))
                                                    ;; len is virtual length of white string
                                                    (let [#_int len (- (:vcol x) (:start_vcol m)) m (assoc m :num_spaces len)
                                                          [#_int num_tabs m]
                                                            (if (not @(:b_p_et @curbuf))
                                                                (let [#_int t' (- ts (% (:start_vcol m) ts)) ns (:num_spaces m)
                                                                      [ns num_tabs] (if (<= t' ns) [(- ns t') 1] [ns 0])]
                                                                    [(+ num_tabs (/ ns ts)) (assoc m :num_spaces (- ns (* (/ ns ts) ts)))])
                                                                [0 m]
                                                            )]
                                                        (if (or @(:b_p_et @curbuf) (:got_tab m) (< (+ num_tabs (:num_spaces m)) len))
                                                            (let-when [[x abort]
                                                                (if (not (:did_undo x))
                                                                    [(assoc x :did_undo true) (not (u-save win, (dec lnum), (inc lnum)))]
                                                                    [x false])
                                                            ] (not abort) => [m s x abort]

                                                                ;; len is actual number of white characters used
                                                                (let [len (+ num_tabs (:num_spaces m)) #_int old_len (STRLEN s)
                                                                      #_Bytes line (Bytes. (+ (- old_len (:col x)) (:start_col m) len 1))
                                                                      _ (when (< 0 (:start_col m))
                                                                            (BCOPY line, s, (:start_col m)))
                                                                      _ (BCOPY line, (+ (:start_col m) len), s, (:col x), (inc (- old_len (:col x))))
                                                                      s (.plus line (:start_col m))]
                                                                    (dotimes [i len]
                                                                        (.be s i, (if (< i num_tabs) TAB (byte \space))))
                                                                    (ml-replace lnum, line)
                                                                    (let [m (assoc m :first_line (if (zero? (:first_line m)) lnum (:first_line m)) :last_line lnum)
                                                                          x (assoc x :col (+ (:start_col m) len))]
                                                                        [m line x false]
                                                                    )
                                                                ))
                                                            [m s x false]
                                                        ))
                                                    [m s x false]
                                                )]
                                            [(assoc m :got_tab false :num_spaces 0) s x abort])
                                    )]
                                (if (or (eos? s (:col x)) abort)
                                    [m abort]
                                    (recur m s (assoc x :vcol (+ (:vcol x) (chartabsize s, (:col x), (:vcol x))) :col (+ (:col x) (us-ptr2len-cc s, (:col x)))))
                                )
                            ))
                    ] (not abort) => m

                        (slow-breakcheck)
                        (recur m (inc lnum))
                    ))
              win (if @got_int (emsg win, e_interr) win)]
            (when (!= @(:b_p_ts @curbuf) ts)
                (redraw-curbuf-later NOT_VALID))
            (when (non-zero? (:first_line m))
                (swap! curbuf changed-lines (:first_line m), 0, (inc (:last_line m)), 0))
            (reset! (:b_p_ts @curbuf) ts)
            (let [win (coladvance win, (:w_curswant win))]
                (u-clearline)
                [win eap]
            ))
    ))

;; Implementation of ":fixdel", also used by get-stty().
;;  <BS>    resulting <Del>
;;   ^?         ^H
;; not ^?       ^?

(defn- #_[window_C exarg_C] ex-fixdel [#_window_C win, #_exarg_C eap]
    (do-fixdel)
    [win eap])

(atom! Bytes prior_sub)         ;; previous substitute pattern

(atom! boolean sub_all)         ;; do multiple substitutions per line
(atom! boolean sub_count)       ;; count only
(atom! boolean sub_error true)  ;; if false, ignore errors
(atom! int sub_ic)              ;; ignore case flag

(declare last_expr)

;; Perform a substitution from line eap.line1 to line eap.line2 using
;; the command pointed to by eap.arg which should be of the form:
;;
;; /pattern/substitution/{flags}
;;
;; The usual escapes are supported as described in the regexp docs.

(defn- #_[window_C exarg_C] ex-sub [#_window_C win, #_exarg_C eap]
    (let-when [o'cursor (:w_cursor win) o'line_count (line-count @curbuf)
          a'sub_nsubs (atom (long 0)) a'sub_nlines (atom (long 0))                                                      ;; number of substitutions/lines changed
          #_Bytes cmd (:arg eap) re_use (if #_(== (:cmdidx eap) (ร CMD_tilde)) nil RE_LAST RE_SUBST)                  ;; use last used/substitute regexp

          [win [cmd re_use #_Bytes pat #_Bytes sub eol? :as _]]
            (cond (and (at? (:cmd eap) (byte \s)) (non-eos? cmd) (not (vim-iswhite (.at cmd 0))) (nil? (vim-strbyte (u8 "0123456789cegriIp|\""), (.at cmd 0))))
                (if (asc-isalpha (.at cmd 0)) ;; don't accept alphanumeric for separator
                    [(emsg win, (u8 "E146: Regular expressions can't be delimited by letters")) nil]
                    ;; Undocumented Vi feature:
                    ;; "\/sub/" and "\?sub?" use last used search pattern (almost like //sub/r).
                    ;; "\&sub&" use last substitute pattern (like //sub/).
                    (let-when [[win [re_use #_byte delimiter pat cmd :as _]]
                            (if (at? cmd (byte \\))
                                (let-when [cmd (.plus cmd 1)] (some? (vim-strbyte (u8 "/?&"), (.at cmd 0))) => [(emsg win, e_backslash) nil]
                                    [win [(if (at? cmd (byte \&)) re_use RE_SEARCH) (.at cmd 0) (u8 "") (.plus cmd 1)]])
                                (let [delimiter (.at cmd 0) cmd (.plus cmd 1) pat cmd                                   ;; remember start of search pattern
                                      cmd (skip-regexp cmd, delimiter, @p_magic, nil)]                                  ;; find the end of the regexp
                                    [win [RE_LAST delimiter pat (if (at? cmd delimiter) (.plus (eos! cmd) 1) cmd)]])    ;; replace it with a NUL
                            )] (some? _) => [win nil]

                        ;; Small incompatibility: Vi sees '\n' as end of the command,
                        ;; but in Vim we want to use '\n' to find/substitute a NUL.
                        (let-when [sub cmd                                                                              ;; remember the start of the substitution
                              cmd (loop-when cmd (non-eos? cmd) => cmd
                                    (if (at? cmd delimiter)                                                             ;; end delimiter found
                                        (.plus (eos! cmd) 1)                                                            ;; replace it with a NUL
                                        (let [cmd (if (and (at? cmd (byte \\)) (non-eos? cmd 1)) (.plus cmd 1) cmd)]    ;; skip escaped characters
                                            (recur (.plus cmd (us-ptr2len-cc cmd))))
                                    ))
                              [win sub]
                                (cond (:skip eap)
                                    [win sub]
                                ;; In POSIX vi ":s/pat/%/" uses the previous substitution string.
                                (and (zero? (STRCMP sub, (u8 "%"))) (some? (vim-strbyte @p_cpo, CPO_SUBPERCENT)))
                                    (when' (some? @prior_sub) => [(emsg win, e_nopresub) nil]
                                        [win @prior_sub])
                                :else
                                    (do (reset! prior_sub (STRDUP sub))
                                        [win sub])
                                )] (some? sub) => [win nil]

                            [win [cmd re_use pat sub false]])
                    ))
            (not (:skip eap)) ;; use previous pattern and substitution
                (when' (some? @prior_sub) => [(emsg win, e_nopresub) nil]
                    ;; Vi compatibility quirk:
                    ;; repeating with ":s" keeps the cursor in the last column after using "$".
                    [win [cmd re_use nil @prior_sub (== (:w_curswant win) MAXCOL)]])
            :else
                [win [cmd re_use nil nil false]])

    ] (some? _) => [win eap]

        ;; Recognize ":%s/\n//" and turn it into a join command, which is much more efficient.
        (if (and (some? pat) (zero? (STRCMP pat, (u8 "\\n"))) (eos? sub) (or (eos? cmd) (and (at? cmd (byte \g)) (eos? cmd 1))))
            (let [win (assoc-in win [:w_cursor :lnum] (:line1 eap))
                  ;; The number of lines joined is the number of lines in the range plus one.
                  ;; One less when the last line is included.
                  n (inc (- (:line2 eap) (:line1 eap)))
                  n (if (< (:line2 eap) (line-count @curbuf)) (inc n) n)
                  win (when' (< 1 n) => win
                        (let [win (do-join win, n, false, true, true)
                              _ (reset! a'sub_nsubs (dec n))
                              _ (reset! a'sub_nlines 1)
                              [win _] (do-sub-msg? win, @a'sub_nsubs, @a'sub_nlines, false)]
                            win)
                    )]
                (save-re-pat RE_SUBST, pat, @p_magic)
                (add-to-history HIST_SEARCH, pat, NUL)
                [win eap])

            ;; Find trailing options.  When '&' is used, keep old options.
            (let-when [cmd (if (at? cmd (byte \&))
                        (.plus cmd 1)
                        (do (reset! sub_all @p_gd) ;; default is global on
                            (reset! sub_error true)
                            (reset! sub_count false)
                            (reset! sub_ic 0)
                            cmd
                        ))
                  [re_use cmd]
                    (loop-when [re_use re_use cmd cmd] (non-eos? cmd) => [re_use cmd]
                        ;; Note: 'g' and 'c' are always inverted; 'r' is never inverted.
                        (condp == (.at cmd 0)
                            (byte \g) (do (swap! sub_all not)       (recur re_use (.plus cmd 1)))
                            (byte \n) (do (reset! sub_count true)   (recur re_use (.plus cmd 1)))
                            (byte \e) (do (swap! sub_error not)     (recur re_use (.plus cmd 1)))
                            (byte \r)                               (recur RE_LAST (.plus cmd 1)) ;; use last used regexp
                            (byte \i) (do (reset! sub_ic (byte \i)) (recur re_use (.plus cmd 1))) ;; ignore case
                            (byte \I) (do (reset! sub_ic (byte \I)) (recur re_use (.plus cmd 1))) ;; don't ignore case
                            [re_use cmd]
                        ))
                  ;; check for a trailing count
                  cmd (skipwhite cmd)
                  [win eap cmd]
                    (when' (asc-isdigit (.at cmd 0)) => [win eap cmd]
                        (let [[i cmd] (let [a'cmd (atom (#_Bytes object cmd))] [(getdigits a'cmd) @a'cmd])]
                            (when' (or (< 0 i) (:skip eap) (not @sub_error)) => [(emsg win, e_zerocount) eap nil]
                                (let [eap (assoc eap :line1 (:line2 eap))]
                                    [win (update eap :line2 #(min (+ % (dec i)) (line-count @curbuf))) cmd]
                                ))
                        ))

            ] (some? cmd) => [win eap]

                ;; check for trailing command or garbage
                (let-when [cmd (skipwhite cmd)
                      ? (when-not (or (eos? cmd) (at? cmd (byte \"))) e_trailing) ;; """

                ] (not ?) => [(emsg win, ?) eap]

                    (if (:skip eap) ;; not executing commands, only parsing
                        [win eap]

                        (let-when [[win #_matcher_C mat ?] (search-regcomp? win, nil, pat, RE_SUBST, re_use, SEARCH_HIST)
                              [win mat]
                                (when' ? => [(if @sub_error (emsg win, e_invcmd) win) nil]
                                    [win mat])

                        ] (some? mat) => [win eap]

                            ;; the 'i' or 'I' flag overrules 'ignorecase' and 'smartcase'
                            (let [mat (condp == @sub_ic (byte \i) (assoc mat :m_icase true) (byte \I) (assoc mat :m_icase false) mat)
                                  ;; ~ in the substitute pattern is replaced with the old pattern.
                                  ;; We do it here once to avoid it to be replaced over and over again.
                                  ;; But don't do it when it starts with "\=", then it's an expression.
                                  sub (if (not (and (at? sub (byte \\)) (at? sub 1 (byte \=)))) (regtilde sub, @p_magic) sub)

                                  a'first_line (atom (long 0))  ;; first changed line
                                  a'last_line (atom (long 0))   ;; below last changed line AFTER the change
                                  a'line2 (atom (long (:line2 eap)))
                                  a'got_match (atom (boolean false))
                                  ;; Check for a match on each line.
                                  win (loop-when [win win mat mat #_long lnum (:line1 eap)] (and (<= lnum @a'line2) (not @got_int)) => win
                                        (let [[win mat ?] (vim-regexec? win, mat, lnum, 0, nil) a'nmatch (atom (long ?)) ;; number of lines in match
                                              [win mat lnum]
                                                (when' (non-zero? @a'nmatch) => [win mat lnum]
                                                    ;; The new text is build up step by step, to avoid too much copying.
                                                    ;; There are these pieces:
                                                    ;;
                                                    ;; sub_firstline    The old text, unmodified.
                                                    ;; copycol          Column in the old text where we started looking for a match;
                                                    ;;                  from here old text still needs to be copied to the new text.
                                                    ;; matchcol         Column number of the old text where to look for the next match.
                                                    ;;                  It's just after the previous match or one further.
                                                    ;; prev_matchcol    Column just after the previous match (if any).
                                                    ;;                  Mostly equal to "matchcol", except for the first match
                                                    ;;                  and after skipping an empty match.
                                                    ;; mat.*pos         Where the pattern matched in the old text.
                                                    ;; new_start        The new text, all that has been produced so far.
                                                    ;; new_end          The new text, where to append new text.
                                                    ;;
                                                    ;; lnum             The line number where we found the start of the match.
                                                    ;;                  Can be below the line we searched when there is a \n
                                                    ;;                  before a \zs in the pattern.
                                                    ;; sub_firstlnum    The line number in the buffer where to look for a match.
                                                    ;;                  Can be different from "lnum" when the pattern or substitute
                                                    ;;                  string contains line breaks.
                                                    ;;
                                                    ;; Special situations:
                                                    ;; - When the substitute string contains a line break, the part up to the line
                                                    ;;   break is inserted in the text, but the copy of the original line is kept.
                                                    ;;   "sub_firstlnum" is adjusted for the inserted lines.
                                                    ;; - When the matched pattern contains a line break, the old line is taken from
                                                    ;;   the line at the end of the pattern.  The lines in the match are deleted
                                                    ;;   later, "sub_firstlnum" is adjusted accordingly.
                                                    ;;
                                                    ;; The new text is built up in new_start[].  It has some extra room to avoid
                                                    ;; using calloc()/free() too often.  new_start_len is the length of the allocated
                                                    ;; memory at new_start.
                                                    ;;
                                                    ;; Make a copy of the old line, so it won't be taken away when updating the screen
                                                    ;; or handling a multi-line match.  The "old_" pointers point into this copy.
                                                    (let [a'did_sub (atom (boolean false))
                                                          ;; At first match, remember current cursor position.
                                                          win (when' (not @a'got_match) => win
                                                                (let [win (setpcmark win)] (reset! a'got_match true) win))

                                                          l'sub_firstlnum (atom (long lnum))            ;; lnum of first sub line
                                                          l'sub_firstline (atom (#_Bytes object nil))   ;; allocated copy of first sub line

                                                          l'new_start (atom (#_Bytes object nil))
                                                          l'new_start_len (atom (int 0))
                                                          l'nmatch_tl (atom (long 0))                   ;; nr of lines matched below lnum
                                                          l'skip_match (atom (boolean false))

                                                          l'prev_matchcol (atom (int MAXCOL))
                                                          l'matchcol (atom (int 0))
                                                          l'copycol (atom (int 0))

                                                          ;; Loop until nothing more to replace in this line.
                                                          ;; 1. Handle match with empty string.
                                                          ;; 3. Substitute the string.
                                                          ;; 4. If "sub_all" is set, find next match.
                                                          ;; 5. Break if there isn't another match in this line.
                                                          [win mat lnum]
                                                            (loop [win win mat mat lnum lnum]
                                                                ;; Advance "lnum" to the line where the match starts.
                                                                ;; The match does not start in the first line when there is a line break before \zs.
                                                                (let-when [lnum
                                                                        (let-when [n (:lnum (... (:m_startpos mat) 0))] (pos? n) => lnum
                                                                            (swap! a'nmatch - n)
                                                                            (swap! l'sub_firstlnum + n) (reset! l'sub_firstline nil)
                                                                            (+ lnum n))
                                                                      _ (when (nil? @l'sub_firstline)
                                                                            (reset! l'sub_firstline (STRDUP (ml-get @l'sub_firstlnum))))
                                                                      ;; Save the line number of the last change for the final cursor position (just like Vi).
                                                                      win (assoc-in win [:w_cursor :lnum] lnum)
                                                                      a'do_again (atom (boolean false)) ;; do it again after joining lines

                                                                      [win lnum]
                                                                        (if (and (== @l'matchcol @l'prev_matchcol) (zero? (:lnum (... (:m_endpos mat) 0))) (== @l'matchcol (:col (... (:m_endpos mat) 0))))
                                                                            (do ;; 1. Matching the empty string does not count, except for the first match.
                                                                                ;; This reproduces the strange Vi behaviour; also catches endless loops.
                                                                                (if (eos? @l'sub_firstline @l'matchcol)
                                                                                    ;; We are already at eol, don't look for a match in this line again.
                                                                                    (reset! l'skip_match true)
                                                                                    ;; Otherwise search for a match at the next column.
                                                                                    (swap! l'matchcol #(+ % (us-ptr2len-cc @l'sub_firstline, %))))
                                                                                [win lnum])
                                                                            ;; Normally we continue searching for a match just after the previous match.
                                                                            (let-when [_ (reset! l'matchcol (:col (... (:m_endpos mat) 0)))
                                                                                  _ (reset! l'prev_matchcol @l'matchcol)
                                                                                  ;; 2. If "sub_count" is set, only increase the counter.
                                                                                  ? (if @sub_count
                                                                                        (do ;; For a multi-line match, put "matchcol" at the NUL at the end of the line and
                                                                                            ;; set "nmatch" to one, so that we continue looking for a match on the next line.
                                                                                            ;; Avoids that ":s/\nB\@=//gc" get stuck.
                                                                                            (when (< 1 @a'nmatch)
                                                                                                (reset! l'matchcol (STRLEN @l'sub_firstline))
                                                                                                (reset! a'nmatch 1)
                                                                                                (reset! l'skip_match true))
                                                                                            (swap! a'sub_nsubs inc)
                                                                                            (reset! a'did_sub true)
                                                                                            ;; Skip the substitution, unless an expression is used,
                                                                                            ;; then it is evaluated in the sandbox.
                                                                                            (and (at? sub (byte \\)) (at? sub 1 (byte \=))))
                                                                                        true
                                                                                    )] ? => [win lnum]

                                                                                ;; Move the cursor to the start of the match, so that we can use "\=col(".").
                                                                                (let [win (assoc-in win [:w_cursor :col] (:col (... (:m_startpos mat) 0)))
                                                                                      ;; get length of substitution part
                                                                                      [win #_int sublen] (vim-regsub? win, mat, (- @l'sub_firstlnum (:lnum (... (:m_startpos mat) 0))), sub, @l'sub_firstline, false, @p_magic, true)]
                                                                                    (if @sub_count
                                                                                        [win lnum]
                                                                                        ;; 3. Substitute the string.
                                                                                        ;; When the match included the "$" of the last line,
                                                                                        ;; it may go beyond the last line of the buffer.
                                                                                        (let [_ (let-when [n (inc (- (line-count @curbuf) @l'sub_firstlnum))] (< n @a'nmatch)
                                                                                                    (reset! a'nmatch n)
                                                                                                    (reset! l'skip_match true))
                                                                                              ;; Need room for:
                                                                                              ;; - result so far in "new_start" (not for first sub in line)
                                                                                              ;; - original text up to match
                                                                                              ;; - length of substituted part
                                                                                              ;; - original text after match
                                                                                              #_Bytes s
                                                                                                (if (== @a'nmatch 1)
                                                                                                    @l'sub_firstline
                                                                                                    (do (swap! l'nmatch_tl + (dec @a'nmatch))
                                                                                                        (ml-get (+ @l'sub_firstlnum (dec @a'nmatch)))
                                                                                                    ))
                                                                                              #_int copy_len (- (:col (... (:m_startpos mat) 0)) @l'copycol)
                                                                                              #_int needed_len (+ copy_len (- (STRLEN s) (:col (... (:m_endpos mat) 0))) sublen 1)
                                                                                              [s needed_len #_Bytes new_end]
                                                                                                (if (nil? @l'new_start)
                                                                                                    (do ;; Get some space for a temporary buffer to do the substitution into
                                                                                                        ;; (and some extra space to avoid too many calls to calloc()/free()).
                                                                                                        (reset! l'new_start_len (+ needed_len 50))
                                                                                                        (reset! l'new_start (Bytes. @l'new_start_len))
                                                                                                        [s needed_len (eos! @l'new_start)])
                                                                                                    (let [n (STRLEN @l'new_start) needed_len (+ needed_len n)
                                                                                                          ;; Check if the temporary buffer is sufficient for the substitution.
                                                                                                          ;; If not, make it larger (with a bit extra as above).
                                                                                                          s (if (< @l'new_start_len needed_len)
                                                                                                                (let [_ (reset! l'new_start_len (+ needed_len 50))
                                                                                                                      s (Bytes. @l'new_start_len)
                                                                                                                      _ (BCOPY s, @l'new_start, (inc n))]
                                                                                                                    (reset! l'new_start s))
                                                                                                                s
                                                                                                            )]
                                                                                                        [s needed_len (.plus @l'new_start n)]
                                                                                                    ))
                                                                                              ;; copy the text up to the part that matched
                                                                                              _ (BCOPY new_end, 0, @l'sub_firstline, @l'copycol, copy_len)
                                                                                              new_end (.plus new_end copy_len)
                                                                                              [win _] (vim-regsub? win, mat, (- @l'sub_firstlnum (:lnum (... (:m_startpos mat) 0))), sub, new_end, true, @p_magic, true)
                                                                                              _ (swap! a'sub_nsubs inc)
                                                                                              _ (reset! a'did_sub true)
                                                                                              ;; Move the cursor to the start of the line, to avoid that
                                                                                              ;; it is beyond the end of the line after the substitution.
                                                                                              win (assoc-in win [:w_cursor :col] 0)]

                                                                                            ;; For a multi-line match, make a copy of the last matched line and continue in that one.
                                                                                            (when (< 1 @a'nmatch)
                                                                                                (swap! l'sub_firstlnum + (dec @a'nmatch))
                                                                                                (reset! l'sub_firstline (STRDUP (ml-get @l'sub_firstlnum)))
                                                                                                ;; When going beyond the last line, stop substituting.
                                                                                                (if (<= @l'sub_firstlnum @a'line2)
                                                                                                    (reset! a'do_again true)
                                                                                                    (reset! sub_all false)
                                                                                                ))
                                                                                            ;; Remember next character to be copied.
                                                                                            (reset! l'copycol (:col (... (:m_endpos mat) 0)))
                                                                                            (when @l'skip_match
                                                                                                ;; Already hit end of the buffer,
                                                                                                ;; "sub_firstlnum" is one less than what it ought to be.
                                                                                                (reset! l'sub_firstline (STRDUP (u8 "")))
                                                                                                (reset! l'copycol 0))

                                                                                            ;; Now the trick is to replace CTRL-M chars with a real line break.
                                                                                            ;; This would make it impossible to insert a CTRL-M in the text.
                                                                                            ;; The line break can be avoided by preceding the CTRL-M with a backslash.
                                                                                            ;; To be able to insert a backslash, they must be doubled in the string
                                                                                            ;; and are halved here.
                                                                                            ;; That is Vi compatible.

                                                                                            (loop-when [win win lnum lnum s new_end] (non-eos? s) => [win lnum]
                                                                                                (cond (and (at? s (byte \\)) (non-eos? s 1)) ;; remove backslash
                                                                                                    (do (BCOPY s, 0, s, 1, (inc (STRLEN s, 1)))
                                                                                                        (recur win lnum (.plus s 1)))
                                                                                                (at? s CAR)
                                                                                                    (when' (u-inssub win, lnum) => (recur win lnum (.plus s 1))
                                                                                                        (let [_ (eos! s) ;; truncate up to the CR
                                                                                                              _ (ml-append (dec lnum), @l'new_start)
                                                                                                              win (mark-adjust win, (inc lnum), MAXLNUM, 1, 0)
                                                                                                              _ (reset! a'first_line (if (zero? @a'first_line) lnum @a'first_line))
                                                                                                              _ (reset! a'last_line (inc lnum))
                                                                                                              ;; All line numbers increase.
                                                                                                              _ (swap! l'sub_firstlnum inc)
                                                                                                              lnum (inc lnum)
                                                                                                              _ (swap! a'line2 inc)
                                                                                                              ;; move the cursor to the new line, like Vi
                                                                                                              win (update-in win [:w_cursor :lnum] inc)
                                                                                                              ;; copy the rest
                                                                                                              _ (BCOPY @l'new_start, 0, s, 1, (inc (STRLEN s, 1)))]
                                                                                                            (recur win lnum @l'new_start)
                                                                                                        ))
                                                                                                :else
                                                                                                    (recur win lnum (.plus s (us-ptr2len-cc s))))
                                                                                            ))
                                                                                    ))
                                                                            ))

                                                                      ;; 4. If "sub_all" is set, find next match.
                                                                      ;; Prevent endless loop with patterns that match empty strings, e.g. :s/$/pat/g or :s/[a-z]* /(&)/g.
                                                                      ;; But ":s/\n/#/" is OK.

                                                                      ;; We already know that we did the last subst when we are at the end of the line,
                                                                      ;; except that a pattern like "bar\|\nfoo" may match at the NUL.
                                                                      ;; "lnum" can be below "line2" when there is a \zs in the pattern after a line break.

                                                                      #_boolean lastone (or @l'skip_match @got_int (< @a'line2 lnum) (not (or @sub_all @a'do_again))
                                                                                            (and (eos? @l'sub_firstline @l'matchcol) (<= @a'nmatch 1)
                                                                                                 (not (re-multiline (:m_pattern mat)))))
                                                                      _ (reset! a'nmatch -1)

                                                                      ;; Replace the line in the buffer when needed.
                                                                      ;; This is skipped when there are more matches.
                                                                      ;; The check for "nmatch_tl" is needed for when multi-line matching must replace
                                                                      ;; the lines before trying to do another match, otherwise "\@<=" won't work.
                                                                      ;; When the match starts below where we start searching
                                                                      ;; also need to replace the line first (using \zs after \n).

                                                                      [win mat ?]
                                                                        (when' (not (or lastone (< 0 @l'nmatch_tl))) => [win mat true]
                                                                            (let [[win mat ?] (vim-regexec? win, mat, @l'sub_firstlnum, @l'matchcol, nil)]
                                                                                (reset! a'nmatch ?)
                                                                                [win mat false]
                                                                            ))
                                                                      [win mat lnum ?]
                                                                        (if (or ? (zero? @a'nmatch) (< 0 (:lnum (... (:m_startpos mat) 0))))
                                                                            (let-when [[win lnum ?]
                                                                                    (when' (some? @l'new_start) => [win lnum nil]
                                                                                        ;; Copy the rest of the line, that didn't match.
                                                                                        ;; "matchcol" has to be adjusted, we use the end of the line as reference,
                                                                                        ;; because the substitute may have changed the number of characters.
                                                                                        ;; Same for "prev_matchcol".
                                                                                        (STRCAT @l'new_start, (.plus @l'sub_firstline @l'copycol))
                                                                                        (let [n (STRLEN @l'sub_firstline)]
                                                                                            (reset! l'matchcol (- n @l'matchcol))
                                                                                            (reset! l'prev_matchcol (- n @l'prev_matchcol)))
                                                                                        (when' (u-savesub win, lnum) => [win lnum :break]
                                                                                            (let-when [_ (ml-replace lnum, @l'new_start)
                                                                                                  [win lnum ? :as _]
                                                                                                    (when' (< 0 @l'nmatch_tl) => [win lnum nil]
                                                                                                        ;; Matched lines have now been substituted and are useless,
                                                                                                        ;; delete them.
                                                                                                        ;; The part after the match has been appended to "new_start",
                                                                                                        ;; we don't need it in the buffer.
                                                                                                        (let-when [lnum (inc lnum)] (u-savedel win, lnum, @l'nmatch_tl) => [win lnum :break]
                                                                                                            (dotimes [_ @l'nmatch_tl] (ml-delete lnum, false))
                                                                                                            (let [win (mark-adjust win, lnum, (dec (+ lnum @l'nmatch_tl)), MAXLNUM, (- @l'nmatch_tl))
                                                                                                                  lnum (dec lnum)]
                                                                                                                (swap! a'line2 - @l'nmatch_tl)
                                                                                                                (reset! l'nmatch_tl 0)
                                                                                                                [win lnum nil]
                                                                                                            ))
                                                                                                    )] (not ?) => _

                                                                                                (reset! a'first_line (if (zero? @a'first_line) lnum @a'first_line))
                                                                                                (reset! a'last_line (inc lnum))
                                                                                                (reset! l'sub_firstlnum lnum)
                                                                                                (reset! l'sub_firstline @l'new_start)
                                                                                                (reset! l'new_start nil)
                                                                                                (let [n (STRLEN @l'sub_firstline)]
                                                                                                    (reset! l'matchcol (- n @l'matchcol))
                                                                                                    (reset! l'prev_matchcol (- n @l'prev_matchcol)))
                                                                                                (reset! l'copycol 0)
                                                                                                [win lnum nil]
                                                                                            ))
                                                                                    )] (not ?) => [win mat lnum ?]

                                                                                (let [[win mat]
                                                                                        (when' (and (== @a'nmatch -1) (not lastone)) => [win mat]
                                                                                            (let [[win mat ?] (vim-regexec? win, mat, @l'sub_firstlnum, @l'matchcol, nil)]
                                                                                                (reset! a'nmatch ?)
                                                                                                [win mat]
                                                                                            ))

                                                                                      ;; 5. Break if there isn't another match in this line.

                                                                                      [lnum ?]
                                                                                        (if (<= @a'nmatch 0)
                                                                                            ;; If the match found didn't start where we were searching,
                                                                                            ;; do the next search in the line where we found the match.
                                                                                            [(if (== @a'nmatch -1) (- lnum (:lnum (... (:m_startpos mat) 0))) lnum) :break]
                                                                                            [lnum nil]
                                                                                        )]
                                                                                    [win mat lnum ?]
                                                                                ))
                                                                            [win mat lnum nil])

                                                                ] (not ?) => [win mat lnum]

                                                                    (slow-breakcheck)
                                                                    (recur win mat lnum)
                                                                )
                                                            )]
                                                        (when @a'did_sub
                                                            (swap! a'sub_nlines inc))
                                                        [win mat lnum]
                                                    )
                                                )]
                                            (slow-breakcheck)
                                            (recur win mat (inc lnum))
                                        )
                                    )]
                                (when (non-zero? @a'first_line)
                                    ;; Need to subtract the number of added lines from "last_line" to get the line number
                                    ;; before the change (same as adding the number of deleted lines).
                                    (let [n (- (line-count @curbuf) o'line_count)]
                                        (swap! curbuf changed-lines @a'first_line, 0, (- @a'last_line n), n)
                                    ))
                                ;; ":s/pat//n" doesn't move the cursor
                                (let [win (if @sub_count (assoc win :w_cursor o'cursor) win)
                                      win (if (< 0 @a'sub_nsubs)
                                            ;; Set the '[ and '] marks.
                                            (let [_ (swap! curbuf update :b_op_start assoc :lnum (:line1 eap) :col 0)
                                                  _ (swap! curbuf update :b_op_end assoc :lnum @a'line2 :col 0)
                                                  win (if eol?
                                                        (coladvance win, MAXCOL)
                                                        (beginline win, (| BL_WHITE BL_FIX)))
                                                  [win _] (do-sub-msg? win, @a'sub_nsubs, @a'sub_nlines, @sub_count)]
                                                win)
                                            (cond
                                                @got_int     (emsg win, e_interr)                ;; interrupted
                                                @a'got_match (msg win, (u8 ""))                  ;; found something, but nothing substituted
                                                @sub_error   (emsg* win, e_patnotf2, @last_expr) ;; nothing found
                                                :else        win)
                                        )]
                                    [win eap])
                            ))
                    ))
            ))
    ))

;; Give message for number of substitutions.
;; Return true if a message was given.

(defn- #_[window_C boolean] do-sub-msg? [#_window_C win, #_long nsubs, #_long nlines, #_boolean count_only] ;; count_only: used 'n' flag for ":s"
    ;; Only report substitutions when:
    ;; - more than 'report' substitutions
    ;; - command was typed by user, or number of changed lines > 'report'
    ;; - giving messages is not disabled by 'lazyredraw'
    (cond (and (or (and (< @p_report nsubs) (or @key_typed (< 1 nlines) (< @p_report 1))) count_only) (messaging))
        (let [#_Bytes buf (Bytes. MSG_BUF_LEN)]
            (if @got_int
                (STRCPY buf, (u8 "(Interrupted) "))
                (eos! buf)
            )
            (if (== nsubs 1)
                (ร .sprintf libC (.plus buf (STRLEN buf)), (u8 "%s"), (if count_only (u8 "1 match") (u8 "1 substitution")))
                (ร .sprintf libC (.plus buf (STRLEN buf)), (if count_only (u8 "%ld matches") (u8 "%ld substitutions")), nsubs)
            )
            (if (== nlines 1)
                (ร .sprintf libC (.plus buf (STRLEN buf)), (u8 "%s"), (u8 " on 1 line"))
                (ร .sprintf libC (.plus buf (STRLEN buf)), (u8 " on %ld lines"), nlines)
            )
            (let [[win ?] (msg? win, buf)]
                (when ? (set-keep-msg buf, 0)) ;; save message to display it after redraw
                [win true]
            ))
    @got_int
        [(emsg win, e_interr) true]
    :else
        [win false]
    ))

;; ex_getln.c: Functions for entering and editing an Ex command line ------------------------------

;; Variables shared between getcmdline(), redrawcmdline() and others.
;; These need to be saved when using CTRL-R |, that's why they are in a structure.

(class! #_final cmdline_info_C
    [
        (field Bytes        cmdbuff)        ;; pointer to command line buffer
        (field int          cmdbufflen)     ;; length of "cmdbuff"
        (field int          cmdlen)         ;; number of chars in command line
        (field int          cmdpos)         ;; current cursor position
        (field int          cmdspos)        ;; cursor column on screen
        (field int          cmdfirstc)      ;; ':', '/', '?', '=' or NUL
        (field int          cmdindent)      ;; number of spaces before cmdline
        (field Bytes        cmdprompt)      ;; message in front of cmdline
        (field int          cmdattr)        ;; attributes for prompt
        (field boolean      overstrike)     ;; Typing mode on the command line.  Shared by getcmdline() and put-on-cmdline().
    ])

;; The current cmdline_info.
;; Initialized in getcmdline() then used by other functions.
;; When invoking getcmdline() recursively, it needs to be saved
;; with save-cmdline() and restored with restore-cmdline().
;; TODO: make it local to getcmdline() and pass it around.

(atom! cmdline_info_C ccline (NEW_cmdline_info_C))

(atom! Bytes**  history     HIST_COUNT)
(atom! int*     hisidx      (repeat HIST_COUNT -1))     ;; last used entry
(atom! int      hislen)                                 ;; actual length of history tables

;; Accept a command line starting with "firstc".
;;
;; firstc == ':'            get ":" command line
;; firstc == '/' or '?'     get search pattern
;; firstc == '='            get expression
;; firstc == '@'            get text for input() function
;; firstc == '>'            get text for debug mode
;; firstc == NUL            get text for :insert command
;; firstc == -1             like NUL, and break on CTRL-C
;;
;; The line is collected in ccline.cmdbuff, which is reallocated to fit the command line.
;;
;; Careful: getcmdline() can be called recursively!
;;
;; Everything that may work recursively should save and restore the current command line.
;; That includes update-screen(), a custom status line may invoke ":normal".
;;
;; Return pointer to allocated string if there is a command line, null otherwise.

(defn- #_[window_C Bytes] getcmdline [#_window_C win, #_int firstc, #_long count]
    ;; count: only used for incremental search
    (let [o'State @State o'msg_scroll @msg_scroll
          o'cursor (:w_cursor win) o'curswant (:w_curswant win) o'leftcol (:w_leftcol win) o'topline (:w_topline win) o'botline (:w_botline win)
          #_boolean break_ctrl_c (== firstc -1) firstc (if break_ctrl_c NUL firstc)]
        (swap! ccline assoc :overstrike false) ;; always start in Insert mode
        (swap! ccline assoc :cmdfirstc (if (== firstc (byte \@)) 0 firstc) :cmdindent 0)
        (alloc-cmdbuff 1) ;; alloc initial ccline.cmdbuff
        (swap! ccline assoc :cmdpos 0 :cmdlen 0)
        (eos! (:cmdbuff @ccline))
        (when (<= firstc 0)
            (swap! ccline assoc :cmdspos 0))
        (let [#_int i @msg_scrolled]
            (reset! msg_scrolled 0) ;; avoid wait-return() message
            (gotocmdline true)
            (swap! msg_scrolled + i)
            (redrawcmdprompt)
            (set-cmdspos))
        ;; Avoid scrolling when called by a recursive do-cmdline(),
        ;; e.g. when doing ":@0" when register 0 doesn't contain a CR.
        (reset! msg_scroll false)
        (reset! State CMDLINE)
        (ui-cursor-shape) ;; may show different cursor shape
        ;; When inside an autocommand for writing "exiting" may be set and terminal mode set to cooked.
        ;; Need to set raw mode here then.
        (settmode TMODE_RAW)
        (init-history)
        (let [#_int histype (hist-char2type firstc)         ;; history type to be used
              a'hiscnt (atom (int @hislen))                 ;; current history line in use; set to impossible history value
              _ (do-digraph -1)                             ;; init digraph typeahead
              ;; If something above caused an error, reset the flags, we do want to type and execute commands.
              ;; Display may be messed up a bit.
              _ (when @did_emsg (redrawcmd))
              _ (reset! did_emsg false)
              _ (reset! got_int false)
              a'gotesc (atom (boolean false))               ;; true when <ESC> just typed
              a'lookfor (atom (#_Bytes object nil))         ;; string to match
              a'did_incsearch (atom (boolean false))
              a'incsearch_postponed (atom (boolean false))
              a'some_key_typed (atom (boolean false))       ;; one of the keys was typed
              ;; Collect the command string, handling editing keys.
              win (loop [win win]
                    (cursorcmd)              ;; set the cursor on the right spot
                    ;; Get a character.
                    ;; Ignore K_IGNORE, it should not do anything.
                    (let-when [[win #_int c] (loop-when-recur [[win c :as _] (safe-vgetc? win)] (== c K_IGNORE) [(safe-vgetc? win)] => _)
                          _ (reset! a'some_key_typed (or @key_typed @a'some_key_typed))
                          ;; Ignore "got_int" when CTRL-C was typed here.
                          ;; Don't ignore it in :global, we really need to break then, e.g. for ":g/pat/normal /pat" (without the <CR>).
                          ;; Don't ignore it for the input() function.
                          _ (when (and (any == c Ctrl_C @intr_char) (!= firstc (byte \@)) (not break_ctrl_c))
                                (reset! got_int false))
                          ;; Free old command line when finished moving around in the history list.
                          _ (when (and (some? @a'lookfor) (not (any == c K_S_DOWN K_S_UP K_DOWN K_UP K_PAGEDOWN K_PAGEUP K_KPAGEDOWN K_KPAGEUP K_LEFT K_RIGHT Ctrl_P Ctrl_N)))
                                (reset! a'lookfor nil))
                          [win ?] (let-when [         ;; CTRL-\ CTRL-N goes to Normal mode,
                                  [win ?] (let-when [ ;; CTRL-\ CTRL-G goes to Insert mode when 'insertmode' is set,
                                          [win c ?]   ;; CTRL-\ e prompts for an expression.
                                            (if (== c Ctrl_BSL)
                                                (let [_ (swap! no_mapping inc) _ (swap! allow_keys inc) [win c] (plain-vgetc? win) _ (swap! no_mapping dec) _ (swap! allow_keys dec)]
                                                    ;; CTRL-\ e doesn't work when obtaining an expression, unless it is in a mapping.
                                                    (cond (and (!= c Ctrl_N) (!= c Ctrl_G) (or (!= c (byte \e)) (and (== (:cmdfirstc @ccline) (byte \=)) @key_typed)))
                                                        (do (vungetc c) [win Ctrl_BSL nil])
                                                    (== c (byte \e))
                                                        ;; Replace the command line with the result of an expression.
                                                        ;; Need to save and restore the current command line, to be able to enter a new one...
                                                        (let-when [o'cmdpos (if (!= (:cmdpos @ccline) (:cmdlen @ccline)) (:cmdpos @ccline) 99999) ;; keep it at the end
                                                              o'cli (save-cmdline) [win c] (get-expr-register? win) _ (restore-cmdline o'cli)
                                                              ? (when (== c (byte \=))
                                                                    ;; Need to save and restore "ccline" and set "textlock" to avoid nasty things
                                                                    ;; like going to another buffer when evaluating an expression.
                                                                    (let-when [o'cli (save-cmdline) _ (swap! textlock inc) #_Bytes s (get-expr-line)
                                                                          _ (swap! textlock dec) _ (restore-cmdline o'cli)] (some? s)
                                                                        (let [#_int n (STRLEN s)]
                                                                            (realloc-cmdbuff (inc n))
                                                                            (swap! ccline assoc :cmdlen n)
                                                                            (STRCPY (:cmdbuff @ccline), s)
                                                                            ;; Restore the cursor or use the position set with set_cmdline_pos().
                                                                            (swap! ccline assoc :cmdpos (min o'cmdpos (:cmdlen @ccline)))
                                                                            (reset! key_typed false) ;; Don't do 'wildchar' completion.
                                                                            (redrawcmd)
                                                                            :cmdline_changed
                                                                        ))
                                                                )] (not ?) => [win c ?]

                                                        (let [win (beep-flush win)]
                                                            (reset! got_int false) ;; don't abandon the command line
                                                            (reset! did_emsg false)
                                                            (reset! emsg_on_display false)
                                                            (redrawcmd)
                                                            [win c :cmdline_not_changed]
                                                        ))
                                                    :else
                                                        (do (when (and (== c Ctrl_G) @p_im (zero? @restart_edit))
                                                                (reset! restart_edit (byte \a)))
                                                            (reset! a'gotesc true) ;; will free ccline.cmdbuff after putting it in history
                                                            [win c :quit]) ;; back to Normal mode
                                                    ))
                                                [win c nil]
                                            )] (not ?) => [win ?]

                                        (let [[win c]
                                                (if (any == c @cedit_key K_CMDWIN)
                                                    (if (not @got_int)
                                                        ;; Open a window to edit the command line (and history).
                                                        (let [[win c] (ex-window? win)] (reset! a'some_key_typed true) [win c])
                                                        [win c])
                                                    [win (do-digraph c)]
                                                )]
                                            (if (or (any == c (byte \newline) (byte \return) K_KENTER) (and (== c ESC) (or (not @key_typed) (some? (vim-strbyte @p_cpo, CPO_ESC)))))
                                                (do (reset! a'gotesc false) ;; Might have typed ESC previously, don't truncate the cmdline now.
                                                    (windgoto @msg_row, 0)
                                                    (out-flush)
                                                    [win :quit])

                                                (let-when [_ (reset! a'gotesc false)
                                                      c (if (any == c NUL K_ZERO) NL c) ;; NUL is stored as NL
                                                      a'do_abbr (atom (boolean true))   ;; default: check for abbreviation
                                                      [win c ?]
                                                        (condp ==? c ;; Big switch for a typed command line character.

                                                           [K_BS Ctrl_H K_DEL K_KDEL Ctrl_W]
                                                                (let [c (if (== c K_KDEL) K_DEL c)]
                                                                    ;; Delete current character is the same as backspace on next character, except at end of line.
                                                                    (when (and (== c K_DEL) (!= (:cmdpos @ccline) (:cmdlen @ccline)))
                                                                        (swap! ccline update :cmdpos inc))
                                                                    (when (== c K_DEL)
                                                                        (swap! ccline update :cmdpos #(+ % (us-off-next (:cmdbuff @ccline), (.plus (:cmdbuff @ccline) %)))))
                                                                    (cond (< 0 (:cmdpos @ccline))
                                                                        (let [#_Bytes p (:cmdbuff @ccline) #_int j (:cmdpos @ccline)
                                                                              #_Bytes s (us-prevptr p, (.plus p j))
                                                                              s (if (== c Ctrl_W)
                                                                                    (let [s (loop-when-recur s (and (BLT p, s) (vim-isspace (.at s 0))) (us-prevptr p, s) => s)
                                                                                          #_int cls (us-get-class s)
                                                                                          s (loop-when-recur s (and (BLT p, s) (== (us-get-class s) cls)) (us-prevptr p, s) => s)]
                                                                                        s (if (!= (us-get-class s) cls) (.plus s (us-ptr2len-cc s)) s))
                                                                                    s
                                                                                )]
                                                                            (swap! ccline assoc :cmdpos (BDIFF s, p))
                                                                            (swap! ccline update :cmdlen - (- j (:cmdpos @ccline)))
                                                                            (loop-when-recur [#_int i (:cmdpos @ccline) j j] (< i (:cmdlen @ccline)) [(inc i) (inc j)]
                                                                                (.be p i, (.at p j)))
                                                                            ;; Truncate at the end, required for multi-byte chars.
                                                                            (eos! p (:cmdlen @ccline))
                                                                            (redrawcmd)
                                                                            [win c :cmdline_changed])
                                                                    (and (zero? (:cmdlen @ccline)) (!= c Ctrl_W) (nil? (:cmdprompt @ccline)))
                                                                        (do (swap! ccline assoc :cmdbuff nil) ;; no command line to return
                                                                            (reset! msg_col 0)
                                                                            (msg-putchar (byte \space)) ;; delete ':'
                                                                            (reset! redraw_cmdline true)
                                                                            [win c :quit]) ;; back to cmd mode
                                                                    :else
                                                                        [win c :cmdline_changed]
                                                                    ))

                                                           [K_INS K_KINS]
                                                                (do (swap! ccline update :overstrike not)
                                                                    (ui-cursor-shape) ;; may show different cursor shape
                                                                    [win c :cmdline_not_changed])

                                                            Ctrl_HAT
                                                                [win c :cmdline_not_changed]

                                                            Ctrl_U ;; Delete all characters left of the cursor.
                                                                (let [#_int i 0 #_int j (:cmdpos @ccline)
                                                                      _ (swap! ccline assoc :cmdpos i)
                                                                      _ (swap! ccline update :cmdlen - j)
                                                                      #_Bytes p (:cmdbuff @ccline) #_int n (:cmdlen @ccline)]
                                                                    (loop-when-recur [i i j j] (< i n) [(inc i) (inc j)]
                                                                        (.be p i, (.at p j)))
                                                                    ;; Truncate at the end, required for multi-byte chars.
                                                                    (eos! p n)
                                                                    (redrawcmd)
                                                                    [win c :cmdline_changed])

                                                           [ESC Ctrl_C] ;; get here when ESC typed twice
                                                                (do (reset! a'gotesc true) ;; will free ccline.cmdbuff after putting it in history
                                                                    [win c :quit]) ;; back to cmd mode

                                                            Ctrl_R ;; insert register
                                                                (let-when [_ (putcmdline (byte \"), true) ;; """
                                                                      _ (swap! no_mapping inc)
                                                                      [win c] (plain-vgetc? win) #_int k c                  ;; CTRL-R <char>
                                                                      k (if (== k Ctrl_O) Ctrl_R k)                         ;; CTRL-R CTRL-O == CTRL-R CTRL-R
                                                                      [win c] (if (== k Ctrl_R) (plain-vgetc? win) [win c]) ;; CTRL-R CTRL-R <char>
                                                                      _ (swap! no_mapping dec)
                                                                      ;; Insert the result of an expression.
                                                                      ;; Need to save the current command line, to be able to enter a new one...
                                                                      [win c]
                                                                        (when' (== c (byte \=)) => [win c]
                                                                            (if (== (:cmdfirstc @ccline) (byte \=)) ;; can't do this recursively
                                                                                [(beep-flush win) ESC]
                                                                                (let [o'cli (save-cmdline) [win c] (get-expr-register? win) _ (restore-cmdline o'cli)]
                                                                                    [win c])
                                                                            ))
                                                                      [win ?]
                                                                        (when' (!= c ESC) => [win nil]           ;; use ESC to cancel inserting register
                                                                            (let [[win _] (cmdline-paste? win, c, (== k Ctrl_R), false)]
                                                                                ;; When there was a serious error, abort getting the command line.
                                                                                (if @got_int
                                                                                    (do (reset! a'gotesc true)   ;; will free ccline.cmdbuff after putting it in history
                                                                                        [win :quit])             ;; back to cmd mode
                                                                                    (do (reset! key_typed false) ;; don't do 'wildchar' completion
                                                                                        [win nil])
                                                                                ))
                                                                        )] (not ?) => [win c ?]

                                                                    (redrawcmd)
                                                                    [win c :cmdline_changed])

                                                           [K_RIGHT K_S_RIGHT K_C_RIGHT]
                                                                (do (loop-when [] (< (:cmdpos @ccline) (:cmdlen @ccline))
                                                                        (let [#_int n (cmdline-charsize (:cmdpos @ccline))]
                                                                            (when-not (and @key_typed (<= (* @Rows @Cols) (+ (:cmdspos @ccline) n)))
                                                                                (swap! ccline update :cmdspos + n)
                                                                                (swap! ccline update :cmdpos #(+ % (us-ptr2len-cc (:cmdbuff @ccline), %)))
                                                                                (recur-if (and (or (== c K_S_RIGHT) (== c K_C_RIGHT)
                                                                                                   (flag? @mod_mask (| MOD_MASK_SHIFT MOD_MASK_CTRL)))
                                                                                               (not-at? (:cmdbuff @ccline) (:cmdpos @ccline) (byte \space)))
                                                                                          []
                                                                                ))
                                                                        ))
                                                                    (set-cmdspos-cursor)
                                                                    [win c :cmdline_not_changed])

                                                           [K_LEFT K_S_LEFT K_C_LEFT]
                                                                (do (when (< 0 (:cmdpos @ccline))
                                                                        (loop []
                                                                            (swap! ccline update :cmdpos dec)
                                                                            ;; move to first byte of char
                                                                            (swap! ccline update :cmdpos #(- % (us-head-off (:cmdbuff @ccline), (.plus (:cmdbuff @ccline) %))))
                                                                            (swap! ccline update :cmdspos - (cmdline-charsize (:cmdpos @ccline)))
                                                                            (recur-if (and (< 0 (:cmdpos @ccline))
                                                                                           (or (== c K_S_LEFT) (== c K_C_LEFT) (flag? @mod_mask (| MOD_MASK_SHIFT MOD_MASK_CTRL)))
                                                                                           (not-at? (:cmdbuff @ccline) (dec (:cmdpos @ccline)) (byte \space)))
                                                                                      []
                                                                            ))
                                                                        (set-cmdspos-cursor))
                                                                    [win c :cmdline_not_changed])

                                                            K_IGNORE ;; Ignore mouse event or ex-window() result.
                                                                [win c :cmdline_not_changed]

                                                            K_DROP
                                                                (let [[win _] (cmdline-paste? win, (byte \~), true, false)]
                                                                    (redrawcmd)
                                                                    [win c :cmdline_changed])

                                                            K_SELECT ;; end of Select mode mapping - ignore
                                                                [win c :cmdline_not_changed]

                                                           [Ctrl_B K_HOME K_KHOME K_S_HOME K_C_HOME] ;; begin of command line
                                                                (do (swap! ccline assoc :cmdpos 0)
                                                                    (set-cmdspos)
                                                                    [win c :cmdline_not_changed])

                                                           [Ctrl_E K_END K_KEND K_S_END K_C_END] ;; end of command line
                                                                (do (swap! ccline assoc :cmdpos (:cmdlen @ccline))
                                                                    (set-cmdspos-cursor)
                                                                    [win c :cmdline_not_changed])

                                                            Ctrl_L
                                                                (when' (and @p_is (any == firstc (byte \/) (byte \?))) => [win c nil]
                                                                    ;; Add a character from under the cursor for 'incsearch'.
                                                                    (if (and @a'did_incsearch (not (eqpos (:w_cursor win), o'cursor)))
                                                                        (let [c (gchar-cursor win)
                                                                              ;; If 'ignorecase' and 'smartcase' are set and the command line
                                                                              ;; has no uppercase characters, convert the character to lowercase.
                                                                              c (if (and @p_ic @p_scs (not (re-has-uppercase? (:cmdbuff @ccline)))) (utf-tolower c) c)]
                                                                            (if (!= c NUL)
                                                                                (let [c (if (or (== c firstc) (some? (vim-strchr (if @p_magic (u8 "\\^$.*[") (u8 "\\^$")), c)))
                                                                                            ;; put a backslash before special characters
                                                                                            (do (stuff-char c) (byte \\))
                                                                                            c
                                                                                        )]
                                                                                    [win c nil])
                                                                                [win c :cmdline_not_changed]
                                                                            ))
                                                                        [win c :cmdline_not_changed]
                                                                    ))

                                                           [Ctrl_P K_UP   K_S_UP   K_PAGEUP   K_KPAGEUP     ;; previous match
                                                            Ctrl_N K_DOWN K_S_DOWN K_PAGEDOWN K_KPAGEDOWN]  ;; next match
                                                                (if (or (zero? @hislen) (== firstc NUL))    ;; no history
                                                                    [win c :cmdline_not_changed]

                                                                    (let [#_int i @a'hiscnt]
                                                                        ;; save current command string so it can be restored later
                                                                        (when (nil? @a'lookfor)
                                                                            (reset! a'lookfor (eos! (STRDUP (:cmdbuff @ccline)) (:cmdpos @ccline))))
                                                                        (loop []
                                                                            (let-when [#_int x @a'hiscnt
                                                                                  [x ?]
                                                                                    (cond (any == c K_UP K_S_UP Ctrl_P K_PAGEUP K_KPAGEUP)  ;; one step backwards
                                                                                        (cond (== x @hislen)                                ;; first time
                                                                                            [(... @hisidx histype) nil]
                                                                                        (and (zero? x) (!= (... @hisidx histype) (dec @hislen)))
                                                                                            [(dec @hislen) nil]
                                                                                        (!= x (inc (... @hisidx histype)))
                                                                                            [(dec x) nil]
                                                                                        :else                                               ;; at top of list
                                                                                            [i :break])
                                                                                    :else                                               ;; one step forwards
                                                                                        (cond (== x (... @hisidx histype))              ;; on last entry, clear the line
                                                                                            [@hislen :break]
                                                                                        (== x @hislen)                                  ;; not on a history line, nothing to do
                                                                                            [x :break]
                                                                                        :else
                                                                                            [(if (== x (dec @hislen)) 0 (inc x)) nil])  ;; wrap around
                                                                                    )
                                                                                  _ (reset! a'hiscnt x)
                                                                            ] (not ?) => ?

                                                                                (cond (or (< @a'hiscnt 0) (nil? (... (... @history histype) @a'hiscnt)))
                                                                                    (do (reset! a'hiscnt i)
                                                                                        :break)
                                                                                (or (and (!= c K_UP) (!= c K_DOWN))
                                                                                    (== @a'hiscnt i)
                                                                                    (zero? (STRNCMP (... (... @history histype) @a'hiscnt), @a'lookfor, (STRLEN @a'lookfor))))
                                                                                    (do :break)
                                                                                :else
                                                                                    (recur))
                                                                            ))
                                                                        (when' (!= @a'hiscnt i) => [(beep-flush win) c :cmdline_not_changed] ;; jumped to other entry
                                                                            (let [_ (swap! ccline assoc :cmdbuff nil)
                                                                                  #_Bytes s (if (== @a'hiscnt @hislen) @a'lookfor (... (... @history histype) @a'hiscnt))
                                                                                  a'firstc (atom (int))]
                                                                                (cond (and (== histype HIST_SEARCH) (BNE s, @a'lookfor)
                                                                                           (!= (reset! a'firstc (.at s (inc (STRLEN s)))) firstc))
                                                                                    ;; Correct the separator char used when adding the history entry vs. the one used now.
                                                                                    ;; First loop: count length.
                                                                                    ;; Second loop: copy the characters.
                                                                                    (dotimes [round 2]
                                                                                        (let [n (loop-when [n 0 i 0] (non-eos? s i) => n
                                                                                                    (let [n (if (and (at? s i @a'firstc)
                                                                                                                     (or (zero? i) (not-at? s (dec i) (byte \\))))
                                                                                                                ;; Replace old sep with new sep, unless it is escaped.
                                                                                                                (do (when (< 0 round) (.be (:cmdbuff @ccline) n, firstc))
                                                                                                                    n)
                                                                                                                ;; Escape new sep, unless it is already escaped.
                                                                                                                (let [n (if (and (at? s i firstc)
                                                                                                                                 (or (zero? i) (not-at? s (dec i) (byte \\))))
                                                                                                                            (do (when (< 0 round)
                                                                                                                                    (.be (:cmdbuff @ccline) n, (byte \\)))
                                                                                                                                (inc n))
                                                                                                                            n
                                                                                                                        )]
                                                                                                                    (when (< 0 round) (.be (:cmdbuff @ccline) n, (.at s i)))
                                                                                                                    n)
                                                                                                            )]
                                                                                                        (recur (inc n) (inc i)))
                                                                                                )]
                                                                                            (if (< 0 round) (eos! (:cmdbuff @ccline) n) (alloc-cmdbuff n))
                                                                                        ))
                                                                                :else
                                                                                    (do (alloc-cmdbuff (STRLEN s))
                                                                                        (STRCPY (:cmdbuff @ccline), s)
                                                                                    ))
                                                                                (let [n (STRLEN (:cmdbuff @ccline))] (swap! ccline assoc :cmdpos n :cmdlen n))
                                                                                (redrawcmd)
                                                                                [win c :cmdline_changed]
                                                                            ))
                                                                    ))

                                                           [Ctrl_V Ctrl_Q]
                                                                (let [_ (putcmdline (byte \^), true) [win c] (get-literal? win)] ;; get next (two) character(s)
                                                                    (reset! a'do_abbr false)    ;; don't do abbreviation now
                                                                    (when (utf-iscomposing c)   ;; may need to remove ^ when composing char was typed
                                                                        (draw-cmdline (:cmdpos @ccline), (- (:cmdlen @ccline) (:cmdpos @ccline)))
                                                                        (msg-putchar (byte \space))
                                                                        (cursorcmd))
                                                                    [win c nil])

                                                            Ctrl_K
                                                                (let [_ (putcmdline (byte \?), true) [win c] (get-digraph? win, true)]
                                                                    (if (!= c NUL)
                                                                        [win c nil]
                                                                        (do (redrawcmd) [win c :cmdline_not_changed])
                                                                    ))

                                                            (if (== c @intr_char)
                                                                (do (reset! a'gotesc true)  ;; will free ccline.cmdbuff after putting it in history
                                                                    [win c :quit])          ;; back to Normal mode

                                                                ;; Normal character with no special meaning.
                                                                ;; Just set "mod_mask" to 0 so that typing shift-space in the GUI doesn't enter the string <S-Space>.
                                                                ;; This should only happen after ^V.
                                                                (do (when (not (is-special c))
                                                                        (reset! mod_mask 0))
                                                                    [win c nil]
                                                                ))
                                                        )] (not ?) => [win ?]

                                                    ;; End of switch on command line character.
                                                    ;; We come here if we have a normal character.
                                                    (cond (and @a'do_abbr (or (is-special c) (not (vim-iswordc c))) (== c Ctrl_RSB))
                                                        nil
                                                    ;; Put the character in the command line.
                                                    (or (is-special c) (non-zero? @mod_mask))
                                                        (put-on-cmdline (get-special-key-name c, @mod_mask), -1, true)
                                                    :else
                                                        (let [#_int i (utf-char2bytes c, ioBuff)]
                                                            (eos! ioBuff i) ;; exclude composing chars
                                                            (put-on-cmdline ioBuff, i, true)
                                                        ))
                                                    [win :cmdline_changed]
                                                ))
                                        ))
                            ] (== ? :cmdline_not_changed) => [win (when-not (== ? :cmdline_changed) ?)]

                                ;; This part implements incremental searches for "/" and "?"
                                ;; Jump to :cmdline_not_changed when a character has been read but the command line did not change.
                                ;; Then we only search and redraw if something changed in the past.
                                ;; Jump to :cmdline_changed when the command line did change.
                                [win (when-not @a'incsearch_postponed :recur)]
                            )] (not ?) => (if (== ? :recur) (recur win) win)

                        ;; 'incsearch' highlighting
                        (let [win (if (and @p_is (any == firstc (byte \/) (byte \?)))
                                    ;; if there is a character waiting, search and redraw later
                                    (if (char-avail)
                                        (do (reset! a'incsearch_postponed true) win)

                                        (let [_ (reset! a'incsearch_postponed false)
                                              win (assoc win :w_cursor o'cursor)                    ;; start at old position
                                              [win #_int i]
                                                (if (zero? (:cmdlen @ccline))                       ;; if there is no command line, don't do anything
                                                    [win 0]
                                                    (let [_ (cursor-off) _ (out-flush)              ;; so the user knows we're busy
                                                          _ (swap! emsg_off inc)                    ;; so it doesn't beep if bad expr
                                                          #_long nsec (profile-setlimit 500)        ;; set the time limit to half a second
                                                          [win i _]
                                                            (do-search? win, (byte firstc), (:cmdbuff @ccline), count, (| SEARCH_KEEP SEARCH_OPT SEARCH_NOOF SEARCH_PEEK), nsec)
                                                          _ (swap! emsg_off dec)]
                                                        (if @got_int                                ;; if interrupted while searching, behave like it failed
                                                            (let [[win _] (vpeekc? win)]            ;; remove <C-C> from input stream
                                                                (reset! got_int false)              ;; don't abandon the command line
                                                                [win 0])
                                                            (do (when (char-avail)                  ;; cancelled searching because a char was typed
                                                                    (reset! a'incsearch_postponed true))
                                                                [win i]
                                                            ))
                                                    ))
                                              _ (reset! highlight_match (non-zero? i))
                                              ;; First restore the old "win" values, so the screen is positioned in the same way as the actual search command.
                                              win (assoc win :w_leftcol o'leftcol, :w_topline o'topline, :w_botline o'botline)
                                              win (changed-cline-bef-curs win)
                                              win (update-topline win)
                                              [#_pos_C end win]
                                                (when' (non-zero? i) => [(:w_cursor win) win]
                                                    (let [o'c (:w_cursor win)
                                                          ;; First move the cursor to the end of the match, then to the start.
                                                          ;; This moves the whole match onto the screen when 'nowrap' is set.
                                                          win (-> win
                                                                (update-in [:w_cursor :lnum] + @search_match_lines)
                                                                (assoc-in [:w_cursor :col] @search_match_endcol))
                                                          lmax (line-count @curbuf)
                                                          win (if (< lmax (:lnum (:w_cursor win)))
                                                                (-> win
                                                                    (assoc-in [:w_cursor :lnum] lmax)
                                                                    (coladvance MAXCOL))
                                                                win)
                                                          win (validate-cursor win)]
                                                        [(:w_cursor win) (assoc win :w_cursor o'c)]
                                                    ))
                                              win (validate-cursor win)
                                              ;; May redraw the status line to show the cursor position.
                                              win (if (and @p_ru (< 0 (:w_status_height win))) (assoc win :w_redr_status true) win)
                                              o'cli (save-cmdline) win (update-screen win, SOME_VALID) _ (restore-cmdline o'cli)
                                              ;; Leave it at the end to make CTRL-R CTRL-W work.
                                              win (if (non-zero? i) (assoc win :w_cursor end) win)]
                                            (msg-starthere)
                                            (redrawcmdline)
                                            (reset! a'did_incsearch true)
                                            win
                                        ))
                                    win
                                )]
                            (recur win))
                    ))
              win (when' @a'did_incsearch => win
                    (let [win (assoc win :w_cursor o'cursor, :w_curswant o'curswant, :w_leftcol o'leftcol, :w_topline o'topline, :w_botline o'botline)]
                        (reset! highlight_match false)
                        ;; needed for TAB
                        (-> win (validate-cursor) (redraw-later SOME_VALID))
                    ))
              win (when' (some? (:cmdbuff @ccline)) => win
                    ;; Put line in history buffer (":" and "=" only when it was typed).
                    (when (and (non-zero? (:cmdlen @ccline)) (!= firstc NUL) (or @a'some_key_typed (== histype HIST_SEARCH)))
                        (add-to-history histype, (:cmdbuff @ccline), (if (== histype HIST_SEARCH) firstc NUL))
                        (when (== firstc (byte \:))
                            (reset! new_last_cmdline (STRDUP (:cmdbuff @ccline)))
                        ))
                    (when' @a'gotesc => win ;; abandon command line
                        (swap! ccline assoc :cmdbuff nil)
                        (when (zero? @msg_scrolled)
                            (compute-cmdrow))
                        (let [win (msg win, (u8 ""))]
                            (reset! redraw_cmdline true)
                            win
                        ))
                )]
            ;; If the screen was shifted up, redraw the whole screen (later).
            ;; If the line is too long, clear it, so ruler and shown command do not get printed in the middle of it.
            (msg-check)
            (reset! msg_scroll o'msg_scroll)
            ;; When the command line was typed, no need for a wait-return() prompt.
            (when @a'some_key_typed
                (reset! need_wait_return false))
            (reset! State o'State)
            (ui-cursor-shape) ;; may show different cursor shape
            (let [#_Bytes s (:cmdbuff @ccline)]
                ;; Make "ccline" empty, getcmdline() may try to use it.
                (swap! ccline assoc :cmdbuff nil)
                [win s]
            ))
    ))

;; Return true when the text must not be changed and we can't switch to
;; another window or buffer.  Used when editing the command line, etc.

(defn- #_boolean text-locked []
    (or (non-zero? @cmdwin_type) (non-zero? @textlock)))

;; Give an error message for a command that isn't allowed while the cmdline
;; window is open or editing the cmdline in another way.

(defn- #_window_C text-locked-msg [#_window_C win]
    (emsg win, (if (non-zero? @cmdwin_type) e_cmdwin e_secure)))

(defn- #_int cmdline-charsize [#_int idx]
    (mb-ptr2cells (:cmdbuff @ccline), idx))

;; Compute the offset of the cursor on the command line for the prompt.

(defn- #_void set-cmdspos []
    (swap! ccline assoc :cmdspos (+ (if (!= (:cmdfirstc @ccline) NUL) 1 0) (:cmdindent @ccline)))
    nil)

;; Compute the screen position for the cursor on the command line.

(defn- #_void set-cmdspos-cursor []
    (set-cmdspos)
    (let [#_int m (if @key_typed (let [m (* @Cols @Rows)] (if (< m 0) MAXCOL m)) MAXCOL)]
        (loop-when [#_int i 0] (and (< i (:cmdlen @ccline)) (< i (:cmdpos @ccline)))
            (let [#_int c (cmdline-charsize i)]
                ;; Count ">" for double-wide multi-byte char that doesn't fit.
                (correct-cmdspos i, c)
                ;; If the cmdline doesn't fit, show cursor on last visible char.
                ;; Don't move the cursor itself, so we can still append.
                (when (< (+ (:cmdspos @ccline) c) m)
                    (swap! ccline update :cmdspos + c)
                    (recur (+ i (us-ptr2len-cc (:cmdbuff @ccline), i)))
                )
            ))
    )
    nil)

;; Check if the character at "idx", which is "cells" wide, is a multi-byte
;; character that doesn't fit, so that a ">" must be displayed.

(defn- #_void correct-cmdspos [#_int idx, #_int cells]
    (let [pos (.plus (:cmdbuff @ccline) idx) cols @Cols]
        (when (and (< 1 (us-ptr2len-cc pos)) (< 1 (us-ptr2cells pos)) (< cols (+ (% (:cmdspos @ccline) cols) cells)))
            (swap! ccline update :cmdspos inc)
        ))
    nil)

;; Get an Ex command line for the ":" command.

(defn- #_[window_C Bytes] getexline [#_window_C win]
    (getcmdline win, (byte \:), 1))

;; Allocate a new command line buffer.
;; Assigns the new buffer to ccline.cmdbuff and ccline.cmdbufflen.
;; Returns the new value of ccline.cmdbuff and ccline.cmdbufflen.

(defn- #_void alloc-cmdbuff [#_int len]
    (let [len (if (< len 80) 100 (+ len 20))] ;; give some extra space to avoid having to allocate all the time
        (swap! ccline assoc :cmdbuff (Bytes. len) :cmdbufflen len))
    nil)

;; Re-allocate the command line to length len + something extra.

(defn- #_void realloc-cmdbuff [#_int len]
    (if-not (< len (:cmdbufflen @ccline))
        (let [#_Bytes s (:cmdbuff @ccline)]
            (alloc-cmdbuff len) ;; will get some more
            ;; There isn't always a NUL after the command, but it may need to be there,
            ;; thus copy up to the NUL and add a NUL.
            (BCOPY (:cmdbuff @ccline), s, (:cmdlen @ccline))
            (eos! (:cmdbuff @ccline) (:cmdlen @ccline))
        ))
    nil)

;; Draw part of the cmdline at the current cursor position.

(defn- #_void draw-cmdline [#_int start, #_int len]
    (msg-outtrans-len (.plus (:cmdbuff @ccline) start), len)
    nil)

;; Put a character on the command line.  Shifts the following text to the
;; right when "shift" is true.  Used for CTRL-V, CTRL-K, etc.
;; "c" must be printable (fit in one display cell)!

(defn- #_void putcmdline [#_int c, #_boolean shift]
    (reset! msg_no_more true)
    (msg-putchar c)
    (if shift (let [pos (:cmdpos @ccline) len (:cmdlen @ccline)]
        (draw-cmdline pos, (- len pos))))
    (reset! msg_no_more false)
    (cursorcmd)
    nil)

;; Undo a putcmdline(c, false).

(defn- #_void unputcmdline []
    (reset! msg_no_more true)
    (let [pos (:cmdpos @ccline) len (:cmdlen @ccline)]
        (if (== len pos)
            (msg-putchar (byte \space))
            (draw-cmdline pos, (us-ptr2len-cc (:cmdbuff @ccline), pos))))
    (reset! msg_no_more false)
    (cursorcmd)
    nil)

;; Put the given string, of the given length, onto the command line.
;; If len is -1, then STRLEN() is used to calculate the length.
;; If 'redraw' is true then the new part of the command line, and the remaining part
;; will be redrawn, otherwise it will not.  If this function is called twice in a row,
;; then 'redraw' should be false and redrawcmd() should be called afterwards.

(defn- #_void put-on-cmdline [#_Bytes str, #_int len, #_boolean redraw]
    (let [len (if (< len 0) (STRLEN str) len)]

        ;; Check if ccline.cmdbuff needs to be longer.
        (let-when [more (+ (:cmdlen @ccline) len 1)] (<= (:cmdbufflen @ccline) more)
            (realloc-cmdbuff more))

        (let [cbuf (:cmdbuff @ccline) cpos (:cmdpos @ccline)]
            (swap! ccline update :cmdlen #(if (not (:overstrike @ccline))
                (do
                    (BCOPY cbuf, (+ cpos len), cbuf, cpos, (- % cpos))
                    (+ % len)
                )
                (let [#_int m (loop [#_int m 0 #_int n 0] (if (< n len) (recur (inc m) (+ n (us-ptr2len-cc str, n))) m))
                      #_int n (loop [m m #_int n cpos] (if (and (< n %) (< 0 m)) (recur (dec m) (+ n (us-ptr2len-cc cbuf, n))) n))]
                    ;; m: nof characters in the new string ;; n: nof bytes in cmdline that are overwritten by these characters
                    (if (< n %)
                        (do
                            (BCOPY cbuf, (+ cpos len), cbuf, n, (- % n))
                            (+ % (- (+ cpos len) n))
                        )
                        (+ cpos len)
                    )
                )))
            (BCOPY cbuf, cpos, str, 0, len)
            (eos! cbuf (:cmdlen @ccline))
        )

        (let [cbuf (:cmdbuff @ccline)
              ;; When the inserted text starts with a composing character, backup to the character before it.  There could be two of them.
              [_ len] (loop-when [#_int i 0 len len] (and (< 0 (:cmdpos @ccline)) (utf-iscomposing (us-ptr2char cbuf, (:cmdpos @ccline)))) => [(non-zero? i) len]
                        (let [i (inc (us-head-off cbuf, (.plus cbuf (dec (:cmdpos @ccline)))))]
                            (swap! ccline update :cmdpos - i)
                            (recur i (+ len i))
                        ))]
            (when _ ;; Also backup the cursor position.
                (let [#_int i (mb-ptr2cells cbuf, (:cmdpos @ccline))]
                    (swap! ccline update :cmdspos - i)
                    (swap! msg_col - i)
                    (when (< @msg_col 0) (swap! msg_col + @Cols) (swap! msg_row dec))
                ))

            (when redraw
                (reset! msg_no_more true)
                (let [#_int i @cmdline_row]
                    (cursorcmd)
                    (draw-cmdline (:cmdpos @ccline), (- (:cmdlen @ccline) (:cmdpos @ccline)))
                    ;; Avoid clearing the rest of the line too often.
                    (when (or (!= @cmdline_row i) (:overstrike @ccline))
                        (msg-clr-eos)
                    ))
                (reset! msg_no_more false))

            (let [#_int m (if @key_typed (let [m (* @Cols @Rows)] (if (< m 0) MAXCOL m)) MAXCOL)]

                (loop-when [#_int i 0] (< i len)
                    (let [#_int n (cmdline-charsize (:cmdpos @ccline))]
                        ;; Count ">" for a double-wide char that doesn't fit.
                        (correct-cmdspos (:cmdpos @ccline), n)
                        ;; Stop cursor at the end of the screen, but do increment the insert position,
                        ;; so that entering a very long command works, even though you can't see it.
                        (when (< (+ (:cmdspos @ccline) n) m)
                            (swap! ccline update :cmdspos + n))
                        (let [n (min (dec (us-ptr2len-cc cbuf, (:cmdpos @ccline))) (- len i 1))]
                            (swap! ccline update :cmdpos + n 1)
                            (recur (+ i n 1))
                        )
                    ))

                (when redraw (msg-check))
            )
        ))
    nil)

;; Save ccline, because obtaining the "=" register may execute "normal :cmd" and overwrite it.

(defn- #_cmdline_info_C save-cmdline []
    (let [#_cmdline_info_C cli @ccline]
        (swap! ccline assoc :cmdbuff nil :cmdprompt nil)
        cli
    ))

;; Restore ccline after it has been saved with save-cmdline().

(defn- #_void restore-cmdline [#_cmdline_info_C cli]
    (reset! ccline cli)
    nil)

;; Paste a yank register into the command line.
;; Used by CTRL-R command in command-line mode.
;; insert-reg() can't be used here, because special characters from the register contents will be interpreted as commands.
;;
;; literally: insert text literally instead of "as typed"
;; remcr: remove trailing CR
;;
;; return false for failure, true otherwise

(defn- #_[window_C boolean] cmdline-paste? [#_window_C win, #_int regname, #_boolean literally, #_boolean remcr]
    ;; Check for valid regname.  ;; Also accept special characters for CTRL-R in the command line.
    ;; A register containing CTRL-R can cause an endless loop.  ;; Allow using CTRL-C to break the loop.
    (when' (and (or (any == regname Ctrl_F Ctrl_P Ctrl_W Ctrl_A) (valid-yank-reg regname, false)) (not (slow-breakcheck))) => [win false]
        (let [regname (may-get-selection regname)
              ;; Need to save and restore ccline.
              o'cli (save-cmdline)
              ;; Also set "textlock" to avoid nasty things like going to another buffer when evaluating an expression.
              _ (swap! textlock inc) a'arg (atom (#_Bytes object)) [win ?] (get-spec-reg? win, regname, a'arg) _ (swap! textlock dec)
              _ (restore-cmdline o'cli)
              ? (if ? ;; Got the value of a special register in "arg".
                    (and (some? @a'arg)
                         (let [#_Bytes s ;; When 'incsearch' is set and CTRL-R CTRL-W used: skip the duplicate part of the word.
                                (if (and @p_is (== regname Ctrl_W))
                                    (let [#_Bytes w ;; Locate start of last word in the cmd buffer.
                                            (loop-when [w (.plus (:cmdbuff @ccline) (:cmdpos @ccline))] (BLT (:cmdbuff @ccline), w) => w
                                                (let [#_int n (inc (us-head-off (:cmdbuff @ccline), (.minus w 1)))]
                                                    (recur-if (vim-iswordc (us-ptr2char w, (- n))) [(.minus w n)] => w)
                                                ))
                                          #_int n (BDIFF (.plus (:cmdbuff @ccline) (:cmdpos @ccline)), w)]
                                        (if (if @p_ic (zero? (STRNCASECMP w, @a'arg, n)) (zero? (STRNCMP w, @a'arg, n))) (.plus @a'arg n) @a'arg))
                                    @a'arg
                                )]
                            (cmdline-paste-str s, literally)
                        ))
                    (cmdline-paste-reg regname, literally, remcr)
                )]
            [win ?]
        )
    ))

;; Put a string on the command line.
;; When "literally" is true, insert literally.
;; When "literally" is false, insert as typed, but don't leave the command line.

(defn- #_boolean cmdline-paste-str [#_Bytes _s, #_boolean literally]
    (let [a's (atom (#_Bytes object _s))]
        (if literally
            (put-on-cmdline @a's, -1, true)
            (while (non-eos? @a's)
                (let [#_int cv (.at @a's 0)]
                    (when (and (== cv Ctrl_V) (non-eos? @a's 1))
                        (swap! a's plus 1))
                    (let [#_int c (us-ptr2char-adv a's, false)]
                        (when (or (== cv Ctrl_V) (any == c ESC Ctrl_C CAR NL Ctrl_L @intr_char) (and (== c Ctrl_BSL) (at? @a's Ctrl_N)))
                            (stuff-char Ctrl_V))
                        (stuff-char c))
                ))
        ))
    true)

;; this function is called when the screen size changes and with incremental search

(defn- #_void redrawcmdline []
    (reset! need_wait_return false)
    (compute-cmdrow)
    (redrawcmd)
    (cursorcmd)
    nil)

(defn- #_void redrawcmdprompt []
    (let [firstc (:cmdfirstc @ccline) prompt (:cmdprompt @ccline)]
        (when (!= firstc NUL)
            (msg-putchar firstc))
        (if (some? prompt)
            (do
                (msg-puts-attr prompt, (:cmdattr @ccline))
                (swap! ccline assoc :cmdindent (+ @msg_col (* (- @msg_row @cmdline_row) @Cols)))
                ;; do the reverse of set-cmdspos()
                (when (!= firstc NUL)
                    (swap! ccline update :cmdindent dec))
            )
            (dotimes [_ (:cmdindent @ccline)] (msg-putchar (byte \space)))
        ))
    nil)

;; Redraw what is currently on the command line.

(defn- #_void redrawcmd []
    ;; when 'incsearch' is set there may be no command line while redrawing
    (cond (nil? (:cmdbuff @ccline))
    (do
        (windgoto @cmdline_row, 0)
        (msg-clr-eos)
    )
    :else
    (do
        (msg-start)
        (redrawcmdprompt)

        ;; Don't use more prompt, truncate the cmdline if it doesn't fit.
        (reset! msg_no_more true)
        (draw-cmdline 0, (:cmdlen @ccline))
        (msg-clr-eos)
        (reset! msg_no_more false)

        (set-cmdspos-cursor)

        ;; An emsg() before may have set msg_scroll.
        ;; This is used in normal mode, in cmdline mode we can reset them now.

        (reset! msg_scroll false)       ;; next message overwrites cmdline

        ;; Typing ':' at the more prompt may set skip_redraw.
        ;; We don't want this in cmdline mode.
        (reset! skip_redraw false)
    ))
    nil)

(defn- #_void compute-cmdrow []
    (reset! cmdline_row (if (non-zero? @msg_scrolled) (dec @Rows) (+ (:w_winrow @lastwin) (:w_height @lastwin) (:w_status_height @lastwin))))
    nil)

(defn- #_void cursorcmd []
    (reset! msg_row (min (+ @cmdline_row (/ (:cmdspos @ccline) @Cols)) (dec @Rows)))
    (reset! msg_col (% (:cmdspos @ccline) @Cols))
    (windgoto @msg_row, @msg_col)
    nil)

(defn- #_void gotocmdline [#_boolean clr]
    (msg-start)
    (reset! msg_col 0)  ;; always start in column 0
    (when clr           ;; clear the bottom line(s)
        (msg-clr-eos))  ;; will reset clear_cmdline
    (windgoto @cmdline_row, 0)
    nil)

;; Command line history stuff

;; Translate a history character to the associated type number.

(defn- #_int hist-char2type [#_int c]
    (condp == c (byte \:) HIST_CMD (byte \=) HIST_EXPR (byte \@) HIST_INPUT HIST_SEARCH)) ;; must be '?' or '/'

;; Initialize the command line history.
;; Also used to re-allocate the history when the size changes.

(defn- #_void init-history []
    (let-when [#_int newlen @p_hi] (!= newlen @hislen)  ;; history length changed
        (dotimes [#_int t HIST_COUNT]
            (let [#_Bytes* a (if (non-zero? newlen) (Bytes* newlen) nil)
                  a (cond (neg? (... @hisidx t))        ;; there are no entries yet
                        a
                    (< @hislen newlen)                  ;; array becomes bigger
                        (let [n (inc (... @hisidx t)) d (- newlen @hislen) h (... @history t)
                              a (loop-when-recur [a a i 0] (< i n)       [(assoc a i       (... h i)) (inc i)] => a)
                              a (loop-when-recur [a a i n] (< i @hislen) [(assoc a (+ i d) (... h i)) (inc i)] => a)]
                            a)
                    :else                               ;; array becomes smaller or 0
                        (let [x (... @hisidx t) m (dec newlen) h (... @history t)
                              a (loop [a a i x n m]
                                    (let [a (if (<= 0 n) (assoc a n (... h i)) a) i (dec (if (< 0 i) i @hislen))]
                                        (recur-if (!= i x) [a i (dec n)] => a))
                                )]
                            (swap! hisidx assoc t m)
                            a)
                    )]
                (swap! history assoc t a)
            ))
        (reset! hislen newlen))
    nil)

;; Check if command line "s" is already in history.
;; If "move?" is true, matching entry is moved to end of history.

(defn- #_boolean in-history [#_int t, #_Bytes s, #_boolean move?, #_int sep]
    (let [#_int i (... @hisidx t)]
        (if (neg? i)
            false
            (let-when [[i ?]
                    (loop [i i]
                        (let-when [#_Bytes p (... (... @history t) i)] (some? p) => [nil false]
                            ;; For search history, check that the separator character matches as well.
                            (if (and (zero? (STRCMP s, p)) (or (!= t HIST_SEARCH) (== sep (.at p (inc (STRLEN p))))))
                                (if move? [i nil] [nil true])
                                (let [i (dec (if (< 0 i) i @hislen))] (recur-if (!= i (... @hisidx t)) i => [i nil]))
                            ))
                    )] (some? i) => ?

                (if (neg? i)
                    false
                    (let [s (... (... @history t) i)
                          i (loop-when i (!= i (... @hisidx t)) => i
                                (let [#_int e i i (inc i) i (if (< i @hislen) i 0)]
                                    (swap! history assoc-in [t e] (... (... @history t) i))
                                    (recur i))
                            )]
                        (swap! history assoc-in [t i] s)
                        true
                    ))
            ))
    ))

;; Add the given string to the given history.  If the string is already in the
;; history then it is moved to the front.  "t" may be one of he HIST_ values.

(defn- #_void add-to-history [#_int t, #_Bytes s, #_int sep]
    ;; sep: separator character used (search hist)
    (when-not (or (zero? @hislen) (in-history t, s, true, sep))
        (swap! hisidx update t inc)
        (when (== (... @hisidx t) @hislen)
            (swap! hisidx assoc t 0))
        ;; Store the separator after the NUL of the string.
        (let [#_int n (STRLEN s) s (-> s (STRNDUP (+ n 2)) (.be (+ n 1), sep))]
            (swap! history assoc-in [t (... @hisidx t)] s)
        ))
    nil)

;; Open a window on the current command line and history.
;; Allow editing in the window.  When the window is closed,
;; returns:
;;      CR       if the command is to be executed
;;      Ctrl_C   if it is to be abandoned
;;      K_IGNORE if editing continues

(defn- #_[window_C int] ex-window? [#_window_C win]
    [(beep-flush win) K_IGNORE])

;; ex_docmd.c: functions for executing an Ex command line -----------------------------------------

(atom! int      quitmore)
(atom! boolean  ex_pressedreturn)

;;; ============================================================================================== VimI

;; This file defines the Ex commands.
;;
;; When adding an Ex command:
;; 1. Add an entry in the table below.
;;    Keep it sorted on the shortest version of the command name that works.
;;    If it doesn't start with a lower case letter, add it at the end.
;; 2. Add a "case: CMD_xxx" in the big switch in ex_docmd.c.

;; This array maps ex command names to command codes.
;; The order in which command names are listed below is significant --
;; ambiguous abbreviations are always resolved to be the first possible match
;; (e.g. "r" is taken to mean "read", not "rewind", because "read" comes before "rewind").
;; Not supported commands are included to avoid ambiguities.

(class! #_final cmdname_C
    [
        (field Bytes        cmd_name)       ;; name of the command
        (field ex_func_F    cmd_func)       ;; function for this command
        (field long         cmd_argt)       ;; flags declared above
        (field int          cmd_addr_type)  ;; flag for address type
    ])

;; Execute a simple command line.  Used for translated commands like "*".

(defn- #_window_C do-cmdline-cmd [#_window_C win, #_Bytes cmd]
    (let [[win _] (do-cmdline? win, cmd, false, (| DOCMD_VERBOSE DOCMD_NOWAIT DOCMD_KEYTYPED))]
        win
    ))

(atom! int _0_recurse)              ;; recursive depth

;; Execute one Ex command line.
;;
;; Execute "cmdline" when it is not null.
;; If it is null, or more lines are needed, getexline() is used.
;;
;; This function can be called recursively!
;;
;; flags:
;; DOCMD_VERBOSE  - The command will be included in the error message.
;; DOCMD_NOWAIT   - Don't call wait-return() and friends.
;; DOCMD_KEYTYPED - Don't reset "key_typed".
;; DOCMD_KEEPLINE - Store first typed line (for repeating with ".").
;;
;; Return false if "cmdline" could not be executed, true otherwise.

(defn- #_[window_C boolean] do-cmdline? [#_window_C win, #_Bytes cmdline, #_boolean use_getline, #_int flags]
    ;; "did_emsg" will be set to true when emsg() is used,
    ;; in which case we cancel the whole command line.
    (reset! did_emsg false)
    ;; "key_typed" is only set when calling vgetc().
    ;; Reset it here when not calling vgetc() (sourced command lines).
    (when (and (non-flag? flags DOCMD_KEYTYPED) (not use_getline))
        (reset! key_typed false))

    (let [a'did_out (atom (boolean false)) a'did_inc (atom (boolean false)) ;; incremented "no_redraw"
          [win #_boolean retval]
            (let-when [[win cmdline]
                (if (nil? cmdline)
                    ;; If no line given, get an allocated line with getexline().
                    (let [[win cmdline] (if use_getline (getexline win) [win nil])]
                        (if (nil? cmdline)
                            (do ;; Don't call wait-return() for aborted command line.
                                ;; The null returned for the end of a sourced file or executed function doesn't do this.
                                (when @key_typed
                                    (reset! need_wait_return false))
                                [win nil])
                            (do ;; Keep the first typed line.  Clear it when more lines are typed.
                                (when (flag? flags DOCMD_KEEPLINE)
                                    (reset! repeat_cmdline (STRDUP cmdline)))
                                [win cmdline])
                        ))
                    ;; Make a copy of the command so we can mess with it.
                    [win (STRDUP cmdline)])
            ] (some? cmdline) => [win false]

                ;; All output from the commands is put below each other, without waiting for a return.
                ;; Don't do this when executing commands from a script or when being called recursive.
                (when (and (non-flag? flags DOCMD_NOWAIT) (zero? @_0_recurse))
                    (reset! a'did_out @msg_didout)
                    (reset! msg_didany false)   ;; no output yet
                    (msg-start)
                    (reset! msg_scroll true)    ;; put messages below each other
                    (swap! no_wait_return inc)  ;; don't wait for return until finished
                    (swap! no_redraw inc)
                    (reset! a'did_inc true))
                ;; Execute the command.
                (let [_ (swap! _0_recurse inc)
                      win (do-one-cmd win, cmdline, (flag? flags DOCMD_VERBOSE))
                      _ (swap! _0_recurse dec)]
                    ;; If the command was typed, remember it for the ':' register.
                    ;; Do this AFTER executing the command to make :@: work.
                    (when (and use_getline (some? @new_last_cmdline))
                        (reset! last_cmdline @new_last_cmdline)
                        (reset! new_last_cmdline nil))
                    [win true])
            )]
        ;; If there was too much output to fit on the command line, ask the user to
        ;; hit return before redrawing the screen.  With the ":global" command we do
        ;; this only once after the command is finished.
        (when' @a'did_inc => [win retval]
            (swap! no_redraw dec)
            (swap! no_wait_return dec)
            (reset! msg_scroll false)
            ;; When just finished an ":if"-":else" which was typed, no need to
            ;; wait for hit-return.  Also for an error situation.
            (cond (not retval)
                (do (reset! need_wait_return false)
                    (reset! msg_didany false) ;; don't wait when restarting edit
                    [win retval])
            @need_wait_return
                (do ;; The msg-start() above clears "msg_didout".  The wait-return() we do here
                    ;; should not overwrite the command that may be shown before doing that.
                    (swap! msg_didout | @a'did_out)
                    [(wait-return win, FALSE) retval])
            :else
                [win retval]
            ))
    ))

(defn- #_int current-win-nr [#_window_C win]
    (loop-when [#_int n 0 #_window_C w @firstwin] (some? w) => n
        (let [n (inc n)] (if (== w win) n (recur n (:w_next w))))
    ))

(declare cmdnames)

;; Execute one Ex command.
;;
;; If "verbose" is true, the command will be included in the error message.
;;
;; 1. skip comment lines and leading space
;; 2. handle command modifiers
;; 3. find the command
;; 4. parse range
;; 5. parse the command
;; 6. parse arguments
;; 7. switch on command name
;;
;; This function may be called recursively!

(defn- #_window_C do-one-cmd [#_window_C win, #_Bytes cmdline, #_boolean verbose]
    ;; When the last file has not been edited :q has to be typed twice.
    (when (non-zero? @quitmore)
        (swap! quitmore dec))
    (let [a'errormsg (atom (#_Bytes object nil)) lmax (line-count @curbuf)
          #_exarg_C ea (assoc (NEW_exarg_C) :line1 1 :line2 1)
          ;; "#!anything" is handled like a comment.
          [win ea]
            (if (and (at? cmdline 0 (byte \#)) (at? cmdline 1 (byte \!)))
                [win ea]
                (let-when [#_Bytes s cmdline
                      [s abort] ;; 1. Skip comment lines and leading white space and colons.
                        (let [s (loop-when-recur s (any == (.at s 0) (byte \space) TAB (byte \:)) (.plus s 1) => s)]
                            ;; ignore comment and empty lines
                            (cond (at? s (byte \")) ;; """
                                [s :abort]
                            (eos? s)
                                (do (reset! ex_pressedreturn true) [s :abort])
                            :else ;; 2. Handle command modifiers.
                                [(if (asc-isdigit (.at s 0)) (skipwhite (skipdigits s)) s) nil]
                            ))
                      ea (assoc ea :cmd s)
                ] (not abort) => [win ea]

                    (let-when [ea (assoc ea :skip (or @did_emsg @got_int))
                          ;; 3. Skip over the range to find the command.  Let "p" point to after it.
                          ;;
                          ;; We need the command to know what kind of range it uses.
                          o'cmd (:cmd ea)
                          ea (update ea :cmd skip-range)
                          ea (if (at? (:cmd ea) (byte \*)) (assoc ea :cmd (skipwhite (.plus (:cmd ea) 1))) ea)
                          [ea #_Bytes p] (find-command ea)
                          ;; 4. parse a range specifier of the form: addr [,addr] [;addr] ...
                          ;;
                          ;; where 'addr' is:
                          ;;
                          ;; %          (entire file)
                          ;; $  [+-NUM]
                          ;; 'x [+-NUM] (where x denotes a currently defined mark)
                          ;; .  [+-NUM]
                          ;; [+-NUM]...
                          ;; NUM
                          ;;
                          ;; The ea.cmd pointer is updated to point to the first character following the range spec.
                          ;; If an initial address is found, but no second, the upper bound is equal to the lower.
                          ea (assoc ea :addr_type (if (!= (:cmdidx ea) CMD_SIZE) (:cmd_addr_type (... cmdnames (:cmdidx ea))) ADDR_LINES))
                          ;; repeat for all ',' or ';' separated addresses
                          [win ea #_long lnum abort]
                            (loop [win win ea (assoc ea :cmd o'cmd)]
                                (let-when [ea (assoc ea :line1 (:line2 ea))
                                      ea (assoc ea :line2 (condp == (:addr_type ea) ADDR_LINES (:lnum (:w_cursor win)) ADDR_WINDOWS (current-win-nr win)))
                                      ea (update ea :cmd skipwhite)
                                      [win lnum ea]
                                        (let [[win lnum ?] (get-address? win, (:cmd ea), (:addr_type ea), (:skip ea))] [win lnum (assoc ea :cmd ?)])
                                      [ea abort]
                                        (cond (nil? (:cmd ea)) ;; error detected
                                            [ea :abort]
                                        (== lnum MAXLNUM)
                                            (cond (at? (:cmd ea) (byte \%)) ;; '%' - all lines
                                                (let [ea (update ea :cmd plus 1)]
                                                    (condp == (:addr_type ea)
                                                        ADDR_LINES [(-> ea (assoc :line1 1 :line2 lmax) (update :addr_count inc)) nil]
                                                        ;; There is no Vim command which uses '%' and ADDR_WINDOWS.
                                                        ADDR_WINDOWS (do (reset! a'errormsg e_invrange) [ea :abort])
                                                    ))
                                            (at? (:cmd ea) (byte \*)) ;; '*' - visual area
                                                (when' (== (:addr_type ea) ADDR_LINES) => (do (reset! a'errormsg e_invrange) [ea :abort])
                                                    (let-when [ea (update ea :cmd plus 1)] (not (:skip ea)) => [ea nil]
                                                        (let-when                             [#_pos_C fp (getmark win, (byte \<)) [win ?] (check-mark? win, fp)] ? => [ea :abort]
                                                            (let-when [ea (assoc ea :line1 (:lnum fp)) fp (getmark win, (byte \>)) [win ?] (check-mark? win, fp)] ? => [ea :abort]
                                                                [(-> ea (assoc :line2 (:lnum fp)) (update :addr_count inc)) nil]
                                                            ))
                                                    ))
                                            :else
                                                [ea nil])
                                        :else
                                            [(assoc ea :line2 lnum) nil])
                                ] (not abort) => [win ea lnum abort]

                                    (let [ea (update ea :addr_count inc)]
                                        (cond (at? (:cmd ea) (byte \;))
                                            (let [win (if (:skip ea) win (assoc-in win [:w_cursor :lnum] (:line2 ea)))]
                                                (recur win (update ea :cmd plus 1)))
                                        (at? (:cmd ea) (byte \,))
                                            (recur win (update ea :cmd plus 1))
                                        :else
                                            [win ea lnum nil]
                                        ))
                                ))
                    ] (not abort) => [win ea]

                        ;; One address given: set start and end lines.
                        (let-when [ea (if (== (:addr_count ea) 1)
                                    (let [ea (assoc ea :line1 (:line2 ea))]
                                        (if (== lnum MAXLNUM) (assoc ea :addr_count 0) ea)) ;; ... but only implicit: really no address given
                                    ea)
                              ;; Don't leave the cursor on an illegal line (caused by ';').
                              win (check-cursor-lnum win)
                              ;; 5. Parse the command.
                              ;;
                              ;; Skip ':' and any white space
                              ea (update ea :cmd skipwhite)
                              ea (loop-when-recur ea (at? (:cmd ea) (byte \:)) (assoc ea :cmd (skipwhite (.plus (:cmd ea) 1))) => ea)
                              [win ea abort]
                                (if (or (eos? (:cmd ea)) (at? (:cmd ea) (byte \"))) ;; """
                                    ;; strange vi behaviour:
                                    ;; ":3"         jumps to line 3
                                    ;; ":3|..."     prints line 3
                                    ;; ":|"         prints current line
                                    (let [[win ea]
                                            (cond (:skip ea) ;; skip this if inside :if
                                                [win ea]
                                            (at? (:cmd ea) (byte \|))
                                                (let [ea (assoc ea :cmdidx (ร CMD_print) :argt (+ RANGE COUNT))]
                                                    (reset! a'errormsg (invalid-range ea))
                                                    (if (nil? @a'errormsg)
                                                        (let [ea (correct-range ea) _ (ร ea (ex-print ea))]
                                                            [win ea])
                                                        [win ea]
                                                    ))
                                            (non-zero? (:addr_count ea))
                                                ;; With '-' in 'cpoptions' a line number past the file is an error, otherwise put it at the end of the file.
                                                (let [ea (if (< lmax (:line2 ea)) (assoc ea :line2 (if (some? (vim-strbyte @p_cpo, CPO_MINUS)) -1 lmax)) ea)]
                                                    (if (< (:line2 ea) 0)
                                                        (do (reset! a'errormsg e_invrange)
                                                            [win ea])
                                                        (let [win (assoc-in win [:w_cursor :lnum] (if (zero? (:line2 ea)) 1 (:line2 ea)))]
                                                            [(beginline win, (| BL_SOL BL_FIX)) ea])
                                                    ))
                                            :else
                                                [win ea]
                                            )]
                                        [win ea :abort])
                                    [win ea nil])
                        ] (not abort) => [win ea]

                            (if (== (:cmdidx ea) CMD_SIZE)
                                (do (when (not (:skip ea))
                                        (STRCPY ioBuff, (u8 "E492: Not an editor command"))
                                        (when (not verbose)
                                            (append-command cmdline))
                                        (reset! a'errormsg ioBuff))
                                    [win ea])

                                (let-when [[ea p] ;; forced commands
                                        (if (and (at? p (byte \!)) (!= (:cmdidx ea) CMD_substitute))
                                            [(assoc ea :forceit true) (.plus p 1)]
                                            [(assoc ea :forceit false) p])
                                      ;; 6. Parse arguments.
                                      ea (assoc ea :argt (:cmd_argt (... cmdnames (:cmdidx ea))))
                                      abort
                                        (when (not (:skip ea))
                                            (cond (and (text-locked) (non-flag? (:argt ea) CMDWIN))
                                                (do ;; Command not allowed when editing the command line.
                                                    (reset! a'errormsg (if (non-zero? @cmdwin_type) e_cmdwin e_secure))
                                                    :abort)
                                            (and (non-flag? (:argt ea) RANGE) (< 0 (:addr_count ea)))
                                                (do ;; no range allowed
                                                    (reset! a'errormsg e_norange)
                                                    :abort
                                                )))
                                ] (not abort) => [win ea]

                                    (if (and (non-flag? (:argt ea) BANG) (:forceit ea)) ;; no <!> allowed
                                        (do (reset! a'errormsg e_nobang)
                                            [win ea])

                                        ;; Don't complain about the range if it is not used.
                                        (let-when [[ea abort]
                                                (if (not (:skip ea))
                                                    ;; If the range is backwards, ask for confirmation and, if given,
                                                    ;; swap ea.line1 with ea.line2, so it's forwards again.
                                                    (let-when [[ea abort]
                                                            (if (< (:line2 ea) (:line1 ea))
                                                                (if verbose
                                                                    (do (reset! a'errormsg (u8 "E493: Backwards range given"))
                                                                        [ea :abort])
                                                                    [(assoc ea :line1 (:line2 ea) :line2 (:line1 ea)) nil])
                                                                [ea nil])
                                                    ] (not abort) => [ea abort]

                                                        (reset! a'errormsg (invalid-range ea))
                                                        [ea (if (some? @a'errormsg) :abort nil)])
                                                    [ea nil])
                                        ] (not abort) => [win ea]

                                            ;; default is 1, not cursor
                                            (let-when [ea (if (and (flag? (:argt ea) NOTADR) (zero? (:addr_count ea))) (assoc ea :line2 1) ea)
                                                  ea (correct-range ea)
                                                  ;; Skip to start of argument.
                                                  ea (assoc ea :arg (skipwhite p))
                                                  ea (if (and (flag? (:argt ea) DFLALL) (zero? (:addr_count ea)))
                                                        (assoc ea :line1 1 :line2 (condp == (:addr_type ea) ADDR_LINES lmax ADDR_WINDOWS (current-win-nr nil)))
                                                        ea)
                                                  ;; Check for a count.
                                                  [ea abort]
                                                    (if (and (flag? (:argt ea) COUNT) (asc-isdigit (.at (:arg ea) 0)))
                                                        (let [[#_long n ea] (let [a's (atom (:arg ea))] [(getdigits a's) (assoc ea :arg @a's)])
                                                              ea (update ea :arg skipwhite)]
                                                            (cond (and (< n 1) (non-flag? (:argt ea) ZEROR))
                                                                (do (reset! a'errormsg e_zerocount)
                                                                    [ea :abort])
                                                            (flag? (:argt ea) NOTADR) ;; e.g. :buffer 2, :sleep 3
                                                                (let [ea (assoc ea :line2 n)]
                                                                    [(if (zero? (:addr_count ea)) (assoc ea :addr_count 1) ea) nil])
                                                            :else
                                                                (let [ea (assoc ea :line1 (:line2 ea)) ea (update ea :line2 + (dec n)) ea (update ea :addr_count inc)]
                                                                    ;; Be vi compatible: no error message for out of range.
                                                                    [(update ea :line2 min lmax) nil])
                                                            ))
                                                        [ea nil])
                                            ] (not abort) => [win ea]

                                                (cond (and (non-flag? (:argt ea) EXTRA) (non-eos? (:arg ea)) (not-at? (:arg ea) (byte \"))) ;; """
                                                    (do (reset! a'errormsg e_trailing)
                                                        [win ea])

                                                (and (flag? (:argt ea) NEEDARG) (eos? (:arg ea)))
                                                    (do (reset! a'errormsg e_argreq)
                                                        [win ea])

                                                :else
                                                    ;; Skip the command when it's not going to be executed.
                                                    ;; The commands like :if, :endif, etc. always need to be executed.
                                                    ;; Also make an exception for commands that handle a trailing command themselves.
                                                    (let-when [abort
                                                            (when (:skip ea)
                                                                ;; Commands that handle '|' themselves.
                                                                ;; Check:  A command should either have the TRLBAR flag,
                                                                ;; appear in this list or appear in the list at ":help :bar".
                                                                (condp == (:cmdidx ea) CMD_substitute nil :abort))
                                                    ] (not abort) => [win ea]

                                                        ;; 7. Switch on command name.
                                                        ;;
                                                        ;; The "ea" structure holds the arguments that can be used.
                                                        ;; Call the function to execute the command.
                                                        (let [ea (assoc ea :errmsg nil)
                                                              [win ea] ((:cmd_func (... cmdnames (:cmdidx ea))) win, ea)]
                                                            (when (some? (:errmsg ea))
                                                                (reset! a'errormsg (:errmsg ea)))
                                                            [win ea]
                                                        ))
                                                ))
                                        ))
                                ))
                        ))
                ))
          win (when' (zero? (:lnum (:w_cursor win))) => win ;; can happen with zero line number
                (assoc-in win [:w_cursor :lnum] 1)
            )]
        (when' (and (some? @a'errormsg) (non-eos? @a'errormsg) (not @did_emsg)) => win
            (when verbose
                (when (BNE @a'errormsg, ioBuff)
                    (STRCPY ioBuff, @a'errormsg)
                    (reset! a'errormsg ioBuff))
                (append-command cmdline))
            (emsg win, @a'errormsg)
        )
    ))

;; Append "cmd" to the error message in "ioBuff".
;; Takes care of limiting the length and handling 0xa0,
;; which would be invisible otherwise.

(defn- #_void append-command [#_Bytes cmd]
    (STRCAT ioBuff, (u8 ": "))
    (loop [#_Bytes d (.plus ioBuff (STRLEN ioBuff)) #_Bytes s cmd] (if (and (non-eos? s) (< (BDIFF d, ioBuff) (- IOSIZE 7)))
        (if (and (== (char_u (.at s 0)) 0xc2) (== (char_u (.at s 1)) 0xa0))
            (do (STRCPY d, (u8 "<a0>")) (recur (.plus d 4) (.plus s 2)))
            (let [#_int len (us-ptr2len-cc s)] (BCOPY d, s, len) (recur (.plus d len) (.plus s len))))
        (eos! d)
    ))
    nil)

;; Find an Ex command by its name.
;; Start of the name can be found at eap.cmd.
;; Returns pointer to char after the command name.

(defn- #_[exarg_C Bytes] find-command [#_exarg_C eap]
    ;; Isolate the command and search for it in the command table.
    ;; Exceptions: the 's' command can be followed directly by 'c', 'g', 'i', 'I' or 'r',
    ;; but :sre[wind] is another command, as are :scr[iptnames], :scs[cope], :sim[alt], :sig[ns] and :sil[ent].
    (let [#_Bytes s (:cmd eap)]
        (cond (and (at? s (byte \s))
                   (or (and (at? s 1 (byte \c)) (not-at? s 2 (byte \s)) (not-at? s 2 (byte \r)) (not-at? s 3 (byte \i)) (not-at? s 4 (byte \s)))
                       (at? s 1 (byte \g))
                       (and (at? s 1 (byte \i)) (not-at? s 2 (byte \m)) (not-at? s 2 (byte \l)) (not-at? s 2 (byte \g)))
                       (at? s 1 (byte \I))
                       (and (at? s 1 (byte \r)) (not-at? s 2 (byte \e)))))
            [(assoc eap :cmdidx CMD_substitute) (.plus s 1)]
        :else
            (let [s (loop-when-recur s (asc-isalpha (.at s 0)) (.plus s 1) => s)
                  ;; check for non-alpha command
                  s (if (and (BEQ s, (:cmd eap)) (some? (vim-strbyte (u8 "@*!=><&~#"), (.at s 0)))) (.plus s 1) s)
                  #_int n (BDIFF s, (:cmd eap))
                  eap (loop-when [eap (assoc eap :cmdidx 0)] (< (:cmdidx eap) CMD_SIZE) => eap
                        (recur-if (non-zero? (STRNCMP (:cmd_name (... cmdnames (:cmdidx eap))), (:cmd eap), n)) [(update eap :cmdidx inc)] => eap)
                    )]
                [(if (BEQ s, (:cmd eap)) (assoc eap :cmdidx CMD_SIZE) eap) s]
            ))
    ))

;; skip a range specifier of the form: addr [,addr] [;addr] ..
;;
;; Backslashed delimiters after / or ? will be skipped, and commands
;; will not be expanded between /'s and ?'s or after "'".
;;
;; Also skip white space and ":" characters.
;; Returns the "s" pointer advanced to beyond the range.

(defn- #_Bytes skip-range [#_Bytes s]
    (let [s (loop-when s (some? (vim-strbyte (u8 " \t0123456789.$%'/?-+,;"), (.at s 0))) => s
                (let [s (cond (at? s (byte \'))
                            (.plus s 1)
                        (or (at? s (byte \/)) (at? s (byte \?)))
                            (let [x (.at s 0)]
                                (loop-when-recur [s (.plus s 1)] (and (non-eos? s) (not-at? s x)) [(if (and (at? s 0 (byte \\)) (non-eos? s 1)) (.plus s 2) (.plus s 1))] => s))
                        :else s)]
                    (recur (if (non-eos? s) (.plus s 1) s))
                ))]
        (loop-when-recur s (at? s (byte \:)) [(skipwhite (.plus s 1))] => s) ;; skip ":" and white space
    ))

;; Get a single EX address.
;;
;; Set "s" to the next character after the part that was interpreted.
;; Set "s" to null when an error is encountered.
;;
;; Return MAXLNUM when no Ex address was found.

(defn- #_[window_C long Bytes] get-address? [#_window_C win, #_Bytes s, #_int addr_type, #_boolean skip]
    ;; addr_type: flag: one of ADDR_LINES, ...
    ;; skip: only skip the address, don't use it
    (loop [win win #_long lnum MAXLNUM s (skipwhite s)]
        (let-when [[win lnum s]
                (condp ==? (.at s 0)
                    (byte \.) ;; '.' = cursor position
                        [win (condp == addr_type ADDR_LINES (:lnum (:w_cursor win)) ADDR_WINDOWS (current-win-nr win) lnum) (.plus s 1)]

                    (byte \$) ;; '$' = last line
                        [win (condp == addr_type ADDR_LINES (line-count @curbuf) ADDR_WINDOWS (current-win-nr nil) lnum) (.plus s 1)]

                    (byte \') ;; ''' = mark
                        (let [s (.plus s 1)]
                            (cond (eos? s)
                                [win lnum nil]
                            (!= addr_type ADDR_LINES)
                                [(emsg win, e_invaddr) lnum nil]
                            skip
                                [win lnum (.plus s 1)]
                            :else
                                (let [#_pos_C fp (getmark win, (.at s 0)) [win ?] (check-mark? win, fp)]
                                    (if ? [win (:lnum fp) (.plus s 1)] [win lnum nil]))
                            ))

                   [(byte \/) (byte \?)] ;; '/' or '?' = search
                        (let [#_byte c (.at s 0) s (.plus s 1)]
                            (cond (!= addr_type ADDR_LINES)
                                [(emsg win, e_invaddr) lnum nil]
                            skip
                                (let [s (skip-regexp s, c, @p_magic, nil)] [win lnum (if (at? s c) (.plus s 1) s)])
                            :else
                                (let [o'cursor (:w_cursor win)
                                      ;; When '/' or '?' follows another address, start from there.
                                      win (if (!= lnum MAXLNUM) (assoc-in win [:w_cursor :lnum] lnum) win)
                                      ;; Start a forward search at the end of the line.
                                      ;; Start a backward search at the start of the line.
                                      ;; This makes sure we never match in the current line,
                                      ;; and can match anywhere in the next/previous line.
                                      win (assoc-in win [:w_cursor :col] (if (== c (byte \/)) MAXCOL 0))
                                      _ (reset! searchcmdlen 0)
                                      [win #_int i _] (do-search? win, c, s, 1, (| SEARCH_HIST SEARCH_MSG), nil)]
                                    (if (zero? i)
                                        [(assoc win :w_cursor o'cursor) lnum nil]
                                        (let [lnum (:lnum (:w_cursor win))]
                                            [(assoc win :w_cursor o'cursor) lnum (.plus s @searchcmdlen)])
                                    ))
                            ))

                    (byte \\) ;; "\?", "\/" or "\&" = repeat search
                        (let-when [s (.plus s 1)] (== addr_type ADDR_LINES) => [(emsg win, e_invaddr) lnum nil]
                            (let-when [#_int i (condp ==? (.at s 0) (byte \&) RE_SUBST [(byte \?) (byte \/)] RE_SEARCH nil)] (some? i) => [(emsg win, e_backslash) lnum nil]
                                (if skip
                                    [win lnum (.plus s 1)]
                                    ;; When search follows another address, start from there.  ;; Start the search just like for the above do-search().
                                    (let [#_pos_C pos (pos_C. (if (!= lnum MAXLNUM) lnum (:lnum (:w_cursor win))) (if (at? s (byte \?)) 0 MAXCOL) 0)
                                            [win pos #_int sm1] (searchit? win, pos, (if (at? s (byte \?)) BACKWARD FORWARD), (u8 ""), 1, SEARCH_MSG, i, 0, nil)]
                                        (if (non-zero? sm1)
                                            [win (:lnum pos) s]
                                            [win lnum nil])
                                    ))
                            ))

                    (if (asc-isdigit (.at s 0)) ;; absolute line number
                        (let [a's (atom s)] [win (getdigits a's) @a's])
                        [win lnum s]
                    ))
        ] (some? s) => [win lnum s]

            (let [[lnum s]
                    (loop [lnum lnum s s]
                        (let-when [s (skipwhite s)] (or (at? s (byte \-)) (at? s (byte \+)) (asc-isdigit (.at s 0))) => [lnum s]
                            ;; "+1" is same as ".+1" ;; "number" is same as "+number" ;; '+' is '+1', but '+0' is not '+1'
                            (let [lnum (if (== lnum MAXLNUM) (condp == addr_type ADDR_LINES (:lnum (:w_cursor win)) ADDR_WINDOWS (current-win-nr win) lnum) lnum)
                                  [#_int m s] (if (asc-isdigit (.at s 0)) [(byte \+) s] [(.at s 0) (.plus s 1)])
                                  [#_int n s] (if (asc-isdigit (.at s 0)) (let [a's (atom s)] [(getdigits a's) @a's]) [1 s])]
                                (recur ((if (== m (byte \-)) - +) lnum n) s)
                            ))
                    )]
                (recur-if (any == (.at s 0) (byte \/) (byte \?)) [win lnum s] => [win lnum s])
            ))
    ))

;; Check range in Ex command for validity.
;; Return null when valid, error message when invalid.

(defn- #_Bytes invalid-range [#_exarg_C eap]
    (if (or (< (:line1 eap) 0) (< (:line2 eap) 0) (< (:line2 eap) (:line1 eap)))
        e_invrange
        (when (flag? (:argt eap) RANGE)
            (condp == (:addr_type eap)
                ADDR_LINES
                    (when (and (non-flag? (:argt eap) NOTADR) (< (line-count @curbuf) (:line2 eap))) e_invrange)
                ADDR_WINDOWS
                    (when (< (current-win-nr nil) (:line2 eap)) e_invrange)
            ))
    ))

;; Correct the range for zero line number, if required.

(defn- #_exarg_C correct-range [#_exarg_C eap]
    (if (non-flag? (:argt eap) ZEROR)    ;; zero in range not allowed
        (let [eap (if (zero? (:line1 eap)) (assoc eap :line1 1) eap)
              eap (if (zero? (:line2 eap)) (assoc eap :line2 1) eap)]
            eap)
        eap
    ))

;; ":close": close current window, unless it is the last one

(defn- #_[window_C exarg_C] ex-close [#_window_C win, #_exarg_C eap]
    (cond (non-zero? @cmdwin_type)
        (do (reset! cmdwin_result Ctrl_C) [win eap])
    (not (text-locked))
        (let [#_window_C w (if (zero? (:addr_count eap)) win (loop-when-recur [w @firstwin n 1] (and (some? w) (!= n (:line2 eap))) [(:w_next w) (inc n)] => (or w @lastwin)))]
            [(ex-win-close win, w, (:forceit eap)) eap])
    :else
        [win eap]
    ))

;; Close window "win'" and take care of handling closing the last window for a modified buffer.

(defn- #_window_C ex-win-close [#_window_C win, #_window_C win', #_boolean forceit]
    (let-when [able? (or (not @(:b_changed @curbuf)) (< 1 (:b_nwindows @curbuf)))] (or able? forceit) => (emsg win, e_nowrtmsg)
        (let [[win _] (win-close? win, win', able?)] win)
    ))

;; ":only".

(defn- #_[window_C exarg_C] ex-only [#_window_C win, #_exarg_C eap]
    (let [win (when' (< 0 (:addr_count eap)) => win
                (win-goto win, (loop-when-recur [w @firstwin n (:line2 eap)] (and (< 1 n) (some? (:w_next w))) [(:w_next w) (dec n)] => w))
            )]
        [(close-others win, true, (:forceit eap)) eap]
    ))

;; ":stop" and ":suspend": Suspend Vim.

(defn- #_[window_C exarg_C] ex-stop [#_window_C win, #_exarg_C eap]
    (windgoto (dec @Rows), 0)
    (out-char (byte \newline))
    (out-flush)
    (stop-termcap)
    (out-flush)            ;; needed for SUN to restore xterm buffer
    (ui-suspend)           ;; call machine specific function
    (start-termcap)
    (scroll-start)         ;; scroll screen before redrawing
    (redraw-later-clear)
    [(shell-resized win) eap]) ;; may have resized window

;; Sleep for "msec" milliseconds, but keep checking for a CTRL-C every second.

(defn- #_void do-sleep [#_long msec]
    (cursor-on)
    (out-flush)
    (loop-when-recur [#_long done 0] (and (not @got_int) (< done msec)) [(+ done 1000)]
        (ui-delay (min (- msec done) 1000), true)
        (ui-breakcheck))
    nil)

;; ":set"

(defn- #_[window_C exarg_C] ex-set [#_window_C win, #_exarg_C eap]
    (let [[win _] (do-set? win, (:arg eap))]
        [win eap]
    ))

(final cmdname_C* cmdnames
    [
        (cmdname_C. (u8 "close"),      ex-close,  (| BANG RANGE NOTADR COUNT CMDWIN), ADDR_WINDOWS),
        (cmdname_C. (u8 "fixdel"),     ex-fixdel,    CMDWIN,                          ADDR_LINES  ),
        (cmdname_C. (u8 "only"),       ex-only,   (| BANG NOTADR RANGE COUNT),        ADDR_WINDOWS),
        (cmdname_C. (u8 "retab"),      ex-retab,  (| RANGE DFLALL BANG WORD1 CMDWIN), ADDR_LINES  ),
        (cmdname_C. (u8 "substitute"), ex-sub,    (| RANGE EXTRA CMDWIN),             ADDR_LINES  ),
        (cmdname_C. (u8 "set"),        ex-set,    (| EXTRA CMDWIN),                   ADDR_LINES  ),
        (cmdname_C. (u8 "stop"),       ex-stop,   (| BANG CMDWIN),                    ADDR_LINES  ),
        (cmdname_C. (u8 "suspend"),    ex-stop,   (| BANG CMDWIN),                    ADDR_LINES  ),
    ])

;;; ============================================================================================== VimJ

;; Top level evaluation function, returning a string.

(defn- #_Bytes eval-to-string [#_Bytes arg]
    ;; %% not yet
    nil)

;; Return the time "msec" past now.

(defn- #_long profile-setlimit [#_long msec]
    (if (< 0 msec)
        (+ (System/nanoTime) (* msec 1000 1000))
        0)) ;; no limit

;; Return true if the current time is past "nsec".

(defn- #_boolean profile-passed-limit [#_long nsec]
    (if (zero? nsec) ;; timer was not set
        false
        (< nsec (System/nanoTime))))

;;; ============================================================================================== VimK

;; normal.c ---------------------------------------------------------------------------------------
;; Contains the main routine for processing characters in command mode.
;; Communicates closely with the code in ops.c to handle the operators.

;; The Visual area is remembered for reselection.

(atom! int      resel_VIsual_mode       NUL)    ;; 'v', 'V', or Ctrl-V
(atom! long     resel_VIsual_lmax)              ;; number of lines
(atom! int      resel_VIsual_vcol)              ;; nr of cols or end col
(atom! int      VIsual_mode_orig        NUL)    ;; saved Visual mode

(atom! int      restart_VIsual_select)

;; nv_*(): functions called to handle Normal and Visual mode commands.
;; n_*(): functions called to handle Normal mode commands.
;; v_*(): functions called to handle Visual mode commands.

(final Bytes e_noident (u8 "E349: No identifier under cursor"))

;; Values for cmd_flags.
(final int
    NV_NCH          0x01,           ;; may need to get a second char
    NV_NCH_NOP   (| 0x02 NV_NCH),   ;; get second char when no operator pending
    NV_NCH_ALW   (| 0x04 NV_NCH),   ;; always get a second char
    NV_LANG         0x08,           ;; second char needs language adjustment

    NV_SS           0x10,           ;; may start selection
    NV_SSS          0x20,           ;; may start selection with shift modifier
    NV_STS          0x40,           ;; may stop selection without shift modif.
    NV_RL           0x80,           ;; 'rightleft' modifies command
    NV_KEEPREG      0x100,          ;; don't clear regname
    NV_NCW          0x200)          ;; not allowed in command-line window

;; Generally speaking, every Normal mode command should either clear any
;; pending operator (with *clearop*()), or set the motion type variable
;; oap.motion_type.
;;
;; When a cursor motion command is made, it is marked as being a character or
;; line oriented motion.  Then, if an operator is in effect, the operation
;; becomes character or line oriented accordingly.

;; Function to be called for a Normal or Visual mode command.
;; The argument is a cmdarg_C.

(class! #_final nv_cmd_C
    [
        (field int          cmd_char)           ;; (first) command character
        (field nv_func_F    cmd_func)           ;; function for this command
        (field int          cmd_flags)          ;; NV_ flags
        (field int          cmd_arg)            ;; value for ca.arg
    ])

(declare nv_cmds)

;; Search for a command in the commands table.
;; Returns -1 for invalid command.

(defn- #_int find--command [#_int cmdchar]
    ;; A multi-byte character is never a command.
    (if (<= 0x100 cmdchar)
        -1
;       %% return nv_cmds index for cmd_char or -1
    )
)

;; Execute a command in Normal mode.

(defn- #_[window_C oparg_C] normal-cmd [#_window_C win, #_oparg_C oap, #_boolean toplevel]
    ;; toplevel: true when called from main()
    (let [o'curswant (:w_curswant win)
          #_cmdarg_C ca (assoc (NEW_cmdarg_C) :oap oap)
          ;; Use a count remembered from before entering an operator.
          ;; After typing "3d" we return from normal-cmd() and come back here,
          ;; the "3" is remembered in "opcount".
          ca (assoc ca :opcount @opcount)
          ;; If there is an operator pending, then the command we take this time
          ;; will terminate it.  "finish_op" tells us to finish the operation before
          ;; returning this time (unless the operation was cancelled).
          o'finish_op @finish_op _ (reset! finish_op (!= (:op_type (:oap ca)) OP_NOP))
          _ (when (!= @finish_op o'finish_op)
                (ui-cursor-shape)) ;; may show different cursor shape
          ;; When not finishing an operator and no register name typed, reset the count.
          ca (if (and (not @finish_op) (zero? (:regname (:oap ca)))) (assoc ca :opcount 0) ca)
          ;; Restore counts from before receiving K_CURSORHOLD.  This means after typing "3",
          ;; handling K_CURSORHOLD and then typing "2" we get "32", not "3 * 2".
          ca (let-when [x (:prev_opcount (:oap ca)) y (:prev_count0 (:oap ca))] (or (< 0 x) (< 0 y)) => ca
                (-> ca
                    (assoc :opcount x :count0 y)
                    (update :oap assoc :prev_opcount 0 :prev_count0 0)
                ))
          _ (reset! State NORMAL_BUSY)
          ;; Get the command character from the user.
          [win #_int c] (safe-vgetc? win) c (if (== c NUL) K_ZERO c)
          ;; In Select mode, typed text replaces the selection.
          c (if (and @VIsual_active @VIsual_select (or (vim-isprintc c) (== c NL) (== c CAR) (== c K_KENTER)))
                (do ;; Fake a "c"hange command.
                    ;; When "restart_edit" is set (e.g. because 'insertmode' is set),
                    ;; fake a "d"elete command, Insert mode will restart automatically.
                    ;; Insert the typed character in the typeahead buffer, so it can be
                    ;; mapped in Insert mode.
                    (ins-char-typebuf c)
                    (let [c (if (non-zero? @restart_edit) (byte \d) (byte \c))]
                        (reset! msg_nowait true) ;; don't delay going to insert mode
                        c
                    ))
                c)
          [win ?] (add-to-showcmd? win, c)
          a'flush (atom (boolean ?)) ;; need to call out-flush()
          [win ca c #_boolean ctrl_w]
            (loop-when [win win ca ca c c ctrl_w false] (not (and @VIsual_active @VIsual_select)) => [win ca c ctrl_w]
                ;; Handle a count before a command and compute ca.count0.
                ;; Note that '0' is a command and not the start of a count, but it's part of a count after other digits.
                (let-when [[win ca c]
                        (loop-when [win win ca ca c c] (or (<= (byte \1) c (byte \9)) (and (!= (:count0 ca) 0) (any == c K_DEL K_KDEL (byte \0)))) => [win ca c]
                            (let [[win ca]
                                    (if (any == c K_DEL K_KDEL)
                                        [(del-from-showcmd win, 4) (assoc ca :count0 (/ (:count0 ca) 10))]  ;; delete the digit and ~@%
                                        [win (assoc ca :count0 (+ (* (:count0 ca) 10) (- c (byte \0))))])
                                  ca (if (< (:count0 ca) 0) (assoc ca :count0 999999999) ca)                ;; got too large!
                                  _ (when ctrl_w (swap! no_mapping inc) (swap! allow_keys inc))             ;; no mapping for nchar, but keys
                                  [win c] (plain-vgetc? win)
                                  _ (when ctrl_w (swap! no_mapping dec) (swap! allow_keys dec))
                                  [win ?] (add-to-showcmd? win, c)]
                                (reset! a'flush (or ? @a'flush))
                                (recur win ca c)
                            ))
                ;; If we got CTRL-W, there may be a/another count.
                ] (and (== c Ctrl_W) (not ctrl_w) (== (:op_type (:oap ca)) OP_NOP)) => [win ca c ctrl_w]

                    (let [ca (assoc ca :opcount (:count0 ca) :count0 0)     ;; remember first count
                          _ (swap! no_mapping inc) _ (swap! allow_keys inc) ;; no mapping for nchar, but keys
                          [win c] (plain-vgetc? win)                        ;; get next character
                          _ (swap! no_mapping dec) _ (swap! allow_keys dec)
                          [win ?] (add-to-showcmd? win, c)]
                        (reset! a'flush (or ? @a'flush))
                        (recur win ca c true))
                ))
          ca (cond (== c K_CURSORHOLD)
                ;; Save the count values so that ca.opcount and ca.count0 are exactly
                ;; the same when coming back here after handling K_CURSORHOLD.
                (update ca :oap assoc :prev_opcount (:opcount ca) :prev_count0 (:count0 ca))
            (non-zero? (:opcount ca))
                ;; If we're in the middle of an operator (including after entering a yank buffer with '"') AND
                ;; we had a count before the operator, then that count overrides the current value of ca.count0.
                ;; Commands like "3dw" get turned into "d3w", which makes things fall into place pretty neatly.
                ;; If you give a count before AND after the operator, they are multiplied.
                (assoc ca :count0 (if (non-zero? (:count0 ca)) (* (:count0 ca) (:opcount ca)) (:opcount ca)))
            :else
                ca)
          ;; Always remember the count.
          ;; It will be set to zero (on the next call, above) when there is no pending operator.
          ;; When called from main(), save the count for use by the "count" built-in variable.
          ca (assoc ca :opcount (:count0 ca) :count1 (if (zero? (:count0 ca)) 1 (:count0 ca)))
          ;; Find the command character in the table of commands.
          ;; For CTRL-W we already got nchar when looking for a count.
          ca (if ctrl_w (assoc ca :cmdchar Ctrl_W :nchar c) (assoc ca :cmdchar c))
          [win ca]
            (let [#_int idx (find--command (:cmdchar ca))]
                (cond (< idx 0)
                    [win (clearopbeep ca)] ;; Not a known command: beep.

                (and (text-locked) (flag? (:cmd_flags (... nv_cmds idx)) NV_NCW))
                    ;; This command is not allowed while editing a cmdline: beep.
                    [(text-locked-msg win) (clearopbeep ca)]

                :else
                    ;; In Visual/Select mode, a few keys are handled in a special way.
                    (let-when [[win ca idx ?]
                            (when' @VIsual_active => [win ca idx nil]
                                ;; when 'keymodel' contains "stopsel" may stop Select/Visual mode
                                (let [win (when' (and @km_stopsel (flag? (:cmd_flags (... nv_cmds idx)) NV_STS) (non-flag? @mod_mask MOD_MASK_SHIFT)) => win
                                            (let [win (end-visual-mode win)]
                                                (redraw-curbuf-later INVERTED)
                                                win)
                                        )]
                                    ;; Keys that work different when 'keymodel' contains "startsel".
                                    (when' @km_startsel => [win ca idx nil]
                                        (if (flag? (:cmd_flags (... nv_cmds idx)) NV_SS)
                                            (let [ca (unshift-special ca) idx (find--command (:cmdchar ca))]
                                                (if (< idx 0) ;; Just in case.
                                                    [win (clearopbeep ca) idx :abort]
                                                    [win ca idx nil]
                                                ))
                                            (do (when (and (flag? (:cmd_flags (... nv_cmds idx)) NV_SSS) (flag? @mod_mask MOD_MASK_SHIFT))
                                                    (swap! mod_mask & (bit-not MOD_MASK_SHIFT)))
                                                [win ca idx nil])
                                        ))
                                ))
                    ] (not ?) => [win ca]

                        ;; Get an additional character if we need one.
                        (let [[win ca idx]
                                (if (and (flag? (:cmd_flags (... nv_cmds idx)) NV_NCH)
                                         (or (and (== (& (:cmd_flags (... nv_cmds idx)) NV_NCH_NOP) NV_NCH_NOP) (== (:op_type (:oap ca)) OP_NOP))
                                             (== (& (:cmd_flags (... nv_cmds idx)) NV_NCH_ALW) NV_NCH_ALW)
                                             (and (== (:cmdchar ca) (byte \q)) (== (:op_type (:oap ca)) OP_NOP) (not @Recording) (not @exec_reg))
                                             (and (any == (:cmdchar ca) (byte \a) (byte \i)) (or (!= (:op_type (:oap ca)) OP_NOP) @VIsual_active))))
                                    (let [_ (swap! no_mapping inc) _ (swap! allow_keys inc) ;; no mapping for nchar, but allow key codes
                                          ;; Don't generate a CursorHold event here, most commands can't handle it, e.g. nv-replace(), nv-csearch().
                                          _ (reset! did_cursorhold true)
                                          [win #_keyword k'char #_boolean repl #_boolean lit] ;; get char for replace mode ;; get extra char literally
                                            (if (== (:cmdchar ca) (byte \g))
                                                ;; For 'g' get the next character now, so that we can check for "gr", "g'" and "g`".
                                                (let [[win ?] (plain-vgetc? win) ca (assoc ca :nchar ?) [win ?] (add-to-showcmd? win, (:nchar ca))]
                                                    (reset! a'flush (or ? @a'flush))
                                                    (condp ==? (:nchar ca)
                                                        (byte \r)                     [win :extra_char true false] ;; get it in replace mode
                                                       [(byte \') (byte \`) Ctrl_BSL] [win :extra_char false true] ;; get it literally
                                                                                      [win nil false false]        ;; no third character needed
                                                    ))
                                                [win :nchar (== (:cmdchar ca) (byte \r)) false]) ;; get it in replace mode
                                          #_boolean lang (or repl (flag? (:cmd_flags (... nv_cmds idx)) NV_LANG))
                                          ;; Get a second or third character.
                                          [win ca idx]
                                            (if (some? k'char)
                                                (let-when [_ (when repl (reset! State REPLACE) (ui-cursor-shape)) ;; pretend Replace mode ;; show different cursor shape
                                                      [win ?] (plain-vgetc? win) ca (assoc ca k'char ?)
                                                      _ (reset! State NORMAL_BUSY)
                                                      [win ?] (add-to-showcmd? win, (k'char ca))
                                                      _ (reset! a'flush (or ? @a'flush))
                                                      [win ca]
                                                        (cond lit
                                                            [win ca]
                                                        (and (== (k'char ca) Ctrl_K) ;; Typing CTRL-K gets a digraph.
                                                             (or (flag? (:cmd_flags (... nv_cmds idx)) NV_LANG) (== k'char :extra_char)) (nil? (vim-strbyte @p_cpo, CPO_DIGRAPH)))
                                                            (let-when [[win #_int c] (get-digraph? win, false)] (< 0 c) => [win ca]
                                                                (let [ca (assoc ca k'char c)
                                                                      win (del-from-showcmd win, 3) ;; Guessing how to update showcmd here...
                                                                      [win ?] (add-to-showcmd? win, (k'char ca))]
                                                                    (reset! a'flush (or ? @a'flush))
                                                                    [win ca]
                                                                ))
                                                        :else
                                                            [win ca])
                                                      ;; When the next char is CTRL-\, a following CTRL-N means the command is aborted and we go to Normal mode.
                                                      [win ca idx]
                                                        (cond (and (== k'char :extra_char) (== (:nchar ca) Ctrl_BSL) (any == (:extra_char ca) Ctrl_N Ctrl_G))
                                                            [win (assoc ca :cmdchar Ctrl_BSL :nchar (:extra_char ca)) (find--command Ctrl_BSL)]
                                                        (and (any == (:nchar ca) (byte \n) (byte \N)) (== (:cmdchar ca) (byte \g)))
                                                            [win (assoc-in ca [:oap :op_type] (get-op-type (k'char ca), NUL)) idx]
                                                        (== (k'char ca) Ctrl_BSL)
                                                            ;; There is a busy wait here when typing "f<C-\>" and then something different from CTRL-N.
                                                            ;; Can't be avoided.
                                                            (let [[win #_int c]
                                                                    (loop-when [#_long msec (if (<= 0 @p_ttm) @p_ttm @p_tm) [win c] (vpeekc? win)] (and (<= c 0) (< 0 msec)) => [win c]
                                                                        (do-sleep (min msec 50))
                                                                        (recur (- msec 50) (vpeekc? win))
                                                                    )]
                                                                (if (< 0 c)
                                                                    (let [[win c] (plain-vgetc? win)]
                                                                        (if (any == c Ctrl_N Ctrl_G)
                                                                            [win (assoc ca :cmdchar Ctrl_BSL :nchar c) (find--command Ctrl_BSL)]
                                                                            (do (vungetc c) [win ca idx])
                                                                        ))
                                                                    [win ca idx]
                                                                ))
                                                        :else
                                                            [win ca idx])
                                                ] lang => [win ca idx]

                                                    ;; When getting a text character and the next character is a multi-byte character,
                                                    ;; it could be a composing character.  However, don't wait for it to arrive.
                                                    ;; Also, do enable mapping, because if it's put back with vungetc() it's too late
                                                    ;; to apply mapping.
                                                    (let [_ (swap! no_mapping dec)
                                                          [win ca]
                                                            (loop-when [ca ca [win #_int c] (vpeekc? win)] (and (< 0 c) (or (<= 0x100 c) (< 1 (mb-byte2len c)))) => [win ca]
                                                                (let [[win c] (plain-vgetc? win)]
                                                                    (recur-if (utf-iscomposing c)
                                                                              [(assoc ca (if (zero? (:ncharC1 ca)) :ncharC1 :ncharC2) c) (vpeekc? win)]
                                                                           => (do (vungetc c) [win ca])) ;; it wasn't, put it back
                                                                ))
                                                          _ (swap! no_mapping inc)]
                                                        [win ca idx]
                                                    ))
                                                [win ca idx])
                                          _ (swap! no_mapping dec) _ (swap! allow_keys dec)]
                                        [win ca idx])
                                    [win ca idx]
                                )]
                            ;; Flush the showcmd characters onto the screen so we can see them while the command
                            ;; is being executed.  Only do this when the shown command was actually displayed,
                            ;; otherwise this will slow down a lot when executing mappings.
                            (when @a'flush
                                (out-flush))
                            (when (!= (:cmdchar ca) K_IGNORE)
                                (reset! did_cursorhold false))
                            (reset! State NORMAL)
                            (if (== (:nchar ca) ESC)
                                (do (when (and (zero? @restart_edit) (goto-im))
                                        (reset! restart_edit (byte \a)))
                                    [win (clearop ca)])

                                (let [_ (when (!= (:cmdchar ca) K_IGNORE)
                                            (reset! msg_didout false) ;; don't scroll screen up for normal command
                                            (reset! msg_col 0))
                                      o'cursor (:w_cursor win) ;; remember where cursor was
                                      ;; When 'keymodel' contains "startsel", some keys start Select/Visual mode.
                                      [win ca idx]
                                        (cond (or @VIsual_active (not @km_startsel))
                                            [win ca idx]
                                        (flag? (:cmd_flags (... nv_cmds idx)) NV_SS)
                                            (let [win (start-selection win) ca (unshift-special ca)] [win ca (find--command (:cmdchar ca))])
                                        (and (flag? (:cmd_flags (... nv_cmds idx)) NV_SSS) (flag? @mod_mask MOD_MASK_SHIFT))
                                            (let [win (start-selection win)]
                                                (swap! mod_mask & (bit-not MOD_MASK_SHIFT))
                                                [win ca idx])
                                        :else
                                            [win ca idx])
                                      ;; Execute the command!  ;; Call the command function found in the commands table.
                                      ca (assoc ca :arg (:cmd_arg (... nv_cmds idx)))
                                      [win ca] ((:cmd_func (... nv_cmds idx)) win, ca)
                                      ;; If we didn't start or finish an operator, reset oap.regname, unless we need it later.
                                      ca (if (and (not @finish_op) (== (:op_type (:oap ca)) OP_NOP) (or (< idx 0) (non-flag? (:cmd_flags (... nv_cmds idx)) NV_KEEPREG)))
                                            (clearop ca)
                                            ca)
                                      ;; If an operation is pending, handle it...
                                      [win ca] (do-pending-operator win, ca, o'curswant)]

                                    ;; Wait for a moment when a message is displayed that will be overwritten by the mode message.
                                    ;; In Visual mode and with "^O" in Insert mode, a short message will be overwritten by the mode message.  Wait a bit, until a key is hit.
                                    ;; In Visual mode, it's more important to keep the Visual area updated than keeping a message (e.g. from a /pat search).
                                    ;; Only do this if the command was typed, not from a mapping.
                                    ;; Also wait a bit after an error message, e.g. for "^O:".
                                    ;; Don't redraw the screen, it would remove the message.

                                    (when' (and (or (and @p_smd
                                                         (or (!= @restart_edit 0)
                                                             (and @VIsual_active (== (:lnum o'cursor) (:lnum (:w_cursor win))) (== (:col o'cursor) (:col (:w_cursor win)))))
                                                         (or @clear_cmdline @redraw_cmdline)
                                                         (or @msg_didout (and @msg_didany @msg_scroll))
                                                         (not @msg_nowait)
                                                         @key_typed)
                                                    (and (!= @restart_edit 0) (not @VIsual_active) (or @msg_scroll @emsg_on_display)))
                                                (== (:regname (:oap ca)) 0)
                                                (non-flag? (:retval ca) CA_COMMAND_BUSY)
                                                (stuff-empty)
                                                (not @did_wait_return)
                                                (== (:op_type (:oap ca)) OP_NOP)) => [win ca]
                                        ;; Draw the cursor with the right shape here.
                                        (let [o'State @State _ (when (non-zero? @restart_edit) (reset! State INSERT))
                                              ;; If need to redraw and there is a "keep_msg", redraw before the delay.
                                              win (when' (and (non-zero? @must_redraw) (some? @keep_msg) (not @emsg_on_display)) => win
                                                    (let [#_Bytes kmsg @keep_msg _ (reset! keep_msg nil)
                                                          ;; showmode() will clear "keep_msg", but we want to use it anyway
                                                          win (update-screen win, 0)]
                                                        ;; now reset it, otherwise it's put in the history again
                                                        (reset! keep_msg kmsg)
                                                        (msg-attr win, kmsg, @keep_msg_attr)
                                                    ))
                                              win (setcursor win)]
                                            (cursor-on)
                                            (out-flush)
                                            (when (or @msg_scroll @emsg_on_display)
                                                (ui-delay 1000, true)) ;; wait at least one second
                                            (ui-delay 3000, false)     ;; wait up to three seconds
                                            (reset! State o'State)
                                            (reset! msg_scroll false)
                                            (reset! emsg_on_display false)
                                            [win ca])
                                    ))
                            ))
                    ))
            )]
        ;; Finish up after executing a Normal mode command.
        (reset! msg_nowait false)
        ;; Reset "finish_op", in case it was set.
        (reset! o'finish_op @finish_op)
        (reset! finish_op false)
        ;; Redraw the cursor with another shape if we were in Operator-pending mode or did a replace command.
        (when (or o'finish_op (== (:cmdchar ca) (byte \r)))
            (ui-cursor-shape)) ;; may show different cursor shape
        (let [win (when' (and (== (:op_type (:oap ca)) OP_NOP) (zero? (:regname (:oap ca))) (!= (:cmdchar ca) K_CURSORHOLD)) => win
                    (clear-showcmd win))
              win (checkpcmark win) ;; check if we moved since setting pcmark
              ca (assoc ca :searchbuf nil)
              win (update win :w_cursor mb-adjust-pos)
              ;; May restart edit(), if we got here with CTRL-O in Insert mode
              ;; (but not if still inside a mapping that started in Visual mode).
              ;; May switch from Visual to Select mode after CTRL-O command.
              win (when' (and (== (:op_type (:oap ca)) OP_NOP)
                            (or (and (non-zero? @restart_edit) (not @VIsual_active)) (== @restart_VIsual_select 1))
                            (non-flag? (:retval ca) CA_COMMAND_BUSY)
                            (stuff-empty)
                            (zero? (:regname (:oap ca)))) => win
                    (let [win (when' (== @restart_VIsual_select 1) => win
                                (let [_ (reset! VIsual_select true)
                                      win (showmode win)]
                                    (reset! restart_VIsual_select 0)
                                    win)
                            )]
                        (when' (and (non-zero? @restart_edit) (not @VIsual_active)) => win
                            (let [[win _] (edit? win, @restart_edit, false, 1)] win)
                        ))
                )]
            (when (== @restart_VIsual_select 2)
                (reset! restart_VIsual_select 1))
            ;; Save count before an operator for next time.
            (reset! opcount (:opcount ca))
            [win (:oap ca)]
        )
    ))

;; The visual area is remembered for redo.
(atom! int      redo_VIsual_mode NUL)       ;; 'v', 'V', or Ctrl-V
(atom! long     redo_VIsual_lmax)           ;; number of lines
(atom! int      redo_VIsual_vcol)           ;; number of cols or end column
(atom! long     redo_VIsual_count)          ;; count for Visual operator

;; Handle an operator after visual mode or when the movement is finished.

(defn- #_[window_C cmdarg_C] do-pending-operator [#_window_C win, #_cmdarg_C cap, #_int o'col]
    (let [o'lbr @(:wo_lbr (:w_options win))
          ;; If an operation is pending, handle it...
          [win cap oap]
            (let-when [oap (:oap cap)] (and (or @finish_op @VIsual_active) (!= (:op_type oap) OP_NOP)) => [win cap oap]
                ;; Avoid a problem with unwanted linebreaks in block mode.
                (let [_ (reset! (:wo_lbr (:w_options win)) false)
                      oap (assoc oap :is_VIsual @VIsual_active)
                      oap (condp == (:motion_force oap)
                            (byte \V)
                                (assoc oap :motion_type MLINE)
                            (byte \v)
                                ;; If the motion was linewise, "inclusive" will not have been set.
                                ;; Use "exclusive" to be consistent.  Makes "dvj" work nice.
                                (let [oap (condp == (:motion_type oap)
                                            MLINE (assoc oap :inclusive false)
                                            ;; If the motion already was characterwise, toggle "inclusive".
                                            MCHAR (update oap :inclusive not)
                                                  oap
                                        )]
                                    (assoc oap :motion_type MCHAR))
                            Ctrl_V
                                (do ;; Change line- or characterwise motion into Visual block mode.
                                    (reset! VIsual_active true)
                                    (reset! VIsual_cursor (:op_start oap))
                                    (reset! VIsual_mode Ctrl_V)
                                    (reset! VIsual_select false)
                                    (reset! VIsual_reselect false)
                                    oap)
                            oap
                        )]
                    (let-when [t (:op_type oap)]
                          (and (or (some? (vim-strbyte @p_cpo, CPO_YANK)) (!= t OP_YANK)) ;; Only redo yank when 'y' flag is in 'cpoptions'.
                               (or (not @VIsual_active) (non-zero? (:motion_force oap)) (and @VIsual_active (== (:cmdchar cap) (byte \:)) (!= t OP_COLON)))
                               (!= (:cmdchar cap) (byte \D)))
                        (prep-redo (:regname oap), (:count0 cap), (get-op-char t), (get-extra-op-char t), (:motion_force oap), (:cmdchar cap), (:nchar cap))
                        (cond (any == (:cmdchar cap) (byte \/) (byte \?)) ;; was a search
                            (do ;; If 'cpoptions' does not contain 'r',
                                ;; insert the search pattern to really repeat the same command.
                                (when (nil? (vim-strbyte @p_cpo, CPO_REDO))
                                    (append-redo-lit (:searchbuf cap), -1))
                                (append-redo NL_STR))
                        (== (:cmdchar cap) (byte \:))
                            ;; do-cmdline() has stored the first typed line in "repeat_cmdline".
                            ;; When several lines are typed, repeating won't be possible.
                            (if (some? @repeat_cmdline)
                                (do (append-redo-lit @repeat_cmdline, -1)
                                    (append-redo NL_STR)
                                    (reset! repeat_cmdline nil))
                                (reset-redo))
                        ))
                    (let [[win cap oap include_eol?]
                            (cond @redo_VIsual_busy
                                ;; Redo of an operation on a Visual area.
                                ;; Use the same size from redo_VIsual_lmax and redo_VIsual_vcol.
                                (let [oap (assoc oap :op_start (:w_cursor win))
                                      win (update-in win [:w_cursor :lnum] #(min (+ % (dec @redo_VIsual_lmax)) (line-count @curbuf)))
                                      _ (reset! VIsual_mode @redo_VIsual_mode)
                                      win (if (or (== @redo_VIsual_vcol MAXCOL) (== @VIsual_mode (byte \v)))
                                            (let [win (if (== @VIsual_mode (byte \v))
                                                        (if (<= @redo_VIsual_lmax 1)
                                                            (let [win (validate-virtcol win)]
                                                                (assoc win :w_curswant (dec (+ (:w_virtcol win) @redo_VIsual_vcol))))
                                                            (assoc win :w_curswant @redo_VIsual_vcol))
                                                        (assoc win :w_curswant MAXCOL)
                                                    )]
                                                (coladvance win, (:w_curswant win)))
                                            win)
                                      cap (assoc cap :count0 @redo_VIsual_count, :count1 (if (non-zero? @redo_VIsual_count) @redo_VIsual_count 1))]
                                    [win cap oap false])
                            @VIsual_active
                                (do ;; Save the current VIsual area for '< and '> marks, and "gv".
                                    (swap! curbuf update :b_visual assoc :vi_start @VIsual_cursor, :vi_end (:w_cursor win), :vi_mode @VIsual_mode)
                                    (when (!= @VIsual_mode_orig NUL)
                                        (swap! curbuf assoc-in [:b_visual :vi_mode] @VIsual_mode_orig)
                                        (reset! VIsual_mode_orig NUL))
                                    (swap! curbuf assoc-in [:b_visual :vi_curswant] (:w_curswant win))
                                    ;; In Select mode,
                                    ;; a linewise selection is operated upon like a characterwise selection.
                                    (let [[win include_eol?]
                                            (cond (and @VIsual_select (== @VIsual_mode (byte \V)))
                                                (let [win (if (ltpos @VIsual_cursor, (:w_cursor win))
                                                            (let [_ (swap! VIsual_cursor assoc :col 0)
                                                                  win (assoc-in win [:w_cursor :col] (STRLEN (ml-get (:lnum (:w_cursor win)))))]
                                                                win)
                                                            (let [win (assoc-in win [:w_cursor :col] 0)
                                                                  _ (swap! VIsual_cursor assoc :col (STRLEN (ml-get (:lnum @VIsual_cursor))))]
                                                                win)
                                                        )]
                                                    (reset! VIsual_mode (byte \v))
                                                    [win false])
                                            ;; If 'selection' is "exclusive", backup one character for charwise selections.
                                            (== @VIsual_mode (byte \v))
                                                (unadjust-for-sel? win)
                                            :else
                                                [win false])
                                          oap (assoc oap :op_start @VIsual_cursor)
                                          oap (if (== @VIsual_mode (byte \V)) (assoc-in oap [:op_start :col] 0) oap)]
                                        [win cap oap include_eol?]
                                    ))
                            :else
                                [win cap oap false])
                          ;; Set oap.op_start to the first position of the operated text, oap.op_end
                          ;; to the end of the operated text.  "w_cursor" is equal to oap.op_start.
                          [win oap]
                            (if (ltpos (:op_start oap), (:w_cursor win))
                                (let [oap (assoc oap :op_end (:w_cursor win))
                                      win (assoc win :w_cursor (:op_start oap))]
                                    ;; "w_virtcol" may have been updated;
                                    ;; if the cursor goes back to its previous position,
                                    ;; "w_virtcol" becomes invalid and isn't updated automatically.
                                    [(update win :w_valid & (bit-not VALID_VIRTCOL)) oap])
                                (let [oap (assoc oap :op_end (:op_start oap))
                                      oap (assoc oap :op_start (:w_cursor win))]
                                    [win oap]
                                ))
                          oap (assoc oap :line_count (inc (- (:lnum (:op_end oap)) (:lnum (:op_start oap)))))
                          ;; Set "virtual_op" before resetting VIsual_active.
                          _ (reset! virtual_op (if (virtual-active) TRUE FALSE))
                          [win oap]
                            (if (or @VIsual_active @redo_VIsual_busy)
                                (let [[win oap]
                                        (if (== @VIsual_mode Ctrl_V)  ;; block mode
                                            (let [oap (assoc oap :block_mode true)
                                                  a'start (atom (int (:start_vcol oap))) a'end (atom (int (:end_vcol oap)))
                                                  _ (getvvcol win, (:op_start oap), a'start, nil, a'end)
                                                  oap (assoc oap :start_vcol @a'start :end_vcol @a'end)
                                                  oap (if (not @redo_VIsual_busy)
                                                        (let [_ (getvvcol win, (:op_end oap), a'start, nil, a'end)
                                                              oap (update oap :start_vcol min @a'start)]
                                                            (if (< (:end_vcol oap) @a'end)
                                                                (assoc oap :end_vcol
                                                                    (if (and (at? @p_sel (byte \e)) (<= 1 @a'start) (<= (:end_vcol oap) (dec @a'start))) (dec @a'start) @a'end))
                                                                oap
                                                            ))
                                                        oap)
                                                  ;; if '$' was used, get oap.end_vcol from longest line
                                                  [win oap]
                                                    (cond (== (:w_curswant win) MAXCOL)
                                                        (let [win (update win :w_cursor assoc :lnum (:lnum (:op_start oap)) :col MAXCOL)]
                                                            (loop-when [win win oap (assoc oap :end_vcol 0)] (<= (:lnum (:w_cursor win)) (:lnum (:op_end oap))) => [win oap]
                                                                (let [_ (getvvcol win, (:w_cursor win), nil, nil, a'end)
                                                                      oap (update oap :end_vcol max @a'end)
                                                                      win (update-in win [:w_cursor :lnum] inc)]
                                                                    (recur win oap))
                                                            ))
                                                    @redo_VIsual_busy
                                                        [win (assoc oap :end_vcol (dec (+ (:start_vcol oap) @redo_VIsual_vcol)))]
                                                    :else
                                                        [win oap])
                                                  ;; Correct oap.op_end.col and oap.op_start.col to be the
                                                  ;; upper-left and lower-right corner of the block area.
                                                  ;;
                                                  ;; (Actually, this does convert column positions into character positions.)
                                                  win (assoc-in win [:w_cursor :lnum] (:lnum (:op_end oap)))
                                                  win (coladvance win, (:end_vcol oap))
                                                  oap (assoc oap :op_end (:w_cursor win))
                                                  win (assoc win :w_cursor (:op_start oap))
                                                  win (coladvance win, (:start_vcol oap))
                                                  oap (assoc oap :op_start (:w_cursor win))]
                                                [win oap])
                                            [win oap])
                                      oap (if (not @redo_VIsual_busy)
                                            ;; Prepare to reselect and redo Visual:
                                            ;; this is based on the size of the Visual text.
                                            (let [_ (reset! resel_VIsual_mode @VIsual_mode)
                                                  oap (if (== (:w_curswant win) MAXCOL)
                                                        (do (reset! resel_VIsual_vcol MAXCOL)
                                                            oap)
                                                        (let [oap (if (!= @VIsual_mode Ctrl_V)
                                                                    (assoc oap :end_vcol
                                                                        (let [__ (atom (int (:end_vcol oap)))] (getvvcol win, (:op_end oap), nil, nil, __) @__))
                                                                    oap
                                                                )]
                                                            (if (or (== @VIsual_mode Ctrl_V) (<= (:line_count oap) 1))
                                                                (let [oap (if (!= @VIsual_mode Ctrl_V)
                                                                            (assoc oap :start_vcol
                                                                                (let [__ (atom (int (:start_vcol oap)))] (getvvcol win, (:op_start oap), __, nil, nil) @__))
                                                                            oap
                                                                        )]
                                                                    (reset! resel_VIsual_vcol (inc (- (:end_vcol oap) (:start_vcol oap))))
                                                                    oap)
                                                                (do (reset! resel_VIsual_vcol (:end_vcol oap))
                                                                    oap)
                                                            ))
                                                    )]
                                                (reset! resel_VIsual_lmax (:line_count oap))
                                                oap)
                                            oap
                                        )]
                                    ;; can't redo yank (unless 'y' is in 'cpoptions') and ":"
                                    (let-when [t (:op_type oap)] (and (or (some? (vim-strbyte @p_cpo, CPO_YANK)) (!= t OP_YANK)) (!= t OP_COLON) (zero? (:motion_force oap)))
                                        ;; Prepare for redoing.
                                        ;; Only use the nchar field for "r", otherwise it might be the second char of the operator.
                                        (cond (and (== (:cmdchar cap) (byte \g)) (any == (:nchar cap) (byte \n) (byte \N)))
                                            (prep-redo (:regname oap), (:count0 cap), (get-op-char t), (get-extra-op-char t), (:motion_force oap), (:cmdchar cap), (:nchar cap))
                                        (!= (:cmdchar cap) (byte \:))
                                            (prep-redo (:regname oap), 0, NUL, (byte \v), (get-op-char t), (get-extra-op-char t), (if (== t OP_REPLACE) (:nchar cap) NUL))
                                        )
                                        (when (not @redo_VIsual_busy)
                                            (reset! redo_VIsual_mode @resel_VIsual_mode)
                                            (reset! redo_VIsual_vcol @resel_VIsual_vcol)
                                            (reset! redo_VIsual_lmax @resel_VIsual_lmax)
                                            (reset! redo_VIsual_count (:count0 cap))
                                        ))
                                    ;; oap.inclusive defaults to true.
                                    ;; If oap.op_end is on a NUL (empty line) oap.inclusive becomes false.
                                    ;; This makes "d}P" and "v}dP" work the same.
                                    (let [oap (if (or (== (:motion_force oap) NUL) (== (:motion_type oap) MLINE)) (assoc oap :inclusive true) oap)
                                          oap (when' (!= @VIsual_mode (byte \V)) => (assoc oap :motion_type MLINE)
                                                (let [oap (assoc oap :motion_type MCHAR)]
                                                    (if (and (!= @VIsual_mode Ctrl_V) (eos? (ml-get-pos (:op_end oap))) (or include_eol? (== @virtual_op FALSE)))
                                                        ;; Try to include the newline, unless it's an operator that works on lines only.
                                                        (cond (or (at? @p_sel (byte \o)) (op-on-lines (:op_type oap)))
                                                            (assoc oap :inclusive false)
                                                        (< (:lnum (:op_end oap)) (line-count @curbuf))
                                                            (let [oap (update oap :op_end assoc :lnum (inc (:lnum (:op_end oap))) :col 0 :coladd 0)
                                                                  oap (update oap :line_count inc)]
                                                                (assoc oap :inclusive false))
                                                        :else
                                                            ;; Cannot move below the last line, make the op inclusive
                                                            ;; to tell the operation to include the line break.
                                                            (assoc oap :inclusive true))
                                                        oap)
                                                ))
                                          _ (reset! redo_VIsual_busy false)
                                          ;; Switch Visual off now, so screen updating does not show inverted text when the screen is redrawn.
                                          ;; With OP_YANK and sometimes with OP_COLON and OP_FILTER there is no screen redraw,
                                          ;; so it is done here to remove the inverted part.
                                          _ (reset! VIsual_active false)
                                          win (if @mode_displayed
                                                (do (reset! clear_cmdline true) win) ;; unshow visual mode later
                                                (clear-showcmd win)
                                            )]
                                        (when (and (any == (:op_type oap) OP_YANK OP_COLON OP_FUNCTION OP_FILTER) (== (:motion_force oap) NUL))
                                            (reset! (:wo_lbr (:w_options win)) o'lbr) ;; make sure redrawing is correct
                                            (redraw-curbuf-later INVERTED))
                                        [win oap]
                                    ))
                                [win oap])
                          ;; Include the trailing byte of a multi-byte char.
                          oap (if (:inclusive oap)
                                (let [#_int l (us-ptr2len-cc (ml-get-pos (:op_end oap)))]
                                    (if (< 1 l) (update-in oap [:op_end :col] + (dec l)) oap))
                                oap)
                          win (assoc win :w_set_curswant true)
                          ;; oap.empty is set when start and end are the same.
                          ;; The inclusive flag affects this too, unless yanking and the end is on a NUL.
                          oap (assoc oap :empty (and (== (:motion_type oap) MCHAR)
                                                     (or (not (:inclusive oap)) (and (== (:op_type oap) OP_YANK) (== (gchar-pos (:op_end oap)) NUL)))
                                                     (eqpos (:op_start oap), (:op_end oap))
                                                     (not (and (!= @virtual_op FALSE) (!= (:coladd (:op_start oap)) (:coladd (:op_end oap)))))))
                          ;; For delete, change and yank, it's an error to operate on an
                          ;; empty region, when 'E' included in 'cpoptions' (Vi compatible).
                          empty_region? (and (:empty oap) (some? (vim-strbyte @p_cpo, CPO_EMPTYREGION)))
                          ;; Force a redraw when operating on an empty Visual region,
                          ;; when 'modifiable' is off or creating a fold.
                          _ (when (and (:is_VIsual oap) (:empty oap))
                                (reset! (:wo_lbr (:w_options win)) o'lbr)
                                (redraw-curbuf-later INVERTED))
                          ;; If the end of an operator is in column one while oap.motion_type
                          ;; is MCHAR and oap.inclusive is false, we put op_end after the last
                          ;; character in the previous line.  If op_start is on or before the
                          ;; first non-blank in the line, the operator becomes linewise
                          ;; (strange, but that's the way vi does it).
                          oap (if (and (== (:motion_type oap) MCHAR)
                                     (not (:inclusive oap))
                                     (non-flag? (:retval cap) CA_NO_ADJ_OP_END)
                                     (== (:col (:op_end oap)) 0)
                                     (or (not (:is_VIsual oap)) (at? @p_sel (byte \o)))
                                     (not (:block_mode oap))
                                     (< 1 (:line_count oap))
                                )
                                (let [oap (assoc oap :end_adjusted true) ;; remember that we did this
                                      oap (update oap :line_count dec)
                                      oap (update-in oap [:op_end :lnum] dec)]
                                    (if (inindent win, 0)
                                        (assoc oap :motion_type MLINE)
                                        (let [oap (assoc-in oap [:op_end :col] (STRLEN (ml-get (:lnum (:op_end oap)))))]
                                            (if (< 0 (:col (:op_end oap)))
                                                (-> oap (update-in [:op_end :col] dec) (assoc :inclusive true))
                                                oap
                                            ))
                                    ))
                                (assoc oap :end_adjusted false))
                          [win cap oap]
                            (condp ==? (:op_type oap)

                               [OP_LSHIFT OP_RSHIFT]
                                    [(op-shift win, oap, true, (if (:is_VIsual oap) (:count1 cap) 1)) cap oap]

                               [OP_JOIN_NS OP_JOIN]
                                    (let [oap (update oap :line_count max 2)
                                          win (if (<= (dec (+ (:lnum (:w_cursor win)) (:line_count oap))) (line-count @curbuf))
                                                (do-join win, (:line_count oap), (== (:op_type oap) OP_JOIN), true, true)
                                                (beep-flush win)
                                            )]
                                        [win cap oap])

                                OP_DELETE
                                    (let [_ (reset! VIsual_reselect false) ;; don't reselect now
                                          [win oap]
                                            (if empty_region?
                                                (do (beep) (cancel-redo) [win oap])
                                                (let [[win oap _] (op-delete? win, oap)] [win oap])
                                            )]
                                        [win cap oap])

                                OP_YANK
                                    (let [[win oap]
                                            (if empty_region?
                                                (do (beep) (cancel-redo) [win oap])
                                                (let [_ (reset! (:wo_lbr (:w_options win)) o'lbr) [win oap _] (op-yank? win, oap, false, true)] [win oap])
                                            )]
                                        [(check-cursor-col win) cap oap])

                                OP_CHANGE
                                    (do (reset! VIsual_reselect false) ;; don't reselect now
                                        (if empty_region?
                                            (do (beep) (cancel-redo) [win cap oap])
                                            ;; This is a new edit command, not a restart.
                                            ;; Need to remember it to make 'insertmode' work with mappings for Visual mode.
                                            ;; But do this only once and not when typed and 'insertmode' isn't set.
                                            (let [o'restart_edit (if (or @p_im (not @key_typed)) @restart_edit 0) _ (reset! restart_edit 0)
                                                  ;; Restore linebreak, so that when the user edits, it looks as before.
                                                  _ (reset! (:wo_lbr (:w_options win)) o'lbr)
                                                  ;; Reset "finish_op" now, don't want it set inside edit().
                                                  _ (reset! finish_op false)
                                                  [win oap ?] (op-change? win, oap) cap (if ? (update cap :retval | CA_COMMAND_BUSY) cap)] ;; will call edit()
                                                (when (zero? @restart_edit)
                                                    (reset! restart_edit o'restart_edit))
                                                [win cap oap])
                                        ))

                                OP_INDENT
                                    (let [win (op-reindent win, oap, (ร get_c_indent))]
                                        [win cap oap])

                                OP_FILTER
                                    (do (if (some? (vim-strbyte @p_cpo, CPO_FILTER))
                                            (append-redo (u8 "!\r"))    ;; use any last used !cmd
                                            (reset! bangredo true))     ;; do_bang() will put cmd in redo buffer
                                        (op-colon win, oap)
                                        [win cap oap])

                                OP_COLON
                                    (do (op-colon win, oap)
                                        [win cap oap])

                               [OP_TILDE OP_UPPER OP_LOWER OP_ROT13]
                                    (let [[win oap]
                                            (if empty_region?
                                                (do (beep) (cancel-redo) [win oap])
                                                (op-tilde win, oap)
                                            )]
                                        [(check-cursor-col win) cap oap])

                                OP_FORMAT
                                    (do (ยง op-format oap, false)  ;; use internal function
                                        [win cap oap])

                                OP_FORMAT2
                                    (do (ยง op-format oap, true)   ;; use internal function
                                        [win cap oap])

                                OP_FUNCTION
                                    [(op-function win, oap) cap oap] ;; call 'operatorfunc'

                               [OP_INSERT OP_APPEND]
                                    (let [_ (reset! VIsual_reselect false) ;; don't reselect now
                                          [win oap] (if empty_region?
                                                (do (beep) (cancel-redo) [win oap])
                                                ;; This is a new edit command, not a restart.
                                                ;; Need to remember it to make 'insertmode' work with mappings for Visual mode.
                                                ;; But do this only once.
                                                (let [o'restart_edit @restart_edit _ (reset! restart_edit 0)
                                                      ;; Restore linebreak, so that when the user edits, it looks as before.
                                                      _ (reset! (:wo_lbr (:w_options win)) o'lbr)
                                                      [win oap] (op-insert win, oap, (:count1 cap))
                                                      ;; Reset linebreak, so that formatting works correctly.
                                                      _ (reset! (:wo_lbr (:w_options win)) false)]
                                                    (when (zero? @restart_edit)
                                                        (reset! restart_edit o'restart_edit))
                                                    [win oap])
                                            )]
                                        [win cap oap])

                                OP_REPLACE
                                    (let [_ (reset! VIsual_reselect false) ;; don't reselect now
                                          [win oap] (if empty_region?
                                                (do (beep) (cancel-redo) [win oap])
                                                ;; Restore linebreak, so that when the user edits, it looks as before.
                                                (let [_ (reset! (:wo_lbr (:w_options win)) o'lbr)
                                                      [win oap _] (op-replace? win, oap, (:nchar cap))]
                                                    [win oap])
                                            )]
                                        [win cap oap])

                                [win cap (clearopbeep' oap)]
                            )]
                        (reset! virtual_op MAYBE)
                        ;; If 'sol' not set, go back to old column for some commands.
                        (let [win (if (and (not @p_sol) (== (:motion_type oap) MLINE) (not (:end_adjusted oap)) (any == (:op_type oap) OP_LSHIFT OP_RSHIFT OP_DELETE))
                                    (let [_ (reset! (:wo_lbr (:w_options win)) false)]
                                        (-> win
                                            (assoc :w_curswant o'col)
                                            (coladvance o'col)
                                        ))
                                    win)
                              oap (assoc oap :block_mode false)]
                            [win cap (clearop' oap)])
                    ))
            )]
        (reset! (:wo_lbr (:w_options win)) o'lbr)
        [win (assoc cap :oap oap)]
    ))

;; Handle filter operator and visual mode ":".

(defn- #_void op-colon [#_window_C win, #_oparg_C oap]
    (stuff-char (byte \:))
    (if (:is_VIsual oap)
        (stuff-string (u8 "'<,'>"))
        (let [start (:lnum (:op_start oap)) end (:lnum (:op_end oap)) cursor (:lnum (:w_cursor win)) lmax (line-count @curbuf)]
            ;; Make the range look nice, so it can be repeated.
            (if (== start cursor)
                (stuff-char (byte \.))
                (stuff-num start))
            (when (!= end start)
                (stuff-char (byte \,))
                (cond
                    (== end cursor) (stuff-char (byte \.))
                    (== end lmax) (stuff-char (byte \$))
                    (== start cursor) (do (stuff-string (u8 ".+")) (stuff-num (dec (:line_count oap))))
                    :else (stuff-num end)
                ))
        ))
    (when (!= (:op_type oap) OP_COLON)
        (stuff-string (u8 "!")))
    ;; do-cmdline() does the rest
    nil)

;; Handle the "g@" operator: call 'operatorfunc'.

(defn- #_window_C op-function [#_window_C win, #_oparg_C oap]
    (if (eos? @p_opfunc)
        (emsg win, (u8 "E774: 'operatorfunc' is empty"))
        ;; Set '[ and '] marks to text to be operated on.
        (let [start (:op_start oap) end (:op_end oap)
              end (if (and (!= (:motion_type oap) MLINE) (not (:inclusive oap))) (decl end) end) ;; exclude the end position
              _ (swap! curbuf assoc :b_op_start start, :b_op_end end)
              ;; Reset "virtual_op" so that 'virtualedit' can be changed in the function.
              o'virtual_op @virtual_op _ (reset! virtual_op MAYBE) a'argv (atom (#_Bytes object))]
            (reset! a'argv (cond (:block_mode oap) (u8 "block") (== (:motion_type oap) MLINE) (u8 "line") :else (u8 "char")))
            (ยง call_func_retnr @p_opfunc, 1, a'argv, false)
            (reset! virtual_op o'virtual_op)
            win
        )
    ))

(atom! boolean did_check_visual_highlight)

;; Check if highlighting for visual mode is possible, give a warning message if not.

(defn- #_window_C check-visual-highlight [#_window_C win]
    (when' @full_screen => win
        (let [win (when' (and (not @did_check_visual_highlight) (zero? (hl-attr HLF_V))) => win
                    (msg win, (u8 "Warning: terminal cannot highlight"))
                )]
            (reset! did_check_visual_highlight true)
            win
        )
    ))

;; End Visual mode.
;; This function should ALWAYS be called to end Visual mode, except from do-pending-operator().

(defn- #_window_C end-visual-mode [#_window_C win]
    (reset! VIsual_active false)
    ;; Save the current VIsual area for '< and '> marks, and "gv".
    (swap! curbuf update :b_visual assoc :vi_mode @VIsual_mode, :vi_start @VIsual_cursor, :vi_end (:w_cursor win), :vi_curswant (:w_curswant win))
    (let [win (if (not (virtual-active)) (assoc-in win [:w_cursor :coladd] 0) win)
          win (if @mode_displayed
                (do (reset! clear_cmdline true) win) ;; unshow visual mode later
                (clear-showcmd win)
            )]
        (adjust-cursor-eol win)
    ))

;; Reset VIsual_active and VIsual_reselect.

(defn- #_window_C reset-VIsual-and-resel [#_window_C win]
    (let [win (when' @VIsual_active => win
                (let [win (end-visual-mode win)]
                    (redraw-curbuf-later INVERTED)  ;; delete the inversion later
                    win)
            )]
        (reset! VIsual_reselect false)
        win
    ))

;; Reset VIsual_active and VIsual_reselect if it's set.

(defn- #_window_C reset-VIsual [#_window_C win]
    (let [win (when' @VIsual_active => win
                (let [win (end-visual-mode win)]
                    (redraw-curbuf-later INVERTED)  ;; delete the inversion later
                    (reset! VIsual_reselect false)
                    win)
            )]
        win
    ))

;; Find the identifier under or to the right of the cursor.
;;
;; "find_type" can have one of three values:
;; FIND_IDENT:   find an identifier (keyword)
;; FIND_STRING:  find any non-white string
;; FIND_IDENT + FIND_STRING: find any non-white string, identifier preferred.
;;
;; There are three steps:
;; 1. Search forward for the start of an identifier/string.
;;    Doesn't move if already on one.
;; 2. Search backward for the start of this identifier/string.
;;    This doesn't match the real Vi but I like it a little better and it shouldn't bother anyone.
;; 3. Search forward to the end of this identifier/string.
;;    When FIND_IDENT isn't defined, we backup until a blank.
;;
;; Returns the length of the string, or zero if no string is found.
;; If a string is found, a pointer to the string is put in "*string".
;; This string is not always NUL terminated.

(defn- #_[window_C int] find-ident-under-cursor? [#_window_C win, #_Bytes' a'string, #_int find_type]
    (let [cursor (:w_cursor win) #_Bytes s (ml-get (:lnum cursor)) #_int startcol (:col cursor)
          ;; if round == 0: try to find an identifier ;; if round == 1: try to find any non-white string
          [#_int i #_int cls #_int round]
            (loop-when [i 0 cls 0 round (if (flag? find_type FIND_IDENT) 0 1)] (< round 2) => [i cls round]
                ;; 1. Skip to start of identifier/string.
                (let-when [i (loop-when [i startcol] (non-eos? s i) => i
                            (let-when [#_int cls (us-get-class (.plus s i))] (or (zero? cls) (and (zero? round) (== cls 1))) => i
                                (recur (+ i (us-ptr2len-cc s, i)))
                            ))
                      ;; 2. Back up to start of identifier/string.
                      cls (us-get-class (.plus s i)) ;; remember class of character under cursor
                      i (loop-when i (and (< 0 i) (!= cls 0)) => i
                            (let [#_int i' (- (dec i) (us-head-off s, (.plus s (dec i)))) #_int cls' (us-get-class (.plus s i'))]
                                (if (and (!= cls' cls) (or (zero? round) (zero? cls') (flag? find_type FIND_IDENT))) i (recur i'))
                            ))
                      ;; If we don't want just any old string, or we've found an identifier, stop searching.
                      cls (min cls 2)
                ] (and (flag? find_type FIND_STRING) (!= cls 2)) => [i cls round]
                    (recur i cls (inc round)))
            )]
        (if (or (eos? s i) (and (zero? round) (!= cls 2)))
            [(emsg win, (if (flag? find_type FIND_STRING) (u8 "E348: No string under cursor") e_noident)) 0]
            (let [s (.plus s i) _ (reset! a'string s)
                  ;; 3. Find the end of the identifier/string.
                  cls (us-get-class s)]
                (loop-when-recur [i 0] ;; Search for point of changing multibyte character class.
                                 (and (non-eos? s i) (let [cls' (us-get-class (.plus s i))] (if (zero? round) (== cls' cls) (!= cls' 0))))
                                 [(+ i (us-ptr2len-cc s, i))]
                              => [win i])
            ))
    ))

;; Prepare for redo of a normal command.

(defn- #_void prep-redo-cmd [#_cmdarg_C cap]
    (prep-redo (:regname (:oap cap)), (:count0 cap), NUL, (:cmdchar cap), NUL, NUL, (:nchar cap))
    nil)

;; Prepare for redo of any command.
;; Note that only the last argument can be a multi-byte char.

(defn- #_void prep-redo [#_int regname, #_long num, #_int cmd1, #_int cmd2, #_int cmd3, #_int cmd4, #_int cmd5]
    (reset-redo)
    (when (non-zero? regname) ;; yank from specified buffer
        (append-redo-char (byte \")) ;; """
        (append-redo-char regname))
    (when (non-zero? num)
        (append-redo-number num))
    (when (!= cmd1 NUL) (append-redo-char cmd1))
    (when (!= cmd2 NUL) (append-redo-char cmd2))
    (when (!= cmd3 NUL) (append-redo-char cmd3))
    (when (!= cmd4 NUL) (append-redo-char cmd4))
    (when (!= cmd5 NUL) (append-redo-char cmd5))
    nil)

;; Check for operator active and clear it.

(defn- #_[cmdarg_C boolean] checkclearop? [#_cmdarg_C cap]
    (if (== (:op_type (:oap cap)) OP_NOP) [cap false] [(clearopbeep cap) true]))

;; Check for operator or Visual active.  Clear active operator.

(defn- #_[cmdarg_C boolean] checkclearopq? [#_cmdarg_C cap]
    (if (and (== (:op_type (:oap cap)) OP_NOP) (not @VIsual_active)) [cap false] [(clearopbeep cap) true]))

(defn- #_oparg_C clearop' [#_oparg_C oap]
    (assoc oap :op_type OP_NOP, :regname 0, :motion_force NUL, :use_reg_one false))

(defn- #_oparg_C clearopbeep' [#_oparg_C oap]
    (swap! curwin beep-flush)
    (clearop' oap))

(defn- #_cmdarg_C clearop     [#_cmdarg_C cap] (update cap :oap clearop'))
(defn- #_cmdarg_C clearopbeep [#_cmdarg_C cap] (update cap :oap clearopbeep'))

;; Remove the shift modifier from a special key.

(defn- #_cmdarg_C unshift-special [#_cmdarg_C cap]
    (let [unsh- #(condp == %
            K_S_RIGHT K_RIGHT
            K_S_LEFT  K_LEFT
            K_S_UP    K_UP
            K_S_DOWN  K_DOWN
            K_S_HOME  K_HOME
            K_S_END   K_END
            %)
          simp- #(let [__ (atom (int @mod_mask)) _ (simplify-key %, __)] (reset! mod_mask @__) _)]
        (-> cap (update :cmdchar unsh-) (update :cmdchar simp-))
    ))

;; Routines for displaying a partly typed command

(final int SHOWCMD_BUFLEN (+ SHOWCMD_COLS 1 30))
(final Bytes    showcmd_buf     (Bytes. SHOWCMD_BUFLEN))
(final Bytes    old_showcmd_buf (Bytes. SHOWCMD_BUFLEN))    ;; for push-showcmd()
(atom! boolean  showcmd_is_clear true)
(atom! boolean  showcmd_visual)

(defn- #_window_C clear-showcmd [#_window_C win]
    (when' @p_sc => win
        (if (and @VIsual_active (not (char-avail)))
            (let [#_boolean cursor_bot (ltpos @VIsual_cursor, (:w_cursor win))
                  [#_long top #_long bot] (if cursor_bot [(:lnum @VIsual_cursor) (:lnum (:w_cursor win))] [(:lnum (:w_cursor win)) (:lnum @VIsual_cursor)])
                  #_long lines (inc (- bot top))]
                (cond (== @VIsual_mode Ctrl_V)
                    (let [o'sbr @p_sbr a'leftcol (atom (int)) a'rightcol (atom (int))]
                        ;; Make 'sbr' empty for a moment to get the correct size.
                        (reset! p_sbr EMPTY_OPTION)
                        (getvcols win, (:w_cursor win), @VIsual_cursor, a'leftcol, a'rightcol)
                        (reset! p_sbr o'sbr)
                        (ร .sprintf libC showcmd_buf, (u8 "%ldx%ld"), lines, (inc (- @a'rightcol @a'leftcol))))
                (or (== @VIsual_mode (byte \V)) (!= (:lnum @VIsual_cursor) (:lnum (:w_cursor win))))
                    (ร .sprintf libC showcmd_buf, (u8 "%ld"), lines)
                :else
                    (let [[#_Bytes s #_Bytes e] (if cursor_bot [(ml-get-pos @VIsual_cursor) (ml-get-cursor win)] [(ml-get-cursor win) (ml-get-pos @VIsual_cursor)])
                          [#_int bytes #_int chars]
                            (loop-when [bytes 0 chars 0 s s] (if (not-at? @p_sel (byte \e)) (BLE s, e) (BLT s, e)) => [bytes chars]
                                (let-when [#_int n (us-ptr2len-cc s)] (pos? n) => [(inc bytes) (inc chars)] ;; end of line
                                    (recur (+ bytes n) (inc chars) (.plus s n))
                                ))]
                        (if (== bytes chars)
                            (ร .sprintf libC showcmd_buf, (u8 "%ld"), chars)
                            (ร .sprintf libC showcmd_buf, (u8 "%ld-%ld"), chars, bytes))
                    ))
                (eos! showcmd_buf SHOWCMD_COLS)      ;; truncate
                (reset! showcmd_visual true)
                (display-showcmd win))
            (do
                (eos! showcmd_buf)
                (reset! showcmd_visual false)
                ;; Don't actually display something if there is nothing to clear.
                (if-not @showcmd_is_clear
                    (display-showcmd win)
                    win)
            ))
    ))

;; Add "c" to shown command chars.

(defn- #_[window_C boolean] add-to-showcmd? [#_window_C win, #_int c]
    (when' @p_sc => [win false]
        (when @showcmd_visual
            (eos! showcmd_buf)
            (reset! showcmd_visual false))
        (when' (not (any == c K_IGNORE K_CURSORHOLD)) => [win false]
            (let [#_Bytes s (transchar c)]
                (when (at? s (byte \space))
                    (STRCPY s, (u8 "<20>")))
                (let [#_int n (STRLEN showcmd_buf) #_int overflow (- (+ n (STRLEN s)) SHOWCMD_COLS)]
                    (when (< 0 overflow)
                        (BCOPY showcmd_buf, 0, showcmd_buf, overflow, (inc (- n overflow))))
                    (STRCAT showcmd_buf, s)
                ))
            (when' (not (char-avail)) => [win false]
                [(display-showcmd win) true]
            ))
    ))

(defn- #_window_C add-to-showcmd [#_window_C win, #_int c]
    (let [[win _] (add-to-showcmd? win, c)]
        win
    ))

(defn- #_window_C add-to-showcmd-c [#_window_C win, #_int c]
    (let-when [[win ?] (add-to-showcmd? win, c)] (not ?) => win
        (setcursor win)
    ))

;; Delete "len" characters from the end of the shown command.

(defn- #_window_C del-from-showcmd [#_window_C win, #_int len]
    (when' @p_sc => win
        (let [#_int o'len (STRLEN showcmd_buf) len (min len o'len)]
            (eos! showcmd_buf (- o'len len)))
        (when' (not (char-avail)) => win
            (display-showcmd win))
    ))

;; push-showcmd() and pop-showcmd() are used when waiting for
;; the user to type something and there is a partial mapping.

(defn- #_void push-showcmd []
    (when @p_sc
        (STRCPY old_showcmd_buf, showcmd_buf))
    nil)

(defn- #_window_C pop-showcmd [#_window_C win]
    (when' @p_sc => win
        (STRCPY showcmd_buf, old_showcmd_buf)
        (display-showcmd win)
    ))

(defn- #_window_C display-showcmd [#_window_C win]
    (cursor-off)
    (let [#_int len (STRLEN showcmd_buf)]
        (when (pos? len)
            (screen-puts showcmd_buf, (dec @Rows), @sc_col, 0))
        ;; clear the rest of an old message by outputting up to SHOWCMD_COLS spaces
        (screen-puts (.plus (u8 "          ") len), (dec @Rows), (+ @sc_col len), 0)
        (reset! showcmd_is_clear (zero? len)))
    (setcursor win)) ;; put cursor back where it belongs

;; Command character that's ignored.
;; Used for CTRL-Q and CTRL-S to avoid problems with terminals that use xon/xoff.

(defn- #_[window_C cmdarg_C] nv-ignore [#_window_C win, #_cmdarg_C cap]
    [win (update cap :retval | CA_COMMAND_BUSY)] ;; don't call edit() now
)

;; Command character that doesn't do anything, but unlike nv-ignore()
;; does start edit().  Used for "startinsert" executed while starting up.

(defn- #_[window_C cmdarg_C] nv-nop [#_window_C win, #_cmdarg_C cap]
    [win cap])

;; Command character doesn't exist.

(defn- #_[window_C cmdarg_C] nv-error [#_window_C win, #_cmdarg_C cap]
    [win (clearopbeep cap)])

;; CTRL-A and CTRL-X: Add or subtract from letter or number under cursor.

(defn- #_[window_C cmdarg_C] nv-addsub [#_window_C win, #_cmdarg_C cap]
    (let-when [[cap ?] (checkclearopq? cap)] (not ?) => [win cap]
        (let [[win ?] (do-addsub win, (:cmdchar cap), (:count1 cap))]
            (when ?
                (prep-redo-cmd cap))
            [win cap]
        )
    ))

;; CTRL-F, CTRL-B, etc: Scroll page up or down.

(defn- #_[window_C cmdarg_C] nv-page [#_window_C win, #_cmdarg_C cap]
    (let-when [[cap ?] (checkclearop? cap)] (not ?) => [win cap]
        (let [win (if (non-flag? @mod_mask MOD_MASK_CTRL)
                    (onepage win, (:arg cap), (:count1 cap))
                    win
                )]
            [win cap]
        )
    ))

;; Move "dist" screen rows in direction "dir".
;; "dist" must be positive.
;;
;; Return true if able to move cursor, false otherwise.

(defn- #_[window_C cmdarg_C boolean] nv-screengo [#_window_C win, #_cmdarg_C cap, #_int dir, #_long dist]
    (let [cap (update cap :oap assoc :motion_type MCHAR :inclusive (== (:w_curswant win) MAXCOL))
          [#_int width1 #_int width2]
            (let [o       (win-col-off  win)  w  (- (:w_width win) o)   ;; margin offset for first/wrapped screen line
                  o' (- o (win-col-off2 win)) w' (- (:w_width win) o')] ;; text width for first/wrapped screen line
                [w (if (zero? w') 1 w')])                               ;; avoid divide by zero
          [win #_boolean atend #_boolean moved]
            (if (non-zero? (:w_width win))
                ;; Instead of sticking at the last character of the buffer line we try to stick in the last column of the screen.
                (let [#_int linelen (linetabsize win, (ml-get (:lnum (:w_cursor win))))
                      [win atend]
                        (if (== (:w_curswant win) MAXCOL)
                            (let [win (validate-virtcol win)]
                                (if (< 0 width1)
                                    (let [win (assoc win :w_curswant (dec width1))
                                          win (if (< (:w_curswant win) (:w_virtcol win))
                                                (update win :w_curswant #(+ % (* (inc (/ (- (:w_virtcol win) % 1) width2)) width2)))
                                                win
                                            )]
                                        [win true])
                                    [(assoc win :w_curswant 0) true]
                                ))
                            (let [n (if (< width1 linelen) (+ (* (inc (/ (- linelen width1 1) width2)) width2) width1) width1)
                                  win (if (< (inc n) (:w_curswant win))
                                        (update win :w_curswant #(- % (* (inc (/ (- % n) width2)) width2)))
                                        win
                                    )]
                                [win false])
                        )]
                    (loop-when [win win linelen linelen dist dist] (< 0 dist) => [win atend true]
                        (let [[win linelen]
                                (cond (== dir BACKWARD)
                                    (if (<= width2 (:w_curswant win))
                                        ;; move back within line
                                        [(update win :w_curswant - width2) linelen]
                                        ;; to previous line
                                        (if (== (:lnum (:w_cursor win)) 1)
                                            [win nil]
                                            (let [win (update-in win [:w_cursor :lnum] dec)
                                                  linelen (linetabsize win, (ml-get (:lnum (:w_cursor win))))
                                                  win (if (< width1 linelen)
                                                        (update win :w_curswant + (* (inc (/ (- linelen width1 1) width2)) width2))
                                                        win
                                                    )]
                                                [win linelen])
                                        ))
                                :else ;; (== dir FORWARD)
                                    (let [#_int n (if (< width1 linelen) (+ (* (inc (/ (- linelen width1 1) width2)) width2) width1) width1)]
                                        (if (< (+ (:w_curswant win) width2) n)
                                            ;; move forward within line
                                            [(update win :w_curswant + width2) linelen]
                                            ;; to next line
                                            (if (== (:lnum (:w_cursor win)) (line-count @curbuf))
                                                [win nil]
                                                (let [win (update-in win [:w_cursor :lnum] inc)
                                                      win (update win :w_curswant % width2)]
                                                    [win (linetabsize win, (ml-get (:lnum (:w_cursor win))))]
                                                ))
                                        ))
                                )]
                            (recur-if (some? linelen) [win linelen (dec dist)] => [win atend false]))
                    ))
                [win false true])
          win (coladvance win, (if (and (virtual-active) atend) MAXCOL (:w_curswant win)))
          win (if (and (< 0 (:col (:w_cursor win))) @(:wo_wrap (:w_options win)))
                ;; Check for landing on a character that got split at the end of the last line.
                ;; We want to advance a screenline, not end up in the same screenline or move two screenlines.
                (let-when [win (validate-virtcol win) vcol (:w_virtcol win)
                      vcol (- vcol (if (and (< width1 vcol) (non-eos? @p_sbr)) (mb-string2cells @p_sbr) 0))
                      i (:w_curswant win)] (and (< i vcol) (if (< i width1) (< (/ width1 2) i) (< (/ width2 2) (% (- i width1) width2)))) => win
                    (update-in win [:w_cursor :col] dec))
                win)
          win (if atend
                (assoc win :w_curswant MAXCOL) ;; stick in the last column
                win
            )]
        [win cap moved]
    ))

;; Handle CTRL-E and CTRL-Y commands: scroll a line up or down.
;; cap.arg must be TRUE for CTRL-E.

(defn- #_[window_C cmdarg_C] nv-scroll-line [#_window_C win, #_cmdarg_C cap]
    (let-when [[cap ?] (checkclearop? cap)] (not ?) => [win cap]
        [(scroll-redraw win, (non-zero? (:arg cap)), (:count1 cap)) cap]
    ))

;; Scroll "count" lines up or down, and redraw.

(defn- #_window_C scroll-redraw [#_window_C win, #_boolean up, #_long count]
    (let [o'topline (:w_topline win) o'lnum (:lnum (:w_cursor win))
          win (if up (scrollup win, count) (scrolldown win, count))
          win (if (non-zero? @p_so)
                ;; Adjust the cursor position for 'scrolloff'.
                ;; Mark "w_topline" as valid, otherwise the screen jumps back at the end of the file.
                (let [win (-> win (cursor-correct) (check-cursor-moved) (update :w_valid | VALID_TOPLINE))]
                    ;; If moved back to where we were, at least move the cursor, otherwise we get stuck at one position.
                    ;; Don't move the cursor up if the first line of the buffer is already on the screen.
                    (loop-when [win win] (== (:w_topline win) o'topline) => win
                        (let-when [[win ?] (if up
                                    (if      (<= (:lnum (:w_cursor win)) o'lnum)                  (cursor-down? win, 1, false) [win false])
                                    (if (and (<= o'lnum (:lnum (:w_cursor win))) (< 1 o'topline)) (cursor-up?   win, 1, false) [win false])
                                )] ? => win
                            ;; Mark "w_topline" as valid, otherwise the screen jumps back at the end of the file.
                            (recur (-> win (check-cursor-moved) (update :w_valid | VALID_TOPLINE))))
                    ))
                win)
          win (if (!= (:lnum (:w_cursor win)) o'lnum) (coladvance win, (:w_curswant win)) win)]
        (redraw-later win, VALID)
    ))

;; Commands that start with "z".

(defn- #_[window_C cmdarg_C] nv-zet [#_window_C win, #_cmdarg_C cap]
    (let-when [[cap ?] (checkclearop? cap)] (not ?) => [win cap]
        (let-when [nchar (:nchar cap)
              [win cap nchar]
                (if (asc-isdigit nchar) ;; "z123{nchar}": edit the count before obtaining {nchar}
                    (loop [win win n (- nchar (byte \0))]
                        ;; no mapping for nchar, but allow key codes
                        (let [_ (swap! no_mapping inc) _ (swap! allow_keys inc) [win nchar] (plain-vgetc? win) _ (swap! no_mapping dec) _ (swap! allow_keys dec)
                              win (add-to-showcmd win, nchar)]
                            (cond
                                (any == nchar K_DEL K_KDEL)                       (recur win (/ n 10))
                                (asc-isdigit nchar)                               (recur win (+ (* n 10) (- nchar (byte \0))))
                                (== nchar CAR)                                    [(win-setheight win, n) cap nil]
                                (any == nchar (byte \l) (byte \h) K_LEFT K_RIGHT) [win (update cap :count1 #(if (non-zero? n) (* n %) %)) nchar]
                                :else                                             [win (clearopbeep cap) nil])
                        ))
                    [win cap nchar]
                )] (some? nchar) => [win cap]

            (let [wrap @(:wo_wrap (:w_options win)) lmax (line-count @curbuf)
                  -t- (fn [win cap y? x?]
                        (let [win (if (and y? (zero? (:count0 cap))) ;; No count given: put cursor at the line below screen.
                                    (let [win (validate-botline win)] (assoc-in win [:w_cursor :lnum] (min (:w_botline win) lmax)))
                                    win)
                              win (if (or y? x?) (beginline win, (| BL_WHITE BL_FIX)) win)]
                            [(-> win (scroll-cursor-top 0, true) (redraw-later VALID)) cap]
                        ))
                  -z- (fn [win cap z?]
                        (let [win (if z? (beginline win, (| BL_WHITE BL_FIX)) win)]
                            [(-> win (scroll-cursor-halfway true) (redraw-later VALID)) cap]
                        ))
                  -b- (fn [win cap y? x?]
                        (let [win (cond (not y?)
                                    win
                                (zero? (:count0 cap))
                                    (assoc-in win, [:w_cursor :lnum] (max 1 (- (:w_topline win) 1)))
                                :else
                                    ;; Strange Vi behavior:
                                    ;; <count>z^ finds line at top of window when <count> is at bottom of window,
                                    ;; and puts that one at bottom of window.
                                    (let [win (scroll-cursor-bot win, 0, true)]
                                        (assoc-in win, [:w_cursor :lnum] (:w_topline win))
                                    ))
                              win (if (or y? x?) (beginline win, (| BL_WHITE BL_FIX)) win)]
                            [(-> win (scroll-cursor-bot 0, true) (redraw-later VALID)) cap]
                        ))
                  -h- (fn [win cap z?]
                        (let [cap (if z? (update cap :count1 * (/ (:w_width win) 2)) cap)
                              win (if (not wrap)
                                    (let [win (assoc win :w_leftcol (max 0 (- (:w_leftcol win) (:count1 cap))))]
                                        (leftcol-changed win))
                                    win
                                )]
                            [win cap]
                        ))
                  -l- (fn [win cap z?]
                        (let [cap (if z? (update cap :count1 * (/ (:w_width win) 2)) cap)
                              win (if (not wrap)
                                    (let [win (update win :w_leftcol + (:count1 cap))]
                                        (leftcol-changed win))
                                    win
                                )]
                            [win cap]
                        ))
                  ;; For "z+", "z<CR>", "zt", "z.", "zz", "z^", "z-", "zb":  If line number given, set cursor.
                  win (if (and (some? (vim-strchr (u8 "+\r\nt.z^-b"), nchar)) (non-zero? (:count0 cap)) (!= (:count0 cap) (:lnum (:w_cursor win))))
                        (-> win
                            (setpcmark)
                            (assoc-in [:w_cursor :lnum] (min (:count0 cap) lmax))
                            (check-cursor-col))
                        win
                    )]

                (condp ==? nchar

                    (byte \+)           (-t- win, cap, :y?, :x?)            ;; put cursor at top of screen
                   [NL CAR K_KENTER]    (-t- win, cap, nil, :x?)
                    (byte \t)           (-t- win, cap, nil, nil)

                    (byte \.)           (-z- win, cap, :z?)                 ;; put cursor in middle of screen
                    (byte \z)           (-z- win, cap, nil)

                    (byte \^)           (-b- win, cap, :y?, :x?)            ;; put cursor at bottom of screen
                    (byte \-)           (-b- win, cap, nil, :x?)
                    (byte \b)           (-b- win, cap, nil, nil)

                    (byte \H)           (-h- win, cap, :z?)                 ;; scroll screen right half-page
                   [(byte \h) K_LEFT]   (-h- win, cap, nil)                 ;; scroll screen to the right

                    (byte \L)           (-l- win, cap, :z?)                 ;; scroll screen left half-page
                   [(byte \l) K_RIGHT]  (-l- win, cap, nil)                 ;; scroll screen to the left

                    (byte \s)                                               ;; scroll screen, cursor at the start
                        (let [win (if (not wrap)
                                    (let [a'col (atom (int)) _ (getvcol win, (:w_cursor win), a'col, nil, nil)
                                          _ (reset! a'col (max 0 (- @a'col @p_siso)))]
                                        (if (!= (:w_leftcol win) @a'col)
                                            (-> win (assoc :w_leftcol @a'col) (redraw-later NOT_VALID))
                                            win
                                        ))
                                    win
                                )]
                            [win cap])

                    (byte \e)                                               ;; scroll screen, cursor at the end
                        (let [win (if (not wrap)
                                    (let [a'col (atom (int)) _ (getvcol win, (:w_cursor win), nil, nil, a'col)
                                        n (- (:w_width win) (win-col-off win))
                                        _ (reset! a'col (max 0 (inc (+ @a'col (- @p_siso n)))))]
                                        (if (!= (:w_leftcol win) @a'col)
                                            (-> win (assoc :w_leftcol @a'col) (redraw-later NOT_VALID))
                                            win
                                        ))
                                    win
                                )]
                            [win cap])

                    [win (clearopbeep cap)])
            ))
    ))

;; Handle a ":" command.

(defn- #_[window_C cmdarg_C] nv-colon [#_window_C win, #_cmdarg_C cap]
    (if @VIsual_active
        (nv-operator win, cap)
        (let [cap (if (!= (:op_type (:oap cap)) OP_NOP)
                    ;; using ":" as a movement is characterwise exclusive
                    (update cap :oap assoc :motion_type MCHAR :inclusive false)
                    (do ;; translate "count:" into ":.,.+(count - 1)"
                        (when (non-zero? (:count0 cap))
                            (stuff-char (byte \.))
                            (when (< 1 (:count0 cap))
                                (stuff-string (u8 ",.+"))
                                (stuff-num (dec (:count0 cap)))
                            ))
                    cap)
                )]
            ;; When typing, don't type below an old message.
            (when @key_typed
                (compute-cmdrow))
            (let [o'im @p_im [win ?] (do-cmdline? win, nil, true, (if (!= (:op_type (:oap cap)) OP_NOP) DOCMD_KEEPLINE 0))] ;; get a command line and execute it
                ;; If 'insertmode' changed, enter or exit Insert mode.
                (when (!= @p_im o'im)
                    (reset! restart_edit (if @p_im (byte \i) 0)))
                (let [start (:op_start (:oap cap)) lmax (line-count @curbuf)]
                    (cond (not ?)
                        [win (clearop cap)] ;; the Ex command failed, do not execute the operator
                    (and (!= (:op_type (:oap cap)) OP_NOP) (or (< lmax (:lnum start)) (< (STRLEN (ml-get (:lnum start))) (:col start)) @did_emsg))
                        [win (clearopbeep cap)] ;; the start of the operator has become invalid by the Ex command
                    :else
                        [win cap]
                    ))
            ))
    ))

;; Handle CTRL-G command.

(defn- #_[window_C cmdarg_C] nv-ctrlg [#_window_C win, #_cmdarg_C cap]
    (cond @VIsual_active ;; toggle Selection/Visual mode
        (do (swap! VIsual_select not) [(showmode win) cap])
    :else
        (let-when [[cap ?] (checkclearop? cap)] (not ?) => [win cap]
            [(fileinfo win, (:count0 cap)) cap] ;; print full name if count given
        )
    ))

;; Handle CTRL-H <Backspace> command.

(defn- #_[window_C cmdarg_C] nv-ctrlh [#_window_C win, #_cmdarg_C cap]
    (if (and @VIsual_active @VIsual_select)
        (v-visop win, (assoc cap :cmdchar (byte \x))) ;; BS key behaves like 'x' in Select mode
        (nv-left win, cap)
    ))

;; CTRL-L: clear screen and redraw.

(defn- #_[window_C cmdarg_C] nv-clear [#_window_C win, #_cmdarg_C cap]
    (let-when [[cap ?] (checkclearop? cap)] (not ?) => [win cap]
        [(redraw-later win, CLEAR) cap]
    ))

;; CTRL-O: In Select mode: switch to Visual mode for one command.
;; Otherwise: Go to older pcmark.

(defn- #_[window_C cmdarg_C] nv-ctrlo [#_window_C win, #_cmdarg_C cap]
    (if (and @VIsual_active @VIsual_select)
        (let [_ (reset! VIsual_select false)
              win (showmode win)]
            (reset! restart_VIsual_select 2) ;; restart Select mode later
            [win cap])
        (nv-pcmark win, (update cap :count1 -))
    ))

;; "Z" commands.

(defn- #_[window_C cmdarg_C] nv-Zet [#_window_C win, #_cmdarg_C cap]
    (let-when [[cap ?] (checkclearopq? cap)] (not ?) => [win cap]
        (condp == (:nchar cap)
            (byte \Z) [(do-cmdline-cmd win, (u8 "x")) cap] ;; "ZZ": equivalent to ":x".
            [win (clearopbeep cap)]
        )
    ))

;; Handle the commands that use the word under the cursor.
;; [g] 'K'      run program for current identifier
;; [g] '*'      / to current identifier or string
;; [g] '#'      ? to current identifier or string

(defn- #_[window_C cmdarg_C] nv-ident [#_window_C win, #_cmdarg_C cap]
    (let-when [#_int cmd (:cmd cap) #_boolean g_cmd (== cmd (byte \g))
          cmd (if g_cmd (:nchar cap) cmd)                   ;; "g*" and "g#"
          cmd (if (== cmd (char_u POUND)) (byte \#) cmd)    ;; the pound sign, '#' for English keyboards
          a'ident (atom (#_Bytes object nil)) a'count (atom (int 0))
          ;; The "K" command accepts an argument in Visual mode.
          [win cap abort]
            (if (== cmd (byte \K))
                (let [[win ?] (if @VIsual_active (get-visual-text? win, a'ident, a'count) [win true])]
                    (cond (not ?)
                        [win (clearopbeep cap) :abort]
                    :else
                        (let [[cap ?] (checkclearopq? cap)] [win cap (when ? :abort)])
                    ))
                [win cap nil]
            )
    ] (not abort) => [win cap]

        (let-when [sea? (any == cmd (byte \*) (byte \#))
              [win cap abort]
                (when' (nil? @a'ident) => [win cap nil]
                    (let [#_int type (if sea? (| FIND_IDENT FIND_STRING) FIND_IDENT)
                          [win ?] (find-ident-under-cursor? win, a'ident, type)]
                        (reset! a'count ?)
                        (if (zero? @a'count) [win (clearop cap) :abort] [win cap nil])
                    ))
        ] (not abort) => [win cap]

            ;; Allocate buffer to put the command in.
            ;; Inserting backslashes can double the length of the word.
            ;; 'keywordprg' could be added and some numbers.
            (let-when [#_Bytes kp @(:b_p_kp @curbuf)
                  #_Bytes buf (Bytes. (+ (* @a'count 2) 30 (STRLEN kp)))
                  [win abort] (if sea?
                        ;; Put cursor at start of word, makes search skip the word under the cursor.
                        ;; Call setpcmark() first, so "*``" puts the cursor back where it was.
                        (let [win (setpcmark win)
                              win (assoc-in win [:w_cursor :col] (BDIFF @a'ident, (ml-get (:lnum (:w_cursor win)))))]
                            (when (and (not g_cmd) (us-iswordp @a'ident))
                                (STRCPY buf, (u8 "\\<")))
                            (reset! no_smartcase true)        ;; don't use 'smartcase' now
                            [win nil])
                        (do ;; An external command will probably use an argument starting
                            ;; with "-" as an option.  To avoid trouble we skip the "-".
                            (while (and (pos? @a'count) (at? @a'ident (byte \-)))
                                (swap! a'ident plus 1) (swap! a'count dec))
                            (if (zero? @a'count)
                                [(emsg win, e_noident) :abort] ;; found dashes only
                                (do ;; When a count is given, turn it into a range.  Is this really what we want?
                                    (when (non-zero? (:count0 cap))
                                        (ร .sprintf libC buf, (u8 ".,.+%ld"), (dec (:count0 cap))))
                                    (when (not-at? kp (byte \:))
                                        (STRCAT buf, (u8 "!")))
                                    (STRCAT buf, (if (at? kp (byte \:)) (.plus kp 1) kp))
                                    (STRCAT buf, (u8 " "))
                                    [win nil]
                                ))
                        ))
            ] (not abort) => [win cap]

                (let [#_Bytes aux
                        (condp == cmd
                            (byte \*) (if @p_magic (u8 "/.*~[^$\\") (u8 "/^$\\"))
                            (byte \#) (if @p_magic (u8 "/?.*~[^$\\") (u8 "/?^$\\"))
                                      (u8 "\\|\"\n*?[")
                        )]
                    ;; now grab the chars in the identifier
                    (loop-when [i (STRLEN buf)] (< 0 @a'count) => (eos! buf i)
                        ;; put a backslash before \ and some others
                        (let [i (if (some? (vim-strchr aux, (.at @a'ident 0))) (do (.be buf i, (byte \\)) (inc i)) i)]
                            ;; when current byte is part of multibyte character, copy all bytes of the character
                            (let [i (let [n (dec (us-ptr2len-cc @a'ident))]
                                        (loop-when-recur i (and (< i n) (< 1 @a'count)) (inc i) => i
                                            (.be buf i, (.at @a'ident 0)) (swap! a'ident plus 1) (swap! a'count dec)
                                        ))]
                                (.be buf i, (.at @a'ident 0)) (swap! a'ident plus 1) (swap! a'count dec)
                                (recur (inc i))
                            ))
                    ))
                ;; Execute the command.
                (if sea?
                    (do (when (and (not g_cmd) (us-iswordp (us-prevptr (ml-get (:lnum (:w_cursor win))), @a'ident)))
                            (STRCAT buf, (u8 "\\>")))
                        ;; put pattern in search history
                        (init-history)
                        (add-to-history HIST_SEARCH, buf, NUL)
                        (let [[win cap _] (normal-search? win, cap, (if (== cmd (byte \*)) (byte \/) (byte \?)), buf, 0)]
                            [win cap]
                        ))
                    [(do-cmdline-cmd win, buf) cap])
            ))
    ))

;; Get visually selected text, within one line only.
;; Returns false if more than one line selected.

(defn- #_[window_C boolean] get-visual-text? [#_window_C win, #_Bytes' a'start, #_int' a'count]
    (let-when [line? (== @VIsual_mode (byte \V))
          win (if (not line?) (let [[win _] (unadjust-for-sel? win)] win) win)
          visual @VIsual_cursor, cursor (:w_cursor win)] (== (:lnum visual) (:lnum cursor)) => [win false]

        (cond line?
        (do
            (reset! a'start (ml-get (:lnum cursor)))
            (reset! a'count (STRLEN @a'start))
        )
        :else
        (do
            (cond (ltpos cursor, visual)
            (do
                (reset! a'start (ml-get-pos cursor))
                (reset! a'count (inc (- (:col visual) (:col cursor))))
            )
            :else
            (do
                (reset! a'start (ml-get-pos visual))
                (reset! a'count (inc (- (:col cursor) (:col visual))))
            ))

            ;; Correct the length to include the whole last character.
            (swap! a'count #(+ % (dec (us-ptr2len-cc @a'start, (dec %)))))
        ))
        [(reset-VIsual-and-resel win) true]
    ))

;; Handle scrolling command 'H', 'L' and 'M'.

(defn- #_[window_C cmdarg_C] nv-scroll [#_window_C win, #_cmdarg_C cap]
    (let [cap (update cap :oap assoc :motion_type MLINE)
          win (setpcmark win)
          [win n]
            (if (== (:cmdchar cap) (byte \L))
                (let [win (validate-botline win)]
                    [win (max 1 (- (dec (:w_botline win)) (dec (:count1 cap))))])
                (let [lmax (line-count @curbuf)
                      [win n]
                        (cond (== (:cmdchar cap) (byte \M))
                            (let [win (validate-botline win) ;; make sure "w_empty_rows" is valid
                                  half (/ (inc (- (:w_height win) (:w_empty_rows win))) 2)
                                  [used n]
                                    (loop-when [used 0 n 0] (< (+ (:w_topline win) n) lmax) => [used n]
                                        (let [used (+ used (plines win, (+ (:w_topline win) n), true))]
                                            (recur-if (< used half) [used (inc n)] => [used n]))
                                    )]
                                [win (if (and (< 0 n) (< (:w_height win) used)) (dec n) n)])
                        :else ;; (== (:cmdchar cap) (byte \H))
                            [win (dec (:count1 cap))]
                        )]
                    [win (min (+ (:w_topline win) n) lmax)]
                ))
          win (assoc-in win [:w_cursor :lnum] n)
          win (cursor-correct win)] ;; correct for 'so'
        [(beginline win, (| BL_SOL BL_FIX)) cap]
    ))

;; Cursor right commands.

(defn- #_[window_C cmdarg_C] nv-right [#_window_C win, #_cmdarg_C cap]
    (if (flag? @mod_mask (| MOD_MASK_SHIFT MOD_MASK_CTRL))
        (let [cap (if (flag? @mod_mask MOD_MASK_CTRL) (assoc cap :arg TRUE) cap)] ;; <C-Right> and <S-Right> move a word or WORD right
            (nv-wordcmd win, cap))
        ;; In virtual edit mode, there's no such thing as "past_line", as lines are (theoretically) infinitely long.
        (let [#_boolean past_line (and @VIsual_active (not-at? @p_sel (byte \o)) (not (virtual-active)))]
            (loop-when [win win cap (update cap :oap assoc :motion_type MCHAR :inclusive false) n (:count1 cap)] (< 0 n) => [win cap]
                (let [[win ?] (if past_line [win true] (oneright? win))]
                    (if (and ? (or (not past_line) (non-eos? (ml-get-cursor win))))
                        (let [win (if past_line
                                    (let [win (assoc win :w_set_curswant true)]
                                        (if (virtual-active)
                                            (oneright win)
                                            (update-in win [:w_cursor :col] + (us-ptr2len-cc (ml-get-cursor win)))
                                        ))
                                    win
                                )]
                            (recur win cap (dec n)))
                        ;;    <Space> wraps to next line if 'whichwrap' has 's'.
                        ;;        'l' wraps to next line if 'whichwrap' has 'l'.
                        ;; CURS_RIGHT wraps to next line if 'whichwrap' has '>'.
                        (if (and (or (and (== (:cmdchar cap) (byte \space)) (some? (vim-strchr @p_ww, (byte \s))))
                                     (and (== (:cmdchar cap) (byte \l))     (some? (vim-strchr @p_ww, (byte \l))))
                                     (and (== (:cmdchar cap) K_RIGHT)       (some? (vim-strchr @p_ww, (byte \>)))))
                                 (< (:lnum (:w_cursor win)) (line-count @curbuf)))
                            ;; When deleting we also count the NL as a character.
                            ;; Set cap.oap.inclusive when last char in the line is included, move to next line after that.
                            (let [? (and (!= (:op_type (:oap cap)) OP_NOP) (not (:inclusive (:oap cap))) (not (lineempty (:lnum (:w_cursor win)))))
                                  cap (update cap :oap assoc :inclusive ?)
                                  win (if-not ?
                                        (let [win (update win :w_cursor #(assoc % :lnum (inc (:lnum %)) :col 0 :coladd 0))]
                                            (assoc win :w_set_curswant true))
                                        win
                                    )]
                                (recur win cap (dec n)))
                            (if (== (:op_type (:oap cap)) OP_NOP)
                                [(if (== n (:count1 cap)) (beep-flush win) win) cap] ;; only beep and flush if not moved at all
                                [win (if (not (lineempty (:lnum (:w_cursor win)))) (update cap :oap assoc :inclusive true) cap)]
                            ))
                    ))
            ))
    ))

;; Cursor left commands.

(defn- #_window_C skip-cc [#_window_C win] (let [#_Bytes s (ml-get-cursor win)] (if (non-eos? s) (update-in win [:w_cursor :col] + (us-ptr2len-cc s)) win)))

(defn- #_[window_C cmdarg_C] nv-left [#_window_C win, #_cmdarg_C cap]
    (if (flag? @mod_mask (| MOD_MASK_SHIFT MOD_MASK_CTRL))
        (let [cap (if (flag? @mod_mask MOD_MASK_CTRL) (assoc cap :arg 1) cap)] ;; <C-Left> and <S-Left> move a word or WORD left
            (nv-bck-word win, cap))
        (loop-when [win win cap (update cap :oap assoc :motion_type MCHAR :inclusive false) n (:count1 cap)] (< 0 n) => [win cap]
            (let-when [[win ?] (oneleft? win)] (not ?) => (recur win cap (dec n))
                ;; <BS> and <Del> wrap to previous line if 'whichwrap' has 'b'.
                ;;           'h' wraps to previous line if 'whichwrap' has 'h'.
                ;;     CURS_LEFT wraps to previous line if 'whichwrap' has '<'.
                (if (and (or (and (any == (:cmdchar cap) K_BS Ctrl_H) (some? (vim-strchr @p_ww, (byte \b))))
                             (or (and (== (:cmdchar cap) (byte \h))   (some? (vim-strchr @p_ww, (byte \h))))
                                 (and (== (:cmdchar cap) K_LEFT)      (some? (vim-strchr @p_ww, (byte \<))))))
                         (< 1 (:lnum (:w_cursor win))))
                    (let [win (-> win (update-in [:w_cursor :lnum] dec) (coladvance MAXCOL) (assoc :w_set_curswant true))]
                        ;; When the NL before the first char has to be deleted we put the cursor on the NUL after the previous line.
                        ;; This is a very special case, be careful!  Don't adjust op_end now, otherwise it won't work.
                        (let [? (and (or (== (:op_type (:oap cap)) OP_DELETE) (== (:op_type (:oap cap)) OP_CHANGE)) (not (lineempty (:lnum (:w_cursor win)))))
                              [win cap] (if ? [(skip-cc win) (update cap :retval | CA_NO_ADJ_OP_END)] [win cap])]
                            (recur win cap (dec n))
                        ))
                    [(if (and (== (:op_type (:oap cap)) OP_NOP) (== n (:count1 cap))) (beep-flush win) win) cap]) ;; only beep and flush if not moved at all
            ))
    ))

;; Cursor up commands.
;; cap.arg is TRUE for "-": Move cursor to first non-blank.

(defn- #_[window_C cmdarg_C] nv-up [#_window_C win, #_cmdarg_C cap]
    (cond (flag? @mod_mask MOD_MASK_SHIFT) ;; <S-Up> is page up
        (nv-page win, (assoc cap :arg BACKWARD))
    :else
        (let [cap (assoc-in cap [:oap :motion_type] MLINE) [win ?] (cursor-up? win, (:count1 cap), (== (:op_type (:oap cap)) OP_NOP))]
            (cond (not ?)
                [win (clearopbeep cap)]
            (non-zero? (:arg cap))
                [(beginline win, (| BL_WHITE BL_FIX)) cap]
            :else
                [win cap]
            ))
    ))

;; Cursor down commands.
;; cap.arg is TRUE for CR and "+": Move cursor to first non-blank.

(defn- #_[window_C cmdarg_C] nv-down [#_window_C win, #_cmdarg_C cap]
    (cond (flag? @mod_mask MOD_MASK_SHIFT) ;; <S-Down> is page down
        (nv-page win, (assoc cap :arg FORWARD))
    (and (non-zero? @cmdwin_type) (== (:cmdchar cap) CAR)) ;; in the cmdline window a <CR> executes the command
        (do (reset! cmdwin_result CAR) [win cap])
    :else
        (let [cap (assoc-in cap [:oap :motion_type] MLINE) [win ?] (cursor-down? win, (:count1 cap), (== (:op_type (:oap cap)) OP_NOP))]
            (cond (not ?)
                [win (clearopbeep cap)]
            (non-zero? (:arg cap))
                [(beginline win, (| BL_WHITE BL_FIX)) cap]
            :else
                [win cap]
            ))
    ))

;; <End> command: to end of current line or last line.

(defn- #_[window_C cmdarg_C] nv-end [#_window_C win, #_cmdarg_C cap]
    (let [[win cap]
            (if (or (non-zero? (:arg cap)) (flag? @mod_mask MOD_MASK_CTRL)) ;; CTRL-END = goto last line
                (let [[win cap] (nv-goto win, (assoc cap :arg TRUE))]
                    [win (assoc cap :count1 1)])
                [win cap]
            )]
        (nv-dollar win, cap)
    ))

;; Handle the "$" command.

(defn- #_[window_C cmdarg_C] nv-dollar [#_window_C win, #_cmdarg_C cap]
    (let [cap (update cap :oap assoc :motion_type MCHAR :inclusive true) nop? (== (:op_type (:oap cap)) OP_NOP)
          ;; In virtual mode when off the edge of a line and an operator is pending (whew!) keep the cursor where it is.
          ;; Otherwise, send it to the end of the line.
          win (if (or (not (virtual-active)) (!= (gchar-cursor win) NUL) nop?) (assoc win :w_curswant MAXCOL) win) ;; so we stay at the end
          [win ?] (cursor-down? win, (dec (:count1 cap)), nop?)]
        [win (if (not ?) (clearopbeep cap) cap)]
    ))

;; Implementation of '?' and '/' commands.
;; If cap.arg is TRUE, don't set PC mark.

(defn- #_[window_C cmdarg_C] nv-search [#_window_C win, #_cmdarg_C cap]
    (if (and (== (:cmdchar cap) (byte \?)) (== (:op_type (:oap cap)) OP_ROT13))
        (nv-operator win, (assoc cap :cmdchar (byte \g) :nchar (byte \?))) ;; translate "g??" to "g?g?"
        (let [[win ?] (getcmdline win, (:cmdchar cap), (:count1 cap)) cap (assoc cap :searchbuf ?)]
            (if (some? (:searchbuf cap))
                (let [[win cap _] (normal-search? win, cap, (:cmdchar cap), (:searchbuf cap), (if (zero? (:arg cap)) SEARCH_MARK 0))] [win cap])
                [win (clearop cap)]
            ))
    ))

;; Handle "N" and "n" commands.
;; cap.arg is SEARCH_REV for "N", 0 for "n".

(defn- #_[window_C cmdarg_C] nv-next [#_window_C win, #_cmdarg_C cap]
    (let [o'cursor (:w_cursor win) [win cap ?] (normal-search? win, cap, NUL, nil, (| SEARCH_MARK (:arg cap)))]
        (if (and (== ? 1) (eqpos o'cursor, (:w_cursor win)))
            ;; Avoid getting stuck on the current cursor position, which can happen when an offset is given
            ;; and the cursor is on the last char in the buffer: Repeat with count + 1.
            (let [cap (update cap :count1 inc) [win cap _] (normal-search? win, cap, NUL, nil, (| SEARCH_MARK (:arg cap))) cap (update cap :count1 dec)]
                [win cap])
            [win cap]
        )
    ))

;; Search for "pat" in direction "dirc" ('/' or '?', 0 for repeat).
;; Uses only cap.count1 and cap.oap from "cap".
;; Return 0 for failure, 1 for found, 2 for found and line offset added.

(defn- #_[window_C cmdarg_C int] normal-search? [#_window_C win, #_cmdarg_C cap, #_byte dirc, #_Bytes pat, #_int opt]
    ;; opt: extra flags for do-search()
    (let [cap (update cap :oap assoc :motion_type MCHAR :inclusive false :use_reg_one true)
          win (assoc win :w_set_curswant true)
          [win i ?] (do-search? win, dirc, pat, (:count1 cap), (| opt SEARCH_OPT SEARCH_ECHO SEARCH_MSG), nil)
          cap (if ? (assoc-in cap [:oap :inclusive] true) cap)
          [win cap]
            (if (zero? i)
                [win (clearop cap)]
                [(assoc-in win [:w_cursor :coladd] 0) (if (== i 2) (assoc-in cap [:oap :motion_type] MLINE) cap)]
            )]
        ;; "/$" will put the cursor after the end of the line, may need to correct that here
        [(check-cursor win) cap i]
    ))

;; Character search commands.
;; cap.arg is BACKWARD for 'F' and 'T', FORWARD for 'f' and 't', TRUE for ',' and FALSE for ';'.
;; cap.nchar is NUL for ',' and ';' (repeat the search).

(defn- #_[window_C cmdarg_C] nv-csearch [#_window_C win, #_cmdarg_C cap]
    (let-when [cap (assoc-in cap [:oap :motion_type] MCHAR)] (not (is-special (:nchar cap))) => [win (clearopbeep cap)]
        (let-when [tT? (any == (:cmdchar cap) (byte \t) (byte \T)) [win cap ?] (searchc? win, cap, tT?)] ? => [win (clearopbeep cap)]
            (let [win (assoc win :w_set_curswant true)
                  win (assoc-in win [:w_cursor :coladd] ;; include a Tab for "tx" and for "dfx"
                        (if (and (== (gchar-cursor win) TAB) (virtual-active) (== (:arg cap) FORWARD) (or tT? (!= (:op_type (:oap cap)) OP_NOP)))
                            (let [a'scol (atom (int)) a'ecol (atom (int))] (getvcol win, (:w_cursor win), a'scol, nil, a'ecol) (- @a'ecol @a'scol))
                            0)
                    )]
                (adjust-for-sel win, cap)
            ))
    ))

;; "[" and "]" commands.
;; cap.arg is BACKWARD for "[" and FORWARD for "]".

(defn- #_[window_C cmdarg_C] nv-brackets [#_window_C win, #_cmdarg_C cap]
    (let [cap (update cap :oap assoc :motion_type MCHAR :inclusive false) o'cursor (:w_cursor win)
          win (assoc-in win [:w_cursor :coladd] 0)] ;; TODO: don't do this for an error

        ;; "[{", "[(", "]}" or "])": go to Nth unclosed '{', '(', '}' or ')'
        ;; "[#", "]#": go to start/end of Nth innermost #if..#endif construct.
        ;; "[/", "[*", "]/", "]*": go to Nth comment start/end.

        (cond (or (and (== (:cmdchar cap) (byte \[)) (some? (vim-strchr (u8 "{("), (:nchar cap))))
                  (and (== (:cmdchar cap) (byte \])) (some? (vim-strchr (u8 "})"), (:nchar cap)))))
            (let [#_int findc (:nchar cap) dir (if (== (:cmdchar cap) (byte \[)) FM_BACKWARD FM_FORWARD)
                  [win cap #_pos_C pos]
                    (loop-when [win win cap cap pos nil n (:count1 cap)] (< 0 n) => [win cap pos]
                        (let [#_pos_C prior pos pos (findmatchlimit win, findc, dir, 0)]
                            (if (some? pos)
                                (recur (assoc win :w_cursor pos) cap pos (dec n))
                                (if (some? prior) [win cap prior] [win (clearopbeep cap) nil])
                            )))
                  win (if (some? pos)
                        (-> win (setpcmark) (assoc :w_cursor pos :w_set_curswant true))
                        (assoc win :w_cursor o'cursor)
                    )]
                [win cap])

        ;; "[p", "[P", "]P" and "]p": put with indent adjustment

        (any == (:nchar cap) (byte \p) (byte \P))
            (let-when [[cap ?] (checkclearop? cap)] (not ?) => [win cap]
                (let-when [visual? @VIsual_active
                      #_int dir (if (and (== (:cmdchar cap) (byte \])) (== (:nchar cap) (byte \p))) FORWARD BACKWARD)
                      [win [start end]]
                        (if visual?
                            (let [c (:w_cursor win) v @VIsual_cursor s (if (ltoreq v, c) v c) e (if (eqpos s, v) c v)]
                                [(assoc win :w_cursor (if (== dir BACKWARD) s e)) [s e]])
                            [win nil])
                      o'lmax (line-count @curbuf)
                      #_int regname (adjust-clip-reg (:regname (:oap cap)))
                      _ (prep-redo-cmd cap)
                      win (do-put win, regname, dir, (:count1 cap), PUT_FIXINDENT)] visual? => [win cap]

                    (let [n (if (== dir BACKWARD) (- (line-count @curbuf) o'lmax) 0)
                          _ (reset! VIsual_cursor (update start :lnum + n))
                          win (assoc win :w_cursor (update end :lnum + n))
                          _ (reset! VIsual_active true)
                          [win cap]
                            (if (== @VIsual_mode (byte \V)) ;; delete visually selected lines
                                (let [cap (-> cap (assoc :cmdchar (byte \d) :nchar NUL) (assoc-in [:oap :regname] regname))
                                      [win cap] (nv-operator win, cap)]
                                    (do-pending-operator win, cap, 0))
                                [win cap]
                            )]
                        [(if @VIsual_active (-> win (end-visual-mode) (redraw-later SOME_VALID)) win) cap])
                ))

        ;; "['", "[`", "]'" and "]`": jump to next mark

        (any == (:nchar cap) (byte \') (byte \`))
            (let [dir (if (== (:cmdchar cap) (byte \[)) BACKWARD FORWARD) sol (== (:nchar cap) (byte \'))
                  pos (loop-when [pos (:w_cursor win) n (:count1 cap)] (< 0 n) => pos
                            (let [next (getnextmark pos, dir, sol)]
                                (recur-if (some? next) [next (dec n)] => pos))
                        )]
                (nv-cursormark win, cap, sol, pos))

        ;; Not a valid cap.nchar.

        :else [win (clearopbeep cap)])
    ))

;; Handle Normal mode "%" command.

(defn- #_[window_C cmdarg_C] nv-percent [#_window_C win, #_cmdarg_C cap]
    (let [cap (assoc-in cap [:oap :inclusive] true)]
        (if (non-zero? (:count0 cap))
            ;; {cnt}% : goto {cnt} percentage in file
            (if (< 100 (:count0 cap))
                [win (clearopbeep cap)]
                (let [cap (assoc-in cap [:oap :motion_type] MLINE)
                      win (setpcmark win)
                      lmax (line-count @curbuf)
                      ;; Round up, so CTRL-G will give same value.
                      win (assoc-in win [:w_cursor :lnum] (min (/ (+ (* lmax (:count0 cap)) 99) 100) lmax))]
                    [(beginline win, (| BL_SOL BL_FIX)) cap]
                ))
            ;; "%" : go to matching paren
            (let [cap (update cap :oap assoc :motion_type MCHAR :use_reg_one true) #_pos_C pos (findmatch win, NUL)]
                (if (nil? pos)
                    [win (clearopbeep cap)]
                    (let [win (setpcmark win)
                          win (assoc win :w_cursor (assoc pos :coladd 0) :w_set_curswant true)]
                        (adjust-for-sel win, cap)
                    ))
            ))
    ))

;; "m" command: Mark a position.

(defn- #_[window_C cmdarg_C] nv-mark [#_window_C win, #_cmdarg_C cap]
    (let-when [[cap ?] (checkclearop? cap)] (not ?) => [win cap]
        (let [[win ?] (set-mark? win, (:w_cursor win), (:nchar cap))]
            [win (if (not ?) (clearopbeep cap) cap)])
    ))

;; "u" command: Undo or make lower case.

(defn- #_[window_C cmdarg_C] nv-undo [#_window_C win, #_cmdarg_C cap]
    (if (or (== (:op_type (:oap cap)) OP_LOWER) @VIsual_active)
        (nv-operator win, (assoc cap :cmdchar (byte \g) :nchar (byte \u))) ;; translate "<Visual>u" to "<Visual>gu" and "guu" to "gugu"
        (nv-kundo win, cap)
    ))

;; <Undo> command.

(defn- #_[window_C cmdarg_C] nv-kundo [#_window_C win, #_cmdarg_C cap]
    (let-when [[cap ?] (checkclearopq? cap)] (not ?) => [win cap]
        (let [win (u-undo win, (:count1 cap))]
            [(assoc win :w_set_curswant true) cap])
    ))

;; Handle the "r" command.

(defn- #_[window_C cmdarg_C] nv-replace [#_window_C win, #_cmdarg_C cap]
    (let-when [[cap ?] (checkclearop? cap)] (not ?) => [win cap]
        (let [[win cap #_int had_ctrl_v]
                (if (== (:nchar cap) Ctrl_V) ;; get another character
                    (let [[win ?] (get-literal? win) cap (assoc cap :nchar ?)]
                        ;; Don't redo a multibyte character with CTRL-V.
                        [win cap (if (< DEL (:nchar cap)) NUL Ctrl_V)])
                    [win cap NUL]
                )]
            (cond (is-special (:nchar cap))
                ;; Abort if the character is a special key.
                [win (clearopbeep cap)]
            @VIsual_active
                ;; Visual mode "r".
                (let [win (if @got_int (reset-VIsual win) win)
                      cap (if (!= had_ctrl_v NUL) (update cap :nchar #(condp == % (byte \return) -1 (byte \newline) -2 %)) cap)]
                    (nv-operator win, cap))
            :else
                ;; Break tabs, etc.
                (let-when [[win abort]
                    (if (virtual-active)
                        (when' (u-save-cursor win) => [win :abort]
                            (condp == (gchar-cursor win)
                                ;; Add extra space and put the cursor on the first one.
                                NUL [(-> win (coladvance-force (+ (getviscol win) (:count1 cap))) (update-in [:w_cursor :col] - (:count1 cap))) nil]
                                TAB [(coladvance-force win, (getviscol win)) nil]
                                    [win nil]
                            ))
                        [win nil]
                    )] (not abort) => [win cap]

                    (let [#_Bytes s (ml-get-cursor win)]
                        (cond (< (min (us-charlen s) (STRLEN s)) (:count1 cap))
                            ;; Abort if not enough characters to replace.
                            [win (clearopbeep cap)]

                        (and (!= had_ctrl_v Ctrl_V) (== (:nchar cap) TAB) (or @(:b_p_et @curbuf) @p_sta))
                            ;; Replacing with a TAB is done by edit() when it is complicated because
                            ;; 'expandtab' or 'smarttab' is set.  CTRL-V TAB inserts a literal TAB.
                            ;; Other characters are done below to avoid problems with things like
                            ;; CTRL-V 048 (for edit() this would be R CTRL-V 0 ESC).
                            (do (stuff-num (:count1 cap))
                                (stuff-char (byte \R))
                                (stuff-char TAB)
                                (stuff-char ESC)
                                [win cap])

                        ;; save line for undo
                        (not (u-save-cursor win))
                            [win cap]

                        (and (!= had_ctrl_v Ctrl_V) (any == (:nchar cap) (byte \return) (byte \newline)))
                            ;; Replace character(s) by a single newline.
                            ;; Strange vi behaviour:  Only one newline is inserted.
                            ;; Delete the characters here.
                            ;; Insert the newline with an insert command, takes care of autoindent.
                            ;; The insert command depends on being on the last character of a line or not.
                            (let [win (del-chars win, (:count1 cap), false)]
                                (stuff-char (byte \return))
                                (stuff-char ESC)
                                ;; Give 'r' to edit(), to get the redo command right.
                                (invoke-edit win, cap, true, (byte \r), false))

                        :else
                            (let [_ (prep-redo (:regname (:oap cap)), (:count1 cap), NUL, (byte \r), NUL, had_ctrl_v, (:nchar cap))
                                  _ (swap! curbuf assoc :b_op_start (:w_cursor win))
                                  o'State @State
                                  _ (when (non-zero? (:ncharC1 cap)) (append-redo-char (:ncharC1 cap)))
                                  _ (when (non-zero? (:ncharC2 cap)) (append-redo-char (:ncharC2 cap)))
                                  ;; This is slow, but it handles replacing a single-byte with a multi-byte and the other way around.
                                  ;; Also handles adding composing characters for utf-8.
                                  win (loop-when [win win n (:count1 cap)] (< 0 n) => win
                                        (reset! State REPLACE)
                                        (let [win (if (any == (:nchar cap) Ctrl_E Ctrl_Y)
                                                    (let [[win #_int c] (ins-copychar win, (+ (:lnum (:w_cursor win)) (if (== (:nchar cap) Ctrl_Y) -1 1)))]
                                                        (if (!= c NUL)
                                                            (ins-char win, c)
                                                            (update-in win [:w_cursor :col] inc) ;; will be decremented further down
                                                        ))
                                                    (ins-char win, (:nchar cap)))
                                              _ (reset! State o'State)
                                              win (if (non-zero? (:ncharC1 cap)) (ins-char win, (:ncharC1 cap)) win)
                                              win (if (non-zero? (:ncharC2 cap)) (ins-char win, (:ncharC2 cap)) win)]
                                            (recur win (dec n))
                                        ))
                                  win (update-in win [:w_cursor :col] dec) ;; cursor on the last replaced char
                                  ;; If the character on the left of the current cursor
                                  ;; is a multi-byte character, move two characters left.
                                  win (update win :w_cursor mb-adjust-pos)
                                  _ (swap! curbuf assoc :b_op_end (:w_cursor win))
                                  win (assoc win :w_set_curswant true)]
                                (set-last-insert (:nchar cap))
                                [win cap]
                            ))
                    ))
            ))
    ))

;; 'o': Exchange start and end of Visual area;
;; 'O': same, but in block mode exchange left and right corners.

(defn- #_window_C v-swap-corners [#_window_C win, #_int cmdchar]
    (let [o'cursor (:w_cursor win)]
        (if (and (== cmdchar (byte \O)) (== @VIsual_mode Ctrl_V))
            (let [a'left (atom (int)) a'right (atom (int)) _ (getvcols win, o'cursor, @VIsual_cursor, a'left, a'right)
                  win (assoc-in win [:w_cursor :lnum] (:lnum @VIsual_cursor))
                  win (coladvance win, @a'left)
                  _ (reset! VIsual_cursor (:w_cursor win))
                  win (assoc-in win [:w_cursor :lnum] (:lnum o'cursor))
                  win (assoc win :w_curswant @a'right)
                  ;; 'selection "exclusive" and cursor at right-bottom corner: move it right one column
                  win (if (and (<= (:lnum @VIsual_cursor) (:lnum o'cursor)) (at? @p_sel (byte \e))) (update win :w_curswant inc) win)
                  win (coladvance win, (:w_curswant win))]
                (if (and (== (:col (:w_cursor win)) (:col o'cursor)) (or (not (virtual-active)) (== (:coladd (:w_cursor win)) (:coladd o'cursor))))
                    (let [win (assoc-in win [:w_cursor :lnum] (:lnum @VIsual_cursor))
                          _ (when (and (<= (:lnum o'cursor) (:lnum @VIsual_cursor)) (at? @p_sel (byte \e)))
                                (swap! a'right inc))
                          win (coladvance win, @a'right)
                          _ (reset! VIsual_cursor (:w_cursor win))
                          win (assoc-in win [:w_cursor :lnum] (:lnum o'cursor))
                          win (coladvance win, @a'left)
                          win (assoc win :w_curswant @a'left)]
                        win)
                    win
                ))
            (let [win (assoc win :w_cursor @VIsual_cursor)
                  _ (reset! VIsual_cursor o'cursor)
                  win (assoc win :w_set_curswant true)]
                win
            ))
    ))

;; "R" (cap.arg is FALSE) and "gR" (cap.arg is TRUE).

(defn- #_[window_C cmdarg_C] nv-Replace [#_window_C win, #_cmdarg_C cap]
    (cond @VIsual_active
        (do ;; "R" is replace lines
            (reset! VIsual_mode_orig @VIsual_mode) ;; remember original area for gv
            (reset! VIsual_mode (byte \V))
            (nv-operator win, (assoc cap :cmdchar (byte \c) :nchar NUL)))
    :else
        (let-when [[cap ?] (checkclearopq? cap)] (not ?) => [win cap]
            (let [win (if (virtual-active) (coladvance win, (getviscol win)) win)]
                (invoke-edit win, cap, false, (if (non-zero? (:arg cap)) (byte \V) (byte \R)), false)
            ))
    ))

;; "gr".

(defn- #_[window_C cmdarg_C] nv-vreplace [#_window_C win, #_cmdarg_C cap]
    (cond @VIsual_active
        (nv-replace win, (assoc cap :cmdchar (byte \r) :nchar (:extra_char cap))) ;; do same as "r" in Visual mode for now
    :else
        (let-when [[cap ?] (checkclearopq? cap)] (not ?) => [win cap]
            (let [[win cap] (if (== (:extra_char cap) Ctrl_V) (let [[win ?] (get-literal? win)] [win (assoc cap :extra_char ?)]) [win cap]) ;; get another character
                  _ (stuff-char (:extra_char cap))
                  _ (stuff-char ESC)
                  win (if (virtual-active) (coladvance win, (getviscol win)) win)]
                (invoke-edit win, cap, true, (byte \v), false)
            ))
    ))

;; Swap case for "~" command, when it does not work like an operator.

(defn- #_pos_C crlf [#_pos_C pos] (assoc pos :lnum (inc (:lnum pos)) :col 0))

(defn- #_[window_C cmdarg_C] n-swapchar [#_window_C win, #_cmdarg_C cap]
    (let-when [[cap ?] (checkclearopq? cap)] (not ?) => [win cap]
        (cond (and (lineempty (:lnum (:w_cursor win))) (nil? (vim-strchr @p_ww, (byte \~))))
            [win (clearopbeep cap)]
        :else
            (let-when [_ (prep-redo-cmd cap)] (u-save-cursor win) => [win cap]
                (let [startpos (:w_cursor win) lmax (line-count @curbuf)
                      [win changed]
                        (loop-when [win win changed false n (:count1 cap)] (< 0 n) => [win changed]
                            (let [[win _ ?] (swapchar win, (:op_type (:oap cap)), (:w_cursor win)) win (assoc win :w_cursor _) changed (or ? changed)
                                  win (inc-cursor win, false)
                                  [win ?]
                                    (cond (!= (gchar-cursor win) NUL)
                                        [win true]
                                    (and (some? (vim-strchr @p_ww, (byte \~))) (< (:lnum (:w_cursor win)) lmax))
                                        (let-when [win (update win :w_cursor crlf)] (< 1 n) => [win true]
                                            [win (if (u-savesub win, (:lnum (:w_cursor win))) (do (u-clearline) true) false)])
                                    :else
                                        [win false]
                                    )]
                                (recur-if ? [win changed (dec n)] => [win changed])
                            ))
                      win (-> win (check-cursor) (assoc :w_set_curswant true))]
                    (when changed
                        (swap! curbuf changed-lines (:lnum startpos), (:col startpos), (inc (:lnum (:w_cursor win))), 0)
                        (let [endpos (update (:w_cursor win) :col #(max 0 (dec %)))]
                            (swap! curbuf assoc :b_op_start startpos, :b_op_end endpos)
                        ))
                    [win cap])
            ))
    ))

;; Move cursor to mark.

(defn- #_[window_C cmdarg_C] nv-cursormark [#_window_C win, #_cmdarg_C cap, #_boolean flag, #_pos_C pos]
    (let [[win ?] (check-mark? win, pos)
          [win cap]
            (when' ? => [win (clearop cap)]
                (let [win (if (any == (:cmdchar cap) (byte \') (byte \`) (byte \[) (byte \])) (setpcmark win) win)
                      win (assoc win :w_cursor pos)
                      win (if flag (beginline win, (| BL_WHITE BL_FIX)) (check-cursor win))]
                    [win cap]
                ))
          cap (update cap :oap assoc :motion_type (if flag MLINE MCHAR))
          cap (if (== (:cmdchar cap) (byte \`)) (update cap :oap assoc :use_reg_one true) cap)
          cap (update cap :oap assoc :inclusive false)] ;; ignored if not MCHAR
        [(assoc win :w_set_curswant true) cap]
    ))

(final Bytes visop_trans (u8 "YyDdCcxdXdAAIIrr"))

;; Handle commands that are operators in Visual mode.

(defn- #_[window_C cmdarg_C] v-visop [#_window_C win, #_cmdarg_C cap]
    ;; Uppercase means linewise, except in block mode, then "D" deletes, and "C" replaces till EOL.
    (let [win (if (asc-isupper (:cmdchar cap))
                (cond (!= @VIsual_mode Ctrl_V)
                    (do (reset! VIsual_mode_orig @VIsual_mode)
                        (reset! VIsual_mode (byte \V))
                        win)
                (any == (:cmdchar cap) (byte \C) (byte \D))
                    (assoc win :w_curswant MAXCOL)
                :else
                    win)
                win
            )]
        (nv-operator win, (update cap :cmdchar #(.at (vim-strchr visop_trans, %) 1)))
    ))

;; "s" and "S" commands.

(defn- #_[window_C cmdarg_C] nv-subst [#_window_C win, #_cmdarg_C cap]
    (if @VIsual_active ;; "vs" and "vS" are the same as "vc"
        (do (when (== (:cmdchar cap) (byte \S))
                (reset! VIsual_mode_orig @VIsual_mode)
                (reset! VIsual_mode (byte \V)))
            (nv-operator win, (assoc cap :cmdchar (byte \c))))
        (nv-optrans win, cap)
    ))

;; Abbreviated commands.

(defn- #_[window_C cmdarg_C] nv-abbrev [#_window_C win, #_cmdarg_C cap]
    (let [cap (if (any == (:cmdchar cap) K_DEL K_KDEL) (assoc cap :cmdchar (byte \x)) cap)] ;; DEL key behaves like 'x'
        ;; in Visual mode these commands are operators
        (if @VIsual_active (v-visop win, cap) (nv-optrans win, cap))
    ))

(final Bytes* #_"[/*8*/]" optrans_ar
    [
        (u8 "dl"), (u8 "dh"),
        (u8 "d$"), (u8 "c$"),
        (u8 "cl"), (u8 "cc"),
        (u8 "yy"), (u8 ":s\r")
    ])
(final Bytes optrans_str (u8 "xXDCsSY&"))

;; Translate a command into another command.

(defn- #_[window_C cmdarg_C] nv-optrans [#_window_C win, #_cmdarg_C cap]
    (let [[win cap]
            (let-when [[cap ?] (checkclearopq? cap)] (not ?) => [win cap]
                (if (and (== (:cmdchar cap) (byte \D)) (some? (vim-strbyte @p_cpo, CPO_HASH)))
                    ;; In Vi "2D" doesn't delete the next line.
                    ;; Can't translate it either, because "2." should also not use the count.
                    (let [[win cap] (nv-dollar win, (-> cap (update :oap assoc :op_start (:w_cursor win) :op_type OP_DELETE) (assoc :count1 1)))]
                        (reset! finish_op true)
                        (reset-redo)
                        (append-redo-char (byte \D))
                        [win cap])
                    (do (when (non-zero? (:count0 cap))
                            (stuff-num (:count0 cap)))
                        (stuff-string (... optrans_ar (BDIFF (vim-strchr optrans_str, (:cmdchar cap)), optrans_str)))
                        [win cap])
                ))]
        [win (assoc cap :opcount 0)]
    ))

;; "'" and "`" commands.  Also for "g'" and "g`".
;; cap.arg is TRUE for "'" and "g'".

(defn- #_[window_C cmdarg_C] nv-gomark [#_window_C win, #_cmdarg_C cap]
    (let [#_int c (if (== (:cmdchar cap) (byte \g)) (:extra_char cap) (:nchar cap))
          [win cap] (nv-cursormark win, cap, (non-zero? (:arg cap)), (getmark win, c))]
        ;; May need to clear the coladd that a mark includes.
        [(if-not (virtual-active) (assoc-in win [:w_cursor :coladd] 0) win) cap]
    ))

;; Handle CTRL-O, CTRL-I, "g;" and "g," commands.

(defn- #_[window_C cmdarg_C] nv-pcmark [#_window_C win, #_cmdarg_C cap]
    (let-when [[cap ?] (checkclearopq? cap)] (not ?) => [win cap]
        (let [[win #_pos_C pos] (if (== (:cmdchar cap) (byte \g)) (movechangelist win, (:count1 cap)) (movemark win, (:count1 cap)))]
            (if (some? pos)
                (nv-cursormark win, cap, false, pos)
                (when' (== (:cmdchar cap) (byte \g)) => [win (clearopbeep cap)]
                    (let [? (cond
                                (zero? (:b_changelistlen @curbuf)) (u8 "E664: changelist is empty")
                                (< (:count1 cap) 0) (u8 "E662: At start of changelist")
                                :else (u8 "E663: At end of changelist")
                            )]
                        [(emsg win, ?) cap]
                    ))
            ))
    ))

;; Handle '"' command.

(defn- #_[window_C cmdarg_C] nv-regname [#_window_C win, #_cmdarg_C cap]
    (let-when [[cap ?] (checkclearop? cap)] (not ?) => [win cap]
        (let [[win cap] (if (== (:nchar cap) (byte \=)) (let [[win ?] (get-expr-register? win)] [win (assoc cap :nchar ?)]) [win cap])]
            (if (and (!= (:nchar cap) NUL) (valid-yank-reg (:nchar cap), false))
                [win (as-> (update cap :oap assoc :regname (:nchar cap)) cap
                      (assoc cap :opcount (:count0 cap)))] ;; remember count before '"'
                [win (clearopbeep cap)]
            ))
    ))

;; Handle "v", "V" and "CTRL-V" commands.
;; Also for "gh", "gH" and "g^H" commands: Always start Select mode, cap.arg is TRUE.
;; Handle CTRL-Q just like CTRL-V.

(defn- #_[window_C cmdarg_C] nv-visual [#_window_C win, #_cmdarg_C cap]
    (let [cap (if (== (:cmdchar cap) Ctrl_Q) (assoc cap :cmdchar Ctrl_V) cap)]
        ;; 'v', 'V' and CTRL-V can be used while an operator is pending to make it characterwise, linewise, or blockwise
        (cond (!= (:op_type (:oap cap)) OP_NOP)
            (do (reset! finish_op false)                                    ;; operator doesn't finish now but later
                [win (update cap :oap assoc :motion_force (:cmdchar cap))])
        :else
            (do (reset! VIsual_select (non-zero? (:arg cap)))
                (cond @VIsual_active                                        ;; change Visual mode
                    (let [win (if (== @VIsual_mode (:cmdchar cap))          ;; stop visual mode
                                (end-visual-mode win)
                                (do (reset! VIsual_mode (:cmdchar cap)) (showmode win))
                            )]
                        (redraw-curbuf-later INVERTED)                      ;; update the inversion
                        [win cap])
                :else                                                       ;; start Visual mode
                    (let [win (check-visual-highlight win)]
                        (cond (and (< 0 (:count0 cap)) (!= @resel_VIsual_mode NUL))
                            (do (reset! VIsual_cursor (:w_cursor win))      ;; use previously selected part
                                (reset! VIsual_active true)
                                (reset! VIsual_reselect true)
                                (when (zero? (:arg cap))
                                    (may-start-select (byte \c)))           ;; start Select mode when 'selectmode' contains "cmd"
                                (when @p_smd
                                    (reset! redraw_cmdline true))           ;; show visual mode later
                                ;; For V and ^V, we multiply the number of lines even if there was only one.
                                (let [win (if (or (!= @resel_VIsual_mode (byte \v)) (< 1 @resel_VIsual_lmax))
                                            (update-in win [:w_cursor :lnum] #(min (+ % (dec (* @resel_VIsual_lmax (:count0 cap)))) (line-count @curbuf)))
                                            win)
                                      _ (reset! VIsual_mode @resel_VIsual_mode)
                                      win (if (== @VIsual_mode (byte \v))
                                            (let [[win ?]
                                                    (if (<= @resel_VIsual_lmax 1)
                                                        (let [win (validate-virtcol win)]
                                                            [win (dec (+ (:w_virtcol win) (* @resel_VIsual_vcol (:count0 cap))))])
                                                        [win @resel_VIsual_vcol]
                                                    )]
                                                (-> win (assoc :w_curswant ?) (coladvance ?)))
                                            win)
                                      win (cond (== @resel_VIsual_vcol MAXCOL)
                                            (-> win (assoc :w_curswant MAXCOL) (coladvance MAXCOL))
                                        (== @VIsual_mode Ctrl_V)
                                            (let [win (validate-virtcol win) ? (dec (+ (:w_virtcol win) (* @resel_VIsual_vcol (:count0 cap))))]
                                                (-> win (assoc :w_curswant ?) (coladvance ?)))
                                        :else
                                            (assoc win :w_set_curswant true)
                                        )]
                                    (redraw-curbuf-later INVERTED)          ;; show the inversion
                                    [win cap]
                                ))
                        :else
                            (do (when (zero? (:arg cap))
                                    (may-start-select (byte \c))) ;; start Select mode when 'selectmode' contains "cmd"
                                (let [win (n-start-visual-mode win, (:cmdchar cap))
                                      cap (if (and (!= @VIsual_mode (byte \V)) (at? @p_sel (byte \e))) (update cap :count1 inc) cap)] ;; include one more char
                                    (if (< 0 (:count0 cap))
                                        (let [cap (update cap :count1 dec)]
                                            (if (< 0 (:count1 cap)) ;; with a count select that many characters or lines
                                                (cond
                                                    (any == @VIsual_mode (byte \v) Ctrl_V) (nv-right win, cap)
                                                    (== @VIsual_mode (byte \V)) (nv-down win, cap)
                                                    :else [win cap]
                                                )
                                                [win cap]
                                            ))
                                        [win cap]
                                    ))
                            ))
                    ))
            ))
    ))

;; Start selection for Shift-movement keys.

(defn- #_window_C start-selection [#_window_C win]
    (may-start-select (byte \k)) ;; if 'selectmode' contains "key", start Select mode
    (n-start-visual-mode win, (byte \v)))

;; Start Select mode, if "c" is in 'selectmode' and not in a mapping or menu.

(defn- #_void may-start-select [#_int c]
    (reset! VIsual_select (and (stuff-empty) (some? (vim-strchr @p_slm, c))))
    nil)

;; Start Visual mode "c".
;; Should set VIsual_select before calling this.

(defn- #_window_C n-start-visual-mode [#_window_C win, #_int c]
    (let [_ (reset! VIsual_mode c)
          _ (reset! VIsual_active true)
          _ (reset! VIsual_reselect true)
          ;; Corner case: the 0 position in a tab may change when going into virtualedit.
          ;; Recalculate "w_cursor" to avoid bad hilighting.
          win (if (and (== c Ctrl_V) (flag? @ve_flags VE_BLOCK) (== (gchar-cursor win) TAB))
                (let [win (validate-virtcol win)]
                    (coladvance win, (:w_virtcol win)))
                win)
          _ (reset! VIsual_cursor (:w_cursor win))]
        (when @p_smd ;; show visual mode later
            (reset! redraw_cmdline true))
        ;; Only need to redraw this line, unless still need to redraw
        ;; an old Visual area (when 'lazyredraw' is set).
        (if (< (:w_redr_type win) INVERTED)
            (let [cln (:lnum (:w_cursor win))]
                (assoc win :w_old_cursor_lnum cln, :w_old_visual_lnum cln))
            win)
    ))

;; CTRL-W: Window commands

(defn- #_[window_C cmdarg_C] nv-window [#_window_C win, #_cmdarg_C cap]
    (let-when [[cap ?] (checkclearop? cap)] (not ?) => [win cap]
        [(do-window win, (:nchar cap), (:count0 cap), NUL) cap]
    ))

;; CTRL-Z: Suspend

(defn- #_[window_C cmdarg_C] nv-suspend [#_window_C win, #_cmdarg_C cap]
    (let [cap (clearop cap) win (if @VIsual_active (end-visual-mode win) win)] ;; stop Visual mode
        [(do-cmdline-cmd win, (u8 "st")) cap]
    ))

;; Commands starting with "g".

(defn- #_[window_C cmdarg_C] nv-g-cmd [#_window_C win, #_cmdarg_C cap]
    (condp ==? (:nchar cap)
        ;; "gR": Enter virtual replace mode.

        (byte \R)
            (nv-Replace win, (assoc cap :arg TRUE))

        (byte \r)
            (nv-vreplace win, cap)

        (byte \&)
            [(do-cmdline-cmd win, (u8 "%s//~/&")) cap]

        ;; "gv": Reselect the previous Visual area.
        ;;       If Visual already active, exchange previous and current Visual area.

        (byte \v)
            (let-when [[cap ?] (checkclearop? cap)] (not ?) => [win cap]
                (let [vi (:b_visual @curbuf) lmax (line-count @curbuf)]
                    (cond (or (zero? (:lnum (:vi_start vi))) (< lmax (:lnum (:vi_start vi))) (zero? (:lnum (:vi_end vi))))
                        [(beep-flush win) cap]
                    :else
                        (let [[win tpos] ;; Set "w_cursor" to the start of the Visual area, "tpos" to the end.
                                (cond @VIsual_active
                                    (let [? @VIsual_mode
                                          _ (reset! VIsual_mode (:vi_mode (:b_visual @curbuf)))
                                          _ (swap! curbuf assoc-in [:b_visual :vi_mode] ?)
                                          ? (:w_curswant win)
                                          win (assoc win :w_curswant (:vi_curswant (:b_visual @curbuf)))
                                          _ (swap! curbuf assoc-in [:b_visual :vi_curswant] ?)
                                          tpos (:vi_end (:b_visual @curbuf))
                                          _ (swap! curbuf assoc-in [:b_visual :vi_end] (:w_cursor win))
                                          win (assoc win :w_cursor (:vi_start (:b_visual @curbuf)))
                                          _ (swap! curbuf assoc-in [:b_visual :vi_start] @VIsual_cursor)]
                                        [win tpos])
                                :else
                                    (let [_ (reset! VIsual_mode (:vi_mode (:b_visual @curbuf)))
                                          win (assoc win :w_curswant (:vi_curswant (:b_visual @curbuf)))
                                          tpos (:vi_end (:b_visual @curbuf))
                                          win (assoc win :w_cursor (:vi_start (:b_visual @curbuf)))]
                                        [win tpos])
                                )]
                            (reset! VIsual_active true)
                            (reset! VIsual_reselect true)
                            ;; Set "VIsual_cursor" to the start and "w_cursor" to the end of the Visual area.
                            ;; Make sure they are on an existing character.
                            (let [win (check-cursor win)
                                  _ (reset! VIsual_cursor (:w_cursor win))
                                  win (assoc win :w_cursor tpos)
                                  win (check-cursor win)
                                  win (update-topline win)]
                                ;; Normal "g" command: start Select mode when 'selectmode' contains "cmd".
                                ;; K_SELECT: always start Select mode.
                                (if (non-zero? (:arg cap))
                                    (reset! VIsual_select true)
                                    (may-start-select (byte \c)))
                                (redraw-curbuf-later INVERTED)
                                [(showmode win) cap]
                            ))
                    )))

        ;; "gV": Don't reselect the previous Visual area after a Select mode mapping of menu.

        (byte \V)
            (do (reset! VIsual_reselect false) [win cap])

        ;; "gh":  start Select mode.
        ;; "gH":  start Select line mode.
        ;; "g^H": start Select block mode.

       [K_BS (byte \h) (byte \H) Ctrl_H]
            (let [cap (if (== (:nchar cap) K_BS) (assoc cap :nchar Ctrl_H) cap)
                  cap (assoc cap :cmdchar (+ (:nchar cap) (- (byte \v) (byte \h))) :arg TRUE)]
                (nv-visual win, cap))

        ;; "gn", "gN" visually select next/previous search match
        ;; "gn" selects next match
        ;; "gN" selects previous match

       [(byte \N) (byte \n)]
            (let [[win ?] (current-search? win, (:count1 cap), (== (:nchar cap) (byte \n)))]
                [win (if (not ?) (clearopbeep cap) cap)])

        ;; "gj" and "gk" two new funny movement keys -- up and down movement based on *screen* line rather than *file* line.

       [(byte \j) K_DOWN]
            (let [[win cap ?] ;; with 'nowrap' it works just like the normal "j" command
                    (if (not @(:wo_wrap (:w_options win)))
                        (let [cap (update cap :oap assoc :motion_type MLINE)
                              [win ?] (cursor-down? win, (:count1 cap), (== (:op_type (:oap cap)) OP_NOP))]
                            [win cap ?])
                        (nv-screengo win, cap, FORWARD, (:count1 cap))
                    )]
                [win (if (not ?) (clearopbeep cap) cap)])

       [(byte \k) K_UP]
            (let [[win cap ?] ;; with 'nowrap' it works just like the normal "k" command
                    (if (not @(:wo_wrap (:w_options win)))
                        (let [cap (update cap :oap assoc :motion_type MLINE)
                              [win ?] (cursor-up? win, (:count1 cap), (== (:op_type (:oap cap)) OP_NOP))]
                            [win cap ?])
                        (nv-screengo win, cap, BACKWARD, (:count1 cap))
                    )]
                [win (if (not ?) (clearopbeep cap) cap)])

        ;; "gJ": join two lines without inserting a space.

        (byte \J)
            (nv-join win, cap)

        ;; "g0", "g^" and "g$": Like "0", "^" and "$" but for screen lines.
        ;; "gm": middle of "g0" and "g$".

       [(byte \0) (byte \^) (byte \m) K_HOME K_KHOME]
            (let [cap (update cap :oap assoc :motion_type MCHAR :inclusive false)
                  wrap? @(:wo_wrap (:w_options win))
                  [win i]
                    (if (and wrap? (non-zero? (:w_width win)))
                        (let [width1 (- (:w_width win) (win-col-off win)) width2 (+ width1 (win-col-off2 win))
                              win (validate-virtcol win)]
                            [win (if (and (<= width1 (:w_virtcol win)) (< 0 width2)) (+ (* (/ (- (:w_virtcol win) width1) width2) width2) width1) 0)])
                        [win (:w_leftcol win)])
                  ;; Go to the middle of the screen line.
                  ;; When 'number' or 'relativenumber' is on and lines are wrapping, the middle can be more to the left.
                  i (if (== (:nchar cap) (byte \m)) (+ i (/ (+ (- (:w_width win) (win-col-off win)) (if (and wrap? (< 0 i)) (win-col-off2 win) 0)) 2)) i)
                  win (coladvance win, i)
                  win (if (== (:nchar cap) (byte \^))
                        (loop-when win (vim-iswhite (gchar-cursor win)) => win
                            (let [[win ?] (oneright? win)] (recur-if ? win => win)))
                        win
                    )]
                [(assoc win :w_set_curswant true) cap])

        ;; "g_": to the last non-blank character in the line or <count> lines downward.

        (byte \_)
            (let [cap (update cap :oap assoc :motion_type MCHAR :inclusive true)
                  win (assoc win :w_curswant MAXCOL)
                  [win ?] (cursor-down? win, (dec (:count1 cap)), (== (:op_type (:oap cap)) OP_NOP))]
                (if (not ?)
                    [win (clearopbeep cap)]
                    (let [s (ml-get (:lnum (:w_cursor win))) i (:col (:w_cursor win))
                          ;; In Visual mode we may end up after the line.
                          i (if (and (< 0 i) (eos? s i)) (dec i) i)
                          ;; Decrease the cursor column until it's on a non-blank.
                          win (loop-when-recur i (and (< 0 i) (vim-iswhite (.at s i))) (dec i) => (assoc-in win [:w_cursor :col] i))
                          win (assoc win :w_set_curswant true)]
                        (adjust-for-sel win, cap))
                ))

       [(byte \$) K_END K_KEND]
            (let [cap (update cap :oap assoc :motion_type MCHAR :inclusive true)
                  wrap? @(:wo_wrap (:w_options win)) off (win-col-off win)]
                (if (and wrap? (non-zero? (:w_width win)))
                    (let [win (assoc win :w_curswant MAXCOL)] ;; so we stay at the end
                        (cond (== (:count1 cap) 1)
                            (let [width1 (- (:w_width win) off) width2 (+ width1 (win-col-off2 win))
                                  win (validate-virtcol win)
                                  i (+ (dec width1) (if (<= width1 (:w_virtcol win)) (* (inc (/ (- (:w_virtcol win) width1) width2)) width2) 0))
                                  win (coladvance win, i)
                                  ;; Make sure we stick in this column.
                                  win (validate-virtcol win)
                                  win (assoc win :w_curswant (:w_virtcol win) :w_set_curswant false)
                                  ;; Check for landing on a character that got split at the end of the line.
                                  ;; We do not want to advance to the next screen line.
                                  win (if (and (< 0 (:col (:w_cursor win))) wrap? (< i (:w_virtcol win)))
                                        (update-in win [:w_cursor :col] dec)
                                        win
                                    )]
                                [win cap])
                        :else
                            (let [[win cap ?] (nv-screengo win, cap, FORWARD, (dec (:count1 cap)))]
                                [win (if (not ?) (clearopbeep cap) cap)])
                        ))
                    (let [i (dec (- (+ (:w_leftcol win) (:w_width win)) off))
                          win (coladvance win, i)
                          ;; Make sure we stick in this column.
                          win (validate-virtcol win)
                          win (assoc win :w_curswant (:w_virtcol win) :w_set_curswant false)]
                        [win cap])
                ))

        ;; "g*" and "g#", like "*" and "#" but without using "\<" and "\>"

       [(byte \*) (byte \#) (char_u POUND)] ;; pound sign (sometimes equal to '#')
            (nv-ident win, cap)

        ;; ge and gE: go back to end of word

       [(byte \e) (byte \E)]
            (let [cap (update cap :oap assoc :motion_type MCHAR :inclusive true)
                  win (assoc win :w_set_curswant true)
                  [win ?] (bckend-word? win, (:count1 cap), (== (:nchar cap) (byte \E)), false)]
                [win (if (not ?) (clearopbeep cap) cap)])

        ;; "g CTRL-G": display info about cursor position.

        Ctrl_G
            [(cursor-pos-info win) cap]

        ;; "gi": start Insert at the last position.

        (byte \i)
            (let [win (if (non-zero? (:lnum (:b_last_insert @curbuf)))
                        (let [win (assoc win :w_cursor (:b_last_insert @curbuf))
                              win (check-cursor-lnum win)
                              i (STRLEN (ml-get (:lnum (:w_cursor win)))) j (- (:col (:w_cursor win)) i)]
                            (if (< 0 j)
                                (let [win (if (virtual-active) (update-in win [:w_cursor :coladd] + j) win)]
                                    (assoc-in win [:w_cursor :col] i))
                                win
                            ))
                        win
                    )]
                (nv-edit win, (assoc cap :cmdchar (byte \i))))

        ;; "gI": Start insert in column 1.

        (byte \I)
            (let [win (beginline win, 0) [cap ?] (checkclearopq? cap)]
                (if (not ?) (invoke-edit win, cap, false, (byte \g), false) [win cap]))

        ;; "g'm" and "g`m": jump to mark without setting pcmark.

        (byte \')
            (nv-gomark win, (assoc cap :arg TRUE))

        (byte \`)
            (nv-gomark win, cap)

        ;; "gs": Goto sleep.

        (byte \s)
            (do (do-sleep (* (:count1 cap) 1000)) [win cap])

        ;; "ga": Display the ascii value of the character under the cursor.
        ;;       It is displayed in decimal, hex, and octal.

        (byte \a)
            [(do-ascii win) cap]

        ;; "g8": Display the bytes used for the UTF-8 character under the cursor.
        ;;       It is displayed in hex.
        ;; "8g8" finds illegal byte sequence.

        (byte \8)
            [(if (== (:count0 cap) 8) (utf-find-illegal win) (show-utf8 win)) cap]

        ;; "gg": Goto the first line in file.
        ;;       With a count it goes to that line number like for "G".

        (byte \g)
            (nv-goto win, (assoc cap :arg FALSE))

        ;; Two-character operators:
        ;;  "gq"    Format text.
        ;;  "gw"    Format text and keep cursor position.
        ;;  "g~"    Toggle the case of the text.
        ;;  "gu"    Change text to lower case.
        ;;  "gU"    Change text to upper case.
        ;;  "g?"    rot13 encoding
        ;;  "g@"    call 'operatorfunc'

       [(byte \q) (byte \w)]
            (let [cap (assoc-in cap [:oap :cursor_start] (:w_cursor win))]
                (nv-operator win, cap))

       [(byte \~) (byte \u) (byte \U) (byte \?) (byte \@)]
            (nv-operator win, cap)

        ;; "gP" and "gp": same as "P" and "p" but leave cursor just after new text.

       [(byte \p) (byte \P)]
            (nv-put win, cap)

        (byte \,)
            (nv-pcmark win, cap)

        (byte \;)
            (nv-pcmark win, (update cap :count1 -))

        ;; "g+" and "g-": undo or redo along the timeline.

       [(byte \+) (byte \-)]
            (let [[cap ?] (checkclearopq? cap)
                  win (when' (not ?) => win
                        (undo-time win, (if (== (:nchar cap) (byte \-)) (- (:count1 cap)) (:count1 cap)), false, false)
                    )]
                [win cap])

        K_IGNORE
            [win cap]

        [win (clearopbeep cap)]
    ))

;; Handle "o" and "O" commands.

(defn- #_[window_C cmdarg_C] n-opencmd [#_window_C win, #_cmdarg_C cap]
    (let-when [[cap ?] (checkclearopq? cap)] (not ?) => [win cap]
        (let-when [lnum (:lnum (:w_cursor win)) back (== (:cmdchar cap) (byte \O)) fore (== (:cmdchar cap) (byte \o))
              [win ?]
                (if (u-save win, (- lnum (if back 1 0)), (+ lnum (if fore 1 0)))
                    (open-line? win, (if back BACKWARD FORWARD), 0, 0)
                    [win false]
                )] ? => [win cap]

            ;; When '#' is in 'cpoptions', ignore the count.
            (let [cap (if (some? (vim-strbyte @p_cpo, CPO_HASH)) (assoc cap :count1 1) cap)]
                (invoke-edit win, cap, false, (:cmdchar cap), true)
            ))
    ))

;; "." command: redo last change.

(defn- #_[window_C cmdarg_C] nv-dot [#_window_C win, #_cmdarg_C cap]
    (let-when [[cap ?] (checkclearopq? cap)] (not ?) => [win cap]
        ;; If "restart_edit" is true, the last but one command is repeated instead of the last command (inserting text).
        ;; This is used for CTRL-O <.> in Insert mode.
        (let [? (start-redo win, (:count0 cap), (and (non-zero? @restart_edit) (not @arrow_used)))]
            [win (if (not ?) (clearopbeep cap) cap)])
    ))

;; CTRL-R: undo undo

(defn- #_[window_C cmdarg_C] nv-redo [#_window_C win, #_cmdarg_C cap]
    (let-when [[cap ?] (checkclearopq? cap)] (not ?) => [win cap]
        (let [win (u-redo win, (:count1 cap))]
            [(assoc win :w_set_curswant true) cap])
    ))

;; Handle "U" command.

(defn- #_[window_C cmdarg_C] nv-Undo [#_window_C win, #_cmdarg_C cap]
    ;; In Visual mode and typing "gUU" triggers an operator.
    (cond (or (== (:op_type (:oap cap)) OP_UPPER) @VIsual_active)
        (nv-operator win, (assoc cap :cmdchar (byte \g) :nchar (byte \U))) ;; translate "gUU" to "gUgU"
    :else
        (let-when [[cap ?] (checkclearopq? cap)] (not ?) => [win cap]
            [(-> win (u-undoline) (assoc :w_set_curswant true)) cap])
    ))

;; '~' command: If tilde is not an operator and Visual is off: swap case of a single character.

(defn- #_[window_C cmdarg_C] nv-tilde [#_window_C win, #_cmdarg_C cap]
    (if (or @p_to @VIsual_active (== (:op_type (:oap cap)) OP_TILDE)) (nv-operator win, cap) (n-swapchar win, cap)))

;; Handle an operator command.
;; The actual work is done by do-pending-operator().

(defn- #_[window_C cmdarg_C] nv-operator [#_window_C win, #_cmdarg_C cap]
    (let [#_int op_type (get-op-type (:cmdchar cap), (:nchar cap))]
        (cond (== op_type (:op_type (:oap cap))) ;; double operator works on lines
            (nv-lineop win, cap)
        :else
            (let-when [[cap ?] (checkclearop? cap)] (not ?) => [win cap]
                [win (update cap :oap assoc :op_start (:w_cursor win) :op_type op_type)]
            ))
    ))

;; Handle linewise operator "dd", "yy", etc.
;;
;; "_" is is a strange motion command that helps make operators more logical.
;; It is actually implemented, but not documented in the real Vi.  This motion
;; command actually refers to "the current line".  Commands like "dd" and "yy"
;; are really an alternate form of "d_" and "y_".  It does accept a count, so
;; "d3_" works to delete 3 lines.

(defn- #_[window_C cmdarg_C] nv-lineop [#_window_C win, #_cmdarg_C cap]
    (let [cap (update cap :oap assoc :motion_type MLINE) motion_force (:motion_force (:oap cap)) op_type (:op_type (:oap cap))
          [win ?] (cursor-down? win, (dec (:count1 cap)), (== op_type OP_NOP))]
        (cond (not ?)
            [win (clearopbeep cap)]
        ;; only with linewise motions
        (or (and (== op_type OP_DELETE) (!= motion_force (byte \v)) (!= motion_force Ctrl_V)) (== op_type OP_LSHIFT) (== op_type OP_RSHIFT))
            [(beginline win, (| BL_SOL BL_FIX)) cap]
        (!= op_type OP_YANK) ;; 'Y' does not move cursor
            [(beginline win, (| BL_WHITE BL_FIX)) cap]
        :else
            [win cap]
        )
    ))

;; <Home> command.

(defn- #_[window_C cmdarg_C] nv-home [#_window_C win, #_cmdarg_C cap]
    ;; CTRL-HOME is like "gg"
    (let [[win cap] (if (flag? @mod_mask MOD_MASK_CTRL) (nv-goto win, cap) (nv-pipe win, (assoc cap :count0 1)))]
        (reset! ins_at_eol false) ;; don't move cursor past eol (only necessary in a one-character line)
        [win cap]
    ))

;; "|" command.

(defn- #_[window_C cmdarg_C] nv-pipe [#_window_C win, #_cmdarg_C cap]
    (let [cap (update cap :oap assoc :motion_type MCHAR :inclusive false) col (max 0 (dec (:count0 cap)))
          win (-> win (beginline 0) (coladvance col))]
        ;; Keep curswant at the column where we wanted to go,
        ;; not where we ended; differs if line is too short.
        [(assoc win :w_curswant col, :w_set_curswant false) cap]
    ))

;; Handle back-word command "b" and "B".
;; cap.arg is 1 for "B"

(defn- #_[window_C cmdarg_C] nv-bck-word [#_window_C win, #_cmdarg_C cap]
    (let [cap (update cap :oap assoc :motion_type MCHAR :inclusive false) win (assoc win :w_set_curswant true)
          [win ?] (bck-word? win, (:count1 cap), (non-zero? (:arg cap)), false)]
        [win (if (not ?) (clearopbeep cap) cap)]
    ))

;; Handle word motion commands "e", "E", "w" and "W".
;; cap.arg is TRUE for "E" and "W".

(defn- #_[window_C cmdarg_C] nv-wordcmd [#_window_C win, #_cmdarg_C cap]
    (let-when [end? (any == (:cmdchar cap) (byte \e) (byte \E))
          ;; set inclusive for the "E" and "e" command
          cap (update cap :oap assoc :motion_type MCHAR :inclusive end?)
          ;; "cw" and "cW" are special
          [cap [end? #_boolean flag :as _]]
            (let-when [__ [cap [end? false]]] (and (not end?) (== (:op_type (:oap cap)) OP_CHANGE)) => __
                (let-when [c (gchar-cursor win)] (!= c NUL) => __                   ;; empty line
                    ;; This is a little strange:  To match what the real Vi does,
                    ;; we effectively map 'cw' to 'ce', and 'cW' to 'cE', provided
                    ;; that we are not on a space or a TAB.  This seems impolite
                    ;; at first, but it's really more what we mean when we say 'cw'.
                    ;;
                    ;; Another strangeness:  When standing on the end of a word,
                    ;; "ce" will change until the end of the next word, but "cw" will
                    ;; change only one character!  This is done by setting "flag".
                    (cond (not (vim-iswhite c))
                        [(assoc-in cap [:oap :inclusive] true) [true true]]
                    ;; Reproduce a funny Vi behaviour:  "cw" on a blank only changes
                    ;; one character, not all blanks until the start of the next word.
                    ;; Only do this when the 'w' flag is included in 'cpoptions'.
                    (and (== (:count1 cap) 1) (some? (vim-strbyte @p_cpo, CPO_CW)))
                        [(assoc-in cap [:oap :inclusive] true) nil]
                    :else
                        __
                    ))
            )] (some? _) => [win cap]

        (let [o'cursor (:w_cursor win) win (assoc win :w_set_curswant true)
              [win ?]
                (if end?
                    (end-word? win, (:count1 cap), (non-zero? (:arg cap)), flag, false)
                    (fwd-word? win, (:count1 cap), (non-zero? (:arg cap)), (!= (:op_type (:oap cap)) OP_NOP)))
              ;; Don't leave the cursor on the NUL past the end of line.
              ;; Unless we didn't move it forward.
              [win cap] (if (ltpos o'cursor, (:w_cursor win)) (adjust-cursor win, cap) [win cap])]
            (if (and (not ?) (== (:op_type (:oap cap)) OP_NOP))
                [win (clearopbeep cap)]
                (adjust-for-sel win, cap)
            ))
    ))

;; Used after a movement command: if the cursor ends up on the NUL after the end of the line,
;; may move it back to the last character and make the motion inclusive.

(defn- #_[window_C cmdarg_C] adjust-cursor [#_window_C win, #_cmdarg_C cap]
    ;; The cursor cannot remain on the NUL when: the column is > 0; not in Visual mode or 'selection' is "o"; 'virtualedit' is not "all" and not "onemore".
    (if (and (< 0 (:col (:w_cursor win))) (== (gchar-cursor win) NUL) (or (not @VIsual_active) (at? @p_sel (byte \o))) (not (virtual-active)) (non-flag? @ve_flags VE_ONEMORE))
        [(-> win (update-in [:w_cursor :col] dec) (update :w_cursor mb-adjust-pos)) (assoc-in cap [:oap :inclusive] true)]
        [win cap]
    ))

;; "0" and "^" commands.
;; cap.arg is the argument for beginline().

(defn- #_[window_C cmdarg_C] nv-beginline [#_window_C win, #_cmdarg_C cap]
    (let [cap (update cap :oap assoc :motion_type MCHAR :inclusive false)
          win (beginline win, (:arg cap))]
        (reset! ins_at_eol false) ;; don't move cursor past eol (only necessary in a one-character line)
        [win cap]
    ))

;; In exclusive Visual mode, may include the last character.

(defn- #_[window_C cmdarg_C] adjust-for-sel [#_window_C win, #_cmdarg_C cap]
    (if (and @VIsual_active (:inclusive (:oap cap)) (at? @p_sel (byte \e)) (!= (gchar-cursor win) NUL) (ltpos @VIsual_cursor, (:w_cursor win)))
        [(inc-cursor win, false) (assoc-in cap [:oap :inclusive] false)]
        [win cap]
    ))

;; Exclude last character at end of Visual area for 'selection' is "exclusive".
;; Should check VIsual_mode before calling this.
;; Returns true when backed up to the previous line.

(defn- #_[window_C boolean] unadjust-for-sel? [#_window_C win]
    (let [ufs- (fn [#_pos_C p]
                    (cond
                        (< 0 (:coladd p)) [(update p :coladd dec) false]
                        (< 0 (:col p))    [(let [p (update p :col dec)] (mb-adjust-pos p)) false]
                        (< 1 (:lnum p))   [(let [p (update p :lnum dec)] (assoc p :col (STRLEN (ml-get (:lnum p))))) true]
                        :else             [p false]
                    ))]
        (if (and (at? @p_sel (byte \e)) (not (eqpos @VIsual_cursor, (:w_cursor win))))
            (if (ltpos @VIsual_cursor, (:w_cursor win))
                (let [[_ ?] (ufs- (:w_cursor win))] [(assoc win :w_cursor _) ?])
                (let [[_ ?] (ufs- @VIsual_cursor)] (reset! @VIsual_cursor _) [win ?])
            )
            [win false]
        )
    ))

;; SELECT key in Normal or Visual mode: end of Select mode mapping.

(defn- #_[window_C cmdarg_C] nv-select [#_window_C win, #_cmdarg_C cap]
    (cond
        @VIsual_active   (do (reset! VIsual_select true) [win cap])
        @VIsual_reselect (nv-g-cmd win, (assoc cap :nchar (byte \v) :arg TRUE)) ;; fake "gv" command
        :else            [win cap]
    ))

;; "G", "gg", CTRL-END, CTRL-HOME.
;; cap.arg is TRUE for "G".

(defn- #_[window_C cmdarg_C] nv-goto [#_window_C win, #_cmdarg_C cap]
    (let [lmax (line-count @curbuf) lnum (if (zero? (:arg cap)) 1 lmax) cap (assoc-in cap [:oap :motion_type] MLINE)
          win (setpcmark win)]
        (let [lnum (if (non-zero? (:count0 cap)) (:count0 cap) lnum) ;; when a count is given, use it instead of the default lnum
              win (assoc-in win [:w_cursor :lnum] (max 1 (min lnum lmax)))]
            [(beginline win, (| BL_SOL BL_FIX)) cap]
        )
    ))

;; CTRL-\ in Normal mode.

(defn- #_[window_C cmdarg_C] nv-normal [#_window_C win, #_cmdarg_C cap]
    (let-when [key (:nchar cap)] (any == key Ctrl_N Ctrl_G) => [win (clearopbeep cap)]
        (when (and (non-zero? @restart_edit) @mode_displayed)
            (reset! clear_cmdline true)) ;; unshow mode later
        (reset! restart_edit 0)
        (when (non-zero? @cmdwin_type)
            (reset! cmdwin_result Ctrl_C))
        (let [win (if @VIsual_active (let [win (end-visual-mode win)] (redraw-curbuf-later INVERTED) win) win)] ;; stop Visual
            ;; CTRL-\ CTRL-G restarts Insert mode when 'insertmode' is set.
            (when (and (== key Ctrl_G) @p_im)
                (reset! restart_edit (byte \a)))
            [win (clearop cap)]
        )
    ))

;; ESC in Normal mode: beep, but don't flush buffers.
;; Don't even beep if we are canceling a command.

(defn- #_[window_C cmdarg_C] nv-esc [#_window_C win, #_cmdarg_C cap]
    (let-when [no_reason (and (== (:op_type (:oap cap)) OP_NOP) (== (:opcount cap) 0) (== (:count0 cap) 0) (zero? (:regname (:oap cap))) (not @p_im))
          [win ?]
            (if (zero? (:arg cap)) ;; false for CTRL-C
                [win true]
                (let [win (when' (and (zero? @restart_edit) (zero? @cmdwin_type) (not @VIsual_active) no_reason) => win
                            (msg win, (u8 "Type  :quit<Enter>  to exit Vim"))
                        )]
                    (when (not @p_im) ;; don't reset "restart_edit" when 'insertmode' is set
                        (reset! restart_edit 0))
                    [win (or (zero? @cmdwin_type) (do (reset! cmdwin_result K_IGNORE) (reset! got_int false) false))]
                ))
    ] ? => [win cap]

        (let [win (if @VIsual_active ;; stop Visual ;; make sure cursor is not beyond EOL
                    (let [win (-> win (end-visual-mode) (check-cursor-col) (assoc :w_set_curswant true))]
                        (redraw-curbuf-later INVERTED)
                        win)
                    (do (when no_reason (beep)) win)
                )]
            ;; When 'insertmode' is set, return to Insert mode afterwards.
            (when (and (zero? @restart_edit) (goto-im))
                (reset! restart_edit (byte \a)))
            [win (clearop cap)]
        )
    ))

;; Handle "A", "a", "I", "i" and <Insert> commands.

(defn- #_[window_C cmdarg_C] nv-edit [#_window_C win, #_cmdarg_C cap]
    (let [cap (if (any == (:cmdchar cap) K_INS K_KINS) (assoc cap :cmdchar (byte \i)) cap)] ;; <Insert> is equal to "i"
        ;; in Visual mode "A" and "I" are an operator
        (cond (and @VIsual_active (any == (:cmdchar cap) (byte \A) (byte \I)))
            (v-visop win, cap)
        ;; in Visual mode and after an operator "a" and "i" are for text objects
        (and (any == (:cmdchar cap) (byte \a) (byte \i)) (or (!= (:op_type (:oap cap)) OP_NOP) @VIsual_active))
            (nv-object win, cap)
        :else
            (let-when [[cap ?] (checkclearopq? cap)] (not ?) => [win cap]
                ;; Pretend Insert mode here to allow the cursor on the character past the end of the line.
                (let [cola- (fn [win i] (let [o'State @State _ (reset! State INSERT) win (coladvance win, i) _ (reset! State o'State)] win))
                      curl (ml-get-cursor win)
                      win (condp == (:cmdchar cap)
                            (byte \A) ;; "A"ppend after the line
                                (let [win (assoc win :w_set_curswant true)]
                                    (if (== @ve_flags VE_ALL)
                                        (cola- win, MAXCOL)
                                        (update-in win [:w_cursor :col] + (STRLEN curl))
                                    ))
                            (byte \I) ;; "I"nsert before the first non-blank
                                (beginline win, (if (nil? (vim-strbyte @p_cpo, CPO_INSEND)) BL_WHITE (| BL_WHITE BL_FIX)))
                            (byte \a) ;; "a"ppend is like "i"nsert on the next character
                                ;; Increment "coladd" when in virtual space, increment the column otherwise, also to append after an unprintable char.
                                (cond (and (virtual-active) (or (< 0 (:coladd (:w_cursor win))) (eos? curl) (at? curl TAB)))
                                    (update-in win [:w_cursor :coladd] inc)
                                (non-eos? curl)
                                    (inc-cursor win, false)
                                :else
                                    win
                                ))
                      win (if (and (non-zero? (:coladd (:w_cursor win))) (!= (:cmdchar cap) (byte \A)))
                            (cola- win, (getviscol win))
                            win
                        )]
                    (invoke-edit win, cap, false, (:cmdchar cap), false))
            ))
    ))

;; Invoke edit() and take care of "restart_edit" and the return value.

(defn- #_[window_C cmdarg_C] invoke-edit [#_window_C win, #_cmdarg_C cap, #_boolean repl, #_int cmd, #_boolean startln]
    ;; repl: "r" or "gr" command
    (let [o'restart_edit (if (or repl (not (stuff-empty))) @restart_edit 0)]
        ;; Complicated: when the user types "a<C-O>a", we don't want to do Insert mode recursively.
        ;; But when doing "a<C-O>." or "a<C-O>rx", we do allow it.

        ;; Always reset "restart_edit", this is not a restarted edit.
        (reset! restart_edit 0)
        (let [[win ?] (edit? win, cmd, startln, (:count1 cap)) cap (if ? (update cap :retval | CA_COMMAND_BUSY) cap)]
            (when (zero? @restart_edit)
                (reset! restart_edit o'restart_edit))
            [win cap]
        )
    ))

;; "a" or "i" while an operator is pending or in Visual mode: object motion.

(defn- #_[window_C cmdarg_C] nv-object [#_window_C win, #_cmdarg_C cap]
    ;; make sure (), [], {} and <> are in 'matchpairs'
    (let [o'mps @(:b_p_mps @curbuf) _ (reset! (:b_p_mps @curbuf) (u8 "(:),{:},[:],<:>"))
          ;; "ax" = an object: include white space ;; "ix" = inner object: exclude white space
          ws? (!= (:cmdchar cap) (byte \i))
          [win cap ?]
            (condp ==? (:nchar cap)
                (byte \w)                                                                   ;; "aw" = a word
                    (current-word? win, cap, (:count1 cap), ws?, false)
                (byte \W)                                                                   ;; "aW" = a WORD
                    (current-word? win, cap, (:count1 cap), ws?, true)
               [(byte \b) (byte \() (byte \))]                                              ;; "ab" = a braces block
                    (current-block? win, cap, (:count1 cap), ws?, (byte \(), (byte \)))
               [(byte \B) (byte \{) (byte \})]                                              ;; "aB" = a Brackets block
                    (current-block? win, cap, (:count1 cap), ws?, (byte \{), (byte \}))
               [(byte \[) (byte \])]                                                        ;; "a[" = a [] block
                    (current-block? win, cap, (:count1 cap), ws?, (byte \[), (byte \]))
               [(byte \<) (byte \>)]                                                        ;; "a<" = a <> block
                    (current-block? win, cap, (:count1 cap), ws?, (byte \<), (byte \>))
               ;; "a"" = a double quoted string ;; "a'" = a single quoted string ;; "a`" = a backtick quoted string
               [(byte \") (byte \') (byte \`)] ;; """
                    (current-quote? win, cap, (:count1 cap), ws?, (:nchar cap))
                [win cap false]
            )]
        (reset! (:b_p_mps @curbuf) o'mps)
        [(-> win (adjust-cursor-col) (assoc :w_set_curswant true)) (if (not ?) (clearopbeep cap) cap)]
    ))

;; "q" command: Start/stop recording.
;; "q:", "q/", "q?": edit command-line in command-line window.

(defn- #_[window_C cmdarg_C] nv-record [#_window_C win, #_cmdarg_C cap]
    (cond (== (:op_type (:oap cap)) OP_FORMAT)
        (nv-operator win, (assoc cap :cmdchar (byte \g) :nchar (byte \q))) ;; "gqq" is the same as "gqgq": format line
    :else
        (let-when [[cap ?] (checkclearop? cap)] (not ?) => [win cap]
            (let [nchar (:nchar cap)]
                (cond (any == nchar (byte \:) (byte \/) (byte \?))
                    (do (stuff-char nchar) (stuff-char K_CMDWIN) [win cap])
                :else ;; (stop) recording into a named register, unless executing a register
                    (let-when [[win ?] (if (not @exec_reg) (do-record? win, nchar) [win true])] (not ?) => [win cap]
                        [win (clearopbeep cap)]
                    ))
            ))
    ))

;; Handle the "@r" command.

(defn- #_[window_C cmdarg_C] nv-at [#_window_C win, #_cmdarg_C cap]
    (let-when [[cap ?] (checkclearop? cap)] (not ?) => [win cap]
        (let [[win ?] (if (== (:nchar cap) (byte \=)) (let [[win ?] (get-expr-register? win)] [win (== ? NUL)]) [win false])]
            (when' (not ?) => [win cap]
                (loop-when [win win cap cap] (and (< 0 (:count1 cap)) (not @got_int)) => [win cap]
                    (let [[win ?] (do-execreg? win, (:nchar cap))]
                        (if ?
                            (do (slow-breakcheck) (recur win (update cap :count1 dec)))
                            [win (clearopbeep cap)]
                        )))
            ))
    ))

;; Handle the CTRL-U and CTRL-D commands.

(defn- #_[window_C cmdarg_C] nv-halfpage [#_window_C win, #_cmdarg_C cap]
    (let [key (:cmdchar cap) lnum (:lnum (:w_cursor win)) lmax (line-count @curbuf)]
        (cond (or (and (== key Ctrl_U) (== lnum 1)) (and (== key Ctrl_D) (== lnum lmax)))
            [win (clearopbeep cap)]
        :else
            (let-when [[cap ?] (checkclearop? cap)] (not ?) => [win cap]
                [(halfpage win, (== key Ctrl_D), (:count0 cap)) cap]
            ))
    ))

;; Handle "J" or "gJ" command.

(defn- #_[window_C cmdarg_C] nv-join [#_window_C win, #_cmdarg_C cap]
    (cond @VIsual_active ;; join the visual lines
        (nv-operator win, cap)
    :else
        (let-when [[cap ?] (checkclearop? cap)] (not ?) => [win cap]
            (let [cap (update cap :count0 max 2)] ;; default for join is two lines!
                (if (<= (dec (+ (:lnum (:w_cursor win)) (:count0 cap))) (line-count @curbuf))
                    (do (prep-redo (:regname (:oap cap)), (:count0 cap), NUL, (:cmdchar cap), NUL, NUL, (:nchar cap))
                        [(do-join win, (:count0 cap), (== (:nchar cap) NUL), true, true) cap])
                    [win (clearopbeep cap)] ;; beyond last line
                )
            )
        )
    ))

;; "P", "gP", "p" and "gp" commands.

(defn- #_[window_C cmdarg_C] nv-put [#_window_C win, #_cmdarg_C cap]
    (if (!= (:op_type (:oap cap)) OP_NOP)
        [win (clearopbeep cap)]
        (let [visual? @VIsual_active]
            (prep-redo-cmd cap)
            (let [#_int dir (if (or (== (:cmdchar cap) (byte \P)) (and (== (:cmdchar cap) (byte \g)) (== (:nchar cap) (byte \P)))) BACKWARD FORWARD)
                  #_int flags (if (== (:cmdchar cap) (byte \g)) PUT_CURSEND 0)
                  [win cap dir flags #_int regname #_yankreg_C reg2]
                    (if visual?
                        ;; Putting in Visual mode: The put text replaces the selected text.
                        ;; First delete the selected text, then put the new text.
                        ;; Need to save and restore the registers that the delete overwrites if the old contents is being put.
                        (let [regname (adjust-clip-reg (:regname (:oap cap)))
                              ;; The delete is going to overwrite the register we want to put, save it first.
                              #_yankreg_C reg1 (when (or (zero? regname) (== regname (byte \")) (asc-isdigit regname) (== regname (byte \-)))  ;; """
                                    (get-register regname, true))
                              ;; Now delete the selected text.
                              cap (-> cap (assoc-in [:oap :regname] NUL) (assoc :cmdchar (byte \d) :nchar NUL))
                              [win cap] (nv-operator win, cap)
                              [win cap] (do-pending-operator win, cap, 0)
                              cap (assoc-in cap [:oap :regname] regname)
                              ;; Delete probably changed the register we want to put, save it first.
                              ;; Then put back what was there before the delete.
                              reg2 (when (some? reg1) (let [_ (get-register regname, false)] (put-register regname, reg1) _))
                              ;; When deleted a linewise Visual area, put the register as lines to avoid it joined with the next line.
                              ;; When deletion was characterwise, split a line when putting lines.
                              mode @VIsual_mode
                              flags (| flags (cond (== mode (byte \V)) PUT_LINE (== mode (byte \v)) PUT_LINE_SPLIT :else 0)
                                             (if (and (== mode Ctrl_V) (== dir FORWARD)) PUT_LINE_FORWARD 0))
                              dir (if (or (and (!= mode (byte \V)) (< (:col (:w_cursor win)) (:col (:b_op_start @curbuf))))
                                          (and (== mode (byte \V)) (< (:lnum (:w_cursor win)) (:lnum (:b_op_start @curbuf)))))
                                    FORWARD ;; cursor is at the end of the line or end of file, put forward
                                    BACKWARD)]
                            (reset! VIsual_active true) ;; may have been reset in do-put()
                            [win cap dir flags regname reg2])
                        [win cap dir flags 0 nil])
                  empty? (:ml_empty (:b_ml @curbuf))
                  win (do-put win, (:regname (:oap cap)), dir, (:count1 cap), flags)]
                ;; If a register was saved, put it back now.
                (when (some? reg2)
                    (put-register regname, reg2))
                ;; What to reselect with "gv"?
                ;; Selecting the just put text seems to be the most useful, since the original was removed.
                (when visual?
                    (swap! curbuf update :b_visual assoc :vi_start (:b_op_start @curbuf) :vi_end (:b_op_end @curbuf)))
                ;; When all lines were selected and deleted do-put() leaves an empty line that needs to be deleted now.
                (let-when [lmax (line-count @curbuf)] (and empty? (eos? (ml-get lmax))) => [win cap]
                    (ml-delete lmax, true)
                    ;; If the cursor was in that line, move it to the end of the last line.
                    (let-when [lmax (line-count @curbuf)] (< lmax (:lnum (:w_cursor win))) => [win cap]
                        [(-> win (assoc-in [:w_cursor :lnum] lmax) (coladvance MAXCOL)) cap]
                    ))
            ))
    ))

;; "o" and "O" commands.

(defn- #_[window_C cmdarg_C] nv-open [#_window_C win, #_cmdarg_C cap]
    (if @VIsual_active
        [(v-swap-corners win, (:cmdchar cap)) cap] ;; switch start and end of visual
        (n-opencmd win, cap)))

(defn- #_[window_C cmdarg_C] nv-drop [#_window_C win, #_cmdarg_C cap]
    [(do-put win, (byte \~), BACKWARD, 1, PUT_CURSEND) cap])

;; Trigger CursorHold event.
;; When waiting for a character for 'updatetime' K_CURSORHOLD is put in the input buffer.
;; "did_cursorhold" is set to avoid retriggering.

(defn- #_[window_C cmdarg_C] nv-cursorhold [#_window_C win, #_cmdarg_C cap]
    (reset! did_cursorhold true)
    [win (update cap :retval | CA_COMMAND_BUSY)]) ;; don't call edit() now

;; This table contains one entry for every Normal or Visual mode command.
;; The order doesn't matter, init_normal_cmds() will create a sorted index.
;; It is faster when all keys from zero to '~' are present.

(final nv_cmd_C* nv_cmds
    [
        (nv_cmd_C. NUL,            nv-error,       0,                      0               ),
        (nv_cmd_C. Ctrl_A,         nv-addsub,      0,                      0               ),
        (nv_cmd_C. Ctrl_B,         nv-page,        NV_STS,                 BACKWARD        ),
        (nv_cmd_C. Ctrl_C,         nv-esc,         0,                      TRUE            ),
        (nv_cmd_C. Ctrl_D,         nv-halfpage,    0,                      0               ),
        (nv_cmd_C. Ctrl_E,         nv-scroll-line, 0,                      TRUE            ),
        (nv_cmd_C. Ctrl_F,         nv-page,        NV_STS,                 FORWARD         ),
        (nv_cmd_C. Ctrl_G,         nv-ctrlg,       0,                      0               ),
        (nv_cmd_C. Ctrl_H,         nv-ctrlh,       0,                      0               ),
        (nv_cmd_C. Ctrl_I,         nv-pcmark,      0,                      0               ),
        (nv_cmd_C. NL,             nv-down,        0,                      FALSE           ),
        (nv_cmd_C. Ctrl_K,         nv-error,       0,                      0               ),
        (nv_cmd_C. Ctrl_L,         nv-clear,       0,                      0               ),
        (nv_cmd_C. Ctrl_M,         nv-down,        0,                      TRUE            ),
        (nv_cmd_C. Ctrl_N,         nv-down,        NV_STS,                 FALSE           ),
        (nv_cmd_C. Ctrl_O,         nv-ctrlo,       0,                      0               ),
        (nv_cmd_C. Ctrl_P,         nv-up,          NV_STS,                 FALSE           ),
        (nv_cmd_C. Ctrl_Q,         nv-visual,      0,                      FALSE           ),
        (nv_cmd_C. Ctrl_R,         nv-redo,        0,                      0               ),
        (nv_cmd_C. Ctrl_S,         nv-ignore,      0,                      0               ),
        (nv_cmd_C. Ctrl_T,         nv-error,       0,                      0               ),
        (nv_cmd_C. Ctrl_U,         nv-halfpage,    0,                      0               ),
        (nv_cmd_C. Ctrl_V,         nv-visual,      0,                      FALSE           ),
        (nv_cmd_C. (int \V),       nv-visual,      0,                      FALSE           ),
        (nv_cmd_C. (int \v),       nv-visual,      0,                      FALSE           ),
        (nv_cmd_C. Ctrl_W,         nv-window,      0,                      0               ),
        (nv_cmd_C. Ctrl_X,         nv-addsub,      0,                      0               ),
        (nv_cmd_C. Ctrl_Y,         nv-scroll-line, 0,                      FALSE           ),
        (nv_cmd_C. Ctrl_Z,         nv-suspend,     0,                      0               ),
        (nv_cmd_C. ESC,            nv-esc,         0,                      FALSE           ),
        (nv_cmd_C. Ctrl_BSL,       nv-normal,      NV_NCH_ALW,             0               ),
        (nv_cmd_C. Ctrl_RSB,       nv-error,       0,                      0               ),
        (nv_cmd_C. Ctrl_HAT,       nv-error,       0,                      0               ),
        (nv_cmd_C. Ctrl__,         nv-error,       0,                      0               ),
        (nv_cmd_C. (int \space),   nv-right,       0,                      0               ),
        (nv_cmd_C. (int \!),       nv-operator,    0,                      0               ),
        (nv_cmd_C. (int \"),       nv-regname,  (| NV_NCH_NOP NV_KEEPREG), 0               ),    ;; """
        (nv_cmd_C. (int \#),       nv-ident,       0,                      0               ),
        (nv_cmd_C. (int \$),       nv-dollar,      0,                      0               ),
        (nv_cmd_C. (int \%),       nv-percent,     0,                      0               ),
        (nv_cmd_C. (int \&),       nv-optrans,     0,                      0               ),
        (nv_cmd_C. (int \'),       nv-gomark,      NV_NCH_ALW,             TRUE            ),
        (nv_cmd_C. (int \(),       nv-error,       0,                      0               ),
        (nv_cmd_C. (int \)),       nv-error,       0,                      0               ),
        (nv_cmd_C. (int \*),       nv-ident,       0,                      0               ),
        (nv_cmd_C. (int \+),       nv-down,        0,                      TRUE            ),
        (nv_cmd_C. (int \,),       nv-csearch,     0,                      TRUE            ),
        (nv_cmd_C. (int \-),       nv-up,          0,                      TRUE            ),
        (nv_cmd_C. (int \.),       nv-dot,         NV_KEEPREG,             0               ),
        (nv_cmd_C. (int \/),       nv-search,      0,                      FALSE           ),
        (nv_cmd_C. (int \0),       nv-beginline,   0,                      0               ),
        (nv_cmd_C. (int \1),       nv-ignore,      0,                      0               ),
        (nv_cmd_C. (int \2),       nv-ignore,      0,                      0               ),
        (nv_cmd_C. (int \3),       nv-ignore,      0,                      0               ),
        (nv_cmd_C. (int \4),       nv-ignore,      0,                      0               ),
        (nv_cmd_C. (int \5),       nv-ignore,      0,                      0               ),
        (nv_cmd_C. (int \6),       nv-ignore,      0,                      0               ),
        (nv_cmd_C. (int \7),       nv-ignore,      0,                      0               ),
        (nv_cmd_C. (int \8),       nv-ignore,      0,                      0               ),
        (nv_cmd_C. (int \9),       nv-ignore,      0,                      0               ),
        (nv_cmd_C. (int \:),       nv-colon,       0,                      0               ),
        (nv_cmd_C. (int \;),       nv-csearch,     0,                      FALSE           ),
        (nv_cmd_C. (int \<),       nv-operator,    NV_RL,                  0               ),
        (nv_cmd_C. (int \=),       nv-operator,    0,                      0               ),
        (nv_cmd_C. (int \>),       nv-operator,    NV_RL,                  0               ),
        (nv_cmd_C. (int \?),       nv-search,      0,                      FALSE           ),
        (nv_cmd_C. (int \@),       nv-at,          NV_NCH_NOP,             FALSE           ),
        (nv_cmd_C. (int \A),       nv-edit,        0,                      0               ),
        (nv_cmd_C. (int \B),       nv-bck-word,    0,                      1               ),
        (nv_cmd_C. (int \C),       nv-abbrev,      NV_KEEPREG,             0               ),
        (nv_cmd_C. (int \D),       nv-abbrev,      NV_KEEPREG,             0               ),
        (nv_cmd_C. (int \E),       nv-wordcmd,     0,                      TRUE            ),
        (nv_cmd_C. (int \F),       nv-csearch,  (| NV_NCH_ALW NV_LANG),    BACKWARD        ),
        (nv_cmd_C. (int \G),       nv-goto,        0,                      TRUE            ),
        (nv_cmd_C. (int \H),       nv-scroll,      0,                      0               ),
        (nv_cmd_C. (int \I),       nv-edit,        0,                      0               ),
        (nv_cmd_C. (int \J),       nv-join,        0,                      0               ),
        (nv_cmd_C. (int \K),       nv-ident,       0,                      0               ),
        (nv_cmd_C. (int \L),       nv-scroll,      0,                      0               ),
        (nv_cmd_C. (int \M),       nv-scroll,      0,                      0               ),
        (nv_cmd_C. (int \N),       nv-next,        0,                      SEARCH_REV      ),
        (nv_cmd_C. (int \O),       nv-open,        0,                      0               ),
        (nv_cmd_C. (int \P),       nv-put,         0,                      0               ),
        (nv_cmd_C. (int \Q),       nv-error,       0,                      0               ),
        (nv_cmd_C. (int \R),       nv-Replace,     0,                      FALSE           ),
        (nv_cmd_C. (int \S),       nv-subst,       NV_KEEPREG,             0               ),
        (nv_cmd_C. (int \T),       nv-csearch,  (| NV_NCH_ALW NV_LANG),    BACKWARD        ),
        (nv_cmd_C. (int \U),       nv-Undo,        0,                      0               ),
        (nv_cmd_C. (int \W),       nv-wordcmd,     0,                      TRUE            ),
        (nv_cmd_C. (int \X),       nv-abbrev,      NV_KEEPREG,             0               ),
        (nv_cmd_C. (int \Y),       nv-abbrev,      NV_KEEPREG,             0               ),
        (nv_cmd_C. (int \Z),       nv-Zet,      (| NV_NCH_NOP NV_NCW),     0               ),
        (nv_cmd_C. (int \[),       nv-brackets,    NV_NCH_ALW,             BACKWARD        ),
        (nv_cmd_C. (int \\),       nv-error,       0,                      0               ),
        (nv_cmd_C. (int \]),       nv-brackets,    NV_NCH_ALW,             FORWARD         ),
        (nv_cmd_C. (int \^),       nv-beginline,   0,                   (| BL_WHITE BL_FIX)),
        (nv_cmd_C. (int \_),       nv-lineop,      0,                      0               ),
        (nv_cmd_C. (int \`),       nv-gomark,      NV_NCH_ALW,             FALSE           ),
        (nv_cmd_C. (int \a),       nv-edit,        NV_NCH,                 0               ),
        (nv_cmd_C. (int \b),       nv-bck-word,    0,                      0               ),
        (nv_cmd_C. (int \c),       nv-operator,    0,                      0               ),
        (nv_cmd_C. (int \d),       nv-operator,    0,                      0               ),
        (nv_cmd_C. (int \e),       nv-wordcmd,     0,                      FALSE           ),
        (nv_cmd_C. (int \f),       nv-csearch,  (| NV_NCH_ALW NV_LANG),    FORWARD         ),
        (nv_cmd_C. (int \g),       nv-g-cmd,       NV_NCH_ALW,             FALSE           ),
        (nv_cmd_C. (int \h),       nv-left,        NV_RL,                  0               ),
        (nv_cmd_C. (int \i),       nv-edit,        NV_NCH,                 0               ),
        (nv_cmd_C. (int \j),       nv-down,        0,                      FALSE           ),
        (nv_cmd_C. (int \k),       nv-up,          0,                      FALSE           ),
        (nv_cmd_C. (int \l),       nv-right,       NV_RL,                  0               ),
        (nv_cmd_C. (int \m),       nv-mark,        NV_NCH_NOP,             0               ),
        (nv_cmd_C. (int \n),       nv-next,        0,                      0               ),
        (nv_cmd_C. (int \o),       nv-open,        0,                      0               ),
        (nv_cmd_C. (int \p),       nv-put,         0,                      0               ),
        (nv_cmd_C. (int \q),       nv-record,      NV_NCH,                 0               ),
        (nv_cmd_C. (int \r),       nv-replace,  (| NV_NCH_NOP NV_LANG),    0               ),
        (nv_cmd_C. (int \s),       nv-subst,       NV_KEEPREG,             0               ),
        (nv_cmd_C. (int \t),       nv-csearch,  (| NV_NCH_ALW NV_LANG),    FORWARD         ),
        (nv_cmd_C. (int \u),       nv-undo,        0,                      0               ),
        (nv_cmd_C. (int \w),       nv-wordcmd,     0,                      FALSE           ),
        (nv_cmd_C. (int \x),       nv-abbrev,      NV_KEEPREG,             0               ),
        (nv_cmd_C. (int \y),       nv-operator,    0,                      0               ),
        (nv_cmd_C. (int \z),       nv-zet,         NV_NCH_ALW,             0               ),
        (nv_cmd_C. (int \{),       nv-error,       0,                      0               ),
        (nv_cmd_C. (int \|),       nv-pipe,        0,                      0               ),
        (nv_cmd_C. (int \}),       nv-error,       0,                      0               ),
        (nv_cmd_C. (int \~),       nv-tilde,       0,                      0               ),

        ;; pound sign
        (nv_cmd_C. (char_u POUND), nv-ident,       0,                      0               ),
        (nv_cmd_C. K_IGNORE,       nv-ignore,      NV_KEEPREG,             0               ),
        (nv_cmd_C. K_NOP,          nv-nop,         0,                      0               ),
        (nv_cmd_C. K_INS,          nv-edit,        0,                      0               ),
        (nv_cmd_C. K_KINS,         nv-edit,        0,                      0               ),
        (nv_cmd_C. K_BS,           nv-ctrlh,       0,                      0               ),
        (nv_cmd_C. K_UP,           nv-up,       (| NV_SSS NV_STS),         FALSE           ),
        (nv_cmd_C. K_S_UP,         nv-page,        NV_SS,                  BACKWARD        ),
        (nv_cmd_C. K_DOWN,         nv-down,     (| NV_SSS NV_STS),         FALSE           ),
        (nv_cmd_C. K_S_DOWN,       nv-page,        NV_SS,                  FORWARD         ),
        (nv_cmd_C. K_LEFT,         nv-left,     (| NV_SSS NV_STS NV_RL),   0               ),
        (nv_cmd_C. K_S_LEFT,       nv-bck-word, (| NV_SS NV_RL),           0               ),
        (nv_cmd_C. K_C_LEFT,       nv-bck-word, (| NV_SSS NV_RL NV_STS),   1               ),
        (nv_cmd_C. K_RIGHT,        nv-right,    (| NV_SSS NV_STS NV_RL),   0               ),
        (nv_cmd_C. K_S_RIGHT,      nv-wordcmd,  (| NV_SS NV_RL),           FALSE           ),
        (nv_cmd_C. K_C_RIGHT,      nv-wordcmd,  (| NV_SSS NV_RL NV_STS),   TRUE            ),
        (nv_cmd_C. K_PAGEUP,       nv-page,     (| NV_SSS NV_STS),         BACKWARD        ),
        (nv_cmd_C. K_KPAGEUP,      nv-page,     (| NV_SSS NV_STS),         BACKWARD        ),
        (nv_cmd_C. K_PAGEDOWN,     nv-page,     (| NV_SSS NV_STS),         FORWARD         ),
        (nv_cmd_C. K_KPAGEDOWN,    nv-page,     (| NV_SSS NV_STS),         FORWARD         ),
        (nv_cmd_C. K_END,          nv-end,      (| NV_SSS NV_STS),         FALSE           ),
        (nv_cmd_C. K_KEND,         nv-end,      (| NV_SSS NV_STS),         FALSE           ),
        (nv_cmd_C. K_S_END,        nv-end,         NV_SS,                  FALSE           ),
        (nv_cmd_C. K_C_END,        nv-end,      (| NV_SSS NV_STS),         TRUE            ),
        (nv_cmd_C. K_HOME,         nv-home,     (| NV_SSS NV_STS),         0               ),
        (nv_cmd_C. K_KHOME,        nv-home,     (| NV_SSS NV_STS),         0               ),
        (nv_cmd_C. K_S_HOME,       nv-home,        NV_SS,                  0               ),
        (nv_cmd_C. K_C_HOME,       nv-goto,     (| NV_SSS NV_STS),         FALSE           ),
        (nv_cmd_C. K_DEL,          nv-abbrev,      0,                      0               ),
        (nv_cmd_C. K_KDEL,         nv-abbrev,      0,                      0               ),
        (nv_cmd_C. K_UNDO,         nv-kundo,       0,                      0               ),
        (nv_cmd_C. K_SELECT,       nv-select,      0,                      0               ),
        (nv_cmd_C. K_DROP,         nv-drop,        NV_STS,                 0               ),
        (nv_cmd_C. K_CURSORHOLD,   nv-cursorhold,  NV_KEEPREG,             0               ),
    ])

;; ops.c: implementation of op-shift, op-delete, op-tilde, op-change, op-yank, do-put and do-join

;; Number of registers.
;;      0 = unnamed register, for normal yanks and puts
;;   1..9 = registers '1' to '9', for deletes
;; 10..35 = registers 'a' to 'z'
;;     36 = delete register '-'
;;     37 = selection register '*'
;;     38 = clipboard register '+'

;; Symbolic names for some registers.

(final int DELETION_REGISTER       36)
(final int STAR_REGISTER           37)
(final int PLUS_REGISTER           STAR_REGISTER)           ;; there is only one
(final int TILDE_REGISTER          (inc PLUS_REGISTER))

(final int NUM_REGISTERS           (inc TILDE_REGISTER))

;; Each yank register is an array of pointers to lines.

(class! #_final yankreg_C
    [
        (field Bytes*       y_array)            ;; pointer to array of line pointers
        (field int          y_size)             ;; number of lines in "y_array"
        (field byte         y_type)             ;; MLINE, MCHAR or MBLOCK
        (field int          y_width)            ;; only set if y_type == MBLOCK
    ])

(defn- #_yankreg_C* ARRAY-yankreg [#_int n]
    (vec (repeatedly n NEW_yankreg_C)))

(atom! yankreg_C*   y_regs    (ARRAY-yankreg NUM_REGISTERS))

(atom! int          y_curr)         ;; index to current yankreg
(atom! boolean      y_append)       ;; true when appending
(atom! int          y_prev)         ;; index to last written yankreg

;; structure used by block-prep, op-delete and op-yank for blockwise operators
;; also op-change, op-shift, op-insert, op-replace

(class! #_final block_def_C
    [
        (field int          startspaces)        ;; 'extra' cols before first char
        (field int          endspaces)          ;; 'extra' cols after last char
        (field int          textlen)            ;; chars in block
        (field Bytes        textstart)          ;; pointer to 1st char (partially) in block
        (field int          textcol)            ;; index of chars (partially) in block
        (field int          start_vcol)         ;; start col of 1st char wholly inside block
        (field int          end_vcol)           ;; start col of 1st char wholly after block
        (field boolean      is_short)           ;; true if line is too short to fit in block
        (field boolean      is_MAX)             ;; true if curswant == MAXCOL when starting
        (field boolean      is_oneChar)         ;; true if block within one character
        (field int          pre_whitesp)        ;; screen cols of ws before block
        (field int          pre_whitesp_c)      ;; chars of ws before block
        (field int          end_char_vcols)     ;; number of vcols of post-block char
        (field int          start_char_vcols)   ;; number of vcols of pre-block char
    ])

;; The names of operators.
;; IMPORTANT: Index must correspond with defines in vim.h!!!
;; The third field indicates whether the operator always works on lines.

(final byte** #_"[/*3*/]" opchars
    [
        [ NUL, NUL, FALSE ],    ;; OP_NOP
        [ \d,  NUL, FALSE ],    ;; OP_DELETE
        [ \y,  NUL, FALSE ],    ;; OP_YANK
        [ \c,  NUL, FALSE ],    ;; OP_CHANGE
        [ \<,  NUL, TRUE  ],    ;; OP_LSHIFT
        [ \>,  NUL, TRUE  ],    ;; OP_RSHIFT
        [ \!,  NUL, TRUE  ],    ;; OP_FILTER
        [ \g,  \~,  FALSE ],    ;; OP_TILDE
        [ \=,  NUL, TRUE  ],    ;; OP_INDENT
        [ \g,  \q,  TRUE  ],    ;; OP_FORMAT
        [ \:,  NUL, TRUE  ],    ;; OP_COLON
        [ \g,  \U,  FALSE ],    ;; OP_UPPER
        [ \g,  \u,  FALSE ],    ;; OP_LOWER
        [ \J,  NUL, TRUE  ],    ;; DO_JOIN
        [ \g,  \J,  TRUE  ],    ;; DO_JOIN_NS
        [ \g,  \?,  FALSE ],    ;; OP_ROT13
        [ \r,  NUL, FALSE ],    ;; OP_REPLACE
        [ \I,  NUL, FALSE ],    ;; OP_INSERT
        [ \A,  NUL, FALSE ],    ;; OP_APPEND
        [ \g,  \w,  TRUE  ],    ;; OP_FORMAT2
        [ \g,  \@,  FALSE ],    ;; OP_FUNCTION
    ])

;; Translate a command name into an operator type.
;; Must only be called with a valid operator name!

(defn- #_int get-op-type [#_int char1, #_int char2]
    (cond
        (== char1 (byte \r))           ;; ignore second character
            OP_REPLACE
        (== char1 (byte \~))           ;; when tilde is an operator
            OP_TILDE
        :else
            (loop-when-recur [#_int i 0] (not (and (== (... (... opchars i) 0) char1) (== (... (... opchars i) 1) char2))) [(inc i)] => i)
    ))

;; Return true if operator "op" always works on whole lines.

(defn- #_boolean op-on-lines [#_int op]
    (!= (... (... opchars op) 2) FALSE))

;; Get first operator command character.
;; Returns 'g' or 'z' if there is another command character.

(defn- #_int get-op-char [#_int optype]
    (... (... opchars optype) 0))

;; Get second operator command character.

(defn- #_int get-extra-op-char [#_int optype]
    (... (... opchars optype) 1))

;; op-shift - handle a shift operation

(defn- #_window_C op-shift [#_window_C win, #_oparg_C oap, #_boolean curs_top, #_int amount]
    (when' (u-save win, (dec (:lnum (:op_start oap))), (inc (:lnum (:op_end oap)))) => win
        (let [#_int block_col (if (:block_mode oap) (:col (:w_cursor win)) 0)
              win (loop-when [win win #_long n (:line_count oap)] (< 0 n) => win
                    (let [win (cond
                                (eos? (ml-get (:lnum (:w_cursor win)))) (assoc-in win [:w_cursor :col] 0)
                                (:block_mode oap)                       (shift-block win, oap, amount)
                                :else                                   (shift-line win, (== (:op_type oap) OP_LSHIFT), @p_sr, amount, false)
                            )]
                        (recur (update-in win [:w_cursor :lnum] inc) (dec n))
                    ))
              _ (swap! curbuf changed-lines (:lnum (:op_start oap)), 0, (inc (:lnum (:op_end oap))), 0)
              win (cond (:block_mode oap)
                    (update win :w_cursor assoc :lnum (:lnum (:op_start oap)) :col block_col)
                curs_top ;; put cursor on first line, for ">>"
                    (-> win
                        (assoc-in [:w_cursor :lnum] (:lnum (:op_start oap)))
                        (beginline (| BL_SOL BL_FIX)) ;; shift-line() may have set cursor.col
                    )
                :else ;; put cursor on last line, for ":>"
                    (update-in win [:w_cursor :lnum] dec)
                )
              win (let-when [n (:line_count oap)] (< @p_report n) => win
                    (let [#_Bytes s (if (== (:op_type oap) OP_RSHIFT) (u8 ">") (u8 "<"))]
                        (cond (== n 1)
                            (if (== amount 1)
                                (msg* win, (u8 "1 line %sed 1 time"), s)
                                (msg* win, (u8 "1 line %sed %ld times"), s, amount))
                        :else
                            (if (== amount 1)
                                (msg* win, (u8 "%ld lines %sed 1 time"), n, s)
                                (msg* win, (u8 "%ld lines %sed %ld times"), n, s, amount))
                        ))
                )]
            ;; Set "'[" and "']" marks.
            (let [enum (:lnum (:op_end oap)) ecol (STRLEN (ml-get enum)) ecol (if (< 0 ecol) (dec ecol) ecol)]
                (swap! curbuf assoc :b_op_start (:op_start oap))
                (swap! curbuf update :b_op_end assoc :lnum enum :col ecol))
            win
        )
    ))

;; Shift the current line one shiftwidth left (if "left" is true) or right.
;; Leaves cursor on first blank in the line.

(defn- #_window_C shift-line [#_window_C win, #_boolean left, #_boolean round?, #_int amount, #_boolean call_changed_bytes]
    (let [#_int sw (get-sw-value) #_int n (get-indent win) n (if round?
            (let [#_int a (if (and (non-zero? (% n sw)) left) (dec amount) amount) n (/ n sw)]
                (* (if left (max 0 (- n a)) (+ n a)) sw)            ;; round off indent
            )
            (let [#_int a (* amount sw)]
                (if left (max 0 (- n a)) (+ n a))                   ;; original vi indent
            ))]
        (if (flag? @State VREPLACE_FLAG)
            (change-indent win, INDENT_SET, n, false, NUL, call_changed_bytes)
            (set-indent win, n, (if call_changed_bytes SIN_CHANGED 0))
        )
    ))

;; Shift one line of the current block one shiftwidth right or left.
;; Leaves cursor on first character in block.

(defn- #_window_C shift-block [#_window_C win, #_oparg_C oap, #_int amount]
    (let-when [#_boolean left (== (:op_type oap) OP_LSHIFT) o'col (:col (:w_cursor win))
          q_sw (get-sw-value) q_ts @(:b_p_ts @curbuf) q_et @(:b_p_et @curbuf)
          o'State @State _ (reset! State INSERT) ;; don't want REPLACE for State
          #_block_def_C bd (block-prep win, oap, false, (:lnum (:w_cursor win)), true)
    ] (not (:is_short bd)) => win
        ;; total is number of screen columns to be inserted/removed
        (let [#_int total (* amount q_sw) #_Bytes oldp (ml-get (:lnum (:w_cursor win)))
              [bd #_Bytes newp]
                (if (not left)
                    (let [total (+ total (:pre_whitesp bd)) ;; all virtual white-space upto and including a split TAB
                          #_int ws_vcol (- (:start_vcol bd) (:pre_whitesp bd))
                          bd (if (non-zero? (:startspaces bd)) (update bd :textstart #(.plus % (us-ptr2len-cc %))) bd)
                          [total bd]
                            (loop-when [total total bd bd] (vim-iswhite (.at (:textstart bd) 0)) => [total bd]
                                ;; TODO: is passing bd.textstart for start of the line OK?
                                (let [__ (atom (#_Bytes object (:textstart bd)))
                                      #_int n (lbr-chartabsize-adv win, (:textstart bd), __, (:start_vcol bd))
                                      bd (assoc bd :textstart @__)]
                                    (recur (+ total n) (update bd :start_vcol + n))
                                ))
                          ;; OK, now total=all the VWS reqd, and textstart points at the 1st non-ws char in the block.
                          #_int i (if (not q_et) (/ (+ (% ws_vcol q_ts) total) q_ts) 0) ;; number of tabs
                          #_int j (if (non-zero? i) (% (+ (% ws_vcol q_ts) total) q_ts) total) ;; number of spp
                          ;; if we're splitting a TAB, allow for it
                          bd (update bd :textcol - (- (:pre_whitesp_c bd) (if (non-zero? (:startspaces bd)) 1 0)))
                          #_int m (:textcol bd) #_int n (inc (STRLEN (:textstart bd))) newp (Bytes. (+ m i j n))]
                        (BCOPY newp, oldp, m)
                        (BFILL newp, m, TAB, i)
                        (BFILL newp, (+ m i), (byte \space), j)
                        (BCOPY newp, (+ m i j), (:textstart bd), 0, n)
                        [bd newp]
                    )
                    ;; Firstly, let's find the first non-whitespace character that is displayed
                    ;; after the block's start column and the character's column number.
                    ;; Also, let's calculate the width of all the whitespace characters that are
                    ;; displayed in the block and precede the searched non-whitespace character.
                    ;;
                    ;; If "bd.startspaces" is set, "bd.textstart" points to the character,
                    ;; the part of which is displayed at the block's beginning.
                    ;; Let's start searching from the next character.
                    (let [a'non_white (atom (#_Bytes object (:textstart bd)))
                          _ (when (non-zero? (:startspaces bd))
                                (swap! a'non_white #(.plus % (us-ptr2len-cc %))))
                          ;; The character's column is in "bd.start_vcol".
                          #_int non_white_col
                            (loop-when [non_white_col (:start_vcol bd)] (vim-iswhite (.at @a'non_white 0)) => non_white_col
                                (let [#_int n (lbr-chartabsize-adv win, (:textstart bd), a'non_white, non_white_col)]
                                    (recur (+ non_white_col n))
                                ))
                          #_int block_space_width (- non_white_col (:start_vcol oap))
                          ;; We will shift by "total" or "block_space_width", whichever is less.
                          #_int shift_amount (min block_space_width total)
                          ;; The column to which we will shift the text.
                          #_int dest_col (- non_white_col shift_amount)
                          ;; Now let's find out how much of the beginning of the line we can reuse without modification.
                          #_Bytes verb_end (:textstart bd) ;; end of the part of the line which is copied verbatim
                          #_int verb_width (:start_vcol bd) ;; the (displayed) width of this part of line
                          ;; If "bd.startspaces" is set, "bd.textstart" points to the character preceding the block.
                          ;; We have to subtract its width to obtain its column number.
                          verb_width (- verb_width (if (non-zero? (:startspaces bd)) (:start_char_vcols bd) 0))
                          [verb_width verb_end]
                            (loop-when [verb_width verb_width verb_end verb_end] (< verb_width dest_col) => [verb_width verb_end]
                                ;; TODO: is passing "verb_end" for start of the line OK?
                                (let [#_int n (lbr-chartabsize win, verb_end, verb_end, verb_width)]
                                    (if (< dest_col (+ verb_width n))
                                        [verb_width verb_end]
                                        (recur (+ verb_width n) (.plus verb_end (us-ptr2len-cc verb_end)))
                                    )))
                          ;; If "dest_col" is different from the width of the initial part of the line that will be copied,
                          ;; it means we encountered a tab character, which we will have to partly replace with spaces.
                          #_int n (- dest_col verb_width)
                          ;; The replacement line will consist of:
                          ;; - the beginning of the original line up to "verb_end",
                          ;; - "n" number of spaces,
                          ;; - the rest of the line, pointed to by "non_white".
                          #_int m (BDIFF verb_end, oldp) ;; the length of the line after the block shift
                          newp (Bytes. (+ m n (STRLEN @a'non_white) 1))]
                        (BCOPY newp, oldp, m)
                        (BFILL newp, m, (byte \space), n)
                        (BCOPY newp, (+ m n), @a'non_white, 0, (inc (STRLEN @a'non_white)))
                        [bd newp]
                    )
                )]
            (ml-replace (:lnum (:w_cursor win)), newp)
            (changed-bytes (:lnum (:w_cursor win)), (:textcol bd))
            (reset! State o'State)
            (assoc-in win [:w_cursor :col] o'col)
        )
    ))

;; Insert string "s" ("ins" ? before : after) block.
;; Caller must prepare for undo.

(defn- #_void block-insert [#_window_C win, #_oparg_C oap, #_Bytes s, #_boolean ins, #_boolean is_MAX]
    (let [#_int state' @State _ (reset! State INSERT) ;; don't want REPLACE for State
          #_int n (STRLEN s)]
        ;; ct: non-zero if cutting a TAB ;; es: extra spaces to replace a cut TAB
        (loop-when [#_int ct 0 #_int es 0 #_long y (inc (:lnum (:op_start oap)))] (<= y (:lnum (:op_end oap)))
            (let [#_block_def_C bd (block-prep win, oap, is_MAX, y, true)]
                (if (and (:is_short bd) ins)
                    (recur ct es (inc y))                       ;; OP_INSERT, line ends before block start
                    (let [#_Bytes p (ml-get y)
                          [#_int ts ct es #_int x]
                            (if ins
                                (let [ts (:start_char_vcols bd) ct (:startspaces bd)]
                                    [ts ct (if (non-zero? ct) (dec ts) es) (:textcol bd)])
                                (let [ts (:end_char_vcols bd)]
                                    (if (not (:is_short bd))
                                        ;; ct = padding after block
                                        (let [ct (if (non-zero? (:endspaces bd)) (- ts (:endspaces bd)) 0)]
                                            [ts ct (if (non-zero? ct) (dec ts) es) (- (+ (:textcol bd) (:textlen bd)) (if (non-zero? ct) 1 0))])
                                        ;; ct = padding to block edge ;; if $ used, just append to EOL (ie ct==0)
                                        (let [ct (if (not (:is_MAX bd)) (inc (- (:end_vcol oap) (:end_vcol bd))) ct)]
                                            [ts ct ct (+ (:textcol bd) (:textlen bd))])
                                    )))
                          [ct es x]
                            (if (< 0 ct) ;; Avoid starting halfway a multi-byte character.
                                (let [[#_int i x] (if ins [(us-head-off p, (.plus p (+ x ct))) x] (let [i (us-off-next p, (.plus p x))] [i (+ x i)]))]
                                    [(- ct i) (- es i) x])
                                [ct es x])
                          #_Bytes q (Bytes. (+ (STRLEN p) n es 1))
                          _ (BCOPY q, p, x)                             ;; copy up to shifted part
                          p (.plus p x)
                          _ (BFILL q, x, (byte \space), ct)             ;; insert pre-padding
                          _ (BCOPY q, (+ x ct), s, 0, n)                ;; copy the new text
                          x (+ x n)
                          [p es]
                            (if (and (< 0 ct) (not (:is_short bd)))
                                (do (BFILL q, (+ x ct), (byte \space), (- ts ct)) ;; insert post-padding
                                    ;; We're splitting a TAB, don't copy it.
                                    ;; We allowed for that TAB, remember this now.
                                    [(.plus p 1) (inc es)])
                                [p es])
                          x (if (< 0 ct) (+ x es) x)
                          _ (BCOPY q, x, p, 0, (inc (STRLEN p)))]
                        (ml-replace y, q)
                        (when (== y (:lnum (:op_end oap)))
                            ;; Set "']" mark to the end of the block instead of the end of the insert in the first line.
                            (swap! curbuf update :b_op_end assoc :lnum y :col x))
                        (recur ct es (inc y))
                    ))
            ))
        (swap! curbuf changed-lines (inc (:lnum (:op_start oap))), 0, (inc (:lnum (:op_end oap))), 0)
        (reset! State state'))
    nil)

;; Handle reindenting a block of lines.

(defn- #_window_C op-reindent [#_window_C win, #_oparg_C oap, #_getindent_F getindent]
    (let [#_long n (:lnum (:w_cursor win)) m (:line_count oap)
          [win #_long x #_long y #_long i]
            (loop-when [win win x 0 y 0 i (dec m)] (and (<= 0 i) (not @got_int)) => [win x y i]
                ;; It's a slow thing to do, so give feedback, so there's no worry that the computer's just hung.
                (let [win (when' (and (< 1 i) (or (zero? (% i 50)) (== i (dec m))) (< @p_report m)) => win
                            (msg* win, (u8 "%ld lines to indent... "), i))
                      [win ?] (set-indent? win, (if (non-eos? (skipwhite (ml-get (:lnum (:w_cursor win))))) (getindent) 0), SIN_UNDO)
                      [x y] (if ? (let [l (:lnum (:w_cursor win))] [(if (zero? x) l x) l]) [x y])]
                    (recur (update win :w_cursor crlf) x y (dec i))
                ))
          ;; put cursor on first non-blank of indented line
          win (assoc-in win [:w_cursor :lnum] n)
          win (beginline win, (| BL_SOL BL_FIX))
          ;; Mark changed lines so that they will be redrawn.
          ;; When Visual highlighting was present, need to continue until the last line.
          ;; When there is no change, still need to remove the Visual highlighting.
          _ (cond (non-zero? y)    (swap! curbuf changed-lines x, 0, (if (:is_VIsual oap) (+ n m) (inc y)), 0)
                  (:is_VIsual oap) (redraw-curbuf-later INVERTED))
          win (when' (< @p_report m) => win
                (let [i (- m (inc i))]
                    (if (== i 1)
                        (msg win, (u8 "1 line indented "))
                        (msg* win, (u8 "%ld lines indented "), i)
                    ))
            )]
        ;; Set '[ and '] marks.
        (swap! curbuf assoc :b_op_start (:op_start oap) :b_op_end (:op_end oap))
        win
    ))

;; Keep the last expression line here, for repeating.

(atom! Bytes expr_line)

;; Get an expression for the "\"=expr1" or "CTRL-R =expr1"
;; Returns '=' when OK, NUL otherwise.

(defn- #_[window_C int] get-expr-register? [#_window_C win]
    (let-when [[win #_Bytes s] (getcmdline win, (byte \=), 0)] (some? s) => [win NUL]
        (when (non-eos? s)
            (reset! expr_line s)) ;; else use previous line
        [win (byte \=)]
    ))

(atom! int __nested)

;; Get the result of the '=' register expression.
;; Returns a pointer to allocated memory, or null for failure.

(defn- #_Bytes get-expr-line []
    (let-when [#_Bytes e @expr_line] (some? e) => nil
        ;; Make a copy of the expression, because evaluating it may cause it to be changed.
        ;; When invoked recursively, limit the evaluation to 10 levels, then return the string as-is.
        (let-when [e (STRDUP e)] (< @__nested 10) => e
            (swap! __nested inc) (let [e (eval-to-string e)] (swap! __nested dec) e))
    ))

;; Check if "regname" is a valid name of a yank register.
;; Note: There is no check for 0 (default register), caller should do this.

(defn- #_boolean valid-yank-reg [#_int regname, #_boolean writing]
    ;; writing: if true check for writable registers
    (or (and (< 0 regname) (asc-isalnum regname))
        (and (not writing) (some? (vim-strchr (u8 "/.%:="), regname)))
        (== regname (byte \#))
        (== regname (byte \"))   ;; """
        (== regname (byte \-))
        (== regname (byte \_))
        (== regname (byte \*))
        (== regname (byte \+))
        (and (not writing) (== regname (byte \~)))
    ))

;; Set "y_curr" and "y_append", according to the value of "regname".
;; Cannot handle the '_' register.
;; Must only be called with a valid register name!
;;
;; If regname is 0 and writing, use register 0.
;; If regname is 0 and reading, use previous register.

(defn- #_int get-yank-register [#_int regname, #_boolean writing]
    (reset! y_append false)
    (if (and (or (zero? regname) (== regname (byte \"))) (not writing) (some? @y_prev))    ;; """
        (reset! y_curr @y_prev)
        (let [#_int i regname
              i (cond
                    (asc-isdigit i) (- i (byte \0))
                    (asc-islower i) (+ (lowerOrd i) 10)
                    (asc-isupper i) (do (reset! y_append true) (+ (upperOrd i) 10))
                    (== regname (byte \-)) DELETION_REGISTER
                    (and (not writing) (== regname (byte \~))) TILDE_REGISTER
                    :else 0 ;; not 0-9, a-z, A-Z or '-': use register 0
                )]
            (reset! y_curr i)
            (when writing        ;; remember the register we write into for do-put()
                (reset! y_prev @y_curr))
        ))
    @y_curr)

;; Obtain the contents of a "normal" register.  The register is made empty.

(defn- #_yankreg_C get-register [#_int name, #_boolean copy]
    ;; copy: make a copy, if false: make register empty
    (let [#_int y (get-yank-register name, false) #_yankreg_C reg (... @y_regs y)]
        (cond (not copy)
            (do (swap! y_regs assoc-in [y :y_array] nil)
                reg)
        ;; If we run out of memory, some or all of the lines are empty.
        (zero? (:y_size reg))
            (assoc reg :y_array nil)
        :else
            (let [reg (assoc reg :y_array (Bytes* (:y_size reg)))]
                (loop-when-recur [reg reg #_int i 0] (< i (:y_size reg)) [(assoc-in reg [:y_array i] (STRDUP (... (:y_array (... @y_regs y)) i))) (inc i)] => reg)
            ))
    ))

;; Put "reg" into register "name".

(defn- #_void put-register [#_int name, #_yankreg_C reg]
    (let [#_int y (get-yank-register name, false)]
        (swap! y_regs assoc y reg))
    nil)

(atom! int rec__regname)

;; Start or stop recording into a yank register.
;;
;; Return false for failure, true otherwise.

(defn- #_[window_C boolean] do-record? [#_window_C win, #_int regname]
    (if (not @Recording)
        ;; start recording ;; registers 0-9, a-z and " are allowed
        (when' (or (asc-isalnum regname) (== regname (byte \"))) => [win false] ;; """
            (reset! Recording true)
            (reset! rec__regname regname)
            [(showmode win) true])
        ;; stop recording
        (let [_ (reset! Recording false) win (msg win, (u8 ""))]
            ;; Get the recorded key hits.
            (let-when [#_Bytes s (get-recorded)] (some? s) => [win false]
                ;; Remove escaping for KB_SPECIAL in multi-byte chars.
                (vim-unescape-special s)
                ;; We don't want to change the default register here, so save and restore the current register name.
                (let [o'prev @y_prev o'curr @y_curr ? (stuff-yank @rec__regname, s) _ (reset! y_prev o'prev) _ (reset! y_curr o'curr)] [win ?])
            ))
    ))

;; Stuff "s" into yank register "regname" as a single line (append if uppercase).
;;
;; Return false for failure, true otherwise.

(defn- #_boolean stuff-yank [#_int regname, #_Bytes s]
    (cond (and (non-zero? regname) (not (valid-yank-reg regname, true))) ;; check for read-only register
        false
    (== regname (byte \_)) ;; black hole: don't do anything
        true
    :else
        (let [#_int y (get-yank-register regname, true)]
            (if (and @y_append (some? (:y_array (... @y_regs y))))
                (let [#_int i (dec (:y_size (... @y_regs y))) #_Bytes ai (... (:y_array (... @y_regs y)) i)
                      #_Bytes s' (Bytes. (+ (STRLEN ai) (STRLEN s) 1)) _ (STRCPY s', ai) _ (STRCAT s', s)]
                    (swap! y_regs update y assoc-in [:y_array i] s'))
                (swap! y_regs update y assoc :y_array [ s ] :y_size 1 :y_type MCHAR)) ;; used to be MLINE, why?
            true)
    ))

(final Bytes CTRL_1_31 (u8 "\001\002\003\004\005\006\007\010\011\012\013\014\015\016\017\020\021\022\023\024\025\026\027\030\031\032\033\034\035\036\037"))

(atom! int execreg_lastc NUL)

;; Execute a yank register: copy it into the stuff buffer.
;;
;; Return false for failure, true otherwise.

(defn- #_[window_C boolean] do-execreg? [#_window_C win, #_int regname]
    (let-when [[regname :as _]
            (if (== regname (byte \@))                                                              ;; repeat previous one
                (let [regname @execreg_lastc] (if (== regname NUL) nil [regname]))
                [regname]
            )] (some? _) => [(emsg win, (u8 "E748: No previously used register")) false]

        (if (or (any == regname (byte \%) (byte \#)) (not (valid-yank-reg regname, false)))         ;; check for valid regname
            [(emsg* win, (u8 "E354: Invalid register name: '%s'"), (transchar regname)) false]

            (let [_ (reset! execreg_lastc regname) regname (may-get-selection regname)]
                (condp == regname
                    (byte \_)                                                                       ;; black hole: don't stuff anything
                        [win true]

                    (byte \:)                                                                       ;; use last command line
                        (when' (some? @last_cmdline) => [(emsg win, e_nolastcmd) false]
                            (let [_ (reset! new_last_cmdline nil)                                   ;; don't keep the cmdline containing @:
                                  ;; Escape all control characters with a CTRL-V.
                                  #_Bytes p (vim-strsave-escaped @last_cmdline, CTRL_1_31, Ctrl_V)
                                  ;; When in Visual mode "'<,'>" will be prepended to the command.
                                  ;; Remove it when it's already there.
                                  p (if (and @VIsual_active (zero? (STRNCMP p, (u8 "'<,'>"), 5))) (.plus p 5) p)]
                                (put-in-typebuf p, true, true)
                                [win true]
                            ))

                    (byte \=)
                        (let-when [#_Bytes p (get-expr-line)] (some? p) => [win false]
                            (put-in-typebuf p, true, false)
                            [win true])

                    (byte \.)                                                                       ;; use last inserted text
                        (let-when [#_Bytes p (get-last-insert-save)] (some? p) => [(emsg win, e_noinstext) false]
                            (put-in-typebuf p, false, false)
                            [win true])

                    (let-when [_ (get-yank-register regname, false)] (some? (:y_array (... @y_regs @y_curr))) => [win false]
                        ;; Insert lines into typeahead buffer from last one to first one.
                        (put-reedit-in-typebuf)
                        (loop-when-recur [#_int i (:y_size (... @y_regs @y_curr))] (< 0 i) [(dec i)]
                            ;; Insert NL between lines and after last line if type is MLINE.
                            (when (or (== (:y_type (... @y_regs @y_curr)) MLINE) (< i (:y_size (... @y_regs @y_curr))))
                                (ins-typebuf (u8 "\n")))
                            (ins-typebuf (vim-strsave-escape-special (... (:y_array (... @y_regs @y_curr)) (dec i)))))
                        (reset! exec_reg true)                                                      ;; disable the 'q' command
                        [win true]
                    ))
            ))
    ))

;; If "restart_edit" is not zero, put it in the typeahead buffer,
;; so that it's used only after other typeahead has been processed.

(defn- #_void put-reedit-in-typebuf []
    (when (!= @restart_edit NUL)
        (let [#_Bytes buf (Bytes. 3)]
            (if (== @restart_edit (byte \V))
                (-> buf (.be 0, (byte \g)) (.be 1, (byte \R)) (eos! 2))
                (-> buf (.be 0, (if (== @restart_edit (byte \I)) (byte \i) @restart_edit)) (eos! 1))
            )
            (ins-typebuf buf)
            (reset! restart_edit NUL)
        ))
    nil)

;; Insert register contents "s" into the typeahead buffer, so that it will be executed again.
;; When "esc" is true it is to be taken literally: escape CSI characters and no remapping.

(defn- #_void put-in-typebuf [#_Bytes s, #_boolean esc, #_boolean colon]
    (put-reedit-in-typebuf)
    (when colon
        (ins-typebuf (u8 "\n")))
    (ins-typebuf (if esc (vim-strsave-escape-special s) s))
    (when colon
        (ins-typebuf (u8 ":")))
    nil)

;; Insert a yank register: copy it into the Read buffer.
;; Used by CTRL-R command in Insert mode.
;;
;; literally: insert literally, not as if typed
;; return false for failure, true otherwise

(defn- #_[window_C boolean] insert-reg? [#_window_C win, #_int regname, #_boolean literally]
    ;; It is possible to get into an endless loop by having CTRL-R a in register a and then, in Insert mode, doing CTRL-R a.
    ;; If you hit CTRL-C, the loop will be broken here.
    (ui-breakcheck)
    (if (or @got_int (and (!= regname NUL) (not (valid-yank-reg regname, false))))  ;; check for valid regname
        [win false]
        (let [regname (may-get-selection regname) a'arg (atom (#_Bytes object))]
            (cond (== regname (byte \.))                                            ;; insert last inserted text
                (stuff-inserted? win, NUL, 1, true)
            :else
                (let [[win ?] (get-spec-reg? win, regname, a'arg)]
                    (cond ?
                        [win (if (some? @a'arg) (do (stuffescaped @a'arg, literally) true) false)]
                    :else                                                           ;; name or number register
                        (let-when [#_int y (get-yank-register regname, false)] (some? (:y_array (... @y_regs y))) => [win false]
                            (dotimes [#_int i (:y_size (... @y_regs y))]
                                (stuffescaped (... (:y_array (... @y_regs y)) i), literally)
                                ;; Insert a newline between lines and after last line if "y_type" is MLINE.
                                (when (or (== (:y_type (... @y_regs y)) MLINE) (< i (dec (:y_size (... @y_regs y)))))
                                    (stuff-char (byte \newline))
                                ))
                            [win true])
                    ))
            ))
    ))

;; Stuff a string into the typeahead buffer, such that edit() will
;; insert it literally or interpret it as typed characters.

(defn- #_void stuffescaped [#_Bytes _arg, #_boolean literally]
    (let [a'arg (atom (#_Bytes object _arg))]
        (while (non-eos? @a'arg)
            ;; Stuff a sequence of normal ASCII characters, that's fast.
            ;; Also stuff KB_SPECIAL to get the effect of a special key when "literally" is true.
            (let [#_Bytes start @a'arg]
                (while (or (and (<= (byte \space) (.at @a'arg 0)) (< (.at @a'arg 0) DEL)) (and (at? @a'arg KB_SPECIAL) (not literally)))
                    (swap! a'arg plus 1))
                (when (BLT start, @a'arg)
                    (stuff-string start, (BDIFF @a'arg, start))
                ))
            ;; stuff a single special character
            (when (non-eos? @a'arg)
                (let [#_int c (us-ptr2char-adv a'arg, false)]
                    (when (and literally (or (and (< c (byte \space)) (!= c TAB)) (== c DEL)))
                        (stuff-char Ctrl_V))
                    (stuff-char c)
                ))
        ))
    nil)

;; If "regname" is a special register, return true and store a pointer to its value in "value".

(defn- #_[window_C boolean] get-spec-reg? [#_window_C win, #_int regname, #_Bytes' a'value]
    (condp ==? regname
        (byte \=)                                       ;; result of expression
        (do
            (reset! a'value (get-expr-line))
            [win true]
        )
        (byte \:)                                       ;; last command line
        (do
            (reset! a'value @last_cmdline)
            [(if (nil? @a'value) (emsg win, e_nolastcmd) win) true]
        )
        (byte \/)                                       ;; last search-pattern
        (do
            (reset! a'value (last-search-expr))
            [(if (nil? @a'value) (emsg win, e_noprevre) win) true]
        )
        (byte \.)                                       ;; last inserted text
        (do
            (reset! a'value (get-last-insert-save))
            [(if (nil? @a'value) (emsg win, e_noinstext) win) true]
        )
       [Ctrl_W Ctrl_A]          ;; word under cursor ;; WORD (mnemonic All) under cursor
        (do
            (reset! a'value nil)
            (let [[win #_int n] (find-ident-under-cursor? win, a'value, (if (== regname Ctrl_W) (| FIND_IDENT FIND_STRING) FIND_STRING))]
                (reset! a'value (if (pos? n) (STRNDUP @a'value, n) nil))
                [win true])
        )
        (byte \_)               ;; black hole: always empty
        (do
            (reset! a'value (u8 ""))
            [win true]
        )
     ;; :else
        (do
            (reset! a'value nil)
            [win false]
        )
    ))

;; Paste a yank register into the command line.
;; Only for non-special registers.
;; Used by CTRL-R command in command-line mode.
;; insert-reg() can't be used here, because special characters from the register contents will be interpreted as commands.
;;
;; return false for failure, true otherwise

(defn- #_boolean cmdline-paste-reg [#_int regname, #_boolean literally, #_boolean remcr]
    ;; literally: insert text literally instead of "as typed"
    ;; remcr: don't add trailing CR
    (let [y (get-yank-register regname, false) r (... @y_regs y) a (:y_array r) n (:y_size r) t (:y_type r)]
        (and (some? a)
            (loop-when [i 0] (< i n) => true
                (cmdline-paste-str (... a i), literally)
                ;; Insert ^M between lines and after last line if type is MLINE.
                ;; Don't do this when "remcr" is true and the next line is empty.
                (when (or (== t MLINE) (and (< i (dec n)) (not (and remcr (== i (- n 2)) (eos? (... a (inc i)))))))
                    (cmdline-paste-str (u8 "\r"), literally))
                ;; Check for CTRL-C in case someone tries to paste a few thousand lines and gets bored.
                (ui-breakcheck)
                (if @got_int false (recur (inc i)))
            ))
    ))

;; Adjust the register name "reg" for the clipboard being used always and the clipboard being available.

(defn- #_int adjust-clip-reg [#_int reg]
    (if (any == reg (byte \*) (byte \+)) 0 reg))

;; When "reg" is a clipboard register, obtain the selection.
;; If it's not available return zero, otherwise return "reg".

(defn- #_int may-get-selection [#_int reg]
    (if (any == reg (byte \*) (byte \+)) 0 reg))

;; Handle a delete operation.
;;
;; Return false if undo failed, true otherwise.

(defn- #_[window_C oparg_C boolean] op-delete? [#_window_C win, #_oparg_C oap]
    (cond (:ml_empty (:b_ml @curbuf)) ;; nothing to do
        [win oap true]
    ;; Nothing to delete, return here.  Do prepare undo, for op-change().
    (:empty oap)
        [win oap (u-save-cursor win)]
    :else
        (let-when [o'lmax (line-count @curbuf) o'regname (:regname oap)
              oap (update oap :regname adjust-clip-reg) oap (mb-adjust-opend oap)
              ;; Imitate the strange Vi behaviour:  If the delete spans more than one line and motion_type == MCHAR and
              ;; the result is a blank line, make the delete linewise.  Don't do this for the change command or Visual mode.
              oap (if (and (== (:motion_type oap) MCHAR) (not (:is_VIsual oap)) (not (:block_mode oap)) (< 1 (:line_count oap))
                           (== (:motion_force oap) NUL) (== (:op_type oap) OP_DELETE))
                    (let [#_Bytes s (.plus (ml-get (:lnum (:op_end oap))) (:col (:op_end oap))) s (if (and (non-eos? s) (:inclusive oap)) (.plus s 1) s) s (skipwhite s)]
                        (if (and (eos? s) (inindent win, 0)) (assoc oap :motion_type MLINE) oap))
                    oap)
              [win ?] ;; Check for trying to delete (e.g. "D") in an empty line.  Note:  For the change operator it is ok.
                (when' (and (== (:motion_type oap) MCHAR) (== (:line_count oap) 1) (== (:op_type oap) OP_DELETE) (eos? (ml-get (:lnum (:op_start oap))))) => [win nil]
                    (if (!= @virtual_op FALSE)
                        ;; Virtual editing: nothing gets deleted, but we set the '[ and '] marks as if it happened.
                        (do (swap! curbuf assoc :b_op_start (:op_start oap))
                            (if (:block_mode oap)
                                (swap! curbuf update :b_op_end assoc :lnum (:lnum (:op_end oap)) :col (:col (:op_start oap)))
                                (swap! curbuf assoc :b_op_end (:op_start oap)))
                            [win :abort])
                        ;; It's an error to operate on an empty region when 'E' included in 'cpoptions' (Vi compatible).
                        [(if (some? (vim-strbyte @p_cpo, CPO_EMPTYREGION)) (beep-flush win) win) :abort]
                    ))
        ] (not ?) => [win oap true]

            ;; Do a yank of whatever we're about to delete.
            ;; If a yank register was specified, put the deleted text into that register.
            ;; For the black hole register '_' don't yank anything.
            (let-when [[win oap _]
                    (when' (!= (:regname oap) (byte \_)) => [win oap nil]
                        (let-when [[win oap #_boolean done? _]
                                (cond (zero? (:regname oap))
                                    [win oap false nil]
                                (valid-yank-reg (:regname oap), true) ;; check for read-only register
                                    (let [_ (get-yank-register (:regname oap), true) [win oap ?] (op-yank? win, oap, true, false)]
                                        [win oap ? nil])
                                :else
                                    [(beep-flush win) oap false true]
                                )] (nil? _) => [win oap _]

                            ;; Put deleted text into register 1 and shift number registers if the
                            ;; delete contains a line break, or when a regname has been specified.
                            ;; Use the register name from before adjust-clip-reg() may have changed it.
                            (let [[win oap done?]
                                    (when' (or (non-zero? o'regname) (== (:motion_type oap) MLINE) (< 1 (:line_count oap)) (:use_reg_one oap)) => [win oap done?]
                                        (loop-when-recur [#_int n 9] (< 1 n) [(dec n)]
                                            (swap! y_regs assoc n (... @y_regs (dec n))))
                                        (swap! y_regs update 1 assoc :y_array nil) ;; set register one to empty
                                        (reset! y_prev (reset! y_curr 1))
                                        (let [[win oap ?] (op-yank? win, oap, true, false)]
                                            [win oap (or ? done?)]
                                        ))
                                  ;; Yank into small delete register when no named register specified
                                  ;; and the delete is within one line.
                                  [win oap done?]
                                    (when' (and (zero? (:regname oap)) (!= (:motion_type oap) MLINE) (== (:line_count oap) 1)) => [win oap done?]
                                        (let [oap (assoc oap :regname (byte \-))
                                              _ (get-yank-register (:regname oap), true) [win oap ?] (op-yank? win, oap, true, false)]
                                            [win (assoc oap :regname 0) (or ? done?)]
                                        ))]
                                (if done? [win oap nil] [(emsg? win, e_abort) oap false])
                            ))
                    )] (nil? _) => [win oap _]

                (let-when [[win oap _]
                        (cond (:block_mode oap) ;; block mode delete
                            (when' (u-save win, (dec (:lnum (:op_start oap))), (inc (:lnum (:op_end oap)))) => [win oap false]
                                (let [win (loop-when [win win #_long lnum (:lnum (:w_cursor win))] (<= lnum (:lnum (:op_end oap))) => (check-cursor-col win)
                                            (let [#_block_def_C bd (block-prep win, oap, false, lnum, true)
                                                  win (when' (non-zero? (:textlen bd)) => win
                                                        ;; Adjust cursor position for tab replaced by spaces and 'lbr'.
                                                        (let [win (when' (== lnum (:lnum (:w_cursor win))) => win
                                                                    (update win :w_cursor assoc :col (+ (:textcol bd) (:startspaces bd)) :coladd 0))
                                                              ;; If we delete a TAB, it may be replaced by several characters,
                                                              ;; thus the number of characters may increase!
                                                              #_int n (- (:textlen bd) (:startspaces bd) (:endspaces bd)) ;; number of chars deleted
                                                              #_Bytes s (ml-get lnum) #_Bytes s' (Bytes. (- (inc (STRLEN s)) n))
                                                              ;; copy up to deleted part
                                                              _ (BCOPY s', s, (:textcol bd))
                                                              ;; insert spaces
                                                              _ (BFILL s', (:textcol bd), (byte \space), (+ (:startspaces bd) (:endspaces bd)))
                                                              ;; copy the part after the deleted part
                                                              s (.plus s (+ (:textcol bd) (:textlen bd)))
                                                              _ (BCOPY s', (+ (:textcol bd) (:startspaces bd) (:endspaces bd)), s, 0, (inc (STRLEN s)))]
                                                            ;; replace the line
                                                            (ml-replace lnum, s')
                                                            win)
                                                    )]
                                                (recur win (inc lnum)))
                                        )]
                                    (swap! curbuf changed-lines (:lnum (:w_cursor win)), (:col (:w_cursor win)), (inc (:lnum (:op_end oap))), 0)
                                    [win (assoc oap :line_count 0) nil] ;; no lines deleted
                                ))
                        (== (:motion_type oap) MLINE)
                            (if (== (:op_type oap) OP_CHANGE)
                                ;; Delete the lines except the first one.  Temporarily move the cursor to the next line.
                                ;; Save the current line number: if the last line is deleted, it may be changed.
                                (let [win (when' (< 1 (:line_count oap)) => win
                                            (let [o'lnum (:lnum (:w_cursor win))]
                                                (-> win
                                                    (update-in [:w_cursor :lnum] inc)
                                                    (del-lines (dec (:line_count oap)), true)
                                                    (assoc-in [:w_cursor :lnum] o'lnum)
                                                ))
                                        )]
                                    (when' (u-save-cursor win) => [win oap false]
                                        (let [win (if @(:b_p_ai @curbuf)                        ;; don't delete indent
                                                    (let [win (beginline win, BL_WHITE)]        ;; cursor on first non-white
                                                        (reset! did_ai true)                    ;; delete the indent when ESC hit
                                                        (reset! ai_col (:col (:w_cursor win))))
                                                    (beginline win, 0))
                                              win (truncate-line win, false)] ;; delete the rest of the line, leave cursor past last char in line
                                            (when (< 1 (:line_count oap))
                                                (u-clearline)) ;; "U" command not possible after "2cc"
                                            [win oap nil])
                                    ))
                                (let [win (-> win (del-lines (:line_count oap), true) (beginline (| BL_WHITE BL_FIX)))]
                                    (u-clearline) ;; "U" command not possible after "dd"
                                    [win oap nil]
                                ))
                        :else
                            (let-when [[win oap _]
                                    (when' (!= @virtual_op FALSE) => [win oap nil]
                                        ;; For virtualedit: break the tabs that are partly included.
                                        (let-when [[win oap _]
                                                (when' (== (gchar-pos (:op_start oap)) TAB) => [win oap nil]
                                                    (when' (u-save-cursor win) => [win oap false] ;; save first line for undo
                                                        (let [#_int endcol (if (== (:line_count oap) 1) (getviscol2 win, (:col (:op_end oap)), (:coladd (:op_end oap))) 0)
                                                              win (coladvance-force win, (getviscol2 win, (:col (:op_start oap)), (:coladd (:op_start oap))))
                                                              oap (assoc oap :op_start (:w_cursor win))
                                                              [win oap]
                                                                (when' (== (:line_count oap) 1) => [win oap]
                                                                    (let [win (coladvance win, endcol)
                                                                          oap (update oap :op_end assoc :col (:col (:w_cursor win)) :coladd (:coladd (:w_cursor win)))
                                                                          win (assoc win :w_cursor (:op_start oap))]
                                                                        [win oap])
                                                                )]
                                                            [win oap nil]
                                                        ))
                                                )] (nil? _) => [win oap _]

                                            ;; Break a tab only when it's included in the area.
                                            (when' (and (== (gchar-pos (:op_end oap)) TAB) (< (:coladd (:op_end oap)) (if (:inclusive oap) 1 0))) => [win oap nil]
                                                (when' (u-save win, (dec (:lnum (:op_end oap))), (inc (:lnum (:op_end oap)))) => [win oap false] ;; save last line for undo
                                                    (let [win (assoc win :w_cursor (:op_end oap))
                                                          win (coladvance-force win, (getviscol2 win, (:col (:op_end oap)), (:coladd (:op_end oap))))
                                                          oap (assoc oap :op_end (:w_cursor win))
                                                          win (assoc win :w_cursor (:op_start oap))]
                                                        [win oap nil]
                                                    ))
                                            ))
                                    )] (nil? _) => [win oap _]

                                (cond (== (:line_count oap) 1) ;; delete characters within one line
                                    (when' (u-save-cursor win) => [win oap false] ;; save line for undo
                                        (let [#_int n (- (inc (- (:col (:op_end oap)) (:col (:op_start oap)))) (if (not (:inclusive oap)) 1 0))
                                              [win n]
                                                (when' (!= @virtual_op FALSE) => [win n]
                                                    ;; fix up things for virtualedit-delete: break the tabs which are going to get in our way
                                                    (let [#_Bytes s (ml-get (:lnum (:w_cursor win))) #_int len (STRLEN s)
                                                          n (if (and (non-zero? (:coladd (:op_end oap))) (<= (dec len) (:col (:op_end oap)))
                                                                     (not (and (non-zero? (:coladd (:op_start oap))) (<= (dec len) (:col (:op_end oap)))))) (inc n) n)
                                                          ;; Delete at least one char (e.g. when on a control char).
                                                          n (if (and (zero? n) (!= (:coladd (:op_start oap)) (:coladd (:op_end oap)))) 1 n)]
                                                        ;; When deleted a char in the line, reset "coladd".
                                                        [(if (!= (gchar-cursor win) NUL) (assoc-in win [:w_cursor :coladd] 0) win) n]
                                                    ))
                                              win (if (and (== (:op_type oap) OP_DELETE) (:inclusive oap)
                                                           (== (:lnum (:op_end oap)) (line-count @curbuf)) (< (STRLEN (ml-get (:lnum (:op_end oap)))) n))
                                                    (del-lines win, 1, false) ;; Special case: gH<Del> deletes the last line.
                                                    (del-bytes win, n, (== @virtual_op FALSE), (and (== (:op_type oap) OP_DELETE) (not (:is_VIsual oap))))
                                                )]
                                            [win oap nil]
                                        ))
                                :else ;; delete characters between lines ;; save deleted and changed lines for undo
                                    (when' (u-save win, (dec (:lnum (:w_cursor win))), (+ (:lnum (:w_cursor win)) (:line_count oap))) => [win oap false]
                                        (let [#_boolean delete_last_line? (== (:lnum (:op_end oap)) (line-count @curbuf))
                                              win (truncate-line win, true) ;; delete from cursor to end of line
                                              o'cursor (:w_cursor win)
                                              win (update-in win [:w_cursor :lnum] inc)
                                              win (del-lines win, (- (:line_count oap) 2), false)
                                              oap (if delete_last_line? (assoc-in oap [:op_end :lnum] (line-count @curbuf)) oap)
                                              #_int n (- (inc (:col (:op_end oap))) (if (not (:inclusive oap)) 1 0))
                                              win (if (and (:inclusive oap) delete_last_line? (< (STRLEN (ml-get (:lnum (:op_end oap)))) n))
                                                    (-> win ;; Special case: gH<Del> deletes the last line.
                                                        (del-lines 1, false)
                                                        (assoc :w_cursor o'cursor)
                                                        (update :w_cursor update :lnum min (line-count @curbuf)))
                                                    (-> win ;; Delete from start of line until "op_end".
                                                        (assoc-in [:w_cursor :col] 0)
                                                        (del-bytes n, (== @virtual_op FALSE), (and (== (:op_type oap) OP_DELETE) (not (:is_VIsual oap))))
                                                        (assoc :w_cursor o'cursor)
                                                    ))
                                              win (if (< (:lnum (:w_cursor win)) (line-count @curbuf)) (do-join win, 2, false, false, false) win)]
                                            [win oap nil]
                                        ))
                                ))
                        )] (nil? _) => [win oap _]

                    (let [win (msgmore win, (- (line-count @curbuf) o'lmax))]
                        (swap! curbuf assoc :b_op_start (:op_start oap))
                        (if (:block_mode oap)
                            (swap! curbuf update :b_op_end assoc :lnum (:lnum (:op_end oap)) :col (:col (:op_start oap)))
                            (swap! curbuf assoc :b_op_end (:op_start oap)))
                        [win oap true]
                    ))
            ))
    ))

;; Adjust end of operating area for ending on a multi-byte character.
;; Used for deletion.

(defn- #_oparg_C mb-adjust-opend [#_oparg_C oap]
    (if (:inclusive oap)
        (let [#_Bytes s (ml-get (:lnum (:op_end oap)))]
            (update-in oap [:op_end :col] #(+ % (us-tail-off s, (.plus s %)))))
        oap
    ))

;; Replace a whole area with one character.

(defn- #_[window_C oparg_C boolean] op-replace? [#_window_C win, #_oparg_C oap, #_int c]
    (if (or (:ml_empty (:b_ml @curbuf)) (:empty oap))
        [win oap true] ;; nothing to do
        (let [oap (mb-adjust-opend oap)]
            (when' (u-save win, (dec (:lnum (:op_start oap))), (inc (:lnum (:op_end oap)))) => [win oap false]
                (let [#_boolean had_ctrl_v_cr (any == c -1 -2)
                      c (if had_ctrl_v_cr (if (== c -1) (byte \return) (byte \newline)) c)
                      [win oap]
                        (cond (:block_mode oap) ;; block mode replace
                            (let [#_boolean is_MAX (== (:w_curswant win) MAXCOL)]
                                (loop-when [win win oap oap #_Bytes after_p nil] (<= (:lnum (:w_cursor win)) (:lnum (:op_end oap))) => [win oap]
                                    (let [win (assoc-in win [:w_cursor :col] 0) ;; make sure cursor position is valid
                                          #_block_def_C bd (block-prep win, oap, is_MAX, (:lnum (:w_cursor win)), true)]
                                        (if (and (zero? (:textlen bd)) (or (== @virtual_op FALSE) (:is_MAX bd)))
                                            (recur (update-in win [:w_cursor :lnum] inc) oap after_p) ;; nothing to replace
                                            ;; If we split a TAB, it may be replaced by several characters, thus the number of chars may increase!
                                            ;; If the range starts in virtual space, count the initial "coladd" offset as part of "startspaces".
                                            (let [[win bd #_int n] ;; number of extra chars required
                                                    (if (and (!= @virtual_op FALSE) (:is_short bd) (eos? (:textstart bd)))
                                                        (let [#_pos_C vpos (pos_C. (:lnum (:w_cursor win)) 0 0)
                                                              [win vpos] (getvpos win, vpos, (:start_vcol oap))
                                                              bd (update bd :startspaces + (:coladd vpos))]
                                                            [win bd (:startspaces bd)])
                                                        ;; allow for pre-spaces
                                                        [win bd (if (non-zero? (:startspaces bd)) (dec (:start_char_vcols bd)) 0)])
                                                  ;; allow for post-spaces
                                                  n (+ n (if (and (non-zero? (:endspaces bd)) (not (:is_oneChar bd)) (< 0 (:end_char_vcols bd))) (dec (:end_char_vcols bd)) 0))
                                                  ;; Figure out how many characters to replace.
                                                  #_int r (inc (- (:end_vcol oap) (:start_vcol oap)))
                                                  r (if (and (:is_short bd) (or (== @virtual_op FALSE) (:is_MAX bd))) (- r (inc (- (:end_vcol oap) (:end_vcol bd)))) r)
                                                  ;; A double-wide character can be replaced only up to half the times.
                                                  [bd n r]
                                                    (if (< 1 (utf-char2cells c))
                                                        (let [[bd n] (if (and (non-zero? (& r 1)) (not (:is_short bd))) [(update bd :endspaces inc) (inc n)] [bd n])]
                                                            [bd n (/ r 2)])
                                                        [bd n r])
                                                  ;; compute bytes needed, move character count to "x"
                                                  #_int x r r (* r (utf-char2len c))
                                                  ;; oldlen includes textlen, so don't double count
                                                  n (+ n (- r (:textlen bd)))
                                                  #_Bytes o's (ml-get (:lnum (:w_cursor win))) #_int o'len (STRLEN o's)
                                                  #_Bytes s (Bytes. (+ o'len n 1))
                                                  ;; copy up to deleted part
                                                  _ (BCOPY s, o's, (:textcol bd))
                                                  o's (.plus o's (+ (:textcol bd) (:textlen bd)))
                                                  ;; insert pre-spaces
                                                  _ (BFILL s, (:textcol bd), (byte \space), (:startspaces bd))
                                                  ;; insert replacement chars ;; -1/-2 is used for entering CR literally
                                                  after_p
                                                    (if (or had_ctrl_v_cr (and (!= c (byte \return)) (!= c (byte \newline))))
                                                        (do (loop-when-recur [n (STRLEN s) x x] (< 0 x) [(+ n (utf-char2bytes c, (.plus s n))) (dec x)])
                                                            (when (not (:is_short bd))
                                                                ;; insert post-spaces
                                                                (BFILL s, (STRLEN s), (byte \space), (:endspaces bd))
                                                                ;; copy the part after the changed part
                                                                (BCOPY s, (STRLEN s), o's, 0, (inc (STRLEN o's))))
                                                            after_p)
                                                        ;; Replacing with \r or \n means splitting the line.
                                                        (let [after_p (Bytes. (- (+ o'len n 1) (STRLEN s)))]
                                                            (BCOPY after_p, o's, (inc (STRLEN o's)))
                                                            after_p)
                                                    )]
                                                ;; replace the line
                                                (ml-replace (:lnum (:w_cursor win)), s)
                                                (let [[win oap]
                                                        (when' (some? after_p) => [win oap]
                                                            (ml-append (:lnum (:w_cursor win)), after_p)
                                                            (let [win (update-in win [:w_cursor :lnum] inc)
                                                                  win (appended-lines-mark win, (:lnum (:w_cursor win)), 1)]
                                                                [win (update-in oap [:op_end :lnum] inc)])
                                                        )]
                                                    (recur (update-in win [:w_cursor :lnum] inc) oap after_p)
                                                ))
                                        ))
                                ))
                        :else ;; MCHAR and MLINE motion replace
                            (let [[win oap]
                                    (cond (== (:motion_type oap) MLINE)
                                        (let [oap (assoc-in oap [:op_start :col] 0)
                                              win (assoc-in win [:w_cursor :col] 0)
                                              oap (assoc-in oap [:op_end :col] (STRLEN (ml-get (:lnum (:op_end oap)))))
                                              oap (if (non-zero? (:col (:op_end oap))) (update-in oap [:op_end :col] dec) oap)]
                                            [win oap])
                                    (not (:inclusive oap))
                                        [win (update oap :op_end decp)]
                                    :else
                                        [win oap]
                                    )]
                                (loop-when [win win oap oap] (ltoreq (:w_cursor win), (:op_end oap)) => [win oap]
                                    (let [#_int k (gchar-cursor win)
                                          [win oap]
                                            (cond (!= k NUL)
                                                (let [cl (utf-char2len c) kl (utf-char2len k)]
                                                    (if (or (< 1 cl) (< 1 kl))
                                                        ;; This is slow, but it handles replacing a single-byte with a multi-byte and the other way around.
                                                        (let [oap (if (== (:lnum (:w_cursor win)) (:lnum (:op_end oap))) (update-in oap [:op_end :col] + (- cl kl)) oap)
                                                              o'State @State _ (reset! State REPLACE)
                                                              win (ins-char win, c)]
                                                            (reset! State o'State)
                                                            ;; Backup to the replaced character.
                                                            [(dec-cursor win, false) oap])
                                                        (let [[win oap]
                                                                (when' (== k TAB) => [win oap]
                                                                    ;; "op_end" has to be recalculated when the tab breaks
                                                                    (let [#_int end_vcol
                                                                            (when' (== (:lnum (:w_cursor win)) (:lnum (:op_end oap))) => 0
                                                                                (getviscol2 win, (:col (:op_end oap)), (:coladd (:op_end oap))))
                                                                          win (coladvance-force win, (getviscol win))]
                                                                        (if (== (:lnum (:w_cursor win)) (:lnum (:op_end oap)))
                                                                            (let [[win ?] (getvpos win, (:op_end oap), end_vcol)] [win (assoc oap :op_end ?)])
                                                                            [win oap]
                                                                        ))
                                                                )]
                                                            (.be (ml-get (:lnum (:w_cursor win))) (:col (:w_cursor win)), c)
                                                            [win oap])
                                                    ))
                                            (and (!= @virtual_op FALSE) (== (:lnum (:w_cursor win)) (:lnum (:op_end oap))))
                                                (let [#_int vcols (:coladd (:op_end oap))
                                                      vcols (if (and (== (:lnum (:w_cursor win)) (:lnum (:op_start oap)))
                                                                     (== (:col (:op_start oap)) (:col (:op_end oap)))
                                                                     (non-zero? (:coladd (:op_start oap))))
                                                                (- vcols (:coladd (:op_start oap)))
                                                                vcols)
                                                      ;; "op_end" has been trimmed, so it's effectively inclusive;
                                                      ;; as a result, an extra +1 must be counted, so we don't trample the NUL byte.
                                                      win (coladvance-force win, (inc (getviscol2 win, (:col (:op_end oap)), (:coladd (:op_end oap)))))
                                                      win (update-in win [:w_cursor :col] - (inc vcols))
                                                      win (loop-when [win win vcols vcols] (<= 0 vcols) => win
                                                            (.be (ml-get (:lnum (:w_cursor win))) (:col (:w_cursor win)), c)
                                                            (let [[win ?] (inc-cursor? win, false)]
                                                                (recur-if (!= ? -1) [win (dec vcols)] => win))
                                                        )]
                                                    [win oap])
                                            :else
                                                [win oap]
                                            )]
                                        ;; Advance to next character, stop at the end of the file.
                                        (let [[win ?] (inc-cursor? win, false)]
                                            (recur-if (!= ? -1) [win oap] => [win oap]))
                                    ))
                            ))
                      win (-> win (assoc :w_cursor (:op_start oap)) (check-cursor))]
                    (swap! curbuf changed-lines (:lnum (:op_start oap)), (:col (:op_start oap)), (inc (:lnum (:op_end oap))), 0)
                    ;; Set '[ and '] marks.
                    (swap! curbuf assoc :b_op_start (:op_start oap) :b_op_end (:op_end oap))
                    [win oap true])
            ))
    ))

;; Handle the (non-standard vi) tilde operator.  Also for "gu", "gU" and "g?".

(defn- #_[window_C oparg_C] op-tilde [#_window_C win, #_oparg_C oap]
    (when' (u-save win, (dec (:lnum (:op_start oap))), (inc (:lnum (:op_end oap)))) => [win oap]
        (let [[win oap #_boolean changed]
                (if (:block_mode oap)
                    (let [[win changed]
                            (loop-when [win win #_pos_C pos (:op_start oap) changed false] (<= (:lnum pos) (:lnum (:op_end oap))) => [win changed]
                                (let [#_block_def_C bd (block-prep win, oap, false, (:lnum pos), false)
                                      pos (assoc pos :col (:textcol bd))
                                      [win pos ?] (swapchars win, (:op_type oap), pos, (:textlen bd)) changed (or ? changed)]
                                    (recur win (update pos :lnum inc) changed))
                            )]
                        (when changed
                            (swap! curbuf changed-lines (:lnum (:op_start oap)), 0, (inc (:lnum (:op_end oap))), 0))
                        [win oap changed]
                    )
                    (let [#_pos_C pos (:op_start oap)
                          [oap pos]
                            (cond (== (:motion_type oap) MLINE)
                                (let [oap (assoc-in oap [:op_start :col] 0)
                                      oap (assoc-in oap [:op_end :col] (STRLEN (ml-get (:lnum (:op_end oap)))))
                                      oap (if (non-zero? (:col (:op_end oap))) (update-in oap [:op_end :col] dec) oap)]
                                    [oap (assoc pos :col 0)])
                            (not (:inclusive oap))
                                [(update oap :op_end decp) pos]
                            :else
                                [oap pos])
                          [win changed]
                            (if (== (:lnum pos) (:lnum (:op_end oap)))
                                (let [[win _ ?] (swapchars win, (:op_type oap), pos, (inc (- (:col (:op_end oap)) (:col pos))))] [win ?])
                                (loop [win win pos pos changed false]
                                    (let [[win pos ?]
                                            (swapchars win, (:op_type oap), pos, (if (== (:lnum pos) (:lnum (:op_end oap))) (inc (:col (:op_end oap))) (STRLEN (ml-get-pos pos))))
                                          changed (or ? changed)]
                                        (if (ltoreq (:op_end oap), pos)
                                            [win changed]
                                            (let [[pos ?] (incp? pos)]
                                                (recur-if (!= ? -1) [win pos changed] => [win changed])
                                            ))
                                    ))
                            )]
                        (when changed
                            (swap! curbuf changed-lines (:lnum (:op_start oap)), (:col (:op_start oap)), (inc (:lnum (:op_end oap))), 0))
                        [win oap changed]
                    ))
              ;; No change: need to remove the Visual selection.
              _ (when (and (not changed) (:is_VIsual oap))
                    (redraw-curbuf-later INVERTED))
              ;; Set '[ and '] marks.
              _ (swap! curbuf assoc :b_op_start (:op_start oap), :b_op_end (:op_end oap))
              win (let-when [n (:line_count oap)] (< @p_report n) => win
                    (if (== n 1) (msg win, (u8 "1 line changed")) (msg* win, (u8 "%ld lines changed"), n))
                )]
            [win oap])
    ))

;; Invoke swapchar() on "len" bytes at position "pos".
;; "pos" is advanced to just after the changed characters.
;; "len" is rounded up to include the whole last multi-byte character.
;; Also works correctly when the number of bytes changes.
;; Returns true if any character has been changed.

(defn- #_[window_C pos_C boolean] swapchars [#_window_C win, #_int op_type, #_pos_C pos, #_int len]
    (loop-when [win win pos pos changed false len len] (< 0 len) => [win pos changed]
        (let [n (us-ptr2len-cc (ml-get-pos pos)) len (- len (if (< 0 n) (dec n) 0)) ;; we're counting bytes, not characters
              [win pos ?] (swapchar win, op_type, pos) changed (or ? changed)
              [pos ?] (incp? pos)]
            (recur-if (!= ? -1) [win pos changed (dec len)] => [win pos changed])) ;; at end of file
    ))

;; If op_type == OP_UPPER: make uppercase,
;; if op_type == OP_LOWER: make lowercase,
;; if op_type == OP_ROT13: do rot13 encoding,
;; else swap case of character at "pos".
;; Returns true when something actually changed.

(defn- #_[window_C pos_C boolean] swapchar [#_window_C win, #_int op_type, #_pos_C pos]
    ;; Only do rot13 encoding for ASCII characters.
    (let-when [#_int c (gchar-pos pos)] (or (< c 0x80) (!= op_type OP_ROT13)) => [win pos false]
        (let [[win pos]
                (when' (and (== op_type OP_UPPER) (== c 0xdf)) => [win pos]
                    (let [o'cursor (:w_cursor win)
                          ;; Special handling of German sharp s: change to "SS".
                          win (-> win
                            (assoc :w_cursor pos)
                            (del-char false)
                            (ins-char (byte \S))
                            (ins-char (byte \S))
                            (assoc :w_cursor o'cursor)
                          )]
                        [win (incp pos)])
                )]
            (let-when [#_int nc (cond
                        (utf-islower c) (cond (== op_type OP_ROT13) (rot13 c, (byte \a)) (!= op_type OP_LOWER) (utf-toupper c) :else c)
                        (utf-isupper c) (cond (== op_type OP_ROT13) (rot13 c, (byte \A)) (!= op_type OP_UPPER) (utf-tolower c) :else c)
                        :else c)] (!= nc c) => [win pos false]
                (let [win (if (or (<= 0x80 c) (<= 0x80 nc))
                            (let [o'cursor (:w_cursor win)
                                  win (assoc win :w_cursor pos)
                                  ;; don't use del-char(), it also removes composing chars
                                  win (del-bytes win, (us-ptr2len (ml-get-cursor win)), false, false)
                                  win (ins-char win, nc)]
                                (assoc win :w_cursor o'cursor))
                            (do (.be (ml-get (:lnum pos)) (:col pos), nc)
                                win)
                        )]
                    [win pos true])
            ))
    ))

;; Insert and append operators for Visual mode.

(defn- #_[window_C oparg_C] op-insert [#_window_C win, #_oparg_C oap, #_long count1]
    ;; edit() changes this - record it for OP_APPEND
    (let-when [#_block_def_C bd (assoc (NEW_block_def_C) :is_MAX (== (:w_curswant win) MAXCOL))
          ;; visual block is still marked, get rid of it now
          win (assoc-in win [:w_cursor :lnum] (:lnum (:op_start oap)))
          win (update-screen win, INVERTED)
          [win [bd #_int pre_textlen :as _]]
            (when' (:block_mode oap) => [win [bd 0]]
                ;; When 'virtualedit' is used, need to insert the extra spaces before doing block-prep().
                ;; When only "block" is used, virtual edit is already disabled,
                ;; but still need it when calling coladvance-force().
                (let-when [[win ?]
                        (when' (< 0 (:coladd (:w_cursor win))) => [win nil]
                            (let [o've_flags @ve_flags _ (reset! ve_flags VE_ALL)]
                                (if (u-save-cursor win)
                                    (let [win (coladvance-force win, (if (== (:op_type oap) OP_APPEND) (inc (:end_vcol oap)) (getviscol win)))
                                          win (if (== (:op_type oap) OP_APPEND) (update-in win [:w_cursor :col] dec) win)]
                                        (reset! ve_flags o've_flags)
                                        [win nil])
                                    (do (reset! ve_flags o've_flags)
                                        [win :abort])
                                ))
                        )] (not ?) => [win nil]

                    ;; Get the info about the block before entering the text.
                    (let [bd (block-prep win, oap, (:is_MAX bd), (:lnum (:op_start oap)), true)
                          #_Bytes s (.plus (ml-get (:lnum (:op_start oap))) (:textcol bd))
                          s (if (== (:op_type oap) OP_APPEND) (.plus s (:textlen bd)) s)]
                        [win [bd (STRLEN s)]]
                    ))
            )] (some? _) => [win oap]

        (let-when [[win [bd :as _]]
                (when' (== (:op_type oap) OP_APPEND) => [win [bd]]
                    (if (and (:block_mode oap) (zero? (:coladd (:w_cursor win))))
                        ;; Move the cursor to the character right of the block.
                        (let [win (assoc win :w_set_curswant true)
                              win (loop-when-recur win
                                                   (and (non-eos? (ml-get-cursor win)) (< (:col (:w_cursor win)) (+ (:textcol bd) (:textlen bd))))
                                                   (update-in win [:w_cursor :col] inc)
                                                => win)]
                            (when' (and (:is_short bd) (not (:is_MAX bd))) => [win [bd]]
                                ;; First line was too short, make it longer and adjust the values in "bd".
                                (when' (u-save-cursor win) => [win nil]
                                    (let [win (loop-when-recur [win win _ 0] (< _ (:endspaces bd)) [(ins-char win, (byte \space)) (inc _)] => win)]
                                        [win [(update bd :textlen + (:endspaces bd))]]
                                    ))
                            ))
                        (let [win (-> win (assoc :w_cursor (:op_end oap)) (check-cursor-col))
                              ;; Works just like an 'i'nsert on the next character.
                              win (when' (and (not (lineempty (:lnum (:w_cursor win)))) (!= (:start_vcol oap) (:end_vcol oap))) => win
                                    (inc-cursor win, false)
                                )]
                            [win [bd]]
                        ))
                )] (some? _) => [win oap]

            (let [#_pos_C t1 (:op_start oap)
                  [win _] (edit? win, NUL, false, count1)
                  ;; When a tab was inserted, and the characters in front of the tab have been converted to a tab
                  ;; as well, the column of the cursor might have actually been reduced, so need to adjust here.
                  oap (when' (and (== (:lnum t1) (:lnum (:b_op_start_orig @curbuf))) (ltpos (:b_op_start_orig @curbuf), t1)) => oap
                        (assoc oap :op_start (:b_op_start_orig @curbuf))
                    )]
                ;; If user has moved off this line, we don't know what to do, so do nothing.
                ;; Also don't repeat the insert when Insert mode ended with CTRL-C.
                (cond (or (!= (:lnum (:w_cursor win)) (:lnum (:op_start oap))) @got_int)
                    [win oap]
                (:block_mode oap)
                    ;; The user may have moved the cursor before inserting something, try to adjust the block for that.
                    (let [[oap pre_textlen]
                            (cond (or (!= (:lnum (:op_start oap)) (:lnum (:b_op_start_orig @curbuf))) (:is_MAX bd))
                                [oap pre_textlen]
                            (and (== (:op_type oap) OP_INSERT)
                                       (!= (+ (:col (:op_start oap)) (:coladd (:op_start oap))) (+ (:col (:b_op_start_orig @curbuf)) (:coladd (:b_op_start_orig @curbuf)))))
                                (let [#_int t (getviscol2 win, (:col (:b_op_start_orig @curbuf)), (:coladd (:b_op_start_orig @curbuf)))
                                      oap (assoc-in oap [:op_start :col] (:col (:b_op_start_orig @curbuf)))
                                      pre_textlen (- pre_textlen (- t (:start_vcol oap)))]
                                    [(assoc oap :start_vcol t) pre_textlen])
                            (and (== (:op_type oap) OP_APPEND)
                                 (<= (+ (:col (:b_op_start_orig @curbuf)) (:coladd (:b_op_start_orig @curbuf))) (+ (:col (:op_end oap)) (:coladd (:op_end oap)))))
                                (let [#_int t (getviscol2 win, (:col (:b_op_start_orig @curbuf)), (:coladd (:b_op_start_orig @curbuf)))
                                      oap (assoc-in oap [:op_start :col] (:col (:b_op_start_orig @curbuf)))
                                      ;; reset "pre_textlen" to the value of OP_INSERT
                                      pre_textlen (- (+ pre_textlen (:textlen bd)) (- t (:start_vcol oap)))]
                                    [(assoc oap :start_vcol t :op_type OP_INSERT) pre_textlen])
                            :else
                                [oap pre_textlen])
                          ;; Spaces and tabs in the indent may have changed to other spaces and tabs.
                          ;; Get the starting column again and correct the length.
                          ;; Don't do this when "$" used, end-of-line will have changed.
                          #_block_def_C bd2 (block-prep win, oap, false, (:lnum (:op_start oap)), true)
                          [bd bd2 pre_textlen]
                            (if (or (not (:is_MAX bd)) (< (:textlen bd2) (:textlen bd)))
                                (let [[bd2 pre_textlen]
                                        (if (== (:op_type oap) OP_APPEND)
                                            (let [pre_textlen (+ pre_textlen (- (:textlen bd2) (:textlen bd)))]
                                                [(if (non-zero? (:endspaces bd2)) (update bd2 :textlen dec) bd2) pre_textlen])
                                            [bd2 pre_textlen]
                                        )]
                                    [(assoc bd :textcol (:textcol bd2) :textlen (:textlen bd2)) bd2 pre_textlen])
                                [bd bd2 pre_textlen])
                          ;; Subsequent calls to ml-get() flush the "s" data - take a copy of the required string.
                          #_Bytes s (.plus (ml-get (:lnum (:op_start oap))) (:textcol bd))
                          s (if (== (:op_type oap) OP_APPEND) (.plus s (:textlen bd)) s)]
                        (when' (<= 0 pre_textlen) => [win oap]
                            (let [#_int ins_len (- (STRLEN s) pre_textlen)]
                                (when' (< 0 ins_len) => [win oap]
                                    (let [#_Bytes ins_text (STRNDUP s, ins_len)]
                                        ;; block handled here
                                        (when (u-save win, (:lnum (:op_start oap)), (inc (:lnum (:op_end oap))))
                                            (block-insert win, oap, ins_text, (== (:op_type oap) OP_INSERT), (:is_MAX bd)))
                                        [(-> win (assoc-in [:w_cursor :col] (:col (:op_start oap))) (check-cursor)) oap])
                                ))
                        ))
                :else
                    [win oap])
            ))
    ))

;; Handle a change operation.
;;
;; Return true if edit() returns because of a CTRL-O command.

(defn- #_[window_C oparg_C boolean] op-change? [#_window_C win, #_oparg_C oap]
    (let-when [#_int l
            (when' (== (:motion_type oap) MLINE) => (:col (:op_start oap))
                (when (and (not @p_paste) @(:b_p_si @curbuf))
                    (reset! can_si true)) ;; it's like opening a new line, do 'si'
                0)
          ;; First delete the text in the region.  In an empty buffer only need to save for undo.
          [win oap ?] (if (:ml_empty (:b_ml @curbuf)) [win oap (u-save-cursor win)] (op-delete? win, oap))
    ] ? => [win oap false]

        (let [win (when' (and (< (:col (:w_cursor win)) l) (not (lineempty (:lnum (:w_cursor win)))) (== @virtual_op FALSE)) => win
                    (inc-cursor win, false))
              ;; Check for still on same line (<CR> in inserted text meaningless), skip blank lines too.
              [win #_int pre_textlen #_int pre_indent #_int textcol]
                (when' (:block_mode oap) => [win 0 0 0]
                    ;; Add spaces before getting the current line length.
                    (let [win (when' (and (!= @virtual_op FALSE) (or (< 0 (:coladd (:w_cursor win))) (== (gchar-cursor win) NUL))) => win
                                (coladvance-force win, (getviscol win)))
                          #_Bytes s (ml-get (:lnum (:op_start oap)))]
                        [win (STRLEN s) (BDIFF (skipwhite s), s) (:col (:w_cursor win))]
                    ))
              [win #_boolean retval] (edit? win, NUL, false, 1)]
            ;; In Visual block mode, handle copying the new text to all lines of the block.
            ;; Don't repeat the insert when Insert mode ended with CTRL-C.
            (when' (and (:block_mode oap) (!= (:lnum (:op_start oap)) (:lnum (:op_end oap))) (not @got_int)) => [win oap retval]
                ;; Auto-indenting may have changed the indent.
                ;; If the cursor was past the indent, exclude that indent change from the inserted text.
                (let [#_Bytes s (ml-get (:lnum (:op_start oap)))
                      [pre_textlen textcol]
                        (if (< pre_indent textcol)
                            (let [#_int i (BDIFF (skipwhite s), s)]
                                [(+ pre_textlen (- i pre_indent)) (+ textcol (- i pre_indent))])
                            [pre_textlen textcol])
                      #_int ins_len (- (STRLEN s) pre_textlen)
                      win (when' (< 0 ins_len) => win
                            ;; Subsequent calls to ml-get() flush the "s" data - take a copy of the inserted text.
                            (let [#_Bytes ins_text (STRNDUP (.plus s textcol), ins_len)
                                  win (loop-when [win win #_long lnum (inc (:lnum (:op_start oap)))] (<= lnum (:lnum (:op_end oap))) => (check-cursor win)
                                        (let [#_block_def_C bd (block-prep win, oap, false, lnum, true)
                                              win (when' (or (not (:is_short bd)) (!= @virtual_op FALSE)) => win
                                                    (let [#_pos_C vpos (pos_C. lnum 0 0)
                                                          ;; If the block starts in virtual space, count the initial "coladd" offset as part of "startspaces".
                                                          [win vpos] (if (:is_short bd) (getvpos win, vpos, (:start_vcol oap)) [win vpos])
                                                          #_Bytes p (ml-get lnum)
                                                          #_Bytes t (Bytes. (+ (STRLEN p) (:coladd vpos) ins_len 1))
                                                          _ (BCOPY t, p, (:textcol bd))           #_int i (:textcol bd)
                                                          _ (BFILL t, i, (byte \space), (:coladd vpos)) i (+ i (:coladd vpos))
                                                          _ (BCOPY t, i, ins_text, 0, ins_len)          i (+ i ins_len)
                                                          p (.plus p (:textcol bd))
                                                          _ (BCOPY t, i, p, 0, (inc (STRLEN p)))]
                                                        (ml-replace lnum, t)
                                                        win)
                                                )]
                                            (recur win (inc lnum)))
                                    )]
                                (swap! curbuf changed-lines (inc (:lnum (:op_start oap))), 0, (inc (:lnum (:op_end oap))), 0)
                                win)
                        )]
                    [win oap retval])
            ))
    ))

;; Yank the text between "oap.op_start" and "oap.op_end" into a yank register.
;; If we are to append (uppercase regname), we first yank into a new register, then concatenate with the old one.
;;
;; Return false for failure, true otherwise.

(defn- #_[window_C oparg_C boolean] op-yank? [#_window_C win, #_oparg_C oap, #_boolean deleting, #_boolean mess]
    (cond (and (non-zero? (:regname oap)) (not (valid-yank-reg (:regname oap), true))) ;; check for read-only register
        [(beep-flush win) oap false]
    (== (:regname oap) (byte \_)) ;; black hole: nothing to do
        [win oap true]
    :else
        (let [oap (if (any == (:regname oap) (byte \*) (byte \+)) (assoc oap :regname 0) oap)
              _ (when (not deleting) ;; otherwise op-delete() already called get-yank-register()
                    (get-yank-register (:regname oap), true))
              #_int y'lines (:line_count oap) #_byte y'type (:motion_type oap) #_long y'end (:lnum (:op_end oap))
              ;; If the cursor was in column 1 before and after the movement,
              ;; and the operator is not inclusive, the yank is always linewise.
              [y'lines y'type y'end]
                (if (and (== y'type MCHAR) (zero? (:col (:op_start oap))) (zero? (:col (:op_end oap))) (not (:inclusive oap))
                         (or (not (:is_VIsual oap)) (at? @p_sel (byte \o))) (not (:block_mode oap)) (< 1 y'lines))
                    [(dec y'lines) MLINE (dec y'end)]
                    [y'lines y'type y'end])
              #_yankreg_C reg (yankreg_C. (Bytes* y'lines) y'lines y'type 0)
              reg (if (:block_mode oap) ;; Visual block mode.
                    (let [#_int n (- (:end_vcol oap) (:start_vcol oap)) n (if (and (== (:w_curswant win) MAXCOL) (< 0 n)) (dec n) n)]
                        (assoc reg :y_type MBLOCK :y_width n))
                    reg)
              reg (loop-when [reg reg #_int i 0 #_long lnum (:lnum (:op_start oap))] (<= lnum y'end) => reg
                    (let [reg (condp == (:y_type reg)
                                MBLOCK (yank-copy-line reg, i, (block-prep win, oap, false, lnum, false))
                                MLINE  (assoc-in reg [:y_array i] (STRDUP (ml-get lnum)))
                                MCHAR  (yank-copy-line reg, i, (char-prep win, oap, lnum))
                            )]
                        (recur reg (inc i) (inc lnum)))
                )]
            ;; append the new block to the old one
            (let-when [#_yankreg_C o'reg (... @y_regs @y_curr)] (and @y_append (some? (:y_array o'reg))) => (swap! y_regs assoc @y_curr reg)
                (let [#_Bytes* a (Bytes* (+ (:y_size o'reg) (:y_size reg)))
                      [a #_int n] (loop-when-recur [a a n 0] (< n (:y_size o'reg)) [(assoc a n (... (:y_array o'reg) n)) (inc n)] => [a n])
                      o'reg (if (== y'type MLINE) (assoc o'reg :y_type MLINE) o'reg) ;; MLINE overrides MCHAR and MBLOCK
                      ;; Concatenate the last line of the old block with the first line of the new block, unless being Vi compatible.
                      [a n #_int i]
                        (if (and (== (:y_type o'reg) MCHAR) (nil? (vim-strbyte @p_cpo, CPO_REGAPPEND)))
                            (let [#_Bytes s (Bytes. (+ (STRLEN (... a (dec (:y_size o'reg)))) (STRLEN (... (:y_array reg) 0)) 1))
                                  _ (STRCPY s, (... a (dec n))) _ (STRCAT s, (... (:y_array reg) 0))]
                                [(assoc a (dec n) s) n 1])
                            [a n 0])
                      [a n] (loop-when-recur [a a n n i i] (< i (:y_size reg)) [(assoc a n (... (:y_array reg) i)) (inc n) (inc i)] => [a n])
                      o'reg (assoc o'reg :y_array a :y_size n)]
                    (swap! y_regs assoc @y_curr o'reg)
                ))
            (let [win (if @(:wo_rnu (:w_options win)) (redraw-later win, SOME_VALID) win) ;; cursor moved to start
                  win (when' mess => win ;; Display message about yank?
                        (let-when [y'lines (if (and (== y'type MCHAR) (not (:block_mode oap)) (== y'lines 1)) 0 y'lines)] (< @p_report y'lines) => win
                            ;; redisplay now, so message is not deleted
                            (let [win (update-topline-redraw win)]
                                (if (== y'lines 1)
                                    (msg win, (if (:block_mode oap) (u8 "block of 1 line yanked") (u8 "1 line yanked")))
                                    (msg* win, (if (:block_mode oap) (u8 "block of %ld lines yanked") (u8 "%ld lines yanked")), y'lines))
                            ))
                    )]
                ;; Set '[ and '] marks.
                (swap! curbuf assoc :b_op_start (:op_start oap))
                (swap! curbuf assoc :b_op_end (:op_end oap))
                (when (and (== y'type MLINE) (not (:block_mode oap)))
                    (swap! curbuf assoc-in [:b_op_start :col] 0)
                    (swap! curbuf assoc-in [:b_op_end :col] MAXCOL))
                [win oap true]
            ))
    ))

(defn- #_yankreg_C yank-copy-line [#_yankreg_C reg, #_int i, #_block_def_C bd]
    (let [n1 (:startspaces bd) n2 (:textlen bd) n3 (:endspaces bd)
          s (Bytes. (+ n1 n2 n3 1))
          _ (BFILL s, 0, (byte \space), n1) s (.plus s n1)
          _ (BCOPY s, (:textstart bd), n2)  s (.plus s n2)
          _ (BFILL s, 0, (byte \space), n3) s (.plus s n3)]
        (assoc-in reg [:y_array i] (eos! s))
    ))

;; Put contents of register "regname" into the text.
;; Caller must check "regname" to be valid!
;;
;; "dir": BACKWARD for 'P', FORWARD for 'p'

(defn- #_window_C do-put [#_window_C win, #_int regname, #_int dir, #_int count, #_int flags]
    ;; Adjust register name for "unnamed" in 'clipboard'.
    (let [regname (adjust-clip-reg regname) _ (may-get-selection regname)
          o'indent (if (flag? flags PUT_FIXINDENT) (get-indent win) 0)]
        (swap! curbuf assoc :b_op_start (:w_cursor win) :b_op_end (:w_cursor win)) ;; default for '[ and '] marks
        ;; Using inserted text works differently, because the register includes special characters (newlines, etc.).
        (if (== regname (byte \.))
            (let [[win _] (stuff-inserted? win, (if (== dir FORWARD) (if (== count -1) (byte \o) (byte \a)) (if (== count -1) (byte \O) (byte \i))), count, false)]
                ;; Putting the text is done later, so can't really move the cursor to the next character.
                ;; Use "l" to simulate it.
                (when (and (flag? flags PUT_CURSEND) (!= (gchar-cursor win) NUL))
                    (stuff-char (byte \l)))
                win)
            ;; For special registers, like ':' (last command line), we have to create a fake yank register.
            (let-when [a'content (atom (#_Bytes object nil)) [win ?] (get-spec-reg? win, regname, a'content)] (or (not ?) (some? @a'content)) => win
                (u-save win, (:lnum (:w_cursor win)), (inc (:lnum (:w_cursor win))))
                (let [#_yankreg_C reg
                        (if (some? @a'content)
                            (if (== regname (byte \=))
                                ;; For the = register we need to split the string at NL characters.
                                ;; Loop twice: count the number of lines, then save them.
                                (loop [reg (yankreg_C. nil 0 MCHAR 0)]
                                    (let [reg (loop-when [reg reg #_Bytes s @a'content] (some? s) => reg
                                                (let-when [reg (if (some? (:y_array reg)) (assoc-in reg [:y_array (:y_size reg)] s) reg)
                                                      reg (update reg :y_size inc)
                                                      s (vim-strchr s, (byte \newline))] (some? s) => reg
                                                    (when (some? (:y_array reg))
                                                        (eos! s))
                                                    ;; A trailing '\n' makes the register linewise.
                                                    (let-when [s (.plus s 1)] (non-eos? s) => (assoc reg :y_type MLINE)
                                                        (recur reg s)
                                                    ))
                                            )]
                                        (if (some? (:y_array reg)) reg (recur (assoc reg :y_array (Bytes* (:y_size reg)) :y_size 0)))
                                    ))
                                (yankreg_C. [ @a'content ] 1 MCHAR 0)) ;; use fake one-line yank register
                            (let [#_int y (get-yank-register regname, false)]
                                (... @y_regs y)
                            ))
                      win (let-when [a'nr_lines (atom (long 0))
                              [win dir abort]
                                (if (== (:y_type reg) MLINE)
                                    (let-when [[dir abort]
                                            (if (flag? flags PUT_LINE_SPLIT) ;; "p" or "P" in Visual mode: split the lines to put the text in between
                                                (when' (u-save-cursor win) => [dir true]
                                                    (let [#_Bytes s (STRDUP (ml-get-cursor win))
                                                          _ (ml-append (:lnum (:w_cursor win)), s)
                                                          s (STRNDUP (ml-get (:lnum (:w_cursor win))), (:col (:w_cursor win)))
                                                          _ (ml-replace (:lnum (:w_cursor win)), s)]
                                                        (swap! a'nr_lines inc)
                                                        [FORWARD false]
                                                    ))
                                                [dir false]
                                            )] (not abort) => [win dir true]

                                        (let [[win dir]
                                                (if (flag? flags PUT_LINE_FORWARD)
                                                    ;; Must be "p" for a Visual block, put lines below the block.
                                                    [(assoc win :w_cursor (:vi_end (:b_visual @curbuf))) FORWARD]
                                                    [win dir]
                                                )]
                                            (swap! curbuf assoc :b_op_start (:w_cursor win) :b_op_end (:w_cursor win)) ;; default for '[ and '] marks
                                            [win dir false]
                                        ))
                                    [win dir false]
                                )] (not abort) => win

                            (let-when [reg (if (flag? flags PUT_LINE) (assoc reg :y_type MLINE) reg)] ;; :put command or "p" in Visual line mode
                                      (and (some? (:y_array reg)) (non-zero? (:y_size reg)))
                                   => (emsg* win, (u8 "E353: Nothing in register %s"), (if (zero? regname) (u8 "\"") (transchar regname)))

                                (let-when [abort
                                        (condp == (:y_type reg)
                                            MBLOCK
                                                (let [#_long lnum (min (+ (:lnum (:w_cursor win)) (:y_size reg) 1) (inc (line-count @curbuf)))]
                                                    (not (u-save win, (dec (:lnum (:w_cursor win))), lnum)))
                                            MLINE
                                                (let [#_long lnum (+ (:lnum (:w_cursor win)) (if (== dir FORWARD) 1 0))]
                                                    ;; In an empty buffer the empty line is going to be replaced, include it in the saved lines.
                                                    (not (if (bufempty) (u-save win, 0, 2) (u-save win, (dec lnum), lnum))))
                                            MCHAR
                                                (not (u-save-cursor win))
                                        )] (not abort) => win

                                    (let [win (if (and (== @ve_flags VE_ALL) (== (:y_type reg) MCHAR))
                                                (let [#_int c (gchar-cursor win) #_int a (:coladd (:w_cursor win))]
                                                    (cond (== c TAB)
                                                        ;; Don't need to insert spaces when "p" on the last position of a tab or "P" on the first position.
                                                        (if (if (== dir FORWARD) (< a (dec @(:b_p_ts @curbuf))) (< 0 a))
                                                            (coladvance-force win, (getviscol win))
                                                            (assoc-in win [:w_cursor :coladd] 0))
                                                    (or (< 0 a) (== c NUL))
                                                        (coladvance-force win, (+ (getviscol win) (if (== dir FORWARD) 1 0)))
                                                    :else
                                                        win
                                                    )
                                                )
                                                win)
                                          #_long lnum (:lnum (:w_cursor win)) a'col (atom (int (:col (:w_cursor win))))
                                          win (cond (== (:y_type reg) MBLOCK) ;; Block mode
                                                (let [#_int c (gchar-cursor win) a'endcol2 (atom (int 0))
                                                      win (if (and (== dir FORWARD) (!= c NUL))
                                                            (do (if (== @ve_flags VE_ALL)
                                                                    (getvcol win, (:w_cursor win), a'col, nil, a'endcol2)
                                                                    (getvcol win, (:w_cursor win), nil, nil, a'col))
                                                                ;; move to start of next multi-byte character
                                                                (let [win (update-in win [:w_cursor :col] + (us-ptr2len-cc (ml-get-cursor win)))]
                                                                    (swap! a'col inc)
                                                                    win
                                                                ))
                                                            (do (getvcol win, (:w_cursor win), a'col, nil, a'endcol2)
                                                                win
                                                            ))
                                                      _ (swap! a'col + (:coladd (:w_cursor win)))
                                                      win (if (and (== @ve_flags VE_ALL) (or (< 0 (:coladd (:w_cursor win))) (== (:col (:w_cursor win)) @a'endcol2)))
                                                            (let [a'col2 (atom (int (:col (:w_cursor win))))]
                                                                (when (and (== dir FORWARD) (== c NUL))
                                                                    (swap! a'col inc))
                                                                (when (and (!= dir FORWARD) (!= c NUL))
                                                                    (swap! a'col2 inc))
                                                                (when (== c TAB)
                                                                    (when (and (== dir BACKWARD) (< 0 @a'col2))
                                                                        (swap! a'col2 dec))
                                                                    (when (and (== dir FORWARD) (== (dec @a'col) @a'endcol2))
                                                                        (swap! a'col2 inc)
                                                                    ))
                                                                (assoc-in win [:w_cursor :col] @a'col2))
                                                            win)
                                                      win (assoc-in win [:w_cursor :coladd] 0)
                                                      a'totlen (atom (int 0))
                                                      [win #_block_def_C bd]
                                                        (loop-when [win win bd (NEW_block_def_C) #_int incr 0 #_int i 0] (< i (:y_size reg)) => [win bd]
                                                            (let-when [lmax (line-count @curbuf)] (< lmax (:lnum (:w_cursor win)))
                                                                (ml-append lmax, (u8 "")) ;; add a new line
                                                                (swap! a'nr_lines inc))
                                                            ;; get the old line and advance to the position to insert at
                                                            (let [o'line (ml-get (:lnum (:w_cursor win))) o'len (STRLEN o'line) a's (atom (#_Bytes object o'line))
                                                                  [incr #_int vcol]
                                                                    (loop-when [incr incr vcol 0] (and (< vcol @a'col) (non-eos? @a's)) => [incr vcol]
                                                                        (let [incr (lbr-chartabsize-adv win, o'line, a's, vcol)] ;; count a tab for what it's worth
                                                                            (recur incr (+ vcol incr))
                                                                        ))
                                                                  bd (assoc bd :textcol (BDIFF @a's, o'line))
                                                                  #_boolean shortline (or (< vcol @a'col) (and (== vcol @a'col) (eos? @a's)))
                                                                  [bd #_int delcount]
                                                                    (cond (< vcol @a'col) ;; line too short, pad with spaces
                                                                        [(assoc bd :startspaces (- @a'col vcol) :endspaces 0) 0]
                                                                    (< @a'col vcol)
                                                                        (let [bd (assoc bd :endspaces (- vcol @a'col))
                                                                              bd (assoc bd :startspaces (- incr (:endspaces bd)))
                                                                              bd (update bd :textcol dec)
                                                                              bd (update bd :textcol #(- % (us-head-off o'line, (.plus o'line %))))]
                                                                            (if (at? o'line (:textcol bd) TAB)
                                                                                ;; Only a Tab can be split into spaces.
                                                                                [bd 1]
                                                                                ;; Others will be moved to after the block, causing misalignment.
                                                                                [(assoc bd :endspaces 0) 0]
                                                                            ))
                                                                    :else
                                                                        [(assoc bd :startspaces 0 :endspaces 0) 0])
                                                                  #_int yanklen (STRLEN (... (:y_array reg) i))
                                                                  ;; calculate number of spaces required to fill right side of block
                                                                  #_int spaces (loop-when-recur [spaces (inc (:y_width reg)) #_int n 0]
                                                                                                (< n yanklen)
                                                                                                [(- spaces (lbr-chartabsize win, nil, (.plus (... (:y_array reg) i) n), 0)) (inc n)]
                                                                                             => (max 0 spaces))
                                                                  _ (reset! a'totlen (+ (* count (+ yanklen spaces)) (:startspaces bd) (:endspaces bd)))
                                                                  #_Bytes line (Bytes. (+ @a'totlen o'len 1)) #_Bytes s line
                                                                  ;; copy part up to cursor to new line
                                                                  _ (BCOPY s, o'line, (:textcol bd)) s (.plus s (:textcol bd))
                                                                  ;; may insert any spaces before new text
                                                                  _ (BFILL s, 0, (byte \space), (:startspaces bd)) s (.plus s (:startspaces bd))
                                                                  ;; insert new text
                                                                  s (loop-when [s s #_int n 0] (< n count) => s
                                                                        (let [_ (BCOPY s, (... (:y_array reg) i), yanklen) s (.plus s yanklen)
                                                                              ;; insert block's trailing spaces only if there's text behind
                                                                              s (if (and (or (< n (dec count)) (not shortline)) (non-zero? spaces))
                                                                                    (do (BFILL s, 0, (byte \space), spaces) (.plus s spaces))
                                                                                    s
                                                                                )]
                                                                            (recur s (inc n))
                                                                        ))
                                                                  ;; may insert any spaces after new text
                                                                  _ (BFILL s, 0, (byte \space), (:endspaces bd)) s (.plus s (:endspaces bd))
                                                                  ;; move the text after the cursor to the end of the line
                                                                  _ (BCOPY s, 0, o'line, (+ (:textcol bd) delcount), (inc (- o'len (:textcol bd) delcount)))]
                                                                (ml-replace (:lnum (:w_cursor win)), line)
                                                                (let [win (update-in win [:w_cursor :lnum] inc)
                                                                      win (if (zero? i) (update-in win [:w_cursor :col] + (:startspaces bd)) win)]
                                                                    (recur win bd incr (inc i))
                                                                ))
                                                        )]
                                                    (swap! curbuf changed-lines lnum, 0, (:lnum (:w_cursor win)), @a'nr_lines)
                                                    ;; Set '[ and '] marks.
                                                    (swap! curbuf assoc :b_op_start (assoc (:w_cursor win) :lnum lnum))
                                                    (swap! curbuf assoc :b_op_end (pos_C. (dec (:lnum (:w_cursor win))) (dec (+ (:textcol bd) @a'totlen)) 0))
                                                    (if (flag? flags PUT_CURSEND)
                                                        (let [win (assoc win :w_cursor (update (:b_op_end @curbuf) :col inc))]
                                                            ;; in Insert mode we might be after the NUL, correct for that
                                                            (update-in win [:w_cursor :col] min (STRLEN (ml-get (:lnum (:w_cursor win))))))
                                                        (assoc-in win [:w_cursor :lnum] lnum)
                                                    )
                                                )
                                            :else ;; Character or Line mode
                                                (let [#_int yanklen (STRLEN (... (:y_array reg) 0))
                                                      [win lnum]
                                                        (if (== (:y_type reg) MCHAR)
                                                            ;; if type is MCHAR, FORWARD is the same as BACKWARD on the next char
                                                            (let [win (if (and (== dir FORWARD) (!= (gchar-cursor win) NUL))
                                                                        (let [#_int n (us-ptr2len-cc (ml-get-cursor win))]
                                                                            ;; put it on the next of the multi-byte character
                                                                            (swap! a'col + n)
                                                                            (if (non-zero? yanklen)
                                                                                (let [win (update-in win [:w_cursor :col] + n)]
                                                                                    (swap! curbuf update-in [:b_op_end :col] + n)
                                                                                    win)
                                                                                win
                                                                            ))
                                                                        win
                                                                    )]
                                                                (swap! curbuf assoc :b_op_start (:w_cursor win))
                                                                [win lnum])
                                                            ;; Line mode: BACKWARD is the same as FORWARD on the previous line
                                                            [win (if (== dir BACKWARD) (dec lnum) lnum)]
                                                        )]
                                                    ;; simple case: insert into current line
                                                    (cond (and (== (:y_type reg) MCHAR) (== (:y_size reg) 1))
                                                        (let [#_int totlen (* count yanklen)
                                                              [win lnum]
                                                                (loop [win win lnum lnum]
                                                                    (let [win (if (< 0 totlen)
                                                                                (let [#_Bytes oldp (ml-get lnum) #_Bytes newp (Bytes. (+ (STRLEN oldp) totlen 1))
                                                                                      _ (BCOPY newp, oldp, @a'col) #_Bytes s (.plus newp @a'col)
                                                                                      s (loop-when [s s #_int n 0] (< n count) => s
                                                                                            (BCOPY s, (... (:y_array reg) 0), yanklen)
                                                                                            (recur (.plus s yanklen) (inc n)))
                                                                                      _ (BCOPY s, 0, oldp, @a'col, (inc (STRLEN oldp, @a'col)))]
                                                                                    (ml-replace lnum, newp)
                                                                                    ;; Place cursor on last put char.
                                                                                    (if (== lnum (:lnum (:w_cursor win)))
                                                                                        (-> win ;; make sure "w_virtcol" is updated
                                                                                            (changed-cline-bef-curs)
                                                                                            (update-in [:w_cursor :col] + (dec totlen)))
                                                                                        win))
                                                                                win)
                                                                          lnum (if @VIsual_active (inc lnum) lnum)]
                                                                        (recur-if (and @VIsual_active (<= lnum (:lnum (:vi_end (:b_visual @curbuf))))) [win lnum] => [win lnum])
                                                                    ))
                                                              lnum (if @VIsual_active (dec lnum) lnum) ;; reset lnum to the last visual line
                                                              _ (swap! curbuf assoc :b_op_end (:w_cursor win))
                                                              ;; For "CTRL-O p" in Insert mode, put cursor after last char.
                                                              win (if (and (non-zero? totlen) (or (non-zero? @restart_edit) (flag? flags PUT_CURSEND)))
                                                                    (update-in win [:w_cursor :col] inc)
                                                                    win
                                                                )]
                                                            (changed-bytes lnum, @a'col)
                                                            win
                                                        )
                                                    :else ;; Insert at least one line.  When "y_type" is MCHAR, break the first line in two.
                                                        (let [o'cursor (:w_cursor win) a'first_indent (atom (boolean true)) a'indent_diff (atom (int 0))
                                                              [win lnum #_int delta]
                                                                (loop-when [win win lnum lnum delta 0 #_long n 1] (<= n count) => [win lnum delta]
                                                                    (let [[win lnum #_int i]
                                                                            (if (== (:y_type reg) MCHAR)
                                                                                ;; Split the current line in two at the insert position.
                                                                                ;; First insert y_array[size - 1] in front of second line, then append y_array[0] to first line.
                                                                                (let [lnum (:lnum o'cursor) #_Bytes s (.plus (ml-get lnum) @a'col)
                                                                                      #_Bytes z (... (:y_array reg) (dec (:y_size reg)))
                                                                                      #_Bytes s' (Bytes. (+ (STRLEN s) (STRLEN z) 1))
                                                                                      _ (STRCPY s', z) _ (STRCAT s', s)]
                                                                                    (ml-append lnum, s')
                                                                                    (let [s (ml-get lnum) s' (Bytes. (+ @a'col yanklen 1))
                                                                                          _ (BCOPY s', s, @a'col)
                                                                                          _ (BCOPY s', @a'col, (... (:y_array reg) 0), 0, (inc yanklen))]
                                                                                        (ml-replace lnum, s')
                                                                                        [(assoc-in win [:w_cursor :lnum] lnum) lnum 1]
                                                                                    ))
                                                                                [win lnum 0])
                                                                          [win lnum delta]
                                                                            (loop-when [win win lnum lnum delta delta i i] (< i (:y_size reg)) => [win lnum delta]
                                                                                (when (or (!= (:y_type reg) MCHAR) (< i (dec (:y_size reg))))
                                                                                    (ml-append lnum, (... (:y_array reg) i)))
                                                                                (let [lnum (inc lnum) _ (swap! a'nr_lines inc)
                                                                                      [win delta]
                                                                                        (if (flag? flags PUT_FIXINDENT)
                                                                                            (let [o'pos (:w_cursor win) win (assoc-in win [:w_cursor :lnum] lnum)
                                                                                                  #_Bytes s (ml-get lnum)
                                                                                                  delta (if (and (== n count) (== i (dec (:y_size reg)))) (STRLEN s) delta)
                                                                                                  #_int indent
                                                                                                    (cond (eos? s)
                                                                                                        0 ;; ignore empty lines
                                                                                                    @a'first_indent
                                                                                                        (do (reset! a'first_indent false)
                                                                                                            (reset! a'indent_diff (- o'indent (get-indent win)))
                                                                                                            o'indent)
                                                                                                    :else
                                                                                                        (max 0 (+ (get-indent win) @a'indent_diff)))
                                                                                                  win (set-indent win, indent, 0)
                                                                                                  ;; remember how many chars were removed
                                                                                                  delta (if (and (== n count) (== i (dec (:y_size reg)))) (- delta (STRLEN (ml-get lnum))) delta)]
                                                                                                [(assoc win :w_cursor o'pos) delta])
                                                                                            [win delta]
                                                                                        )]
                                                                                    (recur win lnum delta (inc i)))
                                                                            )]
                                                                        (recur win lnum delta (inc n))
                                                                    ))
                                                              ;; Adjust marks.
                                                              _ (when (== (:y_type reg) MLINE)
                                                                    (swap! curbuf assoc-in [:b_op_start :col] 0)
                                                                    (when (== dir FORWARD)
                                                                        (swap! curbuf update-in [:b_op_start :lnum] inc)
                                                                    ))
                                                              win (mark-adjust win, (+ (:lnum (:b_op_start @curbuf)) (if (== (:y_type reg) MCHAR) 1 0)), MAXLNUM, @a'nr_lines, 0)]
                                                            ;; note changed text for displaying
                                                            (if (== (:y_type reg) MCHAR)
                                                                (swap! curbuf changed-lines (:lnum (:w_cursor win)), @a'col, (inc (:lnum (:w_cursor win))), @a'nr_lines)
                                                                (swap! curbuf changed-lines (:lnum (:b_op_start @curbuf)), 0, (:lnum (:b_op_start @curbuf)), @a'nr_lines))
                                                            ;; put '] mark at last inserted character
                                                            (swap! curbuf assoc-in [:b_op_end :lnum] lnum)
                                                            ;; correct length for change in indent
                                                            (reset! a'col (- (STRLEN (... (:y_array reg) (dec (:y_size reg)))) delta))
                                                            (swap! curbuf assoc-in [:b_op_end :col] (max 0 (dec @a'col)))
                                                            (cond (flag? flags PUT_CURSLINE) ;; put cursor on last inserted line
                                                                (-> win (assoc-in [:w_cursor :lnum] lnum) (beginline (| BL_WHITE BL_FIX)))
                                                            (flag? flags PUT_CURSEND) ;; put cursor after inserted text
                                                                (if (== (:y_type reg) MLINE)
                                                                    (update win :w_cursor assoc :lnum (min (inc lnum) (line-count @curbuf)) :col 0)
                                                                    (update win :w_cursor assoc :lnum lnum :col @a'col))
                                                            (== (:y_type reg) MLINE) ;; put cursor on first non-blank in first inserted line
                                                                (let [win (if (== dir FORWARD) (update-in win [:w_cursor :lnum] inc) win)
                                                                      win (assoc-in win [:w_cursor :col] 0)]
                                                                    (beginline win, (| BL_WHITE BL_FIX)))
                                                            :else ;; put cursor on first inserted character
                                                                (assoc win :w_cursor o'cursor)
                                                            ))
                                                    ))
                                            )]
                                        (-> win (msgmore @a'nr_lines) (assoc :w_set_curswant true)))
                                ))
                        )]
                    (reset! VIsual_active false)
                    ;; If the cursor is past the end of the line, put it at the end.
                    (adjust-cursor-eol win))
            ))
    ))

;; When the cursor is on the NUL past the end of the line and it should not be there, move it left.

(defn- #_window_C adjust-cursor-eol [#_window_C win]
    (if (and (< 0 (:col (:w_cursor win))) (== (gchar-cursor win) NUL) (non-flag? @ve_flags VE_ONEMORE) (zero? @restart_edit) (non-flag? @State INSERT))
        ;; Put the cursor on the last character in the line.
        (let [win (dec-cursor win, false)]
            (if (== @ve_flags VE_ALL)
                ;; Coladd is set to the width of the last character.
                (let [a'scol (atom (int)) a'ecol (atom (int)) _ (getvcol win, (:w_cursor win), a'scol, nil, a'ecol)]
                    (assoc-in win [:w_cursor :coladd] (inc (- @a'ecol @a'scol))))
                win
            ))
        win
    ))

;; Join "count" lines (minimal 2) at cursor position.
;; When "save_undo" is true, save lines for undo first.
;; When "setmark?" is true, sets the '[ and '] marks, else the caller is expected to set those marks.
;;
;; Return false for failure, true otherwise.

(defn- #_[window_C boolean] do-join? [#_window_C win, #_int count, #_boolean insert_space, #_boolean save_undo, #_boolean setmark?]
    (let-when [lnum (:lnum (:w_cursor win))] (or (not save_undo) (u-save win, (dec lnum), (+ lnum count))) => [win false]
        ;; Allocate an array to store the number of spaces inserted before each line.
        ;; We will use it to pre-compute the length of the new line and the
        ;; proper placement of each original line in the new one.
        (let-when [#_int* spaces (int-array count)
            ;; Don't move anything, just compute the final line length and set the array of space lengths up.
            [#_Bytes s0 #_Bytes s #_int n #_int m :as _]
                (loop-when [s0 nil s nil n 0 m 0 #_int e1 NUL #_int e2 NUL #_int i 0] (< i count) => [s0 s n m]
                    (let [s0 (ml-get (+ lnum i)) s s0]
                        (when (and (zero? i) setmark?) ;; Set the '[ mark.
                            (swap! curbuf update :b_op_start assoc :lnum lnum :col (STRLEN s)))
                        (let [s (if (and insert_space (pos? i))
                                    (let [s (skipwhite s)]
                                        (when (and (not-at? s (byte \))) (non-zero? n) (!= e1 TAB))
                                            ;; don't add a space if the line is ending in a space
                                            (let [e1 (if (== e1 (byte \space)) e2 (do (aset spaces i (inc (aget spaces i))) e1))]
                                                ;; extra space when 'joinspaces' set and line ends in '.'
                                                (when (and @p_js (or (== e1 (byte \.)) (and (any == e1 (byte \?) (byte \!)) (nil? (vim-strbyte @p_cpo, CPO_JOINSP)))))
                                                    (aset spaces i (inc (aget spaces i))))
                                            ))
                                        s)
                                    s)
                              n (STRLEN s) m (+ m n (aget spaces i))
                              [e1 e2]
                                (if (and insert_space (pos? n))
                                    (let [#_Bytes q (.plus s n) q (.minus q (us-ptr-back s, q))]
                                        [(us-ptr2char q) (if (BLT s, q) (us-ptr2char (.minus q (us-ptr-back s, q))) NUL)])
                                    [NUL NUL]
                                )]
                            (if (slow-breakcheck) nil (recur s0 s n m e1 e2 (inc i)))
                        ))
                )] (some? _) => [win false]

            (let [#_int col (- m n (aget spaces (dec count))) ;; column position before last line
                  #_Bytes line (Bytes. (inc m))
                  ;; Move affected lines to the new long one.
                  ;; Also move marks from each deleted line to the joined line, adjusting the column.
                  ;; This is not Vi compatible, but since Vi deletes the marks, it should not be a problem.
                  [win n]
                    (loop [win win s0 s0 s s n n #_Bytes q (eos! (.plus line m)) #_int i (dec count)]
                        (let [t (aget spaces i)
                              q (.minus q n)
                              _ (BCOPY q, s, n)
                              q (if (pos? t) (let [q (.minus q t)] (BFILL q, 0, (byte \space), t) q) q)
                              win (mark-col-adjust win, (+ lnum i), 0, (- i), (- (+ (BDIFF q, line) t) (BDIFF s, s0)))]
                            (if (zero? i)
                                [win n]
                                (let [s0 (ml-get (+ lnum (dec i))) s (if (and insert_space (< 1 i)) (skipwhite s0) s0) n (STRLEN s)]
                                    (recur win s0 s n q (dec i)))
                            ))
                    )]
                (ml-replace lnum, line)
                (when setmark? ;; Set the '] mark.
                    (swap! curbuf update :b_op_end assoc :lnum lnum :col (STRLEN line)))
                ;; Only report the change in the first line here, del-lines() will report the deleted lines.
                (swap! curbuf changed-lines lnum, n, (inc lnum), 0)
                ;; Delete following lines.  To do this we move the cursor there briefly, and then move it back.
                ;; After del-lines() the cursor may have moved up (last line deleted), so the current lnum is kept.
                [(-> win
                    (update-in [:w_cursor :lnum] inc)
                    (del-lines (dec count), false)
                    (assoc-in [:w_cursor :lnum] lnum)
                    ;; Set the cursor column:
                    ;; Vi compatible: use the column of the first join
                    ;; Vim:           use the column of the last join
                    (assoc-in [:w_cursor :col] (if (some? (vim-strbyte @p_cpo, CPO_JOINCOL)) n col))
                    (check-cursor-col)
                    (assoc-in [:w_cursor :coladd] 0)
                    (assoc :w_set_curswant true))
                true]
            ))
    ))

(defn- #_window_C do-join [#_window_C win, #_int count, #_boolean insert_space, #_boolean save_undo, #_boolean setmark?]
    (let [[win _] (do-join? win, count, insert_space, save_undo, setmark?)]
        win
    ))

;; Prepare a few things for block mode yank/delete/tilde.
;;
;; For delete:
;; - textlen includes the first/last char to be (partly) deleted
;; - start/endspaces is the number of columns that are taken by the
;;   first/last deleted char minus the number of columns that have to be deleted.
;;
;; For yank and tilde:
;; - textlen includes the first/last char to be wholly yanked
;; - start/endspaces is the number of columns of the first/last yanked char
;;   that are to be yanked.

(defn- #_block_def_C block-prep [#_window_C win, #_oparg_C oap, #_boolean is_MAX, #_long lnum, #_boolean is_del]
    (let [#_block_def_C bd (assoc (NEW_block_def_C) :is_MAX is_MAX)
          #_Bytes line (ml-get lnum)
          [#_int t bd #_Bytes p #_Bytes s]
            (loop-when [t 0 bd bd p line s line] (and (< (:start_vcol bd) (:start_vcol oap)) (non-eos? s)) => [t bd p s]
                ;; Count a tab for what it's worth (if list mode not on).
                (let [t (lbr-chartabsize win, line, s, (:start_vcol bd))
                      bd (update bd :start_vcol + t)
                      bd (if (vim-iswhite (.at s 0))
                            (-> bd (update :pre_whitesp + t) (update :pre_whitesp_c inc))
                            (assoc bd :pre_whitesp 0 :pre_whitesp_c 0)
                        )]
                    (recur t bd s (.plus s (us-ptr2len-cc s)))
                ))
          bd (assoc bd :start_char_vcols t)
          [bd s]
            (cond (< (:start_vcol bd) (:start_vcol oap))        ;; line too short
                (let [bd (assoc bd :end_vcol (:start_vcol bd) :is_short true)
                      bd (if (or (not is_del) (== (:op_type oap) OP_APPEND)) (assoc bd :endspaces (inc (- (:end_vcol oap) (:start_vcol oap)))) bd)]
                    [bd s])
            :else ;; notice: this converts partly selected multibyte characters to spaces, too
                (let [bd (assoc bd :startspaces (- (:start_vcol bd) (:start_vcol oap)))
                      bd (if (and is_del (non-zero? (:startspaces bd))) (assoc bd :startspaces (- (:start_char_vcols bd) (:startspaces bd))) bd)
                      a'pend (atom (#_Bytes object s))
                      bd (assoc bd :end_vcol (:start_vcol bd))
                      [bd t]
                        (cond (< (:end_vcol oap) (:end_vcol bd))        ;; it's all in one character
                            [(let [bd (assoc bd :is_oneChar true)] (cond
                                (== (:op_type oap) OP_INSERT)
                                    (assoc bd :endspaces (- (:start_char_vcols bd) (:startspaces bd)))
                                (== (:op_type oap) OP_APPEND)
                                    (let [bd (update bd :startspaces + (inc (- (:end_vcol oap) (:start_vcol oap))))]
                                        (assoc bd :endspaces (- (:start_char_vcols bd) (:startspaces bd))))
                                :else
                                    (let-when [bd (assoc bd :startspaces (inc (- (:end_vcol oap) (:start_vcol oap))))] (and is_del (!= (:op_type oap) OP_LSHIFT)) => bd
                                        ;; just putting the sum of those two into bd.startspaces doesn't work for Visual replace, so we have to split the tab in two
                                        (assoc bd :startspaces (- (:start_char_vcols bd) (- (:start_vcol bd) (:start_vcol oap)))
                                                  :endspaces (- (:end_vcol bd) (:end_vcol oap) 1)))
                                )) t]
                        :else
                            (let [[#_Bytes prev_pend t bd]
                                    (loop-when [prev_pend @a'pend t t bd bd] (and (<= (:end_vcol bd) (:end_vcol oap)) (non-eos? @a'pend)) => [prev_pend t bd]
                                        ;; Count a tab for what it's worth (if list mode not on).
                                        (let [prev_pend @a'pend t (lbr-chartabsize-adv win, line, a'pend, (:end_vcol bd))]
                                            (recur prev_pend t (update bd :end_vcol + t)))
                                    )]
                                (cond (and (<= (:end_vcol bd) (:end_vcol oap)) (or (not is_del) (== (:op_type oap) OP_APPEND) (== (:op_type oap) OP_REPLACE))) ;; line too short
                                    [(let [bd (assoc bd :is_short true)]
                                        ;; Alternative: include spaces to fill up the block.
                                        ;; Disadvantage: can lead to trailing spaces when the line is short where the text is put.
                                        (assoc bd :endspaces (if (or (== (:op_type oap) OP_APPEND) (!= @virtual_op FALSE))
                                            (+ (- (:end_vcol oap) (:end_vcol bd)) (if (:inclusive oap) 1 0))
                                            0 ;; replace doesn't add characters
                                        ))) t]
                                (< (:end_vcol oap) (:end_vcol bd))
                                    [(let-when [bd (assoc bd :endspaces (- (:end_vcol bd) (:end_vcol oap) 1))] (and (not is_del) (non-zero? (:endspaces bd))) => bd
                                        (when (BNE @a'pend, s) (reset! a'pend prev_pend))
                                        (assoc bd :endspaces (- t (:endspaces bd)))) t]
                                :else
                                    [bd t])
                            ))
                      bd (assoc bd :end_char_vcols t)
                      s (if (and is_del (non-zero? (:startspaces bd))) p s)]
                    [(assoc bd :textlen (BDIFF @a'pend, s)) s])
            )]
        (assoc bd :textstart s :textcol (BDIFF s, line))
    ))

(defn- #_block_def_C char-prep [#_window_C win, #_oparg_C oap, #_long lnum]
    (let [#_block_def_C bd (NEW_block_def_C) start (:op_start oap)
          [bd #_int scol]
            (if (== lnum (:lnum start))
                (let-when [scol (:col start)] (!= @virtual_op FALSE) => [bd scol]
                    (let [a'cs (atom (int)) a'ce (atom (int)) _ (getvcol win, start, a'cs, nil, a'ce)]
                        (if (and (!= @a'ce @a'cs) (< 0 (:coladd start)))
                            ;; Part of a tab selected -- but don't double-count it.
                            (let [bd (assoc bd :startspaces (- (inc (- @a'ce @a'cs)) (:coladd start)))]
                                [bd (inc scol)])
                            [bd scol]
                        )))
                [bd 0])
          #_Bytes s (ml-get lnum) end (:op_end oap) incl (if (:inclusive oap) 1 0)
          [bd #_int ecol #_boolean one?]
            (if (== lnum (:lnum end))
                (let-when [ecol (:col end)] (!= @virtual_op FALSE) => [bd ecol false]
                    (let [a'cs (atom (int)) a'ce (atom (int)) _ (getvcol win, end, a'cs, nil, a'ce)]
                        ;; Don't add space for double-wide char; "ecol" will be on last byte of multi-byte char.
                        (if (or (eos? s ecol) (and (< (+ @a'cs (:coladd end)) @a'ce) (zero? (us-head-off s, (.plus s ecol)))))
                            (if (and (== (:lnum start) (:lnum end)) (== (:col start) (:col end)))
                                ;; Special case: inside a single char.
                                (let [bd (assoc bd :startspaces (+ (- (:coladd end) (:coladd start)) incl))]
                                    [bd scol true])
                                (let [bd (assoc bd :endspaces (+ (:coladd end) incl))]
                                    [bd (- ecol incl) false]
                                ))
                            [bd ecol false]
                        )))
                [bd MAXCOL false])
          ecol (if (== ecol MAXCOL) (STRLEN s) ecol)]
         (assoc bd :textlen (if (or (< ecol scol) one?) 0 (+ (- ecol scol) incl)) :textstart (.plus s scol))
    ))

(final int NUMBUFLEN 30)        ;; length of a buffer to store a number in ASCII

(atom! boolean hexupper)        ;; 0xABC

;; Add/subtract "Prenum1" to/from a number at cursor.
;; "command" is CTRL-A for add, CTRL-X for subtract.
;;
;; Return false for failure, true otherwise.

(defn- #_[window_C boolean] do-addsub [#_window_C win, #_int command, #_long Prenum1]
    (let-when [nf @(:b_p_nf @curbuf)
          #_boolean dohex (some? (vim-strchr nf, (byte \x)))   ;; "heXadecimal"
          #_boolean dooct (some? (vim-strchr nf, (byte \o)))   ;; "Octal"
          #_boolean doalp (some? (vim-strchr nf, (byte \p)))   ;; "alPha"
          #_Bytes s (ml-get (:lnum (:w_cursor win)))
          ;; First check if we are on a hexadecimal number, after the "0x".
          #_int col (:col (:w_cursor win))
          col (if dohex (loop-when-recur col (and (< 0 col) (asc-isxdigit (.at s col))) (dec col) => col) col)
          col (if (and dohex (< 0 col) (or (at? s col (byte \X)) (at? s col (byte \x))) (at? s (dec col) (byte \0)) (asc-isxdigit (.at s (inc col))))
                ;; Found hexadecimal number, move to its start.
                (dec col)
                ;; Search forward and then backward to find the start of number.
                (let [col (:col (:w_cursor win))
                      col (loop-when-recur col (and (non-eos? s col) (not (asc-isdigit (.at s col))) (not (and doalp (asc-isalpha (.at s col))))) (inc col) => col)
                      col (loop-when-recur col (and (< 0 col) (asc-isdigit (.at s (dec col))) (not (and doalp (asc-isalpha (.at s col))))) (dec col) => col)]
                    col))
          ;; If a number was found, and saving for undo works, replace the number.
          #_int d (.at s col)
    ] (and (or (asc-isdigit d) (and doalp (asc-isalpha d))) (u-save-cursor win)) => [(beep-flush win) false]

        ;; get 's' again, because u-save() may have changed it
        (let [s (ml-get (:lnum (:w_cursor win)))
              win (cond (and doalp (asc-isalpha d))
                    ;; decrement or increment alphabetic character
                    (let [d (if (== command Ctrl_X)
                                (if (<       (alphaOrd d)    Prenum1) (if (asc-isupper d) (byte \A) (byte \a)) (- d Prenum1))
                                (if (< (- 26 (alphaOrd d) 1) Prenum1) (if (asc-isupper d) (byte \Z) (byte \z)) (+ d Prenum1))
                            )]
                        (-> win (assoc-in [:w_cursor :col] col) (del-char false) (ins-char d)))
                :else
                    (let [[col #_boolean negative] (if (and (< 0 col) (at? s (dec col) (byte \-))) [(dec col) true] [col false])
                          a'hex (atom (int))            ;; 'X' or 'x': hex; '0': octal
                          a'len (atom (int 0))          ;; character length of the number
                          a'n (atom (long))]
                        ;; get the number value (unsigned)
                        (vim-str2nr (.plus s col), a'hex, a'len, dooct, dohex, a'n)
                        (when (neg? @a'n) (swap! a'n -))
                        ;; ignore leading '-' for hex and octal numbers
                        (let [[col negative] (if (and (non-zero? @a'hex) negative) (do (swap! a'len dec) [(inc col) false]) [col negative])
                              #_boolean subtract (== command Ctrl_X) subtract (if negative (not subtract) subtract)
                              #_long oldn @a'n
                              _ (swap! a'n (if subtract - +) Prenum1)
                              #_final #_long roof 0x7fffffffffffffff
                              _ (swap! a'n & roof)
                              ;; handle wraparound for decimal numbers
                              negative
                                (if (zero? @a'hex)
                                    (let [negative (if subtract
                                                (if (< oldn @a'n) (do (swap! a'n #(inc (bit-xor % roof))) (not negative)) negative)
                                                (if (< @a'n oldn) (do (swap! a'n        bit-xor   roof)   (not negative)) negative)
                                            )]
                                        (if (zero? @a'n) false negative))
                                    negative)
                              ;; Delete the old number.
                              win (assoc-in win [:w_cursor :col] col)
                              win (let [#_int n @a'len #_int c (gchar-cursor win)]
                                    ;; Don't include the '-' in the length.
                                    (when (== c (byte \-)) (swap! a'len dec))
                                    (loop-when [win win n n c c] (< 0 n) => win
                                        (when (and (< c 0x100) (asc-isalpha c))
                                            (reset! hexupper (asc-isupper c)))
                                        ;; del-char() will mark line needing displaying
                                        (let [win (del-char win, false)]
                                            (recur win (dec n) (gchar-cursor win))
                                        ))
                                )]
                            ;; Prepare the leading characters in buf1[].
                            ;; When there are many leading zeros it could be very long.
                            ;; Allocate a bit too much.
                            (let [#_Bytes buf1 (Bytes. (+ @a'len NUMBUFLEN)) s buf1
                                  s (if negative (-> s (.be 0, (byte \-)) (.plus 1)) s)
                                  s (if (non-zero? @a'hex) (do (swap! a'len dec) (-> s (.be 0, (byte \0)) (.plus 1))) s)
                                  s (if (or (== @a'hex (byte \x)) (== @a'hex (byte \X))) (do (swap! a'len dec) (-> s (.be 0, @a'hex) (.plus 1))) s)
                                  ;; Put the number characters in buf2[].
                                  #_Bytes buf2 (Bytes. NUMBUFLEN)]
                                (cond
                                    (zero? @a'hex)                     (ร .sprintf libC buf2, (u8 "%ld"), @a'n)
                                    (== @a'hex (byte \0))              (ร .sprintf libC buf2, (u8 "%lo"), @a'n)
                                    (and (non-zero? @a'hex) @hexupper) (ร .sprintf libC buf2, (u8 "%lX"), @a'n)
                                    :else                              (ร .sprintf libC buf2, (u8 "%lx"), @a'n)
                                )
                                (swap! a'len - (STRLEN buf2))
                                ;; Adjust number of zeros to the new number of digits,
                                ;; so the total length of the number remains the same.
                                ;; Don't do this when the result may look like an octal number.
                                (let [s (if (and (== d (byte \0)) (not (and dooct (zero? @a'hex))))
                                            (loop-when-recur s (<= 0 (swap! a'len dec)) (-> s (.be 0, (byte \0)) (.plus 1)) => s)
                                            s)]
                                    (eos! s)
                                    (STRCAT buf1, buf2)
                                    (ins-str win, buf1) ;; insert the new number
                                ))
                        ))
                )]
            [(-> win (update-in [:w_cursor :col] dec) (assoc :w_set_curswant true)) true]
        )
    ))

;; Count the number of bytes, characters and "words" in a line.
;;
;; "Words" are counted by looking for boundaries between non-space and
;; space characters.  (It seems to produce results that match 'wc'.)
;;
;; Return value is byte count; word count for the line is added to "*wc".
;; Char count is added to "*cc".
;;
;; The function will only examine the first "limit" characters in the
;; line, stopping if it encounters an end-of-line (NUL byte).  In that
;; case, eol_size will be added to the character count to account for
;; the size of the EOL character.

(defn- #_int line-count-info [#_Bytes line, #_int' a'wc, #_int' a'cc, #_int limit, #_int eol_size]
    (let [[#_int words #_boolean word? #_int chars #_int bytes]
            (loop-when [w* 0 w? false c* 0 b* 0] (and (< b* limit) (non-eos? line b*)) => [w* w? c* b*]
                (let [[w* w?] (or (cond w? (when (vim-isspace (.at line b*)) [(inc w*) false]) (not (vim-isspace (.at line b*))) [w* true]) [w* w?])]
                    (recur w* w? (inc c*) (+ b* (us-ptr2len-cc line, b*)))
                ))
          words (if word? (inc words) words)]
        (swap! a'wc + words)
        ;; Add eol_size if the end of line was reached before hitting limit.
        (let [[bytes chars] (if (and (< bytes limit) (eos? line bytes)) [(+ bytes eol_size) (+ chars eol_size)] [bytes chars])]
            (swap! a'cc + chars)
            bytes)
    ))

;; Give some info about the position of the cursor (for "g CTRL-G").
;; In Visual mode, give some info about the selected region.  (In this case,
;; the *_count_cursor variables store running totals for the selection.)

(defn- #_window_C cursor-pos-info [#_window_C win]
    (if (:ml_empty (:b_ml @curbuf))
        (msg win, no_lines_msg)
        (let-when [[#_pos_C min_pos #_pos_C max_pos #_oparg_C oparg #_long selected_lines]
                (if @VIsual_active
                    (let [[min_pos max_pos] (if (ltpos @VIsual_cursor, (:w_cursor win)) [@VIsual_cursor (:w_cursor win)] [(:w_cursor win) @VIsual_cursor])
                          max_pos (update max_pos :col #(if (and (at? @p_sel (byte \e)) (< 0 %)) (dec %) %))
                          oparg (when (== @VIsual_mode Ctrl_V)
                                    (let [oparg (assoc (NEW_oparg_C) :is_VIsual true :block_mode true :op_type OP_NOP)
                                          o'sbr @p_sbr
                                          ;; Make 'sbr' empty for a moment to get the correct size.
                                          _ (reset! p_sbr EMPTY_OPTION)
                                          a'scol (atom (int (:start_vcol oparg))) a'ecol (atom (int (:end_vcol oparg)))
                                          _ (getvcols win, min_pos, max_pos, a'scol, a'ecol)
                                          oparg (assoc oparg :start_vcol @a'scol :end_vcol @a'ecol)
                                          _ (reset! p_sbr o'sbr)
                                          oparg (if (== (:w_curswant win) MAXCOL) (assoc oparg :end_vcol MAXCOL) oparg)]
                                        ;; Swap the start, end vcol if needed.
                                        (if (< (:end_vcol oparg) (:start_vcol oparg))
                                            (assoc oparg :start_vcol (:end_vcol oparg) :end_vcol (:start_vcol oparg))
                                            oparg)
                                    ))]
                        [min_pos max_pos oparg (inc (- (:lnum max_pos) (:lnum min_pos)))])
                    [nil nil nil 0])
              lmin 1 lmax (line-count @curbuf)
              a'bytes (atom (int 0)) a'cursor_bytes (atom (int 0))
              a'chars (atom (int 0)) a'cursor_chars (atom (int 0))
              a'words (atom (int 0)) a'cursor_words (atom (int 0))
              _ (loop-when [#_int miles (+ @a'bytes 100000) #_long lnum lmin] (<= lnum lmax) => :_
                    ;; Check for a CTRL-C every 100000 characters.
                    (let-when [miles (if (< miles @a'bytes) (do (ui-breakcheck) (if @got_int nil (+ @a'bytes 100000))) miles)] (some? miles) => nil
                        ;; Do extra processing for VIsual mode.
                        (cond (and @VIsual_active (<= (:lnum min_pos) lnum (:lnum max_pos)))
                            (let [[#_Bytes s #_int n]
                                    (condp == @VIsual_mode
                                        Ctrl_V
                                            (let [_ (reset! virtual_op (if (virtual-active) TRUE FALSE))
                                                  #_block_def_C bd (block-prep win, oparg, false, lnum, false)
                                                  _ (reset! virtual_op MAYBE)]
                                                [(:textstart bd) (:textlen bd)])
                                        (byte \V)
                                            [(ml-get lnum) MAXCOL]
                                        (byte \v)
                                            (let [#_int start_col (if (== lnum (:lnum min_pos)) (:col min_pos) 0)
                                                  #_int end_col (if (== lnum (:lnum max_pos)) (inc (- (:col max_pos) start_col)) MAXCOL)]
                                                [(.plus (ml-get lnum) start_col) end_col])
                                        [nil 0]
                                    )]
                                (swap! a'cursor_bytes #(if (some? s) (+ % (line-count-info s, a'cursor_words, a'cursor_chars, n, 1)) %)))
                        :else
                            ;; In non-visual mode, check for the line the cursor is on.
                            (when (== lnum (:lnum (:w_cursor win)))
                                (swap! a'cursor_words + @a'words)
                                (swap! a'cursor_chars + @a'chars)
                                (reset! a'cursor_bytes (+ @a'bytes (line-count-info (ml-get lnum), a'cursor_words, a'cursor_chars, (inc (:col (:w_cursor win))), 1)))
                            ))
                        ;; Add to the running totals.
                        (swap! a'bytes + (line-count-info (ml-get lnum), a'words, a'chars, MAXCOL, 1))
                        (recur miles (inc lnum)))
                )] (some? _) => win

            (if @VIsual_active
                (let [#_Bytes buf1 (Bytes. 50)]
                    (if (and (== @VIsual_mode Ctrl_V) (< (:w_curswant win) MAXCOL))
                        (ร .sprintf libC buf1, (u8 "%ld Cols; "), (inc (- (:end_vcol oparg) (:start_vcol oparg))))
                        (eos! buf1))
                    (if (and (== @a'cursor_chars @a'cursor_bytes) (== @a'chars @a'bytes))
                        (msg* win, (u8 "Selected %s%ld of %ld Lines; %ld of %ld Words; %ld of %ld Bytes"),
                                   buf1, selected_lines, lmax, @a'cursor_words, @a'words, @a'cursor_bytes, @a'bytes)
                        (msg* win, (u8 "Selected %s%ld of %ld Lines; %ld of %ld Words; %ld of %ld Chars; %ld of %ld Bytes"),
                                   buf1, selected_lines, lmax, @a'cursor_words, @a'words, @a'cursor_chars, @a'chars, @a'cursor_bytes, @a'bytes)
                    ))
                (let [#_Bytes s (ml-get (:lnum (:w_cursor win))) #_Bytes buf1 (Bytes. 50) #_Bytes buf2 (Bytes. 40)
                        win (validate-virtcol win)]
                    (col-print buf1, (inc (:col (:w_cursor win))), (inc (:w_virtcol win)))
                    (col-print buf2, (STRLEN s), (linetabsize win, s))
                    (if (and (== @a'cursor_chars @a'cursor_bytes) (== @a'chars @a'bytes))
                        (msg* win, (u8 "Col %s of %s; Line %ld of %ld; Word %ld of %ld; Byte %ld of %ld"),
                                   buf1, buf2, (:lnum (:w_cursor win)), lmax, @a'cursor_words, @a'words, @a'cursor_bytes, @a'bytes)
                        (msg* win, (u8 "Col %s of %s; Line %ld of %ld; Word %ld of %ld; Char %ld of %ld; Byte %ld of %ld"),
                                   buf1, buf2, (:lnum (:w_cursor win)), lmax, @a'cursor_words, @a'words, @a'cursor_chars, @a'chars, @a'cursor_bytes, @a'bytes)
                    ))
            ))
    ))

;; mark.c: functions for setting marks and jumping to them ----------------------------------------

;; If a named file mark's lnum is non-zero, it is valid.
;; There are marks 'A - 'Z (set by user) and '0 to '9 (set when writing viminfo).

(final int EXTRA_MARKS 10)                                              ;; marks 0-9
(atom! pos_C*    namedfm    (ARRAY-pos (+ NMARKS EXTRA_MARKS)))

;; Set named mark "c" to position "pos" for window "win".
;; Returns true on success, false if bad name given.

(defn- #_[window_C boolean] set-mark? [#_window_C win, #_pos_C pos, #_int c]
    (cond
        ;; Check for a special key (may cause islower() to crash).
        (< c 0)
            [win false]

        (any == c (byte \') (byte \`))
            (let [win
                    (if (== pos (:w_cursor win))
                        (let [win (setpcmark win)]
                            (assoc win :w_prev_pcmark (:w_pcmark win))) ;; keep it even when the cursor doesn't move
                        (assoc win :w_pcmark pos)
                    )]
                [win true])

        (== c (byte \"))  ;; """
            (do (swap! curbuf assoc :b_last_cursor pos)
                [win true])

        ;; Allow setting '[ and '] for an autocommand that simulates reading a file.
        (== c (byte \[))
            (do (swap! curbuf assoc :b_op_start pos)
                [win true])

        (== c (byte \]))
            (do (swap! curbuf assoc :b_op_end pos)
                [win true])

        (any == c (byte \<) (byte \>))
            (do (swap! curbuf update :b_visual assoc (if (== c (byte \<)) :vi_start :vi_end) pos)
                ;; Visual_mode has not yet been set, use a sane default.
                (when (== (:vi_mode (:b_visual @curbuf)) NUL)
                    (swap! curbuf assoc-in [:b_visual :vi_mode] (byte \v)))
                [win true])

        (< (byte \z) c)        ;; some islower() and isupper() cannot handle characters above 127
            [win false]

        (asc-islower c)
            (let [#_int i (- c (byte \a))]
                (swap! curbuf assoc-in [:b_namedm i] pos)
                [win true])

        (asc-isupper c)
            (let [#_int i (- c (byte \A))]
                (swap! namedfm assoc i pos)
                [win true])

        :else
            [win false]
    ))

;; Set the previous context mark to the current position and add it to the jump list.

(defn- #_window_C setpcmark [#_window_C win]
    (let [win (assoc win :w_prev_pcmark (:w_pcmark win), :w_pcmark (:w_cursor win))
          win (update win :w_jumplistlen inc)
          ;; If jumplist is full: remove oldest entry.
          win (if (< JUMPLISTSIZE (:w_jumplistlen win))
                (let [win (assoc win :w_jumplistlen JUMPLISTSIZE)]
                    (loop-when-recur [win win #_int i 1] (< i JUMPLISTSIZE) [(assoc-in win [:w_jumplist (dec i)] (... (:w_jumplist win) i)) (inc i)] => win))
                win)
          win (assoc win :w_jumplistidx (:w_jumplistlen win))]
        (assoc-in win [:w_jumplist (dec (:w_jumplistlen win))] (:w_pcmark win))
    ))

;; To change context, call setpcmark(), then move the current position to where ever, then call checkpcmark().
;; This ensures that the previous context will only be changed if the cursor moved to a different line.
;; If pcmark was deleted (with "dG") the previous mark is restored.

(defn- #_window_C checkpcmark [#_window_C win]
    (if (and (non-zero? (:lnum (:w_prev_pcmark win))) (or (zero? (:lnum (:w_pcmark win))) (eqpos (:w_pcmark win), (:w_cursor win))))
        (let [win (assoc win :w_pcmark (:w_prev_pcmark win))]
            (assoc-in win [:w_prev_pcmark :lnum] 0)) ;; show it has been checked
        win
    ))

;; Move "m" positions in the jump list ("m" may be negative).

(defn- #_[window_C pos_C] movemark [#_window_C win, #_int m]
    (let-when [win (dedupe-jumplist win) n (:w_jumplistlen win)] (< -1 (+ (:w_jumplistidx win) m) n) => [win nil]
        ;; If first CTRL-O or CTRL-I command after a jump, add cursor position
        ;; to list.  Careful:  If there are duplicates (CTRL-O immediately after
        ;; starting Vim on a file), another entry may have been removed.
        (let-when [[win _]
                (if (== (:w_jumplistidx win) n)
                    (let [win (setpcmark win) win (update win :w_jumplistidx dec)] ;; skip the new entry
                        [win (if (< -1 (+ (:w_jumplistidx win) m)) :_ nil)])
                    [win :_]
                )] (some? _) => [win nil]
            (let [win (update win :w_jumplistidx + m)]
                [win (... (:w_jumplist win) (:w_jumplistidx win))]
            ))
    ))

;; Move "m" positions in the changelist ("m" may be negative).

(defn- #_[window_C pos_C] movechangelist [#_window_C win, #_int m]
    (let-when [n (:b_changelistlen @curbuf)] (non-zero? n) => [win nil]
        (let-when [i (:w_changelistidx win)
                   i (cond
                        (< (+ i m) 0) (if (zero? i) nil 0)
                        (<= n (+ i m)) (if (== i (dec n)) nil (dec n))
                        :else (+ i m)
                    )] (some? i) => [win nil]
            [(assoc win :w_changelistidx i) (... (:b_changelist @curbuf) i)])
    ))

(defn- #_pos_C getmark [#_window_C win, #_int c]
    (cond
        (or (< c 0) (< (byte \~) c))        nil
        (any == c (byte \') (byte \`))      (:w_pcmark win)             ;; previous context mark
        (== c (byte \"))                    (:b_last_cursor @curbuf)    ;; to pos when leaving buffer """
        (== c (byte \^))                    (:b_last_insert @curbuf)    ;; to where Insert mode stopped
        (== c (byte \.))                    (:b_last_change @curbuf)    ;; to where last change was made
        (== c (byte \[))                    (:b_op_start @curbuf)       ;; to start of previous operator
        (== c (byte \]))                    (:b_op_end @curbuf)         ;; to end of previous operator
        (any == c (byte \{) (byte \}))      nil                         ;; to previous/next paragraph
        (any == c (byte \() (byte \)))      nil                         ;; to previous/next sentence
        (any == c (byte \<) (byte \>))                                  ;; start/end of visual area
            (let [visual (:b_visual @curbuf) #_pos_C start (:vi_start visual) #_pos_C end (:vi_end visual)
                  #_pos_C p (if (== (== c (byte \<)) (ltpos start, end)) start end)]
                ;; for Visual line mode, set mark at begin or end of line
                (if (== (:vi_mode visual) (byte \V)) (assoc p :col (if (== c (byte \<)) 0 MAXCOL) :coladd 0) p)
            )
        (asc-islower c)                     (... (:b_namedm @curbuf) (- c (byte \a)))
        (asc-isupper c)                     (... @namedfm (- c (byte \A)))
        (asc-isdigit c)                     (... @namedfm (+ (- c (byte \0)) NMARKS))
        :else                               nil
    ))

;; Search for the next named mark in the current file.
;;
;; Returns pointer to pos_C of the next mark or null if no mark is found.

(defn- #_pos_C getnextmark [#_pos_C startpos, #_int dir, #_boolean begin_line] ;; startpos: where to start ;; dir: direction for search
    ;; When searching backward/forward and leaving the cursor on the first non-blank, position must be in a previous/next line.
    (let [#_pos_C pos (cond (and (== dir BACKWARD) begin_line) (assoc startpos :col 0) (and (== dir FORWARD) begin_line) (assoc startpos :col MAXCOL) :else startpos)]
        (loop-when [#_pos_C mark nil #_int i 0] (< i NMARKS) => mark
            (let [mi (... (:b_namedm @curbuf) i)
                  mark (if (< 0 (:lnum mi))
                            (if (== dir FORWARD)
                                (if (and (or (nil? mark) (ltpos mi, mark)) (ltpos pos, mi)) mi mark)
                                (if (and (or (nil? mark) (ltpos mark, mi)) (ltpos mi, pos)) mi mark))
                            mark)]
                (recur mark (inc i))
            ))
    ))

;; Check whether a position from a mark is valid.
;; Give and error message and return false if not.

(defn- #_[window_C boolean] check-mark? [#_window_C win, #_pos_C pos]
    (cond
        (nil? pos)
            [(emsg win, e_umark) false]
        ;; 'lnum' is negative if mark is in another file and can't get that file, error message is already given then
        (<= (:lnum pos) 0)
            [(if (zero? (:lnum pos)) (emsg win, e_marknotset) win) false]
        (< (line-count @curbuf) (:lnum pos))
            [(emsg win, e_markinval) false]
        :else
            [win true]
    ))

(defn- #_long one-adjust [#_long add, #_long line1, #_long line2, #_long amount, #_long amount_after]
    (cond
        (<= line1 add line2)
            (if (== amount MAXLNUM) 0 (+ add amount))
        (and (non-zero? amount_after) (< line2 add))
            (+ add amount_after)
        :else
            add
    ))

;; don't delete the line, just put at first deleted line
(defn- #_long one-adjust-nodel [#_long add, #_long line1, #_long line2, #_long amount, #_long amount_after]
    (cond
        (<= line1 add line2)
            (if (== amount MAXLNUM) line1 (+ add amount))
        (and (non-zero? amount_after) (< line2 add))
            (+ add amount_after)
        :else
            add
    ))

(atom! pos_C mark_initpos (pos_C. 1, 0, 0))

;; Adjust marks between "line1" and "line2" (inclusive) to move "amount" lines.
;;
;; Must be called before changed-*(), appended-lines() or deleted-lines().
;; May be called before or after changing the text.
;; When deleting lines "line1" to "line2", use an "amount" of MAXLNUM: the marks within this range are made invalid.
;; If "amount_after" is non-zero, adjust marks after "line2".
;; Example: Delete lines 34 and 35: mark-adjust(34, 35, MAXLNUM, -2);
;; Example: Insert two lines below 55: mark-adjust(56, MAXLNUM, 2, 0);
;;                                 or: mark-adjust(56, 55, MAXLNUM, 2);

(defn- #_window_C mark-adjust [#_window_C win, #_long line1, #_long line2, #_long amount, #_long amount_after]
    (when' (not (and (< line2 line1) (zero? amount_after))) => win
        ;; named marks, lower case and upper case
        (dotimes [#_int i NMARKS]
            (swap! curbuf update-in [:b_namedm i :lnum] one-adjust line1, line2, amount, amount_after)
            (swap! namedfm update-in [i :lnum] one-adjust-nodel line1, line2, amount, amount_after))

        (loop-when-recur [#_int i NMARKS] (< i (+ NMARKS EXTRA_MARKS)) [(inc i)]
            (swap! namedfm update-in [i :lnum] one-adjust-nodel line1, line2, amount, amount_after))

        (swap! curbuf update-in [:b_last_insert :lnum] one-adjust line1, line2, amount, amount_after)   ;; last insert position
        (swap! curbuf update-in [:b_last_change :lnum] one-adjust line1, line2, amount, amount_after)   ;; last change position

        ;; last cursor position, if it was set
        (when (not (eqpos (:b_last_cursor @curbuf), @mark_initpos))
            (swap! curbuf update-in [:b_last_cursor :lnum] one-adjust line1, line2, amount, amount_after))

        ;; list of change positions
        (dotimes [#_int i (:b_changelistlen @curbuf)]
            (swap! curbuf update-in [:b_changelist i :lnum] one-adjust-nodel line1, line2, amount, amount_after))

        ;; Visual area.
        (swap! curbuf update-in [:b_visual :vi_start :lnum] one-adjust-nodel line1, line2, amount, amount_after)
        (swap! curbuf update-in [:b_visual :vi_end :lnum] one-adjust-nodel line1, line2, amount, amount_after)

        (let [win (-> win
                    (update-in [:w_pcmark :lnum] one-adjust line1, line2, amount, amount_after)         ;; previous context mark
                    (update-in [:w_prev_pcmark :lnum] one-adjust line1, line2, amount, amount_after)    ;; previous pcmark
                )]

            ;; Adjust items in all windows related to the current buffer.

            (loop-when-recur [#_window_C w @firstwin] (some? w) [(:w_next w)]
                ;; Marks in the jumplist.
                ;; When deleting lines, this may create duplicate marks in the jumplist, they will be removed later.
                (dotimes [#_int i (:w_jumplistlen w)]
                    ((ร w =) (update-in w [:w_jumplist i :lnum] one-adjust-nodel line1, line2, amount, amount_after)))

                ;; the displayed Visual area
                (when (non-zero? (:w_old_cursor_lnum w))
                    ((ร w =) (update w :w_old_cursor_lnum one-adjust-nodel line1, line2, amount, amount_after))
                    ((ร w =) (update w :w_old_visual_lnum one-adjust-nodel line1, line2, amount, amount_after)))

                ;; topline and cursor position for windows with the same buffer, other than the current window
                (when (!= w win)
                    ((ร w =) (cond (<= line1 (:w_topline w) line2) ;; topline is deleted ;; keep topline on the same line
                        (assoc w :w_topline (if (== amount MAXLNUM) (max 1 (dec line1)) (+ (:w_topline w) amount)))
                    (and (non-zero? amount_after) (< line2 (:w_topline w)))
                        (update w :w_topline + amount_after)
                    :else
                        w
                    ))

                    ((ร w =) (cond (<= line1 (:lnum (:w_cursor w)) line2)
                        (if (== amount MAXLNUM)
                            (update w :w_cursor assoc :lnum (max 1 (dec line1)) :col 0)     ;; line with cursor is deleted
                            (update-in w [:w_cursor :lnum] + amount))                       ;; keep cursor on the same line
                    (and (non-zero? amount_after) (< line2 (:lnum (:w_cursor w))))
                        (update-in w [:w_cursor :lnum] + amount_after)
                    :else
                        w
                    ))
                ))

            win)
    ))

;; This code is used often, needs to be fast.
(defn- #_pos_C col-adjust [#_pos_C pos, #_long lnum, #_int mincol, #_long lnum_amount, #_long col_amount]
    (if (and (== (:lnum pos) lnum) (<= mincol (:col pos)))
        (let [pos (update pos :lnum + lnum_amount)]
            (assoc pos :col (max 0 (+ (:col pos) col_amount))))
        pos
    ))

;; Adjust marks in line "lnum" at column "mincol" and further:
;; add "lnum_amount" to the line number and add "col_amount" to the column position.

(defn- #_window_C mark-col-adjust [#_window_C win, #_long lnum, #_int mincol, #_long lnum_amount, #_long col_amount]
    (when' (not (and (zero? col_amount) (zero? lnum_amount))) => win
        ;; named marks, lower case and upper case
        (dotimes [#_int i NMARKS]
            (swap! curbuf update-in [:b_namedm i] col-adjust lnum, mincol, lnum_amount, col_amount)
            (swap! namedfm update i col-adjust lnum, mincol, lnum_amount, col_amount))

        (loop-when-recur [#_int i NMARKS] (< i (+ NMARKS EXTRA_MARKS)) [(inc i)]
            (swap! namedfm update i col-adjust lnum, mincol, lnum_amount, col_amount))

        (swap! curbuf update :b_last_insert col-adjust lnum, mincol, lnum_amount, col_amount)   ;; last insert position
        (swap! curbuf update :b_last_change col-adjust lnum, mincol, lnum_amount, col_amount)   ;; last change position

        ;; list of change positions
        (dotimes [#_int i (:b_changelistlen @curbuf)]
            (swap! curbuf update-in [:b_changelist i] col-adjust lnum, mincol, lnum_amount, col_amount))

        ;; Visual area.
        (swap! curbuf update-in [:b_visual :vi_start] col-adjust lnum, mincol, lnum_amount, col_amount)
        (swap! curbuf update-in [:b_visual :vi_end] col-adjust lnum, mincol, lnum_amount, col_amount)

        (let [win (-> win
                    (update :w_pcmark col-adjust lnum, mincol, lnum_amount, col_amount)         ;; previous context mark
                    (update :w_prev_pcmark col-adjust lnum, mincol, lnum_amount, col_amount)    ;; previous pcmark
                )]

            ;; Adjust items in all windows related to the current buffer.

            (loop-when-recur [#_window_C w @firstwin] (some? w) [(:w_next w)]
                ;; marks in the jumplist
                (dotimes [#_int i (:w_jumplistlen w)]
                    ((ร w =) (update-in w [:w_jumplist i] col-adjust lnum, mincol, lnum_amount, col_amount)))

                ;; cursor position for other windows with the same buffer
                (when (!= w win)
                    ((ร w =) (update w :w_cursor col-adjust lnum, mincol, lnum_amount, col_amount))
                ))

            win)
    ))

;; Deleting lines may create duplicate marks in the jumplist.

(defn- #_window_C dedupe-jumplist [#_window_C win]
    (let [n (:w_jumplistlen win)
          [win e]
            (loop-when [win win e 0 i 0] (< i n) => [win e]
                (let [win (if (== (:w_jumplistidx win) i) (assoc win :w_jumplistidx e) win)
                      m (loop-when-recur [m (inc i)] (and (< m n) (!= (:lnum (... (:w_jumplist win) m)) (:lnum (... (:w_jumplist win) i)))) [(inc m)] => m)
                      [win e] (if (<= n m) [(assoc-in win [:w_jumplist e] (... (:w_jumplist win) i)) (inc e)] [win e])]
                    (recur win e (inc i))
                ))
          win (if (== (:w_jumplistidx win) n) (assoc win :w_jumplistidx e) win)]
        (assoc win :w_jumplistlen e)
    ))

;; Copy the jumplist from window "won" to window "win".

(defn- #_window_C copy-jumplist [#_window_C win, #_window_C won]
    (-> win
        (assoc :w_jumplist    (:w_jumplist    won))
        (assoc :w_jumplistlen (:w_jumplistlen won))
        (assoc :w_jumplistidx (:w_jumplistidx won))
    ))

;;; ============================================================================================== VimL

;; getchar.c --------------------------------------------------------------------------------------
;;
;; functions related with getting a character from the user/mapping/redo/...
;;
;; manipulations with redo buffer and stuff buffer
;; mappings and abbreviations

;; These buffers are used for storing:
;; - stuffed characters: A command that is translated into another command.
;; - redo characters: will redo the last change.
;; - recorded characters: for the "q" command.
;;
;; The bytes are stored like in the typeahead buffer:
;; - KB_SPECIAL introduces a special key (two more bytes follow).
;;   A literal KB_SPECIAL is stored as KB_SPECIAL KS_SPECIAL KE_FILLER.
;; These translations are also done on multi-byte characters!
;;
;; Escaping KB_SPECIAL is done by inchar().
;; Un-escaping is done by vgetc().

(atom! Bytes* redobuff        [])
(atom! Bytes* old_redobuff    [])
(atom! Bytes* recordbuff      [])

;; When block_redo is true redo buffer will not be changed;
;; used by edit() to repeat insertions and 'V' command for redoing.

(atom! boolean block_redo)

;; Variables used by vgetorpeek() and flush-buffers().
;;
;; typebuf.tb_buf[] contains all characters that are not consumed yet.
;; typebuf.tb_buf[typebuf.tb_off] is the first valid character.
;; typebuf.tb_buf[typebuf.tb_off + typebuf.tb_len - 1] is the last valid char.
;; typebuf.tb_buf[typebuf.tb_off + typebuf.tb_len] must be NUL.
;;
;; After the head are characters that come from the terminal.

;; typebuf.tb_buf has three parts:
;;  room in front (for result of mappings),
;;  the middle for typeahead and
;;  room for new characters (which needs to be 3 * MAXMAPLEN).

(atom! int      last_recorded_len)          ;; number of last recorded chars

;; Return the contents of a buffer as a single string.
;; KB_SPECIAL in the returned string is escaped.

(defn- #_Bytes get-buffcont [#_Bytes* buffer, #_boolean dozero]
    ;; dozero: n == zero is not an error
    (let-when [n (loop-when-recur [n 0 [s & z] buffer] (some? s) [(+ n (STRLEN s)) z] => n)] (or (< 0 n) dozero) => nil
        (let [q (Bytes. (inc n))
              n (loop-when [n 0 [s & z] buffer] (some? s) => n
                    (let [n (loop-when-recur [n n i 0] (non-eos? s i) [(inc n) (inc i)] => n
                                (.be q n, (.at s i))
                            )]
                        (recur n z)
                    ))]
            (eos! q n)
        )))

;; Return the contents of the record buffer as a single string and clear the record buffer.
;; KB_SPECIAL in the returned string is escaped.

(defn- #_Bytes get-recorded []
    (let [s (get-buffcont @recordbuff, true) _ (reset! recordbuff [])
          ;; Remove the characters that were added the last time, these must be the
          ;; (possibly mapped) characters that stopped the recording.
          n (STRLEN s) m @last_recorded_len n (if (<= m n) (let [n (- n m)] (eos! s n) n) n)]
        ;; When stopping recording from Insert mode with CTRL-O q, also remove the CTRL-O.
        (when (and (< 0 n) (non-zero? @restart_edit) (at? s (dec n) Ctrl_O))
            (eos! s (dec n)))
        s
    ))

;; Return the contents of the redo buffer as a single string.
;; KB_SPECIAL in the returned string is escaped.

(defn- #_Bytes get-inserted []
    (get-buffcont @redobuff, false))

;; Append string "s" to read buffer "buf".
;; KB_SPECIAL should have been escaped already.

(defn- #_Bytes* add-buff [#_Bytes* buf, #_Bytes s, #_long slen]
    ;; slen: length of "s" or -1
    (let-when [slen (if (neg? slen) (STRLEN s) slen)] (pos? slen) => buf ;; don't add empty strings
        (conj buf (STRNDUP s, slen))
    ))

;; Append number "n" to read buffer "buf".

(defn- #_Bytes* add-num-buff [#_Bytes* buf, #_long n]
    (let [s (Bytes. 32)]
        (ร .sprintf libC s, (u8 "%ld"), n)
        (add-buff buf, s, -1)
    ))

;; Append character "c" to read buffer "buf".
;; Translates special keys, NUL, KB_SPECIAL and multibyte characters.

(defn- #_Bytes* add-char-buff [#_Bytes* buf, #_int c]
    (let [s (Bytes. (inc MB_MAXBYTES)) n (if (is-special c) 1 (utf-char2bytes c, s)) q (Bytes. 4)]
        (loop-when [buf buf c c i 0] (< i n) => buf
            (let [c (if (is-special c) c (char_u (.at s i)))]
                (if (or (is-special c) (== c (char_u KB_SPECIAL)) (== c NUL))
                    (-> q (.be 0, KB_SPECIAL) (.be 1, (KB-SECOND c)) (.be 2, (KB-THIRD c)) (eos! 3)) ;; translate special key code into three byte sequence
                    (-> q (.be 0, c) (eos! 1)))
                (recur (add-buff buf, q, -1) c (inc i))
            ))
    ))

;; First read ahead buffer.  Used for translated commands.
(atom! Bytes* readbuf1    [])

;; Second read ahead buffer.  Used for redo.
(atom! Bytes* readbuf2    [])

;; Get one byte from a read buffer.
;; If "advance" is true, go to the next char.
;; No translation is done, KB_SPECIAL is escaped.

(defn- #_byte read-readbuf [#_Bytes*' a'buf, #_boolean advance]
    (when' (pos? (count @a'buf)) => NUL ;; buffer is empty
        (let [#_Bytes s (... @a'buf 0) #_byte b (.at s 0)]
            (when advance
                (if (eos? s 1)
                    (swap! a'buf subvec 1)
                    (swap! a'buf assoc 0 (.plus s 1))
                ))
            b)
    ))

;; Get one byte from the read buffers.
;; Use "readbuf1" first, then use "readbuf2" if prior is empty.
;; If "advance" is true, go to the next char.
;; No translation is done, KB_SPECIAL is escaped.

(defn- #_byte read-readbuffers [#_boolean advance]
    (let [#_byte b (read-readbuf readbuf1, advance)]
        (if (== b NUL) (read-readbuf readbuf2, advance) b)
    ))

;; Return true if the stuff buffer is empty.

(defn- #_boolean stuff-empty []
    (and (zero? (count @readbuf1)) (zero? (count @readbuf2))))

;; Remove the contents of the stuff buffer and the mapped characters in the typeahead buffer (used in case of an error).
;; If "flush_typeahead" is true, flush all typeahead characters (used when interrupted by a CTRL-C).

(defn- #_window_C flush-buffers [#_window_C win, #_boolean flush_typeahead]
    (init-typebuf)
    (while (!= (read-readbuffers true) NUL)
        nil)
    (when' flush_typeahead => win
        ;; We have to get all characters, because we may delete the first part of an escape sequence.
        ;; In an xterm we get one char at a time and we have to get them all.
        (let [win (loop [win win]
                    (let [t @typebuf [win ?] (inchar? win, (:tb_buf t), (dec (:tb_buflen t)), 10, (:tb_change_cnt t))]
                        (recur-if (non-zero? ?) win => win))
                )]
            (swap! typebuf assoc :tb_off MAXMAPLEN :tb_len 0)
            win)
    ))

;; The previous contents of the redo buffer is kept in "old_redobuff".
;; This is used for the CTRL-O <.> command in Insert mode.

(defn- #_void reset-redo []
    (when (not @block_redo)
        (reset! old_redobuff @redobuff)
        (reset! redobuff []))
    nil)

;; Discard the contents of the redo buffer and restore the previous redo buffer.

(defn- #_void cancel-redo []
    (when (not @block_redo)
        (reset! redobuff @old_redobuff)
        (reset! old_redobuff [])
        (while (!= (read-readbuffers true) NUL)
            nil
        ))
    nil)

;; Append "s" to the redo buffer.
;; KB_SPECIAL should already have been escaped.

(defn- #_void append-redo [#_Bytes s]
    (when (not @block_redo)
        (swap! redobuff add-buff s, -1))
    nil)

;; Append to Redo buffer literally, escaping special characters with CTRL-V.
;; KB_SPECIAL is escaped as well.

(defn- #_void append-redo-lit [#_Bytes str, #_int len]
    ;; len: length of "str" or -1 for up to the NUL
    (when-not @block_redo
        (let [a's (atom (#_Bytes object str))]
            (loop-when [] (if (< len 0) (non-eos? @a's) (< (BDIFF @a's, str) len))
                ;; Put a string of normal characters in the redo buffer (that's faster).
                (let [#_Bytes start @a's]
                    (while (and (<= (byte \space) (.at @a's 0)) (< (.at @a's 0) DEL) (or (< len 0) (< (BDIFF @a's, str) len)))
                        (swap! a's inc))
                    ;; Don't put '0' or '^' as last character, just in case a CTRL-D is typed next.
                    (when (and (eos? @a's) (any == (.at @a's -1) (byte \0) (byte \^)))
                        (swap! a's dec))
                    (when (BLT start, @a's)
                        (swap! redobuff add-buff start, (BDIFF @a's, start)))
                    (when (and (non-eos? @a's) (not (<= 0 len (BDIFF @a's, str))))
                        ;; Handle a special or multibyte character.  ;; Handle composing chars separately.
                        (let [#_int c (us-ptr2char-adv a's, false)]
                            (when (or (< c (byte \space)) (== c DEL) (and (eos? @a's) (any == c (byte \0) (byte \^))))
                                (swap! redobuff add-char-buff Ctrl_V))
                            ;; CTRL-V '0' must be inserted as CTRL-V 048
                            (if (and (eos? @a's) (== c (byte \0)))
                                (swap! redobuff add-buff (u8 "048"), 3)
                                (swap! redobuff add-char-buff c))
                            (recur)
                        ))
                ))
        ))
    nil)

;; Append a character to the redo buffer.
;; Translates special keys, NUL, KB_SPECIAL and multibyte characters.

(defn- #_void append-redo-char [#_int c]
    (when (not @block_redo)
        (swap! redobuff add-char-buff c))
    nil)

;; Append a number to the redo buffer.

(defn- #_void append-redo-number [#_long n]
    (when (not @block_redo)
        (swap! redobuff add-num-buff n))
    nil)

;; Append string "s" to the stuff buffer.
;; KB_SPECIAL must already have been escaped.

(defn- #_void stuff-string
    ([#_Bytes s] (stuff-string s, -1))
    ([#_Bytes s, #_long len] (swap! readbuf1 add-buff s, len) nil))

;; Append string "s" to the redo stuff buffer.
;; KB_SPECIAL must already have been escaped.

(defn- #_void stuff-redo [#_Bytes s]
    (swap! readbuf2 add-buff s, -1)
    nil)

;; Append a character to the stuff buffer.
;; Translates special keys, NUL, KB_SPECIAL and multibyte characters.

(defn- #_void stuff-char [#_int c]
    (swap! readbuf1 add-char-buff c)
    nil)

;; Append a number to the stuff buffer.

(defn- #_void stuff-num [#_long n]
    (swap! readbuf1 add-num-buff n)
    nil)

(atom! Bytes* redo_now)

;; Prepare for redo; return false if nothing to redo, true otherwise.
;; If "old?" is true, use "old_redobuff" instead of "redobuff".

(defn- #_boolean init-redo [#_boolean old?]
    (reset! redo_now (if old? @old_redobuff @redobuff))
    (pos? (count @redo_now)))

;; Read a character from the redo buffer.
;; Translates KB_SPECIAL and multibyte characters.
;; The redo buffer is left as it is.

(defn- #_int read-redo []
    (when' (pos? (count @redo_now)) => NUL
        ;; For a multi-byte character get all the bytes and return the converted character.
        (let [s (... @redo_now 0) n (if (or (not-at? s KB_SPECIAL) (at? s 1 KS_SPECIAL)) (mb-byte2len (char_u (.at s 0))) 1) q (Bytes. (inc MB_MAXBYTES))]
            (loop [s s i 0] ;; special key or escaped KB_SPECIAL
                (let [[c m] (if (at? s KB_SPECIAL) [(toSpecial (.at s 1), (.at s 2)) 3] [(char_u (.at s 0)) 1])
                      s (if (eos? s m) (first (swap! redo_now subvec 1)) (do (swap! redo_now assoc 0 (.plus s m)) s))]
                    (.be q i, c)
                    (cond
                        (== i (dec n)) (if (!= n 1) (us-ptr2char q) c) ;; last byte of a character
                        (some? s)      (recur s (inc i))
                        :else          NUL ;; cannot happen?
                    ))
            ))
    ))

;; Stuff the redo buffer into "readbuf2".
;; Insert the redo count into the command.
;; If "old?" is true, the last but one command is repeated instead of the last command (inserting text).
;; This is used for CTRL-O <.> in Insert mode.
;;
;; Return false for failure, true otherwise.

(defn- #_boolean start-redo [#_window_C win, #_long count, #_boolean old?]
    (and (init-redo old?)
        (let [c (read-redo)
              ;; copy the buffer name, if present
              c (if (== c (byte \"))  ;; """
                    (let [_ (swap! readbuf2 add-buff (u8 "\""), 1)
                          c (read-redo) c (if (< (byte \0) c (byte \9)) (inc c) c)] ;; if a numbered buffer is used, increment the number
                        (swap! readbuf2 add-char-buff c)
                        (read-redo))
                    c)
              c (if (== c (byte \v))   ;; redo Visual
                    (do
                        (reset! VIsual_cursor (:w_cursor win))
                        (reset! VIsual_active true)
                        (reset! VIsual_select false)
                        (reset! VIsual_reselect true)
                        (reset! redo_VIsual_busy true)
                        (read-redo))
                    c)
              ;; try to enter the count (in place of a previous count)
              c (if (non-zero? count)
                    (let [c (loop-when-recur c (asc-isdigit c) (read-redo) => c)] ;; skip "old" count
                        (swap! readbuf2 add-num-buff count)
                        c)
                    c)]
            ;; copy from the redo buffer into the stuff buffer
            (swap! readbuf2 add-char-buff c)
            (loop-when-recur [c (read-redo)] (!= c NUL) [(read-redo)] => true
                (swap! readbuf2 add-char-buff c)
            ))
    ))

;; Repeat the last insert (R, o, O, a, A, i or I command) by stuffing the redo buffer into "readbuf2".
;; Return false for failure, true otherwise.

(defn- #_boolean start-redo-ins []
    (and (init-redo false)
        (do ;; skip the count and the command character
            (loop-when [c (read-redo)] (!= c NUL)
                (if (some? (vim-strchr (u8 "AaIiRrOo"), c))
                    (when (any == c (byte \O) (byte \o))
                        (swap! readbuf2 add-buff NL_STR, -1))
                    (recur (read-redo))
                ))
            ;; copy the typed text from the redo buffer into the stuff buffer
            (loop-when-recur [c (read-redo)] (!= c NUL) [(read-redo)]
                (swap! readbuf2 add-char-buff c))
            (reset! block_redo true)
            true)
    ))

(defn- #_void stop-redo-ins []
    (reset! block_redo false)
    nil)

(final int TYPELEN_INIT    (* 5 (+ MAXMAPLEN 3)))

;; Initialize typebuf.

(defn- #_void init-typebuf []
    (when (nil? (:tb_buf @typebuf))
        (swap! typebuf assoc
            :tb_buf (Bytes. TYPELEN_INIT)
            :tb_buflen TYPELEN_INIT
            :tb_len 0
            :tb_off 0
            :tb_change_cnt 1)
    )
    nil)

;; Insert a string in the typeahead buffer.

(defn- #_void ins-typebuf [#_Bytes str]
    (init-typebuf)
    (swap! typebuf update :tb_change_cnt inc)
    (if (zero? (:tb_change_cnt @typebuf))
        (swap! typebuf assoc :tb_change_cnt 1))
    (let [#_int addlen (STRLEN str)]
        ;; Easy case: there is room in front of typebuf.tb_buf[typebuf.tb_off].
        (cond (<= addlen (:tb_off @typebuf))
        (do
            (swap! typebuf update :tb_off - addlen)
            (BCOPY (:tb_buf @typebuf), (:tb_off @typebuf), str, 0, addlen)
        )
        :else
        ;; Need to allocate a new buffer.
        ;; In typebuf.tb_buf there must always be room for 3 * MAXMAPLEN + 4 characters.
        ;; We add some extra room to avoid having to allocate too often.
        (let [#_int newoff (+ MAXMAPLEN 4)
              #_int newlen (+ (:tb_len @typebuf) addlen newoff (* 4 (+ MAXMAPLEN 4)))
              #_Bytes newbuf (Bytes. newlen)]
            ;; copy the new chars
            (BCOPY newbuf, newoff, str, 0, addlen)
            ;; copy the old chars, after the insertion point, including the NUL at the end
            (BCOPY newbuf, (+ newoff addlen), (:tb_buf @typebuf), (:tb_off @typebuf), (inc (:tb_len @typebuf)))
            (swap! typebuf assoc :tb_buf newbuf :tb_buflen newlen :tb_off newoff)
        ))
        (swap! typebuf update :tb_len + addlen))
    nil)

;; Put character "c" back into the typeahead buffer.
;; Can be used for a character obtained by vgetc() that needs to be put back.
;; Uses "key_typed" to restore the flags belonging to the char.

(defn- #_void ins-char-typebuf [#_int c]
    (let [#_Bytes buf (Bytes. (inc MB_MAXBYTES))]
        (if (is-special c)
            (-> buf (.be 0, KB_SPECIAL) (.be 1, (KB-SECOND c)) (.be 2, (KB-THIRD c)) (eos! 3))
            (eos! buf (utf-char2bytes c, buf)))
        (ins-typebuf buf))
    nil)

;; Return true if the typeahead buffer was changed (while waiting for a character to arrive).
;; Happens when a message was received from a client or from feedkeys().
;; But check in a more generic way to avoid trouble: When "typebuf.tb_buf"
;; changed it was reallocated and the old pointer can no longer be used.
;; Or "typebuf.tb_off" may have been changed and we would overwrite characters that was just added.

(defn- #_boolean typebuf-changed [#_int cnt]
    ;; cnt: old value of typebuf.tb_change_cnt
    (and (non-zero? cnt) (!= (:tb_change_cnt @typebuf) cnt)))

;; Remove "len" characters from typebuf.tb_buf[typebuf.tb_off].

(defn- #_void del-typebuf [#_int len]
    (when (non-zero? len)
        (swap! typebuf update :tb_len - len)
        (if (<= (+ (* 3 MAXMAPLEN) 3) (- (:tb_buflen @typebuf) (+ (:tb_off @typebuf) len)))
            (swap! typebuf update :tb_off + len)
            (let [#_int i (:tb_off @typebuf)]
                ;; leave some extra room at the end to avoid reallocation
                (swap! typebuf update :tb_off min MAXMAPLEN)
                ;; adjust typebuf.tb_buf (include the NUL at the end)
                (BCOPY (:tb_buf @typebuf), (:tb_off @typebuf), (:tb_buf @typebuf), (+ i len), (inc (:tb_len @typebuf)))
            ))
        (swap! typebuf update :tb_change_cnt inc)
        (when (zero? (:tb_change_cnt @typebuf))
            (swap! typebuf assoc :tb_change_cnt 1)
        ))
    nil)

;; Write typed characters to script file.
;; If recording is on, put the character into "recordbuff".

(defn- #_window_C gotchars [#_window_C win, #_Bytes chars, #_int len]
    (let [#_Bytes s (Bytes. 2)]
        ;; Remember how many chars were last recorded.
        (when @Recording (swap! last_recorded_len + len))
        ;; Handle one byte at a time; no translation to be done.
        (dotimes [#_int i len]
            (let [#_byte c (.at chars i)]
                (updatescript c)
                (when @Recording
                    (swap! recordbuff add-buff (.be s 0, c), 1))
            ))
        (may-sync-undo win)
    ))

;; Sync undo.
;; Called when typed characters are obtained from the typeahead buffer.
;; Do not sync:
;; - In Insert mode, unless cursor key has been used.
;; - While reading a script file.
;; - When "no_u_sync" is non-zero.

(defn- #_window_C may-sync-undo [#_window_C win]
    (when' (or (non-flag? @State (+ INSERT CMDLINE)) @arrow_used) => win
        (u-sync win, false)
    ))

(atom! int old_char         -1) ;; character put back by vungetc()
(atom! int old_mod_mask)        ;; "mod_mask" for ungotten character

;; This function is called just before doing a blocking wait.
;; Thus after waiting 'updatetime' for a character to arrive.

(defn- #_void before-blocking []
    (updatescript NUL)
    nil)

;; updatescipt() is called when a character can be written into the script file
;; or when we have waited some time for a character (c == 0)

(defn- #_void updatescript [#_byte c]
;   
    nil)

;; Get the next input character.
;; Can return a special key or a multi-byte character.
;; Can return NUL when called recursively, use safe-vgetc() if that's not wanted.
;; This translates escaped KB_SPECIAL bytes to a KB_SPECIAL byte.
;; Collects the bytes of a multibyte character into the whole character.
;; Returns the modifiers in the global "mod_mask".

(defn- #_[window_C int] vgetc? [#_window_C win]
    (if (!= @old_char -1)
        (let [#_int c @old_char]
            ;; If a character was put back with vungetc, it was already processed.
            ;; Return it directly.
            (reset! old_char -1)
            (reset! mod_mask @old_mod_mask)
            [win c]
        )
        (do
            (reset! mod_mask 0)
            (reset! last_recorded_len 0)

            (let [[win #_int c]
                    (loop [win win] ;; this is done twice if there are modifiers
                        (when (non-zero? @mod_mask) (swap! no_mapping inc) (swap! allow_keys inc)) ;; no mapping after modifier has been read
                        (let [[win c1] (vgetorpeek? win, true)]
                            (when (non-zero? @mod_mask) (swap! no_mapping dec) (swap! allow_keys dec))
                            (if (== c1 (char_u KB_SPECIAL)) ;; get two extra bytes for special keys
                                (let [_ @allow_keys]
                                    (swap! no_mapping inc)
                                    (reset! allow_keys 0) ;; make sure BS is not found
                                    (let [[win c2] (vgetorpeek? win, true) [win c3] (vgetorpeek? win, true)] ;; no mapping for these chars
                                        (swap! no_mapping dec)
                                        (reset! allow_keys _)
                                        (if (== c2 (char_u KS_MODIFIER))
                                            (do (reset! mod_mask c3) (recur win))
                                            [win (toSpecial (byte c2), (byte c3))]
                                        )))
                                [win c1]
                            )))

                  ;; a keypad or special function key was not mapped, use it like its ASCII equivalent
                  c (condp ==? c
                        K_KPLUS     (byte \+)
                        K_KMINUS    (byte \-)
                        K_KDIVIDE   (byte \/)
                        K_KMULTIPLY (byte \*)
                        K_KENTER    CAR
                        K_KPOINT    (byte \.)
                        K_K0        (byte \0)
                        K_K1        (byte \1)
                        K_K2        (byte \2)
                        K_K3        (byte \3)
                        K_K4        (byte \4)
                        K_K5        (byte \5)
                        K_K6        (byte \6)
                        K_K7        (byte \7)
                        K_K8        (byte \8)
                        K_K9        (byte \9)
                       [K_XHOME
                        K_ZHOME]    (cond (== @mod_mask MOD_MASK_SHIFT) (do (reset! mod_mask 0) K_S_HOME)
                                          (== @mod_mask MOD_MASK_CTRL)  (do (reset! mod_mask 0) K_C_HOME) :else K_HOME)
                       [K_XEND
                        K_ZEND]     (cond (== @mod_mask MOD_MASK_SHIFT) (do (reset! mod_mask 0) K_S_END)
                                          (== @mod_mask MOD_MASK_CTRL)  (do (reset! mod_mask 0) K_C_END)  :else K_END)
                        K_XUP       K_UP
                        K_XDOWN     K_DOWN
                        K_XLEFT     K_LEFT
                        K_XRIGHT    K_RIGHT
                    c)

                  #_int n (mb-byte2len c)]
                ;; For a multi-byte character get all the bytes and return the converted character.
                ;; Note: This will loop until enough bytes are received!
                (when' (< 1 n) => [win c]
                    (let [#_Bytes s (Bytes. (inc MB_MAXBYTES)) _ (.be s 0, c)
                          _ (swap! no_mapping inc)
                          win (loop-when [win win i 1] (< i n) => win
                                (let [[win c] (vgetorpeek? win, true) _ (.be s i, c)
                                      ;; Must be a KB_SPECIAL - KS_SPECIAL - KE_FILLER sequence, which represents a KB_SPECIAL (0x80).
                                      win (when' (at? s i KB_SPECIAL) => win
                                            (let [[win _] (vgetorpeek? win, true)] win)
                                        )]
                                    (recur win (inc i)))
                            )]
                        (swap! no_mapping dec)
                        [win (us-ptr2char s)]
                    ))
            ))
    ))

(defn- #_window_C vflush [#_window_C win]
    (let [[win _] (vgetc? win)]
        win
    ))

;; Like vgetc(), but never return a NUL when called recursively,
;; get a key directly from the user (ignoring typeahead).

(defn- #_[window_C int] safe-vgetc? [#_window_C win]
    (let [[win c] (vgetc? win)] (if (== c NUL) (get-keystroke? win) [win c])))

;; Like safe-vgetc(), but loop to handle K_IGNORE.
;; Also ignore scrollbar events.

(defn- #_[window_C int] plain-vgetc? [#_window_C win]
    (loop-when-recur [[win c :as _] (safe-vgetc? win)] (any == c K_IGNORE K_VER_SCROLLBAR K_HOR_SCROLLBAR) [(safe-vgetc? win)] => _))

;; Check if a character is available, such that vgetc() will not block.
;; If the next character is a special character or multi-byte, the returned character is not valid!

(defn- #_[window_C int] vpeekc? [#_window_C win]
    (if (!= @old_char -1) [win @old_char] (vgetorpeek? win, false)))

;; Call vpeekc() without causing anything to be mapped.
;; Return true if a character is available, false otherwise.

(defn- #_boolean char-avail []
    (let [_ (swap! no_mapping inc) #_int c (let [[_ ?] (vpeekc? (ยง @curwin))] (ยง reset! curwin _) ?) _ (swap! no_mapping dec)] (!= c NUL)))

;; unget one character (can only be done once!)
(defn- #_void vungetc [#_int c]
    (reset! old_char c)
    (reset! old_mod_mask @mod_mask)
    nil)

(atom! int __tc)

;; Get a character:
;;
;; 1. from the stuffbuffer
;;      This is used for abbreviated commands like "D" -> "d$".
;;      Also used to redo a command for ".".
;; 2. from the typeahead buffer
;;      Stores text obtained previously but not used yet.
;;      Also stores the result of mappings.
;;      Also used for the ":normal" command.
;; 3. from the user
;;      This may do a blocking wait if "advance" is true.
;;
;; If "advance" is true (vgetc()):
;;      Really get the character.
;;      "key_typed" is set to true in the case the user typed the key.
;;      "key_stuffed" is true if the character comes from the stuff buffer.
;; If "advance" is false (vpeekc()):
;;      Just look whether there is a character available.
;;
;; When "no_mapping" is zero, checks for mappings in the current mode.
;; Only returns one byte (of a multi-byte character).
;; KB_SPECIAL may be escaped, need to get two more bytes then.

(defn- #_[window_C int] vgetorpeek? [#_window_C win, #_boolean advance]
    ;; This function doesn't work very well when called recursively.
    ;; It may happen though, because of:
    ;;
    ;; 1. The call to add-to-showcmd(). char-avail() is then used to check
    ;; if there is a character available, which calls this function.
    ;; In that case we must return NUL, to indicate no character is available.
    ;;
    ;; 2. A GUI callback function writes to the screen, causing a wait-return().
    ;; Using ":normal" can also do this, but it saves the typeahead buffer,
    ;; thus it should be OK.  But don't get a key from the user then.
    (if (pos? @vgetc_busy)
        [win NUL]

        (let [_ (swap! vgetc_busy inc)
              _ (when advance
                    (reset! key_stuffed false))
              _ (init-typebuf)
              _ (when advance
                    (reset! exec_reg false))
              a'timedout (atom (boolean false))     ;; waited for more than 1 second for mapping to complete
              a'mode_deleted (atom (boolean false)) ;; set when mode has been deleted
              [win #_int c]
                (loop [win win]
                    ;; Get a character: 1. from the stuffbuffer.
                    (let [c (char_u (read-readbuffers advance))
                          [win c]
                            (if (and (!= c NUL) (not @got_int))
                                (do (when advance ;; [sic!
                                        ;; key_typed = false;
                                        ;; When the command that stuffed something was typed, behave like the stuffed command was typed;
                                        ;; needed e.g. for CTRL-W CTRL-] to open a fold.
                                        (reset! key_stuffed true))
                                    [win c])
                                ;; Loop until we either find a matching mapped key or we are sure that it is not a mapped key.
                                ;; If a mapped key sequence is found, we go back to the start to try re-mapping.
                                (loop [win win]
                                    (ui-breakcheck) ;; check for CTRL-C
                                    (cond @got_int
                                        (let [[win #_int len] (inchar? win, (:tb_buf @typebuf), (dec (:tb_buflen @typebuf)), 0, (:tb_change_cnt @typebuf)) ;; flush all input
                                              ;; If inchar() returns true (script file was active) or we are inside a mapping, get out of Insert mode.
                                              ;; Otherwise we behave like having gotten a CTRL-C.
                                              ;; As a result, typing CTRL-C in Insert mode will really insert a CTRL-C.
                                              c (if (and (non-zero? len) (flag? @State (+ INSERT CMDLINE))) ESC Ctrl_C)
                                              win (flush-buffers win, true) ;; flush all typeahead
                                              win (when' advance => win
                                                    ;; Also record this character, it might be needed to get out of Insert mode.
                                                    (.be (:tb_buf @typebuf) 0, c)
                                                    (gotchars win, (:tb_buf @typebuf), 1)
                                                )]
                                            [win c])
                                    :else
                                        (let-when [[win #_int keylen ?]
                                                (when' (< 0 (:tb_len @typebuf)) => [win 0 nil]
                                                    ;; When no matching mapping found or found a non-matching mapping
                                                    ;; that matches at least what the matching mapping matched:
                                                    ;; Check if we have a terminal code, when:
                                                    ;; - mapping is allowed,
                                                    ;; - keys have not been mapped,
                                                    ;; - and when not timed out.
                                                    (let [keylen
                                                            (if (and (or (zero? @no_mapping) (non-zero? @allow_keys)) (not @a'timedout))
                                                                (let [keylen (check-termcode nil, 0, nil)]
                                                                    ;; When getting a partial match, but the last characters were not typed,
                                                                    ;; don't wait for a typed character to complete the termcode.
                                                                    ;; This helps a lot when a ":normal" command ends in an ESC.
                                                                    (if (and (< keylen 0) (zero? (:tb_len @typebuf))) 0 keylen))
                                                                0)]
                                                        (cond (zero? keylen)                    ;; no matching terminal code
                                                            ;; Get a character: 2. from the typeahead buffer.
                                                            (let [c (& (.at (:tb_buf @typebuf) (:tb_off @typebuf)) 0xff)
                                                                  win (when' advance => win     ;; remove chars from "tb_buf"
                                                                        (reset! key_typed true)
                                                                        (let [win (gotchars win, (.plus (:tb_buf @typebuf) (:tb_off @typebuf)), 1)]
                                                                            (del-typebuf 1)
                                                                            win)
                                                                    )]
                                                                [win nil :break])               ;; got character, break for loop
                                                        (< 0 keylen)                            ;; full matching terminal code
                                                            [win nil :recur]                    ;; try mapping again
                                                        :else
                                                            ;; Partial match: get some more characters.
                                                            [win KEYLEN_PART_KEY nil]
                                                        ))
                                                )] (not ?) => (if (== ? :recur) (recur win) [win c])

                                            ;; Get a character: 3. from the user - handle <Esc> in Insert mode.

                                            ;; Special case: if we get an <ESC> in Insert mode and there are no more characters
                                            ;; at once, we pretend to go out of Insert mode.  This prevents the one second delay
                                            ;; after typing an <ESC>.  If we get something after all, we may have to redisplay
                                            ;; the mode.  That the cursor is in the wrong place does not matter.
                                            (let [a'len (atom (int 0))
                                                  ? (and advance
                                                         (== (:tb_len @typebuf) 1) (at? (:tb_buf @typebuf) (:tb_off @typebuf) ESC)
                                                         (zero? @no_mapping) (flag? @State INSERT)
                                                         (or @p_timeout (and (== keylen KEYLEN_PART_KEY) @p_ttimeout)))
                                                  [win ?]
                                                    (when' ? => [win false]
                                                        (let [t @typebuf [win ?] (inchar? win, (.plus (:tb_buf t) (+ (:tb_off t) (:tb_len t))), 3, 25, (:tb_change_cnt t))]
                                                            [win (zero? (reset! a'len ?))]
                                                        ))
                                                  [win #_int new_wcol #_int new_wrow]
                                                    (when' ? => [win (:w_wcol win) (:w_wrow win)]
                                                        (let [_ (when @mode_displayed (unshowmode true) (reset! a'mode_deleted true))
                                                              win (validate-cursor win) o'wcol (:w_wcol win) o'wrow (:w_wrow win)
                                                              ;; move cursor left, if possible
                                                              win (when' (non-zero? (:col (:w_cursor win))) => win
                                                                    (let [[win #_int col]
                                                                            (cond (< 0 (:w_wcol win))
                                                                                (if @did_ai
                                                                                    ;; We are expecting to truncate the trailing white-space,
                                                                                    ;; so find the last non-white character.
                                                                                    (let [win (assoc win :w_wcol 0) #_Bytes s (ml-get (:lnum (:w_cursor win)))
                                                                                          win (loop-when [win win #_int vcol 0 #_int i 0] (< i (:col (:w_cursor win))) => win
                                                                                                (let [win (if (not (vim-iswhite (.at s i))) (assoc win :w_wcol vcol) win)
                                                                                                      vcol (+ vcol (lbr-chartabsize win, s, (.plus s i), vcol))]
                                                                                                    (recur win vcol (+ i (us-ptr2len-cc s, i)))
                                                                                                ))
                                                                                          win (assoc win :w_wrow (+ (:w_cline_row win) (/ (:w_wcol win) (:w_width win))))
                                                                                          win (update win :w_wcol % (:w_width win))
                                                                                          win (update win :w_wcol + (win-col-off win))]
                                                                                        [win 0]) ;; no correction needed
                                                                                    (let [win (update win :w_wcol dec)]
                                                                                        [win (dec (:col (:w_cursor win)))]
                                                                                    ))
                                                                            (and @(:wo_wrap (:w_options win)) (< 0 (:w_wrow win)))
                                                                                (let [win (update win :w_wrow dec) win (assoc win :w_wcol (dec (:w_width win)))]
                                                                                    [win (dec (:col (:w_cursor win)))])
                                                                            :else
                                                                                [win 0]
                                                                            )]
                                                                        (when' (and (< 0 col) (< 0 (:w_wcol win))) => win
                                                                            ;; Correct when the cursor is on the right halve of a double-wide character.
                                                                            (let [#_Bytes s (ml-get (:lnum (:w_cursor win))) col (- col (us-head-off s, (.plus s col)))]
                                                                                (when' (< 1 (us-ptr2cells s, col)) => win
                                                                                    (update win :w_wcol dec))
                                                                            ))
                                                                    ))
                                                              win (setcursor win)
                                                              _ (out-flush)
                                                              new_wcol (:w_wcol win) new_wrow (:w_wrow win)]
                                                            [(assoc win :w_wcol o'wcol :w_wrow o'wrow) new_wcol new_wrow])
                                                    )]
                                                (if (< @a'len 0)
                                                    (recur win) ;; end of input script reached

                                                    (do (swap! typebuf update :tb_len + @a'len)
                                                        ;; buffer full, don't map
                                                        (if (<= MAXMAPLEN (:tb_len @typebuf))
                                                            (do (reset! a'timedout true)
                                                                (recur win))

                                                            ;; Get a character: 3. from the user - update display.

                                                            ;; In Insert mode a screen update is skipped when characters are still available.
                                                            ;; But when those available characters are part of a mapping, and we are going
                                                            ;; to do a blocking wait here.  Need to update the screen to display the changed
                                                            ;; text so far.  Also for when 'lazyredraw' is set and redrawing was postponed
                                                            ;; because there was something in the input buffer (e.g. termresponse).
                                                            (let [win (when' (and (or (flag? @State INSERT) @p_lz) (non-flag? @State CMDLINE) advance
                                                                                  (non-zero? @must_redraw) (not @need_wait_return)) => win
                                                                        (-> win (update-screen 0) (setcursor))) ;; put cursor back where it belongs
                                                                  ;; If we have a partial match (and are going to wait for more input from the user),
                                                                  ;; show the partially matched characters to the user with showcmd.
                                                                  [win #_int i #_int c1]
                                                                    (when' (and (< 0 (:tb_len @typebuf)) advance) => [win 0 0]
                                                                        (let [[win i c1]
                                                                                (when' (and (flag? @State (| NORMAL INSERT)) (!= @State HITRETURN)) => [win 0 0]
                                                                                    ;; this looks nice when typing a dead character map
                                                                                    (let [[win c1]
                                                                                            (if (and (flag? @State INSERT)
                                                                                                     (== (mb-ptr2cells (:tb_buf @typebuf),
                                                                                                                       (dec (+ (:tb_off @typebuf) (:tb_len @typebuf)))) 1))
                                                                                                (let [win (edit-putchar win, (.at (:tb_buf @typebuf)
                                                                                                                                  (dec (+ (:tb_off @typebuf)
                                                                                                                                          (:tb_len @typebuf)))), false)
                                                                                                      win (setcursor win)] ;; put cursor back where it belongs
                                                                                                    [win 1])
                                                                                                [win 0])
                                                                                          ;; need to use the col and row from above here
                                                                                          o'wcol (:w_wcol win) o'wrow (:w_wrow win)
                                                                                          win (assoc win :w_wcol new_wcol :w_wrow new_wrow)
                                                                                          _ (push-showcmd)
                                                                                          i (if (< SHOWCMD_COLS (:tb_len @typebuf)) (- (:tb_len @typebuf) SHOWCMD_COLS) 0)
                                                                                          [win i]
                                                                                            (loop-when [win win i i] (< i (:tb_len @typebuf)) => [win i]
                                                                                                (let [win (add-to-showcmd win, (.at (:tb_buf @typebuf) (+ (:tb_off @typebuf) i)))]
                                                                                                    (recur win (inc i)))
                                                                                            )]
                                                                                        [(assoc win :w_wcol o'wcol :w_wrow o'wrow) i c1])
                                                                                )]
                                                                            ;; this looks nice when typing a dead character map
                                                                            (if (and (flag? @State CMDLINE)
                                                                                     (== (mb-ptr2cells (:tb_buf @typebuf), (dec (+ (:tb_off @typebuf) (:tb_len @typebuf)))) 1))
                                                                                (do (putcmdline (.at (:tb_buf @typebuf) (dec (+ (:tb_off @typebuf) (:tb_len @typebuf)))), false)
                                                                                    [win i 1])
                                                                                [win i c1]
                                                                            )))
                                                                  ;; Get a character: 3. from the user - get it.
                                                                  #_int wait_tb_len (:tb_len @typebuf)
                                                                  [win ?] (inchar? win, (.plus (:tb_buf @typebuf) (+ (:tb_off @typebuf) (:tb_len @typebuf))),
                                                                                        (- (:tb_buflen @typebuf) (:tb_off @typebuf) (:tb_len @typebuf) 1),
                                                                                (cond (not advance)
                                                                                    0
                                                                                (or (zero? (:tb_len @typebuf)) (not (or @p_timeout (and @p_ttimeout (== keylen KEYLEN_PART_KEY)))))
                                                                                    -1
                                                                                :else
                                                                                    (if (and (== keylen KEYLEN_PART_KEY) (<= 0 @p_ttm)) @p_ttm @p_tm)
                                                                                ),
                                                                                        (:tb_change_cnt @typebuf))
                                                                  _ (reset! a'len ?)
                                                                  win (if (non-zero? i) (pop-showcmd win) win)
                                                                  win (when' (== c1 1) => win
                                                                        (let [win (if (flag? @State INSERT) (edit-unputchar win) win)]
                                                                            (if (flag? @State CMDLINE)
                                                                                (do (unputcmdline) win)
                                                                                (setcursor win) ;; put cursor back where it belongs
                                                                            ))
                                                                    )]
                                                                (cond (< @a'len 0) ;; end of input script reached
                                                                    (recur win)
                                                                (< 0 @a'len) ;; no character available
                                                                    (do (while (non-eos? (:tb_buf @typebuf) (+ (:tb_off @typebuf) (:tb_len @typebuf)))
                                                                            (swap! typebuf update :tb_len inc))
                                                                        (recur win))
                                                                advance
                                                                    (do (when (< 0 wait_tb_len) ;; timed out
                                                                            (reset! a'timedout true))
                                                                        (recur win))
                                                                :else
                                                                    [win NUL])
                                                            ))
                                                    ))
                                            ))
                                    ))
                            )]
                        (recur-if (or (< c 0) (and advance (== c NUL))) [win] => [win c]) ;; if advance is false, don't loop on NULs
                    ))
              ;; The "INSERT" message is taken care of here:
              ;;   if we return an ESC to exit Insert mode, the message is deleted;
              ;;   if we don't return an ESC, but deleted the message before, redisplay it.
              win (when' (and advance @p_smd (flag? @State INSERT)) => win
                    (cond (and (== c ESC) (not @a'mode_deleted) (zero? @no_mapping) @mode_displayed)
                        (if (and (non-zero? (:tb_len @typebuf)) (not @key_typed))
                            (do (reset! redraw_cmdline true) win)   ;; delete mode later
                            (do (unshowmode false) win))
                    (and (!= c ESC) @a'mode_deleted)
                        (if (and (non-zero? (:tb_len @typebuf)) (not @key_typed))
                            (do (reset! redraw_cmdline true) win)   ;; show mode later
                            (showmode win))
                    :else
                        win)
                )]
            (swap! vgetc_busy dec)
            [win c])
    ))

;; inchar() - get one character from
;;      1. a scriptfile
;;      2. the keyboard
;;
;; As much characters as we can get (upto "maxlen") are put in "buf" and NUL terminated (buffer length must be "maxlen" + 1).
;; Minimum for "maxlen" is 3!!!
;;
;; "tb_change_cnt" is the value of typebuf.tb_change_cnt if "buf" points into it.
;; When typebuf.tb_change_cnt changes (e.g. when a message is received from a remote client) "buf" can no longer be used.
;; "tb_change_cnt" is 0 otherwise.
;;
;; If we got an interrupt, all input is read until none is available.
;;
;; If "wait_time" == 0, there is no waiting for the char.
;; If "wait_time" == n, we wait for n msec for a character to arrive.
;; If "wait_time" == -1, we wait forever for a character to arrive.
;;
;; Return the number of obtained characters.
;; Return -1 when end of input script reached.

(defn- #_[window_C int] inchar? [#_window_C win, #_Bytes buf, #_int maxlen, #_long wait_time, #_int tb_change_cnt]
    ;; wait_time: milli seconds
    (when (or (== wait_time -1) (< 100 wait_time)) ;; flush output before waiting
        (cursor-on)
        (out-flush))
    ;; If we got an interrupt, skip all previously typed characters and return true if quit reading script file.
    ;; Stop reading typeahead when a single CTRL-C was read, fill-input-buf() returns this when not able to read from stdin.
    ;; Don't use *buf here, closescript() may have freed typebuf.tb_buf[] and "buf" may be pointing inside typebuf.tb_buf[].
    (if @got_int
        (let [#_int l (+ (* MAXMAPLEN 3) 3) #_Bytes s (Bytes. (inc l))]
            (loop [win win] (let [[win #_int n] (ui-inchar? win, s, l, 0, 0)] (if (or (zero? n) (and (== n 1) (at? s Ctrl_C))) [win 0] (recur win)))))
        (do ;; Always flush the output characters when getting input characters from the user.
            (out-flush)
            ;; Fill up to a third of the buffer, because each character may be tripled below.
            (let [[win #_int n] (ui-inchar? win, buf, (/ maxlen 3), wait_time, tb_change_cnt)]
                [win (if (typebuf-changed tb_change_cnt) 0 (fix-input-buffer buf, n))]
            ))
    ))

;; Fix typed characters for use by vgetc() and check-termcode().
;; buf[] must have room to triple the number of bytes!
;; Returns the new length.

(defn- #_int fix-input-buffer [#_Bytes buf, #_int len]
    ;; Two characters are special: NUL and KB_SPECIAL.
    ;; Replace        NUL by KB_SPECIAL KS_ZERO    KE_FILLER
    ;; Replace KB_SPECIAL by KB_SPECIAL KS_SPECIAL KE_FILLER
    (loop [#_Bytes s buf #_int n len #_int i (dec n)] (if (<= 0 i)
        ;; timeout may generate K_CURSORHOLD
        (if (or (eos? s) (and (at? s KB_SPECIAL) (or (< i 2) (not-at? s 1 KS_EXTRA) (not-at? s 2 KE_CURSORHOLD))))
            (do
                (BCOPY s, 3, s, 1, i)
                (let [c (char_u (.at s 0))] (-> s (.be 2, (KB-THIRD c)) (.be 1, (KB-SECOND c)) (.be 0, KB_SPECIAL)))
                (recur (.plus s 3) (+ n 2) (dec i))
            )
            (recur (.plus s 1) n (dec i)))
        (do (eos! s) n))
    ))

;; Return true when bytes are in the input buffer or in the typeahead buffer.

(defn- #_boolean input-available []
    (not (is-input-buf-empty)))

;; Escape KB_SPECIAL so that the result can be put in the typeahead buffer.

(defn- #_Bytes vim-strsave-escape-special [#_Bytes p]
    ;; Need a buffer to hold up to three times as much.
    (let [#_Bytes res (Bytes. (inc (* (STRLEN p) 3)))]
        (loop [#_Bytes d res #_Bytes s p] (if (non-eos? s)
            (if (and (at? s KB_SPECIAL) (non-eos? s 1) (non-eos? s 2))
            (do
                ;; Copy special key unmodified.
                (.be d 0, (.at s 0)) (.be d 1, (.at s 1)) (.be d 2, (.at s 2))
                (recur (.plus d 3) (.plus s 3))
            )
            (let [#_int end (us-ptr2len-cc s)
                ;; Add character, possibly multi-byte to destination, escaping KB_SPECIAL.
                  d (loop [#_int c (us-ptr2char s) d (add-char2buf c, d) #_int n (utf-char2len c)] (if (< n end)
                    ;; Add following combining char.
                    (recur (us-ptr2char s, n) (add-char2buf c, d) (+ n (utf-char2len c)))
                    d))]
                (recur d (.plus s end))
            ))
            (eos! d)
        ))
        res
    ))

;; Remove escaping from KB_SPECIAL characters.
;; Reverse of vim-strsave-escape-special().
;; Works in-place.

(defn- #_void vim-unescape-special [#_Bytes p]
    (loop [#_Bytes d p #_Bytes s p] (if (non-eos? s)
        (let [n (if (and (at? s KB_SPECIAL) (at? s 1 KS_SPECIAL) (at? s 2 KE_FILLER)) 3 1)]
            (recur (.plus (.be d 0, (.at s 0)) 1) (.plus s n)))
        (eos! d)
    ))
    nil)

;;; ============================================================================================== VimM

;; edit.c: functions for Insert mode --------------------------------------------------------------

(final int
    BACKSPACE_CHAR           1,
    BACKSPACE_WORD           2,
    BACKSPACE_WORD_NOT_SPACE 3,
    BACKSPACE_LINE           4)

(atom! int      insStart_textlen)               ;; length of line when insert started
(atom! int      insStart_blank_vcol)            ;; vcol for first inserted blank
(atom! boolean  update_insStart_orig    true)   ;; set "insStart_orig" to "insStart"

(atom! Bytes    last_insert)                    ;; the text of the previous insert, KB_SPECIAL is escaped
(atom! int      last_insert_skip)               ;; nr of chars in front of previous insert
(atom! int      new_insert_skip)                ;; nr of chars in front of current insert
(atom! int      did_restart_edit)               ;; "restart_edit" when calling edit()

(atom! boolean  can_cindent)                    ;; may do cindenting on this line

(atom! int      old_indent)                     ;; for ^^D command in insert mode

(atom! boolean  ins_need_undo)                  ;; call u-save() before inserting a char; set when edit() is called; after that arrow_used is used

(atom! long     o_lnum)

;; Start inserting text.
;;
;; "cmdchar" can be:
;; 'i'  normal insert command
;; 'a'  normal append command
;; 'R'  replace command
;; 'r'  "r<CR>" command: insert one <CR>.  Note: count can be > 1, for redo,
;;      but still only one <CR> is inserted.  The <Esc> is not used for redo.
;; 'g'  "gI" command
;; 'V'  "gR" command for Virtual Replace mode
;; 'v'  "gr" command for single character Virtual Replace mode
;;
;; This function is not called recursively.  For CTRL-O commands, it returns
;; and lets the caller handle the Normal-mode command.
;;
;; Return true if a CTRL-O command caused the return (insert mode pending).

(defn- #_[window_C boolean] edit? [#_window_C win, #_int cmdchar, #_boolean startln, #_long _count]
    ;; startln: if set, insert at start of line
    (let-when [a'count (atom (long _count))
          ;; Remember whether editing was restarted after CTRL-O.
          _ (reset! did_restart_edit @restart_edit)
          ;; sleep before redrawing, needed for "CTRL-O :" that results in an error message
          _ (check-for-delay true)
          ;; set "insStart_orig" to "insStart"
          _ (reset! update_insStart_orig true)
          ;; Don't allow changes in the buffer while editing the cmdline.
          ;; The caller of getcmdline() may get confused.
    ] (zero? @textlock) => [(emsg win, e_secure) false]

        (do ;; When doing a paste with the middle mouse button,
            ;; "insStart" is set to where the paste started.
            (if (non-zero? (:lnum @where_paste_started))
                (reset! insStart @where_paste_started)
                (do
                    (reset! insStart (:w_cursor win))
                    (when startln
                        (swap! insStart assoc :col 0))
                ))
            (reset! insStart_textlen (linetabsize win, (ml-get (:lnum (:w_cursor win)))))
            (reset! insStart_blank_vcol MAXCOL)
            (when (not @did_ai)
                (reset! ai_col 0))
            (when (and (!= cmdchar NUL) (zero? @restart_edit))
                (reset-redo)
                (append-redo-number @a'count)
                (if (any == cmdchar (byte \V) (byte \v))
                    (do ;; "gR" or "gr" command
                        (append-redo-char (byte \g))
                        (append-redo-char (if (== cmdchar (byte \v)) (byte \r) (byte \R))))
                    (do
                        (append-redo-char cmdchar)
                        (cond
                            (== cmdchar (byte \g)) (append-redo-char (byte \I)) ;; "gI" command
                            (== cmdchar (byte \r)) (reset! a'count 1)           ;; "r<CR>" command ;; insert only one <CR>
                        ))
                ))
            (let [#_int replaceState
                    (condp ==? cmdchar
                        (byte \R)            (do (reset! State REPLACE)                                                                            REPLACE)
                       [(byte \V) (byte \v)] (do (reset! State VREPLACE) (reset! orig_line_count (line-count @curbuf)) (reset! vr_lines_changed 1) VREPLACE)
                                             (do (reset! State INSERT)                                                                             REPLACE))
                  _ (reset! stop_insert_mode false)
                  ;; Need to recompute the cursor position, it might move when the cursor is on a TAB or special character.
                  win (curs-columns win, true)
                  win (clear-showcmd win)
                  ;; Handle restarting Insert mode.
                  ;; Don't do this for "CTRL-O ." (repeat an insert): we get here with "restart_edit" non-zero, and something in the stuff buffer.
                  win (if (and (non-zero? @restart_edit) (stuff-empty))
                        (do ;; After a paste we consider text typed to be part of the insert for the pasted text.
                            ;; You can backspace over the pasted text too.
                            (reset! arrow_used (zero? (:lnum @where_paste_started)))
                            (reset! restart_edit 0)
                            ;; If the cursor was after the end-of-line before the CTRL-O and it is now at the end-of-line,
                            ;; put it after the end-of-line (this is not correct in very rare cases).
                            ;; Also do this if curswant is greater than the current virtual column, e.g. after "^O$" or "^O80|".
                            (let [win (-> win (validate-virtcol) (update-curswant))
                                  win (if (or (and @ins_at_eol (== (:lnum (:w_cursor win)) @o_lnum)) (< (:w_virtcol win) (:w_curswant win)))
                                        (let-when [#_Bytes s (.plus (ml-get (:lnum (:w_cursor win))) (:col (:w_cursor win)))] (non-eos? s) => win
                                            (if (eos? s 1)
                                                (update-in win [:w_cursor :col] inc)
                                                (let-when [#_int n (us-ptr2len-cc s)] (eos? s n) => win
                                                    (update-in win [:w_cursor :col] + n))
                                            ))
                                        win
                                    )]
                                (reset! ins_at_eol false)
                                win
                            ))
                        (do (reset! arrow_used false)
                            win
                        ))
                  ;; We are in Insert mode now, don't need to start it anymore.
                  _ (reset! need_start_insertmode false)
                  ;; Need to save the line for undo before inserting the first char.
                  _ (reset! ins_need_undo true)
                  _ (swap! where_paste_started assoc :lnum 0)
                  _ (reset! can_cindent true)
                  ;; If 'showmode' is set, show the current (insert/replace/...) mode.
                  ;; A warning message for changing a readonly file is given here, before actually changing anything.
                  ;; It's put after the mode, if any.
                  win (if @p_smd (showmode win) win)]
                (ui-cursor-shape)           ;; may show different cursor shape
                (do-digraph -1)             ;; clear digraphs
                ;; Get the current length of the redo buffer,
                ;; those characters have to be skipped if we want to get to the inserted characters.
                (let [#_Bytes s (get-inserted)]
                    (reset! new_insert_skip (if (some? s) (STRLEN s) 0)))
                (reset! old_indent 0)
                (let [a'inserted_space (atom (boolean false))   ;; just inserted a space
                      a'did_backspace (atom (boolean true))     ;; previous char was backspace
                      a'old_topline (atom (long 0))             ;; topline before insertion
                      a'nomove (atom (boolean false))]          ;; don't move cursor on return

                    ;; Main loop in Insert mode: repeat until Insert mode is left.

                    (loop [win win #_int lastc 0 #_int c 0]
                        (when @arrow_used ;; don't repeat insert when arrow key used
                            (reset! a'count 0))
                        (when @update_insStart_orig
                            (reset! insStart_orig @insStart))
                        (let-when [[win lastc c recur?]
                                (if @stop_insert_mode
                                    ;; ":stopinsert" used or 'insertmode' reset
                                    (do (reset! a'count 0) [win lastc c nil])

                                    ;; set "w_curswant" for next K_DOWN or K_UP
                                    (let-when [win (if (not @arrow_used) (assoc win :w_set_curswant true) win)
                                          ;; When emsg() was called, "msg_scroll" will have been set.
                                          _ (reset! msg_scroll false)
                                          ;; If we inserted a character at the last position of the last line in the window,
                                          ;; scroll the window one line up.  This avoids an extra redraw.
                                          ;; This is detected when the cursor column is smaller after inserting something.
                                          ;; Don't do this when the topline changed already,
                                          ;; it has already been adjusted (by insert-char() calling open-line()).
                                          win (if (and (:b_mod_set @curbuf) @(:wo_wrap (:w_options win)) (not @a'did_backspace) (== (:w_topline win) @a'old_topline))
                                                (let [#_int mincol (:w_wcol win) win (validate-cursor-col win)]
                                                    (if (and (< (:w_wcol win) (- mincol @(:b_p_ts @curbuf)))
                                                             (== (:w_wrow win) (- (dec (+ (:w_winrow win) (:w_height win))) @p_so))
                                                             (!= (:lnum (:w_cursor win)) (:w_topline win)))
                                                        (set-topline win, (inc (:w_topline win)))
                                                        win
                                                    ))
                                                win)
                                          ;; May need to adjust "w_topline" to show the cursor.
                                          win (update-topline win)
                                          _ (reset! a'did_backspace false)
                                          win (validate-cursor win) ;; may set "must_redraw"
                                          ;; Redraw the display when no characters are waiting.
                                          ;; Also shows mode, ruler and positions cursor.
                                          win (ins-redraw win, true)
                                          win (update-curswant win)
                                          _ (reset! a'old_topline (:w_topline win))
                                          ;; Get a character for Insert mode.  Ignore K_IGNORE.
                                          lastc (if (!= c K_CURSORHOLD) c lastc) ;; remember the previous char for CTRL-D
                                          [win c] (loop [win win] (let [[win c] (safe-vgetc? win)] (recur-if (== c K_IGNORE) [win] => [win c])))
                                          ;; Don't want K_CURSORHOLD for the second key, e.g. after CTRL-V.
                                          _ (reset! did_cursorhold true)
                                          ;; CTRL-\ CTRL-N goes to Normal mode,
                                          ;; CTRL-\ CTRL-G goes to mode selected with 'insertmode',
                                          ;; CTRL-\ CTRL-O is like CTRL-O but without moving the cursor.
                                          [win c ?]
                                            (if (== c Ctrl_BSL)
                                                ;; may need to redraw when no more chars available now
                                                (let [win (ins-redraw win, false)
                                                      _ (swap! no_mapping inc) _ (swap! allow_keys inc) [win c] (plain-vgetc? win) _ (swap! no_mapping dec) _ (swap! allow_keys dec)]
                                                    (cond (and (!= c Ctrl_N) (!= c Ctrl_G) (!= c Ctrl_O))
                                                        (do ;; it's something else
                                                            (vungetc c)
                                                            [win Ctrl_BSL nil])
                                                    (and (== c Ctrl_G) @p_im)
                                                        [win c :recur]
                                                    :else
                                                        (do (when (== c Ctrl_O)
                                                                (ins-ctrl-o win)
                                                                (reset! ins_at_eol false) ;; cursor keeps its column
                                                                (reset! a'nomove true))
                                                            (reset! a'count 0)
                                                            [win c :quit])
                                                    ))
                                                [win c nil])
                                    ] (not ?) => [win lastc c (when (== ? :recur) ?)]

                                        (let-when [c (do-digraph c)] (and (!= c Ctrl_V) (!= c Ctrl_Q)) => [(ins-ctrl-v win) lastc Ctrl_V :recur] ;; pretend CTRL-V is last typed char

                                            ;; If 'keymodel' contains "startsel", may start selection.
                                            ;; If it does, a CTRL-O and c will be stuffed, we need to get these characters.
                                            (let-when [[win ?] (ins-start-select? win, c)] (not ?) => [win lastc c :recur]

                                                (let-when [[win c ?]
                                                        (let-when [ctrl-o #((ins-ctrl-o %)
                                                                            ;; Don't move the cursor left when 'virtualedit' has "onemore".
                                                                            (when (flag? @ve_flags VE_ONEMORE)
                                                                                (reset! ins_at_eol false)
                                                                                (reset! a'nomove true))
                                                                            (reset! a'count 0)
                                                                            nil)
                                                              [win c ?]
                                                                (condp ==? c ;; Big switch to handle a character in Insert mode.

                                                                   [Ctrl_C ESC]                                             ;; end input mode
                                                                        (let [[win ?]
                                                                                (cond (and (== c Ctrl_C) (non-zero? @cmdwin_type))
                                                                                    (do ;; Close the cmdline window.
                                                                                        (reset! cmdwin_result K_IGNORE)
                                                                                        (reset! got_int false)              ;; don't stop executing autocommands et al.
                                                                                        (reset! a'nomove true)
                                                                                        [win :quit])
                                                                                (goto-im) ;; When 'insertmode' set, don't leave Insert mode.
                                                                                    (let [win (when' @got_int => (do (beep) win)
                                                                                                (let [win (vflush win)]     ;; flush all buffers
                                                                                                    (reset! got_int false)
                                                                                                    win)
                                                                                            )]
                                                                                        [win :done])
                                                                                :else
                                                                                    [win :quit]
                                                                                )]
                                                                            [win c ?])

                                                                    Ctrl_Z                                                  ;; suspend when 'insertmode' set
                                                                        (if @p_im
                                                                            [win Ctrl_O (do (stuff-string (u8 ":st\r")) (ctrl-o win) :quit)]
                                                                            [win c nil])                                    ;; insert CTRL-Z as normal char

                                                                    Ctrl_O                                                  ;; execute one command
                                                                        [win c (do (ctrl-o win) :quit)]

                                                                   [K_INS K_KINS]                                           ;; toggle insert/replace mode
                                                                        [(ins-insert win, replaceState) c :done]

                                                                    K_SELECT
                                                                        [win c :done]

                                                                   [K_HELP K_F1 K_XF1]                                      ;; Help key works like <ESC> <Help>
                                                                        (do (stuff-char K_HELP)
                                                                            (when @p_im
                                                                                (reset! need_start_insertmode true))
                                                                            [win c :quit])

                                                                   [K_ZERO NUL Ctrl_A]                                      ;; insert the previously inserted text
                                                                        ;; For ^@ the trailing ESC will end the insert, unless there is an error.
                                                                        (let [[win ?] (stuff-inserted? win, NUL, 1, (== c Ctrl_A))
                                                                              ? (if (or ? (== c Ctrl_A) @p_im)
                                                                                    (do (reset! a'inserted_space false) :done)
                                                                                    :quit                                   ;; quit insert mode
                                                                                )]
                                                                            [win c ?])

                                                                    Ctrl_R                                                  ;; insert the contents of a register
                                                                        (let [win (ins-reg win)]
                                                                            (reset! a'inserted_space false)
                                                                            [win c :done])

                                                                    Ctrl_G                                                  ;; commands starting with CTRL-G
                                                                        [(ins-ctrl-g win) c :done]

                                                                    Ctrl_HAT
                                                                        [win c :done]

                                                                    Ctrl__
                                                                        [win c nil]

                                                                   [Ctrl_D Ctrl_T]                                          ;; make indent one shiftwidth smaller/greater
                                                                        (let [win (ins-shift win, c, lastc)]
                                                                            (reset! a'inserted_space false)
                                                                            [win c :done])

                                                                   [K_DEL K_KDEL]                                           ;; delete character under the cursor
                                                                        [(ins-del win) c :done]

                                                                   [K_BS Ctrl_H]                                            ;; delete character before the cursor
                                                                        (let [[win ?] (ins-bs? win, c, BACKSPACE_CHAR, a'inserted_space)]
                                                                            (reset! a'did_backspace ?)
                                                                            [win c :done])

                                                                    Ctrl_W                                                  ;; delete word before the cursor
                                                                        (let [[win ?] (ins-bs? win, c, BACKSPACE_WORD, a'inserted_space)]
                                                                            (reset! a'did_backspace ?)
                                                                            [win c :done])

                                                                    Ctrl_U                                                  ;; delete all inserted text in current line
                                                                        (let [[win ?] (ins-bs? win, c, BACKSPACE_LINE, a'inserted_space)]
                                                                            (reset! a'did_backspace ?)
                                                                            (reset! a'inserted_space false)
                                                                            [win c :done])

                                                                    K_IGNORE                                                ;; something mapped to nothing
                                                                        [win c :done]

                                                                    K_CURSORHOLD                                            ;; didn't type something for a while
                                                                        [win c (do (reset! did_cursorhold true) :done)]

                                                                   [K_HOME K_KHOME K_S_HOME K_C_HOME]                       ;; <Home>
                                                                        [(ins-home win, c) c :done]

                                                                   [K_END K_KEND K_S_END K_C_END]                           ;; <End>
                                                                        [(ins-end win, c) c :done]

                                                                    K_LEFT                                                  ;; <Left>
                                                                        (let [win (if (flag? @mod_mask (| MOD_MASK_SHIFT MOD_MASK_CTRL))
                                                                                    (ins-s-left win)
                                                                                    (ins-left win)
                                                                                )]
                                                                            [win c :done])

                                                                   [K_S_LEFT K_C_LEFT]                                      ;; <S-Left>
                                                                        [(ins-s-left win) c :done]

                                                                    K_RIGHT                                                 ;; <Right>
                                                                        (let [win (if (flag? @mod_mask (| MOD_MASK_SHIFT MOD_MASK_CTRL))
                                                                                    (ins-s-right win)
                                                                                    (ins-right win)
                                                                                )]
                                                                            [win c :done])

                                                                   [K_S_RIGHT K_C_RIGHT]                                    ;; <S-Right>
                                                                        [(ins-s-right win) c :done]

                                                                    K_UP                                                    ;; <Up>
                                                                        (let [win (if (flag? @mod_mask MOD_MASK_SHIFT)
                                                                                    (ins-pageup win)
                                                                                    (ins-up win, false)
                                                                                )]
                                                                            [win c :done])

                                                                   [K_S_UP K_PAGEUP K_KPAGEUP]                              ;; <S-Up>
                                                                        [(ins-pageup win) c :done]

                                                                    K_DOWN                                                  ;; <Down>
                                                                        (let [win (if (flag? @mod_mask MOD_MASK_SHIFT)
                                                                                    (ins-pagedown win)
                                                                                    (ins-down win, false)
                                                                                )]
                                                                            [win c :done])

                                                                   [K_S_DOWN K_PAGEDOWN K_KPAGEDOWN]                        ;; <S-Down>
                                                                        [(ins-pagedown win) c :done]

                                                                    K_DROP                                                  ;; drag-n-drop event
                                                                        [(ins-drop win) c :done]

                                                                   [TAB K_S_TAB]                                            ;; TAB
                                                                        (let [[win ?] (ins-tab? win)]
                                                                            (reset! a'inserted_space false)
                                                                            [win TAB (when (not ?) :done)])

                                                                   [K_KENTER CAR NL]                                        ;; <Enter>
                                                                        (let [c (if (== c K_KENTER) CAR c)]
                                                                            (if (non-zero? @cmdwin_type)
                                                                                (do ;; Execute the command in the cmdline window.
                                                                                    (reset! cmdwin_result CAR)
                                                                                    [win c :quit])
                                                                                (let-when [[win ?] (ins-eol? win, c)] (or ? @p_im) => [win c :quit]
                                                                                    (reset! a'inserted_space false)
                                                                                    [win c :done])
                                                                            ))

                                                                    Ctrl_K                                                  ;; digraph
                                                                        (let [[win c] (ins-digraph win)]
                                                                            [win c (when (== c NUL) :done)])

                                                                    Ctrl_L
                                                                        ;; CTRL-L with 'insertmode' set: Leave Insert mode.
                                                                        [win c (when @p_im :quit)]

                                                                   [Ctrl_Y Ctrl_E]                                          ;; copy from previous/next line or scroll down/up
                                                                        (let [[win c] (ins-ctrl-ey win, c)]
                                                                            [win c :done])

                                                                    (let [[win ?]
                                                                            (when' (== c @intr_char) => [win nil]           ;; special interrupt char
                                                                                ;; When 'insertmode' set, don't leave Insert mode.
                                                                                (when' (goto-im) => [win :quit]
                                                                                    (let [win (when' @got_int => (do (beep) win)
                                                                                                (let [win (vflush win)]     ;; flush all buffers
                                                                                                    (reset! got_int false)
                                                                                                    win)
                                                                                            )]
                                                                                        [win :done]
                                                                                    ))
                                                                            )]
                                                                        [win c ?]
                                                                    ))
                                                        ] (not ?) => [win c (when (== ? :quit) ?)]

                                                            ;; Insert a normal character.
                                                            (let-when [[win c ?]
                                                                    (if (not @p_paste)
                                                                        ;; Trigger InsertCharPre.
                                                                        (let [#_Bytes p (do-insert-char-pre c)
                                                                              [win c]
                                                                                (if (some? p)
                                                                                    (if (and (non-eos? p) (stop-arrow win))
                                                                                        ;; Insert the new value of v:char literally.
                                                                                        (let [win (loop-when [win win #_Bytes s p] (non-eos? s) => win
                                                                                                    (let [c (us-ptr2char s)
                                                                                                          win (if (any == c CAR K_KENTER NL) (ins-eol win, c) (ins-char win, c))]
                                                                                                        (recur win (.plus s (us-ptr2len-cc s))))
                                                                                                )]
                                                                                            (append-redo-lit p, -1)
                                                                                            [win NUL])
                                                                                        [win NUL])
                                                                                    [win c]
                                                                                )]
                                                                            ;; If the new value is already inserted or an empty string, don't insert any character.
                                                                            [win c (when (== c NUL) :done)])
                                                                        [win c nil]
                                                                    )] (not ?) => [win c nil]

                                                                ;; Try to perform smart-indenting.
                                                                (let [win (ins-try-si win, c)
                                                                      win (if (== c (byte \space))
                                                                            (do (reset! a'inserted_space true)
                                                                                (when (inindent win, 0)
                                                                                    (reset! can_cindent false))
                                                                                (if (and (== @insStart_blank_vcol MAXCOL) (== (:lnum (:w_cursor win)) (:lnum @insStart)))
                                                                                    (let [win (validate-virtcol win)]
                                                                                        (reset! insStart_blank_vcol (:w_virtcol win))
                                                                                        win)
                                                                                    win
                                                                                ))
                                                                            win
                                                                        )]
                                                                    ;; Insert a normal character and check for abbreviations on a special character.
                                                                    ;; Let CTRL-] expand abbreviations without inserting it.
                                                                    [(if (or (vim-iswordc c) (!= c Ctrl_RSB)) (insert-special win, c, false, false) win) c nil]
                                                                ))
                                                        )] (not ?) => [win lastc c nil]

                                                    ;; If typed something, it may trigger CursorHoldI again.
                                                    (when (!= c K_CURSORHOLD)
                                                        (reset! did_cursorhold false))
                                                    ;; If the cursor was moved, we didn't just insert a space.
                                                    (when @arrow_used
                                                        (reset! a'inserted_space false))
                                                    [win lastc c :recur]
                                                ))
                                        ))
                                )] (not recur?) => (recur win lastc c)

                            ;; This is the ONLY return from edit()!

                            ;; Always update "o_lnum", so a "CTRL-O ." that adds a line
                            ;; still puts the cursor back after the inserted text.
                            (when (and @ins_at_eol (== (gchar-cursor win) NUL))
                                (reset! o_lnum (:lnum (:w_cursor win))))
                            (let-when [[win ?] (ins-esc? win, a'count, cmdchar, @a'nomove)] ? => (recur win lastc c)
                                (reset! did_cursorhold false)
                                [win (== c Ctrl_O)]
                            ))
                    ))
            ))
    ))

;; Redraw for Insert mode.
;; This is postponed until getting the next character to make '$' in the 'cpo' option work correctly.
;; Only redraw when there are no characters available.
;; This speeds up inserting sequences of characters (e.g. for CTRL-R).

(defn- #_window_C ins-redraw [#_window_C win, #_boolean _ready]
    ;; _ready: not busy with something
    (if (char-avail)
        win
        (let [win (cond
                    (non-zero? @must_redraw) (update-screen win, 0)
                    (or @clear_cmdline @redraw_cmdline) (showmode win) ;; clear cmdline and show mode
                    :else win)
                win (showruler win, false)
                win (setcursor win)]
            (reset! emsg_on_display false) ;; may remove error message now
            win
        )
    ))

;; Handle a CTRL-V or CTRL-Q typed in Insert mode.

(defn- #_window_C ins-ctrl-v [#_window_C win]
    ;; May need to redraw when no more chars available now.
    (let [win (ins-redraw win, false)
          #_boolean putchar? (and (redrawing) (not (char-avail)))
          win (if putchar? (edit-putchar win, (byte \^), true) win)
          _ (append-redo CTRL_V_STR)
          win (add-to-showcmd-c win, Ctrl_V)
          [win #_int c] (get-literal? win)
          ;; When the line fits in 'columns' the '^' is at the start
          ;; of the next line and will not be removed by the redraw.
          win (if putchar? (edit-unputchar win) win)
          win (clear-showcmd win)]
        (insert-special win, c, false, true)
    ))

;; Put a character directly onto the screen.  It's not stored in a buffer.
;; Used while handling CTRL-K, CTRL-V, etc. in Insert mode.

(final int
    PC_STATUS_UNSET 0,                   ;; "pc_bytes" was not set
    PC_STATUS_RIGHT 1,                   ;; right halve of double-wide char
    PC_STATUS_LEFT  2,                   ;; left halve of double-wide char
    PC_STATUS_SET   3)                   ;; "pc_bytes" was filled
(atom! int  pc_status)

(final Bytes pc_bytes (Bytes. (inc MB_MAXBYTES)))   ;; saved bytes
(atom! int  pc_attr)
(atom! int  pc_row)
(atom! int  pc_col)

(defn- #_window_C edit-putchar [#_window_C win, #_int c, #_boolean highlight]
    (if (some? @screenLines)
        (let [win (update-topline win) ;; just in case "w_topline" isn't valid
              win (validate-cursor win)
              #_int attr (if highlight (hl-attr HLF_8) 0)]
            (reset! pc_row (+ (:w_winrow win) (:w_wrow win)))
            (reset! pc_col (+ (:w_wincol win) (:w_wcol win)))
            (if (mb-lefthalve @pc_row, @pc_col)
                (reset! pc_status PC_STATUS_LEFT)
                (do ;; save the character to be able to put it back
                    (screen-getbytes @pc_row, @pc_col, pc_bytes, pc_attr)
                    (reset! pc_status PC_STATUS_SET)
                ))
            (screen-putchar c, @pc_row, @pc_col, attr)
            win)
        win
    ))

;; Undo the previous edit-putchar().

(defn- #_window_C edit-unputchar [#_window_C win]
    (if (and (!= @pc_status PC_STATUS_UNSET) (<= @msg_scrolled @pc_row))
        (let [win (if (== @pc_status PC_STATUS_RIGHT) (update win :w_wcol inc) win)]
            (if (any == @pc_status PC_STATUS_RIGHT PC_STATUS_LEFT)
                (redraw-winline win, (:lnum (:w_cursor win)))
                (do (screen-puts pc_bytes, (- @pc_row @msg_scrolled), @pc_col, @pc_attr) win)
            ))
        win
    ))

;; Insert an indent (for <Tab> or CTRL-T) or delete an indent (for CTRL-D).
;; Keep the cursor on the same character.
;; type == INDENT_INC   increase indent (for CTRL-T or <Tab>)
;; type == INDENT_DEC   decrease indent (for CTRL-D)
;; type == INDENT_SET   set indent to "amount"
;; If "round?" is true, round the indent to 'shiftwidth' (only with _INC and _DEC).
;; replaced: replaced character, put on replace stack

(defn- #_window_C change-indent [#_window_C win, #_int type, #_int amount, #_boolean round?, #_int replaced, #_boolean call_changed_bytes]
    ;; VREPLACE mode needs to know what the line was like before changing.
    (let [[o'line o'col] (if (flag? @State VREPLACE_FLAG) [(STRDUP (ml-get (:lnum (:w_cursor win)))) (:col (:w_cursor win))] [nil 0])
          #_int vcol (getvcol-nolist win, (:w_cursor win))
          ;; For Replace mode we need to fix the replace stack later, which is only possible when the
          ;; cursor is in the indent.  Remember the number of chars before the cursor if it's possible.
          #_int start_col (:col (:w_cursor win))
          ;; determine offset from first non-blank
          win (beginline win, BL_WHITE)
          #_int new_cursor_col (- start_col (:col (:w_cursor win)))
          #_int insstart_less (:col (:w_cursor win))    ;; reduction for insStart.col
          ;; If the cursor is in the indent, compute how many screen columns
          ;; the cursor is to the left of the first non-blank.
          vcol (if (< new_cursor_col 0) (- (get-indent win) vcol) vcol)
          start_col (if (< 0 new_cursor_col) -1 start_col) ;; can't fix replace stack

          ;; Set the new indent.  The cursor will be put on the first non-blank.

          win (if (== type INDENT_SET)
                (set-indent win, amount, (if call_changed_bytes SIN_CHANGED 0))
                (let [state' @State ;; Avoid being called recursively.
                      _ (when (flag? @State VREPLACE_FLAG)
                            (reset! State INSERT))
                      win (shift-line win, (== type INDENT_DEC), round?, 1, call_changed_bytes)]
                    (reset! State state')
                    win
                ))
          insstart_less (- insstart_less (:col (:w_cursor win)))

          ;; Try to put cursor on same character.
          ;; If the cursor is at or after the first non-blank in the line,
          ;; compute the cursor column relative to the column of the first non-blank character.
          ;; If we are not in insert mode, leave the cursor on the first non-blank.
          ;; If the cursor is before the first non-blank, position it relative
          ;; to the first non-blank, counted in screen columns.

          [win insstart_less new_cursor_col]
            (cond (<= 0 new_cursor_col)
                ;; When changing the indent while the cursor is touching it, reset insStart_col to 0.
                [win (if (zero? new_cursor_col) MAXCOL insstart_less) (+ new_cursor_col (:col (:w_cursor win)))]
            (non-flag? @State INSERT)
                [win insstart_less (:col (:w_cursor win))]
            :else ;; Compute the screen column where the cursor should be.
                (let [win (assoc win :w_virtcol (max 0 (- (get-indent win) vcol)))
                      ;; Advance the cursor until we reach the right screen column.
                      #_Bytes s (ml-get (:lnum (:w_cursor win)))
                      [vcol new_cursor_col]
                        (loop-when [#_int last_vcol 0 #_int i -1 #_int vcol 0] (<= vcol (:w_virtcol win)) => [last_vcol i]
                            (let [i (+ i (if (<= 0 i) (us-ptr2len-cc s, i) 1))]
                                (recur vcol i (+ vcol (lbr-chartabsize win, s, (.plus s i), vcol)))
                            ))
                      ;; May need to insert spaces to be able to position the cursor on the right screen column.
                      [win new_cursor_col]
                        (if (!= vcol (:w_virtcol win))
                            (let [win (assoc-in win [:w_cursor :col] new_cursor_col)
                                  #_int i (- (:w_virtcol win) vcol) #_Bytes p (-> (Bytes. (inc i)) (eos! i))
                                  _ (loop-when-recur [i (dec i)] (<= 0 i) [(dec i)] (.be p i, (byte \space)))]
                                [(ins-str win, p) (+ new_cursor_col i)])
                            [win new_cursor_col]
                        )]
                    ;; When changing the indent while the cursor is in it, reset insStart_col to 0.
                    [win MAXCOL new_cursor_col]
                ))
          win (assoc-in win [:w_cursor :col] (max 0 new_cursor_col))
          win (assoc win :w_set_curswant true)
          win (changed-cline-bef-curs win)]

        ;; May have to adjust the start of the insert.

        (when (flag? @State INSERT)
            (when (and (== (:lnum (:w_cursor win)) (:lnum @insStart)) (non-zero? (:col @insStart)))
                (swap! insStart update :col #(max 0 (- % insstart_less))))
            (swap! ai_col #(max 0 (- % insstart_less))))

        ;; For REPLACE mode, may have to fix the replace stack, if it's possible.
        ;; If the number of characters before the cursor decreased, need to pop a
        ;; few characters from the replace stack.
        ;; If the number of characters before the cursor increased, need to push a
        ;; few NULs onto the replace stack.

        (when (and (flag? @State REPLACE_FLAG) (non-flag? @State VREPLACE_FLAG) (<= 0 start_col))
            (let [start_col
                    (loop-when-recur start_col (< (:col (:w_cursor win)) start_col) (dec start_col) => start_col
                        (replace-join 0) ;; remove a NUL from the replace stack
                    )]
                (loop-when-recur [#_int i start_col #_int r replaced] (or (< i (:col (:w_cursor win))) (!= r NUL)) [(inc i) NUL]
                    (replace-push NUL)
                    (when (!= r NUL) (replace-push r)))
            ))

        ;; For VREPLACE mode, we also have to fix the replace stack.  In this case
        ;; it is always possible because we backspace over the whole line and then
        ;; put it back again the way we wanted it.

        (if (and (flag? @State VREPLACE_FLAG) (some? o'line))
            ;; Save new line.
            (let [#_Bytes line (STRDUP (ml-get (:lnum (:w_cursor win))))
                  ;; We only put back the new line up to the cursor.
                  _ (eos! line (:col (:w_cursor win)))
                  ;; Put back original line.
                  _ (ml-replace (:lnum (:w_cursor win)), o'line)
                  win (assoc-in win [:w_cursor :col] o'col)
                  ;; Backspace from cursor to start of line.
                  win (backspace-until-column win, 0)]
                ;; Insert new stuff into line again.
                (ins-bytes win, line))
            win)
    ))

;; Truncate the space at the end of a line.  This is to be used only in an insert mode.
;; It handles fixing the replace stack for REPLACE and VREPLACE modes.

(defn- #_void truncate-spaces [#_Bytes line]
    (let [#_int i ;; find start of trailing white space
            (loop-when-recur [i (dec (STRLEN line))] (and (<= 0 i) (vim-iswhite (.at line i))) [(dec i)] => i
                (when (flag? @State REPLACE_FLAG)
                    (replace-join 0))        ;; remove a NUL from the replace stack
            )]
        (eos! line (inc i)))
    nil)

;; Backspace the cursor until the given column.  Handles REPLACE and VREPLACE
;; modes correctly.  May also be used when not in insert mode at all.
;; Will attempt not to go before "col" even when there is a composing character.

(defn- #_window_C backspace-until-column [#_window_C win, #_int col]
    (loop-when win (< col (:col (:w_cursor win))) => win
        (let [win (update-in win [:w_cursor :col] dec)]
            (if (flag? @State REPLACE_FLAG)
                (recur (replace-do-bs win, col))
                (let-when [[win ?] (del-char-after-col? col)] ? => win
                    (recur win))
            ))
    ))

;; Like del-char(), but make sure not to go before column "limit_col".
;; Only matters when there are composing characters.
;; Return true when something was deleted.

(defn- #_[window_C boolean] del-char-after-col? [#_window_C win, #_int limit_col]
    (if (<= 0 limit_col)
        (let [#_int ecol (inc (:col (:w_cursor win)))
              ;; Make sure the cursor is at the start of a character, but skip forward
              ;; again when going too far back because of a composing character.
              win (update win :w_cursor mb-adjust-pos)
              win (loop-when win (< (:col (:w_cursor win)) limit_col) => win
                    (let-when [#_int n (us-ptr2len (ml-get-cursor win))] (pos? n) => win
                        (recur (update-in win [:w_cursor :col] + n)))
                )]
            (if (or (eos? (ml-get-cursor win)) (== (:col (:w_cursor win)) ecol))
                [win false]
                (del-bytes? win, (- ecol (:col (:w_cursor win))), false, true)
            ))
        (del-char? win, false)
    ))

(defn- #_window_C del-char-after-col [#_window_C win, #_int limit_col]
    (let [[win _] (del-char-after-col? win, limit_col)]
        win
    ))

;; Next character is interpreted literally.
;; A one, two or three digit decimal number is interpreted as its byte value.
;; If one or two digits are entered, the next character is given to vungetc().
;; For Unicode a character > 255 may be returned.

(defn- #_[window_C int] get-literal? [#_window_C win]
    (if @got_int
        [win Ctrl_C]
        (do (swap! no_mapping inc)                  ;; don't map the next key hits
            (let [[win #_int i #_int nc #_int cc]
                    (loop [win win i 0 cc 0 m {#_boolean :hex false, #_boolean :oct false, #_int :unicode 0}]
                        (let [[win nc] (plain-vgetc? win)
                              win (when' (and (non-flag? @State CMDLINE) (== (mb-byte2len nc) 1)) => win
                                    (add-to-showcmd win, nc)
                                )]
                            (let-when [[m cc i :as _]
                                    (cond
                                        (any == nc (byte \x) (byte \X)) [(assoc m :hex true) cc i]
                                        (any == nc (byte \o) (byte \O)) [(assoc m :oct true) cc i]
                                        (any == nc (byte \u) (byte \U)) [(assoc m :unicode nc) cc i]
                                    :else (cond
                                        (or (:hex m) (non-zero? (:unicode m))) (when (asc-isxdigit nc) [m (+ (* cc 16) (hex2nr nc)) (inc i)])
                                        (:oct m)                               (when (asc-isodigit nc) [m (+ (* cc 8) (- nc (byte \0))) (inc i)])
                                        :else                                  (when (asc-isdigit nc) [m (+ (* cc 10) (- nc (byte \0))) (inc i)])
                                    ))] (some? _) => [win i nc cc]

                                (let-when [cc (if (and (< 255 cc) (zero? (:unicode m))) 255 cc) ;; limit range to 0-255
                                      nc 0
                                      _ (cond (:hex m)              ;; hex: up to two chars
                                            (when (< i 2) :_)
                                        (non-zero? (:unicode m))    ;; unicode: up to four or eight chars
                                            (when-not (or (and (== (:unicode m) (byte \u)) (<= 4 i)) (and (== (:unicode m) (byte \U)) (<= 8 i))) :_)
                                        (< i 3)                     ;; decimal or octal: up to three chars
                                            :_
                                        )] (some? _) => [win i nc cc]

                                    (recur win i cc m)
                                ))
                        ))]
                (swap! no_mapping dec)
                (let [cc (if (zero? i) (if (== nc K_ZERO) 0 nc) cc)]    ;; no number entered
                    (let-when [nc (if (zero? i) 0 nc)] (non-zero? nc)
                        (vungetc nc))
                    (reset! got_int false)                              ;; CTRL-C typed after CTRL-V is not an interrupt
                    [win (if (zero? cc) (byte \newline) cc)]            ;; NUL is stored as NL
                )))
    ))

;; Insert character, taking care of special keys and mod_mask.

(defn- #_window_C insert-special [#_window_C win, #_int c, #_boolean allow_modmask, #_boolean ctrl_v]
    ;; ctrl_v: c was typed after CTRL-V
    (let [[win [c ctrl_v :as _]]
          ;; Special function key, translate into "<Key>".
          ;; Up to the last '>' is inserted with ins-str(), so as not to replace characters in replace mode.
          ;; Only use mod_mask for special keys, to avoid things like <S-Space>, unless 'allow_modmask' is true.
            (if (or (is-special c) (and (non-zero? @mod_mask) allow_modmask))
                (let-when [#_Bytes s (get-special-key-name c, @mod_mask) #_int n (STRLEN s) c (.at s (dec n))] (< 2 n) => [win [c ctrl_v]]
                    (if (stop-arrow win)
                        (let [_ (eos! s (dec n)) win (ins-str win, s)]
                            (append-redo-lit s, -1)
                            [win [c false]])
                        [win nil]
                    ))
                [win [c ctrl_v]]
            )]
        (if (and (some? _) (stop-arrow win)) (insert-char win, c, ctrl_v) win)
    ))

;; Special characters in this context are those that need processing other
;; than the simple insertion that can be performed here.  This includes ESC
;; which terminates the insert, and CR/NL which need special processing to
;; open up a new line.  This routine tries to optimize insertions performed by
;; the "redo", "undo" or "put" commands, so it needs to know when it should
;; stop and defer processing to the "normal" mechanism.
;; '0' and '^' are special, because they can be followed by CTRL-D.

(defn- #_boolean isspecial? [#_int c]
    (or (< c (byte \space)) (<= DEL c) (== c (byte \0)) (== c (byte \^))))

(defn- #_window_C insert-char [#_window_C win, #_int c, #_boolean ctrl_v]
    (if (== c NUL) ;; only formatting was wanted
        win
        (let [_ (reset! did_ai false) _ (reset! did_si false) _ (reset! can_si false) _ (reset! can_si_back false)
              ;; If there's any pending input, grab up to INPUT_BUFLEN at once.
              ;; This speeds up normal text input considerably.
              ? (and (not (isspecial? c)) (== (utf-char2len c) 1))
              [win ?] (if ? (let [[win #_int x] (vpeekc? win)] [win (!= x NUL)]) [win false])
              ? (and ? (non-flag? @State REPLACE_FLAG))]
            (if ?
                (let [#_final #_int INPUT_BUFLEN 100 #_Bytes buf (-> (Bytes. (inc INPUT_BUFLEN)) (.be 0, c))
                      [win #_int i] ;; eos! when: no more chars available or found a special character (command key) or the buffer is full
                        (loop-when [i 1 [win c] (vpeekc? win)] (and (!= c NUL) (not (isspecial? c)) (== (mb-byte2len c) 1) (< i INPUT_BUFLEN)) => [win i]
                            (let [[win c] (vgetc? win)]
                                (.be buf i, c)
                                (recur (inc i) (vpeekc? win))
                            ))
                      _ (eos! buf i)]
                    (do-digraph -1)                     ;; clear digraphs
                    (do-digraph (.at buf (dec i)))      ;; may be the start of a digraph
                    (let [win (ins-str win, buf)]
                        (let-when [i (if ctrl_v (do (redo-literal (.at buf 0)) 1) 0)] (non-eos? buf i) (append-redo-lit (.plus buf i), -1))
                        win
                    ))
                (let [#_int n (utf-char2len c)]
                    (if (< 1 n)
                        (let [#_Bytes buf (Bytes. (inc MB_MAXBYTES)) _ (utf-char2bytes c, buf) _ (eos! buf n)
                              win (ins-char-bytes win, buf, n)]
                            (append-redo-char c)
                            win)
                        (let [win (ins-char win, c)]
                            (if ctrl_v (redo-literal c) (append-redo-char c))
                            win)
                    ))
            ))
    ))

;; Put a character in the redo buffer, for when just after a CTRL-V.

(defn- #_void redo-literal [#_int c]
    ;; Only digits need special treatment.  Translate them into a string of three digits.
    (if (asc-isdigit c)
        (let [#_Bytes buf (Bytes. 10)]
            (ร .sprintf libC buf, (u8 "%03d"), c)
            (append-redo buf))
        (append-redo-char c))
    nil)

;; start-arrow() is called when an arrow key is used in Insert mode.
;; For undo/redo it resembles hitting the <ESC> key.

(defn- #_window_C start-arrow [#_window_C win, #_pos_C eoi]
    ;; eoi: can be null
    (if (not @arrow_used)               ;; something has been inserted
        (let [_ (append-redo ESC_STR)
              win (stop-insert win, eoi, false, false)]
            (reset! arrow_used true)    ;; this means we stopped the current insert
            win)
        win
    ))

;; stop-arrow() is called before a change is made in Insert mode.
;; If an arrow key has been used, start a new insertion.
;; Returns false if undo is impossible, shouldn't insert then.

(defn- #_boolean stop-arrow [#_window_C win]
    (cond @arrow_used
    (do
        (reset! insStart (:w_cursor win)) ;; new insertion starts here
        (when (and (< (:col @insStart_orig) (:col @insStart)) (not @ins_need_undo))
            ;; Don't update the original insert position when moved to the right,
            ;; except when nothing was inserted yet.
            (reset! update_insStart_orig false))
        (reset! insStart_textlen (linetabsize win, (ml-get (:lnum (:w_cursor win)))))
        (when (u-save-cursor win)
            (reset! arrow_used false)
            (reset! ins_need_undo false))
        (reset! ai_col 0)
        (when (flag? @State VREPLACE_FLAG)
            (reset! orig_line_count (line-count @curbuf))
            (reset! vr_lines_changed 1))
        (reset-redo)
        (append-redo (u8 "1i")) ;; pretend we start an insertion
        (reset! new_insert_skip 2)
    )
    @ins_need_undo
    (do
        (when (u-save-cursor win)
            (reset! ins_need_undo false))
    ))

    (or @arrow_used (not @ins_need_undo)))

;; Do a few things to stop inserting.
;; "eoi" is where insert ended.
;; It is null when we already jumped to another window/buffer.

(defn- #_window_C stop-insert [#_window_C win, #_pos_C eoi, #_boolean esc, #_boolean nomove]
    ;; nomove: <c-\><c-o>, do not move the cursor
    (stop-redo-ins)
    (replace-flush) ;; abandon replace stack
    ;; Save the inserted text for later redo with ^@ and CTRL-A.
    ;; Don't do it when "restart_edit" was set and nothing was inserted,
    ;; otherwise CTRL-O w and then <Left> will clear "last_insert".
    (let-when [#_Bytes s (get-inserted)] (or (zero? @did_restart_edit) (and (some? s) (< @new_insert_skip (STRLEN s))))
        (reset! last_insert s)
        (reset! last_insert_skip @new_insert_skip))
    ;; If we just did an auto-indent, remove the white space from the end of the line, and put the cursor back.
    ;; Do this when ESC was used or moving the cursor up/down.
    ;; Check for the old position still being valid, just in case the text got changed unexpectedly.
    (let [win (if (and (not @arrow_used) (some? eoi) (not nomove) @did_ai
                       (or esc (and (nil? (vim-strbyte @p_cpo, CPO_INDENT)) (!= (:lnum (:w_cursor win)) (:lnum eoi))))
                       (<= (:lnum eoi) (line-count @curbuf)))
                (let [#_pos_C tpos (:w_cursor win)
                      win (assoc win :w_cursor eoi)
                      win (check-cursor-col win) ;; make sure it is not past the line
                      [win #_int x]
                        (loop [win win]
                            (let-when [win (if (and (== (gchar-cursor win) NUL) (< 0 (:col (:w_cursor win)))) (update-in win [:w_cursor :col] dec) win)
                                  x (gchar-cursor win)] (vim-iswhite x) => [win x]
                                (let [[win ?] (del-char? win, true)] (recur-if ? [win] => [win x]))
                            ))
                      win (if (!= (:lnum (:w_cursor win)) (:lnum tpos))
                            (assoc win :w_cursor tpos)
                            (let [tpos (update (:w_cursor win) :col inc)] ;; reset tpos, could have been invalidated in the loop above
                                (if (and (!= x NUL) (== (gchar-pos tpos) NUL)) (assoc win :w_cursor tpos) win)) ;; put cursor back on the NUL
                        )]
                    ;; <C-S-Right> may have started Visual mode, adjust the position for deleted characters.
                    (when (and @VIsual_active (== (:lnum @VIsual_cursor) (:lnum (:w_cursor win))))
                        (let [#_int len (STRLEN (ml-get (:lnum (:w_cursor win))))]
                            (when (< len (:col @VIsual_cursor))
                                (swap! VIsual_cursor assoc :col len :coladd 0))
                        ))
                    win)
                win
            )]
        (reset! did_ai false) (reset! did_si false) (reset! can_si false) (reset! can_si_back false)
        ;; Set '[ and '] to the inserted text.  ;; When "eoi" is null, we are now in a different buffer.
        (when (some? eoi)
            (swap! curbuf assoc :b_op_start @insStart, :b_op_start_orig @insStart_orig, :b_op_end eoi))
        win
    ))

;; Set the last inserted text to a single character.
;; Used for the replace command.

(defn- #_void set-last-insert [#_int c]
    (let [#_Bytes s (reset! last_insert (Bytes. (+ (* MB_MAXBYTES 3) 5)))
          ;; Use the CTRL-V only when entering a special char.
          s (if (or (< c (byte \space)) (== c DEL)) (-> s (.be 0, Ctrl_V) (.plus 1)) s)]
        (-> (add-char2buf c, s) (.be 0, ESC) (eos! 1))
        (reset! last_insert_skip 0))
    nil)

;; Add character "c" to buffer "s".
;; Escape the special meaning of KB_SPECIAL.
;; Handle multi-byte characters.
;; Returns a pointer to after the added bytes.

(defn- #_Bytes add-char2buf [#_int c, #_Bytes s]
    (let [#_Bytes bytes (Bytes. (inc MB_MAXBYTES)) #_int n (utf-char2bytes c, bytes)]
        (loop-when [s s #_int i 0] (< i n) => s
            (let [#_byte b (.at bytes i)
                  ;; Need to escape KB_SPECIAL like in the typeahead buffer.
                  s (if (== b KB_SPECIAL)
                        (-> s (.be 0, KB_SPECIAL) (.be 1, KS_SPECIAL) (.be 2, KE_FILLER) (.plus 3))
                        (-> s (.be 0, b) (.plus 1)))]
                (recur s (inc i))
            ))
    ))

;; Move cursor to start of line:
;;  if (flags & BL_WHITE) move to first non-white;
;;  if (flags & BL_SOL)   move to first non-white if 'startofline' is set, otherwise keep "curswant" column;
;;  if (flags & BL_FIX)   don't leave the cursor on a NUL.

(defn- #_window_C beginline [#_window_C win, #_int flags]
    (if (and (flag? flags BL_SOL) (not @p_sol))
        (coladvance win, (:w_curswant win))
        (let [win (update win :w_cursor assoc :col 0 :coladd 0)
              win (if (flag? flags (| BL_WHITE BL_SOL))
                    (let [s (ml-get (:lnum (:w_cursor win))) fix? (flag? flags BL_FIX)]
                        (loop-when-recur [i (:col (:w_cursor win))] (and (vim-iswhite (.at s i)) (not (and fix? (eos? s (inc i))))) [(inc i)] => (assoc-in win [:w_cursor :col] i)))
                    win
                )]
            (assoc win :w_set_curswant true))
    ))

;; oneright, oneleft, cursor-down, cursor-up
;;
;; Move one char [right, left, down, up].
;; Doesn't move onto the NUL past the end of the line, unless it is allowed.
;;
;; Return true when successful, false when we hit a line of file boundary.

(defn- #_[window_C boolean] oneright? [#_window_C win]
    (let [#_Bytes s (ml-get-cursor win)]
        (cond (virtual-active)
            (let [#_pos_C prior (:w_cursor win)
                  ;; Adjust for multi-wide char (excluding TAB).
                  win (coladvance win, (+ (getviscol win) (if (and (not-at? s TAB) (vim-isprintc (us-ptr2char s))) (mb-ptr2cells s) 1)))
                  win (assoc win :w_set_curswant true)]
                ;; Return true if the cursor moved, false otherwise (at window edge).
                [win (or (!= (:col prior) (:col (:w_cursor win))) (!= (:coladd prior) (:coladd (:w_cursor win))))]
            )
        (eos? s)
            [win false] ;; already at the very end
        :else
            (let [#_int n (us-ptr2len-cc s)]
                ;; Move "n" bytes right, but don't end up on the NUL, unless 'virtualedit' contains "onemore".
                (if (and (eos? s n) (non-flag? @ve_flags VE_ONEMORE))
                    [win false]
                    (let [win (update-in win [:w_cursor :col] + n)
                          win (assoc win :w_set_curswant true)]
                        [win true]
                    )
                ))
        )
    ))

(defn- #_window_C oneright [#_window_C win]
    (let [[win _] (oneright? win)]
        win
    ))

(defn- #_[window_C boolean] oneleft? [#_window_C win]
    (cond (virtual-active)
        (let [#_int v (getviscol win)]
            (if (zero? v)
                [win false]
                ;; We might get stuck on 'showbreak', skip over it.
                (let [win (loop [win win #_int width 1] (let [win (coladvance win, (- v width))] (if (< (getviscol win) v) win (recur win (inc width)))))
                      win (if (== (:coladd (:w_cursor win)) 1)
                            ;; Adjust for multi-wide char (not a TAB).
                            (let-when [#_Bytes s (ml-get-cursor win)] (and (not-at? s TAB) (vim-isprintc (us-ptr2char s)) (< 1 (mb-ptr2cells s))) => win
                                (assoc-in win [:w_cursor :coladd] 0))
                            win)
                      win (assoc win :w_set_curswant true)]
                    [win true]
                )
            ))
    (zero? (:col (:w_cursor win)))
        [win false]
    :else
        (let [win (update-in win [:w_cursor :col] dec)
              win (assoc win :w_set_curswant true)
              ;; If the char on the left of the cursor is multi-byte, move to its first byte.
              win (update win :w_cursor mb-adjust-pos)]
            [win true]
        )
    ))

(defn- #_window_C oneleft [#_window_C win]
    (let [[win _] (oneleft? win)]
        win
    ))

(defn- #_[window_C boolean] cursor-up? [#_window_C win, #_long n, #_boolean upd_topline]
    (let [[win ?] (if (< 0 n)
                (let [lmin 1 lnum (:lnum (:w_cursor win))]
                    ;; This fails if the cursor is already in the first line
                    ;; or the count is larger than the line number and '-' is in 'cpoptions'.
                    (if (or (<= lnum lmin) (and (< (- lnum n) lmin) (some? (vim-strbyte @p_cpo, CPO_MINUS))))
                        [win false]
                        [(assoc-in win [:w_cursor :lnum] (max lmin (- lnum n))) true]
                    ))
                [win true])
          win (if ?
                (let [win (coladvance win, (:w_curswant win))] ;; try to advance to the column we want to be at
                    (if upd_topline (update-topline win) win)) ;; make sure "w_topline" is valid
                win
            )]
        [win ?]
    ))

(defn- #_window_C cursor-up [#_window_C win, #_long n, #_boolean upd_topline]
    (let [[win _] (cursor-up? win, n, upd_topline)]
        win
    ))

(defn- #_[window_C boolean] cursor-down? [#_window_C win, #_long n, #_boolean upd_topline]
    (let [[win ?] (if (< 0 n)
                (let [lnum (:lnum (:w_cursor win)) lmax (line-count @curbuf)]
                    ;; This fails if the cursor is already in the last line
                    ;; or would move beyond the last line and '-' is in 'cpoptions'.
                    (if (or (<= lmax lnum) (and (< lmax (+ lnum n)) (some? (vim-strbyte @p_cpo, CPO_MINUS))))
                        [win false]
                        [(assoc-in win [:w_cursor :lnum] (min (+ lnum n) lmax)) true]
                    ))
                [win true])
          win (if ?
                (let [win (coladvance win, (:w_curswant win))] ;; try to advance to the column we want to be at
                    (if upd_topline (update-topline win) win)) ;; make sure "w_topline" is valid
                win
            )]
        [win ?]
    ))

(defn- #_window_C cursor-down [#_window_C win, #_long n, #_boolean upd_topline]
    (let [[win _] (cursor-down? win, n, upd_topline)]
        win
    ))

;; Stuff the last inserted text in the read buffer.
;; "last_insert" actually is a copy of the redo buffer,
;; so we first have to remove the command.

(defn- #_[window_C boolean] stuff-inserted? [#_window_C win, #_int c, #_long n, #_boolean no_esc]
    ;; c: command character to be inserted
    ;; n: repeat this many times
    ;; no_esc: don't add an ESC at the end
    (let-when [#_Bytes p (get-last-insert)] (some? p) => [(emsg win, e_noinstext) false]
        ;; may want to stuff the command character, to start Insert mode
        (when (!= c NUL)
            (stuff-char c))
        (let [#_Bytes e (vim-strrchr p, ESC)
              _ (when (some? e) (eos! e)) ;; remove the ESC
              ;; when the last char is either "0" or "^" it will be quoted if no ESC comes
              ;; after it OR if it will inserted more than once and "p" starts with ^D
              #_Bytes q (if (some? e) (.minus e 1) (.plus p (dec (STRLEN p))))
              #_byte x (if (and (BLE p, q) (any == (.at q 0) (byte \0) (byte \^)) (or no_esc (and (at? p Ctrl_D) (< 1 n))))
                                (let [x (.at q 0)] (eos! q) x)
                                NUL)]
            (loop [n n]
                (stuff-string p)
                ;; a trailing "0" is inserted as "<C-V>048", "^" as "<C-V>^"
                (when (!= x NUL)
                    (stuff-string (if (== x (byte \0)) (u8 "\026\060\064\070") (u8 "\026^"))))
                (let-when [n (dec n)] (< 0 n)
                    (recur n)
                ))
            (when (!= x NUL) (.be q 0, x))
            (when (some? e) (.be e 0, ESC)) ;; put the ESC back
        )
        ;; may want to stuff a trailing ESC, to get out of Insert mode
        (when (not no_esc)
            (stuff-char ESC))
        [win true]
    ))

(defn- #_Bytes get-last-insert []
    (when (some? @last_insert) (.plus @last_insert @last_insert_skip)))

;; Get last inserted string, and remove trailing <Esc>.
;; Returns pointer to allocated memory (must be freed) or null.

(defn- #_Bytes get-last-insert-save []
    (let [#_Bytes s (get-last-insert)]
        (when (some? s)
            (let [s (STRDUP s) #_int len (STRLEN s)]
                (when (and (< 0 len) (at? s (dec len) ESC))       ;; remove trailing ESC
                    (eos! s (dec len)))
            ))
    s))

;; replace-stack functions
;;
;; When replacing characters, the replaced characters are remembered for each
;; new character.  This is used to re-insert the old text when backspacing.
;;
;; There is a NUL headed list of characters for each character that is
;; currently in the file after the insertion point.  When BS is used, one NUL
;; headed list is put back for the deleted character.
;;
;; For a newline, there are two NUL headed lists.  One contains the characters
;; that the NL replaced.  The extra one stores the characters after the cursor
;; that were deleted (always white space).
;;
;; Replace_offset is normally 0, in which case replace-push will add a new
;; character at the end of the stack.  If replace_offset is not 0, that many
;; characters will be left on the stack above the newly inserted character.

(atom! Bytes    replace_stack)
(atom! int      replace_stack_nr)       ;; next entry in replace stack
(atom! int      replace_stack_len)      ;; max. number of entries

(defn- #_void replace-push [#_int c]
    ;; c: character that is replaced (NUL is none)
    (when (<= @replace_offset @replace_stack_nr)
        (when (<= @replace_stack_len @replace_stack_nr)
            (swap! replace_stack_len + 50)
            (let [#_Bytes p (Bytes. @replace_stack_len)]
                (when (some? @replace_stack)
                    (BCOPY p, @replace_stack, @replace_stack_nr))
                (reset! replace_stack p)
            ))
        (let [#_Bytes p (.plus @replace_stack (- @replace_stack_nr @replace_offset))]
            (when (non-zero? @replace_offset)
                (BCOPY p, 1, p, 0, @replace_offset))
            (.be p 0, c)
            (swap! replace_stack_nr inc)
        ))
    nil)

;; Push a character onto the replace stack.
;; Handles a multi-byte character in reverse byte order, so that the first byte is popped off first.
;; Return the number of bytes done (includes composing characters).

(defn- #_int replace-push-mb [#_Bytes p]
    (let [#_int n (us-ptr2len-cc p)]
        (loop-when-recur [#_int i (dec n)] (<= 0 i) [(dec i)]
            (replace-push (.at p i)))
    n))

;; Pop one item from the replace stack.
;; return -1 if stack empty
;; return replaced character or NUL otherwise

(defn- #_int replace-pop []
    (if (zero? @replace_stack_nr) -1 (.at @replace_stack (swap! replace_stack_nr dec))))

;; Join the top two items on the replace stack.  This removes to "off"'th NUL encountered.

(defn- #_void replace-join [#_int off]
    ;; off: offset for which NUL to remove
    (loop-when [off off #_int i (dec @replace_stack_nr)] (<= 0 i)
        (if (eos? @replace_stack i)
            (let-when [off (dec off)] (< off 0) => (recur off (dec i))
                (swap! replace_stack_nr dec)
                (BCOPY @replace_stack, i, @replace_stack, (inc i), (- @replace_stack_nr i)))
            (recur off (dec i))
        ))
    nil)

;; Pop bytes from the replace stack until a NUL is found, and insert them
;; before the cursor.  Can only be used in REPLACE or VREPLACE mode.

(defn- #_window_C replace-pop-ins [#_window_C win]
    (let [o'State @State _ (reset! State NORMAL) ;; don't want REPLACE here
          win (loop-when [win win c (replace-pop)] (< 0 c) => win
                (let [win (mb-replace-pop-ins win, c)
                      win (dec-cursor win, false)]
                    (recur win (replace-pop)))
            )]
        (reset! State o'State)
        win
    ))

;; Insert bytes popped from the replace stack.  "c" is the first byte.
;; If it indicates a multi-byte char, pop the other bytes too.

(defn- #_window_C mb-replace-pop-ins [#_window_C win, #_int c]
    (let [s (Bytes. (inc MB_MAXBYTES))
          bees- (fn [c n] (.be s 0, c) (loop-when-recur [i 1] (< i n) [(inc i)] (.be s i, (replace-pop))))
          win (let-when [n (mb-byte2len c)] (< 1 n) => (ins-char win, c)
                (bees- c n)
                (ins-bytes-len win, s, n)
            )]
        (loop [win win] ;; Handle composing chars.
            (let-when [c (replace-pop)] (!= c -1) => win ;; => stack empty
                (let-when [n (mb-byte2len c)] (< 1 n) => (do (replace-push c) win) ;; Not a multi-byte char, put it back.
                    (bees- c n)
                    (recur-if (utf-iscomposing (us-ptr2char s)) [(ins-bytes-len win, s, n)] =>
                        (loop-when-recur [i (dec n)] (<= 0 i) [(dec i)] => win
                            (replace-push (.at s i)))
                    ))
            ))
    ))

;; make the replace stack empty
;; (called when exiting replace mode)

(defn- #_void replace-flush []
    (reset! replace_stack nil)
    (reset! replace_stack_len 0)
    (reset! replace_stack_nr 0)
    nil)

;; Handle doing a BS for one character.
;;
;; "c" < 0: replace stack empty, just move cursor
;; "c" == 0: character was inserted, delete it
;; "c" > 0: character was replaced, put "c" (first byte of original char) back and check for more to be put back
;;
;; When "limit_col" is >= 0, don't delete before this column.
;; Matters when using composing characters, use del-char-after-col() instead of del-char().

(defn- #_window_C replace-do-bs [#_window_C win, #_int limit_col]
    (let [c (replace-pop)]
        (cond (< 0 c)
            (let [vrep? (flag? @State VREPLACE_FLAG) a'start (atom (int)) o'vcol
                    (if vrep?
                        (do ;; Get the number of screen cells used by the character we are going to delete.
                            (getvcol win, (:w_cursor win), nil, a'start, nil)
                            (chartabsize (ml-get-cursor win), @a'start))
                        0)
                  win (del-char-after-col win, limit_col)
                  n (if vrep? (STRLEN (ml-get-cursor win)) 0)
                  _ (replace-push c)
                  win (replace-pop-ins win)
                  win (when' vrep? => win
                        (let [s (ml-get-cursor win) n (- (STRLEN s) n)
                              ;; Get the number of screen cells used by the inserted characters.
                              vcol (loop-when-recur [vcol @a'start i 0] (< i n) [(+ vcol (chartabsize s, i, vcol)) (+ i (us-ptr2len-cc s, i))] => (- vcol @a'start))
                              ;; Delete spaces that were inserted after the cursor to keep the text aligned.
                              win (update-in win [:w_cursor :col] + n)
                              win (loop-when-recur [win win i o'vcol] (and (< i vcol) (== (gchar-cursor win) (byte \space))) [(del-char win, false) (inc i)] => win)
                              win (update-in win [:w_cursor :col] - n)]
                            win)
                    )]
                ;; mark the buffer as changed and prepare for displaying
                (changed-bytes (:lnum (:w_cursor win)), (:col (:w_cursor win)))
                win)
        (zero? c)
            (del-char-after-col win, limit_col)
        :else
            win)
    ))

(defn- #_window_C ins-reg [#_window_C win]
    (let [o'VIsual_active @VIsual_active
          ;; If we are going to wait for a character, show a '"'.
          _ (reset! pc_status PC_STATUS_UNSET)
          win (if (and (redrawing) (not (char-avail)))
                ;; May need to redraw when no more chars available now.
                (-> win
                    (ins-redraw false)
                    (edit-putchar (byte \"), true) ;; """
                    (add-to-showcmd-c Ctrl_R))
                win)
          ;; Don't map the register name.  This also prevents the mode message to be deleted when ESC is hit.
          _ (swap! no_mapping inc)
          [win #_int regname] (plain-vgetc? win)
          ;; Get a third key for literal register insertion.
          [win #_int literally regname]
            (when' (any == regname Ctrl_R Ctrl_O Ctrl_P) => [win 0 regname]
                (let [win (add-to-showcmd-c win, regname) [win ?] (plain-vgetc? win)] [win regname ?]))
          _ (swap! no_mapping dec)
          ;; Don't call u-sync() while typing the expression or giving an error message for it.  Only call it explicitly.
          _ (swap! no_u_sync inc)
          [win regname]
            (when' (== regname (byte \=)) => [win regname]
                ;; Sync undo when evaluating the expression calls setline() or append(), so that it can be undone separately.
                (reset! u_sync_once 2)
                (get-expr-register? win))
          [win #_boolean need_redraw]
            (cond (or (== regname NUL) (not (valid-yank-reg regname, false)))
                (do (beep) [win true]) ;; remove the '"'
            (any == literally Ctrl_O Ctrl_P)
                (do ;; Append the command to the redo buffer.
                    (append-redo-char Ctrl_R) (append-redo-char literally) (append-redo-char regname)
                    [(do-put win, regname, BACKWARD, 1, (| (if (== literally Ctrl_P) PUT_FIXINDENT 0) PUT_CURSEND)) false])
            :else
                (let-when [[win ?] (insert-reg? win, regname, (non-zero? literally))] ? => (do (beep) [win true]) ;; remove the '"'
                    ;; When the '=' register was used and a function was invoked that did ":stopinsert",
                    ;; then stuff-empty() returns false, but we won't insert anything, need to remove the '"'.
                    [win @stop_insert_mode]
                ))
          _ (swap! no_u_sync dec)
          _ (when (== @u_sync_once 1)
                (reset! ins_need_undo true))
          _ (reset! u_sync_once 0)
          win (clear-showcmd win)
          ;; If the inserted register is empty, we need to remove the '"'.
          win (if (or need_redraw (stuff-empty)) (edit-unputchar win) win)]
        ;; Disallow starting Visual mode here, would get a weird mode.
        (if (and (not o'VIsual_active) @VIsual_active) (end-visual-mode win) win)
    ))

;; CTRL-G commands in Insert mode.

(defn- #_window_C ins-ctrl-g [#_window_C win]
    ;; Don't map the second key.  This also prevents the mode message to be deleted when ESC is hit.
    (let [_ (swap! no_mapping inc) [win #_int c] (plain-vgetc? win) _ (swap! no_mapping dec)]
        (condp ==? c
           [K_UP   Ctrl_K (byte \k)] (ins-up win, true)   ;; CTRL-G k and CTRL-G <Up>: cursor up to insStart.col
           [K_DOWN Ctrl_J (byte \j)] (ins-down win, true) ;; CTRL-G j and CTRL-G <Down>: cursor down to insStart.col

            (byte \u)                                     ;; CTRL-G u: start new undoable edit
                (let [win (u-sync win, true)]
                    (reset! ins_need_undo true)
                    ;; Need to reset "insStart",
                    ;; esp. because a BS that joins a line to the previous one must save for undo.
                    (reset! update_insStart_orig false)
                    (reset! insStart (:w_cursor win))
                    win)

            ;; Unknown CTRL-G command, reserved for future expansion.
            (do (beep) win)
        )
    ))

(atom! boolean disabled_redraw)

;; Handle ESC in Insert mode.
;; Returns true when leaving Insert mode, false when going to repeat the insert.

(defn- #_[window_C boolean] ins-esc? [#_window_C win, #_long' a'count, #_int cmdchar, #_boolean nomove]
    ;; nomove: do not move the cursor
    (let [o'col (:col (:w_cursor win))]
        (when @disabled_redraw
            (swap! no_redraw dec)
            (reset! disabled_redraw false))
        (let-when [[win ? :as _]
                    (if (not @arrow_used)
                        (do ;; Don't append the ESC for "r<CR>" and "grx".
                            ;; When 'insertmode' is set, only CTRL-L stops Insert mode.
                            ;; Needed for when "count" is non-zero.
                            (when (and (!= cmdchar (byte \r)) (!= cmdchar (byte \v)))
                                (append-redo (if @p_im (u8 "\014") ESC_STR)))
                            ;; Repeating insert may take a long time.  Check for interrupt now and then.
                            (when (and (< 0 @a'count) (slow-breakcheck))
                                (reset! a'count 0))
                            (if (< 0 (swap! a'count dec)) ;; repeat what was typed
                                (do ;; Vi repeats the insert without replacing characters.
                                    (when (some? (vim-strbyte @p_cpo, CPO_REPLCNT))
                                        (swap! State & (bit-not REPLACE_FLAG)))
                                    (start-redo-ins)
                                    (when (any == cmdchar (byte \r) (byte \v))
                                        (stuff-redo ESC_STR)) ;; no ESC in redo buffer
                                    (swap! no_redraw inc)
                                    (reset! disabled_redraw true)
                                    [win false])
                                [(stop-insert win, (:w_cursor win), true, nomove) true]
                            ))
                        [win true]
                    )] ? => _ ;; repeat the insert

            ;; When an autoindent was removed, curswant stays after the indent.
            (let [win (if (and (== @restart_edit NUL) (== (:col (:w_cursor win)) o'col)) (assoc win :w_set_curswant true) win)
                  ;; Remember the last Insert position in the '^ mark.
                  _ (swap! curbuf assoc :b_last_insert (:w_cursor win))
                  ;; The cursor should end up on the last inserted character.
                  ;; Don't do it for CTRL-O, unless past the end of the line.
                  win (if (and (not nomove)
                             (or (pos? (:col (:w_cursor win))) (pos? (:coladd (:w_cursor win))))
                             (or (== @restart_edit NUL) (and (== (gchar-cursor win) NUL) (not @VIsual_active))))
                        (if (or (pos? (:coladd (:w_cursor win))) (== @ve_flags VE_ALL))
                            (let [win (oneleft win)]
                                (if (!= @restart_edit NUL) (update-in win [:w_cursor :coladd] inc) win))
                            (-> win
                                (update-in [:w_cursor :col] dec)
                                (update :w_cursor mb-adjust-pos)
                            ))
                        win)
                  _ (reset! State NORMAL)
                  win (changed-cline-bef-curs win) ;; need to position the cursor again (e.g. when on a TAB)
                  _ (ui-cursor-shape)
                  ;; When recording or for CTRL-O, need to display the new mode.
                  ;; Otherwise remove the mode message.
                  win (cond (or @Recording (!= @restart_edit NUL)) (showmode win) @p_smd (msg win, (u8 "")) :else win)]
                ;; exit Insert mode
                [win true]
            ))
    ))

;; If 'keymodel' contains "startsel", may start selection.
;; Returns true when a CTRL-O and other keys stuffed.

(defn- #_[window_C boolean] ins-start-select? [#_window_C win, #_int c]
    (let-when [iss-
            (fn [win c] ;; start selection right away, the cursor can move with CTRL-O when beyond the end of the line
                (let [win (start-selection win)]
                    (stuff-char Ctrl_O) ;; execute the key in (insert) Select mode
                    (when (non-zero? @mod_mask)
                        (stuff-string (-> (Bytes. 4) (.be 0, KB_SPECIAL) (.be 1, KS_MODIFIER) (.be 2, @mod_mask) (eos! 3))))
                    (stuff-char c)
                    [win true]
                )
            )] @km_startsel => [win false]
        (condp ==? c
            [K_KHOME K_KEND K_PAGEUP K_KPAGEUP K_PAGEDOWN K_KPAGEDOWN]
                (if (flag? @mod_mask MOD_MASK_SHIFT) (iss- win, c) [win false])
            [K_S_LEFT K_S_RIGHT K_S_UP K_S_DOWN K_S_END K_S_HOME]
                (iss- win, c)
            [win false]
        )
    ))

;; <Insert> key in Insert mode: toggle insert/replace mode.

(defn- #_window_C ins-insert [#_window_C win, #_int replaceState]
    (swap! State #(if (flag? % REPLACE_FLAG) INSERT replaceState))
    (append-redo-char K_INS)
    (let [win (showmode win)]
        (ui-cursor-shape) ;; may show different cursor shape
        win
    ))

;; Pressed CTRL-O in Insert mode.

(defn- #_void ins-ctrl-o [#_window_C win]
    (reset! restart_edit (cond (flag? @State VREPLACE_FLAG) (byte \V) (flag? @State REPLACE_FLAG) (byte \R) :else (byte \I)))
    (reset! ins_at_eol (if (virtual-active) false (== (gchar-cursor win) NUL))) ;; cursor always keeps its column
    nil)

;; If the cursor is on an indent, ^T/^D insert/delete one 'shiftwidth'.
;; Otherwise ^T/^D behave like a "<<" or ">>".
;; Always round the indent to 'shiftwidth', this is compatible with vi.
;; But vi only supports ^T and ^D after an autoindent, we support it everywhere.

(defn- #_window_C ins-shift [#_window_C win, #_int c, #_int lastc]
    (if (stop-arrow win)
        (let [_ (append-redo-char c)
              ;; 0^D and ^^D: remove all indent.
              win (if (and (== c Ctrl_D) (any == lastc (byte \0) (byte \^)) (< 0 (:col (:w_cursor win))))
                    (let [win (update-in win [:w_cursor :col] dec)
                          win (del-char win, false)                 ;; delete the '^' or '0'
                          ;; In Replace mode, restore the characters that '^' or '0' replaced.
                          win (if (flag? @State REPLACE_FLAG) (replace-pop-ins win) win)]
                        (when (== lastc (byte \^))
                            (reset! old_indent (get-indent win)))   ;; remember curr. indent
                        (change-indent win, INDENT_SET, 0, true, NUL, true))
                    (change-indent win, (if (== c Ctrl_D) INDENT_DEC INDENT_INC), 0, true, NUL, true)
                )]
            (when (and @did_ai (non-eos? (skipwhite (ml-get (:lnum (:w_cursor win))))))
                (reset! did_ai false))
            (reset! did_si false)
            (reset! can_si false)
            (reset! can_si_back false)
            (reset! can_cindent false) ;; no cindenting after ^D or ^T
            win)
        win
    ))

(defn- #_window_C ins-del [#_window_C win]
    (if (stop-arrow win)
        (let [win (if (== (gchar-cursor win) NUL)
                    ;; delete newline ;; only if "eol" included
                    (let-when [] (can-bs BS_EOL) => (do (beep) win)
                        (let-when [o'col (:col (:w_cursor win)) [win ?] (do-join? win, 2, false, true, false)] ? => (do (beep) win)
                            (assoc-in win [:w_cursor :col] o'col)
                        ))
                    ;; delete char under cursor
                    (let-when [[win ?] (del-char? win, false)] ? => (do (beep) win)
                        win)
                )]
            (reset! did_ai false) (reset! did_si false) (reset! can_si false) (reset! can_si_back false)
            (append-redo-char K_DEL)
            win)
        win
    ))

;; Delete one character for ins-bs().

(defn- #_window_C ins-bs-one [#_window_C win, #_int' a'vcol]
    (let [win (dec-cursor win, false)]
        (getvcol win, (:w_cursor win), a'vcol, nil, nil)
        (if (flag? @State REPLACE_FLAG) ;; Don't delete characters before the insert point when in Replace mode.
            (when (or (!= (:lnum (:w_cursor win)) (:lnum @insStart)) (<= (:col @insStart) (:col (:w_cursor win))))
                (replace-do-bs win, -1))
            (del-char win, false)
        )
    ))

;; Handle backspace, delete-word and delete-line in Insert mode.
;; Return true when backspace was actually used.

(defn- #_[window_C boolean] ins-bs? [#_window_C win, #_int c, #_int mode, #_boolean' a'inserted_space]
    ;; can't delete anything in an empty file
    ;; can't backup past first character in buffer
    ;; can't backup past starting point unless 'backspace' > 1
    ;; can backup to a previous line if 'backspace' == 0
    (cond (or (bufempty)
              (and (== (:lnum (:w_cursor win)) 1) (zero? (:col (:w_cursor win))))
              (and (not (can-bs BS_START)) (or @arrow_used (and (== (:lnum (:w_cursor win)) (:lnum @insStart_orig)) (<= (:col (:w_cursor win)) (:col @insStart_orig)))))
              (and (not (can-bs BS_INDENT)) (not @arrow_used) (< 0 @ai_col) (<= (:col (:w_cursor win)) @ai_col))
              (and (not (can-bs BS_EOL)) (zero? (:col (:w_cursor win)))))
            (do (beep) [win false])

    (not (stop-arrow win))
        [win false]

    :else
        (let [#_boolean in_indent (inindent win, 0)]
            (when in_indent
                (reset! can_cindent false))
            ;; virtualedit:
            ;;  BACKSPACE_CHAR eats a virtual space
            ;;  BACKSPACE_WORD eats all coladd
            ;;  BACKSPACE_LINE eats all coladd and keeps going
            (let-when [[win ? :as _]
                    (if (pos? (:coladd (:w_cursor win)))
                        (condp == mode
                            BACKSPACE_CHAR [(update-in win [:w_cursor :coladd] dec) true]
                            BACKSPACE_WORD [(assoc-in win [:w_cursor :coladd] 0) true]
                            BACKSPACE_LINE [(assoc-in win [:w_cursor :coladd] 0) nil])
                        [win nil]
                    )] (not ?) => _

                (let-when [[win #_boolean did_backspace]
                        (cond (zero? (:col (:w_cursor win))) ;; Delete newline!
                            (let-when [#_long lnum (:lnum @insStart)
                                       _ (cond
                                            (!= lnum (:lnum (:w_cursor win))) :_
                                            (u-save win, (- lnum 2), (+ lnum 1)) (do (swap! insStart update :lnum dec) (swap! insStart assoc :col MAXCOL) :_)
                                            :else nil
                                        )] (some? _) => [win nil]
                                ;; In REPLACE mode:
                                ;; "x" < 0: NL was inserted, delete it
                                ;; "x" >= 0: NL was replaced, put original characters back
                                (let [rep? (flag? @State REPLACE_FLAG) #_int x (if rep? (replace-pop) -1) ;; returns -1 if NL was inserted
                                      ;; In REPLACE mode, in the line we started replacing, we only move the cursor.
                                      win (if (and rep? (<= (:lnum (:w_cursor win)) lnum))
                                            (dec-cursor win, false)
                                            (let [win (if (and rep? (<= (:lnum (:w_cursor win)) @orig_line_count))
                                                        (dec-cursor win, false)
                                                        (let [_ (gchar-cursor win) win (update-in win [:w_cursor :lnum] dec) win (do-join win, 2, false, false, false)]
                                                            (if (and (== _ NUL) (!= (gchar-cursor win) NUL))
                                                                (inc-cursor win, false)
                                                                win
                                                            ))
                                                    )]
                                                ;; In REPLACE mode we have to put back the text that was replaced by the NL.
                                                ;; On the replace stack is first a NUL-terminated sequence of characters
                                                ;; that were deleted and then the characters that NL replaced.
                                                (if rep?
                                                    ;; Do the next ins-char() in NORMAL state, to prevent it
                                                    ;; from replacing characters and avoiding showmatch().
                                                    (let [o'State @State _ (reset! State NORMAL)
                                                          ;; restore characters (blanks) deleted after cursor
                                                          win (loop-when [win win x x] (< 0 x) => win
                                                                (let [o'col (:col (:w_cursor win)) win (mb-replace-pop-ins win, x) win (assoc-in win [:w_cursor :col] o'col)]
                                                                    (recur win (replace-pop))
                                                                ))
                                                          ;; restore the characters that NL replaced
                                                          win (replace-pop-ins win)
                                                          _ (reset! State o'State)]
                                                        win)
                                                    win
                                                ))
                                        )]
                                    (reset! did_ai false)
                                    [win false]
                                ))
                        :else ;; Delete character(s) before the cursor.
                            (let [[win #_int mincol] ;; keep indent
                                    (if (and (== mode BACKSPACE_LINE) @(:b_p_ai @curbuf))
                                        (let [o'col (:col (:w_cursor win)) win (beginline win, BL_WHITE)
                                              mincol (if (< (:col (:w_cursor win)) o'col) (:col (:w_cursor win)) 0)]
                                            [(assoc-in win [:w_cursor :col] o'col) mincol])
                                        [win 0]
                                    )]
                                ;; Handle deleting one 'shiftwidth' or 'softtabstop'.
                                (cond (and (== mode BACKSPACE_CHAR)
                                           (or (and @p_sta in_indent)
                                               (and (non-zero? (get-sts-value))
                                                    (< 0 (:col (:w_cursor win)))
                                                    (let [s (ml-get-cursor win)] (or (at? s -1 TAB) (and (at? s -1 (byte \space)) (or (not @a'inserted_space) @arrow_used)))))))
                                    (let [_ (reset! a'inserted_space false)
                                          #_int ts (if (and @p_sta in_indent) (get-sw-value) (get-sts-value))
                                          ;; Compute the virtual column where we want to be.
                                          ;; Since 'showbreak' may get in the way, need to get the last column of the previous character.
                                          a'vcol (atom (int)) _ (getvcol win, (:w_cursor win), a'vcol, nil, nil) #_int from @a'vcol win (dec-cursor win, false)
                                          a'over (atom (int)) _ (getvcol win, (:w_cursor win), nil, nil, a'over)                    win (inc-cursor win, false)
                                          _ (swap! a'over #(* (/ % ts) ts))
                                          ;; delete characters until we are at or before "over"
                                          win (if (and (< @a'over @a'vcol) (vim-iswhite (.at (ml-get-cursor win) -1)))
                                                (ins-bs-one win, a'vcol)
                                                win)
                                          ;; insert extra spaces until we are at "over"
                                          win (loop-when win (< @a'vcol @a'over) => win
                                                ;; Remember the first char we inserted.
                                                (when (and (== (:lnum (:w_cursor win)) (:lnum @insStart_orig)) (< (:col (:w_cursor win)) (:col @insStart_orig)))
                                                    (swap! insStart_orig assoc :col (:col (:w_cursor win))))
                                                (let [win (if (flag? @State VREPLACE_FLAG)
                                                            (ins-char win, (byte \space))
                                                            (let [win (ins-str win, (u8 " "))]
                                                                (when (flag? @State REPLACE_FLAG)
                                                                    (replace-push NUL))
                                                                win)
                                                        )]
                                                    (getvcol win, (:w_cursor win), a'vcol, nil, nil)
                                                    (recur win)
                                                ))
                                          ;; If we are now back where we started delete one character.
                                          ;; Can happen when using 'sts' and 'linebreak'.
                                          win (if (<= from @a'vcol) (ins-bs-one win, a'vcol) win)]
                                        [win true]
                                    )
                                :else ;; Delete upto starting point, start of line or previous word.
                                    (loop [#_int pls 0 #_int cls (us-get-class (ml-get-cursor win)) mode mode #_boolean word? false]
                                        (let-when [win (dec-cursor win, false) ;; put cursor on char to be deleted
                                              #_int x (gchar-cursor win) pls cls cls (us-get-class (ml-get-cursor win)) ;; look multi-byte character class
                                              [win [mode word? :as _]]
                                                (cond (and (== mode BACKSPACE_WORD) (not (vim-isspace x))) ;; start of word?
                                                    [win [BACKSPACE_WORD_NOT_SPACE (vim-iswordc x)]]
                                                (and (== mode BACKSPACE_WORD_NOT_SPACE) (or (vim-isspace x) (!= (vim-iswordc x) word?) (!= pls cls))) ;; end of word?
                                                    [(inc-cursor win, false) nil]
                                                :else
                                                    [win [mode word?]]
                                                )] (some? _) => [win true]

                                            (let [win (if (flag? @State REPLACE_FLAG)
                                                        (replace-do-bs win, -1)
                                                        (let [#_int* cpc (int-array MAX_MCO) _ (when @p_deco (us-ptr2char-cc (ml-get-cursor win), cpc)) ;; composing characters
                                                              win (del-char win, false)]
                                                            ;; If there are combining characters and 'delcombine' is set,
                                                            ;; move the cursor back.  Don't back up before the base character.
                                                            (if (and @p_deco (non-zero? (aget cpc 0))) (inc-cursor win, false) win))
                                                    )]
                                                (recur-if (and (!= mode BACKSPACE_CHAR) ;; !Just a single backspace?
                                                               (< mincol (:col (:w_cursor win)))
                                                               (or (!= (:lnum (:w_cursor win)) (:lnum @insStart_orig)) (!= (:col (:w_cursor win)) (:col @insStart_orig))))
                                                          [pls cls mode word?]
                                                       => [win true])
                                            ))
                                    ))
                            ))
                ] (some? did_backspace) => [win false]

                    (reset! did_si false) (reset! can_si false) (reset! can_si_back false) (when (<= (:col (:w_cursor win)) 1) (reset! did_ai false))
                    ;; It's a little strange to put backspaces into the redo buffer, but it makes auto-indent a lot easier to deal with.
                    (append-redo-char c)
                    ;; If deleted before the insertion point, adjust it.
                    (when (and (== (:lnum (:w_cursor win)) (:lnum @insStart_orig)) (< (:col (:w_cursor win)) (:col @insStart_orig)))
                        (swap! insStart_orig assoc :col (:col (:w_cursor win))))
                    [win did_backspace])
            ))
    ))

(defn- #_window_C ins-left [#_window_C win]
    (let [lmin 1 o'cursor (:w_cursor win) [win ?] (oneleft? win)]
        (cond ?
            (start-arrow win, o'cursor)
        ;; if 'whichwrap' set for cursor in insert mode, may go to previous line
        (and (some? (vim-strchr @p_ww, (byte \[))) (< lmin (:lnum (:w_cursor win))))
            (-> win
                (start-arrow o'cursor)
                (update-in [:w_cursor :lnum] dec)
                (coladvance MAXCOL)
                (assoc :w_set_curswant true)) ;; so we stay at the end
        :else
            (do (beep) win))
    ))

(defn- #_window_C ins-home [#_window_C win, #_int c]
    (let [lmin 1 o'cursor (:w_cursor win)
          win (if (== c K_C_HOME) (assoc-in win, [:w_cursor :lnum] lmin) win)]
        (-> win
            (update :w_cursor assoc :col 0 :coladd 0)
            (assoc :w_curswant 0)
            (start-arrow o'cursor))
    ))

(defn- #_window_C ins-end [#_window_C win, #_int c]
    (let [lmax (line-count @curbuf) o'cursor (:w_cursor win)
          win (if (== c K_C_END) (assoc-in win, [:w_cursor :lnum] lmax) win)]
        (-> win
            (coladvance MAXCOL)
            (assoc :w_curswant MAXCOL)
            (start-arrow o'cursor))
    ))

(defn- #_window_C ins-s-left [#_window_C win]
    (let-when [lmin 1 o'cursor (:w_cursor win)] (or (< lmin (:lnum o'cursor)) (< 0 (:col o'cursor))) => (do (beep) win)
        (-> win
            (start-arrow o'cursor)
            (bck-word 1, false, false)
            (assoc :w_set_curswant true))
    ))

(defn- #_window_C ins-right [#_window_C win]
    (let [lmax (line-count @curbuf) o'cursor (:w_cursor win) s (ml-get-cursor win)]
        (cond (or (!= (us-ptr2char s) NUL) (virtual-active))
            (let [win (start-arrow win, o'cursor)
                  win (assoc win :w_set_curswant true)]
                (if (virtual-active)
                    (oneright win)
                    (update-in win [:w_cursor :col] + (us-ptr2len-cc s))
                ))
        ;; if 'whichwrap' set for cursor in insert mode, may go to next line
        (and (some? (vim-strchr @p_ww, (byte \]))) (< (:lnum o'cursor) lmax))
            (-> win
                (start-arrow o'cursor)
                (assoc :w_set_curswant true)
                (update-in [:w_cursor :lnum] inc)
                (assoc-in [:w_cursor :col] 0))
        :else
            (do (beep) win))
    ))

(defn- #_window_C ins-s-right [#_window_C win]
    (let-when [lmax (line-count @curbuf) o'cursor (:w_cursor win)] (or (< (:lnum o'cursor) lmax) (!= (gchar-cursor win) NUL)) => (do (beep) win)
        (-> win
            (start-arrow o'cursor)
            (fwd-word 1, false, false)
            (assoc :w_set_curswant true))
    ))

(defn- #_window_C ins-up [#_window_C win, #_boolean startcol]
    ;; startcol: when true move to insStart.col
    (let-when [o'topline (:w_topline win) tpos (:w_cursor win) [win ?] (cursor-up? win, 1, true)] ? => (do (beep) win)
        (let [win (if startcol (coladvance win, (getvcol-nolist win, @insStart)) win)
              win (if (!= (:w_topline win) o'topline) (redraw-later win, VALID) win)
              win (start-arrow win, tpos)]
            (reset! can_cindent true)
            win)
    ))

(defn- #_window_C ins-pageup [#_window_C win]
    (if (non-flag? @mod_mask MOD_MASK_CTRL)
        (let-when [tpos (:w_cursor win) [win ?] (onepage? win, BACKWARD, 1)] ? => (do (beep) win)
            (let [win (start-arrow win, tpos)]
                (reset! can_cindent true)
                win
            ))
        win
    ))

(defn- #_window_C ins-down [#_window_C win, #_boolean startcol]
    ;; startcol: when true move to insStart.col
    (let-when [o'topline (:w_topline win) tpos (:w_cursor win) [win ?] (cursor-down? win, 1, true)] ? => (do (beep) win)
        (let [win (if startcol (coladvance win, (getvcol-nolist win, @insStart)) win)
              win (if (!= (:w_topline win) o'topline) (redraw-later win, VALID) win)
              win (start-arrow win, tpos)]
            (reset! can_cindent true)
            win)
    ))

(defn- #_window_C ins-pagedown [#_window_C win]
    (if (non-flag? @mod_mask MOD_MASK_CTRL)
        (let-when [tpos (:w_cursor win) [win ?] (onepage? win, FORWARD, 1)] ? => (do (beep) win)
            (let [win (start-arrow win, tpos)]
                (reset! can_cindent true)
                win
            ))
        win
    ))

(defn- #_window_C ins-drop [#_window_C win]
    (do-put win, (byte \~), BACKWARD, 1, PUT_CURSEND))

;; Handle TAB in Insert or Replace mode.
;; Return true when the TAB needs to be inserted like a normal character.

(defn- #_[window_C boolean] ins-tab? [#_window_C win]
    (let [et @(:b_p_et @curbuf) ts @(:b_p_ts @curbuf) sw' (get-sw-value) sts @(:b_p_sts @curbuf) sts' (get-sts-value)
          win (if (and (== @insStart_blank_vcol MAXCOL) (== (:lnum (:w_cursor win)) (:lnum @insStart)))
                (let [win (validate-virtcol win)] (reset! insStart_blank_vcol (:w_virtcol win)) win)
                win)
          #_boolean ind (inindent win, 0) rep? (flag? @State REPLACE_FLAG) vrep? (flag? @State VREPLACE_FLAG)]
        (when ind
            (reset! can_cindent false))
        ;; When nothing special, insert TAB like a normal character
        (if (or (and (not et) (not (and @p_sta ind (!= ts sw'))) (zero? sts')) (not (stop-arrow win)))
            [win true]
            (do
                (reset! did_ai false) (reset! did_si false) (reset! can_si false) (reset! can_si_back false)
                (append-redo (u8 "\t"))
                (let-when [win (validate-virtcol win)
                      ;; Insert tab in indent: use 'shiftwidth', 'softtabstop' or 'tabstop'.
                      #_int t (cond (and @p_sta ind) sw' (!= sts 0) sts' :else ts) t (- t (% (:w_virtcol win) t))
                      ;; Insert the first space with ins-char().  It will delete one char in Replace mode.
                      ;; Insert the rest with ins-str().  It will not delete any chars.
                      ;; For VREPLACE mode, we use ins-char() for all characters.
                      win (loop-when [win (ins-char win, (byte \space)) t (dec t)] (< 0 t) => win
                            (let [win (if vrep?
                                        (ins-char win, (byte \space))
                                        (let [win (ins-str win, (u8 " "))] (when rep? (replace-push NUL)) win)
                                    )]
                                (recur win (dec t)))
                           ;; When 'expandtab' not set: replace spaces with TABs where possible.
                        )] (and (not et) (or (non-zero? sts') (and @p_sta ind))) => [win false]

                    ;; Get the current line.  ;; For VREPLACE mode, don't make real changes yet, just work on a copy of the line.
                    (let-when [#_pos_C cpos (:w_cursor win)
                          [#_Bytes s' #_Bytes s] (if vrep? (let [s' (STRDUP (ml-get (:lnum cpos)))] [s' (.plus s' (:col cpos))]) [nil (ml-get-cursor win)])
                          ;; Find first white before the cursor.
                          [#_pos_C fpos s]
                            (loop-when-recur [fpos cpos s s] (and (< 0 (:col fpos)) (vim-iswhite (.at s -1))) [(update fpos :col dec) (.minus s 1)] => [fpos s])
                          ;; In Replace mode, don't change characters before the insert point.
                          [s fpos]
                            (if (and rep? (== (:lnum fpos) (:lnum @insStart)) (< (:col fpos) (:col @insStart)))
                                [(.plus s (- (:col @insStart) (:col fpos))) (assoc fpos :col (:col @insStart))]
                                [s fpos])
                          ;; Compute virtual column numbers of first white and cursor.
                          a'vcol (atom (int))      _ (getvcol win, fpos, a'vcol, nil, nil)
                          a'want_vcol (atom (int)) _ (getvcol win, cpos, a'want_vcol, nil, nil)
                          ;; Use as many TABs as possible.  ;; Beware of 'breakindent', 'showbreak' and 'linebreak' adding extra virtual columns.
                          [#_int x fpos s]
                            (loop-when [x -1 fpos fpos s s] (vim-iswhite (.at s 0)) => [x fpos s]
                                (let-when [#_int i (lbr-chartabsize win, nil, (u8 "\t"), @a'vcol)] (not (< @a'want_vcol (+ @a'vcol i))) => [x fpos s]
                                    (swap! a'vcol + i)
                                    (let [x (if (not-at? s TAB) (do (.be s 0, TAB)
                                                (if (< x 0)
                                                    (let [x (:col fpos)] ;; column of first change
                                                        (when (and (== (:lnum fpos) (:lnum @insStart)) (< (:col fpos) (:col @insStart)))
                                                            (swap! insStart assoc :col (:col fpos)))
                                                        x)
                                                    x))
                                                x)]
                                        (recur x (update fpos :col inc) (.plus s 1)))
                                ))] (< -1 x) => [win false]

                        (let [#_Bytes line s
                              ;; Skip over the spaces we need.
                              [s #_int roff]
                                (loop-when-recur [s s roff 0] (and (< @a'vcol @a'want_vcol) (at? s (byte \space))) [(.plus s 1) (inc roff)] => [s roff]
                                    (swap! a'vcol #(+ % (lbr-chartabsize win, line, s, %))))
                              ;; Must have a char with 'showbreak' just before it.
                              [s roff]
                                (if (< @a'want_vcol @a'vcol) [(.minus s 1) (dec roff)] [s roff])
                              fpos (update fpos :col + roff)
                              ;; Delete following spaces.
                              #_int i (- (:col cpos) (:col fpos))]
                            (when (< 0 i)
                                (BCOPY s, 0, s, i, (inc (STRLEN s, i)))
                                ;; Correct replace stack.
                                (when (and rep? (not vrep?))
                                    (loop-when-recur [#_int t i] (< 0 t) [(dec t)] (replace-join roff))
                                ))
                            ;; In VREPLACE mode, we haven't changed anything yet.
                            ;; Do it now by backspacing over the changed spacing and then inserting the new spacing.
                            (let [win (if vrep?
                                        (-> win (backspace-until-column x) (ins-bytes-len (.plus s' x), (- (:col cpos) i x)))
                                        (update-in win [:w_cursor :col] - i)
                                    )]
                                [win false]
                            ))
                    ))
            ))
    ))

;; Handle CR or NL in Insert mode.
;; Return false when can't undo.

(defn- #_[window_C boolean] ins-eol? [#_window_C win, #_int c]
    (if (stop-arrow win)
        (do ;; Strange Vi behaviour:
            ;; In Replace mode, typing a NL will not delete the character under the cursor.
            ;; Only push a NUL on the replace stack, nothing to put back when the NL is deleted.
            (when (and (flag? @State REPLACE_FLAG) (non-flag? @State VREPLACE_FLAG))
                (replace-push NUL))
            ;; In VREPLACE mode, a NL replaces the rest of the line, and starts replacing the next line,
            ;; so we push all of the characters left on the line onto the replace stack.
            ;; This is not done here though, it is done in open-line().
            ;; Put cursor on NUL if on the last char and coladd is 1 (happens after CTRL-O).
            (let [win (if (and (virtual-active) (< 0 (:coladd (:w_cursor win)))) (coladvance win, (getviscol win)) win)
                  _ (append-redo NL_STR)
                  [win ?] (open-line? win, FORWARD, 0, @old_indent) _ (reset! old_indent 0)]
                (reset! can_cindent true)
                [win ?]
            ))
        [win false]
    ))

(defn- #_window_C ins-eol [#_window_C win, #_int c]
    (let [[win _] (ins-eol? win, c)]
        win
    ))

;; Handle digraph in Insert mode.
;; Returns character still to be inserted, or NUL when nothing remaining to be done.

(defn- #_[window_C int] ins-digraph [#_window_C win]
    (reset! pc_status PC_STATUS_UNSET)
    (let [a'putchar? (atom (boolean false))
          win (if (and (redrawing) (not (char-avail)))
                ;; May need to redraw when no more chars available now.
                (let [win (ins-redraw win, false)
                      win (edit-putchar win, (byte \?), true) _ (reset! a'putchar? true)]
                    (add-to-showcmd-c win, Ctrl_K))
                win)
          ;; Don't map the digraph chars.  ;; This also prevents the mode message to be deleted when ESC is hit.
          _ (swap! no_mapping inc) _ (swap! allow_keys inc) [win #_int c1] (plain-vgetc? win) _ (swap! no_mapping dec) _ (swap! allow_keys dec)
          ;; When the line fits in 'columns', the '?' is at the start of the next line and will not be removed by the redraw.
          win (if @a'putchar? (edit-unputchar win) win)]

        (cond (or (is-special c1) (non-zero? @mod_mask)) ;; special key
            (let [win (clear-showcmd win)] [(insert-special win, c1, true, false) NUL])
        (!= c1 ESC)
            (let [_ (reset! a'putchar? false)
                  win (if (and (redrawing) (not (char-avail)))
                        ;; May need to redraw when no more chars available now.
                        (let [win (ins-redraw win, false)
                              win (if (== (mb-char2cells c1) 1)
                                    (let [win (ins-redraw win, false)
                                          win (edit-putchar win, c1, true) _ (reset! a'putchar? true)]
                                        win)
                                    win)]
                            (add-to-showcmd-c win, c1))
                        win)
                  _ (swap! no_mapping inc) _ (swap! allow_keys inc) [win #_int c2] (plain-vgetc? win) _ (swap! no_mapping dec) _ (swap! allow_keys dec)
                  ;; When the line fits in 'columns', the '?' is at the start of the next line and will not be removed by a redraw.
                  win (if @a'putchar? (edit-unputchar win) win)

                  #_int c3 (if (!= c2 ESC) (do (append-redo CTRL_V_STR) (getdigraph c1, c2, true)) NUL)]
                [(clear-showcmd win) c3]
            )
        :else
            [(clear-showcmd win) NUL]
        )
    ))

;; Handle CTRL-E and CTRL-Y in Insert mode: copy char from other line.
;; Returns the char to be inserted, or NUL if none found.

(defn- #_[window_C int] ins-copychar [#_window_C win, #_long lnum]
    (let [[win c]
            (if (<= 1 lnum (line-count @curbuf))
                (let [#_Bytes line (ml-get lnum) a's (atom (#_Bytes object line))
                      win (validate-virtcol win) vcol (:w_virtcol win)]
                    (loop-when-recur [#_Bytes prior @a's #_int i 0] ;; try to advance to the cursor column
                                     (and (< i vcol) (non-eos? @a's))
                                     [@a's (+ i (lbr-chartabsize-adv win, line, a's, i))]
                                  => (when (< vcol i) (reset! a's prior)))
                    [win (us-ptr2char @a's)])
                [win NUL]
            )]
        (when (== c NUL) (beep))
        [win c]
    ))

;; CTRL-Y or CTRL-E typed in Insert mode.

(defn- #_[window_C int] ins-ctrl-ey [#_window_C win, #_int c]
    (let [[win c] (ins-copychar win, (+ (:lnum (:w_cursor win)) (if (== c Ctrl_Y) -1 1)))]
        (if (!= c NUL)
            (do ;; The character must be taken literally, insert like it was typed after a CTRL-V.
                ;; Digits, 'o' and 'x' are special after a CTRL-V, don't use it for these.
                (when (and (< c 256) (not (asc-isalnum c)))
                    (append-redo CTRL_V_STR))
                [(insert-special win, c, true, false) Ctrl_V]) ;; pretend CTRL-V is last character
            [win NUL])
    ))

;; Try to do some very smart auto-indenting.
;; Used when inserting a "normal" character.

(defn- #_window_C ins-try-si [#_window_C win, #_int c]
    ;; do some very smart indenting when entering '{' or '}'
    (let [win (if (or (and (or @did_si @can_si_back) (== c (byte \{))) (and @can_si (== c (byte \}))))
                (let [a'pos (atom (#_pos_C object))]
                    ;; for '}' set indent equal to indent of line containing matching '{'
                    (cond (and (== c (byte \})) (some? (reset! a'pos (findmatch win, (byte \{)))))
                        ;; If the matching '{' has a ')' immediately before it (ignoring white-space),
                        ;; then line up with the start of the line containing the matching '(' if there is one.
                        ;; This handles the case where an "if (..\n..) {" statement continues over multiple lines.
                        (let [o'cursor (:w_cursor win) #_Bytes s (ml-get (:lnum @a'pos)) #_int i (:col @a'pos)
                              i (if (< 0 i) (loop-when-recur [i (dec i)] (and (< 0 i) (vim-iswhite (.at s i))) [(dec i)] => i) i) ;; skip blanks before '{'
                              win (update win :w_cursor assoc :lnum (:lnum @a'pos) :col i)
                              win (if (and (at? s i (byte \))) (some? (reset! a'pos (findmatch win, (byte \()))))
                                    (assoc win :w_cursor @a'pos)
                                    win)
                              #_int i (get-indent win) win (assoc win :w_cursor o'cursor)]
                            (if (flag? @State VREPLACE_FLAG)
                                (change-indent win, INDENT_SET, i, false, NUL, true)
                                (set-indent win, i, SIN_CHANGED)
                            ))
                    (< 0 (:col (:w_cursor win)))
                        ;; when inserting '{' after "O" reduce indent, but not more than indent of previous line
                        (let [[win shl?]
                                (if (and (== c (byte \{)) @can_si_back (< 1 (:lnum (:w_cursor win))))
                                    (let [o'cursor (:w_cursor win) o'indent (get-indent win)
                                          skip- #(loop-when [l %] (< 1 l) => l ;; ignore empty lines and lines starting with '#'
                                                    (let [l (dec l) s (skipwhite (ml-get l))] (recur-if (or (at? s (byte \#)) (eos? s)) l => l)))
                                          win (update-in win [:w_cursor :lnum] skip-)
                                          shl? (< (get-indent win) o'indent)]
                                        [(assoc win :w_cursor o'cursor) shl?])
                                    [win true]
                                )]
                            (if shl? (shift-line win, true, false, 1, true) win))
                    :else
                        win))
                win)
          ;; set indent of '#' always to 0
          win (if (and (< 0 (:col (:w_cursor win))) @can_si (== c (byte \#)))
                (do ;; remember current indent for next line
                    (reset! old_indent (get-indent win))
                    (set-indent win, 0, SIN_CHANGED))
                win
            )]
        ;; Adjust ai_col, the char at this position can be deleted.
        (when (< (:col (:w_cursor win)) @ai_col)
            (reset! ai_col (:col (:w_cursor win))))
        win
    ))

;; Handle the InsertCharPre autocommand.
;; "c" is the character that was typed.
;; Return a pointer to allocated memory with the replacement string.
;; Return null to continue inserting "c".

(defn- #_Bytes do-insert-char-pre [#_int c]
    ;; %% not yet
    nil)

;;; ============================================================================================== VimN

;; regexp.c ---------------------------------------------------------------------------------------

;; Handling of regular expressions: vim-regcomp(), vim-regexec(), vim-regsub()
;;
;; Beware that some of this code is subtly aware of the way operator
;; precedence is structured in regular expressions.  Serious changes in
;; regular-expression syntax might require a total rethink.

;; The "internal use only" fields in regexp.h are present to pass info from
;; compile to execute that permits the execute phase to run lots faster on
;; simple cases.  They are:
;;
;; regstart     char that must begin a match; NUL if none obvious; Can be a
;;              multi-byte character.
;; reganch      is the match anchored (at beginning-of-line only)?
;; regmust      string (pointer into program) that match must include, or null
;; regmlen      length of regmust string
;; regflags     RF_ values or'ed together
;;
;; Regstart and reganch permit very fast decisions on suitable starting points
;; for a match, cutting down the work a lot.  Regmust permits fast rejection
;; of lines that cannot possibly match.  The regmust tests are costly enough
;; that vim-regcomp() supplies a regmust only if the r.e. contains something
;; potentially expensive (at present, the only such thing detected is * or +
;; at the start of the r.e., which can involve a lot of backup).  Regmlen is
;; supplied because the test in vim-regexec() needs it and vim-regcomp() is
;; computing it anyway.

;; Structure for regexp "program".  This is essentially a linear encoding
;; of a nondeterministic finite-state machine (aka syntax charts or
;; "railroad normal form" in parsing technology).  Each node is an opcode
;; plus a "next" pointer, possibly plus an operand.  "Next" pointers of
;; all nodes except BRANCH and BRACES_COMPLEX implement concatenation; a "next"
;; pointer with a BRANCH on both ends of it is connecting two alternatives.
;; (Here we have one of the subtle syntax dependencies: an individual BRANCH
;; (as opposed to a collection of them) is never concatenated with anything
;; because of operator precedence).  The "next" pointer of a BRACES_COMPLEX
;; node points to the node after the stuff to be repeated.
;; The operand of some types of node is a literal string; for others, it is a
;; node leading into a sub-FSM.  In particular, the operand of a BRANCH node
;; is the first node of the branch.
;; (NB this is *not* a tree structure: the tail of the branch connects to the
;; thing following the set of BRANCHes.)
;;
;; pattern      is coded like:
;;
;;                        +-----------------+
;;                        |                 V
;; <aa>\|<bb>   BRANCH <aa> BRANCH <bb> --> END
;;                   |      ^    |          ^
;;                   +------+    +----------+
;;
;;                     +------------------+
;;                     V                  |
;; <aa>*        BRANCH BRANCH <aa> --> BACK BRANCH --> NOTHING --> END
;;                   |      |               ^                      ^
;;                   |      +---------------+                      |
;;                   +---------------------------------------------+
;;
;;                     +----------------------+
;;                     V                      |
;; <aa>\+       BRANCH <aa> --> BRANCH --> BACK  BRANCH --> NOTHING --> END
;;                   |               |           ^                      ^
;;                   |               +-----------+                      |
;;                   +--------------------------------------------------+
;;
;;                                      +-------------------------+
;;                                      V                         |
;; <aa>\{}      BRANCH BRACE_LIMITS --> BRACE_COMPLEX <aa> --> BACK  END
;;                   |                              |                ^
;;                   |                              +----------------+
;;                   +-----------------------------------------------+
;;
;; <aa>\@!<bb>  BRANCH NOMATCH <aa> --> END  <bb> --> END
;;                   |       |                ^       ^
;;                   |       +----------------+       |
;;                   +--------------------------------+
;;
;;                                                    +---------+
;;                                                    |         V
;; \z[abc]      BRANCH BRANCH  a  BRANCH  b  BRANCH  c  BRANCH  NOTHING --> END
;;                   |      |          |          |     ^                   ^
;;                   |      |          |          +-----+                   |
;;                   |      |          +----------------+                   |
;;                   |      +---------------------------+                   |
;;                   +------------------------------------------------------+
;;
;; They all start with a BRANCH for "\|" alternatives, even when there is only
;; one alternative.

;; The opcodes are:

;; definition   number             opnd?    meaning
(final int BT_END           0)      ;;      End of program or NOMATCH operand.
(final int BT_BOL           1)      ;;      Match "" at beginning of line.
(final int BT_EOL           2)      ;;      Match "" at end of line.
(final int BRANCH           3)      ;; node Match this alternative, or the next...
(final int BACK             4)      ;;      Match "", "next" ptr points backward.
(final int EXACTLY          5)      ;; str  Match this string.
(final int NOTHING          6)      ;;      Match empty string.
(final int STAR             7)      ;; node Match this (simple) thing 0 or more times.
(final int PLUS             8)      ;; node Match this (simple) thing 1 or more times.
(final int MATCH            9)      ;; node Match the operand zero-width.
(final int NOMATCH         10)      ;; node Check for no match with operand.
(final int BEHIND          11)      ;; node Look behind for a match with operand.
(final int NOBEHIND        12)      ;; node Look behind for no match with operand.
(final int SUBPAT          13)      ;; node Match the operand here.
(final int BRACE_SIMPLE    14)      ;; node Match this (simple) thing between m and n times (\{m,n\}).
(final int BT_BOW          15)      ;;      Match "" after [^a-zA-Z0-9_].
(final int BT_EOW          16)      ;;      Match "" at    [^a-zA-Z0-9_].
(final int BRACE_LIMITS    17)      ;; nr nr  Define the min & max for BRACE_SIMPLE and BRACE_COMPLEX.
(final int BT_NEWL         18)      ;;      Match line-break.
(final int BHPOS           19)      ;;      End position for BEHIND or NOBEHIND.

;; character classes: 20-48 normal, 50-78 include a line-break
(final int ADD_NL          30)

(final int ANY             20)      ;;      Match any one character.
(final int ANYOF           21)      ;; str  Match any character in this string.
(final int ANYBUT          22)      ;; str  Match any character not in this string.
(final int IDENT           23)      ;;      Match identifier char.
(final int SIDENT          24)      ;;      Match identifier char but no digit.
(final int KWORD           25)      ;;      Match keyword char.
(final int SKWORD          26)      ;;      Match word char but no digit.
(final int FNAME           27)      ;;      Match file name char.
(final int SFNAME          28)      ;;      Match file name char but no digit.
(final int PRINT           29)      ;;      Match printable char.
(final int SPRINT          30)      ;;      Match printable char but no digit.
(final int WHITE           31)      ;;      Match whitespace char.
(final int NWHITE          32)      ;;      Match non-whitespace char.
(final int DIGIT           33)      ;;      Match digit char.
(final int NDIGIT          34)      ;;      Match non-digit char.
(final int HEX             35)      ;;      Match hex char.
(final int NHEX            36)      ;;      Match non-hex char.
(final int OCTAL           37)      ;;      Match octal char.
(final int NOCTAL          38)      ;;      Match non-octal char.
(final int WORD            39)      ;;      Match word char.
(final int NWORD           40)      ;;      Match non-word char.
(final int HEAD            41)      ;;      Match head char.
(final int NHEAD           42)      ;;      Match non-head char.
(final int ALPHA           43)      ;;      Match alpha char.
(final int NALPHA          44)      ;;      Match non-alpha char.
(final int LOWER           45)      ;;      Match lowercase char.
(final int NLOWER          46)      ;;      Match non-lowercase char.
(final int UPPER           47)      ;;      Match uppercase char.
(final int NUPPER          48)      ;;      Match non-uppercase char.

(final int FIRST_NL        (+ ANY ADD_NL))
(final int LAST_NL         (+ NUPPER ADD_NL))

(defn- #_boolean with-nl [#_int op]
    (<= FIRST_NL op LAST_NL))

(final int MOPEN            80) ;;  -89      Mark this point in input as start of \( subexpr.  MOPEN + 0 marks start of match.
(final int MCLOSE           90) ;;  -99      Analogous to MOPEN.  MCLOSE + 0 marks end of match.
(final int BACKREF         100) ;; -109 node Match same string again \1-\9

(final int BRACE_COMPLEX   140) ;; -149 node Match nodes between m & n times.

(final int NOPEN           150)     ;;      Mark this point in input as start of \%( subexpr.   ;; sic!)
(final int NCLOSE          151)     ;;      Analogous to NOPEN.

(final int MULTIBYTECODE   200)     ;; mbc  Match one multi-byte character.
(final int BT_BOF          201)     ;;      Match "" at beginning of file.
(final int BT_EOF          202)     ;;      Match "" at end of file.
(final int BT_CURSOR       203)     ;;      Match location of cursor.

(final int BT_LNUM         204)     ;; nr cmp  Match line number.
(final int BT_COL          205)     ;; nr cmp  Match column number.
(final int BT_VCOL         206)     ;; nr cmp  Match virtual column number.

(final int BT_MARK         207)     ;; mark cmp  Match mark position.
(final int BT_VISUAL       208)     ;;      Match Visual area.
(final int BT_COMPOSING    209)     ;; any composing characters

;; Magic characters have a special meaning, they don't match literally.
;; Magic characters are negative.  This separates them from literal characters
;; (possibly multi-byte).  Only ASCII characters can be Magic.

(defn- #_final #_int Magic [#_int x]
    (- x 256))

(defn- #_int un-Magic [#_int x]
    (+ x 256))

(defn- #_boolean is-Magic [#_int x]
    (< x 0))

(defn- #_int no-Magic [#_int x]
    (if (is-Magic x) (un-Magic x) x))

(defn- #_int toggle-Magic [#_int x]
    (if (is-Magic x) (un-Magic x) (Magic x)))

;; Opcode notes:
;;
;; BRANCH           The set of branches constituting a single choice are hooked
;;                  together with their "next" pointers, since precedence prevents
;;                  anything being concatenated to any individual branch.  The
;;                  "next" pointer of the last BRANCH in a choice points to the
;;                  thing following the whole choice.  This is also where the
;;                  final "next" pointer of each individual branch points; each
;;                  branch starts with the operand node of a BRANCH node.
;;
;; BACK             Normal "next" pointers all implicitly point forward; BACK
;;                  exists to make loop structures possible.
;;
;; STAR,PLUS        '=', and complex '*' and '+', are implemented as circular
;;                  BRANCH structures using BACK.  Simple cases (one character
;;                  per match) are implemented with STAR and PLUS for speed
;;                  and to minimize recursive plunges.
;;
;; BRACE_LIMITS     This is always followed by a BRACE_SIMPLE or BRACE_COMPLEX
;;                  node, and defines the min and max limits to be used for that node.
;;
;; MOPEN, MCLOSE    ... are numbered at compile time.

;; A node is one char of opcode followed by two chars of "next" pointer.
;; "Next" pointers are stored as two 8-bit bytes, high order first.  The
;; value is a positive offset from the opcode of the node containing it.
;; An operand, if any, simply follows the node.  (Note that much of the
;; code generation knows about this implicit relationship.)
;;
;; Using two bytes for the "next" pointer is vast overkill for most things,
;; but allows patterns to get big without disasters.

(defn- #_int re-op [#_Bytes p]
    (int (.at p 0)))

(defn- #_int re-next [#_Bytes p]
    (+ (<< (int (.at p 1)) 8) (int (.at p 2))))

(defn- #_Bytes operand [#_Bytes p]
    (.plus p 3))

;; Obtain an operand that was stored as four bytes, MSB first.
(defn- #_long operand-min [#_Bytes p]
    (+ (<< (long (.at p 3)) 24) (<< (long (.at p 4)) 16) (<< (long (.at p 5)) 8) (long (.at p 6))))

;; Obtain a second operand stored as four bytes.
(defn- #_long operand-max [#_Bytes p]
    (operand-min (.plus p 4)))

;; Obtain a second single-byte operand stored after a four bytes operand.
(defn- #_byte operand-cmp [#_Bytes p]
    (.at p 7))

(final long MAX_LIMIT       (<< 32767 16))

(final Bytes
    e_missingbracket  (u8 "E769: Missing ] after %s["),
    e_unmatchedpp     (u8 "E53: Unmatched %s%%("),
    e_unmatchedp      (u8 "E54: Unmatched %s("),
    e_unmatchedpar    (u8 "E55: Unmatched %s)"),
    e_z_not_allowed   (u8 "E66: \\z( not allowed here"),
    e_z1_not_allowed  (u8 "E67: \\z1 et al. not allowed here"),
    e_missing_sb      (u8 "E69: Missing ] after %s%%["),
    e_empty_sb        (u8 "E70: Empty %s%%[]"))

(final int
    NOT_MULTI       0,
    MULTI_ONE       1,
    MULTI_MULT      2)

;; Return NOT_MULTI if c is not a "multi" operator.
;; Return MULTI_ONE if c is a single "multi" operator.
;; Return MULTI_MULT if c is a multi "multi" operator.

(defn- #_int re-multi-type [#_int c]
    (condp ==? c
        [(Magic (byte \@)) (Magic (byte \=)) (Magic (byte \?))]
            MULTI_ONE
        [(Magic (byte \*)) (Magic (byte \+)) (Magic (byte \{))]
            MULTI_MULT
     ;; :else
            NOT_MULTI
    ))

;; Flags to be passed up and down.

(final int
    HASWIDTH        0x1,     ;; Known never to match null string.
    SIMPLE          0x2,     ;; Simple enough to be STAR/PLUS operand.
    SPSTART         0x4,     ;; Starts with * or +.
    HASNL           0x8,     ;; Contains some \n.
    HASLOOKBH       0x10)    ;; Contains "\@<=" or "\@<!".
(final int WORST    0)       ;; Worst case.

;; When regcode is set to this value, code is not emitted and size is computed instead.

(final Bytes JUST_CALC_SIZE (u8 ""))

(atom! Bytes reg_prev_sub)

;; REGEXP_INRANGE contains all characters which are always special in a [] range after '\'.
;; REGEXP_ABBR contains all characters which act as abbreviations after '\'.
;; These are:
;;  \n  - New line (NL).
;;  \r  - Carriage Return (CR).
;;  \t  - Tab (TAB).
;;  \e  - Escape (ESC).
;;  \b  - Backspace (Ctrl_H).
;;  \d  - Character code in decimal, e.g. \d123
;;  \o  - Character code in octal, e.g. \o80
;;  \x  - Character code in hex, e.g. \x4a
;;  \\u (sic!) - Multibyte character code, e.g. \u20ac
;;  \U  - Long multibyte character code, e.g. \U12345678

(final Bytes REGEXP_INRANGE (u8 "]^-n\\"))
(final Bytes REGEXP_ABBR (u8 "nrtebdoxuU"))

;; Translate '\x' to its control character, except "\n", which is Magic.

(defn- #_int backslash-trans [#_int c]
    (condp == c
        (byte \r) CAR
        (byte \t) TAB
        (byte \e) ESC
        (byte \b) BS
                  c
    ))

(final int
    CLASS_ALNUM      0,
    CLASS_ALPHA      1,
    CLASS_BLANK      2,
    CLASS_CNTRL      3,
    CLASS_DIGIT      4,
    CLASS_GRAPH      5,
    CLASS_LOWER      6,
    CLASS_PRINT      7,
    CLASS_PUNCT      8,
    CLASS_SPACE      9,
    CLASS_UPPER     10,
    CLASS_XDIGIT    11,
    CLASS_TAB       12,
    CLASS_RETURN    13,
    CLASS_BACKSPACE 14,
    CLASS_ESCAPE    15,
    CLASS_NONE      99)

(final Bytes* class_names
    [
        (u8 "alnum:]")
        (u8 "alpha:]")
        (u8 "blank:]")
        (u8 "cntrl:]")
        (u8 "digit:]")
        (u8 "graph:]")
        (u8 "lower:]")
        (u8 "print:]")
        (u8 "punct:]")
        (u8 "space:]")
        (u8 "upper:]")
        (u8 "xdigit:]")
        (u8 "tab:]")
        (u8 "return:]")
        (u8 "backspace:]")
        (u8 "escape:]")
    ])

;; Check for a character class name "[:name:]".  "s" points to the '['.
;; Returns one of the CLASS_ items.  CLASS_NONE means that no item was
;; recognized.  Otherwise "s" is advanced to after the item.

(defn- #_int get-char-class [#_Bytes' a's]
    (when' (at? @a's 1 (byte \:)) => CLASS_NONE
        (let [#_int m (count class_names)]
            (loop-when [#_int i 0] (< i m) => CLASS_NONE
                (let [#_int n (STRLEN (... class_names i))]
                    (if (zero? (STRNCMP (.plus @a's 2), (... class_names i), n))
                        (do (swap! a's plus (+ 2 n)) i)
                        (recur (inc i))
                    ))
            ))
    ))

;; Specific version of character class functions.
;; Using a table to keep this fast.

(final int
    RI_DIGIT    0x01,
    RI_HEX      0x02,
    RI_OCTAL    0x04,
    RI_WORD     0x08,
    RI_HEAD     0x10,
    RI_ALPHA    0x20,
    RI_LOWER    0x40,
    RI_UPPER    0x80,
    RI_WHITE    0x100)

(defn- #_int* init-class-tab []
    (let [cls- #(cond
                    (any == % TAB (byte \space))  RI_WHITE
                    (<= (byte \0) % (byte \7)) (+ RI_DIGIT RI_HEX RI_OCTAL RI_WORD)
                    (<= (byte \8) % (byte \9)) (+ RI_DIGIT RI_HEX RI_WORD)
                    (<= (byte \a) % (byte \f)) (+ RI_HEX RI_WORD RI_HEAD RI_ALPHA RI_LOWER)
                    (<= (byte \g) % (byte \z)) (+ RI_WORD RI_HEAD RI_ALPHA RI_LOWER)
                    (<= (byte \A) % (byte \F)) (+ RI_HEX RI_WORD RI_HEAD RI_ALPHA RI_UPPER)
                    (<= (byte \G) % (byte \Z)) (+ RI_WORD RI_HEAD RI_ALPHA RI_UPPER)
                    (== % (byte \_))           (+ RI_WORD RI_HEAD)
                :else 0
            )]
        (vec (map cls- (range 256)))
    ))

(final int* class_tab (init-class-tab))

(defn- #_boolean ri-digit [#_int c] (and (< c 0x100) (flag? (... class_tab c) RI_DIGIT)))
(defn- #_boolean ri-hex   [#_int c] (and (< c 0x100) (flag? (... class_tab c) RI_HEX)))
(defn- #_boolean ri-octal [#_int c] (and (< c 0x100) (flag? (... class_tab c) RI_OCTAL)))
(defn- #_boolean ri-word  [#_int c] (and (< c 0x100) (flag? (... class_tab c) RI_WORD)))
(defn- #_boolean ri-head  [#_int c] (and (< c 0x100) (flag? (... class_tab c) RI_HEAD)))
(defn- #_boolean ri-alpha [#_int c] (and (< c 0x100) (flag? (... class_tab c) RI_ALPHA)))
(defn- #_boolean ri-lower [#_int c] (and (< c 0x100) (flag? (... class_tab c) RI_LOWER)))
(defn- #_boolean ri-upper [#_int c] (and (< c 0x100) (flag? (... class_tab c) RI_UPPER)))
(defn- #_boolean ri-white [#_int c] (and (< c 0x100) (flag? (... class_tab c) RI_WHITE)))

;; flags for regflags
(final int
    RF_ICASE    1,   ;; ignore case
    RF_NOICASE  2,   ;; don't ignore case
    RF_HASNL    4,   ;; can match a NL
    RF_ICOMBINE 8,   ;; ignore combining characters
    RF_LOOKBH   16)  ;; uses "\@<=" or "\@<!"

;; Global work variables for vim-regcomp().

(atom! Bytes    regparse)                   ;; input-scan pointer
(atom! int      prevchr_len)                ;; byte length of previous char
(atom! int      num_complex_braces)         ;; complex \{...} count
(atom! int      regnpar)                    ;; () count
(atom! Bytes    regcode)                    ;; code-emit pointer, or JUST_CALC_SIZE
(atom! int      regsize)                    ;; code size
(atom! boolean  reg_toolong)                ;; true when offset out of range
(atom! boolean* had_endbrace    NSUBEXP)    ;; flags, true if end of () found
(atom! int      regflags)                   ;; RF_ flags
(atom! long*    brace_min       10)         ;; minimums for complex brace repeats
(atom! long*    brace_max       10)         ;; maximums for complex brace repeats
(atom! int*     brace_count     10)         ;; current counts for complex brace repeats
(atom! boolean  one_exactly)                ;; only do one char for EXACTLY

(atom! int      reg_magic)                  ;; magicness of the pattern:
(final int
    MAGIC_NONE  1,                   ;; "\V" very unmagic
    MAGIC_OFF   2,                   ;; "\M" or 'magic' off
    MAGIC_ON    3,                   ;; "\m" or 'magic'
    MAGIC_ALL   4)                   ;; "\v" very magic

(atom! boolean  reg_string)                 ;; matching with a string instead of a buffer line
(atom! boolean  reg_strict)                 ;; "[abc" is illegal

;; META contains all characters that may be magic, except '^' and '$'.

;; META[] is used often enough to justify turning it into a table.
(final byte* META_flags
    [
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
;;                     %  &     (  )  *  +        .
        0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 1, 0,
;;         1  2  3  4  5  6  7  8  9        <  =  >  ?
        0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1,
;;      @  A     C  D     F     H  I     K  L  M     O
        1, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 1, 1, 0, 1,
;;      P        S     U  V  W  X     Z  [           _
        1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 1,
;;         a     c  d     f     h  i     k  l  m  n  o
        0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1,
;;      p        s     u  v  w  x     z  {  |     ~
        1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1
    ])

(atom! int      curchr)             ;; currently parsed character

;; Previous character.  Note: prevchr is sometimes -1 when we are not at the start,
;; e.g. in /[ ^I]^ the pattern was never found even if it existed,
;; because ^ was taken to be magic.

(atom! int      prevchr)
(atom! int      prevprevchr)        ;; previous-previous character
(atom! int      nextchr)            ;; used for ungetchr()

;; arguments for bt-reg()
(final int REG_NOPAREN     0)           ;; toplevel bt-reg()
(final int REG_PAREN       1)           ;; \(\)
(final int REG_NPAREN      2)           ;; \%(\)    ;; sic!)

(class! #_final parse_state_C
    [
        (field Bytes        regparse)
        (field int          prevchr_len)
        (field int          curchr)
        (field int          prevchr)
        (field int          prevprevchr)
        (field int          nextchr)
        (field boolean      at_start)
        (field boolean      prev_at_start)
        (field int          regnpar)
    ])

;; Return true if compiled regular expression "pat" can match a line break.

(defn- #_boolean re-multiline [#_pattern_C pat]
    (flag? (:regflags pat) RF_HASNL))

;; Return true if compiled regular expression "pat" looks before the start
;; position (pattern contains "\@<=" or "\@<!").

(defn- #_boolean re-lookbehind [#_pattern_C pat]
    (flag? (:regflags pat) RF_LOOKBH))

;; Check for an equivalence class name "[=a=]".  "s" points to the '['.
;; Returns a character representing the class.  Zero means that no item
;; was recognized.  Otherwise "s" is advanced to after the item.

(defn- #_int get-equi-class [#_Bytes' a's]
    (let-when [s @a's] (at? s 1 (byte \=)) => 0
        (let-when [n (us-ptr2len-cc s, 2)] (and (at? s (+ n 2) (byte \=)) (at? s (+ n 3) (byte \]))) => 0
            (let [c (us-ptr2char s, 2)] (swap! a's plus (+ n 4)) c)
        )))

;; Produce the bytes for equivalence class "c".
;; Currently only handles latin1, latin9 and utf-8.
;;
;; NOTE! When changing this function, also change nfa-emit-equi-class()

(defn- #_void reg-equi-class [#_int c]
    (condp ==? c
        [(byte \A), 0xc0 0xc1 0xc2, 0xc3 0xc4 0xc5, 0x100 0x102 0x104, 0x1cd 0x1de 0x1e0, 0x1ea2]
        (do
            (regmbc (byte \A))
            (regmbc 0xc0) (regmbc 0xc1) (regmbc 0xc2)
            (regmbc 0xc3) (regmbc 0xc4) (regmbc 0xc5)
            (regmbc 0x100) (regmbc 0x102) (regmbc 0x104)
            (regmbc 0x1cd) (regmbc 0x1de) (regmbc 0x1e0)
            (regmbc 0x1ea2)
        )

        [(byte \a), 0xe0 0xe1 0xe2, 0xe3 0xe4 0xe5, 0x101 0x103 0x105, 0x1ce 0x1df 0x1e1, 0x1ea3]
        (do
            (regmbc (byte \a))
            (regmbc 0xe0) (regmbc 0xe1) (regmbc 0xe2)
            (regmbc 0xe3) (regmbc 0xe4) (regmbc 0xe5)
            (regmbc 0x101) (regmbc 0x103) (regmbc 0x105)
            (regmbc 0x1ce) (regmbc 0x1df) (regmbc 0x1e1)
            (regmbc 0x1ea3)
        )

        [(byte \B), 0x1e02 0x1e06]
        (do
            (regmbc (byte \B))
            (regmbc 0x1e02) (regmbc 0x1e06)
        )

        [(byte \b), 0x1e03 0x1e07]
        (do
            (regmbc (byte \b))
            (regmbc 0x1e03) (regmbc 0x1e07)
        )

        [(byte \C), 0xc7, 0x106 0x108 0x10a 0x10c]
        (do
            (regmbc (byte \C))
            (regmbc 0xc7)
            (regmbc 0x106) (regmbc 0x108) (regmbc 0x10a) (regmbc 0x10c)
        )

        [(byte \c), 0xe7, 0x107 0x109 0x10b 0x10d]
        (do
            (regmbc (byte \c))
            (regmbc 0xe7)
            (regmbc 0x107) (regmbc 0x109) (regmbc 0x10b) (regmbc 0x10d)
        )

        [(byte \D), 0x10e 0x110, 0x1e0a 0x1e0c 0x1e0e 0x1e10 0x1e12]
        (do
            (regmbc (byte \D))
            (regmbc 0x10e) (regmbc 0x110)
            (regmbc 0x1e0a) (regmbc 0x1e0c) (regmbc 0x1e0e) (regmbc 0x1e10) (regmbc 0x1e12)
        )

        [(byte \d), 0x10f 0x111, 0x1e0b 0x1e0d 0x1e0f 0x1e11 0x1e13]
        (do
            (regmbc (byte \d))
            (regmbc 0x10f) (regmbc 0x111)
            (regmbc 0x1e0b) (regmbc 0x1e0d) (regmbc 0x1e0f) (regmbc 0x1e11) (regmbc 0x1e13)
        )

        [(byte \E), 0xc8 0xc9 0xca 0xcb, 0x112 0x114 0x116 0x118 0x11a, 0x1eba 0x1ebc]
        (do
            (regmbc (byte \E))
            (regmbc 0xc8) (regmbc 0xc9) (regmbc 0xca) (regmbc 0xcb)
            (regmbc 0x112) (regmbc 0x114) (regmbc 0x116) (regmbc 0x118) (regmbc 0x11a)
            (regmbc 0x1eba) (regmbc 0x1ebc)
        )

        [(byte \e), 0xe8 0xe9 0xea 0xeb, 0x113 0x115 0x117 0x119 0x11b, 0x1ebb 0x1ebd]
        (do
            (regmbc (byte \e))
            (regmbc 0xe8) (regmbc 0xe9) (regmbc 0xea) (regmbc 0xeb)
            (regmbc 0x113) (regmbc 0x115) (regmbc 0x117) (regmbc 0x119) (regmbc 0x11b)
            (regmbc 0x1ebb) (regmbc 0x1ebd)
        )

        [(byte \F), 0x1e1e]
        (do
            (regmbc (byte \F))
            (regmbc 0x1e1e)
        )

        [(byte \f), 0x1e1f]
        (do
            (regmbc (byte \f))
            (regmbc 0x1e1f)
        )

        [(byte \G), 0x11c 0x11e 0x120 0x122, 0x1e4 0x1e6 0x1f4, 0x1e20]
        (do
            (regmbc (byte \G))
            (regmbc 0x11c) (regmbc 0x11e) (regmbc 0x120) (regmbc 0x122)
            (regmbc 0x1e4) (regmbc 0x1e6) (regmbc 0x1f4)
            (regmbc 0x1e20)
        )

        [(byte \g), 0x11d 0x11f 0x121 0x123, 0x1e5 0x1e7 0x1f5, 0x1e21]
        (do
            (regmbc (byte \g))
            (regmbc 0x11d) (regmbc 0x11f) (regmbc 0x121) (regmbc 0x123)
            (regmbc 0x1e5) (regmbc 0x1e7) (regmbc 0x1f5)
            (regmbc 0x1e21)
        )

        [(byte \H), 0x124 0x126, 0x1e22 0x1e26 0x1e28]
        (do
            (regmbc (byte \H))
            (regmbc 0x124) (regmbc 0x126)
            (regmbc 0x1e22) (regmbc 0x1e26) (regmbc 0x1e28)
        )

        [(byte \h), 0x125 0x127, 0x1e23 0x1e27 0x1e29 0x1e96]
        (do
            (regmbc (byte \h))
            (regmbc 0x125) (regmbc 0x127)
            (regmbc 0x1e23) (regmbc 0x1e27) (regmbc 0x1e29) (regmbc 0x1e96)
        )

        [(byte \I), 0xcc 0xcd 0xce 0xcf, 0x128 0x12a 0x12c 0x12e 0x130, 0x1cf, 0x1ec8]
        (do
            (regmbc (byte \I))
            (regmbc 0xcc) (regmbc 0xcd) (regmbc 0xce) (regmbc 0xcf)
            (regmbc 0x128) (regmbc 0x12a) (regmbc 0x12c) (regmbc 0x12e) (regmbc 0x130)
            (regmbc 0x1cf)
            (regmbc 0x1ec8)
        )

        [(byte \i), 0xec 0xed 0xee 0xef, 0x129 0x12b 0x12d 0x12f 0x131, 0x1d0, 0x1ec9]
        (do
            (regmbc (byte \i))
            (regmbc 0xec) (regmbc 0xed) (regmbc 0xee) (regmbc 0xef)
            (regmbc 0x129) (regmbc 0x12b) (regmbc 0x12d) (regmbc 0x12f) (regmbc 0x131)
            (regmbc 0x1d0)
            (regmbc 0x1ec9)
        )

        [(byte \J), 0x134]
        (do
            (regmbc (byte \J))
            (regmbc 0x134)
        )

        [(byte \j), 0x135 0x1f0]
        (do
            (regmbc (byte \j))
            (regmbc 0x135) (regmbc 0x1f0)
        )

        [(byte \K), 0x136 0x1e8, 0x1e30 0x1e34]
        (do
            (regmbc (byte \K))
            (regmbc 0x136) (regmbc 0x1e8)
            (regmbc 0x1e30) (regmbc 0x1e34)
        )

        [(byte \k), 0x137 0x1e9, 0x1e31 0x1e35]
        (do
            (regmbc (byte \k))
            (regmbc 0x137) (regmbc 0x1e9)
            (regmbc 0x1e31) (regmbc 0x1e35)
        )

        [(byte \L), 0x139 0x13b 0x13d 0x13f 0x141, 0x1e3a]
        (do
            (regmbc (byte \L))
            (regmbc 0x139) (regmbc 0x13b) (regmbc 0x13d) (regmbc 0x13f) (regmbc 0x141)
            (regmbc 0x1e3a)
        )

        [(byte \l), 0x13a 0x13c 0x13e 0x140 0x142, 0x1e3b]
        (do
            (regmbc (byte \l))
            (regmbc 0x13a) (regmbc 0x13c) (regmbc 0x13e) (regmbc 0x140) (regmbc 0x142)
            (regmbc 0x1e3b)
        )

        [(byte \M), 0x1e3e 0x1e40]
        (do
            (regmbc (byte \M))
            (regmbc 0x1e3e) (regmbc 0x1e40)
        )

        [(byte \m), 0x1e3f 0x1e41]
        (do
            (regmbc (byte \m))
            (regmbc 0x1e3f) (regmbc 0x1e41)
        )

        [(byte \N), 0xd1, 0x143 0x145 0x147, 0x1e44 0x1e48]
        (do
            (regmbc (byte \N))
            (regmbc 0xd1)
            (regmbc 0x143) (regmbc 0x145) (regmbc 0x147)
            (regmbc 0x1e44) (regmbc 0x1e48)
        )

        [(byte \n), 0xf1, 0x144 0x146 0x148 0x149, 0x1e45 0x1e49]
        (do
            (regmbc (byte \n))
            (regmbc 0xf1)
            (regmbc 0x144) (regmbc 0x146) (regmbc 0x148) (regmbc 0x149)
            (regmbc 0x1e45) (regmbc 0x1e49)
        )

        [(byte \O), 0xd2 0xd3 0xd4, 0xd5 0xd6 0xd8, 0x14c 0x14e 0x150, 0x1a0 0x1d1 0x1ea 0x1ec, 0x1ece]
        (do
            (regmbc (byte \O))
            (regmbc 0xd2) (regmbc 0xd3) (regmbc 0xd4)
            (regmbc 0xd5) (regmbc 0xd6) (regmbc 0xd8)
            (regmbc 0x14c) (regmbc 0x14e) (regmbc 0x150)
            (regmbc 0x1a0) (regmbc 0x1d1) (regmbc 0x1ea) (regmbc 0x1ec)
            (regmbc 0x1ece)
        )

        [(byte \o), 0xf2 0xf3 0xf4, 0xf5 0xf6 0xf8, 0x14d 0x14f 0x151, 0x1a1 0x1d2 0x1eb 0x1ed, 0x1ecf]
        (do
            (regmbc (byte \o))
            (regmbc 0xf2) (regmbc 0xf3) (regmbc 0xf4)
            (regmbc 0xf5) (regmbc 0xf6) (regmbc 0xf8)
            (regmbc 0x14d) (regmbc 0x14f) (regmbc 0x151)
            (regmbc 0x1a1) (regmbc 0x1d2) (regmbc 0x1eb) (regmbc 0x1ed)
            (regmbc 0x1ecf)
        )

        [(byte \P), 0x1e54 0x1e56]
        (do
            (regmbc (byte \P))
            (regmbc 0x1e54) (regmbc 0x1e56)
        )

        [(byte \p), 0x1e55 0x1e57]
        (do
            (regmbc (byte \p))
            (regmbc 0x1e55) (regmbc 0x1e57)
        )

        [(byte \R), 0x154 0x156 0x158, 0x1e58 0x1e5e]
        (do
            (regmbc (byte \R))
            (regmbc 0x154) (regmbc 0x156) (regmbc 0x158)
            (regmbc 0x1e58) (regmbc 0x1e5e)
        )

        [(byte \r), 0x155 0x157 0x159, 0x1e59 0x1e5f]
        (do
            (regmbc (byte \r))
            (regmbc 0x155) (regmbc 0x157) (regmbc 0x159)
            (regmbc 0x1e59) (regmbc 0x1e5f)
        )

        [(byte \S), 0x15a 0x15c 0x15e 0x160, 0x1e60]
        (do
            (regmbc (byte \S))
            (regmbc 0x15a) (regmbc 0x15c) (regmbc 0x15e) (regmbc 0x160)
            (regmbc 0x1e60)
        )

        [(byte \s), 0x15b 0x15d 0x15f 0x161, 0x1e61]
        (do
            (regmbc (byte \s))
            (regmbc 0x15b) (regmbc 0x15d) (regmbc 0x15f) (regmbc 0x161)
            (regmbc 0x1e61)
        )

        [(byte \T), 0x162 0x164 0x166, 0x1e6a 0x1e6e]
        (do
            (regmbc (byte \T))
            (regmbc 0x162) (regmbc 0x164) (regmbc 0x166)
            (regmbc 0x1e6a) (regmbc 0x1e6e)
        )

        [(byte \t), 0x163 0x165 0x167, 0x1e6b 0x1e6f 0x1e97]
        (do
            (regmbc (byte \t))
            (regmbc 0x163) (regmbc 0x165) (regmbc 0x167)
            (regmbc 0x1e6b) (regmbc 0x1e6f) (regmbc 0x1e97)
        )

        [(byte \U), 0xd9 0xda 0xdb 0xdc, 0x168 0x16a 0x16c 0x16e, 0x170 0x172 0x1af 0x1d3, 0x1ee6]
        (do
            (regmbc (byte \U))
            (regmbc 0xd9) (regmbc 0xda) (regmbc 0xdb) (regmbc 0xdc)
            (regmbc 0x168) (regmbc 0x16a) (regmbc 0x16c) (regmbc 0x16e)
            (regmbc 0x170) (regmbc 0x172) (regmbc 0x1af) (regmbc 0x1d3)
            (regmbc 0x1ee6)
        )

        [(byte \u), 0xf9 0xfa 0xfb 0xfc, 0x169 0x16b 0x16d 0x16f, 0x171 0x173 0x1b0 0x1d4, 0x1ee7]
        (do
            (regmbc (byte \u))
            (regmbc 0xf9) (regmbc 0xfa) (regmbc 0xfb) (regmbc 0xfc)
            (regmbc 0x169) (regmbc 0x16b) (regmbc 0x16d) (regmbc 0x16f)
            (regmbc 0x171) (regmbc 0x173) (regmbc 0x1b0) (regmbc 0x1d4)
            (regmbc 0x1ee7)
        )

        [(byte \V), 0x1e7c]
        (do
            (regmbc (byte \V))
            (regmbc 0x1e7c)
        )

        [(byte \v), 0x1e7d]
        (do
            (regmbc (byte \v))
            (regmbc 0x1e7d)
        )

        [(byte \W), 0x174, 0x1e80 0x1e82 0x1e84 0x1e86]
        (do
            (regmbc (byte \W))
            (regmbc 0x174)
            (regmbc 0x1e80) (regmbc 0x1e82) (regmbc 0x1e84) (regmbc 0x1e86)
        )

        [(byte \w), 0x175, 0x1e81 0x1e83 0x1e85 0x1e87 0x1e98]
        (do
            (regmbc (byte \w))
            (regmbc 0x175)
            (regmbc 0x1e81) (regmbc 0x1e83) (regmbc 0x1e85) (regmbc 0x1e87) (regmbc 0x1e98)
        )

        [(byte \X), 0x1e8a 0x1e8c]
        (do
            (regmbc (byte \X))
            (regmbc 0x1e8a) (regmbc 0x1e8c)
        )

        [(byte \x), 0x1e8b 0x1e8d]
        (do
            (regmbc (byte \x))
            (regmbc 0x1e8b) (regmbc 0x1e8d)
        )

        [(byte \Y), 0xdd, 0x176 0x178, 0x1e8e 0x1ef2 0x1ef6 0x1ef8]
        (do
            (regmbc (byte \Y))
            (regmbc 0xdd)
            (regmbc 0x176) (regmbc 0x178)
            (regmbc 0x1e8e) (regmbc 0x1ef2) (regmbc 0x1ef6) (regmbc 0x1ef8)
        )

        [(byte \y), 0xfd 0xff, 0x177, 0x1e8f 0x1e99 0x1ef3 0x1ef7 0x1ef9]
        (do
            (regmbc (byte \y))
            (regmbc 0xfd) (regmbc 0xff)
            (regmbc 0x177)
            (regmbc 0x1e8f) (regmbc 0x1e99) (regmbc 0x1ef3) (regmbc 0x1ef7) (regmbc 0x1ef9)
        )

        [(byte \Z), 0x179 0x17b 0x17d 0x1b5, 0x1e90 0x1e94]
        (do
            (regmbc (byte \Z))
            (regmbc 0x179) (regmbc 0x17b) (regmbc 0x17d) (regmbc 0x1b5)
            (regmbc 0x1e90) (regmbc 0x1e94)
        )

        [(byte \z), 0x17a 0x17c 0x17e 0x1b6, 0x1e91 0x1e95]
        (do
            (regmbc (byte \z))
            (regmbc 0x17a) (regmbc 0x17c) (regmbc 0x17e) (regmbc 0x1b6)
            (regmbc 0x1e91) (regmbc 0x1e95)
        )

     ;; :else
            (regmbc c))
    nil)

;; Check for a collating element "[.a.]".  "s" points to the '['.
;; Returns a character.  Zero means that no item was recognized.
;; Otherwise "s" is advanced to after the item.
;; Currently only single characters are recognized!

(defn- #_int get-coll-element [#_Bytes' a's]
    (let-when [s @a's] (at? s 1 (byte \.)) => 0
        (let-when [n (us-ptr2len-cc s, 2)] (and (at? s (+ n 2) (byte \.)) (at? s (+ n 3) (byte \]))) => 0
            (let [c (us-ptr2char s, 2)] (swap! a's plus (+ n 4)) c)
        )))

(atom! boolean reg_cpo_lit)     ;; 'cpoptions' contains 'l' flag
(atom! boolean reg_cpo_bsl)     ;; 'cpoptions' contains '\' flag

(defn- #_void get-cpo-flags []
    (reset! reg_cpo_lit (some? (vim-strbyte @p_cpo, CPO_LITERAL)))
    (reset! reg_cpo_bsl (some? (vim-strbyte @p_cpo, CPO_BACKSL)))
    nil)

;; Skip over a "[]" range.
;; "s" must point to the character after the '['.
;; The returned pointer is on the matching ']', or the terminating NUL.

(defn- #_Bytes skip-anyof [#_Bytes s]
    (let [s (if (at? s (byte \^)) (.plus s 1) s) ;; complement of range
          s (if (or (at? s (byte \])) (at? s (byte \-))) (.plus s 1) s)]
        (loop-when s (and (non-eos? s) (not-at? s (byte \]))) => s
            (let [#_int n (us-ptr2len-cc s)
                  s (cond (< 1 n)
                        (.plus s n)
                    (at? s (byte \-))
                        (let [s (.plus s 1)]
                            (if (and (not-at? s (byte \])) (non-eos? s)) (.plus s (us-ptr2len-cc s)) s))
                    (and (at? s (byte \\))
                            (not @reg_cpo_bsl)
                                (or (some? (vim-strchr REGEXP_INRANGE, (.at s 1))) (and (not @reg_cpo_lit) (some? (vim-strchr REGEXP_ABBR, (.at s 1))))))
                        (.plus s 2)
                    (at? s (byte \[))
                        (let [[#_boolean b s]
                                (let [__ (atom (#_Bytes object s))]
                                    [(and (== (get-char-class __) CLASS_NONE) (zero? (get-equi-class __)) (zero? (get-coll-element __))) @__])]
                            (if b (.plus s 1) s)) ;; not a class name
                    :else
                        (.plus s 1)
                    )]
                (recur s)
            ))
    ))

;; Skip past regular expression.
;; Stop at end of "s" or where "dirc" is found ('/', '?', etc).
;; Take care of characters with a backslash in front of it.
;; Skip strings inside [ and ].
;; When "q" is not null and "dirc" is '?', make an allocated copy of the expression and change "\?" to "?".
;; When "*q" is not null, the expression is changed in-place.

(defn- #_Bytes skip-regexp [#_Bytes s, #_byte dirc, #_boolean magic, #_Bytes' a'q]
    (get-cpo-flags)
    (loop-when [#_int m (if magic MAGIC_ON MAGIC_OFF) #_Bytes p s] (and (non-eos? p) (not-at? p dirc)) => p
        (let-when [[m p]
                (cond (or (and (at? p (byte \[)) (<= MAGIC_ON m)) (and (at? p (byte \\)) (at? p 1 (byte \[)) (<= m MAGIC_OFF)))
                    (let [p (skip-anyof (.plus p 1))]
                        [(if (eos? p) nil m) p])
                (and (at? p (byte \\)) (non-eos? p 1))
                    (let [p (if (and (== dirc (byte \?)) (some? a'q) (at? p 1 (byte \?))) ;; change "\?" to "?", make a copy first
                                (let [p (if (nil? @a'q) (do (reset! a'q (STRDUP s)) (.plus @a'q (BDIFF p, s))) p)] (BCOPY p, 0, p, 1, (inc (STRLEN p, 1))) p)
                                (.plus p 1))] ;; skip next character
                        [(cond (at? p (byte \v)) MAGIC_ALL (at? p (byte \V)) MAGIC_NONE :else m) p])
                :else [m p])] (some? m) => p
            (recur m (.plus p (us-ptr2len-cc p))))
    ))

;; Compile a regular expression into internal code for the traditional backtrack matcher.
;; Returns the program in allocated space.  Returns null for an error.
;;
;; We can't allocate space until we know how big the compiled form will be,
;; but we can't compile it (and thus know how big it is) until we've got a place to put the code.
;; So we cheat:  we compile it twice, once with code generation turned off and size counting turned on, and once "for real".
;; This also means that we don't allocate space until we are sure that the thing really will compile successfully,
;; and we never have to move the code and thus invalidate pointers into it.
;;
;; Whether upper/lower case is to be ignored is decided when executing the program, it does not matter here.
;;
;; Beware that the optimization-preparation code in here knows about some of the structure of the compiled regexp.
;; "re_flags": RE_MAGIC and/or RE_STRING.

(defn- #_[window_C pattern_C] bt-regcomp? [#_window_C win, #_Bytes expr, #_int re_flags]
    (when' (some? expr) => (do (reset! rc_did_emsg true) [(emsg win, e_null) nil])
        ;; First pass: determine size, legality.
        (regcomp-start expr, re_flags)
        (reset! regcode JUST_CALC_SIZE)
        (let-when [a'flags (atom (int)) [win ?] (bt-reg? win, REG_NOPAREN, a'flags)] (some? ?) => [win nil]

            (let-when [#_bt_pattern_C pat (-> (NEW_bt_pattern_C) (assoc :program (Bytes. (inc @regsize))))
                  ;; Second pass: emit code.
                  _ (regcomp-start expr, re_flags)
                  _ (reset! regcode (:program pat))
                  [win ?] (bt-reg? win, REG_NOPAREN, a'flags)
            ] (and (some? ?) (not @reg_toolong)) => [(if @reg_toolong (do (reset! rc_did_emsg true) (emsg win, (u8 "E339: Pattern too long"))) win) nil]

                ;; Dig out information for optimizations.  ;; Worst-case defaults.
                (let [pat (assoc pat :regstart NUL, :reganch false, :regmust nil, :regmlen 0, :regflags @regflags)
                      pat (if (flag? @a'flags HASNL)     (update pat :regflags | RF_HASNL)  pat)
                      pat (if (flag? @a'flags HASLOOKBH) (update pat :regflags | RF_LOOKBH) pat)
                      #_Bytes scan (.plus (:program pat) 1) ;; First BRANCH.
                      pat (when' (== (re-op (regnext scan)) BT_END) => pat ;; Only one top-level choice.
                            (let [scan (operand scan)
                                  [pat scan] ;; Starting-point info.
                                    (when' (any == (re-op scan) BT_BOL BT_BOF) => [pat scan]
                                        [(assoc pat :reganch true) (regnext scan)])
                                  pat (cond (== (re-op scan) EXACTLY)
                                        (assoc pat :regstart (us-ptr2char (operand scan)))
                                    (and (any == (re-op scan) BT_BOW BT_EOW NOTHING (+ MOPEN 0) NOPEN (+ MCLOSE 0) NCLOSE) (== (re-op (regnext scan)) EXACTLY))
                                        (assoc pat :regstart (us-ptr2char (operand (regnext scan))))
                                    :else
                                        pat
                                    )]
                                ;; If there's something expensive in the r.e., find the longest literal string that must appear and make it the "regmust".
                                ;; Resolve ties in favor of later strings, since the "regstart" check works with the beginning of the r.e. and avoiding
                                ;; duplication strengthens checking.  Not a strong reason, but sufficient in the absence of others.
                                ;; When the r.e. starts with BOW, it is faster to look for a "regmust" first.  Used a lot for "#" and "*" commands.
                                (when' (and (or (flag? @a'flags SPSTART) (any == (re-op scan) BT_BOW BT_EOW)) (non-flag? @a'flags HASNL)) => pat
                                    (let [[#_Bytes longest #_int len]
                                            (loop-when [longest nil len 0 scan scan] (some? scan) => [longest len]
                                                (let [[longest len]
                                                        (when' (and (== (re-op scan) EXACTLY) (<= len (STRLEN (operand scan)))) => [longest len]
                                                            [(operand scan) (STRLEN (operand scan))]
                                                        )]
                                                    (recur longest len (regnext scan)))
                                            )]
                                        (assoc pat :regmust longest :regmlen len))
                                ))
                        )]
                    [win #_pattern_C (assoc pat :regexec bt-regexec?)])
            ))
    ))

;; Setup to parse the regexp.  Used once to get the length and once to do it.

(defn- #_void regcomp-start [#_Bytes expr, #_int re_flags]
    ;; re_flags: see vim-regcomp()
    (init-parse-state expr)
    (reset! reg_magic (if (flag? re_flags RE_MAGIC) MAGIC_ON MAGIC_OFF))
    (reset! reg_string (flag? re_flags RE_STRING))
    (reset! reg_strict (flag? re_flags RE_STRICT))
    (get-cpo-flags)

    (reset! num_complex_braces 0)
    (reset! regnpar 1)
    (swap! had_endbrace #(into (empty %) (map (constantly false) %)))
    (reset! regsize 0)
    (reset! reg_toolong false)
    (reset! regflags 0)
    nil)

;; Parse regular expression, i.e. main body or parenthesized thing.
;;
;; Caller must absorb opening parenthesis.
;;
;; Combining parenthesis handling with the base level of regular expression
;; is a trifle forced, but the need to tie the tails of the branches to what
;; follows makes it hard to avoid.
;;
;; paren: REG_NOPAREN, REG_PAREN or REG_NPAREN

(defn- #_[window_C Bytes] bt-reg? [#_window_C win, #_int paren, #_int' a'fl]
    (reset! a'fl HASWIDTH)                      ;; Tentatively.
    (let-when [[win [#_int parno #_Bytes ret :as _]]
            (condp == paren
                REG_PAREN                       ;; Make a MOPEN node.
                    (if (<= NSUBEXP @regnpar)
                        (let [win (emsg* win, (u8 "E51: Too many %s("), (if (== @reg_magic MAGIC_ALL) (u8 "") (u8 "\\")))]
                            (reset! rc_did_emsg true)
                            [win nil])
                        (let [parno @regnpar]
                            (swap! regnpar inc)
                            [win [parno (regnode (+ MOPEN parno))]]
                        ))
                REG_NPAREN                      ;; Make a NOPEN node.
                    [win [0 (regnode NOPEN)]]
                REG_NOPAREN
                    [win [0 nil]]
            )] (some? _) => [win nil]

        ;; Pick up the branches, linking them together.
        (let-when [a'flags (atom (int)) [win #_Bytes br] (bt-regbranch? win, a'flags)] (some? br) => [win nil]
            ;; [MZ]OPEN -> first.
            (let [ret (if (some? ret) (do (regtail ret, br) ret) br)]
                ;; If one of the branches can be zero-width, the whole thing can.
                ;; If one of the branches has * at start or matches a line-break, the whole thing can.
                (when (non-flag? @a'flags HASWIDTH)
                    (swap! a'fl & (bit-not HASWIDTH)))
                (swap! a'fl | (& @a'flags (| SPSTART HASNL HASLOOKBH)))
                (let-when [[win _]
                        (loop-when win (== (peekchr) (Magic (byte \|))) => [win :_]
                            (skipchr)
                            (let-when [[win #_Bytes br] (bt-regbranch? win, a'flags)] (and (some? br) (not @reg_toolong)) => [win nil]
                                (regtail ret, br)                           ;; BRANCH -> BRANCH.
                                (when (non-flag? @a'flags HASWIDTH)
                                    (swap! a'fl & (bit-not HASWIDTH)))
                                (swap! a'fl | (& @a'flags (| SPSTART HASNL HASLOOKBH)))
                                (recur win))
                        )] (some? _) => [win nil]

                    ;; Make a closing node, and hook it on the end.
                    (let [#_Bytes ender (regnode (condp == paren REG_PAREN (+ MCLOSE parno) REG_NPAREN NCLOSE BT_END))]
                        (regtail ret, ender)
                        ;; Hook the tails of the branches to the closing node.
                        (loop-when-recur [#_Bytes br ret] (some? br) [(regnext br)]
                            (regoptail br, ender))
                        ;; Check for proper termination.
                        (cond (and (!= paren REG_NOPAREN) (!= (getchr) (Magic (byte \)))))
                            (let [win (condp == paren
                                        REG_NPAREN (emsg* win, e_unmatchedpp, (if (== @reg_magic MAGIC_ALL) (u8 "") (u8 "\\")))
                                        REG_PAREN  (emsg* win, e_unmatchedp,  (if (== @reg_magic MAGIC_ALL) (u8 "") (u8 "\\")))
                                    )]
                                (reset! rc_did_emsg true)
                                [win nil])
                        (and (== paren REG_NOPAREN) (!= (peekchr) NUL))     ;; "Can't happen".
                            (let [win (if (== @curchr (Magic (byte \))))
                                        (emsg* win, e_unmatchedpar, (if (== @reg_magic MAGIC_ALL) (u8 "") (u8 "\\")))
                                        (emsg win, e_trailing)
                                    )]
                                (reset! rc_did_emsg true)
                                [win nil])
                        :else ;; Here we set the flag allowing back references to this set of parentheses.
                            (do (when (== paren REG_PAREN)
                                    (swap! had_endbrace assoc parno true))  ;; have seen the close paren
                                [win ret]
                            ))
                    ))
            ))
    ))

;; Parse one alternative of an | operator.
;; Implements the & operator.

(defn- #_[window_C Bytes] bt-regbranch? [#_window_C win, #_int' a'fl]
    (reset! a'fl (| WORST HASNL)) ;; Tentatively.
    (let [#_Bytes ret (regnode BRANCH)]
        (loop [win win #_Bytes chain nil]
            (let-when [a'flags (atom (int)) [win #_Bytes latest] (bt-regconcat? win, a'flags)] (some? latest) => [win nil]
                ;; If one of the branches has width, the whole thing has.
                ;; If one of the branches anchors at start-of-line, the whole thing does.
                ;; If one of the branches uses look-behind, the whole thing does.
                (swap! a'fl | (& @a'flags (| HASWIDTH SPSTART HASLOOKBH)))
                ;; If one of the branches doesn't match a line-break, the whole thing doesn't.
                (swap! a'fl & (| (bit-not HASNL) (& @a'flags HASNL)))
                (when (some? chain)
                    (regtail chain, latest))
                (when' (== (peekchr) (Magic (byte \&))) => [win ret]
                    (skipchr)
                    (regtail latest, (regnode BT_END)) ;; operand ends
                    (when' (not @reg_toolong) => [win ret]
                        (reginsert MATCH, latest)
                        (recur win latest)
                    ))
            ))
    ))

;; Parse one alternative of an | or & operator.
;; Implements the concatenation operator.

(defn- #_[window_C Bytes] bt-regconcat? [#_window_C win, #_int' a'fl]
    (reset! a'fl WORST) ;; Tentatively.
    (let-when [[win [#_Bytes first :as _]]
            (loop [win win first nil #_Bytes chain nil]
                (condp ==? (peekchr)
                   [NUL (Magic (byte \|)) (Magic (byte \&)) (Magic (byte \)))]                                  [win [first]]

                    (Magic (byte \Z)) (do (swap! regflags | RF_ICOMBINE) (skipchr-keepstart)                    (recur win first chain))
                    (Magic (byte \c)) (do (swap! regflags | RF_ICASE)    (skipchr-keepstart)                    (recur win first chain))
                    (Magic (byte \C)) (do (swap! regflags | RF_NOICASE)  (skipchr-keepstart)                    (recur win first chain))

                    (Magic (byte \v)) (do (reset! reg_magic MAGIC_ALL)   (skipchr-keepstart) (reset! curchr -1) (recur win first chain))
                    (Magic (byte \m)) (do (reset! reg_magic MAGIC_ON)    (skipchr-keepstart) (reset! curchr -1) (recur win first chain))
                    (Magic (byte \M)) (do (reset! reg_magic MAGIC_OFF)   (skipchr-keepstart) (reset! curchr -1) (recur win first chain))
                    (Magic (byte \V)) (do (reset! reg_magic MAGIC_NONE)  (skipchr-keepstart) (reset! curchr -1) (recur win first chain))

                    (let-when [a'flags (atom (int)) [win #_Bytes latest] (bt-regpiece? win, a'flags)] (and (some? latest) (not @reg_toolong)) => [win nil]
                        (swap! a'fl | (& @a'flags (| HASWIDTH HASNL HASLOOKBH)))
                        (if (nil? chain) ;; First piece.
                            (swap! a'fl | (& @a'flags SPSTART))
                            (regtail chain, latest))
                        (recur win (if (some? first) first latest) latest)
                    ))
            )] (some? _) => [win nil]

        ;; Loop ran zero times.
        [win (if (some? first) first (regnode NOTHING))]
    ))

;; Parse something followed by possible [*+=].
;;
;; Note that the branching code sequences used for = and the general cases
;; of * and + are somewhat optimized:  they use the same NOTHING node as
;; both the endmarker for their branch list and the body of the last branch.
;; It might seem that this node could be dispensed with entirely, but the
;; endmarker role is not redundant.

(defn- #_[window_C Bytes] bt-regpiece? [#_window_C win, #_int' a'fl]
    (let-when [a'flags (atom (int)) [win #_Bytes ret] (bt-regatom? win, a'flags)] (some? ret) => [win nil]
        (let [#_int op (peekchr)]
            (cond (== (re-multi-type op) NOT_MULTI)
                (do (reset! a'fl @a'flags) [win ret])
            :else
                (do (reset! a'fl (| WORST SPSTART (& @a'flags (| HASNL HASLOOKBH)))) ;; default flags
                    (skipchr)
                    (let-when [[win _]
                            (condp ==? op
                                (Magic (byte \*))
                                    (do (if (flag? @a'flags SIMPLE)
                                            (reginsert STAR, ret)
                                            (do ;; Emit x* as (x&|), where & means "self".
                                                (reginsert BRANCH, ret)             ;; Either x
                                                (regoptail ret, (regnode BACK))     ;; and loop
                                                (regoptail ret, ret)                ;; back
                                                (regtail ret, (regnode BRANCH))     ;; or
                                                (regtail ret, (regnode NOTHING))    ;; null.
                                            ))
                                        [win :_])

                                (Magic (byte \+))
                                    (do (if (flag? @a'flags SIMPLE)
                                            (reginsert PLUS, ret)
                                            ;; Emit x+ as x(&|), where & means "self".
                                            (let [#_Bytes next (regnode BRANCH)]    ;; Either
                                                (regtail ret, next)
                                                (regtail (regnode BACK), ret)       ;; loop back
                                                (regtail next, (regnode BRANCH))    ;; or
                                                (regtail ret, (regnode NOTHING))    ;; null.
                                            ))
                                        (reset! a'fl (| WORST HASWIDTH (& @a'flags (| HASNL HASLOOKBH))))
                                        [win :_])

                                (Magic (byte \@))
                                    (let [#_int nr (getdecchrs)
                                          #_int lop (condp == (no-Magic (getchr))
                                                (byte \=) MATCH                     ;; \@=
                                                (byte \!) NOMATCH                   ;; \@!
                                                (byte \>) SUBPAT                    ;; \@>
                                                (byte \<)
                                                    (condp == (no-Magic (getchr))
                                                        (byte \=) BEHIND            ;; \@<=
                                                        (byte \!) NOBEHIND          ;; \@<!
                                                        BT_END)
                                                BT_END)]
                                        (if (== lop BT_END)
                                            (let [win (emsg* win, (u8 "E59: invalid character after %s@"), (if (== @reg_magic MAGIC_ALL) (u8 "") (u8 "\\")))]
                                                (reset! rc_did_emsg true)
                                                [win nil])
                                            (do ;; Look behind must match with "behind_pos".
                                                (when (any == lop BEHIND NOBEHIND)
                                                    (regtail ret, (regnode BHPOS))
                                                    (swap! a'fl | HASLOOKBH))
                                                (regtail ret, (regnode BT_END))             ;; operand ends
                                                (if (any == lop BEHIND NOBEHIND)
                                                    (reginsert-nr lop, (max 0 nr), ret)     ;; no limit is same as zero limit
                                                    (reginsert lop, ret))
                                                [win :_])
                                        ))

                               [(Magic (byte \?)) (Magic (byte \=))]
                                    (do ;; Emit x= as (x|).
                                        (reginsert BRANCH, ret)                     ;; Either x
                                        (regtail ret, (regnode BRANCH))             ;; or
                                        (let [#_Bytes next (regnode NOTHING)]       ;; null.
                                            (regtail ret, next)
                                            (regoptail ret, next))
                                        [win :_])

                                (Magic (byte \{))
                                    (let-when [a'minval (atom (long)) a'maxval (atom (long)) [win ?] (read-limits? win, a'minval, a'maxval)] ? => [win nil]
                                        (cond (flag? @a'flags SIMPLE)
                                            (do
                                                (reginsert BRACE_SIMPLE, ret)
                                                (reginsert-limits BRACE_LIMITS, @a'minval, @a'maxval, ret)
                                                (when (and (< 0 @a'minval) (< 0 @a'maxval))
                                                    (reset! a'fl (| HASWIDTH (& @a'flags (| HASNL HASLOOKBH)))))
                                                [win :_])
                                        (< @num_complex_braces 10)
                                            (do
                                                (reginsert (+ BRACE_COMPLEX @num_complex_braces), ret)
                                                (regoptail ret, (regnode BACK))
                                                (regoptail ret, ret)
                                                (reginsert-limits BRACE_LIMITS, @a'minval, @a'maxval, ret)
                                                (swap! num_complex_braces inc)
                                                (when (and (< 0 @a'minval) (< 0 @a'maxval))
                                                    (reset! a'fl (| HASWIDTH (& @a'flags (| HASNL HASLOOKBH)))))
                                                [win :_])
                                        :else
                                            (let [win (emsg* win, (u8 "E60: Too many complex %s{...}s"), (if (== @reg_magic MAGIC_ALL) (u8 "") (u8 "\\")))]
                                                (reset! rc_did_emsg true)
                                                [win nil])
                                        ))
                            )] (some? _) => [win nil]

                        (when' (!= (re-multi-type (peekchr)) NOT_MULTI) => [win ret]
                            ;; Can't have a multi follow a multi.
                            (let [win (if (== (peekchr) (Magic (byte \*)))
                                        (emsg* win, (u8 "E61: Nested %s*"), (if (<= MAGIC_ON @reg_magic) (u8 "") (u8 "\\")))
                                        (emsg* win, (u8 "E62: Nested %s%c"), (if (== @reg_magic MAGIC_ALL) (u8 "") (u8 "\\")), (no-Magic (peekchr)))
                                    )]
                                (reset! rc_did_emsg true)
                                [win nil]
                            ))
                    ))
            ))
    ))

;; When making changes to "classchars" also change "nfa_classcodes".
(final Bytes classchars (u8 ".iIkKfFpPsSdDxXoOwWhHaAlLuU"))
(final int* classcodes
    [
        ANY,
        IDENT, SIDENT,
        KWORD, SKWORD,
        FNAME, SFNAME,
        PRINT, SPRINT,
        WHITE, NWHITE,
        DIGIT, NDIGIT,
        HEX,   NHEX,
        OCTAL, NOCTAL,
        WORD,  NWORD,
        HEAD,  NHEAD,
        ALPHA, NALPHA,
        LOWER, NLOWER,
        UPPER, NUPPER
    ])

(defn- #_[window_C Bytes] regcoll- [#_window_C win, #_int c, #_int extra, #_int' a'fl]
    ;; If there is no matching ']', we assume the '[' is a normal character.
    ;; This makes 'incsearch' and ":help [" work.
    (let [#_Bytes lp (skip-anyof @regparse)]
        (cond (at? lp (byte \])) ;; there is a matching ']'
            ;; In a character class, different parsing rules apply.
            ;; Not even \ is special anymore, nothing is.
            (let-when [#_Bytes ret ;; Complement of range.
                    (if (at? @regparse (byte \^)) (let [ret (regnode (+ ANYBUT extra))] (swap! regparse plus 1) ret) (regnode (+ ANYOF extra)))
                  ;; At the start ']' and '-' mean the literal character.
                  #_int startc ;; > 0 when next '-' is a range
                    (let [startc (.at @regparse 0)] (if (any == startc (byte \]) (byte \-)) (do (regc startc) (swap! regparse plus 1) startc) -1))
                  [win _]
                    (loop-when startc (and (non-eos? @regparse) (not-at? @regparse (byte \]))) => [win :_]
                        (cond (at? @regparse (byte \-))
                            (do (swap! regparse plus 1)
                                ;; The '-' is not used for a range at the end and after or before a '\n'.
                                (if (or (at? @regparse (byte \])) (eos? @regparse) (== startc -1) (and (at? @regparse (byte \\)) (at? @regparse 1 (byte \n))))
                                    ;; [--x] is a range
                                    (let [startc (byte \-)] (regc startc) (recur startc))
                                    ;; also accept "a-[.z.]"
                                    (let [#_int endc (if (at? @regparse (byte \[)) (get-coll-element regparse) 0)
                                          endc (if (zero? endc) (us-ptr2char-adv regparse, true) endc)
                                          ;; Handle \o40, \x20 and \u20AC style sequences.
                                          endc (if (and (== endc (byte \\)) (not @reg_cpo_lit) (not @reg_cpo_bsl)) (coll-get-char) endc)]
                                        (cond (< endc startc)
                                            (let [win (emsg win, e_invrange)]
                                                (reset! rc_did_emsg true)
                                                [win nil])
                                        (or (< 1 (utf-char2len startc)) (< 1 (utf-char2len endc)))
                                            ;; Limit to a range of 256 chars.
                                            (if (< (+ startc 256) endc)
                                                (let [win (emsg win, e_invrange)]
                                                    (reset! rc_did_emsg true)
                                                    [win nil])
                                                (do (loop-when [startc (inc startc)] (<= startc endc) (regmbc startc) (recur (inc startc)))
                                                    (recur -1)
                                                ))
                                        :else
                                            (do (loop-when [startc (inc startc)] (<= startc endc) (regc startc) (recur (inc startc)))
                                                (recur -1))
                                        ))
                                ))
                        ;; Only "\]", "\^", "\]" and "\\" are special in Vi.
                        ;; Vim accepts "\t", "\e", etc., but only when the 'l' flag in 'cpoptions' is not included.
                        ;; Posix doesn't recognize backslash at all.
                        (and (at? @regparse (byte \\))
                             (not @reg_cpo_bsl)
                             (or (some? (vim-strchr REGEXP_INRANGE, (.at @regparse 1))) (and (not @reg_cpo_lit) (some? (vim-strchr REGEXP_ABBR, (.at @regparse 1))))))
                            (do (swap! regparse plus 1)
                                (cond (at? @regparse (byte \n))
                                    (do ;; '\n' in range: also match NL
                                        (when (!= ret JUST_CALC_SIZE)
                                            ;; Using \n inside [^] does not change what matches.  "[^\n]" is the same as ".".
                                            (when (at? ret ANYOF)
                                                (.be ret 0, (+ ANYOF ADD_NL))
                                                (swap! a'fl | HASNL)
                                            )) ;; else: must have had a \n already
                                        (swap! regparse plus 1)
                                        (recur -1))
                                (or (at? @regparse (byte \d)) (at? @regparse (byte \o)) (at? @regparse (byte \x)) (at? @regparse (byte \u)) (at? @regparse (byte \U)))
                                    (let [startc (coll-get-char)]
                                        (if (zero? startc) (regc 0x0a) (regmbc startc))
                                        (recur startc))
                                :else
                                    (let [startc (backslash-trans (.at (swap! regparse plus 1) -1))]
                                        (regc startc)
                                        (recur startc))
                                ))
                        (at? @regparse (byte \[))
                            (let [#_int c_class (get-char-class regparse) a'startc (atom -1)]
                                ;; Characters assumed to be 8 bits!
                                (condp == c_class
                                    CLASS_NONE
                                        (let-when [c_class (get-equi-class regparse)] (zero? c_class) => (reg-equi-class c_class) ;; produce equivalence class
                                            (let-when [c_class (get-coll-element regparse)] (zero? c_class) => (regmbc c_class)   ;; produce a collating element
                                                (regc (reset! a'startc (.at (swap! regparse plus 1) -1)))                         ;; literal '[', allow [[-x] as a range
                                            ))
                                    CLASS_ALNUM     (loop-when-recur [#_int cu 1] (<= cu 255) [(inc cu)] (when (asc-isalnum cu)  (regc cu)))
                                    CLASS_ALPHA     (loop-when-recur [#_int cu 1] (<= cu 255) [(inc cu)] (when (asc-isalpha cu)  (regc cu)))
                                    CLASS_BLANK (do (regc (byte \space)) (regc TAB))
                                    CLASS_CNTRL     (loop-when-recur [#_int cu 1] (<= cu 255) [(inc cu)] (when (asc-iscntrl cu)  (regc cu)))
                                    CLASS_DIGIT     (loop-when-recur [#_int cu 1] (<= cu 255) [(inc cu)] (when (asc-isdigit cu)  (regc cu)))
                                    CLASS_GRAPH     (loop-when-recur [#_int cu 1] (<= cu 255) [(inc cu)] (when (asc-isgraph cu)  (regc cu)))
                                    CLASS_LOWER     (loop-when-recur [#_int cu 1] (<= cu 255) [(inc cu)] (when (utf-islower cu)  (regc cu)))
                                    CLASS_PRINT     (loop-when-recur [#_int cu 1] (<= cu 255) [(inc cu)] (when (vim-isprintc cu) (regc cu)))
                                    CLASS_PUNCT     (loop-when-recur [#_int cu 1] (<= cu 255) [(inc cu)] (when (asc-ispunct cu)  (regc cu)))
                                    CLASS_SPACE (do (loop-when-recur [#_int cu 9] (<= cu  13) [(inc cu)]                         (regc cu)) (regc (byte \space)))
                                    CLASS_UPPER     (loop-when-recur [#_int cu 1] (<= cu 255) [(inc cu)] (when (utf-isupper cu)  (regc cu)))
                                    CLASS_XDIGIT    (loop-when-recur [#_int cu 1] (<= cu 255) [(inc cu)] (when (asc-isxdigit cu) (regc cu)))
                                    CLASS_TAB       (regc TAB)
                                    CLASS_RETURN    (regc (byte \return))
                                    CLASS_BACKSPACE (regc (byte \backspace))
                                    CLASS_ESCAPE    (regc ESC)
                                )
                                (recur @a'startc)
                            )
                        :else
                            ;; produce a multibyte character including any following composing characters
                            (let [startc (us-ptr2char @regparse) #_int n (us-ptr2len-cc @regparse)
                                  startc (if (!= (utf-char2len startc) n) -1 startc)] ;; composing chars
                                (loop-when-recur n (< 0 n) (dec n) (regc (.at (swap! regparse plus 1) -1)))
                                (recur startc)
                            ))
                    )] (some? _) => [win nil]

                (regc NUL)
                (reset! prevchr_len 1)                  ;; last char was the ']'
                (if (not-at? @regparse (byte \]))
                    (let [win (emsg win, e_toomsbra)]
                        (reset! rc_did_emsg true)
                        [win nil])                      ;; Cannot happen?
                    (do (skipchr)                       ;; let's be friends with the lexer again
                        (swap! a'fl | HASWIDTH SIMPLE)
                        [win ret])
                ))
        @reg_strict
            (let [win (emsg* win, e_missingbracket, (if (< MAGIC_OFF @reg_magic) (u8 "") (u8 "\\")))]
                (reset! rc_did_emsg true)
                [win nil])
        :else
            [win (do-multibyte c, a'fl)])
    ))

(defn- #_[window_C Bytes] regclass- [#_window_C win, #_int c, #_int extra, #_int' a'fl]
    (let [#_Bytes s (vim-strchr classchars, (no-Magic c))]
        (cond (nil? s)
            (let [win (emsg win, (u8 "E63: invalid use of \\_"))]
                (reset! rc_did_emsg true)
                [win nil])
        ;; When '.' is followed by a composing char ignore the dot,
        ;; so that the composing char is matched here.
        (and (== c (Magic (byte \.))) (utf-iscomposing (peekchr)))
            (let [c (getchr) #_Bytes ret (regnode MULTIBYTECODE)]
                (regmbc c)
                (swap! a'fl | HASWIDTH SIMPLE)
                [win ret])
        :else
            (let [#_Bytes ret (regnode (+ (... classcodes (BDIFF s, classchars)) extra))]
                (swap! a'fl | HASWIDTH SIMPLE)
                [win ret]
            ))
    ))

;; Parse the lowest level.
;;
;; Optimization: gobbles an entire sequence of ordinary characters so
;; it can turn them into a single node, which is smaller to store and
;; faster to run.  Don't do this when "one_exactly" is set.

(defn- #_[window_C Bytes] bt-regatom? [#_window_C win, #_int' a'fl]
    (reset! a'fl WORST) ;; Tentatively.
    (let [#_int c (getchr)]
        (condp ==? c
            (Magic (byte \^)) [win (regnode BT_BOL)]
            (Magic (byte \$)) [win (regnode BT_EOL)]
            (Magic (byte \<)) [win (regnode BT_BOW)]
            (Magic (byte \>)) [win (regnode BT_EOW)]

            (Magic (byte \_))
                (let [c (no-Magic (getchr))]
                    (condp == c
                        (byte \^) [win (regnode BT_BOL)]        ;; "\_^" is start-of-line
                        (byte \$) [win (regnode BT_EOL)]        ;; "\_$" is end-of-line
                        (let [#_int extra ADD_NL]
                            (swap! a'fl | HASNL)
                            (if (== c (byte \[))
                                (regcoll- win, c, extra, a'fl)  ;; "\_[" is character range plus newline
                                (regclass- win, c, extra, a'fl) ;; "\_x" is character class plus newline
                            ))
                    ))

           [(Magic (byte \.))                   ;; Character classes.
            (Magic (byte \i)) (Magic (byte \I))
            (Magic (byte \k)) (Magic (byte \K))
            (Magic (byte \f)) (Magic (byte \F))
            (Magic (byte \p)) (Magic (byte \P))
            (Magic (byte \s)) (Magic (byte \S))
            (Magic (byte \d)) (Magic (byte \D))
            (Magic (byte \x)) (Magic (byte \X))
            (Magic (byte \o)) (Magic (byte \O))
            (Magic (byte \w)) (Magic (byte \W))
            (Magic (byte \h)) (Magic (byte \H))
            (Magic (byte \a)) (Magic (byte \A))
            (Magic (byte \l)) (Magic (byte \L))
            (Magic (byte \u)) (Magic (byte \U))] (regclass- win, c, 0, a'fl)

            (Magic (byte \n))
                (if @reg_string
                    ;; In a string, "\n" matches a newline character.
                    (let [#_Bytes ret (regnode EXACTLY)] (regc NL) (regc NUL) (swap! a'fl | HASWIDTH SIMPLE) [win ret])
                    ;; In buffer text, "\n" matches the end of a line.
                    (let [#_Bytes ret (regnode BT_NEWL)] (swap! a'fl | HASWIDTH HASNL) [win ret]))

            (Magic (byte \())
                (if @one_exactly
                    (let [win (emsg* win, (u8 "E369: invalid item in %s%%[]"), (if (== @reg_magic MAGIC_ALL) (u8 "") (u8 "\\")))]
                        (reset! rc_did_emsg true)
                        [win nil])
                    (let [a'flags (atom (int)) [win #_Bytes ret] (bt-reg? win, REG_PAREN, a'flags)]
                        [win (when (some? ret) (do (swap! a'fl | (& @a'flags (| HASWIDTH SPSTART HASNL HASLOOKBH))) ret))]
                    ))

           [NUL (Magic (byte \|)) (Magic (byte \&)) (Magic (byte \)))]
                (let [win (if @one_exactly
                            (emsg* win, (u8 "E369: invalid item in %s%%[]"), (if (== @reg_magic MAGIC_ALL) (u8 "") (u8 "\\")))
                            (emsg win, e_internal) ;; supposed to be caught earlier
                        )]
                    (reset! rc_did_emsg true)
                    [win nil])

           [(Magic (byte \=)) (Magic (byte \?)) (Magic (byte \+)) (Magic (byte \@)) (Magic (byte \{)) (Magic (byte \*))]
                (let [c (no-Magic c)
                      win (emsg* win, (u8 "E64: %s%c follows nothing"), (if (if (== c (byte \*)) (<= MAGIC_ON @reg_magic) (== @reg_magic MAGIC_ALL)) (u8 "") (u8 "\\")), c)]
                    (reset! rc_did_emsg true)
                    [win nil])

            (Magic (byte \~)) ;; previous substitute pattern
                (if (some? @reg_prev_sub)
                    (let [#_Bytes ret (regnode EXACTLY)
                          #_Bytes s (loop-when-recur [s @reg_prev_sub] (non-eos? s) [(.plus s 1)] => s
                                (regc (.at s 0))
                            )]
                        (regc NUL)
                        (when (non-eos? @reg_prev_sub)
                            (swap! a'fl | HASWIDTH)
                            (when (== (BDIFF s, @reg_prev_sub) 1)
                                (swap! a'fl | SIMPLE)))
                        [win ret])
                    (let [win (emsg win, e_nopresub)]
                        (reset! rc_did_emsg true)
                        [win nil]))

           [(Magic (byte \1)) (Magic (byte \2)) (Magic (byte \3)) (Magic (byte \4)) (Magic (byte \5)) (Magic (byte \6)) (Magic (byte \7)) (Magic (byte \8)) (Magic (byte \9))]
                (let [#_int refnum (- c (Magic (byte \0)))]
                    ;; Check if the back reference is legal.  We must have seen the close brace.
                    ;; TODO:  Should also check that we don't refer to something that is repeated (+*=):
                    ;; what instance of the repetition should we match?
                    (if (... @had_endbrace refnum)
                        [win (regnode (+ BACKREF refnum))]
                        ;; Trick: check if "@<=" or "@<!" follows, in which case the \1 can appear before the referenced match.
                        (let [#_Bytes p (loop-when [p @regparse] (non-eos? p) => p
                                    (recur-if (not (and (at? p (byte \@)) (at? p 1 (byte \<)) (or (at? p 2 (byte \!)) (at? p 2 (byte \=))))) [(.plus p 1)] => p)
                                )]
                            (if (eos? p)
                                (let [win (emsg win, (u8 "E65: Illegal back reference"))]
                                    (reset! rc_did_emsg true)
                                    [win nil])
                                [win (regnode (+ BACKREF refnum))]
                            ))
                    ))

            (Magic (byte \z))
                (let [c (no-Magic (getchr))]
                    (condp ==? c
                        (byte \()
                            (let [win (emsg win, e_z_not_allowed)]
                                (reset! rc_did_emsg true)
                                [win nil])

                       [(byte \1) (byte \2) (byte \3) (byte \4) (byte \5) (byte \6) (byte \7) (byte \8) (byte \9)]
                            (let [win (emsg win, e_z1_not_allowed)]
                                (reset! rc_did_emsg true)
                                [win nil])

                        (byte \s) (let [#_Bytes ret (regnode (+ MOPEN 0))  [win ?] (re-mult-next? win, (u8 "\\zs"))] [win (when ? ret)])
                        (byte \e) (let [#_Bytes ret (regnode (+ MCLOSE 0)) [win ?] (re-mult-next? win, (u8 "\\ze"))] [win (when ? ret)])

                        (let [win (emsg win, (u8 "E68: Invalid character after \\z"))]
                            (reset! rc_did_emsg true)
                            [win nil])
                    ))

            (Magic (byte \%))
                (let [c (no-Magic (getchr))]
                    (condp ==? c
                        (byte \() ;; () without a back reference
                            (if @one_exactly
                                (let [win (emsg* win, (u8 "E369: invalid item in %s%%[]"), (if (== @reg_magic MAGIC_ALL) (u8 "") (u8 "\\")))]
                                    (reset! rc_did_emsg true)
                                    [win nil])
                                (let [a'flags (atom (int)) [win #_Bytes ret] (bt-reg? win, REG_NPAREN, a'flags)]
                                    [win (when (some? ret) (do (swap! a'fl | (& @a'flags (| HASWIDTH SPSTART HASNL HASLOOKBH))) ret))]
                                ))

                        ;; Catch \%^ and \%$ regardless of where they appear in the pattern -- regardless of whether or not it makes sense.
                        (byte \^) [win (regnode BT_BOF)]
                        (byte \$) [win (regnode BT_EOF)]
                        (byte \#) [win (regnode BT_CURSOR)]
                        (byte \V) [win (regnode BT_VISUAL)]
                        (byte \C) [win (regnode BT_COMPOSING)]

                        ;; \%[abc]: Emit as a list of branches, all ending at the last branch which matches nothing.
                        (byte \[)
                            (if @one_exactly        ;; doesn't nest
                                (let [win (emsg* win, (u8 "E369: invalid item in %s%%[]"), (if (== @reg_magic MAGIC_ALL) (u8 "") (u8 "\\")))]
                                    (reset! rc_did_emsg true)
                                    [win nil])
                                (let-when [[win [#_Bytes lastnode #_Bytes ret :as _]]
                                        (loop-when [win win lastnode nil ret nil c (getchr)] (!= c (byte \])) => [win [lastnode ret]]
                                            (if (== c NUL)
                                                (let [win (emsg* win, e_missing_sb, (if (== @reg_magic MAGIC_ALL) (u8 "") (u8 "\\")))]
                                                    (reset! rc_did_emsg true)
                                                    [win nil])
                                                (let [#_Bytes br (regnode BRANCH) ret (if (nil? ret) br (do (regtail lastnode, br) ret))]
                                                    (ungetchr)
                                                    (let [_ (reset! one_exactly true) [win lastnode] (bt-regatom? win, a'fl) _ (reset! one_exactly false)]
                                                        (recur-if (some? lastnode) [win lastnode ret (getchr)] => [win nil])
                                                    ))
                                            ))] (some? _) => [win nil]

                                    (if (nil? ret)
                                        (let [win (emsg* win, e_empty_sb, (if (== @reg_magic MAGIC_ALL) (u8 "") (u8 "\\")))]
                                            (reset! rc_did_emsg true)
                                            [win nil])
                                        (let [#_Bytes lastbranch (regnode BRANCH) #_Bytes br (regnode NOTHING)]
                                            (when (!= ret JUST_CALC_SIZE)
                                                (regtail lastnode, br)
                                                (regtail lastbranch, br)
                                                ;; connect all branches to the NOTHING branch at the end
                                                (loop-when [br ret] (BNE br, lastnode)
                                                    (recur (if (== (re-op br) BRANCH) (do (regtail br, lastbranch) (operand br)) (regnext br)))
                                                ))
                                            (swap! a'fl & (bit-not (| HASWIDTH SIMPLE)))
                                            [win ret]
                                        ))
                                ))

                       [(byte \d)   ;; %d123 decimal
                        (byte \o)   ;; %o123 octal
                        (byte \x)   ;; %xab hex 2
                        (byte \u)   ;; %uabcd hex 4
                        (byte \U)]  ;; %U1234abcd hex 8
                            (let [#_int i (condp == c
                                        (byte \d) (getdecchrs)
                                        (byte \o) (getoctchrs)
                                        (byte \x) (gethexchrs 2)
                                        (byte \u) (gethexchrs 4)
                                        (byte \U) (gethexchrs 8)
                                    -1)]
                                (if (< i 0)
                                    (let [win (emsg* win, (u8 "E678: Invalid character after %s%%[dxouU]"), (if (== @reg_magic MAGIC_ALL) (u8 "") (u8 "\\")))]
                                        (reset! rc_did_emsg true)
                                        [win nil])
                                    (let [#_Bytes ret (regnode (if (use-multibytecode i) MULTIBYTECODE EXACTLY))]
                                        (if (zero? i) (regc 0x0a) (regmbc i))
                                        (regc NUL)
                                        (swap! a'fl | HASWIDTH)
                                        [win ret])
                                ))

                        (let-when [[ret :as _]
                                (when (or (asc-isdigit c) (== c (byte \<)) (== c (byte \>)) (== c (byte \')))
                                    (let [#_int cmp c c (if (any == cmp (byte \<) (byte \>)) (getchr) c)
                                          [#_long n c] (loop-when-recur [n 0 c c] (asc-isdigit c) [(+ (* n 10) (- c (byte \0))) (getchr)] => [n c])]
                                        (cond (and (== c (byte \')) (zero? n))
                                            (let [c (getchr) #_Bytes ret (regnode BT_MARK)] ;; "\%'m", "\%<'m" and "\%>'m": Mark
                                                (if (== ret JUST_CALC_SIZE)
                                                    (swap! regsize + 2)
                                                    (do
                                                        (-> @regcode (.be 0, c) (.be 1, cmp))
                                                        (swap! regcode plus 2)
                                                    ))
                                                [ret])
                                        (any == c (byte \l) (byte \c) (byte \v))
                                            (let [#_Bytes ret (regnode (cond (== c (byte \l)) BT_LNUM (== c (byte \c)) BT_COL :else BT_VCOL))]
                                                (if (== ret JUST_CALC_SIZE)
                                                    (swap! regsize + 5)
                                                    (do ;; put the number and the optional comparator after the opcode
                                                        (swap! regcode re-put-long n)
                                                        (.be @regcode 0, cmp)
                                                        (swap! regcode plus 1)
                                                    ))
                                                [ret])
                                        ))
                                )] (nil? _) => [win ret]

                            (let [win (emsg* win, (u8 "E71: Invalid character after %s%%"), (if (== @reg_magic MAGIC_ALL) (u8 "") (u8 "\\")))]
                                (reset! rc_did_emsg true)
                                [win nil]
                            ))
                    ))

            (Magic (byte \[)) (regcoll- win, c, 0, a'fl)

            [win (do-multibyte c, a'fl)])
    ))

(defn- #_final #_Bytes do-multibyte [#_int c, #_int' a'fl]
    ;; A multi-byte character is handled as a separate atom if it's before a multi and when it's a composing char.
    (if (use-multibytecode c)
        (let [#_Bytes s (regnode MULTIBYTECODE)]
            (regmbc c)
            (swap! a'fl | HASWIDTH SIMPLE)
        s)
        (let [#_Bytes s (regnode EXACTLY)
              ;; Append characters as long as:
              ;; - there is no following multi, we then need the character in front of it as a single character operand;
              ;; - not running into a Magic character;
              ;; - "one_exactly" is not set.
              ;; But always emit at least one character.  Might be a Multi, e.g. a "[" without matching "]".
              #_int n
                (loop-when-recur [c c n 0]
                                 (and (!= c NUL) (or (== n 0) (and (== (re-multi-type (peekchr)) NOT_MULTI) (not @one_exactly) (not (is-Magic c)))))
                                 [(getchr) (inc n)]
                              => n
                    (regmbc (no-Magic c))
                    ;; Need to get composing character too.
                    (while (utf-iscomposing (us-ptr2char @regparse, (us-ptr2len @regparse)))
                        (regmbc (us-ptr2char @regparse))
                        (skipchr))
                )]
            (ungetchr)
            (regc NUL)
            (swap! a'fl | HASWIDTH)
            (when (== n 1) (swap! a'fl | SIMPLE))
        s)
    ))

;; Return true if MULTIBYTECODE should be used instead of EXACTLY for character "c".

(defn- #_boolean use-multibytecode [#_int c]
    (and (< 1 (utf-char2len c)) (or (!= (re-multi-type (peekchr)) NOT_MULTI) (utf-iscomposing c))))

;; Emit a node.
;; Return pointer to generated code.

(defn- #_Bytes regnode [#_int op]
    (let [#_Bytes ret @regcode]
        (if (== ret JUST_CALC_SIZE)
            (swap! regsize + 3)
            (-> (swap! regcode plus 3) (.be -3, op) (eos! -2) (eos! -1))) ;; Null "next" pointer.
        ret
    ))

;; Emit (if appropriate) a byte of code.

(defn- #_void regc [#_int b]
    (if (== @regcode JUST_CALC_SIZE)
        (swap! regsize inc)
        (.be (swap! regcode plus 1) -1, b))
    nil)

;; Emit (if appropriate) a multi-byte character of code.

(defn- #_void regmbc [#_int c]
    (if (== @regcode JUST_CALC_SIZE)
        (swap! regsize + (utf-char2len c))
        (swap! regcode #(.plus % (utf-char2bytes c, %))))
    nil)

;; Insert an operator in front of already-emitted operand.
;;
;; Means relocating the operand.

(defn- #_void reginsert [#_int op, #_Bytes opnd]
    (if (== @regcode JUST_CALC_SIZE)
        (swap! regsize + 3)
        (do
            (loop-when-recur [src @regcode dst (swap! regcode plus 3)] (BLT opnd, src) [(.minus src 1) (.minus dst 1)]
                (.be dst -1, (.at src -1)))
            ;; Op node, where operand used to be.
            (-> opnd (.be 0, op) (eos! 1) (eos! 2))
        ))
    nil)

;; Insert an operator in front of already-emitted operand.
;; Add a number to the operator.

(defn- #_void reginsert-nr [#_int op, #_long val, #_Bytes opnd]
    (if (== @regcode JUST_CALC_SIZE)
        (swap! regsize + 7)
        (do
            (loop-when-recur [src @regcode dst (swap! regcode plus 7)] (BLT opnd, src) [(.minus src 1) (.minus dst 1)]
                (.be dst -1, (.at src -1)))
            ;; Op node, where operand used to be.
            (-> opnd (.be 0, op) (eos! 1) (eos! 2))
            (re-put-long (.plus opnd 3), val)
        ))
    nil)

;; Insert an operator in front of already-emitted operand.
;; The operator has the given limit values as operands.
;; Also set next pointer.
;;
;; Means relocating the operand.

(defn- #_void reginsert-limits [#_int op, #_long minval, #_long maxval, #_Bytes opnd]
    (if (== @regcode JUST_CALC_SIZE)
        (swap! regsize + 11)
        (do
            (loop-when-recur [src @regcode dst (swap! regcode plus 11)] (BLT opnd, src) [(.minus src 1) (.minus dst 1)]
                (.be dst -1, (.at src -1)))
            ;; Op node, where operand used to be.
            (-> opnd (.be 0, op) (eos! 1) (eos! 2))
            (regtail opnd, (-> (.plus opnd 3) (re-put-long minval) (re-put-long maxval)))
        ))
    nil)

;; Write a long as four bytes at "p" and return pointer to the next char.

(defn- #_Bytes re-put-long [#_Bytes p, #_long val]
    (.be p 0, (byte (& (>>> val 24) 0xff)))
    (.be p 1, (byte (& (>>> val 16) 0xff)))
    (.be p 2, (byte (& (>>> val  8) 0xff)))
    (.be p 3, (byte (&      val     0xff)))
    (.plus p 4))

;; Set the next-pointer at the end of a node chain.

(defn- #_void regtail [#_Bytes p, #_Bytes val]
    (when-not (== p JUST_CALC_SIZE)
        (let [p (loop [p p] (let [#_Bytes q (regnext p)] (if (some? q) (recur q) p))) ;; find last node
              #_int offset (if (== (re-op p) BACK) (BDIFF p, val) (BDIFF val, p))]
            ;; When the offset uses more than 16 bits it can no longer fit in the two bytes available.
            ;; Use a global flag to avoid having to check return values in too many places.
            (if (< 0xffff offset)
                (reset! reg_toolong true)
                (-> p
                    (.be 1, (byte (& (>>> offset 8) 0xff)))
                    (.be 2, (byte (&      offset    0xff)))
                ))
        ))
    nil)

;; Like regtail(), on item after a BRANCH; nop if none.

(defn- #_void regoptail [#_Bytes p, #_Bytes val]
    (let [op (re-op p)]
        ;; When op is neither BRANCH nor BRACE_COMPLEX0-9, it is "operandless".
        (when-not (or (nil? p) (== p JUST_CALC_SIZE) (and (!= op BRANCH) (or (< op BRACE_COMPLEX) (< (+ BRACE_COMPLEX 9) op))))
            (regtail (operand p), val)
        ))
    nil)

;; Functions for getting characters from the regexp input.

(atom! boolean at_start)        ;; true when on the first character
(atom! boolean prev_at_start)   ;; true when on the second character

;; Start parsing at "str".

(defn- #_void init-parse-state [#_Bytes str]
    (reset! regparse str)
    (reset! prevchr_len 0)
    (reset! curchr -1)
    (reset! prevchr -1)
    (reset! prevprevchr -1)
    (reset! nextchr -1)
    (reset! at_start true)
    (reset! prev_at_start false)
    nil)

;; Save the current parse state, so that it can be restored and parsing starts in the same state again.

(defn- #_parse_state_C save-parse-state []
    (parse_state_C. @regparse @prevchr_len @curchr @prevchr @prevprevchr @nextchr @at_start @prev_at_start @regnpar))

;; Restore a previously saved parse state.

(defn- #_void restore-parse-state [#_parse_state_C ps]
    (reset! regparse (:regparse ps))
    (reset! prevchr_len (:prevchr_len ps))
    (reset! curchr (:curchr ps))
    (reset! prevchr (:prevchr ps))
    (reset! prevprevchr (:prevprevchr ps))
    (reset! nextchr (:nextchr ps))
    (reset! at_start (:at_start ps))
    (reset! prev_at_start (:prev_at_start ps))
    (reset! regnpar (:regnpar ps))
    nil)

(atom! int after_slash)

;; Get the next character without advancing.

(defn- #_int peekchr []
    (when (== @curchr -1)
        (condp ==? (reset! curchr (.at @regparse 0))
           [(byte \.)
            (byte \[)
            (byte \~)]
                (when (<= MAGIC_ON @reg_magic) ;; magic when 'magic' is on
                    (swap! curchr Magic))

           [(byte \()
            (byte \))
            (byte \{)
            (byte \%)
            (byte \+)
            (byte \=)
            (byte \?)
            (byte \@)
            (byte \!)
            (byte \&)
            (byte \|)
            (byte \<)
            (byte \>)
            (byte \#)   ;; future ext.
            (byte \")   ;; future ext. """
            (byte \')   ;; future ext.
            (byte \,)   ;; future ext.
            (byte \-)   ;; future ext.
            (byte \:)   ;; future ext.
            (byte \;)   ;; future ext.
            (byte \`)   ;; future ext.
            (byte \/)]  ;; can't be used in / command
                (when (== @reg_magic MAGIC_ALL) ;; magic only after "\v"
                    (swap! curchr Magic))

            (byte \*)
                ;; * is not magic as the very first character, e.g. "?*ptr",
                ;; when after '^', e.g. "/^*ptr" and when after "\(", "\|", "\&",
                ;; but "\(\*" is not magic, thus must be magic if "after_slash"
                (when (and (<= MAGIC_ON @reg_magic)
                           (not @at_start)
                           (not (and @prev_at_start (== @prevchr (Magic (byte \^)))))
                           (or (!= @after_slash 0) (and (!= @prevchr (Magic (byte \())) (!= @prevchr (Magic (byte \&))) (!= @prevchr (Magic (byte \|))))))
                    (swap! curchr Magic))

            (byte \^)
                ;; '^' is only magic as the very first character
                ;; and if it's after "\(", "\|", "\&' or "\n"
                (when (and (<= MAGIC_OFF @reg_magic)
                           (or @at_start (== @reg_magic MAGIC_ALL)
                                         (== @prevchr (Magic (byte \())) (== @prevchr (Magic (byte \|))) (== @prevchr (Magic (byte \&))) (== @prevchr (Magic (byte \n)))
                                         (and (== (no-Magic @prevchr) (byte \()) (== @prevprevchr (Magic (byte \%))))))
                    (swap! curchr Magic)
                    (reset! at_start true)
                    (reset! prev_at_start false))

            (byte \$)
                ;; '$' is only magic as the very last character
                ;; and if it's in front of either "\|", "\)", "\&", or "\n"
                (when (<= MAGIC_OFF @reg_magic)
                    (let [[ma? re] ;; ignore \c \C \m \M \v \V and \Z after '$'
                            (loop-when-recur [ma? (boolean (== @reg_magic MAGIC_ALL)) re (.plus @regparse 1)]
                                             (and (at? re (byte \\)) (any == (.at re 1) (byte \c) (byte \C) (byte \m) (byte \M) (byte \v) (byte \V) (byte \Z)))
                                             [(cond (at? re 1 (byte \v)) true (any == (.at re 1) (byte \m) (byte \M) (byte \V)) false :else ma?) (.plus re 2)]
                                          => [ma? re])]
                        (when (or (eos? re)
                                  (and (at? re (byte \\)) (any == (.at re 1) (byte \|) (byte \&) (byte \)) (byte \n)))
                                  (and ma?                (any == (.at re 0) (byte \|) (byte \&) (byte \))))
                                  (== @reg_magic MAGIC_ALL))
                            (swap! curchr Magic)
                        )))

            (byte \\)
                (let [#_int c (.at @regparse 1)]
                    (cond (== c NUL)
                    (do
                        (reset! curchr (byte \\))      ;; trailing '\'
                    )
                    (and (<= (char_u (byte c)) (byte \~)) (non-zero? (... META_flags c)))
                    (do
                        ;; META contains everything that may be magic sometimes,
                        ;; except ^ and $ ("\^" and "\$" are only magic after "\v").
                        ;; We now fetch the next character and toggle its magicness.
                        ;; Therefore, \ is so meta-magic that it is not in META.
                        (reset! curchr -1)
                        (reset! prev_at_start @at_start)
                        (reset! at_start false)   ;; be able to say "/\*ptr"
                        (swap! regparse plus 1)
                        (swap! after_slash inc)
                        (peekchr)
                        (swap! regparse minus 1)
                        (swap! after_slash dec)
                        (swap! curchr toggle-Magic)
                    )
                    (some? (vim-strchr REGEXP_ABBR, c))
                    (do
                        ;; Handle abbreviations, like "\t" for TAB.
                        (reset! curchr (backslash-trans c))
                    )
                    (and (== @reg_magic MAGIC_NONE) (any == c (byte \$) (byte \^)))
                    (do
                        (reset! curchr (toggle-Magic c))
                    )
                    :else
                    (do
                        ;; Next character can never be (made) magic?
                        ;; Then backslashing it won't do anything.
                        (reset! curchr (us-ptr2char @regparse, 1))
                    ))
                )

         ;; :else
            (reset! curchr (us-ptr2char @regparse))
        ))
    @curchr)

;; Eat one lexed character.  Do this in a way that we can undo it.

(defn- #_void skipchr []
    ;; peekchr() eats a backslash, do the same here
    (reset! prevchr_len (if (at? @regparse (byte \\)) 1 0))
    ;; exclude composing chars that us-ptr2len-cc does include
    (when (non-eos? @regparse @prevchr_len)
        (swap! prevchr_len #(+ % (us-ptr2len @regparse %))))
    (swap! regparse plus @prevchr_len)
    (reset! prev_at_start @at_start)
    (reset! at_start false)
    (reset! prevprevchr @prevchr)
    (reset! prevchr @curchr)
    (reset! curchr @nextchr)       ;; use previously unget char, or -1
    (reset! nextchr -1)
    nil)

;; Skip a character while keeping the value of "prev_at_start" for at_start.
;; "prevchr" and "prevprevchr" are also kept.

(defn- #_void skipchr-keepstart []
    (let [#_boolean as @prev_at_start, #_int pr @prevchr, #_int prpr @prevprevchr]
        (skipchr)
        (reset! at_start as)
        (reset! prevchr pr)
        (reset! prevprevchr prpr)
        nil
    ))

;; Get the next character from the pattern.
;; We know about magic and such, so therefore we need a lexical analyzer.

(defn- #_int getchr []
    (let [#_int chr (peekchr)] (skipchr) chr))

;; Put character back.  Works only once!

(defn- #_void ungetchr []
    (reset! nextchr @curchr)
    (reset! curchr @prevchr)
    (reset! prevchr @prevprevchr)
    (reset! at_start @prev_at_start)
    (reset! prev_at_start false)
    ;; Backup "regparse", so that it's at the same position as before the getchr().
    (swap! regparse minus @prevchr_len)
    nil)

;; Get and return the value of the hex string at the current position.
;; Return -1 if there is no valid hex number.
;; The position is updated:
;;     blahblah\%x20asdf
;;         before-^ ^-after
;; The parameter controls the maximum number of input characters.  This will be
;; 2 when reading a \%x20 sequence and 4 when reading a \%u20AC sequence.

(defn- #_int gethexchrs [#_int maxinputlen]
    (let [[#_int n #_int i]
            (loop-when [n 0 i 0] (< i maxinputlen) => [n i]
                (let-when [#_int c (.at @regparse 0)] (asc-isxdigit c) => [n i]
                    (swap! regparse plus 1)
                    (recur (| (<< n 4) (hex2nr c)) (inc i))
                ))]
        (if (zero? i) -1 n)
    ))

;; Get and return the value of the decimal string immediately after the
;; current position.  Return -1 for invalid.  Consumes all digits.

(defn- #_int getdecchrs []
    (let [[#_int n #_int i]
            (loop [n 0 i 0]
                (let-when [#_int c (.at @regparse 0)] (asc-isdigit c) => [n i]
                    (swap! regparse plus 1)
                    (reset! curchr -1)    ;; no longer valid
                    (recur (+ (* n 10) (- c (byte \0))) (inc i))
                ))]
        (if (zero? i) -1 n)
    ))

;; Get and return the value of the octal string immediately after the current
;; position.  Return -1 for invalid, or 0-255 for valid.  Smart enough to handle
;; numbers > 377 correctly (for example, 400 is treated as 40) and doesn't
;; treat 8 or 9 as recognised characters.  Position is updated:
;;     blahblah\%o210asdf
;;         before-^  ^-after

(defn- #_int getoctchrs []
    (let [[#_int n #_int i]
            (loop-when [n 0 i 0] (and (< i 3) (< n 040)) => [n i]
                (let-when [#_int c (.at @regparse 0)] (asc-isodigit c) => [n i]
                    (swap! regparse plus 1)
                    (recur (| (<< n 3) (hex2nr c)) (inc i))
                ))]
        (if (zero? i) -1 n)
    ))

;; Get a number after a backslash that is inside [].
;; When nothing is recognized return a backslash.

(defn- #_int coll-get-char []
    (let [#_int nr
            (condp == (.at (swap! regparse plus 1) -1)
                (byte \d) (getdecchrs)
                (byte \o) (getoctchrs)
                (byte \x) (gethexchrs 2)
                (byte \u) (gethexchrs 4)
                (byte \U) (gethexchrs 8)
            -1)]
        (if (neg? nr) ;; if getting the number fails, be backwards compatible: the character is a backslash
            (do (swap! regparse minus 1) (byte \\))
            nr)
    ))

;; Read two integers to be taken as minimum and maximum values.
;; If the first character is '-', the range is reversed.
;; If "minval" is missing, the default is zero.
;; If "maxval" is missing, the default is a very big number.

(defn- #_[window_C boolean] read-limits? [#_window_C win, #_long' a'min, #_long' a'max]
    (let [#_boolean reverse (at? @regparse (byte \-)) _ (when reverse (swap! regparse plus 1))
          #_Bytes start @regparse]
        (reset! a'min (getdigits regparse))
        (reset! a'max (cond
            (at? @regparse (byte \,))   (if (asc-isdigit (.at (swap! regparse plus 1) 0)) (getdigits regparse) MAX_LIMIT)
            (asc-isdigit (.at start 0)) @a'min      ;; it was \{n} or \{-n}
            :else                       MAX_LIMIT   ;; it was \{} or \{-}
        ))
        (when (at? @regparse (byte \\))
            (swap! regparse plus 1))                ;; allow either \{...} or \{...\}
        (if (at? @regparse (byte \}))
            ;; Reverse the range if there was a '-', or make sure it is in the right order otherwise.
            (do (when (or (and (not reverse) (< @a'max @a'min)) (and reverse (< @a'min @a'max)))
                    (let [_ @a'min] (reset! a'min @a'max) (reset! a'max _)))
                (skipchr) ;; let's be friends with the lexer again
                [win true])
            (let [win (emsg* win, (u8 "E554: Syntax error in %s{...}"), (if (== @reg_magic MAGIC_ALL) (u8 "") (u8 "\\")))]
                (reset! rc_did_emsg true)
                [win false]
            ))
    ))

;; Global work variables for vim-regexec().

;; The current match-position is remembered with these variables:
(atom! long     reglnum)                ;; line number, relative to first line
(atom! Bytes    regline)                ;; start of current line
(atom! Bytes    reginput)               ;; current input, points into "regline"

;; Structure used to save the current input state, when it needs to be
;; restored after trying a match.  Used by reg-save() and reg-restore().
;; Also stores the state of "backpos".

(class! #_final regsave_C
    [
        (field long         rs_lnum)
        (field int          rs_col)
        (field int          rs_back)
    ])

;; Used for BEHIND and NOBEHIND matching.

(class! #_final regbehind_C
    [
        (field regsave_C    rb_after)
        (field regsave_C    rb_behind)
        (field lpos_C*      rb_start)
        (field lpos_C*      rb_end)
    ])

;; Internal copy of 'ignorecase'.  It is set at each call to vim-regexec().  Normally it gets
;; the value of "m_icase", but when the pattern contains '\c' or '\C', the value is overruled.

(atom! boolean ireg_icase)

;; Similar to "ireg_icase", but only for 'combining' characters.
;; Set with \Z flag in the regexp.  Defaults to false, always.

(atom! boolean ireg_icombine)

;; Copy of "m_maxcol": maximum column to search for a match.
;; Zero when there is no maximum.

(atom! int     ireg_maxcol)

;; These variables are set when executing a regexp to speed up the execution.
;;
;; reg_match            matcher_C
;; reg_lmin             first line in which to search
;; reg_lmax             last line nr

(atom! matcher_C    reg_match)
(atom! long         reg_lmin)
(atom! long         reg_lmax)

;; Values for "ri_state" in regitem_C.

(final int
    RS_NOPEN         0,     ;; NOPEN and NCLOSE
    RS_MOPEN         1,     ;; MOPEN + [0-9]
    RS_MCLOSE        2,     ;; MCLOSE + [0-9]
    RS_BRANCH        3,     ;; BRANCH
    RS_BRCPLX_MORE   4,     ;; BRACE_COMPLEX and trying one more match
    RS_BRCPLX_LONG   5,     ;; BRACE_COMPLEX and trying longest match
    RS_BRCPLX_SHORT  6,     ;; BRACE_COMPLEX and trying shortest match
    RS_NOMATCH       7,     ;; NOMATCH
    RS_BEHIND1       8,     ;; BEHIND / NOBEHIND matching rest
    RS_BEHIND2       9,     ;; BEHIND / NOBEHIND matching behind part
    RS_STAR_LONG    10,     ;; STAR/PLUS/BRACE_SIMPLE longest match
    RS_STAR_SHORT   11)     ;; STAR/PLUS/BRACE_SIMPLE shortest match

;; When there are alternatives, an RS_ is pushed on "regstack" to remember what we are doing.
;; Before it may be another type of item, depending on "ri_state", to remember more things.

(class! #_final regitem_C
    [
        (field int          ri_state)       ;; what we are doing, one of RS_ above
        (field Bytes        ri_scan)        ;; current node in program
        (field int          ri_no)          ;; submatch nr or BEHIND/NOBEHIND
        (field lpos_C       ri_sesave)      ;; union room for saving reginput
        (field regsave_C    ri_regsave)     ;; union room for saving reginput
    ])

;; Used for STAR, PLUS and BRACE_SIMPLE matching.

(class! #_final regstar_C
    [
        (field int          rs_nextb)       ;; next byte
        (field int          rs_nextb_ic)    ;; next byte reverse case
        (field long         rs_count)
        (field long         rs_minval)
        (field long         rs_maxval)
    ])

;; Used to store input position when a BACK was encountered,
;; so that we now if we made any progress since the last time.

(class! #_final backpos_C
    [
        (field Bytes        bp_scan)        ;; "scan" where BACK was encountered
        (field regsave_C    bp_regsave)     ;; last input position
    ])

;; "regstack" and "backpos" are used by bt-regmatch().
;;
;; "regstack" is a stack with regitem_C items, sometimes preceded by regstar_C or regbehind_C.
;; "backpos" is a table with backpos_C items for BACK.

(atom! Object*      regstack)
(atom! backpos_C*   backpos)

;; Get pointer to the line "lnum", which is relative to "reg_lmin".

(defn- #_Bytes reg-getline [#_long lnum]
    (cond
        (< (+ @reg_lmin lnum) 1) ;; When looking behind for a match/no-match, lnum is negative, but we can't go before line 1.
            nil
        (< @reg_lmax lnum) ;; Must have matched the "\n" in the last line.
            (u8 "")
        :else
            (ml-get (+ @reg_lmin lnum))
    ))

(atom! regsave_C    behind_pos)

;; Match a regexp against multiple lines.
;; "matcher.m_pattern" is a compiled regexp as returned by vim-regcomp().
;;
;; Return zero if there is no match.  Return number of lines contained in the match otherwise.

(defn- #_[window_C matcher_C long] bt-regexec? [#_window_C win, #_matcher_C matcher, #_long lnum, #_int col, #_long nsec]
    ;; lnum, col: pos to start looking for match
    ;; nsec: timeout limit or 0
    (reset! reg_match matcher)
    (reset! reg_lmin lnum)
    (reset! reg_lmax (- (line-count @curbuf) lnum))
    (reset! ireg_icase (:m_icase matcher))
    (reset! ireg_icombine false)
    (reset! ireg_maxcol (:m_maxcol matcher))

    (let [[win #_long nof]
            (let-when [#_bt_pattern_C pat (:m_pattern matcher) #_Bytes line (reg-getline 0)] (and (some? pat) (some? line)) => [(emsg win, e_null) 0] ;; Be paranoid...
                ;; When the start column is past the maximum column, no need to try.
                (when' (not (<= 1 @ireg_maxcol col)) => [win 0]
                    ;; If pattern contains "\c" or "\C", overrule value of "ireg_icase".
                    (cond
                        (flag? (:regflags pat) RF_ICASE)   (reset! ireg_icase true)
                        (flag? (:regflags pat) RF_NOICASE) (reset! ireg_icase false)
                    )
                    ;; If pattern contains "\Z", overrule value of "ireg_icombine".
                    (when (flag? (:regflags pat) RF_ICOMBINE)
                        (reset! ireg_icombine true))
                    ;; If there is a "must appear" string, look for it.
                    (let-when [[pat ?]
                            (when' (some? (:regmust pat)) => [pat nil]
                                (let [f'strchr (if @ireg_icase cstrchr vim-strchr) #_int c (us-ptr2char (:regmust pat))]
                                    (loop [pat pat #_Bytes s (.plus line col)]
                                        (let-when [s (f'strchr s, c)] (some? s) => [pat :oops!] ;; Not found.
                                            (let [__ (atom (int (:regmlen pat))) ? (zero? (cstrncmp s, (:regmust pat), __)) pat (assoc pat :regmlen @__)]
                                                (recur-if (not ?) [pat (.plus s (us-ptr2len-cc s))] => [pat nil])) ;; Found it.
                                        ))
                                ))
;                           %% poor "pat" !!
                    ] (not ?) => [win 0]

                        (reset! regline line)
                        (reset! reglnum 0)
                        (reset! reg_toolong false)

                        (if (:reganch pat)
                            ;; Simplest case: Anchored match need be tried only once.
                            (let [#_int b (:regstart pat) #_int c (us-ptr2char @regline, col)]
                                (when' (or (any == b NUL c) (and @ireg_icase (or (== (utf-fold b) (utf-fold c)) (== (utf-tolower b) (utf-tolower c))))) => [win 0]
                                    (bt-regtry? win, pat, col)
                                ))
                            ;; Messy cases: Unanchored match.
                            (loop-when [win win col col #_int t 0] (not @got_int) => [win 0]
                                (let-when [[col ?]
                                        (when' (!= (:regstart pat) NUL) => [col nil]
                                            ;; Skip until the char we know it must start with.
                                            ;; Used often, do some work to avoid call overhead.
                                            (let [#_Bytes s (cstrchr (.plus @regline col), (:regstart pat))]
                                                (if (some? s) [(BDIFF s, @regline) nil] [col :oops!])
                                            ))
                                    ;; Check for maximum column to try.
                                ] (and (not ?) (not (<= 1 @ireg_maxcol col))) => [win 0]

                                    (let-when [[win nof :as _] (bt-regtry? win, pat, col)] (zero? nof) => _
                                        ;; If not currently on the first line, get it again.
                                        (when (non-zero? @reglnum)
                                            (reset! reglnum 0)
                                            (reset! regline (reg-getline 0))
                                        )
                                        (when' (non-eos? @regline col) => [win 0]
                                            ;; Check for timeout once in 20 times to avoid overhead.
                                            (let-when [[t ?]
                                                    (when' (non-zero? nsec) => [t nil]
                                                        (let-when [t (inc t)] (== t 20) => [t nil]
                                                            [0 (when (profile-passed-limit nsec) :over!)]
                                                        ))
                                            ] (not ?) => [win 0]

                                                (recur win (+ col (us-ptr2len-cc @regline, col)) t)
                                            ))
                                    ))
                            ))
                    ))
            )]

        [win matcher nof]
    ))

;; Try matching "pat" at regline[col].
;; Return 0 for failure, number of lines contained in the match otherwise.

(defn- #_[window_C long] bt-regtry? [#_window_C win, #_bt_pattern_C pat, #_int col]
    (reset! reginput (.plus @regline col))
    (swap! reg_match cleanup-subexpr)
    (let-when [[win ?] (bt-regmatch? win, (.plus (:program pat) 1))] ? => [win 0]
        (when (neg? (:lnum (... (:m_startpos @reg_match) 0)))
            (swap! reg_match assoc-in [:m_startpos 0] (lpos_C. 0 col)))
        ;; Pattern has a \ze, but it didn't match, use current end.  ;; Use line number of \ze.
        (let-when [e (:lnum (... (:m_endpos @reg_match) 0))] (neg? e) => (reset! reglnum e)
            (swap! reg_match assoc-in [:m_endpos 0] (lpos_C. @reglnum (BDIFF @reginput, @regline))))
        [win (+ 1 @reglnum)]
    ))

;; Get class of previous character.

(defn- #_int reg-prev-class []
    (if (BLT @regline, @reginput) (us-get-class (.minus @reginput (inc (us-head-off @regline, (.minus @reginput 1))))) -1))

;; Return true if the current reginput position matches the Visual area.

(defn- #_boolean reg-match-visual [#_window_C win]
    (if (zero? (:lnum @VIsual_cursor))
        false
        (let-when [[#_pos_C top #_pos_C bot #_int mode]
                (if @VIsual_active
                    (let [v @VIsual_cursor c (:w_cursor win) m @VIsual_mode]
                        (if (ltpos v, c) [v c m] [c v m]))
                    (let [v (:b_visual @curbuf) s (:vi_start v) e (:vi_end v) m (:vi_mode v)]
                        (if (ltpos s, e) [s e m] [e s m])
                    ))
              #_long lnum (+ @reglnum @reg_lmin)
        ] (<= (:lnum top) lnum (:lnum bot)) => false

            (condp == mode
                (byte \v)
                    (let [#_int col (BDIFF @reginput, @regline)]
                        (and (or (!= lnum (:lnum top)) (<= (:col top) col))
                             (or (!= lnum (:lnum bot)) (< col (+ (:col bot) (if (not-at? @p_sel (byte \e)) 1 0))))
                        ))
                Ctrl_V
                    (let [a's1 (atom (int)) a'e1 (atom (int)) _ (getvvcol win, top, a's1, nil, a'e1)
                          a's2 (atom (int)) a'e2 (atom (int)) _ (getvvcol win, bot, a's2, nil, a'e2)]
                        (reset! a's1 (min @a's1 @a's2))
                        (reset! a'e1 (max @a'e2 @a'e1))
                        (when (or (== (:col top) MAXCOL) (== (:col bot) MAXCOL))
                            (reset! a'e1 MAXCOL))
                        (let [#_int cols (win-linetabsize win, @regline, (BDIFF @reginput, @regline))]
                            (<= @a's1 cols (- @a'e1 (if (at? @p_sel (byte \e)) 1 0)))
                        ))
                true
            ))
    ))

;; The arguments from BRACE_LIMITS are stored here.  They are actually local
;; to bt-regmatch(), but they are here to reduce the amount of stack space used
;; (it can be called recursively many times).

(atom! long     bl_minval)
(atom! long     bl_maxval)

(defn- #_boolean enough-regstack? [] (< (>>> (count @regstack) 10) @p_mmp))

(final int
    RA_NIL      0,      ;; didn't match
    RA_FAIL     1,      ;; something failed, abort
    RA_JUMP     2,      ;; (reg-nextline) + RA_CONT
    RA_STEP     3,      ;; (reg-nextchar) + RA_CONT
    RA_CONT     4,      ;; continue in inner loop
    RA_BREAK    5,      ;; break inner loop
    RA_MATCH    6)      ;; successful match

(defn- #_[window_C Bytes int] one-regmatch- [#_window_C win, #_Bytes scan, #_int op]
    (let [a'win (atom (#_window_C object win)) a'next (atom (#_Bytes object (regnext scan)))
          #_int status RA_CONT #_byte b (.at @reginput 0) #_int c (us-ptr2char @reginput)
          status
            (condp ==? op

                BT_BOL  (if (BNE @reginput, @regline) RA_NIL status)
                BT_EOL  (if (!= c NUL)                RA_NIL status)

                ;; We're not at the beginning of the file when below the first line where we started,
                ;; not at the start of the line or we didn't start at the first line of the buffer.
                BT_BOF  (if (or (non-zero? @reglnum) (BNE @reginput, @regline) (< 1 @reg_lmin)) RA_NIL status)
                BT_EOF  (if (or (!= @reglnum @reg_lmax) (!= c NUL))                             RA_NIL status)

                BT_CURSOR ;; compare the cursor position to the match position
                    (if (or (!= (+ @reglnum @reg_lmin) (:lnum (:w_cursor @a'win))) (!= (BDIFF @reginput, @regline) (:col (:w_cursor @a'win)))) RA_NIL status)

                BT_MARK ;; compare the mark position to the match position
                    (let [#_int mark (.at (operand scan) 0) #_int cmp (.at (operand scan) 1) #_pos_C pos (getmark @a'win, mark)]
                        (if (or (nil? pos) (< (:lnum pos) 1)
                                (if (== (:lnum pos) (+ @reglnum @reg_lmin))
                                    (if (== (:col pos) (BDIFF @reginput, @regline))
                                        (any == cmp (byte \<) (byte \>))
                                        (if (< (:col pos) (BDIFF @reginput, @regline)) (!= cmp (byte \>)) (!= cmp (byte \<))))
                                    (if (< (:lnum pos) (+ @reglnum @reg_lmin)) (!= cmp (byte \>)) (!= cmp (byte \<)))))
                            RA_NIL status
                        ))

                BT_VISUAL
                    (if (not (reg-match-visual @a'win)) RA_NIL status)

                BT_LNUM (if (not (re-num-cmp (+ @reglnum @reg_lmin), scan))                                                RA_NIL status)
                BT_COL  (if (not (re-num-cmp (inc (BDIFF @reginput, @regline)), scan))                                     RA_NIL status)
                BT_VCOL (if (not (re-num-cmp (inc (win-linetabsize @a'win, @regline, (BDIFF @reginput, @regline))), scan)) RA_NIL status)

                BT_BOW ;; \<word; reginput points to w
                    (if (== c NUL) ;; can't match at end of line
                        RA_NIL
                        (let [#_int cls (us-get-class @reginput)]
                            ;; not on a word at all ;; previous char is in same word
                            (if (or (<= cls 1) (== (reg-prev-class) cls)) RA_NIL status)
                        ))

                BT_EOW ;; word\>; reginput points after d
                    (if (BEQ @reginput, @regline) ;; can't match at start of line
                        RA_NIL
                        (let [#_int cls' (reg-prev-class)]
                            (if (any == cls' (us-get-class @reginput) 0 1) RA_NIL status)
                        ))

                ANY ;; does not match new lines
                    (if (== c NUL) RA_NIL RA_STEP)

                IDENT   (if (not (vim-isidentc c))       RA_NIL RA_STEP)        SIDENT  (if (or (asc-isdigit b) (not (vim-isidentc c)))       RA_NIL RA_STEP)
                KWORD   (if (not (us-iswordp @reginput)) RA_NIL RA_STEP)        SKWORD  (if (or (asc-isdigit b) (not (us-iswordp @reginput))) RA_NIL RA_STEP)
                FNAME   (if (not (vim-isfnamec c))       RA_NIL RA_STEP)        SFNAME  (if (or (asc-isdigit b) (not (vim-isfnamec c)))       RA_NIL RA_STEP)
                PRINT   (if (not (vim-isprintc c))       RA_NIL RA_STEP)        SPRINT  (if (or (asc-isdigit b) (not (vim-isprintc c)))       RA_NIL RA_STEP)

                WHITE   (if (not (vim-iswhite c))        RA_NIL RA_STEP)        NWHITE  (if (or (== c NUL)           (vim-iswhite c))         RA_NIL RA_STEP)
                DIGIT   (if (not (ri-digit c))           RA_NIL RA_STEP)        NDIGIT  (if (or (== c NUL)           (ri-digit c))            RA_NIL RA_STEP)
                HEX     (if (not (ri-hex c))             RA_NIL RA_STEP)        NHEX    (if (or (== c NUL)           (ri-hex c))              RA_NIL RA_STEP)
                OCTAL   (if (not (ri-octal c))           RA_NIL RA_STEP)        NOCTAL  (if (or (== c NUL)           (ri-octal c))            RA_NIL RA_STEP)
                WORD    (if (not (ri-word c))            RA_NIL RA_STEP)        NWORD   (if (or (== c NUL)           (ri-word c))             RA_NIL RA_STEP)
                HEAD    (if (not (ri-head c))            RA_NIL RA_STEP)        NHEAD   (if (or (== c NUL)           (ri-head c))             RA_NIL RA_STEP)
                ALPHA   (if (not (ri-alpha c))           RA_NIL RA_STEP)        NALPHA  (if (or (== c NUL)           (ri-alpha c))            RA_NIL RA_STEP)
                LOWER   (if (not (ri-lower c))           RA_NIL RA_STEP)        NLOWER  (if (or (== c NUL)           (ri-lower c))            RA_NIL RA_STEP)
                UPPER   (if (not (ri-upper c))           RA_NIL RA_STEP)        NUPPER  (if (or (== c NUL)           (ri-upper c))            RA_NIL RA_STEP)

                EXACTLY
                    (let [#_Bytes opnd (operand scan)]
                        ;; Inline the first byte for speed.
                        (cond (and (not-at? opnd b) (not @ireg_icase))
                            RA_NIL
                        ;; Match empty string always works; happens when "~" is empty.
                        (eos? opnd)
                            status
                        :else
                            (let [a'len (atom (int))
                                  status
                                    (if (and (eos? opnd 1) (not @ireg_icase))
                                        (do (reset! a'len 1) ;; matched a single byte above
                                            status)
                                        ;; Need to match first byte again for multi-byte.
                                        (do (reset! a'len (STRLEN opnd))
                                            (if (non-zero? (cstrncmp opnd, @reginput, a'len)) RA_NIL status)
                                        ))
                                  ;; Check for following composing character, unless %C follows (skips over all composing chars).
                                  status
                                    (if (and (!= status RA_NIL) (utf-iscomposing (us-ptr2char @reginput, @a'len)) (not @ireg_icombine) (!= (re-op @a'next) BT_COMPOSING))
                                        ;; This code makes a composing character get ignored, which is the correct behavior (sometimes) for voweled Hebrew texts.
                                        RA_NIL status
                                    )]
                                (when (!= status RA_NIL)
                                    (swap! reginput plus @a'len))
                                status)
                        ))

               [ANYOF ANYBUT]
                    (if (or (== c NUL) (== (nil? (cstrchr (operand scan), c)) (== op ANYOF))) RA_NIL RA_STEP)

                MULTIBYTECODE
                    ;; Safety check (just in case 'encoding' was changed since compiling the program).
                    (let-when [#_Bytes opnd (operand scan) #_int len (us-ptr2len-cc opnd)] (< 1 len) => RA_NIL
                        (let [#_int opndc (us-ptr2char opnd)
                              [len status]
                                (if (utf-iscomposing opndc)
                                    ;; When only a composing char is given, match at any position where that composing char appears.
                                    (loop-when [#_int i 0] (non-eos? @reginput i) => [len RA_NIL]
                                        (let [#_int inpc (us-ptr2char @reginput, i)]
                                            (if (utf-iscomposing inpc)
                                                (if (== opndc inpc)
                                                    [(+ i (us-ptr2len-cc @reginput, i)) RA_MATCH] ;; include all following composing chars
                                                    (recur (+ i (us-ptr2len @reginput, i)))
                                                )
                                                (if (< 0 i)
                                                    [len RA_NIL]
                                                    (recur (+ i (us-ptr2len @reginput, i)))
                                                ))
                                        ))
                                    (loop-when [#_int i 0] (< i len) => [len status]
                                        (recur-if (at? opnd i (.at @reginput i)) [(inc i)] => [len RA_NIL]))
                                )]
                            (swap! reginput plus len)
                            status
                        ))

                BT_COMPOSING
                    (do ;; Skip composing characters.
                        (while (utf-iscomposing (us-ptr2char @reginput))
                            (swap! reginput #(.plus % (us-ptr2len %))))
                        status)

                NOTHING
                    status

                ;; When we run into BACK, we need to check if we don't keep looping without matching any input.
                ;; From the second time, it fails if the input is still at the same position as the previous time.
                ;; The positions are stored in "backpos" and found by comparing to the current value of "scan".
                BACK
                    (let [#_int n (count @backpos)
                          #_int i (loop-when-recur [i 0] (and (< i n) (BNE (:bp_scan (... @backpos i)), scan)) [(inc i)] => i)
                          status
                            (cond (== i n) ;; First time at this BACK.
                                (do (swap! backpos conj (backpos_C. scan, nil))
                                    status)
                            (reg-save-equal (:bp_regsave (... @backpos i)))
                                ;; Still at same position as last time, fail.
                                RA_NIL
                            :else
                                status
                            )]
                        (when (and (!= status RA_FAIL) (!= status RA_NIL))
                            (swap! backpos assoc-in [i :bp_regsave] (reg-save @backpos)))
                        status)

               [(+ MOPEN 0)     ;; Match start: \zs
                (+ MOPEN 1)     ;; \(
                (+ MOPEN 2)
                (+ MOPEN 3)
                (+ MOPEN 4)
                (+ MOPEN 5)
                (+ MOPEN 6)
                (+ MOPEN 7)
                (+ MOPEN 8)
                (+ MOPEN 9)]
                    (when' (enough-regstack?) => (do (swap! a'win emsg e_maxmempat) RA_FAIL)
                        (let [#_int no (- op MOPEN)]
                            (swap! regstack conj (reg-item RS_MOPEN, scan, no, (... (:m_startpos @reg_match) no), nil))
                            (swap! reg_match assoc-in [:m_startpos no] (lpos_C. @reglnum (BDIFF @reginput, @regline)))
                            ;; We simply continue and handle the result when done.
                            status
                        ))

               [NOPEN           ;; \%(                   ;; sic!)
                NCLOSE]         ;; \) after \%(          ;; sic!)
                    (when' (enough-regstack?) => (do (swap! a'win emsg e_maxmempat) RA_FAIL)
                        (do (swap! regstack conj (reg-item RS_NOPEN, scan))
                            ;; We simply continue and handle the result when done.
                            status
                        ))

               [(+ MCLOSE 0)    ;; Match end: \ze
                (+ MCLOSE 1)    ;; \)
                (+ MCLOSE 2)
                (+ MCLOSE 3)
                (+ MCLOSE 4)
                (+ MCLOSE 5)
                (+ MCLOSE 6)
                (+ MCLOSE 7)
                (+ MCLOSE 8)
                (+ MCLOSE 9)]
                    (when' (enough-regstack?) => (do (swap! a'win emsg e_maxmempat) RA_FAIL)
                        (let [#_int no (- op MCLOSE)]
                            (swap! regstack conj (reg-item RS_MCLOSE, scan, no, (... (:m_endpos @reg_match) no), nil))
                            (swap! reg_match assoc-in [:m_endpos no] (lpos_C. @reglnum (BDIFF @reginput, @regline)))
                            ;; We simply continue and handle the result when done.
                            status
                        ))

               [(+ BACKREF 1)
                (+ BACKREF 2)
                (+ BACKREF 3)
                (+ BACKREF 4)
                (+ BACKREF 5)
                (+ BACKREF 6)
                (+ BACKREF 7)
                (+ BACKREF 8)
                (+ BACKREF 9)]
                    (let [a'len (atom (int)) #_int no (- op BACKREF) startpos' (... (:m_startpos @reg_match) no) endpos' (... (:m_endpos @reg_match) no)
                          status
                            (cond (or (neg? (:lnum startpos')) (neg? (:lnum endpos')))
                                (do ;; Backref was not set: Match an empty string.
                                    (reset! a'len 0)
                                    status)
                            (and (== (:lnum startpos') @reglnum) (== (:lnum endpos') @reglnum))
                                (do ;; Compare back-ref within the current line.
                                    (reset! a'len (- (:col endpos') (:col startpos')))
                                    (if (non-zero? (cstrncmp (.plus @regline (:col startpos')), @reginput, a'len)) RA_NIL status))
                            :else
                                ;; Messy situation: Need to compare between two lines.
                                (let [#_int r (match-with-backref (:lnum startpos'), (:col startpos'), (:lnum endpos'), (:col endpos'), a'len)]
                                    (if (!= r RA_MATCH) r status))
                            )]
                        ;; Matched the backref, skip over it.
                        (swap! reginput plus @a'len)
                        status)

                BRANCH
                    (if (!= (re-op @a'next) BRANCH) ;; No choice.
                        (do ;; Avoid recursion.
                            (reset! a'next (operand scan))
                            status)
                        (when' (enough-regstack?) => (do (swap! a'win emsg e_maxmempat) RA_FAIL)
                            (do (swap! regstack conj (reg-item RS_BRANCH, scan))
                                RA_BREAK) ;; Rest is below.
                        ))

                BRACE_LIMITS
                    (cond (== (re-op @a'next) BRACE_SIMPLE)
                        (do (reset! bl_minval (operand-min scan))
                            (reset! bl_maxval (operand-max scan))
                            status)
                    (<= BRACE_COMPLEX (re-op @a'next) (+ BRACE_COMPLEX 9))
                        (let [#_int no (- (re-op @a'next) BRACE_COMPLEX)]
                            (swap! brace_min assoc no (operand-min scan))
                            (swap! brace_max assoc no (operand-max scan))
                            (swap! brace_count assoc no 0)
                            status)
                    :else
                        (do (swap! a'win emsg e_internal) ;; Shouldn't happen.
                            RA_FAIL
                        ))

               [(+ BRACE_COMPLEX 0)
                (+ BRACE_COMPLEX 1)
                (+ BRACE_COMPLEX 2)
                (+ BRACE_COMPLEX 3)
                (+ BRACE_COMPLEX 4)
                (+ BRACE_COMPLEX 5)
                (+ BRACE_COMPLEX 6)
                (+ BRACE_COMPLEX 7)
                (+ BRACE_COMPLEX 8)
                (+ BRACE_COMPLEX 9)]
                    (let [#_int no (- op BRACE_COMPLEX)]
                        (swap! brace_count update no inc)
                        ;; If not matched enough times yet, try one more.
                        (cond (<= (... @brace_count no) (min (... @brace_min no) (... @brace_max no)))
                            (when' (enough-regstack?) => (do (swap! a'win emsg e_maxmempat) RA_FAIL)
                                (do (swap! regstack conj (reg-item RS_BRCPLX_MORE, scan, no, nil, (reg-save @backpos)))
                                    (reset! a'next (operand scan))
                                    ;; We continue and handle the result when done.
                                    status
                                ))
                        ;; If matched enough times, may try matching some more.
                        (<= (... @brace_min no) (... @brace_max no))
                            ;; Range is the normal way around, use longest match.
                            (when' (<= (... @brace_count no) (... @brace_max no)) => status
                                (when' (enough-regstack?) => (do (swap! a'win emsg e_maxmempat) RA_FAIL)
                                    (do (swap! regstack conj (reg-item RS_BRCPLX_LONG, scan, no, nil, (reg-save @backpos)))
                                        (reset! a'next (operand scan))
                                        ;; We continue and handle the result when done.
                                        status)
                                ))
                        :else
                            ;; Range is backwards, use shortest match first.
                            (when' (<= (... @brace_count no) (... @brace_min no)) => status
                                (when' (enough-regstack?) => (do (swap! a'win emsg e_maxmempat) RA_FAIL)
                                    (do (swap! regstack conj (reg-item RS_BRCPLX_SHORT, scan, 0, nil, (reg-save @backpos)))
                                        ;; We continue and handle the result when done.
                                        status)
                                ))
                        ))

               [BRACE_SIMPLE STAR PLUS]
                    (let [#_regstar_C rs (NEW_regstar_C)
                          ;; Lookahead to avoid useless match attempts when we know what character comes next.
                          rs (when' (== (re-op @a'next) EXACTLY) => (assoc rs :rs_nextb NUL :rs_nextb_ic NUL)
                                (let [? (.at (operand @a'next) 0)]
                                    (assoc rs :rs_nextb ? :rs_nextb_ic (if @ireg_icase (if (utf-isupper ?) (utf-tolower ?) (utf-toupper ?)) ?))
                                ))
                          rs (if (!= op BRACE_SIMPLE)
                                (assoc rs :rs_minval (if (== op STAR) 0 1) :rs_maxval MAX_LIMIT)
                                (assoc rs :rs_minval @bl_minval            :rs_maxval @bl_maxval))
                          ;; When maxval > minval, try matching as much as possible, up to maxval.
                          ;; When maxval < minval, try matching at least the minimal number
                          ;; (since the range is backwards, that's also maxval!).
                          rs (assoc rs :rs_count (regrepeat (operand scan), (:rs_maxval rs)))]
                        (cond @got_int
                            RA_FAIL
                        (<= (min (:rs_minval rs) (:rs_maxval rs)) (:rs_count rs))
                            ;; It could match.  Prepare for trying to match what follows.
                            ;; The code is below.  Parameters are stored in a regstar_C on "regstack".
                            (when' (enough-regstack?) => (do (swap! a'win emsg e_maxmempat) RA_FAIL)
                                (do (swap! regstack conj rs)
                                    (swap! regstack conj (reg-item (if (<= (:rs_minval rs) (:rs_maxval rs)) RS_STAR_LONG RS_STAR_SHORT), scan))
                                    RA_BREAK ;; skip the restore bits
                                ))
                        :else
                            RA_NIL
                        ))

               [NOMATCH MATCH SUBPAT]
                    (when' (enough-regstack?) => (do (swap! a'win emsg e_maxmempat) RA_FAIL)
                        (do (swap! regstack conj (reg-item RS_NOMATCH, scan, op, nil, (reg-save @backpos)))
                            (reset! a'next (operand scan))
                            ;; We continue and handle the result when done.
                            status
                        ))

               [BEHIND NOBEHIND]
                    (when' (enough-regstack?) => (do (swap! a'win emsg e_maxmempat) RA_FAIL)
                        (do ;; Need to save the subexpr to be able to restore them
                            ;; when there is a match but we don't use it.
                            (swap! regstack conj (save-subexpr (NEW_regbehind_C), @reg_match))
                            (swap! regstack conj (reg-item RS_BEHIND1, scan, op, nil, (reg-save @backpos)))
                            ;; First try if what follows matches.
                            ;; If it does, then we check the behind match by looping.
                            status
                        ))

                BHPOS
                    (if (or (!= (:rs_col @behind_pos) (BDIFF @reginput, @regline)) (!= (:rs_lnum @behind_pos) @reglnum)) RA_NIL status)

                BT_NEWL
                    (if (or (!= c NUL) (< @reg_lmax @reglnum)) RA_NIL RA_JUMP)

                BT_END
                    RA_MATCH ;; Success!

                (do (swap! a'win emsg e_re_corr) RA_FAIL)
            )]
        [@a'win @a'next status]
    ))

(defn- #_[window_C Bytes int] seq-regmatch- [#_window_C win, #_Bytes scan]
    ;; Some patterns may take a long time to match, e.g. "\([a-z]\+\)\+Q".
    ;; Allow interrupting them with CTRL-C.
    (fast-breakcheck)
    ;; Repeat for items that can be matched sequentially, without using "regstack".
    (loop-when [win win scan scan] (and (not @got_int) (some? scan)) => [win scan RA_FAIL]
        (let [#_int op (re-op scan)
              [win #_Bytes next #_int status] ;; Check for character class with NL added.
                (if (and (with-nl op) (eos? @reginput) (<= @reglnum @reg_lmax))
                    [win (regnext scan) RA_JUMP]
                    (one-regmatch- win, scan, (if (with-nl op) (- op ADD_NL) op)))
              status
                (condp == status
                    RA_JUMP (do (reg-nextline) (fast-breakcheck) RA_CONT)
                    RA_STEP (do (reg-nextchar) RA_CONT)
                    status
                )]
            (recur-if (== status RA_CONT) [win next] => [win scan status])
        )
    ))

(defn- #_[Bytes int] pop-regmatch- [#_Bytes scan, #_int status]
    ;; If there is something on "regstack", execute the code for the state.
    ;; When the state is popped, loop and use the older state.
    (do ;; loop [scan scan status status]
        (let-when [n (count @regstack)] (and (< 0 n) (!= status RA_FAIL)) => [scan status]
            (let [r (- n 1) rip #_regitem_C (... @regstack r)
                  [scan status]
                    (condp ==? (:ri_state rip)

                        RS_NOPEN
                            (do ;; Result is passed on as-is, simply pop the state.
                                [(pop-regitem) status])

                        RS_MOPEN
                            (do ;; Pop the state.  Restore pointers when there is no match.
                                (when (== status RA_NIL)
                                    (swap! reg_match assoc-in [:m_startpos (:ri_no rip)] (:ri_sesave rip)))
                                [(pop-regitem) status])

                        RS_MCLOSE
                            (do ;; Pop the state.  Restore pointers when there is no match.
                                (when (== status RA_NIL)
                                    (swap! reg_match assoc-in [:m_endpos (:ri_no rip)] (:ri_sesave rip)))
                                [(pop-regitem) status])

                        RS_BRANCH
                            (cond (== status RA_MATCH)
                                [(pop-regitem) status] ;; This branch matched, use it.
                            :else
                                (let [scan (when' (!= status RA_BREAK) => scan
                                            ;; After a non-matching branch: try next one.
                                            (swap! backpos reg-restore (:ri_regsave rip))
                                            (:ri_scan rip)
                                        )]
                                    (cond (or (nil? scan) (!= (re-op scan) BRANCH))
                                        [(pop-regitem) RA_NIL] ;; No more branches, didn't find a match.
                                    :else
                                        (do ;; Prepare to try a branch.
                                            (swap! regstack update r assoc :ri_scan (regnext scan) :ri_regsave (reg-save @backpos))
                                            [(operand scan) status]
                                        ))
                                ))

                        RS_BRCPLX_MORE
                            (do ;; Pop the state.  Restore pointers when there is no match.
                                (when (== status RA_NIL)
                                    (swap! backpos reg-restore (:ri_regsave rip))
                                    (swap! brace_count update (:ri_no rip) dec))
                                [(pop-regitem) status])

                        RS_BRCPLX_LONG
                            (let [status ;; Pop the state.  Restore pointers when there is no match.
                                    (when' (== status RA_NIL) => status
                                        ;; There was no match, but we did find enough matches.
                                        (swap! backpos reg-restore (:ri_regsave rip))
                                        (swap! brace_count update (:ri_no rip) dec)
                                        ;; Continue with the items after "\{}".
                                        RA_CONT)
                                  scan (pop-regitem) scan (if (== status RA_CONT) (regnext scan) scan)]
                                [scan status])

                        RS_BRCPLX_SHORT
                            (do ;; Pop the state.  Restore pointers when there is no match.
                                (when (== status RA_NIL)
                                    ;; There was no match, try to match one more item.
                                    (swap! backpos reg-restore (:ri_regsave rip)))
                                (let-when [scan (pop-regitem)] (== status RA_NIL) => [scan status]
                                    [(operand scan) RA_CONT]
                                ))

                        RS_NOMATCH
                            ;; Pop the state.  If the operand matches for NOMATCH or doesn't match for MATCH/SUBPAT, we fail.
                            (let [status ;; Otherwise backup, except for SUBPAT, and continue with the next item.
                                    (when' (!= status (if (== (:ri_no rip) NOMATCH) RA_MATCH RA_NIL)) => RA_NIL
                                        (when (!= (:ri_no rip) SUBPAT) ;; zero-width
                                            (swap! backpos reg-restore (:ri_regsave rip)))
                                        RA_CONT)
                                  scan (pop-regitem) scan (if (== status RA_CONT) (regnext scan) scan)]
                                [scan status])

                        RS_BEHIND1
                            (cond (== status RA_NIL)
                                (let [scan (pop-regitem) _ (drop-regbehind)]
                                    [scan status])
                            :else
                                (let [rs' (:ri_regsave rip)]
                                    ;; The stuff after BEHIND/NOBEHIND matches.
                                    ;; Now try if the behind part does (not) match before the current position in the input.
                                    ;; This must be done at every position in the input and checking if the match ends at the current position.
                                    ;;
                                    ;; Start looking for a match with operand at the current position.
                                    ;; Go back one character until we find the result, hitting the start of the line or the previous line (for multi-line matching).
                                    ;; Set "behind_pos" to where the match should end, BHPOS will match it.
                                    ;;
                                    ;; Save the position after the found match for next.  Save the current value.
                                    (swap! regstack update #_regbehind_C (- n 2) assoc :rb_after (reg-save @backpos) :rb_behind @behind_pos)
                                    (reset! behind_pos rs')
                                    (swap! regstack assoc-in [r :ri_state] RS_BEHIND2)
                                    (swap! backpos reg-restore rs')
                                    [(.plus (operand (:ri_scan rip)) 4) status]
                                ))

                        RS_BEHIND2
                            ;; Looping for BEHIND / NOBEHIND match.
                            (let [rb #_regbehind_C (... @regstack (- n 2))]
                                (cond (and (== status RA_MATCH) (reg-save-equal @behind_pos))
                                    (do ;; Found a match that ends where "next" started.
                                        (reset! behind_pos (:rb_behind rb))
                                        (let [status
                                                (if (== (:ri_no rip) BEHIND)
                                                    (do (swap! backpos reg-restore (:rb_after rb))
                                                        status)
                                                    (do ;; But we didn't want a match.  Need to restore the subexpr,
                                                        ;; because what follows matched, so they have been set.
                                                        (swap! reg_match restore-subexpr rb)
                                                        RA_NIL
                                                    ))
                                              scan (pop-regitem) _ (drop-regbehind)]
                                            [scan status]
                                        ))
                                :else
                                    ;; No match or a match that doesn't end where we want it:
                                    ;; go back one character.  May go to previous line once.
                                    (let [#_long limit (operand-min (:ri_scan rip)) rs' (:ri_regsave rip) bp' @behind_pos
                                          #_boolean no?
                                            (cond (<= 1 limit (- (if (< (:rs_lnum rs') (:rs_lnum bp')) (STRLEN @regline) (:rs_col bp')) (:rs_col rs')))
                                                false
                                            (zero? (:rs_col rs'))
                                                (let [? (< (:rs_lnum rs') (:rs_lnum bp'))
                                                      ? (when' (not ?) => true
                                                            (swap! regstack update-in [r :ri_regsave :rs_lnum] dec)
                                                            (nil? (reg-getline (:rs_lnum (:ri_regsave (... @regstack r)))))
                                                        )]
                                                    (when' (not ?) => false
                                                        (swap! backpos reg-restore (:ri_regsave (... @regstack r)))
                                                        (swap! regstack assoc-in [r :ri_regsave :rs_col] (STRLEN @regline))
                                                        true
                                                    ))
                                            :else
                                                (do (swap! regstack update-in [r :ri_regsave :rs_col] #(- % (inc (us-head-off @regline, (.plus @regline (dec %))))))
                                                    true
                                                ))
                                          rip (... @regstack r)]
                                        (cond no?
                                            (do ;; Advanced, prepare for finding match again.
                                                (swap! backpos reg-restore (:ri_regsave rip))
                                                (let [scan (.plus (operand (:ri_scan rip)) 4)
                                                      status
                                                        (when' (== status RA_MATCH) => status
                                                            ;; We did match, so subexpr may have been changed,
                                                            ;; need to restore them for the next try.
                                                            (swap! reg_match restore-subexpr rb)
                                                            RA_NIL
                                                        )]
                                                    [scan status]
                                                ))
                                        :else
                                            (do ;; Can't advance.  For NOBEHIND that's a match.
                                                (reset! behind_pos (:rb_behind rb))
                                                (let [status
                                                        (if (== (:ri_no rip) NOBEHIND)
                                                            (do (swap! backpos reg-restore (:rb_after rb))
                                                                RA_MATCH)
                                                            (when' (== status RA_MATCH) => status
                                                                ;; We do want a proper match.  Need to restore the subexpr
                                                                ;; if we had a match, because they may have been set.
                                                                (swap! reg_match restore-subexpr rb)
                                                                RA_NIL
                                                            ))
                                                      scan (pop-regitem) _ (drop-regbehind)]
                                                    [scan status]
                                                ))
                                        ))
                                ))

                        [RS_STAR_LONG RS_STAR_SHORT]
                            (if (== status RA_MATCH)
                                (let [scan (pop-regitem) _ (drop-regstar)]
                                    [scan status])
                                (do ;; Tried once already, restore input pointers.
                                    (when (!= status RA_BREAK)
                                        (swap! backpos reg-restore (:ri_regsave rip)))
                                    ;; Repeat until we found a position where it could match.
                                    (let [[scan status]
                                            (loop [status status rs #_regstar_C (... @regstack (- n 2))]
                                                (let-when [[status rs]
                                                        (when' (!= status RA_BREAK) => [RA_NIL rs]
                                                            ;; Tried first position already, advance.
                                                            (cond (== (:ri_state rip) RS_STAR_LONG)
                                                                ;; Trying for longest match, but couldn't or didn't match -- back up one char.
                                                                (let [rs (update rs :rs_count dec)]
                                                                    (cond (< rs (:rs_minval rs))
                                                                        [status nil]
                                                                    (BEQ @reginput, @regline)
                                                                        (do ;; Backup to last char of previous line.
                                                                            (swap! reglnum dec)
                                                                            (reset! regline (reg-getline @reglnum))
                                                                            ;; Just in case regrepeat() didn't count right.
                                                                            (when' (some? @regline) => [status nil]
                                                                                (reset! reginput (.plus @regline (STRLEN @regline)))
                                                                                (fast-breakcheck)
                                                                                [status (when-not @got_int rs)]
                                                                            ))
                                                                    :else
                                                                        (do (swap! reginput #(.minus % (us-ptr-back @regline, %)))
                                                                            [status (when-not @got_int rs)])
                                                                    ))
                                                            ;; Range is backwards, use shortest match first.
                                                            ;; Careful: maxval and minval are exchanged!
                                                            ;; Couldn't or didn't match: try advancing one char.
                                                            (or (== (:rs_count rs) (:rs_minval rs)) (zero? (regrepeat (operand (:ri_scan rip)), 1)))
                                                                [status nil]
                                                            :else
                                                                (let [rs (update rs :rs_count inc)]
                                                                    [status (when-not @got_int rs)]
                                                                ))
                                                        )] (some? rs) => [scan status]

                                                    ;; If it could match, try it.
                                                    (when' (or (== (:rs_nextb rs) NUL) (at? @reginput (:rs_nextb rs)) (at? @reginput (:rs_nextb_ic rs))) => (recur status rs)
                                                        (swap! regstack assoc-in [r :ri_regsave] (reg-save @backpos))
                                                        [(regnext (:ri_scan rip)) RA_CONT]
                                                    ))
                                            )]
                                        (when' (!= status RA_CONT) => [scan status]
                                            ;; Failed.
                                            (let [scan (pop-regitem) _ (drop-regstar)]
                                                [scan RA_NIL])
                                        ))
                                ))
                    )]
                ;; If we want to continue the inner loop or didn't pop a state, continue the matching loop.
                (when' (or (== status RA_CONT) (== (count @regstack) n)) => (recur scan status)
                    [scan status])
            ))
    ))

;; Main matching routine.
;;
;; Conceptually the strategy is simple:
;; check to see whether the current node matches, push an item onto "regstack"
;; and loop to see whether the rest matches, then act accordingly.
;;
;; In practice we make some effort to avoid using "regstack", in particular by going through
;; "ordinary" nodes (that don't need to know whether the rest of the match failed) by a nested loop.
;;
;; Returns true when there is a match.
;; Leaves "reginput" and "reglnum" just after the last matched character.
;;
;; Returns false when there is no match.
;; Leaves "reginput" and "reglnum" in an undefined state!

(defn- #_[window_C boolean] bt-regmatch? [#_window_C win, #_Bytes scan]
    ;; Make "regstack" and "backpos" empty.
    (reset! regstack [])
    (reset! backpos [])
    ;; Repeat until "regstack" is empty.
    (loop [win win scan scan]
        ;; "status": one of the RA_ values above
        (let [[win scan #_int status] (seq-regmatch- win, scan) [scan status] (pop-regmatch- scan, status)]
            ;; May need to continue with the inner loop, starting at "scan".
            (when' (!= status RA_CONT) => (recur win scan)
                ;; When "regstack" is empty or something failed, we are done.
                (when' (or (zero? (count @regstack)) (== status RA_FAIL)) => (recur win scan)
                    ;; We get here only if there's trouble -- normally "case END" is the terminating point.
                    (let [win (if (nil? scan) (emsg win, e_re_corr) win)]
                        (when (== status RA_FAIL)
                            (reset! got_int true))
                        (reset! backpos nil)
                        (reset! regstack nil)
                        [win (== status RA_MATCH)]
                    ))
            ))
    ))

;; Create an item for the "regstack".

(defn- #_regitem_C reg-item
    ([state, scan]                      (regitem_C. state, scan,  0,    nil,     nil))
    ([state, scan, no, sesave, regsave] (regitem_C. state, scan, no, sesave, regsave)))

;; Pop an item from the "regstack".

(defn- #_Bytes pop-regitem []
    (let [rip #_regitem_C (... @regstack (- (count @regstack) 1))]
        (swap! regstack pop)
        (:ri_scan rip)
    ))

(defn- #_void drop-regbehind []
    (swap! regstack pop)
    nil)

(defn- #_void drop-regstar []
    (swap! regstack pop)
    nil)

;; Repeatedly match something simple, return how many.
;; Advances reginput (and reglnum) to just after the matched chars.

(defn- #_int regrepeat [#_Bytes p, #_long m] ;; m(axcount): maximum number of matches allowed
    (let [#_Bytes s @reginput #_long n 0
          ret- (fn [s n] (reset! reginput s) n)
          eor- (fn [p] (or (not (with-nl (re-op p))) (< @reg_lmax @reglnum)))
          fun- (fn [s n m p f t]
                    (let [[s n] (loop-when [s s n n] (< n m) => [s n]
                                    (cond (eos? s)
                                        (if (eor- p) [s n] (let [s (reg-nextline)] (if (fast-breakcheck) [s n] (recur s (inc n)))))
                                    (and (f s) (or t (not (asc-isdigit (.at s 0)))))
                                        (recur (.plus s (us-ptr2len-cc s)) (inc n))
                                    :else
                                        [s n]
                                    ))]
                        (ret- s n)
                    ))
          cls- (fn [s n m p e v]
                    (let [[s n] (loop-when [s s n n] (< n m) => [s n]
                                    (if (eos? s)
                                        (if (eor- p) [s n] (let [s (reg-nextline)] (if (fast-breakcheck) [s n] (recur s (inc n)))))
                                        (let [#_int l (us-ptr2len-cc s)]
                                            (cond
                                                (< 1 l)                           (if (zero? v) (recur (.plus s l) (inc n)) [s n])
                                                (== (& (... class_tab (char_u (.at s 0))) e) v) (recur (.plus s 1) (inc n))
                                                :else                                           [s n]
                                            ))
                                    ))]
                        (ret- s n)
                    ))
          any- (fn [s n m p t]
                    (let [#_Bytes op (operand p)
                          [s n] (loop-when [s s n n] (< n m) => [s n]
                                    (if (eos? s)
                                        (if (eor- p) [s n] (let [s (reg-nextline)] (if (fast-breakcheck) [s n] (recur s (inc n)))))
                                        (let [#_int l (us-ptr2len-cc s)]
                                            (if (< 1 l)
                                                (if (== (nil? (cstrchr op, (us-ptr2char s))) t) [s n] (recur (.plus s l) (inc n)))
                                                (if (== (nil? (cstrchr op, (.at s 0)))       t) [s n] (recur (.plus s 1) (inc n)))
                                            ))
                                    ))]
                        (ret- s n)
                    ))
          ident? #(vim-isidentc (us-ptr2char %))
          kword? us-iswordp
          fname? #(vim-isfnamec (us-ptr2char %))
          print? #(vim-isprintc (us-ptr2char %))]

        (condp ==? (re-op p)
            [ANY (+ ANY ADD_NL)]
                (let [[s n] (loop-when [s s n n] (< n m) => [s n]
                        ;; Matching anything means we continue until end-of-line (or end-of-file for ANY + ADD_NL), only limited by m(axcount).
                        (let [[s n] (loop-when-recur [s s n n] (and (non-eos? s) (< n m)) [(.plus s (us-ptr2len-cc s)) (inc n)] => [s n])]
                            (if (or (eor- p) (== n m)) [s n] (let [s (reg-nextline) n (inc n)] (if (fast-breakcheck) [s n] (recur s n)))) ;; count the line-break
                        ))]
                    (ret- s n))

            [IDENT (+ IDENT ADD_NL)] (fun- s n m p ident? true)         [SIDENT (+ SIDENT ADD_NL)] (fun- s n m p ident? false)
            [KWORD (+ KWORD ADD_NL)] (fun- s n m p kword? true)         [SKWORD (+ SKWORD ADD_NL)] (fun- s n m p kword? false)
            [FNAME (+ FNAME ADD_NL)] (fun- s n m p fname? true)         [SFNAME (+ SFNAME ADD_NL)] (fun- s n m p fname? false)
            [PRINT (+ PRINT ADD_NL)] (fun- s n m p print? true)         [SPRINT (+ SPRINT ADD_NL)] (fun- s n m p print? false)

            [WHITE (+ WHITE ADD_NL)] (cls- s n m p RI_WHITE RI_WHITE)   [NWHITE (+ NWHITE ADD_NL)] (cls- s n m p RI_WHITE 0)
            [DIGIT (+ DIGIT ADD_NL)] (cls- s n m p RI_DIGIT RI_DIGIT)   [NDIGIT (+ NDIGIT ADD_NL)] (cls- s n m p RI_DIGIT 0)
            [HEX   (+ HEX   ADD_NL)] (cls- s n m p RI_HEX   RI_HEX)     [NHEX   (+ NHEX   ADD_NL)] (cls- s n m p RI_HEX   0)
            [OCTAL (+ OCTAL ADD_NL)] (cls- s n m p RI_OCTAL RI_OCTAL)   [NOCTAL (+ NOCTAL ADD_NL)] (cls- s n m p RI_OCTAL 0)
            [WORD  (+ WORD  ADD_NL)] (cls- s n m p RI_WORD  RI_WORD)    [NWORD  (+ NWORD  ADD_NL)] (cls- s n m p RI_WORD  0)
            [HEAD  (+ HEAD  ADD_NL)] (cls- s n m p RI_HEAD  RI_HEAD)    [NHEAD  (+ NHEAD  ADD_NL)] (cls- s n m p RI_HEAD  0)
            [ALPHA (+ ALPHA ADD_NL)] (cls- s n m p RI_ALPHA RI_ALPHA)   [NALPHA (+ NALPHA ADD_NL)] (cls- s n m p RI_ALPHA 0)
            [LOWER (+ LOWER ADD_NL)] (cls- s n m p RI_LOWER RI_LOWER)   [NLOWER (+ NLOWER ADD_NL)] (cls- s n m p RI_LOWER 0)
            [UPPER (+ UPPER ADD_NL)] (cls- s n m p RI_UPPER RI_UPPER)   [NUPPER (+ NUPPER ADD_NL)] (cls- s n m p RI_UPPER 0)

            EXACTLY
                (let [#_Bytes op (operand p)
                      ;; This doesn't do a multi-byte character, because a MULTIBYTECODE would have
                      ;; been used for it.  It does handle single-byte characters, such as latin1.
                      [s n] (if @ireg_icase
                                (let [#_int cu (utf-toupper (.at op 0)) #_int cl (utf-tolower (.at op 0))]
                                    (loop-when-recur [s s n n] (and (< n m) (or (at? s cu) (at? s cl))) [(.plus s 1) (inc n)] => [s n]))
                                (let [#_int cu (.at op 0)]
                                    (loop-when-recur [s s n n] (and (< n m) (at? s cu)) [(.plus s 1) (inc n)] => [s n]))
                            )]
                    (ret- s n))

            MULTIBYTECODE
                (let [#_Bytes op (operand p) #_int l (us-ptr2len-cc op)
                      ;; Safety check (just in case 'encoding' was changed since compiling the program).
                      [s n] (if (< 1 l)
                                (let [#_int cf (if @ireg_icase (utf-fold (us-ptr2char op)) 0)]
                                    (loop-when [s s n n] (< n m) => [s n]
                                        (let [#_int i (loop-when-recur [i 0] (and (< i l) (at? op i (.at s i))) [(inc i)] => i)]
                                            (if (and (< i l) (or (not @ireg_icase) (!= (utf-fold (us-ptr2char s)) cf)))
                                                [s n]
                                                (recur (.plus s l) (inc n))
                                            ))
                                    ))
                                [s n]
                            )]
                    (ret- s n))

            [ANYOF (+ ANYOF ADD_NL)] (any- s n m p true)                [ANYBUT (+ ANYBUT ADD_NL)] (any- s n m p false)

            BT_NEWL
                (let [[s n] (loop-when [s s n n] (and (< n m) (eos? s) (<= @reglnum @reg_lmax)) => [s n]
                                (let [s (reg-nextline) n (inc n)] (if (fast-breakcheck) [s n] (recur s n)))
                            )]
                    (ret- s n))

            #_(do (swap! curwin emsg e_re_corr) (ret- s n)) ;; Oh dear, called inappropriately.
        )
    ))

;; Dig the "next" pointer out of a node.
;; Returns null when calculating size, when there is no next item and when there is an error.

(defn- #_Bytes regnext [#_Bytes p]
    (when-not (or (== p JUST_CALC_SIZE) @reg_toolong)
        (let [#_int offset (re-next p)]
            (when-not (zero? offset) (if (== (re-op p) BACK) (.minus p offset) (.plus p offset))))
    ))

;; Cleanup the subexpressions.

(defn- #_matcher_C cleanup-subexpr [#_matcher_C m]
    (let [_ (vec (repeat NSUBEXP LPOS-1))] (assoc m :m_startpos _ :m_endpos _)))

;; Save the current subexpr to "rb", so that they can be restored later by restore-subexpr().

(defn- #_regbehind_C save-subexpr [#_regbehind_C rb, #_matcher_C m]
    (assoc rb :rb_start (:m_startpos m) :rb_end (:m_endpos m)))

;; Restore the subexpr from "rb".

(defn- #_matcher_C restore-subexpr [#_matcher_C m, #_regbehind_C rb]
    (assoc m :m_startpos (:rb_start rb) :m_endpos (:rb_end rb)))

;; Advance "reginput" to the next char.

(defn- #_Bytes reg-nextchar []
    (swap! reginput #(.plus % (us-ptr2len-cc %))))

;; Advance "reglnum", "regline" and "reginput" to the next line.

(defn- #_Bytes reg-nextline []
    (reset! reginput (reset! regline (reg-getline (swap! reglnum inc)))))

;; Save the input line and position in a regsave_C.

(defn- #_regsave_C reg-save [#_backpos_C* bp]
    (regsave_C. @reglnum, (BDIFF @reginput, @regline), (count bp)))

;; Restore the input line and position from a regsave_C.

(defn- #_backpos_C* reg-restore [#_backpos_C* bp, #_regsave_C rs]
    ;; only call reg-getline() when the line number changed to save a bit of time
    (when (!= @reglnum (:rs_lnum rs))
        (reset! reglnum (:rs_lnum rs))
        (reset! regline (reg-getline @reglnum)))
    (reset! reginput (.plus @regline (:rs_col rs)))
    (subvec bp 0 (:rs_back rs)))

;; Return true if current position is equal to saved position.

(defn- #_boolean reg-save-equal [#_regsave_C rs]
    (and (== @reglnum (:rs_lnum rs)) (BEQ @reginput, (.plus @regline (:rs_col rs)))))

;; Compare a number with the operand of BT_LNUM, BT_COL or BT_VCOL.

(defn- #_boolean re-num-cmp [#_long val, #_Bytes scan]
    (let [#_long n (operand-min scan)]
        (condp == (operand-cmp scan) (byte \>) (> val n) (byte \<) (< val n) (== val n))
    ))

;; Check whether a backreference matches.
;; Returns RA_FAIL, RA_NIL or RA_MATCH.
;; If "len" is not null, it is set to the byte length of the match in the last line.

(defn- #_int match-with-backref [#_long start_lnum, #_int start_col, #_long end_lnum, #_int end_col, #_int' a'len]
    (when (some? a'len)
        (reset! a'len 0))
    (loop [#_long lnum start_lnum #_int col start_col]
        ;; Get the line to compare with.
        (let-when [#_Bytes p (reg-getline lnum)
                   a'n (atom (int (if (== lnum end_lnum) (- end_col col) (STRLEN p, col))))
        ] (zero? (cstrncmp (.plus p col), @reginput, a'n)) => RA_NIL ;; doesn't match
            (when (some? a'len)
                (swap! a'len + @a'n))
            (cond (== lnum end_lnum) ;; match and at end
                ;; Found a match!
                ;; Note that regline may now point to a copy of the line, that should not matter.
                RA_MATCH
            (<= @reg_lmax @reglnum) ;; text too short
                RA_NIL
            :else ;; Advance to next line.
                (do (reg-nextline)
                    (when (some? a'len)
                        (reset! a'len 0))
                    (if (fast-breakcheck)
                        RA_FAIL
                        (recur (inc lnum) 0)
                    ))
            ))
    ))

;; Used in a place where no * or \+ can follow.

(defn- #_[window_C boolean] re-mult-next? [#_window_C win, #_Bytes what]
    (when' (== (re-multi-type (peekchr)) MULTI_MULT) => [win true]
        (let [win (emsg* win, (u8 "E888: (NFA regexp) cannot repeat %s"), what)]
            (reset! rc_did_emsg true)
            [win false]
        )
    ))

(class! #_final decomp_C
    [
        (field int a) (field int b) (field int c)
    ])

;; 0xfb20 - 0xfb4f
(final decomp_C* decomp_table
    [
        (decomp_C.  0x5e2,     0,     0)   ;; 0xfb20   alt ayin
        (decomp_C.  0x5d0,     0,     0)   ;; 0xfb21   alt alef
        (decomp_C.  0x5d3,     0,     0)   ;; 0xfb22   alt dalet
        (decomp_C.  0x5d4,     0,     0)   ;; 0xfb23   alt he
        (decomp_C.  0x5db,     0,     0)   ;; 0xfb24   alt kaf
        (decomp_C.  0x5dc,     0,     0)   ;; 0xfb25   alt lamed
        (decomp_C.  0x5dd,     0,     0)   ;; 0xfb26   alt mem-sofit
        (decomp_C.  0x5e8,     0,     0)   ;; 0xfb27   alt resh
        (decomp_C.  0x5ea,     0,     0)   ;; 0xfb28   alt tav
        (decomp_C. (int \+),   0,     0)   ;; 0xfb29   alt plus
        (decomp_C.  0x5e9, 0x5c1,     0)   ;; 0xfb2a   shin+shin-dot
        (decomp_C.  0x5e9, 0x5c2,     0)   ;; 0xfb2b   shin+sin-dot
        (decomp_C.  0x5e9, 0x5c1, 0x5bc)   ;; 0xfb2c   shin+shin-dot+dagesh
        (decomp_C.  0x5e9, 0x5c2, 0x5bc)   ;; 0xfb2d   shin+sin-dot+dagesh
        (decomp_C.  0x5d0, 0x5b7,     0)   ;; 0xfb2e   alef+patah
        (decomp_C.  0x5d0, 0x5b8,     0)   ;; 0xfb2f   alef+qamats
        (decomp_C.  0x5d0, 0x5b4,     0)   ;; 0xfb30   alef+hiriq
        (decomp_C.  0x5d1, 0x5bc,     0)   ;; 0xfb31   bet+dagesh
        (decomp_C.  0x5d2, 0x5bc,     0)   ;; 0xfb32   gimel+dagesh
        (decomp_C.  0x5d3, 0x5bc,     0)   ;; 0xfb33   dalet+dagesh
        (decomp_C.  0x5d4, 0x5bc,     0)   ;; 0xfb34   he+dagesh
        (decomp_C.  0x5d5, 0x5bc,     0)   ;; 0xfb35   vav+dagesh
        (decomp_C.  0x5d6, 0x5bc,     0)   ;; 0xfb36   zayin+dagesh
        (decomp_C. 0xfb37,     0,     0)   ;; 0xfb37 - UNUSED
        (decomp_C.  0x5d8, 0x5bc,     0)   ;; 0xfb38   tet+dagesh
        (decomp_C.  0x5d9, 0x5bc,     0)   ;; 0xfb39   yud+dagesh
        (decomp_C.  0x5da, 0x5bc,     0)   ;; 0xfb3a   kaf sofit+dagesh
        (decomp_C.  0x5db, 0x5bc,     0)   ;; 0xfb3b   kaf+dagesh
        (decomp_C.  0x5dc, 0x5bc,     0)   ;; 0xfb3c   lamed+dagesh
        (decomp_C. 0xfb3d,     0,     0)   ;; 0xfb3d - UNUSED
        (decomp_C.  0x5de, 0x5bc,     0)   ;; 0xfb3e   mem+dagesh
        (decomp_C. 0xfb3f,     0,     0)   ;; 0xfb3f - UNUSED
        (decomp_C.  0x5e0, 0x5bc,     0)   ;; 0xfb40   nun+dagesh
        (decomp_C.  0x5e1, 0x5bc,     0)   ;; 0xfb41   samech+dagesh
        (decomp_C. 0xfb42,     0,     0)   ;; 0xfb42 - UNUSED
        (decomp_C.  0x5e3, 0x5bc,     0)   ;; 0xfb43   pe sofit+dagesh
        (decomp_C.  0x5e4, 0x5bc,     0)   ;; 0xfb44   pe+dagesh
        (decomp_C. 0xfb45,     0,     0)   ;; 0xfb45 - UNUSED
        (decomp_C.  0x5e6, 0x5bc,     0)   ;; 0xfb46   tsadi+dagesh
        (decomp_C.  0x5e7, 0x5bc,     0)   ;; 0xfb47   qof+dagesh
        (decomp_C.  0x5e8, 0x5bc,     0)   ;; 0xfb48   resh+dagesh
        (decomp_C.  0x5e9, 0x5bc,     0)   ;; 0xfb49   shin+dagesh
        (decomp_C.  0x5ea, 0x5bc,     0)   ;; 0xfb4a   tav+dagesh
        (decomp_C.  0x5d5, 0x5b9,     0)   ;; 0xfb4b   vav+holam
        (decomp_C.  0x5d1, 0x5bf,     0)   ;; 0xfb4c   bet+rafe
        (decomp_C.  0x5db, 0x5bf,     0)   ;; 0xfb4d   kaf+rafe
        (decomp_C.  0x5e4, 0x5bf,     0)   ;; 0xfb4e   pe+rafe
        (decomp_C.  0x5d0, 0x5dc,     0)   ;; 0xfb4f   alef-lamed
    ])

(defn- #_void mb-decompose [#_int c, #_int' a'c1, #_int' a'c2, #_int' a'c3]
    (if (<= 0xfb20 c 0xfb4f)
        (let [#_decomp_C d (... decomp_table (- c 0xfb20))]
            (reset! a'c1 (:a d))
            (reset! a'c2 (:b d))
            (reset! a'c3 (:c d))
        )
        (do
            (reset! a'c1 c)
            (reset! a'c2 0)
            (reset! a'c3 0)
        ))
    nil)

;; Compare two strings, ignore case if "ireg_icase" set.
;; Return 0 if strings match, non-zero otherwise.
;; Correct the length "*n" when composing characters are ignored.

(defn- #_int cstrncmp [#_Bytes s1, #_Bytes s2, #_int' a'n]
    (let-when [#_int cmp (if (not @ireg_icase) (STRNCMP s1, s2, @a'n) (us-strnicmp s1, s2, @a'n))] (and (non-zero? cmp) @ireg_icombine) => cmp
        ;; if it failed and it's utf8 and we want to combineignore
        (let [a's1 (atom (#_Bytes object s1)) a's2 (atom (#_Bytes object s2))
              ;; We have to handle the strcmp() ourselves, since it is necessary
              ;; to deal with the composing characters by ignoring them.
              cmp (loop-when [#_int c1 0 #_int c2 0] (< (BDIFF @a's1, s1) @a'n) => (- c2 c1)
                    (let [c1 (us-ptr2char-adv a's1, true) c2 (us-ptr2char-adv a's2, true)]
                        ;; Decompose the character if necessary into 'base' characters,
                        ;; because I don't care about Arabic, I will hard-code the Hebrew
                        ;; which I *do* care about!  So sue me...
                        (if (and (!= c1 c2) (or (not @ireg_icase) (!= (utf-fold c1) (utf-fold c2))))
                            (let [a'c1 (atom (int)) a'c2 (atom (int)) _ (atom (int))]
                                ;; decomposition necessary?
                                (mb-decompose c1, a'c1, _, _)
                                (mb-decompose c2, a'c2, _, _)
                                (let-when [c1 @a'c1 c2 @a'c2] (or (== @a'c1 @a'c2) (and @ireg_icase (== (utf-fold @a'c1) (utf-fold @a'c2)))) => (- c2 c1)
                                    (recur c1 c2)
                                ))
                            (recur c1 c2)
                        ))
                )]
            (when (zero? cmp)
                (reset! a'n (BDIFF @a's2, s2)))
            cmp)
    ))

;; This function is used a lot for simple searches, keep it fast!

(defn- #_Bytes cstrchr [#_Bytes s, #_int c]
    (if @ireg_icase
        (let-when [cc (cond (<= 0x80 c) (utf-fold c) (utf-isupper c) (utf-tolower c) (utf-islower c) (utf-toupper c))] (some? cc) => (vim-strchr s, c)
            (loop-when [i 0] (non-eos? s i) => nil
                (let-when [_ (cond (<= 0x80 c) (when (== (utf-fold (us-ptr2char s, i)) cc) i) (or (at? s i c) (at? s i cc)) i)] (nil? _) => (.plus s _)
                    (recur (+ i (us-ptr2len-cc s, i)))
                )))
        (vim-strchr s, c)
    ))

;; Replace tildes in the pattern by the old pattern.
;;
;; Short explanation of the tilde: It stands for the previous replacement pattern.
;; If that previous pattern also contains a ~ we should go back a step further...
;; But we insert the previous pattern into the current one and remember that.
;; This still does not handle the case where "magic" changes.
;; So require the user to keep his hands off of "magic".
;;
;; The tildes are parsed once before the first call to vim-regsub().

(defn- #_Bytes regtilde [#_Bytes source, #_boolean magic]
    (let [#_Bytes newsub
            (loop-when [newsub source #_Bytes s source] (non-eos? s) => newsub
                (if (or (and (at? s (byte \~)) magic) (and (at? s (byte \\)) (at? s 1 (byte \~)) (not magic)))
                    (cond (some? @reg_prev_sub)
                    (let [#_int m (STRLEN @reg_prev_sub)
                          #_Bytes t (Bytes. (+ (STRLEN newsub) m))
                          #_int n (BDIFF s, newsub)                     ;; not including ~
                          _ (BCOPY t, newsub, n)                        ;; copy prefix
                          _ (BCOPY t, n, @reg_prev_sub, 0, m)           ;; interpret tilde
                          s (if (not magic) (.plus s 1) s)              ;; back off \
                          _ (STRCPY (.plus t (+ n m)), (.plus s 1))]    ;; copy postfix
                        (recur t (.plus t (+ n m)))
                    )
                    magic
                    (let [_ (BCOPY s, 0, s, 1, (inc (STRLEN s, 1)))]    ;; remove '~'
                        (recur newsub s)
                    )
                    :else
                    (let [_ (BCOPY s, 0, s, 2, (inc (STRLEN s, 2)))]    ;; remove '\~'
                        (recur newsub s)
                    ))
                    (let [s (if (and (at? s (byte \\)) (non-eos? s 1)) (.plus s 1) s)]        ;; skip escaped characters
                        (recur newsub (.plus s (us-ptr2len-cc s)))
                    ))
            )]
        ;; if: "newsub" was allocated, just keep it ;; else: no ~ found, need to save "newsub"
        (reset! reg_prev_sub (if (BNE newsub, source) newsub (STRDUP newsub)))
        newsub
    ))

(atom! boolean can_f_submatch)          ;; true when submatch() can be used

(atom! Bytes eval_result)

(defn- #_int fun-regsub- [#_Bytes source, #_Bytes dest, #_boolean copy, #_boolean backslash]
    ;; To make sure that the length doesn't change between checking it and copying the string, and to speed up things,
    ;; the resulting string is saved from the call with "copy" == false to the call with "copy" == true.
    (let [#_Bytes d dest
          d (if copy
                (when' (some? @eval_result) => d
                    (let [_ (STRCPY d, @eval_result) d (.plus d (STRLEN @eval_result)) _ (reset! eval_result nil)]
                        d
                    ))
                ;; The expression may contain substitute(), which calls us recursively.
                ;; Make sure submatch() gets the text from the first level.
                (let [o'ireg_icase @ireg_icase _ (reset! can_f_submatch true)
                      _ (reset! eval_result (eval-to-string (.plus source 2)))
                      d (when' (some? @eval_result) => d
                            (let [#_boolean bs?
                                    (loop-when [bs? false #_Bytes s @eval_result] (non-eos? s) => bs?
                                        ;; Change NL to CR, so that it becomes a line break.
                                        ;; Skip over a backslashed character.
                                        (let [[s bs?]
                                                (cond (at? s NL)
                                                    [(.be s 0, CAR) bs?]
                                                (and (at? s (byte \\)) (non-eos? s 1))
                                                    (let [s (.plus s 1)]
                                                        ;; Change NL to CR here too, so that this works:
                                                        ;; :s/abc\\\ndef/\="aaa\\\nbbb"/  on text:
                                                        ;;   abc\
                                                        ;;   def
                                                        [(if (at? s NL) (.be s 0, CAR) s) true])
                                                :else
                                                    [s bs?]
                                                )]
                                            (recur bs? (.plus s (us-ptr2len-cc s))))
                                    )]
                                (when (and bs? backslash)
                                    ;; Backslashes will be consumed, need to double them.
                                    (swap! eval_result vim-strsave-escaped (u8 "\\"), (byte \\)))
                                (.plus d (STRLEN @eval_result))
                            ))
                      _ (reset! can_f_submatch false) _ (reset! ireg_icase o'ireg_icase)]
                    d)
            )]
        (when copy (eos! d))
        (inc (BDIFF d, dest))
    ))

(defn- #_[window_C int] lit-regsub- [#_window_C win, #_Bytes source, #_Bytes dest, #_boolean copy, #_boolean magic, #_boolean backslash]
    (let [f'one (atom (#_fn object nil)) f'all (atom (#_fn object nil))
          #_Bytes s source [win #_Bytes d]
            (loop-when [#_byte b (.at s 0) #_int no -1 s (.plus s 1) d dest] (!= b NUL) => [win (if copy (eos! d) d)]
                (let-when [[no s ?]
                        (cond (and (== b (byte \&)) magic)
                            [0 s nil]
                        (and (== b (byte \\)) (non-eos? s))
                            (cond (and (at? s (byte \&)) (not magic))
                                [0 (.plus s 1) nil]
                            (<= (byte \0) (.at s 0) (byte \9))
                                [(- (.at s 0) (byte \0)) (.plus s 1) nil]
                            :else
                                (when' (some? (vim-strbyte (u8 "uUlLeE"), (.at s 0))) => [no s nil]
                                    (condp ==? (.at s 0)
                                        (byte \u) (reset! f'one (fn   [a c] (reset! a (utf-toupper c)) nil))
                                        (byte \U) (reset! f'all (fn f [a c] (reset! a (utf-toupper c)) f))
                                        (byte \l) (reset! f'one (fn   [a c] (reset! a (utf-tolower c)) nil))
                                        (byte \L) (reset! f'all (fn f [a c] (reset! a (utf-tolower c)) f))
                                       [(byte \e)
                                        (byte \E)] (do (reset! f'one nil)
                                                       (reset! f'all nil)
                                            ))
                                    [no (.plus s 1) :recur]
                                ))
                        :else
                            [no s nil]
                        )
                ] (not ?) => (recur (.at s 0) no (.plus s 1) d)

                    (cond (< no 0) ;; Ordinary character.
                        (if (and (== b KB_SPECIAL) (non-eos? 0 s) (non-eos? s 1))
                            ;; Copy a special key as-is.
                            (let [d (if copy (-> d (.be 0, b) (.be 1, (.at s 0)) (.be 2, (.at s 1))) d)]
                                (recur (.at s 2) no (.plus s 3) (.plus d 3)))

                            (let [[b s #_int c d]
                                    (when' (and (== b (byte \\)) (non-eos? s)) => [b s (us-ptr2char s, -1) d]
                                        (let [[b d] ;; Check for abbreviations.
                                                (condp == (.at s 0)
                                                    (byte \r) [CAR    d]
                                                    (byte \n) [NL     d]
                                                    (byte \t) [TAB    d]
                                                 ;; (byte \e) [ESC    d] ;; Oh no!  \e already has meaning in subst. pat.
                                                    (byte \b) [Ctrl_H d]
                                                    ;; If "backslash" is true, the backslash will be removed later.
                                                    ;; Used to insert a literal CR.
                                                    (let [d (if backslash (-> (if copy (.be d 0, (byte \\)) d) (.plus 1)) d)]
                                                        [(.at s 0) d])
                                                )]
                                            [b (.plus s 1) (char_u b) d]
                                        ))
                                  ;; Write to buffer, if copy is set.
                                  a'c (atom (int))
                                  _ (cond
                                        (some? @f'one) (reset! f'one (@f'one a'c, c))
                                        (some? @f'all) (reset! f'all (@f'all a'c, c))
                                        :else          (reset! a'c c)) ;; just copy
                                  #_int cclen (us-ptr2len-cc s, -1)
                                  _ (when copy
                                        (utf-char2bytes @a'c, d))
                                  d (.plus d (dec (utf-char2len @a'c)))
                                  #_int clen (us-ptr2len s, -1)
                                  ;; If the character length is shorter than "cclen",
                                  ;; there are composing characters; copy them as-is.
                                  d (when' (< clen cclen) => d
                                        (when copy
                                            (BCOPY d, 1, s, (+ -1 clen), (- cclen clen)))
                                        (.plus d (- cclen clen)))
                                  s (.plus s (dec cclen))]
                                (recur (.at s 0) no (.plus s 1) (.plus d 1))
                            ))
                    :else
                        (let-when [startpos' (... (:m_startpos @reg_match) no) endpos' (... (:m_endpos @reg_match) no)
                              [#_Bytes q #_int l]
                                (when' (<= 0 (:lnum startpos') (:lnum endpos')) => [nil 0]
                                    (let [q (.plus (reg-getline (:lnum startpos')) (:col startpos'))
                                          l (if (== (:lnum endpos') (:lnum startpos')) (- (:col endpos') (:col startpos')) (STRLEN q))]
                                        [q l]
                                    ))
                              [d ?]
                                (when' (some? q) => [d nil]
                                    (loop [#_long lnum (:lnum startpos') q q l l d d]
                                        (cond (zero? l)
                                            (when' (< lnum (:lnum endpos')) => [d nil]
                                                (let [d (if copy (.be d 0, CAR) d) d (.plus d 1)
                                                      lnum (inc lnum) q (reg-getline lnum)
                                                      l (if (== (:lnum endpos') lnum) (:col endpos') (STRLEN q))]
                                                    (recur lnum q l d)
                                                ))
                                        (eos? q)
                                            [d :abort]
                                        :else
                                            (cond (and backslash (or (at? q CAR) (at? q (byte \\))))
                                                ;; Insert a backslash in front of a CR,
                                                ;; otherwise it will be replaced by a line break.
                                                ;; Number of backslashes will be halved later, double them here.
                                                (let [d (if copy (-> d (.be 0, (byte \\)) (.be 1, (.at q 0))) d)]
                                                    (recur lnum (.plus q 1) (dec l) (.plus d 2)))
                                            :else
                                                (let [a'c (atom (int)) #_int c (us-ptr2char q)
                                                      _ (cond
                                                            (some? @f'one) (reset! f'one (@f'one a'c, c))
                                                            (some? @f'all) (reset! f'all (@f'all a'c, c))
                                                            :else          (reset! a'c c)) ;; just copy
                                                      ;; Copy composing characters separately, one at a time.
                                                      #_int clen (us-ptr2len q)]
                                                    (when copy
                                                        (utf-char2bytes @a'c, d))
                                                    (recur lnum (.plus q clen) (- l clen) (.plus d (utf-char2len @a'c)))
                                                ))
                                        ))
                                )] (not ?) => [(if copy (emsg win, e_re_damg) win) d]

                            (recur (.at s 0) -1 (.plus s 1) d))
                    ))
            )]
        [win (inc (BDIFF d, dest))]
    ))

;; Perform substitutions after a vim-regexec() match.
;;
;; If "copy" is true, really copy into "dest".
;; If "copy" is false, nothing is copied, this is just to find out the length of the result.
;;
;; If "backslash" is true, a backslash will be removed later, need to double them to keep them,
;; and insert a backslash before a CR to avoid it being replaced with a line break later.
;;
;; Note: The matched text must not change between the call of vim-regexec() and vim-regsub()!
;; It would make the back references invalid!
;;
;; Returns the size of the replacement, including terminating NUL.

(defn- #_[window_C int] vim-regsub? [#_window_C win, #_matcher_C matcher, #_long lnum, #_Bytes source, #_Bytes dest, #_boolean copy, #_boolean magic, #_boolean backslash]
    (reset! reg_match matcher)
    (reset! reg_lmin lnum)
    (reset! reg_lmax (- (line-count @curbuf) lnum))
    (when' (and (some? source) (some? dest)) => [(emsg win, e_null) 0] ;; Be paranoid...
        ;; When the substitute part starts with "\=", evaluate it as an expression.
        (if (and (at? source 0 (byte \\)) (at? source 1 (byte \=)) (not @can_f_submatch)) ;; can't do this recursively
            [win (fun-regsub- source, dest, copy, backslash)]
            (lit-regsub- win, source, dest, copy, magic, backslash)
        )
    ))

;;; ============================================================================================== VimO

;; NFA regular expression implementation.

;; Added to NFA_ANY - NFA_NUPPER_IC to include a NL.
(final int NFA_ADD_NL 31)

(final int
    NFA_SPLIT -1024,
    NFA_MATCH -1023,
    NFA_EMPTY -1022,                      ;; matches 0-length

    NFA_START_COLL -1021,                 ;; [abc] start
    NFA_END_COLL -1020,                   ;; [abc] end
    NFA_START_NEG_COLL -1019,             ;; [^abc] start
    NFA_END_NEG_COLL -1018,               ;; [^abc] end (postfix only)
    NFA_RANGE -1017,                      ;; range of the two previous items (postfix only)
    NFA_RANGE_MIN -1016,                  ;; low end of a range
    NFA_RANGE_MAX -1015,                  ;; high end of a range

    NFA_CONCAT -1014,                     ;; concatenate two previous items (postfix only)
    NFA_OR -1013,                         ;; \| (postfix only)
    NFA_STAR -1012,                       ;; greedy * (postfix only)
    NFA_STAR_NONGREEDY -1011,             ;; non-greedy * (postfix only)
    NFA_QUEST -1010,                      ;; greedy \? (postfix only)
    NFA_QUEST_NONGREEDY -1009,            ;; non-greedy \? (postfix only)

    NFA_BOL -1008,                        ;; ^    Begin line
    NFA_EOL -1007,                        ;; $    End line
    NFA_BOW -1006,                        ;; \<   Begin word
    NFA_EOW -1005,                        ;; \>   End word
    NFA_BOF -1004,                        ;; \%^  Begin file
    NFA_EOF -1003,                        ;; \%$  End file
    NFA_NEWL -1002,
    NFA_ZSTART -1001,                     ;; Used for \zs
    NFA_ZEND -1000,                       ;; Used for \ze
    NFA_NOPEN -999,                       ;; Start of subexpression marked with \%(     ;; sic!)
    NFA_NCLOSE -998,                      ;; End of subexpr. marked with \%( ... \)     ;; sic!)
    NFA_START_INVISIBLE -997,
    NFA_START_INVISIBLE_FIRST -996,
    NFA_START_INVISIBLE_NEG -995,
    NFA_START_INVISIBLE_NEG_FIRST -994,
    NFA_START_INVISIBLE_BEFORE -993,
    NFA_START_INVISIBLE_BEFORE_FIRST -992,
    NFA_START_INVISIBLE_BEFORE_NEG -991,
    NFA_START_INVISIBLE_BEFORE_NEG_FIRST -990,
    NFA_START_PATTERN -989,
    NFA_END_INVISIBLE -988,
    NFA_END_INVISIBLE_NEG -987,
    NFA_END_PATTERN -986,
    NFA_COMPOSING -985,                   ;; Next nodes in NFA are part of the composing multibyte char
    NFA_END_COMPOSING -984,               ;; End of a composing char in the NFA
    NFA_ANY_COMPOSING -983,               ;; \%C: Any composing characters.
    NFA_OPT_CHARS -982,                   ;; \%[abc]

    ;; The following are used only in the postfix form, not in the NFA.
    NFA_PREV_ATOM_NO_WIDTH -981,          ;; Used for \@=
    NFA_PREV_ATOM_NO_WIDTH_NEG -980,      ;; Used for \@!
    NFA_PREV_ATOM_JUST_BEFORE -979,       ;; Used for \@<=
    NFA_PREV_ATOM_JUST_BEFORE_NEG -978,   ;; Used for \@<!
    NFA_PREV_ATOM_LIKE_PATTERN -977,      ;; Used for \@>

    NFA_BACKREF1 -976,                    ;; \1
    NFA_BACKREF2 -975,                    ;; \2
    NFA_BACKREF3 -974,                    ;; \3
    NFA_BACKREF4 -973,                    ;; \4
    NFA_BACKREF5 -972,                    ;; \5
    NFA_BACKREF6 -971,                    ;; \6
    NFA_BACKREF7 -970,                    ;; \7
    NFA_BACKREF8 -969,                    ;; \8
    NFA_BACKREF9 -968,                    ;; \9

    NFA_SKIP -958,                        ;; Skip characters

    NFA_MOPEN -957,
    NFA_MOPEN1 -956,
    NFA_MOPEN2 -955,
    NFA_MOPEN3 -954,
    NFA_MOPEN4 -953,
    NFA_MOPEN5 -952,
    NFA_MOPEN6 -951,
    NFA_MOPEN7 -950,
    NFA_MOPEN8 -949,
    NFA_MOPEN9 -948,

    NFA_MCLOSE -947,
    NFA_MCLOSE1 -946,
    NFA_MCLOSE2 -945,
    NFA_MCLOSE3 -944,
    NFA_MCLOSE4 -943,
    NFA_MCLOSE5 -942,
    NFA_MCLOSE6 -941,
    NFA_MCLOSE7 -940,
    NFA_MCLOSE8 -939,
    NFA_MCLOSE9 -938,

    ;; NFA_FIRST_NL
    NFA_ANY -917,                        ;; Match any one character.
    NFA_IDENT -916,                      ;; Match identifier char
    NFA_SIDENT -915,                     ;; Match identifier char but no digit
    NFA_KWORD -914,                      ;; Match keyword char
    NFA_SKWORD -913,                     ;; Match word char but no digit
    NFA_FNAME -912,                      ;; Match file name char
    NFA_SFNAME -911,                     ;; Match file name char but no digit
    NFA_PRINT -910,                      ;; Match printable char
    NFA_SPRINT -909,                     ;; Match printable char but no digit
    NFA_WHITE -908,                      ;; Match whitespace char
    NFA_NWHITE -907,                     ;; Match non-whitespace char
    NFA_DIGIT -906,                      ;; Match digit char
    NFA_NDIGIT -905,                     ;; Match non-digit char
    NFA_HEX -904,                        ;; Match hex char
    NFA_NHEX -903,                       ;; Match non-hex char
    NFA_OCTAL -902,                      ;; Match octal char
    NFA_NOCTAL -901,                     ;; Match non-octal char
    NFA_WORD -900,                       ;; Match word char
    NFA_NWORD -899,                      ;; Match non-word char
    NFA_HEAD -898,                       ;; Match head char
    NFA_NHEAD -897,                      ;; Match non-head char
    NFA_ALPHA -896,                      ;; Match alpha char
    NFA_NALPHA -895,                     ;; Match non-alpha char
    NFA_LOWER -894,                      ;; Match lowercase char
    NFA_NLOWER -893,                     ;; Match non-lowercase char
    NFA_UPPER -892,                      ;; Match uppercase char
    NFA_NUPPER -891,                     ;; Match non-uppercase char
    NFA_LOWER_IC -890,                   ;; Match [a-z]
    NFA_NLOWER_IC -889,                  ;; Match [^a-z]
    NFA_UPPER_IC -888,                   ;; Match [A-Z]
    NFA_NUPPER_IC -887,                  ;; Match [^A-Z]

    NFA_FIRST_NL (+ NFA_ANY NFA_ADD_NL),
    NFA_LAST_NL (+ NFA_NUPPER_IC NFA_ADD_NL),

    NFA_CURSOR -855,                     ;; Match cursor pos
    NFA_LNUM -854,                       ;; Match line number
    NFA_LNUM_GT -853,                    ;; Match > line number
    NFA_LNUM_LT -852,                    ;; Match < line number
    NFA_COL -851,                        ;; Match cursor column
    NFA_COL_GT -850,                     ;; Match > cursor column
    NFA_COL_LT -849,                     ;; Match < cursor column
    NFA_VCOL -848,                       ;; Match cursor virtual column
    NFA_VCOL_GT -847,                    ;; Match > cursor virtual column
    NFA_VCOL_LT -846,                    ;; Match < cursor virtual column
    NFA_MARK -845,                       ;; Match mark
    NFA_MARK_GT -844,                    ;; Match > mark
    NFA_MARK_LT -843,                    ;; Match < mark
    NFA_VISUAL -842,                     ;; Match Visual area

    ;; Character classes [:alnum:] etc.
    NFA_CLASS_ALNUM -841,
    NFA_CLASS_ALPHA -840,
    NFA_CLASS_BLANK -839,
    NFA_CLASS_CNTRL -838,
    NFA_CLASS_DIGIT -837,
    NFA_CLASS_GRAPH -836,
    NFA_CLASS_LOWER -835,
    NFA_CLASS_PRINT -834,
    NFA_CLASS_PUNCT -833,
    NFA_CLASS_SPACE -832,
    NFA_CLASS_UPPER -831,
    NFA_CLASS_XDIGIT -830,
    NFA_CLASS_TAB -829,
    NFA_CLASS_RETURN -828,
    NFA_CLASS_BACKSPACE -827,
    NFA_CLASS_ESCAPE -826)

;; Keep in sync with "classchars".
(final int* nfa_classcodes
    [
        NFA_ANY, NFA_IDENT, NFA_SIDENT, NFA_KWORD, NFA_SKWORD,
        NFA_FNAME, NFA_SFNAME, NFA_PRINT, NFA_SPRINT,
        NFA_WHITE, NFA_NWHITE, NFA_DIGIT, NFA_NDIGIT,
        NFA_HEX, NFA_NHEX, NFA_OCTAL, NFA_NOCTAL,
        NFA_WORD, NFA_NWORD, NFA_HEAD, NFA_NHEAD,
        NFA_ALPHA, NFA_NALPHA, NFA_LOWER, NFA_NLOWER,
        NFA_UPPER, NFA_NUPPER
    ])

(final Bytes
    e_nul_found      (u8 "E865: (NFA) Regexp end encountered prematurely"),
    e_misplaced      (u8 "E866: (NFA regexp) Misplaced %c"),
    e_ill_char_class (u8 "E877: (NFA regexp) Invalid character class: %ld"))

;; re_flags passed to nfa-regcomp()
(atom! int nfa_re_flags)

;; NFA regexp \ze operator encountered.
(atom! boolean nfa_has_zend)

;; NFA regexp \1 .. \9 encountered.
(atom! boolean nfa_has_backref)

(atom! int* post_array) ;; holds the postfix form of r.e.

;; If not null, match must end at this position.
(atom! lpos_C nfa_endp)

;; "nfa_listid" is global, so that it increases on recursive calls to nfa-regmatch().

(atom! int nfa_listid)

;; Initialize internal variables before NFA compilation.

(defn- #_void nfa-regcomp-start [#_Bytes expr, #_int re_flags]
    ;; re_flags: see vim-regcomp()
    (reset! post_array [])
    (reset! nfa_has_zend false)
    (reset! nfa_has_backref false)
    ;; shared with BT engine
    (regcomp-start expr, re_flags)
    nil)

;; Figure out if the NFA state list starts with an anchor, must match at start of the line.

(defn- #_boolean nfa-get-reganch [#_nfa_state_C start, #_int depth]
    (if (< 4 depth)
        false
        (loop-when [#_nfa_state_C state start] (some? state) => false
            (condp ==? (:c state)
               [NFA_BOL
                NFA_BOF]
                    true ;; yes!

               [NFA_ZSTART
                NFA_ZEND
                NFA_CURSOR
                NFA_VISUAL

                NFA_MOPEN
                NFA_MOPEN1
                NFA_MOPEN2
                NFA_MOPEN3
                NFA_MOPEN4
                NFA_MOPEN5
                NFA_MOPEN6
                NFA_MOPEN7
                NFA_MOPEN8
                NFA_MOPEN9
                NFA_NOPEN]
                    (recur (out0 state))

                NFA_SPLIT
                    (and (nfa-get-reganch (out0 state), (inc depth)) (nfa-get-reganch (out1 state), (inc depth)))

             ;; :else
                false ;; noooo!
            ))
    ))

;; Figure out if the NFA state list starts with a character which must match at start of the match.

(defn- #_int nfa-get-regstart [#_nfa_state_C start, #_int depth]
    (if (< 4 depth)
        0
        (loop-when [#_nfa_state_C state start] (some? state) => 0
            (condp ==? (:c state)
                ;; all kinds of zero-width matches
               [NFA_BOL
                NFA_BOF
                NFA_BOW
                NFA_EOW
                NFA_ZSTART
                NFA_ZEND
                NFA_CURSOR
                NFA_VISUAL
                NFA_LNUM
                NFA_LNUM_GT
                NFA_LNUM_LT
                NFA_COL
                NFA_COL_GT
                NFA_COL_LT
                NFA_VCOL
                NFA_VCOL_GT
                NFA_VCOL_LT
                NFA_MARK
                NFA_MARK_GT
                NFA_MARK_LT

                NFA_MOPEN
                NFA_MOPEN1
                NFA_MOPEN2
                NFA_MOPEN3
                NFA_MOPEN4
                NFA_MOPEN5
                NFA_MOPEN6
                NFA_MOPEN7
                NFA_MOPEN8
                NFA_MOPEN9
                NFA_NOPEN]
                    (recur (out0 state))

                NFA_SPLIT
                    (let [l (nfa-get-regstart (out0 state), (inc depth)) r (nfa-get-regstart (out1 state), (inc depth))]
                        (if (== l r) l 0))

             ;; :else
                (max 0 (:c state))
            ))
    ))

;; Figure out if the NFA state list contains just literal text and nothing else.
;; If so return a string in allocated memory with what must match after regstart.
;; Otherwise return null.

(defn- #_Bytes nfa-get-match-text [#_nfa_state_C start]
    (let-when [p start] (== (:c p) NFA_MOPEN) => nil
        (let-when [[n p] (loop-when-recur [n 0 p (out0 p)] (< 0 (:c p)) [(+ n (utf-char2len (:c p))) (out0 p)] => [n p])]
                  (and (== (:c p) NFA_MCLOSE) (== (:c (out0 p)) NFA_MATCH)) => nil
            (let [q (Bytes. n) ;; skip first char, it goes into regstart
                  _ (loop-when-recur [s q p (-> start (out0) (out0))] (< 0 (:c p)) [(.plus s (utf-char2bytes (:c p), s)) (out0 p)] => (eos! s))]
            q))
    ))

;; Search between "start" and "end" and try to recognize a character class in expanded form.
;; For example [0-9].
;; On success, return the id the character class to be emitted.
;; On failure, return 0 (=false).
;; Start points to the first char of the range, while end should point to the closing brace.
;; Keep in mind that 'ignorecase' applies at execution time,
;; thus [a-z] may need to be interpreted as [a-zA-Z].

(final int
    CLASS_not        0x80,
    CLASS_af         0x40,
    CLASS_AF         0x20,
    CLASS_az         0x10,
    CLASS_AZ         0x08,
    CLASS_o7         0x04,
    CLASS_o9         0x02,
    CLASS_underscore 0x01)

(defn- #_int nfa-recognize-char-class [#_Bytes start, #_Bytes end, #_boolean newl]
    (if (not-at? end (byte \]))
        0
        (let-when [[#_int x #_Bytes p] (if (at? start (byte \^)) [CLASS_not (.plus start 1)] [0 start])
              [x p newl :as _]
                (loop-when [x x p p newl newl] (BLT p, end) => [x p newl]
                    (cond (and (BLT (.plus p 2), end) (at? p 1 (byte \-)))
                        (let-when [x (condp == (.at p 0)
                                    (byte \0) (condp == (.at p 2) (byte \9) (| x CLASS_o9) (byte \7) (| x CLASS_o7) nil)
                                    (byte \a) (condp == (.at p 2) (byte \z) (| x CLASS_az) (byte \f) (| x CLASS_af) nil)
                                    (byte \A) (condp == (.at p 2) (byte \Z) (| x CLASS_AZ) (byte \F) (| x CLASS_AF) nil)
                                nil)] (some? x) => nil
                            (recur x (.plus p 3) newl))
                    (and (BLT (.plus p 1), end) (at? p (byte \\)) (at? p 1 (byte \n)))
                        (recur x (.plus p 2) true)
                    (at? p (byte \_))
                        (recur (| x CLASS_underscore) (.plus p 1) newl)
                    (at? p (byte \newline))
                        (recur x (.plus p 1) true)
                    ))
        ] (some? _) => 0
            (if (BNE p, end)
                0
                (let [#_int nfa_add_nl (if newl NFA_ADD_NL 0)]
                    (condp == x
                        CLASS_o9                                               (+ nfa_add_nl NFA_DIGIT)
                     (| CLASS_not CLASS_o9)                                    (+ nfa_add_nl NFA_NDIGIT)
                     (| CLASS_af CLASS_AF CLASS_o9)                            (+ nfa_add_nl NFA_HEX)
                     (| CLASS_not CLASS_af CLASS_AF CLASS_o9)                  (+ nfa_add_nl NFA_NHEX)
                        CLASS_o7                                               (+ nfa_add_nl NFA_OCTAL)
                     (| CLASS_not CLASS_o7)                                    (+ nfa_add_nl NFA_NOCTAL)
                     (| CLASS_az CLASS_AZ CLASS_o9 CLASS_underscore)           (+ nfa_add_nl NFA_WORD)
                     (| CLASS_not CLASS_az CLASS_AZ CLASS_o9 CLASS_underscore) (+ nfa_add_nl NFA_NWORD)
                     (| CLASS_az CLASS_AZ CLASS_underscore)                    (+ nfa_add_nl NFA_HEAD)
                     (| CLASS_not CLASS_az CLASS_AZ CLASS_underscore)          (+ nfa_add_nl NFA_NHEAD)
                     (| CLASS_az CLASS_AZ)                                     (+ nfa_add_nl NFA_ALPHA)
                     (| CLASS_not CLASS_az CLASS_AZ)                           (+ nfa_add_nl NFA_NALPHA)
                        CLASS_az                                               (+ nfa_add_nl NFA_LOWER_IC)
                     (| CLASS_not CLASS_az)                                    (+ nfa_add_nl NFA_NLOWER_IC)
                        CLASS_AZ                                               (+ nfa_add_nl NFA_UPPER_IC)
                     (| CLASS_not CLASS_AZ)                                    (+ nfa_add_nl NFA_NUPPER_IC)
                0))
            ))
    ))

;; Helper functions used when doing re2post() ... bt-regatom() parsing.

(defn- #_boolean emc1 [& #_int* c*]
    (apply swap! post_array conj c*)
    true)

(defn- #_boolean emc2 [& #_int* c*]
    (apply swap! post_array conj (interleave c* (repeat NFA_CONCAT)))
    true)

;; Produce the bytes for equivalence class "c".
;;
;; Emits bytes in postfix notation:
;; 'a b NFA_OR c NFA_OR' is equivalent to 'a OR b OR c'.
;;
;; NOTE! When changing this function, also update reg-equi-class()

(defn- #_boolean nfa-emit-equi-class [#_int c]
    (condp ==? c
       [      (byte \A), 0xc0 0xc1 0xc2, 0xc3 0xc4 0xc5, 0x100 0x102 0x104, 0x1cd 0x1de 0x1e0, 0x1ea2]
        (emc2 (byte \A), 0xc0 0xc1 0xc2, 0xc3 0xc4 0xc5, 0x100 0x102 0x104, 0x1cd 0x1de 0x1e0, 0x1ea2)

       [      (byte \a), 0xe0 0xe1 0xe2, 0xe3 0xe4 0xe5, 0x101 0x103 0x105, 0x1ce 0x1df 0x1e1, 0x1ea3]
        (emc2 (byte \a), 0xe0 0xe1 0xe2, 0xe3 0xe4 0xe5, 0x101 0x103 0x105, 0x1ce 0x1df 0x1e1, 0x1ea3)

       [      (byte \B), 0x1e02 0x1e06]
        (emc2 (byte \B), 0x1e02 0x1e06)

       [      (byte \b), 0x1e03 0x1e07]
        (emc2 (byte \b), 0x1e03 0x1e07)

       [      (byte \C), 0xc7, 0x106 0x108 0x10a 0x10c]
        (emc2 (byte \C), 0xc7, 0x106 0x108 0x10a 0x10c)

       [      (byte \c), 0xe7, 0x107 0x109 0x10b 0x10d]
        (emc2 (byte \c), 0xe7, 0x107 0x109 0x10b 0x10d)

       [      (byte \D), 0x10e 0x110, 0x1e0a 0x1e0c 0x1e0e 0x1e10 0x1e12]
        (emc2 (byte \D), 0x10e 0x110, 0x1e0a 0x1e0c 0x1e0e 0x1e10 0x1e12)

       [      (byte \d), 0x10f 0x111, 0x1e0b 0x1e0d 0x1e0f 0x1e11 0x1e13]
        (emc2 (byte \d), 0x10f 0x111, 0x1e0b 0x1e0d 0x1e0f 0x1e11 0x1e13)

       [      (byte \E), 0xc8 0xc9 0xca 0xcb, 0x112 0x114 0x116 0x118 0x11a, 0x1eba 0x1ebc]
        (emc2 (byte \E), 0xc8 0xc9 0xca 0xcb, 0x112 0x114 0x116 0x118 0x11a, 0x1eba 0x1ebc)

       [      (byte \e), 0xe8 0xe9 0xea 0xeb, 0x113 0x115 0x117 0x119 0x11b, 0x1ebb 0x1ebd]
        (emc2 (byte \e), 0xe8 0xe9 0xea 0xeb, 0x113 0x115 0x117 0x119 0x11b, 0x1ebb 0x1ebd)

       [      (byte \F), 0x1e1e]
        (emc2 (byte \F), 0x1e1e)

       [      (byte \f), 0x1e1f]
        (emc2 (byte \f), 0x1e1f)

       [      (byte \G), 0x11c 0x11e 0x120 0x122, 0x1e4 0x1e6 0x1f4, 0x1e20]
        (emc2 (byte \G), 0x11c 0x11e 0x120 0x122, 0x1e4 0x1e6 0x1f4, 0x1e20)

       [      (byte \g), 0x11d 0x11f 0x121 0x123, 0x1e5 0x1e7 0x1f5, 0x1e21]
        (emc2 (byte \g), 0x11d 0x11f 0x121 0x123, 0x1e5 0x1e7 0x1f5, 0x1e21)

       [      (byte \H), 0x124 0x126, 0x1e22 0x1e26 0x1e28]
        (emc2 (byte \H), 0x124 0x126, 0x1e22 0x1e26 0x1e28)

       [      (byte \h), 0x125 0x127, 0x1e23 0x1e27 0x1e29 0x1e96]
        (emc2 (byte \h), 0x125 0x127, 0x1e23 0x1e27 0x1e29 0x1e96)

       [      (byte \I), 0xcc 0xcd 0xce 0xcf, 0x128 0x12a 0x12c 0x12e 0x130, 0x1cf, 0x1ec8]
        (emc2 (byte \I), 0xcc 0xcd 0xce 0xcf, 0x128 0x12a 0x12c 0x12e 0x130, 0x1cf, 0x1ec8)

       [      (byte \i), 0xec 0xed 0xee 0xef, 0x129 0x12b 0x12d 0x12f 0x131, 0x1d0, 0x1ec9]
        (emc2 (byte \i), 0xec 0xed 0xee 0xef, 0x129 0x12b 0x12d 0x12f 0x131, 0x1d0, 0x1ec9)

       [      (byte \J), 0x134]
        (emc2 (byte \J), 0x134)

       [      (byte \j), 0x135 0x1f0]
        (emc2 (byte \j), 0x135 0x1f0)

       [      (byte \K), 0x136 0x1e8, 0x1e30 0x1e34]
        (emc2 (byte \K), 0x136 0x1e8, 0x1e30 0x1e34)

       [      (byte \k), 0x137 0x1e9, 0x1e31 0x1e35]
        (emc2 (byte \k), 0x137 0x1e9, 0x1e31 0x1e35)

       [      (byte \L), 0x139 0x13b 0x13d 0x13f 0x141, 0x1e3a]
        (emc2 (byte \L), 0x139 0x13b 0x13d 0x13f 0x141, 0x1e3a)

       [      (byte \l), 0x13a 0x13c 0x13e 0x140 0x142, 0x1e3b]
        (emc2 (byte \l), 0x13a 0x13c 0x13e 0x140 0x142, 0x1e3b)

       [      (byte \M), 0x1e3e 0x1e40]
        (emc2 (byte \M), 0x1e3e 0x1e40)

       [      (byte \m), 0x1e3f 0x1e41]
        (emc2 (byte \m), 0x1e3f 0x1e41)

       [      (byte \N), 0xd1, 0x143 0x145 0x147, 0x1e44 0x1e48]
        (emc2 (byte \N), 0xd1, 0x143 0x145 0x147, 0x1e44 0x1e48)

       [      (byte \n), 0xf1, 0x144 0x146 0x148 0x149, 0x1e45 0x1e49]
        (emc2 (byte \n), 0xf1, 0x144 0x146 0x148 0x149, 0x1e45 0x1e49)

       [      (byte \O), 0xd2 0xd3 0xd4, 0xd5 0xd6 0xd8, 0x14c 0x14e 0x150, 0x1a0 0x1d1 0x1ea 0x1ec, 0x1ece]
        (emc2 (byte \O), 0xd2 0xd3 0xd4, 0xd5 0xd6 0xd8, 0x14c 0x14e 0x150, 0x1a0 0x1d1 0x1ea 0x1ec, 0x1ece)

       [      (byte \o), 0xf2 0xf3 0xf4, 0xf5 0xf6 0xf8, 0x14d 0x14f 0x151, 0x1a1 0x1d2 0x1eb 0x1ed, 0x1ecf]
        (emc2 (byte \o), 0xf2 0xf3 0xf4, 0xf5 0xf6 0xf8, 0x14d 0x14f 0x151, 0x1a1 0x1d2 0x1eb 0x1ed, 0x1ecf)

       [      (byte \P), 0x1e54 0x1e56]
        (emc2 (byte \P), 0x1e54 0x1e56)

       [      (byte \p), 0x1e55 0x1e57]
        (emc2 (byte \p), 0x1e55 0x1e57)

       [      (byte \R), 0x154 0x156 0x158, 0x1e58 0x1e5e]
        (emc2 (byte \R), 0x154 0x156 0x158, 0x1e58 0x1e5e)

       [      (byte \r), 0x155 0x157 0x159, 0x1e59 0x1e5f]
        (emc2 (byte \r), 0x155 0x157 0x159, 0x1e59 0x1e5f)

       [      (byte \S), 0x15a 0x15c 0x15e 0x160, 0x1e60]
        (emc2 (byte \S), 0x15a 0x15c 0x15e 0x160, 0x1e60)

       [      (byte \s), 0x15b 0x15d 0x15f 0x161, 0x1e61]
        (emc2 (byte \s), 0x15b 0x15d 0x15f 0x161, 0x1e61)

       [      (byte \T), 0x162 0x164 0x166, 0x1e6a 0x1e6e]
        (emc2 (byte \T), 0x162 0x164 0x166, 0x1e6a 0x1e6e)

       [      (byte \t), 0x163 0x165 0x167, 0x1e6b 0x1e6f 0x1e97]
        (emc2 (byte \t), 0x163 0x165 0x167, 0x1e6b 0x1e6f 0x1e97)

       [      (byte \U), 0xd9 0xda 0xdb 0xdc, 0x168 0x16a 0x16c 0x16e, 0x170 0x172 0x1af 0x1d3, 0x1ee6]
        (emc2 (byte \U), 0xd9 0xda 0xdb 0xdc, 0x168 0x16a 0x16c 0x16e, 0x170 0x172 0x1af 0x1d3, 0x1ee6)

       [      (byte \u), 0xf9 0xfa 0xfb 0xfc, 0x169 0x16b 0x16d 0x16f, 0x171 0x173 0x1b0 0x1d4, 0x1ee7]
        (emc2 (byte \u), 0xf9 0xfa 0xfb 0xfc, 0x169 0x16b 0x16d 0x16f, 0x171 0x173 0x1b0 0x1d4, 0x1ee7)

       [      (byte \V), 0x1e7c]
        (emc2 (byte \V), 0x1e7c)

       [      (byte \v), 0x1e7d]
        (emc2 (byte \v), 0x1e7d)

       [      (byte \W), 0x174, 0x1e80 0x1e82 0x1e84 0x1e86]
        (emc2 (byte \W), 0x174, 0x1e80 0x1e82 0x1e84 0x1e86)

       [      (byte \w), 0x175, 0x1e81 0x1e83 0x1e85 0x1e87 0x1e98]
        (emc2 (byte \w), 0x175, 0x1e81 0x1e83 0x1e85 0x1e87 0x1e98)

       [      (byte \X), 0x1e8a 0x1e8c]
        (emc2 (byte \X), 0x1e8a 0x1e8c)

       [      (byte \x), 0x1e8b 0x1e8d]
        (emc2 (byte \x), 0x1e8b 0x1e8d)

       [      (byte \Y), 0xdd, 0x176 0x178, 0x1e8e 0x1ef2 0x1ef6 0x1ef8]
        (emc2 (byte \Y), 0xdd, 0x176 0x178, 0x1e8e 0x1ef2 0x1ef6 0x1ef8)

       [      (byte \y), 0xfd 0xff, 0x177, 0x1e8f 0x1e99 0x1ef3 0x1ef7 0x1ef9]
        (emc2 (byte \y), 0xfd 0xff, 0x177, 0x1e8f 0x1e99 0x1ef3 0x1ef7 0x1ef9)

       [      (byte \Z), 0x179 0x17b 0x17d 0x1b5, 0x1e90 0x1e94]
        (emc2 (byte \Z), 0x179 0x17b 0x17d 0x1b5, 0x1e90 0x1e94)

       [      (byte \z), 0x17a 0x17c 0x17e 0x1b6, 0x1e91 0x1e95]
        (emc2 (byte \z), 0x17a 0x17c 0x17e 0x1b6, 0x1e91 0x1e95)

        ;; default: character itself
        (emc2 c)
    ))

;; Code to parse regular expression.
;;
;; We try to reuse parsing functions in regexp.c to
;; minimize surprise and keep the syntax consistent.

(defn- #_[window_C boolean] nfa-regcoll- [#_window_C win, #_int c, #_int extra, #_Bytes o'regparse]
    ;; [abc]  uses NFA_START_COLL - NFA_END_COLL
    ;; [^abc] uses NFA_START_NEG_COLL - NFA_END_NEG_COLL
    ;; Each character is produced as a regular state,
    ;; using NFA_CONCAT to bind them together.
    ;; Besides normal characters there can be:
    ;; - character classes  NFA_CLASS_*
    ;; - ranges, two characters followed by NFA_RANGE.
    (let [#_Bytes p @regparse #_Bytes endp (skip-anyof p)]
        (cond (at? endp (byte \]))
            ;; Try to reverse engineer character classes.  For example,
            ;; recognize that [0-9] stands for \d and [A-Za-z_] for \h,
            ;; and perform the necessary substitutions in the NFA.
            (let [#_int result (nfa-recognize-char-class @regparse, endp, (== extra NFA_ADD_NL))]
                (if (non-zero? result)
                    (do (if (<= NFA_FIRST_NL result NFA_LAST_NL)
                            (and (emc1 (- result NFA_ADD_NL)) (emc1 NFA_NEWL) (emc1 NFA_OR))
                            (emc1 result))
                        (reset! regparse endp)
                        (swap! regparse #(.plus % (us-ptr2len-cc %)))
                        [win true])

                    ;; Failed to recognize a character class.
                    ;; Use the simple version that turns [abc] into 'a' OR 'b' OR 'c'.
                    (let-when [#_boolean negated (at? @regparse (byte \^))
                          _ (if negated
                                (do (swap! regparse #(.plus % (us-ptr2len-cc %)))
                                    (emc1 NFA_START_NEG_COLL))
                                (emc1 NFA_START_COLL))
                          #_int startc
                            (let-when [startc (byte \-)] (at? @regparse startc) => -1
                                (swap! regparse #(.plus % (us-ptr2len-cc %)))
                                (emc2 startc)
                                startc)
                          [win [extra :as _]]
                            ;; Emit the OR branches for each character in the [].
                            (loop-when [startc startc #_boolean emit_range false extra extra] (BLT @regparse, endp) => [win [extra]]
                                (let-when [o'startc startc
                                      [startc recur? :as _]
                                        (when' (at? @regparse (byte \[)) => [-1 false]
                                            ;; Check for [: :], [= =], [. .].
                                            (let [#_int charclass (get-char-class regparse)
                                                  #_int equiclass (if (== charclass CLASS_NONE) (get-equi-class regparse) 0)
                                                  #_int collclass (if (and (== charclass CLASS_NONE) (zero? equiclass)) (get-coll-element regparse) 0)]
                                                ;; Character class like [:alpha:].
                                                (cond (!= charclass CLASS_NONE)
                                                    (do (condp == charclass
                                                            CLASS_ALNUM     (emc2 NFA_CLASS_ALNUM)
                                                            CLASS_ALPHA     (emc2 NFA_CLASS_ALPHA)
                                                            CLASS_BLANK     (emc2 NFA_CLASS_BLANK)
                                                            CLASS_CNTRL     (emc2 NFA_CLASS_CNTRL)
                                                            CLASS_DIGIT     (emc2 NFA_CLASS_DIGIT)
                                                            CLASS_GRAPH     (emc2 NFA_CLASS_GRAPH)
                                                            CLASS_LOWER     (emc2 NFA_CLASS_LOWER)
                                                            CLASS_PRINT     (emc2 NFA_CLASS_PRINT)
                                                            CLASS_PUNCT     (emc2 NFA_CLASS_PUNCT)
                                                            CLASS_SPACE     (emc2 NFA_CLASS_SPACE)
                                                            CLASS_UPPER     (emc2 NFA_CLASS_UPPER)
                                                            CLASS_XDIGIT    (emc2 NFA_CLASS_XDIGIT)
                                                            CLASS_TAB       (emc2 NFA_CLASS_TAB)
                                                            CLASS_RETURN    (emc2 NFA_CLASS_RETURN)
                                                            CLASS_BACKSPACE (emc2 NFA_CLASS_BACKSPACE)
                                                            CLASS_ESCAPE    (emc2 NFA_CLASS_ESCAPE)
                                                        )
                                                        [-1 true])
                                                ;; Try equivalence class [=a=] and the like.
                                                (non-zero? equiclass)
                                                    (do (nfa-emit-equi-class equiclass)
                                                        [-1 true])
                                                ;; Try collating class like [. .].
                                                (non-zero? collclass)
                                                    ;; Will emit the proper atom at the end of the while loop.
                                                    [collclass false] ;; allow [.a.]-x as a range
                                                :else
                                                    [-1 false])
                                            ))
                                ] (some? _) => [win nil]

                                    (cond recur?
                                        (recur startc emit_range extra)
                                    ;; Try a range like 'a-x' or '\t-z'.  Also allows '-' as a start character.
                                    (and (at? @regparse (byte \-)) (!= o'startc -1))
                                        (do (swap! regparse #(.plus % (us-ptr2len-cc %)))
                                            (recur o'startc true extra)) ;; reading the end of the range
                                    :else
                                        ;; Now handle simple and escaped characters.
                                        ;; Only "\]", "\^", "\]" and "\\" are special in Vi.
                                        ;; Vim accepts "\t", "\e", etc., but only when the 'l' flag in 'cpoptions' is not included.
                                        ;; Posix doesn't recognize backslash at all.
                                        (let-when [[startc #_boolean got_coll_char]
                                                (if (and (at? @regparse (byte \\)) (not @reg_cpo_bsl) (BLE (.plus @regparse 1), endp)
                                                         (or (some? (vim-strchr REGEXP_INRANGE, (.at @regparse 1)))
                                                             (and (not @reg_cpo_lit) (some? (vim-strchr REGEXP_ABBR, (.at @regparse 1))))))
                                                    (do (swap! regparse #(.plus % (us-ptr2len-cc %)))
                                                        (let [#_int c (.at @regparse 0)]
                                                            (cond (== c (byte \n))
                                                                [(if @reg_string NL NFA_NEWL) false]
                                                            (any == c (byte \d) (byte \o) (byte \x) (byte \u) (byte \U))
                                                                (let [startc (coll-get-char)] ;; TODO(RE) This needs more testing.
                                                                    (swap! regparse #(.minus % (us-ptr-back o'regparse, %)))
                                                                    [startc true])
                                                            :else ;; \r,\t,\e,\b
                                                                [(backslash-trans c) false])
                                                        ))
                                                    [startc false])
                                              ;; Normal printable char.
                                              startc (if (== startc -1) (us-ptr2char @regparse) startc)
                                              [win [startc emit_range extra :as _]]
                                                ;; Previous char was '-', so this char is end of range.
                                                (if emit_range
                                                    (let [#_int endc startc startc o'startc]
                                                        (cond (< endc startc)
                                                            (let [win (emsg win, e_invrange)] (reset! rc_did_emsg true) [win nil])
                                                        (< (+ startc 2) endc)
                                                            ;; Emit a range instead of the sequence of individual characters.
                                                            (do (when' (zero? startc) => (swap! post_array pop) ;; remove NFA_CONCAT
                                                                    (emc1 1)) ;; \x00 is translated to \x0a, start at \x01
                                                                (emc1 endc) (emc1 NFA_RANGE) (emc1 NFA_CONCAT)
                                                                [win [-1 false extra]])
                                                        :else
                                                            ;; Emit the range.  "startc" was already emitted, so skip it.
                                                            (do (loop-when-recur [#_int c (inc startc)] (<= c endc) [(inc c)] (emc2 c))
                                                                [win [-1 false extra]])
                                                        ))
                                                    ;; This char (startc) is not part of a range.  Normally, just emit it.
                                                    ;; But if we get NUL from a collating char, then replace it with 0x0a.
                                                    ;; Needed to completely mimic the behaviour of the backtracking engine.
                                                    (let [extra (if (== startc NFA_NEWL)
                                                                    ;; Line break can't be matched as part of the collection,
                                                                    ;; add an OR below.  But not for negated range.
                                                                    (if (not negated) NFA_ADD_NL extra)
                                                                    (do (emc2 (if (and got_coll_char (zero? startc)) 0x0a startc)) extra)
                                                                )]
                                                        [win [startc emit_range extra]]
                                                    ))
                                        ] (some? _) => [win nil]

                                            (swap! regparse #(.plus % (us-ptr2len-cc %)))
                                            (recur startc emit_range extra)
                                        ))
                                ))
                    ] (some? _) => [win false]

                        (swap! regparse #(.minus % (us-ptr-back o'regparse, %)))
                        (when (at? @regparse (byte \-)) ;; if last, '-' is just a char
                            (emc2 (byte \-)))
                        ;; skip the trailing ]
                        (reset! regparse endp)
                        (swap! regparse #(.plus % (us-ptr2len-cc %)))
                        ;; Mark end of the collection.
                        (emc1 (if negated NFA_END_NEG_COLL NFA_END_COLL))
                        ;; \_[] also matches \n but it's not negated
                        (when (== extra NFA_ADD_NL)
                            (emc1 (if @reg_string NL NFA_NEWL))
                            (emc1 NFA_OR))
                        [win true])
                ))
        @reg_strict
            (let [win (emsg win, e_missingbracket)]
                (reset! rc_did_emsg true)
                [win false])
        :else
            [win (nfa-do-multibyte c, o'regparse)])
    ))

(defn- #_[window_C boolean] nfa-regclass- [#_window_C win, #_int c, #_int extra, #_Bytes o'regparse]
    (let [#_Bytes p (vim-strchr classchars, (no-Magic c))]
        (cond (nil? p)
            (when' (== extra NFA_ADD_NL) => [(emsg* win, (u8 "INTERNAL: Unknown character class char: %ld"), c) false]
                (let [win (emsg* win, e_ill_char_class, c)]
                    (reset! rc_did_emsg true)
                    [win false]
                ))
        ;; When '.' is followed by a composing char ignore the dot, so that the composing char is matched here.
        (and (== c (Magic (byte \.))) (utf-iscomposing (peekchr)))
            (let [o'regparse @regparse c (getchr)]
                [win (nfa-do-multibyte c, o'regparse)])
        :else
            (do (emc1 (... nfa_classcodes (BDIFF p, classchars)))
                (when (== extra NFA_ADD_NL)
                    (emc1 NFA_NEWL)
                    (emc1 NFA_OR)
                    (swap! regflags | RF_HASNL))
                [win true]
            ))
    ))

;; Parse the lowest level.
;;
;; An atom can be one of a long list of items.
;; Many atoms match one character in the text.
;; It is often an ordinary character or a character class.
;; Braces can be used to make a pattern into an atom.
;; The "\z(\)" construct is only for syntax highlighting.
;;
;; atom    ::=     ordinary-atom
;;     or  \( pattern \)
;;     or  \%( pattern \)
;;     or  \z( pattern \)

(defn- #_[window_C boolean] nfa-regatom? [#_window_C win]
    (let [#_Bytes o'regparse @regparse #_int c (getchr)]
        (condp ==? c
            NUL (let [win (emsg win, e_nul_found)] (reset! rc_did_emsg true) [win false])

            (Magic (byte \^)) [win (emc1 NFA_BOL)]
            (Magic (byte \$)) [win (emc1 NFA_EOL)]
            (Magic (byte \<)) [win (emc1 NFA_BOW)]
            (Magic (byte \>)) [win (emc1 NFA_EOW)]

            (Magic (byte \_))
                (let [c (no-Magic (getchr))]
                    (condp == c
                        NUL       (let [win (emsg win, e_nul_found)] (reset! rc_did_emsg true) [win false])
                        (byte \^) [win (emc1 NFA_BOL)]                           ;; "\_^" is start-of-line
                        (byte \$) [win (emc1 NFA_EOL)]                           ;; "\_$" is end-of-line
                        (byte \[) (nfa-regcoll- win, c, NFA_ADD_NL, o'regparse)  ;; "\_[" is collection plus newline
                        #_else    (nfa-regclass- win, c, NFA_ADD_NL, o'regparse) ;; "\_x" is character class plus newline
                    ))

           [(Magic (byte \.))                   ;; Character classes.
            (Magic (byte \i)) (Magic (byte \I))
            (Magic (byte \k)) (Magic (byte \K))
            (Magic (byte \f)) (Magic (byte \F))
            (Magic (byte \p)) (Magic (byte \P))
            (Magic (byte \s)) (Magic (byte \S))
            (Magic (byte \d)) (Magic (byte \D))
            (Magic (byte \x)) (Magic (byte \X))
            (Magic (byte \o)) (Magic (byte \O))
            (Magic (byte \w)) (Magic (byte \W))
            (Magic (byte \h)) (Magic (byte \H))
            (Magic (byte \a)) (Magic (byte \A))
            (Magic (byte \l)) (Magic (byte \L))
            (Magic (byte \u)) (Magic (byte \U))] (nfa-regclass- win, c, 0, o'regparse)

            (Magic (byte \n))
                ;; In a string "\n" matches a newline character.  ;; In buffer text "\n" matches the end of a line.
                [win (if @reg_string (emc1 NL) (do (emc1 NFA_NEWL) (swap! regflags | RF_HASNL) true))]

            (Magic (byte \()) (nfa-reg? win, REG_PAREN) ;; false: cascaded error

           [(Magic (byte \|)) (Magic (byte \&)) (Magic (byte \)))]
                [(emsg* win, e_misplaced, (no-Magic c)) false]

           [(Magic (byte \=)) (Magic (byte \?)) (Magic (byte \+)) (Magic (byte \@)) (Magic (byte \*)) (Magic (byte \{))]
                ;; these should follow an atom, not form an atom
                [(emsg* win, e_misplaced, (no-Magic c)) false]

            (Magic (byte \~))
                ;; Previous substitute pattern.  ;; Generated as "\%(pattern\)".
                (let-when [#_Bytes s @reg_prev_sub] (some? s) => [(emsg win, e_nopresub) false]
                    (loop-when-recur [#_int i 0] (non-eos? s i) [(+ i (us-ptr2len s, i))]
                        (emc1 (us-ptr2char s, i))
                        (when (pos? i)
                            (emc1 NFA_CONCAT)))
                    [win (emc1 NFA_NOPEN)])

           [(Magic (byte \1)) (Magic (byte \2)) (Magic (byte \3)) (Magic (byte \4)) (Magic (byte \5)) (Magic (byte \6)) (Magic (byte \7)) (Magic (byte \8)) (Magic (byte \9))]
                [win (do (emc1 (+ NFA_BACKREF1 (- (no-Magic c) (byte \1)))) (reset! nfa_has_backref true) true)]

            (Magic (byte \z))
                (let [c (no-Magic (getchr))]
                    (condp ==? c
                        (byte \s) (do (emc1 NFA_ZSTART)                          (re-mult-next? win, (u8 "\\zs")))
                        (byte \e) (do (emc1 NFA_ZEND) (reset! nfa_has_zend true) (re-mult-next? win, (u8 "\\ze")))

                       [(byte \1) (byte \2) (byte \3) (byte \4) (byte \5) (byte \6) (byte \7) (byte \8) (byte \9)] ;; \z1...\z9
                            (let [win (emsg win, e_z1_not_allowed)] (reset! rc_did_emsg true) [win false])

                        (byte \() ;; \z(    ;; sic!)
                            (let [win (emsg win, e_z_not_allowed)] (reset! rc_did_emsg true) [win false])

                        [(emsg* win, (u8 "E867: (NFA) Unknown operator '\\z%c'"), (no-Magic c)) false]
                    ))

            (Magic (byte \%))
                (let [c (no-Magic (getchr))]
                    (condp ==? c
                        (byte \() (let [[win ?] (nfa-reg? win, REG_NPAREN)] [win (and ? (emc1 NFA_NOPEN))]) ;; () without a back reference

                       [(byte \d)   ;; %d123 decimal
                        (byte \o)   ;; %o123 octal
                        (byte \x)   ;; %xab hex 2
                        (byte \u)   ;; %uabcd hex 4
                        (byte \U)]  ;; %U1234abcd hex 8
                            (let [#_int nr (condp == c
                                    (byte \d) (getdecchrs)
                                    (byte \o) (getoctchrs)
                                    (byte \x) (gethexchrs 2)
                                    (byte \u) (gethexchrs 4)
                                    (byte \U) (gethexchrs 8)
                                              -1)]
                                (if (< nr 0)
                                    (let [win (emsg* win, (u8 "E678: Invalid character after %s%%[dxouU]"), (if (== @reg_magic MAGIC_ALL) (u8 "") (u8 "\\")))]
                                        (reset! rc_did_emsg true)
                                        [win false])
                                    ;; A NUL is stored in the text as NL.
                                    ;; TODO: what if a composing character follows?
                                    [win (emc1 (if (zero? nr) 0x0a nr))]
                                ))

                        ;; Catch \%^ and \%$ regardless of where they appear in the pattern -- regardless of whether or not it makes sense.
                        (byte \^) [win (emc1 NFA_BOF)]
                        (byte \$) [win (emc1 NFA_EOF)]
                        (byte \#) [win (emc1 NFA_CURSOR)]
                        (byte \V) [win (emc1 NFA_VISUAL)]
                        (byte \C) [win (emc1 NFA_ANY_COMPOSING)]

                        (byte \[) ;; \%[abc]
                            (let-when [[win [#_int n c :as _]]
                                (loop-when [win win n 0 c (peekchr)] (!= c (byte \])) => [win [n c]]
                                    (cond (== c NUL)
                                        (let [win (emsg* win, e_missing_sb, (if (== @reg_magic MAGIC_ALL) (u8 "") (u8 "\\")))]
                                            (reset! rc_did_emsg true)
                                            [win nil])
                                    :else
                                        (let [[win ?] (nfa-regatom? win)] ;; recursive call!
                                            (recur-if ? [win (inc n) (peekchr)] => [win nil]))
                                    ))
                            ] (some? _) => [win false]

                                (getchr)       ;; get the ]
                                (if (zero? n)
                                    (let [win (emsg* win, e_empty_sb, (if (== @reg_magic MAGIC_ALL) (u8 "") (u8 "\\")))]
                                        (reset! rc_did_emsg true)
                                        [win false])
                                    (do
                                        (emc1 NFA_OPT_CHARS)
                                        (emc1 n)
                                        ;; Emit as "\%(\%[abc]\)" to be able to handle "\%[abc]*" which would
                                        ;; cause the empty string to be matched an unlimited number of times.
                                        ;; NFA_NOPEN is added only once at a position, while NFA_SPLIT is added
                                        ;; multiple times.  This is more efficient than not allowing NFA_SPLIT
                                        ;; multiple times, it is used a lot.
                                        [win (emc1 NFA_NOPEN)])
                                ))

                        (let [#_int cmp c [#_int n c]
                                (loop-when-recur [n 0 c (if (any == c (byte \<) (byte \>)) (getchr) c)] (asc-isdigit c) [(+ (* n 10) (- c (byte \0))) (getchr)] => [n c])]
                            (cond (any == c (byte \l) (byte \c) (byte \v))
                                (do (condp == c
                                        (byte \l) (emc1 (condp == cmp (byte \<) NFA_LNUM_LT (byte \>) NFA_LNUM_GT NFA_LNUM))  ;; \%{n}l  \%{n}<l  \%{n}>l
                                        (byte \c) (emc1 (condp == cmp (byte \<) NFA_COL_LT  (byte \>) NFA_COL_GT  NFA_COL))   ;; \%{n}c  \%{n}<c  \%{n}>c
                                        (byte \v) (emc1 (condp == cmp (byte \<) NFA_VCOL_LT (byte \>) NFA_VCOL_GT NFA_VCOL))) ;; \%{n}v  \%{n}<v  \%{n}>v
                                    [win (emc1 n)])
                            (and (== c (byte \')) (zero? n))
                                (do (emc1 (condp == cmp (byte \<) NFA_MARK_LT (byte \>) NFA_MARK_GT NFA_MARK)) ;; \%'m  \%<'m  \%>'m
                                    [win (emc1 (getchr))])
                            :else
                                [(emsg* win, (u8 "E867: (NFA) Unknown operator '\\%%%c'"), (no-Magic c)) false]
                            ))
                    ))

            (Magic (byte \[)) (nfa-regcoll- win, c, 0, o'regparse)

            #_else            [win (nfa-do-multibyte c, o'regparse)])
    ))

(defn- #_final #_boolean nfa-do-multibyte [#_int c, #_Bytes o'regparse]
    ;; plen is length of current char with composing chars
    (let-when [#_int plen (us-ptr2len-cc o'regparse)] (or (!= (utf-char2len c) plen) (utf-iscomposing c)) => (emc1 (no-Magic c))
        ;; A base character plus composing characters, or just one or more composing characters.
        ;; This requires creating a separate atom as if enclosing the characters in (), where
        ;; NFA_COMPOSING is the ( and NFA_END_COMPOSING is the ).
        ;; Note that right now we are building the postfix form, not the NFA itself; a composing
        ;; char could be: a, b, c, NFA_COMPOSING where 'b' and 'c' are chars with codes > 256.
        (loop [#_int i 0 c c]
            (emc1 c)
            (when (< 0 i)
                (emc1 NFA_CONCAT))
            (let [i (+ i (utf-char2len c))]
                (recur-if (< i plen) [i (us-ptr2char o'regparse, i)])
            ))
        (emc1 NFA_COMPOSING)
        (reset! regparse (.plus o'regparse plen)))
    true)

;; Parse something followed by possible [*+=].
;;
;; A piece is an atom, possibly followed by a multi, an indication of how many
;; times the atom can be matched.  Example: "a*" matches any sequence of "a"
;; characters: "", "a", "aa", etc.
;;
;; piece   ::=      atom
;;      or  atom  multi

(defn- #_[window_C boolean] nfa-regpiece? [#_window_C win]
    ;; Save the current parse state, so that we can use it if <atom>{m,n} is next.
    ;; Store current pos in the postfix form for \{m,n} involving 0s.
    (let-when [o'state (save-parse-state) o'array @post_array [win ?] (nfa-regatom? win)] ? => [win false] ;; cascaded error

        (let-when [#_int op (peekchr)] (!= (re-multi-type op) NOT_MULTI) => [win true]
            (skipchr)

            (let-when [[win _]
                (condp ==? op
                    (Magic (byte \*)) (do (emc1 NFA_STAR) [win nil])

                    (Magic (byte \+))
                        (do ;; Trick:  Normally, (a*)\+ would match the whole input "aaa".  The first and
                            ;; only submatch would be "aaa".  But the backtracking engine interprets the
                            ;; plus as "try matching one more time", and a* matches a second time at the
                            ;; end of the input, the empty string.  The submatch will be the empty string.
                            ;;
                            ;; In order to be consistent with the old engine,
                            ;; we replace <atom>+ with <atom><atom>*
                            (restore-parse-state o'state)
                            (reset! curchr -1)
                            (let-when [[win ?] (nfa-regatom? win)] ? => [win false]
                                (emc1 NFA_STAR) (emc1 NFA_CONCAT) (skipchr) [win nil] ;; skip the \+
                            ))

                    (Magic (byte \@))
                        (let [#_int c2 (getdecchrs) op (no-Magic (getchr))
                              [op #_int i]
                                (condp == op
                                    (byte \=) [op NFA_PREV_ATOM_NO_WIDTH]                       ;; \@=
                                    (byte \!) [op NFA_PREV_ATOM_NO_WIDTH_NEG]                   ;; \@!
                                    (byte \<)
                                        (let [op (no-Magic (getchr))]
                                            (condp == op
                                                (byte \=) [op NFA_PREV_ATOM_JUST_BEFORE]        ;; \@<=
                                                (byte \!) [op NFA_PREV_ATOM_JUST_BEFORE_NEG]    ;; \@<!
                                                          [op 0]))
                                    (byte \>) [op NFA_PREV_ATOM_LIKE_PATTERN]                   ;; \@>
                                              [op 0]
                                )]
                            (if (zero? i)
                                [(emsg* win, (u8 "E869: (NFA) Unknown operator '\\@%c'"), op) false]
                                (do (emc1 i)
                                    (when (any == i NFA_PREV_ATOM_JUST_BEFORE NFA_PREV_ATOM_JUST_BEFORE_NEG)
                                        (emc1 c2))
                                    [win nil])
                            ))

                   [(Magic (byte \?)) (Magic (byte \=))] (do (emc1 NFA_QUEST) [win nil])

                    (Magic (byte \{))
                        ;; a{2,5} will expand to 'aaa?a?a?'
                        ;; a{-1,3} will expand to 'aa??a??', where ?? is the nongreedy version of '?'
                        ;; \v(ab){2,3} will expand to '(ab)(ab)(ab)?', where all the parenthesis have the same id
                        (let [#_int c2 (peekchr)
                              #_boolean greedy (if (any == c2 (byte \-) (Magic (byte \-))) (do (skipchr) false) true)
                              a'minval (atom (long)) a'maxval (atom (long)) [win ?] (read-limits? win, a'minval, a'maxval)]
                            (cond (not ?)
                                (let [win (emsg win, (u8 "E870: (NFA regexp) Error reading repetition limits"))]
                                    (reset! rc_did_emsg true)
                                    [win false])
                            ;; <atom>{0,inf}, <atom>{0,} and <atom>{} are equivalent to <atom>*
                            (and (zero? @a'minval) (== @a'maxval MAX_LIMIT))
                                (do (if greedy
                                        (emc1 NFA_STAR)             ;; {{   ;; \{}, \{0,}
                                        (emc1 NFA_STAR_NONGREEDY))  ;; {{   ;; \{-}, \{-0,}
                                    [win nil])
                            ;; Special case: x{0} or x{-0}.
                            (zero? @a'maxval)
                                (do ;; Ignore result of previous call to nfa-regatom().
                                    (reset! post_array o'array)
                                    ;; NFA_EMPTY is 0-length and works everywhere.
                                    (emc1 NFA_EMPTY)
                                    [win true])
                            ;; The engine is very inefficient (uses too many states) when the maximum
                            ;; is much larger than the minimum and when the maximum is large.
                            ;; Bail out if we can use the other engine.
                            (and (flag? @nfa_re_flags RE_AUTO) (< (min (+ @a'minval 200) 500) @a'maxval))
                                [win false]
                            :else     ;; Ignore previous call to nfa-regatom().
                                (let-when [_ (reset! post_array o'array)
                                      ;; Save parse state after the repeated atom and the \{}.
                                      o''state (save-parse-state)
                                      #_int quest (if greedy NFA_QUEST NFA_QUEST_NONGREEDY)
                                      [win _]
                                        (loop-when [win win #_int i 0] (< i @a'maxval) => [win nil]
                                            ;; Goto beginning of the repeated atom.
                                            (restore-parse-state o'state)
                                            (let [o'count (count @post_array)]
                                                (let-when [[win ?] (nfa-regatom? win)] ? => [win false]
                                                    ;; after "minval" times, atoms are optional
                                                    (when (< @a'minval (inc i))
                                                        (if (== @a'maxval MAX_LIMIT)
                                                            (emc1 (if greedy NFA_STAR NFA_STAR_NONGREEDY))
                                                            (emc1 quest)
                                                        ))
                                                    (when (!= o'count (count o'array))
                                                        (emc1 NFA_CONCAT))
                                                    (if (and (< @a'minval (inc i)) (== @a'maxval MAX_LIMIT))
                                                        [win nil]
                                                        (recur win (inc i))
                                                    ))
                                            ))] (nil? _) => [win _]

                                    ;; Go to just after the repeated atom and the \{}.
                                    (restore-parse-state o''state)
                                    (reset! curchr -1)
                                    [win nil])
                            ))

                    [win nil])] (nil? _) => [win _]

                (when' (!= (re-multi-type (peekchr)) NOT_MULTI) => [win true]
                    (let [win (emsg win, (u8 "E871: (NFA regexp) Can't have a multi follow a multi !"))]
                        (reset! rc_did_emsg true)
                        [win false]
                    ))
            ))
    ))

;; Parse one or more pieces, concatenated.  It matches a match for the
;; first piece, followed by a match for the second piece, etc.  Example:
;; "f[0-9]b", first matches "f", then a digit and then "b".
;;
;; concat  ::=      piece
;;      or  piece piece
;;      or  piece piece piece
;;      etc.

(defn- #_[window_C boolean] nfa-regconcat? [#_window_C win]
    (loop [win win #_boolean first true]
        (condp ==? (peekchr)
           [NUL
            (Magic (byte \|))
            (Magic (byte \&))
            (Magic (byte \)))]
                [win true]

            (Magic (byte \Z)) (do (swap! regflags | RF_ICOMBINE) (skipchr-keepstart)                    (recur win first))
            (Magic (byte \c)) (do (swap! regflags | RF_ICASE)    (skipchr-keepstart)                    (recur win first))
            (Magic (byte \C)) (do (swap! regflags | RF_NOICASE)  (skipchr-keepstart)                    (recur win first))

            (Magic (byte \v)) (do (reset! reg_magic MAGIC_ALL)   (skipchr-keepstart) (reset! curchr -1) (recur win first))
            (Magic (byte \m)) (do (reset! reg_magic MAGIC_ON)    (skipchr-keepstart) (reset! curchr -1) (recur win first))
            (Magic (byte \M)) (do (reset! reg_magic MAGIC_OFF)   (skipchr-keepstart) (reset! curchr -1) (recur win first))
            (Magic (byte \V)) (do (reset! reg_magic MAGIC_NONE)  (skipchr-keepstart) (reset! curchr -1) (recur win first))

            (let-when [[win ?] (nfa-regpiece? win)] ? => [win false]
                (when-not first
                    (emc1 NFA_CONCAT))
                (recur win false)
            ))
    ))

;; Parse a branch, one or more concats, separated by "\&".  It matches the
;; last concat, but only if all the preceding concats also match at the same
;; position.  Examples:
;;      "foobeep\&..." matches "foo" in "foobeep".
;;      ".*Peter\&.*Bob" matches in a line containing both "Peter" and "Bob"
;;
;; branch ::=       concat
;;              or  concat \& concat
;;              or  concat \& concat \& concat
;;              etc.

(defn- #_[window_C boolean] nfa-regbranch? [#_window_C win]
    (let-when [i (count @post_array) [win ?] (nfa-regconcat? win)] ? => [win false] ;; first branch, possibly the only one
        (let [[win i]
                (loop-when [win win i i] (== (peekchr) (Magic (byte \&))) => [win i] ;; try next concats
                    (skipchr)
                    (emc1 NFA_NOPEN)
                    (emc1 NFA_PREV_ATOM_NO_WIDTH)
                    (let-when [i (count @post_array) [win ?] (nfa-regconcat? win)] ? => [win nil]
                        (when (== (count @post_array) i) ;; if concat is empty, emit a node
                            (emc1 NFA_EMPTY))
                        (emc1 NFA_CONCAT)
                        (recur win i)
                    )
                )]
            (when' (some? i) => [win false]
                (when (== (count @post_array) i) ;; if branch is empty, emit a node
                    (emc1 NFA_EMPTY))
                [win true]
            ))
    ))

;; Parse a pattern, one or more branches, separated by "\|".
;; It matches anything that matches one of the branches.
;; Example: "foo\|beep" matches "foo" and matches "beep".
;; If more than one branch matches, the first one is used.
;;
;; pattern ::=     branch
;;     or  branch \| branch
;;     or  branch \| branch \| branch
;;     etc.
;;
;; paren: REG_NOPAREN, REG_PAREN or REG_NPAREN

(defn- #_[window_C boolean] nfa-reg? [#_window_C win, #_int paren]
    (let-when [[win #_int parno]
            (when' (== paren REG_PAREN) => [win 0]
                (if (< @regnpar NSUBEXP)
                    (let [parno @regnpar]
                        (swap! regnpar inc)
                        [win parno])
                    (let [win (emsg win, (u8 "E872: (NFA regexp) Too many '('"))]
                        (reset! rc_did_emsg true)
                        [win nil])
                ))
          [win ?] (if (some? parno) (nfa-regbranch? win) [win false])
    ] ? => [win false]

        (let-when [[win _]
                (loop-when win (== (peekchr) (Magic (byte \|))) => [win :_]
                    (skipchr)
                    (let-when [[win ?] (nfa-regbranch? win)] ? => [win nil]
                        (emc1 NFA_OR)
                        (recur win)
                    ))
        ] (some? _) => [win false]

            ;; Check for proper termination.
            (cond (and (!= paren REG_NOPAREN) (!= (getchr) (Magic (byte \)))))
                (let [win (if (== paren REG_NPAREN)
                            (emsg* win, e_unmatchedpp, (if (== @reg_magic MAGIC_ALL) (u8 "") (u8 "\\")))
                            (emsg* win, e_unmatchedp,  (if (== @reg_magic MAGIC_ALL) (u8 "") (u8 "\\")))
                        )]
                    (reset! rc_did_emsg true)
                    [win false])
            (and (== paren REG_NOPAREN) (!= (peekchr) NUL))
                (let [win (if (== (peekchr) (Magic (byte \))))
                            (emsg* win, e_unmatchedpar, (if (== @reg_magic MAGIC_ALL) (u8 "") (u8 "\\")))
                            (emsg win, (u8 "E873: (NFA regexp) proper termination error"))
                        )]
                    (reset! rc_did_emsg true)
                    [win false])
            :else ;; Here we set the flag allowing back references to this set of parentheses.
                (do (when (== paren REG_PAREN)
                        (swap! had_endbrace assoc parno true) ;; have seen the close paren
                        (emc1 (+ NFA_MOPEN parno)))
                    [win true])
            ))
    ))

;; Parse r.e. and convert it into postfix form.
;; Return the postfix string on success, null otherwise.

(defn- #_[window_C int*] re2post? [#_window_C win]
    (let [[win ?] (nfa-reg? win, REG_NOPAREN)] [win (when ? (emc1 NFA_MOPEN) @post_array)]))

;; Allocate and initialize an nfa_state_C.
;;
;; It represents an NFA state plus zero or one or two arrows exiting.
;; If c == MATCH, no arrows out; matching state.
;; If c == SPLIT, unlabeled arrows to out0 and out1 (if != null).
;; If c < 256, labeled arrow with character c to out0.

(defn- #_[nfa_state_C* nfa_state_C] alloc-state? [#_nfa_state_C* states, #_int c, #_nfa_state_C out0, #_nfa_state_C out1]
    (let [#_nfa_state_C state (NEW_nfa_state_C)
          state (assoc state :c c)
          _ (when (some? out0) (out0! state out0))
          _ (when (some? out1) (out1! state out1))
          state (assoc state :id (count states))]
        [(conj states state) state]
    ))

;; Estimate the maximum byte length of anything matching "state".
;; When unknown or unlimited, return -1.

(defn- #_int nfa-max-width [#_nfa_state_C state, #_int depth]
    (if (< 4 depth) ;; detect looping in a NFA_SPLIT
        -1
        (loop-when [#_int len 0 state state] (some? state) => -1 ;; unrecognized, "cannot happen"
            (condp ==? (:c state)
               [NFA_END_INVISIBLE
                NFA_END_INVISIBLE_NEG]
                    len ;; the end, return what we have

                NFA_SPLIT
                    ;; two alternatives, use the maximum
                    (let [l (nfa-max-width (out0 state), (inc depth)) r (nfa-max-width (out1 state), (inc depth))]
                        (if (or (neg? l) (neg? r)) -1 (+ len (max l r))))

               [NFA_ANY
                NFA_START_COLL
                NFA_START_NEG_COLL]
                    ;; matches some character, including composing chars
                    (recur (+ len MB_MAXBYTES) (if (!= (:c state) NFA_ANY) (-> state (out1) (out0)) (out0 state)))

               [NFA_DIGIT
                NFA_WHITE
                NFA_HEX
                NFA_OCTAL]
                    (recur (inc len) (out0 state)) ;; ascii

               [NFA_IDENT
                NFA_SIDENT
                NFA_KWORD
                NFA_SKWORD
                NFA_FNAME
                NFA_SFNAME
                NFA_PRINT
                NFA_SPRINT
                NFA_NWHITE
                NFA_NDIGIT
                NFA_NHEX
                NFA_NOCTAL
                NFA_WORD
                NFA_NWORD
                NFA_HEAD
                NFA_NHEAD
                NFA_ALPHA
                NFA_NALPHA
                NFA_LOWER
                NFA_NLOWER
                NFA_UPPER
                NFA_NUPPER
                NFA_LOWER_IC
                NFA_NLOWER_IC
                NFA_UPPER_IC
                NFA_NUPPER_IC
                NFA_ANY_COMPOSING]
                    (recur (+ len 3) (out0 state)) ;; possibly non-ascii

               [NFA_START_INVISIBLE
                NFA_START_INVISIBLE_NEG
                NFA_START_INVISIBLE_BEFORE
                NFA_START_INVISIBLE_BEFORE_NEG]
                    (recur len (-> state (out1) (out0))) ;; zero-width, out1 points to the END state

               [NFA_BACKREF1
                NFA_BACKREF2
                NFA_BACKREF3
                NFA_BACKREF4
                NFA_BACKREF5
                NFA_BACKREF6
                NFA_BACKREF7
                NFA_BACKREF8
                NFA_BACKREF9
                NFA_NEWL
                NFA_SKIP]
                    -1 ;; unknown width

               [NFA_BOL
                NFA_EOL
                NFA_BOF
                NFA_EOF
                NFA_BOW
                NFA_EOW

                NFA_MOPEN
                NFA_MOPEN1
                NFA_MOPEN2
                NFA_MOPEN3
                NFA_MOPEN4
                NFA_MOPEN5
                NFA_MOPEN6
                NFA_MOPEN7
                NFA_MOPEN8
                NFA_MOPEN9
                NFA_MCLOSE
                NFA_MCLOSE1
                NFA_MCLOSE2
                NFA_MCLOSE3
                NFA_MCLOSE4
                NFA_MCLOSE5
                NFA_MCLOSE6
                NFA_MCLOSE7
                NFA_MCLOSE8
                NFA_MCLOSE9
                NFA_NOPEN
                NFA_NCLOSE

                NFA_LNUM_GT
                NFA_LNUM_LT
                NFA_COL_GT
                NFA_COL_LT
                NFA_VCOL_GT
                NFA_VCOL_LT
                NFA_MARK_GT
                NFA_MARK_LT
                NFA_VISUAL
                NFA_LNUM
                NFA_CURSOR
                NFA_COL
                NFA_VCOL
                NFA_MARK

                NFA_ZSTART
                NFA_ZEND
                NFA_OPT_CHARS
                NFA_EMPTY
                NFA_START_PATTERN
                NFA_END_PATTERN
                NFA_COMPOSING
                NFA_END_COMPOSING]
                    (recur len (out0 state)) ;; zero-width

             ;; :else
                (if (< (:c state) 0)
                    ;; don't know what this is
                    -1
                    ;; normal character
                    (recur (+ len (utf-char2len (:c state))) (out0 state))
                )
            ))
    ))

;; A partially built NFA without the matching state filled in.
;; "fr_start" points at the start state.
;; "fr_out" is a list of places that need to be set to the next state for this fragment.

(class! #_final frag_C
    [
        (field nfa_state_C  fr_start)
        (atom' nfa_state_C  fr_out)
    ])

;; Initialize a frag_C struct and return it.

(defn- #_frag_C alloc-frag [#_nfa_state_C start, #_nfa_state_C' out]
    (frag_C. start out))

;; Create singleton list containing just outp.

(defn- #_nfa_state_C' fr-single [#_nfa_state_C' node]
    (reset! node nil)
    node)

;; Patch the list of states at out to point to start.

(defn- #_void fr-patch [#_nfa_state_C' node, #_nfa_state_C start]
    (loop-when node (some? node)
        (let [#_nfa_state_C' next @node]
            (reset! node start)
            (recur next)
        ))
    nil)

;; Join the two lists returning the concatenation.

(defn- #_nfa_state_C' fr-append [#_nfa_state_C' head, #_nfa_state_C' tail]
    (loop-when-recur head (some? @head) @head => (reset! head tail))
    head)

;; Push an item onto the stack.

(defn- #_frag_C* fr-push [#_frag_C* stack, #_frag_C frag]
    (conj stack frag))

;; Pop an item from the stack.

(defn- #_[frag_C frag_C*] fr-pop [#_frag_C* stack]
    [(peek stack) (pop stack)])

;; Convert a postfix form into its equivalent NFA.
;; Return the NFA start state on success, null otherwise.

(defn- #_[window_C nfa_state_C* nfa_state_C] post2nfa? [#_window_C win, #_int* postfix]
    (when' (some? postfix) => [win nil nil]
        (let [#_int over (count postfix)
              [#_frag_C* stack #_nfa_state_C* states]
                (loop-when [stack [] states [] #_int i 0] (< i over) => [stack states]
                    (condp ==? (... postfix i)

                        NFA_CONCAT
                            ;; Concatenation.
                            ;; Pay attention: this operator does not exist in the r.e. itself (it is implicit, really).
                            ;; It is added when r.e. is translated to postfix form in re2post().
                            (let [[#_frag_C e2 stack] (fr-pop stack) [#_frag_C e1 stack] (fr-pop stack)]
                                (fr-patch (:fr_out e1), (:fr_start e2))
                                (recur (fr-push stack, (alloc-frag (:fr_start e1), (:fr_out e2))) states (inc i)))

                        NFA_OR
                            ;; Alternation.
                            (let [[#_frag_C e2 stack] (fr-pop stack) [#_frag_C e1 stack] (fr-pop stack)
                                  [states #_nfa_state_C s0] (alloc-state? states, NFA_SPLIT, (:fr_start e1), (:fr_start e2))]
                                (recur (fr-push stack, (alloc-frag s0, (fr-append (:fr_out e1), (:fr_out e2)))) states (inc i)))

                        NFA_STAR
                            ;; Zero or more, prefer more.
                            (let [[#_frag_C e0 stack] (fr-pop stack) [states #_nfa_state_C s0] (alloc-state? states, NFA_SPLIT, (:fr_start e0), nil)]
                                (fr-patch (:fr_out e0), s0)
                                (recur (fr-push stack, (alloc-frag s0, (fr-single (:out1 s0)))) states (inc i)))

                        NFA_STAR_NONGREEDY
                            ;; Zero or more, prefer zero.
                            (let [[#_frag_C e0 stack] (fr-pop stack) [states #_nfa_state_C s0] (alloc-state? states, NFA_SPLIT, nil, (:fr_start e0))]
                                (fr-patch (:fr_out e0), s0)
                                (recur (fr-push stack, (alloc-frag s0, (fr-single (:out0 s0)))) states (inc i)))

                        NFA_QUEST
                            ;; One or zero atoms => greedy match.
                            (let [[#_frag_C e0 stack] (fr-pop stack) [states #_nfa_state_C s0] (alloc-state? states, NFA_SPLIT, (:fr_start e0), nil)]
                                (recur (fr-push stack, (alloc-frag s0, (fr-append (:fr_out e0), (fr-single (:out1 s0))))) states (inc i)))

                        NFA_QUEST_NONGREEDY
                            ;; Zero or one atoms => non-greedy match.
                            (let [[#_frag_C e0 stack] (fr-pop stack) [states #_nfa_state_C s0] (alloc-state? states, NFA_SPLIT, nil, (:fr_start e0))]
                                (recur (fr-push stack, (alloc-frag s0, (fr-append (:fr_out e0), (fr-single (:out0 s0))))) states (inc i)))

                       [NFA_END_COLL NFA_END_NEG_COLL]
                            ;; On the stack the sequence is starting with NFA_START_COLL or NFA_START_NEG_COLL and all possible characters.
                            ;; Patch it to add the output to the start.
                            (let [[#_frag_C e0 stack] (fr-pop stack) [states #_nfa_state_C s0] (alloc-state? states, NFA_END_COLL, nil, nil)]
                                (fr-patch (:fr_out e0), s0)
                                (out1! (:fr_start e0) s0)
                                (recur (fr-push stack, (alloc-frag (:fr_start e0), (fr-single (:out0 s0)))) states (inc i)))

                        NFA_RANGE
                            ;; There are two characters before this: the low and high end of a range.
                            ;; Turn them into two states with MIN and MAX.
                            (let [[#_frag_C e2 stack] (fr-pop stack) [#_frag_C e1 stack] (fr-pop stack)]
                                ((ร e2.fr_start.val =) (:c (:fr_start e2)))
                                ((ร e2.fr_start.c =) NFA_RANGE_MAX)
                                ((ร e1.fr_start.val =) (:c (:fr_start e1)))
                                ((ร e1.fr_start.c =) NFA_RANGE_MIN)
                                (fr-patch (:fr_out e1), (:fr_start e2))
                                (recur (fr-push stack, (alloc-frag (:fr_start e1), (:fr_out e2))) states (inc i)))

                        NFA_EMPTY
                            ;; 0-length, used in a repetition with max/min count of 0
                            (let [[states #_nfa_state_C s0] (alloc-state? states, NFA_EMPTY, nil, nil)]
                                (recur (fr-push stack, (alloc-frag s0, (fr-single (:out0 s0)))) states (inc i)))

                        NFA_OPT_CHARS
                            ;; \%[abc] implemented as:
                            ;;    NFA_SPLIT
                            ;;    +-CHAR(a)
                            ;;    | +-NFA_SPLIT
                            ;;    |   +-CHAR(b)
                            ;;    |   | +-NFA_SPLIT
                            ;;    |   |   +-CHAR(c)
                            ;;    |   |   | +-next
                            ;;    |   |   +- next
                            ;;    |   +- next
                            ;;    +- next
                            (let [i (inc i) #_int n (... postfix i)
                                  [stack states #_nfa_state_C s0 #_frag_C e1] ;; s1: previous NFA_SPLIT to connect to ;; e1.fr_out: stores list with out1's
                                    (loop-when [stack stack states states s0 nil #_nfa_state_C s1 nil e1 (alloc-frag nil, nil) n n] (< 0 n) => [stack states s0 e1]
                                        (let [[#_frag_C e0 stack] (fr-pop stack) [states s0] (alloc-state? states, NFA_SPLIT, (:fr_start e0), nil)
                                              e1 (if (some? (:fr_out e1)) e1 e0)]
                                            (fr-patch (:fr_out e0), s1)
                                            (fr-append (:fr_out e1), (fr-single (:out1 s0)))
                                            (recur stack states s0 s0 e1 (dec n)))
                                    )]
                                (recur (fr-push stack, (alloc-frag s0, (:fr_out e1))) states (inc i)))

                       [NFA_PREV_ATOM_NO_WIDTH
                        NFA_PREV_ATOM_NO_WIDTH_NEG
                        NFA_PREV_ATOM_JUST_BEFORE
                        NFA_PREV_ATOM_JUST_BEFORE_NEG
                        NFA_PREV_ATOM_LIKE_PATTERN]
                            (let [#_boolean before? (any == (... postfix i) NFA_PREV_ATOM_JUST_BEFORE NFA_PREV_ATOM_JUST_BEFORE_NEG)
                                  #_boolean pattern? (== (... postfix i) NFA_PREV_ATOM_LIKE_PATTERN)
                                  [#_int start_state #_int end_state]
                                    (condp == (... postfix i)
                                        NFA_PREV_ATOM_NO_WIDTH        [NFA_START_INVISIBLE            NFA_END_INVISIBLE    ]
                                        NFA_PREV_ATOM_NO_WIDTH_NEG    [NFA_START_INVISIBLE_NEG        NFA_END_INVISIBLE_NEG]
                                        NFA_PREV_ATOM_JUST_BEFORE     [NFA_START_INVISIBLE_BEFORE     NFA_END_INVISIBLE    ]
                                        NFA_PREV_ATOM_JUST_BEFORE_NEG [NFA_START_INVISIBLE_BEFORE_NEG NFA_END_INVISIBLE_NEG]
                                        NFA_PREV_ATOM_LIKE_PATTERN    [NFA_START_PATTERN              NFA_END_PATTERN      ]
                                    )
                                  i (inc i) #_int n (if before? (... postfix i) 0)
                                  ;; The \@= operator: match the preceding atom with zero width.
                                  ;; The \@! operator: no match for the preceding atom.
                                  ;; The \@<= operator: match for the preceding atom.
                                  ;; The \@<! operator: no match for the preceding atom.
                                  ;; Surrounds the preceding atom with START_INVISIBLE and END_INVISIBLE, similarly to MOPEN.
                                  [#_frag_C e0 stack] (fr-pop stack)
                                  [states #_nfa_state_C s1] (alloc-state? states, end_state, nil, nil)
                                  [states #_nfa_state_C s0] (alloc-state? states, start_state, (:fr_start e0), s1)]
                                (cond pattern?
                                    ;; NFA_ZEND -> NFA_END_PATTERN -> NFA_SKIP -> what follows.
                                    (let [[states #_nfa_state_C skip] (alloc-state? states, NFA_SKIP, nil, nil)
                                          [states #_nfa_state_C zend] (alloc-state? states, NFA_ZEND, s1, nil)]
                                        (out0! s1 skip)
                                        (fr-patch (:fr_out e0), zend)
                                        (recur (fr-push stack, (alloc-frag s0, (fr-single (:out0 skip)))) states (inc i)))
                                :else
                                    (let [_ (fr-patch (:fr_out e0), s1)
                                          stack (fr-push stack, (alloc-frag s0, (fr-single (:out0 s1))))]
                                        ;; See if we can guess the maximum width, it avoids a lot of pointless tries.
                                        (when before?
                                            ((ร s0.val =) (if (< 0 n) n (nfa-max-width (:fr_start e0), 0))))
                                        (recur stack states (inc i)))
                                ))

                       [NFA_MOPEN ;; \( \) Submatch
                        NFA_MOPEN1
                        NFA_MOPEN2
                        NFA_MOPEN3
                        NFA_MOPEN4
                        NFA_MOPEN5
                        NFA_MOPEN6
                        NFA_MOPEN7
                        NFA_MOPEN8
                        NFA_MOPEN9
                        NFA_NOPEN ;; \%( \) "Invisible Submatch"   ;; sic!)
                        NFA_COMPOSING]
                            (let [#_int mopen (... postfix i)
                                  #_int mclose (condp == mopen NFA_NOPEN NFA_NCLOSE NFA_COMPOSING NFA_END_COMPOSING (+ mopen NSUBEXP))] ;; NFA_MOPEN, NFA_MOPEN1 .. NFA_MOPEN9
                              #_(when (and (== mopen NFA_COMPOSING) (flag? @regflags RF_ICOMBINE))
                                    ;; TODO: use the base character only
                                )
                                ;; Allow "NFA_MOPEN" as a valid postfix representation for the empty regexp "".
                                ;; In this case, the NFA will be NFA_MOPEN -> NFA_MCLOSE.  Note that this also
                                ;; allows empty groups of parenthesis, and empty multi-byte characters.
                                (if (zero? (count stack))
                                    (let [[states #_nfa_state_C s0] (alloc-state? states, mopen, nil, nil)
                                          [states #_nfa_state_C s1] (alloc-state? states, mclose, nil, nil)]
                                        (fr-patch (fr-single (:out0 s0)), s1)
                                        (recur (fr-push stack, (alloc-frag s0, (fr-single (:out0 s1)))) states (inc i)))
                                    ;; At least one node was emitted before NFA_MOPEN, so
                                    ;; at least one node will be between NFA_MOPEN and NFA_MCLOSE.
                                    (let [[#_frag_C e0 stack] (fr-pop stack)
                                          [states #_nfa_state_C s0] (alloc-state? states, mopen, (:fr_start e0), nil)
                                          [states #_nfa_state_C s1] (alloc-state? states, mclose, nil, nil)]
                                        (fr-patch (:fr_out e0), s1)
                                        (when (== mopen NFA_COMPOSING)
                                            (fr-patch (fr-single (:out1 s0)), s1)) ;; COMPOSING.out1 = END_COMPOSING
                                        (recur (fr-push stack, (alloc-frag s0, (fr-single (:out0 s1)))) states (inc i)))
                                ))

                       [NFA_BACKREF1
                        NFA_BACKREF2
                        NFA_BACKREF3
                        NFA_BACKREF4
                        NFA_BACKREF5
                        NFA_BACKREF6
                        NFA_BACKREF7
                        NFA_BACKREF8
                        NFA_BACKREF9]
                            (let [[states #_nfa_state_C s0] (alloc-state? states, (... postfix i), nil, nil)
                                  [states #_nfa_state_C s1] (alloc-state? states, NFA_SKIP, nil, nil)]
                                (fr-patch (fr-single (:out0 s0)), s1)
                                (recur (fr-push stack, (alloc-frag s0, (fr-single (:out0 s1)))) states (inc i)))

                       [NFA_LNUM NFA_LNUM_GT NFA_LNUM_LT
                        NFA_VCOL NFA_VCOL_GT NFA_VCOL_LT
                        NFA_COL  NFA_COL_GT  NFA_COL_LT
                        NFA_MARK NFA_MARK_GT NFA_MARK_LT]
                            (let [i (inc i) #_int n (... postfix i) ;; lnum, col or mark name
                                  [states #_nfa_state_C s0] (alloc-state? states, (... postfix (dec i)), nil, nil)]
                                ((ร s0.val =) n)
                                (recur (fr-push stack, (alloc-frag s0, (fr-single (:out0 s0)))) states (inc i)))

                     #_[NFA_ZSTART NFA_ZEND]
                            ;; Operands.
                            (let [[states #_nfa_state_C s0] (alloc-state? states, (... postfix i), nil, nil)]
                                (recur (fr-push stack, (alloc-frag s0, (fr-single (:out0 s0)))) states (inc i)))
                    ))
              [#_frag_C e0 stack] (fr-pop stack)]
            (if (pos? (count stack))
                (let [win (emsg win, (u8 "E875: (NFA regexp) (While converting from postfix to NFA), too many states left on stack"))]
                    (reset! rc_did_emsg true)
                    [win nil nil])
                (let [[states #_nfa_state_C s0] (alloc-state? states, NFA_MATCH, nil, nil)]
                    (fr-patch (:fr_out e0), s0)
                    [win states (:fr_start e0)])
            ))
    ))

;; After building the NFA program, inspect it to add optimization hints.

(defn- #_nfa_pattern_C nfa-postprocess [#_nfa_pattern_C pat]
    (let [#_int n (count (:states pat))]
        (loop-when [pat pat #_int i 0] (< i n) => pat
            (let [#_nfa_state_C state (... (:states pat) i)
                  pat (let-when [#_int c (:c state)] (any == c NFA_START_INVISIBLE, NFA_START_INVISIBLE_NEG, NFA_START_INVISIBLE_BEFORE, NFA_START_INVISIBLE_BEFORE_NEG) => pat
                        ;; Do it directly when what follows is possibly the end of the match.
                        (let [#_boolean directly?
                                (or (match-follows (-> state (out1) (out0)), 0)
                                    (let [#_int ch_invisible (failure-chance (out0 state), 0) #_int ch_follows (failure-chance (-> state (out1) (out0)), 0)]
                                        ;; Postpone when the invisible match is expensive or has a lower chance of failing.
                                        (if (any == c NFA_START_INVISIBLE_BEFORE, NFA_START_INVISIBLE_BEFORE_NEG)
                                            ;; "before" matches are very expensive when unbounded,
                                            ;; always prefer what follows then, unless what follows will always match.
                                            ;; Otherwise strongly prefer what follows.
                                            (and (or (< 0 (:val state)) (<= ch_follows 0)) (< (* ch_follows 10) ch_invisible))
                                            ;; Normal invisible, first do the one with the highest failure chance.
                                            (< ch_follows ch_invisible)
                                        ))
                                )]
                            (when' directly? => pat ;; switch to the _FIRST state
                                (update-in pat [:states i :c] inc)
                            ))
                    )]
                (recur pat (inc i))
            ))
    ))

;; NFA execution code.

(class! #_final regsubs_C
    [
        (field int          in_use)     ;; number of subexpr with useful info

        (field lpos_C*      rs_start    (ARRAY-lpos NSUBEXP))
        (field lpos_C*      rs_end      (ARRAY-lpos NSUBEXP))
    ])

(defn- #_regsubs_C new-regsubs []
    (let [_ (vec (repeat NSUBEXP LPOS-1))] (regsubs_C. 0 _ _)))

;; nfa_pim_C stores a Postponed Invisible Match.
(class! #_final nfa_pim_C
    [
        (field int          np_result)      ;; NFA_PIM_*, see below
        (field nfa_state_C  np_state)       ;; the invisible match start state
        (field regsubs_C    np_subs)        ;; submatch info, only partly used
        (field lpos_C       np_end_pos)     ;; where the match must end
    ])

;; Values for "np_result" in nfa_pim_C.
(final int
    NFA_PIM_TODO     1,     ;; pim not done yet
    NFA_PIM_MATCH    2,     ;; pim executed, matches
    NFA_PIM_NOMATCH  3)     ;; pim executed, no match

;; Execution information of a NFA state.
(class! #_final nfa_thread_C
    [
        (field nfa_state_C  th_state)
        (field int          th_count)
        (field nfa_pim_C    th_pim)         ;; postponed invisible match
        (field regsubs_C    th_subs)        ;; submatch info, only party used
    ])

;; Alternative NFA execution states.
(class! #_final nfa_list_C
    [
        (field nfa_thread_C*    nl_threads)     ;; vector of runtime states
        (field int*             nl_ids)         ;; set of state ids for quick lookup
        (field boolean          nl_has_pim)     ;; true when any state has a PIM
    ])

(atom! long nfa_time_limit)
(atom! int nfa_time_count)

;; Like copy-subs() but exclude the main match.

(defn- #_regsubs_C copy-sub-off [#_regsubs_C rs1, #_regsubs_C rs0]
    (let-when [n (:in_use rs0) rs1 (update rs1 :in_use max n)] (< 1 n) => rs1
        ;; Copy the match start and end positions.
        (loop-when [rs1 rs1 #_int i 1] (< i n) => rs1
            (let [rs1 (-> rs1
                        (assoc-in [:rs_start i] (... (:rs_start rs0) i))
                        (assoc-in [:rs_end i] (... (:rs_end rs0) i))
                    )]
                (recur rs1 (inc i))
            ))
    ))

;; Like copy-subs() but only do the end of the main match if \ze is present.

(defn- #_regsubs_C copy-ze-off [#_regsubs_C rs1, #_regsubs_C rs0]
    (when' (and @nfa_has_zend (not (neg? (:lnum (... (:rs_end rs0) 0))))) => rs1
        (assoc-in rs1 [:rs_end 0] (... (:rs_end rs0) 0))
    ))

;; Return true if "one" and "two" have the same start positions.
;; When using back-references also check the end position.

(defn- #_boolean sub-equal [#_regsubs_C one, #_regsubs_C two]
    (let [n1 (:in_use one) n2 (:in_use two) n (max n1 n2)]
        (loop-when [i 0] (< i n) => true
            (let-when [s1 (... (:rs_start one) i) l1 (if (< i n1) (:lnum s1) -1)
                       s2 (... (:rs_start two) i) l2 (if (< i n2) (:lnum s2) -1)
            ] (and (== l1 l2) (or (== l1 -1) (== (:col s1) (:col s2)))) => false
                (let [_ (when @nfa_has_backref
                            (let-when [e1 (... (:rs_end one) i) l1 (if (< i n1) (:lnum e1) -1)
                                       e2 (... (:rs_end two) i) l2 (if (< i n2) (:lnum e2) -1)
                            ] (and (== l1 l2) (or (== l1 -1) (== (:col e1) (:col e2)))) => false)
                        )]
                    (if (some? _) _ (recur (inc i))))
            ))
    ))

;; Return true if "one" and "two" are equal.  That includes when both are not set.

(defn- #_boolean pim-equal [#_nfa_pim_C one, #_nfa_pim_C two]
    (let [#_boolean one_unused (nil? one) #_boolean two_unused (nil? two)]
        (cond
            one_unused ;; one is unused: equal when two is also unused
                two_unused
            two_unused ;; one is used and two is not: not equal
                false
            (!= (:id (:np_state one)) (:id (:np_state two))) ;; compare the state id
                false
            :else ;; compare the position
                (and (== (:lnum (:np_end_pos one)) (:lnum (:np_end_pos two))) (== (:col (:np_end_pos one)) (:col (:np_end_pos two))))
        )))

;; Return true if the same state is already in list "nfl" with the same positions as "subs".

(defn- #_boolean has-state-with-pos [#_nfa_list_C nfl, #_nfa_state_C state, #_regsubs_C subs, #_nfa_pim_C pim]
    (let [n (count (:nl_threads nfl))]
        (loop-when [i 0] (< i n) => false
            (let [#_nfa_thread_C t (... (:nl_threads nfl) i)]
                (if (and (== (:id (:th_state t)) (:id state)) (sub-equal (:th_subs t), subs) (pim-equal (:th_pim t), pim))
                    true
                    (recur (inc i))
                ))
        )))

;; Return true if "state" leads to a NFA_MATCH without advancing the input.

(defn- #_boolean match-follows [#_nfa_state_C state, #_int depth]
    (if (< 10 depth) ;; avoid too much recursion
        false
        (loop-when state (some? state) => false
            (condp ==? (:c state)
               [NFA_MATCH
                NFA_MCLOSE
                NFA_END_INVISIBLE
                NFA_END_INVISIBLE_NEG
                NFA_END_PATTERN]
                    true

                NFA_SPLIT
                    (or (match-follows (out0 state), (inc depth)) (match-follows (out1 state), (inc depth)))

               [NFA_START_INVISIBLE
                NFA_START_INVISIBLE_FIRST
                NFA_START_INVISIBLE_BEFORE
                NFA_START_INVISIBLE_BEFORE_FIRST
                NFA_START_INVISIBLE_NEG
                NFA_START_INVISIBLE_NEG_FIRST
                NFA_START_INVISIBLE_BEFORE_NEG
                NFA_START_INVISIBLE_BEFORE_NEG_FIRST
                NFA_COMPOSING]
                    (recur (-> state (out1) (out0))) ;; skip ahead to next state

               [NFA_ANY
                NFA_ANY_COMPOSING
                NFA_IDENT
                NFA_SIDENT
                NFA_KWORD
                NFA_SKWORD
                NFA_FNAME
                NFA_SFNAME
                NFA_PRINT
                NFA_SPRINT
                NFA_WHITE
                NFA_NWHITE
                NFA_DIGIT
                NFA_NDIGIT
                NFA_HEX
                NFA_NHEX
                NFA_OCTAL
                NFA_NOCTAL
                NFA_WORD
                NFA_NWORD
                NFA_HEAD
                NFA_NHEAD
                NFA_ALPHA
                NFA_NALPHA
                NFA_LOWER
                NFA_NLOWER
                NFA_UPPER
                NFA_NUPPER
                NFA_LOWER_IC
                NFA_NLOWER_IC
                NFA_UPPER_IC
                NFA_NUPPER_IC
                NFA_START_COLL
                NFA_START_NEG_COLL
                NFA_NEWL]
                    false ;; state will advance input

             ;; :else
                (if (< 0 (:c state))
                    ;; state will advance input
                    false
                    ;; Others: zero-width or possibly zero-width, might still find a match at the same position, keep looking.
                    (recur (out0 state))
                )
            ))
    ))

;; Return true if "state" is already in list "nfl".

(defn- #_boolean state-in-list [#_nfa_list_C nfl, #_nfa_state_C state, #_regsubs_C subs]
    ;; nfl: runtime state list
    ;; state: state to update
    ;; subs: pointers to subexpressions
    (and (... (:nl_ids nfl) (:id state)) (or (not @nfa_has_backref) (has-state-with-pos nfl, state, subs, nil))))

;; Add "state" and possibly what follows to list "nfl".

(defn- #_nfa_list_C addstate [#_nfa_list_C nfl, #_nfa_state_C state, #_regsubs_C subs, #_nfa_pim_C pim, #_int off]
    ;; nfl: runtime state list
    ;; state: state to update
    ;; subs: pointers to subexpressions
    ;; pim: postponed look-behind match
    ;; off: byte offset, when -1 go to next line
    (let-when [?
            (condp ==? (:c state)
               [NFA_NCLOSE
                NFA_MCLOSE NFA_MCLOSE1 NFA_MCLOSE2 NFA_MCLOSE3 NFA_MCLOSE4 NFA_MCLOSE5 NFA_MCLOSE6 NFA_MCLOSE7 NFA_MCLOSE8 NFA_MCLOSE9
                NFA_MOPEN
                NFA_ZEND
                NFA_SPLIT
                NFA_EMPTY]
                    ;; These nodes are not added themselves, but their "out0" and/or "out1" may be added below.
                    :ignore

               [NFA_BOL NFA_BOF]
                    ;; "^" won't match past end-of-line, don't bother trying.
                    ;; Except when at the end of the line, or when we are going to the next line for a look-behind match.
                    (if (and (BLT @regline, @reginput) (non-eos? @reginput) (or (nil? @nfa_endp) (== @reglnum (:lnum @nfa_endp))))
                        nil
                        :apply)

               [NFA_MOPEN1 NFA_MOPEN2 NFA_MOPEN3 NFA_MOPEN4 NFA_MOPEN5 NFA_MOPEN6 NFA_MOPEN7 NFA_MOPEN8 NFA_MOPEN9
                NFA_NOPEN
                NFA_ZSTART]
                    ;; These nodes need to be added so that we can bail out when it was added to this list
                    ;; before at the same position to avoid an endless loop for "\(\)*"
                    :apply

                :apply
            )
    ] ? => nfl

        (let-when [[nfl ?]
                    (when' (== ? :apply) => [nfl :flow]
                        (let-when [?
                                (when' (and (... (:nl_ids nfl) (:id state)) (!= (:c state) NFA_SKIP)) => :flow
                                    ;; This state is already in the list, don't add it again,
                                    ;; unless it is an MOPEN that is used for a backref or when there is a PIM.
                                    ;; For NFA_MATCH check the position, lower position is preferred.
                                    (cond (and (not @nfa_has_backref) (nil? pim) (not (:nl_has_pim nfl)) (!= (:c state) NFA_MATCH))
                                        nil
                                    ;; Do not add the state again when it exists with the same positions.
                                    (has-state-with-pos nfl, state, subs, pim)
                                        nil
                                    :else
                                        :flow
                                    ))
                        ] ? => [nfl nil]

                            ;; When there are backreferences or PIMs,
                            ;; the number of states may be (a lot) bigger than anticipated.
                            (let [nfl (update nfl :nl_threads conj (nfa_thread_C. state 0 pim subs))
                                  nfl (update nfl :nl_ids conj (:id state))
                                  nfl (if (some? pim) (assoc nfl :nl_has_pim true) nfl)]
                                [nfl :flow]
                            ))
                    )
        ] ? => nfl

            (condp ==? (:c state)
                NFA_MATCH
                    nfl

                NFA_SPLIT
                    (-> nfl ;; order matters here
                        (addstate (out0 state), subs, pim, off)
                        (addstate (out1 state), subs, pim, off))

               [NFA_EMPTY NFA_NOPEN NFA_NCLOSE]
                    (addstate nfl, (out0 state), subs, pim, off)

               [NFA_MOPEN NFA_MOPEN1 NFA_MOPEN2 NFA_MOPEN3 NFA_MOPEN4 NFA_MOPEN5 NFA_MOPEN6 NFA_MOPEN7 NFA_MOPEN8 NFA_MOPEN9
                NFA_ZSTART]
                    (let [#_int x (if (== (:c state) NFA_ZSTART) 0 (- (:c state) NFA_MOPEN))
                          ;; Set the position (with "off" added) in the subexpression.
                          subs ;; Fill any gap.
                            (loop-when [subs subs #_int i (:in_use subs)] (< i x) => subs
                                (let [subs (-> subs (assoc-in [:rs_start i] LPOS-1) (assoc-in [:rs_end i] LPOS-1))]
                                    (recur subs (inc i))
                                ))
                          subs (update subs :in_use max (inc x))
                          subs (assoc-in subs [:rs_start x] (if (== off -1) (lpos_C. (inc @reglnum) 0) (lpos_C. @reglnum (+ (BDIFF @reginput, @regline) off))))]
                        (addstate nfl, (out0 state), subs, pim, off))

               [NFA_MCLOSE
                NFA_MCLOSE1 NFA_MCLOSE2 NFA_MCLOSE3 NFA_MCLOSE4 NFA_MCLOSE5 NFA_MCLOSE6 NFA_MCLOSE7 NFA_MCLOSE8 NFA_MCLOSE9
                NFA_ZEND]
                    (if (and (== (:c state) NFA_MCLOSE) @nfa_has_zend (not (neg? (:lnum (... (:rs_end subs) 0)))))
                        ;; Do not overwrite the position set by \ze.
                        (addstate nfl, (out0 state), subs, pim, off)
                        (let [#_int x (if (== (:c state) NFA_ZEND) 0 (- (:c state) NFA_MCLOSE))
                              ;; We don't fill in gaps here, there must have been an MOPEN that has done that.
                              subs (update subs :in_use max (inc x))
                              subs (assoc-in subs [:rs_end x] (if (== off -1) (lpos_C. (inc @reglnum) 0) (lpos_C. @reglnum (+ (BDIFF @reginput, @regline) off))))]
                            (addstate nfl, (out0 state), subs, pim, off)
                        ))

                nfl
            ))
    ))

;; Like addstate(), but the new state(s) are put at position "i".
;; Used for zero-width matches, next state to use is the added one.
;; This makes sure the order of states to be tried does not change, which matters for alternatives.

(defn- #_[nfa_list_C int] addstate-here [#_nfa_list_C nfl, #_nfa_state_C state, #_regsubs_C subs, #_nfa_pim_C pim, #_int i]
    ;; first add the state(s) at the end, so that we know how many there are
    (let [o'n (count nfl) nfl (addstate nfl, state, subs, pim, 0)]
        ;; nothing to do if "i" was at the end of the list or no state got added
        (when' (not (any == o'n (inc i) (count nfl))) => [nfl i]
            ;; re-order to put the new state at the current position
            (let [nfl (update nfl :nl_threads #(into (subvec % 0 i) (subvec % o'n) (subvec % (inc i) o'n)))]
                [nfl (dec i)]
            ))
    ))

;; Check character class "cls" against current character "c".

(defn- #_boolean check-char-class [#_int cls, #_int c]
    (condp == cls
        NFA_CLASS_ALNUM     (and (<= 1 c 255) (asc-isalnum c))
        NFA_CLASS_ALPHA     (and (<= 1 c 255) (asc-isalpha c))
        NFA_CLASS_BLANK     (any == c (byte \space) TAB)
        NFA_CLASS_CNTRL     (and (<= 1 c 255) (asc-iscntrl c))
        NFA_CLASS_DIGIT     (asc-isdigit c)
        NFA_CLASS_GRAPH     (and (<= 1 c 255) (asc-isgraph c))
        NFA_CLASS_LOWER     (utf-islower c)
        NFA_CLASS_PRINT     (vim-isprintc c)
        NFA_CLASS_PUNCT     (and (<= 1 c 255) (asc-ispunct c))
        NFA_CLASS_SPACE     (or (<= TAB c CAR) (== c (byte \space)))
        NFA_CLASS_UPPER     (utf-isupper c)
        NFA_CLASS_XDIGIT    (asc-isxdigit c)
        NFA_CLASS_TAB       (== c TAB)
        NFA_CLASS_RETURN    (== c (byte \return))
        NFA_CLASS_BACKSPACE (== c (byte \backspace))
        NFA_CLASS_ESCAPE    (== c ESC)
    ))

;; Check for a match with subexpression "i".
;; Return true if it matches.

(defn- #_boolean match-backref [#_regsubs_C subs, #_int i, #_int' a'len]
    ;; subs: pointers to subexpressions
    ;; len: out: length of match in bytes
    (if (< i (:in_use subs))
        (let [start (... (:rs_start subs) i) end (... (:rs_end subs) i)]
            (cond (or (neg? (:lnum start)) (neg? (:lnum end)))
                (do (reset! a'len 0) true) ;; backref was not set, match an empty string
            (and (== (:lnum start) @reglnum) (== (:lnum end) @reglnum))
                (let [a'n (atom (int (- (:col end) (:col start))))]
                    (if (zero? (cstrncmp (.plus @regline (:col start)), @reginput, a'n))
                        (do (reset! a'len @a'n) true)
                        false
                    ))
            :else
                (== (match-with-backref (:lnum start), (:col start), (:lnum end), (:col end), a'len) RA_MATCH)
            ))
        (do (reset! a'len 0) true) ;; backref was not set, match an empty string
    ))

(defn- #_boolean nfa-re-num-cmp [#_long val, #_int op, #_long pos]
    (condp == op 1 (< val pos) 2 (< pos val) (== val pos)))

(defn- #_boolean pim-before? [#_int c]
    (any == c NFA_START_INVISIBLE_BEFORE, NFA_START_INVISIBLE_BEFORE_FIRST, NFA_START_INVISIBLE_BEFORE_NEG, NFA_START_INVISIBLE_BEFORE_NEG_FIRST))

(defn- #_boolean pim-first? [#_int c]
    (any == c NFA_START_INVISIBLE_FIRST, NFA_START_INVISIBLE_NEG_FIRST, NFA_START_INVISIBLE_BEFORE_FIRST, NFA_START_INVISIBLE_BEFORE_NEG_FIRST))

(defn- #_boolean pim-neg? [#_int c]
    (any == c NFA_START_INVISIBLE_NEG, NFA_START_INVISIBLE_NEG_FIRST, NFA_START_INVISIBLE_BEFORE_NEG, NFA_START_INVISIBLE_BEFORE_NEG_FIRST))

;; Recursively call nfa-regmatch().
;; "pim" is null or contains info about a Postponed Invisible Match (start position).

(defn- #_[window_C int] recursive-regmatch? [#_window_C win, #_nfa_pattern_C pat, #_nfa_state_C state, #_nfa_pim_C pim, #_regsubs_C' a'subs, #_regsubs_C' a'msubs]
    (let [o'reglnum @reglnum o'reginput_col (BDIFF @reginput, @regline) o'nfa_listid @nfa_listid o'nfa_endp @nfa_endp]
        (when (some? pim) ;; start at the position where the postponed match was
            (reset! reginput (.plus @regline (:col (:np_end_pos pim)))))
        (let [#_lpos_C endp
                (when (pim-before? (:c state))
                    ;; The recursive match must end at the current position.
                    ;; When "pim" is not null, it specifies the current position.
                    (let [endp (if (some? pim) (:np_end_pos pim) (lpos_C. @reglnum, (BDIFF @reginput, @regline)))]
                        ;; Go back the specified number of bytes, or as far as the start of
                        ;; the previous line, to try matching "\@<=" or not matching "\@<!".
                        ;; This is very inefficient, limit the number of bytes if possible.
                        (if (<= (:val state) 0)
                            (do (reset! regline (reg-getline (swap! reglnum dec)))
                                (when (nil? @regline) ;; can't go before the first line
                                    (reset! regline (reg-getline (swap! reglnum inc))))
                                (reset! reginput @regline))
                            (do (when (< (BDIFF @reginput, @regline) (:val state))
                                    ;; Not enough bytes in this line, go to end of previous line.
                                    (reset! regline (reg-getline (swap! reglnum dec)))
                                    (if (nil? @regline) ;; can't go before the first line
                                        (do (reset! regline (reg-getline (swap! reglnum inc)))
                                            (reset! reginput @regline))
                                        (reset! reginput (.plus @regline (STRLEN @regline)))
                                    ))
                                (if (<= (:val state) (BDIFF @reginput, @regline))
                                    (do (swap! reginput minus (:val state))
                                        (swap! reginput #(.minus % (us-head-off @regline, %))))
                                    (reset! reginput @regline)
                                )
                            ))
                        endp
                    ))
              ;; Call nfa-regmatch() to check if the current concat matches at this position.
              ;; The concat ends with the node NFA_END_INVISIBLE.
              _ (reset! nfa_endp endp)
              [win #_int ?] (nfa-regmatch? win, pat, (out0 state), a'subs, a'msubs)]
            ;; restore position in input text
            (reset! reglnum o'reglnum)
            (reset! regline (reg-getline @reglnum))
            (reset! reginput (.plus @regline o'reginput_col))
            (reset! nfa_listid o'nfa_listid)
            (reset! nfa_endp o'nfa_endp)
            [win ?])
    ))

;; Estimate the chance of a match with "state" failing.
;; empty match: 0
;; NFA_ANY: 1
;; specific character: 99

(defn- #_int failure-chance [#_nfa_state_C state, #_int depth]
    (if (< 4 depth) ;; detect looping
        1
        (let [#_int c (:c state)]
            (condp ==? c
                NFA_SPLIT
                    (if (or (== (:c (out0 state)) NFA_SPLIT) (== (:c (out1 state)) NFA_SPLIT))
                        1 ;; avoid recursive stuff
                        (min (failure-chance (out0 state), (inc depth)) ;; two alternatives, use the lowest failure chance
                             (failure-chance (out1 state), (inc depth))))

                NFA_ANY
                    1 ;; matches anything, unlikely to fail

               [NFA_MATCH
                NFA_MCLOSE
                NFA_ANY_COMPOSING]
                    0 ;; empty match works always

               [NFA_START_INVISIBLE
                NFA_START_INVISIBLE_FIRST
                NFA_START_INVISIBLE_NEG
                NFA_START_INVISIBLE_NEG_FIRST
                NFA_START_INVISIBLE_BEFORE
                NFA_START_INVISIBLE_BEFORE_FIRST
                NFA_START_INVISIBLE_BEFORE_NEG
                NFA_START_INVISIBLE_BEFORE_NEG_FIRST
                NFA_START_PATTERN]
                    5 ;; recursive-regmatch() is expensive, use low failure chance

               [NFA_BOL
                NFA_EOL
                NFA_BOF
                NFA_EOF
                NFA_NEWL]
                    99

               [NFA_BOW
                NFA_EOW]
                    90

               [NFA_MOPEN
                NFA_MOPEN1
                NFA_MOPEN2
                NFA_MOPEN3
                NFA_MOPEN4
                NFA_MOPEN5
                NFA_MOPEN6
                NFA_MOPEN7
                NFA_MOPEN8
                NFA_MOPEN9
                NFA_NOPEN
                NFA_MCLOSE1
                NFA_MCLOSE2
                NFA_MCLOSE3
                NFA_MCLOSE4
                NFA_MCLOSE5
                NFA_MCLOSE6
                NFA_MCLOSE7
                NFA_MCLOSE8
                NFA_MCLOSE9
                NFA_NCLOSE]
                    (failure-chance (out0 state), (inc depth))

               [NFA_BACKREF1
                NFA_BACKREF2
                NFA_BACKREF3
                NFA_BACKREF4
                NFA_BACKREF5
                NFA_BACKREF6
                NFA_BACKREF7
                NFA_BACKREF8
                NFA_BACKREF9]
                    94 ;; backreferences don't match in many places

               [NFA_LNUM_GT
                NFA_LNUM_LT
                NFA_COL_GT
                NFA_COL_LT
                NFA_VCOL_GT
                NFA_VCOL_LT
                NFA_MARK_GT
                NFA_MARK_LT
                NFA_VISUAL]
                    85 ;; before/after positions don't match very often

                NFA_LNUM
                    90

               [NFA_CURSOR
                NFA_COL
                NFA_VCOL
                NFA_MARK]
                    98 ;; specific positions rarely match

                NFA_COMPOSING
                    95

                (if (< 0 c)
                    95 ;; character match fails often
                    50 ;; something else, includes character classes
                )
            ))
    ))

;; Skip until the char "c" we know a match must start with.

(defn- #_boolean skip-to-start [#_int c, #_int' a'col]
    ;; Used often, do some work to avoid call overhead.
    (let [#_Bytes s (cstrchr (.plus @regline @a'col), c)]
        (if (some? s) (do (reset! a'col (BDIFF s, @regline)) true) false)
    ))

;; Check for a match with "match_text".
;; Called after skip-to-start() has found "regstart".
;; Returns zero for no match, 1 for a match.

(defn- #_long find-match-text [#_int startcol, #_int regstart, #_Bytes match_text]
    (let [a'col (atom (int startcol))]
        (loop []
            (let [[#_boolean match #_int n2]
                    (loop-when [#_int n1 0 n2 (utf-char2len regstart)] (non-eos? match_text n1) => [true n2] ;; skip regstart
                        (let [#_int c1 (us-ptr2char match_text, n1) #_int c2 (us-ptr2char @regline, (+ @a'col n2))]
                            (if (or (== c1 c2) (and @ireg_icase (== (utf-tolower c1) (utf-tolower c2))))
                                (recur (+ n1 (utf-char2len c1)) (+ n2 (utf-char2len c2)))
                                [false n2]
                            ))
                    )]
                ;; check that no composing char follows
                (if (and match (not (utf-iscomposing (us-ptr2char @regline, (+ @a'col n2)))))
                    (do (swap! reg_match assoc-in [:m_startpos 0] (lpos_C. @reglnum @a'col))
                        (swap! reg_match assoc-in [:m_endpos 0] (lpos_C. @reglnum (+ @a'col n2)))
                        1)
                    (do ;; Try finding regstart after the current match.
                        (swap! a'col + (utf-char2len regstart)) ;; skip regstart
                        (recur-if (skip-to-start regstart, a'col) [] => 0)
                    ))
            ))
    ))

;; Main matching routine.
;;
;; Run NFA to determine whether it matches "reginput".
;; When "nfa_endp" is not null, it is a required end-of-match position.
;;
;; Return TRUE if there is a match, FALSE otherwise.
;; When there is a match, @a'msubs contains the positions.
;;
;; Note: caller must ensure that: start != null.

(defn- #_[window_C int] nfa-regmatch? [#_window_C win, #_nfa_pattern_C pat, #_nfa_state_C start, #_regsubs_C' a'subs, #_regsubs_C' a'msubs]
    ;; Some patterns may take a long time to match, especially when using recursive-regmatch().
    ;; Allow interrupting them with CTRL-C.
    (if (or (fast-breakcheck) (and (non-zero? @nfa_time_limit) (profile-passed-limit @nfa_time_limit)))
        [win FALSE]

        (let [a'match (atom (int FALSE)) #_boolean toplevel (== (:c start) NFA_MOPEN)
              #_nfa_list_C ls1 (nfa_list_C. [] #{} false)
              ls1 ;; Inline optimized code for addstate() if we know it's the first MOPEN.
                (when' toplevel => (addstate ls1, start, @a'subs, nil, 0)
                    (let [_ (swap! a'subs #(-> (assoc-in [:rs_start 0] (lpos_C. @reglnum (BDIFF @reginput, @regline))) (assoc :in_use 1)))]
                        (addstate ls1, (out0 start), @a'subs, nil, 0)
                    ))
              a'go_to_nextline (atom (boolean false))]

            ;; Run for each character.
            (loop [win win #_nfa_list_C ls0 nil ls1 ls1] ;; If too many states, retry with the old engine.
                (when' (or (< (swap! nfa_listid inc) NFA_MAX_STATES) (!= (:re_engine pat) AUTOMATIC_ENGINE)) => [win NFA_TOO_EXPENSIVE]

                    (let [ls0 ls1 ls1 (nfa_list_C. [] #{} false)] ;; swap lists
                        ;; If the state lists are empty, we can stop.
                        (if (zero? (count (:nl_threads ls0)))
                            [win @a'match]

                            (let-when [#_int curc (us-ptr2char @reginput)
                                  a'clen (atom (int (if (== curc NUL) (do (reset! a'go_to_nextline false) 0) (us-ptr2len-cc @reginput))))
                                  [win ls0 ls1 ?]
                                    (let-when [[win ls0 ls1 ?] ;; compute "ls1"
                                            (loop-when [win win ls0 ls0 ls1 ls1 #_int i 0] (< i (count (:nl_threads ls0))) => [win ls0 ls1 nil]
                                                (let-when [#_nfa_thread_C t (... (:nl_threads ls0) i) t'state (:th_state t) t'subs (:th_subs t)
                                                      ;; Handle the possible codes of the current state.  The most important is NFA_MATCH.
                                                      m { #_nfa_state_C :add_state nil, #_boolean :add_here false, #_regsubs_C :add_subs nil, #_nfa_pim_C :add_pim nil, #_int :add_off 0, #_int :add_count 0 }
                                                      [win m ?]
                                                        (condp ==? (:c t'state)

                                                            NFA_MATCH
                                                                ;; If the match ends before a composing character and
                                                                ;; "ireg_icombine" is not set, that is not really a match.
                                                                (if (and (not @ireg_icombine) (utf-iscomposing curc))
                                                                    [win m nil]
                                                                    (do (reset! a'match TRUE)
                                                                        (reset! a'msubs t'subs)
                                                                        ;; Found the left-most longest match, do not look at any other states at this position.
                                                                        ;; When the list of states is going to be empty, quit without advancing, so that "reginput" is correct.
                                                                        (when (zero? (count (:nl_threads ls1)))
                                                                            (reset! a'clen 0))
                                                                        [win m :nextchar]
                                                                    ))

                                                           [NFA_END_INVISIBLE NFA_END_INVISIBLE_NEG NFA_END_PATTERN]
                                                                ;; This is only encountered after a NFA_START_INVISIBLE or NFA_START_INVISIBLE_BEFORE node.
                                                                ;; They surround a zero-width group, used with "\@=", "\&", "\@!", "\@<=" and "\@<!".
                                                                ;;
                                                                ;; If we got here, it means that the current "invisible" group finished successfully,
                                                                ;; so return control to the parent nfa-regmatch().
                                                                ;; For a look-behind match only when it ends in the position in "nfa_endp"
                                                                ;; submatches are stored in @a'subs, and used in the parent call.
                                                                ;;
                                                                ;; If "nfa_endp" is set, it's only a match if it ends at "nfa_endp".
                                                                (if (and (some? @nfa_endp) (or (!= @reglnum (:lnum @nfa_endp)) (!= (BDIFF @reginput, @regline) (:col @nfa_endp))))
                                                                    [win m nil]
                                                                    (do (reset! a'match TRUE)
                                                                        ;; do not set submatches for \@!
                                                                        (when (!= (:c t'state) NFA_END_INVISIBLE_NEG)
                                                                            (reset! a'subs t'subs))
                                                                        ;; See comment above at "goto nextchar".
                                                                        (when (zero? (count (:nl_threads ls1)))
                                                                            (reset! a'clen 0))
                                                                        [win m :nextchar]
                                                                    ))

                                                           [NFA_START_INVISIBLE
                                                            NFA_START_INVISIBLE_FIRST
                                                            NFA_START_INVISIBLE_NEG
                                                            NFA_START_INVISIBLE_NEG_FIRST
                                                            NFA_START_INVISIBLE_BEFORE
                                                            NFA_START_INVISIBLE_BEFORE_FIRST
                                                            NFA_START_INVISIBLE_BEFORE_NEG
                                                            NFA_START_INVISIBLE_BEFORE_NEG_FIRST]
                                                                (if (or (some? (:th_pim t)) (pim-first? (:c t'state)))
                                                                    ;; Do it directly if there already is a PIM or when nfa-postprocess() detected it will work better.
                                                                    (let [o'in_use (:in_use @a'subs)
                                                                          _ (swap! a'subs copy-sub-off t'subs)
                                                                          ;; First try matching the invisible match, then what follows.
                                                                          [win #_int ?] (recursive-regmatch? win, pat, t'state, nil, a'subs, a'msubs)]
                                                                        (when' (!= ? NFA_TOO_EXPENSIVE) => (do (reset! a'match ?) [win m :return])
                                                                            ;; For \@! and \@<! it is a match when the result is false.
                                                                            (let [m (when' (!= (!= ? FALSE) (pim-neg? (:c t'state))) => m
                                                                                        ;; "out1" is the corresponding END_INVISIBLE node.
                                                                                        ;; Add its "out0" to the current list (zero-width match).
                                                                                        (assoc m :add_here true :add_state (-> t'state (out1) (out0))
                                                                                            ;; If the pattern has \ze and it matched in the sub pattern, use it.
                                                                                            :add_subs (-> t'subs (copy-sub-off @a'subs) (copy-ze-off @a'subs)))
                                                                                    )]
                                                                                (swap! a'subs assoc :in_use o'in_use)
                                                                                [win m nil])
                                                                        ))
                                                                    ;; First try matching what follows.  Only if a match is found, verify the invisible match matches.
                                                                    ;; Add a nfa_pim_C to the following states, it contains info about the invisible match.
                                                                    (let [pim (nfa_pim_C. NFA_PIM_TODO t'state (NEW_regsubs_C) (lpos_C. @reglnum (BDIFF @reginput, @regline)))]
                                                                        ;; "out1" is the corresponding END_INVISIBLE node.
                                                                        ;; Add its "out0" to the current list (zero-width match).
                                                                        [win (assoc m :add_here true :add_state (-> t'state (out1) (out0)) :add_pim pim) nil]
                                                                    ))

                                                            NFA_START_PATTERN
                                                                ;; There is no point in trying to match the pattern if the output state is not going to be added to the list.
                                                                (when' (not (or (state-in-list ls1, (-> t'state (out1) (out0)),        t'subs)
                                                                                (state-in-list ls1, (-> t'state (out1) (out0) (out0)), t'subs)
                                                                                (state-in-list ls0, (-> t'state (out1) (out0) (out0)), t'subs))) => [win m nil]

                                                                    (let [_ (swap! a'subs copy-sub-off t'subs)
                                                                          [win #_int ?] (recursive-regmatch? win, pat, t'state, nil, a'subs, a'msubs)]
                                                                        (condp == ? NFA_TOO_EXPENSIVE (do (reset! a'match ?) [win m :return]) FALSE [win m nil]
                                                                            ;; Now we need to skip over the matched text and then continue with what follows.
                                                                            ;; TODO: multi-line match
                                                                            (let [#_int blen (- (:col (... (:rs_end @a'subs) 0)) (BDIFF @reginput, @regline))
                                                                                  m (cond
                                                                        ;; Empty match: output of corresponding NFA_END_PATTERN/NFA_SKIP to be used at current position.
                                                                        (zero? blen)      (assoc m :add_here true :add_state (-> t'state (out1) (out0) (out0)))
                                                                        ;; Match current character, output of corresponding NFA_END_PATTERN to be used at next position.
                                                                        (<= blen @a'clen) (assoc m :add_state (-> t'state (out1) (out0) (out0)) :add_off @a'clen)
                                                                        ;; Skip over the matched characters, set character count in NFA_SKIP.
                                                                        :else             (assoc m :add_state (-> t'state (out1) (out0)) :add_off blen :add_count (- blen @a'clen))
                                                                                    )]
                                                                                [win (assoc m :add_subs (copy-sub-off t'subs, @a'subs)) nil]
                                                                            ))
                                                                    ))

                                                            NFA_BOL
                                                                (let [? (BEQ @reginput, @regline)]
                                                                    [win (if ? (assoc m :add_here true :add_state (-> t'state (out0))) m) nil])

                                                            NFA_EOL
                                                                (let [? (== curc NUL)]
                                                                    [win (if ? (assoc m :add_here true :add_state (-> t'state (out0))) m) nil])

                                                            NFA_BOW
                                                                (let [! (or (== curc NUL) (any == (us-get-class @reginput) 0 1 (reg-prev-class)))]
                                                                    [win (if (not !) (assoc m :add_here true :add_state (-> t'state (out0))) m) nil])

                                                            NFA_EOW
                                                                (let [! (or (BEQ @reginput, @regline) (any == (reg-prev-class) 0 1 (us-get-class @reginput)))]
                                                                    [win (if (not !) (assoc m :add_here true :add_state (-> t'state (out0))) m) nil])

                                                            NFA_BOF
                                                                (let [? (and (zero? @reglnum) (BEQ @reginput, @regline) (== @reg_lmin 1))]
                                                                    [win (if ? (assoc m :add_here true :add_state (-> t'state (out0))) m) nil])

                                                            NFA_EOF
                                                                (let [? (and (== @reglnum @reg_lmax) (== curc NUL))]
                                                                    [win (if ? (assoc m :add_here true :add_state (-> t'state (out0))) m) nil])

                                                            NFA_COMPOSING
                                                                (let [#_nfa_state_C s (-> t'state (out0)) #_nfa_state_C e (-> t'state (out1)) ;; NFA_END_COMPOSING
                                                                      ;; Only match composing character(s), ignoring the base character.
                                                                      ;; Used for ".{composing}" and "{composing}" (no preceding character).
                                                                      #_int n (if (utf-iscomposing (:c s)) (utf-char2len curc) 0)
                                                                      ? (cond (and @ireg_icombine (zero? n))
                                                                            ;; If \Z was present, then ignore composing characters.
                                                                            ;; When ignoring the base character, this always matches.
                                                                            (not (and (zero? n) (!= (:c s) curc)))
                                                                        (or (< 0 n) (== (:c s) curc))
                                                                            ;; Check base character matches first, unless ignored.
                                                                            (let [[n s] (if (zero? n) [(+ n (utf-char2len curc)) (out0 s)] [n s])
                                                                                  ;; We don't care about the order of composing characters.
                                                                                  #_int* cc (int-array MAX_MCO) ;; Get them into cc[] first.
                                                                                  #_int k
                                                                                    (loop-when [n n k 0] (< n @a'clen) => k
                                                                                        (let [#_int c (us-ptr2char @reginput, n) _ (aset cc k c) k (inc k) n (+ n (utf-char2len c))]
                                                                                            (recur-if (< k MAX_MCO) [n k] => k))
                                                                                    )]
                                                                                ;; Check that each composing char in the pattern matches a composing char in the text.
                                                                                ;; We do not check if all composing chars are matched.
                                                                                (loop-when s (!= (:c s) NFA_END_COMPOSING) => true
                                                                                    (let [#_int j (loop-when-recur [j 0] (and (< j k) (!= (aget cc j) (:c s))) [(inc j)] => j)]
                                                                                        (recur-if (< j k) (out0 s) => false))
                                                                                ))
                                                                        :else
                                                                            false
                                                                        )]
                                                                    [win (if ? (assoc m :add_state (out0 e) :add_off @a'clen) m) nil])

                                                            NFA_NEWL
                                                                (let [m (when' (and (== curc NUL) (<= @reglnum @reg_lmax)) => m
                                                                            (reset! a'go_to_nextline true)
                                                                            ;; Pass -1 for the offset, which means taking the position at the start of the next line.
                                                                            (assoc m :add_state (-> t'state (out0)) :add_off -1)
                                                                        )]
                                                                    [win m nil])

                                                           [NFA_START_COLL NFA_START_NEG_COLL]
                                                                ;; What follows is a list of characters, until NFA_END_COLL.
                                                                ;; One of them must match or none of them must match.
                                                                ;;
                                                                ;; Never match EOL.
                                                                ;; If it's part of the collection, it is added as a separate state with an OR.
                                                                (when' (!= curc NUL) => [win m nil]
                                                                    (let [! (== (:c t'state) NFA_START_COLL)
                                                                          ? (loop [#_nfa_state_C s (-> t'state (out0))]
                                                                                (condp == (:c s)
                                                                                    NFA_END_COLL
                                                                                        (not !)
                                                                                    NFA_RANGE_MIN
                                                                                        (let [#_int c1 (:val s) s (out0 s) #_int c2 (:val s)] ;; advance to NFA_RANGE_MAX
                                                                                            (cond (<= c1 curc c2)
                                                                                                !
                                                                                            @ireg_icase
                                                                                                (let [#_int l (utf-tolower curc)
                                                                                                      ? (loop-when c1 (<= c1 c2) => false
                                                                                                            (recur-if (!= (utf-tolower c1) l) (inc c1) => true)
                                                                                                        )]
                                                                                                    (recur-if (not ?) [(out0 s)] => !))
                                                                                            :else
                                                                                                (recur (out0 s))
                                                                                            ))
                                                                                    (let [? (if (< (:c s) 0)
                                                                                                (check-char-class (:c s), curc)
                                                                                                (or (== (:c s) curc)
                                                                                                    (and @ireg_icase (== (utf-tolower (:c s)) (utf-tolower curc)))))]
                                                                                        (recur-if (not ?) [(out0 s)] => !)
                                                                                    ))
                                                                            )]
                                                                        ;; Next state is in out0 of the NFA_END_COLL, out1 of START points to the END state.
                                                                        [win (if ? (assoc m :add_state (-> t'state (out1) (out0)) :add_off @a'clen) m) nil]
                                                                    ))

                                                            NFA_ANY
                                                                ;; Any char except NUL, (end of input) does not match.
                                                                (let [? (< 0 curc)]
                                                                    [win (if ? (assoc m :add_state (-> t'state (out0)) :add_off @a'clen) m) nil])

                                                            NFA_ANY_COMPOSING
                                                                ;; On a composing character, skip over it.
                                                                ;; Otherwise do nothing.
                                                                ;; Always matches.
                                                                (let [m (if (utf-iscomposing curc) (assoc m :add_off @a'clen) (assoc m :add_here true :add_off 0))]
                                                                    [win (assoc m :add_state (-> t'state (out0))) nil])

                                                            ;; Character classes like \a for alpha, \d for digit, etc.

                                                            NFA_IDENT     ;;  \i
                                                                (let [? (vim-isidentc curc)]
                                                                    [win (if ? (assoc m :add_state (-> t'state (out0)) :add_off @a'clen) m) nil])

                                                            NFA_SIDENT    ;;  \I
                                                                (let [? (and (not (asc-isdigit curc)) (vim-isidentc curc))]
                                                                    [win (if ? (assoc m :add_state (-> t'state (out0)) :add_off @a'clen) m) nil])

                                                            NFA_KWORD     ;;  \k
                                                                (let [? (us-iswordp @reginput)]
                                                                    [win (if ? (assoc m :add_state (-> t'state (out0)) :add_off @a'clen) m) nil])

                                                            NFA_SKWORD    ;;  \K
                                                                (let [? (and (not (asc-isdigit curc)) (us-iswordp @reginput))]
                                                                    [win (if ? (assoc m :add_state (-> t'state (out0)) :add_off @a'clen) m) nil])

                                                            NFA_FNAME     ;;  \f
                                                                (let [? (vim-isfnamec curc)]
                                                                    [win (if ? (assoc m :add_state (-> t'state (out0)) :add_off @a'clen) m) nil])

                                                            NFA_SFNAME    ;;  \F
                                                                (let [? (and (not (asc-isdigit curc)) (vim-isfnamec curc))]
                                                                    [win (if ? (assoc m :add_state (-> t'state (out0)) :add_off @a'clen) m) nil])

                                                            NFA_PRINT     ;;  \p
                                                                (let [? (vim-isprintc (us-ptr2char @reginput))]
                                                                    [win (if ? (assoc m :add_state (-> t'state (out0)) :add_off @a'clen) m) nil])

                                                            NFA_SPRINT    ;;  \P
                                                                (let [? (and (not (asc-isdigit curc)) (vim-isprintc (us-ptr2char @reginput)))]
                                                                    [win (if ? (assoc m :add_state (-> t'state (out0)) :add_off @a'clen) m) nil])

                                                            NFA_WHITE     ;;  \s
                                                                (let [? (vim-iswhite curc)]
                                                                    [win (if ? (assoc m :add_state (-> t'state (out0)) :add_off @a'clen) m) nil])

                                                            NFA_NWHITE    ;;  \S
                                                                (let [? (and (!= curc NUL) (not (vim-iswhite curc)))]
                                                                    [win (if ? (assoc m :add_state (-> t'state (out0)) :add_off @a'clen) m) nil])

                                                            NFA_DIGIT     ;;  \d
                                                                (let [? (ri-digit curc)]
                                                                    [win (if ? (assoc m :add_state (-> t'state (out0)) :add_off @a'clen) m) nil])

                                                            NFA_NDIGIT    ;;  \D
                                                                (let [? (and (!= curc NUL) (not (ri-digit curc)))]
                                                                    [win (if ? (assoc m :add_state (-> t'state (out0)) :add_off @a'clen) m) nil])

                                                            NFA_HEX       ;;  \x
                                                                (let [? (ri-hex curc)]
                                                                    [win (if ? (assoc m :add_state (-> t'state (out0)) :add_off @a'clen) m) nil])

                                                            NFA_NHEX      ;;  \X
                                                                (let [? (and (!= curc NUL) (not (ri-hex curc)))]
                                                                    [win (if ? (assoc m :add_state (-> t'state (out0)) :add_off @a'clen) m) nil])

                                                            NFA_OCTAL     ;;  \o
                                                                (let [? (ri-octal curc)]
                                                                    [win (if ? (assoc m :add_state (-> t'state (out0)) :add_off @a'clen) m) nil])

                                                            NFA_NOCTAL    ;;  \O
                                                                (let [? (and (!= curc NUL) (not (ri-octal curc)))]
                                                                    [win (if ? (assoc m :add_state (-> t'state (out0)) :add_off @a'clen) m) nil])

                                                            NFA_WORD      ;;  \w
                                                                (let [? (ri-word curc)]
                                                                    [win (if ? (assoc m :add_state (-> t'state (out0)) :add_off @a'clen) m) nil])

                                                            NFA_NWORD     ;;  \W
                                                                (let [? (and (!= curc NUL) (not (ri-word curc)))]
                                                                    [win (if ? (assoc m :add_state (-> t'state (out0)) :add_off @a'clen) m) nil])

                                                            NFA_HEAD      ;;  \h
                                                                (let [? (ri-head curc)]
                                                                    [win (if ? (assoc m :add_state (-> t'state (out0)) :add_off @a'clen) m) nil])

                                                            NFA_NHEAD     ;;  \H
                                                                (let [? (and (!= curc NUL) (not (ri-head curc)))]
                                                                    [win (if ? (assoc m :add_state (-> t'state (out0)) :add_off @a'clen) m) nil])

                                                            NFA_ALPHA     ;;  \a
                                                                (let [? (ri-alpha curc)]
                                                                    [win (if ? (assoc m :add_state (-> t'state (out0)) :add_off @a'clen) m) nil])

                                                            NFA_NALPHA    ;;  \A
                                                                (let [? (and (!= curc NUL) (not (ri-alpha curc)))]
                                                                    [win (if ? (assoc m :add_state (-> t'state (out0)) :add_off @a'clen) m) nil])

                                                            NFA_LOWER     ;;  \l
                                                                (let [? (ri-lower curc)]
                                                                    [win (if ? (assoc m :add_state (-> t'state (out0)) :add_off @a'clen) m) nil])

                                                            NFA_NLOWER    ;;  \L
                                                                (let [? (and (!= curc NUL) (not (ri-lower curc)))]
                                                                    [win (if ? (assoc m :add_state (-> t'state (out0)) :add_off @a'clen) m) nil])

                                                            NFA_UPPER     ;;  \\u (sic!)
                                                                (let [? (ri-upper curc)]
                                                                    [win (if ? (assoc m :add_state (-> t'state (out0)) :add_off @a'clen) m) nil])

                                                            NFA_NUPPER    ;;  \U
                                                                (let [? (and (!= curc NUL) (not (ri-upper curc)))]
                                                                    [win (if ? (assoc m :add_state (-> t'state (out0)) :add_off @a'clen) m) nil])

                                                            NFA_LOWER_IC  ;; [a-z]
                                                                (let [? (or (ri-lower curc) (and @ireg_icase (ri-upper curc)))]
                                                                    [win (if ? (assoc m :add_state (-> t'state (out0)) :add_off @a'clen) m) nil])

                                                            NFA_NLOWER_IC ;; [^a-z]
                                                                (let [? (and (!= curc NUL) (not (or (ri-lower curc) (and @ireg_icase (ri-upper curc)))))]
                                                                    [win (if ? (assoc m :add_state (-> t'state (out0)) :add_off @a'clen) m) nil])

                                                            NFA_UPPER_IC  ;; [A-Z]
                                                                (let [? (or (ri-upper curc) (and @ireg_icase (ri-lower curc)))]
                                                                    [win (if ? (assoc m :add_state (-> t'state (out0)) :add_off @a'clen) m) nil])

                                                            NFA_NUPPER_IC ;; [^A-Z]
                                                                (let [? (and (!= curc NUL) (not (or (ri-upper curc) (and @ireg_icase (ri-lower curc)))))]
                                                                    [win (if ? (assoc m :add_state (-> t'state (out0)) :add_off @a'clen) m) nil])

                                                           [NFA_BACKREF1
                                                            NFA_BACKREF2
                                                            NFA_BACKREF3
                                                            NFA_BACKREF4
                                                            NFA_BACKREF5
                                                            NFA_BACKREF6
                                                            NFA_BACKREF7
                                                            NFA_BACKREF8
                                                            NFA_BACKREF9] ;; \1 .. \9
                                                                (let [a'blen (atom (int)) ? (match-backref t'subs, (inc (- (:c t'state) NFA_BACKREF1)), a'blen)
                                                                      m (when' ? => m
                                                                            (cond
                                                                                (zero? @a'blen)     ;; Empty match always works, output of NFA_SKIP to be used next.
                                                                                    (assoc m :add_here true :add_state (-> t'state (out0) (out0)))
                                                                                (<= @a'blen @a'clen) ;; Match current character, jump ahead to out0 of NFA_SKIP.
                                                                                    (assoc m :add_state (-> t'state (out0) (out0)) :add_off @a'clen)
                                                                                :else               ;; Skip over the matched characters, set character count in NFA_SKIP.
                                                                                    (assoc m :add_state (-> t'state (out0)) :add_off @a'blen :add_count (- @a'blen @a'clen))
                                                                            )
                                                                        )]
                                                                    [win m nil])

                                                            NFA_SKIP
                                                                ;; character of previous matching \1 .. \9  or \@>
                                                                (let [m (if (<= (- (:th_count t) @a'clen) 0)
                                                                            ;; end of match, go to what follows
                                                                            (assoc m :add_state (-> t'state (out0)) :add_off @a'clen)
                                                                            ;; add state again with decremented count
                                                                            (assoc m :add_state t'state :add_off 0 :add_count (- (:th_count t) @a'clen))
                                                                        )]
                                                                    [win m nil])

                                                           [NFA_LNUM NFA_LNUM_GT NFA_LNUM_LT]
                                                                (let [? (nfa-re-num-cmp (:val t'state), (- (:c t'state) NFA_LNUM), (+ @reglnum @reg_lmin))]
                                                                    [win (if ? (assoc m :add_here true :add_state (-> t'state (out0))) m) nil])

                                                           [NFA_COL NFA_COL_GT NFA_COL_LT]
                                                                (let [? (nfa-re-num-cmp (:val t'state), (- (:c t'state) NFA_COL), (inc (BDIFF @reginput, @regline)))]
                                                                    [win (if ? (assoc m :add_here true :add_state (-> t'state (out0))) m) nil])

                                                           [NFA_VCOL NFA_VCOL_GT NFA_VCOL_LT]
                                                                (let [#_int op (- (:c t'state) NFA_VCOL) #_int col (BDIFF @reginput, @regline)]
                                                                    ;; Bail out quickly when there can't be a match, avoid the overhead of win-linetabsize() on long lines.
                                                                    (let-when [vcol (:val t'state)] (or (== op 1) (<= col (* vcol MB_MAXBYTES))) => [win m nil]
                                                                        ;; Guess that a character won't use more columns than 'tabstop', with a minimum of 4.
                                                                        (let [ts (max 4 @(:b_p_ts @curbuf))
                                                                              ? (and (== op 1) (< vcol (dec col)) (< 100 col) (< (* vcol ts) col))
                                                                              ? (or ? (nfa-re-num-cmp vcol, op, (inc (win-linetabsize win, @regline, col))))]
                                                                            [win (if ? (assoc m :add_here true :add_state (-> t'state (out0))) m) nil])
                                                                    ))

                                                           [NFA_MARK NFA_MARK_GT NFA_MARK_LT]
                                                                (let [#_pos_C pos (getmark win, (:val t'state)) #_int c (:c t'state)
                                                                      ;; Compare the mark position to the match position.
                                                                      ? (and (some? pos) (< 0 (:lnum pos))
                                                                             (if (== (:lnum pos) (+ @reglnum @reg_lmin))
                                                                                 (if (== (:col pos) (BDIFF @reginput, @regline))
                                                                                     (== c NFA_MARK)
                                                                                     (if (< (:col pos) (BDIFF @reginput, @regline))
                                                                                         (== c NFA_MARK_GT)
                                                                                         (== c NFA_MARK_LT)))
                                                                                 (if (< (:lnum pos) (+ @reglnum @reg_lmin))
                                                                                     (== c NFA_MARK_GT)
                                                                                     (== c NFA_MARK_LT)))
                                                                        )]
                                                                    [win (if ? (assoc m :add_here true :add_state (-> t'state (out0))) m) nil])

                                                            NFA_CURSOR
                                                                (let [cursor (:w_cursor win)
                                                                      ? (and (== (+ @reglnum @reg_lmin) (:lnum cursor)) (== (BDIFF @reginput, @regline) (:col cursor)))]
                                                                    [win (if ? (assoc m :add_here true :add_state (-> t'state (out0))) m) nil])

                                                            NFA_VISUAL
                                                                (let [? (reg-match-visual win)]
                                                                    [win (if ? (assoc m :add_here true :add_state (-> t'state (out0))) m) nil])

                                                           [NFA_MOPEN1 NFA_MOPEN2 NFA_MOPEN3 NFA_MOPEN4 NFA_MOPEN5 NFA_MOPEN6 NFA_MOPEN7 NFA_MOPEN8 NFA_MOPEN9
                                                            NFA_NOPEN
                                                            NFA_ZSTART]
                                                                ;; These states are only added to be able to bail out when they are added again, nothing is to be done.
                                                                [win m nil]

                                                            ;; regular character
                                                            (let [#_int c (:c t'state)
                                                                  ? (== c curc) ? (if (and (not ?) @ireg_icase) (== (utf-tolower c) (utf-tolower curc)) ?)]
                                                                ;; If "ireg_icombine" is not set, only skip over the character itself.
                                                                ;; When it is set, skip over composing characters.
                                                                (when (and ? (not @ireg_icombine))
                                                                    (reset! a'clen (utf-char2len curc)))
                                                                [win (if ? (assoc m :add_state (-> t'state (out0)) :add_off @a'clen) m) nil])

                                                        )] (not ?) => [win ls0 ls1 ?]

                                                    (let [[win ls0 ls1 i]
                                                            (when' (some? (:add_state m)) => [win ls0 ls1 i]
                                                                (let-when [[win m #_nfa_pim_C pim ?]
                                                                        (let-when [pim (:add_pim m)] (nil? pim) => [win m pim nil]
                                                                            ;; Handle the PIM if the match might end without advancing and before the end of the line.
                                                                            (let-when [pim (:th_pim t)] (and (some? pim) (or (zero? @a'clen) (match-follows (:add_state m), 0))) => [win m pim nil]
                                                                                (let [[win pim #_int ?]
                                                                                        (when' (== (:np_result pim) NFA_PIM_TODO) => [win pim (if (== (:np_result pim) NFA_PIM_MATCH) TRUE FALSE)]
                                                                                            (let [[win ?] (recursive-regmatch? win, pat, (:np_state pim), pim, a'subs, a'msubs)
                                                                                                  pim (assoc pim :np_result (if (!= ? FALSE) NFA_PIM_MATCH NFA_PIM_NOMATCH))
                                                                                                  ;; For \@! and \@<! it is a match when the result is false.
                                                                                                  pim (when' (!= (!= ? FALSE) (pim-neg? (:c (:np_state pim)))) => pim
                                                                                                        (update pim :np_subs copy-sub-off @a'subs)
                                                                                                    )]
                                                                                                [win pim ?])
                                                                                        )]
                                                                                    ;; For \@! and \@<! it is a match when the result is false.
                                                                                    (if (!= (!= ? FALSE) (pim-neg? (:c (:np_state pim))))
                                                                                        ;; PIM was handled, don't add it to the following states.
                                                                                        [win (assoc m :add_subs (copy-sub-off t'subs, (:np_subs pim))) nil nil]
                                                                                        ;; Look-behind match failed, don't add the state.
                                                                                        [win m nil :recur]
                                                                                    ))
                                                                            ))
                                                                ] (not ?) => [win ls0 ls1 i]

                                                                    (let [t'subs (or (:add_subs m) t'subs)]
                                                                        (if (:add_here m)
                                                                            (let [[ls0 i] (addstate-here ls0, (:add_state m), t'subs, pim, i)]
                                                                                [win ls0 ls1 i])
                                                                            (let [ls1 (addstate ls1, (:add_state m), t'subs, pim, (:add_off m))
                                                                                  ls1 (when' (< 0 (:add_count m)) => ls1
                                                                                        (assoc-in ls1 [:nl_threads (dec (count (:nl_threads ls1))) :th_count] (:add_count m))
                                                                                    )]
                                                                                [win ls0 ls1 i]
                                                                            ))
                                                                    ))
                                                            )]
                                                        (recur win ls0 ls1 (inc i))
                                                    ))
                                            )] (not ?) => [win ls0 ls1 (when (== ? :return) ?)]

                                        ;; Look for the start of a match in the current position by adding the start state to the list of states.
                                        ;; The first found match is the leftmost one, thus the order of states matters!  Do not add the start state
                                        ;; in recursive calls of nfa-regmatch(), because recursive calls should only start in the first position.
                                        ;; Unless "nfa_endp" is not null, we match the end position.  Also don't start a match past the first line.
                                        (when' (and (== @a'match FALSE)
                                                    (or (and toplevel (== @reglnum 0) (non-zero? @a'clen) (or (== @ireg_maxcol 0) (< (BDIFF @reginput, @regline) @ireg_maxcol)))
                                                        (and (some? @nfa_endp)
                                                             (or (< @reglnum (:lnum @nfa_endp))
                                                                 (and (== @reglnum (:lnum @nfa_endp)) (< (BDIFF @reginput, @regline) (:col @nfa_endp))))))) => [win ls0 ls1 nil]
                                            ;; Inline optimized code for addstate() if we know the state is the first MOPEN.
                                            (cond toplevel
                                                (let-when [#_boolean add?
                                                        (when' (and (!= (:regstart pat) NUL) (non-zero? @a'clen)) => true
                                                            (if (zero? (count (:nl_threads ls1)))
                                                                (let [a'col (atom (int (+ (BDIFF @reginput, @regline) @a'clen)))]
                                                                    ;; "ls1" is empty, we can skip ahead to the
                                                                    ;; character that must appear at the start.
                                                                    (when' (skip-to-start (:regstart pat), a'col) => nil
                                                                        (reset! reginput (.plus @regline (- @a'col @a'clen)))
                                                                        true
                                                                    ))
                                                                ;; Checking if the required start character match
                                                                ;; is cheaper than adding a state that won't match.
                                                                (let [#_int c (us-ptr2char @reginput, @a'clen)]
                                                                    (or (== c (:regstart pat)) (and @ireg_icase (== (utf-tolower c) (utf-tolower (:regstart pat)))))
                                                                ))
                                                        )] (some? add?) => [win ls0 ls1 :return]

                                                    (when' add? => [win ls0 ls1 nil]
                                                        (let [_ (swap! a'subs assoc-in [:rs_start 0 :col] (+ (BDIFF @reginput, @regline) @a'clen))]
                                                            [win ls0 (addstate ls1, (out0 start), @a'subs, nil, @a'clen) nil])
                                                    ))
                                            :else
                                                [win ls0 (addstate ls1, start, @a'subs, nil, @a'clen) nil]
                                            ))
                                    )] (not ?) => [win @a'match]

                                ;; Advance to the next character, or advance to the next line, or finish.
                                (let [? (cond (non-zero? @a'clen)
                                            (do (swap! reginput plus @a'clen) nil)
                                        (or @a'go_to_nextline (and (some? @nfa_endp) (< @reglnum (:lnum @nfa_endp))))
                                            (do (reg-nextline) nil)
                                        :else
                                            :finish
                                        )]
                                    ;; Allow interrupting with CTRL-C.
                                    (when' (and (not ?) (not (slow-breakcheck))) => [win @a'match]

                                        ;; Check for timeout once in 20 times to avoid overhead.
                                        (let [? (when (and (non-zero? @nfa_time_limit) (== (swap! nfa_time_count inc) 20))
                                                    (reset! nfa_time_count 0)
                                                    (when (profile-passed-limit @nfa_time_limit)
                                                        :timeout)
                                                )]
                                            (recur-if (not ?) [win ls0 ls1] => [win @a'match]))
                                    ))
                            ))
                    ))
            ))
    ))

;; Try matching "pat" at regline[col].
;; Return <= 0 for failure, number of lines contained in the match otherwise.

(defn- #_[window_C long] nfa-regtry? [#_window_C win, #_nfa_pattern_C pat, #_int col, #_long nsec]
    ;; nsec: timeout limit or 0
    (reset! reginput (.plus @regline col))
    (reset! nfa_time_limit nsec)
    (reset! nfa_time_count 0)
    (let [a'subs (atom (#_regsubs_C object (new-regsubs))) a'msubs (atom (#_regsubs_C object (new-regsubs)))
          [win #_int ?] (nfa-regmatch? win, pat, (:start pat), a'subs, a'msubs)]
        (condp == ? FALSE [win 0] NFA_TOO_EXPENSIVE [win ?]
            (do
                (loop-when-recur [#_int i 0] (< i (:in_use @a'msubs)) [(inc i)]
                    (swap! reg_match assoc-in [:m_startpos i] (... (:rs_start @a'msubs) i))
                    (swap! reg_match assoc-in [:m_endpos i] (... (:rs_end @a'msubs) i)))
                (when (neg? (:lnum (... (:m_startpos @reg_match) 0)))
                    (swap! reg_match assoc-in [:m_startpos 0] (lpos_C. 0 col)))
                ;; Pattern has a \ze, but it didn't match, use current end.  ;; Use line number of \ze.
                (let-when [e (:lnum (... (:m_endpos @reg_match) 0))] (neg? e) => (reset! reglnum e)
                    (swap! reg_match assoc-in [:m_endpos 0] (lpos_C. @reglnum (BDIFF @reginput, @regline))))
                [win (+ 1 @reglnum)]
            ))
    ))

;; Compile a regular expression into internal code for the NFA matcher.
;; Returns the program in allocated space.  Returns null for an error.

(defn- #_[window_C pattern_C] nfa-regcomp? [#_window_C win, #_Bytes expr, #_int re_flags]
    (when' (some? expr) => [win nil]
        (reset! nfa_re_flags re_flags)
        (nfa-regcomp-start expr, re_flags)
        (let [[win #_nfa_pattern_C pat]
                ;; Build postfix form of the regexp.  Needed to build the NFA.
                (let-when [[win #_int* postfix] (re2post? win)] (some? postfix) => [win nil] ;; cascaded (syntax?) error
                    (let-when [ ;; Build the NFA.
                          [win #_nfa_state_C* states #_nfa_state_C start] (post2nfa? win, postfix)
                    ] (some? start) => [win nil]

                        [win (-> (NEW_nfa_pattern_C)
                            (assoc :states      states)
                            (assoc :start       start)
                            (assoc :regflags    @regflags)
                            (assoc :regexec     nfa-regexec?)
                            (assoc :has_zend    @nfa_has_zend)
                            (assoc :has_backref @nfa_has_backref)
                            (nfa-postprocess)
                            (assoc :reganch     (nfa-get-reganch start, 0))
                            (assoc :regstart    (nfa-get-regstart start, 0))
                            (assoc :match_text  (nfa-get-match-text start))
                            (assoc :rex         (STRDUP expr))
                        )]
                    )
                )]
            (reset! post_array nil)
            [win #_pattern_C pat]
        )
    ))

;; Match a regexp against multiple lines.
;; "matcher.m_pattern" is a compiled regexp as returned by vim-regcomp().
;;
;; Return <= 0 if there is no match.  Return number of lines contained in the match otherwise.

(defn- #_[window_C matcher_C long] nfa-regexec? [#_window_C win, #_matcher_C matcher, #_long lnum, #_int col, #_long nsec]
    ;; lnum, col: pos to start looking for match
    ;; nsec: timeout limit or 0
    (reset! reg_match matcher)
    (reset! reg_lmin lnum)
    (reset! reg_lmax (- (line-count @curbuf) lnum))
    (reset! ireg_icase (:m_icase matcher))
    (reset! ireg_icombine false)
    (reset! ireg_maxcol (:m_maxcol matcher))

    (let-when [#_nfa_pattern_C pat (:m_pattern matcher) #_Bytes line (reg-getline 0)] (and (some? pat) (some? line)) => [(emsg win, e_null) matcher 0] ;; Be paranoid...
        ;; If pattern contains "\c" or "\C", overrule value of "ireg_icase".
        (cond
            (flag? (:regflags pat) RF_ICASE)   (reset! ireg_icase true)
            (flag? (:regflags pat) RF_NOICASE) (reset! ireg_icase false)
        )
        ;; If pattern contains "\Z", overrule value of "ireg_icombine".
        (when (flag? (:regflags pat) RF_ICOMBINE)
            (reset! ireg_icombine true))

        (reset! regline line)
        (reset! reglnum 0) ;; relative to line

        (reset! nfa_has_zend (:has_zend pat))
        (reset! nfa_has_backref (:has_backref pat))
        (reset! nfa_listid 1)

        (when' (not (and (:reganch pat) (< 0 col))) => [win matcher 0]
            (swap! reg_match cleanup-subexpr)
            (let-when [a'col (atom (int col))
                  _ (when (!= (:regstart pat) NUL)
                        ;; Skip ahead until a character we know the match must start with.
                        ;; When there is none, there is no match.
                        (cond (not (skip-to-start (:regstart pat), a'col))
                            0
                        ;; If "match_text" is set, it contains the full text that must match.
                        ;; Nothing else to try.  Doesn't handle combining chars well.
                        (and (some? (:match_text pat)) (not @ireg_icombine))
                            (find-match-text @a'col, (:regstart pat), (:match_text pat))
                        ))
            ] (nil? _) => [win matcher _]

                ;; If the start column is past the maximum column, no need to try.
                (when' (not (<= 1 @ireg_maxcol @a'col)) => [win matcher 0]
                    (let [[win ?] (nfa-regtry? win, pat, @a'col, nsec)]
                        [win matcher ?]
                    ))
            ))
    ))

;; ----------------------------------------------------------------------- ;;

;; Compile a regular expression into internal code.
;; Returns the program in allocated memory.
;; Returns null for an error.

(defn- #_[window_C pattern_C] vim-regcomp? [#_window_C win, #_Bytes expr, #_int re_flags]
    ;; Check for prefix "\%#=", that sets the regexp engine.
    (let [[win #_int re_engine expr]
            (when' (zero? (STRNCMP expr, (u8 "\\%#="), 4)) => [win @p_re expr]
                (let [#_int n (- (.at expr 4) (byte \0))]
                    (if (any == n AUTOMATIC_ENGINE BACKTRACKING_ENGINE NFA_ENGINE)
                        [win n (.plus expr 5)]
                        (let [win (emsg win, (u8 "E864: \\%#= can only be followed by 0, 1, or 2. The automatic engine will be used."))]
                            [win AUTOMATIC_ENGINE expr]
                        ))
                ))
          ;; First try the NFA engine, unless backtracking was requested.
          [win #_pattern_C pat]
            (if (!= re_engine BACKTRACKING_ENGINE)
                (nfa-regcomp? win, expr, (+ re_flags (if (== re_engine AUTOMATIC_ENGINE) RE_AUTO 0)))
                (bt-regcomp? win, expr, re_flags))
          ;; Check for error compiling regexp with initial engine.
          [win re_engine pat]
            (when' (and (nil? pat) (== re_engine AUTOMATIC_ENGINE)) => [win re_engine pat]
                ;; If the NFA engine failed, try the backtracking engine.
                ;; The NFA engine also fails for patterns that it can't handle well but are still valid patterns, thus a retry should work.
                (let [[win pat] (bt-regcomp? win, expr, re_flags)]
                    [win BACKTRACKING_ENGINE pat])
            )]
        ;; Store the info needed to call regcomp() again when the engine turns out to be very slow executing it.
        [win (when (some? pat) (assoc pat :re_engine re_engine, :re_flags re_flags))]
    ))

(defn- #_void report-re-switch [#_Bytes expr]
    (when (< 0 @p_verbose)
        (msg-puts (u8 "Switching to backtracking RE engine for pattern: "))
        (msg-puts expr))
    nil)

;; Match a regexp against multiple lines.
;; "mat.m_pattern" is a compiled regexp as returned by vim-regcomp().
;; Note: "mat.m_pattern" may be freed and changed.
;;
;; Return zero if there is no match.  Return number of lines contained in the match otherwise.

(defn- #_[window_C matcher_C long] vim-regexec? [#_window_C win, #_matcher_C mat, #_long lnum, #_int col, #_long nsec]
    ;; lnum: nr of line to start looking for match
    ;; col: column to start looking for match
    ;; nsec: timeout limit or 0
    (let [[win mat #_long nof] ((:regexec (:m_pattern mat)) win, mat, lnum, col, nsec) #_pattern_C pat (:m_pattern mat)]
        ;; NFA engine aborted because it's very slow.
        (when' (and (== (:re_engine pat) AUTOMATIC_ENGINE) (== nof NFA_TOO_EXPENSIVE)) => [win mat (max 0, nof)]
            (let [o'p_re @p_re _ (reset! p_re BACKTRACKING_ENGINE)
                  mat (assoc mat :m_pattern nil)
                  #_Bytes expr (STRDUP (:rex #_nfa_pattern_C pat))
                  [win mat nof]
                    (when' (some? expr) => [win mat nof]
                        (report-re-switch expr)
                        (let [[win pat] (vim-regcomp? win, expr, (:re_flags pat)) mat (assoc mat :m_pattern pat)]
                            (when' (some? pat) => [win mat nof]
                                ((:regexec pat) win, mat, lnum, col, nsec)
                            ))
                    )]
                (reset! p_re o'p_re)
                [win mat (max 0, nof)]
            ))
    ))

;;; ============================================================================================== VimP

;; search.c: code for normal mode searching commands ----------------------------------------------

;; Various search-related routines.  These fall into three groups:
;; 1. string searches (for /, ?, n, and N)
;; 2. character searches within a single line (for f, F, t, T, etc)
;; 3. "other" kinds of searches like the '%' command, and 'word' searches.

;; String searches
;;
;; The string search functions are divided into two levels:
;; lowest: searchit(); uses a pos_C for starting position and found match,
;; highest: do-search(); uses "w_cursor"; calls searchit().
;;
;; The last search pattern is remembered for repeating the same search.
;; This pattern is shared between the :g, :s, ? and / commands.
;; This is in search-regcomp().
;;
;; The actual string matching is done using a heavily modified version of
;; Henry Spencer's regular expression library.  See regexp.c.

;; The offset for a search command is store in a soff struct.
;; Note: only spats[0].sp_off is really used.
(class! #_final soffset_C
    [
        (field byte         dir)            ;; search direction, '/' or '?'
        (field boolean      line)           ;; search has line offset
        (field boolean      end)            ;; search set cursor at end
        (field long         off)            ;; line or char offset
    ])

;; A search pattern and its attributes are stored in a spat struct.
(class! #_final spat_C
    [
        (field Bytes        pat)            ;; the pattern (in allocated memory) or null
        (field boolean      magic)          ;; magicness of the pattern
        (field boolean      no_scs)         ;; no smartcase for this pattern
        (field soffset_C    sp_off      (NEW_soffset_C))
    ])

(defn- #_spat_C new-spat []
    (-> (NEW_spat_C) (assoc :magic true) (assoc-in [:sp_off :dir] (byte \/))))

;; Two search patterns are remembered: one for the :substitute command and one for other searches.
;; "last_idx" points to the one that was used the last time.

(atom! spat_C* #_"/*[2]*/" spats
    [
        (new-spat),         ;; last used search pat
        (new-spat)          ;; last used substitute pat
    ])
(atom! int last_idx)        ;; index in spats[] for RE_LAST

(atom! Bytes last_expr)     ;; pattern used by search-regcomp()

;; Translate search pattern for vim-regcomp().
;;
;; re_save == RE_SEARCH: save "expr" in spats[RE_SEARCH].pat (normal search cmd)
;; re_save == RE_SUBST: save "expr" in spats[RE_SUBST].pat (:substitute command)
;; re_save == RE_BOTH: save "expr" in both patterns (:global command)
;;
;; re_use  == RE_SEARCH: use previous search pattern if "expr" is null
;; re_use  == RE_SUBST: use previous substitute pattern if "expr" is null
;; re_use  == RE_LAST: use last used pattern if "expr" is null
;;
;; options & SEARCH_HIST: put search string in history
;; options & SEARCH_KEEP: keep previous search pattern
;;
;; returns false if failed, true otherwise

(defn- #_[window_C matcher_C boolean] search-regcomp? [#_window_C win, #_matcher_C mat, #_Bytes expr, #_int re_save, #_int re_use, #_int options]
    (let-when [mat (if (nil? mat) (NEW_matcher_C) mat)
          _ (reset! rc_did_emsg false)
          ;; If no pattern given, use a previously defined pattern.
          [win [expr magic :as _]]
            (if (or (nil? expr) (eos? expr))
                (let [i (if (== re_use RE_LAST) @last_idx re_use) si (... @spats i)]
                    (if (nil? (:pat si)) ;; pattern was never defined
                        (do (reset! rc_did_emsg true)
                            [(emsg win, (if (== re_use RE_SUBST) e_nopresub e_noprevre)) nil])
                        (do (reset! no_smartcase (:no_scs si))
                            [win [(:pat si) (:magic si)]])
                    ))
                (do (when (flag? options SEARCH_HIST) ;; put new pattern in history
                        (add-to-history HIST_SEARCH, expr, NUL))
                    [win [expr @p_magic]]
                ))
    ] (some? _) => [win mat false]

        (reset! last_expr expr)
        ;; Save the currently used pattern in the appropriate place, unless the pattern should not be remembered.
        (when (non-flag? options SEARCH_KEEP)
            (when (any == re_save RE_SEARCH RE_BOTH) (save-re-pat RE_SEARCH, expr, magic)) ;; search or global command
            (when (any == re_save RE_SUBST RE_BOTH)  (save-re-pat RE_SUBST, expr, magic))  ;; substitute or global command
        )
        (let [[win ?] (vim-regcomp? win, expr, (if magic RE_MAGIC 0)) mat (assoc mat :m_icase (re-ignorecase? expr), :m_maxcol 0, :m_pattern ?)]
            [win mat (some? (:m_pattern mat))]
        )
    ))

(defn- #_void save-re-pat [#_int idx, #_Bytes pat, #_boolean magic]
    (when (BNE (:pat (... @spats idx)), pat)
        (swap! spats update idx assoc :pat (STRDUP pat) :magic magic :no_scs @no_smartcase)
        (reset! last_idx idx)
        ;; If 'hlsearch' set and search 'pat' changed: need redraw.
        (when @p_hls
            (redraw-all-later SOME_VALID))
        (reset! no_hlsearch false))
    nil)

;; Return true when case should be ignored for search pattern "expr".
;; Uses the 'ignorecase' and 'smartcase' options.

(defn- #_boolean re-ignorecase? [#_Bytes expr]
    (let [#_boolean ic @p_ic ic (if (and ic (not @no_smartcase) @p_scs) (not (re-has-uppercase? expr)) ic)]
        (reset! no_smartcase false)
        ic
    ))

;; Return true if pattern "expr" has uppercase character.

(defn- #_boolean re-has-uppercase? [#_Bytes expr]
    (loop-when [#_Bytes s expr] (non-eos? s) => false
        (let [#_int n (us-ptr2len-cc s)
              n (cond (< 1 n)
                    (if (utf-isupper (us-ptr2char s)) 0 n)
                (at? s (byte \\))
                    (cond
                        (and (at? s 1 (byte \_)) (non-eos? s 2)) 3 ;; skip "\_X"
                        (and (at? s 1 (byte \%)) (non-eos? s 2)) 3 ;; skip "\%X"
                                                 (non-eos? s 1)  2 ;; skip "\X"
                        :else 1)
                (utf-isupper (.at s 0))
                    0
                :else
                    1)]
            (recur-if (pos? n) [(.plus s n)] => true)
        )
    ))

(defn- #_Bytes last-search-expr []
    (:pat (... @spats @last_idx)))

;; Get a regexp program for the last used search pattern.
;; This is used for highlighting all matches in a window.

(defn- #_[window_C matcher_C] last-search-matcher? [#_window_C win, #_matcher_C mat]
    (when' (some? (last-search-expr)) => [win (assoc mat :m_pattern nil)]
        (let [_ (swap! emsg_off inc) [win mat _] (search-regcomp? win, mat, (u8 ""), 0, @last_idx, SEARCH_KEEP) _ (swap! emsg_off dec)]
            [win mat])
    ))

(final Bytes
    top_bot_msg (u8 "search hit TOP, continuing at BOTTOM"),
    bot_top_msg (u8 "search hit BOTTOM, continuing at TOP"))

;; Lowest level search function.
;; Search for "count"th occurrence of pattern "expr" in direction "dir".
;; Start at position "pos" and return the found position in "pos".
;;
;; if (options & SEARCH_MSG) == 0            don't give any messages
;; if (options & SEARCH_MSG) == SEARCH_MSG   give all messages
;; if (options & SEARCH_HIST)                put search pattern in history
;; if (options & SEARCH_END)                 return position at end of match
;; if (options & SEARCH_START)               accept match at "pos" itself
;; if (options & SEARCH_KEEP)                keep previous search pattern
;; if (options & SEARCH_PEEK)                check for typed char, cancel search
;;
;; re_use:    which pattern to use when "expr" is empty
;; stop_lnum: stop after this line number when != 0
;; nsec:      timeout limit or 0
;;
;; Returns the index of the first matching subpattern plus one; one if there was none.

(defn- #_[window_C pos_C int] searchit? [#_window_C win, #_pos_C pos, #_int dir, #_Bytes expr, #_long count, #_int options, #_int re_use, #_long stop_lnum, #_long nsec]
    (let [[win #_matcher_C mat ?] (search-regcomp? win, nil, expr, RE_SEARCH, re_use, (& options (| SEARCH_HIST SEARCH_KEEP)))]
        (if (not ?)
            (let [win (when' (and (flag? options SEARCH_MSG) (not @rc_did_emsg)) => win
                        (emsg* win, (u8 "E383: Invalid search string: %s"), @last_expr)
                    )]
                [win pos 0])

            (let [o'called_emsg @called_emsg _ (reset! called_emsg false)
                  a'submatch (atom (int 0)) a'first_match (atom (boolean true)) a'break_loop (atom (boolean false))
                  a'found (atom (boolean)) lmax (line-count @curbuf)
                  [win pos count #_long lnum]
                    (loop [win win pos pos count count]
                        ;; When not accepting a match at the start position, set "extra_col" to a non-zero value.
                        ;; Don't do that when starting at MAXCOL, since MAXCOL + 1 is zero.
                        (let [#_int extra_col
                                (cond (or (flag? options SEARCH_START) (== (:col pos) MAXCOL))
                                    0
                                ;; Watch out for the "col" being MAXCOL - 2, used in a closed fold.
                                (and (!= dir BACKWARD) (<= 1 (:lnum pos) lmax) (< (:col pos) (- MAXCOL 2)))
                                    (let [#_Bytes s (.plus (ml-get (:lnum pos)) (:col pos))]
                                        (if (eos? s) 1 (us-ptr2len-cc s)))
                                :else
                                    1)
                              o'pos pos                                 ;; remember start pos for detecting no match
                              _ (reset! a'found false)                  ;; default: not found
                              a'at_first_line (atom (boolean true))     ;; default: start in first line
                              pos (if (zero? (:lnum pos))               ;; correct lnum for when starting in line 0
                                    (do (reset! a'at_first_line false)  ;; not in first line now
                                        (assoc pos :lnum 1 :col 0))
                                    pos)
                              ;; Start searching in current line, unless searching backwards and we're in column 0.
                              ;; If we are searching backwards in column 0 and not including the current position, gain some efficiency by skipping back a line.
                              ;; Otherwise begin the search in the current line.
                              lnum (if (and (== dir BACKWARD) (zero? (:col o'pos)) (non-flag? options SEARCH_START))
                                    (do (reset! a'at_first_line false)
                                        (dec (:lnum pos)))
                                    (:lnum pos))
                              [win pos lnum]
                                (loop-when [win win pos pos lnum lnum #_int round 0] (< round 2) => [win pos lnum] ;; loop twice if 'wrapscan' set
                                    (let [[win pos lnum]
                                            (loop-when [win win pos pos lnum lnum] (<= 1 lnum lmax) => [win pos lnum]
                                                ;; Stop after checking "stop_lnum", if it's set.
                                                (cond (and (non-zero? stop_lnum) (if (== dir FORWARD) (< stop_lnum lnum) (< lnum stop_lnum)))
                                                    [win pos lnum]
                                                ;; Stop after passing the 'nsec' time limit.
                                                (and (non-zero? nsec) (profile-passed-limit nsec))
                                                    [win pos lnum]
                                                :else
                                                    ;; Look for a match somewhere in line "lnum".
                                                    (let [[win mat #_long nof] (vim-regexec? win, mat, lnum, 0, nsec)]
                                                        ;; Abort searching on an error (e.g. out of stack).
                                                        (cond @called_emsg
                                                            [win pos lnum]
                                                        (< 0 nof)
                                                            ;; match may actually be in another line when using \zs
                                                            (let-when [#_lpos_C start (... (:m_startpos mat) 0) #_lpos_C end (... (:m_endpos mat) 0)
                                                                  _ (reset! a'submatch (first-submatch mat))
                                                                  ;; "lnum" may be past end of buffer for "\n\zs"
                                                                  #_Bytes line (if (< lmax (+ lnum (:lnum start))) (u8 "") (ml-get (+ lnum (:lnum start))))
                                                                  ;; Forward search in the first line: match should be after the start position.
                                                                  ;; If not, continue at the end of the match (this is vi compatible) or on the next char.
                                                                  [win t*]
                                                                    (let-when [t* [mat nof start end line]] (and (== dir FORWARD) @a'at_first_line) => [win t*]
                                                                        ;; When the match starts in a next line, it's certainly past the start position.
                                                                        ;; When match lands on a NUL, the cursor will be put one back afterwards,
                                                                        ;; compare with that position, otherwise "/$" will get stuck at EOL.
                                                                        (loop-when [win win [mat nof start end line :as t*] t*]
                                                                                   (and (zero? (:lnum start))
                                                                                        (if (and (flag? options SEARCH_END) @a'first_match)
                                                                                            (and (== nof 1) (< (dec (:col end)) (+ (:col o'pos) extra_col)))
                                                                                            (< (- (:col start) (if (eos? line (:col start)) 1 0)) (+ (:col o'pos) extra_col))))
                                                                                => [win t*]
                                                                            ;; If searching is vi-compatible, continue at the end
                                                                            ;; of the match, else continue one position forward.
                                                                            (let-when [#_int i
                                                                                    (if (some? (vim-strbyte @p_cpo, CPO_SEARCH))
                                                                                        (if (< 1 nof)
                                                                                            nil ;; end is in next line, thus no match in this line
                                                                                            (let [i (:col end)]
                                                                                                ;; for empty match: advance one char
                                                                                                (if (and (== i (:col start)) (non-eos? line i)) (+ i (us-ptr2len-cc line, i)) i)
                                                                                            ))
                                                                                        (let [i (:col start)]
                                                                                            (if (non-eos? line i) (+ i (us-ptr2len-cc line, i)) i)
                                                                                        ))
                                                                            ] (some? i) => [win nil]

                                                                                (if (and (zero? i) (flag? options SEARCH_START))
                                                                                    [win t*]
                                                                                    (let [[win mat nof] (vim-regexec? win, mat, (+ lnum (:lnum start)), i, nsec)]
                                                                                        (if (or (eos? line i) (zero? nof))
                                                                                            [win nil]
                                                                                            (let [start (... (:m_startpos mat) 0) end (... (:m_endpos mat) 0)]
                                                                                                (reset! a'submatch (first-submatch mat))
                                                                                                ;; Need to get the line pointer again,
                                                                                                ;; a multi-line search may have made it invalid.
                                                                                                (recur win [mat nof start end (ml-get (+ lnum (:lnum start)))]))
                                                                                        ))
                                                                                ))
                                                                        ))
                                                            ] (some? t*) => (do (reset! a'at_first_line false) (recur win pos lnum))

                                                                (let-when [[win [start end :as t']]
                                                                        (let-when [[mat nof start end line] t*] (== dir BACKWARD) => [win [start end]]
                                                                            ;; Now, if there are multiple matches on this line, we have to get the last one.
                                                                            ;; Or the last one before the cursor, if we're on that line.
                                                                            ;; When putting the new cursor at the end, compare relative to the end of the match.
                                                                            (loop-when [win win mat mat nof nof t' nil line line]
                                                                                       (or (non-zero? round)
                                                                                           (if (flag? options SEARCH_END)
                                                                                               (let [end (... (:m_endpos mat) 0)]
                                                                                                   (or (< (+ lnum (:lnum end)) (:lnum o'pos))
                                                                                                       (and (== (+ lnum (:lnum end)) (:lnum o'pos))
                                                                                                            (<= (+ (dec (:col end)) extra_col) (:col o'pos)))))
                                                                                               (let [start (... (:m_startpos mat) 0)]
                                                                                                   (or (< (+ lnum (:lnum start)) (:lnum o'pos))
                                                                                                       (and (== (+ lnum (:lnum start)) (:lnum o'pos))
                                                                                                            (<= (+ (:col start) extra_col) (:col o'pos)))))))
                                                                                    => [win t']
                                                                                ;; Remember a position that is before the start position,
                                                                                ;; we use it if it's the last match in the line.
                                                                                ;; Always accept a position after wrapping around.
                                                                                (let-when [[start end :as t'] [(... (:m_startpos mat) 0) (... (:m_endpos mat) 0)]
                                                                                      _ (reset! a'submatch (first-submatch mat))
                                                                                      ;; We found a valid match, now check if there is another one after it.
                                                                                      ;; If searching is vi-compatible, continue at the end of the match,
                                                                                      ;; else continue one position forward.
                                                                                      #_int i
                                                                                        (if (some? (vim-strbyte @p_cpo, CPO_SEARCH))
                                                                                            (if (< 1 nof)
                                                                                                nil
                                                                                                (let [i (:col end)]
                                                                                                    ;; for empty match: advance one char
                                                                                                    (if (and (== i (:col start)) (non-eos? line i)) (+ i (us-ptr2len-cc line, i)) i)
                                                                                                ))
                                                                                            ;; Stop when the match is in a next line.
                                                                                            (if (< 0 (:lnum start))
                                                                                                nil
                                                                                                (let [i (:col start)] (if (non-eos? line i) (+ i (us-ptr2len-cc line, i)) i))
                                                                                            ))
                                                                                ] (some? i) => [win t']

                                                                                    (let [[win mat nof] (vim-regexec? win, mat, (+ lnum (:lnum start)), i, nsec)]
                                                                                        (if (or (eos? line i) (zero? nof))
                                                                                            [win t']
                                                                                            ;; Need to get the line pointer again,
                                                                                            ;; a multi-line search may have made it invalid.
                                                                                            (recur win mat nof t' (ml-get (+ lnum (:lnum start)))))
                                                                                    ))
                                                                            )) ;; If there is only a match after the cursor, skip this match.
                                                                ] (some? t') => (do (reset! a'at_first_line false) (recur win pos lnum))

                                                                    ;; With the SEARCH_END option, move to the last character of the match.
                                                                    ;; Don't do it for an empty match, end should be same as start then.
                                                                    (let [pos (if (and (flag? options SEARCH_END) (non-flag? options SEARCH_NOOF)
                                                                                       (or (!= (:lnum start) (:lnum end)) (!= (:col start) (:col end))))
                                                                                ;; For a match in the first column,
                                                                                ;; set the position on the NUL in the previous line.
                                                                                (let [pos (assoc pos :lnum (+ lnum (:lnum end)) :col (:col end))]
                                                                                    (if (zero? (:col end))
                                                                                        (if (< 1 (:lnum pos)) ;; just in case
                                                                                            (let [pos (update pos :lnum dec)]
                                                                                                (assoc pos :col (STRLEN (ml-get (:lnum pos)))))
                                                                                            pos)
                                                                                        (let-when [pos (update pos :col dec)] (<= (:lnum pos) lmax) => pos
                                                                                            (let [#_Bytes s (ml-get (:lnum pos))]
                                                                                                (update pos :col #(- % (us-head-off s, (.plus s %))))
                                                                                            ))
                                                                                    ))
                                                                                (assoc pos :lnum (+ lnum (:lnum start)) :col (:col start)))
                                                                          pos (assoc pos :coladd 0)]
                                                                        (reset! a'found true)
                                                                        (reset! a'first_match false)
                                                                        ;; Set variables used for 'incsearch' highlighting.
                                                                        (reset! search_match_lines (- (:lnum end) (:lnum start)))
                                                                        (reset! search_match_endcol (:col end))
                                                                        [win pos lnum])
                                                                ))
                                                        (slow-breakcheck) ;; stop if CTRL-C typed
                                                            [win pos lnum]
                                                        ;; Cancel searching if a character was typed.  Used for 'incsearch'.
                                                        ;; Don't check too often, that would slow searching down considerably.
                                                        (and (flag? options SEARCH_PEEK) (zero? (& (- lnum (:lnum pos)) 0x3f)) (char-avail))
                                                            (do (reset! a'break_loop true)
                                                                [win pos lnum])
                                                        (and (non-zero? round) (== lnum (:lnum o'pos)))
                                                            [win pos lnum] ;; if second round, stop where started
                                                        :else
                                                            (do (reset! a'at_first_line false)
                                                                (recur win pos (+ lnum dir))
                                                            ))
                                                    ))
                                            )]
                                        (reset! a'at_first_line false)
                                        ;; Stop the search if 'wrapscan' isn't set, "stop_lnum" is specified,
                                        ;; after an interrupt, after a match and after looping twice.
                                        (if (or (not @p_ws) (non-zero? stop_lnum) @got_int @called_emsg @a'break_loop @a'found (non-zero? round))
                                            [win pos lnum]
                                            ;; If 'wrapscan' is set, we continue at the other end of the file.
                                            ;; This message is also remembered in "keep_msg" for when the screen is redrawn.
                                            ;; "keep_msg" is cleared whenever another message is written.
                                            (let [lnum (if (== dir BACKWARD) lmax 1) ;; start second round at the other end
                                                  win (when' (flag? options SEARCH_MSG) => win
                                                        (give-warning win, (if (== dir BACKWARD) top_bot_msg bot_top_msg), true)
                                                    )]
                                                (recur win pos lnum (inc round)))
                                        ))
                                )]
                            (if (or @got_int @called_emsg @a'break_loop)
                                [win pos count lnum]
                                (let [count (dec count)]
                                    (recur-if (and (< 0 count) @a'found) [win pos count] => [win pos count lnum])) ;; stop after count matches or no match
                            ))
                    )]
                (swap! called_emsg #(or % o'called_emsg))
                (if (not @a'found)
                    (let [win (cond @got_int
                                (emsg win, e_interr)
                            (== (& options SEARCH_MSG) SEARCH_MSG)
                                (cond
                                    @p_ws        (emsg* win, e_patnotf2, @last_expr)
                                    (zero? lnum) (emsg* win, (u8 "E384: search hit TOP without match for: %s"), @last_expr)
                                    :else        (emsg* win, (u8 "E385: search hit BOTTOM without match for: %s"), @last_expr))
                            :else
                                win
                            )]
                        [win pos 0])
                    ;; A pattern like "\n\zs" may go past the last line.
                    (let [pos (if (< lmax (:lnum pos))
                                (let [pos (assoc pos :lnum lmax, :col (STRLEN (ml-get lmax)))]
                                    (if (< 0 (:col pos)) (update pos :col dec) pos))
                                pos
                            )]
                        [win pos (+ 1 @a'submatch)]
                    ))
            ))
    ))

;; Return the number of the first subpat that matched.

(defn- #_int first-submatch [#_matcher_C m]
    (loop-when [i 1] (neg? (:lnum (... (:m_startpos m) i))) => i
        (recur-if (< i 9) [(inc i)] => 0)
    ))

;; Highest level search function.
;;
;; Search for the "count"th occurrence of pattern "pat" in direction "dirc".
;;
;; If "dirc" is 0,              use previous direction.
;; If "pat" is null or empty,   use previous pattern.
;;
;; If (options & SEARCH_REV),   go in reverse of previous direction.
;; If (options & SEARCH_ECHO),  echo the search command and handle options.
;; If (options & SEARCH_MSG),   may give error message.
;; If (options & SEARCH_OPT),   interpret optional flags.
;; If (options & SEARCH_HIST),  put search pattern in history.
;; If (options & SEARCH_NOOF),  don't add offset to position.
;; If (options & SEARCH_MARK),  set previous context mark.
;; If (options & SEARCH_KEEP),  keep previous search pattern.
;; If (options & SEARCH_START), accept match at curpos itself.
;; If (options & SEARCH_PEEK),  check for typed char, cancel search.
;;
;; dirc: '/' or '?'
;; nsec: timeout limit or 0
;;
;; Careful: If spats[0].sp_off.line == true and spats[0].sp_off.off == 0,
;; this makes the movement linewise without moving the match position.
;;
;; Return 0 for failure, 1 for found, 2 for found and line offset added.

(defn- #_[window_C int boolean] do-search? [#_window_C win, #_byte dirc, #_Bytes pat, #_long count, #_int options, #_long nsec]
    ;; A line offset is not remembered, this is Vi compatible.
    (when (and (:line (:sp_off (... @spats RE_SEARCH))) (some? (vim-strbyte @p_cpo, CPO_LINEOFF)))
        (swap! spats update-in [0 :sp_off] assoc :line false :off 0))
    ;; Save the values for when (options & SEARCH_KEEP) is used.
    (let [#_soffset_C o'off (:sp_off (... @spats RE_SEARCH))
          ;; Find out the direction of the search.
          dirc (get-in (if (zero? dirc) @spats (swap! spats assoc-in [0 :sp_off :dir] dirc)) [0 :sp_off :dir])
          dirc (if (flag? options SEARCH_REV) (if (== dirc (byte \/)) (byte \?) (byte \/)) dirc)
          ;; Turn 'hlsearch' highlighting back on.
          _ (when (and @no_hlsearch (non-flag? options SEARCH_KEEP))
                (redraw-all-later SOME_VALID)
                (reset! no_hlsearch false))
          a'inclusive (atom (boolean false))
          a'strcopy (atom (#_Bytes object nil))
          ;; Repeat the search when pattern followed by ';', e.g. "/foo/;?bar".
          [win #_pos_C pos #_int found]
            (loop [win win pos (:w_cursor win) dirc dirc pat pat]
                (let-when [[win [#_Bytes sea pat :as _]]
                        (if (or (nil? pat) (eos? pat) (at? pat dirc))   ;; no previous pattern
                            (if (some? (:pat (... @spats RE_SEARCH)))
                                [win [(u8 "") pat]]                     ;; make search-regcomp() use spats[RE_SEARCH].pat
                                (let-when [pat (:pat (... @spats RE_SUBST))] (some? pat) => [(emsg win, e_noprevre) nil]
                                    [win [pat pat]]
                                ))
                            [win [pat pat]]                             ;; use previous pattern
                        )] (some? _) => [win pos 0]

                    (let [[sea pat #_Bytes dircp]
                            (if (and (some? pat) (non-eos? pat))        ;; look for (new) offset
                                ;; Find end of regular expression.
                                ;; If there is a matching '/' or '?', toss it.
                                (let [o'p @a'strcopy #_Bytes p (skip-regexp pat, dirc, @p_magic, a'strcopy)
                                      [sea pat]
                                        (if (BNE @a'strcopy, o'p)
                                            (do ;; made a copy of "pat" to change "\?" to "?"
                                                (swap! searchcmdlen + (- (STRLEN pat) (STRLEN @a'strcopy)))
                                                [@a'strcopy @a'strcopy])
                                            [sea pat])
                                      [dircp p]
                                        (if (at? p dirc)
                                            [(eos! p) (.plus p 1)]      ;; remember where we put the NUL
                                            [nil p])
                                      _ (swap! spats update-in [0 :sp_off] assoc :line false :end false :off 0)
                                      ;; Check for a line offset or a character offset.
                                      ;; For get-address() (echo off) we don't check for a character offset,
                                      ;; because it is meaningless and the 's' could be a substitute command.
                                      p (cond (or (at? p (byte \+)) (at? p (byte \-)) (asc-isdigit (.at p 0)))
                                            (do (swap! spats assoc-in [0 :sp_off :line] true)
                                                p)
                                        (and (flag? options SEARCH_OPT) (or (at? p (byte \e)) (at? p (byte \s)) (at? p (byte \b))))
                                            (do (when (at? p (byte \e)) ;; end
                                                    (swap! spats assoc-in [0 :sp_off :end] (!= SEARCH_END 0)))
                                                (.plus p 1))
                                        :else
                                            p)
                                      p (let-when [digit? (asc-isdigit (.at p 0))] (or digit? (at? p (byte \+)) (at? p (byte \-))) => p
                                            (let [#_long off ;; got an offset
                                                    (cond
                                                        (or digit? (asc-isdigit (.at p 1))) ;; 'nr' or '+nr' or '-nr'
                                                            (ร .atol libC p)
                                                        (at? p (byte \-)) ;; single '-'
                                                            -1
                                                        :else ;; single '+'
                                                            1
                                                    )]
                                                (swap! spats assoc-in [0 :sp_off :off] off)
                                                (loop-when-recur [p (.plus p 1)] (asc-isdigit (.at p 0)) [(.plus p 1)] => p)) ;; skip number
                                        )]
                                    ;; compute length of search command for get-address()
                                    (swap! searchcmdlen + (BDIFF p, pat))
                                    [sea p dircp]) ;; put "pat" after search command
                                [sea pat nil]
                            )]
                        (when (and (flag? options SEARCH_ECHO) (messaging))
                            (let [#_Bytes p (if (eos? sea) (last-search-expr) sea)
                                  #_Bytes buf (Bytes. (+ (STRLEN p) 40)) sof (:sp_off (... @spats RE_SEARCH))]
                                (.be buf 0, dirc)
                                (if (utf-iscomposing (us-ptr2char p))
                                    (do ;; Use a space to draw the composing char on.
                                        (.be buf 1, (byte \space))
                                        (STRCPY (.plus buf 2), p))
                                    (STRCPY (.plus buf 1), p))
                                (when (or (:line sof) (:end sof) (non-zero? (:off sof)))
                                    (let [p (-> (.plus buf (STRLEN buf)) (.be 0, dirc) (.plus 1))
                                          p (cond
                                                (:end sof)        (-> p (.be 0, (byte \e)) (.plus 1))
                                                (not (:line sof)) (-> p (.be 0, (byte \s)) (.plus 1))
                                                :else                 p)
                                          p (if (or (< 0 (:off sof)) (:line sof))
                                                (-> p (.be 0, (byte \+)) (.plus 1))
                                                p
                                            )]
                                        (if (or (non-zero? (:off sof)) (:line sof))
                                            (ร .sprintf libC p, (u8 "%ld"), (:off sof))
                                            (eos! p))
                                    ))
                                (msg-start)
                                (let [#_Bytes t (msg-strtrunc buf)]
                                    (msg-outtrans (if (some? t) t buf))
                                    (msg-clr-eos)
                                    (msg-check)
                                    (gotocmdline false)
                                    (out-flush)
                                    (reset! msg_nowait true)) ;; don't wait for this message
                            ))
                        ;; If there is a character offset, subtract it from the current position, so we don't get stuck at "?pat?e+2" or "/pat/s-2".
                        ;; Skip this if pos.col is near MAXCOL (closed fold).
                        ;; This is not done for a line offset, because then we would not be vi compatible.
                        (let [lmax (line-count @curbuf)
                              pos (let-when [sof (:sp_off (... @spats RE_SEARCH))] (and (not (:line sof)) (non-zero? (:off sof)) (< (:col pos) (- MAXCOL 2))) => pos
                                    (let [#_long i (:off sof)]
                                        (if (< 0 i)
                                            (let [[pos i] (loop-when [pos pos i i] (non-zero? i) => [pos i]
                                                    (let [[pos ?] (decl? pos)] (recur-if (!= ? -1) [pos (dec i)] => [pos i])))]
                                                (if (non-zero? i)                   ;; at start of buffer
                                                    (assoc pos :lnum 0 :col MAXCOL) ;; allow lnum == 0 here
                                                    pos
                                                ))
                                            (let [[pos i] (loop-when [pos pos i i] (non-zero? i) => [pos i]
                                                    (let [[pos ?] (incl? pos)] (recur-if (!= ? -1) [pos (inc i)] => [pos i])))]
                                                (if (non-zero? i)                   ;; at end of buffer
                                                    (assoc pos :lnum (inc lmax) :col 0)
                                                    pos
                                                ))
                                        )))
                              flags (+ (if (:end (:sp_off (... @spats RE_SEARCH))) SEARCH_REV 0)
                                       (& options (| SEARCH_KEEP SEARCH_PEEK SEARCH_HIST SEARCH_MSG SEARCH_START (if (and (some? pat) (at? pat (byte \;))) 0 SEARCH_NOOF))))
                              [win pos #_int sm1] (searchit? win, pos, (if (== dirc (byte \/)) FORWARD BACKWARD), sea, count, flags, RE_LAST, 0, nsec)]
                            (when (some? dircp)
                                (.be dircp 0, dirc)) ;; restore second '/' or '?' for normal-cmd()
                            (if (zero? sm1)
                                [win pos 0]

                                (let [_ (when (:end (:sp_off (... @spats RE_SEARCH)))
                                            (reset! a'inclusive true))              ;; 'e' includes last character
                                      a'found (atom (int 1))                        ;; pattern found
                                      ;; Add character and/or line offset.
                                      pos
                                        (if (or (non-flag? options SEARCH_NOOF) (and (some? pat) (at? pat (byte \;))))
                                            (cond (:line (:sp_off (... @spats RE_SEARCH)))  ;; add the offset to the line number
                                                (let [#_long i (+ (:lnum pos) (:off (:sp_off (... @spats RE_SEARCH))))]
                                                    (reset! a'found 2)              ;; pattern found, line offset added
                                                    (assoc pos :lnum (cond (< i 1) 1 (< lmax i) lmax :else i) :col 0))
                                            (< (:col pos) (- MAXCOL 2))             ;; just in case
                                                (let [#_long i (:off (:sp_off (... @spats RE_SEARCH)))]
                                                    (if (< 0 i)
                                                        (loop-when [pos pos i i] (< 0 i) => pos ;; to the right, check for end of file
                                                            (let [[pos ?] (incl? pos)] (recur-if (!= ? -1) [pos (dec i)] => pos)))
                                                        (loop-when [pos pos i i] (< i 0) => pos ;; to the left, check for start of file
                                                            (let [[pos ?] (decl? pos)] (recur-if (!= ? -1) [pos (inc i)] => pos)))
                                                    ))
                                            :else
                                                pos)
                                            pos
                                        )]
                                    ;; The search command can be followed by a ';' to do another search, e.g. "/pat/;/foo/+3;?bar".
                                    ;; This is like doing another search command, except:
                                    ;; - The remembered direction '/' or '?' is from the first search.
                                    ;; - When an error happens the cursor isn't moved at all.
                                    ;; Don't do this when called by get-address() (it handles ';' itself).
                                    (if (or (non-flag? options SEARCH_OPT) (nil? pat) (not-at? pat (byte \;)))
                                        [win pos @a'found]

                                        (let [pat (.plus pat 1) dirc (.at pat 0)]
                                            (when' (any == dirc (byte \?) (byte \/)) => [(emsg win, (u8 "E386: Expected '?' or '/' after ';'")) pos 0]
                                                (recur win pos dirc (.plus pat 1)))
                                        ))
                                ))
                        ))
                ))
          win (when' (non-zero? found) => win
                (let [win (if (flag? options SEARCH_MARK) (setpcmark win) win)]
                    (assoc win :w_cursor pos :w_set_curswant true))
            )]
        (when (flag? options SEARCH_KEEP)
            (swap! spats assoc-in [0 :sp_off] o'off))
        [win found @a'inclusive]
    ))

;; Character Searches

(atom! int sc__lastc NUL)       ;; last character searched for
(atom! int sc__lastcdir)        ;; last direction of character search
(atom! boolean sc__last_t_cmd)  ;; last search t_cmd

(final Bytes sc__bytes (Bytes. (inc MB_MAXBYTES)))
(atom! int sc__bytelen 1)       ;; >1 for multi-byte char

;; Search for a character in a line.
;; If "t_cmd" is false, move to the position of the character, otherwise move to just before the char.
;; Do this "cap.count1" times.
;; Return false or true.

(defn- #_[window_C cmdarg_C boolean] searchc? [#_window_C win, #_cmdarg_C cap, #_boolean t_cmd]
    (let-when [#_int c (:nchar cap) #_int dir (:arg cap) #_long count (:count1 cap)
          [c dir t_cmd #_boolean stop :as _]
            (cond (!= c NUL)                    ;; normal search: remember args for repeat
                (do (when (not @key_stuffed)    ;; don't remember when redoing
                        (reset! sc__lastc c)
                        (reset! sc__lastcdir dir)
                        (reset! sc__last_t_cmd t_cmd)
                        (reset! sc__bytelen (utf-char2bytes c, sc__bytes))
                        (when (non-zero? (:ncharC1 cap))
                            (swap! sc__bytelen #(+ % (utf-char2bytes (:ncharC1 cap), (.plus sc__bytes %))))
                            (when (non-zero? (:ncharC2 cap))
                                (swap! sc__bytelen #(+ % (utf-char2bytes (:ncharC2 cap), (.plus sc__bytes %)))))
                        ))
                    [c dir t_cmd true])
            (!= @sc__lastc NUL)
                (let [c @sc__lastc ;; for multi-byte, re-use last "sc__bytes" and "sc__bytelen"
                      dir (if (non-zero? dir) (- @sc__lastcdir) @sc__lastcdir) ;; repeat in opposite direction
                      t_cmd @sc__last_t_cmd]
                    ;; Force a move of at least one char, so ";" and "," will move the cursor,
                    ;; even if the cursor is right in front of a char we are looking for.
                    [c dir t_cmd (not (and (nil? (vim-strbyte @p_cpo, CPO_SCOLON)) (== count 1) t_cmd))]
                ))
    ] (some? _) => [win cap false]

        (let-when [cap (assoc-in cap [:oap :inclusive] (!= dir BACKWARD))
              #_Bytes s (ml-get (:lnum (:w_cursor win))) #_int i (:col (:w_cursor win)) #_int n (STRLEN s)
              i (loop-when [i i stop stop count count] (< 0 count) => i
                    (let [i (loop [i i stop stop]
                                (let [i (if (< 0 dir)
                                            (let [i (+ i (us-ptr2len-cc s, i))] (when (< i n) i))
                                            (when (< 0 i) (- i (inc (us-head-off s, (.plus s (dec i))))))
                                        )]
                                    (when (some? i)
                                        (let [? (if (== @sc__bytelen 1)
                                                    (and (at? s i c) stop)
                                                    (and (zero? (MEMCMP (.plus s i), sc__bytes, @sc__bytelen)) stop)
                                                )]
                                            (recur-if (not ?) [i true] => i))
                                    ))
                            )]
                        (when (some? i)
                            (recur i true (dec count)))
                    ))
        ] (some? i) => [win cap false]

            (let [i (if t_cmd
                        (let [i (- i dir)]                         ;; backup to before the char (possibly double-byte)
                            (if (< dir 0)
                                (+ i (dec @sc__bytelen))           ;; landed on the search char, which is "sc__bytelen" long
                                (- i (us-head-off s, (.plus s i))) ;; to previous char, which may be multi-byte
                            ))
                        i
                    )]
                [(assoc-in win [:w_cursor :col] i) cap true]
            ))
    ))

;; "Other" Searches

;; Find the matching paren or brace.
;;
;; Improvement over vi: Braces inside quotes are ignored.

(defn- #_pos_C findmatch [#_window_C win, #_int initc]
    (findmatchlimit win, initc, 0, 0))

;; Find the matching paren or brace, if it exists within "maxtravel" lines of here.
;; A "maxtravel" of 0 means search until falling off the edge of the file.
;;
;; "initc" is the character to find a match for.
;; NUL means to find the character at or after the cursor.
;;
;; flags: FM_BLOCKSTOP  stop at start/end of block ({ or } in column 0)

(defn- #_pos_C findmatchlimit [#_window_C win, #_int _initc, #_int flags, #_int maxtravel]
    (let-when [#_boolean cpo_match (some? (vim-strbyte @p_cpo, CPO_MATCH))  ;; vi compatible matching
          #_boolean cpo_bsl (some? (vim-strbyte @p_cpo, CPO_MATCHBSL))      ;; don't recognize backslashes
          a'initc (atom (int _initc))
          a'findc (atom (int NUL))                                          ;; matching brace
          a'backwards (atom (boolean false))
          a'match_escaped (atom (int 0))                                    ;; search for escaped match
          #_pos_C pos (assoc (:w_cursor win) :coladd 0)
          #_Bytes line (ml-get (:lnum pos))                                 ;; pointer to current line
          pos (if (!= @a'initc NUL)
                ;; If "initc" given, look in the table for the matching character.
                (let [_ (find-mps-values a'initc, a'findc, a'backwards, true)]
                    (when (!= @a'findc NUL) pos))
                ;; If no "initc" was given, find the brace under or after the cursor.
                ;; If beyond the end of the line, use the last character in the line.
                (let [pos (if (and (at? line (:col pos) NUL) (non-zero? (:col pos))) (update pos :col dec) pos)
                      pos (loop [pos pos]
                            (let-when [_ (reset! a'initc (us-ptr2char line, (:col pos)))] (!= @a'initc NUL) => pos
                                (let-when [_ (find-mps-values a'initc, a'findc, a'backwards, false)] (== @a'findc NUL) => pos
                                    (recur (update pos :col #(+ % (us-ptr2len-cc line, %))))
                                ))
                        )]
                    (when (!= @a'findc NUL)
                        (when (not cpo_bsl) ;; Set "match_escaped" if there are an odd number of backslashes.
                            (let [a'col (atom (int (:col pos))) #_int n (loop-when-recur [n 0] (check-prevcol line, @a'col, (byte \\), a'col) [(inc n)] => n)]
                                (reset! a'match_escaped (& n 1))
                            ))
                        pos)
                ))
    ] (some? pos) => pos

        (let [lmax (line-count @curbuf)
              a'count (atom (int 0))                                    ;; cumulative number of braces
              a'do_quotes (atom (int -1))                               ;; check for quotes in current line
              a'start_in_quotes (atom (maybean MAYBE))                  ;; start position is in quotes
              a'inquote (atom (boolean false))                          ;; true when inside quotes
              a'traveled (atom (int 0))]                                ;; how far we've searched so far
            (loop-when [pos pos line line] (not @got_int) => nil
                ;; Go to the next position, forward or backward.
                ;; We could use incp() and decp() here, but that is much slower.
                (let-when [[pos line]
                        (cond @a'backwards
                            (if (zero? (:col pos))
                                (when (< 1 (:lnum pos))
                                    (let [pos (update pos :lnum dec) _ (swap! a'traveled inc)]
                                        (when-not (< 0 maxtravel @a'traveled)
                                            (let [line (ml-get (:lnum pos)) pos (assoc pos :col (STRLEN line))]
                                                (reset! a'do_quotes -1)
                                                (slow-breakcheck)
                                                [pos line]
                                            ))
                                    ))
                                (let [pos (update pos :col dec)]
                                    [(update pos :col #(- % (us-head-off line, (.plus line %)))) line]
                                ))
                        :else
                            (if (at? line (:col pos) NUL)
                                (when (< (:lnum pos) lmax)
                                    (let [pos (update pos :lnum inc)]
                                        (when-not (< 0 maxtravel @a'traveled)
                                            (let [_ (swap! a'traveled inc) line (ml-get (:lnum pos)) pos (assoc pos :col 0)]
                                                (reset! a'do_quotes -1)
                                                (slow-breakcheck)
                                                [pos line]
                                            ))
                                    ))
                                [(update pos :col #(+ % (us-ptr2len-cc line, %))) line]
                            ))
                ] (some? pos) => pos

                    ;; If FM_BLOCKSTOP given, stop at a '{' or '}' in column 0.
                    (if (and (zero? (:col pos)) (flag? flags FM_BLOCKSTOP) (any == (.at line 0) (byte \{) (byte \})))
                        (when (and (at? line @a'findc) (zero? @a'count))
                            pos) ;; match!  ;; out of scope

                        ;; If smart matching ('cpoptions' does not contain '%'), braces inside of quotes are ignored,
                        (let [line ;; but only if there is an even number of quotes in the line.
                                (cond cpo_match
                                    (do (reset! a'do_quotes 0)
                                        line)
                                (== @a'do_quotes -1)
                                    ;; Count the number of quotes in the line, skipping \" and '"', watching out for "\\".
                                    (let [a'at_start (atom (int @a'do_quotes)) ;; "do_quotes" value at start position
                                          #_Bytes s
                                            (loop-when [s line] (non-eos? s) => s
                                                (when (BEQ s, (.plus line (+ (:col pos) (if @a'backwards 1 0))))
                                                    (reset! a'at_start (& @a'do_quotes 1)))
                                                (when (and (at? s (byte \")) (or (BEQ s, line) (not-at? s -1 (byte \')) (not-at? s 1 (byte \')))) ;; """
                                                    (swap! a'do_quotes inc))
                                                (recur (.plus s (if (and (at? s (byte \\)) (non-eos? s 1)) 2 1)))
                                            )]
                                        (swap! a'do_quotes & 1) ;; result is 1 with even number of quotes
                                        ;; If we find an uneven count, check current line, then prior one for a '\' at the end.
                                        (if (zero? @a'do_quotes)
                                            (do (reset! a'inquote false)
                                                (when (at? s -1 (byte \\))
                                                    (reset! a'do_quotes 1)
                                                    (cond (== @a'start_in_quotes MAYBE)
                                                        (do ;; Do we need to use "at_start" here?
                                                            (reset! a'inquote true)
                                                            (reset! a'start_in_quotes TRUE))
                                                    @a'backwards
                                                        (reset! a'inquote true)
                                                    ))
                                                (if (< 1 (:lnum pos))
                                                    (let [s (ml-get (dec (:lnum pos)))]
                                                        (when (and (non-eos? s) (at? s (dec (STRLEN s)) (byte \\)))
                                                            (reset! a'do_quotes 1)
                                                            (cond (== @a'start_in_quotes MAYBE)
                                                                (do (reset! a'inquote (non-zero? @a'at_start))
                                                                    (when @a'inquote
                                                                        (reset! a'start_in_quotes TRUE)
                                                                    ))
                                                            (not @a'backwards)
                                                                (reset! a'inquote true)
                                                            ))
                                                        ;; ml-get() only keeps one line, need to get it again
                                                        (ml-get (:lnum pos)))
                                                    line
                                                ))
                                            line
                                        ))
                                :else
                                    line
                                )]
                            (when (== @a'start_in_quotes MAYBE)
                                (reset! a'start_in_quotes FALSE))
                            ;; If 'smartmatch' is set:
                            ;;
                            ;; Things inside quotes are ignored by setting "inquote".
                            ;; If we find a quote without a preceding '\', invert "inquote".
                            ;; At the end of a line not ending in '\' we reset "inquote".
                            ;;
                            ;; In lines with an uneven number of quotes (without preceding '\')
                            ;; we do not know which part to ignore.  Therefore we only set
                            ;; "inquote" if the number of quotes in a line is even, unless this
                            ;; line or the prior one ends in a '\'.
                            ;;
                            ;; Complicated, isn't it?
                            (let-when [#_int c (us-ptr2char line, (:col pos))
                                  [pos ?]
                                    (condp == c
                                        NUL (do ;; at end of line without trailing backslash, reset "inquote"
                                                (when (or (zero? (:col pos)) (not-at? line (dec (:col pos)) (byte \\)))
                                                    (reset! a'inquote false)
                                                    (reset! a'start_in_quotes FALSE))
                                                [pos nil])

                                        (byte \") ;; """
                                            (do ;; a quote that is preceded with an odd number of backslashes is ignored
                                                (when (non-zero? @a'do_quotes)
                                                    (let [#_int col (loop-when-recur [col (dec (:col pos))] (and (<= 0 col) (at? line col (byte \\))) [(dec col)] => col)]
                                                        (when (zero? (& (- (dec (:col pos)) col) 1))
                                                            (swap! a'inquote not)
                                                            (reset! a'start_in_quotes FALSE))
                                                    ))
                                                [pos nil])

                                        ;; If smart matching ('cpoptions' does not contain '%'):
                                        ;; - Skip things in single quotes: 'x' or '\x'.
                                        ;; - Be careful for single single quotes, e.g. jon's.
                                        ;; - Things like '\233' or '\x3f' are not skipped, there is never a brace in them.
                                        ;; - Ignore this when finding matches for `'.
                                        (let-when [
                                              ? (let-when [i (:col pos)] (and (== c (byte \')) (not cpo_match) (!= @a'initc (byte \')) (!= @a'findc (byte \')))
                                                    (cond @a'backwards
                                                        (when (< 1 i)
                                                            (cond
                                                                (at? line (- i 2) (byte \'))                                            -2
                                                                (and (at? line (- i 2) (byte \\)) (< 2 i) (at? line (- i 3) (byte \'))) -3
                                                            ))
                                                    (non-eos? line (inc i))
                                                        (cond
                                                            (and (at? line (inc i) (byte \\)) (non-eos? line (+ i 2)) (at? line (+ i 3) (byte \'))) +3
                                                            (at? line (+ i 2) (byte \'))                                                            +2
                                                        ))
                                                )] (not ?) => [(update pos :col + ?) nil]

                                            ;; Check for match outside of quotes, and inside of quotes when the start is also inside of quotes.
                                            (let [? (when (and (or (not @a'inquote) (== @a'start_in_quotes TRUE)) (any == c @a'initc @a'findc))
                                                        (let [#_int n
                                                                (if (not cpo_bsl)
                                                                    (let [a'col (atom (int (:col pos)))]
                                                                        (loop-when-recur [n 0] (check-prevcol line, @a'col, (byte \\), a'col) (inc n) => n))
                                                                    0
                                                                )]
                                                            ;; Only accept a match when 'M' is in 'cpo' or when escaping is what we expect.
                                                            (when (or cpo_bsl (== (& n 1) @a'match_escaped))
                                                                (cond
                                                                    (== c @a'initc)      (do (swap! a'count inc) nil)
                                                                    (non-zero? @a'count) (do (swap! a'count dec) nil)
                                                                    :else :found
                                                                ))
                                                        ))]
                                                [pos ?]
                                            ))
                                    )] (not ?) => pos

                                (recur pos line)
                            ))
                    ))
            ))
    ))

;; Return true if the character before "s[i]" equals "c".
;; Return false if "i" is zero.
;; Update "*prior" to the column of the previous character, unless "prior" is null.
;; Handles multi-byte string correctly.

(defn- #_boolean check-prevcol [#_Bytes s, #_int i, #_int c, #_int' a'prior]
    (let [i (dec i) i (if (< 0 i) (- i (us-head-off s, (.plus s i))) i)]
        (when (some? a'prior)
            (reset! a'prior i))
        (and (<= 0 i) (at? s i c))
    ))

;; Move cursor briefly to character matching the one under the cursor.
;; Used for Insert mode and "r" command.
;; Show the match only if it is visible on the screen.
;; If there isn't a match, then beep.

(defn- #_window_C showmatch [#_window_C win, #_int c] ;; c: char to show match for
    ;; Only show match for chars in the 'matchpairs' option.
    (let-when [_ (let [s @(:b_p_mps @curbuf)] ;; 'matchpairs' is "x:y,x:y"
                    (loop-when [i 0] (non-eos? s i) => :_
                        (let-when [i (+ i (inc (us-ptr2len-cc s, i)))] (!= (us-ptr2char s, i) c) => :_
                            (let-when [i (+ i (us-ptr2len-cc s, i))] (non-eos? s i) => nil
                                (recur (inc i))
                            ))
                    ))] (some? _) => win

        (let [lpos (findmatch win, NUL)]
            (cond (nil? lpos) ;; no match, so beep
                (do (beep) win)
            (and (<= (:w_topline win) (:lnum lpos)) (< (:lnum lpos) (:w_botline win)))
                (let [wrap @(:wo_wrap (:w_options win)) a'vcol (atom (int))]
                    (when (not wrap)
                        (getvcol win, lpos, nil, a'vcol, nil))
                    (if (or wrap (and (<= (:w_leftcol win) @a'vcol) (< @a'vcol (+ (:w_leftcol win) (:w_width win)))))
                        ;; save the pos, update-screen() may change it
                        (let [o'lpos lpos o'cursor (:w_cursor win) o'so @p_so o'siso @p_siso
                              win (update win :w_virtcol inc)               ;; do display ')' just before "$"
                              win (update-screen win, VALID)                ;; show the new char first
                              o'State @State _ (reset! State SHOWMATCH)
                              _ (ui-cursor-shape)                           ;; may show different cursor shape
                              win (assoc win :w_cursor o'lpos)              ;; move to matching char
                              _ (reset! p_so 0)                             ;; don't use 'scrolloff' here
                              _ (reset! p_siso 0)                           ;; don't use 'sidescrolloff' here
                              win (showruler win, false)
                              win (setcursor win)]
                            (cursor-on)                                     ;; make sure that the cursor is shown
                            (out-flush)
                            ;; brief pause, unless 'm' is present in 'cpo' and a character is available
                            (cond (some? (vim-strbyte @p_cpo, CPO_SHOWMATCH)) (ui-delay (* @p_mat 100), true)
                                  (not (char-avail))                          (ui-delay (* @p_mat 100), false))
                            (let [win (assoc win :w_cursor o'cursor)]       ;; restore cursor position
                                (reset! p_so o'so)
                                (reset! p_siso o'siso)
                                (reset! State o'State)
                                (ui-cursor-shape)                           ;; may show different cursor shape
                                win
                            ))
                        win
                    ))
            :else
                win
            ))
    ))

;; The following routines do the word searches performed
;; by the 'w', 'W', 'b', 'B', 'e', and 'E' commands.

;; To perform these searches, characters are placed into one of three
;; classes, and transitions between classes determine word boundaries.
;;
;; The classes are:
;;
;; 0 - white space
;; 1 - punctuation
;; 2 or higher - keyword characters (letters, digits and underscore)

;; Returns the class of the character at "w_cursor" of "win".
;;
;; If a 'W', 'B', or 'E' motion is being done,
;; chars from class 2 and higher are reported as class 1 since only
;; white space boundaries are of interest.

(defn- #_int cls-cursor [#_window_C win, #_boolean bigword]
    ;; bigword: true for "W", "B" or "E"
    (let [c (gchar-cursor win)] (if (any == c (byte \space) TAB NUL) 0 (let [c (utf-class c)] (if (and (non-zero? c) bigword) 1 c)))))

;; Move forward 'n' words.
;;
;; Returns false if the cursor was already at the end of the file.
;; If eol is true, last word stops at end of line (for operators).

(defn- #_[window_C boolean] fwd-word? [#_window_C win, #_long n, #_boolean bigword, #_boolean eol]
    (let [lmax (line-count @curbuf)]
        (loop-when [win (assoc-in win [:w_cursor :coladd] 0) n n] (pos? n) => [win true]
            ;; always move at least one char, unless on the last one in the buffer
            (let [cls (cls-cursor win, bigword) eof (== (:lnum (:w_cursor win)) lmax) [win ?] (inc-cursor? win, false)]
                (cond (or (== ? -1) (and (<= 1 ?) eof))         ;; started at last char in file
                    [win false]
                (and (<= 1 ?) eol (== n 1))                     ;; started at last char in line
                    [win true]
                :else ;; go one char past end of current word (if any)
                    (let-when [[win ? :as _]
                        (if (non-zero? cls)
                            (loop-when win (== (cls-cursor win, bigword) cls) => [win nil]
                                (let [[win ?] (inc-cursor? win, false)] (if (or (== ? -1) (and (<= 1 ?) eol (== n 1))) [win true] (recur win))))
                            [win nil]
                        )
                    ] (not ?) => _
                        ;; skip white space, but stop on an empty line
                        (let-when [[win ? :as _]
                            (loop-when win (and (zero? (cls-cursor win, bigword)) (not (and (zero? (:col (:w_cursor win))) (lineempty (:lnum (:w_cursor win)))))) => [win nil]
                                (let [[win ?] (inc-cursor? win, false)] (if (or (== ? -1) (and (<= 1 ?) eol (== n 1))) [win true] (recur win)))
                            )
                        ] (not ?) => _
                            (recur win (dec n)))
                    ))
            ))
    ))

(defn- #_window_C fwd-word [#_window_C win, #_long n, #_boolean bigword, #_boolean eol]
    (let [[win _] (fwd-word? win, n, bigword, eol)]
        win
    ))

;; Move backward 'n' words.
;;
;; If stop is true and we are already on the start of a word, move one less.
;; Returns false if top of the file was reached.

(defn- #_[window_C boolean] bck-word? [#_window_C win, #_long n, #_boolean bigword, #_boolean stop]
    (loop-when [win (assoc-in win [:w_cursor :coladd] 0) n n stop stop] (pos? n) => [win true]
        (let-when [cls (cls-cursor win, bigword) [win ?] (dec-cursor? win, false)] (!= ? -1) => [win false] ;; started at start of file
            (let-when [[win ? :as _]
                (if (or (not stop) (== (cls-cursor win, bigword) cls) (zero? cls))
                    (loop [win win]
                        (let [cls' (cls-cursor win, bigword)]
                            (if (zero? cls')
                                ;; skip white space before the word, but stop on an empty line
                                (if (and (zero? (:col (:w_cursor win))) (lineempty (:lnum (:w_cursor win))))
                                    [win nil]
                                    (let-when [[win ?] (dec-cursor? win, false)] (!= ? -1) => [win true] ;; hit start of file, stop here
                                        (recur win)
                                    ))
                                ;; move backward to start of this word
                                (let-when [[win ?] (skip-chars? win, cls', bigword, BACKWARD)] (not ?) => [win true]
                                    [(inc-cursor win, false) nil] ;; overshot - forward one
                                ))
                        ))
                    [(inc-cursor win, false) nil] ;; overshot - forward one
                )
            ] (not ?) => _
                (recur win (dec n) false)
            ))
    ))

(defn- #_window_C bck-word [#_window_C win, #_long n, #_boolean bigword, #_boolean stop]
    (let [[win _] (bck-word? win, n, bigword, stop)]
        win
    ))

;; Move to the end of the word.
;;
;; Returns false if end of the file was reached.
;; If stop is true and we are already on the end of a word, move one less.
;; If empty is true stop on an empty line.

(defn- #_[window_C boolean] end-word? [#_window_C win, #_long n, #_boolean bigword, #_boolean stop, #_boolean empty]
    (loop-when [win (assoc-in win [:w_cursor :coladd] 0) n n stop stop] (pos? n) => [win true]
        (let-when [cls (cls-cursor win, bigword) [win ?] (inc-cursor? win, false)] (!= ? -1) => [win false]
            (let-when [[win ? :as _]
                ;; If we're in the middle of a word, we just have to move to the end of it.
                (cond (and (== (cls-cursor win, bigword) cls) (non-zero? cls))
                    ;; move forward to end of the current word
                    (let-when [[win ?] (skip-chars? win, cls, bigword, FORWARD)] (not ?) => [win false]
                        [(dec-cursor win, false) nil] ;; overshot - one char backward
                    )
                (or (not stop) (zero? cls))
                    ;; We were at the end of a word.  Go to the end of the next word.
                    ;; First skip white space, if "empty" is true, stop at empty line.
                    (loop [win win]
                        (let [cls' (cls-cursor win, bigword)]
                            (if (zero? cls')
                                (if (and empty (zero? (:col (:w_cursor win))) (lineempty (:lnum (:w_cursor win))))
                                    [win nil]
                                    (let-when [[win ?] (inc-cursor? win, false)] (!= ? -1) => [win false] ;; hit end of file, stop here
                                        (recur win)
                                    ))
                                ;; move forward to the end of this word
                                (let-when [[win ?] (skip-chars? win, cls', bigword, FORWARD)] (not ?) => [win false]
                                    [(dec-cursor win, false) nil] ;; overshot - one char backward
                                ))
                        ))
                :else
                    [(dec-cursor win, false) nil] ;; overshot - one char backward
                )
            ] (nil? ?) => _
                (recur win (dec n) false) ;; we move only one word less
            ))
    ))

(defn- #_window_C end-word [#_window_C win, #_long n, #_boolean bigword, #_boolean stop, #_boolean empty]
    (let [[win _] (end-word? win, n, bigword, stop, empty)]
        win
    ))

;; Move back to the end of the word.
;;
;; Returns false if start of the file was reached.
;; If eol is true, stop at end of line.

(defn- #_[window_C boolean] bckend-word? [#_window_C win, #_long n, #_boolean bigword, #_boolean eol]
    (loop-when [win (assoc-in win [:w_cursor :coladd] 0) n n] (pos? n) => [win true]
        (let [cls (cls-cursor win, bigword) [win ?] (dec-cursor? win, false)]
            (cond (== ? -1)
                [win false]
            (and eol (== ? 1))
                [win true]
            :else ;; move backward to before the start of this word
                (let-when [[win ? :as _]
                    (if (non-zero? cls)
                        (loop-when win (== (cls-cursor win, bigword) cls) => [win nil]
                            (let [[win ?] (dec-cursor? win, false)] (if (or (== ? -1) (and eol (== ? 1))) [win true] (recur win))))
                        [win nil]
                    )
                ] (not ?) => _
                    ;; move backward to end of the previous word
                    (let-when [[win ? :as _]
                        (loop-when win (and (zero? (cls-cursor win, bigword)) (not (and (zero? (:col (:w_cursor win))) (lineempty (:lnum (:w_cursor win)))))) => [win nil]
                            (let [[win ?] (dec-cursor? win, false)] (if (or (== ? -1) (and eol (== ? 1))) [win true] (recur win)))
                        )
                    ] (not ?) => _
                        (recur win (dec n))
                    ))
            ))
    ))

(defn- #_window_C bckend-word [#_window_C win, #_long n, #_boolean bigword, #_boolean eol]
    (let [[win _] (bckend-word? win, n, bigword, eol)]
        win
    ))

;; Skip a row of characters of the same class.
;; Return true when end-of-file reached, false otherwise.

(defn- #_[window_C boolean] skip-chars? [#_window_C win, #_int cclass, #_boolean bigword, #_int dir]
    (loop-when win (== (cls-cursor win, bigword) cclass) => [win false]
        (let [[win ?] ((if (== dir FORWARD) inc-cursor? dec-cursor?) win, false)] (recur-if (!= ? -1) win => [win true]))
    ))

;; Go back to the start of the word or the start of white space.

(defn- #_window_C back-in-line [#_window_C win, #_boolean bigword]
    (let [sclass (cls-cursor win, bigword)] ;; starting class
        (loop-when win (pos? (:col (:w_cursor win))) => win ;; stop at start of line
            (let [win (dec-cursor win, false)]
                (recur-if (== (cls-cursor win, bigword) sclass) win => (inc-cursor win, false)) ;; stop at start of word
            ))
    ))

;; Find word under cursor, cursor at end.
;; Used while an operator is pending, and in Visual mode.
;;
;; include: true: include word and white space
;; bigword: false == word, true == WORD

(defn- #_[window_C cmdarg_C boolean] current-word? [#_window_C win, #_cmdarg_C cap, #_long count, #_boolean include, #_boolean bigword]
    ;; Correct cursor when 'selection' is exclusive.
    (let-when [win (if (and @VIsual_active (at? @p_sel (byte \e)) (ltpos @VIsual_cursor, (:w_cursor win))) (dec-cursor win, false) win)
          a'start_pos (atom (#_pos_C object (NEW_pos_C)))
          a'include_white (atom (boolean false))
          ;; When Visual mode is not active, or when the VIsual area is only one
          ;; character, select the word and/or white space under the cursor.
          [win cap count]
            (if (or (not @VIsual_active) (eqpos (:w_cursor win), @VIsual_cursor))
                ;; Go to start of current word or white space.
                (let-when [win (back-in-line win, bigword) _ (reset! a'start_pos (:w_cursor win))
                      ;; If the start is on white space, and white space should be included ("   word"),
                      ;; or start is not on white space, and white space should not be included ("word"),
                      ;; find end of word.
                      [win ?]
                        (if (== (zero? (cls-cursor win, bigword)) include)
                            (let [[win ?] (end-word? win, 1, bigword, true, true)]
                                [win (when (not ?) :abort)])
                            ;; If the start is not on white space, and white space should be included ("word   "),
                            ;; or start is on white space and white space should not be included ("   "),
                            ;; find start of word.  If we end up in the first column of the next line (single char word),
                            ;; back up to end of the line.
                            (let [win (fwd-word win, 1, bigword, true)
                                  win (if (zero? (:col (:w_cursor win))) (dec-cursor win, true) (oneleft win))]
                                (reset! a'include_white (or include @a'include_white))
                                [win nil]
                            ))
                ] (not ?) => [win cap nil]

                    (let [cap (if @VIsual_active
                                (do ;; should do something when inclusive == false !
                                    (reset! VIsual_cursor @a'start_pos)
                                    (redraw-curbuf-later INVERTED) ;; update the inversion
                                    cap)
                                (update cap :oap assoc :op_start @a'start_pos :motion_type MCHAR)
                            )]
                        [win cap (dec count)]
                    ))
                [win cap count])
    ] (some? count) => [win cap false]

        (let-when [a'inclusive (atom (boolean true))
              ;; When count is still > 0, extend with more objects.
              [win count]
                (loop-when [win win count count] (< 0 count) => [win count]
                    (let-when [_ (reset! a'inclusive true)
                          [win ?]
                            (cond (and @VIsual_active (ltpos (:w_cursor win), @VIsual_cursor))
                                ;; In Visual mode, with cursor at start: move cursor back.
                                (let [[win ?] (dec-cursor? win, true)]
                                    (cond (== ? -1)
                                        [win :abort]
                                    (!= include (non-zero? (cls-cursor win, bigword)))
                                        (let [[win ?] (bck-word? win, 1, bigword, true)]
                                            [win (when (not ?) :abort)])
                                    :else
                                        (let [[win ?] (bckend-word? win, 1, bigword, true)]
                                            (if (not ?) [win :abort] [(inc-cursor win, true) nil]))
                                    ))
                            :else
                                ;; Move cursor forward one word and/or white area.
                                (let [[win ?] (inc-cursor? win, true)]
                                    (cond (== ? -1)
                                        [win :abort]
                                    (!= include (zero? (cls-cursor win, bigword)))
                                        (let [[win ?] (fwd-word? win, 1, bigword, true)]
                                            (if (and (not ?) (< 1 count))
                                                [win :abort]
                                                ;; If end is just past a new-line,
                                                ;; we don't want to include the first character on the line.
                                                ;; Put cursor on last char of white.
                                                (let [[win ?] (oneleft? win)]
                                                    (reset! a'inclusive (and ? @a'inclusive))
                                                    [win nil])
                                            ))
                                    :else
                                        (let [[win ?] (end-word? win, 1, bigword, true, true)]
                                            [win (when (not ?) :abort)]
                                        ))
                                ))
                    ] (not ?) => [win nil]

                        (recur win (dec count))
                    ))
        ] (some? count) => [win cap false]

            (let [[win cap]
                    (if (and @a'include_white (or (non-zero? (cls-cursor win, bigword)) (and (zero? (:col (:w_cursor win))) (not @a'inclusive))))
                        ;; If we don't include white space at the end, move the start to include some white space there.
                        ;; This makes "daw" work better on the last word in a sentence (and "2daw" on last-but-one word).
                        ;; Also when "2daw" deletes "word." at the end of the line (cursor is at start of next line).
                        ;; But don't delete white space at start of line (indent).
                        (let [o'cursor (:w_cursor win) win (assoc win :w_cursor @a'start_pos)
                              [win ?] (oneleft? win)
                              [win cap]
                                (if ?
                                    (let [win (back-in-line win, bigword)]
                                        (if (and (zero? (cls-cursor win, bigword)) (< 0 (:col (:w_cursor win))))
                                            (let [cap (if @VIsual_active
                                                        (do (reset! VIsual_cursor (:w_cursor win)) cap)
                                                        (update cap :oap assoc :op_start (:w_cursor win))
                                                    )]
                                                [win cap])
                                            [win cap]
                                        ))
                                    [win cap]
                                )]
                            [(assoc win :w_cursor o'cursor) cap]) ;; put cursor back at end
                        [win cap]
                    )]
                (if @VIsual_active
                    (let [win (if (and (at? @p_sel (byte \e)) @a'inclusive (ltoreq @VIsual_cursor, (:w_cursor win)))
                                (inc-cursor win, false)
                                win
                            )]
                        (when (== @VIsual_mode (byte \V))
                            (reset! VIsual_mode (byte \v))
                            (reset! redraw_cmdline true)) ;; show mode later
                        [win cap true])
                    [win (update cap :oap assoc :inclusive @a'inclusive) true])
            ))
    ))

;; Find block under the cursor, cursor at end.
;; "what" and "other" are two matching parens/braces/etc.
;;
;; include: true == include white space
;; what: '(', '{', etc.
;; other: ')', '}', etc.

(defn- #_[window_C cmdarg_C boolean] current-block? [#_window_C win, #_cmdarg_C cap, #_long count, #_boolean include, #_int what, #_int other]
    (let-when [o'cursor (:w_cursor win)
          ;; If we start on '(', '{', ')', '}', etc., use the whole block inclusive.
          [win o'start o'end]
            (cond (or (not @VIsual_active) (eqpos @VIsual_cursor, (:w_cursor win)))
                (let [win (setpcmark win)
                      win (if (== what (byte \{)) ;; ignore indent
                            (loop-when win (inindent win, 1) => win
                                (let [[win ?] (inc-cursor? win, false)]
                                    (recur-if (zero? ?) win => win)
                                ))
                            win)
                      ;; cursor on '(' or '{', move cursor just after it
                      win (if (== (gchar-cursor win) what) (update-in win [:w_cursor :col] inc) win)]
                    [win o'cursor o'cursor])
            (ltpos @VIsual_cursor, (:w_cursor win))
                ;; cursor at low end of Visual
                [(assoc win :w_cursor @VIsual_cursor) @VIsual_cursor o'cursor]
            :else
                [win o'cursor @VIsual_cursor])
          ;; Search backwards for unclosed '(', '{', etc.
          ;; Put this position in "start_pos".
          ;; Ignore quotes here.
          ;; Keep the "M" flag in 'cpo', as that is what the user wants.
          o'cpo @p_cpo _ (reset! p_cpo (if (some? (vim-strbyte @p_cpo, CPO_MATCHBSL)) (u8 "%M") (u8 "%")))
          [win #_pos_C start_pos]
            (loop-when [win win pos nil count count] (< 0 count) => [win pos]
                (let [pos (findmatch win, what)]
                    (recur-if (some? pos) [(assoc win :w_cursor pos) pos (dec count)] => [win pos])
                ))
          _ (reset! p_cpo o'cpo)
          ;; Search for matching ')', '}', etc.
          ;; Put this position in "w_cursor".
          #_pos_C end_pos (when (some? start_pos) (findmatch win, other))
    ] (some? end_pos) => [(assoc win :w_cursor o'cursor) cap false]

        (let-when [win (assoc win :w_cursor end_pos)
              a'sol (atom (boolean false)) ;; '{' at start of line
              ;; Try to exclude the '(', '{', ')', '}', etc. when "include" is false.
              ;; If the ending '}', ')' or ']' is only preceded by indent, skip that indent,
              ;; but only if the resulting area is not smaller than what we started with.
              [win start_pos]
                (loop-when [win win start_pos start_pos] (not include) => [win start_pos]
                    (let [start_pos (incl start_pos)
                          _ (reset! a'sol (== (:col (:w_cursor win)) 0))
                          win (dec-cursor win, true)
                          win (loop-when win (inindent win, 1) => win
                                (let [_ (reset! a'sol true)
                                      [win ?] (dec-cursor? win, true)]
                                    (recur-if (== ? 0) win => win))
                            )]
                        ;; In Visual mode, when the resulting area is not bigger than what we
                        ;; started with, extend it to the next block, and then exclude again.
                        (if (and (not (ltpos start_pos, o'start)) (not (ltpos o'end, (:w_cursor win))) @VIsual_active)
                            (let-when [win (assoc win :w_cursor o'start) win (dec-cursor win, true)
                                  start_pos (findmatch win, what)
                            ] (some? start_pos) => [win nil]

                                (let-when [win (assoc win :w_cursor start_pos)
                                      end_pos (findmatch win, other)
                                ] (some? end_pos) => [win nil]

                                    (recur (assoc win :w_cursor end_pos) start_pos)
                                ))
                            [win start_pos]
                        )))
        ] (some? start_pos) => [(assoc win :w_cursor o'cursor) cap false]

            (if @VIsual_active
                (let [win (if (at? @p_sel (byte \e)) (update-in win [:w_cursor :col] inc) win)
                      win (if (and @a'sol (!= (gchar-cursor win) NUL)) (inc-cursor win, false) win)] ;; include the line break
                    (reset! VIsual_cursor start_pos)
                    (reset! VIsual_mode (byte \v))
                    (redraw-curbuf-later INVERTED) ;; update the inversion
                    [(showmode win) cap true])
                (let [cap (update cap :oap assoc :op_start start_pos :motion_type MCHAR :inclusive false)]
                    (cond @a'sol
                        [(inc-cursor win, true) cap true]
                    (ltoreq start_pos, (:w_cursor win))
                        ;; Include the character under the cursor.
                        [win (update cap :oap assoc :inclusive true) true]
                    :else
                        ;; End is before the start (no text in between <>, [], etc.): don't operate on any text.
                        [(assoc win :w_cursor start_pos) cap true]
                    ))
            ))
    ))

;; Search quote char from string line[col].
;; Quote character escaped by one of the characters in "escape" is not counted as a quote.
;; Returns column number of "quotechar" or -1 when not found.

(defn- #_int find-next-quote [#_Bytes line, #_int col, #_int quotechar, #_Bytes escape]
    ;; escape: escape characters, can be null
    (loop [i col]
        (let [c (.at line i)]
            (cond (== c NUL)
                -1
            (and (some? escape) (some? (vim-strchr escape, c)))
                (let [i (inc i)] (recur (+ i (us-ptr2len-cc line, i))))
            (== c quotechar)
                i
            :else
                (recur (+ i (us-ptr2len-cc line, i)))
            ))
    ))

;; Search backwards in "line" from column "col_start" to find "quotechar".
;; Quote character escaped by one of the characters in "escape" is not counted as a quote.
;; Return the found column or zero.

(defn- #_int find-prev-quote [#_Bytes line, #_int col_start, #_int quotechar, #_Bytes escape]
    ;; escape: escape characters, can be null
    (loop-when [i col_start] (< 0 i) => i
        (let [i (dec i) i (- i (us-head-off line, (.plus line i)))
              n (if (some? escape) (loop-when-recur [n 0] (and (< 0 (- i n)) (some? (vim-strchr escape, (.at line (- i n 1))))) [(inc n)] => n) 0)]
            (cond
                (non-zero? (& n 1)) (recur (- i n)) ;; uneven number of escape chars, skip it
                (at? line i quotechar) i
                :else (recur i)
            ))
    ))

;; Find quote under the cursor, cursor at end.
;; Returns true if found, else false.
;;
;; include: true == include quote char
;; q: quote character

(defn- #_[window_C cmdarg_C boolean] current-quote? [#_window_C win, #_cmdarg_C cap, #_long count, #_boolean include, #_int q]
    (let-when [#_Bytes line (ml-get (:lnum (:w_cursor win))) #_int start (:col (:w_cursor win))
          ;; Correct cursor when 'selection' is exclusive.
          [win #_boolean vis_empty #_boolean vis_bef_curs] ;; Visual selection <= 1 char.  ;; Visual starts before cursor.
            (if @VIsual_active
                (let [vis_bef_curs (ltpos @VIsual_cursor, (:w_cursor win))
                      win (if (and (at? @p_sel (byte \e)) vis_bef_curs) (dec-cursor win, false) win)]
                    [win (eqpos @VIsual_cursor, (:w_cursor win)) vis_bef_curs])
                [win true false])
          [#_boolean inside_quotes #_boolean selected_quote] ;; Looks like "i'" done before.  ;; Has quote inside selection.
            (if (not vis_empty)
                ;; Check if the existing selection exactly spans the text inside quotes.
                (let [cuc (:col (:w_cursor win)) vic (:col @VIsual_cursor)
                      [inside_quotes #_int i #_int e]
                        (if vis_bef_curs
                            [(and (< 0 vic) (at? line (dec vic) q) (non-eos? line cuc) (at? line (inc cuc) q)) vic cuc]
                            [(and (< 0 cuc) (at? line (dec cuc) q) (non-eos? line vic) (at? line (inc vic) q)) cuc vic])
                      ;; Find out if we have a quote in the selection.
                      selected_quote
                        (loop-when i (<= i e) => false
                            (recur-if (not-at? line i q) (inc i) => true)
                        )]
                    [inside_quotes selected_quote])
                [false false])
          qe @(:b_p_qe @curbuf)
          [start #_int end :as _]
            (cond (and (not vis_empty) (at? line start q))
                ;; Already selecting something and on a quote character.
                ;; Find the next quoted string.
                (cond vis_bef_curs
                    ;; Assume we are on a closing quote: move to after the next opening quote.
                    (let-when [start (find-next-quote line, (inc start), q, nil)] (<= 0 start) => nil
                        (let [end (find-next-quote line, (inc start), q, qe)]
                            ;; We were on a starting quote perhaps?
                            (if (<= 0 end) [start end] [(:col (:w_cursor win)) start])
                        ))
                :else
                    (let-when [end (find-prev-quote line, start, q, nil)] (at? line end q) => nil
                        (let [start (find-prev-quote line, end, q, qe)]
                            ;; We were on an ending quote perhaps?
                            (if (at? line start q) [start end] [end (:col (:w_cursor win))])
                        ))
                )
            (or (at? line start q) (not vis_empty))
                (let [#_int first
                        (if (not vis_empty)
                            (if vis_bef_curs
                                (find-next-quote line, start, q, nil)
                                (find-prev-quote line, start, q, nil))
                            start
                        )]
                    ;; The cursor is on a quote, we don't know if it's the opening or closing quote.
                    ;; Search from the start of the line to find out.
                    ;; Also do this when there is a Visual area, a' may leave the cursor in between two strings.
                    (loop [start 0 end nil]
                        ;; Find open quote character.
                        (let-when [start (find-next-quote line, start, q, nil)] (<= 0 start first) => nil
                            ;; Find close quote character.
                            (let-when [end (find-next-quote line, (inc start), q, qe)] (<= 0 end) => nil
                                ;; If cursor is between start and end quote, it is target text.
                                (if (<= start first end) [start end] (recur (inc end) end))
                            ))
                    ))
            :else
                ;; Search backward for a starting quote.
                (let-when [start (find-prev-quote line, start, q, qe)
                      start
                        (if (not-at? line start q)
                            ;; No quote before the cursor, look after the cursor.
                            (let-when [start (find-next-quote line, start, q, nil)] (<= 0 start) => nil
                                start)
                            start
                        )] (some? start) => nil

                    ;; Find close quote character.
                    (let-when [end (find-next-quote line, (inc start), q, qe)] (<= 0 end) => nil
                        [start end])
                ))
    ] (some? _) => [win cap false]

        ;; When "include" is true, include spaces after closing quote or before the starting quote.
        (let [[start end]
                (cond (not include)
                    [start end]
                (vim-iswhite (.at line (inc end)))
                    [start (loop-when-recur end (vim-iswhite (.at line (inc end))) (inc end) => end)]
                :else
                    [(loop-when-recur start (and (< 0 start) (vim-iswhite (.at line (dec start)))) (dec start) => start) end])
              ;; Set start position.  After vi" another i" must include the ".
              ;; For v2i" include the quotes.
              start (if (and (not include) (< count 2) (or vis_empty (not inside_quotes))) (inc start) start)
              win (assoc-in win [:w_cursor :col] start)
              cap (if @VIsual_active
                    ;; Set the start of the Visual area when it was empty, we were just inside quotes,
                    ;; or the Visual area didn't start at a quote and didn't include a quote.
                    (do (let-when [vic (:col @VIsual_cursor)]
                                  (or vis_empty (and vis_bef_curs (not selected_quote) (or inside_quotes (and (not-at? line vic q) (or (zero? vic) (not-at? line (dec vic) q))))))
                            (reset! VIsual_cursor (:w_cursor win))
                            (redraw-curbuf-later INVERTED))
                        cap)
                    (update cap :oap assoc :op_start (:w_cursor win) :motion_type MCHAR))
              ;; Set end position.
              win (assoc-in win [:w_cursor :col] end)
              ;; After vi" another i" must include the ".
              [win #_boolean inclusive] (if (or include (< 1 count) (and (not vis_empty) inside_quotes)) (let [[win ?] (inc-cursor? win, false)] [win (== ? 2)]) [win false])]
            (if @VIsual_active
                (let [win (if (or vis_empty vis_bef_curs)
                            ;; Decrement cursor when 'selection' is not exclusive.
                            (if (not-at? @p_sel (byte \e)) (dec-cursor win, false) win)
                            ;; Cursor is at start of Visual area.
                            ;; Set the end of the Visual area when it was just inside quotes or it didn't end at a quote.
                            (let [vic (:col @VIsual_cursor)
                                  win (if (or inside_quotes (and (not selected_quote) (not-at? line vic q) (or (eos? line vic) (not-at? line (inc vic) q))))
                                        (let [win (dec-cursor win, false)] (reset! VIsual_cursor (:w_cursor win)) win)
                                        win
                                    )]
                                (assoc-in win [:w_cursor :col] start))
                        )]
                    (when (== @VIsual_mode (byte \V))
                        (reset! VIsual_mode (byte \v))
                        (reset! redraw_cmdline true)) ;; show mode later
                    [win cap true])
                [win (update cap :oap assoc :inclusive inclusive) true]
            ))
    ))

;; Find next search match under cursor, cursor at end.
;; Used while an operator is pending, and in Visual mode.

(defn- #_[window_C boolean] current-search? [#_window_C win, #_long count, #_boolean forward]
    (let-when [o'visual @VIsual_cursor o'p_ws @p_ws _ (reset! p_ws false)   ;; wrapping should not occur
          ;; Correct cursor when 'selection' is exclusive.
          win (when' (and @VIsual_active (at? @p_sel (byte \e)) (ltpos @VIsual_cursor, (:w_cursor win))) => win
                (dec-cursor win, false))
          o'cursor (:w_cursor win)                                          ;; position of the cursor at beginning
          [#_pos_C start_pos #_pos_C pos]                                   ;; position before/after the pattern
            (if @VIsual_active                                              ;; make sure, searching further will extend the match
                [@VIsual_cursor ((if forward incl decl) o'cursor)]
                [o'cursor o'cursor])
          ;; Is the pattern zero-width?
          [win #_int one_char] (is-one-char? win, (last-search-expr), true)
    ] (!= one_char -1) => (do (reset! p_ws o'p_ws) [win false])             ;; pattern not found

        ;; The trick is to first search backwards and then search forward again,
        ;; so that a match at the current cursor position will be correctly captured.
        (let-when [[win pos]
            (loop-when [win win pos pos #_int round 0] (< round 2) => [win pos]
                (let-when [#_boolean dir (if forward (non-zero? round) (zero? round))
                      #_int flags (if (and (not dir) (zero? one_char)) SEARCH_END 0)
                      [win pos #_int sm1]
                        (searchit? win, pos, (if dir FORWARD BACKWARD), (last-search-expr), (if (non-zero? round) count 1), (| flags SEARCH_KEEP), RE_SEARCH, 0, nil)
                        ;; First search may fail, but then start searching from the beginning of
                        ;; the file (cursor might be on the search match) except when Visual mode
                        ;; is active, so that extending the visual selection works.
                      [win pos]
                        (cond (non-zero? sm1)
                            [win pos]
                        (zero? round)
                            (let [pos (if forward
                                        (NEW_pos_C)                         ;; try again from start of buffer
                                        (let [lmax (line-count @curbuf)]    ;; try again from end of buffer
                                            (assoc pos :lnum lmax :col (STRLEN (ml-get lmax))))
                                    )]
                                [win pos])
                        :else                                               ;; not found, abort
                            (let [win (assoc win :w_cursor o'cursor)]
                                (when @VIsual_active
                                    (reset! VIsual_cursor o'visual))
                                [win nil])
                        )] (some? pos) => [win nil]

                    (reset! p_ws o'p_ws)
                    (recur win pos (inc round))
                ))
        ] (some? pos) => (do (reset! p_ws o'p_ws) [win false])

            (let [start_pos pos
                  #_int flags (if forward SEARCH_END 0)
                  ;; Check again from the current cursor position,
                  ;; since the next match might actually be only one char wide.
                  [win one_char] (is-one-char? win, (last-search-expr), false)
                  ;; Move to match, except for zero-width matches,
                  ;; in which case, we are already on the next match.
                  [win pos]
                    (when' (== one_char FALSE) => [win pos]
                        (let [[win pos _]
                                (searchit? win, pos, (if forward FORWARD BACKWARD), (last-search-expr), 0, (| flags SEARCH_KEEP), RE_SEARCH, 0, nil)] [win pos]
                        ))
                  _ (when (not @VIsual_active)
                        (reset! VIsual_cursor start_pos))
                  win (assoc win :w_cursor pos)
                  _ (reset! VIsual_active true)
                  _ (reset! VIsual_mode (byte \v))
                  _ (redraw-curbuf-later INVERTED)                          ;; update the inversion
                  win (when' (at? @p_sel (byte \e)) => win
                        (cond ;; Correction for exclusive selection depends on the direction.
                            (and      forward  (ltoreq @VIsual_cursor, (:w_cursor win))) (inc-cursor win, false)
                            (and (not forward) (ltoreq (:w_cursor win), @VIsual_cursor)) (do (swap! VIsual_cursor incp) win)
                            :else win)
                    )]
                (may-start-select (byte \c))
                (redraw-curbuf-later INVERTED)
                [(showmode win) true]
            ))
    ))

;; Check if pattern "expr" is one character or zero-width.
;; If "move" is true, check from the beginning of the buffer, else from the current cursor position.
;; Returns TRUE, FALSE or -1 for failure.

(defn- #_[window_C int] is-one-char? [#_window_C win, #_Bytes expr, #_boolean move]
    (let-when [o'called_emsg @called_emsg
               [win mat ?] (search-regcomp? win, nil, expr, RE_SEARCH, RE_SEARCH, SEARCH_KEEP)] ? => [win -1]

        (let [[pos flags] (if move [(NEW_pos_C) 0] [(:w_cursor win) SEARCH_START]) ;; accept a match at the cursor position
              [win pos sm1] (searchit? win, pos, FORWARD, (last-search-expr), 1, (| flags SEARCH_KEEP), RE_SEARCH, 0, nil)
              [win one?] ;; Zero-width pattern should match somewhere, then we can check if start and end are in the same position.
                (when' (non-zero? sm1) => [win -1]
                    (let [_ (reset! called_emsg false)
                          [win mat n] (vim-regexec? win, mat, (:lnum pos), 0, nil)
                          startpos (... (:m_startpos mat) 0) endpos (... (:m_endpos mat) 0)
                          one? (if (not @called_emsg) (if (and (non-zero? n) (== (:lnum startpos) (:lnum endpos)) (== (:col startpos) (:col endpos))) TRUE FALSE) -1)]
                        [win (if (and (== one? FALSE) (let [[pos ?] (incp? pos)] (and (<= 0 ?) (== (:col pos) (:col endpos))))) TRUE one?)])
                )]
            (swap! called_emsg #(or % o'called_emsg))
            [win one?])
    ))

;; Return true if line "lnum" is empty or has white chars only.

(defn- #_boolean linewhite [#_long lnum]
    (eos? (skipwhite (ml-get lnum))))

;; memline.c: Contains the functions for appending, deleting and changing the text lines.

;; Open a new memline.

(defn- #_memline_C ml-open []
    (let [#_memline_C ml (-> (NEW_memline_C) (assoc :ml_empty true :ml_line_count 1))]
        ;; Create an empty line 1.
;       %% insert @0 (u8 "")
        ml
    ))

;; Return a pointer to a (read-only copy of a) line.
;;
;; On failure an error message is given and "???" is returned
;; (to avoid having to check for error everywhere).

(defn- #_Bytes ml-get [#_long lnum]
    (if-not (<= 0 lnum (line-count @curbuf))
        (do
            (swap! curwin emsg* (u8 "E315: ml-get: invalid lnum: %ld"), lnum)
            (u8 "???")
        )
        (let [lnum (max 1 lnum)]           ;; pretend line 0 is line 1
;           %% return @(lnum - 1)
        )
    ))

;; Return pointer to position "pos".

(defn- #_Bytes ml-get-pos [#_pos_C pos]
    (.plus (ml-get (:lnum pos)) (:col pos)))

;; Return pointer to cursor position.

(defn- #_Bytes ml-get-cursor [#_window_C win]
    (.plus (ml-get (:lnum (:w_cursor win))) (:col (:w_cursor win))))

;; Append a line after lnum (may be 0 to insert a line in front of the file).
;; "line" does not need to be allocated, but can't be another line in a buffer,
;; unlocking may make it invalid.
;;
;; Check: The caller of this function should probably also call appended-lines().
;;
;; return false for failure, true otherwise

(defn- #_boolean ml-append [#_long lnum, #_Bytes line]
    ;; lnum: append after this line (can be 0)
    ;; line: text of the new line
    (if-not (<= 0 lnum (line-count @curbuf))
        false
        (do
;           %% insert @lnum STRDUP(line)
            (swap! curbuf update-in [:b_ml :ml_line_count] inc)
            (swap! curbuf assoc-in [:b_ml :ml_empty] false)
            true
        )
    ))

;; Replace line lnum in current buffer.
;;
;; Check: The caller of this function should probably also call
;; changed-lines(), unless update-screen(NOT_VALID) is used.
;;
;; return false for failure, true otherwise

(defn- #_boolean ml-replace [#_long lnum, #_Bytes line]
    (if (or (not (<= 1 lnum (line-count @curbuf))) (nil? line))           ;; just checking...
        false
        (do
;           %% replace @(lnum - 1) STRDUP(line)
            (swap! curbuf assoc-in [:b_ml :ml_empty] false)
            true
        )
    ))

;; Delete line 'lnum' in the current buffer.
;;
;; Check: The caller of this function should probably also call
;; deleted-lines() after this.
;;
;; return false for failure, true otherwise

(defn- #_boolean ml-delete [#_long lnum, #_boolean message]
    (let [lmax (line-count @curbuf)]
        (cond (not (<= 1 lnum lmax))
            false
        (== lmax 1) ;; if the file becomes empty the last line is replaced by an empty line
            (do
                (if message
                    (set-keep-msg no_lines_msg, 0))
;               %% replace @0 (u8 "")
                (swap! curbuf assoc-in [:b_ml :ml_empty] true)
                true
            )
        :else
            (do
;               %% delete @(lnum - 1)
                (swap! curbuf update-in [:b_ml :ml_line_count] dec)
                true
            )
        )
    ))

;; buffer.c: functions for dealing with the buffer structure --------------------------------------

;; Close the link to the buffer.

(defn- #_void close-buffer [#_window_C win]
    ;; decrease the link count from windows (unless not in any window)
    (let-when [n (:b_nwindows @curbuf)] (pos? n)
        ;; Set "b_last_cursor" when closing the last window for the buffer.
        ;; Remember the last cursor position and window options of the buffer.
        (when (== n 1)
            (swap! curbuf assoc :b_last_cursor (:w_cursor win)))
        (swap! curbuf update :b_nwindows dec))
    nil)

;; This is the ONLY way to create a new buffer.

(defn- #_buffer_C newBuffer []
    (-> (NEW_buffer_C) (assoc :b_u_synced true) (assoc-in [:b_last_cursor :lnum] 1)))

;; Print info about the current buffer.

(defn- #_window_C fileinfo [#_window_C win, #_int _fullname]
    (let [lnum (:lnum (:w_cursor win)) lmax (line-count @curbuf) changed @(:b_changed @curbuf)
          #_Bytes buf (Bytes. IOSIZE)]
        (let [#_Bytes s (-> buf (.be 0, (byte \")) (.plus 1))] ;; """
            (vim-strncpy s, (u8 "[No Name]"), (- IOSIZE (BDIFF s, buf) 1)))
        (let [#_int len (STRLEN buf)
              _ (ร .sprintf libC (.plus buf len), (u8 "\"%s"), (if changed (u8 " [Modified] ") (u8 " ")))
              #_long n (/ (* lnum 100) lmax)
              win (cond (:ml_empty (:b_ml @curbuf))
                    (let [len (STRLEN buf)]
                        (ร .sprintf libC (.plus buf len), (u8 "%s"), no_lines_msg)
                        win)
                @p_ru ;; Current line and column are already on the screen.
                    (let [len (STRLEN buf)]
                        (if (== lmax 1)
                            (ร .sprintf libC (.plus buf len), (u8 "1 line --%ld%%--"), n)
                            (ร .sprintf libC (.plus buf len), (u8 "%ld lines --%ld%%--"), lmax, n))
                        win)
                :else
                    (let [len (STRLEN buf)
                          _ (ร .sprintf libC (.plus buf len), (u8 "line %ld of %ld --%ld%%-- col "), lnum, lmax, n)
                          len (STRLEN buf) win (validate-virtcol win)]
                        (col-print (.plus buf len), (inc (:col (:w_cursor win))), (inc (:w_virtcol win)))
                        win)
                )]
            ;; Temporarily set "msg_scroll" to avoid the message being truncated.
            ;; First call msg-start() to get the message in the right place.
            (msg-start)
            (let [o'msg_scroll @msg_scroll _ (reset! msg_scroll true) win (msg win, buf)]
                (reset! msg_scroll o'msg_scroll)
                win
            ))
    ))

(defn- #_void col-print [#_Bytes buf, #_int col, #_int vcol]
    (if (== col vcol)
        (ร .sprintf libC buf, (u8 "%ld"), col)
        (ร .sprintf libC buf, (u8 "%ld-%ld"), col, vcol))
    nil)

;; Get relative cursor position in window into "buf[buflen]", in the form 99%, using "Top", "Bot" or "All" when appropriate.

(defn- #_void get-rel-pos [#_window_C win, #_Bytes buf, #_int buflen]
    (when (<= 3 buflen) ;; need at least 3 chars for writing
        ;; number of lines above/below window
        (let [above (dec (:w_topline win)) below (inc (- (line-count @curbuf) (:w_botline win)))]
            (cond (<= below 0)
                (vim-strncpy buf, (if (zero? above) (u8 "All") (u8 "Bot")), (dec buflen))
            (<= above 0)
                (vim-strncpy buf, (u8 "Top"), (dec buflen))
            :else
            (let [cent (if (< 1000000 above) (/ above (/ (+ above below) 100)) (/ (* above 100) (+ above below)))]
                (ร .sprintf libC buf, (u8 "%2d%%"), cent)
            ))
        ))
    nil)

;;; ============================================================================================== VimQ

;; charset.c --------------------------------------------------------------------------------------

(atom! boolean chartab_initialized)

(defn- #_void set-chartab [#_int c]
    (swap! curbuf update-in [:b_chartab (>>> c 5)] | (<< 1 (& c 0x1f)))
    nil)

(defn- #_void reset-chartab [#_int c]
    (swap! curbuf update-in [:b_chartab (>>> c 5)] & (bit-not (<< 1 (& c 0x1f))))
    nil)

(defn- #_int get-chartab [#_int c]
    (& (... (:b_chartab @curbuf) (>>> c 5)) (<< 1 (& c 0x1f))))

;; Fill chartab[].  Also fills @curbuf.b_chartab[] with flags for keyword characters for current buffer.
;;
;; Depends on the option settings 'isident', 'isprint', 'isfname' and 'iskeyword'.
;;
;; The index in chartab[] depends on 'encoding':
;; - For non-multi-byte index with the byte (same as the character).
;; - For UTF-8 index with the character (when first byte is up to 0x80 it is the same
;;   as the character, if the first byte is 0x80 and above it depends on further bytes).
;;
;; The contents of chartab[]:
;; - The lower three bits, masked by CT_CELL_MASK, give the number of display cells
;;   the character occupies (1, 2 or 4).  Not valid for UTF-8 above 0x80.
;; - CT_PRINT_CHAR bit is set when the character is printable (no need to translate before displaying it).
;; - CT_IDENT_CHAR bit is set when the character can be in an identifier.
;; - CT_FNAME_CHAR bit is set when the character can be in a file name.
;;
;; Return false if 'isident', 'isprint', 'isfname' or 'iskeyword' option has an error, true otherwise.

(defn- #_boolean init-chartab [#_boolean global] ;; global: false: only set @curbuf.b_chartab[]
    (let [wide (if (flag? @dy_flags DY_UHEX) (byte 4) (byte 2))]
        (when global
            (let [cls- #(condp > % (byte \space) wide DEL (inc CT_PRINT_CHAR) 0xa0 wide 256 (inc (+ CT_PRINT_CHAR CT_FNAME_CHAR)))]
                (swap! chartab #(into (empty %) (map cls- %)))
            ))
        (swap! curbuf update :b_chartab #(into (empty %) (map (constantly 0) %)))
        ;; Walk through the 'isident', 'isprint', 'isfname' and 'iskeyword' options:
        ;; characters, numbers or ranges separated by commas, e.g.: "48-57,x,#-37,-"
        (and
            (loop-when-recur [#_int round (if global 0 3)] (<= round 3) [(inc round)] => true
                (loop-when [#_Bytes p (condp == round 0 @p_isi 1 @p_isp 2 @p_isf 3 @(:b_p_isk @curbuf))] (non-eos? p) => true
                    (let-when [gec- #(let [__ (atom (#_Bytes object %))] (if (asc-isdigit (.at % 0)) [(getdigits __) @__] [(us-ptr2char-adv __, true) @__]))
                        [#_boolean ! p] (if (and (at? p (byte \^)) (non-eos? p 1)) [true (.plus p 1)] [false p])
                        [#_int c p] (gec- p)
                        [#_int e p] (if (and (at? p (byte \-)) (non-eos? p 1)) (gec- (.plus p 1)) [-1 p])
                    ] (and (< 0 c) (< c 256) (or (<= c e) (== e -1)) (< e 256) (or (eos? p) (at? p (byte \,)))) => false
                        ;; A single '@' (not "@-@") = any isalpha (islower|isupper).
                        (let [[#_boolean alpha c e] (cond (!= e -1) [false c e] (== c (byte \@)) [true 1 255] :else [false c c])
                            cel- #(-> % (& (bit-not CT_CELL_MASK)) (+ (if ! wide 1)))
                            bit- (fn [x y] (if ! (& x (bit-not y)) (| x y)))]
                            (loop-when-recur c (<= c e) (inc c)
                                (when (or (not alpha) (utf-islower c) (utf-isupper c))
                                    (condp == round
                                        0       (swap! chartab update c              bit- CT_IDENT_CHAR)
                                        1 (when (or (< c (byte \space)) (< (byte \~) c))
                                                (swap! chartab update c #(-> % cel- (bit- CT_PRINT_CHAR))))
                                        2       (swap! chartab update c              bit- CT_FNAME_CHAR)
                                        3 (if ! (reset-chartab c) (set-chartab c))
                                    )))
                            (let [#_int c (.at p 0) p (skip-to-option-part p)]
                                ;; Trailing comma is not allowed.
                                (if (and (== c (byte \,)) (eos? p)) false (recur p)))
                        ))
                ))
            (reset! chartab_initialized true))
    ))

;; Translate any special characters in buf[bufsize] in-place.
;; The result is a string with only printable characters, but if there is not
;; enough room, not all characters will be translated.

(defn- #_void trans-characters [#_Bytes buf, #_int bufsize]
    (loop-when [buf buf #_int len (STRLEN buf) #_int room (- bufsize len)] (non-eos? buf)
        (let-when [#_int n (us-ptr2len-cc buf)
            ;; Assume a multi-byte character doesn't need translation.
            [n len room :as _] (if (< 1 n)
                [n (- len n) room]
                (let-when [#_Bytes s (transchar-byte (.at buf 0)) n (STRLEN s)
                           room (if (< 1 n) (let-when [room (- room (dec n))] (< 0 room) (BCOPY buf, n, buf, 1, len) room) room)]
                (some? room)
                    (BCOPY buf, s, n)
                    [n (dec len) room]
                ))] (some? _)
            (recur (.plus buf n) len room)
        ))
    nil)

;; Catch 22: chartab[] can't be initialized before the options are initialized,
;; and initializing options may cause transchar() to be called!
;; When !chartab_initialized, don't use chartab[].
;; Does NOT work for multi-byte characters, c must be <= 255.
;; Also doesn't work for the first byte of a multi-byte, "c" must be a character!

(final Bytes transchar_buf (Bytes. 7))

(defn- #_Bytes transchar [#_int c]
    (let [buf transchar_buf
          [#_int i c] (if (is-special c) ;; special key code, display as ~@ char
                (do (-> buf (.be 0, (byte \~)) (.be 1, (byte \@))) [2 (char_u (KB-SECOND c))])
                [0 c]
            )]
        (if (or (and (not @chartab_initialized) (<= (byte \space) c (byte \~))) (and (< c 256) (vim-isprintc c)))
            (-> buf (.be i, c) (eos! (inc i))) ;; printable character
            (transchar-nonprint (.plus buf i), c))
        buf
    ))

;; Like transchar(), but called with a byte instead of a character.
;; Checks for an illegal UTF-8 byte.

(defn- #_Bytes transchar-byte [#_byte b]
    (let [c (char_u b)]
        (if (< c 0x80) (transchar c) (transchar-nonprint transchar_buf, c))
    ))

;; Convert non-printable character to two or more printable characters in "buf[]".
;; "buf" needs to be able to hold five bytes.
;; Does NOT work for multi-byte characters, c must be <= 255.

(defn- #_Bytes transchar-nonprint [#_Bytes buf, #_int c]
    (let [c (if (== c NL) NUL c)]                                                           ;; we use newline in place of a NUL
        (cond (flag? @dy_flags DY_UHEX)                                                     ;; 'display' has "uhex"
            (transchar-hex buf, c)
        (<= c 0x7f)                                                                         ;; 0x00 - 0x1f and 0x7f
            (-> buf (.be 0, (byte \^)) (.be 1, (byte (bit-xor c 0x40))) (eos! 2))           ;; DEL displayed as ^?
        (<= 0x80 c)
            (transchar-hex buf, c)
        (and (<= (+ (byte \space) 0x80) c) (<= c (+ (byte \~) 0x80)))                       ;; 0xa0 - 0xfe
            (-> buf (.be 0, (byte \|)) (.be 1, (byte (- c 0x80))) (eos! 2))
        :else                                                                               ;; 0x80 - 0x9f and 0xff
            (-> buf (.be 0, (byte \~)) (.be 1, (byte (bit-xor (- c 0x80) 0x40))) (eos! 2))  ;; 0xff displayed as ~?
        ))
    buf)

(defn- #_Bytes transchar-hex [#_Bytes buf, #_int c]
    (let [#_int' a'i (atom (int 0))]
        (.be buf @a'i, (byte \<))
        (when (< 0xff c)
            (.be buf (swap! a'i inc), (nr2hex (>>> c 12)))
            (.be buf (swap! a'i inc), (nr2hex (>>> c 8)))
        )
        (.be buf (swap! a'i inc), (nr2hex (>>> c 4)))
        (.be buf (swap! a'i inc), (nr2hex c))
        (.be buf (swap! a'i inc), (byte \>))
        (eos! buf (swap! a'i inc))
    )
    buf)

;; Convert the lower 4 bits of byte "c" to its hex character.
;; Lower case letters are used to avoid the confusion of <F1> being 0xf1 or function key 1.

(defn- #_int nr2hex [#_int c]
    (let [n (& c 0xf)]
        (if (< n 10) (+ (byte \0) n) (+ (byte \a) (- n 10)))
    ))

;; Return the number of screen cells occupied by byte "b".
;; For multi-byte mode "b" must be the first byte of a character.
;; A TAB is counted as two cells: "^I".
;; For UTF-8 mode this will return 0 for bytes >= 0x80, because the number of cells depends on further bytes.

(defn- #_int mb-byte2cells [#_byte b]
    (let [c (char_u b)]
        (if (< c 0x80) (& (... @chartab c) CT_CELL_MASK) 0)
    ))

;; Return the number of screen cells occupied by character "c".
;; "c" can be a special key (negative number) in which case 3 or 4 is returned.
;; A TAB is counted as two cells: "^I" or four: "<09>".

(defn- #_int mb-char2cells [#_int c]
    (cond
        (is-special c) (+ (mb-char2cells (char_u (KB-SECOND c))) 2)
        ;; UTF-8: above 0x80 need to check the value.
        (<= 0x80 c) (utf-char2cells c)
        :else (& (... @chartab (& c 0xff)) CT_CELL_MASK)
    ))

;; Return the number of screen cells for character at "*s".
;; TAB is counted as either two: "^I" or four: "<09>".

(defn- mb-ptr2cells
    ([s] (mb-ptr2cells s 0))
    ([s i]
        (let [c (char_u (.at s i))]
            ;; For UTF-8 we need to look at more bytes if the first byte is >= 0x80.
            (if (<= 0x80 c) (us-ptr2cells s, i) (& (... @chartab c) CT_CELL_MASK))
        )))

;; Return the number of screen cells for "*s" counting TABs as two characters: "^I".

(defn- mb-string2cells
    ([s] (mb-string2cells s -1))
    ([s n]
        (loop-when-recur [cells 0 i 0]
                         (and (or (< n 0) (< i n)) (non-eos? s i))
                         [(+ cells (mb-ptr2cells s, i)) (+ i (us-ptr2len-cc s, i))]
                      => cells)))

;; Return the number of screen cells for "*s" taking into account the size of TABs.
;; Also see getvcol() below.

(defn- chartabsize
    ([s col] (chartabsize s 0 col))
    ([s i col]
        (if (at? s i TAB)
            (let [ts @(:b_p_ts @curbuf)] (- ts (% col ts)))
            (mb-ptr2cells s, i)
        )))

;; Return the number of screen cells for "*s" taking into account the size of TABs.

(defn- #_int linetabsize [#_window_C win, #_Bytes s]
    (linetabsize-col win, s, 0))

;; Like linetabsize(), but starting at column "startcol".

(defn- #_int linetabsize-col [#_window_C win, #_Bytes _s, #_int startcol]
    (let [#_Bytes' a's (atom (#_Bytes object _s)) #_Bytes line @a's] ;; pointer to start of line, for breakindent
        (loop-when-recur [#_int col startcol] (non-eos? @a's) [(+ col (lbr-chartabsize-adv win, line, a's, col))] => col)
    ))

;; Like linetabsize(), but for a given window instead of the current one.

(defn- #_int win-linetabsize [#_window_C win, #_Bytes line, #_int len]
    (loop-when-recur [#_int col 0 #_Bytes s line]
                     (and (non-eos? s) (or (== len MAXCOL) (BLT s, (.plus line len))))
                     [(+ col (win-lbr-chartabsize win, line, s, col, nil)) (.plus s (us-ptr2len-cc s))]
                  => col))

;; Return true if 'c' is a normal identifier character:
;; Letters and characters from the 'isident' option.

(defn- #_boolean vim-isidentc [#_int c]
    (and (< 0 c 0x100) (flag? (... @chartab c) CT_IDENT_CHAR)))

;; Return true if 'c' is a keyword character:
;; Letters and characters from 'iskeyword' option for current buffer.
;; For multi-byte characters us-get-class() is used (builtin rules).

(defn- #_boolean vim-iswordc [#_int c]
    (if (<= 0x100 c) (<= 2 (utf-class c)) (and (< 0 c 0x100) (non-zero? (get-chartab c)))))

(defn- #_boolean us-iswordb [#_byte b]
    (and (non-zero? b) (non-zero? (get-chartab (char_u b)))))

(defn- #_boolean us-iswordp [#_Bytes p]
    (if (< 1 (us-byte2len (.at p 0), false)) (<= 2 (us-get-class p)) (us-iswordb (.at p 0))))

;; Return true if 'c' is a valid file-name character.
;; Assume characters above 0x100 are valid (multi-byte).

(defn- #_boolean vim-isfnamec [#_int c]
    (or (<= 0x100 c) (and (< 0 c) (flag? (... @chartab c) CT_FNAME_CHAR))))

;; Return true if 'c' is a printable character.
;; Assume characters above 0x100 are printable (multi-byte), except for Unicode.

(defn- #_boolean vim-isprintc [#_int c]
    (if (<= 0x100 c) (utf-printable c) (or (<= 0x100 c) (and (< 0 c) (flag? (... @chartab c) CT_PRINT_CHAR)))))

;; like chartabsize(), but also check for line breaks on the screen

(defn- #_int lbr-chartabsize [#_window_C win, #_Bytes line, #_Bytes s, #_int col]
    ;; line: start of the line
    (let [wops (:w_options win)] (cond
        (or @(:wo_lbr wops) (non-eos? @p_sbr) @(:wo_bri wops))
            (win-lbr-chartabsize win, (if (nil? line) s line), s, col, nil)
        @(:wo_wrap wops)
            (win-nolbr-chartabsize win, s, col, nil)
        :else
            (chartabsize s, col)
    )))

;; Call lbr-chartabsize() and advance the pointer.

(defn- #_int lbr-chartabsize-adv [#_window_C win, #_Bytes line, #_Bytes' a's, #_int col]
    ;; line: start of the line
    (let [#_int size (lbr-chartabsize win, line, @a's, col)]
        (swap! a's #(.plus % (us-ptr2len-cc %)))
        size
    ))

;; This function is used very often, keep it fast!!!!
;;
;; If "head" not null, set "*head" to the size of what we for 'showbreak' string at start of line.
;; Warning: "*head" is only set if it's a non-zero value, init to 0 before calling.

(defn- #_int win-lbr-chartabsize [#_window_C win, #_Bytes line, #_Bytes s, #_int col, #_int' a'head]
    ;; line: start of the line
    (let [lbr @(:wo_lbr (:w_options win)) bri @(:wo_bri (:w_options win)) wrap @(:wo_wrap (:w_options win))]
        ;; No 'linebreak', 'showbreak' and 'breakindent': return quickly.
        (if (and (not lbr) (not bri) (eos? @p_sbr))
            (if wrap (win-nolbr-chartabsize win, s, col, a'head) (chartabsize s, col))
            ;; First get normal size, without 'linebreak'.
            (let [#_int size (chartabsize s, col)
                  #_int col_adj (if (at? s TAB) (dec size) 0) ;; col + screen size of tab
                  breakat? #(... @breakat_flags (char_u (.at %1 %2)))
                  ;; If 'linebreak' set check at a blank before a non-blank if the line needs a break here.
                  [size #_int mb_added]
                        (cond (and lbr (breakat? s 0) (not (breakat? s 1)) wrap (non-zero? (:w_width win)))
                            ;; Count all characters from first non-blank after a blank up to next non-blank after a blank.
                            (let [#_int colmax (let [x (- (:w_width win) (win-col-off win) col_adj)] (if (<= x col)
                                               (let [m (+ x col_adj) n (+ m (win-col-off2 win))]     (if (< 0 n) (+ m (- (* (inc (/ (- col m) n)) n) col_adj)) m)) x))
                                size (loop [s s #_int col2 col]
                                        (let-when [#_Bytes ps s s (.plus s (us-ptr2len-cc s))]
                                                  (and (non-eos? s) (or (breakat? s 0) (and (not (breakat? s 0)) (or (== col2 col) (not (breakat? ps 0)))))) => size
                                            (let-when [col2 (+ col2 (chartabsize s, col2))] (< col2 colmax) => (+ (- colmax col) col_adj) ;; doesn't fit
                                                (recur s col2)
                                            )))]
                                [size 0])
                        (and (== size 2) (< 1 (us-byte2len (.at s 0), false)) wrap (in-win-border win, col))
                            [(inc size) 1] ;; count the ">" in the last column
                        :else
                            [size 0])
                  ;; May have to add something for 'breakindent' and/or 'showbreak' string at start of line.
                  [size #_int added]
                        (if (and (or (non-eos? @p_sbr) bri) (and wrap (non-zero? col)))
                            (let [#_int z (if (non-eos? @p_sbr) (us-charlen @p_sbr) 0)
                                  #_int n (win-col-off win)
                                  col (+ col n mb_added)
                                  [n col] (if (<= (:w_width win) col)
                                            (let [n (- n (win-col-off2 win))
                                                  #_int e (- (:w_width win) n)
                                                  col (- col (:w_width win))
                                                  col (if (and (<= e col) (< 0 e)) (% col e) col)
                                                  col (if (and (non-eos? @p_sbr) (<= z col)) (- col z) col)
                                                  col (cond (and (<= e col) (< 0 e)) (% col e) (and (< 0 col) (< 0 e)) (+ col n) :else col)]
                                                [n col])
                                            [n col])]
                                (if (or (zero? col) (< (:w_width win) (+ col size z)))
                                    (let [#_int m (if (non-eos? @p_sbr)
                                                    (if (< (:w_width win) (+ size z n))
                                                        (let [#_int w (- (:w_width win) z n) w (if (zero? w) (:w_width win) w)
                                                              #_int x (- size (if (non-zero? col) (- (:w_width win) z col) 0))]
                                                            (+ (/ x w) (if (non-zero? (% x w)) 1 0))) ;; if wrapped, add another length of 'sbr'
                                                        1)
                                                    0)
                                          added (* m (mb-string2cells @p_sbr))
                                          added (if bri (+ added (get-breakindent win, line)) added)]
                                        [(+ size added) (if (zero? col) added 0)])
                                    [size 0]
                                ))
                            [size 0]
                        )]
                ;; Set "*head" to the size of what we add.
                (when (some? a'head) (reset! a'head (+ added mb_added)))
                size
            ))
    ))

;; Like win-lbr-chartabsize(), except that we know 'linebreak' is off and 'wrap' is on.
;; This means we need to check for a double-byte character that doesn't fit at the end
;; of the screen line.

(defn- #_int win-nolbr-chartabsize [#_window_C win, #_Bytes s, #_int col, #_int' a'head]
    (if (at? s TAB)
        (let [#_int ts (int @(:b_p_ts @curbuf))] (- ts (% col ts)))
        ;; Add one cell for a double-width character in the last column of the window, displayed with a ">".
        (let-when [#_int n (mb-ptr2cells s)] (and (== n 2) (< 1 (us-byte2len (.at s 0), false)) (in-win-border win, col)) => n
            (when (some? a'head) (reset! a'head 1))
            3)
    ))

;; Return true if virtual column "vcol" is in the rightmost column of window "win".

(defn- #_boolean in-win-border [#_window_C win, #_int vcol]
    (if (zero? (:w_width win))                                          ;; there is no border
        false
        (let [#_int width1 (- (:w_width win) (win-col-off win))]        ;; width of first line (after line number)
            (cond (< vcol (dec width1))
                false
            (== vcol (dec width1))
                true
            :else
                (let [#_int width2 (+ width1 (win-col-off2 win))]       ;; width of further lines
                    (if (<= width2 0)
                        false
                        (== (% (- vcol width1) width2) (dec width2))
                    ))
            ))
    ))

;; Get virtual column number of pos.
;;
;;  start: on the first position of this character (TAB, ctrl)
;; cursor: where the cursor is on this character (first char, except for TAB)
;;    end: on the last position of this character (TAB, ctrl)
;;
;; This is used very often, keep it fast!

(defn- #_void getvcol [#_window_C win, #_pos_C pos, #_int' a'start, #_int' a'cursor, #_int' a'end]
    (let [lbr @(:wo_lbr (:w_options win)) bri @(:wo_bri (:w_options win)) wrap @(:wo_wrap (:w_options win))
          #_Bytes line (ml-get (:lnum pos))
          #_Bytes q (if (== (:col pos) MAXCOL) nil (.plus line (:col pos)))
          a'head (atom (int))
          tabs- (fn [#_Bytes s, #_int col]
                    (if (at? s TAB)
                        (let [#_int ts (int @(:b_p_ts @curbuf))] (- ts (% col ts)))
                        (let-when [#_int n (mb-ptr2cells s)] (and (== n 2) wrap (< 1 (us-byte2len (.at s 0), false)) (in-win-border win, col)) => n
                            ;; If a double-cell char doesn't fit at eol, it wraps to the next line, like this char is three cells wide.
                            (reset! a'head 1)
                            (inc n))
                    ))
          ;; This function is used very often, do some speed optimizations.
          ;; When 'linebreak', 'showbreak' and 'breakindent' are not set, use a simple loop.
          [#_int vcol #_int i #_Bytes p]
            (cond (and (not lbr) (eos? @p_sbr) (not bri))
                (loop [vcol 0 p line] (reset! a'head 0)
                    ;; make sure we don't go past the end of the line
                    (if (eos? p)
                        [vcol 1 p]          ;; NUL at end of line only takes one column
                        ;; A tab gets expanded, depending on the current column.
                        (let [i (tabs- p, vcol)]
                            (if (and (some? q) (BLE q, p))
                                [vcol i p]
                                (recur (+ vcol i) (.plus p (us-ptr2len-cc p)))))
                    ))
            :else
                (loop [vcol 0 p line] (reset! a'head 0)
                    ;; A tab gets expanded, depending on the current column.
                    (let [i (win-lbr-chartabsize win, line, p, vcol, a'head)]
                        ;; make sure we don't go past the end of the line
                        (cond (eos? p)
                            [vcol 1 p]       ;; NUL at end of line only takes one column
                        (and (some? q) (BLE q, p))
                            [vcol i p]
                        :else
                            (recur (+ vcol i) (.plus p (us-ptr2len-cc p))))
                    ))
            )]
        (when (some? a'start)  (reset! a'start (+ vcol @a'head)))
        (when (some? a'end)    (reset! a'end (dec (+ vcol i))))
        (when (some? a'cursor) (reset! a'cursor
            (if (and (at? p TAB) (flag? @State NORMAL) (not (virtual-active)) (not (and @VIsual_active (or (at? @p_sel (byte \e)) (ltoreq pos, @VIsual_cursor)))))
                (dec (+ vcol i))    ;; cursor at end
                (+ vcol @a'head)    ;; cursor at start
            )))
    )
    nil)

;; Get virtual cursor column in the current window, pretending 'list' is off.

(defn- #_int getvcol-nolist [#_window_C win, #_pos_C pos]
    (let [#_int' a'vcol (atom (int))]
        (getvcol win, pos, nil, a'vcol, nil)
        @a'vcol
    ))

;; Get virtual column in virtual mode.

(defn- #_void getvvcol [#_window_C win, #_pos_C pos, #_int' a'start, #_int' a'cursor, #_int' a'end]
    (if (virtual-active)
        (let [#_int' a'col (atom (int))]
            ;; For virtual mode, only want one value.
            (getvcol win, pos, a'col, nil, nil)
            (let [coladd (:coladd pos) [coladd endadd]
                ;; Cannot put the cursor on part of a wide character.
                    (let-when [#_Bytes s (ml-get (:lnum pos))] (< (:col pos) (STRLEN s)) => [coladd 0]
                        (let-when [#_int c (us-ptr2char s, (:col pos))] (and (!= c TAB) (vim-isprintc c)) => [coladd 0]
                            (let-when [endadd (dec (mb-char2cells c))] (< endadd coladd) => [0 endadd]
                                [coladd 0] ;; past end of line
                            )
                        )
                    )]
                (swap! a'col + coladd)
                (when (some? a'start) (reset! a'start @a'col))
                (when (some? a'cursor) (reset! a'cursor @a'col))
                (when (some? a'end) (reset! a'end (+ @a'col endadd)))
            ))
        (getvcol win, pos, a'start, a'cursor, a'end))
    nil)

;; Get the leftmost and rightmost virtual column of pos1 and pos2.
;; Used for Visual block mode.

(defn- #_void getvcols [#_window_C win, #_pos_C pos1, #_pos_C pos2, #_int' a'left, #_int' a'right]
    (let [a'from1 (atom (int)) a'from2 (atom (int)) a'to1 (atom (int)) a'to2 (atom (int))]
        (if (ltpos pos1, pos2)
            (do (getvvcol win, pos1, a'from1, nil, a'to1) (getvvcol win, pos2, a'from2, nil, a'to2))
            (do (getvvcol win, pos2, a'from1, nil, a'to1) (getvvcol win, pos1, a'from2, nil, a'to2))
        )
        (reset! a'left (min @a'from1 @a'from2))
        (reset! a'right (if (< @a'to1 @a'to2) (if (and (at? @p_sel (byte \e)) (<= @a'to1 (dec @a'from2))) (dec @a'from2) @a'to2) @a'to1)))
    nil)

(defn- #_Bytes skipwhite  [#_Bytes s] (loop-when-recur s (vim-iswhite (.at s 0)) (.plus s 1) => s)) ;; skip to next non-white
(defn- #_Bytes skipdigits [#_Bytes s] (loop-when-recur s (asc-isdigit (.at s 0)) (.plus s 1) => s)) ;; skip to next non-digit

(defn- #_boolean asc-isdigit  [#_int c] (<= (byte \0) c (byte \9)))
(defn- #_boolean asc-isodigit [#_int c] (<= (byte \0) c (byte \7)))
(defn- #_boolean asc-isxdigit [#_int c] (or (<= (byte \0) c (byte \9)) (<= (byte \a) c (byte \f)) (<= (byte \A) c (byte \F))))

;; Get a number from a string and skip over it.

(defn- #_long getdigits [#_Bytes' a's]
    (let [n (ร .atol libC @a's)]
        (when (at? @a's (byte \-))                  ;; skip negative sign
            (swap! a's plus 1))
        (swap! a's skipdigits)              ;; skip to next non-digit
        n
    ))

;; Convert a string into a long and/or unsigned long, taking care of
;; hexadecimal and octal numbers.  Accepts a '-' sign.
;; If "t" is not null, returns a flag to indicate the type of the number:
;;  0           decimal
;;  '0'         octal
;;  'x' or 'X'  hexadecimal
;; If "l" is not null, the length of the number in characters is returned.
;; If "dooct" is true, recognize octal numbers.
;; If "dohex" is true, recognize hex numbers.
;; If "n" is not null, the signed result is returned in it.

(defn- #_void vim-str2nr [#_Bytes start, #_int' a't, #_int' a'l, #_boolean dooct, #_boolean dohex, #_long' a'n]
    (let [#_boolean negative (at? start (byte \-))
          #_Bytes s (if negative (.plus start 1) start)
          ;; Recognize hex and octal.
          [#_int x s]
            (if (and (at? s (byte \0)) (not-at? s 1 (byte \8)) (not-at? s 1 (byte \9)))
                (let [x (.at s 1)]
                    (if (and dohex (any == x (byte \X) (byte \x)) (asc-isxdigit (.at s 2)))
                        [x (.plus s 2)]                                                         ;; hexadecimal
                        (if dooct
                            ;; Don't interpret "0", "08" or "0129" as octal.
                            (loop-when [x 0 #_int i 1] (asc-isdigit (.at s i)) => [x s]
                                (if (< (byte \7) (.at s i))
                                    [0 s]                                                       ;; can't be octal
                                    (recur (if (<= (byte \0) (.at s i)) (byte \0) x) (inc i))   ;; assume octal
                                ))
                            [0 s])
                    ))
                [0 s]
            )]
        (let [[#_long nr s] ;; do the conversion "manually" to avoid sscanf quirks
                (cond (== x (byte \0))                                              ;; octal
                    (loop-when [nr 0 #_int i 0] (asc-isodigit (.at s i))
                        (let [#_long a (+ (* 8 nr) (long (- (.at s i) (byte \0))))]
                            (recur-if (<= nr a) [a (inc i)] => [nr (.plus s i)])
                        ))
                (non-zero? x)                                                       ;; hex
                    (loop-when [nr 0 #_int i 0] (asc-isxdigit (.at s i))
                        (let [#_long a (+ (* 16 nr) (long (hex2nr (.at s i))))]
                            (recur-if (<= nr a) [a (inc i)] => [nr (.plus s i)])
                        ))
                :else                                                               ;; decimal
                    (loop-when [nr 0 #_int i 0] (asc-isdigit (.at s i))
                        (let [#_long a (+ (* 10 nr) (long (- (.at s i) (byte \0))))]
                            (recur-if (<= nr a) [a (inc i)] => [nr (.plus s i)])
                        ))
                )]
            (when (some? a't) (reset! a't x))
            (when (some? a'l) (reset! a'l (BDIFF s, start)))
            (when (some? a'n) (reset! a'n (if negative (- nr) nr))) ;; account for leading '-' for decimal numbers
        ))
    nil)

;; Return the value of a single hex character.
;; Only valid when the argument is '0' - '9', 'A' - 'F' or 'a' - 'f'.

(defn- #_int hex2nr [#_int c]
    (cond
        (<= (byte \a) c (byte \f)) (+ (- c (byte \a)) 10)
        (<= (byte \A) c (byte \F)) (+ (- c (byte \A)) 10)
        :else (- c (byte \0))
    ))

;;; ============================================================================================== VimR

;; digraph.c: code for digraphs -------------------------------------------------------------------

(class! #_final digr_C
    [
        (field byte     char1)
        (field byte     char2)
        (field int      result)
    ])

(defn- #_final #_digr_C digr [#_"/*byte*/char" char1, #_"/*byte*/char" char2, #_int result]
    (digr_C. (byte char1), (byte char2), result))

;; digraphs for Unicode from RFC1345 (also work for ISO-8859-1 aka latin1)
(final digr_C* digraphdefault
    [
        (digr \N, \U, 0x0a),       ;; LF for NUL
        (digr \S, \H, 0x01),
        (digr \S, \X, 0x02),
        (digr \E, \X, 0x03),
        (digr \E, \T, 0x04),
        (digr \E, \Q, 0x05),
        (digr \A, \K, 0x06),
        (digr \B, \L, 0x07),
        (digr \B, \S, 0x08),
        (digr \H, \T, 0x09),
        (digr \L, \F, 0x0a),
        (digr \V, \T, 0x0b),
        (digr \F, \F, 0x0c),
        (digr \C, \R, 0x0d),
        (digr \S, \O, 0x0e),
        (digr \S, \I, 0x0f),
        (digr \D, \L, 0x10),
        (digr \D, \1, 0x11),
        (digr \D, \2, 0x12),
        (digr \D, \3, 0x13),
        (digr \D, \4, 0x14),
        (digr \N, \K, 0x15),
        (digr \S, \Y, 0x16),
        (digr \E, \B, 0x17),
        (digr \C, \N, 0x18),
        (digr \E, \M, 0x19),
        (digr \S, \B, 0x1a),
        (digr \E, \C, 0x1b),
        (digr \F, \S, 0x1c),
        (digr \G, \S, 0x1d),
        (digr \R, \S, 0x1e),
        (digr \U, \S, 0x1f),
        (digr \S, \P, 0x20),
        (digr \N, \b, 0x23),
        (digr \D, \O, 0x24),
        (digr \A, \t, 0x40),
        (digr \<, \(, 0x5b),
        (digr \/, \/, 0x5c),
        (digr \), \>, 0x5d),
        (digr \', \>, 0x5e),
        (digr \', \!, 0x60),
        (digr \(, \!, 0x7b),
        (digr \!, \!, 0x7c),
        (digr \!, \), 0x7d),
        (digr \', \?, 0x7e),
        (digr \D, \T, 0x7f),
        (digr \P, \A, 0x80),
        (digr \H, \O, 0x81),
        (digr \B, \H, 0x82),
        (digr \N, \H, 0x83),
        (digr \I, \N, 0x84),
        (digr \N, \L, 0x85),
        (digr \S, \A, 0x86),
        (digr \E, \S, 0x87),
        (digr \H, \S, 0x88),
        (digr \H, \J, 0x89),
        (digr \V, \S, 0x8a),
        (digr \P, \D, 0x8b),
        (digr \P, \U, 0x8c),
        (digr \R, \I, 0x8d),
        (digr \S, \2, 0x8e),
        (digr \S, \3, 0x8f),
        (digr \D, \C, 0x90),
        (digr \P, \1, 0x91),
        (digr \P, \2, 0x92),
        (digr \T, \S, 0x93),
        (digr \C, \C, 0x94),
        (digr \M, \W, 0x95),
        (digr \S, \G, 0x96),
        (digr \E, \G, 0x97),
        (digr \S, \S, 0x98),
        (digr \G, \C, 0x99),
        (digr \S, \C, 0x9a),
        (digr \C, \I, 0x9b),
        (digr \S, \T, 0x9c),
        (digr \O, \C, 0x9d),
        (digr \P, \M, 0x9e),
        (digr \A, \C, 0x9f),
        (digr \N, \S, 0xa0),
        (digr \!, \I, 0xa1),
        (digr \C, \t, 0xa2),
        (digr \P, \d, 0xa3),
        (digr \C, \u, 0xa4),
        (digr \Y, \e, 0xa5),
        (digr \B, \B, 0xa6),
        (digr \S, \E, 0xa7),
        (digr \', \:, 0xa8),
        (digr \C, \o, 0xa9),
        (digr \-, \a, 0xaa),
        (digr \<, \<, 0xab),
        (digr \N, \O, 0xac),
        (digr \-, \-, 0xad),
        (digr \R, \g, 0xae),
        (digr \', \m, 0xaf),
        (digr \D, \G, 0xb0),
        (digr \+, \-, 0xb1),
        (digr \2, \S, 0xb2),
        (digr \3, \S, 0xb3),
        (digr \', \', 0xb4),
        (digr \M, \y, 0xb5),
        (digr \P, \I, 0xb6),
        (digr \., \M, 0xb7),
        (digr \', \,, 0xb8),
        (digr \1, \S, 0xb9),
        (digr \-, \o, 0xba),
        (digr \>, \>, 0xbb),
        (digr \1, \4, 0xbc),
        (digr \1, \2, 0xbd),
        (digr \3, \4, 0xbe),
        (digr \?, \I, 0xbf),
        (digr \A, \!, 0xc0),
        (digr \A, \', 0xc1),
        (digr \A, \>, 0xc2),
        (digr \A, \?, 0xc3),
        (digr \A, \:, 0xc4),
        (digr \A, \A, 0xc5),
        (digr \A, \E, 0xc6),
        (digr \C, \,, 0xc7),
        (digr \E, \!, 0xc8),
        (digr \E, \', 0xc9),
        (digr \E, \>, 0xca),
        (digr \E, \:, 0xcb),
        (digr \I, \!, 0xcc),
        (digr \I, \', 0xcd),
        (digr \I, \>, 0xce),
        (digr \I, \:, 0xcf),
        (digr \D, \-, 0xd0),
        (digr \N, \?, 0xd1),
        (digr \O, \!, 0xd2),
        (digr \O, \', 0xd3),
        (digr \O, \>, 0xd4),
        (digr \O, \?, 0xd5),
        (digr \O, \:, 0xd6),
        (digr \*, \X, 0xd7),
        (digr \O, \/, 0xd8),
        (digr \U, \!, 0xd9),
        (digr \U, \', 0xda),
        (digr \U, \>, 0xdb),
        (digr \U, \:, 0xdc),
        (digr \Y, \', 0xdd),
        (digr \T, \H, 0xde),
        (digr \s, \s, 0xdf),
        (digr \a, \!, 0xe0),
        (digr \a, \', 0xe1),
        (digr \a, \>, 0xe2),
        (digr \a, \?, 0xe3),
        (digr \a, \:, 0xe4),
        (digr \a, \a, 0xe5),
        (digr \a, \e, 0xe6),
        (digr \c, \,, 0xe7),
        (digr \e, \!, 0xe8),
        (digr \e, \', 0xe9),
        (digr \e, \>, 0xea),
        (digr \e, \:, 0xeb),
        (digr \i, \!, 0xec),
        (digr \i, \', 0xed),
        (digr \i, \>, 0xee),
        (digr \i, \:, 0xef),
        (digr \d, \-, 0xf0),
        (digr \n, \?, 0xf1),
        (digr \o, \!, 0xf2),
        (digr \o, \', 0xf3),
        (digr \o, \>, 0xf4),
        (digr \o, \?, 0xf5),
        (digr \o, \:, 0xf6),
        (digr \-, \:, 0xf7),
        (digr \o, \/, 0xf8),
        (digr \u, \!, 0xf9),
        (digr \u, \', 0xfa),
        (digr \u, \>, 0xfb),
        (digr \u, \:, 0xfc),
        (digr \y, \', 0xfd),
        (digr \t, \h, 0xfe),
        (digr \y, \:, 0xff),

        (digr \A, \-, 0x0100),
        (digr \a, \-, 0x0101),
        (digr \A, \(, 0x0102),
        (digr \a, \(, 0x0103),
        (digr \A, \;, 0x0104),
        (digr \a, \;, 0x0105),
        (digr \C, \', 0x0106),
        (digr \c, \', 0x0107),
        (digr \C, \>, 0x0108),
        (digr \c, \>, 0x0109),
        (digr \C, \., 0x010a),
        (digr \c, \., 0x010b),
        (digr \C, \<, 0x010c),
        (digr \c, \<, 0x010d),
        (digr \D, \<, 0x010e),
        (digr \d, \<, 0x010f),
        (digr \D, \/, 0x0110),
        (digr \d, \/, 0x0111),
        (digr \E, \-, 0x0112),
        (digr \e, \-, 0x0113),
        (digr \E, \(, 0x0114),
        (digr \e, \(, 0x0115),
        (digr \E, \., 0x0116),
        (digr \e, \., 0x0117),
        (digr \E, \;, 0x0118),
        (digr \e, \;, 0x0119),
        (digr \E, \<, 0x011a),
        (digr \e, \<, 0x011b),
        (digr \G, \>, 0x011c),
        (digr \g, \>, 0x011d),
        (digr \G, \(, 0x011e),
        (digr \g, \(, 0x011f),
        (digr \G, \., 0x0120),
        (digr \g, \., 0x0121),
        (digr \G, \,, 0x0122),
        (digr \g, \,, 0x0123),
        (digr \H, \>, 0x0124),
        (digr \h, \>, 0x0125),
        (digr \H, \/, 0x0126),
        (digr \h, \/, 0x0127),
        (digr \I, \?, 0x0128),
        (digr \i, \?, 0x0129),
        (digr \I, \-, 0x012a),
        (digr \i, \-, 0x012b),
        (digr \I, \(, 0x012c),
        (digr \i, \(, 0x012d),
        (digr \I, \;, 0x012e),
        (digr \i, \;, 0x012f),
        (digr \I, \., 0x0130),
        (digr \i, \., 0x0131),
        (digr \I, \J, 0x0132),
        (digr \i, \j, 0x0133),
        (digr \J, \>, 0x0134),
        (digr \j, \>, 0x0135),
        (digr \K, \,, 0x0136),
        (digr \k, \,, 0x0137),
        (digr \k, \k, 0x0138),
        (digr \L, \', 0x0139),
        (digr \l, \', 0x013a),
        (digr \L, \,, 0x013b),
        (digr \l, \,, 0x013c),
        (digr \L, \<, 0x013d),
        (digr \l, \<, 0x013e),
        (digr \L, \., 0x013f),
        (digr \l, \., 0x0140),
        (digr \L, \/, 0x0141),
        (digr \l, \/, 0x0142),
        (digr \N, \', 0x0143),
        (digr \n, \', 0x0144),
        (digr \N, \,, 0x0145),
        (digr \n, \,, 0x0146),
        (digr \N, \<, 0x0147),
        (digr \n, \<, 0x0148),
        (digr \', \n, 0x0149),
        (digr \N, \G, 0x014a),
        (digr \n, \g, 0x014b),
        (digr \O, \-, 0x014c),
        (digr \o, \-, 0x014d),
        (digr \O, \(, 0x014e),
        (digr \o, \(, 0x014f),
        (digr \O, \", 0x0150),  ;; """
        (digr \o, \", 0x0151),  ;; """
        (digr \O, \E, 0x0152),
        (digr \o, \e, 0x0153),
        (digr \R, \', 0x0154),
        (digr \r, \', 0x0155),
        (digr \R, \,, 0x0156),
        (digr \r, \,, 0x0157),
        (digr \R, \<, 0x0158),
        (digr \r, \<, 0x0159),
        (digr \S, \', 0x015a),
        (digr \s, \', 0x015b),
        (digr \S, \>, 0x015c),
        (digr \s, \>, 0x015d),
        (digr \S, \,, 0x015e),
        (digr \s, \,, 0x015f),
        (digr \S, \<, 0x0160),
        (digr \s, \<, 0x0161),
        (digr \T, \,, 0x0162),
        (digr \t, \,, 0x0163),
        (digr \T, \<, 0x0164),
        (digr \t, \<, 0x0165),
        (digr \T, \/, 0x0166),
        (digr \t, \/, 0x0167),
        (digr \U, \?, 0x0168),
        (digr \u, \?, 0x0169),
        (digr \U, \-, 0x016a),
        (digr \u, \-, 0x016b),
        (digr \U, \(, 0x016c),
        (digr \u, \(, 0x016d),
        (digr \U, \0, 0x016e),
        (digr \u, \0, 0x016f),
        (digr \U, \", 0x0170),  ;; """
        (digr \u, \", 0x0171),  ;; """
        (digr \U, \;, 0x0172),
        (digr \u, \;, 0x0173),
        (digr \W, \>, 0x0174),
        (digr \w, \>, 0x0175),
        (digr \Y, \>, 0x0176),
        (digr \y, \>, 0x0177),
        (digr \Y, \:, 0x0178),
        (digr \Z, \', 0x0179),
        (digr \z, \', 0x017a),
        (digr \Z, \., 0x017b),
        (digr \z, \., 0x017c),
        (digr \Z, \<, 0x017d),
        (digr \z, \<, 0x017e),
        (digr \O, \9, 0x01a0),
        (digr \o, \9, 0x01a1),
        (digr \O, \I, 0x01a2),
        (digr \o, \i, 0x01a3),
        (digr \y, \r, 0x01a6),
        (digr \U, \9, 0x01af),
        (digr \u, \9, 0x01b0),
        (digr \Z, \/, 0x01b5),
        (digr \z, \/, 0x01b6),
        (digr \E, \D, 0x01b7),
        (digr \A, \<, 0x01cd),
        (digr \a, \<, 0x01ce),
        (digr \I, \<, 0x01cf),
        (digr \i, \<, 0x01d0),
        (digr \O, \<, 0x01d1),
        (digr \o, \<, 0x01d2),
        (digr \U, \<, 0x01d3),
        (digr \u, \<, 0x01d4),
        (digr \A, \1, 0x01de),
        (digr \a, \1, 0x01df),
        (digr \A, \7, 0x01e0),
        (digr \a, \7, 0x01e1),
        (digr \A, \3, 0x01e2),
        (digr \a, \3, 0x01e3),
        (digr \G, \/, 0x01e4),
        (digr \g, \/, 0x01e5),
        (digr \G, \<, 0x01e6),
        (digr \g, \<, 0x01e7),
        (digr \K, \<, 0x01e8),
        (digr \k, \<, 0x01e9),
        (digr \O, \;, 0x01ea),
        (digr \o, \;, 0x01eb),
        (digr \O, \1, 0x01ec),
        (digr \o, \1, 0x01ed),
        (digr \E, \Z, 0x01ee),
        (digr \e, \z, 0x01ef),
        (digr \j, \<, 0x01f0),
        (digr \G, \', 0x01f4),
        (digr \g, \', 0x01f5),
        (digr \;, \S, 0x02bf),
        (digr \', \<, 0x02c7),
        (digr \', \(, 0x02d8),
        (digr \', \., 0x02d9),
        (digr \', \0, 0x02da),
        (digr \', \;, 0x02db),
        (digr \', \", 0x02dd),  ;; """
        (digr \A, \%, 0x0386),
        (digr \E, \%, 0x0388),
        (digr \Y, \%, 0x0389),
        (digr \I, \%, 0x038a),
        (digr \O, \%, 0x038c),
        (digr \U, \%, 0x038e),
        (digr \W, \%, 0x038f),
        (digr \i, \3, 0x0390),
        (digr \A, \*, 0x0391),
        (digr \B, \*, 0x0392),
        (digr \G, \*, 0x0393),
        (digr \D, \*, 0x0394),
        (digr \E, \*, 0x0395),
        (digr \Z, \*, 0x0396),
        (digr \Y, \*, 0x0397),
        (digr \H, \*, 0x0398),
        (digr \I, \*, 0x0399),
        (digr \K, \*, 0x039a),
        (digr \L, \*, 0x039b),
        (digr \M, \*, 0x039c),
        (digr \N, \*, 0x039d),
        (digr \C, \*, 0x039e),
        (digr \O, \*, 0x039f),
        (digr \P, \*, 0x03a0),
        (digr \R, \*, 0x03a1),
        (digr \S, \*, 0x03a3),
        (digr \T, \*, 0x03a4),
        (digr \U, \*, 0x03a5),
        (digr \F, \*, 0x03a6),
        (digr \X, \*, 0x03a7),
        (digr \Q, \*, 0x03a8),
        (digr \W, \*, 0x03a9),
        (digr \J, \*, 0x03aa),
        (digr \V, \*, 0x03ab),
        (digr \a, \%, 0x03ac),
        (digr \e, \%, 0x03ad),
        (digr \y, \%, 0x03ae),
        (digr \i, \%, 0x03af),
        (digr \u, \3, 0x03b0),
        (digr \a, \*, 0x03b1),
        (digr \b, \*, 0x03b2),
        (digr \g, \*, 0x03b3),
        (digr \d, \*, 0x03b4),
        (digr \e, \*, 0x03b5),
        (digr \z, \*, 0x03b6),
        (digr \y, \*, 0x03b7),
        (digr \h, \*, 0x03b8),
        (digr \i, \*, 0x03b9),
        (digr \k, \*, 0x03ba),
        (digr \l, \*, 0x03bb),
        (digr \m, \*, 0x03bc),
        (digr \n, \*, 0x03bd),
        (digr \c, \*, 0x03be),
        (digr \o, \*, 0x03bf),
        (digr \p, \*, 0x03c0),
        (digr \r, \*, 0x03c1),
        (digr \*, \s, 0x03c2),
        (digr \s, \*, 0x03c3),
        (digr \t, \*, 0x03c4),
        (digr \u, \*, 0x03c5),
        (digr \f, \*, 0x03c6),
        (digr \x, \*, 0x03c7),
        (digr \q, \*, 0x03c8),
        (digr \w, \*, 0x03c9),
        (digr \j, \*, 0x03ca),
        (digr \v, \*, 0x03cb),
        (digr \o, \%, 0x03cc),
        (digr \u, \%, 0x03cd),
        (digr \w, \%, 0x03ce),
        (digr \', \G, 0x03d8),
        (digr \,, \G, 0x03d9),
        (digr \T, \3, 0x03da),
        (digr \t, \3, 0x03db),
        (digr \M, \3, 0x03dc),
        (digr \m, \3, 0x03dd),
        (digr \K, \3, 0x03de),
        (digr \k, \3, 0x03df),
        (digr \P, \3, 0x03e0),
        (digr \p, \3, 0x03e1),
        (digr \', \%, 0x03f4),
        (digr \j, \3, 0x03f5),
        (digr \I, \O, 0x0401),
        (digr \D, \%, 0x0402),
        (digr \G, \%, 0x0403),
        (digr \I, \E, 0x0404),
        (digr \D, \S, 0x0405),
        (digr \I, \I, 0x0406),
        (digr \Y, \I, 0x0407),
        (digr \J, \%, 0x0408),
        (digr \L, \J, 0x0409),
        (digr \N, \J, 0x040a),
        (digr \T, \s, 0x040b),
        (digr \K, \J, 0x040c),
        (digr \V, \%, 0x040e),
        (digr \D, \Z, 0x040f),
        (digr \A, \=, 0x0410),
        (digr \B, \=, 0x0411),
        (digr \V, \=, 0x0412),
        (digr \G, \=, 0x0413),
        (digr \D, \=, 0x0414),
        (digr \E, \=, 0x0415),
        (digr \Z, \%, 0x0416),
        (digr \Z, \=, 0x0417),
        (digr \I, \=, 0x0418),
        (digr \J, \=, 0x0419),
        (digr \K, \=, 0x041a),
        (digr \L, \=, 0x041b),
        (digr \M, \=, 0x041c),
        (digr \N, \=, 0x041d),
        (digr \O, \=, 0x041e),
        (digr \P, \=, 0x041f),
        (digr \R, \=, 0x0420),
        (digr \S, \=, 0x0421),
        (digr \T, \=, 0x0422),
        (digr \U, \=, 0x0423),
        (digr \F, \=, 0x0424),
        (digr \H, \=, 0x0425),
        (digr \C, \=, 0x0426),
        (digr \C, \%, 0x0427),
        (digr \S, \%, 0x0428),
        (digr \S, \c, 0x0429),
        (digr \=, \", 0x042a),  ;; """
        (digr \Y, \=, 0x042b),
        (digr \%, \", 0x042c),  ;; """
        (digr \J, \E, 0x042d),
        (digr \J, \U, 0x042e),
        (digr \J, \A, 0x042f),
        (digr \a, \=, 0x0430),
        (digr \b, \=, 0x0431),
        (digr \v, \=, 0x0432),
        (digr \g, \=, 0x0433),
        (digr \d, \=, 0x0434),
        (digr \e, \=, 0x0435),
        (digr \z, \%, 0x0436),
        (digr \z, \=, 0x0437),
        (digr \i, \=, 0x0438),
        (digr \j, \=, 0x0439),
        (digr \k, \=, 0x043a),
        (digr \l, \=, 0x043b),
        (digr \m, \=, 0x043c),
        (digr \n, \=, 0x043d),
        (digr \o, \=, 0x043e),
        (digr \p, \=, 0x043f),
        (digr \r, \=, 0x0440),
        (digr \s, \=, 0x0441),
        (digr \t, \=, 0x0442),
        (digr \u, \=, 0x0443),
        (digr \f, \=, 0x0444),
        (digr \h, \=, 0x0445),
        (digr \c, \=, 0x0446),
        (digr \c, \%, 0x0447),
        (digr \s, \%, 0x0448),
        (digr \s, \c, 0x0449),
        (digr \=, \', 0x044a),
        (digr \y, \=, 0x044b),
        (digr \%, \', 0x044c),
        (digr \j, \e, 0x044d),
        (digr \j, \u, 0x044e),
        (digr \j, \a, 0x044f),
        (digr \i, \o, 0x0451),
        (digr \d, \%, 0x0452),
        (digr \g, \%, 0x0453),
        (digr \i, \e, 0x0454),
        (digr \d, \s, 0x0455),
        (digr \i, \i, 0x0456),
        (digr \y, \i, 0x0457),
        (digr \j, \%, 0x0458),
        (digr \l, \j, 0x0459),
        (digr \n, \j, 0x045a),
        (digr \t, \s, 0x045b),
        (digr \k, \j, 0x045c),
        (digr \v, \%, 0x045e),
        (digr \d, \z, 0x045f),
        (digr \Y, \3, 0x0462),
        (digr \y, \3, 0x0463),
        (digr \O, \3, 0x046a),
        (digr \o, \3, 0x046b),
        (digr \F, \3, 0x0472),
        (digr \f, \3, 0x0473),
        (digr \V, \3, 0x0474),
        (digr \v, \3, 0x0475),
        (digr \C, \3, 0x0480),
        (digr \c, \3, 0x0481),
        (digr \G, \3, 0x0490),
        (digr \g, \3, 0x0491),
        (digr \A, \+, 0x05d0),
        (digr \B, \+, 0x05d1),
        (digr \G, \+, 0x05d2),
        (digr \D, \+, 0x05d3),
        (digr \H, \+, 0x05d4),
        (digr \W, \+, 0x05d5),
        (digr \Z, \+, 0x05d6),
        (digr \X, \+, 0x05d7),
        (digr \T, \j, 0x05d8),
        (digr \J, \+, 0x05d9),
        (digr \K, \%, 0x05da),
        (digr \K, \+, 0x05db),
        (digr \L, \+, 0x05dc),
        (digr \M, \%, 0x05dd),
        (digr \M, \+, 0x05de),
        (digr \N, \%, 0x05df),
        (digr \N, \+, 0x05e0),
        (digr \S, \+, 0x05e1),
        (digr \E, \+, 0x05e2),
        (digr \P, \%, 0x05e3),
        (digr \P, \+, 0x05e4),
        (digr \Z, \j, 0x05e5),
        (digr \Z, \J, 0x05e6),
        (digr \Q, \+, 0x05e7),
        (digr \R, \+, 0x05e8),
        (digr \S, \h, 0x05e9),
        (digr \T, \+, 0x05ea),
        (digr \,, \+, 0x060c),
        (digr \;, \+, 0x061b),
        (digr \?, \+, 0x061f),
        (digr \H, \', 0x0621),
        (digr \a, \M, 0x0622),
        (digr \a, \H, 0x0623),
        (digr \w, \H, 0x0624),
        (digr \a, \h, 0x0625),
        (digr \y, \H, 0x0626),
        (digr \a, \+, 0x0627),
        (digr \b, \+, 0x0628),
        (digr \t, \m, 0x0629),
        (digr \t, \+, 0x062a),
        (digr \t, \k, 0x062b),
        (digr \g, \+, 0x062c),
        (digr \h, \k, 0x062d),
        (digr \x, \+, 0x062e),
        (digr \d, \+, 0x062f),
        (digr \d, \k, 0x0630),
        (digr \r, \+, 0x0631),
        (digr \z, \+, 0x0632),
        (digr \s, \+, 0x0633),
        (digr \s, \n, 0x0634),
        (digr \c, \+, 0x0635),
        (digr \d, \d, 0x0636),
        (digr \t, \j, 0x0637),
        (digr \z, \H, 0x0638),
        (digr \e, \+, 0x0639),
        (digr \i, \+, 0x063a),
        (digr \+, \+, 0x0640),
        (digr \f, \+, 0x0641),
        (digr \q, \+, 0x0642),
        (digr \k, \+, 0x0643),
        (digr \l, \+, 0x0644),
        (digr \m, \+, 0x0645),
        (digr \n, \+, 0x0646),
        (digr \h, \+, 0x0647),
        (digr \w, \+, 0x0648),
        (digr \j, \+, 0x0649),
        (digr \y, \+, 0x064a),
        (digr \:, \+, 0x064b),
        (digr \", \+, 0x064c),  ;; """
        (digr \=, \+, 0x064d),
        (digr \/, \+, 0x064e),
        (digr \', \+, 0x064f),
        (digr \1, \+, 0x0650),
        (digr \3, \+, 0x0651),
        (digr \0, \+, 0x0652),
        (digr \a, \S, 0x0670),
        (digr \p, \+, 0x067e),
        (digr \v, \+, 0x06a4),
        (digr \g, \f, 0x06af),
        (digr \0, \a, 0x06f0),
        (digr \1, \a, 0x06f1),
        (digr \2, \a, 0x06f2),
        (digr \3, \a, 0x06f3),
        (digr \4, \a, 0x06f4),
        (digr \5, \a, 0x06f5),
        (digr \6, \a, 0x06f6),
        (digr \7, \a, 0x06f7),
        (digr \8, \a, 0x06f8),
        (digr \9, \a, 0x06f9),
        (digr \B, \., 0x1e02),
        (digr \b, \., 0x1e03),
        (digr \B, \_, 0x1e06),
        (digr \b, \_, 0x1e07),
        (digr \D, \., 0x1e0a),
        (digr \d, \., 0x1e0b),
        (digr \D, \_, 0x1e0e),
        (digr \d, \_, 0x1e0f),
        (digr \D, \,, 0x1e10),
        (digr \d, \,, 0x1e11),
        (digr \F, \., 0x1e1e),
        (digr \f, \., 0x1e1f),
        (digr \G, \-, 0x1e20),
        (digr \g, \-, 0x1e21),
        (digr \H, \., 0x1e22),
        (digr \h, \., 0x1e23),
        (digr \H, \:, 0x1e26),
        (digr \h, \:, 0x1e27),
        (digr \H, \,, 0x1e28),
        (digr \h, \,, 0x1e29),
        (digr \K, \', 0x1e30),
        (digr \k, \', 0x1e31),
        (digr \K, \_, 0x1e34),
        (digr \k, \_, 0x1e35),
        (digr \L, \_, 0x1e3a),
        (digr \l, \_, 0x1e3b),
        (digr \M, \', 0x1e3e),
        (digr \m, \', 0x1e3f),
        (digr \M, \., 0x1e40),
        (digr \m, \., 0x1e41),
        (digr \N, \., 0x1e44),
        (digr \n, \., 0x1e45),
        (digr \N, \_, 0x1e48),
        (digr \n, \_, 0x1e49),
        (digr \P, \', 0x1e54),
        (digr \p, \', 0x1e55),
        (digr \P, \., 0x1e56),
        (digr \p, \., 0x1e57),
        (digr \R, \., 0x1e58),
        (digr \r, \., 0x1e59),
        (digr \R, \_, 0x1e5e),
        (digr \r, \_, 0x1e5f),
        (digr \S, \., 0x1e60),
        (digr \s, \., 0x1e61),
        (digr \T, \., 0x1e6a),
        (digr \t, \., 0x1e6b),
        (digr \T, \_, 0x1e6e),
        (digr \t, \_, 0x1e6f),
        (digr \V, \?, 0x1e7c),
        (digr \v, \?, 0x1e7d),
        (digr \W, \!, 0x1e80),
        (digr \w, \!, 0x1e81),
        (digr \W, \', 0x1e82),
        (digr \w, \', 0x1e83),
        (digr \W, \:, 0x1e84),
        (digr \w, \:, 0x1e85),
        (digr \W, \., 0x1e86),
        (digr \w, \., 0x1e87),
        (digr \X, \., 0x1e8a),
        (digr \x, \., 0x1e8b),
        (digr \X, \:, 0x1e8c),
        (digr \x, \:, 0x1e8d),
        (digr \Y, \., 0x1e8e),
        (digr \y, \., 0x1e8f),
        (digr \Z, \>, 0x1e90),
        (digr \z, \>, 0x1e91),
        (digr \Z, \_, 0x1e94),
        (digr \z, \_, 0x1e95),
        (digr \h, \_, 0x1e96),
        (digr \t, \:, 0x1e97),
        (digr \w, \0, 0x1e98),
        (digr \y, \0, 0x1e99),
        (digr \A, \2, 0x1ea2),
        (digr \a, \2, 0x1ea3),
        (digr \E, \2, 0x1eba),
        (digr \e, \2, 0x1ebb),
        (digr \E, \?, 0x1ebc),
        (digr \e, \?, 0x1ebd),
        (digr \I, \2, 0x1ec8),
        (digr \i, \2, 0x1ec9),
        (digr \O, \2, 0x1ece),
        (digr \o, \2, 0x1ecf),
        (digr \U, \2, 0x1ee6),
        (digr \u, \2, 0x1ee7),
        (digr \Y, \!, 0x1ef2),
        (digr \y, \!, 0x1ef3),
        (digr \Y, \2, 0x1ef6),
        (digr \y, \2, 0x1ef7),
        (digr \Y, \?, 0x1ef8),
        (digr \y, \?, 0x1ef9),
        (digr \;, \', 0x1f00),
        (digr \,, \', 0x1f01),
        (digr \;, \!, 0x1f02),
        (digr \,, \!, 0x1f03),
        (digr \?, \;, 0x1f04),
        (digr \?, \,, 0x1f05),
        (digr \!, \:, 0x1f06),
        (digr \?, \:, 0x1f07),
        (digr \1, \N, 0x2002),
        (digr \1, \M, 0x2003),
        (digr \3, \M, 0x2004),
        (digr \4, \M, 0x2005),
        (digr \6, \M, 0x2006),
        (digr \1, \T, 0x2009),
        (digr \1, \H, 0x200a),
        (digr \-, \1, 0x2010),
        (digr \-, \N, 0x2013),
        (digr \-, \M, 0x2014),
        (digr \-, \3, 0x2015),
        (digr \!, \2, 0x2016),
        (digr \=, \2, 0x2017),
        (digr \', \6, 0x2018),
        (digr \', \9, 0x2019),
        (digr \., \9, 0x201a),
        (digr \9, \', 0x201b),
        (digr \", \6, 0x201c),  ;; """
        (digr \", \9, 0x201d),  ;; """
        (digr \:, \9, 0x201e),
        (digr \9, \", 0x201f),  ;; """
        (digr \/, \-, 0x2020),
        (digr \/, \=, 0x2021),
        (digr \., \., 0x2025),
        (digr \%, \0, 0x2030),
        (digr \1, \', 0x2032),
        (digr \2, \', 0x2033),
        (digr \3, \', 0x2034),
        (digr \1, \", 0x2035),  ;; """
        (digr \2, \", 0x2036),  ;; """
        (digr \3, \", 0x2037),  ;; """
        (digr \C, \a, 0x2038),
        (digr \<, \1, 0x2039),
        (digr \>, \1, 0x203a),
        (digr \:, \X, 0x203b),
        (digr \', \-, 0x203e),
        (digr \/, \f, 0x2044),
        (digr \0, \S, 0x2070),
        (digr \4, \S, 0x2074),
        (digr \5, \S, 0x2075),
        (digr \6, \S, 0x2076),
        (digr \7, \S, 0x2077),
        (digr \8, \S, 0x2078),
        (digr \9, \S, 0x2079),
        (digr \+, \S, 0x207a),
        (digr \-, \S, 0x207b),
        (digr \=, \S, 0x207c),
        (digr \(, \S, 0x207d),
        (digr \), \S, 0x207e),
        (digr \n, \S, 0x207f),
        (digr \0, \s, 0x2080),
        (digr \1, \s, 0x2081),
        (digr \2, \s, 0x2082),
        (digr \3, \s, 0x2083),
        (digr \4, \s, 0x2084),
        (digr \5, \s, 0x2085),
        (digr \6, \s, 0x2086),
        (digr \7, \s, 0x2087),
        (digr \8, \s, 0x2088),
        (digr \9, \s, 0x2089),
        (digr \+, \s, 0x208a),
        (digr \-, \s, 0x208b),
        (digr \=, \s, 0x208c),
        (digr \(, \s, 0x208d),
        (digr \), \s, 0x208e),
        (digr \L, \i, 0x20a4),
        (digr \P, \t, 0x20a7),
        (digr \W, \=, 0x20a9),
        (digr \=, \e, 0x20ac), ;; euro
        (digr \E, \u, 0x20ac), ;; euro
        (digr \=, \R, 0x20bd), ;; rouble
        (digr \=, \P, 0x20bd), ;; rouble
        (digr \o, \C, 0x2103),
        (digr \c, \o, 0x2105),
        (digr \o, \F, 0x2109),
        (digr \N, \0, 0x2116),
        (digr \P, \O, 0x2117),
        (digr \R, \x, 0x211e),
        (digr \S, \M, 0x2120),
        (digr \T, \M, 0x2122),
        (digr \O, \m, 0x2126),
        (digr \A, \O, 0x212b),
        (digr \1, \3, 0x2153),
        (digr \2, \3, 0x2154),
        (digr \1, \5, 0x2155),
        (digr \2, \5, 0x2156),
        (digr \3, \5, 0x2157),
        (digr \4, \5, 0x2158),
        (digr \1, \6, 0x2159),
        (digr \5, \6, 0x215a),
        (digr \1, \8, 0x215b),
        (digr \3, \8, 0x215c),
        (digr \5, \8, 0x215d),
        (digr \7, \8, 0x215e),
        (digr \1, \R, 0x2160),
        (digr \2, \R, 0x2161),
        (digr \3, \R, 0x2162),
        (digr \4, \R, 0x2163),
        (digr \5, \R, 0x2164),
        (digr \6, \R, 0x2165),
        (digr \7, \R, 0x2166),
        (digr \8, \R, 0x2167),
        (digr \9, \R, 0x2168),
        (digr \a, \R, 0x2169),
        (digr \b, \R, 0x216a),
        (digr \c, \R, 0x216b),
        (digr \1, \r, 0x2170),
        (digr \2, \r, 0x2171),
        (digr \3, \r, 0x2172),
        (digr \4, \r, 0x2173),
        (digr \5, \r, 0x2174),
        (digr \6, \r, 0x2175),
        (digr \7, \r, 0x2176),
        (digr \8, \r, 0x2177),
        (digr \9, \r, 0x2178),
        (digr \a, \r, 0x2179),
        (digr \b, \r, 0x217a),
        (digr \c, \r, 0x217b),
        (digr \<, \-, 0x2190),
        (digr \-, \!, 0x2191),
        (digr \-, \>, 0x2192),
        (digr \-, \v, 0x2193),
        (digr \<, \>, 0x2194),
        (digr \U, \D, 0x2195),
        (digr \<, \=, 0x21d0),
        (digr \=, \>, 0x21d2),
        (digr \=, \=, 0x21d4),
        (digr \F, \A, 0x2200),
        (digr \d, \P, 0x2202),
        (digr \T, \E, 0x2203),
        (digr \/, \0, 0x2205),
        (digr \D, \E, 0x2206),
        (digr \N, \B, 0x2207),
        (digr \(, \-, 0x2208),
        (digr \-, \), 0x220b),
        (digr \*, \P, 0x220f),
        (digr \+, \Z, 0x2211),
        (digr \-, \2, 0x2212),
        (digr \-, \+, 0x2213),
        (digr \*, \-, 0x2217),
        (digr \O, \b, 0x2218),
        (digr \S, \b, 0x2219),
        (digr \R, \T, 0x221a),
        (digr \0, \(, 0x221d),
        (digr \0, \0, 0x221e),
        (digr \-, \L, 0x221f),
        (digr \-, \V, 0x2220),
        (digr \P, \P, 0x2225),
        (digr \A, \N, 0x2227),
        (digr \O, \R, 0x2228),
        (digr \(, \U, 0x2229),
        (digr \), \U, 0x222a),
        (digr \I, \n, 0x222b),
        (digr \D, \I, 0x222c),
        (digr \I, \o, 0x222e),
        (digr \., \:, 0x2234),
        (digr \:, \., 0x2235),
        (digr \:, \R, 0x2236),
        (digr \:, \:, 0x2237),
        (digr \?, \1, 0x223c),
        (digr \C, \G, 0x223e),
        (digr \?, \-, 0x2243),
        (digr \?, \=, 0x2245),
        (digr \?, \2, 0x2248),
        (digr \=, \?, 0x224c),
        (digr \H, \I, 0x2253),
        (digr \!, \=, 0x2260),
        (digr \=, \3, 0x2261),
        (digr \=, \<, 0x2264),
        (digr \>, \=, 0x2265),
        (digr \<, \*, 0x226a),
        (digr \*, \>, 0x226b),
        (digr \!, \<, 0x226e),
        (digr \!, \>, 0x226f),
        (digr \(, \C, 0x2282),
        (digr \), \C, 0x2283),
        (digr \(, \_, 0x2286),
        (digr \), \_, 0x2287),
        (digr \0, \., 0x2299),
        (digr \0, \2, 0x229a),
        (digr \-, \T, 0x22a5),
        (digr \., \P, 0x22c5),
        (digr \:, \3, 0x22ee),
        (digr \., \3, 0x22ef),
        (digr \E, \h, 0x2302),
        (digr \<, \7, 0x2308),
        (digr \>, \7, 0x2309),
        (digr \7, \<, 0x230a),
        (digr \7, \>, 0x230b),
        (digr \N, \I, 0x2310),
        (digr \(, \A, 0x2312),
        (digr \T, \R, 0x2315),
        (digr \I, \u, 0x2320),
        (digr \I, \l, 0x2321),
        (digr \<, \/, 0x2329),
        (digr \/, \>, 0x232a),
        (digr \V, \s, 0x2423),
        (digr \1, \h, 0x2440),
        (digr \3, \h, 0x2441),
        (digr \2, \h, 0x2442),
        (digr \4, \h, 0x2443),
        (digr \1, \j, 0x2446),
        (digr \2, \j, 0x2447),
        (digr \3, \j, 0x2448),
        (digr \4, \j, 0x2449),
        (digr \1, \., 0x2488),
        (digr \2, \., 0x2489),
        (digr \3, \., 0x248a),
        (digr \4, \., 0x248b),
        (digr \5, \., 0x248c),
        (digr \6, \., 0x248d),
        (digr \7, \., 0x248e),
        (digr \8, \., 0x248f),
        (digr \9, \., 0x2490),
        (digr \h, \h, 0x2500),
        (digr \H, \H, 0x2501),
        (digr \v, \v, 0x2502),
        (digr \V, \V, 0x2503),
        (digr \3, \-, 0x2504),
        (digr \3, \_, 0x2505),
        (digr \3, \!, 0x2506),
        (digr \3, \/, 0x2507),
        (digr \4, \-, 0x2508),
        (digr \4, \_, 0x2509),
        (digr \4, \!, 0x250a),
        (digr \4, \/, 0x250b),
        (digr \d, \r, 0x250c),
        (digr \d, \R, 0x250d),
        (digr \D, \r, 0x250e),
        (digr \D, \R, 0x250f),
        (digr \d, \l, 0x2510),
        (digr \d, \L, 0x2511),
        (digr \D, \l, 0x2512),
        (digr \L, \D, 0x2513),
        (digr \u, \r, 0x2514),
        (digr \u, \R, 0x2515),
        (digr \U, \r, 0x2516),
        (digr \U, \R, 0x2517),
        (digr \u, \l, 0x2518),
        (digr \u, \L, 0x2519),
        (digr \U, \l, 0x251a),
        (digr \U, \L, 0x251b),
        (digr \v, \r, 0x251c),
        (digr \v, \R, 0x251d),
        (digr \V, \r, 0x2520),
        (digr \V, \R, 0x2523),
        (digr \v, \l, 0x2524),
        (digr \v, \L, 0x2525),
        (digr \V, \l, 0x2528),
        (digr \V, \L, 0x252b),
        (digr \d, \h, 0x252c),
        (digr \d, \H, 0x252f),
        (digr \D, \h, 0x2530),
        (digr \D, \H, 0x2533),
        (digr \u, \h, 0x2534),
        (digr \u, \H, 0x2537),
        (digr \U, \h, 0x2538),
        (digr \U, \H, 0x253b),
        (digr \v, \h, 0x253c),
        (digr \v, \H, 0x253f),
        (digr \V, \h, 0x2542),
        (digr \V, \H, 0x254b),
        (digr \F, \D, 0x2571),
        (digr \B, \D, 0x2572),
        (digr \T, \B, 0x2580),
        (digr \L, \B, 0x2584),
        (digr \F, \B, 0x2588),
        (digr \l, \B, 0x258c),
        (digr \R, \B, 0x2590),
        (digr \., \S, 0x2591),
        (digr \:, \S, 0x2592),
        (digr \?, \S, 0x2593),
        (digr \f, \S, 0x25a0),
        (digr \O, \S, 0x25a1),
        (digr \R, \O, 0x25a2),
        (digr \R, \r, 0x25a3),
        (digr \R, \F, 0x25a4),
        (digr \R, \Y, 0x25a5),
        (digr \R, \H, 0x25a6),
        (digr \R, \Z, 0x25a7),
        (digr \R, \K, 0x25a8),
        (digr \R, \X, 0x25a9),
        (digr \s, \B, 0x25aa),
        (digr \S, \R, 0x25ac),
        (digr \O, \r, 0x25ad),
        (digr \U, \T, 0x25b2),
        (digr \u, \T, 0x25b3),
        (digr \P, \R, 0x25b6),
        (digr \T, \r, 0x25b7),
        (digr \D, \t, 0x25bc),
        (digr \d, \T, 0x25bd),
        (digr \P, \L, 0x25c0),
        (digr \T, \l, 0x25c1),
        (digr \D, \b, 0x25c6),
        (digr \D, \w, 0x25c7),
        (digr \L, \Z, 0x25ca),
        (digr \0, \m, 0x25cb),
        (digr \0, \o, 0x25ce),
        (digr \0, \M, 0x25cf),
        (digr \0, \L, 0x25d0),
        (digr \0, \R, 0x25d1),
        (digr \S, \n, 0x25d8),
        (digr \I, \c, 0x25d9),
        (digr \F, \d, 0x25e2),
        (digr \B, \d, 0x25e3),
        (digr \*, \2, 0x2605),
        (digr \*, \1, 0x2606),
        (digr \<, \H, 0x261c),
        (digr \>, \H, 0x261e),
        (digr \0, \u, 0x263a),
        (digr \0, \U, 0x263b),
        (digr \S, \U, 0x263c),
        (digr \F, \m, 0x2640),
        (digr \M, \l, 0x2642),
        (digr \c, \S, 0x2660),
        (digr \c, \H, 0x2661),
        (digr \c, \D, 0x2662),
        (digr \c, \C, 0x2663),
        (digr \M, \d, 0x2669),
        (digr \M, \8, 0x266a),
        (digr \M, \2, 0x266b),
        (digr \M, \b, 0x266d),
        (digr \M, \x, 0x266e),
        (digr \M, \X, 0x266f),
        (digr \O, \K, 0x2713),
        (digr \X, \X, 0x2717),
        (digr \-, \X, 0x2720),
        (digr \I, \S, 0x3000),
        (digr \,, \_, 0x3001),
        (digr \., \_, 0x3002),
        (digr \+, \", 0x3003),  ;; """
        (digr \+, \_, 0x3004),
        (digr \*, \_, 0x3005),
        (digr \;, \_, 0x3006),
        (digr \0, \_, 0x3007),
        (digr \<, \+, 0x300a),
        (digr \>, \+, 0x300b),
        (digr \<, \', 0x300c),
        (digr \>, \', 0x300d),
        (digr \<, \", 0x300e),  ;; """
        (digr \>, \", 0x300f),  ;; """
        (digr \(, \", 0x3010),  ;; """
        (digr \), \", 0x3011),  ;; """
        (digr \=, \T, 0x3012),
        (digr \=, \_, 0x3013),
        (digr \(, \', 0x3014),
        (digr \), \', 0x3015),
        (digr \(, \I, 0x3016),
        (digr \), \I, 0x3017),
        (digr \-, \?, 0x301c),
        (digr \A, \5, 0x3041),
        (digr \a, \5, 0x3042),
        (digr \I, \5, 0x3043),
        (digr \i, \5, 0x3044),
        (digr \U, \5, 0x3045),
        (digr \u, \5, 0x3046),
        (digr \E, \5, 0x3047),
        (digr \e, \5, 0x3048),
        (digr \O, \5, 0x3049),
        (digr \o, \5, 0x304a),
        (digr \k, \a, 0x304b),
        (digr \g, \a, 0x304c),
        (digr \k, \i, 0x304d),
        (digr \g, \i, 0x304e),
        (digr \k, \u, 0x304f),
        (digr \g, \u, 0x3050),
        (digr \k, \e, 0x3051),
        (digr \g, \e, 0x3052),
        (digr \k, \o, 0x3053),
        (digr \g, \o, 0x3054),
        (digr \s, \a, 0x3055),
        (digr \z, \a, 0x3056),
        (digr \s, \i, 0x3057),
        (digr \z, \i, 0x3058),
        (digr \s, \u, 0x3059),
        (digr \z, \u, 0x305a),
        (digr \s, \e, 0x305b),
        (digr \z, \e, 0x305c),
        (digr \s, \o, 0x305d),
        (digr \z, \o, 0x305e),
        (digr \t, \a, 0x305f),
        (digr \d, \a, 0x3060),
        (digr \t, \i, 0x3061),
        (digr \d, \i, 0x3062),
        (digr \t, \U, 0x3063),
        (digr \t, \u, 0x3064),
        (digr \d, \u, 0x3065),
        (digr \t, \e, 0x3066),
        (digr \d, \e, 0x3067),
        (digr \t, \o, 0x3068),
        (digr \d, \o, 0x3069),
        (digr \n, \a, 0x306a),
        (digr \n, \i, 0x306b),
        (digr \n, \u, 0x306c),
        (digr \n, \e, 0x306d),
        (digr \n, \o, 0x306e),
        (digr \h, \a, 0x306f),
        (digr \b, \a, 0x3070),
        (digr \p, \a, 0x3071),
        (digr \h, \i, 0x3072),
        (digr \b, \i, 0x3073),
        (digr \p, \i, 0x3074),
        (digr \h, \u, 0x3075),
        (digr \b, \u, 0x3076),
        (digr \p, \u, 0x3077),
        (digr \h, \e, 0x3078),
        (digr \b, \e, 0x3079),
        (digr \p, \e, 0x307a),
        (digr \h, \o, 0x307b),
        (digr \b, \o, 0x307c),
        (digr \p, \o, 0x307d),
        (digr \m, \a, 0x307e),
        (digr \m, \i, 0x307f),
        (digr \m, \u, 0x3080),
        (digr \m, \e, 0x3081),
        (digr \m, \o, 0x3082),
        (digr \y, \A, 0x3083),
        (digr \y, \a, 0x3084),
        (digr \y, \U, 0x3085),
        (digr \y, \u, 0x3086),
        (digr \y, \O, 0x3087),
        (digr \y, \o, 0x3088),
        (digr \r, \a, 0x3089),
        (digr \r, \i, 0x308a),
        (digr \r, \u, 0x308b),
        (digr \r, \e, 0x308c),
        (digr \r, \o, 0x308d),
        (digr \w, \A, 0x308e),
        (digr \w, \a, 0x308f),
        (digr \w, \i, 0x3090),
        (digr \w, \e, 0x3091),
        (digr \w, \o, 0x3092),
        (digr \n, \5, 0x3093),
        (digr \v, \u, 0x3094),
        (digr \", \5, 0x309b),  ;; """
        (digr \0, \5, 0x309c),
        (digr \*, \5, 0x309d),
        (digr \+, \5, 0x309e),
        (digr \a, \6, 0x30a1),
        (digr \A, \6, 0x30a2),
        (digr \i, \6, 0x30a3),
        (digr \I, \6, 0x30a4),
        (digr \u, \6, 0x30a5),
        (digr \U, \6, 0x30a6),
        (digr \e, \6, 0x30a7),
        (digr \E, \6, 0x30a8),
        (digr \o, \6, 0x30a9),
        (digr \O, \6, 0x30aa),
        (digr \K, \a, 0x30ab),
        (digr \G, \a, 0x30ac),
        (digr \K, \i, 0x30ad),
        (digr \G, \i, 0x30ae),
        (digr \K, \u, 0x30af),
        (digr \G, \u, 0x30b0),
        (digr \K, \e, 0x30b1),
        (digr \G, \e, 0x30b2),
        (digr \K, \o, 0x30b3),
        (digr \G, \o, 0x30b4),
        (digr \S, \a, 0x30b5),
        (digr \Z, \a, 0x30b6),
        (digr \S, \i, 0x30b7),
        (digr \Z, \i, 0x30b8),
        (digr \S, \u, 0x30b9),
        (digr \Z, \u, 0x30ba),
        (digr \S, \e, 0x30bb),
        (digr \Z, \e, 0x30bc),
        (digr \S, \o, 0x30bd),
        (digr \Z, \o, 0x30be),
        (digr \T, \a, 0x30bf),
        (digr \D, \a, 0x30c0),
        (digr \T, \i, 0x30c1),
        (digr \D, \i, 0x30c2),
        (digr \T, \U, 0x30c3),
        (digr \T, \u, 0x30c4),
        (digr \D, \u, 0x30c5),
        (digr \T, \e, 0x30c6),
        (digr \D, \e, 0x30c7),
        (digr \T, \o, 0x30c8),
        (digr \D, \o, 0x30c9),
        (digr \N, \a, 0x30ca),
        (digr \N, \i, 0x30cb),
        (digr \N, \u, 0x30cc),
        (digr \N, \e, 0x30cd),
        (digr \N, \o, 0x30ce),
        (digr \H, \a, 0x30cf),
        (digr \B, \a, 0x30d0),
        (digr \P, \a, 0x30d1),
        (digr \H, \i, 0x30d2),
        (digr \B, \i, 0x30d3),
        (digr \P, \i, 0x30d4),
        (digr \H, \u, 0x30d5),
        (digr \B, \u, 0x30d6),
        (digr \P, \u, 0x30d7),
        (digr \H, \e, 0x30d8),
        (digr \B, \e, 0x30d9),
        (digr \P, \e, 0x30da),
        (digr \H, \o, 0x30db),
        (digr \B, \o, 0x30dc),
        (digr \P, \o, 0x30dd),
        (digr \M, \a, 0x30de),
        (digr \M, \i, 0x30df),
        (digr \M, \u, 0x30e0),
        (digr \M, \e, 0x30e1),
        (digr \M, \o, 0x30e2),
        (digr \Y, \A, 0x30e3),
        (digr \Y, \a, 0x30e4),
        (digr \Y, \U, 0x30e5),
        (digr \Y, \u, 0x30e6),
        (digr \Y, \O, 0x30e7),
        (digr \Y, \o, 0x30e8),
        (digr \R, \a, 0x30e9),
        (digr \R, \i, 0x30ea),
        (digr \R, \u, 0x30eb),
        (digr \R, \e, 0x30ec),
        (digr \R, \o, 0x30ed),
        (digr \W, \A, 0x30ee),
        (digr \W, \a, 0x30ef),
        (digr \W, \i, 0x30f0),
        (digr \W, \e, 0x30f1),
        (digr \W, \o, 0x30f2),
        (digr \N, \6, 0x30f3),
        (digr \V, \u, 0x30f4),
        (digr \K, \A, 0x30f5),
        (digr \K, \E, 0x30f6),
        (digr \V, \a, 0x30f7),
        (digr \V, \i, 0x30f8),
        (digr \V, \e, 0x30f9),
        (digr \V, \o, 0x30fa),
        (digr \., \6, 0x30fb),
        (digr \-, \6, 0x30fc),
        (digr \*, \6, 0x30fd),
        (digr \+, \6, 0x30fe),
        (digr \b, \4, 0x3105),
        (digr \p, \4, 0x3106),
        (digr \m, \4, 0x3107),
        (digr \f, \4, 0x3108),
        (digr \d, \4, 0x3109),
        (digr \t, \4, 0x310a),
        (digr \n, \4, 0x310b),
        (digr \l, \4, 0x310c),
        (digr \g, \4, 0x310d),
        (digr \k, \4, 0x310e),
        (digr \h, \4, 0x310f),
        (digr \j, \4, 0x3110),
        (digr \q, \4, 0x3111),
        (digr \x, \4, 0x3112),
        (digr \z, \h, 0x3113),
        (digr \c, \h, 0x3114),
        (digr \s, \h, 0x3115),
        (digr \r, \4, 0x3116),
        (digr \z, \4, 0x3117),
        (digr \c, \4, 0x3118),
        (digr \s, \4, 0x3119),
        (digr \a, \4, 0x311a),
        (digr \o, \4, 0x311b),
        (digr \e, \4, 0x311c),
        (digr \a, \i, 0x311e),
        (digr \e, \i, 0x311f),
        (digr \a, \u, 0x3120),
        (digr \o, \u, 0x3121),
        (digr \a, \n, 0x3122),
        (digr \e, \n, 0x3123),
        (digr \a, \N, 0x3124),
        (digr \e, \N, 0x3125),
        (digr \e, \r, 0x3126),
        (digr \i, \4, 0x3127),
        (digr \u, \4, 0x3128),
        (digr \i, \u, 0x3129),
        (digr \v, \4, 0x312a),
        (digr \n, \G, 0x312b),
        (digr \g, \n, 0x312c),
        (digr \1, \c, 0x3220),
        (digr \2, \c, 0x3221),
        (digr \3, \c, 0x3222),
        (digr \4, \c, 0x3223),
        (digr \5, \c, 0x3224),
        (digr \6, \c, 0x3225),
        (digr \7, \c, 0x3226),
        (digr \8, \c, 0x3227),
        (digr \9, \c, 0x3228),
        ;; Code points 0xe000 - 0xefff excluded;
        ;; they have no assigned characters, only used in proposals.
        (digr \f, \f, 0xfb00),
        (digr \f, \i, 0xfb01),
        (digr \f, \l, 0xfb02),
        (digr \f, \t, 0xfb05),
        (digr \s, \t, 0xfb06),

        ;; Vim 5.x compatible digraphs that don't conflict with the above.
        (digr \~, \!, 161),
        (digr \c, \|, 162),
        (digr \$, \$, 163),
        (digr \o, \x, 164),
        (digr \Y, \-, 165),
        (digr \|, \|, 166),
        (digr \c, \O, 169),
        (digr \-, \,, 172),
        (digr \-, \=, 175),
        (digr \~, \o, 176),
        (digr \2, \2, 178),
        (digr \3, \3, 179),
        (digr \p, \p, 182),
        (digr \~, \., 183),
        (digr \1, \1, 185),
        (digr \~, \?, 191),
        (digr \A, \`, 192),
        (digr \A, \^, 194),
        (digr \A, \~, 195),
        (digr \A, \", 196), ;; """
        (digr \A, \@, 197),
        (digr \E, \`, 200),
        (digr \E, \^, 202),
        (digr \E, \", 203), ;; """
        (digr \I, \`, 204),
        (digr \I, \^, 206),
        (digr \I, \", 207), ;; """
        (digr \N, \~, 209),
        (digr \O, \`, 210),
        (digr \O, \^, 212),
        (digr \O, \~, 213),
        (digr \/, \\, 215),
        (digr \U, \`, 217),
        (digr \U, \^, 219),
        (digr \I, \p, 222),
        (digr \a, \`, 224),
        (digr \a, \^, 226),
        (digr \a, \~, 227),
        (digr \a, \", 228), ;; """
        (digr \a, \@, 229),
        (digr \e, \`, 232),
        (digr \e, \^, 234),
        (digr \e, \", 235), ;; """
        (digr \i, \`, 236),
        (digr \i, \^, 238),
        (digr \n, \~, 241),
        (digr \o, \`, 242),
        (digr \o, \^, 244),
        (digr \o, \~, 245),
        (digr \u, \`, 249),
        (digr \u, \^, 251),
        (digr \y, \", 255)  ;; """
    ])

(atom! int backspaced)  ;; character before K_BS
(atom! int lastchar)    ;; last typed character

;; Handle digraphs after typing a character.

(defn- #_int do-digraph [#_int c]
    (let [c (cond (== c -1)
                (do (reset! backspaced -1) c)
            @p_dg
                (let [c (if (<= 0 @backspaced) (getdigraph @backspaced, c, false) c)]
                    (reset! backspaced -1)
                    (when (and (any == c K_BS Ctrl_H) (<= 0 @lastchar))
                        (reset! backspaced @lastchar))
                    c)
            :else c)]
        (reset! lastchar c)
    c))

;; Get a digraph.  Used after typing CTRL-K on the command line or in normal mode.
;; Returns composed character, or NUL when ESC was used.

(defn- #_[window_C int] get-digraph? [#_window_C win, #_boolean cmdline?]
    ;; cmdline?: true when called from the cmdline
    (let [_ (swap! no_mapping inc) _ (swap! allow_keys inc) [win c1] (plain-vgetc? win) _ (swap! no_mapping dec) _ (swap! allow_keys dec)]
        (cond (== c1 ESC)           ;; ESC cancels CTRL-K
            [win NUL]
        (is-special c1)             ;; insert special key code
            [win c1]
        :else
            (let [win (if cmdline?
                        (do (when (== (mb-char2cells c1) 1) (putcmdline c1, true)) win)
                        (add-to-showcmd win, c1)
                    )]
                (let [_ (swap! no_mapping inc) _ (swap! allow_keys inc) [win c2] (plain-vgetc? win) _ (swap! no_mapping dec) _ (swap! allow_keys dec)]
                    (if (== c2 ESC) ;; ESC cancels CTRL-K
                        [win NUL]
                        [win (getdigraph c1, c2, true)]
                    ))
            ))
    ))

;; Lookup the pair "char1", "char2" in the digraph tables.
;; If no match, return "char2".
;; If "meta?" is true and "char1" is a space, return "char2" | 0x80.

(defn- #_int getexactdigraph [#_int char1, #_int char2, #_boolean meta?]
    (if (or (is-special char1) (is-special char2))
        char2
        (let [n (count digraphdefault)
              x (loop-when [i 0] (< i n) => 0
                    (let [y (... digraphdefault i)] (if (and (== (int (:char1 y)) char1) (== (int (:char2 y)) char2)) (:result y) (recur (inc i))))
                )]
            ;; digraph deleted or not found ;; <space> <char> --> meta-char
            (if (zero? x) (if (and (== char1 (byte \space)) meta?) (| char2 0x80) char2) x))
    ))

;; Get digraph.
;; Allow for both char1-char2 and char2-char1

(defn- #_int getdigraph [#_int char1, #_int char2, #_boolean meta?]
    (let-when [x (getexactdigraph char1, char2, meta?)] (and (== x char2) (!= char1 char2)) => x
        (let-when [x (getexactdigraph char2, char1, meta?)] (== x char1) => x
            char2
        )))

;; mbyte.c: Code specifically for handling multi-byte characters.
;;
;; "enc_utf8"   Use Unicode characters in UTF-8 encoding.
;;              The cell width on the display needs to be determined from the character value.
;;              Recognizing bytes is easy: 0xxx.xxxx is a single-byte char, 10xx.xxxx is a
;;              trailing byte, 11xx.xxxx is a leading byte of a multi-byte character.
;;              To make things complicated, up to six composing characters are allowed.
;;              These are drawn on top of the first char.
;;              For most editing the sequence of bytes with composing
;;              characters included is considered to be one character.
;;
;; 'encoding' specifies the encoding used in the core.  This is in registers,
;; text manipulation, buffers, etc.  Conversion has to be done when characters
;; in another encoding are received or send:
;;
;;                     clipboard
;;                         ^
;;                         | (2)
;;                         V
;;                 +---------------+
;;            (1)  |               | (3)
;;  keyboard ----->|     core      |-----> display
;;                 |               |
;;                 +---------------+
;;                         ^
;;                         | (4)
;;                         V
;;                       file
;;
;; (1) Typed characters arrive in the current locale.  Conversion is to be
;;     done when 'encoding' is different from 'termencoding'.
;; (2) Text will be made available with the encoding specified with
;;     'encoding'.  If this is not sufficient, system-specific conversion
;;     might be required.
;; (3) For the GUI the correct font must be selected, no conversion done.
;;     Otherwise, conversion is to be done when 'encoding' differs from
;;     'termencoding'.
;; (4) The encoding of the file is specified with 'fileencoding'.  Conversion
;;     is to be done when it's different from 'encoding'.

;; Lookup table to quickly get the length in bytes of a UTF-8 sequence from the first byte.
;; Bytes which are illegal when used as the first byte have a 0.
;; The NUL byte has length 1.

(final byte* #_"[/*256*/]" utf8len_tab_zero
    [
        1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
        1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
        1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
        1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
        2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
        3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,4,4,4,4,4,4,4,4,5,5,5,5,6,6,0,0
    ])

;; Returns the length of a UTF-8 sequence, obtained from the first byte.
;; For an invalid first byte returns zero ? 0 : 1.

(defn- #_int us-byte2len [#_byte b, #_boolean zero]
    (let [#_int len (... utf8len_tab_zero (char_u b))]
        (if (or zero (< 0 len)) len 1)
    ))

;; Return byte length of character that starts with byte "b".
;; Returns 1 for a single-byte character.
;; mb-byte2len() can be used to count a special key as one byte.

(defn- #_int mb-byte2len [#_int b]
    (if (<= 0 b 0xff) (us-byte2len (byte b), false) 1))

;; Get class of pointer:
;;  0 for blank or NUL
;;  1 for punctuation
;;  2 for an (ASCII) word character
;; >2 for other word characters

(defn- #_int us-get-class [#_Bytes p]
    (let [#_byte b (.at p 0)]
        (cond (!= (us-byte2len b, false) 1) (utf-class (us-ptr2char p)) (or (eos? p) (vim-iswhite b)) 0 (us-iswordb b) 2 :else 1)
    ))

(defn- #_boolean intable [#_int* table, #_int c]
    (if (< c (... table 0))
        false
        (loop-when [bot 0 top (dec (/ (count table) 2))] (<= bot top) => false
            (let [mid (/ (+ bot top) 2)]
                (cond
                    (<   (... table (inc (* 2 mid))) c) (recur (inc mid) top)
                    (< c (... table      (* 2 mid)))    (recur bot (dec mid))
                    :else true)
            ))
    ))

;; Sorted list of non-overlapping intervals of East Asian double width characters,
;; generated with tools/unicode.vim.

(final int* doublewidth
    [
        0x1100, 0x115f,
        0x2329, 0x232a,
        0x2e80, 0x2e99,
        0x2e9b, 0x2ef3,
        0x2f00, 0x2fd5,
        0x2ff0, 0x2ffb,
        0x3000, 0x303e,
        0x3041, 0x3096,
        0x3099, 0x30ff,
        0x3105, 0x312d,
        0x3131, 0x318e,
        0x3190, 0x31ba,
        0x31c0, 0x31e3,
        0x31f0, 0x321e,
        0x3220, 0x3247,
        0x3250, 0x32fe,
        0x3300, 0x4dbf,
        0x4e00, 0xa48c,
        0xa490, 0xa4c6,
        0xa960, 0xa97c,
        0xac00, 0xd7a3,
        0xf900, 0xfaff,
        0xfe10, 0xfe19,
        0xfe30, 0xfe52,
        0xfe54, 0xfe66,
        0xfe68, 0xfe6b,
        0xff01, 0xff60,
        0xffe0, 0xffe6,
        0x1b000, 0x1b001,
        0x1f200, 0x1f202,
        0x1f210, 0x1f23a,
        0x1f240, 0x1f248,
        0x1f250, 0x1f251,
        0x20000, 0x2fffd,
        0x30000, 0x3fffd
    ])

;; Sorted list of non-overlapping intervals of East Asian Ambiguous characters,
;; generated with tools/unicode.vim.

(final int* ambiguous
    [
        0x00a1, 0x00a1,
        0x00a4, 0x00a4,
        0x00a7, 0x00a8,
        0x00aa, 0x00aa,
        0x00ad, 0x00ae,
        0x00b0, 0x00b4,
        0x00b6, 0x00ba,
        0x00bc, 0x00bf,
        0x00c6, 0x00c6,
        0x00d0, 0x00d0,
        0x00d7, 0x00d8,
        0x00de, 0x00e1,
        0x00e6, 0x00e6,
        0x00e8, 0x00ea,
        0x00ec, 0x00ed,
        0x00f0, 0x00f0,
        0x00f2, 0x00f3,
        0x00f7, 0x00fa,
        0x00fc, 0x00fc,
        0x00fe, 0x00fe,
        0x0101, 0x0101,
        0x0111, 0x0111,
        0x0113, 0x0113,
        0x011b, 0x011b,
        0x0126, 0x0127,
        0x012b, 0x012b,
        0x0131, 0x0133,
        0x0138, 0x0138,
        0x013f, 0x0142,
        0x0144, 0x0144,
        0x0148, 0x014b,
        0x014d, 0x014d,
        0x0152, 0x0153,
        0x0166, 0x0167,
        0x016b, 0x016b,
        0x01ce, 0x01ce,
        0x01d0, 0x01d0,
        0x01d2, 0x01d2,
        0x01d4, 0x01d4,
        0x01d6, 0x01d6,
        0x01d8, 0x01d8,
        0x01da, 0x01da,
        0x01dc, 0x01dc,
        0x0251, 0x0251,
        0x0261, 0x0261,
        0x02c4, 0x02c4,
        0x02c7, 0x02c7,
        0x02c9, 0x02cb,
        0x02cd, 0x02cd,
        0x02d0, 0x02d0,
        0x02d8, 0x02db,
        0x02dd, 0x02dd,
        0x02df, 0x02df,
        0x0300, 0x036f,
        0x0391, 0x03a1,
        0x03a3, 0x03a9,
        0x03b1, 0x03c1,
        0x03c3, 0x03c9,
        0x0401, 0x0401,
        0x0410, 0x044f,
        0x0451, 0x0451,
        0x2010, 0x2010,
        0x2013, 0x2016,
        0x2018, 0x2019,
        0x201c, 0x201d,
        0x2020, 0x2022,
        0x2024, 0x2027,
        0x2030, 0x2030,
        0x2032, 0x2033,
        0x2035, 0x2035,
        0x203b, 0x203b,
        0x203e, 0x203e,
        0x2074, 0x2074,
        0x207f, 0x207f,
        0x2081, 0x2084,
        0x20ac, 0x20ac,
        0x2103, 0x2103,
        0x2105, 0x2105,
        0x2109, 0x2109,
        0x2113, 0x2113,
        0x2116, 0x2116,
        0x2121, 0x2122,
        0x2126, 0x2126,
        0x212b, 0x212b,
        0x2153, 0x2154,
        0x215b, 0x215e,
        0x2160, 0x216b,
        0x2170, 0x2179,
        0x2189, 0x2189,
        0x2190, 0x2199,
        0x21b8, 0x21b9,
        0x21d2, 0x21d2,
        0x21d4, 0x21d4,
        0x21e7, 0x21e7,
        0x2200, 0x2200,
        0x2202, 0x2203,
        0x2207, 0x2208,
        0x220b, 0x220b,
        0x220f, 0x220f,
        0x2211, 0x2211,
        0x2215, 0x2215,
        0x221a, 0x221a,
        0x221d, 0x2220,
        0x2223, 0x2223,
        0x2225, 0x2225,
        0x2227, 0x222c,
        0x222e, 0x222e,
        0x2234, 0x2237,
        0x223c, 0x223d,
        0x2248, 0x2248,
        0x224c, 0x224c,
        0x2252, 0x2252,
        0x2260, 0x2261,
        0x2264, 0x2267,
        0x226a, 0x226b,
        0x226e, 0x226f,
        0x2282, 0x2283,
        0x2286, 0x2287,
        0x2295, 0x2295,
        0x2299, 0x2299,
        0x22a5, 0x22a5,
        0x22bf, 0x22bf,
        0x2312, 0x2312,
        0x2460, 0x24e9,
        0x24eb, 0x254b,
        0x2550, 0x2573,
        0x2580, 0x258f,
        0x2592, 0x2595,
        0x25a0, 0x25a1,
        0x25a3, 0x25a9,
        0x25b2, 0x25b3,
        0x25b6, 0x25b7,
        0x25bc, 0x25bd,
        0x25c0, 0x25c1,
        0x25c6, 0x25c8,
        0x25cb, 0x25cb,
        0x25ce, 0x25d1,
        0x25e2, 0x25e5,
        0x25ef, 0x25ef,
        0x2605, 0x2606,
        0x2609, 0x2609,
        0x260e, 0x260f,
        0x2614, 0x2615,
        0x261c, 0x261c,
        0x261e, 0x261e,
        0x2640, 0x2640,
        0x2642, 0x2642,
        0x2660, 0x2661,
        0x2663, 0x2665,
        0x2667, 0x266a,
        0x266c, 0x266d,
        0x266f, 0x266f,
        0x269e, 0x269f,
        0x26be, 0x26bf,
        0x26c4, 0x26cd,
        0x26cf, 0x26e1,
        0x26e3, 0x26e3,
        0x26e8, 0x26ff,
        0x273d, 0x273d,
        0x2757, 0x2757,
        0x2776, 0x277f,
        0x2b55, 0x2b59,
        0x3248, 0x324f,
        0xe000, 0xf8ff,
        0xfe00, 0xfe0f,
        0xfffd, 0xfffd,
        0x1f100, 0x1f10a,
        0x1f110, 0x1f12d,
        0x1f130, 0x1f169,
        0x1f170, 0x1f19a,
        0xe0100, 0xe01ef,
        0xf0000, 0xffffd,
        0x100000, 0x10fffd
    ])

;; For UTF-8 character "c" return 2 for a double-width character, 1 for others.
;; Returns 4 or 6 for an unprintable character.
;; Is only correct for characters >= 0x80.

(defn- #_int utf-char2cells [#_int c]
    (let [miez? false
          _ (when (<= 0x80 c)
                ;; chars below 0x100 are influenced by 'isprint' ;; 4: unprintable, displays <xx> ;; 6: unprintable, displays <xxxx>
                (let [_ (if (< c 0x100) (when (not (vim-isprintc c)) 4) (cond (not (utf-printable c)) 6 (intable doublewidth, c) 2))]
                    (if (some? _) _ (when (and miez? (intable ambiguous, c)) 2)))
            )]
        (if (some? _) _ 1)
    ))

(defn- us-ptr2cells
    ([s] (us-ptr2cells s 0))
    ([s i]
        (if (< (char_u (.at s i)) 0x80)
            1
            (let [c (us-ptr2char s, i)]
                (cond (or (== (us-ptr2len s, i) 1) (== c NUL)) ;; an illegal byte is displayed as <xx>
                    4
                (< c 0x80) ;; if the char is ASCII, it must be an overlong sequence
                    (mb-char2cells c)
                :else
                    (utf-char2cells c)
                ))
        )))

;; Return the number of cells occupied by string "s".
;; Stop at a NUL character.  When 0 <= "n" stop at character "s[n]".

(defn- #_int us-string2cells [#_Bytes s, #_int n]
    (loop-when-recur [#_int cells 0 #_int i 0] (and (or (< n 0) (< i n)) (non-eos? s i)) [(+ cells (us-ptr2cells s, i)) (+ i (us-ptr2len-cc s, i))] => cells))

(defn- #_int utf-off2cells [#_int off, #_int max_off]
    (if (and (< (inc off) max_off) (at? @screenLines (inc off) 0)) 2 1))

;; Convert a UTF-8 byte sequence to a wide character.
;; If the sequence is illegal or truncated by a NUL the first byte is returned.
;; Does not include composing characters, of course.

(defn- us-ptr2char
    ([s] (us-ptr2char s 0))
    ([s i]
        (let [s0 (.at s i) u0 (char_u s0)] (if (< u0 0x80) ;; be quick for ASCII
            s0
        (let [n (us-byte2len s0, true)] (if (< n 2) ;; illegal value, just return the first byte
            u0
        (let [s1 (.at s (+ i 1))] (if (== (& (char_u s1) 0xc0) 0x80) (if (== n 2)
            (+ (<< (& s0 0x1f) 6) (& s1 0x3f))
        (let [s2 (.at s (+ i 2))] (if (== (& (char_u s2) 0xc0) 0x80) (if (== n 3)
            (+ (<< (& s0 0x0f) 12) (<< (& s1 0x3f) 6) (& s2 0x3f))
        (let [s3 (.at s (+ i 3))] (if (== (& (char_u s3) 0xc0) 0x80) (if (== n 4)
            (+ (<< (& s0 0x07) 18) (<< (& s1 0x3f) 12) (<< (& s2 0x3f) 6) (& s3 0x3f))
        (let [s4 (.at s (+ i 4))] (if (== (& (char_u s4) 0xc0) 0x80) (if (== n 5)
            (+ (<< (& s0 0x03) 24) (<< (& s1 0x3f) 18) (<< (& s2 0x3f) 12) (<< (& s3 0x3f) 6) (& s4 0x3f))
        (let [s5 (.at s (+ i 5))] (if (and (== (& (char_u s5) 0xc0) 0x80) (== n 6))
            (+ (<< (& s0 0x01) 30) (<< (& s1 0x3f) 24) (<< (& s2 0x3f) 18) (<< (& s3 0x3f) 12) (<< (& s4 0x3f) 6) (& s5 0x3f))
            u0
        ))) u0
        ))) u0
        ))) u0
        ))) u0
        ))))))
    ))

;; Convert a UTF-8 byte sequence to a wide character.
;; String is assumed to be terminated by NUL or after "n" bytes, whichever comes first.
;; The function is safe in the sense that it never accesses memory beyond the first "n" bytes of "s".
;;
;; On success, returns decoded codepoint,
;; advances "s" to the beginning of next character and decreases "n" accordingly.
;;
;; If end of string was reached, returns 0 and, if "n" > 0, advances "s" past NUL byte.
;;
;; If byte sequence is illegal or incomplete, returns -1 and does not advance "s".

(defn- #_int us-safe-read-char-adv [#_Bytes' a's, #_int' a'n]
    (if (zero? @a'n)    ;; end of buffer
        0
        (let [#_int k (us-byte2len (.at @a's 0), true)]
            (cond (== k 1)     ;; ASCII character or NUL
                (do (swap! a's plus 1) (swap! a'n dec) (.at @a's -1))
            (<= k @a'n)
                ;; We have a multibyte sequence that isn't truncated, so us-ptr2char() is safe to use;
                ;; or the first byte is illegal (k=0), but it's also safe to use us-ptr2char().
                (let [#_int c (us-ptr2char @a's)]
                    ;; On failure, us-ptr2char() returns the first byte, so here we check equality with the first byte.
                    ;; The only non-ASCII character which equals the first byte of its own UTF-8 representation is
                    ;; U+00C3 (UTF-8: 0xC3 0x83), so need to check that special case too.
                    ;; It's safe even if n=1, else we would have k=2 > n.
                    (if (or (!= c (char_u (.at @a's 0))) (and (== c 0xc3) (== (char_u (.at @a's 1)) 0x83)))
                        (do (swap! a's plus k) (swap! a'n - k) c) ;; byte sequence was successfully decoded
                        -1 ;; byte sequence is illegal
                    ))
            :else
                -1 ;; byte sequence is incomplete
            ))
    ))

;; Get character at **pp and advance *pp to the next character.
;; skip: composing characters are skipped!
;; !skip: composing characters are returned as separate characters.

(defn- #_int us-ptr2char-adv [#_Bytes' a's, #_boolean skip]
    (let [#_int c (us-ptr2char @a's)]
        (swap! a's #(.plus % (if skip (us-ptr2len-cc %) (us-ptr2len %))))
        c
    ))

;; Convert a UTF-8 byte string to a wide character.
;; Also get up to MAX_MCO composing characters.

(defn- #_int us-ptr2char-cc [#_Bytes p, #_int* pcc]
    ;; pcc: return: composing chars, last one is 0
    (let [#_int i (us-ptr2len p)
          #_int j ;; Only accept a composing char when the first char isn't illegal.
            (if (or (< 1 i) (< (char_u (.at p 0)) 0x80))
                (loop-when [i i j 0] (<= 0x80 (char_u (.at p i))) => j
                    (let-when [#_int cc (us-ptr2char p, i)] (utf-iscomposing cc) => j
                        (aset pcc j cc)
                        (let [j (inc j)]
                            (recur-if (< j MAX_MCO) [(+ i (us-ptr2len p, i)) j] => j))
                    ))
                0
            )]
        (when (< j MAX_MCO)    ;; last composing char must be 0
            (aset pcc j 0))
        (us-ptr2char p)
    ))

;; Convert a UTF-8 byte string to a wide character.
;; Also get up to MAX_MCO composing characters.
;; Use no more than p[maxlen].

(defn- #_int us-ptr2char-cc-len [#_Bytes p, #_int* pcc, #_int maxlen]
    ;; pcc: return: composing chars, last one is 0
    (let [#_int i (us-ptr2len-len p, maxlen)
          #_int j ;; Only accept a composing char when the first char isn't illegal.
            (if (or (< 1 i) (< (char_u (.at p 0)) 0x80))
                (loop-when [i i j 0] (and (< i maxlen) (<= 0x80 (char_u (.at p i)))) => j
                    (let-when [#_int cc (us-ptr2char p, i)] (utf-iscomposing cc) => j
                        (aset pcc j cc)
                        (let [j (inc j)]
                            (recur-if (< j MAX_MCO) [(+ i (us-ptr2len-len p, i, (- maxlen i))) j] => j))
                    ))
                0
            )]
        (when (< j MAX_MCO)    ;; last composing char must be 0
            (aset pcc j 0))
        (us-ptr2char p)
    ))

;; Convert the character at screen position "off" to a sequence of bytes.
;; Includes the composing characters.
;; "buf" must at least have the length MB_MAXBYTES + 1.
;; Only to be used when screenLinesUC[off] != 0.
;; Returns the produced number of bytes.

(defn- #_int utfc-char2bytes [#_int off, #_Bytes buf]
    (loop-when-recur [#_int len (utf-char2bytes (aget @screenLinesUC off), buf) #_int i 0]
                     (and (< i @screen_mco) (non-zero? (aget (... @screenLinesC i) off)))
                     [(+ len (utf-char2bytes (aget (... @screenLinesC i) off), (.plus buf len))) (inc i)]
                  => len)
)

;; Get the length of a UTF-8 byte sequence, not including any following composing characters.
;; Returns 0 for "".
;; Returns 1 for an illegal byte sequence.

(defn- us-ptr2len
    ([s] (us-ptr2len s 0))
    ([s i]
        (if (eos? s i)
            0
            (let [n (us-byte2len (.at s i), false)]
                (loop-when [i (inc i)] (< i n) => n
                    (recur-if (== (& (char_u (.at s i)) 0xc0) 0x80) [(inc i)] => 1)
                )
            )
        )))

;; Get the length of UTF-8 byte sequence "s[m]".
;; Does not include any following composing characters.
;; Returns 1 for "".
;; Returns 1 for an illegal byte sequence (also in incomplete byte sequence).
;; Returns number > "m" for an incomplete byte sequence.
;; Never returns zero.

(defn- us-ptr2len-len
    ([s m] (us-ptr2len-len s 0 m))
    ([s i m]
        (let [n (us-byte2len (.at s i), false)]
            (if (== n 1)
                1 ;; NUL, ASCII or illegal lead byte
                (let [m (min n m)] ;; incomplete byte sequence?
                    (loop-when [i (inc i)] (< i m) => n
                        (recur-if (== (& (char_u (.at s i)) 0xc0) 0x80) [(inc i)] => 1)
                    )
                )
            )
        )))

;; Return the number of bytes the UTF-8 encoding of the character at "s" takes.
;; This includes following composing characters.

(defn- us-ptr2len-cc
    ([s] (us-ptr2len-cc 0))
    ([s i]
        (cond
            (eos? s i)
                0
            (and (< (char_u (.at s i)) 0x80) (< (char_u (.at s (inc i))) 0x80)) ;; be quick for ASCII
                1
            :else
                (let [n (us-ptr2len s, i)] ;; skip over first UTF-8 char, stopping at a NUL byte
                    (if (and (== n 1) (<= 0x80 (char_u (.at s i)))) ;; check for illegal byte
                        1
                        (let [a i]
                            ;; Check for composing characters.  We can handle only the first six, but skip all of them (otherwise the cursor would get stuck).
                            (loop-when-recur [i (+ i n)] (and (<= 0x80 (char_u (.at s i))) (utf-iscomposing (us-ptr2char s i))) [(+ i (us-ptr2len s, i))] => (- i a)))
                    ))
        )))

;; Return the number of bytes the UTF-8 encoding of the character at "s[m]" takes.
;; This includes following composing characters.
;; Returns 0 for an empty string.
;; Returns 1 for an illegal char or an incomplete byte sequence.

(defn- us-ptr2len-cc-len
    ([s m] (us-ptr2len-cc-len s 0 m))
    ([s i m]
        (cond
            (or (< m 1) (eos? s i))
                0
            (and (< (char_u (.at s i)) 0x80) (or (== m 1) (< (char_u (.at s (inc i))) 0x80))) ;; be quick for ASCII
                1
            :else
                (let [n (us-ptr2len-len s, i, m)] ;; skip over first UTF-8 char, stopping at a NUL byte
                    (if (or (and (== n 1) (<= 0x80 (char_u (.at s i)))) (< m n)) ;; check for illegal byte and incomplete byte sequence
                        1
                        (let [a i m (+ i m)]
                            ;; Check for composing characters.  We can handle only the first six, but skip all of them (otherwise the cursor would get stuck).
                            (loop-when [i (+ i n)] (and (< i m) (<= 0x80 (char_u (.at s i)))) => (- i a)
                                ;; Next character length should not go beyond size to ensure that UTF_COMPOSINGLIKE(...) does not read beyond size.
                                (let [n (us-ptr2len-len s, i, (- m i))]
                                    (recur-if (and (<= n (- m i)) (utf-iscomposing (us-ptr2char s i))) [(+ i n)] => (- i a))
                                )))
                    ))
        )))

;; Return the number of bytes the UTF-8 encoding of character "c" takes.
;; This does not include composing characters.

(defn- #_int utf-char2len [#_int c]
    (cond (< c 0x80) 1 (< c 0x800) 2 (< c 0x10000) 3 (< c 0x200000) 4 (< c 0x4000000) 5 :else 6))

;; Convert Unicode character "c" to UTF-8 string in "buf[]".
;; Returns the number of bytes.
;; This does not include composing characters.

(defn- #_int utf-char2bytes [#_int c, #_Bytes buf]
    (cond
        (< c 0x80)              ;; 7 bits
        (do
            (.be buf 0, c)
            1
        )
        (< c 0x800)             ;; 11 bits
        (do
            (.be buf 0, (+ 0xc0 (>>> c 6)))
            (.be buf 1, (+ 0x80 (& c 0x3f)))
            2
        )
        (< c 0x10000)           ;; 16 bits
        (do
            (.be buf 0, (+ 0xe0 (>>> c 12)))
            (.be buf 1, (+ 0x80 (& (>>> c 6) 0x3f)))
            (.be buf 2, (+ 0x80 (& c 0x3f)))
            3
        )
        (< c 0x200000)          ;; 21 bits
        (do
            (.be buf 0, (+ 0xf0 (>>> c 18)))
            (.be buf 1, (+ 0x80 (& (>>> c 12) 0x3f)))
            (.be buf 2, (+ 0x80 (& (>>> c 6) 0x3f)))
            (.be buf 3, (+ 0x80 (& c 0x3f)))
            4
        )
        (< c 0x4000000)         ;; 26 bits
        (do
            (.be buf 0, (+ 0xf8 (>>> c 24)))
            (.be buf 1, (+ 0x80 (& (>>> c 18) 0x3f)))
            (.be buf 2, (+ 0x80 (& (>>> c 12) 0x3f)))
            (.be buf 3, (+ 0x80 (& (>>> c 6) 0x3f)))
            (.be buf 4, (+ 0x80 (& c 0x3f)))
            5
        )
        :else                   ;; 31 bits
        (do
            (.be buf 0, (+ 0xfc (>>> c 30)))
            (.be buf 1, (+ 0x80 (& (>>> c 24) 0x3f)))
            (.be buf 2, (+ 0x80 (& (>>> c 18) 0x3f)))
            (.be buf 3, (+ 0x80 (& (>>> c 12) 0x3f)))
            (.be buf 4, (+ 0x80 (& (>>> c 6) 0x3f)))
            (.be buf 5, (+ 0x80 (& c 0x3f)))
            6
        )
    ))

;; Sorted list of non-overlapping intervals.
;; Generated by tools/unicode.vim.

(final int* combining
    [
        0x0300, 0x036f,
        0x0483, 0x0489,
        0x0591, 0x05bd,
        0x05bf, 0x05bf,
        0x05c1, 0x05c2,
        0x05c4, 0x05c5,
        0x05c7, 0x05c7,
        0x0610, 0x061a,
        0x064b, 0x065f,
        0x0670, 0x0670,
        0x06d6, 0x06dc,
        0x06df, 0x06e4,
        0x06e7, 0x06e8,
        0x06ea, 0x06ed,
        0x0711, 0x0711,
        0x0730, 0x074a,
        0x07a6, 0x07b0,
        0x07eb, 0x07f3,
        0x0816, 0x0819,
        0x081b, 0x0823,
        0x0825, 0x0827,
        0x0829, 0x082d,
        0x0859, 0x085b,
        0x08e4, 0x0903,
        0x093a, 0x093c,
        0x093e, 0x094f,
        0x0951, 0x0957,
        0x0962, 0x0963,
        0x0981, 0x0983,
        0x09bc, 0x09bc,
        0x09be, 0x09c4,
        0x09c7, 0x09c8,
        0x09cb, 0x09cd,
        0x09d7, 0x09d7,
        0x09e2, 0x09e3,
        0x0a01, 0x0a03,
        0x0a3c, 0x0a3c,
        0x0a3e, 0x0a42,
        0x0a47, 0x0a48,
        0x0a4b, 0x0a4d,
        0x0a51, 0x0a51,
        0x0a70, 0x0a71,
        0x0a75, 0x0a75,
        0x0a81, 0x0a83,
        0x0abc, 0x0abc,
        0x0abe, 0x0ac5,
        0x0ac7, 0x0ac9,
        0x0acb, 0x0acd,
        0x0ae2, 0x0ae3,
        0x0b01, 0x0b03,
        0x0b3c, 0x0b3c,
        0x0b3e, 0x0b44,
        0x0b47, 0x0b48,
        0x0b4b, 0x0b4d,
        0x0b56, 0x0b57,
        0x0b62, 0x0b63,
        0x0b82, 0x0b82,
        0x0bbe, 0x0bc2,
        0x0bc6, 0x0bc8,
        0x0bca, 0x0bcd,
        0x0bd7, 0x0bd7,
        0x0c00, 0x0c03,
        0x0c3e, 0x0c44,
        0x0c46, 0x0c48,
        0x0c4a, 0x0c4d,
        0x0c55, 0x0c56,
        0x0c62, 0x0c63,
        0x0c81, 0x0c83,
        0x0cbc, 0x0cbc,
        0x0cbe, 0x0cc4,
        0x0cc6, 0x0cc8,
        0x0cca, 0x0ccd,
        0x0cd5, 0x0cd6,
        0x0ce2, 0x0ce3,
        0x0d01, 0x0d03,
        0x0d3e, 0x0d44,
        0x0d46, 0x0d48,
        0x0d4a, 0x0d4d,
        0x0d57, 0x0d57,
        0x0d62, 0x0d63,
        0x0d82, 0x0d83,
        0x0dca, 0x0dca,
        0x0dcf, 0x0dd4,
        0x0dd6, 0x0dd6,
        0x0dd8, 0x0ddf,
        0x0df2, 0x0df3,
        0x0e31, 0x0e31,
        0x0e34, 0x0e3a,
        0x0e47, 0x0e4e,
        0x0eb1, 0x0eb1,
        0x0eb4, 0x0eb9,
        0x0ebb, 0x0ebc,
        0x0ec8, 0x0ecd,
        0x0f18, 0x0f19,
        0x0f35, 0x0f35,
        0x0f37, 0x0f37,
        0x0f39, 0x0f39,
        0x0f3e, 0x0f3f,
        0x0f71, 0x0f84,
        0x0f86, 0x0f87,
        0x0f8d, 0x0f97,
        0x0f99, 0x0fbc,
        0x0fc6, 0x0fc6,
        0x102b, 0x103e,
        0x1056, 0x1059,
        0x105e, 0x1060,
        0x1062, 0x1064,
        0x1067, 0x106d,
        0x1071, 0x1074,
        0x1082, 0x108d,
        0x108f, 0x108f,
        0x109a, 0x109d,
        0x135d, 0x135f,
        0x1712, 0x1714,
        0x1732, 0x1734,
        0x1752, 0x1753,
        0x1772, 0x1773,
        0x17b4, 0x17d3,
        0x17dd, 0x17dd,
        0x180b, 0x180d,
        0x18a9, 0x18a9,
        0x1920, 0x192b,
        0x1930, 0x193b,
        0x19b0, 0x19c0,
        0x19c8, 0x19c9,
        0x1a17, 0x1a1b,
        0x1a55, 0x1a5e,
        0x1a60, 0x1a7c,
        0x1a7f, 0x1a7f,
        0x1ab0, 0x1abe,
        0x1b00, 0x1b04,
        0x1b34, 0x1b44,
        0x1b6b, 0x1b73,
        0x1b80, 0x1b82,
        0x1ba1, 0x1bad,
        0x1be6, 0x1bf3,
        0x1c24, 0x1c37,
        0x1cd0, 0x1cd2,
        0x1cd4, 0x1ce8,
        0x1ced, 0x1ced,
        0x1cf2, 0x1cf4,
        0x1cf8, 0x1cf9,
        0x1dc0, 0x1df5,
        0x1dfc, 0x1dff,
        0x20d0, 0x20f0,
        0x2cef, 0x2cf1,
        0x2d7f, 0x2d7f,
        0x2de0, 0x2dff,
        0x302a, 0x302f,
        0x3099, 0x309a,
        0xa66f, 0xa672,
        0xa674, 0xa67d,
        0xa69f, 0xa69f,
        0xa6f0, 0xa6f1,
        0xa802, 0xa802,
        0xa806, 0xa806,
        0xa80b, 0xa80b,
        0xa823, 0xa827,
        0xa880, 0xa881,
        0xa8b4, 0xa8c4,
        0xa8e0, 0xa8f1,
        0xa926, 0xa92d,
        0xa947, 0xa953,
        0xa980, 0xa983,
        0xa9b3, 0xa9c0,
        0xa9e5, 0xa9e5,
        0xaa29, 0xaa36,
        0xaa43, 0xaa43,
        0xaa4c, 0xaa4d,
        0xaa7b, 0xaa7d,
        0xaab0, 0xaab0,
        0xaab2, 0xaab4,
        0xaab7, 0xaab8,
        0xaabe, 0xaabf,
        0xaac1, 0xaac1,
        0xaaeb, 0xaaef,
        0xaaf5, 0xaaf6,
        0xabe3, 0xabea,
        0xabec, 0xabed,
        0xfb1e, 0xfb1e,
        0xfe00, 0xfe0f,
        0xfe20, 0xfe2d,
        0x101fd, 0x101fd,
        0x102e0, 0x102e0,
        0x10376, 0x1037a,
        0x10a01, 0x10a03,
        0x10a05, 0x10a06,
        0x10a0c, 0x10a0f,
        0x10a38, 0x10a3a,
        0x10a3f, 0x10a3f,
        0x10ae5, 0x10ae6,
        0x11000, 0x11002,
        0x11038, 0x11046,
        0x1107f, 0x11082,
        0x110b0, 0x110ba,
        0x11100, 0x11102,
        0x11127, 0x11134,
        0x11173, 0x11173,
        0x11180, 0x11182,
        0x111b3, 0x111c0,
        0x1122c, 0x11237,
        0x112df, 0x112ea,
        0x11301, 0x11303,
        0x1133c, 0x1133c,
        0x1133e, 0x11344,
        0x11347, 0x11348,
        0x1134b, 0x1134d,
        0x11357, 0x11357,
        0x11362, 0x11363,
        0x11366, 0x1136c,
        0x11370, 0x11374,
        0x114b0, 0x114c3,
        0x115af, 0x115b5,
        0x115b8, 0x115c0,
        0x11630, 0x11640,
        0x116ab, 0x116b7,
        0x16af0, 0x16af4,
        0x16b30, 0x16b36,
        0x16f51, 0x16f7e,
        0x16f8f, 0x16f92,
        0x1bc9d, 0x1bc9e,
        0x1d165, 0x1d169,
        0x1d16d, 0x1d172,
        0x1d17b, 0x1d182,
        0x1d185, 0x1d18b,
        0x1d1aa, 0x1d1ad,
        0x1d242, 0x1d244,
        0x1e8d0, 0x1e8d6,
        0xe0100, 0xe01ef
    ])

;; Return true if "c" is a composing UTF-8 character.
;; This means it will be drawn on top of the preceding character.

(defn- #_boolean utf-iscomposing [#_int c]
    (intable combining, c))

;; Sorted list of non-overlapping intervals.
;; 0xd800-0xdfff is reserved for UTF-16, actually illegal.

(final int* nonprint
    [
        0x070f, 0x070f,
        0x180b, 0x180e,
        0x200b, 0x200f,
        0x202a, 0x202e,
        0x206a, 0x206f,
        0xd800, 0xdfff,
        0xfeff, 0xfeff,
        0xfff9, 0xfffb,
        0xfffe, 0xffff
    ])

;; Return true for characters that can be displayed in a normal way.
;; Only for characters of 0x100 and above!

(defn- #_boolean utf-printable [#_int c]
    (not (intable nonprint, c)))

;; sorted list of non-overlapping intervals
(final int* classes
    [
        0x037e, 0x037e, 1,          ;; Greek question mark
        0x0387, 0x0387, 1,          ;; Greek ano teleia
        0x055a, 0x055f, 1,          ;; Armenian punctuation
        0x0589, 0x0589, 1,          ;; Armenian full stop
        0x05be, 0x05be, 1,
        0x05c0, 0x05c0, 1,
        0x05c3, 0x05c3, 1,
        0x05f3, 0x05f4, 1,
        0x060c, 0x060c, 1,
        0x061b, 0x061b, 1,
        0x061f, 0x061f, 1,
        0x066a, 0x066d, 1,
        0x06d4, 0x06d4, 1,
        0x0700, 0x070d, 1,          ;; Syriac punctuation
        0x0964, 0x0965, 1,
        0x0970, 0x0970, 1,
        0x0df4, 0x0df4, 1,
        0x0e4f, 0x0e4f, 1,
        0x0e5a, 0x0e5b, 1,
        0x0f04, 0x0f12, 1,
        0x0f3a, 0x0f3d, 1,
        0x0f85, 0x0f85, 1,
        0x104a, 0x104f, 1,          ;; Myanmar punctuation
        0x10fb, 0x10fb, 1,          ;; Georgian punctuation
        0x1361, 0x1368, 1,          ;; Ethiopic punctuation
        0x166d, 0x166e, 1,          ;; Canadian Syl. punctuation
        0x1680, 0x1680, 0,
        0x169b, 0x169c, 1,
        0x16eb, 0x16ed, 1,
        0x1735, 0x1736, 1,
        0x17d4, 0x17dc, 1,          ;; Khmer punctuation
        0x1800, 0x180a, 1,          ;; Mongolian punctuation
        0x2000, 0x200b, 0,          ;; spaces
        0x200c, 0x2027, 1,          ;; punctuation and symbols
        0x2028, 0x2029, 0,
        0x202a, 0x202e, 1,          ;; punctuation and symbols
        0x202f, 0x202f, 0,
        0x2030, 0x205e, 1,          ;; punctuation and symbols
        0x205f, 0x205f, 0,
        0x2060, 0x27ff, 1,          ;; punctuation and symbols
        0x2070, 0x207f, 0x2070,     ;; superscript
        0x2080, 0x2094, 0x2080,     ;; subscript
        0x20a0, 0x27ff, 1,          ;; all kinds of symbols
        0x2800, 0x28ff, 0x2800,     ;; braille
        0x2900, 0x2998, 1,          ;; arrows, brackets, etc.
        0x29d8, 0x29db, 1,
        0x29fc, 0x29fd, 1,
        0x2e00, 0x2e7f, 1,          ;; supplemental punctuation
        0x3000, 0x3000, 0,          ;; ideographic space
        0x3001, 0x3020, 1,          ;; ideographic punctuation
        0x3030, 0x3030, 1,
        0x303d, 0x303d, 1,
        0x3040, 0x309f, 0x3040,     ;; Hiragana
        0x30a0, 0x30ff, 0x30a0,     ;; Katakana
        0x3300, 0x9fff, 0x4e00,     ;; CJK Ideographs
        0xac00, 0xd7a3, 0xac00,     ;; Hangul Syllables
        0xf900, 0xfaff, 0x4e00,     ;; CJK Ideographs
        0xfd3e, 0xfd3f, 1,
        0xfe30, 0xfe6b, 1,          ;; punctuation forms
        0xff00, 0xff0f, 1,          ;; half/fullwidth ASCII
        0xff1a, 0xff20, 1,          ;; half/fullwidth ASCII
        0xff3b, 0xff40, 1,          ;; half/fullwidth ASCII
        0xff5b, 0xff65, 1,          ;; half/fullwidth ASCII
        0x20000, 0x2a6df, 0x4e00,   ;; CJK Ideographs
        0x2a700, 0x2b73f, 0x4e00,   ;; CJK Ideographs
        0x2b740, 0x2b81f, 0x4e00,   ;; CJK Ideographs
        0x2f800, 0x2fa1f, 0x4e00    ;; CJK Ideographs
    ])

;; Get class of a Unicode character.
;;  0: white space
;;  1: punctuation
;;  2 or bigger: some class of word character.

(defn- #_int utf-class [#_int c]
    (if (< c 0x100) ;; first quick check for Latin1 characters, use 'iskeyword'
        (cond (any == c (byte \space) TAB NUL 0xa0) 0 (vim-iswordc c) 2 :else 1)    ;; blank ;; word character ;; punctuation
        (loop-when [bot 0 top (dec (/ (count classes) 3))] (<= bot top) => 2        ;; most other characters are "word" characters
            (let [mid (/ (+ bot top) 2)]
                (cond
                    (<    (... classes (inc (* 3 mid))) c) (recur (inc mid) top)
                    (< c  (... classes      (* 3 mid)))    (recur bot (dec mid))
                    :else (... classes (+   (* 3 mid) 2))
                )))
    ))

;; Code for Unicode case-dependent operations.  Based on notes in
;; http://www.unicode.org/Public/UNIDATA/CaseFolding.txt
;; This code uses simple case folding, not full case folding.
;; Last updated for Unicode 5.2.

;; Generic conversion function for case operations.
;; Return the converted equivalent of "c", which is a UCS-4 character.
;; Use the given conversion "table".
;; Uses binary search on "table".

(defn- #_int utf-convert [#_int c, #_int* table]
    (let [start 0 entries (/ (count table) 4)
          start (loop-when [start start end entries] (< start end) => start
                    (let [mid (/ (+ start end) 2)] (if (< (... table (inc (* 4 mid))) c) (recur (inc mid) end) (recur start mid)))
                )]
        (if (< start entries)
            (let [i (* 4 start)]
                (if (and (<= (... table i) c) (<= c (... table (inc i))) (zero? (% (- c (... table i)) (... table (+ i 2)))))
                    (+ c (... table (+ i 3)))
                    c
                ))
            c)
    ))

;; The following tables are built by tools/unicode.vim.
;; They must be in numeric order, because we use binary search.
;; An entry such as {0x41,0x5a,1,32} means that Unicode characters in the range from 0x41 to 0x5a inclusive,
;; stepping by 1, are changed to folded/upper/lower by adding 32.

(final int* foldCase
    [
        0x41, 0x5a, 1, 32,
        0xb5, 0xb5,-1, 775,
        0xc0, 0xd6, 1, 32,
        0xd8, 0xde, 1, 32,
        0x100, 0x12e, 2, 1,
        0x132, 0x136, 2, 1,
        0x139, 0x147, 2, 1,
        0x14a, 0x176, 2, 1,
        0x178, 0x178,-1,-121,
        0x179, 0x17d, 2, 1,
        0x17f, 0x17f,-1,-268,
        0x181, 0x181,-1, 210,
        0x182, 0x184, 2, 1,
        0x186, 0x186,-1, 206,
        0x187, 0x187,-1, 1,
        0x189, 0x18a, 1, 205,
        0x18b, 0x18b,-1, 1,
        0x18e, 0x18e,-1, 79,
        0x18f, 0x18f,-1, 202,
        0x190, 0x190,-1, 203,
        0x191, 0x191,-1, 1,
        0x193, 0x193,-1, 205,
        0x194, 0x194,-1, 207,
        0x196, 0x196,-1, 211,
        0x197, 0x197,-1, 209,
        0x198, 0x198,-1, 1,
        0x19c, 0x19c,-1, 211,
        0x19d, 0x19d,-1, 213,
        0x19f, 0x19f,-1, 214,
        0x1a0, 0x1a4, 2, 1,
        0x1a6, 0x1a6,-1, 218,
        0x1a7, 0x1a7,-1, 1,
        0x1a9, 0x1a9,-1, 218,
        0x1ac, 0x1ac,-1, 1,
        0x1ae, 0x1ae,-1, 218,
        0x1af, 0x1af,-1, 1,
        0x1b1, 0x1b2, 1, 217,
        0x1b3, 0x1b5, 2, 1,
        0x1b7, 0x1b7,-1, 219,
        0x1b8, 0x1bc, 4, 1,
        0x1c4, 0x1c4,-1, 2,
        0x1c5, 0x1c5,-1, 1,
        0x1c7, 0x1c7,-1, 2,
        0x1c8, 0x1c8,-1, 1,
        0x1ca, 0x1ca,-1, 2,
        0x1cb, 0x1db, 2, 1,
        0x1de, 0x1ee, 2, 1,
        0x1f1, 0x1f1,-1, 2,
        0x1f2, 0x1f4, 2, 1,
        0x1f6, 0x1f6,-1,-97,
        0x1f7, 0x1f7,-1,-56,
        0x1f8, 0x21e, 2, 1,
        0x220, 0x220,-1,-130,
        0x222, 0x232, 2, 1,
        0x23a, 0x23a,-1, 10795,
        0x23b, 0x23b,-1, 1,
        0x23d, 0x23d,-1,-163,
        0x23e, 0x23e,-1, 10792,
        0x241, 0x241,-1, 1,
        0x243, 0x243,-1,-195,
        0x244, 0x244,-1, 69,
        0x245, 0x245,-1, 71,
        0x246, 0x24e, 2, 1,
        0x345, 0x345,-1, 116,
        0x370, 0x372, 2, 1,
        0x376, 0x376,-1, 1,
        0x37f, 0x37f,-1, 116,
        0x386, 0x386,-1, 38,
        0x388, 0x38a, 1, 37,
        0x38c, 0x38c,-1, 64,
        0x38e, 0x38f, 1, 63,
        0x391, 0x3a1, 1, 32,
        0x3a3, 0x3ab, 1, 32,
        0x3c2, 0x3c2,-1, 1,
        0x3cf, 0x3cf,-1, 8,
        0x3d0, 0x3d0,-1,-30,
        0x3d1, 0x3d1,-1,-25,
        0x3d5, 0x3d5,-1,-15,
        0x3d6, 0x3d6,-1,-22,
        0x3d8, 0x3ee, 2, 1,
        0x3f0, 0x3f0,-1,-54,
        0x3f1, 0x3f1,-1,-48,
        0x3f4, 0x3f4,-1,-60,
        0x3f5, 0x3f5,-1,-64,
        0x3f7, 0x3f7,-1, 1,
        0x3f9, 0x3f9,-1,-7,
        0x3fa, 0x3fa,-1, 1,
        0x3fd, 0x3ff, 1,-130,
        0x400, 0x40f, 1, 80,
        0x410, 0x42f, 1, 32,
        0x460, 0x480, 2, 1,
        0x48a, 0x4be, 2, 1,
        0x4c0, 0x4c0,-1, 15,
        0x4c1, 0x4cd, 2, 1,
        0x4d0, 0x52e, 2, 1,
        0x531, 0x556, 1, 48,
        0x10a0, 0x10c5, 1, 7264,
        0x10c7, 0x10cd, 6, 7264,
        0x1e00, 0x1e94, 2, 1,
        0x1e9b, 0x1e9b,-1,-58,
        0x1e9e, 0x1e9e,-1,-7615,
        0x1ea0, 0x1efe, 2, 1,
        0x1f08, 0x1f0f, 1,-8,
        0x1f18, 0x1f1d, 1,-8,
        0x1f28, 0x1f2f, 1,-8,
        0x1f38, 0x1f3f, 1,-8,
        0x1f48, 0x1f4d, 1,-8,
        0x1f59, 0x1f5f, 2,-8,
        0x1f68, 0x1f6f, 1,-8,
        0x1f88, 0x1f8f, 1,-8,
        0x1f98, 0x1f9f, 1,-8,
        0x1fa8, 0x1faf, 1,-8,
        0x1fb8, 0x1fb9, 1,-8,
        0x1fba, 0x1fbb, 1,-74,
        0x1fbc, 0x1fbc,-1,-9,
        0x1fbe, 0x1fbe,-1,-7173,
        0x1fc8, 0x1fcb, 1,-86,
        0x1fcc, 0x1fcc,-1,-9,
        0x1fd8, 0x1fd9, 1,-8,
        0x1fda, 0x1fdb, 1,-100,
        0x1fe8, 0x1fe9, 1,-8,
        0x1fea, 0x1feb, 1,-112,
        0x1fec, 0x1fec,-1,-7,
        0x1ff8, 0x1ff9, 1,-128,
        0x1ffa, 0x1ffb, 1,-126,
        0x1ffc, 0x1ffc,-1,-9,
        0x2126, 0x2126,-1,-7517,
        0x212a, 0x212a,-1,-8383,
        0x212b, 0x212b,-1,-8262,
        0x2132, 0x2132,-1, 28,
        0x2160, 0x216f, 1, 16,
        0x2183, 0x2183,-1, 1,
        0x24b6, 0x24cf, 1, 26,
        0x2c00, 0x2c2e, 1, 48,
        0x2c60, 0x2c60,-1, 1,
        0x2c62, 0x2c62,-1,-10743,
        0x2c63, 0x2c63,-1,-3814,
        0x2c64, 0x2c64,-1,-10727,
        0x2c67, 0x2c6b, 2, 1,
        0x2c6d, 0x2c6d,-1,-10780,
        0x2c6e, 0x2c6e,-1,-10749,
        0x2c6f, 0x2c6f,-1,-10783,
        0x2c70, 0x2c70,-1,-10782,
        0x2c72, 0x2c75, 3, 1,
        0x2c7e, 0x2c7f, 1,-10815,
        0x2c80, 0x2ce2, 2, 1,
        0x2ceb, 0x2ced, 2, 1,
        0x2cf2, 0xa640, 31054, 1,
        0xa642, 0xa66c, 2, 1,
        0xa680, 0xa69a, 2, 1,
        0xa722, 0xa72e, 2, 1,
        0xa732, 0xa76e, 2, 1,
        0xa779, 0xa77b, 2, 1,
        0xa77d, 0xa77d,-1,-35332,
        0xa77e, 0xa786, 2, 1,
        0xa78b, 0xa78b,-1, 1,
        0xa78d, 0xa78d,-1,-42280,
        0xa790, 0xa792, 2, 1,
        0xa796, 0xa7a8, 2, 1,
        0xa7aa, 0xa7aa,-1,-42308,
        0xa7ab, 0xa7ab,-1,-42319,
        0xa7ac, 0xa7ac,-1,-42315,
        0xa7ad, 0xa7ad,-1,-42305,
        0xa7b0, 0xa7b0,-1,-42258,
        0xa7b1, 0xa7b1,-1,-42282,
        0xff21, 0xff3a, 1, 32,
        0x10400, 0x10427, 1, 40,
        0x118a0, 0x118bf, 1, 32
    ])

;; Return the folded-case equivalent of "c", which is a UCS-4 character.  Uses simple case folding.

(defn- #_int utf-fold [#_int c]
    (utf-convert c, foldCase))

(final int* toLower
    [
        0x41, 0x5a, 1, 32,
        0xc0, 0xd6, 1, 32,
        0xd8, 0xde, 1, 32,
        0x100, 0x12e, 2, 1,
        0x130, 0x130,-1,-199,
        0x132, 0x136, 2, 1,
        0x139, 0x147, 2, 1,
        0x14a, 0x176, 2, 1,
        0x178, 0x178,-1,-121,
        0x179, 0x17d, 2, 1,
        0x181, 0x181,-1, 210,
        0x182, 0x184, 2, 1,
        0x186, 0x186,-1, 206,
        0x187, 0x187,-1, 1,
        0x189, 0x18a, 1, 205,
        0x18b, 0x18b,-1, 1,
        0x18e, 0x18e,-1, 79,
        0x18f, 0x18f,-1, 202,
        0x190, 0x190,-1, 203,
        0x191, 0x191,-1, 1,
        0x193, 0x193,-1, 205,
        0x194, 0x194,-1, 207,
        0x196, 0x196,-1, 211,
        0x197, 0x197,-1, 209,
        0x198, 0x198,-1, 1,
        0x19c, 0x19c,-1, 211,
        0x19d, 0x19d,-1, 213,
        0x19f, 0x19f,-1, 214,
        0x1a0, 0x1a4, 2, 1,
        0x1a6, 0x1a6,-1, 218,
        0x1a7, 0x1a7,-1, 1,
        0x1a9, 0x1a9,-1, 218,
        0x1ac, 0x1ac,-1, 1,
        0x1ae, 0x1ae,-1, 218,
        0x1af, 0x1af,-1, 1,
        0x1b1, 0x1b2, 1, 217,
        0x1b3, 0x1b5, 2, 1,
        0x1b7, 0x1b7,-1, 219,
        0x1b8, 0x1bc, 4, 1,
        0x1c4, 0x1c4,-1, 2,
        0x1c5, 0x1c5,-1, 1,
        0x1c7, 0x1c7,-1, 2,
        0x1c8, 0x1c8,-1, 1,
        0x1ca, 0x1ca,-1, 2,
        0x1cb, 0x1db, 2, 1,
        0x1de, 0x1ee, 2, 1,
        0x1f1, 0x1f1,-1, 2,
        0x1f2, 0x1f4, 2, 1,
        0x1f6, 0x1f6,-1,-97,
        0x1f7, 0x1f7,-1,-56,
        0x1f8, 0x21e, 2, 1,
        0x220, 0x220,-1,-130,
        0x222, 0x232, 2, 1,
        0x23a, 0x23a,-1, 10795,
        0x23b, 0x23b,-1, 1,
        0x23d, 0x23d,-1,-163,
        0x23e, 0x23e,-1, 10792,
        0x241, 0x241,-1, 1,
        0x243, 0x243,-1,-195,
        0x244, 0x244,-1, 69,
        0x245, 0x245,-1, 71,
        0x246, 0x24e, 2, 1,
        0x370, 0x372, 2, 1,
        0x376, 0x376,-1, 1,
        0x37f, 0x37f,-1, 116,
        0x386, 0x386,-1, 38,
        0x388, 0x38a, 1, 37,
        0x38c, 0x38c,-1, 64,
        0x38e, 0x38f, 1, 63,
        0x391, 0x3a1, 1, 32,
        0x3a3, 0x3ab, 1, 32,
        0x3cf, 0x3cf,-1, 8,
        0x3d8, 0x3ee, 2, 1,
        0x3f4, 0x3f4,-1,-60,
        0x3f7, 0x3f7,-1, 1,
        0x3f9, 0x3f9,-1,-7,
        0x3fa, 0x3fa,-1, 1,
        0x3fd, 0x3ff, 1,-130,
        0x400, 0x40f, 1, 80,
        0x410, 0x42f, 1, 32,
        0x460, 0x480, 2, 1,
        0x48a, 0x4be, 2, 1,
        0x4c0, 0x4c0,-1, 15,
        0x4c1, 0x4cd, 2, 1,
        0x4d0, 0x52e, 2, 1,
        0x531, 0x556, 1, 48,
        0x10a0, 0x10c5, 1, 7264,
        0x10c7, 0x10cd, 6, 7264,
        0x1e00, 0x1e94, 2, 1,
        0x1e9e, 0x1e9e,-1,-7615,
        0x1ea0, 0x1efe, 2, 1,
        0x1f08, 0x1f0f, 1,-8,
        0x1f18, 0x1f1d, 1,-8,
        0x1f28, 0x1f2f, 1,-8,
        0x1f38, 0x1f3f, 1,-8,
        0x1f48, 0x1f4d, 1,-8,
        0x1f59, 0x1f5f, 2,-8,
        0x1f68, 0x1f6f, 1,-8,
        0x1f88, 0x1f8f, 1,-8,
        0x1f98, 0x1f9f, 1,-8,
        0x1fa8, 0x1faf, 1,-8,
        0x1fb8, 0x1fb9, 1,-8,
        0x1fba, 0x1fbb, 1,-74,
        0x1fbc, 0x1fbc,-1,-9,
        0x1fc8, 0x1fcb, 1,-86,
        0x1fcc, 0x1fcc,-1,-9,
        0x1fd8, 0x1fd9, 1,-8,
        0x1fda, 0x1fdb, 1,-100,
        0x1fe8, 0x1fe9, 1,-8,
        0x1fea, 0x1feb, 1,-112,
        0x1fec, 0x1fec,-1,-7,
        0x1ff8, 0x1ff9, 1,-128,
        0x1ffa, 0x1ffb, 1,-126,
        0x1ffc, 0x1ffc,-1,-9,
        0x2126, 0x2126,-1,-7517,
        0x212a, 0x212a,-1,-8383,
        0x212b, 0x212b,-1,-8262,
        0x2132, 0x2132,-1, 28,
        0x2160, 0x216f, 1, 16,
        0x2183, 0x2183,-1, 1,
        0x24b6, 0x24cf, 1, 26,
        0x2c00, 0x2c2e, 1, 48,
        0x2c60, 0x2c60,-1, 1,
        0x2c62, 0x2c62,-1,-10743,
        0x2c63, 0x2c63,-1,-3814,
        0x2c64, 0x2c64,-1,-10727,
        0x2c67, 0x2c6b, 2, 1,
        0x2c6d, 0x2c6d,-1,-10780,
        0x2c6e, 0x2c6e,-1,-10749,
        0x2c6f, 0x2c6f,-1,-10783,
        0x2c70, 0x2c70,-1,-10782,
        0x2c72, 0x2c75, 3, 1,
        0x2c7e, 0x2c7f, 1,-10815,
        0x2c80, 0x2ce2, 2, 1,
        0x2ceb, 0x2ced, 2, 1,
        0x2cf2, 0xa640, 31054, 1,
        0xa642, 0xa66c, 2, 1,
        0xa680, 0xa69a, 2, 1,
        0xa722, 0xa72e, 2, 1,
        0xa732, 0xa76e, 2, 1,
        0xa779, 0xa77b, 2, 1,
        0xa77d, 0xa77d,-1,-35332,
        0xa77e, 0xa786, 2, 1,
        0xa78b, 0xa78b,-1, 1,
        0xa78d, 0xa78d,-1,-42280,
        0xa790, 0xa792, 2, 1,
        0xa796, 0xa7a8, 2, 1,
        0xa7aa, 0xa7aa,-1,-42308,
        0xa7ab, 0xa7ab,-1,-42319,
        0xa7ac, 0xa7ac,-1,-42315,
        0xa7ad, 0xa7ad,-1,-42305,
        0xa7b0, 0xa7b0,-1,-42258,
        0xa7b1, 0xa7b1,-1,-42282,
        0xff21, 0xff3a, 1, 32,
        0x10400, 0x10427, 1, 40,
        0x118a0, 0x118bf, 1, 32
    ])

(final int* toUpper
    [
        0x61, 0x7a, 1,-32,
        0xb5, 0xb5,-1, 743,
        0xe0, 0xf6, 1,-32,
        0xf8, 0xfe, 1,-32,
        0xff, 0xff,-1, 121,
        0x101, 0x12f, 2,-1,
        0x131, 0x131,-1,-232,
        0x133, 0x137, 2,-1,
        0x13a, 0x148, 2,-1,
        0x14b, 0x177, 2,-1,
        0x17a, 0x17e, 2,-1,
        0x17f, 0x17f,-1,-300,
        0x180, 0x180,-1, 195,
        0x183, 0x185, 2,-1,
        0x188, 0x18c, 4,-1,
        0x192, 0x192,-1,-1,
        0x195, 0x195,-1, 97,
        0x199, 0x199,-1,-1,
        0x19a, 0x19a,-1, 163,
        0x19e, 0x19e,-1, 130,
        0x1a1, 0x1a5, 2,-1,
        0x1a8, 0x1ad, 5,-1,
        0x1b0, 0x1b4, 4,-1,
        0x1b6, 0x1b9, 3,-1,
        0x1bd, 0x1bd,-1,-1,
        0x1bf, 0x1bf,-1, 56,
        0x1c5, 0x1c5,-1,-1,
        0x1c6, 0x1c6,-1,-2,
        0x1c8, 0x1c8,-1,-1,
        0x1c9, 0x1c9,-1,-2,
        0x1cb, 0x1cb,-1,-1,
        0x1cc, 0x1cc,-1,-2,
        0x1ce, 0x1dc, 2,-1,
        0x1dd, 0x1dd,-1,-79,
        0x1df, 0x1ef, 2,-1,
        0x1f2, 0x1f2,-1,-1,
        0x1f3, 0x1f3,-1,-2,
        0x1f5, 0x1f9, 4,-1,
        0x1fb, 0x21f, 2,-1,
        0x223, 0x233, 2,-1,
        0x23c, 0x23c,-1,-1,
        0x23f, 0x240, 1, 10815,
        0x242, 0x247, 5,-1,
        0x249, 0x24f, 2,-1,
        0x250, 0x250,-1, 10783,
        0x251, 0x251,-1, 10780,
        0x252, 0x252,-1, 10782,
        0x253, 0x253,-1,-210,
        0x254, 0x254,-1,-206,
        0x256, 0x257, 1,-205,
        0x259, 0x259,-1,-202,
        0x25b, 0x25b,-1,-203,
        0x25c, 0x25c,-1, 42319,
        0x260, 0x260,-1,-205,
        0x261, 0x261,-1, 42315,
        0x263, 0x263,-1,-207,
        0x265, 0x265,-1, 42280,
        0x266, 0x266,-1, 42308,
        0x268, 0x268,-1,-209,
        0x269, 0x269,-1,-211,
        0x26b, 0x26b,-1, 10743,
        0x26c, 0x26c,-1, 42305,
        0x26f, 0x26f,-1,-211,
        0x271, 0x271,-1, 10749,
        0x272, 0x272,-1,-213,
        0x275, 0x275,-1,-214,
        0x27d, 0x27d,-1, 10727,
        0x280, 0x283, 3,-218,
        0x287, 0x287,-1, 42282,
        0x288, 0x288,-1,-218,
        0x289, 0x289,-1,-69,
        0x28a, 0x28b, 1,-217,
        0x28c, 0x28c,-1,-71,
        0x292, 0x292,-1,-219,
        0x29e, 0x29e,-1, 42258,
        0x345, 0x345,-1, 84,
        0x371, 0x373, 2,-1,
        0x377, 0x377,-1,-1,
        0x37b, 0x37d, 1, 130,
        0x3ac, 0x3ac,-1,-38,
        0x3ad, 0x3af, 1,-37,
        0x3b1, 0x3c1, 1,-32,
        0x3c2, 0x3c2,-1,-31,
        0x3c3, 0x3cb, 1,-32,
        0x3cc, 0x3cc,-1,-64,
        0x3cd, 0x3ce, 1,-63,
        0x3d0, 0x3d0,-1,-62,
        0x3d1, 0x3d1,-1,-57,
        0x3d5, 0x3d5,-1,-47,
        0x3d6, 0x3d6,-1,-54,
        0x3d7, 0x3d7,-1,-8,
        0x3d9, 0x3ef, 2,-1,
        0x3f0, 0x3f0,-1,-86,
        0x3f1, 0x3f1,-1,-80,
        0x3f2, 0x3f2,-1, 7,
        0x3f3, 0x3f3,-1,-116,
        0x3f5, 0x3f5,-1,-96,
        0x3f8, 0x3fb, 3,-1,
        0x430, 0x44f, 1,-32,
        0x450, 0x45f, 1,-80,
        0x461, 0x481, 2,-1,
        0x48b, 0x4bf, 2,-1,
        0x4c2, 0x4ce, 2,-1,
        0x4cf, 0x4cf,-1,-15,
        0x4d1, 0x52f, 2,-1,
        0x561, 0x586, 1,-48,
        0x1d79, 0x1d79,-1, 35332,
        0x1d7d, 0x1d7d,-1, 3814,
        0x1e01, 0x1e95, 2,-1,
        0x1e9b, 0x1e9b,-1,-59,
        0x1ea1, 0x1eff, 2,-1,
        0x1f00, 0x1f07, 1, 8,
        0x1f10, 0x1f15, 1, 8,
        0x1f20, 0x1f27, 1, 8,
        0x1f30, 0x1f37, 1, 8,
        0x1f40, 0x1f45, 1, 8,
        0x1f51, 0x1f57, 2, 8,
        0x1f60, 0x1f67, 1, 8,
        0x1f70, 0x1f71, 1, 74,
        0x1f72, 0x1f75, 1, 86,
        0x1f76, 0x1f77, 1, 100,
        0x1f78, 0x1f79, 1, 128,
        0x1f7a, 0x1f7b, 1, 112,
        0x1f7c, 0x1f7d, 1, 126,
        0x1f80, 0x1f87, 1, 8,
        0x1f90, 0x1f97, 1, 8,
        0x1fa0, 0x1fa7, 1, 8,
        0x1fb0, 0x1fb1, 1, 8,
        0x1fb3, 0x1fb3,-1, 9,
        0x1fbe, 0x1fbe,-1,-7205,
        0x1fc3, 0x1fc3,-1, 9,
        0x1fd0, 0x1fd1, 1, 8,
        0x1fe0, 0x1fe1, 1, 8,
        0x1fe5, 0x1fe5,-1, 7,
        0x1ff3, 0x1ff3,-1, 9,
        0x214e, 0x214e,-1,-28,
        0x2170, 0x217f, 1,-16,
        0x2184, 0x2184,-1,-1,
        0x24d0, 0x24e9, 1,-26,
        0x2c30, 0x2c5e, 1,-48,
        0x2c61, 0x2c61,-1,-1,
        0x2c65, 0x2c65,-1,-10795,
        0x2c66, 0x2c66,-1,-10792,
        0x2c68, 0x2c6c, 2,-1,
        0x2c73, 0x2c76, 3,-1,
        0x2c81, 0x2ce3, 2,-1,
        0x2cec, 0x2cee, 2,-1,
        0x2cf3, 0x2cf3,-1,-1,
        0x2d00, 0x2d25, 1,-7264,
        0x2d27, 0x2d2d, 6,-7264,
        0xa641, 0xa66d, 2,-1,
        0xa681, 0xa69b, 2,-1,
        0xa723, 0xa72f, 2,-1,
        0xa733, 0xa76f, 2,-1,
        0xa77a, 0xa77c, 2,-1,
        0xa77f, 0xa787, 2,-1,
        0xa78c, 0xa791, 5,-1,
        0xa793, 0xa797, 4,-1,
        0xa799, 0xa7a9, 2,-1,
        0xff41, 0xff5a, 1,-32,
        0x10428, 0x1044f, 1,-40,
        0x118c0, 0x118df, 1,-32
    ])

;; Return the lower-case equivalent of "c", which is a UCS-4 character.  Use simple case folding.

(defn- #_int utf-tolower [#_int c]
    (if (< c 0x80) (asc_tolower c) (utf-convert c, toLower)))

;; Return the upper-case equivalent of "c", which is a UCS-4 character.  Use simple case folding.

(defn- #_int utf-toupper [#_int c]
    (if (< c 0x80) (asc_toupper c) (utf-convert c, toUpper)))

(defn- #_boolean utf-islower [#_int c]
    (if (< c 0x80) (asc-islower c) (or (!= (utf-toupper c) c) (== c 0xdf)))) ;; German sharp s is lower case but has no upper case equivalent.

(defn- #_boolean utf-isupper [#_int c]
    (if (< c 0x80) (asc-isupper c) (!= (utf-tolower c) c)))

(defn- #_int us--strnicmp [#_Bytes _s1, #_Bytes _s2, #_int _n1, #_int _n2]
    (let [a's1 (atom (#_Bytes object _s1)) a'n1 (atom (int _n1))
          a's2 (atom (#_Bytes object _s2)) a'n2 (atom (int _n2))
          [#_int c1 #_int c2 #_int cmp]
            (loop [] (let [c1 (us-safe-read-char-adv a's1, a'n1) c2 (us-safe-read-char-adv a's2, a'n2)]
                (cond
                    (or (<= c1 0) (<= c2 0)) [c1 c2 nil]
                    (== c1 c2) (recur)
                    :else (let [cmp (- (utf-fold c1) (utf-fold c2))] (if (zero? cmp) (recur) [c1 c2 cmp]))
                )
            ))]
        (cond (some? cmp)
            cmp
        (or (zero? c1) (zero? c2)) ;; some string ended: shorter string is smaller
            (if (and (zero? c1) (zero? c2)) 0 (if (zero? c1) -1 1))
        :else ;; some string has an incomplete/illegal character sequence
            (do
                ;; Continue with bytewise comparison to produce some result that
                ;; would make comparison operations involving this function transitive.
                ;;
                ;; If only one string had an error, comparison should be made with
                ;; folded version of the other string.  In this case it is enough
                ;; to fold just one character to determine the result of comparison.

                (let [#_Bytes buf (Bytes. 6)]
                    (cond
                        (and (!= c1 -1) (== c2 -1)) (do (reset! a'n1 (utf-char2bytes (utf-fold c1), buf)) (reset! a's1 buf))
                        (and (!= c2 -1) (== c1 -1)) (do (reset! a'n2 (utf-char2bytes (utf-fold c2), buf)) (reset! a's2 buf))
                    ))

                (let [cmp (loop-when [] (and (< 0 @a'n1) (< 0 @a'n2) (non-eos? @a's1) (non-eos? @a's2)) => nil
                            (let [cmp (- (.at @a's1 0) (.at @a's2 0))]
                                (if (zero? cmp) (do (swap! a's1 plus 1) (swap! a's2 plus 1) (swap! a'n1 dec) (swap! a'n2 dec) (recur)) cmp)
                            ))]
                    (if (some? cmp)
                        cmp
                        (do
                            (when (and (< 0 @a'n1) (eos? @a's1)) (reset! a'n1 0))
                            (when (and (< 0 @a'n2) (eos? @a's2)) (reset! a'n2 0))
                            (if (and (zero? @a'n1) (zero? @a'n2)) 0 (if (zero? @a'n1) -1 1)))
                    ))
            ))
    ))

;; Version of strnicmp() that handles multi-byte characters.
;; Needed for Big5, Shift-JIS and UTF-8 encoding.
;; Returns zero if s1 and s2 are equal (ignoring case),
;; the difference between two characters otherwise.

(defn- #_int us-strnicmp [#_Bytes s1, #_Bytes s2, #_int nn]
    (us--strnicmp s1, s2, nn, nn))

;; "g8": show bytes of the UTF-8 char under the cursor.

(defn- #_window_C show-utf8 [#_window_C win]
    (let [#_Bytes s (ml-get-cursor win) #_int n (us-ptr2len-cc s)]
        (if (zero? n)
            (msg win, (u8 "NUL"))
            (let [#_Bytes buf (Bytes. IOSIZE)]
                (loop-when [#_int clen 0 #_int rlen 0 #_int i 0] (< i n)
                    (let [[clen rlen]
                            (if (zero? clen) ;; start of (composing) character, get its length
                                [(us-ptr2len s, i) (if (< 0 i) (do (STRCPY (.plus buf rlen), (u8 "+ ")) (+ rlen 2)) rlen)]
                                [clen rlen]
                            )]
                        (ร .sprintf libC (.plus buf rlen), (u8 "%02x "), (if (at? s i NL) NUL (.at s i))) ;; NUL is stored as NL
                        (let [rlen (+ rlen (STRLEN buf, rlen))]
                            (when-not (< (- IOSIZE 20) rlen) (recur (dec clen) rlen (inc i))))
                    ))
                (msg win, buf)
            ))
    ))

(defn- #_int us-head-off [#_Bytes base, #_Bytes p]
    (if (< (char_u (.at p 0)) 0x80)        ;; be quick for ASCII
        0
        ;; Skip backwards over trailing bytes: 10xx.xxxx.
        ;; Skip backwards again if on a composing char.
        (loop [#_Bytes q p]
            ;; Move 's' to the last byte of this char.
            (let [#_Bytes s (loop-when-recur [s q] (== (& (char_u (.at s 1)) 0xc0) 0x80) [(.plus s 1)] => s)
                  ;; Move 'q' to the first byte of this char.
                  q (loop-when-recur q (and (BLT base, q) (== (& (char_u (.at q 0)) 0xc0) 0x80)) [(.minus q 1)] => q)
                  ;; Check for illegal sequence.  Do allow an illegal byte after where we started.
                  #_int n (us-byte2len (.at q 0), false)]
                (cond
                    (and (!= n (inc (BDIFF s, q))) (!= n (inc (BDIFF p, q)))) 0
                    (or (BLE q, base) (not (utf-iscomposing (us-ptr2char q)))) (BDIFF p, q)
                    :else (recur (.minus q 1))
                ))
        )
    ))

;; Return the offset from "p" to the first byte of a character.  When "p" is
;; at the start of a character 0 is returned, otherwise the offset to the next
;; character.  Can start anywhere in a stream of bytes.

(defn- #_int us-off-next [#_Bytes base, #_Bytes p]
    (if (< (char_u (.at p 0)) 0x80)        ;; be quick for ASCII
        0
        ;; Find the next character that isn't 10xx.xxxx.
        (let-when [#_int i (loop-when-recur [i 0] (== (& (char_u (.at p i)) 0xc0) 0x80) [(inc i)] => i)] (< 0 i) => i
            ;; Check for illegal sequence.
            (let [#_int j (loop-when-recur [j 0] (and (BLT base, (.minus p j)) (== (& (char_u (.at p (- j))) 0xc0) 0x80)) [(inc j)] => j)]
                (if (== (us-byte2len (.at p (- j)), false) (+ i j)) i 0)
            ))
    ))

;; Return the offset from "p" to the last byte of the character it points into.
;; Can start anywhere in a stream of bytes.

(defn- #_int us-tail-off [#_Bytes base, #_Bytes p]
    (if (eos? p)
        0
        ;; Find the last character that is 10xx.xxxx.
        (let [#_int i (loop-when-recur [i 0] (== (& (char_u (.at p (inc i))) 0xc0) 0x80) [(inc i)] => i)
              ;; Check for illegal sequence.
              #_int j (loop-when-recur [j 0] (and (BLT base, (.minus p j)) (== (& (char_u (.at p (- j))) 0xc0) 0x80)) [(inc j)] => j)]
            (if (== (us-byte2len (.at p (- j)), false) (+ i j 1)) i 0)
        )
    ))

;; Find the next illegal byte sequence.

(defn- #_window_C utf-find-illegal [#_window_C win]
    (let-when [lmax (line-count @curbuf)
        win' (loop [lnum (:lnum (:w_cursor win)) col (:col (:w_cursor win))]
                (let-when [s (ml-get lnum)
                    win' (loop-when [i col] (non-eos? s i) => nil
                            ;; Illegal means that there are not enough trail bytes or too many of them (overlong sequence).
                            (let [n (us-ptr2len s, i)]
                                (if (and (<= 0x80 (char_u (.at s i))) (or (== n 1) (!= (utf-char2len (us-ptr2char s, i)) n)))
                                    (assoc win :w_cursor (pos_C. lnum i 0))
                                    (recur (+ i n))
                                ))
                        )] (nil? win') => win'
                    (recur-if (< lnum lmax) [(inc lnum) 0] => nil))
            )] (nil? win') => win'
        ;; didn't find it: don't move and beep
        (beep-flush win)
    ))

;; Adjust position to point to the first byte of a multi-byte character.
;; If it points to the tail byte, it's moved backwards to the head byte.

(defn- #_pos_C mb-adjust-pos [#_pos_C pos]
    (if (or (< 0 (:col pos)) (< 1 (:coladd pos)))
        (let [#_Bytes s (ml-get (:lnum pos)) pos (update pos :col #(- % (us-head-off s, (.plus s %))))]
            ;; Reset "coladd" when the cursor would be on the right half of a double-wide character.
            (if (and (== (:coladd pos) 1) (not-at? s (:col pos) TAB) (vim-isprintc (us-ptr2char s, (:col pos))) (< 1 (mb-ptr2cells s, (:col pos))))
                (assoc pos :coladd 0)
                pos
            ))
        pos
    ))

;; Backup multi-byte pointer.  Only use with "base" < "p" !
(defn- #_int us-ptr-back [#_Bytes base, #_Bytes p]
    (inc (us-head-off base, (.minus p 1))))

;; Return a pointer to the character before "*p", if there is one.

(defn- #_Bytes us-prevptr [#_Bytes base, #_Bytes p]
    ;; base: start of the string
    (if (BLT base, p) (.minus p (us-ptr-back base, p)) p))

;; Return the character length of "s".
;; Each multi-byte character (with following composing characters) counts as one.

(defn- #_int us-charlen [#_Bytes s]
    (if (some? s) (loop-when-recur [#_int n 0 i 0] (non-eos? s i) [(inc n) (+ i (us-ptr2len-cc s, i))] => n) 0))

;; Return true if the character at "row"/"col" on the screen
;; is the left side of a double-width character.
;; Caller must make sure "row" and "col" are not invalid!

(defn- #_boolean mb-lefthalve [#_int row, #_int col]
    (let [offset (aget @lineOffset row)]
        (< 1 (utf-off2cells (+ offset col), (+ offset @screenCols)))
    ))

;; Correct a position on the screen,
;; if it's the right half of a double-wide char move it to the left half.
;; Returns the corrected column.

(defn- #_int mb-fix-col [#_int col, #_int row]
    (let [col (check-col col) row (check-row row)]
        (if (and (some? @screenLines) (< 0 col) (at? @screenLines (+ (aget @lineOffset row) col) 0)) (dec col) col)
    ))

;; misc.c: functions that didn't seem to fit elsewhere --------------------------------------------

;; Count the size (in window cells) of the indent in the current line.

(defn- #_int get-indent [#_window_C win]
    (get-indent-str (ml-get (:lnum (:w_cursor win))), @(:b_p_ts @curbuf)))

;; Count the size (in window cells) of the indent in line "s", with 'tabstop' at "ts".

(defn- #_int get-indent-str [#_Bytes s, #_int ts]
    (loop-when [#_int n 0 i 0] (non-eos? s i) => n
        (cond (at? s i TAB)
            (recur (+ n (- ts (% n ts))) (inc i))   ;; count a tab for what it is worth
        (at? s i (byte \space))
            (recur (inc n) (inc i))                 ;; count a space for one
        :else
            n)
    ))

;; Set the indent of the current line.
;; Leaves the cursor on the first non-blank in the line.
;; Caller must take care of undo.
;; "flags":
;;      SIN_CHANGED:    call changed-bytes() if the line was changed.
;;      SIN_INSERT:     insert the indent in front of the line.
;;      SIN_UNDO:       save line for undo before changing it.
;; Returns true if the line was changed.

(defn- #_[window_C boolean] set-indent? [#_window_C win, #_int size, #_int flags]
    ;; size: measured in spaces
    (let-when [ts @(:b_p_ts @curbuf) et @(:b_p_et @curbuf) pi @(:b_p_pi @curbuf) curl (ml-get (:lnum (:w_cursor win))) ins? (flag? flags SIN_INSERT)
          #_boolean f! false
          #_int oi -1           ;; number of initial whitespace chars when 'et' and 'pi' are both set
          #_int n size
          #_int m 0             ;; measured in spaces
          #_int i 0             ;; measured in characters
          #_Bytes s curl
          ;; If 'expandtab' isn't set: use TABs;
          ;; if both 'expandtab' and 'preserveindent' are set: count the number of chars at the beginning of the line to be copied.
          [f! oi n m i s]
            (if (or (not et) (and (not ins?) pi))
                ;; If 'preserveindent' is set, then reuse as much as possible of the existing indent structure for the new indent.
                (let [[f! oi n m i s]
                        (if (and (not ins?) pi)
                            (let [[n m i s]
                                    (loop-when [n n m 0 i i s s] (and (< 0 n) (vim-iswhite (.at s 0))) => [n m i s]
                                        (let [#_int k (if (at? s TAB) (let [#_int t (- ts (% m ts))] (if (< n t) nil t)) 1)] ;; stop if this tab will overshoot the target
                                            (recur-if (some? k) [(- n k) (+ m k) (inc i) (.plus s 1)] => [n m i s])          ;; count as many characters as we can use
                                        ))
                                  ;; Set initial number of whitespace chars to copy if we are preserving indent but expandtab is set.
                                  oi (if et i oi)
                                  ;; Fill to next tabstop with a tab, if possible.
                                  [f! n #_m i]
                                    (let [#_int t (- ts (% m ts))] (if (and (<= t n) (== oi -1)) [true (- n t) #_(+ m t) (inc i)] [f! n #_m i]))]
                                [f! oi n m i s])
                            [f! oi n m i s])
                      ;; count tabs required for indent
                      [f! n #_m i s]
                        (loop-when [f! f! n n #_m #_m i i s s] (<= ts n) => [f! n #_m i s]
                            (let [[f! s] (if (not-at? s TAB) [true (.plus s 1)] [f! s])] (recur f! (- n ts) #_(+ m ts) (inc i) s))
                        )]
                    [f! oi n m i s])
                [f! oi n m i s])
          ;; count spaces required for indent
          [f! n #_m i s]
            (loop-when [f! f! n n #_m #_m i i s s] (< 0 n) => [f! n #_m i s]
                (let [[f! s] (if (not-at? s (byte \space)) [true (.plus s 1)] [f! s])] (recur f! (- n 1) #_(+ m 1) (inc i) s))
            )
          ;; Return if the indent is OK already.
          ] (or f! (vim-iswhite (.at s 0)) ins?) => [win false]

        ;; Allocate memory for the new line.
        (let [s (if ins? curl (skipwhite s)) #_int l (inc (STRLEN s))
              ;; If 'preserveindent' and 'expandtab' are both set, keep the original chars and allocate accordingly.
              ;; We will fill the rest with spaces after the (when (not et) ...) below.
              [#_int n i s #_Bytes line #_Bytes p]
                (if (!= oi -1)
                    ;; Set total length of indent in chars, which may have been undercounted until now.
                    (let [n (- size m) i (+ oi n) line (Bytes. (+ (- (+ oi size) m) l))
                          [s p] (loop-when-recur [s curl p line oi oi] (< 0 oi) [(.plus s 1) (.plus p 1) (dec oi)] => [s p]
                                    (.be p 0, (.at s 0)))
                          ;; Skip over any additional white space (useful when new indent is less than old).
                          s (loop-when-recur s (vim-iswhite (.at s 0)) (.plus s 1) => s)]
                        [n i s line p])
                    (let [line (Bytes. (+ i l))] [size i s line line]))
              ;; Put the characters in the new line.
              ;; If 'expandtab' isn't set: use TABs.
              [n s p] (if (not et)
                    ;; If 'preserveindent' is set, reuse as much as possible of the existing indent structure for the new indent.
                    (let [[n s p] (if (and (not ins?) pi)
                                (let [[n int m s p]
                                        (loop-when [n n m 0 s curl p p] (and (< 0 n) (vim-iswhite (.at s 0))) => [n m s p]
                                            ;; stop if this tab will overshoot the target
                                            (let-when [#_int k (if (at? s TAB) (let [#_int t (- ts (% m ts))] (if (< n t) nil t)) 1)] (some? k) => [n m s p]
                                                (.be p 0, (.at s 0)) (recur (- n k) (+ m k) (.plus s 1) (.plus p 1))
                                            ))
                                      ;; Fill to next tabstop with a tab, if possible.
                                      [n p] (let [#_int t (- ts (% m ts))] (if (<= t n) [(- n t) (-> p (.be 0, TAB) (.plus 1))] [n p]))]
                                      [n (skipwhite s) p])
                                [n s p])
                          [n p] (loop-when-recur [n n p p] (<= ts n) [(- n ts) (-> p (.be 0, TAB) (.plus 1))] => [n p])]
                        [n s p])
                    [n s p])
              [n p] (loop-when-recur [n n p p] (< 0 n) [(dec n) (-> p (.be 0, (byte \space)) (.plus 1))] => [n p])]

            (BCOPY p, s, l)

            ;; Replace the line (unless undo fails).
            (let [cln (:lnum (:w_cursor win)) #_boolean ok (or (non-flag? flags SIN_UNDO) (u-savesub win, cln))]
                (when ok
                    (ml-replace cln, line)
                    (when (flag? flags SIN_CHANGED) (changed-bytes cln, 0)))
                [(assoc-in win [:w_cursor :col] i) ok]
            ))
    ))

(defn- #_window_C set-indent [#_window_C win, #_int size, #_int flags]
    (let [[win _] (set-indent? win, size, flags)]
        win
    ))

;; Copy the indent from "src" to the current line (and fill to size).
;; Leaves the cursor on the first non-blank in the line.

(defn- #_window_C copy-indent [#_window_C win, #_int size, #_Bytes src]
    (let [ts @(:b_p_ts @curbuf) et @(:b_p_et @curbuf) be' (fn [p b] (when (some? p) (-> p (.be 0, b) (.plus 1)))) curl (ml-get (:lnum (:w_cursor win))) l' (inc (STRLEN curl))
          ;; Round 1: compute the number of characters needed for the indent.
          ;; Round 2: copy the characters.
          [#_int i #_Bytes line]
            (loop-when [i nil line nil #_Bytes p nil #_int round 0] (< round 2) => [i line]
                (let [[#_int n #_int m i p] ;; Count/copy the usable portion of the source line.
                        (loop-when [n size m 0 i 0 p p #_Bytes s src] (and (< 0 n) (vim-iswhite (.at s 0))) => [n m i p]
                            ;; Stop if this tab will overshoot the target.
                            (let [#_int k (if (at? s TAB) (let [#_int t (- ts (% m ts))] (if (< n t) nil t)) 1)]
                                (recur-if (some? k) [(- n k) (+ m k) (inc i) (be' p (.at s 0)) (.plus s 1)] => [n m i p])
                            ))
                      ;; Fill to next tabstop with a tab, if possible.
                      [n i p] (let [#_int t (- ts (% m ts))] (if (and (<= t n) (not et)) [(- n t) (inc i) (be' p TAB)] [n i p]))
                      ;; Add tabs required for indent.
                      [n i p] (loop-when-recur [n n i i p p] (and (<= ts n) (not et)) [(- n ts) (inc i) (be' p TAB)] => [n i p])
                      ;; Count/add spaces required for indent.
                      [n i p] (loop-when-recur [n n i i p p] (< 0 n) [(dec n) (inc i) (be' p (byte \space))] => [n i p])
                      [line p] (if (nil? p)
                                    ;; Allocate memory for the copied indent, the new indent and the rest of the line.
                                    (let [line (Bytes. (+ i l'))] [line line])
                                    ;; Append the original line.
                                    (do (BCOPY p, curl, l') [line nil])
                                )]
                    (recur i line p (inc round)))
            )]
        ;; Replace the line.
        (ml-replace (:lnum (:w_cursor win)), line)
        ;; Put the cursor after the indent.
        (assoc-in win [:w_cursor :col] i)
    ))

(atom! int      bri_prev_indent)    ;; cached indent value
(atom! long     bri_prev_ts)        ;; cached tabstop value
(atom! Bytes    bri_prev_line)      ;; cached pointer to line
(atom! int      bri_prev_tick)      ;; changedtick of cached value

;; Return appropriate space number for breakindent, taking influencing parameters into account.
;; Window must be specified, since it is not necessarily always the current one.

(defn- #_int get-breakindent [#_window_C win, #_Bytes line]
    ;; window width minus window margin space, i.e. what rests for text
    (let [wops (:w_options win) ts @(:b_p_ts @curbuf) tick (:b_changedtick @curbuf)
          #_int eff_ww (- (:w_width win) (if (and (or @(:wo_nu wops) @(:wo_rnu wops)) (nil? (vim-strbyte @p_cpo, CPO_NUMCOL))) (inc (ร let [[win ?] (number-width? win)] ?)) 0))]
        ;; used cached indent, unless pointer or 'tabstop' changed
        (when (or (BNE @bri_prev_line, line) (!= @bri_prev_ts ts) (!= @bri_prev_tick tick))
            (reset! bri_prev_line line)
            (reset! bri_prev_ts ts)
            (reset! bri_prev_tick tick)
            (reset! bri_prev_indent (get-indent-str line, ts)))
        (let [#_int bri (+ @bri_prev_indent (:w_p_brishift win))
              ;; indent minus the length of the showbreak string
              bri (if (:w_p_brisbr win) (- bri (mb-string2cells @p_sbr)) bri)
              ;; add offset for number column, if 'n' is in 'cpoptions'
              bri (+ bri (win-col-off2 win))]
            (cond
                ;; never indent past left window margin
                (< bri 0) 0
                ;; always leave at least 'brimin' characters on the left, if text width is sufficient
                (< (- eff_ww (:w_p_brimin win)) bri) (max 0 (- eff_ww (:w_p_brimin win)))
                :else bri
            ))
    ))

;; Return true if the string "line" starts with a word from 'cinwords'.

(defn- #_boolean cin-is-cinword [#_Bytes line]
    (let [line (skipwhite line)
          a'cinw (atom (#_Bytes object @(:b_p_cinw @curbuf))) #_int size (inc (STRLEN @a'cinw)) #_Bytes word (Bytes. size)]
        (loop-when [] (non-eos? @a'cinw) => false
            (let [#_int n (copy-option-part a'cinw, word, size, (u8 ","))]
                (recur-if (or (non-zero? (STRNCMP line, word, n)) (and (us-iswordb (.at line n)) (us-iswordb (.at line (dec n))))) [] => true)
            ))
    ))

;; Add a new line below or above the current line.
;;
;; For VREPLACE mode, we only add a new line when we get to the end of the file,
;; otherwise we just start replacing the next line.
;;
;; Caller must take care of undo.  Since VREPLACE may affect any number of lines however,
;; it may call u-save-cursor() again when starting to change a new line.
;;
;; "second_line_indent": indent for after ^^D in Insert mode
;;
;; Return true for success, false for failure.

(defn- #_[window_C boolean] open-line? [#_window_C win, #_int dir, #_int flags, #_int second_line_indent]
    ;; dir: FORWARD or BACKWARD
    (let [#_boolean do_si (and (not @p_paste) @(:b_p_si @curbuf))
          ;; make a copy of the current line so we can mess with it
          #_Bytes saved_line (STRDUP (ml-get (:lnum (:w_cursor win))))
          #_Bytes next_line
            (when (flag? @State VREPLACE_FLAG)
                ;; With VREPLACE we make a copy of the next line, which we will be starting to replace.
                ;; First make the new line empty and let vim play with the indenting and comment leader
                ;; to its heart's content.  Then we grab what it ended up putting on the new line, put
                ;; back the original line, and call ins-char() to put each new character onto the line,
                ;; replacing what was there before and pushing the right stuff onto the replace stack.
                (let [lnum (:lnum (:w_cursor win)) col (:col (:w_cursor win))
                      next_line (STRDUP (if (< lnum @orig_line_count) (ml-get (inc lnum)) (u8 "")))]
                    ;; In VREPLACE mode, a NL replaces the rest of the line, and starts replacing the next line,
                    ;; so push all of the characters left on the line onto the replace stack.  We'll push any other
                    ;; characters that might be replaced at the start of the next line (due to autoindent, etc.)
                    ;; a bit later.
                    (replace-push NUL)      ;; call twice because BS over NL expects it
                    (replace-push NUL)
                    (loop-when-recur [#_Bytes s (.plus saved_line col)] (non-eos? s) [(.plus s (replace-push-mb s))] => (eos! saved_line col))
                    next_line
                ))
          [#_Bytes p_extra #_int first_char #_int saved_char]
            (if (and (flag? @State INSERT) (non-flag? @State VREPLACE_FLAG))
                (let [p_extra (.plus saved_line (:col (:w_cursor win)))
                      first_char (if do_si (.at (skipwhite p_extra) 0) NUL) ;; need first char after new line break
                      saved_char (.at p_extra 0)]
                    [(eos! p_extra) first_char saved_char])
                [nil NUL NUL]
            )]
        (u-clearline)              ;; cannot do "U" command when adding lines
        (reset! did_si false)
        (reset! ai_col 0)
        ;; If we just did an auto-indent, we didn't type anything on the prior line, and it should be truncated.
        ;; Do this even if 'ai' is not set, because automatically inserting a comment leader also sets did_ai.
        (let [#_boolean trunc_line (and (== dir FORWARD) @did_ai)   ;; truncate current line afterwards
              ;; If 'autoindent' and/or 'smartindent' is set, try to figure out what indent to use for the new line.
              #_int ni 0                ;; auto-indent of the new line
              #_boolean no_si false     ;; reset did_si afterwards
              [win ni no_si]
                (if (or @(:b_p_ai @curbuf) do_si)
                    (let [ni (get-indent-str saved_line, @(:b_p_ts @curbuf)) ;; count white space on current line
                          ni (if (zero? ni) second_line_indent ni) ;; for ^^D command in insert mode
                          ;; Do smart indenting.
                          ;; In insert/replace mode (only when dir == FORWARD) we may move some text to the next line.
                          ;; If it starts with '{', don't add an indent.  Fixes inserting a NL before '{' in line
                          ;;      "if (condition) {"
                          [win ni no_si]
                            (if (and (not trunc_line) do_si (non-eos? saved_line) (or (nil? p_extra) (!= first_char (byte \{))))
                                (let [o'cursor (:w_cursor win) #_Bytes s saved_line
                                      [win ni no_si]
                                        (cond (== dir FORWARD)
                                            (let [[win s ni] ;; Skip preprocessor directives, unless they are recognised as comments.
                                                    (if (at? s (byte \#))
                                                        (let [[win s] (loop-when [win win s s] (and (at? s (byte \#)) (< 1 (:lnum (:w_cursor win)))) => [win s]
                                                                    (let [win (update-in win [:w_cursor :lnum] dec)]
                                                                        (recur win (ml-get (:lnum (:w_cursor win)))))
                                                                )]
                                                            [win s (get-indent win)])
                                                        [win s ni])
                                                  ;; Find last non-blank in line.
                                                  #_Bytes p (loop-when-recur [p (.plus s (dec (STRLEN s)))] (and (BLT s, p) (vim-iswhite (.at p 0))) (.minus p 1) => p)
                                                  #_byte last_char (.at p 0)
                                                  ;; find the character just before the '{' or ';'
                                                  p (if (any == last_char (byte \{) (byte \;))
                                                        (loop-when-recur [p (if (BLT s, p) (.minus p 1) p)] (and (BLT s, p) (vim-iswhite (.at p 0))) (.minus p 1) => p)
                                                        p)
                                                  ;; Try to catch lines that are split over multiple lines.
                                                  ;;  e.g.:
                                                  ;;      if (condition &&
                                                  ;;                  condition) {
                                                  ;;          Should line up here!
                                                  ;;      }
                                                  [win s ni]
                                                    (if (at? p (byte \)))
                                                        (let [win (assoc-in win [:w_cursor :col] (BDIFF p, s)) #_pos_C pos (findmatch win, (byte \())]
                                                            (if (some? pos)
                                                                (let [win (assoc-in win [:w_cursor :lnum] (:lnum pos))]
                                                                    [win (ml-get (:lnum (:w_cursor win))) (get-indent win)])
                                                                [win s ni]
                                                            ))
                                                        [win s ni])
                                                  ;; If last character is '{' do indent, without checking for "if" and the like.
                                                  no_si
                                                    (cond (== last_char (byte \{))
                                                        (do (reset! did_si true) true) ;; do indent ;; don't delete it when '{' typed
                                                    ;; Look for "if" and the like, use 'cinwords'.
                                                    ;; Don't do this if the previous line ended in ';' or '}'.
                                                    (and (!= last_char (byte \;)) (!= last_char (byte \})) (cin-is-cinword s))
                                                        (do (reset! did_si true) no_si)
                                                    :else
                                                        no_si
                                                    )]
                                                [win ni no_si])
                                        :else ;; (== dir BACKWARD)
                                            (let [[win s ni] ;; Skip preprocessor directives, unless they are recognised as comments.
                                                    (if (at? s (byte \#))
                                                        (let [lmax (line-count @curbuf)
                                                              [win s #_boolean ?]
                                                                (loop-when [win win s s ? false] (and (or (at? s (byte \#)) ?) (< (:lnum (:w_cursor win)) lmax)) => [win s ?]
                                                                    (let [? (and (non-eos? s) (at? s (dec (STRLEN s)) (byte \\)))
                                                                          win (update-in win [:w_cursor :lnum] inc)]
                                                                        (recur win (ml-get (:lnum (:w_cursor win))) ?))
                                                                )]
                                                            [win s (if ? 0 (get-indent win))])
                                                        [win s ni]
                                                    )]
                                                (if (at? (skipwhite s) (byte \}))
                                                    (reset! did_si true)            ;; line starts with '}': do indent
                                                    (reset! can_si_back true))      ;; can delete indent when '{' typed
                                                [win ni no_si])
                                        )]
                                    [(assoc win :w_cursor o'cursor) ni no_si])
                                [win ni no_si]
                            )]
                        (when do_si
                            (reset! can_si true))
                        (reset! did_ai true)
                        [win ni no_si])
                    [win ni no_si]
                )]

            (let [p_extra
                    (if (some? p_extra)
                        (do (.be p_extra 0, saved_char)          ;; restore char that NUL replaced
                            ;; When 'ai' set, skip to the first non-blank.
                            ;;
                            ;; When in REPLACE mode, put the deleted blanks on the replace stack,
                            ;; preceded by a NUL, so they can be put back when a BS is entered.
                            (when (and (flag? @State REPLACE_FLAG) (non-flag? @State VREPLACE_FLAG))
                                (replace-push NUL))      ;; end of extra blanks
                            (let [p_extra
                                    (if @(:b_p_ai @curbuf)
                                        (loop-when p_extra (and (or (at? p_extra (byte \space)) (at? p_extra TAB)) (not (utf-iscomposing (us-ptr2char p_extra, 1)))) => p_extra
                                            (when (and (flag? @State REPLACE_FLAG) (non-flag? @State VREPLACE_FLAG))
                                                (replace-push (.at p_extra 0)))
                                            (recur (.plus p_extra 1)))
                                        p_extra
                                    )]
                                (when (non-eos? p_extra)
                                    (reset! did_ai false))              ;; append some text, don't truncate now
                                p_extra
                            ))
                        (u8 "") ;; append empty line
                    )]

                (let [o'cursor (:w_cursor win) win (if (== dir BACKWARD) (update-in win [:w_cursor :lnum] dec) win)]
                    (let-when [[win #_boolean did_append]
                            (cond (and (flag? @State VREPLACE_FLAG) (< (:lnum o'cursor) @orig_line_count))
                                ;; In VREPLACE mode we are starting to replace the next line.
                                (let [win (update-in win [:w_cursor :lnum] inc)]
                                    (when (<= (+ (:lnum @insStart) @vr_lines_changed) (:lnum (:w_cursor win)))
                                        ;; In case we NL to a new line, BS to the previous one, and NL
                                        ;; again, we don't want to save the new line for undo twice.
                                        (u-save-cursor win)             ;; errors are ignored!
                                        (swap! vr_lines_changed inc))
                                    (ml-replace (:lnum (:w_cursor win)), p_extra)
                                    (changed-bytes (:lnum (:w_cursor win)), 0)
                                    [(update-in win [:w_cursor :lnum] dec) false])
                            (ml-append (:lnum (:w_cursor win)), p_extra)
                                ;; Postpone calling changed-lines(), because it would mess up folding with markers.
                                [(mark-adjust win, (inc (:lnum (:w_cursor win))), MAXLNUM, 1, 0) true]
                            :else
                                [win nil]
                            )] (some? did_append) => [win false]

                        (let [o'pi @(:b_p_pi @curbuf)
                              [win #_int newcol]
                                (if (or (non-zero? ni) @did_si)
                                    (let [win (update-in win [:w_cursor :lnum] inc)
                                          ni (if @did_si (let [#_int sw (get-sw-value)] (+ (if @p_sr (- ni (% ni sw)) ni) sw)) ni)
                                          win (if @(:b_p_ci @curbuf)
                                                (let [win (copy-indent win, ni, saved_line)]
                                                    ;; Set the 'preserveindent' option so that any further screwing with the line
                                                    ;; doesn't entirely destroy our efforts to preserve it.
                                                    ;; It gets restored at the function end.
                                                    (reset! (:b_p_pi @curbuf) true)
                                                    win)
                                                (set-indent win, ni, SIN_INSERT))]
                                        (reset! ai_col (:col (:w_cursor win)))
                                        ;; In REPLACE mode, for each character in the new indent, there must
                                        ;; be a NUL on the replace stack, for when it is deleted with BS.
                                        (when (and (flag? @State REPLACE_FLAG) (non-flag? @State VREPLACE_FLAG))
                                            (dotimes [_ (:col (:w_cursor win))]
                                                (replace-push NUL)
                                            ))
                                        (when no_si
                                            (reset! did_si false))
                                        [win (:col (:w_cursor win))])
                                    [win 0])
                              win (assoc win :w_cursor o'cursor)
                              [win did_append]
                                (if (== dir FORWARD)
                                    (let [did_append
                                            (if (or trunc_line (flag? @State INSERT))
                                                (let [lnum (:lnum (:w_cursor win)) col (:col (:w_cursor win))]
                                                    ;; Truncate current line at cursor.
                                                    (eos! saved_line col)
                                                    ;; Remove trailing white space.
                                                    (when trunc_line
                                                        (truncate-spaces saved_line))
                                                    (ml-replace lnum, saved_line)
                                                    (if did_append
                                                        (swap! curbuf changed-lines lnum, col, (inc lnum), 1)
                                                        (changed-bytes lnum, col))
                                                    false)
                                                did_append
                                            )]
                                        ;; Put the cursor on the new line.
                                        ;; Careful: the scrollup() above may have moved "w_cursor", we must use "o'cursor".
                                        [(assoc-in win [:w_cursor :lnum] (inc (:lnum o'cursor))) did_append])
                                    [win did_append]
                                )]
                            (when did_append
                                (swap! curbuf changed-lines (:lnum (:w_cursor win)), 0, (:lnum (:w_cursor win)), 1))
                            (let [win (update win :w_cursor assoc :col newcol :coladd 0)
                                  ;; Finally, VREPLACE gets the stuff on the new line, puts back the original line, inserts
                                  ;; the new stuff char by char pushing old stuff onto the replace stack (via ins-char()).
                                  win (if (flag? @State VREPLACE_FLAG)
                                        ;; Put new line in "p_extra".
                                        (let [p_extra (STRDUP (ml-get (:lnum (:w_cursor win))))]
                                            ;; Put back original line.
                                            (ml-replace (:lnum (:w_cursor win)), next_line)
                                            ;; Insert new stuff into line again.
                                            (-> win
                                                (update :w_cursor assoc :col 0 :coladd 0)
                                                (ins-bytes p_extra) ;; will call changed-bytes()
                                            ))
                                        win
                                    )]
                                (reset! (:b_p_pi @curbuf) o'pi)
                                [win true]
                            ))
                    ))
            ))
    ))

;; Return the number of screen rows occupied by buffer line "lnum".

(defn- #_int plines [#_window_C win, #_long lnum, #_boolean limit]
    ;; limit: when true limit to window height
    (if (or (not @(:wo_wrap (:w_options win))) (zero? (:w_width win)))
        1
        (let [n (plines-nowrap win, lnum)]
            (if (and limit (< (:w_height win) n)) (:w_height win) n))
    ))

;; Return the number of screen rows line "lnum" will occupy in window "win".
;; Does not care about 'wrap'.

(defn- #_int plines-nowrap [#_window_C win, #_long lnum]
    (let [#_Bytes s (ml-get lnum)]
        (if (eos? s)     ;; empty line
            1
            (let [col (win-linetabsize win, s, MAXCOL) width (- (:w_width win) (win-col-off win))]
                (cond
                    (<= width 0) 32000
                    (<= col width) 1
                    :else (let [col (- col width) width (+ width (win-col-off2 win))] (inc (/ (+ col (dec width)) width)))
                ))
        )
    ))

;; Like plines(), but only reports the number of screen rows
;; used from the start of the line to the given column number.

(defn- #_int plines-col [#_window_C win, #_long lnum, #_long column]
    (if (or (not @(:wo_wrap (:w_options win))) (zero? (:w_width win)))
        1
        (let [#_Bytes line (ml-get lnum)
              [col s] (loop-when-recur [col 0 s line n column]
                                       (and (non-eos? s) (< 0 n))
                                       [(+ col (win-lbr-chartabsize win, line, s, col, nil)) (.plus s (us-ptr2len-cc s)) (dec n)]
                                    => [col s])
              ;; If s[0] is a TAB, and the TAB is not displayed as ^I, and we're not in INSERT mode,
              ;; then col must be adjusted so that it represents the last screen position of the TAB.
              ;; This only fixes an error when the TAB wraps from one screen line to the next
              ;; (when 'columns' is not a multiple of 'ts').
              col (if (and (at? s TAB) (flag? @State NORMAL)) (+ col (dec (win-lbr-chartabsize win, line, s, col, nil))) col)
              ;; Add column offset for 'number', 'relativenumber', 'foldcolumn', etc.
              width (- (:w_width win) (win-col-off win))]
            (if (< 0 width)
                (if (< width col) (+ 1 (inc (/ (- col width) (+ width (win-col-off2 win))))) 1)
                9999
            ))
    ))

(defn- #_int plines-many [#_window_C win, #_long first, #_long last]
    (loop-when-recur [#_int n 0 #_long i first] (<= i last) [(+ n (plines win, i, true)) (inc i)] => n))

;; Insert string "p" at the cursor position.  Stops at a NUL byte.
;; Handles Replace mode and multi-byte characters.

(defn- #_window_C ins-bytes [#_window_C win, #_Bytes p]
    (ins-bytes-len win, p, (STRLEN p)))

;; Insert string "p" with length "len" at the cursor position.
;; Handles Replace mode and multi-byte characters.

(defn- #_window_C ins-bytes-len [#_window_C win, #_Bytes p, #_int len]
    (loop-when [win win #_int i 0] (< i len) => win
        (let [#_int n (us-ptr2len-cc-len p, i, (- len i))]
            (recur (ins-char-bytes win, (.plus p i), n) (+ i n)))
    ))

;; Insert or replace a single character at the cursor position.
;; When in REPLACE or VREPLACE mode, replace any existing character.
;; Caller must have prepared for undo.
;; For multi-byte characters we get the whole character,
;; the caller must convert bytes to a character.

(defn- #_window_C ins-char [#_window_C win, #_int c]
    (let [#_Bytes buf (Bytes. (inc MB_MAXBYTES)) #_int n (utf-char2bytes c, buf)]
        ;; When "c" is 0x100, 0x200, etc. we don't want to insert a NUL byte.
        ;; Happens for CTRL-Vu9900.
        (when (zero? (.at buf 0))
            (.be buf 0, (byte \newline)))
        (ins-char-bytes win, buf, n)
    ))

(defn- #_window_C ins-char-bytes [#_window_C win, #_Bytes buf, #_int blen]
    ;; Break tabs if needed.
    (let [win (if (and (virtual-active) (< 0 (:coladd (:w_cursor win)))) (coladvance-force win, (getviscol win)) win)
          cln (:lnum (:w_cursor win)) col (:col (:w_cursor win)) o'line (ml-get cln) o'size (inc (STRLEN o'line)) ;; length of old line including NUL
          [#_int olen #_int nlen] ;; nr of bytes deleted (0 when not replacing) ;; nr of bytes inserted
            (if (flag? @State REPLACE_FLAG)
                (let [[olen nlen]
                        (cond (flag? @State VREPLACE_FLAG)
                            ;; In virtual replace mode a char may replace one or more chars (zero if it's a TAB).
                            ;; Count the number of bytes to be deleted to make room for the new character,
                            ;; counting screen cells.  May result in adding spaces to fill a gap.
                            (let [a'vcol (atom (int)) _ (getvcol win, (:w_cursor win), nil, a'vcol, nil)
                                  #_int vcol @a'vcol #_int vcol' (+ vcol (chartabsize buf, vcol))]
                                (loop-when [vcol vcol olen 0 nlen blen] (and (non-eos? o'line (+ col olen)) (< vcol vcol')) => [olen nlen]
                                    (let [vcol (+ vcol (chartabsize o'line, (+ col olen), vcol))]
                                        ;; Don't need to remove a TAB that takes us to the right position.
                                        (if (and (< vcol' vcol) (at? o'line (+ col olen) TAB))
                                            [olen nlen]
                                            ;; Deleted a bit too much, insert spaces.
                                            (recur vcol (+ olen (us-ptr2len-cc o'line, (+ col olen))) (+ nlen (max 0 (- vcol vcol'))))
                                        ))
                                ))
                        (non-eos? o'line col) [(us-ptr2len-cc o'line, col) blen] ;; normal replace
                        :else                 [0 blen])]
                    ;; Push the replaced bytes onto the replace stack, so that they can be put back when BS is used.
                    ;; The bytes of a multi-byte character are done the other way around,
                    ;; so that the first byte is popped off first (it tells the byte length of the character).
                    (replace-push NUL)
                    (loop-when-recur [#_int i 0] (< i olen) [(+ i (replace-push-mb (.plus o'line (+ col i))))])
                    [olen nlen])
                [0 blen])
          #_Bytes line (Bytes. (+ o'size (- nlen olen)))
          _ (when (< 0 col)
                (BCOPY line, o'line, col))                                                  ;; copy bytes before the cursor
          #_Bytes p (.plus line col)
          _ (BCOPY p, nlen, o'line, (+ col olen), (- o'size col olen))                      ;; copy bytes after the changed character(s)
          _ (BCOPY p, buf, blen)                                                            ;; insert or overwrite the new character
          _ (loop-when-recur [#_int i blen] (< i nlen) [(inc i)] (.be p i, (byte \space)))] ;; fill with spaces when necessary
        ;; Replace the line in the buffer.
        (ml-replace cln, line)
        ;; mark the buffer as changed and prepare for displaying
        (changed-bytes cln, col)
        ;; If we're in Insert or Replace mode and 'showmatch' is set, then briefly show the match for right parens and braces.
        (let [win (if (and @p_sm (flag? @State INSERT)) (showmatch win, (us-ptr2char buf)) win)]
            ;; Normal insert: move cursor right.
            (update-in win [:w_cursor :col] + blen))
        ;; TODO: should try to update "w_row" here, to avoid recomputing it later.
    ))

;; Insert a string at the cursor position.
;; Note: Does NOT handle Replace mode.
;; Caller must have prepared for undo.

(defn- #_window_C ins-str [#_window_C win, #_Bytes s]
    (let [win (if (and (virtual-active) (< 0 (:coladd (:w_cursor win)))) (coladvance-force win, (getviscol win)) win)
          cln (:lnum (:w_cursor win)) col (:col (:w_cursor win)) o'line (ml-get cln) o'len (STRLEN o'line)
          #_int n (STRLEN s) #_Bytes line (Bytes. (+ o'len n 1))
          _ (when (< 0 col)
                (BCOPY line, o'line, col))
          _ (BCOPY line, col, s, 0, n)
          _ (BCOPY line, (+ col n), o'line, col, (inc (- o'len col)))]
        (ml-replace cln, line)
        (changed-bytes cln, col)
        (update-in win [:w_cursor :col] + n)
    ))

;; Delete one character under the cursor.
;;
;; If "fixpos" is true, don't leave the cursor on the NUL after the line.
;; Caller must have prepared for undo.
;;
;; Return false for failure, true otherwise.

(defn- #_[window_C boolean] del-char? [#_window_C win, #_boolean fixpos]
    ;; Make sure the cursor is at the start of a character.
    (let-when [win (update win :w_cursor mb-adjust-pos)] (non-eos? (ml-get-cursor win)) => [win false]
        (del-chars? win, 1, fixpos)
    ))

(defn- #_window_C del-char [#_window_C win, #_boolean fixpos]
    (let [[win _] (del-char? win, fixpos)]
        win
    ))

;; Like del-bytes(), but delete characters instead of bytes.

(defn- #_[window_C boolean] del-chars? [#_window_C win, #_int nof, #_boolean fixpos]
    (let [s (ml-get-cursor win) n (loop-when-recur [n 0 i 0] (and (< i nof) (non-eos? s n)) [(+ n (us-ptr2len-cc s, n)) (inc i)] => n)]
        (del-bytes? win, n, fixpos, true)
    ))

(defn- #_window_C del-chars [#_window_C win, #_int nof, #_boolean fixpos]
    (let [[win _] (del-chars? win, nof, fixpos)]
        win
    ))

;; Delete "nof" bytes under the cursor.
;;
;; If "fixpos" is true, don't leave the cursor on the NUL after the line.
;; use_delcombine: 'delcombine' option applies
;; Caller must have prepared for undo.
;;
;; Return false for failure, true otherwise.

(defn- #_[window_C boolean] del-bytes? [#_window_C win, #_int nof, #_boolean fixpos, #_boolean use_delcombine]
    ;; Can't do anything when the cursor is on the NUL after the line.
    (let-when [cln (:lnum (:w_cursor win)) col (:col (:w_cursor win)) o'line (ml-get cln) o'len (STRLEN o'line)] (< col o'len) => [win false]
        ;; If 'delcombine' is set and deleting (less than) one character, only delete the last combining character.
        (let [[col nof fixpos]
                (if (and @p_deco use_delcombine (<= nof (us-ptr2len-cc o'line, col)))
                    (let-when [#_int* cc (int-array MAX_MCO) _ (us-ptr2char-cc (.plus o'line col), cc)] (non-zero? (aget cc 0)) => [col nof fixpos]
                        ;; Find the last composing char, there can be several.
                        (loop [#_int n col]
                            (let [col n nof (us-ptr2len o'line, n) n (+ n nof)]
                                (recur-if (utf-iscomposing (us-ptr2char o'line, n)) [n] => [col nof false]))
                        ))
                    [col nof fixpos])
              ;; When nof is too big, reduce it.
              #_int movelen (inc (- o'len col nof)) ;; includes trailing NUL
              [win nof movelen]
                (if (<= movelen 1)
                    ;; If we just took off the last character of a non-blank line, and fixpos is true, we don't want
                    ;; to end up positioned at the NUL, unless "restart_edit" is set or 'virtualedit' contains "onemore".
                    (let [win (if (and (< 0 col) fixpos (zero? @restart_edit) (non-flag? @ve_flags VE_ONEMORE))
                                (-> win
                                    (update-in [:w_cursor :col] dec)
                                    (assoc-in [:w_cursor :coladd] 0)
                                    (update-in [:w_cursor :col] #(- % (us-head-off o'line, (.plus o'line %)))))
                                win
                            )]
                        [win (- o'len col) 1])
                    [win nof movelen])
              #_Bytes line (Bytes. (- (inc o'len) nof))
              _ (BCOPY line, o'line, col)
              _ (BCOPY line, col, o'line, (+ col nof), movelen)]
            (ml-replace cln, line)
            ;; mark the buffer as changed and prepare for displaying
            (changed-bytes cln, (:col (:w_cursor win)))
            [win true]
        )
    ))

(defn- #_window_C del-bytes [#_window_C win, #_int nof, #_boolean fixpos, #_boolean use_delcombine]
    (let [[win _] (del-bytes? win, nof, fixpos, use_delcombine)]
        win
    ))

;; Delete from cursor to end of line.
;; Caller must have prepared for undo.

(defn- #_window_C truncate-line [#_window_C win, #_boolean fixpos]
    (let [lnum (:lnum (:w_cursor win)) col (:col (:w_cursor win))]
        (ml-replace lnum, (if (zero? col) (STRDUP (u8 "")) (STRNDUP (ml-get lnum), col)))
        ;; mark the buffer as changed and prepare for displaying
        (changed-bytes lnum, col)
        ;; If "fixpos" is true we don't want to end up positioned at the NUL.
        (if (and fixpos (< 0 (:col (:w_cursor win))))
            (update-in win [:w_cursor :col] dec)
            win
        )
    ))

;; Delete "nof" lines at the cursor.
;; Saves the lines for undo first if "undo" is true.

(defn- #_window_C del-lines [#_window_C win, #_long nof, #_boolean undo]
    (let [cln (:lnum (:w_cursor win))]
        (if (and (pos? nof) (or (not undo) (u-savedel win, cln, nof))) ;; save the deleted lines for undo
            (let [n (loop-when [n 0] (and (< n nof) (not (:ml_empty (:b_ml @curbuf)))) => n
                        (ml-delete cln, true)
                        ;; If we delete the last line in the file, stop.
                        (recur-if (<= cln (line-count @curbuf)) [(inc n)] => (inc n)))
                  ;; Correct the cursor position before calling deleted-lines-mark(),
                  ;; it may trigger a callback to display the cursor.
                  win (assoc-in win [:w_cursor :col] 0)
                  win (check-cursor-lnum win)]
                ;; Adjust marks, mark the buffer as changed and prepare for displaying.
                (deleted-lines-mark win, cln, n))
            win)
    ))

(defn- #_int gchar-pos    [#_pos_C pos]    (us-ptr2char (ml-get-pos pos)))
(defn- #_int gchar-cursor [#_window_C win] (us-ptr2char (ml-get-cursor win)))

;; When extra == 0: Return true if the cursor is before or on the first non-blank in the line.
;; When extra == 1: Return true if the cursor is before the first non-blank in the line.

(defn- #_boolean inindent [#_window_C win, #_int extra]
    (let [#_Bytes s (ml-get (:lnum (:w_cursor win)))]
        (<= (+ (:col (:w_cursor win)) extra) (loop [#_int col 0] (recur-if (vim-iswhite (.at s col)) [(inc col)] => col)))
    ))

;; Skip to next part of an option argument: Skip space and comma.

(defn- #_Bytes skip-to-option-part [#_Bytes p]
    (loop [p (if (at? p (byte \,)) (.plus p 1) p)] (if (at? p (byte \space)) (recur (.plus p 1)) p)))

;; Changed bytes within a single line for the current buffer.
;; - marks the windows on this buffer to be redisplayed
;; - marks the buffer changed by calling changed()
;; - invalidates cached values

(defn- #_void changed-bytes [#_long lnum, #_int col]
    (changed-one-line lnum)
    (swap! curbuf changed-common lnum, col, (inc lnum), 0)
    nil)

(defn- #_void changed-one-line [#_long lnum]
    (if (:b_mod_set @curbuf)
        (cond ;; find the maximum area that must be redisplayed
            (< lnum (:b_mod_top @curbuf))  (swap! curbuf assoc :b_mod_top lnum)
            (<= (:b_mod_bot @curbuf) lnum) (swap! curbuf assoc :b_mod_bot (inc lnum)))
        ;; set the area that must be redisplayed to one line
        (swap! curbuf assoc :b_mod_top lnum, :b_mod_bot (inc lnum), :b_mod_xlines 0, :b_mod_set true))
    nil)

;; Appended "count" lines below line "lnum" in the current buffer.
;; Must be called AFTER the change and after mark-adjust().
;; Takes care of marking the buffer to be redrawn and sets the changed flag.

(defn- #_void appended-lines [#_long lnum, #_long count]
    (swap! curbuf changed-lines (inc lnum), 0, (inc lnum), count)
    nil)

;; Like appended-lines(), but adjust marks first.

(defn- #_window_C appended-lines-mark [#_window_C win, #_long lnum, #_long count]
    (let [win (mark-adjust win, (inc lnum), MAXLNUM, count, 0)]
        (swap! curbuf changed-lines (inc lnum), 0, (inc lnum), count)
        win
    ))

;; Deleted "count" lines at line "lnum" in the current buffer.
;; Must be called AFTER the change and after mark-adjust().
;; Takes care of marking the buffer to be redrawn and sets the changed flag.

(defn- #_void deleted-lines [#_long lnum, #_long count]
    (swap! curbuf changed-lines lnum, 0, (+ lnum count), (- count))
    nil)

;; Like deleted-lines(), but adjust marks first.
;; Make sure the cursor is on a valid line before calling,
;; a GUI callback may be triggered to display the cursor.

(defn- #_window_C deleted-lines-mark [#_window_C win, #_long lnum, #_long count]
    (let [win (mark-adjust win, lnum, (dec (+ lnum count)), MAXLNUM, (- count))]
        (swap! curbuf changed-lines lnum, 0, (+ lnum count), (- count))
        win
    ))

;; Changed lines for the current buffer.
;; Must be called AFTER the change and after mark-adjust().
;; - mark the buffer changed by calling changed()
;; - mark the windows on this buffer to be redisplayed
;; - invalidate cached values
;; "lnum" is the first line that needs displaying,
;; "lnume" the first line below the changed lines (BEFORE the change).
;; When only inserting lines, "lnum" and "lnume" are equal.
;; Takes care of calling changed() and updating "b_mod_*".

(defn- #_buffer_C changed-lines [#_buffer_C buf, #_long lnum, #_int col, #_long lnume, #_long xtra]
    ;; lnum: first line with change
    ;; col: column in first line with change
    ;; lnume: line below last changed line
    ;; xtra: number of extra lines (negative when deleting)
    (-> buf
        (changed-lines-buf lnum, lnume, xtra)
        (changed-common lnum, col, lnume, xtra)
    ))

(defn- #_buffer_C changed-lines-buf [#_buffer_C buf, #_long lnum, #_long lnume, #_long xtra]
    ;; lnum: first line with change
    ;; lnume: line below last changed line
    ;; xtra: number of extra lines (negative when deleting)
    (if (:b_mod_set buf)
        ;; find the maximum area that must be redisplayed
        (let [buf (update buf :b_mod_top min lnum)
              buf (if (< lnum (:b_mod_bot buf)) ;; adjust old bot position for xtra lines
                    (assoc buf :b_mod_bot (max lnum (+ (:b_mod_bot buf) xtra)))
                    buf)
              buf (assoc buf :b_mod_bot (max (+ lnume xtra) (:b_mod_bot buf)))]
            (update buf :b_mod_xlines + xtra))
        ;; set the area that must be redisplayed
        (assoc buf :b_mod_top lnum, :b_mod_bot (+ lnume xtra), :b_mod_xlines xtra, :b_mod_set true)
    ))

;; Common code for when a change was made.
;; See changed-lines() for the arguments.

(defn- #_buffer_C changed-common [#_buffer_C buf, #_long lnum, #_int col, #_long lnume, #_long xtra]
    ;; mark the buffer as modified ;; set the '. mark
    (let [buf (changed buf) buf (update buf :b_last_change assoc :lnum lnum :col col)
          ;; Create a new entry if a new undo-able change was started or we don't have an entry yet.
          buf (if (or (:b_new_change buf) (zero? (:b_changelistlen buf)))
                (let-when [#_boolean add
                        (or (zero? (:b_changelistlen buf))
                            ;; Don't create a new entry when the line number is the
                            ;; same as the last one and the column is not too far away.
                            ;; Avoids creating many entries for typing "xxxxx".
                            (let [#_pos_C pos (... (:b_changelist buf) (dec (:b_changelistlen buf)))]
                                (or (!= (:lnum pos) lnum)
                                    (let [#_int cols 79]
                                        (or (< (+ (:col pos) cols) col) (< (+ col cols) (:col pos))))
                                ))
                        )] add => buf

                    ;; This is the first of a new sequence of undo-able changes
                    ;; and it's at some distance of the last change.  Use a new
                    ;; position in the changelist.
                    (let [buf (assoc buf :b_new_change false)
                          buf (if (== (:b_changelistlen buf) JUMPLISTSIZE)
                                ;; If changelist is full: remove oldest entry.
                                (let [buf (assoc buf :b_changelistlen (dec JUMPLISTSIZE))
                                      buf (loop-when-recur [buf buf #_int i 0]
                                                           (< i (dec JUMPLISTSIZE))
                                                           [(assoc-in buf [:b_changelist i] (... (:b_changelist buf) (inc i))) (inc i)]
                                                        => buf
                                        )]
                                    (loop-when-recur [#_window_C w @firstwin] (some? w) [(:w_next w)]
                                        ;; Correct position in changelist for other windows on this buffer.
                                        (when (< 0 (:w_changelistidx w))
                                            ((ร w =) (update w :w_changelistidx dec))
                                        ))
                                    buf)
                                buf
                            )]
                        (loop-when-recur [#_window_C w @firstwin] (some? w) [(:w_next w)]
                            ;; For other windows, if the position in the changelist is at the end,
                            ;; it stays at the end.
                            (when (== (:w_changelistidx w) (:b_changelistlen buf))
                                ((ร w =) (update w :w_changelistidx inc))
                            ))
                        (update buf :b_changelistlen inc)
                    ))
                buf)
          buf (assoc-in buf [:b_changelist (dec (:b_changelistlen buf))] (:b_last_change buf))]

        ;; The current window is always after the last change, so that "g," takes you back to it.
        (loop-when-recur [#_window_C w @firstwin] (some? w) [(:w_next w)]
            (when (:w_focused w)
                ((ร w =) (assoc w :w_changelistidx (:b_changelistlen buf)))
            ))

        (loop-when-recur [#_window_C w @firstwin] (some? w) [(:w_next w)]
            ;; Mark this window to be redrawn later.
            ((ร w =) (update w :w_redr_type max VALID))
            ;; Check if a change in the buffer has invalidated the cached values for the cursor.
            (cond (< lnum (:lnum (:w_cursor w)))
                ((ร w =) (changed-line-abv-curs w))
            (and (== (:lnum (:w_cursor w)) lnum) (<= col (:col (:w_cursor w))))
                ((ร w =) (changed-cline-bef-curs w))
            )
            (when (<= lnum (:w_botline w))
                ;; Assume that botline doesn't change
                ;; (inserted lines make other lines scroll down below botline).
                ((ร w =) (approximate-botline w))
            )
            ;; Check if any w_lines[] entries have become invalid.
            ;; For entries below the change: correct the lnums for inserted/deleted lines.
            ;; Makes it possible to stop displaying after the change.
            (dotimes [#_int i (:w_lines_valid w)]
                (let-when [wli (... (:w_lines w) i)] (and (:wl_valid wli) (<= lnum (:wl_lnum wli)))
                    (cond (< (:wl_lnum wli) lnume)
                        ;; line included in change
                        ((ร w =) (assoc-in w [:w_lines i :wl_valid] false))
                    (non-zero? xtra)
                        ;; line below change
                        ((ร w =) (update-in w [:w_lines i :wl_lnum] + xtra))
                    )
                ))
            ;; relative numbering may require updating more
            (when @(:wo_rnu (:w_options w))
                ((ร w =) (redraw-later w, SOME_VALID)))
        )

        ;; Call update-screen() later, which checks out what needs to be redrawn,
        ;; since it notices "b_mod_set" and then uses "b_mod_*".
        (when (< @must_redraw VALID)
            (reset! must_redraw VALID))

        buf
    ))

(defn- #_buffer_C changed [#_buffer_C buf]
    (when (not @(:b_changed buf))
        (reset! (:b_changed buf) true)
        (check-status))
    (update buf :b_changedtick inc))

(defn- #_buffer_C unchanged [#_buffer_C buf]
    (when @(:b_changed buf)
        (reset! (:b_changed buf) false)
        (check-status))
    (update buf :b_changedtick inc))

;; called when the status bars for buffer 'buf' need to be updated

(defn- #_void check-status []
    (loop-when-recur [#_window_C win @firstwin] (some? win) [(:w_next win)]
        (when (non-zero? (:w_status_height win))
            ((ร win =) (assoc win :w_redr_status true))
            (when (< @must_redraw VALID)
                (reset! must_redraw VALID))
        ))
    nil)

;; Get a key stroke directly from the user.
;;
;; Doesn't use vgetc(), because it syncs undo and eats mapped characters.
;; Disadvantage: typeahead is ignored.
;; Translates the interrupt character for unix to ESC.

(defn- #_[window_C int] get-keystroke? [#_window_C win]
    (let [a'len (atom (int 0))]
        (loop [win win #_int buflen 150 #_Bytes buf (Bytes. buflen) #_int waited 0]
            (cursor-on)
            (out-flush)
            ;; Leave room for check-termcode() to insert a key code (max 5 bytes plus NUL).
            ;; And fix-input-buffer() can triple the number of bytes.
            (let [#_int maxlen (/ (- buflen @a'len 5 1) 3)
                  [buflen buf maxlen]
                    (if (< maxlen 10)
                        ;; Need more space, might happen when receiving a long escape sequence.
                        (let [buflen (+ buflen 100) #_Bytes p (Bytes. buflen)]
                            (BCOPY p, buf, @a'len)
                            [buflen p (/ (- buflen @a'len 5 1) 3)])
                        [buflen buf maxlen])
                  ;; First time: blocking wait.
                  ;; Second time: wait up to 100ms for a terminal code to complete.
                  [win #_int n] (ui-inchar? win, (.plus buf @a'len), maxlen, (if (zero? @a'len) -1 100), 0)
                  waited
                    (cond (< 0 n)
                        (do ;; Replace zero by a special key code.
                            (swap! a'len + (fix-input-buffer (.plus buf @a'len), n))
                            0)
                    (< 0 @a'len)
                        (inc waited)                            ;; keep track of the waiting time
                    :else
                        waited)
                  ;; Incomplete termcode and not timed out yet: get more characters.
                  n (check-termcode buf, buflen, a'len)
                  [win #_int c]
                    (cond (and (< n 0) (or (not @p_ttimeout) (< (* waited 100) (if (< @p_ttm 0) @p_tm @p_ttm))))
                        [win nil]
                    (== n KEYLEN_REMOVED)                       ;; key code removed
                        (let [win (when' (and (non-zero? @must_redraw) (not @need_wait_return) (non-flag? @State CMDLINE)) => win
                                    (-> win
                                        (update-screen 0)       ;; redrawing was postponed, do it now
                                        (setcursor))            ;; put cursor back where it belongs
                                )]
                            [win nil])
                    :else
                        (do (when (< 0 n)                       ;; found a termcode: adjust length
                                (reset! a'len n))
                            (cond (zero? @a'len)                ;; nothing typed yet
                                [win nil]
                            ;; Handle modifier and/or special key code.
                            (at? buf KB_SPECIAL)
                                (let-when [#_int c (toSpecial (.at buf 1), (.at buf 2))] (or (at? buf 1 KS_MODIFIER) (== c K_IGNORE)) => [win c]
                                    (when (at? buf 1 KS_MODIFIER)
                                        (reset! mod_mask (char_u (.at buf 2))))
                                    (swap! a'len - 3)
                                    (when (< 0 @a'len)
                                        (BCOPY buf, 0, buf, 3, @a'len))
                                    [win nil])
                            (< @a'len (mb-byte2len (char_u (.at buf 0))))
                                [win nil]                       ;; more bytes to get
                            :else
                                (let [#_int c (us-ptr2char (eos! buf (min @a'len (dec buflen))))]
                                    [win (if (== c @intr_char) ESC c)])
                            ))
                    )]
                (recur-if (nil? c) [win buflen buf waited] => [win c])
            ))
    ))

(defn- #_window_C msgmore [#_window_C win, #_long n]
    ;; We don't want to overwrite another important message,
    ;; but do overwrite a previous "more lines" or "fewer lines" message,
    ;; so that "5dd" and then "put" reports the last action.
    (when' (and (messaging) (or (nil? @keep_msg) @keep_msg_more)) => win
        (let-when [#_long pn (if (< 0 n) n (- n))] (< @p_report pn) => win
            (let [#_Bytes s (Bytes. MSG_BUF_LEN)]
                (if (== pn 1)
                    (vim-strncpy s, (if (< 0 n) (u8 "1 more line") (u8 "1 line less")), (dec MSG_BUF_LEN))
                    (ร .sprintf libC s, (if (< 0 n) (u8 "%ld more lines") (u8 "%ld fewer lines")), pn))
                (when @got_int
                    (vim-strcat s, (u8 " (Interrupted)"), MSG_BUF_LEN))
                (let-when [[win ?] (msg? win, s)] ? => win
                    (set-keep-msg s, 0)
                    (reset! keep_msg_more true))
            ))
    ))

(defn- #_window_C beep-flush [#_window_C win]
    (let [win (flush-buffers win, false)]
        (beep)
        win
    ))

(defn- #_void beep []
    (if @p_vb
        (out-str @T_VB)
        (out-char BELL))
    nil)

(defn- #_void prepare-to-exit []
    ;; Ignore SIGHUP, because a dropped connection causes a read error, which
    ;; makes Vim exit and then handling SIGHUP causes various reentrance problems.

    (ร .sigset libC SIGHUP, #_"/*SIG_IGN*/"nil)

    (windgoto (dec @Rows), 0)

    ;; Switch terminal mode back now, so messages end up on the "normal"
    ;; screen (if there are two screens).

    (settmode TMODE_COOK)
    (stop-termcap)
    (out-flush)
    nil)

;; Preserve files and exit.
;; NOTE: This may be called from deathtrap() in a signal handler,
;; avoid unsafe functions, such as allocating memory.

(defn- #_void preserve-exit [#_Bytes msg]
    (prepare-to-exit)

    (out-str msg)
    (screen-start)                 ;; don't know where cursor is now
    (out-flush)

    (out-str (u8 "Vim: Finished.\n"))

    (getout 1)
    nil)

;; Check for CTRL-C pressed, but only once in a while.
;; Should be used instead of ui-breakcheck() for functions that check for each line in the file.
;; Calling ui-breakcheck() each time takes too much time, because it can be a system call.

(final int BREAKCHECK_SKIP 32)

(atom! int breakcheck_count)

(defn- #_boolean slow-breakcheck []
    (when (<= BREAKCHECK_SKIP (swap! breakcheck_count inc))
        (reset! breakcheck_count 0)
        (ui-breakcheck))
    @got_int)

;; Like slow-breakcheck() but check 10 times less often.

(defn- #_boolean fast-breakcheck []
    (when (<= (* BREAKCHECK_SKIP 10) (swap! breakcheck_count inc))
        (reset! breakcheck_count 0)
        (ui-breakcheck))
    @got_int)

;; Return true when need to go to Insert mode because of 'insertmode'.
;; Don't do this when still processing a command or a mapping.
;; Don't do this when inside a ":normal" command.

(defn- #_boolean goto-im []
    (and @p_im (stuff-empty)))

;; Return true if in the current mode we need to use virtual.

(defn- #_boolean virtual-active []
    ;; While an operator is being executed we return "virtual_op",
    ;; because VIsual_active has already been reset,
    ;; thus we can't check for "block" being used.
    (if (!= @virtual_op MAYBE)
        (!= @virtual_op FALSE)
        (or (== @ve_flags VE_ALL) (and (flag? @ve_flags VE_BLOCK) @VIsual_active (== @VIsual_mode Ctrl_V)) (and (flag? @ve_flags VE_INSERT) (flag? @State INSERT)))
    ))

;; Get the screen position of the cursor.

(defn- #_int getviscol [#_window_C win]
    (let [a'x (atom (int))]
        (getvvcol win, (:w_cursor win), a'x, nil, nil)
        @a'x
    ))

;; Get the screen position of character col with a coladd in the cursor line.

(defn- #_int getviscol2 [#_window_C win, #_int col, #_int coladd]
    (let [a'x (atom (int))]
        (getvvcol win, (assoc (:w_cursor win) :col col :coladd coladd), a'x, nil, nil)
        @a'x
    ))

;; Go to column "wcol", and add/insert white space as necessary to get the cursor in that column.
;; The caller must have saved the cursor line for undo!

(defn- #_window_C coladvance-force [#_window_C win, #_int wcol]
    (let [[win pos _] (coladvance3 win, (:w_cursor win), true, false, wcol) win (assoc win :w_cursor pos)]
        (if (== wcol MAXCOL)
            (update win :w_valid & (bit-not VALID_VIRTCOL))
        (-> win ;; "w_virtcol" is valid
            (assoc :w_virtcol wcol)
            (update :w_valid | VALID_VIRTCOL)
        ))
    ))

;; Try to advance the cursor to the specified screen column.
;;
;; If virtual editing: fine-tune the cursor position.
;; All virtual positions off the end of a line should share
;; the "col" value (n.b. this is equal to STRLEN(line)),
;; beginning at "coladd" 0.
;;
;; Return true if desired column is reached, false if not.

(defn- #_[window_C boolean] coladvance? [#_window_C win, #_int wcol]
    (let [[win pos #_boolean ?] (coladvance3 win, (:w_cursor win), false, (virtual-active), wcol) win (assoc win :w_cursor pos)]
        (cond (or (== wcol MAXCOL) (not ?))
            [(update win :w_valid & (bit-not VALID_VIRTCOL)) ?]
        (not-at? (ml-get-cursor win) TAB) ;; "w_virtcol" is valid when not on a TAB
            [(-> win (assoc :w_virtcol wcol) (update :w_valid | VALID_VIRTCOL)) ?]
        :else
            [win ?]
        )
    ))

(defn- #_window_C coladvance [#_window_C win, #_int wcol]
    (let [[win _] (coladvance? win, wcol)]
        win
    ))

;; Return in "pos" the position of the cursor advanced to screen column "wcol".

(defn- #_[window_C pos_C] getvpos [#_window_C win, #_pos_C pos, #_int wcol]
    (let [[win pos _] (coladvance3 win, pos, false, (virtual-active), wcol)]
        [win pos]
    ))

(defn- #_[window_C pos_C boolean] coladvance3 [#_window_C win, #_pos_C pos, #_boolean addspaces, #_boolean finetune, #_int wcol]
    ;; addspaces: change the text to achieve our goal?
    ;; finetune: change char offset for the exact column
    ;; wcol: column to move to
    (let-when [#_Bytes line (ml-get (:lnum pos))
        #_boolean one_more (or (flag? @State INSERT) (!= @restart_edit NUL) (and @VIsual_active (not-at? @p_sel (byte \o))) (and (flag? @ve_flags VE_ONEMORE) (< wcol MAXCOL)))
        [win wcol #_int x #_int col abort]
            (if (<= MAXCOL wcol)
                (let [x (+ (dec (STRLEN line)) (if one_more 1 0))
                      win (if (and (or addspaces finetune) (not @VIsual_active))
                            (let [win (assoc win :w_curswant (+ (linetabsize win, line) (if one_more 1 0)))]
                                (if (< 0 (:w_curswant win)) (update win :w_curswant dec) win))
                            win
                        )]
                    [win wcol x wcol false]
                )
                (let [#_int width (- (:w_width win) (win-col-off win))
                      [#_int csize wcol]
                        (if (and finetune @(:wo_wrap (:w_options win)) (non-zero? (:w_width win)) (<= width wcol))
                            (let [csize (linetabsize win, line) csize (if (< 0 csize) (dec csize) csize)
                                  wcol (if (and (< (/ csize width) (/ wcol width)) (or (non-flag? @State INSERT) (< (inc csize) wcol)))
                                        ;; In case of line wrapping don't move the cursor beyond the right screen edge.
                                        ;; In Insert mode allow going just beyond the last character
                                        ;; (like what happens when typing and reaching the right window edge).
                                        (dec (* (inc (/ csize width)) width))
                                        wcol
                                    )]
                                [csize wcol])
                            [0 wcol])
                      a'head (atom (int 0)) [csize x col]
                        (loop-when [csize csize #_Bytes s line col 0] (and (<= col wcol) (non-eos? s)) => [csize (BDIFF s, line) col]
                            ;; Count a tab for what it's worth (if list mode not on).
                            (let [csize (win-lbr-chartabsize win, line, s, col, a'head)]
                                (recur csize (.plus s (us-ptr2len-cc s)) (+ col csize))
                            ))
                      ;; Handle all the special cases.  The virtual-active() check is needed to
                      ;; ensure that a virtual position off the end of a line has the correct indexing.
                      ;; The one_more comparison replaces an explicit add of one_more later on.
                      [csize x col]
                        (if (or (< wcol col) (and (not (virtual-active)) (not one_more)))
                            ;; Don't count the chars from 'showbreak'.
                            (let [csize (- csize @a'head)] [csize (dec x) (- col csize)])
                            [csize x col])
                      [x col abort]
                        (if (and (virtual-active) addspaces (or (and (!= col wcol) (!= col (inc wcol))) (< 1 csize)))
                            ;; 'virtualedit' is set: The difference between wcol and col is filled with spaces.
                            (if (eos? line x)
                                ;; Append spaces.
                                (let [#_int n (+ x (- wcol col))
                                      #_Bytes s (Bytes. (inc n))
                                      _ (loop-when-recur [i 0] (< i x) [(inc i)] (.be s i, (.at line i)))
                                      _ (loop-when-recur [i x] (< i n) [(inc i)] (.be s i, (byte \space)))
                                      _ (eos! s n)]
                                    (ml-replace (:lnum pos), s)
                                    (changed-bytes (:lnum pos), x)
                                    [n wcol false]
                                )
                                ;; Break a tab.
                                (let [#_int n (STRLEN line) #_int m (inc (- wcol col csize))] ;; negative!!
                                    (if (< csize (- m))
                                        [x col true] ;; abort!!
                                        (let [#_Bytes s (Bytes. (+ n csize))
                                              _ (loop-when [i 0 j 0] (< j n)
                                                    (let [i (if (!= j x)
                                                                (do (.be s i, (.at line j)) (inc i))
                                                                (loop-when-recur [i i k 0] (< k csize) [(inc i) (inc k)] => i
                                                                    (.be s i, (byte \space)))
                                                            )]
                                                        (recur i (inc j))
                                                    ))
                                              _ (eos! s (dec (+ n csize)))]
                                            (ml-replace (:lnum pos), s)
                                            (changed-bytes (:lnum pos), x)
                                            [(+ x (dec csize) m) (+ col m) false]
                                        ))
                                ))
                            [x col false]
                        )]
                    [win wcol x col abort]
                )
            )] (not abort) => [win pos false]

        (let [pos (assoc pos :col (max 0 x) :coladd 0)
              [pos col]
                (if finetune
                    (if (== wcol MAXCOL)
                        ;; The width of the last character is used to set coladd.
                        (if (not one_more)
                            (let [a'scol (atom (int)) a'ecol (atom (int)) _ (getvcol win, pos, a'scol, nil, a'ecol)]
                                [(assoc pos :coladd (- @a'ecol @a'scol)) col])
                            [pos col]
                        )
                        ;; The difference between wcol and col is used to set coladd.
                        (let [#_int m (- wcol col)
                              pos (if (< 0 m (- MAXCOL (* 2 (:w_width win)))) (assoc pos :coladd m) pos)]
                            [pos (+ col m)]
                        ))
                    [pos col]
                )]
            ;; prevent from moving onto a trail byte
            [win (mb-adjust-pos pos) (not (< col wcol))]
        )
    ))

;; Increment the cursor position.  See incp() for return values.

(defn- #_[window_C int] inc-cursor? [#_window_C win, #_boolean skip_eos]
    (let [[_ ?] ((if skip_eos incl? incp?) (:w_cursor win))] [(assoc win :w_cursor _) ?]))

(defn- #_window_C inc-cursor [#_window_C win, #_boolean skip_eos]
    (let [[_ ?] (inc-cursor? win, skip_eos)] _))

;; Increment the line pointer "pos" crossing line boundaries as necessary.
;; Return 1 when going to the next line.
;; Return 2 when moving forward onto a NUL at the end of the line.
;; Return -1 when at the end of file.
;; Return 0 otherwise.

(defn- #_[pos_C int] incp? [#_pos_C pos]
    (let [#_Bytes s (ml-get-pos pos)]
        (cond (non-eos? s) ;; still within line, move to next char (may be NUL)
            (let [#_int n (us-ptr2len-cc s)] [(update pos :col + n) (if (non-eos? s n) 0 2)])
        (!= (:lnum pos) (line-count @curbuf)) ;; there is a next line
            [(assoc pos :lnum (inc (:lnum pos)) :col 0 :coladd 0) 1]
        :else
            [pos -1]
        )
    ))

(defn- #_pos_C incp [#_pos_C pos]
    (let [[pos _] (incp? pos)]
        pos
    ))

;; incl(): same as incp(), but skip the NUL at the end of non-empty lines

(defn- #_[pos_C int] incl? [#_pos_C pos]
    (let [[pos ? :as _] (incp? pos)] (if (and (<= 1 ?) (non-zero? (:col pos))) (incp? pos) _)))

(defn- #_pos_C incl [#_pos_C pos]
    (let [[pos _] (incl? pos)]
        pos
    ))

;; Decrement the cursor position.  See decp() for return values.

(defn- #_[window_C int] dec-cursor? [#_window_C win, #_boolean skip_eos]
    (let [[_ ?] ((if skip_eos decl? decp?) (:w_cursor win))] [(assoc win :w_cursor _) ?]))

(defn- #_window_C dec-cursor [#_window_C win, #_boolean skip_eos]
    (let [[_ ?] (dec-cursor? win, skip_eos)] _))

;; Decrement the line pointer "pos" crossing line boundaries as necessary.
;; Return 1 when crossing a line, -1 when at start of file, 0 otherwise.

(defn- #_[pos_C int] decp? [#_pos_C pos]
    (let [pos (assoc pos :coladd 0)]
        (cond (< 0 (:col pos))                  ;; still within line
            (let [pos (update pos :col dec)
                  #_Bytes s (ml-get (:lnum pos))
                  pos (update pos :col #(- % (us-head-off s, (.plus s %))))]
                [pos 0])
        (< 1 (:lnum pos))                       ;; there is a prior line
            (let [pos (update pos :lnum dec)
                  #_Bytes s (ml-get (:lnum pos))
                  pos (assoc pos :col (STRLEN s))
                  pos (update pos :col #(- % (us-head-off s, (.plus s %))))]
                [pos 1])
        :else
            [pos -1]                            ;; at start of file
        )
    ))

(defn- #_pos_C decp [#_pos_C pos]
    (let [[pos _] (decp? pos)]
        pos
    ))

;; decl(): same as decp(), but skip the NUL at the end of non-empty lines

(defn- #_[pos_C int] decl? [#_pos_C pos]
    (let [[pos ? :as _] (decp? pos)] (if (and (== ? 1) (non-zero? (:col pos))) (decp? pos) _)))

(defn- #_pos_C decl [#_pos_C pos]
    (let [[pos _] (decl? pos)]
        pos
    ))

;; Get the line number relative to the current cursor position,
;; i.e. the difference between line number and cursor position.
;; Only look for lines that can be visible, folded lines don't count.

(defn- #_long get-cursor-rel-lnum [#_window_C win, #_long lnum]
    ;; lnum: line number to get the result for
    (- lnum (:lnum (:w_cursor win))))

;; Make sure win.w_cursor.lnum is valid.

(defn- #_window_C check-cursor-lnum [#_window_C win]
    (update-in win [:w_cursor :lnum] #(max 1 (min % (line-count @curbuf)))))

;; Make sure win.w_cursor.col is valid.

(defn- #_window_C check-cursor-col [#_window_C win]
    (let [_ (:w_cursor win) col' (:col _) coladd' (+ col' (:coladd _)) len (STRLEN (ml-get (:lnum _)))
          win (cond (zero? len)
                (assoc-in win [:w_cursor :col] 0)
            (<= len col')
                ;; Allow cursor past end-of-line when in Insert mode or restarting Insert mode, or in Visual mode and 'selection' isn't "old", or 'virtualedit' is set.
                (if (or (flag? @State INSERT) (non-zero? @restart_edit) (and @VIsual_active (not-at? @p_sel (byte \o))) (flag? @ve_flags VE_ONEMORE) (virtual-active))
                    (assoc-in win [:w_cursor :col] len)
                    ;; Move the cursor to the head byte.
                    (-> win (assoc-in [:w_cursor :col] (dec len))
                            (update :w_cursor mb-adjust-pos)
                    ))
            (< col' 0)
                (assoc-in win [:w_cursor :col] 0)
            :else
                win
            )]
        ;; In virtual editing we can leave the cursor at the old position, just set it to virtual; but don't do it at end-of-line.
        (cond (== col' MAXCOL)
            (assoc-in win [:w_cursor :coladd] 0)
        (== @ve_flags VE_ALL)
            (assoc-in win [:w_cursor :coladd] (max 0 (- coladd' (:col (:w_cursor win)))))
        :else
            win
        )
    ))

;; Make sure win.w_cursor in on a valid character.

(defn- #_window_C check-cursor [#_window_C win]
    (-> win (check-cursor-lnum) (check-cursor-col)))

;; Make sure win.w_cursor is not on the NUL at the end of the line.
;; Allow it when in Visual mode and 'selection' is not "old".

(defn- #_window_C adjust-cursor-col [#_window_C win]
    (if (and (pos? (:col (:w_cursor win))) (or (not @VIsual_active) (at? @p_sel (byte \o))) (== (gchar-cursor win) NUL))
        (update-in win [:w_cursor :col] dec)
        win
    ))

;; When "w_leftcol" has changed, adjust the cursor position.
;; Return true if the cursor was moved.

(defn- #_[window_C boolean] leftcol-changed? [#_window_C win]
    (let [win (changed-cline-bef-curs win)
          lastcol (dec (- (+ (:w_leftcol win) (:w_width win)) (win-col-off win)))
          win (validate-virtcol win)
          ;; If the cursor is right or left of the screen, move it to last or first character.
          [win changed?] (cond
                (< (- lastcol @p_siso) (:w_virtcol win))          [(coladvance win, (- lastcol @p_siso)) true]
                (< (:w_virtcol win) (+ (:w_leftcol win) @p_siso)) [(coladvance win, (+ (:w_leftcol win) @p_siso)) true]
                :else                                             [win false])
          ;; If the start of the char under the cursor is not on the screen, advance the cursor one more char.
          ;; If this fails (last char of the line), adjust the scrolling.
          a's (atom (int)) a'e (atom (int)) _ (getvvcol win, (:w_cursor win), a's, nil, a'e)
          [win changed?] (cond
                (< lastcol @a'e)            [(coladvance win, (dec @a's)) true]
                (< @a's (:w_leftcol win)) ;; there isn't another character ;; adjust "w_leftcol" instead
                                            (let [[win ?] (coladvance? win, (inc @a'e))] [(if (not ?) (-> win (assoc :w_leftcol @a's) (changed-cline-bef-curs)) win) true])
                :else                       [win changed?])
          win (if changed? (assoc win :w_set_curswant true) win)]
        [(redraw-later win, NOT_VALID) changed?]
    ))

(defn- #_window_C leftcol-changed [#_window_C win]
    (let [[win _] (leftcol-changed? win)]
        win
    ))

;; Copy "s" into newly allocated memory.

(defn- #_Bytes STRDUP [#_Bytes s]
    (let [n (inc (STRLEN s)) s' (Bytes. n)]
        (BCOPY s', s, n)
        s'
    ))

;; Copy up to "n" bytes of "s" into newly allocated memory and terminate with a NUL.
;; The allocated memory always has size "n + 1", also when "s" is shorter.

(defn- #_Bytes STRNDUP [#_Bytes s, #_int n]
    (let [s' (Bytes. (inc n))]
        (STRNCPY s', s, n)
        (eos! s' n)
    ))

;; Same as STRDUP(), but any characters found in esc_chars are preceded by a backslash.

(defn- #_Bytes vim-strsave-escaped [#_Bytes string, #_Bytes esc_chars, #_int cc]
    ;; First count the number of backslashes required, then allocate the memory and insert them.
    (let [#_int n (loop-when [#_Bytes s string n 1] (non-eos? s) => n                                       ;; count the trailing NUL
                    (let [#_int l (us-ptr2len-cc s)
                          [s n] (if (< 1 l)
                                    [(.plus s l) (+ n l)]                                                   ;; count a multibyte char
                                    [(.plus s 1) (+ n (if (some? (vim-strchr esc_chars, (.at s 0))) 2 1))]  ;; count a 'cc' + an ordinary char
                                )]
                        (recur s n)
                    ))
          #_Bytes q (Bytes. n)]
        (loop-when [#_Bytes s string #_Bytes p q] (non-eos? s) => (eos! p)
            (let [#_int l (us-ptr2len-cc s)
                  [s p] (if (< 1 l)
                            (do (BCOPY p, s, l) [(.plus s l) (.plus p l)])
                            (let [p (if (some? (vim-strchr esc_chars, (.at s 0))) (do (.be p 0, cc) (.plus p 1)) p)] (.be p 0, (.at s 0)) [(.plus s 1) (.plus p 1)])
                        )]
                (recur s p)
            ))
    q))

;; Like strncpy(), but always terminate the result with one NUL.
;; "dst" must be "len + 1" long!

(defn- #_void vim-strncpy [#_Bytes dst, #_Bytes src, #_int len]
    (STRNCPY dst, src, len)
    (eos! dst len)
    nil)

;; Like strcat(), but make sure the result fits in "size" bytes
;; and is always NUL terminated.

(defn- #_void vim-strcat [#_Bytes dst, #_Bytes src, #_int size]
    (let [#_int dlen (STRLEN dst) #_int slen (STRLEN src)]
        (if (< size (+ dlen slen 1))
            (do (BCOPY dst, dlen, src, 0, (- size dlen 1)) (eos! dst (dec size)))
            (STRCPY (.plus dst dlen), src)
        ))
    nil)

;; Isolate one part of a string option where parts are separated with "sep_chars".
;; The part is copied into "buf[maxlen]".
;; "*option" is advanced to the next part.
;; The length is returned.

(defn- #_int copy-option-part [#_Bytes' a'option, #_Bytes buf, #_int maxlen, #_Bytes sep_chars]
    (let [s @a'option n 0
          ;; skip '.' at start of option part, for 'suffixes'
          [s n] (if (at? s (byte \.)) (do (.be buf n, (.at s 0)) [(.plus s 1) (inc n)]) [s n])
          [s n] (loop-when [s s n n] (and (non-eos? s) (nil? (vim-strchr sep_chars, (.at s 0)))) => [s n]
                    ;; skip backslash before a separator character and space
                    (let [s (if (and (at? s (byte \\)) (some? (vim-strchr sep_chars, (.at s 1)))) (.plus s 1) s)
                          n (if (< n (dec maxlen)) (do (.be buf n, (.at s 0)) (inc n)) n)]
                        (recur (.plus s 1) n)
                    ))
          _ (eos! buf n)
          s (if (and (non-eos? s) (not-at? s (byte \,))) (.plus s 1) s) ;; skip non-standard separator
          s (skip-to-option-part s)]
        (reset! a'option s)
    n))

;; Version of strchr() and strrchr() that handle unsigned char strings
;; with characters from 128 to 255 correctly.  It also doesn't return
;; a pointer to the NUL at the end of the string.

(defn- #_Bytes vim-strchr [#_Bytes p, #_int c]
    (loop-when p (non-eos? p) => nil
        (recur-if (!= (us-ptr2char p) c) (.plus p (us-ptr2len-cc p)) => p)
    ))

;; Version of strchr() that only works for bytes and handles unsigned char
;; strings with characters above 128 correctly.  It also doesn't return a
;; pointer to the NUL at the end of the string.

(defn- #_Bytes vim-strbyte [#_Bytes p, #_byte b]
    (loop-when p (non-eos? p) => nil
        (recur-if (not-at? p b) (.plus p 1) => p)
    ))

;; Search for last occurrence of "b" in "p".
;; Return null if not found.
;; Does not handle multi-byte char for "b"!

(defn- #_Bytes vim-strrchr [#_Bytes p, #_byte b]
    (loop-when-recur [#_Bytes q nil p p] (non-eos? p) [(if (at? p b) p q) (.plus p (us-ptr2len-cc p))] => q))

;; Vim has its own isspace() function, because on some machines isspace()
;; can't handle characters above 128.

(defn- #_boolean vim-isspace [#_int x]
    (or (<= 9 x 13) (== x (byte \space))))

;; Some useful tables.

(class! #_final modmasktable_C
    [
        (field int      mod_mask)       ;; bit-mask for particular key modifier
        (field int      mod_flag)       ;; bit(s) for particular key modifier
        (field byte     name)           ;; single letter name of modifier
    ])

(final modmasktable_C* mod_mask_table
    [
        (modmasktable_C. MOD_MASK_ALT,         MOD_MASK_ALT,    (byte \M)),
        (modmasktable_C. MOD_MASK_META,        MOD_MASK_META,   (byte \T)),
        (modmasktable_C. MOD_MASK_CTRL,        MOD_MASK_CTRL,   (byte \C)),
        (modmasktable_C. MOD_MASK_SHIFT,       MOD_MASK_SHIFT,  (byte \S)),
        (modmasktable_C. MOD_MASK_MULTI_CLICK, MOD_MASK_2CLICK, (byte \2)),
        (modmasktable_C. MOD_MASK_MULTI_CLICK, MOD_MASK_3CLICK, (byte \3)),
        (modmasktable_C. MOD_MASK_MULTI_CLICK, MOD_MASK_4CLICK, (byte \4)),
        ;; 'A' must be the last one
        (modmasktable_C. MOD_MASK_ALT,         MOD_MASK_ALT,    (byte \A))
    ])

;; Shifted key terminal codes and their unshifted equivalent.

(final int MOD_KEYS_ENTRY_SIZE 5)

(final byte* modifier_keys_table
    [
     ;; mod mask            with modifier           without modifier
        MOD_MASK_SHIFT,     (byte \&), (byte \9),   (byte \@), (byte \1),   ;; begin
        MOD_MASK_SHIFT,     (byte \&), (byte \0),   (byte \@), (byte \2),   ;; cancel
        MOD_MASK_SHIFT,     (byte \*), (byte \1),   (byte \@), (byte \4),   ;; command
        MOD_MASK_SHIFT,     (byte \*), (byte \2),   (byte \@), (byte \5),   ;; copy
        MOD_MASK_SHIFT,     (byte \*), (byte \3),   (byte \@), (byte \6),   ;; create
        MOD_MASK_SHIFT,     (byte \*), (byte \4),   (byte \k), (byte \D),   ;; delete char
        MOD_MASK_SHIFT,     (byte \*), (byte \5),   (byte \k), (byte \L),   ;; delete line
        MOD_MASK_SHIFT,     (byte \*), (byte \7),   (byte \@), (byte \7),   ;; end
        MOD_MASK_CTRL,      KS_EXTRA, KE_C_END,     (byte \@), (byte \7),   ;; end
        MOD_MASK_SHIFT,     (byte \*), (byte \9),   (byte \@), (byte \9),   ;; exit
        MOD_MASK_SHIFT,     (byte \*), (byte \0),   (byte \@), (byte \0),   ;; find
        MOD_MASK_SHIFT,     (byte \#), (byte \1),   (byte \%), (byte \1),   ;; help
        MOD_MASK_SHIFT,     (byte \#), (byte \2),   (byte \k), (byte \h),   ;; home
        MOD_MASK_CTRL,      KS_EXTRA, KE_C_HOME,    (byte \k), (byte \h),   ;; home
        MOD_MASK_SHIFT,     (byte \#), (byte \3),   (byte \k), (byte \I),   ;; insert
        MOD_MASK_SHIFT,     (byte \#), (byte \4),   (byte \k), (byte \l),   ;; left arrow
        MOD_MASK_CTRL,      KS_EXTRA, KE_C_LEFT,    (byte \k), (byte \l),   ;; left arrow
        MOD_MASK_SHIFT,     (byte \%), (byte \a),   (byte \%), (byte \3),   ;; message
        MOD_MASK_SHIFT,     (byte \%), (byte \b),   (byte \%), (byte \4),   ;; move
        MOD_MASK_SHIFT,     (byte \%), (byte \c),   (byte \%), (byte \5),   ;; next
        MOD_MASK_SHIFT,     (byte \%), (byte \d),   (byte \%), (byte \7),   ;; options
        MOD_MASK_SHIFT,     (byte \%), (byte \e),   (byte \%), (byte \8),   ;; previous
        MOD_MASK_SHIFT,     (byte \%), (byte \f),   (byte \%), (byte \9),   ;; print
        MOD_MASK_SHIFT,     (byte \%), (byte \g),   (byte \%), (byte \0),   ;; redo
        MOD_MASK_SHIFT,     (byte \%), (byte \h),   (byte \&), (byte \3),   ;; replace
        MOD_MASK_SHIFT,     (byte \%), (byte \i),   (byte \k), (byte \r),   ;; right arrow
        MOD_MASK_CTRL,      KS_EXTRA, KE_C_RIGHT,   (byte \k), (byte \r),   ;; right arrow
        MOD_MASK_SHIFT,     (byte \%), (byte \j),   (byte \&), (byte \5),   ;; resume
        MOD_MASK_SHIFT,     (byte \!), (byte \1),   (byte \&), (byte \6),   ;; save
        MOD_MASK_SHIFT,     (byte \!), (byte \2),   (byte \&), (byte \7),   ;; suspend
        MOD_MASK_SHIFT,     (byte \!), (byte \3),   (byte \&), (byte \8),   ;; undo
        MOD_MASK_SHIFT,     KS_EXTRA, KE_S_UP,      (byte \k), (byte \u),   ;; up arrow
        MOD_MASK_SHIFT,     KS_EXTRA, KE_S_DOWN,    (byte \k), (byte \d),   ;; down arrow

                                                                            ;; vt100 F1
        MOD_MASK_SHIFT,     KS_EXTRA, KE_S_XF1,     KS_EXTRA, KE_XF1,
        MOD_MASK_SHIFT,     KS_EXTRA, KE_S_XF2,     KS_EXTRA, KE_XF2,
        MOD_MASK_SHIFT,     KS_EXTRA, KE_S_XF3,     KS_EXTRA, KE_XF3,
        MOD_MASK_SHIFT,     KS_EXTRA, KE_S_XF4,     KS_EXTRA, KE_XF4,

        MOD_MASK_SHIFT,     KS_EXTRA, KE_S_F1,      (byte \k), (byte \1),   ;; F1
        MOD_MASK_SHIFT,     KS_EXTRA, KE_S_F2,      (byte \k), (byte \2),
        MOD_MASK_SHIFT,     KS_EXTRA, KE_S_F3,      (byte \k), (byte \3),
        MOD_MASK_SHIFT,     KS_EXTRA, KE_S_F4,      (byte \k), (byte \4),
        MOD_MASK_SHIFT,     KS_EXTRA, KE_S_F5,      (byte \k), (byte \5),
        MOD_MASK_SHIFT,     KS_EXTRA, KE_S_F6,      (byte \k), (byte \6),
        MOD_MASK_SHIFT,     KS_EXTRA, KE_S_F7,      (byte \k), (byte \7),
        MOD_MASK_SHIFT,     KS_EXTRA, KE_S_F8,      (byte \k), (byte \8),
        MOD_MASK_SHIFT,     KS_EXTRA, KE_S_F9,      (byte \k), (byte \9),
        MOD_MASK_SHIFT,     KS_EXTRA, KE_S_F10,     (byte \k), (byte \;),   ;; F10

        MOD_MASK_SHIFT,     KS_EXTRA, KE_S_F11,     (byte \F), (byte \1),
        MOD_MASK_SHIFT,     KS_EXTRA, KE_S_F12,     (byte \F), (byte \2),

        MOD_MASK_SHIFT,     (byte \k), (byte \B),   KS_EXTRA, KE_TAB,       ;; TAB pseudo code

        NUL
    ])

(class! #_final key_name_C
    [
        (field int      key)        ;; special key code or ascii value
        (field Bytes    name)       ;; name of key
    ])

(final key_name_C* key_names_table
    [
        (key_name_C. (int \space),     (u8 "Space")           ),
        (key_name_C. TAB,              (u8 "Tab")             ),
        (key_name_C. K_TAB,            (u8 "Tab")             ),
        (key_name_C. NL,               (u8 "NL")              ),
        (key_name_C. NL,               (u8 "NewLine")         ),  ;; alternative name
        (key_name_C. NL,               (u8 "LineFeed")        ),  ;; alternative name
        (key_name_C. NL,               (u8 "LF")              ),  ;; alternative name
        (key_name_C. CAR,              (u8 "CR")              ),
        (key_name_C. CAR,              (u8 "Return")          ),  ;; alternative name
        (key_name_C. CAR,              (u8 "Enter")           ),  ;; alternative name
        (key_name_C. K_BS,             (u8 "BS")              ),
        (key_name_C. K_BS,             (u8 "BackSpace")       ),  ;; alternative name
        (key_name_C. ESC,              (u8 "Esc")             ),
        (key_name_C. (int \|),         (u8 "Bar")             ),
        (key_name_C. (int \\),         (u8 "Bslash")          ),
        (key_name_C. K_DEL,            (u8 "Del")             ),
        (key_name_C. K_DEL,            (u8 "Delete")          ),  ;; alternative name
        (key_name_C. K_KDEL,           (u8 "kDel")            ),
        (key_name_C. K_UP,             (u8 "Up")              ),
        (key_name_C. K_DOWN,           (u8 "Down")            ),
        (key_name_C. K_LEFT,           (u8 "Left")            ),
        (key_name_C. K_RIGHT,          (u8 "Right")           ),
        (key_name_C. K_XUP,            (u8 "xUp")             ),
        (key_name_C. K_XDOWN,          (u8 "xDown")           ),
        (key_name_C. K_XLEFT,          (u8 "xLeft")           ),
        (key_name_C. K_XRIGHT,         (u8 "xRight")          ),

        (key_name_C. K_F1,             (u8 "F1")              ),
        (key_name_C. K_F2,             (u8 "F2")              ),
        (key_name_C. K_F3,             (u8 "F3")              ),
        (key_name_C. K_F4,             (u8 "F4")              ),
        (key_name_C. K_F5,             (u8 "F5")              ),
        (key_name_C. K_F6,             (u8 "F6")              ),
        (key_name_C. K_F7,             (u8 "F7")              ),
        (key_name_C. K_F8,             (u8 "F8")              ),
        (key_name_C. K_F9,             (u8 "F9")              ),
        (key_name_C. K_F10,            (u8 "F10")             ),

        (key_name_C. K_F11,            (u8 "F11")             ),
        (key_name_C. K_F12,            (u8 "F12")             ),

        (key_name_C. K_XF1,            (u8 "xF1")             ),
        (key_name_C. K_XF2,            (u8 "xF2")             ),
        (key_name_C. K_XF3,            (u8 "xF3")             ),
        (key_name_C. K_XF4,            (u8 "xF4")             ),

        (key_name_C. K_HELP,           (u8 "Help")            ),
        (key_name_C. K_UNDO,           (u8 "Undo")            ),
        (key_name_C. K_INS,            (u8 "Insert")          ),
        (key_name_C. K_INS,            (u8 "Ins")             ),  ;; alternative name
        (key_name_C. K_KINS,           (u8 "kInsert")         ),
        (key_name_C. K_HOME,           (u8 "Home")            ),
        (key_name_C. K_KHOME,          (u8 "kHome")           ),
        (key_name_C. K_XHOME,          (u8 "xHome")           ),
        (key_name_C. K_ZHOME,          (u8 "zHome")           ),
        (key_name_C. K_END,            (u8 "End")             ),
        (key_name_C. K_KEND,           (u8 "kEnd")            ),
        (key_name_C. K_XEND,           (u8 "xEnd")            ),
        (key_name_C. K_ZEND,           (u8 "zEnd")            ),
        (key_name_C. K_PAGEUP,         (u8 "PageUp")          ),
        (key_name_C. K_PAGEDOWN,       (u8 "PageDown")        ),
        (key_name_C. K_KPAGEUP,        (u8 "kPageUp")         ),
        (key_name_C. K_KPAGEDOWN,      (u8 "kPageDown")       ),

        (key_name_C. K_KPLUS,          (u8 "kPlus")           ),
        (key_name_C. K_KMINUS,         (u8 "kMinus")          ),
        (key_name_C. K_KDIVIDE,        (u8 "kDivide")         ),
        (key_name_C. K_KMULTIPLY,      (u8 "kMultiply")       ),
        (key_name_C. K_KENTER,         (u8 "kEnter")          ),
        (key_name_C. K_KPOINT,         (u8 "kPoint")          ),

        (key_name_C. K_K0,             (u8 "k0")              ),
        (key_name_C. K_K1,             (u8 "k1")              ),
        (key_name_C. K_K2,             (u8 "k2")              ),
        (key_name_C. K_K3,             (u8 "k3")              ),
        (key_name_C. K_K4,             (u8 "k4")              ),
        (key_name_C. K_K5,             (u8 "k5")              ),
        (key_name_C. K_K6,             (u8 "k6")              ),
        (key_name_C. K_K7,             (u8 "k7")              ),
        (key_name_C. K_K8,             (u8 "k8")              ),
        (key_name_C. K_K9,             (u8 "k9")              ),

        (key_name_C. (int \<),         (u8 "lt")              ),

        (key_name_C. K_DROP,           (u8 "Drop")            ),
        (key_name_C. K_ZERO,           (u8 "Nul")             ),

        (key_name_C. K_CURSORHOLD,     (u8 "CursorHold")      ),
    ])

;; Check if there is a special key code for "key" that includes the modifiers specified.

(defn- #_int simplify-key [#_int key, #_int' a'modifiers]
    (if (flag? @a'modifiers (| MOD_MASK_SHIFT MOD_MASK_CTRL MOD_MASK_ALT))
        ;; TAB is a special case.
        (if (and (== key TAB) (flag? @a'modifiers MOD_MASK_SHIFT))
            (do (swap! a'modifiers & (bit-not MOD_MASK_SHIFT))
                K_S_TAB)
            (let [#_byte* t modifier_keys_table #_byte key0 (KEY2TERMCAP0 key) #_byte key1 (KEY2TERMCAP1 key)]
                (loop-when [#_int i 0] (!= (... t i) NUL) => key
                    (if (and (== key0 (... t (+ i 3))) (== key1 (... t (+ i 4))) (non-zero? (& @a'modifiers (char_u (... t i)))))
                        (do (swap! a'modifiers & (bit-not (char_u (... t i))))
                            (TERMCAP2KEY (... t (+ i 1)), (... t (+ i 2))))
                        (recur (+ i MOD_KEYS_ENTRY_SIZE))
                    ))
            ))
        key
    ))

;; Change <xHome> to <Home>, <xUp> to <Up>, etc.

(defn- #_int handle-x-keys [#_int key]
    (condp == key
        K_XUP    K_UP
        K_XDOWN  K_DOWN
        K_XLEFT  K_LEFT
        K_XRIGHT K_RIGHT
        K_XHOME  K_HOME
        K_ZHOME  K_HOME
        K_XEND   K_END
        K_ZEND   K_END
        K_XF1    K_F1
        K_XF2    K_F2
        K_XF3    K_F3
        K_XF4    K_F4
        K_S_XF1  K_S_F1
        K_S_XF2  K_S_F2
        K_S_XF3  K_S_F3
        K_S_XF4  K_S_F4
        :else    key
    ))

;; Return a string which contains the name of the given key when the given modifiers are down.

(defn- #_Bytes get-special-key-name [#_int c, #_int modifiers]
    ;; Key, that stands for a normal character.
    (let [c (if (and (is-special c) (== (KEY2TERMCAP0 c) KS_KEY)) (char_u (KEY2TERMCAP1 c)) c)
          ;; Translate shifted special keys into unshifted keys and set modifier.
          ;; Same for CTRL and ALT modifiers.
          [modifiers c]
            (if (is-special c)
                (let [#_byte* t modifier_keys_table #_byte key0 (KEY2TERMCAP0 c) #_byte key1 (KEY2TERMCAP1 c)]
                    (loop-when [#_int i 0] (!= (... t i) NUL) => [modifiers c]
                        (if (and (== key0 (... t (+ i 1))) (== key1 (... t (+ i 2))))
                            [(| modifiers (char_u (... t i))) (TERMCAP2KEY (... t (+ i 3)), (... t (+ i 4)))]
                            (recur (+ i MOD_KEYS_ENTRY_SIZE))
                        )))
                [modifiers c])
          ;; try to find the key in the special key table
          #_Bytes y (find-special-key-name c)
          ;; When not a known special key, and not a printable character, try to extract modifiers.
          [c modifiers y]
            (if (and (< 0 c) (== (utf-char2len c) 1))
                (let [[c modifiers y]
                        (if (and (nil? y) (or (not (vim-isprintc c)) (== (& c 0x7f) (byte \space))) (!= (& c 0x80) NUL))
                            (let [c (& c 0x7f) modifiers (| modifiers MOD_MASK_ALT)]
                                ;; try again, to find the un-ALTed key in the special key table
                                [c modifiers (find-special-key-name c)])
                            [c modifiers y]
                        )]
                    (if (and (nil? y) (not (vim-isprintc c)) (< c (byte \space)))
                        [(+ c (byte \@)) (| modifiers MOD_MASK_CTRL) y]
                        [c modifiers y]
                    ))
                [c modifiers y])
          #_Bytes k (Bytes. (inc MAX_KEY_NAME_LEN)) k! #(do (.be k %1, %2) (inc %1))
          #_int x (k! 0, (byte \<))
          ;; translate the modifier into a string
          x (let [t mod_mask_table n (count t)]
                (loop-when [x x #_int i 0] (and (< i n) (!= (:name (... t i)) (byte \A))) => x
                    (let [x (if (== (& modifiers (:mod_mask (... t i))) (:mod_flag (... t i))) (-> x (k! (:name (... t i))) (k! (byte \-))) x)]
                        (recur x (inc i)))
                ))
          x (cond (some? y) ;; use name of special key
                (do (STRCPY (.plus k x), y) (STRLEN k))
            (is-special c) ;; unknown special key, may output t_xx
                (-> x (k! (byte \t)) (k! (byte \_)) (k! (KEY2TERMCAP0 c)) (k! (KEY2TERMCAP1 c)))
            ;; Not a special key, only modifiers, output directly.
            (< 1 (utf-char2len c))
                (+ x (utf-char2bytes c, (.plus k x)))
            (vim-isprintc c)
                (k! x, c)
            :else
                (let [#_Bytes s (transchar c)]
                    (loop-when-recur [x x #_int i 0] (non-eos? s i) [(inc x) (inc i)] => x
                        (.be k x, (.at s i)))
                ))
          x (k! x, (byte \>))]
        (eos! k x)
    ))

;; Try to find the name of key "c" in the special key table.

(defn- #_Bytes find-special-key-name [#_int c]
    (let [t key_names_table n (count t)]
        (loop-when [i 0] (< i n) => nil
            (recur-if (!= (:key (... t i)) c) [(inc i)] => (:name (... t i))))
    ))

;; VISUAL, SELECTMODE and OP_PENDING State are never set, they are equal to
;; NORMAL State with a condition.  This function returns the real State.

(defn- #_int get-real-state []
    (if (flag? @State NORMAL)
        (cond
            @VIsual_active (if @VIsual_select SELECTMODE VISUAL)
            @finish_op OP_PENDING
            :else @State
        )
        @State
    ))

;;; ============================================================================================== VimT

;; Return true if the CursorHold event can be triggered.

(defn- #_boolean trigger-cursorhold []
    (let [miez? false]
        (and (not @did_cursorhold) miez? (not @Recording) (zero? (:tb_len @typebuf)) (let [state (get-real-state)] (or (== state NORMAL_BUSY) (flag? state INSERT))))
    ))

;;; ============================================================================================== VimU

;; undo.c: multi level undo facility
;;
;; The saved lines are stored in a list of lists (one for each buffer):
;;
;; b_u_oldhead -----------------------------------------------+
;;                                                            |
;;                                                            V
;;                +--------------+    +--------------+    +--------------+
;; b_u_newhead -->| u_header     |    | u_header     |    | u_header     |
;;                |     uh_next ----->|     uh_next ----->|     uh_next ---> nil
;;         nil <------- uh_prev  |<-------- uh_prev  |<-------- uh_prev  |
;;                |     uh_entry |    |     uh_entry |    |     uh_entry |
;;                +--------|-----+    +--------|-----+    +--------|-----+
;;                         |                   |                   |
;;                         V                   V                   V
;;                +--------------+    +--------------+    +--------------+
;;                | u_entry      |    | u_entry      |    | u_entry      |
;;                |     ue_next  |    |     ue_next  |    |     ue_next  |
;;                +--------|-----+    +--------|-----+    +--------|-----+
;;                         |                   |                   |
;;                         V                   V                   V
;;                +--------------+            nil                 nil
;;                | u_entry      |
;;                |     ue_next  |
;;                +--------|-----+
;;                         |
;;                         V
;;                        etc.
;;
;; Each u_entry list contains the information for one undo or redo.
;; "b_u_curhead" points to the header of the last undo (the next redo),
;; or is null if nothing has been undone (end of the branch).

;; Used in undo_end() to report number of added and deleted lines.

(atom! long     u_newcount)
(atom! long     u_oldcount)

;; When 'u' flag included in 'cpoptions', we behave like vi.
;; Need to remember the action that "u" should do.

(atom! boolean  undo_undoes)

(atom! int      lastmark)

;; Save the current line for both the "u" and "U" command.
;; Returns true or false.

(defn- #_boolean u-save-cursor [#_window_C win]
    (let [lnum (-> win :w_cursor :lnum)]
        (u-save win, (dec lnum), (inc lnum))
    ))

;; Save the lines between "top" and "bot" for both the "u" and "U" command.
;; "top" may be 0 and bot may be curbuf.b_ml.ml_line_count + 1.
;; Returns false when lines could not be saved, true otherwise.

(defn- #_boolean u-save [#_window_C win, #_long top, #_long bot]
    (let [lmax (line-count @curbuf)]
        (if (or (< lmax top) (<= bot top) (< (inc lmax) bot))
            false ;; rely on caller to do error messages
            (do
                (when (== (+ top 2) bot)
                    (u-saveline win, (inc top)))
                (u-savecommon? win, top, bot, 0)
            ))
    ))

;; Save the line "lnum" (used by ":s" and "~" command).
;; The line is replaced, so the new bottom line is lnum + 1.
;; Returns false when lines could not be saved, true otherwise.

(defn- #_boolean u-savesub [#_window_C win, #_long lnum]
    (u-savecommon? win, (dec lnum), (inc lnum), (inc lnum)))

;; A new line is inserted before line "lnum" (used by :s command).
;; The line is inserted, so the new bottom line is lnum + 1.
;; Returns false when lines could not be saved, true otherwise.

(defn- #_boolean u-inssub [#_window_C win, #_long lnum]
    (u-savecommon? win, (dec lnum), lnum, (inc lnum)))

;; Save the lines "lnum" - "lnum" + nlines (used by delete command).
;; The lines are deleted, so the new bottom line is lnum, unless the buffer becomes empty.
;; Returns false when lines could not be saved, true otherwise.

(defn- #_boolean u-savedel [#_window_C win, #_long lnum, #_long nlines]
    (u-savecommon? win, (dec lnum), (+ lnum nlines), (if (== nlines (line-count @curbuf)) 2 lnum)))

;; Return true when undo is allowed,
;; otherwise give an error message and return false.

(defn- #_[window_C boolean] undo-allowed? [#_window_C win]
    ;; Don't allow changes in the buffer while editing the cmdline,
    ;; the caller of getcmdline() may get confused.
    (if (zero? @textlock) [win true] [(emsg win, e_secure) false]))

;; Get the 'undolevels' value for the current buffer.

(defn- #_long get-undolevels []
    @(:b_p_ul @curbuf))

;; Common code for various ways to save text before a change.
;;
;; "top" is the line above the first changed line.
;; "bot" is the line below the last changed line.
;; "newbot" is the new bottom line.  Use zero when not known.
;;
;; Returns false when lines could not be saved, true otherwise.

(defn- #_[window_C boolean] u-savecommon? [#_window_C win, #_long top, #_long bot, #_long newbot]
    ;; When making changes is not allowed, return false.
    ;; It's a crude way to make all change commands fail.
    (let-when [[win ?] (undo-allowed? win)] ? => [win false]
        ;; This happens when the FileChangedRO autocommand changes the file in a way it becomes shorter.
        (let-when [lmax (line-count @curbuf)] (<= bot (inc lmax)) => [(emsg win, (u8 "E881: Line count changed unexpectedly")) false]
            (let-when [#_long size (- bot top 1)
                  [win _] ;; If "b_u_synced" is true, make a new header.
            ] (nil? _) => [win _]

                    (cond (:b_u_synced @curbuf)
                        (do ;; Need to create new entry in "b_changelist".
                            (swap! curbuf assoc :b_new_change true)
                            ;; If we undid more than we redid, move the entry lists before and including "b_u_curhead" to an alternate branch.
                            (let-when [#_int i (:b_u_current @curbuf)] (< i (count (:b_u_headers @curbuf)))
                                (swap! curbuf update :b_u_headers subvec 0 i))
                            ;; Free headers to keep the size right.
                            (let-when [#_int m (get-undolevels) #_int n (count (:b_u_headers @curbuf))] (< 0 m n)
                                (swap! curbuf update :b_u_headers subvec (- n m) n)
                                (swap! curbuf update :b_u_current - (- n m)))
                            (if (< (get-undolevels) 0) ;; no undo at all
                                (do (swap! curbuf assoc :b_u_synced false)
                                    [win true])
                                (do (swap! curbuf update :b_u_seq_last inc)
                                    (swap! curbuf update :b_u_headers conj
                                        (u_header_C.
                                            #_:uh_seq       (:b_u_seq_last @curbuf)
                                            #_:uh_entries   []
                                            #_:uh_getbot    nil
                                            #_:uh_cursor    (:w_cursor win)
                                            #_:uh_vcol      (if (and (virtual-active) (< 0 (:coladd (:w_cursor win)))) (getviscol win) -1)
                                            #_:uh_flags     (+ (if @(:b_changed @curbuf) UH_CHANGED 0) (if (:ml_empty (:b_ml @curbuf)) UH_EMPTYBUF 0))
                                            #_:uh_namedm    (:b_namedm @curbuf)
                                            #_:uh_visual    (:b_visual @curbuf)
                                            #_:uh_time      (ร ._time libC)
                                        ))
                                    (swap! curbuf update :b_u_current inc)
                                    [win nil])
                            ))
                    (< (get-undolevels) 0) ;; no undo at all
                        [win true]
                    :else
                        (let-when [[win _]
                                ;; When saving a single line, and it has been saved just before, it doesn't make sense saving it again.
                                ;; Saves a lot of memory when making lots of changes inside the same line.
                                ;; This is only possible if the previous change didn't increase or decrease the number of lines.
                                ;; Check the ten last changes.  More doesn't make sense and takes too long.
                        ] (nil? _) => [win _]

                                (when' (== size 1) => [win nil]
                                    (let [#_int n (count (:b_u_headers @curbuf)) #_u_header_C uhp (... (:b_u_headers @curbuf) (dec n))
                                          #_int m (count (:uh_entries uhp)) #_u_entry_C getbot' (:uh_getbot uhp)]
                                        (loop-when [#_int i 0] (and (< i m) (< i 10)) => [win nil]
                                            ;; If lines have been inserted/deleted, we give up.
                                            ;; Also when the line was included in a multi-line save.
                                            (let-when [#_u_entry_C uep (... (:uh_entries uhp) i) top' (:ue_top uep) bot' (:ue_bot uep) size' (:ue_size uep)]
                                                      (and (if (== getbot' uep) (== (:ue_lcount uep) lmax) (== (+ top' size' 1) (if (zero? bot') (inc lmax) bot')))
                                                           (not (and (< 1 size') (<= top' top) (<= (+ top 2) (+ top' size' 1)))))
                                                   => [win nil]
                                                ;; If it's the same line, we can skip saving it again.
                                                (when' (and (== size' 1) (== top' top)) => (recur (inc i))
%%                                                  (when (< 0 i)
                                                        ;; It's not the last entry: get "ue_bot" for the last entry now.
                                                        ;; Following deleted/inserted lines go to the re-used entry.
                                                        ((ร win =) (u-getbot win))
                                                        (swap! curbuf assoc :b_u_synced false)
                                                        ;; Move the found entry to become the last entry.
                                                        ;; The order of undo/redo doesn't matter for the entries we move it over,
                                                        ;; since they don't change the line count and don't include this line.
                                                        ;; It does matter for the found entry if the line count is changed by the executed command.
                                                        ((ร prev_uep =) (assoc prev_uep :ue_next (:ue_next uep)))
                                                        ((ร uep =) (assoc uep :ue_next (:uh_entry (:b_u_newhead @curbuf))))
                                                        (swap! curbuf assoc-in [:b_u_newhead :uh_entry] uep)
                                                    )
                                                    ;; The executed command may change the line count.
                                                    (cond (non-zero? newbot)
                                                        ((ร uep =) (assoc uep :ue_bot newbot))
                                                    (< lmax bot)
                                                        ((ร uep =) (assoc uep :ue_bot 0))
                                                    :else
                                                    (do
                                                        ((ร uep =) (assoc uep :ue_lcount lmax))
                                                        (swap! curbuf assoc-in [:b_u_newhead :uh_getbot] uep)
                                                    ))
                                                    [win true]
                                                )
                                            )
                                        )
                                    )
                                )

                            ;; Find line number for "ue_bot" for previous u-save().
                            [(u-getbot win) nil]
                        )
                    )

                ;; add lines in front of entry list

                ((ร u_entry_C uep =) (NEW_u_entry_C))

                ((ร uep =) (assoc uep :ue_size size))
                ((ร uep =) (assoc uep :ue_top top))
                (cond (non-zero? newbot)
                (do
                    ((ร uep =) (assoc uep :ue_bot newbot))
                )
                ;; Use 0 for "ue_bot" if bot is below last line.
                ;; Otherwise we have to compute "ue_bot" later.
                (< lmax bot)
                (do
                    ((ร uep =) (assoc uep :ue_bot 0))
                )
                :else
                (do
                    ((ร uep =) (assoc uep :ue_lcount lmax))
                    (swap! curbuf assoc-in [:b_u_newhead :uh_getbot] uep)
                ))

                (cond (< 0 size)
                (do
                    ((ร uep =) (assoc uep :ue_array (Bytes* size)))
                    ((ร uep =) (loop-when [#_long lnum (inc top) #_int i 0] (< i size) => uep
                        (if (fast-breakcheck)
                            ((ร RETURN) [win false])
                        )
                        ((ร uep =) (assoc-in uep [:ue_array i] (STRDUP (ml-get lnum))))
                        (recur (inc lnum) (inc i))
                    ))
                )
                :else
                (do
                    ((ร uep =) (assoc uep :ue_array nil))
                ))
                ((ร uep =) (assoc uep :ue_next (:uh_entry (:b_u_newhead @curbuf))))
                (swap! curbuf assoc-in [:b_u_newhead :uh_entry] uep)
                (swap! curbuf assoc :b_u_synced false)
                (reset! undo_undoes false)

                [win true]
            )
        )
    ))

;; If 'cpoptions' contains 'u': Undo the previous undo or redo (vi compatible).
;; If 'cpoptions' does not contain 'u': Always undo.

(defn- #_window_C u-undo [#_window_C win, #_int n]
    ;; If we get an undo command while executing a macro, we behave like the original vi.
    ;; If this happens twice in one macro, the result will not be compatible.
    (let [[win n] (if (not (:b_u_synced @curbuf)) [(u-sync win, true) 1] [win n])]
        (if (nil? (vim-strbyte @p_cpo, CPO_UNDO))
            (reset! undo_undoes true)
            (swap! undo_undoes not))
        (u-doit win, n)
    ))

;; If 'cpoptions' contains 'u': Repeat the previous undo or redo.
;; If 'cpoptions' does not contain 'u': Always redo.

(defn- #_window_C u-redo [#_window_C win, #_int n]
    (when (nil? (vim-strbyte @p_cpo, CPO_UNDO))
        (reset! undo_undoes false))
    (u-doit win, n))

;; Undo or redo, depending on "undo_undoes", "n" times.

(defn- #_window_C u-doit [#_window_C win, #_int n]
    (let-when [[win ?] (undo-allowed? win)] ? => win
        (reset! u_newcount 0)
        (reset! u_oldcount (if (:ml_empty (:b_ml @curbuf)) -1 0))
        (let [m (count (:b_u_headers @curbuf))
              [win e]
                (loop-when [win win i n] (< 0 i) => [win nil]
                    (cond @undo_undoes
                        (when' (< 0 (:b_u_current @curbuf)) => [(beep-flush win) (when (== i n) (u8 "Already at oldest change"))]
                            (swap! curbuf update :b_u_current dec)
                            (recur (u-undoredo win, true) (dec i)))
                    :else
                        (when' (< (:b_u_current @curbuf) m) => [(beep-flush win) (when (== i n) (u8 "Already at newest change"))]
                            (let [win (u-undoredo win, false)]
                                (swap! curbuf update :b_u_current inc)
                                (recur win (dec i)))
                        ))
                )]
            (if (some? e) (msg win, e) (u-undo-end win, @undo_undoes, false))
        )
    ))

;; Common code for undo and redo.
;;
;; The lines in the file are replaced by the lines in the entry list at "b_u_curhead".
;; The replaced lines in the file are saved in the entry list for the next undo/redo.
;;
;; When "undo" is true, we go up in the tree; when false, we go down.

(defn- #_window_C u-undoredo [#_window_C win, #_boolean undo]
    (ยง
        ((ร Bytes[] newarray =) nil)
        ((ร long newlnum =) MAXLNUM)
        ((ร u_entry_C newlist =) nil)
        ((ร u_header_C curhead =) (:b_u_curhead @curbuf))

        ((ร int old_flags =) (:uh_flags curhead))
        ((ร int new_flags =) (+ (if @(:b_changed @curbuf) UH_CHANGED 0) (if (:ml_empty (:b_ml @curbuf)) UH_EMPTYBUF 0)))
        ((ร win =) (setpcmark win))

        ;; save marks before undo/redo

        ((ร pos_C[] namedm =) (ARRAY-pos NMARKS))
        (dotimes [#_int i NMARKS]
            ((ร namedm =) (assoc namedm i (... (:b_namedm @curbuf) i)))
        )

        ((ร visualinfo_C visualinfo =) (:b_visual @curbuf))

        (swap! curbuf update :b_op_start assoc :lnum (line-count @curbuf) :col 0)
        (swap! curbuf update :b_op_end assoc :lnum 0 :col 0)

        ((ร FOR) (ร ((ร u_entry_C uep =) (ร curhead.uh_entry, nuep)) (some? uep) ((ร uep =) nuep))
            ((ร long top =) (:ue_top uep))
            ((ร long bot =) (:ue_bot uep))
            ((ร bot =) (if (zero? bot) (inc (line-count @curbuf)) bot))
            (when (or (> top (line-count @curbuf)) (<= bot top) (> bot (inc (line-count @curbuf))))
                ((ร win =) (emsg win, (u8 "E438: u-undo: line numbers wrong")))
                (swap! curbuf changed)          ;; don't want UNCHANGED now
                ((ร RETURN) win)
            )

            ((ร int oldsize =) (int (- bot top 1)))       ;; number of lines before undo
            ((ร int newsize =) (int (:ue_size uep)))         ;; number of lines after undo

            (when (< top newlnum)
                ;; If the saved cursor is somewhere in this undo block,
                ;; move it to the remembered position.
                ;; Makes "gwap" put the cursor back where it was.
                ((ร long lnum =) (:lnum (:uh_cursor curhead)))
                (cond (and (<= top lnum) (<= lnum (+ top newsize 1)))
                (do
                    ((ร win =) (assoc win :w_cursor (:uh_cursor curhead)))
                    ((ร newlnum =) (dec (:lnum (:w_cursor win))))
                )
                :else
                (do
                    ;; Use the first line that actually changed.
                    ;; Avoids that undoing auto-formatting puts the cursor in the previous line.
                    ((ร int i =) (loop-when-recur [i 0] (and (< i newsize) (< i oldsize) (zero? (STRCMP (... (:ue_array uep) i), (ml-get (+ top 1 i))))) [(inc i)] => i))
                    (cond (and (== i newsize) (== newlnum MAXLNUM) (nil? (:ue_next uep)))
                    (do
                        ((ร newlnum =) top)
                        ((ร win =) (assoc-in win [:w_cursor :lnum] (inc newlnum)))
                    )
                    (< i newsize)
                    (do
                        ((ร newlnum =) (+ top i))
                        ((ร win =) (assoc-in win [:w_cursor :lnum] (inc newlnum)))
                    ))
                ))
            )

            ((ร boolean empty_buffer =) false)   ;; buffer became empty

            ;; delete the lines between top and bot and save them in "newarray"
            (cond (< 0 oldsize)
            (do
                ((ร newarray =) (Bytes* oldsize))

                ;; delete backwards, it goes faster in most cases
                (loop-when-recur [#_int i (dec oldsize) #_long lnum (dec bot)] (<= 0 i) [(dec i) (dec lnum)]
                    ((ร newarray[i] =) (STRDUP (ml-get lnum)))
                    ;; remember we deleted the last line in the buffer,
                    ;; and a dummy empty line will be inserted
                    ((ร empty_buffer =) (or (== (line-count @curbuf) 1) empty_buffer))
                    (ml-delete lnum, false)
                )
            )
            :else
            (do
                ((ร newarray =) nil)
            ))

            ;; insert the lines in u_array between top and bot
            (loop-when-recur [#_int i 0 #_long lnum top] (< i newsize) [(inc i) (inc lnum)]
                ;; If the file is empty, there is an empty line 1 that we
                ;; should get rid of, by replacing it with the new line.

                (if (and empty_buffer (zero? lnum))
                    (ml-replace 1, (... (:ue_array uep) i))
                    (ml-append lnum, (... (:ue_array uep) i)))
            )

            ;; adjust marks
            (when (!= oldsize newsize)
                ((ร win =) (mark-adjust win, (inc top), (+ top oldsize), MAXLNUM, (- newsize oldsize)))
                (when (> (:lnum (:b_op_start @curbuf)) (+ top oldsize))
                    (swap! curbuf update-in [:b_op_start :lnum] + (- newsize oldsize)))
                (when (> (:lnum (:b_op_end @curbuf)) (+ top oldsize))
                    (swap! curbuf update-in [:b_op_end :lnum] + (- newsize oldsize)))
            )

            (swap! curbuf changed-lines (inc top), 0, bot, (- newsize oldsize))

            ;; set '[ and '] mark
            (swap! curbuf assoc-in [:b_op_start :lnum] (min (:lnum (:b_op_start @curbuf)) (inc top)))

            (cond (and (zero? newsize) (< (:lnum (:b_op_end @curbuf)) (inc top)))
            (do
                (swap! curbuf assoc-in [:b_op_end :lnum] (inc top))
            )
            (< (:lnum (:b_op_end @curbuf)) (+ top newsize))
            (do
                (swap! curbuf assoc-in [:b_op_end :lnum] (+ top newsize))
            ))

            (swap! u_newcount + newsize)
            (swap! u_oldcount + oldsize)
            ((ร uep =) (assoc uep :ue_size oldsize))
            ((ร uep =) (assoc uep :ue_array newarray))
            ((ร uep =) (assoc uep :ue_bot (+ top newsize 1)))

            ;; insert this entry in front of the new entry list

            ((ร nuep =) (:ue_next uep))
            ((ร uep =) (assoc uep :ue_next newlist))
            ((ร newlist =) uep)
        )

        ((ร curhead =) (assoc curhead :uh_entry newlist))
        ((ร curhead =) (assoc curhead :uh_flags new_flags))
        (when (and (flag? old_flags UH_EMPTYBUF) (bufempty))
            (swap! curbuf assoc-in [:b_ml :ml_empty] true))
        (if (flag? old_flags UH_CHANGED)
            (swap! curbuf changed)
            (swap! curbuf unchanged))

        ;; restore marks from before undo/redo

        (dotimes [#_int i NMARKS]
            (if (non-zero? (:lnum (... (:uh_namedm curhead) i)))
                (swap! curbuf assoc-in [:b_namedm i] (... (:uh_namedm curhead) i)))
            (if (non-zero? (:lnum (... namedm i)))
                ((ร curhead =) (assoc-in curhead [:uh_namedm i] (... namedm i)))
                ((ร curhead =) (assoc-in curhead [:uh_namedm i :lnum] 0))
            )
        )
        (when (non-zero? (:lnum (:vi_start (:uh_visual curhead))))
            (swap! curbuf assoc :b_visual (:uh_visual curhead))
            ((ร curhead =) (assoc curhead :uh_visual visualinfo))
        )

        ;; If the cursor is only off by one line,
        ;; put it at the same position as before starting the change (for the "o" command).
        ;; Otherwise the cursor should go to the first undone line.

        (when (and (== (inc (:lnum (:uh_cursor curhead))) (:lnum (:w_cursor win))) (< 1 (:lnum (:w_cursor win))))
            ((ร win =) (update-in win [:w_cursor :lnum] dec)))
        (cond (<= (:lnum (:w_cursor win)) (line-count @curbuf))
        (do
            (cond (== (:lnum (:uh_cursor curhead)) (:lnum (:w_cursor win)))
            (do
                ((ร win =) (assoc-in win [:w_cursor :col] (:col (:uh_cursor curhead))))
                (if (and (virtual-active) (<= 0 (:uh_vcol curhead)))
                    ((ร win =) (coladvance win, (:uh_vcol curhead)))
                    ((ร win =) (assoc-in win [:w_cursor :coladd] 0))
                )
            )
            :else
            (do
                ((ร win =) (beginline win, (| BL_SOL BL_FIX)))
            ))
        )
        :else
        (do
            ;; We get here with the current cursor line being past the end (e.g.
            ;; after adding lines at the end of the file, and then undoing it).
            ;; check-cursor() will move the cursor to the last line.  Move it to
            ;; the first column here.
            ((ร win =) (update win :w_cursor assoc :col 0 :coladd 0))
        ))

        ;; Make sure the cursor is on an existing line and column.
        ((ร win =) (check-cursor win))
        win
    ))

;; If we deleted or added lines, report the number of less/more lines.
;; Otherwise, report the number of changes
;; (this may be incorrect in some cases, but it's better than nothing).

(defn- #_window_C u-undo-end [#_window_C win, #_boolean did_undo, #_boolean absolute]
    ;; did_undo: just did an undo
    ;; absolute: used ":undo N"
    (when' (messaging) => win
        (when (:ml_empty (:b_ml @curbuf))
            (swap! u_newcount dec))
        (swap! u_oldcount - @u_newcount)
        (let [#_Bytes msgstr
                (cond
                    (==  @u_oldcount -1) (u8 "more line")
                    (<   @u_oldcount  0) (u8 "more lines")
                    (==  @u_oldcount  1) (u8 "line less")
                    (< 1 @u_oldcount)    (u8 "fewer lines")
                    :else (do
                        (reset! u_oldcount @u_newcount)
                        (if (== @u_newcount 1) (u8 "change") (u8 "changes"))
                    ))
              #_int i (:b_u_current @curbuf) #_int n (count (:b_u_headers @curbuf))
              [#_u_header_C uhp did_undo]
                (cond
                    (== i n)               [(when (< 0 n) (... (:b_u_headers @curbuf) (dec n))) did_undo]
                    ;; For ":undo N" we prefer a "after #N" message.
                    (and absolute (< 0 i)) [(... (:b_u_headers @curbuf) (dec i)) false]
                    did_undo               [(... (:b_u_headers @curbuf) i) did_undo]
                    :else                  [(when (< 0 i) (... (:b_u_headers @curbuf) (dec i))) did_undo]
                )
              #_Bytes msgbuf (Bytes. 80)]
            (if (some? uhp)
                (u-add-time msgbuf, (.size msgbuf), (:uh_time uhp))
                (eos! msgbuf))
            (msg* win, (u8 "%ld %s; %s #%ld  %s"), (if (< @u_oldcount 0) (- @u_oldcount) @u_oldcount), msgstr,
                                                   (if did_undo (u8 "before") (u8 "after")), (if (some? uhp) (:uh_seq uhp) 0), msgbuf)
        )
    ))

;; Stop adding to the current entry list.

(defn- #_window_C u-sync [#_window_C win, #_boolean force]
    ;; force: sync even if "no_u_sync" is set
    (cond (or (:b_u_synced @curbuf) (and (not force) (< 0 @no_u_sync)))
        win
    (< (get-undolevels) 0)
        (do (swap! curbuf assoc :b_u_synced true)
            win)
    :else
        (let [win (u-getbot win)]
            (swap! curbuf assoc :b_u_current (count (:b_u_headers @curbuf)))
            win)
    ))

;; Put the timestamp of an undo header in "buf[buflen]" in a nice format.

(defn- #_void u-add-time [#_Bytes buf, #_int buflen, #_long seconds]
    (if (<= 100 (- (ร ._time libC) seconds))
        (let [#_tm_C curtime (ร ._localtime libC seconds)]
            (if (< (- (ร ._time libC) seconds) (* 60 60 12))
                ;; within 12 hours
                (ร .strftime libC buf, buflen, (u8 "%H:%M:%S"), curtime)
                ;; longer ago
                (ร .strftime libC buf, buflen, (u8 "%Y/%m/%d %H:%M:%S"), curtime)
            ))
        (ร .sprintf libC buf, (u8 "%ld seconds ago"), (- (ร ._time libC) seconds)))
    nil)

;; Compute the line number of the last u-save().
;; It is called only when "b_u_synced" is false.

(defn- #_window_C u-getbot [#_window_C win]
    (let [#_int n (count (:b_u_headers @curbuf)) #_u_header_C uhp (... (:b_u_headers @curbuf) (dec n)) #_u_entry_C uep (:uh_getbot uhp)
          win (when' (some? uep) => win
                (let [lmax (line-count @curbuf)
                      ;; The new "ue_bot" is computed from the number of lines that has been inserted (0 - deleted) since calling u-save().
                      ;; This is equal to the old line count subtracted from the current line count.
                      uep (assoc uep :ue_bot (+ (:ue_top uep) (:ue_size uep) 1 (- lmax (:ue_lcount uep))))
                      [win uep]
                        (when' (not (<= 1 (:ue_bot uep) lmax)) => [win uep]
                            ;; Assume all lines deleted, will get all the old lines back without deleting the current ones.
                            [(emsg win, (u8 "E440: undo line missing")) (assoc uep :ue_bot (inc (:ue_top uep)))]
                        )]
;                   %% poor "uep" !!
                    (swap! curbuf assoc-in [:b_u_headers (dec n) :uh_getbot] nil)
                    win)
            )]
        (swap! curbuf assoc :b_u_synced true)
        win
    ))

;; Save the line "lnum" for the "U" command.

(defn- #_void u-saveline [#_window_C win, #_long lnum]
    (when (and (!= lnum (:b_u_line_lnum @curbuf)) (<= 1 lnum (line-count @curbuf)))
        (u-clearline)
        (let [cursor (:w_cursor win)]
            (swap! curbuf assoc
                :b_u_line_lnum lnum
                :b_u_line_colnr (if (== (:lnum cursor) lnum) (:col cursor) 0)
                :b_u_line_ptr (STRDUP (ml-get lnum)))
        ))
    nil)

;; Clear the line saved for the "U" command.
;; (this is used externally for crossing a line while in insert mode)

(defn- #_void u-clearline []
    (when (some? (:b_u_line_ptr @curbuf))
        (swap! curbuf assoc :b_u_line_ptr nil :b_u_line_lnum 0))
    nil)

;; Implementation of the "U" command.
;; Differentiation from vi: "U" can be undone with the next "U".
;; We also allow the cursor to be in another line.

(defn- #_window_C u-undoline [#_window_C win]
    (let-when [uln (:b_u_line_lnum @curbuf)] (and (some? (:b_u_line_ptr @curbuf)) (<= uln (line-count @curbuf))) => (beep-flush win)
        (when' (u-savecommon? win, (dec uln), (inc uln), 0) => win
            (let [#_Bytes s (STRDUP (ml-get uln))]
                (ml-replace uln, (:b_u_line_ptr @curbuf))
                (changed-bytes uln, 0)
                (swap! curbuf assoc :b_u_line_ptr s)
                (let [#_int swp (:b_u_line_colnr @curbuf)]
                    (when (== (:lnum (:w_cursor win)) uln)
                        (swap! curbuf assoc :b_u_line_colnr (:col (:w_cursor win))))
                    (-> win
                        (update :w_cursor assoc :lnum uln :col swp)
                        (check-cursor-col)
                    ))
            ))
    ))

;;; ============================================================================================== VimV

;; term.c: functions for controlling the terminal -------------------------------------------------

;; Each termcap is a list of btcap_C structures.
;; 'bt_key' is either a KS_xxx code (>= 0), or a K_xxx code.

(class! #_final btcap_C
    [
        (field int      bt_key)
        (field Bytes    bt_seq)
    ])

(final btcap_C* xterm_tcaps
    [
        (btcap_C. KS_NAME,      (u8 "xterm")                ),

        (btcap_C. KS_CE,        (u8 "\033[K")               ),
        (btcap_C. KS_AL,        (u8 "\033[L")               ),
        (btcap_C. KS_CAL,       (u8 "\033[%p1%dL")          ),
        (btcap_C. KS_DL,        (u8 "\033[M")               ),
        (btcap_C. KS_CDL,       (u8 "\033[%p1%dM")          ),
        (btcap_C. KS_CS,        (u8 "\033[%i%p1%d;%p2%dr")  ),
        (btcap_C. KS_CL,        (u8 "\033[H\033[2J")        ),
        (btcap_C. KS_CD,        (u8 "\033[J")               ),
        (btcap_C. KS_ME,        (u8 "\033[m")               ),
        (btcap_C. KS_MR,        (u8 "\033[7m")              ),
        (btcap_C. KS_MD,        (u8 "\033[1m")              ),
        (btcap_C. KS_UE,        (u8 "\033[m")               ),
        (btcap_C. KS_US,        (u8 "\033[4m")              ),
        (btcap_C. KS_MS,        (u8 "y")                    ),
        (btcap_C. KS_UT,        (u8 "y")                    ),
        (btcap_C. KS_LE,        (u8 "\b")                   ),
        (btcap_C. KS_CM,        (u8 "\033[%i%p1%d;%p2%dH")  ),
        (btcap_C. KS_SR,        (u8 "\033M")                ),
        (btcap_C. KS_CRI,       (u8 "\033[%p1%dC")          ),
        (btcap_C. KS_KS,        (u8 "\033[?1h\033=")        ),
        (btcap_C. KS_KE,        (u8 "\033[?1l\033>")        ),
        (btcap_C. KS_TI,        (u8 "\0337\033[?47h")       ),
        (btcap_C. KS_TE,        (u8 "\033[2J\033[?47l\0338")),
        (btcap_C. KS_CWS,       (u8 "\033[8;%p1%d;%p2%dt")  ),

        (btcap_C. K_UP,         (u8 "\033O*A")              ),
        (btcap_C. K_DOWN,       (u8 "\033O*B")              ),
        (btcap_C. K_RIGHT,      (u8 "\033O*C")              ),
        (btcap_C. K_LEFT,       (u8 "\033O*D")              ),
        ;; An extra set of cursor keys for vt100 mode.
        (btcap_C. K_XUP,        (u8 "\033[1;*A")            ),
        (btcap_C. K_XDOWN,      (u8 "\033[1;*B")            ),
        (btcap_C. K_XRIGHT,     (u8 "\033[1;*C")            ),
        (btcap_C. K_XLEFT,      (u8 "\033[1;*D")            ),
        ;; An extra set of function keys for vt100 mode.
        (btcap_C. K_XF1,        (u8 "\033O*P")              ),
        (btcap_C. K_XF2,        (u8 "\033O*Q")              ),
        (btcap_C. K_XF3,        (u8 "\033O*R")              ),
        (btcap_C. K_XF4,        (u8 "\033O*S")              ),
        (btcap_C. K_F1,         (u8 "\033[11;*~")           ),
        (btcap_C. K_F2,         (u8 "\033[12;*~")           ),
        (btcap_C. K_F3,         (u8 "\033[13;*~")           ),
        (btcap_C. K_F4,         (u8 "\033[14;*~")           ),
        (btcap_C. K_F5,         (u8 "\033[15;*~")           ),
        (btcap_C. K_F6,         (u8 "\033[17;*~")           ),
        (btcap_C. K_F7,         (u8 "\033[18;*~")           ),
        (btcap_C. K_F8,         (u8 "\033[19;*~")           ),
        (btcap_C. K_F9,         (u8 "\033[20;*~")           ),
        (btcap_C. K_F10,        (u8 "\033[21;*~")           ),
        (btcap_C. K_F11,        (u8 "\033[23;*~")           ),
        (btcap_C. K_F12,        (u8 "\033[24;*~")           ),
        (btcap_C. K_S_TAB,      (u8 "\033[Z")               ),
        (btcap_C. K_HELP,       (u8 "\033[28;*~")           ),
        (btcap_C. K_UNDO,       (u8 "\033[26;*~")           ),
        (btcap_C. K_INS,        (u8 "\033[2;*~")            ),
        (btcap_C. K_HOME,       (u8 "\033[1;*H")            ),
     ;; (btcap_C. K_S_HOME,     (u8 "\033O2H")              ),
     ;; (btcap_C. K_C_HOME,     (u8 "\033O5H")              ),
        (btcap_C. K_KHOME,      (u8 "\033[1;*~")            ),
        (btcap_C. K_XHOME,      (u8 "\033O*H")              ),      ;; other Home
        (btcap_C. K_ZHOME,      (u8 "\033[7;*~")            ),      ;; other Home
        (btcap_C. K_END,        (u8 "\033[1;*F")            ),
     ;; (btcap_C. K_S_END,      (u8 "\033O2F")              ),
     ;; (btcap_C. K_C_END,      (u8 "\033O5F")              ),
        (btcap_C. K_KEND,       (u8 "\033[4;*~")            ),
        (btcap_C. K_XEND,       (u8 "\033O*F")              ),      ;; other End
        (btcap_C. K_ZEND,       (u8 "\033[8;*~")            ),
        (btcap_C. K_PAGEUP,     (u8 "\033[5;*~")            ),
        (btcap_C. K_PAGEDOWN,   (u8 "\033[6;*~")            ),
        (btcap_C. K_KPLUS,      (u8 "\033O*k")              ),      ;; keypad plus
        (btcap_C. K_KMINUS,     (u8 "\033O*m")              ),      ;; keypad minus
        (btcap_C. K_KDIVIDE,    (u8 "\033O*o")              ),      ;; keypad /
        (btcap_C. K_KMULTIPLY,  (u8 "\033O*j")              ),      ;; keypad *
        (btcap_C. K_KENTER,     (u8 "\033O*M")              ),      ;; keypad Enter
        (btcap_C. K_KPOINT,     (u8 "\033O*n")              ),      ;; keypad .
        (btcap_C. K_KDEL,       (u8 "\033[3;*~")            ),      ;; keypad Del
    ])

(atom! boolean need_gather)                     ;; need to fill termleader[]
(final Bytes termleader (Bytes. (inc 256)))     ;; for check-termcode()

;; Parsing of the builtin termcap entries.

(defn- #_void parse-builtin-tcap [#_btcap_C* tcaps]
    (let [#_int n (count tcaps)]
        (loop-when-recur [#_int i 1] (< i n) [(inc i)]
            (let [#_int k (:bt_key (... tcaps i))]
                (cond (neg? k)
                    (let [#_Bytes name (-> (Bytes. 2) (.be 0, (KEY2TERMCAP0 k)) (.be 1, (KEY2TERMCAP1 k)))]
                        (when (nil? (find-termcode name))
                            (add-termcode name, (:bt_seq (... tcaps i)))
                        ))
                :else ;; KS_xx entry ;; only set the value if it wasn't set yet
                    (let-when [#_Bytes' t (... term_strings k)] (or (nil? @t) (== @t EMPTY_OPTION))
                        (reset! t (:bt_seq (... tcaps i)))
                    ))
            )))
    nil)

;; Set terminal options.
;;
;; While doing this, until ttest(), some options may be null, be careful.

(defn- #_window_C set-term [#_window_C win]
    (out-flush)
    ;; Reset a few things before clearing the old options.
    ;; This may cause outputting a few things that the terminal doesn't understand,
    ;; but the screen will be cleared later, so this is OK.
    (stop-termcap)
    (clear-termcodes)
    (parse-builtin-tcap xterm_tcaps)
    ;; Any "stty" settings override the default for t_kb from the termcap.
    (get-stty)
    ;; If the termcap has no entry for 'bs' and/or 'del' and the ioctl() also didn't work,
    ;; use the default CTRL-H.  The default for t_kD is DEL, unless t_kb is DEL.
    (let [#_Bytes bs (find-termcode (u8 "kb"))
          bs (if (or (nil? bs) (eos? bs)) (let [bs CTRL_H_STR] (add-termcode (u8 "kb"), bs) bs) bs)
          #_Bytes del (find-termcode (u8 "kD"))]
        (when (and (or (nil? del) (eos? del)) (or (nil? bs) (not-at? bs DEL)))
            (add-termcode (u8 "kD"), DEL_STR)
        ))
    (let [win (ttest win, true)                     ;; make sure we have a valid set of terminal codes
          _ (reset! full_screen true)               ;; we can use termcap codes from now on
          ;; Initialize the terminal with the appropriate termcap codes.
          _ (when (!= @starting NO_SCREEN)
                (start-termcap))                    ;; may change terminal mode
          win (set-shellsize win, 80, 24, false)]   ;; may change Rows
        (when (!= @starting NO_SCREEN)
            (when @scroll_region
                (scroll-region-reset)))             ;; in case Rows changed
        win
    ))

;; the number of calls to ui-write() is reduced by using the buffer "out_buf"

(final int OUT_SIZE      2047)

(final Bytes out_buf (Bytes. (inc OUT_SIZE)))
(atom! int out_pos)         ;; number of chars in "out_buf"

;; Flush the output buffer.

(defn- #_void out-flush []
    (let [#_int len @out_pos]
        (when (non-zero? len)
            ;; set out_pos to 0 before ui-write(), to avoid recursiveness
            (reset! out_pos 0)
            (ui-write out_buf, len)
        ))
    nil)

;; Sometimes a byte out of a multi-byte character is written with out-char().
;; To avoid flushing half of the character, call this function first.

(defn- #_void out-flush-check []
    nil)

;; out-char(c): put a byte into the output buffer.
;;              Flush it if it becomes full.
;; This should not be used for outputting text on the screen
;; (use functions like msg-puts() and screen-putchar() for that).

(defn- #_void out-char [#_byte c]
    (when (== c (byte \newline))          ;; turn LF into CR-LF (CRMOD doesn't seem to do this)
        (out-char (byte \return)))

    (.be out_buf @out_pos, c)
    (swap! out_pos inc)

    ;; For testing we flush each time.
    (when (or (<= OUT_SIZE @out_pos) (non-zero? @p_wd))
        (out-flush))
    nil)

;; out-char-nf(c): like out-char(), but don't flush when "p_wd" is set

(defn- #_void out-char-nf [#_byte c]
    (when (== c (byte \newline))          ;; turn LF into CR-LF (CRMOD doesn't seem to do this)
        (out-char-nf (byte \return)))

    (.be out_buf @out_pos, c)
    (swap! out_pos inc)

    (when (<= OUT_SIZE @out_pos)
        (out-flush))
    nil)

(defn- #_Bytes _addfmt [#_Bytes buf, #_Bytes fmt, #_int val]
    (ร .sprintf libC buf, fmt, val)
    (loop-when-recur buf (non-eos? buf) (.plus buf 1) => buf))

(final Bytes tgoto_UP)  ;; %% nada!
(final Bytes tgoto_BC)  ;; %% nada!
(final Bytes tgoto_buffer (Bytes. 32))

;; Decode cm cursor motion string.
;; cm is cursor motion string, row and col are the desired destination.
;; Returns a pointer to the decoded string, or "OOPS" if it cannot be decoded.
;;
;; Accepted escapes are:
;;      %d       as in printf, 0 origin.
;;      %2, %3   like %02d, %03d in printf.
;;      %.       like %c
;;      %+x      adds <x> to value, then %.
;;      %>xy     if value > x, adds y. No output.
;;      %i       increments row & col. No output.
;;      %r       reverses order of row & col. No output.
;;      %%       prints as a single %.
;;      %n       exclusive or row & col with 0140.
;;      %B       BCD, no output.
;;      %D       reverse coding (x-2*(x%16)), no output.

(defn- #_Bytes _tgoto [#_Bytes cm, #_int col, #_int row] ;; cm: string, from termcap ;; col: x position ;; row: y position
    (if (some? cm)
        (let-when [a'm (atom {#_boolean :reverse false #_boolean :up false #_boolean :bc false}) ;; reverse flag ;; add upline ;; add backup
                   #_Bytes p
                    (loop-when [cm cm col col row row p tgoto_buffer] (non-eos? cm) => (eos! p)
                        (let-when [#_byte b (.at cm 0) cm (.plus cm 1)] (== b (byte \%)) => (recur cm col row (-> p (.be 0, b) (.plus 1)))  ;; normal char
                            (let [upbc- (fn [col row] (if (any == row TAB (byte \newline) (byte \u0004) (byte \u0000))              ;; these are chars that UNIX hates
                                                        (let [row (inc row)]                                                        ;; so go to next pos
                                                            (swap! a'm assoc (if (== (:reverse @a'm) (== row col)) :up :bc) true)   ;; and mark UP or BC
                                                            row)
                                                        row))
                                  b (.at cm 0) cm (.plus cm 1)] ;; % escape
                                (condp == b
                                    (byte \d) (recur cm col col (_addfmt p, (u8 "%d"), row))                                        ;; decimal
                                    (byte \2) (recur cm col col (_addfmt p, (u8 "%02d"), row))                                      ;; 2 digit decimal
                                    (byte \3) (recur cm col col (_addfmt p, (u8 "%03d"), row))                                      ;; 3 digit decimal

                                    (byte \>)                                                                                       ;; %>xy: if >x, add y
                                        (let [#_byte x (.at cm 0) cm (.plus cm 1) #_byte y (.at cm 0) cm (.plus cm 1)]
                                            (recur cm (if (< x col) (+ col y) col) (if (< x row) (+ row y) row) p))

                                    (byte \+)                                                                                       ;; %+c: add c
                                        (let [row (+ row (.at cm 0)) cm (.plus cm 1)]
                                            (recur cm col col (-> p (.be 0, (upbc- col row)) (.plus 1))))                           ;; %% fallthrough

                                    (byte \.)                                                                                       ;; print x/y
                                        (recur cm col col (-> p (.be 0, (upbc- col row)) (.plus 1)))

                                    (byte \r)                                                                                       ;; r: reverse
                                        (let [#_int _ row row col col _]
                                            (swap! a'm assoc :reverse true)
                                            (recur cm col row p))

                                    (byte \i) (recur cm (inc col) (inc row) p)                                                      ;; increment (1-origin screen)
                                    (byte \%) (recur cm col row (-> p (.be 0, (byte \%)) (.plus 1)))                                ;; %%=% literally
                                    (byte \n) (recur cm (bit-xor col 0140) (bit-xor row 0140) p)                                    ;; magic DM2500 code
                                    (byte \B) (recur cm (+ (<< (/ col 10) 4) (% col 10)) (+ (<< (/ row 10) 4) (% row 10)) p)        ;; bcd encoding
                                    (byte \D) (recur cm (- col (* 2 (& col 15))) (- row (* 2 (& row 15))) p)                        ;; magic Delta Data code

                                    (byte \p)                                                                                       ;; so, what?
                                        (let [#_byte d (.at cm 0) cm (.plus cm 1)]
                                            (recur-if (any == d (byte \1) (byte \2)) [cm col row p] => nil))                        ;; ignore %p1 and %p2

                                    nil ;; unknown escape
                                ))
                        ))] (some? p) => (u8 "OOPS")
            (when (:up @a'm)                                  ;; add upline
                (when (some? tgoto_UP)
                    (let [#_Bytes s (loop-when-recur [s tgoto_UP] (or (asc-isdigit (.at s 0)) (at? s (byte \.))) [(.plus s 1)] => s)]
                        (loop-when-recur [p p s (if (at? s (byte \*)) (.plus s 1) s)] (non-eos? s) [(-> p (.be 0, (.at s 0)) (.plus 1)) (.plus s 1)] => (eos! p)))
                ))
            (when (:bc @a'm)                                 ;; add backspace
                (if (some? tgoto_BC)
                    (let [#_Bytes s (loop-when-recur [s tgoto_BC] (or (asc-isdigit (.at s 0)) (at? s (byte \.))) [(.plus s 1)] => s)]
                        (loop-when-recur [p p s (if (at? s (byte \*)) (.plus s 1) s)] (non-eos? s) [(-> p (.be 0, (.at s 0)) (.plus 1)) (.plus s 1)] => (eos! p)))
                    (-> p (.be 0, (byte \backspace)) (.plus 1) eos!)
                ))
            tgoto_buffer
        )
        (u8 "OOPS")                          ;; kludge, but standard
    ))

;; Note: "s" may have padding information ahead of it, in the form of nnnTEXT or nnn*TEXT.
;;  nnn is the number of milliseconds to delay, and may be a decimal fraction (nnn.mmm).
;;  In case an asterisk is given, the delay is to be multiplied by "_affcnt".

(defn- #_int _tputs [#_Bytes s, #_int _affcnt] ;; affcnt: number of lines affected
    (let [i 0 i (if (asc-isdigit (.at s i))
                    (let [i                         (loop-when-recur [i (inc i)] (asc-isdigit (.at s i)) [(inc i)] => i)
                          i (if (at? s i (byte \.)) (loop-when-recur [i (inc i)] (asc-isdigit (.at s i)) [(inc i)] => i) i)
                          i (if (at? s i (byte \*)) (inc i) i)]
                        i) i)]
        (loop-when-recur i (non-eos? s i) (inc i)
            (out-char-nf (.at s i))))
    0)

;; A never-padding out-str:
;; use this whenever you don't want to run the string through tputs.
;; tputs above is harmless,
;; but tputs from the termcap library is likely to strip off leading digits,
;; that it mistakes for padding information, and "%i", "%d", etc.
;; This should only be used for writing terminal codes, not for outputting
;; normal text: use functions like msg-puts() and screen-putchar() for that.

(defn- #_void out-str-nf [#_Bytes s]
    ;; avoid terminal strings being split up
    (when (< (- OUT_SIZE 20) @out_pos)
        (out-flush))
    (loop-when-recur [#_int i 0] (non-eos? s i) [(inc i)]
        (out-char-nf (.at s i)))
    ;; For testing we write one string at a time.
    (when (non-zero? @p_wd)
        (out-flush))
    nil)

;; out-str(s): Put a character string a byte at a time into the output buffer.
;; This should only be used for writing terminal codes, not for outputting
;; normal text: use functions like msg-puts() and screen-putchar() for that.

(defn- #_void out-str [#_Bytes s]
    (when (and (some? s) (non-eos? s))
        ;; avoid terminal strings being split up
        (when (< (- OUT_SIZE 20) @out_pos)
            (out-flush))
        (_tputs s, 1)
        ;; For testing we write one string at a time.
        (when (non-zero? @p_wd)
            (out-flush)))
    nil)

;; cursor positioning using termcap parser

(defn- #_void term-windgoto     [#_int row, #_int col]      (out-str (_tgoto @T_CM, col, row))       nil)
(defn- #_void term-cursor-right [#_int i]                   (out-str (_tgoto @T_CRI, 0, i))          nil)
(defn- #_void term-append-lines [#_int line_count]          (out-str (_tgoto @T_CAL, 0, line_count)) nil)
(defn- #_void term-delete-lines [#_int line_count]          (out-str (_tgoto @T_CDL, 0, line_count)) nil)
(defn- #_void term-set-winsize  [#_int width, #_int height] (out-str (_tgoto @T_CWS, height, width)) nil)

(defn- #_void term-fg-color [#_int n]
    ;; Use "AF" termcap entry if present, "Sf" entry otherwise.
    (cond
        (non-eos? @T_CAF) (term-color @T_CAF, n)
        (non-eos? @T_CSF) (term-color @T_CSF, n)
    )
    nil)

(defn- #_void term-bg-color [#_int n]
    ;; Use "AB" termcap entry if present, "Sb" entry otherwise.
    (cond
        (non-eos? @T_CAB) (term-color @T_CAB, n)
        (non-eos? @T_CSB) (term-color @T_CSB, n)
    )
    nil)

(defn- #_void term-color [#_Bytes s, #_int n]
    (let [#_int i 2 ;; index in s just after <Esc>[
          ;; Special handling of 16 colors, because termcap can't handle it.
          ;; Also accept "\e[3%dm" for TERMINFO, it is sometimes used.
          [s n] (if (and (<= 8 n) (<= 16 @t_colors) (at? s ESC) (at? s 1 (byte \[)) (non-eos? s i) (or (== (STRCMP (.plus s (inc i)), (u8 "%p1%dm")) 0) (== (STRCMP (.plus s (inc i)), (u8 "%dm")) 0)) (or (at? s i (byte \3)) (at? s i (byte \4))))
                    (let [#_Bytes buf (Bytes. 20)]
                        (ร .sprintf libC buf, (u8 "%s%s%%p1%%dm"), (if (== i 2) (u8 "\033[") (u8 "\233")), (if (at? s i (byte \3)) (if (<= 16 n) (u8 "38;5;") (u8 "9")) (if (<= 16 n) (u8 "48;5;") (u8 "10"))))
                        [buf (if (<= 16 n) n (- n 8))]
                    )
                    [s n]
                )]
        (out-str (_tgoto s, 0, n)))
    nil)

;; Make sure we have a valid set or terminal options.
;; Replace all entries that are null by EMPTY_OPTION.

(defn- #_window_C ttest [#_window_C win, #_boolean pairs]
    ;; MUST have "cm": cursor motion.
    (let [win (when' (eos? @T_CM) => win
                (emsg win, (u8 "E437: terminal capability \"cm\" required"))
            )]

        ;; If "cs" defined, use a scroll region, it's faster.
        (reset! scroll_region (non-eos? @T_CS))

        ;; optional pairs
        (when pairs
            ;; TP goes to normal mode for TI (invert) and TB (bold).
            (when (eos? @T_ME)
                (reset! T_ME (reset! T_MR (reset! T_MD EMPTY_OPTION))))
            (when (or (eos? @T_SO) (eos? @T_SE))
                (reset! T_SO (reset! T_SE EMPTY_OPTION)))
            (when (or (eos? @T_US) (eos? @T_UE))
                (reset! T_US (reset! T_UE EMPTY_OPTION)))
            (when (or (eos? @T_CZH) (eos? @T_CZR))
                (reset! T_CZH (reset! T_CZR EMPTY_OPTION)))

            ;; T_VE is needed even though T_VI is not defined.
            (when (eos? @T_VE)
                (reset! T_VI EMPTY_OPTION))

            ;; If 'mr' or 'me' is not defined use 'so' and 'se'.
            (when (eos? @T_ME)
                (reset! T_ME @T_SE)
                (reset! T_MR (reset! T_MD @T_SO)))

            ;; If 'so' or 'se' is not defined use 'mr' and 'me'.
            (when (eos? @T_SO)
                (reset! T_SE @T_ME)
                (reset! T_SO (if (eos? @T_MR) @T_MD @T_MR)))

            ;; If 'ZH' or 'ZR' is not defined use 'mr' and 'me'.
            (when (eos? @T_CZH)
                (reset! T_CZR @T_ME)
                (reset! T_CZH (if (eos? @T_MR) @T_MD @T_MR)))

            ;; "Sb" and "Sf" come in pairs.
            (when (or (eos? @T_CSB) (eos? @T_CSF))
                (reset! T_CSB EMPTY_OPTION)
                (reset! T_CSF EMPTY_OPTION))

            ;; "AB" and "AF" come in pairs.
            (when (or (eos? @T_CAB) (eos? @T_CAF))
                (reset! T_CAB EMPTY_OPTION)
                (reset! T_CAF EMPTY_OPTION))

            ;; If 'Sb' and 'AB' are not defined, reset "Co".
            (when (and (eos? @T_CSB) (eos? @T_CAB))
                (reset! T_CCO EMPTY_OPTION))
        )

        (reset! need_gather true)

        (reset! t_colors (ร .atoi libC @T_CCO))
        win
    ))

;; Check if the new shell size is valid, correct it if it's too small or way too big.

(defn- #_void check-shellsize []
    (let [m (min-rows)]
        (when (< @Rows m)           ;; need room for one window and command line
            (reset! Rows m))
        (limit-screen-size))
    nil)

;; Limit Rows and Cols to avoid an overflow in Rows * Cols.

(defn- #_void limit-screen-size []
    (swap! Rows min 1000)
    (swap! Cols #(max MIN_COLS (min % 10000)))
    nil)

(atom! long old__Rows)
(atom! long old__Columns)

;; Invoked just before the screen structures are going to be (re)allocated.

(defn- #_void win-new-shellsize []
    (when (or (!= @old__Rows @Rows) (!= @old__Columns @Cols))
        (ui-new-shellsize))
    (when (!= @old__Rows @Rows)
        (reset! old__Rows @Rows)
        (shell-new-rows))           ;; update window sizes
    (when (!= @old__Columns @Cols)
        (reset! old__Columns @Cols)
        (shell-new-columns))        ;; update window sizes
    nil)

;; Call this function when the Vim shell has been resized in any way.
;; Will obtain the current size and redraw (also when size didn't change).

(defn- #_window_C shell-resized [#_window_C win]
    (set-shellsize win, 0, 0, false))

(atom! int _2_busy)

;; Set size of the Vim shell.
;; If 'mustset' is true, we must set Rows and Cols, do not get the real window size (this is used for the :win command).
;; If 'mustset' is false, we may try to get the real window size and if it fails, use 'width' and 'height'.

(defn- #_window_C set-shellsize [#_window_C win, #_int width, #_int height, #_boolean mustset]
    ;; Avoid recursiveness, can happen when setting the window size causes another window-changed signal.
    (when' (not (or (pos? @_2_busy) (neg? width) (neg? height))) => win
        (if (any == @State HITRETURN SETWSIZE)
            (do (reset! State SETWSIZE) ;; postpone the resizing
                win)
            (do (swap! _2_busy inc)
                (if (or mustset (and (not (ui-get-shellsize)) (non-zero? height)))
                    (do (reset! Rows height)
                        (reset! Cols width)
                        (check-shellsize)
                        (ui-set-shellsize mustset))
                    (check-shellsize))
                ;; The window layout used to be adjusted here, but it now happens in screen-alloc()
                ;; (also invoked from screen-clear()).
                ;; That is because the "_2_busy" check above may skip this, but not screen-alloc().
                (screen-clear)
                (let [win (when' (!= @starting NO_SCREEN) => win
                            (let [win (-> win (changed-line-abv-curs) (invalidate-botline))
                                  ;; We only redraw when it's needed:
                                  ;; - While editing the command line, only redraw that.
                                  ;; - Otherwise, redraw right now, and position the cursor.
                                  ;; Always need to call update-screen() or screen-alloc()
                                  ;; to make sure Rows/Cols and the size of screenLines[] is correct!
                                  win (if (flag? @State CMDLINE)
                                        (let [                         win (update-screen win, NOT_VALID)]                 (redrawcmdline) win)
                                        (let [win (update-topline win) win (update-screen win, NOT_VALID)] (if (redrawing) (setcursor win) win))
                                    )]
                                (cursor-on) ;; redrawing may have switched it off
                                win)
                        )]
                    (out-flush)
                    (swap! _2_busy dec)
                    win)
            ))
    ))

;; Set the terminal to TMODE_RAW (for Normal mode)
;; or TMODE_COOK (for external commands and Ex mode).

(defn- #_void settmode [#_int tmode]
    (when @full_screen
        ;; When returning after calling a shell we want to really set the
        ;; terminal to raw mode, even though we think it already is, because
        ;; the shell program may have reset the terminal mode.
        ;; When we think the terminal is normal, don't try to set it to
        ;; normal again, because that causes problems (logout!) on some machines.

        (when (or (!= tmode TMODE_COOK) (!= @cur_tmode TMODE_COOK))
            (out-flush)
            (mch-settmode tmode)        ;; machine specific function
            (reset! cur_tmode tmode)
            (out-flush)))
    nil)

(defn- #_void start-termcap []
    (when (and @full_screen (not @termcap_active))
        (out-str @T_TI)                 ;; start termcap mode
        (out-str @T_KS)                 ;; start "keypad transmit" mode
        (out-flush)
        (reset! termcap_active true)
        (screen-start))                 ;; don't know where cursor is now
    nil)

(defn- #_void stop-termcap []
    (screen-stop-highlight)
    (reset-cterm-colors)
    (when @termcap_active
        (out-str @T_KE)                 ;; stop "keypad transmit" mode
        (out-flush)
        (reset! termcap_active false)
        (cursor-on)                     ;; just in case it is still off
        (out-str @T_TE)                 ;; stop termcap mode
        (screen-start)                  ;; don't know where cursor is now
        (out-flush))
    nil)

;; Return true when saving and restoring the screen.

(defn- #_boolean swapping-screen []
    (and @full_screen (non-eos? @T_TI)))

;; By outputting the 'cursor very visible' termcap code, for some windowed
;; terminals this makes the screen scrolled to the correct position.
;; Used when starting Vim or returning from a shell.

(defn- #_void scroll-start []
    (when (non-eos? @T_VS)
        (out-str @T_VS)
        (out-str @T_VE)
        (screen-start))             ;; don't know where cursor is now
    nil)

(atom! boolean cursor_is_off)

;; Enable the cursor.

(defn- #_void cursor-on []
    (when @cursor_is_off
        (out-str @T_VE)
        (reset! cursor_is_off false))
    nil)

;; Disable the cursor.

(defn- #_void cursor-off []
    (when @full_screen
        (when (not @cursor_is_off)
            (out-str @T_VI))          ;; disable cursor
        (reset! cursor_is_off true))
    nil)

(atom! int showing_mode NORMAL)

;; Set cursor shape to match Insert or Replace mode.

(defn- #_void term-cursor-shape []
    ;; Only do something when redrawing the screen and we can restore the mode.
    (when (and @full_screen (non-eos? @T_CEI))
        (cond (== (& @State REPLACE) REPLACE)
            (when (!= @showing_mode REPLACE)
                ;; Replace mode cursor ;; fall back to Insert mode cursor
                (let-when [#_Bytes s (if (non-eos? @T_CSR) @T_CSR @T_CSI)] (non-eos? s)
                    (out-str s)
                    (reset! showing_mode REPLACE)
                )
            )
        (flag? @State INSERT)
            (when (and (!= @showing_mode INSERT) (non-eos? @T_CSI))
                (out-str @T_CSI)                    ;; Insert mode cursor
                (reset! showing_mode INSERT)
            )
        (!= @showing_mode NORMAL)
            (do
                (out-str @T_CEI)                    ;; non-Insert mode cursor
                (reset! showing_mode NORMAL)
            )
        ))
    nil)

;; Set scrolling region for window 'win'.
;; The region starts 'off' lines from the start of the window.
;; Also set the vertical scroll region for a vertically split window.
;; Always the full width of the window, excluding the vertical separator.

(defn- #_void scroll-region-set [#_window_C win, #_int off]
    (out-str (_tgoto @T_CS, (dec (+ (:w_winrow win) (:w_height win))), (+ (:w_winrow win) off)))

    (when (and (non-eos? @T_CSV) (!= (:w_width win) @Cols))
        (out-str (_tgoto @T_CSV, (dec (+ (:w_wincol win) (:w_width win))), (:w_wincol win))))

    (screen-start)                 ;; don't know where cursor is now
    nil)

;; Reset scrolling region to the whole screen.

(defn- #_void scroll-region-reset []
    (out-str (_tgoto @T_CS, (dec @Rows), 0))

    (when (non-eos? @T_CSV)
        (out-str (_tgoto @T_CSV, (dec @Cols), 0)))

    (screen-start)                  ;; don't know where cursor is now
    nil)

;; List of terminal codes that are currently recognized.

(class! #_final termcode_C
    [
        (field byte     name0)      ;; termcap name, byte 0
        (field byte     name1)      ;; termcap name, byte 1
        (field Bytes    code)       ;; terminal code
        (field int      len)        ;; STRLEN(code)
        (field int      modlen)     ;; length of part before ";*~".
    ])

(defn- #_termcode_C* ARRAY-termcode [#_int n]
    (vec (repeatedly n NEW_termcode_C)))

(atom! termcode_C* termcodes)

(atom! int tc_max_len)  ;; number of entries that termcodes[] can hold
(atom! int tc_len)      ;; current number of entries in termcodes[]

(defn- #_void clear-termcodes []
    (reset! tc_len 0)
    (reset! tc_max_len 0)
    (reset! termcodes nil)

    (reset! need_gather true)         ;; need to fill termleader[]
    nil)

;; Add a new entry to the list of terminal codes.
;; The list is kept alphabetical for ":set termcap"

(defn- #_void add-termcode [#_Bytes name, #_Bytes code]
    (if (or (nil? code) (eos? code))
        (del-termcode name)
        (let [code (STRDUP code) #_int len (STRLEN code)]
            (reset! need_gather true)       ;; need to fill termleader*
            (when (== @tc_len @tc_max_len)  ;; need to make space for more entries
                (swap! tc_max_len + 20)
                (let [#_termcode_C* new_tc (ARRAY-termcode @tc_max_len)]
                    (dotimes [#_int i @tc_len]
                        (swap! new_tc assoc i (... @termcodes i)))
                    (reset! termcodes new_tc)
                ))
            ;; Look for an existing entry with the same name, it is replaced.
            ;; Look for an existing entry that is alphabetical higher, the new entry is inserted in front of it.
            (let [#_int i
                    (loop-when [i 0] (< i @tc_len) => i
                        (let [tc (... @termcodes i)
                              ? (when-not (< (char_u (:name0 tc)) (char_u (.at name 0)))
                                    (let-when [
                                          ? (when (== (:name0 tc) (.at name 0))
                                                (cond (< (char_u (:name1 tc)) (char_u (.at name 1)))
                                                    :recur
                                                (== (:name1 tc) (.at name 1))
                                                    (do ;; Exact match: replace old code.
                                                        (swap! tc_len dec)
                                                        :break
                                                    ))
                                            )] (not ?) => (when (== ? :break) ?)

                                        ;; Found alphabetical larger entry, move rest to insert new entry.
                                        (loop-when-recur [#_int j @tc_len] (< i j) [(dec j)]
                                            (swap! termcodes assoc j (... @termcodes (dec j))))
                                        :break
                                    )
                                )]
                            (recur-if (not ?) [(inc i)] => i)
                        )
                    )]
                (swap! termcodes update i assoc :name0 (.at name 0), :name1 (.at name 1), :code code, :len len)
                ;; For xterm we recognize special codes like "ESC[42;*X" and "ESC O*X" that accept modifiers.
                (let [#_int j (termcode-star code, len)]
                    (swap! termcodes assoc-in [i :modlen] (if (< 0 j) (- len 1 j) 0))
                    (swap! tc_len inc)
                ))
        ))
    nil)

;; Check termcode "code[len]" for ending in ;*X, <Esc>O*X or <M-O>*X.
;; The "X" can be any character.
;; Return 0 if not found, 2 for ;*X and 1 for O*X and <M-O>*X.

(defn- #_int termcode-star [#_Bytes code, #_int len]
    ;; Shortest is <M-O>*X.  With ; shortest is <CSI>1;*X.
    (if (and (<= 3 len) (at? code (- len 2) (byte \*)))
        (cond
            (and (<= 5 len) (at? code (- len 3) (byte \;)))
                2
            (or (and (<= 4 len) (at? code (- len 3) (byte \O))) (== (char_u (.at code (- len 3))) (+ (byte \O) 0x80)))
                1
            :else
                0)
        0))

(defn- #_Bytes find-termcode [#_Bytes name]
    (loop-when [#_int i 0] (< i @tc_len) => nil
        (let [tc (... @termcodes i)] (recur-if (not (and (== (:name0 tc) (.at name 0)) (== (:name1 tc) (.at name 1)))) [(inc i)] => (:code tc)))
    ))

(defn- #_void del-termcode [#_Bytes name]
    (when (some? @termcodes)
        (reset! need_gather true)               ;; need to fill termleader[]
        (loop-when [#_int i 0] (< i @tc_len)
            (if (and (== (:name0 (... @termcodes i)) (.at name 0)) (== (:name1 (... @termcodes i)) (.at name 1)))
                (del-termcode-idx i)
                (recur (inc i))
            )
        ))
    ;; Not found.  Give error message?
    nil)

(defn- #_void del-termcode-idx [#_int idx]
    (swap! tc_len dec)
    (loop-when-recur [#_int i idx] (< i @tc_len) [(inc i)]
        (swap! termcodes assoc i (... @termcodes (inc i))))
    nil)

;; Check if typebuf.tb_buf[] contains a terminal key code.
;; Check at typebuf.tb_buf[typebuf.tb_off].
;; Return 0 for no match, -1 for partial match, > 0 for full match.
;; Return KEYLEN_REMOVED when a key code was deleted.
;; With a match, the match is removed, the replacement code is inserted in
;; typebuf.tb_buf[] and the number of characters in typebuf.tb_buf[] is returned.
;; When "buf" is not null, buf[bufsize] is used instead of typebuf.tb_buf[].
;; "buflen" is then the length of the string in buf[] and is updated for inserts and deletes.

(defn- #_int check-termcode [#_Bytes buf, #_int bufsize, #_int' a'buflen]
    ;; Speed up the checks for terminal codes by gathering all first bytes used in termleader[].
    ;; Often this is just a single <Esc>.
    (when @need_gather
        (gather-termleader))
    (let-when [[#_Bytes tp #_int len :as _]
            (if (nil? buf)
                (when (< 0 (:tb_len @typebuf)) [(.plus (:tb_buf @typebuf) (:tb_off @typebuf)) (:tb_len @typebuf)])
                (when (< 0 @a'buflen)          [buf @a'buflen]))
    ] (some? _) => 0

        ;; Don't check characters after KB_SPECIAL,
        ;; those are already translated terminal chars (avoid translating ~@^Hx).
        (cond (at? tp KB_SPECIAL) ;; there are always 2 extra characters
            0
        ;; Skip this position if the character does not appear as the first character in "term_strings".
        ;; This speeds up a lot, since most termcodes start with the same character (ESC).
        (eos? (loop-when-recur [q termleader] (and (non-eos? q) (!= (.at q 0) (.at tp 0))) [(.plus q 1)] => q))
            0
        ;; Skip this position if "p_ek" is not set and *tp is an ESC and we are in Insert mode.
        (and (at? tp ESC) (not @p_ek) (flag? @State INSERT))
            0
        :else
            (let-when [#_Bytes key_name (Bytes. 2) a'modifiers (atom (int 0)) ;; no modifiers yet
                  #_int slen
                    (loop-when [slen 0 #_int i 0] (< i @tc_len) => slen
                        (let-when [tci (... @termcodes i) slen (:len tci)
                              ? (when (zero? (STRNCMP (:code tci), tp, (min len slen)))
                                    (if (< len slen)    ;; got a partial sequence
                                        :again          ;; need to get more chars
                                        ;; When found a keypad key, check if there is another key that matches and use that one.
                                        ;; This makes <Home> to be found instead of <kHome> when they produce the same key code.
                                        (let [i (if (and (== (:name0 tci) (byte \K)) (asc-isdigit (:name1 tci)))
                                                    (loop-when [#_int j (inc i)] (< j @tc_len) => i
                                                        (let [tcj (... @termcodes j)]
                                                            (if (and (== (:len tcj) slen) (zero? (STRNCMP (:code tci), (:code tcj), slen)))
                                                                j
                                                                (recur (inc j))
                                                            )))
                                                    i
                                                )]
                                            (.be key_name 0, (:name0 (... @termcodes i)))
                                            (.be key_name 1, (:name1 (... @termcodes i)))
                                            :found
                                        ))
                                )] (not ?) => (when (== ? :found) slen)

                            ;; Check for code with modifier, like xterm uses:
                            ;; <Esc>[123;*X (modslen == slen - 3), also <Esc>O*X and <M-O>*X (modslen == slen - 2).
                            ;; When there is a modifier, the * matches a number.
                            ;; When there is no modifier, the ;* or * is omitted.
                            (let-when [#_int modslen (:modlen tci)
                                  [slen ?]
                                    (if (and (< 0 modslen) (zero? (STRNCMP (:code tci), tp, (min len modslen))))
                                        (if (<= len modslen)    ;; got a partial sequence
                                            [slen :again]       ;; need to get more chars
                                            (let-when [[slen ?]
                                                    (cond (at? tp modslen (.at (:code tci) (dec slen)))
                                                        [(inc modslen) nil]     ;; no modifiers
                                                    (and (not-at? tp modslen (byte \;)) (== modslen (- slen 3)))
                                                        [slen :recur]           ;; no match
                                                    :else
                                                        ;; Skip over the digits, the final char must follow.
                                                        (let [#_int j (loop-when-recur [j (- slen 2)] (and (< j len) (asc-isdigit (.at tp j))) [(inc j)] => (inc j))]
                                                            (cond (< len j)     ;; got a partial sequence
                                                                [slen :again]   ;; need to get more chars
                                                            (not-at? tp (dec j) (.at (:code tci) (dec slen)))
                                                                [slen :recur]   ;; no match
                                                            :else
                                                                ;; Match!  Convert modifier bits.
                                                                (let [#_int n (dec (ร .atoi libC (.plus tp (- slen 2))))]
                                                                    (when (non-zero? (& n 1)) (swap! a'modifiers | MOD_MASK_SHIFT))
                                                                    (when (non-zero? (& n 2)) (swap! a'modifiers | MOD_MASK_ALT))
                                                                    (when (non-zero? (& n 4)) (swap! a'modifiers | MOD_MASK_CTRL))
                                                                    (when (non-zero? (& n 8)) (swap! a'modifiers | MOD_MASK_META))
                                                                    [j nil]
                                                                ))
                                                        ))
                                            ] (not ?) => [slen (when-not (== ? :recur) ?)]

                                                (.be key_name 0, (:name0 tci))
                                                (.be key_name 1, (:name1 tci))
                                                [slen :found]
                                            ))
                                        [slen nil])
                            ] (not ?) => (when (== ? :found) slen)

                                (recur slen (inc i))
                            ))
                    )] (some? slen) => -1

                (if (eos? key_name) ;; no match found
                    0
                    ;; We only get here when we have a complete termcode match.
                    ;; Change <xHome> to <Home>, <xUp> to <Up>, etc.
                    (let-when [#_int key (handle-x-keys (TERMCAP2KEY (.at key_name 0), (.at key_name 1)))
                          #_Bytes s (Bytes. (inc MAX_KEY_CODE_LEN)) #_int n 0
                          [key n] ;; Add any modifier codes to our string.
                            (if (non-zero? @a'modifiers) ;; Some keys have the modifier included.
                                (let-when [key (simplify-key key, a'modifiers)] (non-zero? @a'modifiers) => [key n]
                                    (let [_ (.be s n, KB_SPECIAL)   n (inc n)
                                          _ (.be s n, KS_MODIFIER)  n (inc n)
                                          _ (.be s n, @a'modifiers) n (inc n)]
                                        [key n]
                                    ))
                                [key n])
                          ;; Finally, add the special key code to our string.
                          _ (.be key_name 0, (KEY2TERMCAP0 key))
                          _ (.be key_name 1, (KEY2TERMCAP1 key))
                          [#_int retval n]
                            (cond (at? key_name KS_KEY) ;; from ":set <M-b>=xx"
                                [0 (+ n (utf-char2bytes (char_u (.at key_name 1)), (.plus s n)))]
                            (and (zero? n) (at? key_name 0 KS_EXTRA) (at? key_name 1 KE_IGNORE))
                                ;; Do not put K_IGNORE into the buffer, do return KEYLEN_REMOVED to indicate what happened.
                                [KEYLEN_REMOVED n]
                            :else
                                (let [_ (.be s n, KB_SPECIAL)       n (inc n)
                                      _ (.be s n, (.at key_name 0)) n (inc n)
                                      _ (.be s n, (.at key_name 1)) n (inc n)]
                                    [0 n]
                                ))
                          _ (eos! s n)
                          #_int extra (- n slen)
                          ? (cond (nil? buf)
                                (do (cond
                                        (< extra 0) (del-typebuf (- extra))
                                        (< 0 extra) (ins-typebuf (.plus s slen)))
                                    (BCOPY (:tb_buf @typebuf), (:tb_off @typebuf), s, 0, n)
                                    nil)
                            :else
                                (let-when [
                                      ? (cond (< extra 0) ;; Remove matched characters.
                                            (do (BCOPY buf, 0, buf, (- extra), (+ @a'buflen extra))
                                                nil)
                                        (< 0 extra) ;; Insert the extra space we need.
                                            (if (< (+ @a'buflen extra n) bufsize)
                                                (do (BCOPY buf, extra, buf, 0, @a'buflen)
                                                    nil)
                                                :abort ;; If there is insufficient space, return -1.
                                            ))
                                ] (not ?) => ?

                                    (BCOPY buf, 0, s, 0, n)
                                    (swap! a'buflen + extra n)
                                    nil
                                ))
                    ] (not ?) => -1

                        (if (non-zero? retval) retval (+ len extra))
                    ))
            ))
    ))

;; Gather the first characters in the terminal key codes into a string.
;; Used to speed up check-termcode().

(defn- #_void gather-termleader []
    (eos! termleader 0)
    (loop-when [#_int n 0 #_int i 0] (< i @tc_len)
        (let [#_byte leader (.at (:code (... @termcodes i)) 0)
              n (if (nil? (vim-strchr termleader, leader)) (do (.be termleader n, leader) (let [n (inc n)] (eos! termleader n) n)) n)]
            (recur n (inc i))
        ))
    (reset! need_gather false)
    nil)

;; ui.c: functions that handle the user interface.
;;
;; 1. Keyboard input stuff, and a bit of windowing stuff.  These are called
;;    before the machine specific stuff (mch_*) so that we can call the GUI
;;    stuff instead if the GUI is running.
;; 2. Clipboard stuff.
;; 3. Input buffer stuff.

(defn- #_void ui-write [#_Bytes s, #_int len]
    (mch-write s, len)
    nil)

;; Low level input function.
;; Get characters from the keyboard.
;; Return the number of characters that are available.
;;
;; If "wtime" == 0, do not wait for characters.
;; If "wtime" == -1, wait forever for characters.
;; If "wtime" > 0, wait "wtime" milliseconds for a character.
;;
;; "tb_change_cnt" is the value of typebuf.tb_change_cnt if "buf" points into it.
;; When typebuf.tb_change_cnt changes (e.g. when a message is received from a remote client)
;; "buf" can no longer be used.  "tb_change_cnt" is 0 otherwise.

(defn- #_[window_C int] ui-inchar? [#_window_C win, #_Bytes buf, #_int maxlen, #_long wtime, #_int tb_change_cnt]
    ;; If we are going to wait for some time or block...
    (when (or (== wtime -1) (< 100 wtime))
        (vim-handle-signal SIGNAL_UNBLOCK)) ;; ... allow signals to kill us.
    (let [[win #_int len] (mch-inchar? win, buf, maxlen, wtime, tb_change_cnt)]
        (when (or (== wtime -1) (< 100 wtime))
            (vim-handle-signal SIGNAL_BLOCK)) ;; block SIGHUP et al.
        [win len]))

;; Delay for the given number of milliseconds.
;; If ignoreinput is false then we cancel the delay if a key is hit.

(defn- #_void ui-delay [#_long msec, #_boolean ignoreinput]
    (mch-delay msec, ignoreinput)
    nil)

;; If the machine has job control, use it to suspend the program,
;; otherwise fake it by starting a new shell.
;; When running the GUI iconify the window.

(defn- #_void ui-suspend []
    (mch-suspend)
    nil)

;; Try to get the current Vim shell size.
;; Put the result in Rows and Cols.
;; Use the new sizes as defaults for 'columns' and 'lines'.
;; Return true when size could be determined, false otherwise.

(defn- #_boolean ui-get-shellsize []
    (let [#_boolean got (mch-get-shellsize)]
        (check-shellsize)
        got
    ))

;; Set the size of the Vim shell according to Rows and Cols, if possible.
;; The gui_set_shellsize() or mch-set-shellsize() function will try to set the new size.
;; If this is not possible, it will adjust Rows and Cols.

(defn- #_void ui-set-shellsize [#_boolean _mustset]
    ;; mustset: set by the user
    (mch-set-shellsize)
    nil)

;; Called when Rows and/or Cols changed.

(defn- #_void ui-new-shellsize []
    (when (and @full_screen (not @exiting))
        (mch-new-shellsize))
    nil)

(defn- #_void ui-breakcheck []
    (mch-breakcheck)
    nil)

;; Functions that handle the input buffer.
;; This is used for any GUI version, and the unix terminal version.
;;
;; For Unix, the input characters are buffered to be able to check for a CTRL-C.
;; This should be done with signals, but I don't know how to do that in a portable way
;; for a tty in RAW mode.
;;
;; For the client-server code in the console the received keys are put in the input buffer.

;; Internal typeahead buffer.
;; Includes extra space for long key code descriptions which would otherwise overflow.
;; The buffer is considered full when only this extra space (or part of it) remains.

(final int INBUFLEN 250)

(final Bytes    inbuf (Bytes. (+ INBUFLEN MAX_KEY_CODE_LEN)))
(atom! int      inbufcount)     ;; number of chars in inbuf[]

(defn- #_boolean is-input-buf-full  [] (<= INBUFLEN @inbufcount))
(defn- #_boolean is-input-buf-empty [] (zero? @inbufcount))

;; Read as much data from the input buffer as possible up to maxlen, and store it in buf.
;; Note: this function used to be Read() in unix.c

(defn- #_int read-from-input-buf [#_Bytes buf, #_int maxlen]
    (if (zero? @inbufcount)            ;; if the buffer is empty, fill it
        (fill-input-buf true))
    (let [maxlen (min maxlen @inbufcount)]
        (BCOPY buf, inbuf, maxlen)
        (swap! inbufcount - maxlen)
        (if (non-zero? @inbufcount)
            (BCOPY inbuf, 0, inbuf, maxlen, @inbufcount))
        maxlen
    ))

(atom! boolean did_read_something)
(atom! Bytes fib__rest)    ;; unconverted rest of previous read
(atom! int fib__restlen)

(defn- #_void fill-input-buf [#_boolean exit_on_error]
    (ยง if-not (is-input-buf-full)
        ;; fill_input_buf() is only called when we really need a character.
        ;; If we can't get any, but there is some in the buffer, just return.
        ;; If we can't get any, and there isn't any in the buffer, we give up and exit Vim.
        (let-when [#_int unconverted
                (if (some? @fib__rest)
                    ;; Use remainder of previous call, starts with an invalid character that may become valid when reading more.
                    (let [unconverted (min @fib__restlen (- INBUFLEN @inbufcount))]
                        (BCOPY inbuf, @inbufcount, @fib__rest, 0, unconverted)
                        (if (== unconverted @fib__restlen)
                            (reset! fib__rest nil)
                            (do
                                (swap! fib__restlen - unconverted)
                                (BCOPY @fib__rest, 0, @fib__rest, unconverted, @fib__restlen)
                            ))
                        (swap! inbufcount + unconverted)
                        unconverted)
                    0)
              #_int len
                (loop-when [len 0 #_int i 0] (< i 100) => len
                    (let-when [len (int (.read libC @read_cmd_fd, (.plus inbuf @inbufcount), (- INBUFLEN @inbufcount)))] (not (or (< 0 len) @got_int)) => len
                        ;; If reading stdin results in an error, continue reading stderr.
                        ;; This helps when using "foo | xargs vim".
                        (when (and (not @did_read_something) (zero? (.isatty libc @read_cmd_fd)) (zero? @read_cmd_fd))
                            (let [#_int m @cur_tmode]
                                ;; We probably set the wrong file descriptor to raw mode.
                                ;; Switch back to cooked mode, use another descriptor and set the mode to what it was.
                                (settmode TMODE_COOK)
                                ;; Use stderr for stdin, also works for shell commands.
                                (.close libc 0)
                                (.dup libc 2)
                                (settmode m)
                            ))
                        (recur-if exit_on_error [len (inc i)] => nil)
                    ))] (some? len)
            (if (or (< 0 len) @got_int)
                (do
                    (when (< 0 len)
                        (reset! did_read_something true))
                    (if @got_int ;; Interrupted, pretend a CTRL-C was typed.
                        (do (.be inbuf 0, Ctrl_C) (reset! inbufcount 1))
                        ;; May perform conversion on the input characters.  Include the unconverted rest of the previous call.
                        ;; If there is an incomplete char at the end, it is kept for the next time: reading more bytes should make conversion possible.
                        ;; Don't do this in the unlikely event that the input buffer is too small ("fib__rest" still contains more bytes).
                        (loop-when-recur len (< 0 len) (dec len)
                            ;; if a CTRL-C was typed, remove it from the buffer and set got_int
                            (when (at? inbuf @inbufcount Ctrl_C)
                                ;; remove everything typed before the CTRL-C
                                (BCOPY inbuf, 0, inbuf, @inbufcount, len)
                                (reset! inbufcount 0)
                                (reset! got_int true))
                            (swap! inbufcount inc))
                    ))
                (do
                    (preserve-exit (u8 "Vim: Error reading input, exiting...\n"))
                ))
        ))
    nil)

;; May update the shape of the cursor.

(defn- #_void ui-cursor-shape []
    (term-cursor-shape)
    nil)

;; Check bounds for row/column number.

(defn- #_int check-row [#_int row] (cond (< row 0) 0 (<= @screenRows row) (dec @screenRows) :else row))
(defn- #_int check-col [#_int col] (cond (< col 0) 0 (<= @screenCols col) (dec @screenCols) :else col))

;; screen.c: code for displaying on the screen
;;
;; Output to the screen (console, terminal emulator or GUI window) is minimized by
;; remembering what is already displayed and only updating the parts that changed.
;;
;; screenLines [off] Copy of the whole screen (excluding text written by external commands).
;; screenAttrs [off] Associated attributes.
;; lineOffset  [row] Offset into screenLines** and screenAttrs* for each line.
;; lineWraps   [row] Flag for each line whether it wraps to the next line.
;;
;; A multi-byte character is converted to Unicode and stored in screenLinesUC*, then
;; screenLines* contains only the first byte of the UTF-8 sequence.  For ASCII without
;; composing characters, screenLinesUC* will be 0 and screenLinesC** is not used.
;; When a character occupies two display cells, the next byte in screenLines* is 0.
;; screenLinesC** contain up to 'maxcombine' composing characters (drawn on top of
;; the first character).  There is 0 after the last one used.
;;
;; The screen_*() functions write to the screen and handle updating screenLines*.
;;
;; update-screen() is the function that updates all windows and status lines.
;; It is called form the main loop when "must_redraw" is non-zero.
;; It may be called from other places when an immediate screen update is needed.
;;
;; The part of the buffer that is displayed in a window is set with:
;; - w_topline (first buffer line in window)
;; - w_leftcol (leftmost window cell in window),
;; - w_skipcol (skipped window cells of first line)
;;
;; Commands that only move the cursor around in a window, do not need to take action
;; to update the display.  The main loop will check if "w_topline" is valid and update
;; it (scroll the window) when needed.
;;
;; Commands that scroll a window, change "w_topline" and must call check-cursor() to move
;; the cursor into the visible part of the window, then call redraw-later(VALID) to have
;; the window displayed by update-screen() later.
;;
;; Commands that change text in the buffer must call changed-bytes() or changed-lines()
;; to mark the area that changed and will require updating later.  The main loop will call
;; update-screen(), which will update each window that shows the changed buffer.
;; This assumes text above the change can remain displayed as it is.
;; Text after the change may need updating for scrolling, folding and syntax highlighting.
;;
;; Commands that change how a window is displayed (e.g., setting 'list') or invalidate
;; the contents of a window in another way (e.g., change fold settings), must call
;; redraw-later(NOT_VALID) to have the whole window redisplayed by update-screen() later.
;;
;; Commands that change how a buffer is displayed (e.g., setting 'tabstop'), must call
;; redraw-curbuf-later(NOT_VALID) to have all the windows for the buffer redisplayed by
;; update-screen() later.
;;
;; Commands that change highlighting and possibly cause a scroll too, must call
;; redraw-later(SOME_VALID) to update the whole window but still use scrolling to avoid
;; redrawing everything.  However, the length of displayed lines must not change,
;; use NOT_VALID then.
;;
;; Commands that move the window position must call redraw-later(NOT_VALID).
;; TODO: should minimize redrawing by scrolling when possible.
;;
;; Commands that change everything (e.g., resizing the screen), must call
;; redraw-all-later(NOT_VALID) or redraw-all-later(CLEAR).
;;
;; Things that are handled indirectly:  When messages scroll the screen up,
;; "msg_scrolled" will be set and update-screen() called to redraw.

;; Filler used when a double-width character doesn't fit.

(final byte MB_FILLER_CHAR \<)

;; The attributes that are actually active for writing to the screen.

(atom! int screen_attr)

;; Positioning the cursor is reduced by remembering the last position.
;; Mostly used by windgoto() and screen-char().

;; last known cursor position
(atom! int screen_cur_row)
(atom! int screen_cur_col)

(atom! match_C search_hl (NEW_match_C))     ;; used for 'hlsearch'

;; Buffer for one screen line (characters and attributes).

(atom! Bytes current_ScreenLine)

;; Ugly global: overrule attribute used by screen-char().
(atom! int screen_char_attr)

;; Redraw window "win" later with update-screen(type).
;; Set "must_redraw" only if not already set to a higher value,
;; e.g. if "must_redraw" is CLEAR, type NOT_VALID will do nothing.

(defn- #_window_C redraw-later [#_window_C win, #_int type]
    (if (< (:w_redr_type win) type)
        (let [win (assoc win :w_redr_type type)
              win (if (<= NOT_VALID type) (assoc win :w_lines_valid 0) win)]
            ;; "must_redraw" is the maximum of all windows
            (when (< @must_redraw type)
                (reset! must_redraw type))
            win)
        win
    ))

;; Force a complete redraw later.  Also resets the highlighting.
;; To be used after executing a shell command that messes up the screen.

(defn- #_void redraw-later-clear []
    (redraw-all-later CLEAR)
    ;; Use attributes that is very unlikely to appear in text.
    (reset! screen_attr (| HL_BOLD HL_UNDERLINE HL_INVERSE))
    nil)

;; Mark all windows to be redrawn later.

(defn- #_void redraw-all-later [#_int type]
    (loop-when-recur [#_window_C w @firstwin] (some? w) [(:w_next w)]
        (ยง (ร w =) (redraw-later w, type)))
    nil)

;; Mark all windows that are editing the current buffer to be updated later.

(defn- #_void redraw-curbuf-later [#_int type]
    (loop-when-recur [#_window_C w @firstwin] (some? w) [(:w_next w)]
        (ยง (ร w =) (redraw-later w, type)))
    nil)

;; Changed something in the current window, at buffer line "lnum", that
;; requires that line and possibly other lines to be redrawn.
;; Used when entering/leaving Insert mode with the cursor on a folded line.
;; Used to remove the "$" from a change command.
;; Note that when also inserting/deleting lines "w_redraw_top" and "w_redraw_bot"
;; may become invalid and the whole window will have to be redrawn.

(defn- #_window_C redraw-winline [#_window_C win, #_long lnum]
    (let [win (let-when [top (:w_redraw_top win)] (or (zero? top) (> top lnum)) => win (assoc win :w_redraw_top lnum))
          win (let-when [bot (:w_redraw_bot win)] (or (zero? bot) (< bot lnum)) => win (assoc win :w_redraw_bot lnum))]
        (redraw-later win, VALID)
    ))

;; update all windows that are editing the current buffer

(defn- #_window_C update-curbuf [#_window_C win, #_int type]
    (redraw-curbuf-later type)
    (update-screen win, type))

;; Based on the current value of "w_topline", transfer a screenful
;; of stuff from Filemem to screenLines[], and update "w_botline".

(defn- #_window_C update-screen [#_window_C win, #_int type]
    ;; Don't do anything if the screen structures are (not yet) valid.
    (when' (screen-valid true) => win
        (let [type (if (non-zero? @must_redraw)
                    (let [type (max @must_redraw type)] ;; use maximal type
                        ;; "must_redraw" is reset here, so when we run into some weird reason to redraw
                        ;; while busy redrawing (e.g. asynchronous scrolling), or update-topline() in win-update() will cause a scroll,
                        ;; the screen will be redrawn later or in win-update().
                        (reset! must_redraw 0)
                        type)
                    type)
              ;; Need to update w_lines[].
              type (if (and (zero? (:w_lines_valid win)) (< type NOT_VALID)) NOT_VALID type)]
            ;; Postpone the redrawing when it's not needed and when being called recursively.
            (if (or (not (redrawing)) @updating_screen)
                (let [win (redraw-later win, type)] ;; remember type for next time
                    (reset! must_redraw type)
                    (when' (< INVERTED_ALL type) => win
                        (assoc win :w_lines_valid 0) ;; don't use w_lines[].wl_size now
                    ))
                (let [_ (reset! updating_screen true)
                      ;; if the screen was scrolled up when displaying a message, scroll it down
                      type (if (non-zero? @msg_scrolled)
                            (let [_ (reset! clear_cmdline true)
                                  type (cond (< (- @Rows 5) @msg_scrolled) ;; clearing is faster
                                        CLEAR
                                    (!= type CLEAR)
                                        (let [_ (check-for-delay false) type (if (not (screen-ins-lines 0, 0, @msg_scrolled, @Rows, nil)) CLEAR type)]
                                            (loop-when-recur [#_window_C w @firstwin] (some? w) [(:w_next w)]
                                                (ยง (ร w =)
                                                    (cond (<= @msg_scrolled (:w_winrow w))
                                                        w
                                                    (and (< @msg_scrolled (+ (:w_winrow w) (:w_height w))) (< (:w_redr_type w) REDRAW_TOP)
                                                         (< 0 (:w_lines_valid w)) (== (:w_topline w) (:wl_lnum (... (:w_lines w) 0))))
                                                        (-> w
                                                            (assoc :w_upd_rows (- @msg_scrolled (:w_winrow w)))
                                                            (assoc :w_redr_type REDRAW_TOP))
                                                    :else
                                                        (let [w (assoc w :w_redr_type NOT_VALID)]
                                                            (if (<= (+ (:w_winrow w) (:w_height w) (:w_status_height w)) @msg_scrolled)
                                                                (assoc w :w_redr_status true)
                                                                w
                                                            ))
                                                    )))
                                            (reset! redraw_cmdline true)
                                            type)
                                    :else
                                        type
                                    )]
                                (reset! msg_scrolled 0)
                                (reset! need_wait_return false)
                                type)
                            type)
                      ;; reset "cmdline_row" now (may have been changed temporarily)
                      _ (compute-cmdrow)
                      ;; first clear screen ;; will reset "clear_cmdline"
                      type (if (== type CLEAR) (do (screen-clear) NOT_VALID) type)
                      _ (when @clear_cmdline ;; going to clear cmdline (done below)
                            (check-for-delay false))
                      [win ?] ;; Force redraw when width of 'number' or 'relativenumber' column changes.
                        (when' (< (:w_redr_type win) NOT_VALID) => [win false]
                            (let [wops (:w_options win) [win ?] (if (or @(:wo_nu wops) @(:wo_rnu wops)) (number-width? win) [win 0])]
                                [win (!= (:w_nrwidth win) ?)]
                            ))
                      win (if ? (assoc win :w_redr_type NOT_VALID) win)
                      ;; Only start redrawing if there is really something to do.
                      win (if (== type INVERTED) (update-curswant win) win)
                      win (when' (and (< (:w_redr_type win) type)
                                      (not (or (and (== type VALID) (:wl_valid (... (:w_lines win) 0)) (== (:w_topline win) (:wl_lnum (... (:w_lines win) 0))))
                                               (and (== type INVERTED) @VIsual_active (== (:w_old_cursor_lnum win) (:lnum (:w_cursor win)))
                                                                                      (== (:w_old_visual_mode win) @VIsual_mode)
                                                                                      (flag? (:w_valid win) VALID_VIRTCOL)
                                                                                      (== (:w_old_curswant win) (:w_curswant win)))))) => win
                              (assoc win :w_redr_type type)
                        )]
                    ;; Go from top to bottom through the windows, redrawing the ones that need it.
                    (swap! search_hl assoc-in [:matcher :m_pattern] nil)
                    (loop-when-recur [#_boolean did_one false #_window_C w @firstwin] (some? w) [did_one (:w_next w)]
                        (ยง (ร [w did_one] =)
                            (let [[w did_one]
                                    (when' (non-zero? (:w_redr_type w)) => [w did_one]
                                        (let [_ (cursor-off) w (if did_one w (start-search-hl w))]
                                            [(win-update w, false) true])
                                    )]
                                ;; redraw status line after the window to minimize cursor movement
                                [(if (:w_redr_status w) (do (cursor-off) (win-redr-status w)) w) did_one]
                            )
                        ))
                    (end-search-hl)
                    (swap! curbuf assoc :b_mod_set false)
                    (reset! updating_screen false)
                    ;; Clear or redraw the command line.
                    ;; Done last, because scrolling may mess up the command line.
                    (when' (or @clear_cmdline @redraw_cmdline) => win
                        (showmode win)
                    ))
            ))
    ))

(defn- #_window_C update-single-line [#_window_C win, #_long lnum]
    (if (and (<= (:w_topline win) lnum) (< lnum (:w_botline win)))
        (loop-when [win win row 0 i 0] (< i (:w_lines_valid win)) => win
            (let-when [wli (... (:w_lines win) i)] (== lnum (:wl_lnum wli)) => (recur win (+ row (:wl_size wli)) (inc i))
                (let [_ (screen-start) ;; not sure of screen cursor
                      _ (init-search-hl) win (start-search-hl win) win (prepare-search-hl win, lnum)
                      [win _] (win-line win, lnum, row, (+ row (:wl_size wli)))
                      _ (end-search-hl)]
                    win)
            ))
        win
    ))

;; Update a single window.
;; This may cause the windows below it also to be redrawn (when clearing the screen or scrolling lines).
;;
;; How the window is redrawn depends on "w_redr_type".
;; Each type also implies the one below it.
;;
;; NOT_VALID    redraw the whole window
;; SOME_VALID   redraw the whole window but do scroll when possible
;; REDRAW_TOP   redraw the top "w_upd_rows" window lines, otherwise like VALID
;; INVERTED     redraw the changed part of the Visual area
;; INVERTED_ALL redraw the whole Visual area
;; VALID        1. scroll up/down to adjust for a changed "w_topline"
;;              2. update lines at the top when scrolled down
;;              3. redraw changed text:
;;                 - if "b_mod_set" is set, update lines between "b_mod_top" and "b_mod_bot".
;;                 - if "w_redraw_top" is non-zero, redraw lines between "w_redraw_top" and "w_redr_bot".
;;                 - continue redrawing when syntax status is invalid.
;;              4. if scrolled up, update lines at the bottom.
;;
;; This results in three areas that may need updating:
;;
;; top: from first row to "top_end" (when scrolled down)
;; mid: from "mid_start" to "mid_end" (update inversion or changed text)
;; bot: from "bot_start" to last row (when scrolled up)

(defn- #_window_C win-update [#_window_C win, #_boolean recursive?]
    (cond (zero? (:w_height win))
        (assoc win :w_redr_type 0)

    (zero? (:w_width win)) ;; draw the vertical separator right of this window
        (do (draw-vsep-win win, 0) (assoc win :w_redr_type 0))

    :else
        (let [o'botline (:w_botline win) a'type (atom (int (:w_redr_type win)))
              win (if (== @a'type NOT_VALID) (assoc win :w_redr_status true, :w_lines_valid 0) win)
              _ (init-search-hl)
              a'mod_top (atom (long 0)) a'mod_bot (atom (long 0)) a'top_to_mod (atom (boolean false)) ;; redraw above "mod_top"
              ;; Force redraw when width of 'number' or 'relativenumber' column changes.
              [win #_int nrwidth] (if (or @(:wo_nu (:w_options win)) @(:wo_rnu (:w_options win))) (number-width? win) [win 0])
              win (cond (!= (:w_nrwidth win) nrwidth)
                    (do (reset! a'type NOT_VALID) (assoc win :w_nrwidth nrwidth))
                (and (:b_mod_set @curbuf) (non-zero? (:b_mod_xlines @curbuf)) (non-zero? (:w_redraw_top win)))
                    ;; When there are both inserted/deleted lines and specific lines to be redrawn, "w_redraw_top" and "w_redraw_bot" may be invalid.
                    ;; Just redraw everything (only happens when redrawing is off for while).
                    (do (reset! a'type NOT_VALID) win)
                :else
                    ;; Set "mod_top" to the first line that needs displaying because of changes.
                    ;; Set "mod_bot" to the first line after the changes.
                    (let [_ (reset! a'mod_top (:w_redraw_top win))
                          _ (reset! a'mod_bot (if (non-zero? (:w_redraw_bot win)) (inc (:w_redraw_bot win)) 0))
                          win (assoc win :w_redraw_top 0, :w_redraw_bot 0)] ;; reset for next time
                        (when (:b_mod_set @curbuf)
                            (reset! a'mod_top (if (or (zero? @a'mod_top) (< (:b_mod_top @curbuf) @a'mod_top)) (:b_mod_top @curbuf) @a'mod_top))
                            (reset! a'mod_bot (if (or (zero? @a'mod_bot) (< @a'mod_bot (:b_mod_bot @curbuf))) (:b_mod_bot @curbuf) @a'mod_bot))
                            ;; When 'hlsearch' is on and using a multi-line search pattern,
                            ;; a change in one line may make the search highlighting in a previous line invalid.
                            ;; Simple solution: redraw all visible lines above the change.
                            (let-when [pat (:m_pattern (:matcher @search_hl))] (and (some? pat) (re-multiline pat))
                                (reset! a'top_to_mod true)
                            ))
                        ;; When a change starts above "w_topline" and the end is below "w_topline", start redrawing at "w_topline".
                        ;; If the end of the change is above "w_topline": do like no change was made, but redraw the first line to find changes in syntax.
                        (reset! a'mod_top (if (and (non-zero? @a'mod_top) (< @a'mod_top (:w_topline win) @a'mod_bot)) (:w_topline win) @a'mod_top))
                        ;; When line numbers are displayed, need to redraw all lines inserted/deleted below.
                        (reset! a'mod_bot (if (and (non-zero? @a'mod_top) (non-zero? (:b_mod_xlines @curbuf)) @(:wo_nu (:w_options win))) MAXLNUM @a'mod_bot))
                        win
                    ))

              a'top_end (atom (int 0))              ;; Below last row of the top area that needs updating.  0 when no top area updating.
              a'mid_start (atom (int 999))          ;; First row of the mid area that needs updating.     999 when no mid area updating.
              a'mid_end (atom (int 0))              ;; Below last row of the mid area that needs updating.  0 when no mid area updating.
              a'bot_start (atom (int 999))          ;; First row of the bot area that needs updating.     999 when no bot area updating.

              ;; When only displaying the lines at the top, set "top_end".
              ;; Used when window has scrolled down for "msg_scrolled".
              _ (when (== @a'type REDRAW_TOP)
                    (reset! a'top_end
                        (loop-when [#_int i 0 #_int n 0] (< i (:w_lines_valid win)) => n
                            (let-when [n (+ n (:wl_size (... (:w_lines win) i)))] (< n (:w_upd_rows win)) => n
                                (recur (inc i) n))
                        ))
                    (reset! a'type
                        (if (zero? @a'top_end)
                            NOT_VALID ;; not found (cannot happen?): redraw everything
                            VALID ;; top area defined, the rest is VALID
                        )))

              ;; Trick: we want to avoid clearing the screen twice.  screen-clear() will set
              ;; "screen_cleared" to true.  The special value MAYBE (which is still non-zero
              ;; and thus not false) will indicate that screen-clear() was not called.
              _ (when (!= @screen_cleared FALSE)
                    (reset! screen_cleared MAYBE))

              ;; Scrolled down when "w_topline" got smaller a bit.
              a'scrolled_down (atom (boolean false))

              ;; If there are no changes on the screen that require a complete redraw, handle three cases:
              ;; 1: we are off the top of the screen by a few lines: scroll down
              ;; 2: "w_topline" is below "w_lines[0].wl_lnum": may scroll up
              ;; 3: "w_topline" is "w_lines[0].wl_lnum": find first entry in w_lines[] that needs updating.
              win (cond (any == @a'type VALID SOME_VALID INVERTED INVERTED_ALL)
                    (let [win (cond
                            (and (non-zero? @a'mod_top) (== (:w_topline win) @a'mod_top))
                                win ;; "w_topline" is the first changed line, the scrolling will be done further down.
                            (and (:wl_valid (... (:w_lines win) 0)) (< (:w_topline win) (:wl_lnum (... (:w_lines win) 0))))
                                ;; New topline is above old topline: may scroll down.
                                (let [#_int j (- (:wl_lnum (... (:w_lines win) 0)) (:w_topline win))]
                                    (cond (< j (- (:w_height win) 2)) ;; not too far off
                                        (let [#_int i (plines-many win, (:w_topline win), (dec (:wl_lnum (... (:w_lines win) 0))))]
                                            (cond (< i (- (:w_height win) 2)) ;; less than a screen off
                                                ;; Try to insert the correct number of lines.
                                                ;; If not the last window, delete the lines at the bottom.
                                                ;; win-ins-lines() may fail when the terminal can't do it.
                                                (let [_ (when (< 0 i) (check-for-delay false))
                                                      [win ?] (win-ins-lines? win, 0, i, false, (== win @firstwin))]
                                                    (cond ?
                                                        (if (non-zero? (:w_lines_valid win))
                                                            ;; Need to update rows that are new,
                                                            ;; stop at the first one that scrolled down.
                                                            (let [_ (reset! a'top_end i) _ (reset! a'scrolled_down true)
                                                                  ;; Move the entries that were scrolled,
                                                                  ;; disable the entries for the lines to be redrawn.
                                                                  win (assoc win :w_lines_valid (min (+ (:w_lines_valid win) j) (:w_height win)))
                                                                  [win #_int k]
                                                                    (loop-when [win win k (:w_lines_valid win)] (<= 0 (- k j)) => [win k]
                                                                        (recur (assoc-in win [:w_lines k] (... (:w_lines win) (- k j))) (dec k))
                                                                    )]
                                                                (loop-when-recur [win win k k] (<= 0 k) [(assoc-in win [:w_lines k :wl_valid] false) (dec k)] => win))
                                                            win)
                                                    :else
                                                        (do (reset! a'mid_start 0) win) ;; redraw all lines
                                                    ))
                                            :else
                                                (do (reset! a'mid_start 0) win) ;; redraw all lines
                                            ))
                                    :else
                                        (do (reset! a'mid_start 0) win) ;; redraw all lines
                                    ))
                            :else
                                ;; New topline is at or below old topline: may scroll up.
                                ;; When topline didn't change, find first entry in w_lines[] that needs updating.
                                (let [[#_int row #_int j]
                                        (loop-when [row 0 j -1 #_int i 0] (< i (:w_lines_valid win)) => [row j]
                                            (let [wli (... (:w_lines win) i)]
                                                (if-not (and (:wl_valid wli) (== (:wl_lnum wli) (:w_topline win)))
                                                    (recur (+ row (:wl_size wli)) j (inc i))
                                                    [row i]
                                                ))
                                        )]
                                    (cond (== j -1) ;; if "w_topline" is not in "w_lines[].wl_lnum", redraw all lines
                                        (do (reset! a'mid_start 0) win)
                                    :else
                                        ;; Try to delete the correct number of lines.
                                        ;; "w_topline" is at "w_lines[row].wl_lnum".
                                        (let [win (if (< 0 row)
                                                    (let [_ (check-for-delay false)
                                                          [win ?] (win-del-lines? win, 0, row, false, (== win @firstwin))]
                                                        (if ?
                                                            (reset! a'bot_start (- (:w_height win) row))
                                                            (reset! a'mid_start 0)) ;; redraw all lines
                                                        win)
                                                    win
                                                )]
                                            (if (and (or (zero? row) (< @a'bot_start 999)) (non-zero? (:w_lines_valid win)))
                                                ;; Skip the lines (below the deleted lines) that are still valid and
                                                ;; don't need redrawing.  Copy their info upwards, to compensate for the
                                                ;; deleted lines.  Set "bot_start" to the first row that needs redrawing.
                                                (let [_ (reset! a'bot_start 0)]
                                                    (loop [win win #_int k 0 j j]
                                                        (let [win (assoc-in win [:w_lines k] (... (:w_lines win) j))]
                                                            ;; stop at line that didn't fit, unless it is still valid (no lines deleted)
                                                            (if (and (< 0 row) (< (:w_height win) (+ @a'bot_start row (:wl_size (... (:w_lines win) j)))))
                                                                (assoc win :w_lines_valid (inc k))
                                                                (let [_ (reset! a'bot_start (+ @a'bot_start (:wl_size (... (:w_lines win) k)))) k (inc k) j (inc j)]
                                                                    ;; stop at the last valid entry in "w_lines[].wl_size"
                                                                    (recur-if (< j (:w_lines_valid win)) [win k j] => (assoc win :w_lines_valid k)))
                                                            ))
                                                    ))
                                                win
                                            ))
                                    ))
                            )]
                        ;; When starting redraw in the first line, redraw all lines.
                        ;; When there is only one window, it's probably faster to clear the screen first.
                        (when (zero? @a'mid_start)
                            (reset! a'mid_end (:w_height win))
                            (when (== @lastwin @firstwin)
                                ;; Clear the screen when it was not done by win-del-lines() or win-ins-lines() above,
                                ;; "screen_cleared" is false or MAYBE then.
                                (when (!= @screen_cleared TRUE)
                                    (screen-clear))
                            ))
                        ;; When win-del-lines() or win-ins-lines() caused the screen to be
                        ;; cleared (only happens for the first window) or when screen-clear()
                        ;; was called directly above, "must_redraw" will have been set to
                        ;; NOT_VALID, need to reset it here to avoid redrawing twice.
                        (when (== @screen_cleared TRUE)
                            (reset! must_redraw 0))
                        win)
                :else
                    (do ;; Not VALID or INVERTED: redraw all lines.
                        (reset! a'mid_start 0)
                        (reset! a'mid_end (:w_height win))
                        win
                    ))
              _ (when (== @a'type SOME_VALID)
                    ;; SOME_VALID: redraw all lines.
                    (reset! a'mid_start 0)
                    (reset! a'mid_end (:w_height win))
                    (reset! a'type NOT_VALID))
              ;; Check if we are updating or removing the inverted part.
              win (if (or @VIsual_active (and (non-zero? (:w_old_cursor_lnum win)) (!= @a'type NOT_VALID)))
                    (let [ocl (:w_old_cursor_lnum win) ovl (:w_old_visual_lnum win)
                          [win #_long from #_long to]
                            (cond @VIsual_active
                                (let [cln (:lnum (:w_cursor win)) vln (:lnum @VIsual_cursor)
                                      [from to]
                                        (if (and @VIsual_active (or (!= @VIsual_mode (:w_old_visual_mode win)) (== @a'type INVERTED_ALL)))
                                            ;; If the type of Visual selection changed, redraw the whole selection.
                                            (let [[from to] (if (< cln vln) [cln vln] [vln cln])]
                                                ;; redraw more when the cursor moved as well
                                                [(min from ocl ovl) (max ocl ovl to)])
                                            ;; Find the line numbers that need to be updated:
                                            ;; the lines between the old cursor position and the current cursor position.
                                            ;; Also check if the Visual position changed.
                                            (let [[from to] (if (< cln ocl) [cln ocl] [(if (zero? ocl) cln ocl) cln])] ;; Visual mode just started
                                                (if (or (!= vln ovl) (!= (:col @VIsual_cursor) (:w_old_visual_col win)))
                                                    (let [from (if (non-zero? ovl) (min from ovl) from)]
                                                        [(min from vln) (max ovl vln to)])
                                                    [from to]
                                                ))
                                        )]
                                    ;; If in block mode and changed column or "w_curswant": update all lines.
                                    ;; First compute the actual start and end column.
                                    (if (== @VIsual_mode Ctrl_V)
                                        (let [a'fromc (atom (int)) a'toc (atom (int)) o've_flags @ve_flags]
                                            (when @(:wo_lbr (:w_options win))
                                                (reset! ve_flags VE_ALL))
                                            (getvcols win, @VIsual_cursor, (:w_cursor win), a'fromc, a'toc)
                                            (reset! ve_flags o've_flags)
                                            (swap! a'toc inc)
                                            (when (== (:w_curswant win) MAXCOL)
                                                (reset! a'toc MAXCOL))
                                            (let [[from to]
                                                    (if (or (!= @a'fromc (:w_old_cursor_fcol win)) (!= @a'toc (:w_old_cursor_lcol win)))
                                                        [(min from vln) (max vln to)]
                                                        [from to]
                                                    )]
                                                [(-> win (assoc :w_old_cursor_fcol @a'fromc) (assoc :w_old_cursor_lcol @a'toc)) from to]
                                            ))
                                        [win from to]
                                    ))
                            :else
                                ;; Use the line numbers of the old Visual area.
                                (let [[from to] (if (< ocl ovl) [ocl ovl] [ovl ocl])]
                                    [win from to]
                                ))
                          ;; There is no need to update lines above the top of the window.
                          from (max (:w_topline win) from)
                          ;; If we know the value of "w_botline", use it to restrict the update to the lines that are visible in the window.
                          [from to] (if (flag? (:w_valid win) VALID_BOTLINE) [(min from (dec (:w_botline win))) (min to (dec (:w_botline win)))] [from to])]
                        ;; Find the minimal part to be updated.
                        ;; Watch out for scrolling that made entries in w_lines[] invalid.
                        ;; E.g., CTRL-U makes the first half of w_lines[] invalid and sets "top_end": need to redraw from "top_end" to the "to" line.
                        (when (< 0 @a'mid_start)
                            (reset! a'mid_start (if @a'scrolled_down @a'top_end 0))
                            (let [[#_int srow #_int i]
                                    (loop-when [srow 0 #_long lnum (:w_topline win) i 0] (and (< lnum from) (< i (:w_lines_valid win))) => [srow i] ;; find start
                                        (let [wli (... (:w_lines win) i)
                                              srow (cond (:wl_valid wli) (do (swap! a'mid_start + (:wl_size wli)) srow) (not @a'scrolled_down) (+ srow (:wl_size wli)) :else srow)]
                                            (recur srow (inc lnum) (inc i))
                                        ))
                                  srow (+ srow @a'mid_start)]
                                (reset! a'mid_end (:w_height win))
                                (loop-when [srow srow i i] (< i (:w_lines_valid win)) ;; find end
                                    (let [wli (... (:w_lines win) i)]
                                        (if (and (:wl_valid wli) (<= (inc to) (:wl_lnum wli)))
                                            (reset! a'mid_end srow) ;; only update until first row of this line
                                            (recur (+ srow (:wl_size wli)) (inc i))
                                        ))
                                )))
                        win)
                    win)
              win (if @VIsual_active
                    (assoc win :w_old_visual_mode   @VIsual_mode
                               :w_old_cursor_lnum   (:lnum (:w_cursor win))
                               :w_old_visual_lnum   (:lnum @VIsual_cursor)
                               :w_old_visual_col    (:col @VIsual_cursor)
                               :w_old_curswant      (:w_curswant win))
                    (assoc win :w_old_visual_mode   0
                               :w_old_cursor_lnum   0
                               :w_old_visual_lnum   0
                               :w_old_visual_col    0))
            ;; reset "got_int", otherwise regexp won't work
            o'got_int @got_int _ (reset! got_int false)

            lmax (line-count @curbuf)
            a'idx (atom (int 0))
            a'row (atom (int 0))                    ;; current window row to display
            a'srow (atom (int 0))                   ;; starting row of the current line
            a'lnum (atom (long (:w_topline win)))   ;; first line shown in window

            ;; Update all the window rows.

            [win eol? eof?] ;; "eol?": we finished the last line ;; "eof?": we hit the end of the file
                (loop []
                    ;; stop updating when reached the end of the window
                    ;; (check for *past* the end of the window is at the end of the loop)
                    (cond (== @a'row (:w_height win))
                        [win true false]
                    ;; stop updating when hit the end of the file
                    (< lmax @a'lnum)
                        [win false true]
                    :else
                        ;; Remember the starting row of the line that is going to be dealt with.
                        ;; It is used further down when the line doesn't fit.
                        (let-when [_ (reset! a'srow @a'row)
                              ;; Update a line when it is in an area that needs updating, when it has changes or w_lines[idx] is invalid.
                              ;; "bot_start" may be halfway a wrapped line after using win-del-lines(), check if the current line includes it.
                              ;; Match in fixed position might need redraw if lines were inserted or deleted.
                              [win ?]
                                (cond (or (< @a'row @a'top_end)
                                          (and (<= @a'mid_start @a'row) (< @a'row @a'mid_end))
                                          @a'top_to_mod
                                          (<= (:w_lines_valid win) @a'idx)
                                          (< @a'bot_start (+ @a'row (:wl_size (... (:w_lines win) @a'idx))))
                                          (and (!= @a'mod_top 0) (or (== @a'lnum @a'mod_top) (and (<= @a'mod_top @a'lnum) (< @a'lnum @a'mod_bot)))))
                                    (let [_ (reset! a'top_to_mod (if (== @a'lnum @a'mod_top) false @a'top_to_mod))
                                          ;; When at start of changed lines: may scroll following lines up or down to minimize redrawing.
                                          ;; Don't do this when the change continues until the end.
                                          win (if (and (== @a'lnum @a'mod_top) (!= @a'mod_bot MAXLNUM))
                                                ;; Count the old number of window rows, using w_lines[], which should
                                                ;; still contain the sizes for the lines as they are currently displayed.
                                                (let [[#_int old_rows #_int i]
                                                        (loop-when [old_rows 0 i @a'idx] (< i (:w_lines_valid win)) => [old_rows i]
                                                            (let [wli (... (:w_lines win) i)]
                                                                ;; Only valid lines have a meaningful wl_lnum.
                                                                ;; Invalid lines are part of the changed area.
                                                                (if (and (:wl_valid wli) (== (:wl_lnum wli) @a'mod_bot))
                                                                    [old_rows i]
                                                                    (recur (+ old_rows (:wl_size wli)) (inc i))
                                                                ))
                                                        )]
                                                    (cond (<= (:w_lines_valid win) i)
                                                        ;; We can't find a valid line below the changed lines,
                                                        ;; need to redraw until the end of the window.
                                                        ;; Inserting/deleting lines has no use.
                                                        (do (reset! a'bot_start 0) win)
                                                    :else
                                                        ;; Able to count old number of rows:
                                                        ;; count new window rows, and may insert/delete lines.
                                                        (let [[#_int new_rows #_int j]
                                                                (loop-when [new_rows 0 j @a'idx #_long l @a'lnum] (< l @a'mod_bot) => [new_rows j]
                                                                    (let [new_rows (+ new_rows (plines win, l, true))]
                                                                        (if (< (- (:w_height win) @a'row 2) new_rows)
                                                                            [9999 (inc j)] ;; it's getting too much, must redraw the rest
                                                                            (recur new_rows (inc j) (inc l))
                                                                        )))
                                                            #_int xtra_rows (- new_rows old_rows)
                                                            win (cond (< xtra_rows 0)
                                                                    ;; May scroll text up.
                                                                    ;; If there is not enough remaining text or scrolling fails, must redraw the rest.
                                                                    ;; If scrolling works, must redraw the text below the scrolled text.
                                                                    (cond (<= (- (:w_height win) 2) (- @a'row xtra_rows))
                                                                        (do (reset! a'mod_bot MAXLNUM) win)
                                                                    :else
                                                                        (let [_ (check-for-delay false)
                                                                              [win ?] (win-del-lines? win, @a'row, (- xtra_rows), false, false)]
                                                                            (if (not ?)
                                                                                (reset! a'mod_bot MAXLNUM)
                                                                                (reset! a'bot_start (+ (:w_height win) xtra_rows)))
                                                                            win
                                                                        ))
                                                                (< 0 xtra_rows)
                                                                    ;; May scroll text down.
                                                                    ;; If there is not enough remaining text of scrolling fails, must redraw the rest.
                                                                    (cond (<= (- (:w_height win) 2) (+ @a'row xtra_rows))
                                                                        (do (reset! a'mod_bot MAXLNUM) win)
                                                                    :else
                                                                        (let [_ (check-for-delay false)
                                                                              [win ?] (win-ins-lines? win, (+ @a'row old_rows), xtra_rows, false, false)]
                                                                            (cond (not ?)
                                                                                (reset! a'mod_bot MAXLNUM)
                                                                            (< (+ @a'row old_rows) @a'top_end)
                                                                                ;; Scrolled the part at the top that requires updating down.
                                                                                (reset! a'top_end (+ @a'top_end xtra_rows)))
                                                                            win
                                                                        ))
                                                                :else
                                                                    win
                                                                )]
                                                            ;; When not updating the rest, may need to move w_lines[] entries.
                                                            (cond (or (== @a'mod_bot MAXLNUM) (== i j))
                                                                win
                                                            (< j i) ;; move entries in w_lines[] upwards
                                                                (let [[win #_int x]
                                                                        (loop-when [win win x (+ @a'row new_rows) j j i i] (< i (:w_lines_valid win))
                                                                                => [(assoc win :w_lines_valid j) x] ;; stop at last valid entry in w_lines[]
                                                                            (let [win (assoc-in win [:w_lines j] (... (:w_lines win) i))]
                                                                                (if (< (:w_height win) (+ x (:wl_size (... (:w_lines win) j))))
                                                                                    [(assoc win :w_lines_valid (inc j)) x] ;; stop at a line that won't fit
                                                                                    (recur win (+ x (:wl_size (... (:w_lines win) j))) (inc j) (inc i))
                                                                                ))
                                                                        )]
                                                                    (swap! a'bot_start min x)
                                                                    win)
                                                            :else ;; (< i j) ;; move entries in w_lines[] downwards
                                                                (let [j (- j i)
                                                                      win (update win :w_lines_valid + j) win (update win :w_lines_valid min (:w_height win))
                                                                      [win i]
                                                                        (loop-when [win win i (:w_lines_valid win)] (<= @a'idx (- i j)) => [win i]
                                                                            (recur (assoc-in win [:w_lines i] (... (:w_lines win) (- i j))) (dec i))
                                                                        )]
                                                                    ;; The w_lines[] entries for inserted lines are now invalid, but wl_size may be used above.
                                                                    ;; Reset to zero.
                                                                    (loop-when-recur [win win i i]
                                                                                     (<= @a'idx i)
                                                                                     [(update-in win [:w_lines i] assoc :wl_size 0, :wl_valid false) (dec i)]
                                                                                  => win))
                                                            ))
                                                    ))
                                                win)
                                          win (let [wli (... (:w_lines win) @a'idx)]
                                                (if (and (< @a'idx (:w_lines_valid win)) (:wl_valid wli)
                                                         (== (:wl_lnum wli) @a'lnum) (< (:w_topline win) @a'lnum)
                                                         (non-flag? @dy_flags DY_LASTLINE) (< (:w_height win) (+ @a'srow (:wl_size wli))))
                                                    ;; This line is not going to fit.
                                                    ;; Don't draw anything here, will draw "@  " lines below.
                                                    (do (reset! a'row (inc (:w_height win)))
                                                        win)
                                                    ;; Display one line.
                                                    (let [win (prepare-search-hl win, @a'lnum) [win _] (win-line win, @a'lnum, @a'srow, (:w_height win)) _ (reset! a'row _)]
                                                        win)
                                                ))
                                          win (update-in win [:w_lines @a'idx] assoc :wl_lnum @a'lnum, :wl_valid true)]
                                        (if (< (:w_height win) @a'row) ;; *past* end of screen
                                            ;; we may need the size of that too long line later on
                                            (let [win (assoc-in win [:w_lines @a'idx :wl_size] (plines win, @a'lnum, true))]
                                                (swap! a'idx inc)
                                                [win :break])
                                            (let [win (assoc-in win [:w_lines @a'idx :wl_size] (- @a'row @a'srow))]
                                                (swap! a'idx inc)
                                                (swap! a'lnum inc)
                                                [win nil])
                                        ))
                                :else
                                    (do ;; This line does not need updating, advance to the next one.
                                        (swap! a'row + (:wl_size (... (:w_lines win) @a'idx)))
                                        (swap! a'idx inc)
                                        (if (< (:w_height win) @a'row) ;; *past* end of screen
                                            [win :break]
                                            (do (swap! a'lnum inc) [win nil])
                                        ))
                                )] (not ?) => [win false false]

                            (if (< lmax @a'lnum) [win false true] (recur))
                        )))

              ;; End of loop over all window lines.
              win (update win :w_lines_valid max @a'idx)
              ;; If we didn't hit the end of the file, and we didn't finish the last line we were working on, then the line didn't fit.
              win (assoc win :w_empty_rows 0)
              win (cond (and (not eof?) (not eol?))
                    (cond (== @a'lnum (:w_topline win))
                        ;; Single line that does not fit!
                        ;; Don't overwrite it, it can be edited.
                        (assoc win :w_botline (inc @a'lnum))
                    (flag? @dy_flags DY_LASTLINE) ;; 'display' has "lastline"
                        ;; Last line isn't finished: display "@@@" at the end.
                        (do (screen-fill (- (+ (:w_winrow win) (:w_height win)) 1), (+ (:w_winrow win) (:w_height win)),
                                         (- (+ (:w_wincol win) (:w_width win)) 3), (+ (:w_wincol win) (:w_width win)), (byte \@), (byte \@), (hl-attr HLF_AT))
                            (-> win
                                (set-empty-rows @a'srow)
                                (assoc :w_botline @a'lnum)
                            ))
                    :else
                        (-> win
                            (win-draw-end (byte \@), (byte \space), @a'srow, (:w_height win), HLF_AT)
                            (assoc :w_botline @a'lnum)
                        ))
                :else
                    (let [_ (draw-vsep-win win, @a'row) win (assoc win :w_botline (if eof? (inc lmax) @a'lnum))]
                        ;; Make sure the rest of the screen is blank: put '~'s on rows that aren't part of the file.
                        (win-draw-end win, (byte \~), (byte \space), @a'row, (:w_height win), HLF_AT)
                    ))

              ;; Reset the type of redrawing required, the window has been updated.
              win (assoc win :w_redr_type 0)

              ;; There is a trick with "w_botline".  If we invalidate it on each change that might modify it,
              ;; this will cause a lot of expensive calls to plines() in update-topline() each time.
              ;; Therefore the value of "w_botline" is often approximated, and this value is used to compute
              ;; the value of "w_topline".  If the value of "w_botline" was wrong, check that the value of
              ;; "w_topline" is correct (cursor is on the visible part of the text).  If it's not, we need to
              ;; redraw again.  Mostly this just means scrolling up a few lines, so it doesn't look too bad.
              ;; Only do this for the current window (where changes are relevant).
              win (update win :w_valid | VALID_BOTLINE)
              win (if (and (:w_focused win) (!= (:w_botline win) o'botline) (not recursive?))
                    (let [win (-> win (update :w_valid & (bit-not VALID_TOPLINE)) (update-topline))] ;; may invalidate "w_botline" again
                        (if (non-zero? @must_redraw)
                            ;; Don't update for changes in buffer again.
                            (let [? (:b_mod_set @curbuf) _ (swap! curbuf assoc :b_mod_set false)
                                  win (win-update win, true)]
                                (reset! must_redraw 0)
                                (swap! curbuf assoc :b_mod_set ?)
                                win)
                            win
                        ))
                    win
                )]

            ;; Restore "got_int", unless CTRL-C was hit while redrawing.
            (when (not @got_int)
                (reset! got_int o'got_int))
            win
        )
    ))

;; Clear the rest of the window and mark the unused lines with "c1".
;; Use "c2" as the filler character.

(defn- #_window_C win-draw-end [#_window_C win, #_int c1, #_int c2, #_int row, #_int endrow, #_int hl]
    (let [r (:w_winrow win) c (:w_wincol win) w (:w_width win)]
        (let [#_int n
            (if (and (non-zero? @cmdwin_type) (:w_focused win)) ;; draw the cmdline character in the leftmost column
                (let [n (min 1 w)] (screen-fill (+ r row), (+ r endrow), c, (+ c n), @cmdwin_type, (byte \space), (hl-attr HLF_AT)) n)
                0)]
            (screen-fill (+ r row), (+ r endrow), (+ c n), (+ c w), c1, c2, (hl-attr hl))
        )
        (set-empty-rows win, row)
    ))

;; Advance **color_cols and return true when there are columns to draw.

(defn- #_boolean advance-color-col [#_int vcol, #_int* color_cols, #_int' a'cci]
    (while (< -1 (... color_cols @a'cci) vcol)
        (swap! a'cci inc))
    (< -1 (... color_cols @a'cci)))

;; draw_state: items that are drawn in sequence:
(final int
    WL_START   0,   ;; nothing done yet
    WL_CMDLINE 1,   ;; cmdline window column
    WL_NR      2,   ;; line number
    WL_BRI     3,   ;; 'breakindent'
    WL_SBR     4,   ;; 'showbreak' or 'diff'
    WL_LINE    5)   ;; text in the line

;; Display line "lnum" of window "win" on the screen.
;; Start at row "startrow", stop when "endrow" is reached.
;; "w_virtcol" needs to be valid.
;;
;; Return the number of last row the line occupies.

(defn- #_[window_C int] win-line [#_window_C win, #_long lnum, #_int startrow, #_int endrow]
    (if (< endrow startrow) ;; already past the end!
        startrow
        (let [#_int* color_cols (:w_p_cc_cols win) a'cci (atom (int 0))
              a'vcol (atom (int 0))                                 ;; virtual column (for tabs)
              a'draw_color_col (atom (boolean (and (some? color_cols) (advance-color-col @a'vcol, color_cols, a'cci))))
              a'lnum_in_visual (atom (boolean false))               ;; handle visual active in this window
              a'fromcol (atom (int -10))                            ;; start/end of inverting
              a'tocol (atom (int MAXCOL))
              a'noinvcur (atom (boolean false))                     ;; don't invert the cursor
              a'area_highlighting (atom (boolean false))            ;; Visual or 'incsearch' highlighting in this line
              a'attr_highlighting (atom (int 0))                    ;; attributes for area highlighting
              a'n_skip (atom (int 0))                               ;; nr of chars to skip for 'nowrap'
              a'need_showbreak (atom (boolean false))
              a'fromcol_prev (atom (int -2))                        ;; start of inverting after cursor
              a'search_attr (atom (int 0))                          ;; attributes desired by 'hlsearch'
              a'row (atom (int startrow))                           ;; row in the window, excl. "w_winrow"
              a'screen_row (atom (int (+ @a'row (:w_winrow win))))  ;; row on the screen, incl. "w_winrow"

              _ (:w_options win) wo_bri @(:wo_bri _) wo_cuc @(:wo_cuc _) wo_cul @(:wo_cul _) wo_lbr @(:wo_lbr _) wo_nu @(:wo_nu _) wo_rnu @(:wo_rnu _) wo_wrap @(:wo_wrap _)]

            (cond @VIsual_active
                (let [[top bot] (if (ltoreq (:w_cursor win), @VIsual_cursor) [(:w_cursor win) @VIsual_cursor] [@VIsual_cursor (:w_cursor win)])]
                    (reset! a'lnum_in_visual (<= (:lnum top) lnum (:lnum bot)))
                    (cond (== @VIsual_mode Ctrl_V)                  ;; block mode
                        (when @a'lnum_in_visual
                            (reset! a'fromcol (:w_old_cursor_fcol win))
                            (reset! a'tocol (:w_old_cursor_lcol win)))
                    :else                                           ;; non-block mode
                        (do (cond (and (< (:lnum top) lnum) (<= lnum (:lnum bot)))
                                (reset! a'fromcol 0)
                            (== lnum (:lnum top))
                                (if (== @VIsual_mode (byte \V))     ;; linewise
                                    (reset! a'fromcol 0)
                                    (do (getvvcol win, top, a'fromcol, nil, nil)
                                        (when (== (gchar-pos top) NUL)
                                            (reset! a'tocol (+ @a'fromcol 1))
                                        ))
                                ))
                            (when (and (!= @VIsual_mode (byte \V)) (== lnum (:lnum bot)))
                                (cond (and (at? @p_sel (byte \e)) (zero? (:col bot)) (zero? (:coladd bot)))
                                    (do (reset! a'fromcol -10)
                                        (reset! a'tocol MAXCOL))
                                (== (:col bot) MAXCOL)
                                    (reset! a'tocol MAXCOL)
                                (at? @p_sel (byte \e))
                                    (getvvcol win, bot, a'tocol, nil, nil)
                                :else
                                    (do (getvvcol win, bot, nil, nil, a'tocol)
                                        (swap! a'tocol inc))
                                ))
                        ))
                    ;; Check if the character under the cursor should not be inverted.
                    (reset! a'noinvcur (or (and (not @highlight_match) (:w_focused win) (== lnum (:lnum (:w_cursor win)))) @a'noinvcur))
                    ;; If inverting in this line, set "area_highlighting".
                    (when (<= 0 @a'fromcol)
                        (reset! a'area_highlighting true)
                        (reset! a'attr_highlighting (hl-attr HLF_V))
                    ))
            ;; Handle 'incsearch' and ":s///c" highlighting.
            (and @highlight_match (:w_focused win) (<= (:lnum (:w_cursor win)) lnum) (<= lnum (+ (:lnum (:w_cursor win)) @search_match_lines)))
                (do (if (== lnum (:lnum (:w_cursor win)))
                        (getvcol win, (:w_cursor win), a'fromcol, nil, nil)
                        (reset! a'fromcol 0))
                    (if (== lnum (+ (:lnum (:w_cursor win)) @search_match_lines))
                        (getvcol win, (pos_C. lnum @search_match_endcol 0), a'tocol, nil, nil)
                        (reset! a'tocol MAXCOL))
                    ;; Do at least one character; happens when past end of line.
                    (when (== @a'fromcol @a'tocol)
                        (reset! a'tocol (+ @a'fromcol 1)))
                    (reset! a'area_highlighting true)
                    (reset! a'attr_highlighting (hl-attr HLF_I))
                ))

            (let [a'line (atom (#_Bytes object (ml-get lnum))) a's (atom (#_Bytes object @a'line))]
                ;; 'nowrap' or 'wrap' and a single line that doesn't fit:
                ;; advance to the first character to be displayed.
                (let-when [#_int v (if wo_wrap (:w_skipcol win) (:w_leftcol win))] (< 0 v)
                    (let [[#_int c #_Bytes p]
                            (loop-when [c 0 p @a's] (and (< @a'vcol v) (non-eos? @a's)) => [c p]
                                (let [c (win-lbr-chartabsize win, @a'line, @a's, @a'vcol, nil)
                                      _ (swap! a'vcol + c)
                                      p @a's
                                      _ (swap! a's #(.plus % (us-ptr2len-cc %)))]
                                    (recur c p))
                            )]
                        ;; When 'cuc', or 'colorcolumn', or 'virtualedit' is set, or the visual mode is active,
                        ;; the end of the line may be before the start of the displayed part.
                        (reset! a'vcol (if (and (< @a'vcol v) (or wo_cuc @a'draw_color_col (virtual-active) @VIsual_active)) v @a'vcol))
                        ;; Handle a character that's not completely on the screen:
                        ;; put "s" at that character, but skip the first few screen characters.
                        (when (< v @a'vcol)
                            (swap! a'vcol - c)
                            (reset! a's p)
                            (reset! a'n_skip (- v @a'vcol)))
                        ;; Adjust for when the inverted text is before the screen,
                        ;; and when the start of the inverted text is before the screen.
                        (cond (<= @a'tocol @a'vcol)
                            (reset! a'fromcol 0)
                        (and (<= 0 @a'fromcol) (< @a'fromcol @a'vcol))
                            (reset! a'fromcol @a'vcol)
                        )
                        ;; When "w_skipcol" is non-zero, first line needs 'showbreak'.
                        (reset! a'need_showbreak (or wo_wrap @a'need_showbreak))
                    ))
                ;; Correct highlighting for cursor that can't be disabled.
                ;; Avoids having to check this for each character.
                (when (<= 0 @a'fromcol)
                    (when @a'noinvcur
                        (cond (== @a'fromcol (:w_virtcol win))
                        (do ;; highlighting starts at cursor, let it start just after the cursor
                            (reset! a'fromcol_prev @a'fromcol)
                            (reset! a'fromcol -1))
                        (< @a'fromcol (:w_virtcol win))
                        (do ;; restart highlighting after the cursor
                            (reset! a'fromcol_prev (:w_virtcol win)))
                        ))
                    (when (<= @a'tocol @a'fromcol)
                        (reset! a'fromcol -1)
                    ))

                (let [win ;; Handle highlighting the last used search pattern.
                        (let [#_match_C shl (assoc @search_hl :startcol MAXCOL :endcol MAXCOL :attr_cur 0)
                              #_int v (BDIFF @a's, @a'line)
                              [win shl] (next-search-hl? win, shl, lnum, v)
                              ;; Need to get the line again, a multi-line regexp may have made it invalid.
                              _ (reset! a'line (ml-get lnum)) _ (reset! a's (.plus @a'line v))
                              shl (when' (and (non-zero? (:lnum shl)) (<= (:lnum shl) lnum)) => shl
                                    (let [startpos' (... (:m_startpos (:matcher shl)) 0) endpos' (... (:m_endpos (:matcher shl)) 0)
                                          shl (assoc shl :startcol (if (== (:lnum shl) lnum) (:col startpos') 0))
                                          shl (assoc shl :endcol (if (== lnum (- (+ (:lnum shl) (:lnum endpos')) (:lnum startpos'))) (:col endpos') MAXCOL))
                                          ;; Highlight one character for an empty match.
                                          shl (when' (== (:startcol shl) (:endcol shl)) => shl
                                                (if (non-eos? @a'line (:endcol shl))
                                                    (update shl :endcol #(+ % (us-ptr2len-cc @a'line, %)))
                                                    (update shl :endcol inc)
                                                ))
                                          shl (when' (< (:startcol shl) v) => shl ;; match at leftcol
                                                (let [shl (assoc shl :attr_cur (:attr shl))]
                                                    (reset! a'search_attr (:attr shl))
                                                    shl)
                                            )]
                                        (reset! a'area_highlighting true)
                                        shl)
                                )]
                            (reset! search_hl shl)
                            win)

                      a'over_eol (atom (boolean false))
                      a'vcol_sbr (atom (int -1))                    ;; virtual column after 'showbreak'
                      a'vcol_prev (atom (int -1))                   ;; "vcol" of previous character
                      a'line_attr (atom (int 0))                    ;; attribute for the whole line
                      a'char_attr (atom (int 0))                    ;; attributes for next character
                      a'attr_pri (atom (boolean false))             ;; "char_attr" has priority
                      a'area_attr (atom (int 0))                    ;; attributes desired by highlighting
                      #_Bytes s_extra (Bytes. 18)                   ;; "%ld" and 'fdc' must fit in here
                      a'n_extra (atom (int 0))                      ;; number of extra chars
                      a'p_extra (atom (#_Bytes object nil))         ;; string of extra chars, plus NUL
                      a'c_extra (atom (int NUL))                    ;; extra chars, all the same
                      a'extra_attr (atom (int 0))                   ;; attributes when "n_extra" != 0
                      a'saved_n_extra (atom (int 0))                ;; saved "extra" items for when "draw_state" becomes WL_LINE (again)
                      a'saved_p_extra (atom (#_Bytes object nil))
                      a'saved_c_extra (atom (int NUL))
                      a'saved_char_attr (atom (int 0))
                      a'n_attr2 (atom (int 0))                      ;; chars with special attr
                      a'saved_attr2 (atom (int 0))                  ;; "char_attr" saved for "n_attr2"
                      a'eol_hl_off (atom (int 0))                   ;; 1 if highlighted char after EOL
                      a'multi_attr (atom (int 0))                   ;; attributes desired by multi-byte
                      #_int* u8cc (int-array MAX_MCO)               ;; composing UTF-8 chars
                      a'did_line_attr (atom (int 0))
                      a'col (atom (int 0))                          ;; visual column on screen
                      a'off (atom (int (BDIFF @current_ScreenLine, @screenLines))) ;; offset in screenLines/screenAttrs
                      a'draw_state (atom (int WL_START))]           ;; what to draw next

                    ;; Cursor line highlighting for 'cursorline' in the current window.
                    ;; Not when Visual mode is active, because it's not clear what is selected then.
                    (when (and wo_cul (== lnum (:lnum (:w_cursor win))) (not (and (:w_focused win) @VIsual_active)))
                        (reset! a'line_attr (hl-attr HLF_CUL))
                        (reset! a'area_highlighting true))

                    ;; Repeat for the whole displayed line.
                    (loop [win win]

                        ;; Skip this quickly when working on the text.
                        (when (!= @a'draw_state WL_LINE)
                            (when (and (== @a'draw_state (dec WL_CMDLINE)) (zero? @a'n_extra))
                                (reset! a'draw_state WL_CMDLINE)
                                (when (and (non-zero? @cmdwin_type) (:w_focused win))
                                    ;; Draw the cmdline character.
                                    (reset! a'n_extra 1)
                                    (reset! a'c_extra @cmdwin_type)
                                    (reset! a'char_attr (hl-attr HLF_AT))
                                ))

                            (when (and (== @a'draw_state (dec WL_NR)) (zero? @a'n_extra))
                                (reset! a'draw_state WL_NR)
                                ;; Display the absolute or relative line number.
                                ;; After the first fill with blanks when the 'n' flag isn't in 'cpo'.
                                (when (and (or wo_nu wo_rnu) (or (== @a'row startrow) (nil? (vim-strbyte @p_cpo, CPO_NUMCOL))))
                                    (let [#_int wid (ร let [[win ?] (number-width? win)] ?)]
                                        ;; Draw the line number (empty space after wrapping).
                                        (if (== @a'row startrow)
                                            (let [#_Bytes fmt (u8 "%*ld ") #_Bytes -fmt (u8 "%-*ld ")
                                                  [#_long n fmt]
                                                    (if (and wo_nu (not wo_rnu))
                                                        [lnum fmt]                                          ;; 'number' + 'norelativenumber'
                                                        (let [n (Math/abs (get-cursor-rel-lnum win, lnum))] ;; 'relativenumber', don't use negative numbers
                                                            (if (and (zero? n) wo_nu wo_rnu)
                                                                [lnum -fmt]                                 ;; 'number' + 'relativenumber'
                                                                [n fmt]
                                                            ))
                                                    )]
                                                (ร .sprintf libC s_extra, fmt, wid, n)
                                                (when (< 0 (:w_skipcol win))
                                                    (loop-when-recur [s s_extra] (at? s (byte \space)) [(.plus s 1)]
                                                        (.be s 0, (byte \-))
                                                    ))
                                                (reset! a'p_extra s_extra)
                                                (reset! a'c_extra NUL)
                                            )
                                            (reset! a'c_extra (byte \space))
                                        )
                                        (reset! a'n_extra (inc wid))
                                        ;; When 'cursorline' is set, highlight the line number of the current line differently.
                                        (reset! a'char_attr (if (and (or wo_cul wo_rnu) (== lnum (:lnum (:w_cursor win)))) (hl-attr HLF_CLN) (hl-attr HLF_N)))
                                    )
                                ))

                            (cond (and (:w_p_brisbr win) (== @a'draw_state (dec WL_BRI)) (zero? @a'n_extra) (non-eos? @p_sbr))
                            (do
                                ;; draw indent after 'showbreak' value
                                (reset! a'draw_state WL_BRI)
                            )
                            (and (:w_p_brisbr win) (== @a'draw_state WL_SBR) (zero? @a'n_extra))
                            (do
                                ;; after the 'showbreak', draw the 'breakindent'
                                (reset! a'draw_state (dec WL_BRI))
                            ))

                            ;; draw 'breakindent': indent wrapped text accordingly
                            (when (and (== @a'draw_state (dec WL_BRI)) (zero? @a'n_extra))
                                (reset! a'draw_state WL_BRI)
                                (when (and wo_bri (zero? @a'n_extra) (!= @a'row startrow))
                                    (reset! a'char_attr 0) ;; was: (hl-attr HLF_AT)
                                    (reset! a'p_extra nil)
                                    (reset! a'c_extra (byte \space))
                                    (reset! a'n_extra (get-breakindent win, (ml-get lnum)))
                                    ;; Correct end of highlighted area for 'breakindent',
                                    ;; required when 'linebreak' is also set.
                                    (when (== @a'tocol @a'vcol)
                                        (swap! a'tocol + @a'n_extra))
                                ))

                            (when (and (== @a'draw_state (dec WL_SBR)) (zero? @a'n_extra))
                                (reset! a'draw_state WL_SBR)
                                (when (and (non-eos? @p_sbr) @a'need_showbreak)
                                    ;; Draw 'showbreak' at the start of each broken line.
                                    (reset! a'p_extra @p_sbr)
                                    (reset! a'c_extra NUL)
                                    (reset! a'n_extra (STRLEN @p_sbr))
                                    (reset! a'char_attr (hl-attr HLF_AT))
                                    (reset! a'need_showbreak false)
                                    (reset! a'vcol_sbr (+ @a'vcol (us-charlen @p_sbr)))
                                    ;; Correct end of highlighted area for 'showbreak',
                                    ;; required when 'linebreak' is also set.
                                    (when (== @a'tocol @a'vcol)
                                        (swap! a'tocol + @a'n_extra))
                                    ;; combine 'showbreak' with 'cursorline'
                                    (reset! a'char_attr (if (and wo_cul (== lnum (:lnum (:w_cursor win)))) (hl-combine-attr @a'char_attr, (hl-attr HLF_CUL)) @a'char_attr))
                                ))

                            (when (and (== @a'draw_state (dec WL_LINE)) (zero? @a'n_extra))
                                (reset! a'draw_state WL_LINE)
                                (if (non-zero? @a'saved_n_extra)
                                    (do ;; Continue item from end of wrapped line.
                                        (reset! a'n_extra @a'saved_n_extra)
                                        (reset! a'c_extra @a'saved_c_extra)
                                        (reset! a'p_extra @a'saved_p_extra)
                                        (reset! a'char_attr @a'saved_char_attr))
                                    (reset! a'char_attr 0)
                                ))
                        )

                        (let [win (when' (and (== @a'draw_state WL_LINE) @a'area_highlighting) => win
                                    ;; handle Visual or match highlighting in this line
                                    (cond (or (== @a'vcol @a'fromcol) (and (== (inc @a'vcol) @a'fromcol) (== @a'n_extra 0) (< 1 (us-ptr2cells @a's)))
                                                                      (and (== @a'vcol_prev @a'fromcol_prev) (< @a'vcol_prev @a'vcol) (< @a'vcol @a'tocol)))
                                    (do
                                        (reset! a'area_attr @a'attr_highlighting)       ;; start highlighting
                                    )
                                    (and (!= @a'area_attr 0) (or (== @a'vcol @a'tocol) (and @a'noinvcur (== @a'vcol (:w_virtcol win)))))
                                    (do
                                        (reset! a'area_attr 0)                          ;; stop highlighting
                                    ))

                                    (let [win (when' (zero? @a'n_extra) => win
                                                ;; Check for start/end of search pattern match.
                                                ;; After end, check for start/end of next match.
                                                ;; When another match, have to check for start again.
                                                ;; Watch out for matching an empty string!
                                                (let [#_int v (BDIFF @a's, @a'line)
                                                      #_match_C shl @search_hl
                                                      [win shl]
                                                        (loop-when [win win shl shl] (some? (:m_pattern (:matcher shl))) => [win shl]
                                                            (cond (and (!= (:startcol shl) MAXCOL) (<= (:startcol shl) v) (< v (:endcol shl)))
                                                                (let [shl (update shl :endcol max (+ v (us-ptr2len-cc @a's)))]
                                                                    [win (assoc shl :attr_cur (:attr shl))])
                                                            (== v (:endcol shl))
                                                                (let [shl (assoc shl :attr_cur 0) [win shl] (next-search-hl? win, shl, lnum, v)]
                                                                    ;; Need to get the line again, a multi-line regexp may have made it invalid.
                                                                    (reset! a'line (ml-get lnum))
                                                                    (reset! a's (.plus @a'line v))
                                                                    (when' (== (:lnum shl) lnum) => [win shl]
                                                                        (let [startpos' (... (:m_startpos (:matcher shl)) 0) endpos' (... (:m_endpos (:matcher shl)) 0)
                                                                              shl (assoc shl :startcol (:col startpos'))
                                                                              shl (assoc shl :endcol (if (zero? (:lnum endpos')) (:col endpos') MAXCOL))
                                                                              ;; highlight empty match, try again after it
                                                                              shl (when' (== (:startcol shl) (:endcol shl)) => shl
                                                                                    (update shl :endcol #(+ % (us-ptr2len-cc @a'line, %)))
                                                                                )]
                                                                            ;; Loop to check if the match starts at the current position.
                                                                            (recur win shl))
                                                                    ))
                                                            :else
                                                                [win shl])
                                                        )]
                                                    (reset! search_hl shl)
                                                    (reset! a'search_attr (:attr_cur @search_hl))
                                                    win)
                                            )]
                                        ;; Decide which of the highlight attributes to use.
                                        (reset! a'attr_pri true)
                                        (cond (non-zero? @a'area_attr)
                                            (reset! a'char_attr (hl-combine-attr @a'line_attr, @a'area_attr))
                                        (non-zero? @a'search_attr)
                                            (reset! a'char_attr (hl-combine-attr @a'line_attr, @a'search_attr))
                                        ;; Use "line_attr" when not in the Visual or 'incsearch' area ("area_attr" may be 0 when "noinvcur" is set).
                                        (and (non-zero? @a'line_attr)
                                            (or (and (== @a'fromcol -10) (== @a'tocol MAXCOL)) (< @a'vcol @a'fromcol) (< @a'vcol_prev @a'fromcol_prev) (<= @a'tocol @a'vcol)))
                                            (reset! a'char_attr @a'line_attr)
                                        :else
                                        (do
                                            (reset! a'attr_pri false)
                                            (reset! a'char_attr 0)
                                        ))
                                        win
                                    ))

                              ;; Get the next character to put on the screen.

                              ;; "p_extra" points to the extra stuff that is inserted to represent special characters (non-printable stuff) and other things.
                              ;; When all characters are the same, "c_extra" is used.
                              ;; "p_extra" must end in a NUL to avoid us-ptr2len-cc() reading past "p_extra[n_extra]".

                              [#_int c #_int mb_c #_boolean mb_utf8] ;; decoded multi-byte character ;; screen char is UTF-8 char
                                (cond (< 0 @a'n_extra)
                                    (if (!= @a'c_extra NUL)
                                        (let [c @a'c_extra]
                                            (swap! a'n_extra dec)
                                            (if (< 1 (utf-char2len c))
                                                (do (aset u8cc 0 0) [0xc0 c true])
                                                [c c false]
                                            ))
                                        (let [#_int l (us-ptr2len-cc @a'p_extra)
                                              ;; If the UTF-8 character is more than one byte, decode it into "mb_c".
                                              [c mb_c mb_utf8 l]
                                                (cond
                                                    (< @a'n_extra l) (let [c (.at @a'p_extra 0)] [c c false 1])
                                                    (< 1 l)          [0xc0 (us-ptr2char-cc @a'p_extra, u8cc) true l]
                                                    :else            (let [c (.at @a'p_extra 0)] [c c false l]))
                                                l (if (zero? l) 1 l)] ;; at the NUL at end-of-line
                                            ;; If a double-width char doesn't fit, display a '>' in the last column.
                                            (if (and (<= (dec (:w_width win)) @a'col) (== (utf-char2cells mb_c) 2))
                                                (do (reset! a'multi_attr (hl-attr HLF_AT))
                                                    [(byte \>) (byte \>) false])
                                                (do (swap! a'n_extra - l)
                                                    (swap! a'p_extra plus l)
                                                    [c mb_c mb_utf8]
                                                ))
                                        ))
                                :else ;; Get a character from the line itself.
                                    (let [#_int l (us-ptr2len-cc @a's)
                                          ;; If the UTF-8 character is more than one byte, decode it into "mb_c".
                                          [c mb_c mb_utf8]
                                            (if (< 1 l)
                                                (let [c (.at @a's 0) mb_c (us-ptr2char-cc @a's, u8cc)
                                                      ;; Overlong encoded ASCII or ASCII with composing char is displayed normally, except a NUL.
                                                      c (if (< mb_c 0x80) mb_c c)
                                                      ;; At start of the line we can have a composing char.  Draw it as a space with a composing char.
                                                      mb_c (if (utf-iscomposing mb_c)
                                                            (loop-when-recur [i (dec @screen_mco)] (< 0 i) [(dec i)] => (do (aset u8cc 0 mb_c) (byte \space))
                                                                (aset u8cc i (aget u8cc (dec i))))
                                                            mb_c
                                                        )]
                                                    [c mb_c true])
                                                (let [c (.at @a's 0)] [c c false]))
                                          [c mb_c mb_utf8]
                                            (if (or (and (== l 1) (<= 0x80 c)) (and (<= 1 l) (zero? mb_c)) (and (< 1 l) (not (vim-isprintc mb_c))))
                                                ;; Illegal UTF-8 byte: display as <xx>.  Non-BMP character: display as ? or fullwidth ?.
                                                (let [_ (transchar-hex s_extra, mb_c) s s_extra c (.at s 0)
                                                      [mb_c s] (let [__ (atom (#_Bytes object s))] [(us-ptr2char-adv __, true) @__])]
                                                    (reset! a'n_extra (STRLEN s))
                                                    (reset! a'p_extra s)
                                                    (reset! a'c_extra NUL)
                                                    (when (and (zero? @a'area_attr) (zero? @a'search_attr))
                                                        (reset! a'n_attr2 (inc @a'n_extra))
                                                        (reset! a'extra_attr (hl-attr HLF_8))
                                                        (reset! a'saved_attr2 @a'char_attr)) ;; save current attr
                                                    [c mb_c (<= 0x80 c)])
                                                [c mb_c mb_utf8])
                                          l (if (zero? l) 1 l) ;; at the NUL at end-of-line
                                          ;; If a double-width char doesn't fit, display a '>' in the last column.
                                          [c mb_c mb_utf8 l]
                                            (if (and (<= (dec (:w_width win)) @a'col) (== (utf-char2cells mb_c) 2))
                                                ;; Put pointer back so the character will be displayed at the start of the next line.
                                                (do (swap! a's minus 1)
                                                    (reset! a'multi_attr (hl-attr HLF_AT))
                                                    [(byte \>) (byte \>) false 1])
                                                (do (when (non-eos? @a's)
                                                        (swap! a's plus (dec l)))
                                                    [c mb_c mb_utf8 l]
                                                ))
                                          _ (swap! a's plus 1)
                                          ;; If a double-width char doesn't fit at the left side, display a '<' in the first column.
                                          ;; Don't do this for unprintable characters.
                                          [c mb_c mb_utf8]
                                            (if (and (< 0 @a'n_skip) (< 1 l) (zero? @a'n_extra))
                                                (do (reset! a'n_extra 1)
                                                    (reset! a'c_extra MB_FILLER_CHAR)
                                                    (when (and (zero? @a'area_attr) (zero? @a'search_attr))
                                                        (reset! a'n_attr2 (inc @a'n_extra))
                                                        (reset! a'extra_attr (hl-attr HLF_AT))
                                                        (reset! a'saved_attr2 @a'char_attr)) ;; save current attr
                                                    [(byte \space) (byte \space) false])
                                                [c mb_c mb_utf8])
                                          ;; Found last space before word: check for line break.
                                          c (if (and wo_lbr (... @breakat_flags (char_u (byte c))) (not (... @breakat_flags (char_u (.at @a's 0)))))
                                                (let [#_int i (us-head-off @a'line, (.minus @a's 1)) #_Bytes p (.minus @a's (inc i)) ts @(:b_p_ts @curbuf)]
                                                    ;; TODO: is passing 'p' for start of the line OK?
                                                    (reset! a'n_extra (dec (win-lbr-chartabsize win, @a'line, p, @a'vcol, nil)))
                                                    (reset! a'n_extra (if (and (== c TAB) (< (:w_width win) (+ @a'n_extra @a'col))) (- ts (% @a'vcol ts) 1) @a'n_extra))
                                                    (reset! a'c_extra (if (< 0 i) MB_FILLER_CHAR (byte \space)))
                                                    (if (vim-iswhite c)
                                                        (byte \space)
                                                        c
                                                    ))
                                                c
                                            )]

                                        ;; Handling of non-printable characters.
                                        (cond (flag? (... @chartab (& c 0xff)) CT_PRINT_CHAR)
                                            [c mb_c mb_utf8]

                                        (== c TAB)
                                            (let [#_int vcol' (if (and (non-eos? @p_sbr) (== @a'vcol @a'vcol_sbr) wo_wrap) (- @a'vcol (us-charlen @p_sbr)) @a'vcol)
                                                  ts @(:b_p_ts @curbuf)]
                                                ;; tab amount depends on current column
                                                (reset! a'n_extra (- ts (% vcol' ts) 1))
                                                (reset! a'c_extra (byte \space))
                                            [(byte \space) mb_c false]) ;; don't draw as UTF-8

                                        (!= c NUL)
                                            (do (reset! a'p_extra (transchar c))
                                                (reset! a'c_extra NUL)
                                                (let [c (if wo_lbr
                                                            (do (reset! a'n_extra (if (zero? @a'n_extra) (dec (mb-byte2cells (byte c))) @a'n_extra))
                                                                (let [s @a'p_extra c (.at s 0) n @a'n_extra p (Bytes. (inc n))]
                                                                    (BFILL p, 0, (byte \space), n)
                                                                    (STRNCPY p, (.plus s 1), (dec (STRLEN s)))
                                                                    (reset! a'p_extra (eos! p n))
                                                                    c
                                                                ))
                                                            (do (reset! a'n_extra (dec (mb-byte2cells (byte c))))
                                                                (swap! a'p_extra plus 1)
                                                                (.at @a'p_extra -1))
                                                        )]
                                                    (when (not @a'attr_pri)
                                                        (reset! a'n_attr2 (inc @a'n_extra))
                                                        (reset! a'extra_attr (hl-attr HLF_8))
                                                        (reset! a'saved_attr2 @a'char_attr)) ;; save current attr
                                                    [c mb_c false] ;; don't draw as UTF-8
                                                ))

                                        :else ;; (== c NUL)
                                            (cond (and (or (<= 0 @a'fromcol) (<= 0 @a'fromcol_prev)) (< @a'vcol @a'tocol) (!= @VIsual_mode Ctrl_V) (< @a'col (:w_width win))
                                                       (not (and @a'noinvcur (== lnum (:lnum (:w_cursor win))) (== @a'vcol (:w_virtcol win)))) (not @a'over_eol))
                                                (do (when (zero? @a'line_attr)
                                                        ;; In virtualedit, visual selections may extend beyond end of line.
                                                        (if (and @a'area_highlighting (virtual-active) (!= @a'tocol MAXCOL) (< @a'vcol @a'tocol))
                                                            (reset! a'n_extra 0)
                                                            (do (reset! a'p_extra (u8 ""))
                                                                (reset! a'n_extra 1)
                                                                (reset! a'c_extra NUL))
                                                        ))
                                                    (reset! a'over_eol true)
                                                    (swap! a's minus 1) ;; put it back at the NUL
                                                    (when (not @a'attr_pri)
                                                        (reset! a'extra_attr (hl-attr HLF_AT))
                                                        (reset! a'n_attr2 1))
                                                [(byte \space) (byte \space) false]) ;; don't draw as UTF-8

                                            (and @VIsual_active (any == @VIsual_mode Ctrl_V (byte \v)) (virtual-active)
                                                                (!= @a'tocol MAXCOL) (< @a'vcol @a'tocol) (< @a'col (:w_width win)))
                                                (do (swap! a's minus 1) ;; put it back at the NUL
                                                    [(byte \space) mb_c mb_utf8])

                                            (and (non-zero? @a'line_attr) (< @a'col (:w_width win)))
                                                ;; Highlight until the right side of the window.
                                                (do (swap! a's minus 1) ;; put it back at the NUL
                                                    ;; Remember we do the char for line highlighting.
                                                    (swap! a'did_line_attr inc)
                                                    ;; Don't do search HL for the rest of the line.
                                                    (reset! a'char_attr (if (and (non-zero? @a'line_attr) (== @a'char_attr @a'search_attr) (< 0 @a'col)) @a'line_attr @a'char_attr))
                                                [(byte \space) mb_c mb_utf8])

                                            :else
                                                [c mb_c mb_utf8])
                                        ))
                                )]

                            ;; Don't override visual selection highlighting.
                            (reset! a'char_attr (if (and (< 0 @a'n_attr2) (== @a'draw_state WL_LINE) (not @a'attr_pri)) @a'extra_attr @a'char_attr))

                            ;; At end of the text line or just after the last character.
                            (when (or (== c NUL) (== @a'did_line_attr 1))
                                (let [#_long prevcol (- (BDIFF @a's, @a'line) (if (== c NUL) 1 0))
                                      ;; we're not really at that column when skipping some text
                                      prevcol (if (< prevcol (if wo_wrap (:w_skipcol win) (:w_leftcol win))) (inc prevcol) prevcol)]
                                    ;; Invert at least one char, used for Visual and empty line or highlight match at end of line.
                                    ;; If it's beyond the last char on the screen, just overwrite that one (tricky!)
                                    (when (and (not @a'over_eol)
                                               (or (and (== c NUL) (!= @a'area_attr 0) (== @a'vcol @a'fromcol)
                                                        (or (!= @VIsual_mode Ctrl_V) (== lnum (:lnum @VIsual_cursor)) (== lnum (:lnum (:w_cursor win)))))
                                                   (and (== prevcol (:startcol @search_hl)) (<= @a'did_line_attr 1))))
                                        (let [#_int n (if (<= (:w_width win) @a'col) -1 0)]
                                            (if (non-zero? n)
                                                (do ;; At the window boundary, highlight the last character instead (better than nothing).
                                                    (swap! a'off + n)
                                                    (swap! a'col + n))
                                                (do ;; Add a blank character to highlight.
                                                    (.be @screenLines @a'off, (byte \space))
                                                    (aset @screenLinesUC @a'off 0)
                                                ))
                                            (when (zero? @a'area_attr)
                                                (reset! a'char_attr (:attr @search_hl)))
                                            (aset @screenAttrs @a'off @a'char_attr)
                                            (swap! a'col inc)
                                            (swap! a'off inc)
                                            (swap! a'vcol inc)
                                            (reset! a'eol_hl_off 1)
                                        ))
                                ))

                            ;; At end of the text line.
                            (cond (== c NUL)
                                (do (when (and (< 0 @a'eol_hl_off) (== (- @a'vcol @a'eol_hl_off) (:w_virtcol win)) (== lnum (:lnum (:w_cursor win))))
                                        ;; highlight last char after line
                                        (swap! a'col dec)
                                        (swap! a'off dec)
                                        (swap! a'vcol dec))
                                    ;; Highlight 'cursorcolumn' and 'colorcolumn' past end of the line.
                                    (let [#_int v (if wo_wrap (:w_skipcol win) (:w_leftcol win))]
                                        ;; check if line ends before left margin
                                        (reset! a'vcol (max (- (+ v @a'col) (win-col-off win)) @a'vcol))

                                        (reset! a'draw_color_col (and @a'draw_color_col (advance-color-col @a'vcol, color_cols, a'cci)))

                                        (when (or (and wo_cuc (<= (- @a'vcol @a'eol_hl_off) (:w_virtcol win))
                                                              (< (:w_virtcol win) (+ (* (:w_width win) (inc (- @a'row startrow))) v))
                                                              (!= lnum (:lnum (:w_cursor win))))
                                                  @a'draw_color_col)
                                            (let [#_int rightmost_vcol (if wo_cuc (:w_virtcol win) 0)
                                                  rightmost_vcol
                                                    (if @a'draw_color_col
                                                        ;; determine rightmost colorcolumn to possibly draw
                                                        (loop-when-recur [rightmost_vcol rightmost_vcol #_int i 0]
                                                                         (<= 0 (... color_cols (+ @a'cci i)))
                                                                         [(max (... color_cols (+ @a'cci i)) rightmost_vcol) (inc i)]
                                                                      => rightmost_vcol)
                                                        rightmost_vcol
                                                    )]
                                                (loop-when [] (< @a'col (:w_width win))
                                                    (.be @screenLines @a'off, (byte \space))
                                                    (aset @screenLinesUC @a'off 0)
                                                    (swap! a'col inc)
                                                    (reset! a'draw_color_col (and @a'draw_color_col (advance-color-col @a'vcol, color_cols, a'cci)))
                                                    (let [#_int attr
                                                            (cond
                                                                (and wo_cuc (== @a'vcol (:w_virtcol win)))                   (hl-attr HLF_CUC)
                                                                (and @a'draw_color_col (== @a'vcol (... color_cols @a'cci))) (hl-attr HLF_MC)
                                                                :else                                                        0
                                                            )]
                                                        (aset @screenAttrs @a'off attr)
                                                        (swap! a'off inc)
                                                        (when (< @a'vcol rightmost_vcol)
                                                            (swap! a'vcol inc)
                                                            (recur))
                                                    ))
                                            ))

                                        (screen-line @a'screen_row, (:w_wincol win), @a'col, (:w_width win), false)
                                        (swap! a'row inc)

                                        ;; Update "w_cline_height" if the cursor line was updated (saves a call to plines() later).
                                        (let [win (if (and (:w_focused win) (== lnum (:lnum (:w_cursor win))))
                                                    (-> win
                                                        (assoc :w_cline_row startrow, :w_cline_height (- @a'row startrow))
                                                        (update :w_valid | VALID_CHEIGHT VALID_CROW))
                                                    win
                                                )]

                                            #_BREAK [win @a'row]
                                        )
                                    )
                                )
                            :else
                                (do ;; advance to the next 'colorcolumn'
                                    (reset! a'draw_color_col (and @a'draw_color_col (advance-color-col @a'vcol, color_cols, a'cci)))
                                    ;; Highlight the cursor column if 'cursorcolumn' is set, but don't highlight the cursor position itself.
                                    ;; Also highlight the 'colorcolumn' if it is different than 'cursorcolumn'.
                                    (let [a'vcol_save_attr (atom (int -1))]
                                        (when (and (== @a'draw_state WL_LINE) (not @a'lnum_in_visual))
                                            (cond (and wo_cuc (== @a'vcol (:w_virtcol win)) (!= lnum (:lnum (:w_cursor win))))
                                            (do
                                                (reset! a'vcol_save_attr @a'char_attr)
                                                (swap! a'char_attr hl-combine-attr (hl-attr HLF_CUC))
                                            )
                                            (and @a'draw_color_col (== @a'vcol (... color_cols @a'cci)))
                                            (do
                                                (reset! a'vcol_save_attr @a'char_attr)
                                                (swap! a'char_attr hl-combine-attr (hl-attr HLF_MC))
                                            ))
                                        )
                                        ;; Store character to be displayed.
                                        ;; Skip characters that are left of the screen for 'nowrap'.
                                        (reset! a'vcol_prev @a'vcol)
                                        (if (or (< @a'draw_state WL_LINE) (< @a'n_skip 1))
                                            (do ;; Store the character.
                                                (.be @screenLines @a'off, c)
                                                (if mb_utf8
                                                    (do (aset @screenLinesUC @a'off mb_c)
                                                        (when (zero? (& c 0xff))
                                                            (.be @screenLines @a'off, 0x80)) ;; avoid storing zero
                                                        (loop-when [#_int i 0] (< i @screen_mco)
                                                            (aset (... @screenLinesC i) @a'off (aget u8cc i))
                                                            (recur-if (non-zero? (aget u8cc i)) [(inc i)])
                                                        ))
                                                    (aset @screenLinesUC @a'off 0))
                                                (if (non-zero? @a'multi_attr)
                                                    (do (aset @screenAttrs @a'off @a'multi_attr)
                                                        (reset! a'multi_attr 0))
                                                    (aset @screenAttrs @a'off @a'char_attr))
                                                (when (< 1 (utf-char2cells mb_c))
                                                    ;; Need to fill two screen columns.
                                                    (swap! a'off inc)
                                                    (swap! a'col inc)
                                                    ;; UTF-8: Put a 0 in the second screen char.
                                                    (eos! @screenLines @a'off)
                                                    (swap! a'vcol inc)
                                                    ;; When "tocol" is halfway a character, set it to the end
                                                    ;; of the character, otherwise highlighting won't stop.
                                                    (when (== @a'tocol @a'vcol)
                                                        (swap! a'tocol inc)
                                                    ))
                                                (swap! a'off inc)
                                                (swap! a'col inc)
                                            )
                                            (swap! a'n_skip dec)
                                        )

                                        ;; Advance "vcol" only after the 'number' or 'relativenumber' column.
                                        (reset! a'vcol (if (< WL_NR @a'draw_state) (inc @a'vcol) @a'vcol))

                                        (reset! a'char_attr (if (<= 0 @a'vcol_save_attr) @a'vcol_save_attr @a'char_attr))

                                        ;; restore attributes after last 'number' char
                                        (when (and (< 0 @a'n_attr2) (== @a'draw_state WL_LINE))
                                            (swap! a'n_attr2 dec)
                                            (when (zero? @a'n_attr2)
                                                (reset! a'char_attr @a'saved_attr2)
                                            ))

                                        ;; At end of screen line when there is more to come: display the line so far.
                                        ;; It is caught above when there is no more to display.

                                        (if (or (< @a'col (:w_width win)) (and (eos? @a's) (or (zero? @a'n_extra) (and (== @a'c_extra NUL) (eos? @a'p_extra)))))
                                            (recur win)

                                            (do (screen-line @a'screen_row, (:w_wincol win), @a'col, (:w_width win), false)
                                                (swap! a'row inc)
                                                (swap! a'screen_row inc)

                                                ;; When not wrapping and finished diff lines, or when displayed '$' and highlighting until last column, break here.
                                                (if (or (not wo_wrap) @a'over_eol)
                                                    #_BREAK [win @a'row]

                                                    ;; When the window is too narrow, draw all "@" lines.
                                                    (let [win (if (!= @a'draw_state WL_LINE)
                                                                (let [win (win-draw-end win, (byte \@), (byte \space), @a'row, (:w_height win), HLF_AT)]
                                                                    (draw-vsep-win win, @a'row)
                                                                    (reset! a'row endrow)
                                                                    win)
                                                                win
                                                            )]

                                                        ;; When line got too long for screen break here.
                                                        (if (== @a'row endrow)
                                                            (do (swap! a'row inc) #_BREAK [win @a'row])

                                                            (do (when (and (== @screen_cur_row (dec @a'screen_row)) (== (:w_width win) @Cols))
                                                                    ;; Remember that the line wraps, used for modeless copy.
                                                                    (aset @lineWraps (dec @a'screen_row) true)

                                                                    ;; Special trick to make copy/paste of wrapped lines work with xterm/screen:
                                                                    ;; write an extra character beyond the end of the line.
                                                                    ;; This will work with all terminal types (regardless of the xn,am settings).
                                                                    ;; Only do this if the cursor is on the current line (something has been written in it).
                                                                    ;; Don't do this for the GUI.
                                                                    ;; Don't do this for double-width characters.
                                                                    ;; Don't do this for a window not at the right screen border.

                                                                    (let-when [x (aget @lineOffset (dec @a'screen_row)) y (aget @lineOffset @a'screen_row)]
                                                                              (not (or (== (utf-off2cells y, (+ y @screenCols)) 2)
                                                                                       (== (utf-off2cells (+ x (- @Cols 2)), (+ y @screenCols)) 2)))
                                                                        (let [#_int eoff (+ x (dec @Cols))]
                                                                            ;; First make sure we are at the end of the screen line,
                                                                            ;; then output the same character again to let the terminal know about the wrap.
                                                                            ;; If the terminal doesn't auto-wrap, we overwrite the character.
                                                                            (when (!= @screen_cur_col (:w_width win))
                                                                                (screen-char eoff, (dec @a'screen_row), (dec @Cols)))
                                                                            ;; When there is a multi-byte character, just output a space to keep it simple.
                                                                            (if (< 1 (us-byte2len (.at @screenLines eoff), false))
                                                                                (out-char (byte \space))
                                                                                (out-char (.at @screenLines eoff)))
                                                                            ;; Force a redraw of the first char on the next line.
                                                                            (aset @screenAttrs y -1)
                                                                            (screen-start)) ;; don't know where cursor is now
                                                                    ))

                                                                (reset! a'col 0)
                                                                (reset! a'off (BDIFF @current_ScreenLine, @screenLines))

                                                                ;; Reset the drawing state for the start of a wrapped line.
                                                                (reset! a'draw_state WL_START)
                                                                (reset! a'saved_n_extra @a'n_extra)
                                                                (reset! a'saved_p_extra @a'p_extra)
                                                                (reset! a'saved_c_extra @a'c_extra)
                                                                (reset! a'saved_char_attr @a'char_attr)
                                                                (reset! a'n_extra 0)
                                                                (reset! a'need_showbreak true)

                                                                (recur win)
                                                            ))
                                                    ))
                                            ))
                                    ))
                            ))
                    ))
            ))
    ))

;; Return if the composing characters at "off_from" and "off_to" differ.
;; Only to be used when screenLinesUC[off_from] != 0.

(defn- #_boolean comp-char-differs [#_int off_from, #_int off_to]
    (loop-when [#_int i 0] (< i @screen_mco) => false
        (cond (!= (aget (... @screenLinesC i) off_from) (aget (... @screenLinesC i) off_to)) true (zero? (aget (... @screenLinesC i) off_from)) false :else (recur (inc i)))
    ))

;; Check whether the given character needs redrawing:
;; - the (first byte of the) character is different
;; - the attributes are different
;; - the character is multi-byte and the next byte is different
;; - the character is two cells wide and the second cell differs.

(defn- #_boolean char-needs-redraw [#_int from, #_int to, #_int cols]
    (and (< 0 cols)
         (or (!= (.at @screenLines from) (.at @screenLines to))
             (!= (aget @screenAttrs from) (aget @screenAttrs to))
             (!= (aget @screenLinesUC from) (aget @screenLinesUC to))
             (and (!= (aget @screenLinesUC from) 0)
                  (comp-char-differs from, to))
             (and (< 1 (utf-off2cells from, (+ from cols)))
                  (!= (.at @screenLines (inc from)) (.at @screenLines (inc to)))))))

;; Move one "cooked" screen line to the screen, but only the characters that
;; have actually changed.  Handle insert/delete character.
;; "coloff" gives the first column on the screen for this line.
;; "endcol" gives the columns where valid characters are.
;; "clear_width" is the width of the window.
;;    It's > 0 if the rest of the line needs to be cleared, negative otherwise.
;; "rlflag" is true in a rightleft window:
;;    When true and "clear_width" > 0, clear columns 0 to "endcol".
;;    When false and "clear_width" > 0, clear columns "endcol" to "clear_width".

(defn- #_void screen-line [#_int row, #_int coloff, #_int endcol, #_int clear_width, #_boolean rlflag]
    (let [row (min row (dec @Rows)) endcol (min endcol @Cols) ;; check for illegal row and col, just in case
          #_int off_from (BDIFF @current_ScreenLine, @screenLines)
          #_int off_to (+ (aget @lineOffset row) coloff)
          #_int max_off_from (+ off_from @screenCols)
          #_int max_off_to (+ (aget @lineOffset row) @screenCols)
          #_int col 0
          [col off_to off_from endcol]
            (if rlflag ;; clear rest first, because it's left of the text
                (let [[col off_to]
                        (if (< 0 clear_width)
                            (let [[col off_to]
                                    (loop-when-recur [col col off_to off_to]
                                                     (and (<= col endcol) (at? @screenLines off_to (byte \space)) (== (aget @screenAttrs off_to) 0)
                                                                                                                  (== (aget @screenLinesUC off_to) 0))
                                                     [(inc col) (inc off_to)]
                                                  => [col off_to])]
                                (when (<= col endcol)
                                    (screen-fill row, (inc row), (+ col coloff), (+ endcol coloff 1), (byte \space), (byte \space), 0))
                                [col off_to])
                            [col off_to])
                      col (inc endcol)]
                    [col (+ (aget @lineOffset row) col coloff) (+ off_from col) (Math/abs clear_width)])
                [col off_to off_from endcol])
          #_boolean redraw_next (char-needs-redraw off_from, off_to, (- endcol col))
          [#_boolean clear_next off_to col]
            (loop-when [redraw_next redraw_next clear_next false off_to off_to off_from off_from col col] (< col endcol) => [clear_next off_to col]
                (let [#_int cells (if (< (inc col) endcol) (utf-off2cells off_from, max_off_from) 1) ;; 1: normal char; 2: occupies two display cells
                      #_boolean redraw_this redraw_next
                      redraw_next (char-needs-redraw (+ off_from cells), (+ off_to cells), (- endcol col cells)) ;; redraw_this for next character
                      [clear_next redraw_next]
                        (if redraw_this
                            ;; When writing a single-width character over a double-width character and at the end of the redrawn text,
                            ;; need to clear out the right halve of the old character.
                            ;; Also required when writing the right halve of a double-width char over the left halve of an existing one.
                            (let [clear_next (or (and (== (+ col cells) endcol)
                                                      (or (and (== cells 1) (< 1 (utf-off2cells off_to, max_off_to)))
                                                          (and (== cells 2) (== (utf-off2cells off_to, max_off_to) 1) (< 1 (utf-off2cells (inc off_to), max_off_to))))) clear_next)]
                                (.be @screenLines off_to, (.at @screenLines off_from))
                                (aset @screenLinesUC off_to (aget @screenLinesUC off_from))
                                (when (non-zero? (aget @screenLinesUC off_from))
                                    (dotimes [#_int i @screen_mco]
                                        (aset (... @screenLinesC i) off_to (aget (... @screenLinesC i) off_from))
                                    ))
                                (when (== cells 2)
                                    (.be @screenLines (inc off_to), (.at @screenLines (inc off_from))))
                                ;; The bold trick makes a single column of pixels appear in the next character.
                                ;; When a bold character is removed, the next character should be redrawn too.
                                ;; This happens for our own GUI and for some xterms.
                                (let [redraw_next
                                        (if @term_is_xterm
                                            (let [#_int hl (aget @screenAttrs off_to) hl (if (< HL_ALL hl) 0 hl)]
                                                (or (flag? hl HL_BOLD) redraw_next))
                                            redraw_next
                                        )]
                                    (aset @screenAttrs off_to (aget @screenAttrs off_from))
                                    ;; For simplicity, set the attributes of second half
                                    ;; of a double-wide character equal to the first half.
                                    (when (== cells 2)
                                        (aset @screenAttrs (inc off_to) (aget @screenAttrs off_from)))
                                    (screen-char off_to, row, (+ col coloff))
                                    [clear_next redraw_next]
                                ))
                            [clear_next redraw_next]
                        )]
                    (recur redraw_next clear_next (+ off_to cells) (+ off_from cells) (+ col cells)))
            )]
        (when clear_next
            ;; Clear the second half of a double-wide character of which
            ;; the left half was overwritten with a single-wide character.
            (.be @screenLines off_to, (byte \space))
            (aset @screenLinesUC off_to 0)
            (screen-char off_to, row, (+ col coloff)))
        (let [[off_to col]
                (if (and (< 0 clear_width) (not rlflag))
                    (let [[off_to col] ;; blank out the rest of the line
                            (loop-when-recur [off_to off_to col col]
                                             (and (< col clear_width) (at? @screenLines off_to (byte \space)) (== (aget @screenAttrs off_to) 0) (== (aget @screenLinesUC off_to) 0))
                                             [(inc off_to) (inc col)]
                                          => [off_to col])]
                        (if (< col clear_width)
                            (do (screen-fill row, (inc row), (+ col coloff), (+ clear_width coloff), (byte \space), (byte \space), 0)
                                [(+ off_to (- clear_width col)) clear_width])
                            [off_to col]
                        ))
                    [off_to col]
                )]
            (when (< 0 clear_width)
                ;; For a window that's left of another, draw the separator char.
                (if (< (+ col coloff) @Cols)
                    (let [a'hl (atom (int)) #_int c (fillchar-vsep a'hl)]
                        (when (or (not-at? @screenLines off_to c) (!= (aget @screenLinesUC off_to) (if (<= 0x80 c) c 0)) (!= (aget @screenAttrs off_to) @a'hl))
                            (.be @screenLines off_to, c)
                            (aset @screenAttrs off_to @a'hl)
                            (if (<= 0x80 c)
                                (do (aset @screenLinesUC off_to c)
                                    (aset (... @screenLinesC 0) off_to 0))
                                (aset @screenLinesUC off_to 0))
                            (screen-char off_to, row, (+ col coloff))
                        ))
                    (aset @lineWraps row false))
            )))
    nil)

;; Mark all status lines for redraw.

(defn- #_void status-redraw-all []
    (loop-when-recur [#_window_C w @firstwin] (some? w) [(:w_next w)]
        (when (non-zero? (:w_status_height w))
            ((ร w =) (assoc w :w_redr_status true))
            ((ร w =) (redraw-later w, VALID))
        ))
    nil)

;; Redraw all status lines that need to be redrawn.

(defn- #_void redraw-statuslines []
    (loop-when-recur [#_window_C w @firstwin] (some? w) [(:w_next w)]
        (when (:w_redr_status w)
            ((ร w =) (win-redr-status w))
        ))
    nil)

;; Draw the verticap separator right of window "win" starting with line "row".

(defn- #_void draw-vsep-win [#_window_C win, #_int row]
    (when (non-zero? (:w_vsep_width win))
        ;; draw the vertical separator right of this window
        (let [a'hl (atom (int)) #_int fc (fillchar-vsep a'hl)
              wr (:w_winrow win) wc (:w_wincol win) wh (:w_height win) ww (:w_width win)]
            (screen-fill (+ wr row), (+ wr wh), (+ wc ww), (+ wc ww 1), fc, (byte \space), @a'hl)
        ))
    nil)

(atom! boolean _3_busy)

;; Redraw the status line of window "win".
;;
;; If inversion is possible, we use it; else '=' characters are used.

(defn- #_window_C win-redr-status [#_window_C win]
    ;; It's possible to get here recursively when 'statusline' (indirectly) invokes ":redrawstatus".  Simply ignore the call then.
    (if @_3_busy
        win
        (let [_ (reset! _3_busy true)
              win (assoc win :w_redr_status false)
              win (cond (zero? (:w_status_height win))      ;; no status line, must be the last window
                    (do (reset! redraw_cmdline true) win)
                (not (redrawing))                           ;; don't redraw right now, do it later
                    (assoc win :w_redr_status true)
                :else
                    (let [#_Bytes s (Bytes. MAXPATHL)]
                        (vim-strncpy s, (u8 "[No Name]"), (dec MAXPATHL))
                        (trans-characters s, MAXPATHL)
                        (when @(:b_changed @curbuf)
                            (let [n (STRLEN s)] (-> s (.be n, (byte \space)) (.plus (inc n)) (STRCPY (u8 "[+]")))))
                        (let [m (max (/ (inc (:w_width win)) 2) (- @ru_col (- @Cols (:w_width win))))
                              [s n]
                                (if (< 1 m)                 ;; find first character that will fit
                                    (let [[n i] (loop-when-recur [n (us-string2cells s, -1) i 0]
                                                                 (and (<= (dec m) n) (non-eos? s i))
                                                                 [(- n (us-ptr2cells s, i)) (+ i (us-ptr2len-cc s, i))]
                                                              => [n i]
                                                )]
                                        (if (< 0 i) [(-> s (.plus (dec i)) (.be 0, (byte \<))) (inc n)] [s n]))
                                    [(u8 "<") 1]            ;; no room for file name!
                                )]
                            (let [row (+ (:w_winrow win) (:w_height win)) col (:w_wincol win)
                                  a'attr (atom (int)) #_int fillchar (fillchar-status a'attr, (:w_focused win))]
                                (screen-puts s, row, col, @a'attr)
                                (screen-fill row, (inc row), (+ col n), (+ col m), fillchar, fillchar, @a'attr))
                            (win-redr-ruler win, true)
                        ))
                )]
            ;; May need to draw the character below the vertical separator.
            (when (and (non-zero? (:w_vsep_width win)) (non-zero? (:w_status_height win)) (redrawing))
                (let [a'attr (atom (int)) #_int fillchar (if (stl-connected win) (fillchar-status a'attr, (:w_focused win)) (fillchar-vsep a'attr))]
                    (screen-putchar fillchar, (+ (:w_winrow win) (:w_height win)), (+ (:w_wincol win) (:w_width win)), @a'attr)
                ))
            (reset! _3_busy false)
            win)
    ))

;; Return true if the status line of window "win" is connected to the status
;; line of the window right of it.  If not, then it's a vertical separator.
;; Only call if (win.w_vsep_width != 0).

(defn- #_boolean stl-connected [#_window_C win]
    (loop-when [#_frame_C fr (:w_frame win)] (some? (:fr_parent fr)) => false
        (recur-if (nil? (:fr_next fr)) [(:fr_parent fr)] => (!= (:fr_layout (:fr_parent fr)) FR_COL))
    ))

;; Output a single character directly to the screen and update "screenLines".

(defn- #_void screen-putchar [#_int c, #_int row, #_int col, #_int attr]
    (let [#_Bytes buf (Bytes. (inc MB_MAXBYTES))]
        (eos! buf (utf-char2bytes c, buf))
        (screen-puts buf, row, col, attr))
    nil)

;; Get a single character directly from "screenLines" into "bytes[]".
;; Also return its attribute in "*a'attr".

(defn- #_void screen-getbytes [#_int row, #_int col, #_Bytes bytes, #_int' a'attr]
    (when (and (some? @screenLines) (< row @screenRows) (< col @screenCols))
        (let [#_int off (+ (aget @lineOffset row) col)]
            (reset! a'attr (aget @screenAttrs off))
            (-> bytes (.be 0, (.at @screenLines off)) (eos! 1))
            (when (non-zero? (aget @screenLinesUC off))
                (eos! bytes (utfc-char2bytes off, bytes)))
        ))
    nil)

;; Return true if composing characters for screen offset "off" differs from composing characters in "u8cc".
;; Only to be used when screenLinesUC[off] != 0.

(defn- #_boolean screen-comp-differs [#_int off, #_int* u8cc]
    (loop-when [#_int i 0] (< i @screen_mco) => false
        (cond (!= (aget (... @screenLinesC i) off) (aget u8cc i)) true (zero? (aget u8cc i)) false :else (recur (inc i)))
    ))

;; Put string "text" on the screen at position "row" and "col", with
;; attributes "attr", and update screenLines[] and screenAttrs[].
;; Note: only outputs within one row, message is truncated at screen boundary!
;; Note: if screenLines[], row and/or col is invalid, nothing is done.

(defn- #_void screen-puts [#_Bytes text, #_int row, #_int col, #_int attr]
    (screen-puts-len text, -1, row, col, attr)
    nil)

;; Like screen-puts(), but output "text[len]".  When "len" is -1 output up to a NUL.

(defn- #_void screen-puts-len [#_Bytes text, #_int textlen, #_int row, #_int col, #_int attr]
    (when (and (some? @screenLines) (< row @screenRows)) ;; safety check
        (let [#_int off (+ (aget @lineOffset row) col)
              ;; When drawing over the right halve of a double-wide char, clear out the left halve.
              ;; Only needed in a terminal.
              #_boolean force_next
                (if (and (< 0 col) (< col @screenCols) (!= (mb-fix-col col, row) col))
                    (do (.be @screenLines (dec off), (byte \space))
                        (aset @screenAttrs (dec off) 0)
                        (aset @screenLinesUC (dec off) 0)
                        (aset (... @screenLinesC 0) (dec off) 0)
                        ;; redraw the previous cell, make it empty
                        (screen-char (dec off), row, (dec col))
                        ;; force the cell at "col" to be redrawn
                        true)
                    false)
              #_int max_off (+ (aget @lineOffset row) @screenCols)
              #_int* u8cc (int-array MAX_MCO)
              [force_next off col]
                (loop-when [force_next force_next #_boolean clear_next false off off col col #_Bytes s text #_int n textlen]
                           (and (< col @screenCols) (or (< n 0) (< (BDIFF s, text) n)) (non-eos? s))
                        => [force_next off col]
                    (let [#_byte c (.at s 0) ;; check if this is the first byte of a multibyte
                          #_int blen (if (< 0 n) (us-ptr2len-cc-len s, (BDIFF (.plus text n), s)) (us-ptr2len-cc s))
                          #_int u8c (if (<= 0 n) (us-ptr2char-cc-len s, u8cc, (BDIFF (.plus text n), s)) (us-ptr2char-cc s, u8cc))
                          #_int cells (utf-char2cells u8c)
                          ;; Only 1 cell left, but character requires 2 cells:
                          ;; display a '>' in the last column to avoid wrapping.
                          [c cells] (if (< @screenCols (+ col cells)) [(byte \>) 1] [c cells])
                          #_boolean force_this force_next force_next false
                          #_boolean need_redraw (or (not-at? @screenLines off c)
                                                    (and (== cells 2) (not-at? @screenLines (inc off) 0))
                                                    (or (!= (aget @screenLinesUC off) (if (and (< (char_u c) 0x80) (zero? (aget u8cc 0))) 0 u8c))
                                                        (and (non-zero? (aget @screenLinesUC off)) (screen-comp-differs off, u8cc)))
                                                    (!= (aget @screenAttrs off) attr))
                          [force_next clear_next]
                            (if (or need_redraw force_this)
                                ;; The bold trick makes a single row of pixels appear in the next character.
                                ;; When a bold character is removed, the next character should be redrawn too.
                                ;; This happens for our own GUI and for some xterms.
                                (let [force_next
                                        (if (and need_redraw (not-at? @screenLines off (byte \space)) @term_is_xterm)
                                            (let [#_int x (aget @screenAttrs off) x (if (< HL_ALL x) 0 x)]
                                                (or (flag? x HL_BOLD) force_next))
                                            force_next)
                                      ;; When at the end of the text and overwriting a two-cell character with
                                      ;; a one-cell character, need to clear the next cell.  Also when overwriting
                                      ;; the left halve of a two-cell char with the right halve of a two-cell char.
                                      ;; Do this only once (utf-off2cells() may return 2 on the right halve).
                                      clear_next
                                        (cond clear_next
                                            false
                                        (and (if (< n 0) (eos? s blen) (BLE (.plus text n), (.plus s blen)))
                                             (or (and (== cells 1) (< 1 (utf-off2cells off, max_off)))
                                                 (and (== cells 2) (== (utf-off2cells off, max_off) 1) (< 1 (utf-off2cells (inc off), max_off)))))
                                            true
                                        :else
                                            clear_next
                                        )]
                                    (.be @screenLines off, c)
                                    (aset @screenAttrs off attr)
                                    (if (and (< (char_u c) 0x80) (zero? (aget u8cc 0)))
                                        (aset @screenLinesUC off 0)
                                        (do (aset @screenLinesUC off u8c)
                                            (loop-when [#_int i 0] (< i @screen_mco)
                                                (aset (... @screenLinesC i) off (aget u8cc i))
                                                (recur-if (non-zero? (aget u8cc i)) [(inc i)]))
                                        ))
                                    (when (== cells 2)
                                        (eos! @screenLines (inc off))
                                        (aset @screenAttrs (inc off) attr))
                                    (screen-char off, row, col)
                                    [force_next clear_next])
                                [force_next clear_next])
                          off (+ off cells) col (+ col cells) s (.plus s blen)
                          ;; This only happens at the end, display one space next.
                          [s n] (if clear_next [(u8 " ") -1] [s n])]
                        (recur force_next clear_next off col s n))
                )]
            ;; If we detected the next character needs to be redrawn,
            ;; but the text doesn't extend up to there, update the character here.
            (when (and force_next (< col @screenCols))
                (screen-char off, row, col))
        ))
    nil)

;; Prepare for 'hlsearch' highlighting.

(defn- #_window_C start-search-hl [#_window_C win]
    (when' (and @p_hls (not @no_hlsearch)) => win
        (let [[win ?] (last-search-matcher? win, (:matcher @search_hl))]
            ;; Set the time limit to 'redrawtime'.
            (swap! search_hl assoc :matcher ? :attr (hl-attr HLF_L) :nsec (profile-setlimit @p_rdt))
            win
        )
    ))

;; Clean up for 'hlsearch' highlighting.

(defn- #_void end-search-hl []
    (swap! search_hl assoc-in [:matcher :m_pattern] nil)
    nil)

;; Init for calling prepare-search-hl().

(defn- #_void init-search-hl []
    (swap! search_hl assoc :lnum 0 :first_lnum 0) ;; time limit is set at the toplevel, for all windows
    nil)

;; Advance to the match in window "win" line "lnum" or past it.

(defn- #_window_C prepare-search-hl [#_window_C win, #_long lnum]
    (let [#_match_C shl @search_hl
          [win shl]
            (when' (and (some? (:m_pattern (:matcher shl))) (zero? (:lnum shl)) (re-multiline (:m_pattern (:matcher shl)))) => [win shl]
                ;; When using a multi-line pattern, start searching at the top of the window.
                (let [shl (if (zero? (:first_lnum shl)) (assoc shl :first_lnum (:w_topline win)) shl)]
                    (loop-when [win win shl shl n 0] (and (< (:first_lnum shl) lnum) (some? (:m_pattern (:matcher shl)))) => [win shl]
                        (let [[win shl] (next-search-hl? win, shl, (:first_lnum shl), n)]
                            (if (zero? (:lnum shl))
                                (recur win (update shl :first_lnum inc) 0)
                                (let [start (... (:m_startpos (:matcher shl)) 0) end (... (:m_endpos (:matcher shl)) 0)]
                                    (recur win (assoc shl :first_lnum (- (+ (:lnum shl) (:lnum end)) (:lnum start))) (:col end)))
                            ))
                    ))
            )]
        (reset! search_hl shl)
        win
    ))

;; Search for a next 'hlsearch'.  Sets shl.lnum and shl.matcher contents.
;; Note: Assumes a previous match is always before "lnum", unless shl.lnum is zero.
;; Careful: Any pointers for buffer lines will become invalid.

(defn- #_[window_C match_C] next-search-hl? [#_window_C win, #_match_C shl, #_long lnum, #_int mincol]
    ;; mincol: minimal column for a match
    (let-when [[shl ?]
            (if (non-zero? (:lnum shl))
                ;; Check for three situations:
                ;; 1. If the "lnum" is below a previous match, start a new search.
                ;; 2. If the previous match includes "mincol", use it.
                ;; 3. Continue after the previous match.
                (let [start (... (:m_startpos (:matcher shl)) 0) end (... (:m_endpos (:matcher shl)) 0)
                      l (+ (:lnum shl) (- (:lnum end) (:lnum start)))]
                    (cond
                        (< l lnum)                            [(assoc shl :lnum 0) nil]
                        (or (< lnum l) (< mincol (:col end))) [shl :return]
                        :else                                 [shl nil]
                    ))
                [shl nil]
            )] (not ?) => [win shl]

        ;; Repeat searching for a match until one is found that includes "mincol" or none is found in this line.
        (reset! called_emsg false)
        ;; Stop searching after passing the time limit.
        (loop-when [win win shl shl] (not (profile-passed-limit (:nsec shl))) => [win (assoc shl :lnum 0)] ;; no match found in time
            ;; Three situations:
            ;; 1. No useful previous match: search from start of line.
            ;; 2. Not Vi compatible or empty match: continue at next character.
            ;;    Break the loop if this is beyond the end of the line.
            ;; 3. Vi compatible searching: continue at end of previous match.
            (let-when [[matchcol ?]
                    (let [start (... (:m_startpos (:matcher shl)) 0) end (... (:m_endpos (:matcher shl)) 0)]
                        (cond (zero? (:lnum shl))
                            [0 nil]
                        (or (nil? (vim-strbyte @p_cpo, CPO_SEARCH)) (and (zero? (:lnum end)) (<= (:col end) (:col start))))
                            (let [matchcol (:col start) s (.plus (ml-get lnum) matchcol)]
                                (if (eos? s)
                                    [(inc matchcol) :break]
                                    [(+ matchcol (us-ptr2len-cc s)) nil]
                                ))
                        :else
                            [(:col end) nil])
                    )] (not ?) => [win (assoc shl :lnum 0)]

                (let-when [shl (assoc shl :lnum lnum)
                      [win shl nof ?]
                        (when' (some? (:m_pattern (:matcher shl))) => [win shl 0 nil]
                            (let [[win _ nof] (vim-regexec? win, (:matcher shl), lnum, matchcol, (:nsec shl)) shl (assoc shl :matcher _)
                                  ? (when (or @called_emsg @got_int)
                                        ;; Error while handling regexp: stop using this regexp.
                                        (when (== shl @search_hl)
                                            (reset! no_hlsearch true))
                                        (reset! got_int false) ;; avoid the "Type :quit to exit Vim" message
                                        :break
                                    )]
                                [win shl nof ?])
                        )] (not ?) => [win (-> shl (assoc :lnum 0) (assoc-in [:matcher :m_pattern] nil))]

                    (let [start (... (:m_startpos (:matcher shl)) 0) end (... (:m_endpos (:matcher shl)) 0)]
                        (cond (zero? nof)
                            [win (assoc shl :lnum 0)] ;; no match found
                        (or (< 0 (:lnum start)) (<= mincol (:col start)) (< 1 nof) (< mincol (:col end)))
                            [win (update shl :lnum + (:lnum start))] ;; useful match found
                        :else
                            (recur win shl))
                    ))
            ))
    ))

(defn- #_void screen-start-highlight [#_int attr]
    (reset! screen_attr attr)
    (when @full_screen
        (let [attr (if (< HL_ALL attr) 0 attr)]
            (when (and (flag? attr HL_BOLD) (some? @T_MD))          ;; bold
                (out-str @T_MD))
            (when (and (flag? attr HL_STANDOUT) (some? @T_SO))      ;; standout
                (out-str @T_SO))
            (when (and (flag? attr (| HL_UNDERLINE HL_UNDERCURL)) (some? @T_US)) ;; underline or undercurl
                (out-str @T_US))
            (when (and (flag? attr HL_ITALIC) (some? @T_CZH))       ;; italic
                (out-str @T_CZH))
            (when (and (flag? attr HL_INVERSE) (some? @T_MR))       ;; inverse (reverse)
                (out-str @T_MR))
        ))
    nil)

(defn- #_void screen-stop-highlight []
    (when (non-zero? @screen_attr)
        (let [#_boolean me? (and (< HL_ALL @screen_attr) (let [me? false] (reset! screen_attr 0) me?))
              ;; Often all ending-codes are equal to T_ME.
              ;; Avoid outputting the same sequence several times.
              me? (if (flag? @screen_attr HL_STANDOUT)                   (or (zero? (STRCMP @T_SE, @T_ME))  (do (out-str @T_SE) me?))  me?)
              me? (if (flag? @screen_attr (| HL_UNDERLINE HL_UNDERCURL)) (or (zero? (STRCMP @T_UE, @T_ME))  (do (out-str @T_UE) me?))  me?)
              me? (if (flag? @screen_attr HL_ITALIC)                     (or (zero? (STRCMP @T_CZR, @T_ME)) (do (out-str @T_CZR) me?)) me?)]
            (when (or me? (flag? @screen_attr (| HL_BOLD HL_INVERSE)))
                (out-str @T_ME)
            ))
        (when (< 1 @t_colors) ;; set Normal cterm colors
            (when (non-zero? @cterm_normal_fg_color) (term-fg-color (dec @cterm_normal_fg_color)))
            (when (non-zero? @cterm_normal_bg_color) (term-bg-color (dec @cterm_normal_bg_color)))
            (when (non-zero? @cterm_normal_fg_bold) (out-str @T_MD))
        ))
    (reset! screen_attr 0)
    nil)

;; Reset the colors for a cterm.  Used when leaving Vim.
;; The machine specific code may override this again.

(defn- #_void reset-cterm-colors []
    (when (< 1 @t_colors)
        ;; set Normal cterm colors
        (when (or (< 0 @cterm_normal_fg_color) (< 0 @cterm_normal_bg_color))
            (out-str @T_OP)
            (reset! screen_attr -1)
        )
        (when (non-zero? @cterm_normal_fg_bold)
            (out-str @T_ME)
            (reset! screen_attr -1)
        ))
    nil)

;; Put character "screenLines[off]" on the screen at position "row" and "col",
;; using the attributes from "screenAttrs[off]".

(defn- #_void screen-char [#_int off, #_int row, #_int col]
    ;; Check for illegal values, just in case (could happen just after resizing).
    (when (and (< row @screenRows) (< col @screenCols))
        ;; Writing at the last cell of the screen may scroll it up.
        ;; Only do it when the "xn" termcap property is set, otherwise
        ;; mark the character invalid (update it when scrolled up).
        (if (and (eos? @T_XN) (== row (dec @screenRows)) (== col (dec @screenCols)))
            (aset @screenAttrs off -1)
            ;; Stop highlighting first, so it's easier to move the cursor.
            (let [#_int attr (if (non-zero? @screen_char_attr) @screen_char_attr (aget @screenAttrs off))]
                (when (!= @screen_attr attr)
                    (screen-stop-highlight))
                (windgoto row, col)
                (when (!= @screen_attr attr)
                    (screen-start-highlight attr))
                (if (non-zero? (aget @screenLinesUC off))
                    (let [#_Bytes buf (Bytes. (inc MB_MAXBYTES))]
                        ;; Convert UTF-8 character to bytes and write it.
                        (eos! buf (utfc-char2bytes off, buf))
                        (out-str buf)
                        (when (< 1 (utf-char2cells (aget @screenLinesUC off)))
                            (swap! screen_cur_col inc)
                        ))
                    (do (out-flush-check)
                        (out-char (.at @screenLines off))
                    ))
                (swap! screen_cur_col inc)
            )))
    nil)

;; Draw a rectangle of the screen, inverted when "invert" is true.
;; This uses the contents of screenLines[] and doesn't change it.

(defn- #_void screen-draw-rectangle [#_int row, #_int col, #_int height, #_int width, #_boolean invert]
    (when (some? @screenLines) ;; can't use "screenLines" unless initialized
        (when invert
            (reset! screen_char_attr HL_INVERSE))
        (loop-when-recur [#_int r row] (< r (+ row height)) [(inc r)]
            (let [#_int off (aget @lineOffset r) #_int max_off (+ off @screenCols)]
                (loop-when-recur [#_int c col] (< c (+ col width)) [(inc (if (< 1 (utf-off2cells (+ off c), max_off)) (inc c) c))]
                    (screen-char (+ off c), r, c))
            ))
        (reset! screen_char_attr 0))
    nil)

;; Redraw the characters for a vertically split window.

(defn- #_void redraw-block [#_int row, #_int end, #_window_C win]
    (let [[#_int col #_int width] (if (some? win) [(:w_wincol win) (:w_width win)] [0 @Cols])]
        (screen-draw-rectangle row, col, (- end row), width, false))
    nil)

;; Fill the screen from 'start_row' to 'end_row', from 'start_col' to 'end_col'
;; with character 'c1' in first column followed by 'c2' in the other columns.
;; Use attributes 'attr'.

(defn- #_void screen-fill [#_int start_row, #_int end_row, #_int start_col, #_int end_col, #_int c1, #_int c2, #_int attr]
    (let-when [end_row (min end_row @screenRows) end_col (min end_col @screenCols) ;; safety check
    ] (and (some? @screenLines) (< start_row end_row) (< start_col end_col)) ;; => nothing to do

        ;; it's a "normal" terminal when not in a GUI or cterm
        (let [#_boolean norm_term (<= @t_colors 1)]
            (loop-when [#_boolean force_next false #_int row start_row] (< row end_row)
                ;; When drawing over the right/left halve of a double-wide char, clear out the left/right halve.
                ;; Only needed in a terminal.
                (when (and (< 0 start_col) (!= (mb-fix-col start_col, row) start_col))
                    (screen-puts-len (u8 " "), 1, row, (dec start_col), 0))
                (when (and (< end_col @screenCols) (!= (mb-fix-col end_col, row) end_col))
                    (screen-puts-len (u8 " "), 1, row, end_col, 0))
                ;; Try to use delete-line termcap code, when no attributes or in a
                ;; "normal" terminal, where a bold/italic space is just a space.
                (let [#_boolean did_delete
                        (if (and (== c2 (byte \space)) (== end_col @Cols) (can-clear @T_CE)
                                 (or (zero? attr) (and norm_term (<= attr HL_ALL) (zero? (& attr (bit-not (| HL_BOLD HL_ITALIC)))))))
                            ;; check if we really need to clear something
                            (let [#_int col (if (!= c1 (byte \space)) (inc start_col) start_col)    ;; don't clear first char
                                  #_int off (+ (aget @lineOffset row) col) #_int end_off (+ (aget @lineOffset row) end_col)
                                  off (loop-when-recur off                                          ;; skip blanks (used often, keep it fast!)
                                                       (and (< off end_off) (at? @screenLines off (byte \space)) (== (aget @screenAttrs off) 0) (== (aget @screenLinesUC off) 0))
                                                       (inc off)
                                                    => off)]
                                (when (< off end_off)                                               ;; something to be cleared
                                    (let [col (- off (aget @lineOffset row))
                                          _ (screen-stop-highlight)
                                          _ (term-windgoto row, col)                                ;; clear rest of this screen line
                                          _ (out-str @T_CE)
                                          _ (screen-start)                                          ;; don't know where cursor is now
                                          col (- end_col col)]
                                        (loop-when [off off col col] (< 0 col)                      ;; clear chars in "screenLines"
                                            (.be @screenLines off, (byte \space))
                                            (aset @screenLinesUC off 0)
                                            (aset @screenAttrs off 0)
                                            (recur (inc off) (dec col)))
                                    ))
                                true)                                                               ;; the chars are cleared now
                            false)
                      force_next
                        (loop-when [force_next force_next #_int off (+ (aget @lineOffset row) start_col) #_int c c1 #_int col start_col] (< col end_col) => force_next
                            (let-when [force_next
                                    (if (or (not-at? @screenLines off c) (!= (aget @screenLinesUC off) (if (<= 0x80 c) c 0)) (!= (aget @screenAttrs off) attr) force_next)
                                        ;; The bold trick may make a single row of pixels appear in the next character.
                                        ;; When a bold character is removed, the next character should be redrawn too.
                                        ;; This happens for our own GUI and for some xterms.
                                        (let [force_next
                                                (if @term_is_xterm
                                                    (and (not-at? @screenLines off (byte \space)) (or (< HL_ALL (aget @screenAttrs off)) (flag? (aget @screenAttrs off) HL_BOLD)))
                                                    force_next
                                                )]
                                            (.be @screenLines off, c)
                                            (if (<= 0x80 c)
                                                (do (aset @screenLinesUC off c)
                                                    (aset (... @screenLinesC 0) off 0))
                                                (aset @screenLinesUC off 0))
                                            (aset @screenAttrs off attr)
                                            (when (or (not did_delete) (!= c (byte \space)))
                                                (screen-char off, row, col))
                                            force_next)
                                        force_next)
                                  off (inc off)
                                  [c ?] (cond (< start_col col) [c nil] did_delete [c :break] :else [c2 nil])
                            ] (not ?) => force_next
                                (recur force_next off c (inc col)))
                        )]
                    (when (== end_col @Cols)
                        (aset @lineWraps row false))
                    (when (== row (dec @Rows))              ;; overwritten the command line
                        (reset! redraw_cmdline true)
                        (when (and (== c1 (byte \space)) (== c2 (byte \space)))
                            (reset! clear_cmdline false))   ;; command line has been cleared
                        (when (zero? start_col)
                            (reset! mode_displayed false)   ;; mode cleared or overwritten
                        ))
                    (recur force_next (inc row)))
            )))
    nil)

;; Check if there should be a delay.
;; Used before clearing or redrawing the screen or the command line.

(defn- #_void check-for-delay [#_boolean check_msg_scroll]
    (when (and (or @emsg_on_display (and check_msg_scroll @msg_scroll)) (not @did_wait_return))
        (out-flush)
        (ui-delay 1000, true)
        (reset! emsg_on_display false)
        (when check_msg_scroll
            (reset! msg_scroll false)
        ))
    nil)

;; Allocate screen buffers if size changed.
;; When "doclear" is true, clear screen if it has been resized.
;; Returns true if there is a valid screen to write to.
;; Returns false when starting up and screen not initialized yet.

(defn- #_boolean screen-valid [#_boolean doclear]
    (screen-alloc doclear)
    (some? @screenLines))

;; Resize the shell to Rows and Cols.
;; Allocate screenLines* and associated items.
;;
;; There may be some time between setting Rows and Cols and (re)allocating screenLines*.
;; This happens when starting up and when (manually) changing the shell size.
;; Always use screenRows and screenCols to access items in screenLines*.
;; Use Rows and Cols for positioning text, where the final size of the shell is needed.

(defn- #_void screen-alloc [#_boolean doclear]
    ;; Allocation of the screen buffers is done only when the size changes and
    ;; when Rows and Cols have been set and we have started doing full screen stuff.
    (when-not (or (and (some? @screenLines) (== @Rows @screenRows) (== @Cols @screenCols) (some? @screenLinesUC) (== @p_mco @screen_mco))
                  (== @Rows 0) (== @Cols 0) (not (or @full_screen (some? @screenLines))))
        ;; Note that the window sizes are updated before reallocating the arrays,
        ;; thus we must not redraw here!
        (swap! no_redraw inc)

        (win-new-shellsize)     ;; fit the windows in the new sized shell
        (comp-col)              ;; recompute columns for shown command and ruler

        (ยง loop-when-recur [#_window_C win @firstwin] (some? win) [(:w_next win)]
            ((ร win =) (win-free-lines win)))

        (let [n (* (inc @Rows) @Cols)
              #_Bytes slis (Bytes. n)
              #_int* sluc (int-array n)
              #_int** smco (loop-when-recur [smco (vec (repeat MAX_MCO nil)) #_int i 0] (< i @p_mco) [(assoc smco i (int-array n)) (inc i)] => smco)
              #_int* sats (int-array n)
              #_int* lofs (int-array @Rows)
              #_boolean* lwrs (boolean-array @Rows)]

            (ยง loop-when-recur [#_window_C win @firstwin] (some? win) [(:w_next win)]
                ((ร win =) (win-alloc-lines win)))

            (dotimes [#_int r @Rows]
                (aset lofs r (* r @Cols))
                (aset lwrs r false)

                ;; If the screen is not to be cleared, copy as much as possible from the old one and clear the rest
                ;; (used when resizing the window at the "--more--" prompt or when executing an external command).

                (when (not doclear)
                    (BFILL slis, (aget lofs r), (byte \space), @Cols)
                    (AFILL sluc, (aget lofs r), 0, @Cols)
                    (dotimes [#_int i @p_mco] (AFILL (... smco i), (aget lofs r), 0, @Cols))
                    (AFILL sats, (aget lofs r), 0, @Cols)
                    (let [#_int r0 (+ r (- @screenRows @Rows))]
                        (when (and (<= 0 r0) (some? @screenLines))
                            (let [#_int off (aget @lineOffset r0) #_int len (min @screenCols @Cols)]
                                ;; When switching to UTF-8, don't copy characters, they may be invalid now.
                                ;; Also when "p_mco" changes.
                                (when (and (some? @screenLinesUC) (== @p_mco @screen_mco))
                                    (BCOPY slis, (aget lofs r), @screenLines, off, len)
                                    (ACOPY sluc, (aget lofs r), @screenLinesUC, off, len)
                                    (dotimes [#_int i @p_mco]
                                        (ACOPY (... smco i), (aget lofs r), (... @screenLinesC i), off, len)
                                    ))
                                (ACOPY sats, (aget lofs r), @screenAttrs, off, len))
                        ))
                ))

            ;; Use the last line of the screen for the current line.
            (reset! current_ScreenLine (.plus slis (* @Rows @Cols)))

            (reset! screenLines slis)
            (reset! screenLinesUC sluc)
            (reset! screenLinesC smco)
            (reset! screen_mco @p_mco)
            (reset! screenAttrs sats)
            (reset! lineOffset lofs)
            (reset! lineWraps lwrs)

            ;; It's important that screenRows and screenCols reflect the actual size of screenLines*.
            (reset! screenRows @Rows)
            (reset! screenCols @Cols)

            (reset! must_redraw CLEAR) ;; need to clear the screen later
            (when doclear
                (screenclear2))

            (swap! no_redraw dec)
        ))
    nil)

(defn- #_void screen-clear []
    (check-for-delay false)
    (screen-alloc false)            ;; allocate screen buffers if size changed
    (screenclear2)                  ;; clear the screen
    nil)

(defn- #_void screenclear2 []
    (when (and (!= @starting NO_SCREEN) (some? @screenLines))
        (reset! screen_attr -1)                 ;; force setting the Normal colors
        (screen-stop-highlight)                 ;; don't want highlighting here
        (dotimes [#_int i @Rows]                ;; blank out "screenLines"
            (lineclear (aget @lineOffset i), @Cols)
            (aset @lineWraps i false))
        (if (can-clear @T_CL)
            (do (out-str @T_CL)                 ;; clear the display
                (reset! clear_cmdline false)
                (reset! mode_displayed false))
            (do (dotimes [#_int i @Rows]        ;; can't clear the screen, mark all chars with invalid attributes
                    (lineinvalid (aget @lineOffset i), @Cols))
                (reset! clear_cmdline true)
            ))
        (reset! screen_cleared TRUE)            ;; can use contents of "screenLines" now

        (win-rest-invalid @firstwin)

        (reset! redraw_cmdline true)
        (when (== @must_redraw CLEAR)           ;; no need to clear again
            (reset! must_redraw NOT_VALID))
        (compute-cmdrow)
        (reset! msg_row @cmdline_row)           ;; put cursor on last line for messages
        (reset! msg_col 0)
        (screen-start)                          ;; don't know where cursor is now
        (reset! msg_scrolled 0)                 ;; can't scroll back
        (reset! msg_didany false)
        (reset! msg_didout false))
    nil)

;; Clear one line in "screenLines".

(defn- #_void lineclear [#_int off, #_int width]
    (BFILL @screenLines, off, (byte \space), width)
    (AFILL @screenLinesUC, off, 0, width)
    (AFILL @screenAttrs, off, 0, width)
    nil)

;; Mark one line in "screenLines" invalid by setting the attributes to an invalid value.

(defn- #_void lineinvalid [#_int off, #_int width]
    (AFILL @screenAttrs, off, -1, width)
    nil)

;; Copy part of a screenline for vertically split window "win".

(defn- #_void linecopy [#_int to, #_int from, #_window_C win]
    (let [#_int off_to (+ (aget @lineOffset to) (:w_wincol win)) #_int off_from (+ (aget @lineOffset from) (:w_wincol win)) width (:w_width win)]
        (BCOPY @screenLines, off_to, @screenLines, off_from, width)
        (ACOPY @screenLinesUC, off_to, @screenLinesUC, off_from, width)
        (dotimes [#_int i @p_mco]
            (ACOPY (... @screenLinesC i), off_to, (... @screenLinesC i), off_from, width))
        (ACOPY @screenAttrs, off_to, @screenAttrs, off_from, width))
    nil)

;; Return true if clearing with term string "p" would work.
;; It can't work when the string is empty or it won't set the right background.

(defn- #_boolean can-clear [#_Bytes p]
    (and (non-eos? p) (or (<= @t_colors 1) (zero? @cterm_normal_bg_color) (non-eos? @T_UT))))

;; Reset cursor position.  Use whenever cursor was moved because of outputting
;; something directly to the screen (shell commands) or a terminal control code.

(defn- #_void screen-start []
    (reset! screen_cur_row (reset! screen_cur_col 9999))
    nil)

;; Move the cursor to position "row","col" in the screen.
;; This tries to find the most efficient way to move, minimizing the number of
;; characters sent to the terminal.

(final int
    GOTO_COST  7,   ;; assume a term-windgoto() takes about 7 chars
    HIGHL_COST 5)   ;; assume unhighlight takes 5 chars

(final int
    PLAN_LE    1,
    PLAN_CR    2,
    PLAN_NL    3,
    PLAN_WRITE 4)

(defn- #_void windgoto [#_int row, #_int col]
    (when (and (some? @screenLines) (or (!= col @screen_cur_col) (!= row @screen_cur_row)))
        ;; Check for valid position.
        (let [row (max 0 row) ;; window without text lines?
              row (min row (dec @screenRows))
              col (min col (dec @screenCols))
              ;; check if no cursor movement is allowed in highlight mode
              #_int noinvcurs (if (and (non-zero? @screen_attr) (eos? @T_MS)) HIGHL_COST 0)
              #_int goto_cost (+ GOTO_COST noinvcurs)
              ;; Plan how to do the positioning:
              ;;
              ;; 1. Use CR to move it to column 0, same row.
              ;; 2. Use T_LE to move it a few columns to the left.
              ;; 3. Use NL to move a few lines down, column 0.
              ;; 4. Move a few columns to the right with T_ND or by writing chars.
              ;;
              ;; Don't do this if the cursor went beyond the last column,
              ;; the cursor position is unknown then (some terminals wrap, some don't).
              ;;
              ;; First check if the highlighting attributes allow us to write
              ;; characters to move the cursor to the right.
              #_int cost
                (cond (and (<= @screen_cur_row row) (< @screen_cur_col @Cols))
                (let [#_int attr @screen_attr
                      ;; If the cursor is in the same row, bigger col, we can use CR or T_LE.
                      [#_Bytes bs #_int plan #_int wouldbe_col cost attr]
                        (cond (and (== row @screen_cur_row) (< col @screen_cur_col))
                            ;; "le" is preferred over "bc", because "bc" is obsolete ;; "cursor left" ;; "backspace character (old)
                            (let [bs (if (non-eos? @T_LE) @T_LE @T_BC)
                                  cost (if (non-eos? bs) (* (- @screen_cur_col col) (STRLEN bs)) 999)
                                  ;; using CR is less characters ;; CR is just one character
                                  [plan wouldbe_col cost] (if (< (inc col) cost) [PLAN_CR 0 1] [PLAN_LE col cost])
                                  ;; if ... stop highlighting
                                  [cost attr] (if (non-zero? noinvcurs) [(+ cost noinvcurs) 0] [cost attr])]
                                [bs plan wouldbe_col cost attr])
                        ;; If the cursor is above where we want to be, we can use CR LF.
                        (< @screen_cur_row row)
                            (let [cost (* (- row @screen_cur_row) 2) ;; CR LF
                                  ;; if ... stop highlighting
                                  [cost attr] (if (non-zero? noinvcurs) [(+ cost noinvcurs) 0] [cost attr])]
                                [nil PLAN_NL 0 cost attr])
                        ;; If the cursor is in the same row, smaller col, just use write.
                        :else
                            [nil PLAN_WRITE @screen_cur_col 0 attr])
                      ;; Check if any characters that need to be written have the correct attributes.  Also avoid UTF-8 characters.
                      cost (let-when [#_int i (- col wouldbe_col) cost (if (< 0 i) (+ cost i) cost)] (and (< cost goto_cost) (< 0 i)) => cost
                            ;; Check if the attributes are correct without additionally stopping highlighting.
                            (let [[#_int ai i] (loop-when [ai (+ (aget @lineOffset row) wouldbe_col) i i] (< 0 i) => [ai i]
                                                   (recur-if (== (aget @screenAttrs ai) attr) [(inc ai) (dec i)] => [(inc ai) i]))
                                  [i cost] (if (non-zero? i)
                                                (let [ai (dec ai) ;; Try if it works when highlighting is stopped here.
                                                    [i cost] (if (zero? (aget @screenAttrs ai))
                                                                    (let [i (loop-when [ai ai i i] (< 0 i) => i
                                                                                (recur-if (== (aget @screenAttrs ai) 0) [(inc ai) (dec i)] => i))] ;; => (inc ai)
                                                                        [i (+ cost noinvcurs)])
                                                                    [i cost])]
                                                    [i (if (non-zero? i) 999 cost)]) ;; different attributes, don't do it
                                                [i cost])]
                                ;; Don't use an UTF-8 char for positioning, it's slow.
                                (loop-when [cost cost #_int i wouldbe_col] (< i col) => cost
                                    (recur-if (== (aget @screenLinesUC (+ (aget @lineOffset row) i)) 0) [cost (inc i)] => 999))
                            ))]
                    ;; We can do it without term-windgoto()!
                    (when (< cost goto_cost)
                        (cond (== plan PLAN_LE)
                        (do
                            (when (non-zero? noinvcurs) (screen-stop-highlight))
                            (while (< col @screen_cur_col) (out-str bs) (swap! screen_cur_col dec))
                        )
                        (== plan PLAN_CR)
                        (do
                            (when (non-zero? noinvcurs) (screen-stop-highlight))
                            (out-char (byte \return))
                            (reset! screen_cur_col 0)
                        )
                        (== plan PLAN_NL)
                        (do
                            (when (non-zero? noinvcurs) (screen-stop-highlight))
                            (while (< @screen_cur_row row) (out-char (byte \newline)) (swap! screen_cur_row inc))
                            (reset! screen_cur_col 0)
                        ))
                        (let-when [#_int i (- col @screen_cur_col)] (< 0 i)
                            ;; Use cursor-right if it's one character only.
                            ;; Avoids removing a line of pixels from the last bold char, when using the bold trick in the GUI.
                            (if (and (non-eos? @T_ND) (eos? @T_ND 1))
                                (loop-when-recur i (< 0 i) (dec i) (out-char (.at @T_ND 0)))
                                (loop-when-recur [#_int off (+ (aget @lineOffset row) @screen_cur_col) i i] (< 0 i) [(inc off) (dec i)]
                                    (when (!= (aget @screenAttrs off) @screen_attr) (screen-stop-highlight))
                                    (out-flush-check)
                                    (out-char (.at @screenLines off))
                                ))
                        ))
                    cost
                )
                :else 999)]
            (when (<= goto_cost cost)
                (when (non-zero? noinvcurs) (screen-stop-highlight))
                (if (and (== row @screen_cur_row) (< @screen_cur_col col) (non-eos? @T_CRI))
                    (term-cursor-right (- col @screen_cur_col))
                    (term-windgoto row, col)))
            (reset! screen_cur_row row)
            (reset! screen_cur_col col)
        ))
    nil)

;; Set cursor to its position in window "win".

(defn- #_window_C setcursor [#_window_C win]
    (if (redrawing)
        (let [win (validate-cursor win)]
            (windgoto (+ (:w_winrow win) (:w_wrow win)), (+ (:w_wincol win) (:w_wcol win)))
            win)
        win
    ))

;; Insert "line_count" lines at "row" in window "win".
;; If "invalid" is true, win.w_lines[] are invalidated.
;; If "mayclear" is true, the screen will be cleared if it is faster than scrolling.
;; Returns true for success, false if the lines are not inserted.

(defn- #_[window_C boolean] win-ins-lines? [#_window_C win, #_int row, #_int line_count, #_boolean invalid, #_boolean mayclear]
    (let-when [win (if invalid (assoc win :w_lines_valid 0) win)] (<= 5 (:w_height win)) => [win false]
        (let-when [line_count (min line_count (- (:w_height win) row))
              #_maybean maybe (win-do-lines win, row, line_count, mayclear, false)
        ] (== maybe MAYBE) => [win (!= maybe FALSE)]

            ;; If there is a next window or a status line, we first try to delete the lines at the bottom to avoid messing what is after the window.
            ;; If this fails and there are following windows, don't do anything to avoid messing up those windows, better just redraw.
            (let-when [#_boolean did_delete
                    (if (or (some? (:w_next win)) (non-zero? (:w_status_height win)))
                        (cond (screen-del-lines 0, (- (+ (:w_winrow win) (:w_height win)) line_count), line_count, @Rows, false, nil)
                            true
                        (some? (:w_next win))
                            nil
                        :else
                            false)
                        false)
            ] (some? did_delete) => [win false]

                ;; If no lines deleted, blank the lines that will end up below the window.
                (let [win (if (not did_delete)
                            (let [win (assoc win :w_redr_status true)
                                  _ (reset! redraw_cmdline true)
                                  #_int nextrow (+ (:w_winrow win) (:w_height win) (:w_status_height win))
                                  #_int lastrow (min (+ nextrow line_count) @Rows)]
                                (screen-fill (- nextrow line_count), (- lastrow line_count), (:w_wincol win), (+ (:w_wincol win) (:w_width win)), (byte \space), (byte \space), 0)
                                win)
                            win
                        )]
                    (if (not (screen-ins-lines 0, (+ (:w_winrow win) row), line_count, @Rows, nil))
                        ;; deletion will have messed up other windows
                        (let [win (if did_delete
                                    (let [win (assoc win :w_redr_status true)]
                                        (win-rest-invalid (:w_next win))
                                        win)
                                    win
                                )]
                            [win false])
                        [win true]
                    ))
            ))
    ))

;; Delete "line_count" lines at "row" in window "win".
;; If "invalid" is true, win.w_lines[] are invalidated.
;; If "mayclear" is true, the screen will be cleared if it is faster than scrolling.
;; Returns true for success, false if the lines are not deleted.

(defn- #_[window_C boolean] win-del-lines? [#_window_C win, #_int row, #_int line_count, #_boolean invalid, #_boolean mayclear]
    (let-when [win (if invalid (assoc win :w_lines_valid 0) win) line_count (min line_count (- (:w_height win) row))
          #_maybean maybe (win-do-lines win, row, line_count, mayclear, true)
    ] (== maybe MAYBE) => [win (!= maybe FALSE)]

        (cond (not (screen-del-lines 0, (+ (:w_winrow win) row), line_count, @Rows, false, nil))
            [win false]
        ;; If there are windows or status lines below, try to put them at the correct place.
        ;; If we can't do that, they have to be redrawn.
        (or (some? (:w_next win)) (non-zero? (:w_status_height win)) (< @cmdline_row (dec @Rows)))
            (let [win (if (not (screen-ins-lines 0, (- (+ (:w_winrow win) (:w_height win)) line_count), line_count, @Rows, nil))
                        (let [win (assoc win :w_redr_status true)]
                            (win-rest-invalid (:w_next win))
                            win)
                        win
                    )]
                [win true])
        ;; If this is the last window and there is no status line, redraw the command line later.
        :else
            (do (reset! redraw_cmdline true)
                [win true]
            ))
    ))

;; Common code for win-ins-lines() and win-del-lines().
;; Returns TRUE or FALSE when the work has been done.
;; Returns MAYBE when not finished yet.

(defn- #_maybean win-do-lines [#_window_C win, #_int row, #_int line_count, #_boolean mayclear, #_boolean del]
    (cond (or (not (redrawing)) (<= line_count 0))
        FALSE
    (and mayclear (< (- @Rows line_count) 5) (== (:w_width win) @Cols)) ;; only a few lines left: redraw is faster
    (do
        (screen-clear)      ;; will set win.w_lines_valid to 0
        FALSE
    )
    (<= (:w_height win) (+ row line_count)) ;; delete all remaining lines
    (do
        (screen-fill (+ (:w_winrow win) row), (+ (:w_winrow win) (:w_height win)), (:w_wincol win), (+ (:w_wincol win) (:w_width win)), (byte \space), (byte \space), 0)
        TRUE
    )
    :else
    (do ;; When scrolling, the message on the command line should be cleared, otherwise it will stay there forever.
        (reset! clear_cmdline true)
        ;; If the terminal can set a scroll region, use that.  Always do this in a vertically split window.
        ;; This will redraw from screenLines[] when t_CV isn't defined.  That's faster than using win-line().
        ;; Don't use a scroll region when we are going to redraw the text.
        (cond (or @scroll_region (!= (:w_width win) @Cols))
        (do
            (when (and @scroll_region (or (== (:w_width win) @Cols) (non-eos? @T_CSV)))
                (scroll-region-set win, row))
            (let [#_boolean r (if del
                        (screen-del-lines (+ (:w_winrow win) row), 0, line_count, (- (:w_height win) row), false, win)
                        (screen-ins-lines (+ (:w_winrow win) row), 0, line_count, (- (:w_height win) row), win)
                    )]
                (when (and @scroll_region (or (== (:w_width win) @Cols) (non-eos? @T_CSV)))
                    (scroll-region-reset))
                (if r TRUE FALSE)
            ))
        (some? (:w_next win))
            FALSE
        :else
            MAYBE
        ))
    ))

;; Window "win" and everything after it are messed up, mark them for redraw.

(defn- #_void win-rest-invalid [#_window_C win]
    (ร loop-when win (some? win)
        (let [win (-> win (redraw-later NOT_VALID) (assoc :w_redr_status true))]
            (recur (:w_next win))
        ))
    (reset! redraw_cmdline true)
    nil)

;; The rest of the routines in this file perform screen manipulations.
;; The given operation is performed physically on the screen.
;; The corresponding change is also made to the internal screen image.
;; In this way, the editor anticipates the effect of editing changes on the appearance of the screen.
;; That way, when we call update-screen(), a complete redraw isn't usually necessary.

;; types for inserting or deleting lines
(final int
    USE_T_CAL   1,
    USE_T_CDL   2,
    USE_T_AL    3,
    USE_T_CE    4,
    USE_T_DL    5,
    USE_T_SR    6,
    USE_NL      7,
    USE_T_CD    8,
    USE_REDRAW  9)

;; Insert lines on the screen and update screenLines[].
;; "end" is the line after the scrolled part.  Normally it is Rows.
;; When scrolling region used, "off" is the offset from the top for the region.
;; "row" and "end" are relative to the start of the region.
;;
;; Return true for success, false for failure.

(defn- #_boolean screen-ins-lines [#_int off, #_int row, #_int line_count, #_int end, #_window_C win]
    ;; win: null or window to use width from
    (and (screen-valid true) (<= 1 line_count @p_ttyscroll)
        ;; There are several ways to insert lines:
        ;;
        ;; 0. When in a vertically split window and t_CV isn't set, redraw the characters from screenLines[].
        ;; 1. Use T_CD (clear to end of display) if it exists and the result of the insert is just empty lines.
        ;; 2. Use T_CAL (insert multiple lines) if it exists and T_AL is not present or line_count > 1.
        ;;    It looks better if we do all the inserts at once.
        ;; 3. Use T_CDL (delete multiple lines) if it exists and the result of the
        ;;    insert is just empty lines and T_CE is not present or line_count > 1.
        ;; 4. Use T_AL (insert line) if it exists.
        ;; 5. Use T_CE (erase line) if it exists and the result of the insert is just empty lines.
        ;; 6. Use T_DL (delete line) if it exists and the result of the insert is just empty lines.
        ;; 7. Use T_SR (scroll reverse) if it exists and inserting at row 0
        ;;    and the 'da' flag is not set or we have clear line capability.
        ;; 8. Redraw the characters from screenLines[].
        (let-when [#_boolean can_ce (can-clear @T_CE) #_boolean result_empty (<= end (+ row line_count))
              #_int type
                (cond
                    (and (some? win) (!= (:w_width win) @Cols) (eos? @T_CSV))               USE_REDRAW
                    (and (can-clear @T_CD) result_empty)                                    USE_T_CD
                    (and (non-eos? @T_CAL) (or (< 1 line_count) (eos? @T_AL)))              USE_T_CAL
                    (and (non-eos? @T_CDL) result_empty (or (< 1 line_count) (not can_ce))) USE_T_CDL
                    (non-eos? @T_AL)                                                        USE_T_AL
                    (and can_ce result_empty)                                               USE_T_CE
                    (and (non-eos? @T_DL) result_empty)                                     USE_T_DL
                    (and (non-eos? @T_SR) (zero? row) (or (eos? @T_DA) can_ce))             USE_T_SR
                )
        ] (some? type) => false

            ;; Use screen-del-lines() for clearing the lines, it also takes care of T_DB if necessary.
            (if (any == type USE_T_CD USE_T_CDL USE_T_CE USE_T_DL)
                (screen-del-lines off, row, line_count, end, false, win)
                ;; If text is retained below the screen, first clear or delete as many
                ;; lines at the bottom of the window as are about to be inserted so that
                ;; the deleted lines won't later surface during a screen-del-lines().
                (let [_ (when (non-eos? @T_DB)
                            (screen-del-lines off, (- end line_count), line_count, end, false, win))
                      #_int cursor_row (+ row off)
                      ;; Shift lineOffset* "line_count" down to reflect the inserted lines.
                      row (+ row off) end (+ end off)]
                    (dotimes [#_int i line_count]
                        (if (and (some? win) (!= (:w_width win) @Cols))
                            ;; need to copy part of a line
                            (let [#_int j (- end 1 i)
                                  j (loop-when [j (- j line_count)] (<= row j) => (+ j line_count)
                                        (linecopy (+ j line_count), j, win)
                                        (recur (- j line_count))
                                    )]
                                (if (can-clear (u8 " "))
                                    (lineclear (+ (aget @lineOffset j) (:w_wincol win)), (:w_width win))
                                    (lineinvalid (+ (aget @lineOffset j) (:w_wincol win)), (:w_width win)))
                                (aset @lineWraps j false))
                            ;; whole width, moving the line pointers is faster
                            (let [#_int j (- end 1 i) #_int k (aget @lineOffset j)
                                  j (loop-when [j (- j line_count)] (<= row j) => (+ j line_count)
                                        (aset @lineOffset (+ j line_count) (aget @lineOffset j))
                                        (aset @lineWraps (+ j line_count) (aget @lineWraps j))
                                        (recur (- j line_count))
                                    )]
                                (aset @lineOffset j k)
                                (aset @lineWraps j false)
                                (if (can-clear (u8 " "))
                                    (lineclear k, @Cols)
                                    (lineinvalid k, @Cols)
                                ))
                        ))
                    (screen-stop-highlight)
                    (windgoto cursor_row, 0)
                    (condp == type
                        USE_REDRAW  (redraw-block row, end, win) ;; redraw the characters
                        USE_T_CAL   (do (term-append-lines line_count)
                                        (screen-start)) ;; don't know where cursor is now
                        USE_T_AL    (dotimes [i line_count]
                                        (when (and (non-zero? i) (non-zero? cursor_row))
                                            (windgoto cursor_row, 0))
                                        (out-str @T_AL)
                                        (screen-start)) ;; don't know where cursor is now
                        USE_T_SR    (dotimes [_ line_count]
                                        (out-str @T_SR)
                                        (screen-start)) ;; don't know where cursor is now
                    )
                    ;; With scroll-reverse and T_DA, we need to clear the lines
                    ;; that have been scrolled down into the region.
                    (when (and (== type USE_T_SR) (non-eos? @T_DA))
                        (dotimes [i line_count]
                            (windgoto (+ off i), 0)
                            (out-str @T_CE)
                            (screen-start) ;; don't know where cursor is now
                        ))
                    true
                )
            ))
    ))

;; Delete lines on the screen and update screenLines[].
;; "end" is the line after the scrolled part.  Normally it is Rows.
;; When scrolling region used, "off" is the offset from the top for the region.
;; "row" and "end" are relative to the start of the region.
;;
;; Return true for success, false if the lines are not deleted.

(defn- #_boolean screen-del-lines [#_int off, #_int row, #_int line_count, #_int end, #_boolean force, #_window_C win]
    ;; force: even when line_count > 'ttyscroll'
    ;; win: null or window to use width from
    (and (screen-valid true) (<= 1 line_count) (or force (<= line_count @p_ttyscroll))
        ;; Check if the rest of the current region will become empty.
        (let-when [#_boolean result_empty (<= end (+ row line_count))
              ;; We can delete lines only when 'db' flag not set or when 'ce' option available.
              #_boolean can_delete (or (eos? @T_DB) (can-clear @T_CE))
              ;; There are several ways to delete lines:
              ;;
              ;; 0. When in a vertically split window and t_CV isn't set, redraw the characters from screenLines[].
              ;; 1. Use T_CD if it exists and the result is empty.
              ;; 2. Use newlines if row == 0 and count == 1 or T_CDL does not exist.
              ;; 3. Use T_CDL (delete multiple lines) if it exists and line_count > 1 or none of the other ways work.
              ;; 4. Use T_CE (erase line) if the result is empty.
              ;; 5. Use T_DL (delete line) if it exists.
              ;; 6. Redraw the characters from screenLines[].
              #_int type
                (cond
                    (and (some? win) (!= (:w_width win) @Cols) (eos? @T_CSV))                      USE_REDRAW
                    (and (can-clear @T_CD) result_empty)                                           USE_T_CD
                    (and (zero? row) (or (== line_count 1) (eos? @T_CDL)))                         USE_NL
                    (and (non-eos? @T_CDL) (< 1 line_count) can_delete)                            USE_T_CDL
                    (and (can-clear @T_CE) result_empty (or (nil? win) (== (:w_width win) @Cols))) USE_T_CE
                    (and (non-eos? @T_DL) can_delete)                                              USE_T_DL
                    (and (non-eos? @T_CDL) can_delete)                                             USE_T_CDL
                )
        ] (some? type) => false

            (let [#_int cursor_row (+ row off) #_int cursor_end (+ end off)
                  ;; Shift lineOffset* "line_count" up to reflect the deleted lines.
                  row (+ row off) end (+ end off)]
                (dotimes [#_int i line_count]
                    (if (and (some? win) (!= (:w_width win) @Cols))
                        ;; need to copy part of a line
                        (let [#_int j (+ row i)
                              j (loop-when [j (+ j line_count)] (< j end) => (- j line_count)
                                    (linecopy (- j line_count), j, win)
                                    (recur (+ j line_count))
                                )]
                            (if (can-clear (u8 " "))
                                (lineclear (+ (aget @lineOffset j) (:w_wincol win)), (:w_width win))
                                (lineinvalid (+ (aget @lineOffset j) (:w_wincol win)), (:w_width win)))
                            (aset @lineWraps j false))
                        ;; whole width, moving the line pointers is faster
                        (let [#_int j (+ row i) #_int k (aget @lineOffset j)
                              j (loop-when [j (+ j line_count)] (< j end) => (- j line_count)
                                    (aset @lineOffset (- j line_count) (aget @lineOffset j))
                                    (aset @lineWraps (- j line_count) (aget @lineWraps j))
                                    (recur (+ j line_count))
                                )]
                            (aset @lineOffset j k)
                            (aset @lineWraps j false)
                            (if (can-clear (u8 " "))
                                (lineclear k, @Cols)
                                (lineinvalid k, @Cols)
                            ))
                    ))
                (screen-stop-highlight)
                (condp == type
                    USE_REDRAW  (redraw-block row, end, win)        ;; redraw the characters
                    USE_T_CD    (do (windgoto cursor_row, 0)        ;; delete the lines
                                    (out-str @T_CD)
                                    (screen-start))                 ;; don't know where cursor is now
                    USE_T_CDL   (do (windgoto cursor_row, 0)
                                    (term-delete-lines line_count)
                                    (screen-start))                 ;; don't know where cursor is now
                    ;; Deleting lines at top of the screen or scroll region:
                    ;; just scroll the whole screen (scroll region) up by outputting newlines on the last line.
                    USE_NL      (do (windgoto (dec cursor_end), 0)
                                    (dotimes [_ line_count]
                                        (out-char (byte \newline))  ;; cursor will remain on same line
                                    ))
                    USE_T_DL    (dotimes [_ line_count]
                                    (windgoto cursor_row, 0)
                                    (out-str @T_DL)                 ;; delete a line
                                    (screen-start))                 ;; don't know where cursor is now
                    USE_T_CE    (loop-when-recur [i (dec line_count)] (<= 0 i) [(dec i)]
                                    (windgoto (+ cursor_row i), 0)
                                    (out-str @T_CE)                 ;; erase a line
                                    (screen-start))                 ;; don't know where cursor is now
                )
                ;; If the 'db' flag is set, we need to clear the lines
                ;; that have been scrolled up at the bottom of the region.
                (when (and (non-eos? @T_DB) (any == type USE_T_DL USE_T_CDL))
                    (loop-when-recur [i line_count] (< 0 i) [(dec i)]
                        (windgoto (- cursor_end i), 0)
                        (out-str @T_CE)                             ;; erase a line
                        (screen-start)                              ;; don't know where cursor is now
                    ))
                true
            ))
    ))

;; Show the current mode and ruler.
;;
;; If clear_cmdline is true, clear the rest of the cmdline.
;; If clear_cmdline is false there may be a message there that needs to be cleared only if a mode is shown.
;;
;; Return the length of the message (0 if no message).

(defn- #_[window_C int] showmode? [#_window_C win]
    (let-when [#_boolean do_mode (and @p_smd (or (flag? @State INSERT) (!= @restart_edit 0) @VIsual_active))
          #_int length
            (cond (and (not do_mode) (not @Recording))
                ;; Clear the whole command line.  Will reset "clear_cmdline".
                (do (when @clear_cmdline (msg-clr-cmdline)) 0)
            (or (not (redrawing)) (and (char-avail) (not @key_typed)))
                ;; Don't show mode right now, when not redrawing or inside a mapping.
                ;; Call char-avail() only when we are going to show something, because it takes a bit of time.
                (do (reset! redraw_cmdline true) nil) ;; show mode later
            :else
                (let [#_boolean nwr_save @need_wait_return
                      ;; wait a bit before overwriting an important message
                      _ (check-for-delay false)
                      ;; if the cmdline is more than one line high, erase top lines
                      #_boolean need_clear @clear_cmdline]
                    (when (and @clear_cmdline (< @cmdline_row (dec @Rows)))
                        (msg-clr-cmdline))                  ;; will reset clear_cmdline
                    ;; Position on the last line in the window, column 0.
                    (msg-pos-mode)
                    (cursor-off)
                    (let [#_int attr (hl-attr HLF_CM)]                 ;; Highlight mode
                        (when do_mode
                            (msg-puts-attr (u8 "--"), attr)
                            (cond
                                (flag? @State VREPLACE_FLAG) (msg-puts-attr (u8 " VREPLACE"), attr)
                                (flag? @State REPLACE_FLAG)  (msg-puts-attr (u8 " REPLACE"), attr)
                                (flag? @State INSERT)        (msg-puts-attr (u8 " INSERT"), attr)
                                (== @restart_edit (byte \I)) (msg-puts-attr (u8 " (insert)"), attr)
                                (== @restart_edit (byte \R)) (msg-puts-attr (u8 " (replace)"), attr)
                                (== @restart_edit (byte \V)) (msg-puts-attr (u8 " (vreplace)"), attr)
                            )
                            (when (and (flag? @State INSERT) @p_paste)
                                (msg-puts-attr (u8 " (paste)"), attr))
                            (when @VIsual_active
                                ;; Don't concatenate separate words to avoid translation problems.
                                (-> (condp == (+ (if @VIsual_select 4 0) (if (== @VIsual_mode Ctrl_V) 2 0) (if (== @VIsual_mode (byte \V)) 1 0))
                                        0 (u8 " VISUAL")
                                        1 (u8 " VISUAL LINE")
                                        2 (u8 " VISUAL BLOCK")
                                        4 (u8 " SELECT")
                                        5 (u8 " SELECT LINE")
                                        6 (u8 " SELECT BLOCK"))
                                    (msg-puts-attr attr))
                            )
                            (msg-puts-attr (u8 " --"), attr)
                        )
                        (when @Recording
                            (msg-puts-attr (u8 "recording"), attr)
                        ))
                    (reset! mode_displayed true)
                    (when (or need_clear do_mode @Recording @clear_cmdline)
                        (msg-clr-eos))
                    (reset! msg_didout false)             ;; overwrite this message
                    (let [length @msg_col]
                        (reset! msg_col 0)
                        (reset! need_wait_return nwr_save)    ;; never ask for hit-return for this
                        length
                    ))
            )] (some? length) => [win 0]

        ;; In Visual mode the size of the selected area must be redrawn.
        (let [win (if @VIsual_active (clear-showcmd win) win)]
            ;; If the last window has no status line,
            ;; the ruler is after the mode message and must be redrawn.
            (when (and (redrawing) (zero? (:w_status_height @lastwin)))
                (swap! lastwin win-redr-ruler true))
            (reset! redraw_cmdline false)
            (reset! clear_cmdline false)
            [win length]
        )
    ))

(defn- #_window_C showmode [#_window_C win]
    (let [[win _] (showmode? win)]
        win
    ))

;; Position for a mode message.

(defn- #_void msg-pos-mode []
    (reset! msg_col 0)
    (reset! msg_row (dec @Rows))
    nil)

;; Delete mode message.
;; Used when ESC is typed which is expected to end Insert mode (but Insert mode didn't end yet!).
;; Caller should check "mode_displayed".

(defn- #_void unshowmode [#_boolean force]
    ;; Don't delete it right now, when not redrawing or inside a mapping.
    (if (and (redrawing) (or force (not (char-avail)) @key_typed))
        (do (msg-pos-mode)
            (when @Recording
                (msg-puts-attr (u8 "recording"), (hl-attr HLF_CM)))
            (msg-clr-eos))
        (reset! redraw_cmdline true)) ;; delete mode later
    nil)

;; Get the character to use in a status line.  Get its attributes in "*attr".

(defn- #_int fillchar-status [#_int' a'attr, #_boolean focused?]
    (let [#_int fill (if focused?
                (do (reset! a'attr (hl-attr HLF_S))   @fill_stl)
                (do (reset! a'attr (hl-attr HLF_SNC)) @fill_stlnc)
            )]
        ;; Use fill when there is highlighting, and highlighting of current window differs, or the fillchars differ, or this is not the current window.
        (if (and (non-zero? @a'attr) (or (!= (hl-attr HLF_S) (hl-attr HLF_SNC)) (not focused?) (== @firstwin @lastwin) (!= @fill_stl @fill_stlnc)))
            fill
            (if focused? (byte \^) (byte \=)))
    ))

;; Get the character to use in a separator between vertically split windows.
;; Get its attributes in "*attr".

(defn- #_int fillchar-vsep [#_int' a'attr]
    (reset! a'attr (hl-attr HLF_C))
    (if (and (zero? @a'attr) (== @fill_vert (byte \space))) (byte \|) @fill_vert))

;; Return true if redrawing should currently be done.

(defn- #_boolean redrawing []
    (and (zero? @no_redraw) (not (and @p_lz (char-avail) (not @key_typed) (not @do_redraw)))))

;; Return true if printing messages should currently be done.

(defn- #_boolean messaging []
    (not (and @p_lz (char-avail) (not @key_typed))))

;; Show current status info in ruler and various other places.
;; If "always" is false, only show ruler if position has changed.

(defn- #_window_C showruler [#_window_C win, #_boolean always]
    (if (or always (redrawing)) (win-redr-ruler win, always) win))

(defn- #_window_C win-redr-ruler [#_window_C win, #_boolean always]
    ;; If 'ruler' is off or redrawing is disabled, don't do anything.
    ;; Also check if cursor.lnum is valid, since win-redr-ruler() may be
    ;; called after deleting lines, before cursor.lnum is corrected.
    (let-when [lmax (line-count @curbuf)] (and @p_ru (<= (:lnum (:w_cursor win)) lmax)) => win
        ;; Check if not in Insert mode and the line is empty (will show "0-1").
        (let-when [#_boolean empty (and (non-flag? @State INSERT) (eos? (ml-get (:lnum (:w_cursor win)))))
              win (validate-virtcol win)
              ;; Only draw the ruler when something changed.
              ? (or @redraw_cmdline always (!= (:w_ru_cursor win) (:w_cursor win))
                                           (!= (:w_ru_virtcol win) (:w_virtcol win))
                                           (!= (:w_ru_topline win) (:w_topline win))
                                           (!= (:w_ru_line_count win) lmax)
                                           (!= (:w_ru_empty win) empty)
                )] ? => win

            (cursor-off)
            (let [a'attr (atom (int)) [row fillchar off width]
                    (if (non-zero? (:w_status_height win))
                        [(+ (:w_winrow win) (:w_height win)) (fillchar-status a'attr, (:w_focused win)) (:w_wincol win) (:w_width win)]
                        [(dec @Rows) (do (reset! a'attr 0) (byte \space)) 0 @Cols])
                  #_final #_int RULER_BUF_LEN 70 #_Bytes s (Bytes. RULER_BUF_LEN)
                  _ (ร .sprintf libC s, (u8 "%ld,"), (if (:ml_empty (:b_ml @curbuf)) 0 (:lnum (:w_cursor win))))
                  #_int n (STRLEN s)
                  _ (col-print (.plus s n), (if empty 0 (inc (:col (:w_cursor win)))), (inc (:w_virtcol win)))
                  ;; Add a "50%" if there is room for it.
                  #_int n (STRLEN s)
                  _ (get-rel-pos win, (.plus s (inc n)), (- RULER_BUF_LEN (inc n)))
                  ;; Don't print at the last column of the last line (scrolls the screen up on some terminals).
                  #_int e (+ n (mb-string2cells (.plus s (inc n))) (if (zero? (:w_status_height win)) 1 0))
                  ;; Never use more than half the window/screen width, leave the other half for the filename.
                  #_int m (max 0 (- @ru_col (- @Cols width))) m (max (/ (inc width) 2) m)]
                (when (< (+ m e) width) ;; need at least 3 chars left for get-rel-pos() + NUL
                    (let [n (loop-when-recur [n n e e] (and (< (+ m e) width) (< (+ n 3 1) RULER_BUF_LEN)) [(+ n (utf-char2bytes fillchar, (.plus s n))) (inc e)] => n)]
                        (get-rel-pos win, (.plus s n), (- RULER_BUF_LEN n))
                    ))
                ;; Truncate at window boundary.
                (loop-when [#_int n 0 #_int i 0] (non-eos? s i) => s
                    (let [n (+ n (us-ptr2cells s, i))]
                        (recur-if (<= (+ m n) width) [n (+ i (us-ptr2len-cc s, i))] => (eos! s i))
                    ))
                (screen-puts s, row, (+ m off), @a'attr)
                (let [_ @redraw_cmdline] ;; don't redraw the cmdline because of showing the ruler
                    (screen-fill row, (inc row), (+ m off (STRLEN s)), (+ off width), fillchar, fillchar, @a'attr)
                    (reset! redraw_cmdline _))
                (assoc win :w_ru_cursor (:w_cursor win)
                           :w_ru_virtcol (:w_virtcol win)
                           :w_ru_topline (:w_topline win)
                           :w_ru_line_count lmax)
                           :w_ru_empty empty
            ))
    ))

;; Return the width of the 'number' and 'relativenumber' column.
;; Caller may need to check if 'number' or 'relativenumber' is set.
;; Otherwise it depends on 'numberwidth' and the line count.

(defn- #_[window_C int] number-width? [#_window_C win]
    (let [wops (:w_options win) nu @(:wo_nu wops) rnu @(:wo_rnu wops) nuw @(:wo_nuw wops)
          ;; cursor line shows "0" ;; cursor line shows absolute line number
          #_long lnum (if (and rnu (not nu)) (:w_height win) (line-count @curbuf))]
        (if (and (== lnum (:w_nrwidth_line_count win)) (== (:w_nuw_cached win) nuw))
            [win (:w_nrwidth_width win)]

            (let [win (assoc win :w_nrwidth_line_count lnum)
                  #_int n (loop [n 0 lnum lnum] (let [n (inc n) lnum (/ lnum 10)] (recur-if (< 0 lnum) [n lnum] => n)))
                  ;; 'numberwidth' gives the minimal width plus one
                  n (max (dec nuw) n)]
                [(assoc win :w_nrwidth_width n :w_nuw_cached nuw) n]
            ))
    ))

;; Return the current cursor column.  This is the actual position on the screen.
;; First column is 0.

(defn- #_int screen-screencol []
    @screen_cur_col)

;; Return the current cursor row.  This is the actual position on the screen.
;; First row is 0.

(defn- #_int screen-screenrow []
    @screen_cur_row)

;;; ============================================================================================== VimW

;; window.c ---------------------------------------------------------------------------------------

;; All CTRL-W window commands are handled here, called from normal-cmd().

(defn- #_window_C do-window [#_window_C win, #_int nchar, #_long Prenum, #_int xchar]
    ;; xchar: extra char from ":wincmd gx" or NUL
    (let [#_long Prenum1 (if (zero? Prenum) 1 Prenum)]
        (condp ==? nchar
            ;; split current window in two parts, horizontally
            [(byte \S) Ctrl_S (byte \s)]
                (when' (zero? @cmdwin_type) => (emsg win, e_cmdwin)
                    (-> win (reset-VIsual-and-resel) (win-split Prenum, 0)))

            ;; split current window in two parts, vertically
            [Ctrl_V (byte \v)]
                (when' (zero? @cmdwin_type) => (emsg win, e_cmdwin)
                    (-> win (reset-VIsual-and-resel) (win-split Prenum, WSP_VERT)))

            ;; quit current window
            [Ctrl_Q (byte \q)]
                (-> win (reset-VIsual-and-resel) (do-cmdline-cmd (cmd-with-count (u8 "quit"), Prenum)))

            ;; close current window
            [Ctrl_C (byte \c)]
                (-> win (reset-VIsual-and-resel) (do-cmdline-cmd (cmd-with-count (u8 "close"), Prenum)))

            ;; close all but current window
            [Ctrl_O (byte \o)]
                (when' (zero? @cmdwin_type) => (emsg win, e_cmdwin)
                    (-> win (reset-VIsual-and-resel) (do-cmdline-cmd (cmd-with-count (u8 "only"), Prenum))))

            ;; cursor to next window with wrap around ;; cursor to previous window with wrap around
            [Ctrl_W (byte \w) (byte \W)]
                (cond (non-zero? @cmdwin_type)
                    (emsg win, e_cmdwin)
                (and (== @firstwin @lastwin) (!= Prenum 1))         ;; just one window
                    (beep-flush win)
                :else
                    (let [#_window_C win'
                            (cond (non-zero? Prenum)                ;; go to specified window
                                (loop-when-recur [win' @firstwin n Prenum] (and (< 1 n) (some? (:w_next win'))) [(:w_next win') (dec n)] => win')
                            (== nchar (byte \W))                    ;; go to previous window
                                (or (:w_prev win) @lastwin)         ;; wrap around
                            :else                                   ;; go to next window
                                (or (:w_next win) @firstwin)        ;; wrap around
                            )]
                        (win-goto win, win')
                    ))

            ;; cursor to window below
            [(byte \j) K_DOWN Ctrl_J]
                (when' (zero? @cmdwin_type) => (emsg win, e_cmdwin)
                    (win-goto-ver win, false, Prenum1))

            ;; cursor to window above
            [(byte \k) K_UP Ctrl_K]
                (when' (zero? @cmdwin_type) => (emsg win, e_cmdwin)
                    (win-goto-ver win, true, Prenum1))

            ;; cursor to left window
            [(byte \h) K_LEFT Ctrl_H K_BS]
                (when' (zero? @cmdwin_type) => (emsg win, e_cmdwin)
                    (win-goto-hor win, true, Prenum1))

            ;; cursor to right window
            [(byte \l) K_RIGHT Ctrl_L]
                (when' (zero? @cmdwin_type) => (emsg win, e_cmdwin)
                    (win-goto-hor win, false, Prenum1))

            ;; cursor to top-left window
            [(byte \t) Ctrl_T]
                (win-goto win, @firstwin)

            ;; cursor to bottom-right window
            [(byte \b) Ctrl_B]
                (win-goto win, @lastwin)

            ;; cursor to last accessed (previous) window
            [(byte \p) Ctrl_P]
                (when' (some? @prevwin) => (beep-flush win)
                    (win-goto win, @prevwin))

            ;; exchange current and next window
            [(byte \x) Ctrl_X]
                (when' (zero? @cmdwin_type) => (emsg win, e_cmdwin)
                    (win-exchange win, Prenum))

            ;; rotate windows downwards
            [Ctrl_R (byte \r)]
                (when' (zero? @cmdwin_type) => (emsg win, e_cmdwin)
                    (-> win (reset-VIsual-and-resel) (win-rotate false, Prenum1)))

            ;; rotate windows upwards
            (byte \R)
                (when' (zero? @cmdwin_type) => (emsg win, e_cmdwin)
                    (-> win (reset-VIsual-and-resel) (win-rotate true, Prenum1)))

            ;; move window to the very top/bottom/left/right
            [(byte \K) (byte \J) (byte \H) (byte \L)]
                (when' (zero? @cmdwin_type) => (emsg win, e_cmdwin)
                    (win-totop win, Prenum, (| (if (any == nchar (byte \H) (byte \L)) WSP_VERT 0) (if (any == nchar (byte \H) (byte \K)) WSP_TOP WSP_BOT))))

            ;; make all windows the same height
            (byte \=)
                (win-equal win, nil, false, (byte \b))

            ;; increase current window height
            (byte \+)
                (win-setheight win, (+ (:w_height win) Prenum1))

            ;; decrease current window height
            (byte \-)
                (win-setheight win, (- (:w_height win) Prenum1))

            ;; set current window height
            [Ctrl__ (byte \_)]
                (win-setheight win, (if (non-zero? Prenum) Prenum 9999))

            ;; increase current window width
            (byte \>)
                (win-setwidth win, (+ (:w_width win) Prenum1))

            ;; decrease current window width
            (byte \<)
                (win-setwidth win, (- (:w_width win) Prenum1))

            ;; set current window width
            (byte \|)
                (win-setwidth win, (if (non-zero? Prenum) Prenum 9999))

            [K_KENTER CAR]
                win

            (beep-flush win)
        )
    ))

(defn- #_Bytes cmd-with-count [#_Bytes cmd, #_long Prenum]
    (let [#_Bytes buf (Bytes. 40)]
        (STRCPY buf, cmd)
        (let-when [#_int len (STRLEN cmd)] (pos? Prenum)
            (ร .sprintf libC (.plus buf len), (u8 "%ld"), Prenum))
        buf
    ))

;; Split the current window.  Implements CTRL-W s and :split.
;;
;; "size" is the height or width for the new window, 0 to use half of current height or width.
;; "flags" are:
;;   WSP_VERT   vertical split.
;;   WSP_TOP    open window at the top-left of the shell (help window).
;;   WSP_BOT    open window at the bottom-right of the shell (quickfix window).
;;
;; Return false for failure, true otherwise.

(defn- #_[window_C boolean] win-split? [#_window_C win, #_int size, #_int flags]
    (if (and (flag? flags WSP_TOP) (flag? flags WSP_BOT))
        [(emsg win, (u8 "E442: Can't split topleft and botright at the same time")) false]
        (win-split-ins? win, size, flags, nil, 0)
    ))

(defn- #_window_C win-split [#_window_C win, #_int size, #_int flags]
    (let [[win _] (win-split? win, size, flags)]
        win
    ))

;; When "win'" is null: split the current window in two.
;; When "win'" is not null: insert this window at the far top/left/right/bottom.
;;
;; Return false for failure, true otherwise.

(defn- #_[window_C boolean] win-split-ins? [#_window_C win, #_int size, #_int flags, #_window_C win', #_int dir]
    (let-when [#_window_C w0 (cond (flag? flags WSP_TOP) @firstwin (flag? flags WSP_BOT) @lastwin :else win)
          ;; add a status line when "p_ls" is 1 and splitting the first window
          [win #_int need_status]
            (when' (and (== @lastwin @firstwin) (== @p_ls 1) (zero? (:w_status_height w0))) => [win 0]
                (when' (or (< @p_wmh (:w_height w0)) (some? win')) => [(emsg win, e_noroom) nil]
                    [win STATUS_HEIGHT]
                ))
    ] (some? need_status) => [win false]

        (let-when [[win [w0 #_int h0 #_int size1 #_boolean do_equal :as _]]
                (cond (flag? flags WSP_VERT)
                    ;; Check if we are able to split the current window and compute its width.
                    ;; Current window requires at least 1 space.
                    (let-when [#_int wmw1 (if (zero? @p_wmw) 1 @p_wmw)
                          [#_int minwidth #_int available]
                            (cond (flag? flags (| WSP_BOT WSP_TOP))
                                [(frame-minwidth @topframe, :NOWIN) (:fr_width @topframe)]
                            @p_ea
                                (let [m (loop-when [#_frame_C f0 (:w_frame w0) m (frame-minwidth f0, :NOWIN) #_frame_C f1 (:fr_parent f0)] (some? f1) => m
                                            (let [m (when' (== (:fr_layout f1) FR_ROW) => m
                                                        (loop-when [m m #_frame_C f2 (:fr_child f1)] (some? f2) => m
                                                            (recur (if (!= f2 f0) (+ m (frame-minwidth f2, :NOWIN)) m) (:fr_next f2)))
                                                    )]
                                                (recur f1 m (:fr_parent f1)))
                                        )]
                                    [m (:fr_width @topframe)])
                            :else
                                (let [#_frame_C f0 (:w_frame w0)]
                                    [(frame-minwidth f0, :NOWIN) (:fr_width f0)]
                                ))
                    ] (or (<= (+ (inc wmw1) minwidth) available) (some? win')) => [(emsg win, e_noroom) nil]

                        (let [size1 (if (zero? size) (/ (:w_width w0) 2) size)
                              size1 (max wmw1 (min size1 (- available minwidth 1)))
                              ;; if it doesn't fit in the current window, need win-equal()
                              do_equal (< (- (:w_width w0) size1 1) @p_wmw)
                              ;; We don't like to take lines for the new window from a 'winfixwidth' window.
                              ;; Take them from a window to the left or right instead, if possible.
                              w0 (when' @(:wo_wfw (:w_options w0)) => w0
                                    (win-setwidth w0, (+ (:w_width w0) size1)))
                              do_equal ;; Only make all windows the same width if one of them (except "w0") is wider than one of the split windows.
                                (when' (and (not do_equal) @p_ea (zero? size) (not-at? @p_ead (byte \v)) (some? (:fr_parent (:w_frame w0)))) => do_equal
                                    (loop-when [#_frame_C f (:fr_child (:fr_parent (:w_frame w0)))] (some? f) => do_equal
                                        (or (and (!= (:fr_win f) w0) (some? (:fr_win f)) (let [w (:w_width (:fr_win f))] (or (< size1 w) (< (- (:w_width w0) size1 1) w))))
                                            (recur (:fr_next f))
                                        ))
                                )]
                            [win [w0 0 size1 do_equal]]
                        ))
                :else
                    ;; Check if we are able to split the current window and compute its height.
                    ;; Current window requires at least 1 space.
                    (let-when [#_int wmh1 (if (zero? @p_wmh) 1 @p_wmh)
                          [#_int minheight #_int available]
                            (cond (flag? flags (| WSP_BOT WSP_TOP))
                                [(+ (frame-minheight @topframe, :NOWIN) need_status) (:fr_height @topframe)]
                            @p_ea
                                (let [m (loop-when [#_frame_C f0 (:w_frame w0) m (+ (frame-minheight f0, :NOWIN) need_status) #_frame_C f1 (:fr_parent f0)] (some? f1) => m
                                            (let [m (when' (== (:fr_layout f1) FR_COL) => m
                                                        (loop-when [m m #_frame_C f2 (:fr_child f1)] (some? f2) => m
                                                            (recur (if (!= f2 f0) (+ m (frame-minheight f2, :NOWIN)) m) (:fr_next f2)))
                                                    )]
                                                (recur f1 m (:fr_parent f1)))
                                        )]
                                    [m (:fr_height @topframe)])
                            :else
                                (let [#_frame_C f0 (:w_frame w0)]
                                    [(+ (frame-minheight f0, :NOWIN) need_status) (:fr_height f0)]
                                ))
                    ] (or (<= (+ (+ wmh1 STATUS_HEIGHT) minheight) available) (some? win')) => [(emsg win, e_noroom) nil]

                        (let [h0 (:w_height w0)
                              [w0 h0]
                                (when' (non-zero? need_status) => [w0 h0]
                                    [(assoc w0 :w_status_height STATUS_HEIGHT) (- h0 STATUS_HEIGHT)])
                              size1 (if (zero? size) (/ h0 2) size)
                              size1 (max wmh1 (min size1 (- available minheight STATUS_HEIGHT)))
                              ;; if it doesn't fit in the current window, need win-equal()
                              do_equal (< (- h0 size1 STATUS_HEIGHT) @p_wmh)
                              ;; We don't like to take lines for the new window from a 'winfixheight' window.
                              ;; Take them from a window above or below instead, if possible.
                              [w0 h0]
                                (when' @(:wo_wfh (:w_options w0)) => [w0 h0]
                                    (let [w0 (win-setheight w0, (+ (:w_height w0) size1 STATUS_HEIGHT)) h0 (:w_height w0)]
                                        [w0 (if (non-zero? need_status) (- h0 STATUS_HEIGHT) h0)]
                                    ))
                              do_equal ;; Only make all windows the same height if one of them (except "w0") is higher than one of the split windows.
                                (when' (and (not do_equal) @p_ea (zero? size) (not-at? @p_ead (byte \h)) (some? (:fr_parent (:w_frame w0)))) => do_equal
                                    (loop-when [#_frame_C f (:fr_child (:fr_parent (:w_frame w0)))] (some? f) => do_equal
                                        (or (and (!= (:fr_win f) w0) (some? (:fr_win f)) (let [h (:w_height (:fr_win f))] (or (< size1 h) (< (- h0 size1 STATUS_HEIGHT) h))))
                                            (recur (:fr_next f))
                                        ))
                                )]
                            [win [w0 h0 size1 do_equal]]
                        ))
                )] (some? _) => [win false]

            ;; allocate new window structure and link it in the window list
            (let [#_window_C after
                    (if (and (non-flag? flags WSP_TOP) (or (flag? flags (| WSP_BOT WSP_BELOW)) (and (non-flag? flags WSP_ABOVE) (if (flag? flags WSP_VERT) @p_spr @p_sb))))
                        w0 (:w_prev w0))
                  #_window_C w1
                    (if (some? win')
                        (win-append win', after)
                        (let [w1 (newWindow after) w1 (assoc w1 :w_frame (newFrame w1))]
                            (win-init w1, win) ;; make the contents of the new window the same as the current one
                        ))
                  ;; Reorganise the tree of frames to insert the new window.
                  [#_frame_C f0 #_boolean before]
                    (if (flag? flags (| WSP_TOP WSP_BOT))
                        (let [f0 (if (or (and (== (:fr_layout @topframe) FR_COL) (non-flag? flags WSP_VERT)) (and (== (:fr_layout @topframe) FR_ROW) (flag? flags WSP_VERT)))
                                    (let-when [f0 (:fr_child @topframe)] (flag? flags WSP_BOT) => f0
                                        (loop-when-recur f0 (some? (:fr_next f0)) (:fr_next f0) => f0))
                                    @topframe
                                )]
                            [f0 (flag? flags WSP_TOP)])
                        [(:w_frame w0) (cond (flag? flags WSP_BELOW) false (flag? flags WSP_ABOVE) true (flag? flags WSP_VERT) (not @p_spr) :else (not @p_sb))])
                  #_byte layout (if (flag? flags WSP_VERT) FR_ROW FR_COL)
                  [w0 f0]
                    (when' (or (nil? (:fr_parent f0)) (!= (:fr_layout (:fr_parent f0)) layout)) => [w0 f0]
                        ;; Need to create a new frame in the tree to make a branch.
                        (let [#_frame_C f1 f0
                              f0 (assoc f0 :fr_layout layout)
                              f1 (assoc f1 :fr_parent f0)
                              f1 (assoc f1 :fr_next nil)
                              f1 (assoc f1 :fr_prev nil)
                              f0 (assoc f0 :fr_child f1)
                              f0 (assoc f0 :fr_win nil)
                              f0 f1]
                            (if (some? (:fr_win f1))
                                [(assoc w0 :w_frame f1) f0]
                                (loop-when [f1 (:fr_child f1)] (some? f1) => [w0 f0]
                                    ((ร f1 =) (assoc f1 :fr_parent f0))
                                    (recur (:fr_next f1))
                                ))
                        ))
                  #_frame_C f1 (:w_frame (if (some? win') win' w1))
                  f1 (assoc f1 :fr_parent (:fr_parent f0))
                  ;; Insert the new frame at the right place in the frame list.
                  f1 (if before
                        (frame-insert f1, f0)
                        (frame-append f1, f0))
                  ;; Set "w_fraction" now so that the cursor keeps the same relative vertical position.
                  w0 (if (< 0 (:w_height w0)) (set-fraction w0) w0)
                  w1 (assoc w1 :w_fraction (:w_fraction w0))
                  [w1 w0 f1 f0]
                    (cond (flag? flags WSP_VERT)
                        (let [_ (reset! (:wo_scr (:w_options w1)) @(:wo_scr (:w_options win)))
                              w0 (when' (non-zero? need_status) => w0
                                    (let [w0 (win-new-height w0, (dec (:w_height w0)))]
                                        (assoc w0 :w_status_height need_status)
                                    ))
                              w1 (if (flag? flags (| WSP_TOP WSP_BOT))
                                    (-> w1 ;; set height and row of new window to full height
                                        (assoc :w_winrow 0)
                                        (win-new-height (- (:fr_height f0) (if (< 0 @p_ls) 1 0)))
                                        (assoc :w_status_height (if (< 0 @p_ls) 1 0))
                                    )
                                    (-> w1 ;; height and row of new window is same as current window
                                        (assoc :w_winrow (:w_winrow w0))
                                        (win-new-height (:w_height w0))
                                        (assoc :w_status_height (:w_status_height w0))
                                    ))
                              f1 (assoc f1 :fr_height (:fr_height f0))
                              ;; "size1" of the current window goes to the new window, use one column for the vertical separator
                              w1 (win-new-width w1, size1)
                              [w1 w0]
                                (if before
                                    [(assoc w1 :w_vsep_width 1) w0]
                                    [(assoc w1 :w_vsep_width (:w_vsep_width w0)) (assoc w0 :w_vsep_width 1)])
                              [f0 w0]
                                (if (flag? flags (| WSP_TOP WSP_BOT))
                                    (let [f0 (if (flag? flags WSP_BOT) (frame-add-vsep f0) f0)]
                                        ;; Set width of neighbor frame.
                                        [(frame-new-width f0, (- (:fr_width f0) (+ size1 (if (flag? flags WSP_TOP) 1 0))), (flag? flags WSP_TOP), false) w0])
                                    [f0 (win-new-width w0, (- (:w_width w0) (inc size1)))])
                              [w1 w0]
                                (if before
                                    [(assoc w1 :w_wincol (:w_wincol w0)) (update w0 :w_wincol + (inc size1))]
                                    [(assoc w1 :w_wincol (+ (:w_wincol w0) (:w_width w0) 1)) w0]
                                )]
                            [(frame-fix-width w1) (frame-fix-width w0) f1 f0])
                    :else
                        (let [w1 (if (flag? flags (| WSP_TOP WSP_BOT))
                                    (-> w1 ;; set width and column of new window to full width
                                        (assoc :w_wincol 0)
                                        (win-new-width @Cols)
                                        (assoc :w_vsep_width 0)
                                    )
                                    (-> w1 ;; width and column of new window is same as current window
                                        (assoc :w_wincol (:w_wincol w0))
                                        (win-new-width (:w_width w0))
                                        (assoc :w_vsep_width (:w_vsep_width w0))
                                    ))
                              f1 (assoc f1 :fr_width (:fr_width f0))
                              ;; "size1" of the current window goes to the new window, use one row for the status line
                              w1 (win-new-height w1, size1)
                              [f0 w0]
                                (if (flag? flags (| WSP_TOP WSP_BOT))
                                    [(frame-new-height f0, (- (:fr_height f0) (+ size1 STATUS_HEIGHT)), (flag? flags WSP_TOP), false) w0]
                                    [f0 (win-new-height w0, (- h0 (+ size1 STATUS_HEIGHT)))])
                              [w1 w0]
                                (if before
                                    (let [w1 (assoc w1 :w_winrow (:w_winrow w0) :w_status_height STATUS_HEIGHT)]
                                        [w1 (update w0 :w_winrow + (:w_height w1) STATUS_HEIGHT)])
                                    (let [w1 (assoc w1 :w_winrow (+ (:w_winrow w0) (:w_height w0) STATUS_HEIGHT) :w_status_height (:w_status_height w0))]
                                        [w1 (assoc w0 :w_status_height STATUS_HEIGHT)]
                                    ))
                              f0 (if (flag? flags WSP_BOT) (frame-add-statusline f0) f0)]
                            [(frame-fix-height w1) (frame-fix-height w0) f1 f0]
                        ))
                  _ (when (flag? flags (| WSP_TOP WSP_BOT))
                        (win-comp-pos))
                  ;; Both windows need redrawing.
                  w1 (-> w1 (redraw-later NOT_VALID) (assoc :w_redr_status true))
                  w0 (-> w0 (redraw-later NOT_VALID) (assoc :w_redr_status true))]
                (when (non-zero? need_status)
                    (reset! msg_row (dec @Rows))
                    (reset! msg_col @sc_col)
                    (msg-clr-eos-force) ;; old command/ruler may still be there
                    (comp-col)
                    (reset! msg_row (dec @Rows))
                    (reset! msg_col 0)  ;; put position back at start of line
                )
                ;; Equalize the window sizes.
                (let [win (when' (or do_equal (non-zero? dir)) => win
                            (win-equal win, w1, true, (if (flag? flags WSP_VERT) (if (== dir (byte \v)) (byte \b) (byte \h)) (if (== dir (byte \h)) (byte \b) (byte \v)))))
                      #_int i ;; Don't change the window height/width to 'winheight'/'winwidth' if a size was given.
                        (if (flag? flags WSP_VERT)
                            (let [i @p_wiw]
                                (when (non-zero? size)
                                    (reset! p_wiw size))
                                i)
                            (let [i @p_wh]
                                (when (non-zero? size)
                                    (reset! p_wh size))
                                i
                            ))
                      ;; Keep same changelist position in new window.
                      w1 (assoc w1 :w_changelistidx (:w_changelistidx w0))
                      ;; Make the new window the current window.
                      win (win-enter win, w1)]
                    (if (flag? flags WSP_VERT)
                        (reset! p_wiw i)
                        (reset! p_wh i))
                    [win true])
            ))
    ))

(defn- #_window_C win-split-ins [#_window_C win, #_int size, #_int flags, #_window_C win', #_int dir]
    (let [[win _] (win-split-ins? win, size, flags, win', dir)]
        win
    ))

;; Initialize window "win" from window "won".
;; Used when splitting a window and when creating a new tab page.
;; The windows will both edit the same buffer.

(defn- #_window_C win-init [#_window_C win, #_window_C won]
    (swap! curbuf update :b_nwindows inc)
    (let [win (assoc win :w_cursor (:w_cursor won)
                         :w_valid 0
                         :w_curswant (:w_curswant won)
                         :w_set_curswant (:w_set_curswant won)
                         :w_topline (:w_topline won)
                         :w_leftcol (:w_leftcol won)
                         :w_pcmark (:w_pcmark won)
                         :w_prev_pcmark (:w_prev_pcmark won)
                         :w_wrow (:w_wrow won)
                         :w_fraction (:w_fraction won)
                         :w_prev_fraction_row (:w_prev_fraction_row won))
          win (copy-jumplist win, won)
          win (win-copy-options win, won)
          [win _] (check-colorcolumn? win)]
        win
    ))

;; Exchange current and next window.

(defn- #_window_C win-exchange [#_window_C win, #_long Prenum]
    (if (== @lastwin @firstwin) ;; just one window
        (beep-flush win)
        ;; Find window to exchange with.
        (let-when [#_frame_C f1
                (cond (non-zero? Prenum)
                    (loop-when-recur [f1 (:fr_child (:fr_parent (:w_frame win))) Prenum (dec Prenum)] (and (some? f1) (< 0 Prenum)) [(:fr_next f1) (dec Prenum)] => f1)
                (some? (:fr_next (:w_frame win)))
                    (:fr_next (:w_frame win)) ;; Swap with next.
                :else
                    (:fr_prev (:w_frame win)) ;; Swap last window in row/col with previous.
                )
              ;; We can only exchange a window with another window, not with a frame containing windows.
        ] (and (some? f1) (some? (:fr_win f1)) (!= (:fr_win f1) win)) => win

            ;; 1. remove "win" from the list, remember after which window it was in "wp2"
            ;; 2. insert "win" before "w1" in the list
            ;; if "w1" != "wp2"
            ;;    3. remove "w1" from the list
            ;;    4. insert "w1" after "wp2"
            ;; 5. exchange the status line height and vsep width
            (let [#_window_C w1 (:fr_win f1) #_window_C w2 (:w_prev win) #_frame_C f2 (:fr_prev (:w_frame win))
                  win (when' (!= (:w_prev w1) win) => win
                        (let [win (win-remove win)
                              _ ((ร (:w_frame win) =) (frame-remove (:w_frame win)))
                              win (win-append win, (:w_prev w1))]
                            ((ร (:w_frame win) =) (frame-insert (:w_frame win), f1))
                            win
                        ))
                  w1 (when' (!= w1 w2) => w1
                        (let [w1 (win-remove w1)
                              _ ((ร (:w_frame w1) =) (frame-remove (:w_frame w1)))
                              w1 (win-append w1, w2)]
                            ((ร (:w_frame w1) =)
                                (if (some? f2)
                                    (frame-append (:w_frame w1), f2)
                                    (frame-insert (:w_frame w1), (:fr_child (:fr_parent (:w_frame w1))))
                                ))
                            w1
                        ))
                  swp- (fn [[x y] z] [(assoc x z (z y)) (assoc y z (z x))])
                  [win w1] (-> [win w1] (swp- :w_status_height) (swp- :w_vsep_width))
                  ;; If the windows are not in the same frame, exchange the sizes to avoid
                  ;; messing up the window layout.  Otherwise fix the frame sizes.
                  fix- #(-> % (frame-fix-height) (frame-fix-width))
                  [win w1]
                    (if (!= (:fr_parent (:w_frame win)) (:fr_parent (:w_frame w1)))
                        (-> [win w1] (swp- :w_height) (swp- :w_width))
                        [(fix- win) (fix- w1)]
                    )]
                (win-comp-pos) ;; recompute window positions
                (-> win (win-enter w1) (redraw-later CLEAR))
            ))
    ))

;; Rotate windows:
;; if upwards true, the second window becomes the first one,
;; if upwards false, the first window becomes the second one.

(defn- #_window_C win-rotate [#_window_C win, #_boolean upwards, #_int count]
    (if (== @firstwin @lastwin) ;; nothing to do
        (beep-flush win)
        ;; Check if all frames in this row/col have one window.
        (let-when [[win ?] (loop-when [#_frame_C fr (:fr_child (:fr_parent (:w_frame win)))] (some? fr) => [win true]
                        (recur-if (some? (:fr_win fr)) [(:fr_next fr)] => [(emsg win, (u8 "E443: Cannot rotate when another window is split")) false])
                    )] ? => win

            (loop-when count (< 0 count)
                (let [[#_window_C w1 #_window_C w2]
                        (if upwards
                            ;; first window becomes last window ;; remove first window/frame from the list
                            (let [#_frame_C fr (:fr_child (:fr_parent (:w_frame win)))
                                  w1 (:fr_win fr)
                                  w1 (win-remove w1)
                                  fr (frame-remove fr)
                                  ;; find last frame and append removed window/frame after it
                                  fr (loop-when-recur fr (some? (:fr_next fr)) (:fr_next fr) => fr)
                                  w1 (win-append w1, (:fr_win fr))]
                                ((ร (:w_frame w1) =) (frame-append (:w_frame w1), fr))
                                [w1 (:fr_win fr)] ;; previously last window
                            )
                            ;; last window becomes first window ;; find last window/frame in the list and remove it
                            (let [#_frame_C fr (loop-when-recur [fr (:w_frame win)] (some? (:fr_next fr)) [(:fr_next fr)] => fr)
                                  w1 (:fr_win fr) w2 (:w_prev w1) ;; will become last window
                                  w1 (win-remove w1)
                                  fr (frame-remove fr)
                                  ;; append the removed window/frame before the first in the list
                                  w1 (win-append w1, (:w_prev (:fr_win (:fr_child (:fr_parent fr)))))]
                                ((ร fr =) (frame-insert fr, (:fr_child (:fr_parent fr))))
                                [w1 w2]
                            ))
                      swp- (fn [[x y] z] [(assoc x z (z y)) (assoc y z (z x))])
                      fix- #(-> % (frame-fix-height) (frame-fix-width))
                      ;; exchange status height and vsep width of old and new last window
                      [w1 w2] (-> [w1 w2] (swp- :w_status_height) (swp- :w_vsep_width))
                      [w1 w2] [(fix- w1) (fix- w2)]]
                    ;; recompute "w_winrow" and "w_wincol" for all windows
                    (win-comp-pos)
                    (recur (dec count))
                ))
            (redraw-later win, CLEAR)
        )
    ))

;; Move the current window to the very top/bottom/left/right of the screen.

(defn- #_window_C win-totop [#_window_C win, #_int size, #_int flags]
    (if (== @lastwin @firstwin)     ;; nothing to do
        (beep-flush win)
        (let [#_int height (:w_height win) a'dir (atom (int))
              ;; Remove the window and frame from the tree of frames.
              _ (winframe-remove' win, a'dir)
              win (win-remove win)
              win (last-status win, false)  ;; may need to remove last status line
              _ (win-comp-pos)              ;; recompute window positions
              ;; Split a window on the desired side and put the window there.
              win (win-split-ins win, size, flags, win, @a'dir)]
            (when' (non-flag? flags WSP_VERT) => win
                (let [win (win-setheight win, height)]
                    (when' @p_ea => win
                        (win-equal win, nil, true, (byte \v))
                    ))
            ))
    ))

;; Make all windows the same height.
;; "win'" will soon be the current window, make sure it has enough rows.

(defn- #_window_C win-equal [#_window_C win, #_window_C win', #_boolean current, #_int dir]
    ;; win': pointer to current window to be or null
    ;; current: do only frame with current window
    ;; dir: 'v' for vertically, 'h' for horizontally, 'b' for both, 0 for using "p_ead"
    (let [dir (if (zero? dir) (.at @p_ead 0) dir)]
        (let [[win _] (win-equal-rec win, (if (nil? win') win win'), current, @topframe, dir, 0, 0, @Cols, (:fr_height @topframe))] (reset! topframe _) win)
    ))

;; Set a frame to a new position and height, spreading the available room equally over contained frames.
;; The window "win'" (if not null) should at least get the size from 'winheight' and 'winwidth' if possible.

(defn- #_[window_C frame_C] win-equal-rec [#_window_C win, #_window_C win', #_boolean current, #_frame_C frame, #_int dir, #_int col, #_int row, #_int width, #_int height]
    ;; win': pointer to current window to be or null
    ;; current: do only frame with current window
    ;; frame: frame to set size off
    ;; dir: 'v', 'h' or 'b', see win-equal()
    ;; col: horizontal position for frame
    ;; row: vertical position for frame
    ;; width: new width of frame
    ;; height: new height of frame
    (condp == (:fr_layout frame)
        FR_LEAF
            (let [frame ;; Set the width/height of this frame, redraw when size or position changes.
                    (when' (or (!= (:fr_height frame) height) (!= (:w_winrow (:fr_win frame)) row) (!= (:fr_width frame) width) (!= (:w_wincol (:fr_win frame)) col)) => frame
                        (let [frame
                                (-> frame
                                    (assoc-in [:fr_win :w_winrow] row) (frame-new-height height, false, false)
                                    (assoc-in [:fr_win :w_wincol] col) (frame-new-width  width,  false, false)
                                )]
                            (redraw-all-later CLEAR)
                            frame)
                    )]
                [win frame])

        FR_ROW
            (let [frame (assoc frame :fr_width width :fr_height height)
                  [#_int extra #_int total #_boolean next? #_int room #_int size1]
                    (when' (!= dir (byte \v)) => [0 0 false 0 0] ;; equalize frame widths
                        ;; Compute the maximum number of windows horizontally in this frame.
                        (let [#_int n (frame-minwidth frame, :NOWIN)
                              ;; Add one for the rightmost window, it doesn't have a separator.
                              extra (if (== (+ col width) @Cols) 1 0)
                              total (/ (+ n extra) (inc @p_wmw))
                              next? (frame-has-win frame, win')
                              ;; Compute width for "win'" window and room available for other windows.
                              ;; "m" is the minimal width when counting "p_wiw" for "win'".
                              #_int m (frame-minwidth frame, win')
                              room (- width m)
                              [total room size1]
                                (if (< room 0)
                                    ;; The room is less then 'winwidth', use all space for the current window.
                                    [total 0 (+ @p_wiw room)]
                                    (let [[total room size1]
                                            (loop-when [total total room room size1 -1 #_frame_C f (:fr_child frame)] (some? f) => [total room size1]
                                                ;; If 'winfixwidth' set, keep the window width, if possible.
                                                ;; Watch out for this window being the "win'".
                                                (let [[total room size1 f]
                                                        (when' (frame-fixed-width f) => [total room size1 f]
                                                            (let [#_int n (frame-minwidth f, :NOWIN)
                                                                  [total room size1 #_int width1]
                                                                    (if (frame-has-win f, win')
                                                                        [total (+ room (- @p_wiw @p_wmw)) 0 (max @p_wiw (:fr_width f))]
                                                                        (let [total (- total (/ (+ n (if (nil? (:fr_next f)) extra 0)) (inc @p_wmw)))]
                                                                            ;; These windows don't use up room.
                                                                            [total room size1 (:fr_width f)]
                                                                        ))
                                                                  room (- room (- width1 n))
                                                                  [width1 room]
                                                                    (when' (< room 0) => [width1 room]
                                                                        [(+ width1 room) 0]
                                                                    )]
                                                                [total room size1 (assoc f :fr_newwidth width1)])
                                                        )]
                                                    (recur total room size1 (:fr_next f))
                                                ))
                                          [size1 room]
                                            (when' (== size1 -1) => [size1 room]
                                                (cond (not next?)
                                                    [0 room]
                                                (and (< 1 total) (< @p_wiw (/ (+ room (- total 2)) (dec total))))
                                                    ;; Can make all windows wider than 'winwidth', spread the room equally.
                                                    (let [size1 (/ (+ room @p_wiw (* (dec total) @p_wmw) (dec total)) total)]
                                                        [size1 (- room (- size1 @p_wiw))])
                                                :else
                                                    [@p_wiw room])
                                            )]
                                        [total room size1])
                                )]
                            [extra (if next? (dec total) total) next? room size1]) ;; don't count "win"
                    )]
                (loop-when [win win col col width width total total room room size1 size1 #_frame_C f (:fr_child frame)] (some? f) => [win frame]
                    (let [[size1 room #_int t' #_int width1]
                            (cond (nil? (:fr_next f))
                                [size1 room 1 width] ;; last frame gets all that remains (avoid roundoff error)
                            (== dir (byte \v))
                                [size1 room 1 (:fr_width f)]
                            (frame-fixed-width f)
                                [size1 room 0 (:fr_newwidth f)] ;; doesn't count as a sizeable window
                            :else
                                ;; Compute the maximum number of horizontal windows in "f".
                                (let [#_int n (frame-minwidth f, :NOWIN)
                                      t' (/ (+ n (if (nil? (:fr_next f)) extra 0)) (inc @p_wmw))
                                      #_int m (frame-minwidth f, win')
                                      ? (and next? (frame-has-win f, win'))
                                      t' (if ? (dec t') t') ;; don't count "win'"
                                      width1 (if (zero? total) room (/ (+ (* t' room) (>>> total 1)) total))
                                      [size1 width1 room]
                                        (when' ? => [size1 width1 (- room width1)] ;; add "win'" size
                                            (let [size1 (- size1 (- @p_wiw (- m n))) width1 (+ width1 size1)]
                                                [size1 width1 (- room (- width1 size1))])
                                        )]
                                    [size1 room t' (+ width1 n)]
                                ))
                          [win f] ;; Skip frame that is full width when splitting or closing a window, unless equalizing all frames.
                            (when' (or (not current) (!= dir (byte \v)) (some? (:fr_parent frame)) (!= width1 (:fr_width f)) (frame-has-win f, win')) => [win f]
                                (win-equal-rec win, win', current, f, dir, col, row, width1, height))]
                        (recur win (+ col width1) (- width width1) (- total t') room size1 (:fr_next f)))
                ))

        FR_COL
            (let [frame (assoc frame :fr_width width :fr_height height)
                  [#_int extra #_int total #_boolean next? #_int room #_int size1]
                    (when' (!= dir (byte \h)) => [0 0 false 0 0] ;; equalize frame heights
                        ;; Compute maximum number of windows vertically in this frame.
                        (let [#_int n (frame-minheight frame, :NOWIN)
                              ;; Add one for the bottom window if it doesn't have a statusline.
                              extra (if (and (== (+ row height) @cmdline_row) (zero? @p_ls)) 1 0)
                              total (/ (+ n extra) (inc @p_wmh))
                              next? (frame-has-win frame, win')
                              ;; Compute height for "win'" window and room available for other windows.
                              ;; "m" is the minimal height when counting "p_wh" for "win'".
                              #_int m (frame-minheight frame, win')
                              room (- height m)
                              [total room size1]
                                (if (< room 0)
                                    ;; The room is less then 'winheight', use all space for the current window.
                                    [total 0 (+ @p_wh room)]
                                    (let [[total room size1]
                                            (loop-when [total total room room size1 -1 #_frame_C f (:fr_child frame)] (some? f) => [total room size1]
                                                ;; If 'winfixheight' set, keep the window height, if possible.
                                                ;; Watch out for this window being the "win'".
                                                (let [[total room size1 f]
                                                        (when' (frame-fixed-height f) => [total room size1 f]
                                                            (let [#_int n (frame-minheight f, :NOWIN)
                                                                  [total room size1 #_int height1]
                                                                    (if (frame-has-win f, win')
                                                                        [total (+ room (- @p_wh @p_wmh)) 0 (max @p_wh (:fr_height f))]
                                                                        (let [total (- total (/ (+ n (if (nil? (:fr_next f)) extra 0)) (inc @p_wmh)))]
                                                                            ;; These windows don't use up room.
                                                                            [total room size1 (:fr_height f)]
                                                                        ))
                                                                  room (- room (- height1 n))
                                                                  [height1 room]
                                                                    (when' (< room 0) => [height1 room]
                                                                        [(+ height1 room) 0]
                                                                    )]
                                                                [total room size1 (assoc f :fr_newheight height1)])
                                                        )]
                                                    (recur total room size1 (:fr_next f))
                                                ))
                                          [size1 room]
                                            (when' (== size1 -1) => [size1 room]
                                                (cond (not next?)
                                                    [0 room]
                                                (and (< 1 total) (< @p_wh (/ (+ room (- total 2)) (dec total))))
                                                    ;; Can make all windows higher than 'winheight', spread the room equally.
                                                    (let [size1 (/ (+ room @p_wh (* (dec total) @p_wmh) (dec total)) total)]
                                                        [size1 (- room (- size1 @p_wh))])
                                                :else
                                                    [@p_wh room])
                                            )]
                                        [total room size1])
                                )]
                            [extra (if next? (dec total) total) next? room size1]) ;; don't count "win"
                    )]
                (loop-when [win win row row height height total total room room size1 size1 #_frame_C f (:fr_child frame)] (some? f) => [win frame]
                    (let [[size1 room #_int t' #_int height1]
                            (cond (nil? (:fr_next f))
                                [size1 room 1 height] ;; last frame gets all that remains (avoid roundoff error)
                            (== dir (byte \h))
                                [size1 room 1 (:fr_height f)]
                            (frame-fixed-height f)
                                [size1 room 0 (:fr_newheight f)] ;; doesn't count as a sizeable window
                            :else
                                ;; Compute the maximum number of vertical windows in "f".
                                (let [#_int n (frame-minheight f, :NOWIN)
                                      t' (/ (+ n (if (nil? (:fr_next f)) extra 0)) (inc @p_wmh))
                                      #_int m (frame-minheight f, win')
                                      ? (and next? (frame-has-win f, win'))
                                      t' (if ? (dec t') t') ;; don't count "win'"
                                      height1 (if (zero? total) room (/ (+ (* t' room) (>>> total 1)) total))
                                      [size1 height1 room]
                                        (when' ? => [size1 height1 (- room height1)] ;; add "win'" size
                                            (let [size1 (- size1 (- @p_wh (- m n))) height1 (+ height1 size1)]
                                                [size1 height1 (- room (- height1 size1))])
                                        )]
                                    [size1 room t' (+ height1 n)]
                                ))
                          [win f] ;; Skip frame that is full height when splitting or closing a window, unless equalizing all frames.
                            (when' (or (not current) (!= dir (byte \h)) (some? (:fr_parent frame)) (!= height1 (:fr_height f)) (frame-has-win f, win')) => [win f]
                                (win-equal-rec win, win', current, f, dir, col, row, width, height1))]
                        (recur win (+ row height1) (- height height1) (- total t') room size1 (:fr_next f)))
                ))
    ))

;; Return true if there is only one window.

(defn- #_boolean one-window []
    (loop-when [? false #_window_C w @firstwin] (some? w) => true
        (recur-if (not ?) [true (:w_next w)] => false)
    ))

;; Close window "win'".
;; If "_unload" is true, related buffer may be unloaded.
;;
;; Returns false when the window was not closed.

(defn- #_[window_C boolean] win-close? [#_window_C win, #_window_C win', #_boolean _unload]
    (cond (one-window)
        [(emsg win, (u8 "E444: Cannot close last window")) false]
    (== @firstwin @lastwin)
        [win false]
    :else
        (let [? (:w_focused win')
              ;; Close the link to the buffer.
              _ (close-buffer win')
              ;; Free the memory used for the window and get the window that received the screen space.
              a'dir (atom (int)) win' (win-free-mem win', a'dir)
              ;; Make sure "curwin" isn't invalid.
              ;; It can cause severe trouble when printing an error message.
              ;; For win-equal() "curbuf" needs to be valid too.
              win (if ? win' win)
              win (when' (and @p_ea (any == (.at @p_ead 0) (byte \b) @a'dir)) => (do (win-comp-pos) win)
                    (win-equal win, nil, true, @a'dir))
              win (if ? (win-enter-ext win, win', true) win)
              ;; If last window has a status line now and we don't want one, remove the status line.
              win (last-status win, false)]
            (redraw-all-later NOT_VALID)
            [win true])
    ))

;; Free the memory used for a window.
;; Returns a pointer to the window that got the freed up space.

(defn- #_window_C win-free-mem [#_window_C win, #_int' a'dir] ;; dir: set to 'v' or 'h' for direction if 'ea'
    ;; Remove the window and its frame from the tree of frames.
    (let [#_window_C w (winframe-remove' win, a'dir)] (win-free win) w))

;; Remove a window and its frame from the tree of frames.
;; Returns a pointer to the window that got the freed up space.

(defn- #_window_C winframe-remove' [#_window_C win, #_int' a'dir] ;; dir: set to 'v' or 'h' for direction if 'ea'
    ;; If there is only one window, there is nothing to remove.
    (when-not (== @firstwin @lastwin)
        (let [#_frame_C f1 (:w_frame win)
              ;; Remove the window from its frame.
              #_frame_C f2 (win-altframe win)
              #_window_C w2 (frame2win f2)
              ;; Remove this frame from the list of frames.
              f1 (frame-remove f1)
              [f2 w2]
                (cond (== (:fr_layout (:fr_parent f1)) FR_COL)
                    ;; When 'winfixheight' is set, try to find another frame in the column
                    ;; (as close to the closed frame as possible) to distribute the height to.
                    (let [[f2 w2]
                            (when' (and (some? (:fr_win f2)) @(:wo_wfh (:w_options (:fr_win f2)))) => [f2 w2]
                                (loop-when [#_frame_C f0 (:fr_prev f1) #_frame_C f3 (:fr_next f1)] (or (some? f0) (some? f3)) => [f2 w2]
                                    (let-when [[f0 ?]
                                            (when' (some? f0) => [f0 nil]
                                                (if (and (some? (:fr_win f0)) (not @(:wo_wfh (:w_options (:fr_win f0))))) [f0 :found] [(:fr_prev f0) nil])
                                            )] (not ?) => [f0 (:fr_win f0)]

                                        (let-when [[f3 ?]
                                                (when' (some? f3) => [f3 nil]
                                                    (if (and (some? (:fr_win f3)) (not @(:wo_wfh (:w_options (:fr_win f3))))) [f3 :found] [(:fr_next f3) nil])
                                                )] (not ?) => [f3 (:fr_win f3)]

                                            (recur f0 f3))
                                    ))
                            )]
                        (reset! a'dir (byte \v))
                        [(frame-new-height f2, (+ (:fr_height f2) (:fr_height f1)), (== f2 (:fr_next f1)), false) w2]
                    )
                :else
                    ;; When 'winfixwidth' is set, try to find another frame in the column
                    ;; (as close to the closed frame as possible) to distribute the width to.
                    (let [[f2 w2]
                            (when' (and (some? (:fr_win f2)) @(:wo_wfw (:w_options (:fr_win f2)))) => [f2 w2]
                                (loop-when [#_frame_C f0 (:fr_prev f1) #_frame_C f3 (:fr_next f1)] (or (some? f0) (some? f3)) => [f2 w2]
                                    (let-when [[f0 ?]
                                            (when' (some? f0) => [f0 nil]
                                                (if (and (some? (:fr_win f0)) (not @(:wo_wfw (:w_options (:fr_win f0))))) [f0 :found] [(:fr_prev f0) nil])
                                            )] (not ?) => [f0 (:fr_win f0)]

                                        (let-when [[f3 ?]
                                                (when' (some? f3) => [f3 nil]
                                                    (if (and (some? (:fr_win f3)) (not @(:wo_wfw (:w_options (:fr_win f3))))) [f3 :found] [(:fr_next f3) nil])
                                                )] (not ?) => [f3 (:fr_win f3)]

                                            (recur f0 f3))
                                    ))
                            )]
                        (reset! a'dir (byte \h))
                        [(frame-new-width f2, (+ (:fr_width f2) (:fr_width f1)), (== f2 (:fr_next f1)), false) w2]
                    ))
              ;; If rows/columns go to a window below/right, its positions need to be updated.
              ;; Can only be done after the sizes have been updated.
              f2 (when' (== f2 (:fr_next f1)) => f2
                    (let [a'row (atom (int (:w_winrow win))) a'col (atom (int (:w_wincol win)))]
                        (frame-comp-pos f2, a'row, a'col))
                )]
            (when' (and (nil? (:fr_next f2)) (nil? (:fr_prev f2))) => w2
                ;; There is no other frame in this list, move its info to the parent and remove it.
                (let [f2 (update f2 :fr_parent assoc :fr_layout (:fr_layout f2) :fr_child (:fr_child f2))
                      _ (loop-when [#_frame_C f0 (:fr_child f2)] (some? f0)
                            (let [f0 (assoc f0 :fr_parent (:fr_parent f2))]
                                (recur (:fr_next f0))
                            ))
                      f2 (assoc-in f2 [:fr_parent :fr_win] (:fr_win f2))
                      f2 (if (some? (:fr_win f2)) (assoc-in f2 [:fr_win :w_frame] (:fr_parent f2)) f2)
                      #_frame_C f0 (:fr_parent f2)
                      f2 (:fr_parent f0)]
                    (when' (and (some? f2) (== (:fr_layout f2) (:fr_layout f0))) => w2
                        ;; The frame above the parent has the same layout, have to merge the frames into this list.
                        (let [f2 (if (== (:fr_child f2) f0) (assoc f2 :fr_child (:fr_child f0)) f2)
                              f0 (assoc-in f0 [:fr_child :fr_prev] (:fr_prev f0))
                              f0 (if (some? (:fr_prev f0)) (assoc-in f0 [:fr_prev :fr_next] (:fr_child f0)) f0)
                              f0 (loop [#_frame_C f3 (:fr_child f0)]
                                    (let-when [f3 (assoc f3 :fr_parent f2)] (nil? (:fr_next f3)) => (recur (:fr_next f3))
                                        (let [f3 (assoc f3 :fr_next (:fr_next f0))]
                                            (if (some? (:fr_next f0)) (assoc-in f0 [:fr_next :fr_prev] f3) f0)
                                        ))
                                )]
                            w2)
                    ))
            ))
    ))

;; Find out which frame is going to get the freed up space when "win" is closed.
;; if 'splitbelow'/'splitleft' the space goes to the window above/left.
;; if 'nosplitbelow'/'nosplitleft' the space goes to the window below/right.
;; This makes opening a window and closing it immediately keep the same window layout.

(defn- #_frame_C win-altframe [#_window_C win]
    (if (== @firstwin @lastwin)
        (:w_frame @curwin)
        (let [#_frame_C fr (:w_frame win)
              ? (if (and (some? (:fr_parent fr)) (== (:fr_layout (:fr_parent fr)) FR_ROW)) @p_spr @p_sb)]
            (if (or (and (not ?) (some? (:fr_next fr))) (nil? (:fr_prev fr)))
                (:fr_next fr)
                (:fr_prev fr)
            ))
    ))

;; Find the left-upper window in frame "fr".

(defn- #_window_C frame2win [#_frame_C fr]
    (loop-when-recur fr (nil? (:fr_win fr)) (:fr_child fr) => (:fr_win fr)))

;; Return true if frame "fr" contains window "win".

(defn- #_boolean frame-has-win [#_frame_C fr, #_window_C win]
    (if (== (:fr_layout fr) FR_LEAF)
        (== (:fr_win fr) win)
        (loop-when [fr (:fr_child fr)] (some? fr) => false
            (recur-if (not (frame-has-win fr, win)) [(:fr_next fr)] => true)
        )
    ))

;; Set a new height for a frame.
;; Recursively sets the height for contained frames and windows.
;; Caller must take care of positions.

(defn- #_frame_C frame-new-height [#_frame_C frame, #_int height, #_boolean topfirst, #_boolean wfh]
    ;; topfirst: resize topmost contained frame first
    ;; wfh: obey 'winfixheight' when there is a choice; may cause the height not to be set
    (let-when [[frame height ?]
            (cond (some? (:fr_win frame)) ;; Simple case: just one window.
                [(assoc frame :fr_win (win-new-height (:fr_win frame), (- height (:w_status_height (:fr_win frame))))) height nil]

            (== (:fr_layout frame) FR_ROW)
                (let [height ;; All frames in this row get the same new height.
                        (loop [height height]
                            (let [[#_frame_C f height]
                                    (loop-when [f (:fr_child frame)] (some? f) => [f height]
                                        (let [f (frame-new-height f, height, topfirst, wfh)]
                                            ;; If could not fit the windows, make the whole row higher.
                                            (recur-if (<= (:fr_height f) height) [(:fr_next f)] => [f (:fr_height f)]))
                                    )]
                                (recur-if (some? f) [height] => height))
                        )]
                    [frame height nil])

            :else ;; (== (:fr_layout frame) FR_COL)
                ;; Complicated case: resize a column of frames.
                ;; Resize the bottom frame first, then the frames above, when needed.
                (let-when [#_frame_C f (:fr_child frame)
                      f (when' wfh => f
                            ;; Advance past frames with one window with 'wfh' set.
                            (loop-when f (frame-fixed-height f) => f
                                (recur-if (some? (:fr_next f)) (:fr_next f) => nil) ;; no frame without 'wfh', give up
                            ))
                ] (some? f) => [frame height :abort]

                    (let [f (when' (not topfirst) => f
                                ;; Find the bottom frame of this column.
                                (let [f (loop-when-recur f (some? (:fr_next f)) (:fr_next f) => f)]
                                    (when' wfh => f
                                        ;; Advance back for frames with one window with 'wfh' set.
                                        (loop-when-recur f (frame-fixed-height f) (:fr_prev f) => f))
                                ))
                          #_int delta (- height (:fr_height frame))]
                        (cond (< delta 0)
                            (let [[f height] ;; Reduce height of contained frames, bottom or top frame first.
                                    (loop-when [f f delta delta height height] (some? f) => [f height]
                                        (let-when [#_int h' (frame-minheight f, nil)
                                              [delta f]
                                                (if (< (+ (:fr_height f) delta) h')
                                                    [(+ delta (- (:fr_height f) h')) (frame-new-height f, h', topfirst, wfh)]
                                                    [nil (frame-new-height f, (+ (:fr_height f) delta), topfirst, wfh)])
                                        ] (some? delta) => [f height]

                                            (let [f (if topfirst
                                                        (loop-when-recur [f (:fr_next f)] (and wfh (some? f) (frame-fixed-height f)) [(:fr_next f)] => f)
                                                        (loop-when-recur [f (:fr_prev f)] (and wfh (some? f) (frame-fixed-height f)) [(:fr_prev f)] => f)
                                                    )]
                                                ;; Increase "height" if we could not reduce enough frames.
                                                (recur f delta (if (nil? f) (- height delta) height))
                                            ))
                                    )]
                                [frame height nil])
                        (< 0 delta)
                            ;; Increase height of bottom or top frame.
                            (let [f (frame-new-height f, (+ (:fr_height f) delta), topfirst, wfh)]
                                [frame height nil])
                        :else
                            [frame height nil])
                    ))
            )] (not ?) => frame

        (assoc frame :fr_height height)
    ))

;; Return true if height of frame "fr" should not be changed because of the 'winfixheight' option.

(defn- #_boolean frame-fixed-height [#_frame_C fr]
    (cond (some? (:fr_win fr))
        ;; Frame with one window: fixed height if 'winfixheight' set.
        @(:wo_wfh (:w_options (:fr_win fr)))
    (== (:fr_layout fr) FR_ROW)
        (loop-when [fr (:fr_child fr)] (some? fr) => false
            ;; The frame is fixed height if one of the frames in the row is fixed height.
            (recur-if (not (frame-fixed-height fr)) [(:fr_next fr)] => true))
    :else ;; (== (:fr_layout fr) FR_COL)
        (loop-when [fr (:fr_child fr)] (some? fr) => true
            ;; The frame is fixed height if all of the frames in the row are fixed height.
            (recur-if (frame-fixed-height fr) [(:fr_next fr)] => false))
    ))

;; Return true if width of frame "fr" should not be changed because of the 'winfixwidth' option.

(defn- #_boolean frame-fixed-width [#_frame_C fr]
    (cond (some? (:fr_win fr))
        ;; Frame with one window: fixed width if 'winfixwidth' set.
        @(:wo_wfw (:w_options (:fr_win fr)))
    (== (:fr_layout fr) FR_COL)
        (loop-when [fr (:fr_child fr)] (some? fr) => false
            ;; The frame is fixed width if one of the frames in the row is fixed width.
            (recur-if (not (frame-fixed-width fr)) [(:fr_next fr)] => true))
    :else ;; (== (:fr_layout fr) FR_ROW)
        (loop-when [fr (:fr_child fr)] (some? fr) => true
            ;; The frame is fixed width if all of the frames in the row are fixed width.
            (recur-if (frame-fixed-width fr) [(:fr_next fr)] => false))
    ))

;; Add a status line to windows at the bottom of "frame".
;; Note: Does not check if there is room!

(defn- #_frame_C frame-add-statusline [#_frame_C frame]
    (condp == (:fr_layout frame)
        FR_LEAF
            (let [#_window_C win (:fr_win frame)
                  win (when' (zero? (:w_status_height win)) => win
                        (let [win (if (< 0 (:w_height win)) (update win :w_height dec) win)] ;; don't make it negative
                            (assoc win :w_status_height STATUS_HEIGHT))
                    )]
                frame)
        FR_ROW
            (do ;; Handle all the frames in the row.
                (loop-when [#_frame_C f (:fr_child frame)] (some? f)
                    (let [f (frame-add-statusline f)]
                        (recur (:fr_next f))
                    ))
                frame)
        FR_COL
            ;; Only need to handle the last frame in the column.
            (let [#_frame_C f (loop-when-recur [f (:fr_child frame)] (some? (:fr_next f)) [(:fr_next f)] => f)
                  f (frame-add-statusline f)]
                frame)
    ))

;; Set width of a frame.  Handles recursively going through contained frames.
;; May remove separator line for windows at the right side (for win-close()).

(defn- #_frame_C frame-new-width [#_frame_C frame, #_int width, #_boolean leftfirst, #_boolean wfw]
    ;; leftfirst: resize leftmost contained frame first
    ;; wfw: obey 'winfixwidth' when there is a choice; may cause the width not to be set
    (let-when [[frame width ?]
            (cond (== (:fr_layout frame) FR_LEAF) ;; Simple case: just one window.
                (let [#_frame_C f ;; Find out if there are any windows right of this one.
                        (loop-when [f frame] (some? (:fr_parent f)) => f
                            (if (and (== (:fr_layout (:fr_parent f)) FR_ROW) (some? (:fr_next f))) f (recur (:fr_parent f))))
                      #_window_C win (:fr_win frame)
                      win (if (nil? (:fr_parent f)) (assoc win :w_vsep_width 0) win)]
                    ((ร win =) (win-new-width win, (- width (:w_vsep_width win))))
                    [frame width nil])

            (== (:fr_layout frame) FR_COL)
                (let [width ;; All frames in this column get the same new width.
                        (loop [width width]
                            (let [[#_frame_C f width]
                                    (loop-when [f (:fr_child frame)] (some? f) => [f width]
                                        (let [f (frame-new-width f, width, leftfirst, wfw)]
                                            ;; If could not fit the windows, make the whole column wider.
                                            (recur-if (<= (:fr_width f) width) [(:fr_next f)] => [f (:fr_width f)]))
                                    )]
                                (recur-if (some? f) [width] => width))
                        )]
                    [frame width nil])

            :else ;; (== (:fr_layout frame) FR_ROW)
                ;; Complicated case: resize a row of frames.
                ;; Resize the rightmost frame first, then the frames left of it, when needed.
                (let-when [#_frame_C f (:fr_child frame)
                      f (when' wfw => f
                            ;; Advance past frames with one window with 'wfw' set.
                            (loop-when f (frame-fixed-width f) => f
                                (recur-if (some? (:fr_next f)) (:fr_next f) => nil) ;; no frame without 'wfw', give up
                            ))
                ] (some? f) => [frame width :abort]

                    (let [f (when' (not leftfirst) => f
                                ;; Find the rightmost frame of this row.
                                (let [f (loop-when-recur f (some? (:fr_next f)) (:fr_next f) => f)]
                                    (when' wfw => f
                                        ;; Advance back for frames with one window with 'wfw' set.
                                        (loop-when-recur f (frame-fixed-width f) (:fr_prev f) => f))
                                ))
                          #_int delta (- width (:fr_width frame))]
                        (cond (< delta 0)
                            (let [[f width] ;; Reduce frame width, rightmost frame first.
                                    (loop-when [f f delta delta width width] (some? f) => [f width]
                                        (let-when [#_int w' (frame-minwidth f, nil)
                                              [delta f]
                                                (if (< (+ (:fr_width f) delta) w')
                                                    [(+ delta (- (:fr_width f) w')) (frame-new-width f, w', leftfirst, wfw)]
                                                    [nil (frame-new-width f, (+ (:fr_width f) delta), leftfirst, wfw)])
                                        ] (some? delta) => [f width]

                                            (let [f (if leftfirst
                                                        (loop-when-recur [f (:fr_next f)] (and wfw (some? f) (frame-fixed-width f)) [(:fr_next f)] => f)
                                                        (loop-when-recur [f (:fr_prev f)] (and wfw (some? f) (frame-fixed-width f)) [(:fr_prev f)] => f)
                                                    )]
                                                ;; Increase "width" if we could not reduce enough frames.
                                                (recur f delta (if (nil? f) (- width delta) width))
                                            ))
                                    )]
                                [frame width nil])
                        (< 0 delta)
                            ;; Increase width of rightmost frame.
                            (let [f (frame-new-width f, (+ (:fr_width f) delta), leftfirst, wfw)]
                                [frame width nil])
                        :else
                            [frame width nil])
                    ))
            )] (not ?) => frame

        (assoc frame :fr_width width)
    ))

;; Add the vertical separator to windows at the right side of "frame".
;; Note: Does not check if there is room!

(defn- #_frame_C frame-add-vsep [#_frame_C frame]
    (condp == (:fr_layout frame)
        FR_LEAF
            (let [#_window_C win (:fr_win frame)
                  win (when' (zero? (:w_vsep_width win)) => win
                        (let [win (if (< 0 (:w_width win)) (update win :w_width dec) win)] ;; don't make it negative
                            (assoc win :w_vsep_width 1))
                    )]
                frame)
        FR_COL
            (do ;; Handle all the frames in the column.
                (loop-when [#_frame_C f (:fr_child frame)] (some? f)
                    (let [f (frame-add-vsep f)]
                        (recur (:fr_next f))
                    ))
                frame)
        FR_ROW
            ;; Only need to handle the last frame in the row.
            (let [#_frame_C f (loop-when-recur [f (:fr_child frame)] (some? (:fr_next f)) [(:fr_next f)] => f)
                  f (frame-add-vsep f)]
                frame)
    ))

;; Set frame width from the window it contains.

(defn- #_window_C frame-fix-width [#_window_C win]
    (assoc-in win [:w_frame :fr_width] (+ (:w_width win) (:w_vsep_width win))))

;; Set frame height from the window it contains.

(defn- #_window_C frame-fix-height [#_window_C win]
    (assoc-in win [:w_frame :fr_height] (+ (:w_height win) (:w_status_height win))))

;; Compute the minimal height for frame "frame".
;; Uses the 'winminheight' option.
;; When "win'" isn't null, use "p_wh" for this window.
;; When "win'" is NOWIN, don't use at least one line for the current window.

(defn- #_int frame-minheight [#_frame_C frame, #_window_C win']
    (cond (some? (:fr_win frame))
        (if (== (:fr_win frame) win')
            (+ @p_wh (:w_status_height (:fr_win frame)))
            (let [m (+ @p_wmh (:w_status_height (:fr_win frame)))] ;; window: minimal height of the window plus status line
                (if (and (zero? @p_wmh) (:w_focused (:fr_win frame)) (nil? win')) (inc m) m) ;; current window is minimal one line high
            ))
    (== (:fr_layout frame) FR_ROW) ;; get the minimal height from each frame in this row
        (loop-when-recur [m 0 fr (:fr_child frame)] (some? fr) [(max (frame-minheight fr, win') m) (:fr_next fr)] => m)
    :else                          ;; add up the minimal heights for all frames in this column
        (loop-when-recur [m 0 fr (:fr_child frame)] (some? fr) [(+ m (frame-minheight fr, win')) (:fr_next fr)] => m)
    ))

;; Compute the minimal width for frame "frame".
;; When "win'" isn't null, use "p_wiw" for this window.
;; When "win'" is NOWIN, don't use at least one column for the current window.

(defn- #_int frame-minwidth [#_frame_C frame, #_window_C win'] ;; win': use "p_wh" and "p_wiw" for win'
    (cond (some? (:fr_win frame))
        (if (== (:fr_win frame) win')
            (+ @p_wiw (:w_vsep_width (:fr_win frame)))
            (let [m (+ @p_wmw (:w_vsep_width (:fr_win frame)))] ;; window: minimal width of the window plus separator column
                (if (and (zero? @p_wmw) (:w_focused (:fr_win frame)) (nil? win')) (inc m) m) ;; current window is minimal one column wide
            ))
    (== (:fr_layout frame) FR_COL) ;; get the minimal width from each frame in this column
        (loop-when-recur [m 0 fr (:fr_child frame)] (some? fr) [(max (frame-minwidth fr, win') m) (:fr_next fr)] => m)
    :else                          ;; add up the minimal widths for all frames in this row
        (loop-when-recur [m 0 fr (:fr_child frame)] (some? fr) [(+ m (frame-minwidth fr, win')) (:fr_next fr)] => m)
    ))

;; Try to close all windows, except "win".

(defn- #_window_C close-others [#_window_C win, #_boolean message, #_boolean forceit]
    ;; forceit: always hide all other windows
    (when' (not (one-window)) => (if message (msg win, (u8 "Already only one window")) win)
        (loop-when [#_window_C w @firstwin] (some? w)
            (let-when [#_window_C w' (:w_next w)] (!= w win) ;; don't close current window
                ;; Check if it's allowed to abandon this window.
                (let-when [changed @(:b_changed @curbuf)] (or (not changed) (< 1 (:b_nwindows @curbuf)) forceit)
                    ((ร win =) (win-close? win, w, (not changed))))
                (recur w')
            ))
        (when' (and message (!= @lastwin @firstwin)) => win
            (emsg win, (u8 "E445: Other window contains changes")))
    ))

;; Create a frame for window "win".

(defn- #_frame_C newFrame [#_window_C win]
    (assoc (NEW_frame_C) :fr_layout FR_LEAF :fr_win win))

;; Initialize the window and frame size to the maximum.

(defn- #_void win-init-size []
    (let [rows (- @Rows @p_ch) cols @Cols]
        (swap! firstwin assoc :w_height rows :w_width cols)
        (swap! topframe assoc :fr_height rows :fr_width cols))
    nil)

;; Go to another window.
;; When jumping to another buffer, stop Visual mode.
;; Do this before changing windows, so we can yank the selection into the '*' register.
;; When jumping to another window on the same buffer, adjust its cursor position to keep the same Visual area.

(defn- #_window_C win-goto [#_window_C win, #_window_C win']
    (if (text-locked)
        (-> win (text-locked-msg)
            (beep-flush))
        (let [win' (if @VIsual_active (assoc win' :w_cursor (:w_cursor win)) win')]
            (win-enter win, win'))
    ))

;; Move to window above or below "count" times.

(defn- #_window_C win-goto-ver [#_window_C win, #_boolean up, #_long count]
    (let [#_frame_C f0
            (loop-when [f0 (:w_frame win) count count] (< 0 count) => f0
                ;; First go upwards in the tree of frames until we find an upwards or downwards neighbor.
                (let-when [#_frame_C f1
                        (loop-when [#_frame_C f f0] (!= f @topframe) => nil
                            (let [f1 (if up (:fr_prev f) (:fr_next f))]
                                (if (and (== (:fr_layout (:fr_parent f)) FR_COL) (some? f1))
                                    f1
                                    (recur (:fr_parent f))
                                )))
                ] (some? f1) => f0

                    ;; Now go downwards to find the bottom or top frame in it.
                    (let [f0 (loop-when f1 (!= (:fr_layout f1) FR_LEAF) => f1
                                (let [#_frame_C f (:fr_child f1)
                                      f (when' (== (:fr_layout f1) FR_ROW) => f
                                            (loop-when-recur f ;; Find the frame at the cursor row.
                                                             (and (some? (:fr_next f)) (<= (+ (:w_wincol (frame2win f)) (:fr_width f)) (+ (:w_wincol win) (:w_wcol win))))
                                                             (:fr_next f)
                                                          => f)
                                        )]
                                    (recur (if (and (== (:fr_layout f1) FR_COL) up) (loop-when-recur f (some? (:fr_next f)) (:fr_next f) => f) f)))
                            )]
                        (recur f0 (dec count))
                    ))
            )]
        (when' (some? f0) => win
            (win-goto win, (:fr_win f0)))
    ))

;; Move to window left or right "count" times.

(defn- #_window_C win-goto-hor [#_window_C win, #_boolean left, #_long count]
    (let [#_frame_C f0
            (loop-when [f0 (:w_frame win) count count] (< 0 count) => f0
                ;; First go upwards in the tree of frames until we find a left or right neighbor.
                (let-when [#_frame_C f1
                        (loop-when [#_frame_C f f0] (!= f @topframe) => nil
                            (let [f1 (if left (:fr_prev f) (:fr_next f))]
                                (if (and (== (:fr_layout (:fr_parent f)) FR_ROW) (some? f1))
                                    f1
                                    (recur (:fr_parent f))
                                )))
                ] (some? f1) => f0

                    ;; Now go downwards to find the leftmost or rightmost frame in it.
                    (let [f0 (loop-when f1 (!= (:fr_layout f1) FR_LEAF) => f1
                                (let [#_frame_C f (:fr_child f1)
                                      f (when' (== (:fr_layout f1) FR_COL) => f
                                            (loop-when-recur f ;; Find the frame at the cursor row.
                                                             (and (some? (:fr_next f)) (<= (+ (:w_winrow (frame2win f)) (:fr_height f)) (+ (:w_winrow win) (:w_wrow win))))
                                                             (:fr_next f)
                                                          => f)
                                        )]
                                    (recur (if (and (== (:fr_layout f1) FR_ROW) left) (loop-when-recur f (some? (:fr_next f)) (:fr_next f) => f) f)))
                            )]
                        (recur f0 (dec count))
                    ))
            )]
        (when' (some? f0) => win
            (win-goto win, (:fr_win f0)))
    ))

;; Make window "win'" the current window.

(defn- #_window_C win-enter [#_window_C win, #_window_C win']
    (win-enter-ext win, win', false))

;; Make window "win'" the current window.
;; Can be called with "invalid?" true, which means that "curwin" has just been closed and isn't valid.

(defn- #_window_C win-enter-ext [#_window_C win, #_window_C win', #_boolean invalid?]
    (when' (or (!= win' win) invalid?) => win
        ;; Might need to scroll the old window before switching, e.g. when the cursor was moved.
        (let [win (update-topline win)
              win (when' (not invalid?) => win
                    (reset! prevwin win)                    ;; remember for CTRL-W p
                    (assoc win :w_redr_status true))

              win (assoc win :w_focused false)
              win (ยง reset! curwin win')
              win (assoc win :w_focused true)

              win (check-cursor win)
              win (when' (not (virtual-active)) => win
                    (assoc-in win [:w_cursor :coladd] 0))
              win (changed-line-abv-curs win)               ;; assume cursor position needs updating
              win (assoc win :w_redr_status true)
              win (when' (non-zero? @restart_edit) => win
                    (redraw-later win, VALID))              ;; causes status line redraw

              wops (:w_options win)
              ;; set window height to desired minimal value
              win (cond (and (< (:w_height win) @p_wh) (not @(:wo_wfh wops))) (win-setheight win, @p_wh) (zero? (:w_height win)) (win-setheight win, 1) :else win)
              ;; set window width to desired minimal value
              win (cond (and (< (:w_width win) @p_wiw) (not @(:wo_wfw wops))) (win-setwidth win, @p_wiw)                                                :else win)]
        win)
    ))

;; Allocate a window structure and link it in the window list.

(defn- #_window_C newWindow [#_window_C after]
    (-> (NEW_window_C)
        (win-alloc-lines)
        (win-append after) ;; link the window in the window list
        (assoc :w_width @Cols)
        ;; We won't calculate "w_fraction" until resizing the window.
        (assoc :w_prev_fraction_row -1)
    ))

;; Remove window "win" from the window list and free the structure.

(defn- #_window_C win-free [#_window_C win]
    (when (== @prevwin win)
        (reset! prevwin nil))
    (-> win (win-free-lines) (redraw-later SOME_VALID) (win-remove)))

;; Append window "win" in the window list after window "after".

(defn- #_window_C win-append [#_window_C win, #_window_C after]
    (let [#_window_C before (if (some? after) (:w_next after) @firstwin) ;; after null is in front of the first
          win (assoc win :w_prev after :w_next before)]
        (if (nil? after)
            (reset! firstwin win)
            ((ร after =) (assoc after :w_next win))
        )
        (if (nil? before)
            (reset! lastwin win)
            ((ร before =) (assoc before :w_prev win))
        )
        win
    ))

;; Remove a window from the window list.

(defn- #_window_C win-remove [#_window_C win]
    (let [
    ]
        (if (some? (:w_prev win))
            ((ร win =) (assoc-in win [:w_prev :w_next] (:w_next win)))
            (reset! firstwin (:w_next win)))

        (if (some? (:w_next win))
            ((ร win =) (assoc-in win [:w_next :w_prev] (:w_prev win)))
            (reset! lastwin (:w_prev win)))
        win
    ))

;; Append frame "f" in a frame list after frame "after".

(defn- #_frame_C frame-append [#_frame_C f, #_frame_C after]
    (let [f (assoc f :fr_next (:fr_next after))
          after (assoc after :fr_next f)
          f (if (some? (:fr_next f)) (assoc-in f [:fr_next :fr_prev] f) f)]
        (assoc f :fr_prev after)
    ))

;; Insert frame "f" in a frame list before frame "before".

(defn- #_frame_C frame-insert [#_frame_C f, #_frame_C before]
    (let [f (assoc f :fr_next before)
          f (assoc f :fr_prev (:fr_prev before))
          before (assoc before :fr_prev f)]
        (assoc-in f (if (some? (:fr_prev f)) [:fr_prev :fr_next] [:fr_parent :fr_child]) f)
    ))

;; Remove a frame from a frame list.

(defn- #_frame_C frame-remove [#_frame_C f]
    (let [f (assoc-in f (if (some? (:fr_prev f)) [:fr_prev :fr_next] [:fr_parent :fr_child]) (:fr_next f))]
        (if (some? (:fr_next f)) (assoc-in f [:fr_next :fr_prev] (:fr_prev f)) f)
    ))

;; Allocate w_lines[] for window "win".

(defn- #_window_C win-alloc-lines [#_window_C win]
    (assoc win :w_lines_valid 0 :w_lines (ARRAY-wline @Rows)))

;; Free w_lines[] for window "win".

(defn- #_window_C win-free-lines [#_window_C win]
    (assoc win :w_lines nil))

;; Called from win-new-shellsize() after Rows changed.
;; This only does the current tab page, others must be done when made active.

(defn- #_void shell-new-rows []
    (when (some? @firstwin)
        (let [rows (max (frame-minheight @topframe, nil) (- @Rows @p_ch))]
            ;; First try setting the heights of windows with 'winfixheight'.
            ;; If that doesn't result in the right height, forget about that option.
            (swap! topframe frame-new-height rows, false, true)
            (when (not (frame-check-height @topframe, rows))
                (swap! topframe frame-new-height rows, false, false))
            (win-comp-pos) ;; recompute "w_winrow" and "w_wincol"
            (compute-cmdrow)
            (reset! ch_used @p_ch)
        ))
    nil)

;; Called from win-new-shellsize() after Cols changed.

(defn- #_void shell-new-columns []
    (when (some? @firstwin)
        (let [cols @Cols]
            ;; First try setting the widths of windows with 'winfixwidth'.
            ;; If that doesn't result in the right width, forget about that option.
            (swap! topframe frame-new-width cols, false, true)
            (when (not (frame-check-width @topframe, cols))
                (swap! topframe frame-new-width cols, false, false))
            (win-comp-pos) ;; recompute "w_winrow" and "w_wincol"
        ))
    nil)

;; Update the position for all windows, using the width and height of the frames.
;; Returns the row just after the last window.

(defn- #_int win-comp-pos []
    (let [a'row (atom (int 0)) a'col (atom (int 0))]
        (swap! topframe frame-comp-pos a'row, a'col)
        @a'row
    ))

;; Update the position of the windows in frame "frame" using the width and height of child frames.
;; [@a'row @a'col] is the top-left position of the frame, then updated to the bottom-right plus one.

(defn- #_frame_C frame-comp-pos [#_frame_C frame, #_int' a'row, #_int' a'col]
    (let [#_window_C win (:fr_win frame)]
        (if (some? win)
            (let [win (when' (or (!= (:w_winrow win) @a'row) (!= (:w_wincol win) @a'col)) => win
                        ;; position changed, redraw
                        (-> win
                            (assoc :w_winrow @a'row :w_wincol @a'col)
                            (redraw-later NOT_VALID)
                            (assoc :w_redr_status true))
                    )]
                (swap! a'row + (:w_height win) (:w_status_height win))
                (swap! a'col + (:w_width win) (:w_vsep_width win))
                frame)
            (let [#_int startrow @a'row #_int startcol @a'col]
                (loop-when [#_frame_C f (:fr_child frame)] (some? f)
                    (if (== (:fr_layout frame) FR_ROW)
                        (reset! a'row startrow)     ;; all frames are at the same row
                        (reset! a'col startcol))    ;; all frames are at the same col
                    (let [f (frame-comp-pos f, a'row, a'col)]
                        (recur (:fr_next f))
                    ))
                frame
            ))
    ))

;; Set the window height of window "win" and take care of repositioning other windows to fit around it.

(defn- #_window_C win-setheight [#_window_C win, #_int height]
    ;; Always keep current window at least one line high, even when 'winminheight' is zero.
    (let [height (if (:w_focused win) (max 1 @p_wmh height) height)
          win (update win :w_frame frame-setheight (+ height (:w_status_height win)))
          #_int row (win-comp-pos)] ;; recompute the window positions
        ;; If there is extra space created between the last window and the command line, clear it.
        (when (and @full_screen (zero? @msg_scrolled) (< row @cmdline_row))
            (screen-fill row, @cmdline_row, 0, @Cols, (byte \space), (byte \space), 0))
        (reset! cmdline_row row)
        (reset! msg_row row)
        (reset! msg_col 0)
        (redraw-all-later NOT_VALID)
        win
    ))

;; Set the height of a frame to "height"
;; and take care that all frames and windows inside it are resized.
;; Also resize frames on the left and right if they are in the same FR_ROW frame.
;;
;; Strategy:
;; If the frame is part of a FR_COL frame, try fitting the frame in that frame.
;; If that doesn't work (the FR_COL frame is too small),
;; recursively go to containing frames to resize them and make room.
;; If the frame is part of a FR_ROW frame, all frames must be resized as well.
;; Check for the minimal height of the FR_ROW frame.
;; At the top level we can also use change the command line height.

(defn- #_frame_C frame-setheight [#_frame_C frame, #_int height]
    (when' (!= (:fr_height frame) height) => frame
        (cond (nil? (:fr_parent frame)) ;; topframe can only change the command line
            (let-when [height (min height (- @Rows @p_ch))] (< 0 height) => frame
                (frame-new-height frame, height, false, false))

        (== (:fr_layout (:fr_parent frame)) FR_ROW)
            (let [height (max (frame-minheight (:fr_parent frame), nil) height)]
                ;; Row of frames: also need to resize frames left and right of this one.
                ;; First check for the minimal height of these.
                (update frame :fr_parent frame-setheight height))

        :else
            ;; Column of frames: try to change only frames in this column.
            ;; Do this twice:
            ;; 1: compute room available; if it's not enough, try resizing the containing frame.
            ;; 2: compute the room available and adjust the height to it.
            ;; Try not to reduce the height of a window with 'winfixheight' set.
            (let [[frame #_int room #_int rest #_int rcmd height] ;; room: total number of lines available ;; rcmd: lines available from cmdline
                    (loop-when [frame frame ro 0 re 0 rc 0 height height #_int run 1] (<= run 2) => [frame ro re rc height]
                        (let [[ro re] (loop-when [ro 0 re 0 #_frame_C fr (:fr_child (:fr_parent frame))] (some? fr) => [ro re]
                                (let [re (if (and (!= fr frame) (some? (:fr_win fr)) @(:wo_wfh (:w_options (:fr_win fr)))) (+ re (:fr_height fr)) re)
                                      ro (+ ro (:fr_height fr)) ro (if (!= fr frame) (- ro (frame-minheight fr, nil)) ro)]
                                    (recur ro re (:fr_next fr))
                                ))
                              rc (if (== (:fr_width frame) @Cols) (max 0 (- (- @Rows @p_ch) (+ (:w_winrow @lastwin) (:w_height @lastwin) (:w_status_height @lastwin)))) 0)]
                            (cond (<= height (+ ro rc))
                                [frame ro re rc height]
                            (or (== run 2) (== (:fr_width frame) @Cols))
                                [frame ro re rc (min height (+ ro rc))]
                            :else
                                (let [frame (update frame :fr_parent #(frame-setheight %, (- (+ height (frame-minheight %, :NOWIN)) @p_wmh 1)))]
                                    (recur frame ro re rc height (inc run))
                                ))
                        ))
                  ;; Compute the number of lines we will take from others frames (can be negative!).
                  #_int take (- height (:fr_height frame))
                  ;; If there is not enough room, also reduce the height of a window with 'winfixheight' set.
                  rest (min rest (- (+ room rcmd) height))
                  ;; If there is only a 'winfixheight' window and making the window smaller, need to make the other window taller.
                  rest (if (and (< take 0) (< (- room (:fr_height frame)) rest)) 0 rest)
                  take (if (and (< 0 take) (< 0 rcmd)) ;; use lines from cmdline first
                            (let [rcmd (min rcmd take)] (swap! topframe update :fr_height + rcmd) (- take rcmd)) take)
                  a'm (atom {:take take :rest rest})
                  ;; Set the current frame to the new height.
                  frame (frame-new-height frame, height, false, false)]
                ;; First take lines from the frames after the current frame.
                ;; If that is not enough, take lines from frames above the current frame.
                (doseq [step- [:fr_next :fr_prev]]
                    (loop-when [#_frame_C fr (step- frame)] (and (some? fr) (non-zero? (:take @a'm)))
                        (let [#_int h0 (frame-minheight fr, nil) h (:fr_height fr)]
                            (cond (and (< 0 (:rest @a'm)) (some? (:fr_win fr)) @(:wo_wfh (:w_options (:fr_win fr))))
                            (do
                                (cond (<= h (:rest @a'm))
                                (do
                                    (swap! a'm update :rest - h)
                                )
                                :else
                                (do
                                    (swap! a'm update :rest max (- h (:take @a'm)))
                                    (swap! a'm update :take - (- h (:rest @a'm)))
                                    ((ร fr =) (frame-new-height fr, (:rest @a'm), false, false))
                                    (swap! a'm assoc :rest 0)
                                ))
                            )
                            :else
                            (do
                                (cond (< (- h (:take @a'm)) h0)
                                (do
                                    (swap! a'm update :take - (- h h0))
                                    ((ร fr =) (frame-new-height fr, h0, false, false))
                                )
                                :else
                                (do
                                    ((ร fr =) (frame-new-height fr, (- h (:take @a'm)), false, false))
                                    (swap! a'm assoc :take 0)
                                ))
                            ))
                            (recur (step- fr))
                        )))
                frame
            ))
    ))

;; Set the window width of window "win" and take care of repositioning other windows to fit around it.

(defn- #_window_C win-setwidth [#_window_C win, #_int width]
    ;; Always keep current window at least one column wide, even when 'winminwidth' is zero.
    (let [width (if (:w_focused win) (max 1 @p_wmw width) width)
          win (update win :w_frame frame-setwidth (+ width (:w_vsep_width win)))]
        (win-comp-pos) ;; recompute the window positions
        (redraw-all-later NOT_VALID)
        win
    ))

;; Set the width of a frame to "width"
;; and take care that all frames and windows inside it are resized.
;; Also resize frames above and below if they are in the same FR_COL frame.
;;
;; Strategy is similar to frame-setheight().

(defn- #_frame_C frame-setwidth [#_frame_C frame, #_int width]
    (when' (and (!= (:fr_width frame) width) (some? (:fr_parent frame))) => frame ;; topframe can't change width
        (cond (== (:fr_layout (:fr_parent frame)) FR_COL)
            (let [width (max (frame-minwidth (:fr_parent frame), nil) width)]
                ;; Column of frames: also need to resize frames above and below of this one.
                ;; First check for the minimal width of these.
                (update frame :fr_parent frame-setwidth width))

        :else
            ;; Row of frames: try to change only frames in this row.
            ;; Do this twice:
            ;; 1: compute room available; if it's not enough, try resizing the containing frame.
            ;; 2: compute the room available and adjust the width to it.
            ;; Try not to reduce the width of a window with 'winfixwidth' set.
            (let [[frame #_int room #_int rest width] ;; room: total number of lines available
                    (loop-when [frame frame ro 0 re 0 width width #_int run 1] (<= run 2) => [frame ro re width]
                        (let [[ro re] (loop-when [ro 0 re 0 #_frame_C fr (:fr_child (:fr_parent frame))] (some? fr) => [ro re]
                                (let [re (if (and (!= fr frame) (some? (:fr_win fr)) @(:wo_wfw (:w_options (:fr_win fr)))) (+ re (:fr_width fr)) re)
                                      ro (+ ro (:fr_width fr)) ro (if (!= fr frame) (- ro (frame-minwidth fr, nil)) ro)]
                                    (recur ro re (:fr_next fr))
                                ))]
                            (cond (<= width ro)
                                [frame ro re width]
                            (or (== run 2) (<= (- @Rows @p_ch) (:fr_height frame)))
                                [frame ro re (min width ro)]
                            :else
                                (let [frame (update frame :fr_parent #(frame-setwidth %, (- (+ width (frame-minwidth %, :NOWIN)) @p_wmw 1)))]
                                    (recur frame ro re width (inc run))
                                ))
                        ))
                  ;; Compute the number of lines we will take from others frames (can be negative!).
                  #_int take (- width (:fr_width frame))
                  ;; If there is not enough room, also reduce the width of a window with 'winfixwidth' set.
                  rest (min rest (- room width))
                  ;; If there is only a 'winfixwidth' window and making the window smaller, need to make the other window narrower.
                  rest (if (and (< take 0) (< (- room (:fr_width frame)) rest)) 0 rest)
                  a'm (atom {:take take :rest rest})
                  ;; Set the current frame to the new width.
                  frame (frame-new-width frame, width, false, false)]
                ;; First take lines from the frames right of the current frame.
                ;; If that is not enough, take lines from frames left of the current frame.
                (doseq [step- [:fr_next :fr_prev]]
                    (loop-when [#_frame_C fr (step- frame)] (and (some? fr) (non-zero? (:take @a'm)))
                        (let [#_int w0 (frame-minwidth fr, nil) w (:fr_width fr)]
                            (cond (and (< 0 (:rest @a'm)) (some? (:fr_win fr)) @(:wo_wfw (:w_options (:fr_win fr))))
                            (do
                                (cond (<= w (:rest @a'm))
                                (do
                                    (swap! a'm update :rest - w)
                                )
                                :else
                                (do
                                    (swap! a'm update :rest max (- w (:take @a'm)))
                                    (swap! a'm update :take - (- w (:rest @a'm)))
                                    ((ร fr =) (frame-new-width fr, (:rest @a'm), false, false))
                                    (swap! a'm assoc :rest 0)
                                ))
                            )
                            :else
                            (do
                                (cond (< (- w (:take @a'm)) w0)
                                (do
                                    (swap! a'm update :take - (- w w0))
                                    ((ร fr =) (frame-new-width fr, w0, false, false))
                                )
                                :else
                                (do
                                    ((ร fr =) (frame-new-width fr, (- w (:take @a'm)), false, false))
                                    (swap! a'm assoc :take 0)
                                ))
                            ))
                            (recur (step- fr))
                        )))
                frame
            ))
    ))

;; Check 'winminheight' for a valid value.
;; TODO: handle vertical splits

(defn- #_window_C win-setminheight [#_window_C win]
    (loop-when [win win mess true]
               (and (pos? @p_wmh) (neg? (loop-when-recur [room (- @p_wh) #_window_C w @firstwin] (some? w) [(+ room (- (:w_height w) @p_wmh)) (:w_next w)] => room)))
            => win
        (swap! p_wmh dec)
        (recur (if mess (emsg win, e_noroom) win) false)
    ))

(def- win-setminwidth win-setminheight)

(final long FRACTION_MULT 16384)

;; Set "w_fraction" for the current "w_wrow" and "w_height".

(defn- #_window_C set-fraction [#_window_C win]
    (assoc win :w_fraction (/ (+ (* (:w_wrow win) FRACTION_MULT) (/ (:w_height win) 2)) (:w_height win))))

;; Set the height of a window.
;; This takes care of the things inside the window,
;; not what happens to the window position, the frame or to other windows.

(defn- #_window_C win-new-height [#_window_C win, #_int height]
    ;; Don't want a negative height.  Happens when splitting a tiny window.  Will equalize heights soon to fix it.
    (let-when [#_int prev_height (:w_height win) height (max 0 height)] (!= (:w_height win) height) => win ;; nothing to do
        (let-when [[win ?]
            (if (< 0 (:w_height win))
                ;; When setting 'laststatus', this may call win-new-height() recursively.
                (let [win (if (:w_focused win) (validate-cursor win) win)] ;; "w_wrow" needs to be valid
                    (if (!= (:w_height win) prev_height)
                        [win false]
                        [(if (!= (:w_wrow win) (:w_prev_fraction_row win)) (set-fraction win) win) true]
                    ))
                [win true])
        ] ? => win ;; Recursive call already changed the size, bail out here to avoid the following to mess things up.

            (let [win (assoc win :w_height height, :w_skipcol 0)
                  win ;; Don't change "w_topline" when height is zero.
                    (if (< 0 height)
                        ;; Find a value for "w_topline" that shows the cursor at the same relative position in the window as before (more or less).
                        (let [#_long lnum (max 1 (:lnum (:w_cursor win))) ;; can happen when starting up
                              win (assoc win :w_wrow (/ (+ (dec (* (:w_fraction win) height)) (/ FRACTION_MULT 2)) FRACTION_MULT))
                              #_int line_size (dec (plines-col win, lnum, (:col (:w_cursor win))))
                              #_int sline (- (:w_wrow win) line_size)
                              [sline win]
                                (if (<= 0 sline) ;; Make sure the whole cursor line is visible, if possible.
                                    (let [#_int rows (plines win, lnum, false)]
                                        (if (< (- (:w_height win) rows) sline)
                                            [(- (:w_height win) rows) (update win :w_wrow - (- rows line_size))]
                                            [sline win]
                                        ))
                                    [sline win]
                                )]
                            (cond (< sline 0)
                                ;; Cursor line would go off top of screen if "w_wrow" was this high.
                                ;; Make cursor line the first line in the window.
                                ;; If not enough room, use "w_skipcol".
                                (let [win (assoc win :w_wrow line_size)
                                      win
                                        (if (and (<= (:w_height win) (:w_wrow win)) (< 0 (- (:w_width win) (win-col-off win))))
                                            (let [win (update win :w_skipcol + (- (:w_width win) (win-col-off win)))
                                                  win (update win :w_wrow dec)]
                                                (loop-when win (<= (:w_height win) (:w_wrow win)) => win
                                                    (let [win (update win :w_skipcol + (- (:w_width win) (win-col-off win)) (win-col-off2 win))
                                                          win (update win :w_wrow dec)]
                                                        (recur win))
                                                ))
                                            win
                                        )]
                                    (set-topline win, lnum))
                            (< 0 sline)
                                (let [[lnum line_size sline]
                                        (loop-when [lnum lnum line_size line_size sline sline] (and (< 0 sline) (< 1 lnum)) => [lnum line_size sline]
                                            (let [lnum (dec lnum) line_size (plines win, lnum, true) sline (- sline line_size)]
                                                (recur lnum line_size sline)
                                            ))
                                      [lnum win]
                                        (cond (< sline 0) ;; Line we want at top would go off top of screen.  Use next line instead.
                                            [(inc lnum) (update win :w_wrow - line_size sline)]
                                        (< 0 sline) ;; First line of file reached, use that as topline.
                                            [1 (update win :w_wrow - sline)]
                                        :else
                                            [lnum win]
                                        )]
                                    (set-topline win, lnum))
                            :else
                                win
                            ))
                        win)
                  win (if (:w_focused win)
                        (let [win (if (non-zero? @p_so) (update-topline win) win)]
                            (curs-columns win, false)) ;; validate "w_wrow"
                        win)
                  win (if (< 0 prev_height) (assoc win :w_prev_fraction_row (:w_wrow win)) win)
                  _ (win-comp-scroll win)
                  win (redraw-later win, SOME_VALID)
                  win (assoc win :w_redr_status true)]
                (invalidate-botline win)
            ))
    ))

;; Set the width of a window.

(defn- #_window_C win-new-width [#_window_C win, #_int width]
    (let [win (assoc win :w_width width, :w_lines_valid 0)
          win (changed-line-abv-curs win)
          win (invalidate-botline win)
          win (if (:w_focused win)
                (-> win
                    (update-topline)
                    (curs-columns true)) ;; validate "w_wrow"
                win)
          win (redraw-later win, NOT_VALID)]
        (assoc win :w_redr_status true)
    ))

(defn- #_void win-comp-scroll [#_window_C win]
    (reset! (:wo_scr (:w_options win)) (max 1 (>>> (:w_height win) 1)))
    nil)

;; Called whenever "p_ch" has been changed.

(defn- #_window_C command-height [#_window_C win]
    ;; Use the value of "p_ch" that we remembered.  This is needed for when the GUI starts up, we can't be sure in what order things happen.
    (let-when [o'p_ch @ch_used _ (reset! ch_used @p_ch)
          ;; Find bottom frame with width of screen.
          #_frame_C fr (loop-when-recur [fr (:w_frame @lastwin)] (and (!= (:fr_width fr) @Cols) (some? (:fr_parent fr))) [(:fr_parent fr)] => fr)
          ;; Avoid changing the height of a window with 'winfixheight' set.
          fr (loop-when-recur fr (and (some? (:fr_prev fr)) (== (:fr_layout fr) FR_LEAF) @(:wo_wfh (:w_options (:fr_win fr)))) (:fr_prev fr) => fr)
          [win ?]
            (when' (!= @starting NO_SCREEN) => [win nil]
                (reset! cmdline_row (- @Rows @p_ch))
                (if (< o'p_ch @p_ch) ;; 'cmdheight' got bigger
                    (let [win (loop-when [#_long ch o'p_ch fr fr] (< ch @p_ch) => win
                                (if (some? fr)
                                    (let [#_int h' (min (- (:fr_height fr) (frame-minheight fr, nil)) (- @p_ch ch))]
                                        ((ร fr =) (frame-add-height fr, (- h')))
                                        (recur (+ ch h') (:fr_prev fr)))
                                    (let [_ (reset! p_ch ch) _ (reset! ch_used @p_ch)]
                                        (reset! cmdline_row (- @Rows @p_ch))
                                        (emsg win, e_noroom)
                                    ))
                            )]
                        ;; Recompute window positions.
                        (win-comp-pos)
                        ;; Clear the lines added to cmdline.
                        (when @full_screen
                            (screen-fill @cmdline_row, @Rows, 0, @Cols, (byte \space), (byte \space), 0))
                        (reset! msg_row @cmdline_row)
                        (reset! redraw_cmdline true)
                        [win :done])
                    (do
                        (when (< @msg_row @cmdline_row)
                            (reset! msg_row @cmdline_row))
                        (reset! redraw_cmdline true)
                        [win nil])
                ))
    ] (not ?) => win

        ((ร fr =) (frame-add-height fr, (- o'p_ch @p_ch)))
        ;; Recompute window positions.
        (when (!= fr (:w_frame @lastwin))
            (win-comp-pos))
        win
    ))

;; Resize "frame" to be "lines" higher (negative for less high).
;; Also resize the frames it is contained in.

(defn- #_frame_C frame-add-height [#_frame_C frame, #_int lines]
    (let [frame (frame-new-height frame, (+ (:fr_height frame) lines), false, false)]
        (loop [#_frame_C f frame]
            (let [f (:fr_parent f)]
                (recur-if (some? f) [(update f :fr_height + lines)] => nil)
            ))
        frame
    ))

;; Add or remove a status line for the bottom window(s), according to the value of 'laststatus'.
;; Don't make a difference between horizontal or vertical split.

(defn- #_window_C last-status [#_window_C win, #_boolean morewin]
    ;; morewin: pretend there are two or more windows
    (let [[win _] (last-status-rec win, @topframe (or (== @p_ls 2) (and (== @p_ls 1) (or morewin (!= @lastwin @firstwin))))) _ (reset! topframe _)]
        win
    ))

(defn- #_[window_C frame_C] last-status-rec [#_window_C win, #_frame_C frame, #_boolean statusline]
    (condp == (:fr_layout frame)
        FR_LEAF
            (let [#_window_C w (:fr_win frame)]
                (cond (and (non-zero? (:w_status_height w)) (not statusline))
                    ;; Remove the status line.
                    (let [w (win-new-height w, (inc (:w_height w)))
                          w (assoc w :w_status_height 0)]
                        (comp-col)
                        [win frame])
                (and (zero? (:w_status_height w)) statusline)
                    (let-when [[win #_frame_C f] ;; Find a frame to take a line from.
                            (loop-when [f frame] (<= (:fr_height f) (frame-minheight f, nil)) => [win f]
                                ;; In a column of frames: go to frame above.
                                (recur-if (!= f @topframe) ;; If already at the top or in a row of frames: go to parent.
                                          [(if (and (== (:fr_layout (:fr_parent f)) FR_COL) (some? (:fr_prev f))) (:fr_prev f) (:fr_parent f))]
                                       => [(emsg win, e_noroom) nil])
                            )] (some? f) => [win frame]

                        (let [w (assoc w :w_status_height 1)
                              [f w]
                                (if (!= f frame)
                                    (let [f (frame-new-height f, (dec (:fr_height f)), false, false)
                                          w (frame-fix-height w)]
                                        (win-comp-pos)
                                        [f w])
                                    [f (win-new-height w, (dec (:w_height w)))]
                                )]
                            (comp-col)
                            (redraw-all-later SOME_VALID)
                            [win frame]
                        ))
                :else
                    [win frame]
                ))
        FR_ROW
            ;; vertically split windows, set status line for each one
            (loop-when [win win #_frame_C f (:fr_child frame)] (some? f) => [win frame]
                (let [[win f] (last-status-rec win, f, statusline)]
                    (recur win (:fr_next f))
                ))
        FR_COL
            ;; horizontally split window, set status line for last one
            (let [#_frame_C f (loop-when-recur [f (:fr_child frame)] (some? (:fr_next f)) [(:fr_next f)] => f)
                  [win f] (last-status-rec win, f, statusline)]
                [win frame])
    ))

;; Return the minimal number of rows that is needed on the screen to display the current number of windows.

(defn- #_int min-rows []
    (if (some? @firstwin) (inc (max 0 (frame-minheight @topframe, nil))) MIN_ROWS)) ;; count the room for the command line

;; Return true if "frame" and its children are at the right height.

(defn- #_boolean frame-check-height [#_frame_C frame, #_int height]
    (and (== (:fr_height frame) height)
        (when' (== (:fr_layout frame) FR_ROW) => true
            (loop-when [#_frame_C f (:fr_child frame)] (some? f) => true
                (recur-if (== (:fr_height f) height) [(:fr_next f)] => false)
            ))
    ))

;; Return true if "frame" and its children are at the right width.

(defn- #_boolean frame-check-width [#_frame_C frame, #_int width]
    (and (== (:fr_width frame) width)
        (when' (== (:fr_layout frame) FR_COL) => true
            (loop-when [#_frame_C f (:fr_child frame)] (some? f) => true
                (recur-if (== (:fr_width f) width) [(:fr_next f)] => false)
            ))
    ))

;; move.c: Functions for moving the cursor and scrolling text.
;;
;; There are two ways to move the cursor:
;; 1. Move the cursor directly, the text is scrolled to keep the cursor in the window.
;; 2. Scroll the text, the cursor is moved into the text visible in the window.
;; The 'scrolloff' option makes this a bit complicated.

(class! #_final lineoff_C
    [
        (field long     lnum)       ;; line number
        (field int      height)     ;; height of added line
    ])

;; Compute win.w_botline for the current win.w_topline.
;; Can be called after win.w_topline changed.

(defn- #_window_C comp-botline [#_window_C win]
    (let [win (check-cursor-moved win) lmax (line-count @curbuf)
          ;; if "w_cline_row" is valid, start there; else have to start at "w_topline"
          [lnum done] (if (flag? (:w_valid win) VALID_CROW) [(:lnum (:w_cursor win)) (:w_cline_row win)] [(:w_topline win) 0])
          [lnum done win]
            (loop-when [lnum lnum done done win win] (<= lnum lmax) => [lnum done win]
                (let [n (plines win, lnum, true)
                      win (if (== lnum (:lnum (:w_cursor win)))
                            (-> win (assoc :w_cline_row done, :w_cline_height n)
                                    (redraw-for-cursorline)
                                    (update :w_valid | VALID_CROW VALID_CHEIGHT))
                            win)
                      n (+ done n)]
                    (recur-if (<= n (:w_height win)) [(inc lnum) n win] => [lnum done win]))
            )]
        ;; "w_botline" is the line that is just below the window
        (-> win (assoc :w_botline lnum) (update :w_valid | VALID_BOTLINE VALID_BOTLINE_AP)
            (set-empty-rows done))
    ))

;; Redraw when "w_cline_row" changes and 'relativenumber' or 'cursorline' is set.

(defn- #_window_C redraw-for-cursorline [#_window_C win]
    (let-when [wops (:w_options win)] (and (or @(:wo_rnu wops) @(:wo_cul wops)) (non-flag? (:w_valid win) VALID_CROW)) => win
        (redraw-later win, SOME_VALID)
    ))

;; Update "w_topline" and redraw if necessary.
;; Used to update the screen before printing a message.

(defn- #_window_C update-topline-redraw [#_window_C win]
    (let-when [win (update-topline win)] (non-zero? @must_redraw) => win
        (update-screen win, 0)
    ))

;; Update "w_topline" to move the cursor onto the screen.

(defn- #_window_C update-topline [#_window_C win]
    (let-when [o'p_so @p_so] (screen-valid true) => win
        ;; If the window height is zero, just use the cursor line.
        (if (zero? (:w_height win))
            (let [cln (:lnum (:w_cursor win))]
                (-> win (assoc :w_topline cln, :w_botline cln)
                        (update :w_valid | VALID_BOTLINE VALID_BOTLINE_AP)))
            (let-when [win (check-cursor-moved win)] (non-flag? (:w_valid win) VALID_TOPLINE) => win
                (let [o'topline (:w_topline win)
                      [#_boolean check_botline win]
                        (if (bufempty)
                            ;; If the buffer is empty, always set topline to 1.
                            [false (let [win (if (!= (:w_topline win) 1) (redraw-later win, NOT_VALID) win)]
                                (-> win (assoc :w_topline 1, :w_botline 2)
                                        (update :w_valid | VALID_BOTLINE VALID_BOTLINE_AP))
                                )]
                            ;; If the cursor is above or near the top of the window,
                            ;; scroll the window to show the line the cursor is in, with 'scrolloff' context:
                            ;; if the cursor is above topline, scrolling is always needed;
                            ;; if the cursor is far below topline, scrolling down is never needed.
                            (if (and (< 1 (:w_topline win)) (or (< (:lnum (:w_cursor win)) (:w_topline win)) (check-top-offset win)))
                                ;; If we weren't very close to begin with, we scroll to put the cursor in the middle of the window.
                                ;; Otherwise put the cursor near the top of the window.
                                (if (<= (max 2 (dec (/ (:w_height win) 2))) (- (+ (:w_topline win) @p_so) (:lnum (:w_cursor win))))
                                    [false (scroll-cursor-halfway win, false)]
                                    [true (scroll-cursor-top win, (scrolljump-value win), false)])
                                [true win])
                        )]
                    ;; If the cursor is below the bottom of the window, scroll the window to put the cursor on the window.
                    ;; When "w_botline" is invalid, recompute it first, to avoid a redraw later.
                    ;; If "w_botline" was approximated, we might need a redraw later in a few cases,
                    ;; but we don't want to spend (a lot of) time recomputing "w_botline" for every small change.
                    (let [win (if check_botline
                                (let [win (if (non-flag? (:w_valid win) VALID_BOTLINE_AP) (validate-botline win) win)]
                                    (if (<= (:w_botline win) (line-count @curbuf))
                                        (let [cln (:lnum (:w_cursor win)) check_botline
                                                (or (<= (:w_botline win) cln)
                                                    (and (<= (- (:w_botline win) @p_so) cln)
                                                        ;; Cursor is (a few lines) above botline, check if there are 'scrolloff' window lines below the cursor.
                                                        ;; If not, need to scroll.
                                                        (let [n (loop-when [n (:w_empty_rows win) loff (lineoff_C. cln 0)] (< (:lnum loff) (:w_botline win)) => n
                                                                    (let [n (+ n (:height loff))] (recur-if (< n @p_so) [n (botline-forw loff, win)] => n))
                                                                )]
                                                            (< n @p_so)
                                                        ))
                                                )]
                                            (if check_botline
                                                (if (<= (+ (inc (- cln (:w_botline win))) @p_so) (inc (:w_height win)))
                                                    (scroll-cursor-bot win, (scrolljump-value win), false)
                                                    (scroll-cursor-halfway win, false))
                                                win
                                            ))
                                        win
                                    ))
                                win
                            )
                          win (update win :w_valid | VALID_TOPLINE)
                          ;; Need to redraw when topline changed.
                          win (if (!= (:w_topline win) o'topline)
                                (let [win (if (non-zero? (:w_skipcol win)) (let [win (assoc win :w_skipcol 0)] (redraw-later win, NOT_VALID)) (redraw-later win, VALID))]
                                    ;; May need to set "w_skipcol" when cursor in "w_topline".
                                    (if (== (:lnum (:w_cursor win)) (:w_topline win)) (validate-cursor win) win))
                                win
                            )]
                        (reset! p_so o'p_so)
                        win
                    ))
            ))
    ))

;; Return the 'scrolljump' value to use for window "win".
;; When 'scrolljump' is positive use it as-is.
;; When 'scrolljump' is negative use it as a percentage of the window height.

(defn- #_int scrolljump-value [#_window_C win]
    (let [sj @p_sj] (if (< sj 0) (/ (* (:w_height win) (- sj)) 100) sj)))

;; Return true when there are no 'scrolloff' lines above the cursor for window "win".

(defn- #_boolean check-top-offset [#_window_C win]
    (and (< (:lnum (:w_cursor win)) (+ (:w_topline win) @p_so))
        ;; Count the visible screen lines above the cursor line.
        (loop-when [n 0 loff (lineoff_C. (:lnum (:w_cursor win)) 0)] (< n @p_so) => false
            (let [loff (topline-back loff, win)] ;; Stop when included a line above the window.
                (recur-if (<= (:w_topline win) (:lnum loff)) [(+ n (:height loff)) loff] => true)
            ))
    ))

(defn- #_window_C update-curswant [#_window_C win]
    (if (:w_set_curswant win)
        (let [win (validate-virtcol win)]
            (assoc win :w_curswant (:w_virtcol win) :w_set_curswant false))
        win
    ))

;; Check if the cursor has moved.  Set the "w_valid" flag accordingly.

(defn- #_window_C check-cursor-moved [#_window_C win]
    (let [cursor (:w_cursor win) leftcol (:w_leftcol win)]
        (cond (!= (:lnum cursor) (:lnum (:w_valid_cursor win)))
            (-> win (update :w_valid & (bit-not (| VALID_WROW VALID_WCOL VALID_VIRTCOL VALID_CHEIGHT VALID_CROW VALID_TOPLINE)))
                    (assoc :w_valid_cursor cursor, :w_valid_leftcol leftcol))
        (or (!= (:col cursor) (:col (:w_valid_cursor win))) (!= leftcol (:w_valid_leftcol win)) (!= (:coladd cursor) (:coladd (:w_valid_cursor win))))
            (-> win (update :w_valid & (bit-not (| VALID_WROW VALID_WCOL VALID_VIRTCOL)))
                    (update :w_valid_cursor assoc :col (:col cursor) :coladd (:coladd cursor))
                    (assoc :w_valid_leftcol leftcol))
        :else win)
    ))

;; Call this function when some window settings have changed, which require
;; the cursor position, botline and topline to be recomputed and the window
;; to be redrawn, e.g. when changing the 'wrap' option or folding.

(defn- #_window_C changed-window-setting [#_window_C win]
    (-> win
        (assoc :w_lines_valid 0)
        (changed-line-abv-curs)
        (update :w_valid & (bit-not (| VALID_BOTLINE VALID_BOTLINE_AP VALID_TOPLINE)))
        (redraw-later NOT_VALID)
    ))

;; Set win.w_topline to a certain number.

(defn- #_window_C set-topline [#_window_C win, #_long lnum]
    ;; Approximate the value of "w_botline".
    (let [win (update win :w_botline + (- lnum (:w_topline win)))]
        (-> win
            (assoc :w_topline lnum)
            (update :w_valid & (bit-not (| VALID_WROW VALID_CROW VALID_BOTLINE VALID_TOPLINE)))
            ;; Don't set VALID_TOPLINE here, 'scrolloff' needs to be checked.
            (redraw-later VALID)
        )
    ))

;; Call this function when the length of the cursor line (in screen cells) has changed, and the change is before the cursor.
;; Need to take care of "w_botline" separately!

(defn- #_window_C changed-cline-bef-curs [#_window_C win]
    (update win :w_valid & (bit-not (| VALID_WROW VALID_WCOL VALID_VIRTCOL VALID_CHEIGHT VALID_TOPLINE))))

;; Call this function when the length of a line (in screen cells) above the cursor have changed.
;; Need to take care of "w_botline" separately!

(defn- #_window_C changed-line-abv-curs [#_window_C win]
    (update win :w_valid & (bit-not (| VALID_WROW VALID_WCOL VALID_VIRTCOL VALID_CROW VALID_CHEIGHT VALID_TOPLINE))))

;; Make sure the value of win.w_botline is valid.

(defn- #_window_C validate-botline [#_window_C win]
    (if (non-flag? (:w_valid win) VALID_BOTLINE) (comp-botline win) win))

;; Mark "w_botline" as invalid (because of some change in the buffer).

(defn- #_window_C invalidate-botline [#_window_C win]
    (update win :w_valid & (bit-not (| VALID_BOTLINE VALID_BOTLINE_AP))))

(defn- #_window_C approximate-botline [#_window_C win]
    (update win :w_valid & (bit-not VALID_BOTLINE)))

;; Validate cursor position.  Makes sure "w_wrow" and "w_wcol" are valid.
;; "w_topline" must be valid, you may need to call update-topline() first!

(defn- #_window_C validate-cursor [#_window_C win]
    (let [win (check-cursor-moved win)
          row|col (| VALID_WROW VALID_WCOL) #_| valid? (== (& (:w_valid win) row|col) row|col)]
        (if (not valid?) (curs-columns win, true) win)
    ))

;; Compute "w_cline_row" and "w_cline_height" upon the current value of "w_topline".

(defn- #_window_C curs-rows [#_window_C win]
    (let [#_boolean all_invalid (or (not (redrawing)) (zero? (:w_lines_valid win)) (< (:w_topline win) (:wl_lnum (... (:w_lines win) 0))))
          [win #_int i]
            (loop-when [win (assoc win :w_cline_row 0) #_long lnum (:w_topline win) i 0] (< lnum (:lnum (:w_cursor win))) => [win i]
                (let-when [wli (... (:w_lines win) i)
                    [valid? i' :as _]
                        (cond
                            (or all_invalid (<= (:w_lines_valid win) i))        [false i]
                            (or (< (:wl_lnum wli) lnum) (not (:wl_valid wli)))  nil             ;; skip changed or deleted lines
                            (== (:wl_lnum wli) lnum)                            [true i]
                            (< lnum (:wl_lnum wli))                             [false (dec i)] ;; hold at inserted lines
                        )
                ] (some? _) => (recur win lnum (inc i))
                    (let [win (update win :w_cline_row + (if valid? (:wl_size (... (:w_lines win) i')) (plines win, lnum, true)))]
                        (recur win (inc lnum) (inc i')))
                ))
          win (check-cursor-moved win)
          win (if (non-flag? (:w_valid win) VALID_CHEIGHT)
                (let [wli (... (:w_lines win) i) m (:w_lines_valid win)
                      n (cond (or all_invalid (== i m) (and (< i m) (or (not (:wl_valid wli)) (!= (:wl_lnum wli) (:lnum (:w_cursor win))))))
                            (plines win, (:lnum (:w_cursor win)), true)
                        (< m i)
                            0 ;; a line that is too long to fit on the last screen row
                        :else
                            (:wl_size wli)
                        )]
                    (assoc win :w_cline_height n))
                win)
          win (redraw-for-cursorline win)]
        (update win :w_valid | VALID_CROW VALID_CHEIGHT)
    ))

;; Validate "w_virtcol" only.

(defn- #_window_C validate-virtcol [#_window_C win]
    (let-when [win (check-cursor-moved win)] (non-flag? (:w_valid win) VALID_VIRTCOL) => win
        (let-when [a'vcol (atom (int (:w_virtcol win))) _ (getvvcol win, (:w_cursor win), nil, a'vcol, nil)
              win (-> win (assoc :w_virtcol @a'vcol) (update :w_valid | VALID_VIRTCOL))
        ] @(:wo_cuc (:w_options win)) => win
            (redraw-later win, SOME_VALID)
        )
    ))

;; Validate "w_cline_height" only.

(defn- #_window_C validate-cheight [#_window_C win]
    (let-when [win (check-cursor-moved win)] (non-flag? (:w_valid win) VALID_CHEIGHT) => win
        (let [n (plines win, (:lnum (:w_cursor win)), true)]
           (-> win (assoc :w_cline_height n) (update :w_valid | VALID_CHEIGHT))
        )
    ))

;; Validate "w_wcol" and "w_virtcol" only.

(defn- #_window_C validate-cursor-col [#_window_C win]
    (let-when [win (validate-virtcol win)] (non-flag? (:w_valid win) VALID_WCOL) => win
        (let [col (:w_virtcol win) off (win-col-off win) col (+ col off) off (+ (- (:w_width win) off) (win-col-off2 win)) n (- col (:w_width win))
              wrap @(:wo_wrap (:w_options win))
              col (if (and wrap (<= 0 n) (< 0 off)) (- col (* (inc (/ n off)) off)) col)]
           (-> win (assoc :w_wcol (max 0 (- col (:w_leftcol win)))) (update :w_valid | VALID_WCOL))
        )
    ))

;; Compute offset of a window, occupied by absolute or relative line number,
;; fold column and sign column (these don't move when scrolling horizontally).

(defn- #_int win-col-off [#_window_C win]
    (let [wops (:w_options win)]
        (+ (if (or @(:wo_nu wops) @(:wo_rnu wops)) (inc (ร let [[win ?] (number-width? win)] ?)) 0) (if (or (zero? @cmdwin_type) (not (:w_focused win))) 0 1))
    ))

;; Return the difference in column offset for the second screen line of a wrapped line.
;; It's 8 if 'number' or 'relativenumber' is on and 'n' is in 'cpoptions'.

(defn- #_int win-col-off2 [#_window_C win]
    (let [wops (:w_options win)]
        (if (and (or @(:wo_nu wops) @(:wo_rnu wops)) (some? (vim-strbyte @p_cpo, CPO_NUMCOL))) (inc (ร let [[win ?] (number-width? win)] ?)) 0)
    ))

;; Compute "w_wcol" and "w_virtcol".  Also updates "w_wrow", "w_cline_row" and "w_leftcol".
;; may_scroll: when true, may scroll horizontally

(defn- #_window_C curs-columns [#_window_C win, #_boolean may_scroll]
    ;; First make sure that "w_topline" is valid (after moving the cursor).
    (let [win (update-topline win)
          ;; Next make sure that "w_cline_row" is valid.
          win (if (non-flag? (:w_valid win) VALID_CROW) (curs-rows win) win)
          ;; Compute the number of virtual columns.
          a'startcol (atom (int)) a'vcol (atom (int (:w_virtcol win))) a'endcol (atom (int)) _ (getvvcol win, (:w_cursor win), a'startcol, a'vcol, a'endcol)
          win (assoc win :w_virtcol @a'vcol)
          #_int extra (win-col-off win) ;; offset for first screen row
          win (assoc win :w_wcol (+ (:w_virtcol win) extra))
          _ (swap! a'endcol + extra)
          ;; Now compute "w_wrow" counting screen rows from "w_cline_row".
          win (assoc win :w_wrow (:w_cline_row win))
          #_int textwidth (- (:w_width win) extra)
          [win #_int width]
            (cond (<= textwidth 0) ;; No room for text, put cursor in last char of window.
                [(assoc win :w_wcol (dec (:w_width win)) :w_wrow (dec (:w_height win))) 0]
            (and @(:wo_wrap (:w_options win)) (non-zero? (:w_width win)))
                (let [width (+ textwidth (win-col-off2 win))]
                    ;; long line wrapping, adjust "w_wrow"
                    (if (<= (:w_width win) (:w_wcol win))
                        ;; this same formula is used in validate-cursor-col()
                        (let [#_int n (inc (/ (- (:w_wcol win) (:w_width win)) width))
                              win (update win :w_wcol - (* n width))
                              win (update win :w_wrow + n)
                              ;; When cursor wraps to first char of next line in Insert mode,
                              ;; the 'showbreak' string isn't shown, backup to first column.
                              win (if (and (non-eos? @p_sbr) (eos? (ml-get-cursor win)) (== (:w_wcol win) (mb-string2cells @p_sbr))) (assoc win :w_wcol 0) win)]
                            [win width])
                        [win width]
                    ))
            ;; No line wrapping: compute "w_leftcol" if scrolling is on and line is not folded.
            ;; If scrolling is off, "w_leftcol" is assumed to be 0.
            may_scroll
                ;; If cursor is left of the screen, scroll rightwards.
                ;; If cursor is right of the screen, scroll leftwards.
                ;; If we get closer to the edge than 'sidescrolloff', scroll a little extra.
                (let [#_int loff (- @a'startcol (:w_leftcol win) @p_siso) #_int roff (inc (- @a'endcol (- (+ (:w_leftcol win) (:w_width win)) @p_siso)))
                      win (if (or (< loff 0) (< 0 roff))
                            (let [#_int diff (if (< loff 0) (- loff) roff)
                                  #_int lcol ;; When far off or not enough room on either side, put cursor in middle of window.
                                    (if (or (zero? @p_ss) (<= (/ textwidth 2) diff) (<= loff roff))
                                        (- (:w_wcol win) extra (/ textwidth 2))
                                        ((if (< loff 0) - +) (:w_leftcol win) (max @p_ss diff)))
                                  lcol (max 0 lcol)]
                                ;; screen has to be redrawn with new "w_leftcol"
                                (if (!= lcol (:w_leftcol win)) (-> win (assoc :w_leftcol lcol) (redraw-later NOT_VALID)) win))
                            win)
                      win (update win :w_wcol - (:w_leftcol win))]
                    [win 0])
            (< (:w_leftcol win) (:w_wcol win))
                (let [win (update win :w_wcol - (:w_leftcol win))]
                    [win 0])
            :else
                [(assoc win :w_wcol 0) 0])
          o'skipcol (:w_skipcol win) a'plines (atom (int 0))
          win (if (and (or (<= (:w_height win) (:w_wrow win))
                           (and (or (< 0 o'skipcol) (<= (:w_height win) (+ (:w_wrow win) @p_so)))
                                (<= (:w_height win) (dec (reset! a'plines (plines win, (:lnum (:w_cursor win)), false))))))
                       (!= (:w_height win) 0) (== (:lnum (:w_cursor win)) (:w_topline win)) (< 0 width) (!= (:w_width win) 0))
                ;; Cursor past end of screen.  Happens with a single line that does not fit on screen.
                ;; Find a skipcol to show the text around the cursor.  Avoid scrolling all the time.
                ;; Compute value of "extra":
                ;; 1: less than "p_so" lines above
                ;; 2: less than "p_so" lines below
                ;; 3: both of them
                (let [extra (if (< (:w_virtcol win) (+ (:w_skipcol win) (* @p_so width))) 1 0)
                      ;; Compute last display line of the buffer line that we want at the bottom of the window.
                      _ (swap! a'plines #(dec (if (zero? %) (plines win, (:lnum (:w_cursor win)), false) %)))
                      #_int n (min (+ (:w_wrow win) @p_so) @a'plines)
                      extra (if (<= (+ (:w_height win) (/ (:w_skipcol win) width)) n) (+ extra 2) extra)
                      win (cond (or (== extra 3) (< @a'plines (* @p_so 2)))
                            ;; not enough room for 'scrolloff', put cursor in the middle
                            (let [n (max 0 (- (/ (:w_virtcol win) width) (/ (:w_height win) 2)))
                                  ;; don't skip more than necessary
                                  n (min n (inc (- @a'plines (:w_height win))))]
                                (assoc win :w_skipcol (* n width)))
                        (== extra 1)
                            ;; less then 'scrolloff' lines above, decrease skipcol
                            (let [n (/ (dec (+ (- (+ (:w_skipcol win) (* @p_so width)) (:w_virtcol win)) width)) width)]
                                (if (< 0 n)
                                    (let [n (min n (/ (:w_skipcol win) width))]
                                        (update win :w_skipcol - (* n width)))
                                    win
                                ))
                        (== extra 2)
                            (do ;; less then 'scrolloff' lines below, increase skipcol
                                (reset! a'endcol (* (inc (- n (:w_height win))) width))
                                (while (< (:w_virtcol win) @a'endcol)
                                    (swap! a'endcol - width))
                                (update win :w_skipcol max @a'endcol))
                        :else
                            win)
                      win (update win :w_wrow - (/ (:w_skipcol win) width))
                      win (if (<= (:w_height win) (:w_wrow win))
                            ;; small window, make sure cursor is in it
                            (let [n (inc (- (:w_wrow win) (:w_height win)))] (-> win (update :w_skipcol + (* n width)) (update :w_wrow - n)))
                            win)
                      extra (/ (- o'skipcol (:w_skipcol win)) width)]
                    (cond
                        (< 0 extra) (let [[win _] (win-ins-lines? win, 0, extra, false, false)] win)
                        (< extra 0) (let [[win _] (win-del-lines? win, 0, (- extra), false, false)] win)
                        :else win
                    ))
                (assoc win :w_skipcol 0))
          win (if (!= o'skipcol (:w_skipcol win)) (redraw-later win, NOT_VALID) win)
          ;; Redraw when "w_virtcol" changes and 'cursorcolumn' is set.
          win (if (and @(:wo_cuc (:w_options win)) (non-flag? (:w_valid win) VALID_VIRTCOL)) (redraw-later win, SOME_VALID) win)]
        (update win :w_valid | VALID_WCOL VALID_WROW VALID_VIRTCOL)
    ))

;; Scroll window "win" down by "n" logical lines.  "CTRL-Y"

(defn- #_window_C scrolldown [#_window_C win, #_long n]
    (let [win (validate-cursor win)                     ;; "w_wrow" needs to be valid
          [win done]                                    ;; total # of physical lines done
            (loop-when [win win done 0 n n] (and (< 0 n) (< 1 (:w_topline win))) => [win done]
                (let [win (update win :w_topline dec)
                      done (+ done (plines win, (:w_topline win), true))
                      win (update win :w_botline dec)   ;; approximate "w_botline"
                      win (invalidate-botline win)]
                    (recur win done (dec n))
                ))
          win (update win :w_wrow + done)               ;; keep "w_wrow" updated
          win (update win :w_cline_row + done)          ;; keep "w_cline_row" updated
          ;; Compute the row number of the last row of the cursor line
          ;; and move the cursor onto the displayed part of the window.
          wrow (:w_wrow win)
          [win wrow]
            (if (and @(:wo_wrap (:w_options win)) (non-zero? (:w_width win)))
                (let [win (-> win (validate-virtcol) (validate-cheight))]
                    [win (+ wrow (- (:w_cline_height win) 1 (/ (:w_virtcol win) (:w_width win))))])
                [win wrow])
          [win ?]
            (loop-when [win win ? false wrow wrow] (and (<= (:w_height win) wrow) (< 1 (:lnum (:w_cursor win)))) => [win ?]
                (let [wrow (- wrow (plines win, (:lnum (:w_cursor win)), true))
                      win (update-in win [:w_cursor :lnum] dec)
                      win (update win :w_valid & (bit-not (| VALID_WROW VALID_WCOL VALID_CHEIGHT VALID_CROW VALID_VIRTCOL)))]
                    (recur win true wrow))
            )]
        (if ? (coladvance win, (:w_curswant win)) win)
    ))

;; Scroll window "win" up by "n" logical lines.  "CTRL-E"

(defn- #_window_C scrollup [#_window_C win, #_long n]
    (let [lmax (line-count @curbuf)
          win (assoc win :w_topline (min (+ (:w_topline win) n) lmax))
          win (assoc win :w_botline (min (+ (:w_botline win) n) (inc lmax))) ;; approximate "w_botline"
          win (update win :w_valid & (bit-not (| VALID_WROW VALID_CROW VALID_BOTLINE)))]
        (if (< (:lnum (:w_cursor win)) (:w_topline win))
            (let [win (assoc-in win [:w_cursor :lnum] (:w_topline win))
                  win (update win :w_valid & (bit-not (| VALID_WROW VALID_WCOL VALID_CHEIGHT VALID_CROW VALID_VIRTCOL)))]
                (coladvance win, (:w_curswant win)))
            win)
    ))

;; Add one line above "loff.lnum".
;; This can be a filler line, a closed fold or a (wrapped) text line.
;; Returns the height of the added line in "loff.height".
;; Lines above the first one are incredibly high: MAXCOL.

(defn- #_lineoff_C topline-back [#_lineoff_C loff, #_window_C win]
    (let [n (dec (:lnum loff))] (assoc loff :lnum n :height (if (< n 1) MAXCOL (plines win, n, true)))))

;; Add one line below "loff.lnum".
;; This can be a filler line, a closed fold or a (wrapped) text line.
;; Returns the height of the added line in "loff.height".
;; Lines below the last one are incredibly high: MAXCOL.

(defn- #_lineoff_C botline-forw [#_lineoff_C loff, #_window_C win]
    (let [n (inc (:lnum loff))] (assoc loff :lnum n :height (if (< (line-count @curbuf) n) MAXCOL (plines win, n, true)))))

;; Recompute topline to put the cursor at the top of the window.
;; Scroll at least "min_sj" lines.
;; If "always" is true, always set topline (for "zt").

(defn- #_window_C scroll-cursor-top [#_window_C win, #_int min_sj, #_boolean always]
    ;; Decrease topline until it has become 1 or (part of) the cursor line is moved off the screen or
    ;; moved at least 'scrolljump' lines and there are at least 'scrolloff' lines above and below the cursor.
    (let [o'topline (:w_topline win)
          cln (:lnum (:w_cursor win)) lmax (line-count @curbuf)
          win (validate-cheight win)
          #_int used (:w_cline_height win) #_int done (if (< cln (:w_topline win)) used 0)
          ;; Check if the lines from "top" to "bot" fit in the window.
          ;; If they do, set "topline" and advance "top" and "bot" to include more lines.
          [used #_long topline]
            (loop-when [#_int extra 0, used used, done done, topline cln, #_long top (dec cln), #_long bot (inc cln)] (< 0 top) => [used topline]
                (let [#_int n (plines win, top, true)
                      used (+ used n (if (and (<= (+ extra n) @p_so) (< bot lmax)) (plines win, bot, true) 0))]
                    (if (< (:w_height win) used)
                        [used topline]
                        (let [done (+ done (if (< top (:w_topline win)) n 0))]
                            ;; If scrolling is needed, scroll at least 'sj' lines.
                            (if (and (or (<= (:w_topline win) topline) (< min_sj done)) (<= @p_so extra))
                                [used topline]
                                (recur (+ extra n) used done top (dec top) (inc bot))
                            ))
                    )))]
        ;; If we don't have enough space, put cursor in the middle.
        ;; This makes sure we get the same position when using "k" and "j" in a small window.
        (if (< (:w_height win) used)
            (scroll-cursor-halfway win, false)
            ;; If "always" is false, only adjust topline to a lower value, higher value may happen with wrapping lines.
            (let [win (if (or (< topline (:w_topline win)) always) (assoc win :w_topline topline) win)
                  win (update win :w_topline min (:lnum (:w_cursor win)))
                  win (if (!= (:w_topline win) o'topline) (update win :w_valid & (bit-not (| VALID_WROW VALID_CROW VALID_BOTLINE VALID_BOTLINE_AP))) win)]
                (update win :w_valid | VALID_TOPLINE)
            ))
    ))

;; Set "w_empty_rows" for window "win" having used up "used" screen rows for text lines.

(defn- #_window_C set-empty-rows [#_window_C win, #_int used]
    (assoc win :w_empty_rows (if (zero? used)
        0    ;; single line that doesn't fit
        (- (:w_height win) used)
    )))

;; Recompute topline to put the cursor at the bottom of the window.
;; Scroll at least "min_sj" lines.
;; If "set_topbot" is true, set topline and botline first (for "zb").
;; This is messy stuff!!!

(defn- #_window_C scroll-cursor-bot [#_window_C win, #_int min_sj, #_boolean set_topbot]
    (let [o'topline (:w_topline win) o'botline (:w_botline win) o'valid (:w_valid win) o'empty_rows (:w_empty_rows win)
          cln (:lnum (:w_cursor win)) lmax (line-count @curbuf)
          win (if set_topbot
                (let [win (assoc win :w_topline (inc cln) :w_botline (inc cln))
                      win (let [[win #_int used]
                                (loop-when [win win used 0] (< 1 (:w_topline win)) => [win used]
                                    (let [loff (topline-back (lineoff_C. (:w_topline win) 0), win)]
                                        (if (or (== (:height loff) MAXCOL) (< (:w_height win) (+ used (:height loff))))
                                            [win used]
                                            (recur (assoc win :w_topline (:lnum loff)) (+ used (:height loff)))
                                        )))]
                            (set-empty-rows win, used))
                      win (if (!= (:w_topline win) o'topline) (update win :w_valid & (bit-not (| VALID_WROW VALID_CROW))) win)]
                    (update win :w_valid | VALID_BOTLINE VALID_BOTLINE_AP))
                (validate-botline win))
          ;; The screen rows of the cursor line itself are always used.
          win (validate-cheight win)
          #_long n
            (let [#_int used (:w_cline_height win)
                  ;; If the cursor is below botline, we will at least scroll by the height of the cursor line.
                  ;; Correct for empty lines, which are really part of botline.
                  #_int done (if (<= (:w_botline win) cln) (- used (if (== cln (:w_botline win)) (:w_empty_rows win) 0)) 0)
                  ;; Stop counting lines to scroll when
                  ;; - hitting start of the file
                  ;; - scrolled nothing or at least 'sj' lines
                  ;; - at least 'so' lines below the cursor
                  ;; - lines between botline and cursor have been counted
                  [used done]
                    (loop-when [#_int extra 0, used used, done done, loff (lineoff_C. cln 0), boff (lineoff_C. cln 0)] (< 1 (:lnum loff)) => [used done]
                        ;; Stop when scrolled nothing or at least "min_sj", found "extra" context for 'scrolloff' and counted all lines below the window.
                        (if (and (or (and (or (<= done 0) (<= min_sj done)) (<= @p_so extra)) (< lmax (inc (:lnum boff)))) (<= (:lnum loff) (:w_botline win)))
                            [used done]
                            (let [loff (topline-back loff, win) ;; Add one line above.
                                  used (if (== (:height loff) MAXCOL) MAXCOL (+ used (:height loff)))]
                                (if (< (:w_height win) used)
                                    [used done]
                                    ;; Count screen rows that are below the window.
                                    (let [done (+ done
                        #_red!              (if (<= (:w_botline win) (:lnum loff)) (- (:height loff) (if (== (:lnum loff) (:w_botline win)) (:w_empty_rows win) 0)) 0))]
                                        (if (< (:lnum boff) lmax)
                                            (let [boff (botline-forw boff, win) ;; Add one line below.
                                                  used (+ used (:height boff))]
                                                (if (< (:w_height win) used)
                                                    [used done]
                                                    (let [[extra done]
                                                            (if (or (< extra @p_so) (< done min_sj))
                                                                ;; Count screen rows that are below the window.
                                                                (let [done (+ done
                        #_red!              (if (<= (:w_botline win) (:lnum boff)) (- (:height boff) (if (== (:lnum boff) (:w_botline win)) (:w_empty_rows win) 0)) 0))]
                                                                    [(+ extra (:height boff)) done])
                                                                [extra done]
                                                            )]
                                                        (recur extra used done loff boff))
                                                ))
                                            (recur extra used done loff boff)
                                        ))
                                ))
                        ))]
                (cond (<= done 0)                               ;; "w_empty_rows" is larger, no need to scroll
                    0
                (< (:w_height win) used)                        ;; more than a screenfull, don't scroll but redraw
                    used
                :else                                           ;; scroll minimal number of lines
                    (loop-when [boff (lineoff_C. (dec (:w_topline win)) 0) #_int i 0 n 0] (and (< i done) (< (:lnum boff) (:w_botline win)))
                            => (if (< i done) 9999 n)           ;; below "w_botline", don't scroll
                        (let [boff (botline-forw boff, win)]
                            (recur boff (+ i (:height boff)) (inc n)))
                    )
                )
            )
          ;; Scroll up if the cursor is off the bottom of the screen a bit, otherwise put it at 1/2 of the screen.
          win (if (and (<= (:w_height win) n) (< min_sj n)) (scroll-cursor-halfway win, false) (scrollup win, n))
          ;; If topline didn't change we need to restore "w_botline" and "w_empty_rows" (we changed them).
          ;; If topline did change, update-screen() will set botline.
          win (if (and (== (:w_topline win) o'topline) set_topbot) (assoc win :w_botline o'botline :w_empty_rows o'empty_rows :w_valid o'valid) win)]
        (update win :w_valid | VALID_TOPLINE)
    ))

;; Recompute "w_topline" to put the cursor halfway the window "win".
;; If "atend" is true, also put it halfway at the end of the file.

(defn- #_window_C scroll-cursor-halfway [#_window_C win, #_boolean atend]
    (let [cln (:lnum (:w_cursor win)) lmax (line-count @curbuf)
          #_long topline
            (loop-when [#_int above 0, #_int below 0, loff (lineoff_C. cln 0), boff (lineoff_C. cln 0), #_int used (plines win, cln, true), topline cln] (< 1 topline) => topline
                (let-when [[below boff used :as _]
                        (if (<= below above)         ;; add a line below the cursor first
                            (if (< (:lnum boff) lmax)
                                (let [boff (botline-forw boff, win) used (+ used (:height boff))]
                                    (if (< (:w_height win) used)
                                        nil
                                        [(+ below (:height boff)) boff used]))
                                [(inc below) boff (if atend (inc used) used)]) ;; count a "~" line
                            [below boff used])] (some? _) => topline
                    (let-when [[above loff used topline :as _]
                            (if (< above below)          ;; add a line above the cursor
                                (let [loff (topline-back loff, win) used (if (== (:height loff) MAXCOL) MAXCOL (+ used (:height loff)))]
                                    (if (< (:w_height win) used)
                                        nil
                                        [(+ above (:height loff)) loff used (:lnum loff)]))
                                [above loff used topline])] (some? _) => topline
                        (recur above below loff boff used topline)
                    )))]
        (-> win
            (assoc :w_topline topline)
            (update :w_valid & (bit-not (| VALID_WROW VALID_CROW VALID_BOTLINE VALID_BOTLINE_AP)))
            (update :w_valid | VALID_TOPLINE)
        )
    ))

;; Correct the cursor position so that it is in a part of the screen at least 'so' lines from the top and bottom, if possible.
;; If not possible, put it at the same position as scroll-cursor-halfway().
;; When called, topline must be valid!

(defn- #_window_C cursor-correct [#_window_C win]
    ;; How many lines we would like to have above/below the cursor depends on whether the first/last line of the file is on screen.
    (let-when [aw @p_so, bw @p_so, lmin 1, lmax (line-count @curbuf)
          [aw bw] (if (== (:w_topline win)      lmin)  [0 (min bw (/      (:w_height win)  2))] [aw bw])
          win (validate-botline win)
          [bw aw] (if (== (:w_botline win) (inc lmax)) [0 (min aw (/ (dec (:w_height win)) 2))] [bw aw])
          ;; If there are sufficient file-lines above and below the cursor, we can return now.
          cln (:lnum (:w_cursor win))
    ] (or (< cln (+ (:w_topline win) aw)) (<= (- (:w_botline win) bw) cln)) => win
        ;; Narrow down the area where the cursor can be put by taking lines from the top and the bottom until:
        ;; - the desired context lines are found
        ;; - the lines from the top is past the lines from the bottom
        (let [[topline botline]
                (loop-when [a 0 b 0 top' (:w_topline win) bot' (dec (:w_botline win))] (and (or (< a aw) (< b bw)) (< top' bot')) => [top' bot']
                    (let [[b bot'] (if (and (< b bw) (or (<= b a) (<= aw a))) [(+ b (plines win, bot', true)) (dec bot')] [b bot'])
                          [a top'] (if (and (< a aw) (or (<  a b) (<= bw b))) [(+ a (plines win, top', true)) (inc top')] [a top'])]
                        (recur a b top' bot')
                    ))
              inv- #(update % :w_valid & (bit-not (| VALID_WROW VALID_WCOL VALID_CHEIGHT VALID_CROW)))
              win (cond
                    (or (== topline botline) (zero? botline))                (assoc-in win [:w_cursor :lnum] topline)
                    (< botline topline)                                      (assoc-in win [:w_cursor :lnum] botline)
                    (and (< cln topline) (< lmin (:w_topline win)))  (-> win (assoc-in     [:w_cursor :lnum] topline) inv-)
                    (and (< botline cln) (<= (:w_botline win) lmax)) (-> win (assoc-in     [:w_cursor :lnum] botline) inv-)
                    :else                                                win
                )]
            (update win :w_valid | VALID_TOPLINE)
        )
    ))

;; Move "count" pages up or down.
;;
;; return false for failure, true otherwise

(defn- #_[window_C boolean] onepage? [#_window_C win, #_int dir, #_long count]
    (let-when [lmin 1 lmax (line-count @curbuf)] (!= lmin lmax) => [(beep-flush win) false] ;; nothing to do
        (let [o'topline (:w_topline win)
              [win #_boolean ok]
                (loop-when [win win count count] (< 0 count) => [win true]
                    (let [win (validate-botline win)]
                        ;; It's an error to move a page
                        ;; - up when the first line is already on the screen.
                        ;; - down when the last line is on the screen and topline is 'scrolloff' lines from it.
                        (if (if (== dir FORWARD) (and (<= (- lmax @p_so) (:w_topline win)) (< lmax (:w_botline win))) (== (:w_topline win) lmin))
                            [(beep-flush win) false]
                            (let [win (cond (== dir FORWARD)
                                        (if (< lmax (:w_botline win)) ;; at end of file
                                            (let [win (assoc win :w_topline lmax)]
                                                (update win :w_valid & (bit-not (| VALID_WROW VALID_CROW))))
                                            ;; For the overlap, start with the line just below the window and go upwards.
                                            (let [#_lineoff_C loff (get-scroll-overlap win, (:w_botline win), -1)
                                                  win (assoc win :w_topline (:lnum loff))
                                                  win (assoc-in win [:w_cursor :lnum] (:w_topline win))]
                                                (update win :w_valid & (bit-not (| VALID_WCOL VALID_CHEIGHT VALID_WROW VALID_CROW VALID_BOTLINE VALID_BOTLINE_AP)))
                                            ))
                                    :else
                                        ;; Find the line at the top of the window that is going to be the line at the bottom of the window.
                                        ;; Make sure this results in the same line as before doing CTRL-F.
                                        (let [#_lineoff_C loff (get-scroll-overlap win, (dec (:w_topline win)), 1) loff (update loff :lnum min lmax)
                                              win (assoc-in win [:w_cursor :lnum] (:lnum loff))
                                              ;; Find the line just above the new topline to get the right line at the bottom of the window.
                                              loff (loop-when [loff loff #_long n 0] (and (<= n (:w_height win)) (<= lmin (:lnum loff))) => loff
                                                        (let [loff (topline-back loff, win)]
                                                            (recur loff (if (== (:height loff) MAXCOL) MAXCOL (+ n (:height loff)))))
                                                )]
                                            (if (< (:lnum loff) lmin) ;; at begin of file
                                                (let [win (assoc win :w_topline lmin)]
                                                    (update win :w_valid & (bit-not (| VALID_WROW VALID_CROW VALID_BOTLINE))))
                                                ;; Go two lines forward again.
                                                (let [loff (botline-forw loff, win) loff (botline-forw loff, win)]
                                                    ;; Always scroll at least one line.  Avoid getting stuck on very long lines.
                                                    (if (<= (:w_topline win) (:lnum loff))
                                                        (let [win (update win :w_topline dec)
                                                              win (comp-botline win)
                                                              win (assoc-in win [:w_cursor :lnum] (dec (:w_botline win)))]
                                                            (update win :w_valid & (bit-not (| VALID_WCOL VALID_CHEIGHT VALID_WROW VALID_CROW))))
                                                        (let [win (assoc win :w_topline (:lnum loff))]
                                                            (update win :w_valid & (bit-not (| VALID_WROW VALID_CROW VALID_BOTLINE))))
                                                    ))
                                            ))
                                    )]
                                (recur win (dec count)))
                        )))
              win (cursor-correct win)
              win (if ok (beginline win, (| BL_SOL BL_FIX)) win)
              win (update win :w_valid & (bit-not (| VALID_WCOL VALID_WROW VALID_VIRTCOL)))
              ;; Avoid the screen jumping up and down when 'scrolloff' is non-zero.
              ;; But make sure we scroll at least one line (happens with mix of long wrapping lines and non-wrapping line).
              win (if (and ok (== dir FORWARD) (check-top-offset win))
                    (let [win (scroll-cursor-top win, 1, false)]
                        (if (and (<= (:w_topline win) o'topline) (< o'topline lmax)) (assoc win :w_topline (inc o'topline)) win))
                    win
                )]
            [(redraw-later win, VALID) ok]
        )
    ))

(defn- #_window_C onepage [#_window_C win, #_int dir, #_long count]
    (let [[win _] (onepage? win, dir, count)]
        win
    ))

;; Decide how much overlap to use for page-up or page-down scrolling.
;; This is symmetric, so that doing both keeps the same lines displayed.
;; Three lines are examined:
;;
;;  before CTRL-F           after CTRL-F / before CTRL-B
;;     etc.                     l1
;;  l1 last but one line        ------------
;;  l2 last text line           l2 top text line
;;  -------------               l3 second text line
;;  l3                             etc.

(defn- #_lineoff_C get-scroll-overlap [#_window_C win, #_long lnum, #_int dir]
    (let [#_int min_height (- (:w_height win) 2)         #_lineoff_C loff (lineoff_C. lnum (plines win, lnum, true))           #_int h1 (:height loff)]
        (if (< min_height h1)
            loff ;; no overlap
            (let [#_lineoff_C over0 loff                 loff (if (< 0 dir) (botline-forw loff, win) (topline-back loff, win)) #_int h2 (:height loff)]
                (if (or (== h2 MAXCOL) (< min_height (+ h2 h1)))
                    over0 ;; no overlap
                    (let [#_lineoff_C over1 loff         loff (if (< 0 dir) (botline-forw loff, win) (topline-back loff, win)) #_int h3 (:height loff)]
                        (if (or (== h3 MAXCOL) (< min_height (+ h3 h2)))
                            over0 ;; no overlap
                            (let [#_lineoff_C over2 loff loff (if (< 0 dir) (botline-forw loff, win) (topline-back loff, win)) #_int h4 (:height loff)]
                                (if (or (== h4 MAXCOL) (< min_height (+ h4 h3 h2)) (< min_height (+ h3 h2 h1)))
                                    over1 ;; 1 line overlap
                                    over2 ;; 2 lines overlap
                                ))
                        ))
                ))
        )))

;; Scroll 'scroll' lines up or down.

(defn- #_window_C halfpage [#_window_C win, #_boolean ctrl_d, #_long Prenum]
    (when (non-zero? Prenum)
        (reset! (:wo_scr (:w_options win)) (min Prenum (:w_height win))))
    (let [scr (min @(:wo_scr (:w_options win)) (:w_height win))
          win (validate-botline win)
          win (cond ctrl_d ;; scroll the text up
                (let [lmax (line-count @curbuf) [win scr]
                        (loop-when [win win scr scr sed 0 room (:w_empty_rows win)] (and (< 0 scr) (<= (:w_botline win) lmax)) => [win scr]
                            (let [n (plines win, (:w_topline win), true) scr (- scr n)]
                                (if (and (< scr 0) (< 0 sed))
                                    [win scr]
                                    (let [win (update win :w_topline inc)
                                          win (update win :w_valid & (bit-not (| VALID_CROW VALID_WROW)))
                                          win (if (< (:lnum (:w_cursor win)) lmax)
                                                (-> win
                                                    (update-in [:w_cursor :lnum] inc)
                                                    (update :w_valid & (bit-not (| VALID_VIRTCOL VALID_CHEIGHT VALID_WCOL))))
                                                win)
                                          ;; Correct "w_botline" for changed "w_topline".
                                          ;; Won't work when there are filler lines.
                                          [win room]
                                            (loop [win win room (+ room n)]
                                                (let-when [n (plines win, (:w_botline win), true)] (<= n room) => [win room]
                                                    (let [win (update win :w_botline inc) room (- room n)]
                                                        (recur-if (<= (:w_botline win) lmax) [win room] => [win room])
                                                    ))
                                            )]
                                        (recur win scr (+ sed n) room))
                                ))
                        )]
                    (if (< 0 scr) ;; when hit bottom of the file: move cursor down
                        (-> win
                            (update-in [:w_cursor :lnum] + scr)
                            (check-cursor-lnum))
                        win)
                )
            :else ;; scroll the text down
                (let [lmin 1 [win scr]
                        (loop-when [win win scr scr sed 0] (and (< 0 scr) (< lmin (:w_topline win))) => [win scr]
                            (let [n (plines win, (dec (:w_topline win)), true) scr (- scr n)]
                                (if (and (< scr 0) (< 0 sed))
                                    [win scr]
                                    (let [win (update win :w_topline dec)
                                          win (update win :w_valid & (bit-not (| VALID_CROW VALID_WROW VALID_BOTLINE VALID_BOTLINE_AP)))
                                          win (if (< lmin (:lnum (:w_cursor win)))
                                                (-> win
                                                    (update-in [:w_cursor :lnum] dec)
                                                    (update :w_valid & (bit-not (| VALID_VIRTCOL VALID_CHEIGHT VALID_WCOL))))
                                                win
                                            )]
                                        (recur win scr (+ sed n)))
                                ))
                        )]
                    (if (< 0 scr) ;; when hit top of the file: move cursor up
                        (update-in win [:w_cursor :lnum] #(max lmin (- % scr)))
                        win
                    ))
            )]
        (-> win
            (cursor-correct)
            (beginline (| BL_SOL BL_FIX))
            (redraw-later VALID)
        )
    ))

;;; ============================================================================================== VimX

;; Reset the cterm colors to what they were before Vim was started,
;; if possible.  Otherwise reset them to zero.

(defn- #_void restore-cterm-colors []
    (reset! cterm_normal_fg_color 0)
    (reset! cterm_normal_fg_bold 0)
    (reset! cterm_normal_bg_color 0)
    nil)

;; Combine attributes.
;; "prim_attr" overrules "char_attr".

(defn- #_int hl-combine-attr [#_int char_attr, #_int prim_attr]
    (cond (zero? char_attr)
        prim_attr
    (and (<= char_attr HL_ALL) (<= prim_attr HL_ALL))
        (| char_attr prim_attr)
    :else
        0
    ))

;;; ============================================================================================== VimG

;; Main loop: execute Normal mode commands until exiting Vim.
;; Also used to handle commands in the command-line window, until the window is closed.

(defn- #_window_C main-loop [#_window_C win, #_boolean cmdwin]
    ;; cmdwin: true when working in the command-line window
    (let [#_oparg_C oa (NEW_oparg_C)]                                           ;; operator arguments
        (loop-when [[win oa] [win oa]] (or (not cmdwin) (zero? @cmdwin_result)) => win
            (let [win (when' (stuff-empty) => win
                        (let [win (when' @need_wait_return => win               ;; if wait-return() still needed ...
                                    (wait-return win, FALSE)                    ;; ... call it now
                                )]
                            (when (and @need_start_insertmode (goto-im) (not @VIsual_active))
                                (reset! need_start_insertmode false)
                                (stuff-string (u8 "i")))                        ;; start insert mode next
                            win
                        ))
                  ;; Reset "got_int" now that we got back to the main loop.
                  ;; Except when inside a ":g/pat/cmd" command, then the "got_int" needs to abort the ":g" command.
                  ;; For ":g/pat/vi" we reset "got_int" when used once.
                  ;; When used a second time we go back to Ex mode and abort the ":g" command.
                  win (when' @got_int => win
                        (let [win (vflush win)]                                 ;; flush all buffers
                            (reset! got_int false)
                            win
                        ))
                  _ (reset! msg_scroll false)
                  ;; If "skip_redraw" is set (for ":" in wait-return()), don't redraw now.
                  ;; If there is nothing in the stuff buffer or "do_redraw" is true, update cursor and redraw.
                  win (cond @skip_redraw
                        (do (reset! skip_redraw false)
                            win)
                    (or @do_redraw (stuff-empty))
                        ;; Before redrawing, make sure "w_topline" is correct,
                        ;; also "w_leftcol" if lines don't wrap, and "w_skipcol" if lines wrap.
                        (let [win (-> win (update-topline) (validate-cursor))
                              win (cond
                                    @VIsual_active                      (update-curbuf win, INVERTED)
                                    (non-zero? @must_redraw)            (update-screen win, 0)
                                    (or @redraw_cmdline @clear_cmdline) (showmode win)
                                    :else                               win)
                              _ (redraw-statuslines)
                              ;; display message after redraw
                              win (when' (some? @keep_msg) => win
                                    ;; Don't reset "keep_msg", msg-attr-keep() uses it to check for duplicates.
                                    (msg-attr win, @keep_msg, @keep_msg_attr))
                              _ (reset! emsg_on_display false)                  ;; can delete error message now
                              _ (reset! did_emsg false)
                              _ (reset! msg_didany false)                       ;; reset lines_left in msg-start()
                              win (-> win (showruler false) (setcursor))]
                            (cursor-on)
                            (reset! do_redraw false)
                            win)
                    :else
                        win)
                  ;; Update "w_curswant" if "w_set_curswant" has been set.
                  ;; Postponed until here to avoid computing "w_virtcol" too often.
                  win (update-curswant win)]
                ;; Get and execute a Normal mode command.
                (recur (normal-cmd win, oa, true))
            ))
    ))

;; Exit properly.
(defn- #_void getout [#_int exitval]
    (reset! exiting true)
    ;; Position the cursor on the last screen line, below all the text.
    (windgoto (dec @Rows), 0)
    (when @did_emsg
        ;; give the user a chance to read the (error) message
        (reset! no_wait_return FALSE)
        (swap! curwin wait-return FALSE))
    (mch-exit exitval))

;;; ============================================================================================== VimZ

(defn #_void -main [& #_String* args]
    (let [_ (reset! starttime (ร ._time libC))
          _ (reset! curbuf (newBuffer))
          _ (init-chartab false)
          _ (swap! curbuf unchanged)
          #_window_C win (-> (newWindow nil) (assoc :w_focused true))
          _ (swap! curbuf assoc :b_nwindows 1)      ;; there is one window
          win (redraw-later win, NOT_VALID)
          win (let [#_frame_C fr (-> (newFrame win) (assoc :fr_height (- @Rows @p_ch) :fr_width @Cols))]
                (reset! ch_used @p_ch)
                (reset! topframe fr)
                (assoc win :w_frame fr))
          ;; Set the default values for the options.
          win (set-init-1 win)
          ;; Don't redraw until much later.
          _ (swap! no_redraw inc)
          ;; mch-init() sets up the terminal (window) for use.
          ;; This must be done after resetting "full_screen", otherwise it may move the cursor (MSDOS).
          ;; Note that we may use mch-exit() before mch-init()!
          _ (mch-init)
          win (set-term win)                        ;; set terminal capabilities (will set "full_screen")
          _ (screen-start)                          ;; don't know where cursor is now
          ;; Set the default values for the options that use Rows and Cols.
          _ (ui-get-shellsize)                      ;; inits Rows and Cols
          _ (win-init-size)
          _ (reset! cmdline_row (- @Rows @p_ch))
          _ (reset! msg_row @cmdline_row)
          _ (screen-alloc false)                    ;; allocate screen buffers
          _ (win-comp-scroll win)
          _ (comp-col)
          _ (reset! msg_scroll true)
          _ (reset! no_wait_return TRUE)
          ;; Start putting things on the screen.
          ;; Scroll screen down before drawing over it.
          ;; Clear screen now, so file message will not be cleared.
          _ (reset! starting NO_BUFFERS)
          _ (reset! no_wait_return FALSE)
          _ (reset! msg_scroll false)
          ;; When switching screens and something caused a message from a vimrc script,
          ;; need to output an extra newline on exit.
          _ (when (and (or @did_emsg @msg_didout) (non-eos? @T_TI))
                (reset! newline_on_exit true))
          ;; When done something that is not allowed or error message call wait-return().
          ;; This must be done before start-termcap(), because it may switch to another screen.
          ;; It must be done after settmode(TMODE_RAW), because we want to react on a single key stroke.
          ;; Call settmode() and start-termcap() here, so the T_KS and T_TI may be defined by set-term().
          _ (settmode TMODE_RAW)
          win (when' (or @need_wait_return @msg_didany) => win
                (wait-return win, TRUE))
          _ (start-termcap)                         ;; start termcap if not done by wait-return()
          _ (when @scroll_region
                (scroll-region-reset))              ;; in case Rows changed
          _ (scroll-start)                          ;; may scroll the screen to the right position
          _ (screen-clear)                          ;; clear screen
          _ (reset! no_wait_return TRUE)
          win (setpcmark win)
          win (win-enter win, @firstwin)            ;; make the first window the current window
          _ (reset! no_redraw 0)
          _ (redraw-all-later NOT_VALID)
          _ (reset! no_wait_return FALSE)
          _ (reset! starting 0)
          _ (when @p_im
                (reset! need_start_insertmode true)) ;; start in insert mode
          ;; If ":startinsert" command used,
          ;; stuff a dummy command to be able to call normal-cmd(),
          ;; which will then start Insert mode.
          _ (when (non-zero? @restart_edit)
                (stuff-char K_NOP))
          ;; Call the main command loop.  This never returns.
          win (main-loop win, false)]
        #_nil 0
    ))
