(ns vijure.core
    (:refer-clojure :exclude [/ boolean byte short int long])
    (:require [org.baznex.imports :refer [import-static]])
    (:import [java.util Arrays])
    (:gen-class))

(org.baznex.imports/rename {vijure.VimA$Bytes 'Bytes})

(import-static vijure.VimA char_u u8 BEQ BNE BDIFF BLT BLE asc_toupper asc_tolower MEMCMP ACOPY BCOPY AFILL BFILL STRCAT STRCMP STRCPY STRLEN STRNCASECMP STRNCMP STRNCPY)
; %% (import-static vijure.VimB SIGHUP SIGQUIT SIGILL SIGTRAP SIGABRT SIGFPE SIGBUS SIGSEGV SIGSYS SIGALRM SIGTERM SIGVTALRM SIGPROF SIGXCPU SIGXFSZ SIGUSR1 SIGUSR2 SIGINT SIGWINCH SIGTSTP SIGPIPE)

(defmacro ยง [& _])
(defmacro ร [& _])

(defmacro def- [s i] `(def ~(vary-meta s assoc :private true) ~i))

(def- null nil)

(defmacro != [x y] `(not (== ~x ~y)))

(defmacro non-zero? [x] `(not (zero? ~x)))

(defmacro ... [a i] `(~a ~i))

(defmacro any
    ([f x y] `(~f ~x ~y))
    ([f x y & z] `(let [f# ~f x# ~x _# (any f# x# ~y)] (if _# _# (any f# x# ~@z)))))

(defn- ==?
    ([x y] (if (sequential? x) (if (seq x) (or (==? (first x) y) (recur (rest x) y)) false) (if (sequential? y) (recur y x) (== x y))))
    ([x y & z] (==? x (cons y z))))

(defmacro let-when [x y & w]
    (let [[_ & w] (if (= '=> (first w)) (rest w) (cons nil w))]
        `(let [~@x] (if ~y (do ~@w) ~_))))

(letfn [(l' [x y z w]
    (let [x (cond (vector? x) x (symbol? x) [x x] :else [`_# x]) z (cond (vector? z) `((recur ~@z)) (some? z) `((recur ~z))) [_ & w] (if (= '=> (first w)) (rest w) (cons nil w))]
        `(loop [~@x] (if ~y (do ~@w ~@z) ~_))))]
            (defmacro loop-when [x y & w] (l' x y nil w))
            (defmacro loop-when-recur [x y z & w] (l' x y z w)))
(defmacro recur-if [y z & w]
    (let [z (cond (vector? z) `(recur ~@z) (some? z) `(recur ~z)) _ (if (= '=> (first w)) (second w))]
        `(if ~y ~z ~_)))

(def- / quot)
(def- % rem)

(def- & bit-and)
(def- | bit-or)
(def- << bit-shift-left)
(def- >>> unsigned-bit-shift-right)

(defmacro flag? [x y] `(non-zero? (& ~x ~y)))
(defmacro non-flag? [x y] `(zero? (& ~x ~y)))

(defn- boolean? [b] (instance? Boolean b))

(def- byte! unchecked-byte)

(defn- boolean ([] (boolean nil)) ([b] (cond (nil? b) false (boolean? b) b :else (throw (IllegalArgumentException. (str "fuzzy boolean " b))))))
(defn- byte    ([] (byte nil))    ([n] (clojure.core/byte (if (nil? n) 0 n))))
(defn- short   ([] (short nil))   ([n] (clojure.core/short (if (nil? n) 0 n))))
(defn- int     ([] (int nil))     ([n] (clojure.core/int (if (nil? n) 0 n))))
(defn- long    ([] (long nil))    ([n] (clojure.core/long (if (nil? n) 0 n))))
(defn- object  ([] (object nil))  ([o] o))

(def- maybean int)

(defmacro def'type* [& types] (cons 'do
    (map (fn [t] (let [t* (symbol (str t \*))]
        `(defn- ~t* [v#] (cond (sequential? v#) (mapv ~t v#) (number? v#) (recur (repeat v# nil)) :else (assert (nil? v#) (str "fuzzy " '~t* " " v#))))
    )) types)))
(def'type* boolean byte byte* int int* long object object*)

(def- frag_C* object*)

(def- C (map #(symbol (str % "_C")) '(barray buffblock buffer buffheader cmdline_info fmark fragnode frame lpos match matchitem memline msgchunk nfa_pim nfa_state oparg pos posmatch reg_extmatch regmatch regmmatch regprog regsave regsub regsubs save_se soffset termios typebuf u_entry u_header u_link visualinfo window winopt yankreg)))

(def- C* (map #(symbol (str % "_C*")) '(attrentry backpos btcap cmdname decomp digr fmark frag frame hl_group key_name linepos llpos lpos modmasktable multipos nfa_state nfa_thread nv_cmd pos save_se signalinfo spat termcode typebuf vimoption wline yankreg)))

(def- C** (map #(symbol (str % "_C**")) '(histentry)))

(def- F (map #(symbol (str % "_F")) '(ex_func nv_func)))

(let [I '(byte byte! byte* byte** int int* long maybean) O (concat '(Bytes Object) C) O* (concat '(Bytes* Bytes*') C*)
      T (merge (zipmap I I) (zipmap O (repeat 'object)) (zipmap O* (repeat 'object*)))]
    (letfn [(f [t s] (if s (cons `(def- ~(first s) (~t ~(second s))) (f t (nnext s))) '(nil)))]
        (defmacro final [t & s] (let [t' (T t)] (assert t' (str "unexpected type: " t)) (when s (cons 'do (f t' s)))))))

(let [I '(boolean boolean* byte* int int* int** long long* maybean) O (cons 'Bytes C) O* (concat '(Bytes* Object*) C*) O** C**
      T (merge (zipmap I I) (zipmap O (repeat 'object)) (zipmap O* (repeat 'object*)) (zipmap O** (repeat 'object**)))]
    (letfn [(f [t s] (if s (cons `(def- ~(first s) (atom (~t ~(second s)))) (f t (nnext s))) '(nil)))]
        (defmacro atom! [t & s] (let [t' (T t)] (assert t' (str "unexpected type: " t)) (when s (cons 'do (f t' s)))))))

(let [I '#{boolean byte int long} A '(byte* int*) O (concat '(Bytes Object) C F) O* (concat '(Bytes* Object*) C*) O** C**
      T (merge (zipmap I I) (zipmap A A) (zipmap O (repeat 'object)) (zipmap O* (repeat 'object*)) (zipmap O** (repeat 'object**)))]
    (letfn [(f' [[f t n & [v]]] (let [t' (T t)] (assert t' (str "unexpected type: " t))
            (case f atom' `[~n (atom (~t' ~v))]
                    field `[~(if (I t) (vary-meta n assoc :tag t) n) (~t' ~v)])))]
        (defmacro class! [c [& fs] & _] (let [fs' (map f' fs)]
            `(do (defrecord ~c ~(mapv first fs') ~@_)
                 (defn- ~(symbol (str "NEW_" c)) [] (new ~c ~@(map second fs'))) nil)))))

;;; ============================================================================================== VimA

(final maybean FALSE 0, TRUE 1, MAYBE 2)

#_(final Bytes VIMVERSION (u8 "VIM - Vi IMproved 7.4.692"))

(declare alphaOrd lowerOrd upperOrd rot13 ctrl-key is-special TERMCAP2KEY KEY2TERMCAP0 KEY2TERMCAP1 KB-SECOND KB-THIRD toSpecial vim-iswhite COPY-pos ARRAY-pos MIN1-lpos COPY-lpos ARRAY-lpos COPY--lpos COPY-regmmatch COPY-fmark ARRAY-fmark COPY-visualinfo COPY-buffblock COPY-buffheader ZER0-attrentry COPY-attrentry COPY-wline ARRAY-wline COPY-frame COPY-llpos ARRAY-llpos asc-islower asc-isupper asc-isalpha asc-isalnum asc-iscntrl asc-isgraph asc-isprint asc-ispunct hl-attr ltpos eqpos ltoreq lineempty bufempty mch-write mch-inchar handle-resize mch-delay sig-winch catch-sigint catch-sigpwr may-core-dump deathtrap mch-suspend mch-init set-signals catch-int-signal reset-signals catch-signals vim-handle-signal exit-scroll mch-exit mch-settmode get-stty mch-get-shellsize mch-set-shellsize mch-new-shellsize mch-breakcheck waitForChar realWaitForChar msg msg-attr msg-attr-keep msg-strtrunc trunc-string smsg smsg-attr emsg-not-now emsg emsg2 emsg-invreg wait-return hit-return-msg set-keep-msg msg-start msg-starthere msg-putchar msg-putchar-attr msg-outtrans msg-outtrans-attr msg-outtrans-len msg-outtrans-len-attr screen-puts-mbyte msg-puts msg-puts-title msg-puts-attr msg-puts-attr-len msg-puts-display msg-scroll-up inc-msg-scrolled store-sb-text may-clear-sb-text clear-sb-text show-sb-text msg-sb-start disp-sb-line t-puts msg-use-printf msg-puts-printf do-more-prompt msg-screen-putchar msg-moremsg repeat-message msg-check-screen msg-clr-eos msg-clr-eos-force msg-clr-cmdline msg-end msg-check give-warning display-confirm-msg bool-opt long-opt utf8-opt set-init-1 set-option-default set-options-default set-init-2 do-set illegal-char didset-options did-set-string-option check-colorcolumn set-bool-option set-num-option check-redraw findoption get-highlight-default showoneopt comp-col get-varp win-copy-options copy-winopt paste-option-changed fill-breakat-flags check-opt-strings opt-strings-flags can-bs get-sw-value get-sts-value find-mps-values briopt-check do-ascii linelen ex-retab ex-fixdel ex-sub do-sub-msg COPY-histentry ARRAY-histentry getcmdline text-locked text-locked-msg cmdline-charsize set-cmdspos set-cmdspos-cursor correct-cmdspos getexline alloc-cmdbuff realloc-cmdbuff draw-cmdline putcmdline unputcmdline put-on-cmdline save-cmdline restore-cmdline cmdline-paste cmdline-paste-str redrawcmdline redrawcmdprompt redrawcmd compute-cmdrow cursorcmd gotocmdline hist-char2type init-history clear-hist-entry in-history add-to-history ex-window do-cmdline-cmd do-cmdline current-win-nr do-one-cmd append-command find-command skip-range get-address invalid-range correct-range check-nextcmd ex-close ex-win-close ex-only ex-stop ex-syncbind do-sleep ex-set eval-to-string profile-setlimit profile-passed-limit find--command normal-cmd do-pending-operator op-colon op-function check-visual-highlight end-visual-mode reset-VIsual-and-resel reset-VIsual find-ident-under-cursor prep-redo-cmd prep-redo checkclearop checkclearopq clearop clearopbeep unshift-special clear-showcmd add-to-showcmd add-to-showcmd-c del-from-showcmd push-showcmd pop-showcmd display-showcmd do-check-scrollbind check-scrollbind nv-ignore nv-nop nv-error nv-addsub nv-page nv-screengo nv-scroll-line scroll-redraw nv-zet nv-colon nv-ctrlg nv-ctrlh nv-clear nv-ctrlo nv-Zet nv-ident get-visual-text nv-scroll nv-right nv-left nv-up nv-down nv-end nv-dollar nv-search nv-next normal-search nv-csearch nv-brackets nv-percent nv-mark nv-undo nv-kundo nv-replace v-swap-corners nv-Replace nv-vreplace n-swapchar nv-cursormark v-visop nv-subst nv-abbrev nv-optrans nv-gomark nv-pcmark nv-regname nv-visual start-selection may-start-select n-start-visual-mode nv-window nv-suspend nv-g-cmd n-opencmd nv-dot nv-redo nv-Undo nv-tilde nv-operator nv-lineop nv-home nv-pipe nv-bck-word nv-wordcmd adjust-cursor nv-beginline adjust-for-sel unadjust-for-sel nv-select nv-goto nv-normal nv-esc nv-edit invoke-edit nv-object nv-record nv-at nv-halfpage nv-join nv-put nv-open nv-drop nv-cursorhold COPY-yankreg ARRAY-yankreg get-op-type op-on-lines get-op-char get-extra-op-char op-shift shift-line shift-block block-insert op-reindent get-expr-register get-expr-line valid-yank-reg get-yank-register get-register put-register do-record stuff-yank do-execreg put-reedit-in-typebuf put-in-typebuf insert-reg stuffescaped get-spec-reg cmdline-paste-reg adjust-clip-reg may-get-selection op-delete mb-adjust-opend op-replace op-tilde swapchars swapchar op-insert op-change init-yank op-yank yank-copy-line do-put adjust-cursor-eol do-join? do-join block-prep do-addsub line-count-info cursor-pos-info setmark setmark-pos setpcmark checkpcmark movemark movechangelist getmark getnextmark check-mark one-adjust one-adjust-nodel mark-adjust col-adjust mark-col-adjust dedupe-jumplist copy-jumplist free-buff get-buffcont get-recorded get-inserted add-buff add-num-buff add-char-buff read-readbuf read-readbuffers start-stuff stuff-empty typeahead-noflush flush-buffers reset-redo cancel-redo append-redo append-redo-lit append-redo-char append-redo-number stuff-string stuff-redo stuff-redo-len stuff-char stuff-num init-redo read-redo start-redo start-redo-ins stop-redo-ins init-typebuf ins-typebuf ins-char-typebuf typebuf-changed del-typebuf gotchars may-sync-undo before-blocking updatescript vgetc safe-vgetc plain-vgetc vpeekc char-avail vungetc vgetorpeek inchar fix-input-buffer input-available vim-strsave-escape-special vim-unescape-special edit ins-redraw ins-ctrl-v edit-putchar edit-unputchar change-indent truncate-spaces backspace-until-column del-char-after-col? del-char-after-col get-literal insert-special isspecial insert-char redo-literal start-arrow stop-arrow stop-insert set-last-insert add-char2buf beginline oneright? oneright oneleft? oneleft cursor-up? cursor-up cursor-down? cursor-down stuff-inserted get-last-insert get-last-insert-save replace-push replace-push-mb replace-pop replace-join replace-pop-ins mb-replace-pop-ins replace-flush replace-do-bs ins-reg ins-ctrl-g ins-ctrl-hat ins-esc? ins-start-select? ins-insert ins-ctrl-o ins-shift ins-del ins-bs-one ins-bs? ins-left ins-home ins-end ins-s-left ins-right ins-s-right ins-up ins-pageup ins-down ins-pagedown ins-drop ins-tab? ins-eol? ins-eol ins-digraph ins-copychar ins-ctrl-ey ins-try-si do-insert-char-pre with-nl Magic un-Magic is-Magic no-Magic toggle-Magic re-op re-next operand operand-min operand-max operand-cmp re-multi-type backslash-trans get-char-class init-class-tab ri-digit ri-hex ri-octal ri-word ri-head ri-alpha ri-lower ri-upper ri-white re-multiline re-lookbehind get-equi-class reg-equi-class get-coll-element get-cpo-flags skip-anyof skip-regexp bt-regcomp regcomp-start reg regbranch regconcat regpiece regatom do-multibyte use-multibytecode regnode regc regmbc reginsert reginsert-nr reginsert-limits re-put-long regtail regoptail initchr save-parse-state restore-parse-state peekchr skipchr skipchr-keepstart getchr ungetchr gethexchrs getdecchrs getoctchrs coll-get-char read-limits COPY-regsave ARRAY-save-se create-regstack create-backpos reg-getline bt-regexec-nl bt-regexec-multi bt-regexec-both make-extmatch regtry reg-prev-class reg-match-visual regmatch push-regitem pop-regitem drop-regbehind drop-regstar regrepeat regnext prog-magic-wrong cleanup-subexpr cleanup-zsubexpr save-subexpr restore-subexpr reg-nextchar reg-nextline reg-save reg-restore reg-save-equal save-se-multi save-se-one save-se restore-se re-num-cmp match-with-backref re-mult-next mb-decompose cstrncmp cstrchr regtilde vim-regsub vim-regsub-multi vim-regsub-both nfa-regcomp-start nfa-get-reganch nfa-get-regstart nfa-get-match-text grow-post-array nfa-recognize-char-class emc1 emc2 nfa-emit-equi-class nfa-regatom nfa-do-multibyte nfa-regpiece nfa-regconcat nfa-regbranch nfa-reg re2post alloc-state nfa-max-width COPY-frag alloc-frag fr-single fr-patch fr-append new-nfa-stack st-push st-pop st-error post2nfa nfa-postprocess MIN1-multipos COPY-multipos ARRAY-multipos COPY--multipos ZER0-linepos COPY-linepos ARRAY-linepos COPY--linepos COPY-regsub COPY-regsubs COPY-nfa-pim COPY-nfa-thread ARRAY-nfa-thread ARRAY-nfa-list copy-pim clear-sub copy-sub copy-sub-off copy-ze-off sub-equal has-state-with-pos pim-equal match-follows state-in-list addstate addstate-here check-char-class match-backref match-zref nfa-save-listids nfa-restore-listids nfa-re-num-cmp recursive-regmatch failure-chance skip-to-start find-match-text nfa-regmatch nfa-regtry nfa-regexec-both nfa-regcomp nfa-regexec-nl nfa-regexec-multi vim-regcomp report-re-switch vim-regexec-both vim-regexec-prog vim-regexec vim-regexec-nl vim-regexec-multi new-spat search-regcomp get-search-pat save-re-pat ignorecase pat-has-uppercase last-search-pat last-pat-prog searchit first-submatch do-search searchc findmatch check-prevcol findmatchlimit check-linecomment showmatch cls-cursor fwd-word? fwd-word bck-word? bck-word end-word? end-word bckend-word? bckend-word skip-chars? back-in-line current-word current-block find-next-quote find-prev-quote current-quote current-search is-one-char linewhite ml-open ml-get ml-get-pos ml-get-cursor ml-append ml-replace ml-delete close-buffer newBuffer fileinfo col-print get-rel-pos set-chartab reset-chartab get-chartab init-chartab trans-characters transchar transchar-byte transchar-nonprint transchar-hex nr2hex mb-byte2cells mb-char2cells mb-ptr2cells mb-string2cells chartabsize linetabsize linetabsize-col win-linetabsize vim-isidentc vim-iswordc us-iswordb us-iswordp vim-isfnamec vim-isprintc lbr-chartabsize lbr-chartabsize-adv win-lbr-chartabsize win-nolbr-chartabsize in-win-border getvcol getvcol-nolist getvvcol getvcols skipwhite skipdigits asc-isdigit asc-isodigit asc-isxdigit getdigits vim-str2nr hex2nr digr do-digraph get-digraph getexactdigraph getdigraph us-byte2len mb-byte2len us-get-class intable utf-char2cells us-ptr2cells us-string2cells utf-off2cells us-ptr2char us-safe-read-char-adv us-ptr2char-adv us-ptr2char-cc us-ptr2char-cc-len utfc-char2bytes us-ptr2len us-ptr2len-len us-ptr2len-cc us-ptr2len-cc-len utf-char2len utf-char2bytes utf-iscomposing utf-printable utf-class utf-convert utf-fold utf-tolower utf-toupper utf-islower utf-isupper us--strnicmp us-strnicmp show-utf8 us-head-off us-off-next us-tail-off utf-find-illegal mb-adjust-pos us-ptr-back us-prevptr us-charlen mb-lefthalve mb-fix-col get-indent get-indent-str set-indent? set-indent copy-indent get-breakindent cin-is-cinword open-line? plines plines-nowrap plines-col plines-many ins-bytes ins-bytes-len ins-char ins-char-bytes ins-str del-char? del-char del-chars? del-chars del-bytes? del-bytes truncate-line del-lines gchar-pos gchar-cursor inindent skip-to-option-part changed changed-bytes changed-one-line appended-lines appended-lines-mark deleted-lines deleted-lines-mark changed-lines changed-lines-buf changed-common unchanged check-status ask-yesno get-keystroke msgmore beep-flush vim-beep prepare-to-exit preserve-exit slow-breakcheck fast-breakcheck goto-im virtual-active getviscol getviscol2 coladvance-force coladvance? coladvance getvpos coladvance3 inc-cursor? inc-cursor incp incl dec-cursor? dec-cursor decp decl get-cursor-rel-lnum check-cursor-lnum check-cursor-col check-cursor adjust-cursor-col leftcol-changed? leftcol-changed STRDUP STRNDUP vim-strsave-escaped vim-strup vim-strsave-up copy-chars vim-strncpy vim-strcat copy-option-part vim-strchr vim-strbyte vim-strrchr vim-isspace simplify-key handle-x-keys get-special-key-name find-special-key-name get-real-state emsg3 emsgn trigger-cursorhold u-save-cursor u-save u-savesub u-inssub u-savedel undo-allowed get-undolevel u-savecommon u-undo u-redo u-doit undo-time u-undoredo u-undo-end u-sync u-add-time u-get-headentry u-getbot u-freeheader u-freebranch u-freeentries u-saveline u-clearline u-undoline parse-builtin-tcap set-term out-flush out-flush-check out-char out-char-nf _addfmt _tgoto _tputs out-str-nf out-str term-windgoto term-cursor-right term-append-lines term-delete-lines term-set-winsize term-fg-color term-bg-color term-color ttest check-shellsize limit-screen-size win-new-shellsize shell-resized set-shellsize settmode start-termcap stop-termcap swapping-screen scroll-start cursor-on cursor-off term-cursor-shape scroll-region-set scroll-region-reset COPY-termcode ARRAY-termcode clear-termcodes add-termcode termcode-star find-termcode del-termcode del-termcode-idx check-termcode gather-termleader ui-write ui-inchar ui-delay ui-suspend ui-get-shellsize ui-set-shellsize ui-new-shellsize ui-breakcheck is-input-buf-full is-input-buf-empty read-from-input-buf fill-input-buf ui-cursor-shape check-col check-row redraw-later redraw-later-clear redraw-all-later redraw-curbuf-later redraw-winline update-curbuf update-screen conceal-cursor-line conceal-check-cursor-line update-single-line win-update win-draw-end advance-color-col win-line comp-char-differs char-needs-redraw screen-line status-redraw-all redraw-statuslines draw-vsep-win win-redr-status stl-connected screen-putchar screen-getbytes screen-comp-differs screen-puts screen-puts-len start-search-hl end-search-hl init-search-hl prepare-search-hl next-search-hl next-search-hl-pos screen-start-highlight screen-stop-highlight reset-cterm-colors screen-char screen-draw-rectangle redraw-block screen-fill check-for-delay screen-valid screen-alloc screen-clear screenclear2 lineclear lineinvalid linecopy can-clear screen-start windgoto setcursor win-ins-lines win-del-lines win-do-lines win-rest-invalid screen-ins-lines screen-del-lines showmode msg-pos-mode unshowmode fillchar-status fillchar-vsep redrawing messaging showruler win-redr-ruler number-width screen-screencol screen-screenrow do-window cmd-with-count win-split win-split-ins win-init win-valid win-exchange win-rotate win-totop win-equal win-equal-rec one-window win-close win-free-mem winframe-remove win-altframe frame2win frame-has-win frame-new-height frame-fixed-height frame-fixed-width frame-add-statusline frame-new-width frame-add-vsep frame-fix-width frame-fix-height frame-minheight frame-minwidth close-others win-alloc-first newFrame win-init-size win-goto win-goto-ver win-goto-hor win-enter win-enter-ext newWindow win-free win-append win-remove frame-append frame-insert frame-remove win-alloc-lines win-free-lines shell-new-rows shell-new-columns win-comp-pos frame-comp-pos win-setheight frame-setheight win-setwidth frame-setwidth win-setminheight set-fraction win-new-height win-new-width win-comp-scroll command-height frame-add-height last-status last-status-rec min-rows clear-matches frame-check-height frame-check-width comp-botline redraw-for-cursorline update-topline-redraw update-topline scrolljump-value check-top-offset update-curswant check-cursor-moved changed-window-setting set-topline changed-cline-bef-curs changed-line-abv-curs validate-botline invalidate-botline approximate-botline validate-cursor curs-rows validate-virtcol validate-cheight validate-cursor-col win-col-off win-col-off2 curs-columns scrolldown scrollup topline-back botline-forw scroll-cursor-top set-empty-rows scroll-cursor-bot scroll-cursor-halfway cursor-correct onepage? onepage get-scroll-overlap halfpage do-check-cursorbind COPY-hl-group syn-get-sub-char restore-cterm-colors get-attr-entry clear-hl-tables hl-combine-attr syn-attr2attr syn-term-attr2entry syn-cterm-attr2entry set-hl-attr syn-name2id syn-check-group syn-add-group syn-id2attr syn-get-final-id highlight-changed main-loop getout)

;;; ============================================================================================== VimC

;; Definitions of various common control characters.

(final byte NUL     000)    ;; %% VimA/NUL
(final byte BELL    007)
(final byte BS      010)
(final byte TAB     (byte \tab))
(final byte NL      012)
(final byte FF      014)
(final byte CAR     015)    ;; CR is used by Mac OS X
(final byte ESC     033)
(final byte DEL    0x7f)

(final byte! POUND 0xa3)

(final Bytes
    NL_STR   (u8 "\012")
    ESC_STR  (u8 "\033")
    DEL_STR  (u8 "\177"))

(defmacro at
    ([x] (at x 0))
    ([x y] (.at x y)))

(defn- at?
    ([x z] (at? x 0 z))
    ([x y z] (== (.at x y) z)))
(defn- not-at?
    ([x z] (not-at? x 0 z))
    ([x y z] (!= (.at x y) z)))

(defn- eos?
    ([x] (eos? x 0))
    ([x y] (== (.at x y) NUL)))
(defn- non-eos?
    ([x] (non-eos? x 0))
    ([x y] (!= (.at x y) NUL)))
(defn- eos!
    ([x] (eos! x 0))
    ([x y] (.be x y, NUL)))

(defn- plus [x y] (.plus x y))
(defn- minus [x y] (.minus x y))

(defn- #_int alphaOrd [#_int x] (- x (if (< x (byte \a)) (byte \A) (byte \a))))
(defn- #_int lowerOrd [#_int x] (- x (byte \a)))
(defn- #_int upperOrd [#_int x] (- x (byte \A)))

(defn- #_int rot13 [#_int c, #_int a]
    (+ (% (+ (- c a) 13) 26) a))

(defn- #_int ctrl-key [#_byte c]
    (if (< c NUL) (char_u c) (bit-xor (asc_toupper c) 0x40)))       ;; '?' -> DEL, '@' -> ^@, etc.

(final Bytes
    CTRL_H_STR (u8 "\010")
    CTRL_V_STR (u8 "\026"))

(final byte
    Ctrl_AT   0,        ;; @
    Ctrl_A    1,
    Ctrl_B    2,
    Ctrl_C    3,
    Ctrl_D    4,
    Ctrl_E    5,
    Ctrl_F    6,
    Ctrl_G    7,
    Ctrl_H    8,
    Ctrl_I    9,
    Ctrl_J   10,
    Ctrl_K   11,
    Ctrl_L   12,
    Ctrl_M   13,
    Ctrl_N   14,
    Ctrl_O   15,
    Ctrl_P   16,
    Ctrl_Q   17,
    Ctrl_R   18,
    Ctrl_S   19,
    Ctrl_T   20,
    Ctrl_U   21,
    Ctrl_V   22,
    Ctrl_W   23,
    Ctrl_X   24,
    Ctrl_Y   25,
    Ctrl_Z   26,
                        ;; CTRL- [ Left Square Bracket == ESC
    Ctrl_BSL 28,        ;; \ BackSLash
    Ctrl_RSB 29,        ;; ] Right Square Bracket
    Ctrl_HAT 30,        ;; ^
    Ctrl__   31)

;; ----------------------------------------------------------------------- ;;

;; Keycode definitions for special keys.
;;
;; Any special key code sequences are replaced by these codes.

;; KB_SPECIAL is the first byte of a special key code and is always followed by two bytes.
;; The second byte can have any value.  ASCII is used for normal termcap entries,
;; 0x80 and higher for special keys, see below.
;; The third byte is guaranteed to be between 0x02 and 0x7f.

(final byte! KB_SPECIAL         0x80)

;; Positive characters are "normal" characters.
;; Negative characters are special key codes.  Only characters below -0x200 are used,
;; so that the absolute value can't be mistaken for a single-byte character.

(defn- #_boolean is-special [#_int c]
    (< c 0))

;; NUL cannot be in the input string, therefore it is replaced by
;;      KB_SPECIAL  KS_ZERO     KE_FILLER

(final byte! KS_ZERO            255)

;; KB_SPECIAL cannot be in the input string, therefore it is replaced by
;;      KB_SPECIAL  KS_SPECIAL  KE_FILLER

(final byte! KS_SPECIAL         254)

;; KS_EXTRA is used for keys that have no termcap name
;;      KB_SPECIAL  KS_EXTRA    KE_xxx

(final byte! KS_EXTRA           253)

;; KS_MODIFIER is used when a modifier is given for a (special) key
;;      KB_SPECIAL  KS_MODIFIER bitmask

(final byte! KS_MODIFIER        252)

;; These are used for the GUI
;;      KB_SPECIAL  KS_xxx      KE_FILLER

(final byte! KS_VER_SCROLLBAR   249)
(final byte! KS_HOR_SCROLLBAR   248)

;; Used for switching Select mode back on after a mapping or menu.

(final byte! KS_SELECT          245)

;; Used a termcap entry that produces a normal character.

(final byte! KS_KEY             242)

;; Filler used after KS_SPECIAL and others.

(final byte KE_FILLER            \X)

;; Translation of three byte code "KB_SPECIAL a b" into int "K_xxx" and back.

(defn- #_int TERMCAP2KEY [#_byte a, #_byte b]
    (int (- (+ (char_u a) (<< (char_u b) 8)))))

(defn- #_byte KEY2TERMCAP0 [#_int x]
    (byte! (& (- x) 0xff)))

(defn- #_byte KEY2TERMCAP1 [#_int x]
    (byte! (& (>>> (- x) 8) 0xff)))

;; Get second or third byte when translating special key code into three bytes.

(defn- #_byte KB-SECOND [#_int c]
    (cond (== c (char_u KB_SPECIAL)) KS_SPECIAL (== c NUL) KS_ZERO :else (KEY2TERMCAP0 c)))

(defn- #_byte KB-THIRD [#_int c]
    (if (any == c (char_u KB_SPECIAL) NUL) KE_FILLER (KEY2TERMCAP1 c)))

;; Codes for keys that do not have a termcap name.
;;
;; KB_SPECIAL KS_EXTRA KE_xxx

(final byte
    KE_S_UP 4,            ;; shift-up
    KE_S_DOWN 5,          ;; shift-down

    KE_S_F1 6,            ;; shifted function keys
    KE_S_F2 7,
    KE_S_F3 8,
    KE_S_F4 9,
    KE_S_F5 10,
    KE_S_F6 11,
    KE_S_F7 12,
    KE_S_F8 13,
    KE_S_F9 14,
    KE_S_F10 15,

    KE_S_F11 16,
    KE_S_F12 17,

;; Symbols for pseudo keys which are translated from the real key symbols above.

    KE_IGNORE 53,         ;; ignored mouse drag/release

    KE_TAB 54,            ;; unshifted TAB key

    KE_XF1 56,            ;; extra vt100 function keys for xterm
    KE_XF2 57,
    KE_XF3 58,
    KE_XF4 59,
    KE_XEND 60,           ;; extra (vt100) end key for xterm
    KE_ZEND 61,           ;; extra (vt100) end key for xterm
    KE_XHOME 62,          ;; extra (vt100) home key for xterm
    KE_ZHOME 63,          ;; extra (vt100) home key for xterm
    KE_XUP 64,            ;; extra vt100 cursor keys for xterm
    KE_XDOWN 65,
    KE_XLEFT 66,
    KE_XRIGHT 67,

    KE_S_XF1 70,          ;; extra vt100 shifted function keys for xterm
    KE_S_XF2 71,
    KE_S_XF3 72,
    KE_S_XF4 73,

    KE_KINS 78,           ;; keypad Insert key
    KE_KDEL 79,           ;; keypad Delete key

    KE_CMDWIN 83,         ;; open command-line window from Command-line Mode

    KE_C_LEFT 84,         ;; control-left
    KE_C_RIGHT 85,        ;; control-right
    KE_C_HOME 86,         ;; control-home
    KE_C_END 87,          ;; control-end

    KE_DROP 94,           ;; DnD data is available
    KE_CURSORHOLD 95,     ;; CursorHold event

    KE_NOP 98)            ;; doesn't do anything

;; the three byte codes are replaced with the following int when using vgetc()

(final int
    K_ZERO          (TERMCAP2KEY KS_ZERO KE_FILLER),

    K_UP            (TERMCAP2KEY (byte \k) (byte \u)),
    K_DOWN          (TERMCAP2KEY (byte \k) (byte \d)),
    K_LEFT          (TERMCAP2KEY (byte \k) (byte \l)),
    K_RIGHT         (TERMCAP2KEY (byte \k) (byte \r)),
    K_S_UP          (TERMCAP2KEY KS_EXTRA KE_S_UP),
    K_S_DOWN        (TERMCAP2KEY KS_EXTRA KE_S_DOWN),
    K_S_LEFT        (TERMCAP2KEY (byte \#) (byte \4)),
    K_C_LEFT        (TERMCAP2KEY KS_EXTRA KE_C_LEFT),
    K_S_RIGHT       (TERMCAP2KEY (byte \%) (byte \i)),
    K_C_RIGHT       (TERMCAP2KEY KS_EXTRA KE_C_RIGHT),
    K_S_HOME        (TERMCAP2KEY (byte \#) (byte \2)),
    K_C_HOME        (TERMCAP2KEY KS_EXTRA KE_C_HOME),
    K_S_END         (TERMCAP2KEY (byte \*) (byte \7)),
    K_C_END         (TERMCAP2KEY KS_EXTRA KE_C_END),
    K_TAB           (TERMCAP2KEY KS_EXTRA KE_TAB),
    K_S_TAB         (TERMCAP2KEY (byte \k) (byte \B)),

;; extra set of function keys F1-F4, for vt100 compatible xterm
    K_XF1           (TERMCAP2KEY KS_EXTRA KE_XF1),
    K_XF2           (TERMCAP2KEY KS_EXTRA KE_XF2),
    K_XF3           (TERMCAP2KEY KS_EXTRA KE_XF3),
    K_XF4           (TERMCAP2KEY KS_EXTRA KE_XF4),

;; extra set of cursor keys for vt100 compatible xterm
    K_XUP           (TERMCAP2KEY KS_EXTRA KE_XUP),
    K_XDOWN         (TERMCAP2KEY KS_EXTRA KE_XDOWN),
    K_XLEFT         (TERMCAP2KEY KS_EXTRA KE_XLEFT),
    K_XRIGHT        (TERMCAP2KEY KS_EXTRA KE_XRIGHT),

    K_F1            (TERMCAP2KEY (byte \k) (byte \1)),   ;; function keys
    K_F2            (TERMCAP2KEY (byte \k) (byte \2)),
    K_F3            (TERMCAP2KEY (byte \k) (byte \3)),
    K_F4            (TERMCAP2KEY (byte \k) (byte \4)),
    K_F5            (TERMCAP2KEY (byte \k) (byte \5)),
    K_F6            (TERMCAP2KEY (byte \k) (byte \6)),
    K_F7            (TERMCAP2KEY (byte \k) (byte \7)),
    K_F8            (TERMCAP2KEY (byte \k) (byte \8)),
    K_F9            (TERMCAP2KEY (byte \k) (byte \9)),
    K_F10           (TERMCAP2KEY (byte \k) (byte \;)),

    K_F11           (TERMCAP2KEY (byte \F) (byte \1)),
    K_F12           (TERMCAP2KEY (byte \F) (byte \2)),

;; extra set of shifted function keys F1-F4, for vt100 compatible xterm
    K_S_XF1         (TERMCAP2KEY KS_EXTRA KE_S_XF1),
    K_S_XF2         (TERMCAP2KEY KS_EXTRA KE_S_XF2),
    K_S_XF3         (TERMCAP2KEY KS_EXTRA KE_S_XF3),
    K_S_XF4         (TERMCAP2KEY KS_EXTRA KE_S_XF4),

    K_S_F1          (TERMCAP2KEY KS_EXTRA KE_S_F1),  ;; shifted func. keys
    K_S_F2          (TERMCAP2KEY KS_EXTRA KE_S_F2),
    K_S_F3          (TERMCAP2KEY KS_EXTRA KE_S_F3),
    K_S_F4          (TERMCAP2KEY KS_EXTRA KE_S_F4),
    K_S_F5          (TERMCAP2KEY KS_EXTRA KE_S_F5),
    K_S_F6          (TERMCAP2KEY KS_EXTRA KE_S_F6),
    K_S_F7          (TERMCAP2KEY KS_EXTRA KE_S_F7),
    K_S_F8          (TERMCAP2KEY KS_EXTRA KE_S_F8),
    K_S_F9          (TERMCAP2KEY KS_EXTRA KE_S_F9),
    K_S_F10         (TERMCAP2KEY KS_EXTRA KE_S_F10),

    K_S_F11         (TERMCAP2KEY KS_EXTRA KE_S_F11),
    K_S_F12         (TERMCAP2KEY KS_EXTRA KE_S_F12),

    K_HELP          (TERMCAP2KEY (byte \%) (byte \1)),
    K_UNDO          (TERMCAP2KEY (byte \&) (byte \8)),

    K_BS            (TERMCAP2KEY (byte \k) (byte \b)),

    K_INS           (TERMCAP2KEY (byte \k) (byte \I)),
    K_KINS          (TERMCAP2KEY KS_EXTRA KE_KINS),
    K_DEL           (TERMCAP2KEY (byte \k) (byte \D)),
    K_KDEL          (TERMCAP2KEY KS_EXTRA KE_KDEL),
    K_HOME          (TERMCAP2KEY (byte \k) (byte \h)),
    K_KHOME         (TERMCAP2KEY (byte \K) (byte \1)),   ;; keypad home (upper left)
    K_XHOME         (TERMCAP2KEY KS_EXTRA KE_XHOME),
    K_ZHOME         (TERMCAP2KEY KS_EXTRA KE_ZHOME),
    K_END           (TERMCAP2KEY (byte \@) (byte \7)),
    K_KEND          (TERMCAP2KEY (byte \K) (byte \4)),   ;; keypad end (lower left)
    K_XEND          (TERMCAP2KEY KS_EXTRA KE_XEND),
    K_ZEND          (TERMCAP2KEY KS_EXTRA KE_ZEND),
    K_PAGEUP        (TERMCAP2KEY (byte \k) (byte \P)),
    K_PAGEDOWN      (TERMCAP2KEY (byte \k) (byte \N)),
    K_KPAGEUP       (TERMCAP2KEY (byte \K) (byte \3)),   ;; keypad pageup (upper R.)
    K_KPAGEDOWN     (TERMCAP2KEY (byte \K) (byte \5)),   ;; keypad pagedown (lower R.)

    K_KPLUS         (TERMCAP2KEY (byte \K) (byte \6)),   ;; keypad plus
    K_KMINUS        (TERMCAP2KEY (byte \K) (byte \7)),   ;; keypad minus
    K_KDIVIDE       (TERMCAP2KEY (byte \K) (byte \8)),   ;; keypad /
    K_KMULTIPLY     (TERMCAP2KEY (byte \K) (byte \9)),   ;; keypad *
    K_KENTER        (TERMCAP2KEY (byte \K) (byte \A)),   ;; keypad Enter
    K_KPOINT        (TERMCAP2KEY (byte \K) (byte \B)),   ;; keypad . or ,

    K_K0            (TERMCAP2KEY (byte \K) (byte \C)),   ;; keypad 0
    K_K1            (TERMCAP2KEY (byte \K) (byte \D)),   ;; keypad 1
    K_K2            (TERMCAP2KEY (byte \K) (byte \E)),   ;; keypad 2
    K_K3            (TERMCAP2KEY (byte \K) (byte \F)),   ;; keypad 3
    K_K4            (TERMCAP2KEY (byte \K) (byte \G)),   ;; keypad 4
    K_K5            (TERMCAP2KEY (byte \K) (byte \H)),   ;; keypad 5
    K_K6            (TERMCAP2KEY (byte \K) (byte \I)),   ;; keypad 6
    K_K7            (TERMCAP2KEY (byte \K) (byte \J)),   ;; keypad 7
    K_K8            (TERMCAP2KEY (byte \K) (byte \K)),   ;; keypad 8
    K_K9            (TERMCAP2KEY (byte \K) (byte \L)),   ;; keypad 9

    K_VER_SCROLLBAR (TERMCAP2KEY KS_VER_SCROLLBAR KE_FILLER),
    K_HOR_SCROLLBAR (TERMCAP2KEY KS_HOR_SCROLLBAR KE_FILLER),

    K_SELECT        (TERMCAP2KEY KS_SELECT KE_FILLER),

;; Symbols for pseudo keys which are translated from the real key symbols above.

    K_IGNORE        (TERMCAP2KEY KS_EXTRA KE_IGNORE),
    K_NOP           (TERMCAP2KEY KS_EXTRA KE_NOP),

    K_CMDWIN        (TERMCAP2KEY KS_EXTRA KE_CMDWIN),

    K_DROP          (TERMCAP2KEY KS_EXTRA KE_DROP),

    K_CURSORHOLD    (TERMCAP2KEY KS_EXTRA KE_CURSORHOLD))

;; Bits for modifier mask.
;; 0x01 cannot be used, because the modifier must be 0x02 or higher

(final int
    MOD_MASK_SHIFT      0x02,
    MOD_MASK_CTRL       0x04,
    MOD_MASK_ALT        0x08,        ;; aka META
    MOD_MASK_META       0x10,        ;; META when it's different from ALT
    MOD_MASK_2CLICK     0x20,        ;; use MOD_MASK_MULTI_CLICK
    MOD_MASK_3CLICK     0x40,        ;; use MOD_MASK_MULTI_CLICK
    MOD_MASK_4CLICK     0x60)        ;; use MOD_MASK_MULTI_CLICK

(final int MOD_MASK_MULTI_CLICK (| MOD_MASK_2CLICK MOD_MASK_3CLICK MOD_MASK_4CLICK))

;; The length of the longest special key name, including modifiers.
;; Current longest is <M-C-S-T-4-MiddleRelease> (length includes '<' and '>').

(final int MAX_KEY_NAME_LEN    25)

;; Maximum length of a special key event as tokens.  This includes modifiers.
;; The longest event is something like <M-C-S-T-4-LeftDrag> which would be the
;; following string of tokens:
;;
;; <KB_SPECIAL> <KS_MODIFIER> bitmask <KB_SPECIAL> <KS_EXTRA> <KE_LEFTDRAG>.
;;
;; This is a total of 6 tokens, and is currently the longest one possible.

(final int MAX_KEY_CODE_LEN    6)

;; Get single int code from second byte after KB_SPECIAL.

(defn- #_int toSpecial [#_byte a, #_byte b]
    (cond (== a KS_SPECIAL) (char_u KB_SPECIAL) (== a KS_ZERO) K_ZERO :else (TERMCAP2KEY a, b)))

;; ----------------------------------------------------------------------- ;;

;; This file contains the defines for the machine dependent escape sequences
;; that the editor needs to perform various operations.  All of the sequences
;; here are optional, except "cm" (cursor motion).

;; Index of the termcap codes in the 'term_strings' array.

(final int
    KS_NAME  0,     ;; name of this terminal entry
    KS_CE    1,     ;; clear to end of line
    KS_AL    2,     ;; add new blank line
    KS_CAL   3,     ;; add number of blank lines
    KS_DL    4,     ;; delete line
    KS_CDL   5,     ;; delete number of lines
    KS_CS    6,     ;; scroll region
    KS_CL    7,     ;; clear screen
    KS_CD    8,     ;; clear to end of display
    KS_UT    9,     ;; clearing uses current background color
    KS_DA   10,     ;; text may be scrolled down from up
    KS_DB   11,     ;; text may be scrolled up from down
    KS_VI   12,     ;; cursor invisible
    KS_VE   13,     ;; cursor visible
    KS_VS   14,     ;; cursor very visible
    KS_ME   15,     ;; normal mode
    KS_MR   16,     ;; reverse mode
    KS_MD   17,     ;; bold mode
    KS_SE   18,     ;; normal mode
    KS_SO   19,     ;; standout mode
    KS_CZH  20,     ;; italic mode start
    KS_CZR  21,     ;; italic mode end
    KS_UE   22,     ;; exit underscore (underline) mode
    KS_US   23,     ;; underscore (underline) mode
    KS_MS   24,     ;; save to move cur in reverse mode
    KS_CM   25,     ;; cursor motion
    KS_SR   26,     ;; scroll reverse (backward)
    KS_CRI  27,     ;; cursor number of chars right
    KS_VB   28,     ;; visual bell
    KS_KS   29,     ;; put term in "keypad transmit" mode
    KS_KE   30,     ;; out of "keypad transmit" mode
    KS_TI   31,     ;; put terminal in termcap mode
    KS_TE   32,     ;; out of termcap mode
    KS_BC   33,     ;; backspace character (cursor left)
    KS_CCO  34,     ;; number of colors
    KS_CSF  35,     ;; set foreground color
    KS_CSB  36,     ;; set background color
    KS_XN   37,     ;; newline glitch
    KS_CAF  38,     ;; set foreground color (ANSI)
    KS_CAB  39,     ;; set background color (ANSI)
    KS_LE   40,     ;; cursor left (mostly backspace)
    KS_ND   41,     ;; cursor right
    KS_CWS  42,     ;; set window size in characters
    KS_CSI  43,     ;; start insert mode (bar cursor)
    KS_CEI  44,     ;; end insert mode (block cursor)
    KS_CSR  45,     ;; start replace mode (underline cursor)
    KS_CSV  46,     ;; scroll region vertical
    KS_OP   47)     ;; original color pair

;; The terminal capabilities are stored in this array.
;; IMPORTANT: When making changes, note the following:
;; - there should be an entry for each code in the builtin termcaps
;; - there should be an option for each code in option.c
;; - there should be code in term.c to obtain the value from the termcap

;; strings used for terminal

(atom! Bytes
    T_NAME  nil,    ;; terminal name
    T_CE    nil,    ;; clear to end of line
    T_AL    nil,    ;; add new blank line
    T_CAL   nil,    ;; add number of blank lines
    T_DL    nil,    ;; delete line
    T_CDL   nil,    ;; delete number of lines
    T_CS    nil,    ;; scroll region
    T_CL    nil,    ;; clear screen
    T_CD    nil,    ;; clear to end of display
    T_UT    nil,    ;; clearing uses background color
    T_DA    nil,    ;; text may be scrolled down from up
    T_DB    nil,    ;; text may be scrolled up from down
    T_VI    nil,    ;; cursor invisible
    T_VE    nil,    ;; cursor visible
    T_VS    nil,    ;; cursor very visible
    T_ME    nil,    ;; normal mode
    T_MR    nil,    ;; reverse mode
    T_MD    nil,    ;; bold mode
    T_SE    nil,    ;; normal mode
    T_SO    nil,    ;; standout mode
    T_CZH   nil,    ;; italic mode start
    T_CZR   nil,    ;; italic mode end
    T_UE    nil,    ;; exit underscore (underline) mode
    T_US    nil,    ;; underscore (underline) mode
    T_MS    nil,    ;; save to move cur in reverse mode
    T_CM    nil,    ;; cursor motion
    T_SR    nil,    ;; scroll reverse (backward)
    T_CRI   nil,    ;; cursor number of chars right
    T_VB    nil,    ;; visual bell
    T_KS    nil,    ;; put term in "keypad transmit" mode
    T_KE    nil,    ;; out of "keypad transmit" mode
    T_TI    nil,    ;; put terminal in termcap mode
    T_TE    nil,    ;; out of termcap mode
    T_BC    nil,    ;; backspace character
    T_CCO   nil,    ;; number of colors
    T_CSF   nil,    ;; set foreground color
    T_CSB   nil,    ;; set background color
    T_XN    nil,    ;; newline glitch
    T_CAF   nil,    ;; set foreground color (ANSI)
    T_CAB   nil,    ;; set background color (ANSI)
    T_LE    nil,    ;; cursor left
    T_ND    nil,    ;; cursor right
    T_CWS   nil,    ;; window size
    T_CSI   nil,    ;; start insert mode
    T_CEI   nil,    ;; end insert mode
    T_CSR   nil,    ;; start replace mode
    T_CSV   nil,    ;; scroll region vertical
    T_OP    nil)    ;; original color pair

;; 'term_strings' contains currently used terminal output strings.
;; It is initialized with the default values by parse-builtin-tcap().
;; The values can be changed by setting the option with the same name.

(final Bytes*' term_strings [ T_NAME T_CE T_AL  T_CAL T_DL  T_CDL T_CS  T_CL
                              T_CD   T_UT T_DA  T_DB  T_VI  T_VE  T_VS  T_ME
                              T_MR   T_MD T_SE  T_SO  T_CZH T_CZR T_UE  T_US
                              T_MS   T_CM T_SR  T_CRI T_VB  T_KS  T_KE  T_TI
                              T_TE   T_BC T_CCO T_CSF T_CSB T_XN  T_CAF T_CAB
                              T_LE   T_ND T_CWS T_CSI T_CEI T_CSR T_CSV T_OP ])

(final int TMODE_COOK  0)   ;; terminal mode for external cmds and Ex mode
(final int TMODE_SLEEP 1)   ;; terminal mode for sleeping (cooked but no echo)
(final int TMODE_RAW   2)   ;; terminal mode for Normal and Insert mode

;; ----------------------------------------------------------------------- ;;

;; flags for update-screen()
;; The higher the value, the higher the priority

(final int VALID        10) ;; buffer not changed, or changes marked with b_mod_*
(final int INVERTED     20) ;; redisplay inverted part that changed
(final int INVERTED_ALL 25) ;; redisplay whole inverted part
(final int REDRAW_TOP   30) ;; display first "w_upd_rows" screen lines
(final int SOME_VALID   35) ;; like NOT_VALID but may scroll
(final int NOT_VALID    40) ;; buffer needs complete redraw
(final int CLEAR        50) ;; screen messed up, clear it

;; Flags for "w_valid".
;; These are set when something in a window structure becomes invalid, except when the cursor is moved.
;; Call check-cursor-moved() before testing one of the flags.
;; These are reset when that thing has been updated and is valid again.
;;
;; Every function that invalidates one of these must call one of the invalidate_* functions.
;;
;; "w_valid" is supposed to be encapsulated: use the functions that set or reset the flags, instead.
;;
;; VALID_BOTLINE    VALID_BOTLINE_AP
;;     on               on             "w_botline" valid
;;     off              on             "w_botline" approximated
;;     off              off            "w_botline" not valid
;;     on               off            not possible

(final int
    VALID_WROW          0x01,       ;; "w_wrow" (window row) is valid
    VALID_WCOL          0x02,       ;; "w_wcol" (window col) is valid
    VALID_VIRTCOL       0x04,       ;; "w_virtcol" (file col) is valid
    VALID_CHEIGHT       0x08,       ;; "w_cline_height" is valid
    VALID_CROW          0x10,       ;; "w_cline_row" is valid
    VALID_BOTLINE       0x20,       ;; "w_botine" and "w_empty_rows" are valid
    VALID_BOTLINE_AP    0x40,       ;; "w_botine" is approximated
    VALID_TOPLINE       0x80)       ;; "w_topline" is valid (for cursor position)

;; Terminal highlighting attribute bits.
;; Attributes above HL_ALL are used for syntax highlighting.

(final int
    HL_NORMAL           0x00,
    HL_INVERSE          0x01,
    HL_BOLD             0x02,
    HL_ITALIC           0x04,
    HL_UNDERLINE        0x08,
    HL_UNDERCURL        0x10,
    HL_STANDOUT         0x20,
    HL_ALL              0x3f)

;; values for State
;;
;; The lower bits up to 0x20 are used to distinguish normal/visual/op_pending
;; and cmdline/insert+replace mode.  This is used for mapping.
;; If none of these bits are set, no mapping is done.
;; The upper bits are used to distinguish between other states.

(final int
    NORMAL          0x01,           ;; normal mode, command expected
    VISUAL          0x02,           ;; visual mode - use get-real-state()
    OP_PENDING      0x04,           ;; normal mode, operator is pending - use get-real-state()
    CMDLINE         0x08,           ;; editing command line
    INSERT          0x10,           ;; insert mode

    REPLACE_FLAG    0x40,           ;; replace mode flag
    REPLACE      (+ REPLACE_FLAG INSERT),
    VREPLACE_FLAG   0x80,           ;; virtual-replace mode flag
    VREPLACE     (+ REPLACE_FLAG VREPLACE_FLAG INSERT),

    NORMAL_BUSY  (+ 0x100 NORMAL),  ;; normal mode, busy with a command
    HITRETURN    (+ 0x200 NORMAL),  ;; waiting for return or command
    ASKMORE         0x300,          ;; asking if you want --more--
    SETWSIZE        0x400,          ;; window size has changed
    SHOWMATCH    (+ 0x700 INSERT),  ;; show matching paren
    CONFIRM         0x800,          ;; ":confirm" prompt
    SELECTMODE      0x1000)         ;; select mode, only for mappings

;; directions
(final int FORWARD        1)
(final int BACKWARD       -1)

(final int
    HL_CONTAINED        0x01,       ;; not used on toplevel
    HL_TRANSP           0x02,       ;; has no highlighting
    HL_ONELINE          0x04,       ;; match within one line only
    HL_HAS_EOL          0x08,       ;; end pattern that matches with $
    HL_SYNC_HERE        0x10,       ;; sync point after this item (syncing only)
    HL_SYNC_THERE       0x20,       ;; sync point at current line (syncing only)
    HL_MATCH            0x40,       ;; use match ID instead of item ID
    HL_SKIPNL           0x80,       ;; nextgroup can skip newlines
    HL_SKIPWHITE       0x100,       ;; nextgroup can skip white space
    HL_SKIPEMPTY       0x200,       ;; nextgroup can skip empty lines
    HL_KEEPEND         0x400,       ;; end match always kept
    HL_EXCLUDENL       0x800,       ;; exclude NL from match
    HL_DISPLAY        0x1000,       ;; only used for displaying, not syncing
    HL_FOLD           0x2000,       ;; define fold
    HL_EXTEND         0x4000,       ;; ignore a keepend
    HL_MATCHCONT      0x8000,       ;; match continued from previous line
    HL_TRANS_CONT    0x10000,       ;; transparent item without contains arg
    HL_CONCEAL       0x20000,       ;; can be concealed
    HL_CONCEALENDS   0x40000)       ;; can be concealed

;; Values for 'options' argument in do-search() and searchit().
(final int
    SEARCH_REV          0x01,       ;; go in reverse of previous dir.
    SEARCH_ECHO         0x02,       ;; echo the search command and handle options
    SEARCH_MSG          0x0c,       ;; give messages (yes, it's not 0x04)
    SEARCH_NFMSG        0x08,       ;; give all messages except not found
    SEARCH_OPT          0x10,       ;; interpret optional flags
    SEARCH_HIS          0x20,       ;; put search pattern in history
    SEARCH_END          0x40,       ;; put cursor at end of match
    SEARCH_NOOF         0x80,       ;; don't add offset to position
    SEARCH_START       0x100,       ;; start search without col offset
    SEARCH_MARK        0x200,       ;; set previous context mark
    SEARCH_KEEP        0x400,       ;; keep previous search pattern
    SEARCH_PEEK        0x800)       ;; peek for typed char, cancel search

;; Values for find-ident-under-cursor().
(final int FIND_IDENT      1)       ;; find identifier (word)
(final int FIND_STRING     2)       ;; find any string (WORD)

;; Values for change-indent().
(final int INDENT_SET      1)       ;; set indent
(final int INDENT_INC      2)       ;; increase indent
(final int INDENT_DEC      3)       ;; decrease indent

;; Values for flags argument for findmatchlimit().
(final int FM_BACKWARD     0x01)    ;; search backwards
(final int FM_FORWARD      0x02)    ;; search forwards
(final int FM_BLOCKSTOP    0x04)    ;; stop at start/end of block

;; Values for sub_cmd and which_pat argument for search-regcomp().
;; Also used for which_pat argument for searchit().
(final int RE_SEARCH       0)       ;; save/use pat in/from search_pattern
(final int RE_SUBST        1)       ;; save/use pat in/from subst_pattern
(final int RE_BOTH         2)       ;; save pat in both patterns
(final int RE_LAST         2)       ;; use last used pattern if "pat" is null

;; Second argument for vim-regcomp().
(final int RE_MAGIC        1)       ;; 'magic' option
(final int RE_STRING       2)       ;; match in string instead of buffer text
(final int RE_STRICT       4)       ;; don't allow [abc] without ]
(final int RE_AUTO         8)       ;; automatic engine selection

;; values for reg_do_extmatch
(final int REX_SET         1)       ;; to allow \z\(...\),
(final int REX_USE         2)       ;; to allow \z\1 et al.

;; flags for do-cmdline()
(final int DOCMD_VERBOSE   0x01)    ;; included command in error message
(final int DOCMD_NOWAIT    0x02)    ;; don't call wait-return() and friends
(final int DOCMD_KEYTYPED  0x08)    ;; don't reset keyTyped
(final int DOCMD_KEEPLINE  0x20)    ;; keep typed line for repeating with "."

;; flags for beginline()
(final int BL_WHITE        1)       ;; cursor on first non-white in the line
(final int BL_SOL          2)       ;; use 'sol' option
(final int BL_FIX          4)       ;; don't leave cursor on a NUL

;; flags for do-put()
(final int PUT_FIXINDENT   1)       ;; make indent look nice
(final int PUT_CURSEND     2)       ;; leave cursor after end of new text
(final int PUT_CURSLINE    4)       ;; leave cursor on last line of new text
(final int PUT_LINE        8)       ;; put register as lines
(final int PUT_LINE_SPLIT  16)      ;; split line for linewise register
(final int PUT_LINE_FORWARD 32)     ;; put linewise register below Visual sel.

;; flags for set-indent()
(final int SIN_CHANGED     1)       ;; call changed-bytes() when line changed
(final int SIN_INSERT      2)       ;; insert indent before existing text
(final int SIN_UNDO        4)       ;; save line for undo before changing it

;; There are four history tables:

(final int HIST_CMD        0)       ;; colon commands
(final int HIST_SEARCH     1)       ;; search commands
(final int HIST_EXPR       2)       ;; expressions (from entering = register)
(final int HIST_INPUT      3)       ;; input() lines
(final int HIST_COUNT      4)       ;; number of history tables

;; Flags for chartab[].

(final int CT_CELL_MASK    0x07)    ;; mask: nr of display cells (1, 2 or 4)
(final int CT_PRINT_CHAR   0x10)    ;; flag: set for printable chars
(final int CT_IDENT_CHAR   0x20)    ;; flag: set for ID chars
(final int CT_FNAME_CHAR   0x40)    ;; flag: set for file name chars

;; arguments for win-split()

(final int WSP_VERT        2)       ;; split vertically
(final int WSP_TOP         4)       ;; window at top-left of shell
(final int WSP_BOT         8)       ;; window at bottom-right of shell
(final int WSP_BELOW       32)      ;; put new window below/right
(final int WSP_ABOVE       64)      ;; put new window above/left

;; Values for "starting".
(final int NO_SCREEN       2)       ;; no screen updating yet
(final int NO_BUFFERS      1)       ;; not all buffers loaded yet
;;                         0           not starting anymore

;; Values for index in highlight_attr[].
;; When making changes, also update HL_FLAGS below!
;; And update the default value of 'highlight' in option.c.

(final int
    HLF_8        0,     ;; Meta & special keys listed with ":map", text that is displayed different from what it is
    HLF_AT       1,     ;; @ and ~ characters at end of screen, characters that don't really exist in the text
    HLF_E        2,     ;; error messages
    HLF_I        3,     ;; incremental search
    HLF_L        4,     ;; last search string
    HLF_M        5,     ;; "--More--" message
    HLF_CM       6,     ;; Mode (e.g., "-- INSERT --")
    HLF_N        7,     ;; line number for ":number" and ":#" commands
    HLF_CLN      8,     ;; current line number
    HLF_R        9,     ;; return to continue message and yes/no questions
    HLF_S       10,     ;; status lines
    HLF_SNC     11,     ;; status lines of not-current windows
    HLF_C       12,     ;; column to separate vertically split windows
    HLF_T       13,     ;; Titles for output from ":set all", ":autocmd" etc.
    HLF_V       14,     ;; Visual mode
    HLF_W       15,     ;; warning messages
    HLF_CONCEAL 16,     ;; Concealed text
    HLF_CUC     17,     ;; 'cursorcolumn'
    HLF_CUL     18,     ;; 'cursorline'
    HLF_MC      19,     ;; 'colorcolumn'

    HLF_COUNT   20)     ;; MUST be the last one

;; Operator IDs; The order must correspond to opchars[] in ops.c!

(final int
    OP_NOP       0,     ;; no pending operation
    OP_DELETE    1,     ;; "d"  delete operator
    OP_YANK      2,     ;; "y"  yank operator
    OP_CHANGE    3,     ;; "c"  change operator
    OP_LSHIFT    4,     ;; "<"  left shift operator
    OP_RSHIFT    5,     ;; ">"  right shift operator
    OP_FILTER    6,     ;; "!"  filter operator
    OP_TILDE     7,     ;; "g~" switch case operator
    OP_INDENT    8,     ;; "="  indent operator
    OP_FORMAT    9,     ;; "gq" format operator
    OP_COLON    10,     ;; ":"  colon operator
    OP_UPPER    11,     ;; "gU" make upper case operator
    OP_LOWER    12,     ;; "gu" make lower case operator
    OP_JOIN     13,     ;; "J"  join operator, only for Visual mode
    OP_JOIN_NS  14,     ;; "gJ"  join operator, only for Visual mode
    OP_ROT13    15,     ;; "g?" rot-13 encoding
    OP_REPLACE  16,     ;; "r"  replace chars, only for Visual mode
    OP_INSERT   17,     ;; "I"  Insert column, only for Visual mode
    OP_APPEND   18,     ;; "A"  Append column, only for Visual mode
    OP_FORMAT2  19,     ;; "gw" format operator, keeps cursor pos
    OP_FUNCTION 20)     ;; "g@" call 'operatorfunc'

;; Motion types, used for operators and for yank/delete registers.

(final byte!
    MCHAR   0,          ;; character-wise movement/register
    MLINE   1,          ;; line-wise movement/register
    MBLOCK  2,          ;; block-wise register
    MAUTO   0xff)       ;; decide between MLINE/MCHAR

;; Minimum screen size.

(final int MIN_COLS       12)           ;; minimal columns for screen
(final int MIN_ROWS        2)           ;; minimal lines for screen
(final int STATUS_HEIGHT   1)           ;; height of a status line under a window

(final int IOSIZE          (inc 1024))  ;; file i/o and sprintf buffer size
(final int MAXPATHL         4096)

(final int
    MSG_BUF_LEN     480,                ;; length of buffer for small messages
    MSG_BUF_CLEN    (/ MSG_BUF_LEN 6))  ;; cell length (worst case: utf-8 takes 6 bytes for one cell)

;; Maximum length of key sequence to be mapped.

(final int MAXMAPLEN 50)

(final long MAXLNUM 0x7fffffff)      ;; maximum (invalid) line number
(final int MAXCOL 0x7fffffff)           ;; maximum column number, 31 bits

(final int SHOWCMD_COLS 10)             ;; columns needed by shown command

;; vim-iswhite() is used for "^" and the like.  It differs from isspace()
;; because it doesn't include <CR> and <LF> and the like.

(defn- #_boolean vim-iswhite [#_int x]
    (any == x (byte \space) TAB))

(final int MAX_MCO        6)        ;; maximum value for 'maxcombine'

;; Maximum number of bytes in a multi-byte character.  It can be one 32-bit
;; character of up to 6 bytes, or one 16-bit character of up to three bytes
;; plus six following composing characters of three bytes each.

(final int MB_MAXBYTES    21)

;;; ============================================================================================== VimD

;; option.h: definition of global variables for settable options

;; characters for the "p_cpo" option:
(final byte
    CPO_SEARCH      \c,
    CPO_DIGRAPH     \D,  ;; no digraph after "r", "f", etc.
    CPO_EMPTYREGION \E,  ;; operating on empty region is an error
    CPO_INSEND      \H,  ;; "I" inserts before last blank in line
    CPO_INDENT      \I,  ;; remove auto-indent more often
    CPO_JOINSP      \j,  ;; only use two spaces for join after '.'
    CPO_LITERAL     \l,  ;; take char after backslash in [] literal
    CPO_SHOWMATCH   \m,
    CPO_MATCHBSL    \M,  ;; "%" ignores use of backslashes
    CPO_NUMCOL      \n,  ;; 'number' column also used for text
    CPO_LINEOFF     \o,
    CPO_JOINCOL     \q,  ;; with "3J" use column after first join
    CPO_REDO        \r,
    CPO_UNDO        \u,  ;; "u" undoes itself
    CPO_CW          \w,  ;; "cw" only changes one blank
    CPO_ESC         \x,
    CPO_REPLCNT     \X,  ;; "R" with a count only deletes chars once
    CPO_YANK        \y,
    CPO_FILTER      \!,
    CPO_MATCH       \%,
    CPO_MINUS       \-,  ;; "9-" fails at and before line 9
    CPO_REGAPPEND   \>,  ;; insert NL when appending to a register

;; POSIX flags
    CPO_HASH        \#,  ;; "D", "o" and "O" do not use a count
    CPO_SUBPERCENT  \/,  ;; % in :s string uses previous one
    CPO_BACKSL      \\,  ;; \ is not special in []
    CPO_SCOLON      \;)  ;; using "," and ";" will skip over char if cursor would not move

;; default values for Vim, Vi and POSIX
(final Bytes CPO_VIM  (u8 "c"))
(final Bytes CPO_ALL  (u8 "cDEHIjlmMnoqruwxXy!%->#/\\;"))

;; characters for "p_ww" option:
(final Bytes WW_ALL   (u8 "bshl<>[],~"))

(final Bytes COCU_ALL     (u8 "nvic"))     ;; flags for 'concealcursor'

;; arguments for can-bs()
(final byte BS_INDENT     \i)      ;; "Indent"
(final byte BS_EOL        \o)      ;; "eOl"
(final byte BS_START      \s)      ;; "Start"

;; The following are actual variables for the options:

(atom! Bytes   p_bs)        ;; 'backspace'
(atom! Bytes   p_breakat)   ;; 'breakat'
(atom! long    p_ch)        ;; 'cmdheight'
(atom! long    p_cwh)       ;; 'cmdwinheight'
(atom! Bytes   p_cpo)       ;; 'cpoptions'
(atom! boolean p_deco)      ;; 'delcombine'
(atom! boolean p_dg)        ;; 'digraph'
(atom! Bytes   p_dy)        ;; 'display'

(final int
    DY_LASTLINE 0x001,
    DY_UHEX     0x002)
(atom! int    dy_flags)
(final Bytes* p_dy_values [ (u8 "lastline"), (u8 "uhex"), nil ])

(atom! Bytes   p_ead)       ;; 'eadirection'
(atom! boolean p_ea)        ;; 'equalalways'
(atom! boolean p_eb)        ;; 'errorbells'
(atom! boolean p_ek)        ;; 'esckeys'
(atom! boolean p_gd)        ;; 'gdefault'
(atom! Bytes   p_hl)        ;; 'highlight'
(atom! long    p_hi)        ;; 'history'
(atom! boolean p_hls)       ;; 'hlsearch'
(atom! boolean p_ic)        ;; 'ignorecase'
(atom! boolean p_is)        ;; 'incsearch'
(atom! boolean p_im)        ;; 'insertmode'
(atom! Bytes   p_isf)       ;; 'isfname'
(atom! Bytes   p_isi)       ;; 'isident'
(atom! Bytes   p_isp)       ;; 'isprint'
(atom! boolean p_js)        ;; 'joinspaces'
(atom! Bytes   p_km)        ;; 'keymodel'
(atom! long    p_ls)        ;; 'laststatus'
(atom! boolean p_lz)        ;; 'lazyredraw'
(atom! boolean p_magic)     ;; 'magic'
(atom! long    p_mat)       ;; 'matchtime'
(atom! long    p_mco)       ;; 'maxcombine'
(atom! long    p_mmp)       ;; 'maxmempattern'
(atom! boolean p_more)      ;; 'more'
(atom! Bytes   p_opfunc)    ;; 'operatorfunc'
(atom! boolean p_paste)     ;; 'paste'
(atom! boolean p_prompt)    ;; 'prompt'
(atom! long    p_rdt)       ;; 'redrawtime'
(atom! long    p_re)        ;; 'regexpengine'
(atom! long    p_report)    ;; 'report'
(atom! boolean p_ru)        ;; 'ruler'
(atom! long    p_sj)        ;; 'scrolljump'
(atom! long    p_so)        ;; 'scrolloff'
(atom! Bytes   p_sbo)       ;; 'scrollopt'
(atom! Bytes   p_sel)       ;; 'selection'
(atom! Bytes   p_slm)       ;; 'selectmode'
(atom! boolean p_sr)        ;; 'shiftround'
(atom! Bytes   p_sbr)       ;; 'showbreak'
(atom! boolean p_sc)        ;; 'showcmd'
(atom! boolean p_sm)        ;; 'showmatch'
(atom! boolean p_smd)       ;; 'showmode'
(atom! long    p_ss)        ;; 'sidescroll'
(atom! long    p_siso)      ;; 'sidescrolloff'
(atom! boolean p_scs)       ;; 'smartcase'
(atom! boolean p_sta)       ;; 'smarttab'
(atom! boolean p_sb)        ;; 'splitbelow'
(atom! boolean p_spr)       ;; 'splitright'
(atom! boolean p_sol)       ;; 'startofline'
(atom! boolean p_to)        ;; 'tildeop'
(atom! boolean p_timeout)   ;; 'timeout'
(atom! long    p_tm)        ;; 'timeoutlen'
(atom! boolean p_ttimeout)  ;; 'ttimeout'
(atom! long    p_ttm)       ;; 'ttimeoutlen'
(atom! long    p_ttyscroll) ;; 'ttyscroll'
(atom! long    p_ut)        ;; 'updatetime'
(atom! long    p_verbose)   ;; 'verbose'
(atom! Bytes   p_ve)        ;; 'virtualedit'

(final int
    VE_BLOCK   5,       ;; includes "all"
    VE_INSERT  6,       ;; includes "all"
    VE_ALL     4,
    VE_ONEMORE 8)
(atom! int    ve_flags)
(final Bytes* p_ve_values [ (u8 "block"), (u8 "insert"), (u8 "all"), (u8 "onemore"), nil ])

(atom! boolean p_vb)        ;; 'visualbell'
(atom! Bytes   p_ww)        ;; 'whichwrap'
(atom! long    p_wh)        ;; 'winheight'
(atom! long    p_wmh)       ;; 'winminheight'
(atom! long    p_wmw)       ;; 'winminwidth'
(atom! long    p_wiw)       ;; 'winwidth'
(atom! boolean p_ws)        ;; 'wrapscan'
(atom! long    p_wd)        ;; 'writedelay'

;; "indir" values for buffer-local opions.

(final int
    BV_AI     0,
    BV_CI     5,
    BV_CINW   9,
    BV_ET    14,
    BV_ISK   26,
    BV_KP    27,
    BV_MOD   31,
    BV_MPS   32,
    BV_NF    33,
    BV_PI    34,
    BV_QE    35,
    BV_SI    37,
    BV_STS   40,
    BV_SW    41,
    BV_TS    42,
    BV_UL    46)

;; "indir" values for window-local options.

(final int
    WV_COCU    1,
    WV_COLE    2,
    WV_CRBIND  3,
    WV_BRI     4,
    WV_BRIOPT  5,
    WV_LBR     6,
    WV_NU      7,
    WV_RNU     8,
    WV_NUW     9,
    WV_SCBIND 12,
    WV_SCROLL 13,
    WV_CUC    14,
    WV_CUL    15,
    WV_CC     16,
    WV_WFH    18,
    WV_WFW    19,
    WV_WRAP   20)

;; ----------------------------------------------------------------------- ;;

;; position in file or buffer

(class! #_final pos_C
    [
        (field long     lnum)       ;; line number
        (field int      col)        ;; column number
        (field int      coladd)
    ])

(defn- #_void COPY-pos [#_pos_C p1, #_pos_C p0]
    (ยง
        ((ร p1.lnum =) (:lnum p0))
        ((ร p1.col =) (:col p0))
        ((ร p1.coladd =) (:coladd p0))
        nil
    ))

(defn- #_pos_C* ARRAY-pos [#_int n]
    (vec (repeatedly n NEW_pos_C)))

;; Same, but without coladd.

(class! #_final lpos_C
    [
        (field long     lnum)       ;; line number
        (field int      col)        ;; column number
    ])

(defn- #_void MIN1-lpos [#_lpos_C lp]
    (ยง
        ((ร lp =) (assoc lp :lnum -1))
        ((ร lp =) (assoc lp :col -1))
        nil
    ))

(defn- #_void COPY-lpos [#_lpos_C lp1, #_lpos_C lp0]
    (ยง
        ((ร lp1.lnum =) (:lnum lp0))
        ((ร lp1.col =) (:col lp0))
        nil
    ))

(defn- #_lpos_C* ARRAY-lpos [#_int n]
    (vec (repeatedly n NEW_lpos_C)))

(defn- #_void COPY--lpos [#_lpos_C* a1, #_lpos_C* a0, #_int n]
    (dotimes [#_int i n]
        (COPY-lpos (... a1 i), (... a0 i))
    )
    nil)

;; ----------------------------------------------------------------------- ;;

;; The number of sub-matches is limited to 10.
;; The first one (index 0) is the whole match, referenced with "\0".
;; The second one (index 1) is the first sub-match, referenced with "\1".
;; This goes up to the tenth (index 9), referenced with "\9".

(final int NSUBEXP  10)

;; In the NFA engine: how many braces are allowed.

(final int NFA_MAX_BRACES 20)

;; In the NFA engine: how many states are allowed.

(final int NFA_MAX_STATES 100000)
(final int NFA_TOO_EXPENSIVE -1)

;; Which regexp engine to use? Needed for vim-regcomp().
;; Must match with 'regexpengine'.

(final int
    AUTOMATIC_ENGINE    0,
    BACKTRACKING_ENGINE 1,
    NFA_ENGINE          2)

;; Structure returned by vim-regcomp() to pass on to vim-regexec().
;; This is the general structure.  For the actual matcher, two specific
;; structures are used.  See code below.

(ร
;   static abstract class regprog_C
    (ยง
;       regengine_C         engine;
;       int                 regflags;
;       int                 re_engine;      ;; automatic, backtracking or nfa engine
;       int                 re_flags;       ;; second argument for vim-regcomp()

;       protected regprog_C()
;       {
;       }
    ))

;; Structure used by the back track matcher.
;; These fields are only to be used in regexp.c!
;; See regexp.c for an explanation.

(ร
;   static final class bt_regprog_C extends regprog_C
    (ยง
;       int                 reganch;
;       int                 regstart;
;       Bytes               regmust;
;       int                 regmlen;
;       int                 reghasz;
;       Bytes               program;
    ))

;; Structure representing a NFA state.
;; A NFA state may have no outgoing edge, when it is a NFA_MATCH state.

(declare NEW_fragnode_C)

(class! #_final nfa_state_C
    [
        (field int          c)
        (field fragnode_C   out0        (NEW_fragnode_C))
        (field fragnode_C   out1        (NEW_fragnode_C))
        (field int          id)
        (field int*         lastlist    2)  ;; 0: normal, 1: recursive
        (field int          val)

;       #_private void out0(nfa_state_C out0)
;       {
; %%        ((ร this.out0.fn_next =) out0)
;       }

;       #_private void out1(nfa_state_C out1)
;       {
; %%        ((ร this.out1.fn_next =) out1)
;       }

;       #_private nfa_state_C out0()
;       {
; %%        ((ร RETURN) (ร (nfa_state_C)(out0.fn_next)))
;       }

;       #_private nfa_state_C out1()
;       {
; %%        ((ร RETURN) (ร (nfa_state_C)(out1.fn_next)))
;       }
    ])

;; Structure used by the NFA matcher.

(ร
;   static final class nfa_regprog_C extends regprog_C
    (ยง
;       nfa_state_C         start;          ;; points into state[]

;       int                 reganch;        ;; pattern starts with ^
;       int                 regstart;       ;; char at start of pattern
;       Bytes               match_text;     ;; plain text to match with

;       boolean             has_zend;       ;; pattern contains \ze
;       boolean             has_backref;    ;; pattern contains \1 .. \9
;       int                 reghasz;
;       Bytes               pattern;
;       int                 nsubexp;        ;; number of ()

;       int                 nstate;         ;; states.length
;       nfa_state_C[]       states;
;       int                 istate;         ;; index in states == number of states allocated
    ))

;; Structure to be used for single-line matching.
;; Sub-match "no" starts at "startp[no]" and ends just before "endp[no]".
;; When there is no match, the pointer is null.

(class! #_final regmatch_C
    [
        (field regprog_C    regprog)
        (field Bytes*       startp      NSUBEXP)
        (field Bytes*       endp        NSUBEXP)
        (field boolean      rm_ic)
    ])

;; Structure to be used for multi-line matching.
;; Sub-match "no" starts in line "startpos[no].lnum" column "startpos[no].col"
;; and ends in line "endpos[no].lnum" just before column "endpos[no].col".
;; The line numbers are relative to the first line, thus startpos[0].lnum is always 0.
;; When there is no match, the line number is -1.

(class! #_final regmmatch_C
    [
        (field regprog_C    regprog)
        (field lpos_C*      startpos    (ARRAY-lpos NSUBEXP))
        (field lpos_C*      endpos      (ARRAY-lpos NSUBEXP))
        (field boolean      rmm_ic)
        (field int          rmm_maxcol)     ;; when not zero: maximum column
    ])

(defn- #_void COPY-regmmatch [#_regmmatch_C rmm1, #_regmmatch_C rmm0]
    (ยง
        ((ร rmm1.regprog =) (:regprog rmm0))
        (COPY--lpos (:startpos rmm1), (:startpos rmm0), NSUBEXP)
        (COPY--lpos (:endpos rmm1), (:endpos rmm0), NSUBEXP)
        ((ร rmm1.rmm_ic =) (:rmm_ic rmm0))
        ((ร rmm1.rmm_maxcol =) (:rmm_maxcol rmm0))
        nil
    ))

;; Structure used to store external references: "\z\(\)" to "\z\1".
;; Use a reference count to avoid the need to copy this around.
;; When it goes from 1 to zero the matches need to be freed.

(class! #_final reg_extmatch_C
    [
        (field Bytes*       matches     NSUBEXP)
    ])

(ร
;   static abstract class regengine_C
    (ยง
        ((ร Bytes expr =) (u8 ""))

;       protected regengine_C()
;       {
;       }

;       public abstract regprog_C regcomp(Bytes expr, int re_flags);
;       public abstract long regexec_nl(regmatch_C rmp, Bytes line, int col, boolean line_lbr);
;       public abstract long regexec_multi(regmmatch_C rmp, long lnum, int col, long nsec);
    ))

;; ----------------------------------------------------------------------- ;;

;; marks: positions in a file
;; (a normal mark is a lnum/col pair, the same as a file position)

(final int NMARKS (inc (- (int \z) (int \a))))  ;; max. # of named marks
(final int JUMPLISTSIZE 100)        ;; max. # of marks in jump list

(class! #_final fmark_C
    [
        (field pos_C    mark    (NEW_pos_C))      ;; cursor position
    ])

(defn- #_void COPY-fmark [#_fmark_C fm1, #_fmark_C fm0]
    (COPY-pos (:mark fm1), (:mark fm0))
    nil)

(defn- #_fmark_C* ARRAY-fmark [#_int n]
    (vec (repeatedly n NEW_fmark_C)))

;; When a string option is null (which only happens in out-of-memory situations),
;; it is set to EMPTY_OPTION to avoid having to check for null everywhere.

(final Bytes EMPTY_OPTION (u8 ""))

;; Structure that contains all options that are local to a window.
;; Used twice in a window: for the current buffer and for all buffers.

(class! #_final winopt_C
    [
        (atom' boolean wo_bri)                 ;; 'breakindent'
        (atom' Bytes   wo_briopt EMPTY_OPTION) ;; 'breakindentopt'
        (atom' Bytes   wo_cc     EMPTY_OPTION) ;; 'colorcolumn'
        (atom' Bytes   wo_cocu   EMPTY_OPTION) ;; 'concealcursor'
        (atom' long    wo_cole)                ;; 'conceallevel'
        (atom' boolean wo_crb)                 ;; 'cursorbind'
        (atom' boolean wo_cuc)                 ;; 'cursorcolumn'
        (atom' boolean wo_cul)                 ;; 'cursorline'
        (atom' boolean wo_lbr)                 ;; 'linebreak'
        (atom' boolean wo_nu)                  ;; 'number'
        (atom' long    wo_nuw)                 ;; 'numberwidth'
        (atom' boolean wo_rnu)                 ;; 'relativenumber'
        (atom' boolean wo_scb)                 ;; 'scrollbind'
        (atom' long    wo_scr)                 ;; 'scroll'
        (atom' boolean wo_wfh)                 ;; 'winfixheight'
        (atom' boolean wo_wfw)                 ;; 'winfixwidth'
        (atom' boolean wo_wrap)                ;; 'wrap'
    ])

;; Structure to store info about the Visual area.
(class! #_final visualinfo_C
    [
        (field pos_C        vi_start    (NEW_pos_C))      ;; start pos of last VIsual
        (field pos_C        vi_end      (NEW_pos_C))      ;; end position of last VIsual
        (field int          vi_mode)                    ;; VIsual_mode of last VIsual
        (field int          vi_curswant)                ;; MAXCOL from "w_curswant"
    ])

(defn- #_void COPY-visualinfo [#_visualinfo_C vi1, #_visualinfo_C vi0]
    (ยง
        (COPY-pos (:vi_start vi1), (:vi_start vi0))
        (COPY-pos (:vi_end vi1), (:vi_end vi0))
        ((ร vi1.vi_mode =) (:vi_mode vi0))
        ((ร vi1.vi_curswant =) (:vi_curswant vi0))
        nil
    ))

;; structures used for undo

(class! #_final u_entry_C
    [
        (field u_entry_C    ue_next)        ;; pointer to next entry in list
        (field long         ue_top)         ;; number of line above undo block
        (field long         ue_bot)         ;; number of line below undo block
        (field long         ue_lcount)      ;; linecount when u-save() called
        (field Bytes*       ue_array)       ;; array of lines in undo block
        (field long         ue_size)        ;; number of lines in "ue_array"
    ])

(class! #_final u_link_C
    [
        (field u_header_C   ptr)
        (field long         seq)
    ])

(class! #_final u_header_C
    [
        ;; The following have a pointer and a number.
        ;; The number is used when reading the undo file in u_read_undo().
        (field u_link_C     uh_next         (NEW_u_link_C))       ;; next undo header in list
        (field u_link_C     uh_prev         (NEW_u_link_C))       ;; previous header in list
        (field u_link_C     uh_alt_next     (NEW_u_link_C))       ;; next header for alt. redo
        (field u_link_C     uh_alt_prev     (NEW_u_link_C))       ;; previous header for alt. redo
        (field long         uh_seq)                             ;; sequence number, higher == newer undo
        (field int          uh_walk)                            ;; used by undo-time()
        (field u_entry_C    uh_entry)                           ;; pointer to first entry
        (field u_entry_C    uh_getbot_entry)                    ;; pointer to where ue_bot must be set
        (field pos_C        uh_cursor       (NEW_pos_C))          ;; cursor position before saving
        (field long         uh_cursor_vcol)
        (field int          uh_flags)                           ;; see below
        (field pos_C*       uh_namedm       (ARRAY-pos NMARKS)) ;; marks before undo/after redo
        (field visualinfo_C uh_visual       (NEW_visualinfo_C))   ;; Visual areas before undo/after redo
        (field long         uh_time)                            ;; timestamp when the change was made
    ])

;; values for uh_flags
(final int UH_CHANGED  0x01)            ;; "b_changed" flag before undo/after redo
(final int UH_EMPTYBUF 0x02)            ;; buffer was empty

;; structure used to store one block of the stuff/redo/recording buffers

(class! #_final buffblock_C
    [
        (field buffblock_C  bb_next)        ;; pointer to next buffblock
        (field Bytes        bb_str)         ;; contents
    ])

(defn- #_void COPY-buffblock [#_buffblock_C bb1, #_buffblock_C bb0]
    (ยง
        ((ร bb1.bb_next =) (:bb_next bb0))
        ((ร bb1.bb_str =) (:bb_str bb0))
        nil
    ))

;; header used for the stuff buffer and the redo buffer

(class! #_final buffheader_C
    [
        (field buffblock_C  bh_first    (NEW_buffblock_C))    ;; first (dummy) block of list
        (field buffblock_C  bh_curr)        ;; buffblock for appending
        (field int          bh_index)       ;; index for reading
        (field int          bh_space)       ;; space in bh_curr for appending
    ])

(defn- #_void COPY-buffheader [#_buffheader_C bh1, #_buffheader_C bh0]
    (ยง
        (COPY-buffblock (:bh_first bh1), (:bh_first bh0))
        ((ร bh1.bh_curr =) (:bh_curr bh0))
        ((ร bh1.bh_index =) (:bh_index bh0))
        ((ร bh1.bh_space =) (:bh_space bh0))
        nil
    ))

;; things used in memline.c

;; 'ml_flags':
(final int ML_EMPTY        1)   ;; empty buffer

;; The memline structure holds all the information about a memline.

(class! #_final memline_C
    [
        (field long         ml_line_count)      ;; number of lines in the buffer

        (field int          ml_flags)
    ])

;; Structure shared between syntax.c and screen.c.

(class! #_final attrentry_C
    [
        (field int          ae_attr)            ;; HL_BOLD, etc.
        (field Bytes        ae_esc_start)       ;; start escape sequence
        (field Bytes        ae_esc_stop)        ;; stop escape sequence
    ;; These colors need to be > 8 bits to hold 256.
        (field int          ae_fg_color)        ;; foreground color number
        (field int          ae_bg_color)        ;; background color number
    ])

(defn- #_void ZER0-attrentry [#_attrentry_C ae]
    (ยง
        ((ร ae =) (assoc ae :ae_attr 0))
        ((ร ae =) (assoc ae :ae_esc_start nil))
        ((ร ae =) (assoc ae :ae_esc_stop nil))
        ((ร ae =) (assoc ae :ae_fg_color 0))
        ((ร ae =) (assoc ae :ae_bg_color 0))
        nil
    ))

(defn- #_void COPY-attrentry [#_attrentry_C ae1, #_attrentry_C ae0]
    (ยง
        ((ร ae1.ae_attr =) (:ae_attr ae0))
        ((ร ae1.ae_esc_start =) (:ae_esc_start ae0))
        ((ร ae1.ae_esc_stop =) (:ae_esc_stop ae0))
        ((ร ae1.ae_fg_color =) (:ae_fg_color ae0))
        ((ร ae1.ae_bg_color =) (:ae_bg_color ae0))
        nil
    ))

;; Used for the typeahead buffer: typebuf.

(class! #_final typebuf_C
    [
        (field Bytes        tb_buf)             ;; buffer for typed characters
        (field int          tb_buflen)          ;; size of "tb_buf"
        (field int          tb_off)             ;; current position in "tb_buf"
        (field int          tb_len)             ;; number of valid bytes in "tb_buf"
        (field int          tb_change_cnt)      ;; nr of time "tb_buf" was changed; never zero
    ])

;; buffer: structure that holds information about one file
;;
;; Several windows can share a single Buffer.

(class! #_final buffer_C
    [
        (field memline_C    b_ml                (ml-open))      ;; associated memline (also contains line count)

        (field int          b_nwindows)         ;; nr of windows open on this buffer

        (atom' boolean      b_changed)          ;; 'modified'
        (field int          b_changedtick)      ;; incremented for each change, also for undo

        ;; Changes to a buffer require updating of the display.
        ;; To minimize the work, remember changes made and update everything at once.

        (field boolean      b_mod_set)          ;; true when there are changes since the last time the display was updated
        (field long         b_mod_top)          ;; topmost lnum that was changed
        (field long         b_mod_bot)          ;; lnum below last changed line, AFTER the change
        (field long         b_mod_xlines)       ;; number of extra buffer lines inserted; negative when lines were deleted

        (field pos_C*       b_namedm            (ARRAY-pos NMARKS))     ;; current named marks (mark.c)

        ;; These variables are set when VIsual_active becomes false.
        (field visualinfo_C b_visual            (NEW_visualinfo_C))

        (field pos_C        b_last_cursor       (NEW_pos_C))    ;; cursor position when last unloading this buffer
        (field pos_C        b_last_insert       (NEW_pos_C))    ;; where Insert mode was left
        (field pos_C        b_last_change       (NEW_pos_C))    ;; position of last change: '. mark

        ;; the changelist contains old change positions

        (field pos_C*       b_changelist        (ARRAY-pos JUMPLISTSIZE))
        (field int          b_changelistlen)    ;; number of active entries
        (field boolean      b_new_change)       ;; set by u-savecommon()

        ;; Character table, only used in charset.c for 'iskeyword'.
        ;; 8 bytes of 32 bits: 1 bit per character 0-255.

        (field int*         b_chartab           8)

        ;; start and end of an operator, also used for '[ and ']

        (field pos_C        b_op_start          (NEW_pos_C))
        (field pos_C        b_op_start_orig     (NEW_pos_C))    ;; used for insStart_orig
        (field pos_C        b_op_end            (NEW_pos_C))

        ;; The following only used in undo.c.

        (field u_header_C   b_u_oldhead)        ;; pointer to oldest header
        (field u_header_C   b_u_newhead)        ;; pointer to newest header; may not be valid if b_u_curhead is not null
        (field u_header_C   b_u_curhead)        ;; pointer to current header
        (field int          b_u_numhead)        ;; current number of headers
        (field boolean      b_u_synced)         ;; entry lists are synced
        (field long         b_u_seq_last)       ;; last used undo sequence number
        (field long         b_u_seq_cur)        ;; hu_seq of header below which we are now
        (field long         b_u_time_cur)       ;; uh_time of header below which we are now

        ;; variables for "U" command in undo.c

        (field Bytes        b_u_line_ptr)       ;; saved line for "U" command
        (field long         b_u_line_lnum)      ;; line number of line in u_line
        (field int          b_u_line_colnr)     ;; optional column number

        ;; Options local to a buffer.
        ;; They are here because their value depends on the type of file
        ;; or contents of the file being edited.

        (atom' boolean      b_p_ai)                     ;; 'autoindent'
        (field boolean      b_p_ai_nopaste)             ;; "b_p_ai" saved for paste mode
        (atom' boolean      b_p_ci)                     ;; 'copyindent'
        (atom' Bytes        b_p_cinw    EMPTY_OPTION)   ;; 'cinwords'
        (atom' boolean      b_p_et)                     ;; 'expandtab'
        (atom' Bytes        b_p_isk     EMPTY_OPTION)   ;; 'iskeyword'
        (atom' Bytes        b_p_kp      EMPTY_OPTION)   ;; 'keywordprg'
        (atom' Bytes        b_p_mps     EMPTY_OPTION)   ;; 'matchpairs'
        (atom' Bytes        b_p_nf      EMPTY_OPTION)   ;; 'nrformats'
        (atom' boolean      b_p_pi)                     ;; 'preserveindent'
        (atom' Bytes        b_p_qe      EMPTY_OPTION)   ;; 'quoteescape'
        (atom' boolean      b_p_si)                     ;; 'smartindent'
        (atom' long         b_p_sts)                    ;; 'softtabstop'
        (field long         b_p_sts_nopaste)            ;; "b_p_sts" saved for paste mode
        (atom' long         b_p_sw)                     ;; 'shiftwidth'
        (atom' long         b_p_ts)                     ;; 'tabstop'
        (atom' long         b_p_ul)                     ;; 'undolevels'
    ])

(atom! long         ch_used)         ;; value of 'cmdheight' when frame size was set

;; Structure to cache info for displayed lines in w_lines[].
;; Each logical line has one entry.
;; The entry tells how the logical line is currently displayed in the window.
;; This is updated when displaying the window.
;; When the display is changed (e.g., when clearing the screen) "w_lines_valid"
;; is changed to exclude invalid entries.
;; When making changes to the buffer, wl_valid is reset to indicate wl_size
;; may not reflect what is actually in the buffer.  When wl_valid is false,
;; the entries can only be used to count the number of displayed lines used.
;; wl_lnum and wl_lastlnum are invalid too.

(class! #_final wline_C
    [
        (field long         wl_lnum)        ;; buffer line number for logical line
        (field int          wl_size)        ;; height in screen lines
        (field boolean      wl_valid)       ;; true values are valid for text in buffer
    ])

(defn- #_void COPY-wline [#_wline_C wl1, #_wline_C wl0]
    (ยง
        ((ร wl1.wl_lnum =) (:wl_lnum wl0))
        ((ร wl1.wl_size =) (:wl_size wl0))
        ((ร wl1.wl_valid =) (:wl_valid wl0))
        nil
    ))

(defn- #_wline_C* ARRAY-wline [#_int n]
    (vec (repeatedly n NEW_wline_C)))

;; Windows are kept in a tree of frames.  Each frame has a column (FR_COL)
;; or row (FR_ROW) layout or is a leaf, which has a window.

(class! #_final frame_C
    [
        (field byte         fr_layout)      ;; FR_LEAF, FR_COL or FR_ROW
        (field int          fr_width)
        (field int          fr_newwidth)    ;; new width used in win-equal-rec()
        (field int          fr_height)
        (field int          fr_newheight)   ;; new height used in win-equal-rec()
        (field frame_C      fr_parent)      ;; containing frame or null
        (field frame_C      fr_next)        ;; frame right or below in same parent, null for first
        (field frame_C      fr_prev)        ;; frame left or above in same parent, null for last
                                            ;; fr_child and fr_win are mutually exclusive
        (field frame_C      fr_child)       ;; first contained frame
        (field window_C     fr_win)         ;; window that fills this frame
    ])

(defn- #_void COPY-frame [#_frame_C fr1, #_frame_C fr0]
    (ยง
        ((ร fr1.fr_layout =) (:fr_layout fr0))
        ((ร fr1.fr_width =) (:fr_width fr0))
        ((ร fr1.fr_newwidth =) (:fr_newwidth fr0))
        ((ร fr1.fr_height =) (:fr_height fr0))
        ((ร fr1.fr_newheight =) (:fr_newheight fr0))
        ((ร fr1.fr_parent =) (:fr_parent fr0))
        ((ร fr1.fr_next =) (:fr_next fr0))
        ((ร fr1.fr_prev =) (:fr_prev fr0))
        ((ร fr1.fr_child =) (:fr_child fr0))
        ((ร fr1.fr_win =) (:fr_win fr0))
        nil
    ))

(final byte
    FR_LEAF 0,            ;; frame is a leaf
    FR_ROW  1,            ;; frame with a row of windows
    FR_COL  2)            ;; frame with a column of windows

;; Struct used for highlighting 'hlsearch' matches, matches defined by ":match" and
;; matches defined by match functions.  For 'hlsearch' there is one pattern for all windows.
;; For ":match" and the match functions there is a different pattern for each window.

(class! #_final match_C
    [
        (field regmmatch_C  rmm     (NEW_regmmatch_C))    ;; points to the regexp program; contains last found match (may continue in next line)
        (field long         lnum)                       ;; the line to search for a match
        (field int          attr)                       ;; attributes to be used for a match
        (field int          attr_cur)                   ;; attributes currently active in win-line()
        (field long         first_lnum)                 ;; first lnum to search for multi-line pat
        (field int          startcol)                   ;; in win-line() points to char where HL starts
        (field int          endcol)                     ;; in win-line() points to char where HL ends
        (field long         nsec)                       ;; for a time limit
    ])

;; number of positions supported by matchaddpos()
(final int MAXPOSMATCH 8)

;; Same as lpos_C, but with additional field len.

(class! #_final llpos_C
    [
        (field long     lnum)       ;; line number
        (field int      col)        ;; column number
        (field int      len)        ;; length: 0 - to the end of line
    ])

(defn- #_void COPY-llpos [#_llpos_C llp1, #_llpos_C llp0]
    (ยง
        ((ร llp1.lnum =) (:lnum llp0))
        ((ร llp1.col =) (:col llp0))
        ((ร llp1.len =) (:len llp0))
        nil
    ))

(defn- #_llpos_C* ARRAY-llpos [#_int n]
    (vec (repeatedly n NEW_llpos_C)))

;; posmatch_C provides an array for storing match items for matchaddpos() function.

(class! #_final posmatch_C
    [
        (field llpos_C* pm_pos  (ARRAY-llpos MAXPOSMATCH))  ;; array of positions
        (field int      cur)        ;; internal position counter
        (field long     toplnum)    ;; top buffer line
        (field long     botlnum)    ;; bottom buffer line
    ])

;; matchitem_C provides a linked list for storing match items for ":match" and the match functions.

(class! #_final matchitem_C
    [
        (field matchitem_C  next)
        (field int          id)             ;; match ID
        (field int          priority)       ;; match priority
        (field Bytes        pattern)        ;; pattern to highlight
        (field int          hlg_id)         ;; highlight group ID
        (field regmmatch_C  mi_match    (NEW_regmmatch_C))    ;; regexp program for "pattern"
        (field posmatch_C   mi_pos      (NEW_posmatch_C))     ;; position matches
        (field match_C      mi_hl       (NEW_match_C))        ;; struct for doing the actual highlighting
    ])

;; Structure which contains all information that belongs to a window
;;
;; All row numbers are relative to the start of the window, except "w_winrow".

(class! #_final window_C
    [
        (field window_C     w_prev)             ;; link to previous window
        (field window_C     w_next)             ;; link to next window

        (field frame_C      w_frame)            ;; frame containing this window

        (field pos_C        w_cursor            (NEW_pos_C))  ;; cursor position in buffer
        (field int          w_curswant)         ;; column we'd like to be at: used to try to stay in the same column for up/down cursor motions
        (field boolean      w_set_curswant)     ;; if set, update "w_curswant" the next time through cursupdate() to the current virtual column

        ;; the next six are used to update the visual part

        (field int          w_old_visual_mode)  ;; last known VIsual_mode
        (field long         w_old_cursor_lnum)  ;; last known end of visual part
        (field int          w_old_cursor_fcol)  ;; first column for block visual part
        (field int          w_old_cursor_lcol)  ;; last column for block visual part
        (field long         w_old_visual_lnum)  ;; last known start of visual part
        (field int          w_old_visual_col)   ;; last known start of visual part
        (field int          w_old_curswant)     ;; last known value of curswant

        ;; "w_topline", "w_leftcol" and "w_skipcol" specify the offsets for displaying the buffer.

        (field long         w_topline)          ;; buffer line number of the line at the top of the window
        (field boolean      w_topline_was_set)  ;; flag set to true when topline is set, e.g. by winrestview()
        (field int          w_leftcol)          ;; window column of the leftmost character in the window; used when 'wrap' is off
        (field int          w_skipcol)          ;; starting column when a single line doesn't fit in the window

        ;; Layout of the window in the screen.
        ;; May need to add "msg_scrolled" to "w_winrow" in rare situations.

        (field int          w_winrow)           ;; first row of window in screen
        (field int          w_height)           ;; number of rows in window, excluding status/command line(s)
        (field int          w_status_height)    ;; number of status lines (0 or 1)
        (field int          w_wincol)           ;; leftmost column of window in screen
        (field int          w_width)            ;; width of window, excluding separation
        (field int          w_vsep_width)       ;; number of separator columns (0 or 1)

        ;; === start of cached values ====

        ;; Recomputing is minimized by storing the result of computations.
        ;; Use functions in screen.c to check if they are valid and to update.
        ;; "w_valid" is a bitfield of flags, which indicate if specific values are
        ;; valid or need to be recomputed.  See screen.c for values.

        (field int          w_valid)
        (field pos_C        w_valid_cursor      (NEW_pos_C))  ;; last known position of "w_cursor", used to adjust "w_valid"
        (field int          w_valid_leftcol)    ;; last known "w_leftcol"

        ;; "w_cline_height" is the number of physical lines taken by the buffer line
        ;; that the cursor is on.  We use this to avoid extra calls to plines().

        (field int          w_cline_height)     ;; current size of cursor line
        (field int          w_cline_row)        ;; starting row of the cursor line

        (field int          w_virtcol)          ;; Column number of the cursor in the buffer line,
                                                ;; as opposed to the column number we're at on the screen.
                                                ;; This makes a difference on lines which span more than
                                                ;; one screen line or when "w_leftcol" is non-zero.

        ;; "w_wrow" and "w_wcol" specify the cursor position in the window.
        ;; This is related to positions in the window, not in the display
        ;; or buffer, thus "w_wrow" is relative to "w_winrow".

        (field int          w_wrow)
        (field int          w_wcol)

        (field long         w_botline)          ;; number of the line below the bottom of the screen
        (field int          w_empty_rows)       ;; number of ~ rows in window

        ;; Info about the lines currently in the window is remembered to avoid
        ;; recomputing it every time.  The allocated size of w_lines[] is Rows.
        ;; Only the "w_lines_valid" entries are actually valid.
        ;; When the display is up-to-date w_lines[0].wl_lnum is equal to "w_topline"
        ;; and w_lines[w_lines_valid - 1].wl_lnum is equal to "w_botline".
        ;; Between changing text and updating the display w_lines[] represents
        ;; what is currently displayed.  wl_valid is reset to indicated this.
        ;; This is used for efficient redrawing.

        (field int          w_lines_valid)      ;; number of valid entries
        (field wline_C*     w_lines)

        (field int          w_nrwidth)          ;; width of 'number' and 'relativenumber' column being used

        ;; === end of cached values ===

        (field int          w_redr_type)        ;; type of redraw to be performed on win
        (field int          w_upd_rows)         ;; number of window lines to update when "w_redr_type" is REDRAW_TOP
        (field long         w_redraw_top)       ;; when != 0: first line needing redraw
        (field long         w_redraw_bot)       ;; when != 0: last line needing redraw
        (field boolean      w_redr_status)      ;; if true status line must be redrawn

        ;; remember what is shown in the ruler for this window (if 'ruler' set)
        (field pos_C        w_ru_cursor         (NEW_pos_C))  ;; cursor position shown in ruler
        (field int          w_ru_virtcol)       ;; virtcol shown in ruler
        (field long         w_ru_topline)       ;; topline shown in ruler
        (field long         w_ru_line_count)    ;; line count used for ruler
        (field boolean      w_ru_empty)         ;; true if ruler shows 0-1 (empty line)

        ;; Options local to a window.
        ;; They are local because they influence the layout of the window or depend on the window layout.

        (field winopt_C     w_options    (NEW_winopt_C))

        (field int*         w_p_cc_cols)        ;; array of columns to highlight or null
        (field int          w_p_brimin)         ;; minimum width for breakindent
        (field int          w_p_brishift)       ;; additional shift for breakindent
        (field boolean      w_p_brisbr)         ;; sbr in 'briopt'

        (field long         w_scbind_pos)

        ;; "w_prev_pcmark" is used to check whether we really did jump to a new line after setting "w_pcmark".
        ;; If not, we revert to using the previous "w_pcmark".

        (field pos_C        w_pcmark            (NEW_pos_C))  ;; previous context mark
        (field pos_C        w_prev_pcmark       (NEW_pos_C))  ;; previous "w_pcmark"

        ;; the jumplist contains old cursor positions

        (field fmark_C*     w_jumplist      (ARRAY-fmark JUMPLISTSIZE))
        (field int          w_jumplistlen)      ;; number of active entries
        (field int          w_jumplistidx)      ;; current position

        (field int          w_changelistidx)    ;; current position in b_changelist

        (field matchitem_C  w_match_head)       ;; head of match list
        (field int          w_next_match_id)    ;; next match ID

        ;; "w_fraction" is the fractional row of the cursor within the window,
        ;; from 0 at the top row to FRACTION_MULT at the last row.
        ;; "w_prev_fraction_row" was the actual cursor row when "w_fraction" was last calculated.

        (field int          w_fraction)
        (field int          w_prev_fraction_row)

        (field long         w_nrwidth_line_count)   ;; line count when ml_nrwidth_width was computed
        (field long         w_nuw_cached)           ;; 'numberwidth' option cached
        (field int          w_nrwidth_width)        ;; nr of chars to print line count

        (field boolean      w_redraw_cline)     ;; cursor line needs to be redrawn
    ])

;; Arguments for operators.

(class! #_final oparg_C
    [
        (field int          op_type)            ;; current pending operator type
        (field int          regname)            ;; register to use for the operator
        (field byte         motion_type)        ;; type of the current cursor motion
        (field int          motion_force)       ;; force motion type: 'v', 'V' or CTRL-V
        (field boolean      use_reg_one)        ;; true if delete uses reg 1 even when not linewise
        (field boolean      inclusive)          ;; true if char motion is inclusive (only valid when motion_type is MCHAR)
        (field boolean      end_adjusted)       ;; backuped b_op_end one char (only used by do_format())
        (field pos_C        op_start        (NEW_pos_C))  ;; start of the operator
        (field pos_C        op_end          (NEW_pos_C))  ;; end of the operator
        (field pos_C        cursor_start    (NEW_pos_C))  ;; cursor position before motion for "gw"
        (field long         line_count)         ;; number of lines from op_start to op_end (inclusive)
        (field boolean      empty)              ;; op_start and op_end the same (only used by do_change())
        (field boolean      is_VIsual)          ;; operator on Visual area
        (field boolean      block_mode)         ;; current operator is Visual block mode
        (field int          start_vcol)         ;; start col for block mode operator
        (field int          end_vcol)           ;; end col for block mode operator
        (field long         prev_opcount)       ;; ca.opcount saved for K_CURSORHOLD
        (field long         prev_count0)        ;; ca.count0 saved for K_CURSORHOLD
    ])

;; Arguments for Normal mode commands.

(class! #_final cmdarg_C
    [
        (field oparg_C      oap)                ;; operator arguments
        (field int          prechar)            ;; prefix character (optional, always 'g')
        (field int          cmdchar)            ;; command character
        (field int          nchar)              ;; next command character (optional)
        (field int          ncharC1)            ;; first composing character (optional)
        (field int          ncharC2)            ;; second composing character (optional)
        (field int          extra_char)         ;; yet another character (optional)
        (field long         opcount)            ;; count before an operator
        (field long         count0)             ;; count before command, default 0
        (field long         count1)             ;; count before command, default 1
        (field int          arg)                ;; extra argument from nv_cmds[]
        (field int          retval)             ;; return: CA_* values
        (field Bytes        searchbuf)          ;; return: pointer to search pattern or null
    ])

;; values for retval:
(final int CA_COMMAND_BUSY  1)  ;; skip restarting edit() once
(final int CA_NO_ADJ_OP_END 2)  ;; don't adjust operator end

;;; ============================================================================================== VimE

;; ex_cmds.h --------------------------------------------------------------------------------------

(final int
    RANGE           0x001,   ;; allow a linespecs
    BANG            0x002,   ;; allow a ! after the command name
    EXTRA           0x004,   ;; allow extra args after command name
    NOSPC           0x010,   ;; no spaces allowed in the extra part
    DFLALL          0x020,   ;; default file range is 1,$
    NEEDARG         0x080,   ;; argument required
    COUNT           0x400,   ;; allow count in argument, after command
    ZEROR          0x1000,   ;; zero line number allowed
    NOTADR         0x4000,   ;; number before command is not an address
    CMDWIN       0x100000,   ;; allowed in cmdline window

    WORD1 (| EXTRA NOSPC))   ;; one extra word allowed

;; values for cmd_addr_type
(final byte
    ADDR_LINES          0,
    ADDR_WINDOWS        1)

(final int
    CMD_close 0,
    CMD_fixdel 1,
    CMD_only 2,
    CMD_retab 3,
    CMD_substitute 4,
    CMD_set 5,
    CMD_stop 6,
    CMD_suspend 7,
    CMD_syncbind 8,

    CMD_SIZE 9)     ;; MUST be after all real commands!

;; Arguments used for Ex commands.

(class! #_final exarg_C
    [
        (field Bytes        arg)            ;; argument of the command
        (field Bytes        nextcmd)        ;; next command (null if none)
        (field Bytes        cmd)            ;; the name of the command (except for :make)
        (field Bytes*       cmdlinep)       ;; pointer to pointer of allocated cmdline
        (field int          cmdidx)         ;; the index for the command
        (field long         argt)           ;; flags for the command
        (field boolean      skip)           ;; don't execute the command, only parse it
        (field boolean      forceit)        ;; true if ! present
        (field int          addr_count)     ;; the number of addresses given
        (field long         line1)          ;; the first line number
        (field long         line2)          ;; the second line number or count
        (field int          addr_type)      ;; type of the count/range
        (field int          regname)        ;; register name (NUL if none)
        (field Bytes        errmsg)         ;; returned error message
    ])

;; ----------------------------------------------------------------------- ;;

(defn- #_boolean asc-islower [#_int c] (<= (byte \a) c (byte \z)))
(defn- #_boolean asc-isupper [#_int c] (<= (byte \A) c (byte \Z)))
(defn- #_boolean asc-isalpha [#_int c] (or (asc-isupper c) (asc-islower c)))
(defn- #_boolean asc-isalnum [#_int c] (or (asc-isalpha c) (asc-isdigit c)))
(defn- #_boolean asc-iscntrl [#_int c] (or (<= 0x00 c 0x1f) (== c 0x7f)))
(defn- #_boolean asc-isgraph [#_int c] (<= 0x21 c 0x7e))
(defn- #_boolean asc-isprint [#_int c] (<= 0x20 c 0x7e))
(defn- #_boolean asc-ispunct [#_int c] (or (<= 0x21 c 0x2f) (<= 0x3a c 0x40) (<= 0x5b c 0x60) (<= 0x7b c 0x7e)))

;;; ============================================================================================== VimF

;; #include "globals.h"             ;; global variables and messages

;; Number of Rows and Cols in the screen.
;; Must be long to be able to use them as options in option.c.
;; Note: Use screenRows and screenCols to access items in screenLines[].
;; They may have different values when the screen wasn't (re)allocated yet
;; after setting Rows or Cols (e.g., when starting up).

(atom! long   Rows      24)      ;; nr of rows in the screen
(atom! long   Cols      80)      ;; nr of columns in the screen

;; The characters that are currently on the screen are kept in screenLines[].
;; It is a single block of characters, the size of the screen plus one line.
;; The attributes for those characters are kept in screenAttrs[].
;;
;; "lineOffset[n]" is the offset from screenLines[] for the start of line 'n'.
;; The same value is used for screenLinesUC[] and screenAttrs[].
;;
;; Note: before the screen is initialized and when out of memory these can be null.

(atom! Bytes    screenLines)
(atom! int*     screenAttrs)
(atom! int*     lineOffset)
(atom! boolean* lineWraps)          ;; line wraps to next line

;; When using Unicode characters (in UTF-8 encoding) the character in
;; screenLinesUC[] contains the Unicode for the character at this position,
;; or NUL when the character in screenLines[] is to be used (ASCII char).
;; The composing characters are to be drawn on top of the original character.
;; screenLinesC[0][off] is only to be used when screenLinesUC[off] != 0.

(atom! int*     screenLinesUC)      ;; decoded UTF-8 characters
(atom! int**    screenLinesC    MAX_MCO)    ;; composing characters
(atom! int      screen_mco)         ;; value of "p_mco" used when allocating screenLinesC[]

(atom! int      screenRows)         ;; actual size of screenLines[]
(atom! int      screenCols)      ;; actual size of screenLines[]

;; When vgetc() is called, it sets mod_mask to the set of modifiers that are
;; held down based on the MOD_MASK_* symbols that are read first.

(atom! int      mod_mask)           ;; current key modifiers

;; Cmdline_row is the row where the command line starts, just below the last window.
;; When the cmdline gets longer than the available space the screen gets scrolled up.
;; After a CTRL-D (show matches), after hitting ':' after "hit return",
;; and for the :global command, the command line is temporarily moved.
;; The old position is restored with the next call to update-screen().

(atom! int      cmdline_row)

(atom! boolean  redraw_cmdline)     ;; cmdline must be redrawn
(atom! boolean  clear_cmdline)      ;; cmdline must be cleared
(atom! boolean  mode_displayed)     ;; mode is being displayed

(atom! boolean  exec_from_reg)      ;; executing register

(atom! maybean  screen_cleared FALSE)     ;; screen has been cleared

;; Functions for putting characters in the command line,
;; while keeping screenLines[] updated.

(atom! int      msg_col)
(atom! int      msg_row)
(atom! int      msg_scrolled)       ;; number of screen lines that windows have scrolled because of printing messages
(atom! boolean  msg_scrolled_ign)   ;; when true don't set need_wait_return in msg-puts-attr() when msg_scrolled is non-zero

(atom! Bytes    keep_msg)           ;; msg to be shown after redraw
(atom! int      keep_msg_attr)      ;; highlight attr for "keep_msg"
(atom! boolean  keep_msg_more)      ;; "keep_msg" was set by msgmore()
(atom! boolean  msg_scroll)         ;; msg-start() will scroll
(atom! boolean  msg_didout)         ;; msg_outstr() was used in line
(atom! boolean  msg_didany)         ;; msg_outstr() was used at all
(atom! boolean  msg_nowait)         ;; don't wait for this msg
(atom! int      emsg_off)           ;; don't display errors for now
(atom! boolean  info_message)       ;; printing informative message
(atom! int      emsg_skip)          ;; don't display errors for expression that is skipped
(atom! boolean  did_emsg)           ;; set by emsg() when the message is displayed or thrown
(atom! boolean  did_emsg_syntax)    ;; did_emsg set because of a syntax error
(atom! boolean  called_emsg)        ;; always set by emsg()
(atom! boolean  emsg_on_display)    ;; there is an error message
(atom! boolean  rc_did_emsg)        ;; vim-regcomp() called emsg()

(atom! int      no_wait_return)     ;; don't wait for return for now
(atom! boolean  need_wait_return)   ;; need to wait for return later
(atom! boolean  did_wait_return)    ;; wait-return() was used and nothing written since then

(atom! boolean  quit_more)          ;; 'q' hit at "--more--" msg
(atom! boolean  newline_on_exit)    ;; did msg in altern. screen
(atom! int      intr_char)          ;; extra interrupt character
(atom! int      vgetc_busy)         ;; when inside vgetc() then > 0

;; Lines left before a "more" message.
;; Ex mode needs to be able to reset this after you type something.

(atom! int      lines_left      -1)     ;; lines left for listing
(atom! boolean  msg_no_more)            ;; don't use more prompt, truncate messages

(atom! boolean  scroll_region)                  ;; term supports scroll region
(atom! int      t_colors)                       ;; int value of T_CCO

;; When highlight_match is true, highlight a match, starting at the cursor position.
;; Search_match_lines is the number of lines after the match (0 for a match within one line),
;; search_match_endcol the column number of the character just after the match in the last line.

(atom! boolean  highlight_match)                ;; show search match pos
(atom! long     search_match_lines)             ;; lines of of matched string
(atom! int      search_match_endcol)            ;; col nr of match end

(atom! boolean  no_smartcase)                   ;; don't use 'smartcase' once

(atom! int*     highlight_attr HLF_COUNT)       ;; highl. attr. for each context
(atom! int      cterm_normal_fg_color)
(atom! int      cterm_normal_fg_bold)
(atom! int      cterm_normal_bg_color)

(defn- #_int hl-attr [#_int n]
    (... @highlight_attr n))

;; While redrawing the screen this flag is set.
;; It means the screen size ('lines' and 'rows') must not be changed.

(atom! boolean  updating_screen)

;; All windows are linked in a list.  "firstwin" points to the first entry,
;; "lastwin" to the last entry (can be the same as "firstwin") and "curwin"
;; to the currently active window.

(atom! window_C firstwin)               ;; first window
(atom! window_C lastwin)                ;; last window
(atom! window_C prevwin)                ;; previous window
(atom! window_C curwin)                 ;; currently active window

;; The window layout is kept in a tree of frames.  "topframe" points to the top of the tree.

(atom! frame_C  topframe)               ;; top of the window frame tree

(atom! buffer_C curbuf)                 ;; currently active buffer

(atom! int      ru_col)                 ;; column for ruler
(atom! int      ru_wid)                 ;; 'rulerfmt' width of ruler when non-zero
(atom! int      sc_col)                 ;; column for shown command

;; When starting or exiting some things are done differently (e.g. screen updating).

(atom! int      starting NO_SCREEN)     ;; first NO_SCREEN, then NO_BUFFERS and then set to 0 when starting up finished
(atom! boolean  exiting)                ;; true when planning to exit Vim.  Might still keep on running if there is a changed buffer.

;; volatile because it is used in signal handler deathtrap().
(atom! #_"/*volatile*/transient" boolean full_screen)   ;; true when doing full-screen output
                                                        ;; otherwise only writing some messages

(atom! int      textlock)               ;; non-zero when changing text and jumping to another window or buffer is not allowed

(atom! pos_C    VIsual_cursor           (NEW_pos_C))    ;; start position of active Visual selection
(atom! boolean  VIsual_active)          ;; whether Visual mode is active
(atom! boolean  VIsual_select)          ;; whether Select mode is active
(atom! boolean  VIsual_reselect)        ;; whether to restart the selection after a Select mode mapping or menu

(atom! int      VIsual_mode \v)         ;; type of Visual mode

(atom! boolean  redo_VIsual_busy)       ;; true when redoing Visual

;; When pasting text with the middle mouse button in visual mode with
;; restart_edit set, remember where it started so we can set insStart.

(atom! pos_C    where_paste_started     (NEW_pos_C))

;; This flag is used to make auto-indent work right on lines where only a
;; <RETURN> or <ESC> is typed.  It is set when an auto-indent is done, and
;; reset when any other editing is done on the line.  If an <ESC> or <RETURN>
;; is received, and did_ai is true, the line is truncated.

(atom! boolean  did_ai)

;; Column of first char after autoindent.  0 when no autoindent done.
;; Used when 'backspace' is 0, to avoid backspacing over autoindent.

(atom! int      ai_col)

;; This flag is set after a ":syncbind" to let the check-scrollbind() function
;; know that it should not attempt to perform scrollbinding due to the scroll
;; that was a result of the ":syncbind." (Otherwise, check-scrollbind() will
;; undo some of the work done by ":syncbind.")  -ralston

(atom! boolean  did_syncbind)

;; This flag is set when a smart indent has been performed.
;; When the next typed character is a '{' the inserted tab will be deleted again.

(atom! boolean  did_si)

;; This flag is set after an auto indent.
;; If the next typed character is a '}' one indent will be removed.

(atom! boolean  can_si)

;; This flag is set after an "O" command.
;; If the next typed character is a '{' one indent will be removed.

(atom! boolean  can_si_back)

;; Stuff for insert mode.
;; This is where the latest insert/append mode started.

(atom! pos_C    insStart        (NEW_pos_C))

;; This is where the latest insert/append mode started.  In contrast to
;; insStart, this won't be reset by certain keys and is needed for
;; op-insert(), to detect correctly where inserting by the user started.

(atom! pos_C    insStart_orig   (NEW_pos_C))

;; Stuff for VREPLACE mode.

(atom! long     orig_line_count)    ;; Line count when "gR" started
(atom! int      vr_lines_changed)   ;; #Lines changed by "gR" so far

;; "State" is the main state of Vim.
;; There are other variables that modify the state:
;; "Visual_mode"    When State is NORMAL or INSERT.
;; "finish_op"      When State is NORMAL, after typing the operator and before typing the motion command.

(atom! int      State NORMAL)       ;; This is the current state of the command interpreter.

(atom! boolean  finish_op)          ;; true while an operator is pending
(atom! long     opcount)            ;; count for pending operator

(atom! boolean  Recording)          ;; true when recording into a reg.
(atom! boolean  execReg)            ;; true when executing a register

(atom! int      no_mapping)         ;; currently no mapping allowed
(atom! int      allow_keys)         ;; allow key codes when no_mapping is set
(atom! int      no_u_sync)          ;; Don't call u-sync()
(atom! int      u_sync_once)        ;; Call u-sync() once when evaluating an expression.

(atom! int      restart_edit)       ;; call edit when next cmd finished
(atom! boolean  arrow_used)         ;; Normally false, set to true after hitting cursor key in insert mode.
                                    ;; Used by vgetorpeek() to decide when to call u-sync()
(atom! boolean  ins_at_eol)         ;; put cursor after eol when restarting edit after CTRL-O

(atom! Bytes    ioBuff      (Bytes. IOSIZE))        ;; sprintf's are done in this buffer, size is IOSIZE

(atom! int      no_redraw)          ;; When non-zero, postpone redrawing.

(atom! typebuf_C typebuf    (NEW_typebuf_C))  ;; typeahead buffer
(atom! boolean  stop_insert_mode)           ;; for ":stopinsert" and 'insertmode'

(atom! boolean  keyTyped)                   ;; true if user typed current char
(atom! boolean  keyStuffed)                 ;; true if current char from stuffbuf
(atom! int      maptick)                    ;; tick for each non-mapped char

(atom! byte*    chartab     256)            ;; table used in charset.c; see init-chartab()

(atom! int      must_redraw)                ;; type of redraw necessary
(atom! boolean  skip_redraw)                ;; skip redraw once
(atom! boolean  do_redraw)                  ;; extra redraw once

(atom! boolean  need_highlight_changed true)

(atom! int      read_cmd_fd)                ;; fd to read commands from

;; volatile because it is used in signal handler catch-sigint().
(atom! #_"/*volatile*/transient" boolean got_int) ;; set to true when interrupt signal occurred

(atom! boolean  termcap_active)             ;; set by start-termcap()
(atom! int      cur_tmode       TMODE_COOK) ;; input terminal mode
(atom! boolean  bangredo)                   ;; set to true with ! command
(atom! int      searchcmdlen)               ;; length of previous search cmd
(atom! int      reg_do_extmatch)            ;; Used when compiling regexp:
                                                        ;; REX_SET to allow \z\(...\),
                                                        ;; REX_USE to allow \z\1 et al.
(atom! reg_extmatch_C re_extmatch_in)       ;; Used by vim-regexec():
                                                        ;; strings for \z\1...\z\9
(atom! reg_extmatch_C re_extmatch_out)      ;; Set by vim-regexec()
                                                        ;; to store \z\(...\) matches

(atom! boolean  need_start_insertmode)      ;; start insert mode soon
(atom! Bytes    last_cmdline)               ;; last command line (for ":)
(atom! Bytes    repeat_cmdline)             ;; command line for "."
(atom! Bytes    new_last_cmdline)           ;; new value for "last_cmdline"
(atom! boolean  did_cursorhold)             ;; set when CursorHold t'gerd
(atom! pos_C    last_cursormoved    (NEW_pos_C)) ;; for CursorMoved event
(atom! int      last_changedtick)           ;; for TextChanged event
(atom! buffer_C last_changedtick_buf)

(atom! int      postponed_split)            ;; for CTRL-W CTRL-] command
(atom! int      postponed_split_flags)      ;; args for win-split()
(atom! int      replace_offset)             ;; offset for replace-push()

(atom! boolean* breakat_flags   256)        ;; which characters are in 'breakat'

;; Characters from 'fillchars' option.
(atom! int
    fill_stl    \space,
    fill_stlnc  \space,
    fill_vert   \|)

;; Characters from 'listchars' option.
(atom! int
    lcs_eol     \$,
    lcs_ext     NUL,
    lcs_tab     NUL,
    lcs_trail   NUL,
    lcs_conceal \space)

;; Whether 'keymodel' contains "stopsel" and "startsel".
(atom! boolean  km_stopsel)
(atom! boolean  km_startsel)

(atom! int      cedit_key   Ctrl_F)     ;; key value of 'cedit' option
(atom! int      cmdwin_type)            ;; type of cmdline window or 0
(atom! int      cmdwin_result)          ;; result of cmdline window or 0

(final Bytes    no_lines_msg (u8 "--No lines in buffer--"))

;; When ":global" is used to number of substitutions and changed lines is
;; accumulated until it's finished.

(atom! long     sub_nsubs)              ;; total number of substitutions
(atom! long     sub_nlines)             ;; total number of lines changed

;; don't use 'hlsearch' temporarily
(atom! boolean  no_hlsearch)

(atom! boolean  term_is_xterm   true)   ;; xterm-like 'term'

;; Set to TRUE when an operator is being executed with virtual editing,
;; MAYBE when no operator is being executed, FALSE otherwise.

(atom! maybean  virtual_op  MAYBE)

;; The error messages that can be shared are included here.
;; Excluded are errors that are only used once.

(final Bytes
    e_abort           (u8 "E470: Command aborted"),
    e_argreq          (u8 "E471: Argument required"),
    e_backslash       (u8 "E10: \\ should be followed by /, ? or &"),
    e_cmdwin          (u8 "E11: Invalid in command-line window; <CR> executes, CTRL-C quits"),
    e_internal        (u8 "E473: Internal error"),
    e_interr          (u8 "Interrupted"),
    e_invaddr         (u8 "E14: Invalid address"),
    e_invarg          (u8 "E474: Invalid argument"),
    e_invarg2         (u8 "E475: Invalid argument: %s"),
    e_invrange        (u8 "E16: Invalid range"),
    e_invcmd          (u8 "E476: Invalid command"),
    e_markinval       (u8 "E19: Mark has invalid line number"),
    e_marknotset      (u8 "E20: Mark not set"),
    e_nobang          (u8 "E477: No ! allowed"),
    e_noinstext       (u8 "E29: No inserted text yet"),
    e_nolastcmd       (u8 "E30: No previous command line"),
    e_nopresub        (u8 "E33: No previous substitute regular expression"),
    e_noprevre        (u8 "E35: No previous regular expression"),
    e_norange         (u8 "E481: No range allowed"),
    e_noroom          (u8 "E36: Not enough room"),
    e_nowrtmsg        (u8 "E37: No write since last change (add ! to override)"),
    e_null            (u8 "E38: Null argument"),
    e_number_exp      (u8 "E39: Number expected"),
    e_patnotf2        (u8 "E486: Pattern not found: %s"),
    e_positive        (u8 "E487: Argument must be positive"),
    e_re_damg         (u8 "E43: Damaged match string"),
    e_re_corr         (u8 "E44: Corrupted regexp program"),
    e_secure          (u8 "E523: Not allowed here"),
    e_scroll          (u8 "E49: Invalid scroll size"),
    e_toomsbra        (u8 "E76: Too many ["),
    e_trailing        (u8 "E488: Trailing characters"),
    e_umark           (u8 "E78: Unknown mark"),
    e_winheight       (u8 "E591: 'winheight' cannot be smaller than 'winminheight'"),
    e_winwidth        (u8 "E592: 'winwidth' cannot be smaller than 'winminwidth'"),
    e_zerocount       (u8 "Zero count"),
    e_intern2         (u8 "E685: Internal error: %s"),
    e_maxmempat       (u8 "E363: pattern uses more memory than 'maxmempattern'"),
    e_emptybuf        (u8 "E749: empty buffer"))

;; For undo we need to know the lowest time possible.
(atom! long starttime)

;; ----------------------------------------------------------------------- ;;

;; values for vim-handle-signal() that are not a signal
(final int SIGNAL_BLOCK    -1)
(final int SIGNAL_UNBLOCK  -2)

(final int KEYLEN_PART_KEY -1)      ;; keylen value for incomplete key-code
(final int KEYLEN_REMOVED  9999)    ;; keylen value for removed sequence

;; Position comparisons

(defn- #_boolean ltpos [#_pos_C a, #_pos_C b]
    (cond (!= (:lnum a) (:lnum b)) (< (:lnum a) (:lnum b)) (!= (:col a) (:col b)) (< (:col a) (:col b)) :else (< (:coladd a) (:coladd b))))

(defn- #_boolean eqpos [#_pos_C a, #_pos_C b]
    (and (== (:lnum a) (:lnum b)) (== (:col a) (:col b)) (== (:coladd a) (:coladd b))))

(defn- #_boolean ltoreq [#_pos_C a, #_pos_C b]
    (or (ltpos a, b) (eqpos a, b)))

;; true if the line is empty

(defn- #_boolean lineempty [#_long lnum]
    (eos? (ml-get lnum)))

;; true if the current buffer is empty

(defn- #_long line-count [#_buffer_C buf] (:ml_line_count (:b_ml buf)))

(defn- #_boolean bufempty []
    (and (== (line-count @curbuf) 1) (lineempty 1)))

;;; ============================================================================================== VimH

;; os_unix.c --------------------------------------------------------------------------------------

;; volatile because it is used in signal handler sig-winch().
(atom! #_"/*volatile*/transient" boolean do_resize)
;; volatile because it is used in signal handler deathtrap().
(atom! #_"/*volatile*/transient" int deadly_signal)                     ;; the signal we caught
;; volatile because it is used in signal handler deathtrap().
(atom! #_"/*volatile*/transient" boolean in_mch_delay)                  ;; sleeping in mch-delay()

(atom! int curr_tmode TMODE_COOK)                 ;; contains current terminal mode

(class! #_final signalinfo_C
    [
        (field int      sig)        ;; Signal number, e.g. SIGSEGV etc.
        (field Bytes    name)       ;; Signal name.
        (field boolean  deadly)     ;; Catch as a deadly signal?
    ])

(final signalinfo_C* signal_info
    [
; %%    (->signalinfo_C SIGHUP,    (u8 "HUP"),      true ),
; %%    (->signalinfo_C SIGQUIT,   (u8 "QUIT"),     true ),
; %%    (->signalinfo_C SIGILL,    (u8 "ILL"),      true ),
; %%    (->signalinfo_C SIGTRAP,   (u8 "TRAP"),     true ),
; %%    (->signalinfo_C SIGABRT,   (u8 "ABRT"),     true ),
; %%    (->signalinfo_C SIGFPE,    (u8 "FPE"),      true ),
; %%    (->signalinfo_C SIGBUS,    (u8 "BUS"),      true ),
; %%    (->signalinfo_C SIGSEGV,   (u8 "SEGV"),     true ),
; %%    (->signalinfo_C SIGSYS,    (u8 "SYS"),      true ),
; %%    (->signalinfo_C SIGALRM,   (u8 "ALRM"),     false),
; %%    (->signalinfo_C SIGTERM,   (u8 "TERM"),     true ),
; %%    (->signalinfo_C SIGVTALRM, (u8 "VTALRM"),   true ),
; %%    (->signalinfo_C SIGPROF,   (u8 "PROF"),     true ),
; %%    (->signalinfo_C SIGXCPU,   (u8 "XCPU"),     true ),
; %%    (->signalinfo_C SIGXFSZ,   (u8 "XFSZ"),     true ),
; %%    (->signalinfo_C SIGUSR1,   (u8 "USR1"),     true ),
; %%    (->signalinfo_C SIGUSR2,   (u8 "USR2"),     true ),
; %%    (->signalinfo_C SIGINT,    (u8 "INT"),      false),
; %%    (->signalinfo_C SIGWINCH,  (u8 "WINCH"),    false),
; %%    (->signalinfo_C SIGTSTP,   (u8 "TSTP"),     false),
; %%    (->signalinfo_C SIGPIPE,   (u8 "PIPE"),     false),

        (->signalinfo_C -1,        (u8 "Unknown!"), false)
    ])

;; Write s[len] to the screen.

(defn- #_void mch-write [#_Bytes s, #_int len]
;%% (.write libC 1, s, len)
    (when (non-zero? @p_wd)           ;; Unix is too fast, slow down a bit more
        (realWaitForChar @read_cmd_fd, @p_wd))
    nil)

;; mch-inchar(): low level input function.
;; Get a characters from the keyboard.
;; Return the number of characters that are available.
;; If wtime == 0 do not wait for characters.
;; If wtime == n wait a short time for characters.
;; If wtime == -1 wait forever for characters.

(defn- #_int mch-inchar [#_Bytes buf, #_int maxlen, #_long wtime, #_int tb_change_cnt]
    ;; Check if window changed size while we were busy, perhaps the ":set columns=99" command was used.
    (while @do_resize (handle-resize))
    (let-when [#_int n
        (cond (<= 0 wtime)
            (loop-when [] (not (waitForChar wtime))                 ;; no character available
                (if @do_resize (do (handle-resize) (recur)) 0))     ;; return if not interrupted by resize
        (not (waitForChar @p_ut))
            ;; If there is no character available within 'updatetime' seconds, flush all the swap files to disk.
            ;; Also done when interrupted by SIGWINCH.
            (if (and (trigger-cursorhold) (<= 3 maxlen) (not (typebuf-changed tb_change_cnt)))
                (do (-> buf (.be 0, KB_SPECIAL) (.be 1, KS_EXTRA) (.be 2, KE_CURSORHOLD)) 3)
                (do (before-blocking) nil)
            ))
    ] (nil? n) => n
        (loop []                                                    ;; repeat until we got a character
            (while @do_resize (handle-resize))                      ;; window changed size
            ;; We want to be interrupted by the SIGWINCH signal
            ;; or by an event on the monitored file descriptors.
            (cond (not (waitForChar -1))
                (do (when @do_resize (handle-resize)) 0)            ;; interrupted by SIGWINCH signal
            ;; If input was put directly in typeahead buffer bail out here.
            (typebuf-changed tb_change_cnt)
                0
            ;; For some terminals we only get one character at a time.
            ;; We want the get all available characters, so we could keep on trying until none is available.
            ;; For some other terminals this is quite slow, that's why we don't do it.
            :else
                (let [#_int len (read-from-input-buf buf, maxlen)] (if (< 0 len) len (recur)))
            ))
    ))

(defn- #_void handle-resize []
    (reset! do_resize false)
    (shell-resized)
    nil)

(defn- #_void mch-delay [#_long msec, #_boolean ignoreinput]
    (if ignoreinput
        (do ;; Go to cooked mode without echo, to allow SIGINT interrupting us here.
            ;; But we don't want QUIT to kill us (CTRL-\ used in a shell may produce SIGQUIT).
            (reset! in_mch_delay true)
            (let [#_int _ @curr_tmode]
                (when (== @curr_tmode TMODE_RAW)
                    (settmode TMODE_SLEEP))
                ;; Everybody sleeps in a different way...
                ;; Prefer nanosleep(), some versions of usleep() can only sleep up to one second.
                (ยง
                    ((ร timespec_C ts =) (new timespec_C))

                    (.tv_sec ts (/ msec 1000))
                    (.tv_nsec ts (* (% msec 1000) 1000000))
                    (.nanosleep libc ts, nil)
                )
                (settmode _)
                (reset! in_mch_delay false)
            ))
        (waitForChar msec))
    nil)

;; We need correct prototypes for a signal function, otherwise mean compilers
;; will barf when the second argument to sigset() is ``wrong''.

(defn- #_void sig-winch [#_int _sigarg]
    ;; this is not required on all systems, but it doesn't hurt anybody
;%% (.sigset libC SIGWINCH, #_"/*(void (*)())sig-winch*/"nil)
    (reset! do_resize true)
    nil)

(defn- #_void catch-sigint [#_int _sigarg]
    ;; this is not required on all systems, but it doesn't hurt anybody
;%% (.sigset libC SIGINT, #_"/*(void (*)())catch-sigint*/"nil)
    (reset! got_int true)
    nil)

(defn- #_void catch-sigpwr [#_int _sigarg]
    ;; this is not required on all systems, but it doesn't hurt anybody
;%% (.sigset libC SIGPWR, #_"/*(void (*)())catch-sigpwr*/"nil)
    nil)

(atom! int trap__entered)       ;; Count the number of times we got here.
                                            ;; Note: when memory has been corrupted, this may get an arbitrary value!

(defn- #_void may-core-dump []
    (when (non-zero? @deadly_signal)
;%%     (.sigset libC @deadly_signal, #_"/*SIG_DFL*/"nil)
;%%     (.kill libc (.getpid libc), @deadly_signal)        ;; Die using the signal we caught
    )
    nil)

;; This function handles deadly signals.
;; It tries to preserve any swap files and exit properly.
;; NOTE: Avoid unsafe functions, such as allocating memory, they can result in a deadlock.

(defn- #_void deathtrap [#_int sigarg]
    (ยง cond (and @in_mch_delay (== sigarg SIGQUIT))
        ;; While in mch-delay() we go to cooked mode to allow a CTRL-C to interrupt us.
        ;; But in cooked mode we may also get SIGQUIT, e.g., when pressing CTRL-\,
        ;; but we don't want Vim to exit then.
        nil
    (and (zero? @trap__entered) (any == sigarg SIGHUP SIGQUIT SIGTERM SIGPWR SIGUSR1 SIGUSR2) (not (vim-handle-signal sigarg)))
        ;; When SIGHUP, SIGQUIT, etc. are blocked: postpone the effect and return here.
        ;; This avoids that a non-reentrant function is interrupted, e.g. free().
        ;; Calling free() again may then cause a crash.
        nil
    :else
        (do ;; Remember how often we have been called.
            (swap! trap__entered inc)
            ;; Try to find the name of this signal.
            (let [#_int i (loop-when-recur [i 0] (and (!= (:sig (... signal_info i)) -1) (!= sigarg (:sig (... signal_info i)))) [(inc i)] => i)]
                (reset! deadly_signal sigarg)
                (reset! full_screen false)    ;; don't write message to the GUI, it might be part of the problem...

                ;; If something goes wrong after entering here, we may get here again.
                ;; When this happens, give a message and try to exit nicely (resetting the terminal mode, etc.)
                ;; When this happens twice, just exit, don't even try to give a message,
                ;; stack may be corrupt or something weird.
                ;; When this still happens again (or memory was corrupted in such a way
                ;; that "trap__entered" was clobbered) use _exit(), don't try freeing resources.

                (cond (<= 3 @trap__entered)
                (do
                    (reset-signals)        ;; don't catch any signals anymore
                    (may-core-dump)
                    (if (<= 4 @trap__entered) (._exit libc 8) (.exit libc 7))
                )
                (== @trap__entered 2)
                (do
                    (out-str (u8 "Vim: Double signal, exiting\n"))
                    (out-flush)
                    (getout 1)
                )
                :else
                (do
                    (.sprintf libC @ioBuff, (u8 "Vim: Caught deadly signal %s\n"), (:name (... signal_info i)))
                    ;; Preserve files and exit.
                    (preserve-exit @ioBuff)
                ))
            )
        nil)
    ))

;; If the machine has job control, use it to suspend the program,
;; otherwise fake it by starting a new shell.

(defn- #_void mch-suspend []
    (out-flush)                        ;; needed to make cursor visible on some systems
    (settmode TMODE_COOK)
    (out-flush)                        ;; needed to disable mouse on some systems

;%% (.kill libc 0, SIGTSTP)              ;; send ourselves a STOP signal

    (settmode TMODE_RAW)
    nil)

(defn- #_void mch-init []
    (reset! Cols 80)
    (reset! Rows 24)

    (out-flush)
    (set-signals)
    nil)

(defn- #_void set-signals []
    ;; WINDOW CHANGE signal is handled with sig-winch().

;%% (.sigset libC SIGWINCH, #_"/*(void (*)())sig-winch*/"nil)

    ;; We want the STOP signal to work, to make mch-suspend() work.
    ;; For "rvim" the STOP signal is ignored.

;%% (.sigset libC SIGTSTP, #_"/*SIG_DFL*/"nil)

    ;; We want to ignore breaking of PIPEs.

;%% (.sigset libC SIGPIPE, #_"/*SIG_IGN*/"nil)

    (catch-int-signal)

    ;; Ignore alarm signals (Perl's alarm() generates it).

;%% (.sigset libC SIGALRM, #_"/*SIG_IGN*/"nil)

    ;; Catch SIGPWR (power failure?) to preserve the swap files, so that no work will be lost.

;%% (.sigset libC SIGPWR, #_"/*(void (*)())catch-sigpwr*/"nil)

    ;; Arrange for other signals to gracefully shutdown Vim.

;%% (catch-signals #_"/*deathtrap*//*null*/"0, SIG_ERR)
    nil)

;; Catch CTRL-C (only works while in Cooked mode).

(defn- #_void catch-int-signal []
;%% (.sigset libC SIGINT, #_"/*(void (*)())catch-sigint*/"nil)
    nil)

(defn- #_void reset-signals []
;%% (catch-signals SIG_DFL, SIG_DFL)
    nil)

(defn- #_void catch-signals #_"/*(void (*func_deadly)(), void (*func_other)())*/" [#_@sighandler_t #_long func_deadly, #_@sighandler_t #_long func_other]
    (ยง
        (loop-when-recur [#_int i 0] (!= (:sig (... signal_info i)) -1) [(inc i)]
            (cond (:deadly (... signal_info i))
            (do
;            // sigaction_C sa = new sigaction_C();

                ;; Setup to use the alternate stack for the signal function.
;            // sa.sa_handler(func_deadly);
                (.sigemptyset libC #_"/*&sa.sa_mask*/"nil)
;            // sa.sa_flags(SA_ONSTACK);
                (.sigaction libC (:sig (... signal_info i)), #_"/*sa*/"null, nil)
            )
            (!= func_other SIG_ERR)
            (do
                (.sigset libC (:sig (... signal_info i)), #_"/*func_other*/"nil)
            ))
        )
        nil
    ))

(atom! int got_signal)
(atom! boolean __blocked true)

;; Handling of SIGHUP, SIGQUIT and SIGTERM:
;; "when" == a signal:       when busy, postpone and return false, otherwise return true
;; "when" == SIGNAL_BLOCK:   Going to be busy, block signals
;; "when" == SIGNAL_UNBLOCK: Going to wait, unblock signals, use postponed signal
;; Returns true when Vim should exit.

(defn- #_boolean vim-handle-signal [#_int sig]
    (cond (== sig SIGNAL_BLOCK)
    (do
        (reset! __blocked true)
        false
    )
    (== sig SIGNAL_UNBLOCK)
    (do
        (reset! __blocked false)
        (when (non-zero? @got_signal)
;%%         (.kill libc (.getpid libc), @got_signal)
            (reset! got_signal 0)
        )
        false
    )
    @__blocked
    (do
        (reset! got_signal sig)
;%%     (when (!= sig SIGPWR)
;%%         (reset! got_int true))         ;; break any loops
        false
    )
    :else
        true            ;; exit!
    ))

;; Output a newline when exiting.
;; Make sure the newline goes to the same stream as the text.

(defn- #_void exit-scroll []
    (cond (or @newline_on_exit @msg_didout)
    (do
        (cond (msg-use-printf)
        (do
;%%         (if @info_message
;%%             (.fprintf libC stdout, (u8 "\n"))
;%%             (.fprintf libC stderr, (u8 "\r\n"))
;%%         )
        )
        :else
        (do
            (out-char (byte \newline))
        ))
    )
    :else
    (do
        (restore-cterm-colors)         ;; get original colors back
        (msg-clr-eos-force)            ;; clear the rest of the display
        (windgoto (dec @Rows), 0)     ;; may have moved the cursor
    ))
    nil)

(defn- #_void mch-exit [#_int r]
    (reset! exiting true)

    (settmode TMODE_COOK)

    ;; When t_ti is not empty, but it doesn't cause swapping terminal pages,
    ;; need to output a newline when msg_didout is set.
    ;; But when t_ti does swap pages, it should not go to the shell page.
    ;; Do this before stop-termcap().

    (when (and (swapping-screen) (not @newline_on_exit))
        (exit-scroll))

    (stop-termcap)

    ;; A newline is only required after a message in the alternate screen.
    ;; This is set to true by wait-return().
    (when (or (not (swapping-screen)) @newline_on_exit)
        (exit-scroll))

    ;; Cursor may have been switched off without calling start-termcap()
    ;; when doing "vim -u vimrc" and vimrc contains ":q".
    (when @full_screen
        (cursor-on))

    (out-flush)

    (may-core-dump)

;%% (.exit libc r)
    nil)

;; for "new" tty systems

(atom! termios_C stm__told)

(defn- #_void mch-settmode [#_int tmode]
    (ยง
        (when (nil? @stm__told)
            (reset! stm__told (new termios_C))
            (.tcgetattr libc @read_cmd_fd, @stm__told)
        )

        ((ร termios_C tnew =) (new termios_C))
        (COPY_termios tnew, @stm__told)

        (cond (== tmode TMODE_RAW)
        (do
            ;; ~ICRNL enables typing ^V^M

            (.c_iflag tnew (& (.c_iflag tnew) (bit-not ICRNL)))
            (.c_lflag tnew (& (.c_lflag tnew) (bit-not (| ICANON ECHO ISIG ECHOE IEXTEN))))
            (.c_oflag tnew (& (.c_oflag tnew) (bit-not ONLCR)))
            (.c_vmin tnew (short 1))      ;; return after 1 char
            (.c_vtime tnew (short 0))     ;; don't wait
        )
        (== tmode TMODE_SLEEP)
        (do
            (.c_lflag tnew (& (.c_lflag tnew) (bit-not ECHO)))
        ))

        ;; A signal may cause tcsetattr() to fail (e.g., SIGCONT).  Retry a few times.
        (loop-when-recur [#_int n 10] (and (== (.tcsetattr libc @read_cmd_fd, TCSANOW, tnew) -1) (== (.errno libC) EINTR) (< 0 n)) [(dec n)]
;           ;
        )

        (reset! curr_tmode tmode)
        nil
    ))

;; try to get the code for "t_kb" from the stty setting
;;
;; Even if termcap claims a backspace key, the user's setting *should*
;; prevail.  stty knows more about reality than termcap does, and if
;; somebody's usual erase key is DEL (which, for most BSD users, it will
;; be), they're going to get really annoyed if their erase key starts
;; doing forward deletes for no reason.

(defn- #_void get-stty []
    (ยง let [#_termios_C keys (new termios_C)]
        (when (!= (.tcgetattr libc @read_cmd_fd, keys) -1)
        (let [#_Bytes buf (Bytes. 2)]
            (.be buf 0, (.c_verase keys))
            (reset! intr_char (.c_vintr keys))
            (eos! buf 1)
            (add-termcode (u8 "kb"), buf)
            ;; If <BS> and <DEL> are now the same, redefine <DEL>.
            (let [#_Bytes p (find-termcode (u8 "kD"))]
                (when (and (some? p) (at? p 0 (.at buf 0)) (at? p 1 (.at buf 1)))
                    (ex-fixdel nil))
            ))
        ))
    nil)

;; Try to get the current window size:
;; 1. with an ioctl(), most accurate method
;; 2. from the environment variables LINES and COLUMNS
;; 4. keep using the old values
;; Return true when size could be determined, false otherwise.

(defn- #_boolean mch-get-shellsize []
    (ยง let [#_long rows 0 #_long cols 0
          ;; 1.  Try using an ioctl().  It is the most accurate method.
          #_int fd 1
          ;; When stdout is not a tty, use stdin for the ioctl().
          fd (if (and (zero? (.isatty libc fd)) (non-zero? (.isatty libc @read_cmd_fd))) @read_cmd_fd fd)
          [rows cols] (let [#_winsize_C ws (new winsize_C)] (if (zero? (.ioctl libc fd, TIOCGWINSZ, ws)) [(.ws_row ws) (.ws_col ws)] [rows cols]))
          ;; 2.  Get size from environment.
          [rows cols] (if (or (zero? cols) (zero? rows))
                            (let [#_Bytes p (.getenv libC (u8 "LINES"))   rows (if (some? p) (.atoi libC p) rows)
                                          p (.getenv libC (u8 "COLUMNS")) cols (if (some? p) (.atoi libC p) cols)]
                            [rows cols]) [rows cols])
        ] ;; 4.  If everything fails, use the old values.
        (and (< 0 cols) (< 0 rows)
            (do
                (reset! Rows rows)
                (reset! Cols cols)
                (limit-screen-size)
                true
            ))
    ))

;; Try to set the window size to Rows and Cols.

(defn- #_void mch-set-shellsize []
    (when (non-eos? @T_CWS)
        ;; NOTE: if you get an error here that term-set-winsize() is undefined,
        ;; check the output of configure.  It could probably not find a ncurses,
        ;; termcap or termlib library.

        (term-set-winsize @Rows, @Cols)
        (out-flush)
        (screen-start)                 ;; don't know where cursor is now
    )
    nil)

;; Rows and/or Cols has changed.

(defn- #_void mch-new-shellsize []
    ;; Nothing to do.
    nil)

;; Check for CTRL-C typed by reading all available characters.
;; In cooked mode we should get SIGINT, no need to check.

(defn- #_void mch-breakcheck []
    (when (and (== @curr_tmode TMODE_RAW) (realWaitForChar @read_cmd_fd, 0))
        (fill-input-buf false)
    )
    nil)

;; Wait "msec" msec until a character is available from the keyboard or from inbuf[].
;; "msec" == -1 will block forever.

(defn- #_boolean waitForChar [#_long msec]
    (or (input-available) (realWaitForChar @read_cmd_fd, msec)))

;; Wait "msec" msec until a character is available from file descriptor "fd".
;; "msec" == 0 will check for characters once.
;; "msec" == -1 will block until a character is available.

(defn- #_boolean realWaitForChar [#_int fd, #_long msec]
    (ยง
        ((ร timeval_C tv =) (new timeval_C))
        (when (<= 0 msec)
            (.tv_sec tv (/ msec 1000))
            (.tv_usec tv (* (% msec 1000) 1000))
        )

        ;; Select on ready for reading and exceptional condition (end of file).

        ((ร long[] rfds =) (ร new long[FD_SET_LENGTH]))
        ((ร long[] efds =) (ร new long[FD_SET_LENGTH]))
        (loop []
            (FD_ZERO rfds)
            (FD_ZERO efds)
            (FD_SET fd, rfds)
            (FD_SET fd, efds)

            ((ร int ret =) (.select libc (inc fd), rfds, nil, efds, (if (< msec 0) nil tv)))

            (when (and (== ret -1) (== (.errno libC) EINTR))
                ;; Check whether window has been resized, EINTR may be caused by SIGWINCH.

                (when @do_resize (handle-resize))

                ;; Interrupted by a signal, need to try again.  We ignore msec here,
                ;; because we do want to check even after a timeout if characters are available.
                ;; Needed for reading output of an external command after the process has finished.

                (ร CONTINUE)
            )

            ((ร RETURN) (< 0 ret))
            (recur)
        )

        ;; NOTREACHED
    ))

;; message.c: functions for displaying messages on the command line -------------------------------

(atom! int      confirm_msg_used)       ;; displaying "confirm_msg"
(atom! Bytes    confirm_msg)            ;; ":confirm" message
(atom! Bytes    confirm_msg_tail)       ;; tail of "confirm_msg"

;; When writing messages to the screen, there are many different situations.
;; A number of variables is used to remember the current state:
;; msg_didany       true when messages were written since the last time the user reacted to a prompt.
;;                  Reset: After hitting a key for the hit-return prompt,
;;                  hitting <CR> for the command line or input().
;;                  Set: When any message is written to the screen.
;; msg_didout       true when something was written to the current line.
;;                  Reset: When advancing to the next line, when the current text can be overwritten.
;;                  Set: When any message is written to the screen.
;; msg_nowait       No extra delay for the last drawn message.
;;                  Used in normal-cmd() before the mode message is drawn.
;; emsg_on_display  There was an error message recently.
;;                  Indicates that there should be a delay before redrawing.
;; msg_scroll       The next message should not overwrite the current one.
;; msg_scrolled     How many lines the screen has been scrolled (because of messages).
;;                  Used in update-screen() to scroll the screen back.
;;                  Incremented each time the screen scrolls a line.
;; msg_scrolled_ign true when msg_scrolled is non-zero and msg-puts-attr() writes something
;;                  without scrolling should not make need_wait_return to be set.
;;                  This is a hack to make ":ts" work without an extra prompt.
;; lines_left       Number of lines available for messages before the more-prompt is to be given.
;;                  -1 when not set.
;; need_wait_return true when the hit-return prompt is needed.
;;                  Reset: After giving the hit-return prompt, when the user has answered some other prompt.
;;                  Set: When the ruler or typeahead display is overwritten,
;;                  scrolling the screen for some message.
;; keep_msg         Message to be displayed after redrawing the screen, in main-loop().
;;                  This is an allocated string or null when not used.

;; msg(s) - displays the string 's' on the status line.
;; Return true if wait-return not called.

(defn- #_boolean msg [#_Bytes s]
    (msg-attr-keep s, 0, false))

(defn- #_boolean msg-attr [#_Bytes s, #_int attr]
    (msg-attr-keep s, attr, false))

(atom! int msg__entered)

(defn- #_boolean msg-attr-keep [#_Bytes s, #_int attr, #_boolean keep] ;; keep: true: set "keep_msg" if it doesn't scroll
    ;; It is possible that displaying a messages causes a problem
    ;; (e.g. when redrawing the window), which causes another message, etc.
    ;; To break this loop, limit the recursiveness to 3 levels.
    (or (<= 3 @msg__entered)
        (do
            (swap! msg__entered inc)
            ;; When displaying "keep_msg", don't let msg-start() free it, caller must do that.
            (when (BEQ s, @keep_msg)
                (reset! keep_msg nil))
            ;; Truncate the message if needed.
            (msg-start)
            (let [#_Bytes buf (msg-strtrunc s) s (if (some? buf) buf s)]
                (msg-outtrans-attr s, attr)
                (msg-clr-eos)
                (let [#_boolean retval (msg-end)]
                    (when (and keep retval (< (mb-string2cells s) (+ (* (- @Rows @cmdline_row 1) @Cols) @sc_col)))
                        (set-keep-msg s, 0))
                    (swap! msg__entered dec)
                    retval
                )
            )
        )
    ))

;; Truncate a string such that it can be printed without causing a scroll.
;; Returns an allocated string or null when no truncating is done.

(defn- #_Bytes msg-strtrunc [#_Bytes s]
    ;; May truncate message to avoid a hit-return prompt.
    (when (and (not @msg_scroll) (not @need_wait_return))
        (let [m (if (non-zero? @msg_scrolled)
                (dec    (* (- @Rows @msg_row)   @Cols)) ;; Use all the columns.
                (dec (+ (* (- @Rows @msg_row 1) @Cols) @sc_col)))] ;; Use up to 'showcmd' column.
            (when (< 0 m (mb-string2cells s))
                ;; may have up to 18 bytes per cell (6 per char, up to two composing chars)
                (let [n (* (+ m 2) 18) buf (Bytes. n)]
                    (trunc-string s, buf, m, n)
                    buf)
            ))
    ))

;; Truncate a string "s" to "buf" with cell width "room".
;; "s" and "buf" may be equal.

(defn- #_void trunc-string [#_Bytes s, #_Bytes buf, #_int room, #_int buflen]
    (let-when [room (- room 3) #_int half (/ room 2)
          [#_int len #_int e :as _]
            (loop-when [len 0 e 0] (and (< len half) (< e buflen)) => [len e]
                (if (eos? s e)
                    (do (eos! buf e) nil) ;; text fits without truncating!
                    (let [#_int n (mb-ptr2cells s, e)]
                        (if (<= half (+ len n))
                            [len e]
                            (let [len (+ len n)]
                                (.be buf e, (.at s e))
                                (let [e (loop-when [e e #_int n (dec (us-ptr2len-cc s, e))] (< 0 n) => e
                                            (let [e (inc e)] (if (< e buflen) (do (.be buf e, (.at s e)) (recur e (dec n))) e))
                                        )]
                                    (recur len (inc e))
                                ))
                        ))
                ))] (some? _)
        (let [#_int i ;; For UTF-8 we can go backwards easily.
                (loop [half (STRLEN s) len len i half]
                    (let [half (loop [half half] (let [half (- half (us-head-off s, (.plus s (dec half))) 1)]
                            (recur-if (and (utf-iscomposing (us-ptr2char s, half)) (< 0 half)) half => half)))
                          #_int n (mb-ptr2cells s, half)]
                        (if (< room (+ len n)) i (recur half (+ len n) half))
                    ))]
            ;; Set the middle and copy the last part.
            (if (< (+ e 3) buflen)
                (let [#_int len (min (inc (STRLEN s, i)) (- buflen e 3 1))]
                    (BCOPY buf, e, (u8 "..."), 0, 3)
                    (BCOPY buf, (+ e 3), s, i, len)
                    (eos! buf (dec (+ e 3 len))))
                (eos! buf (dec e))     ;; make sure it is truncated
            )))
    nil)

(defn- #_final #_boolean smsg [#_Bytes s, #_Object... args]
    (smsg-attr 0, s, args))

(defn- #_boolean smsg-attr [#_int attr, #_Bytes s, #_Object... args]
;%% (vim_snprintf @ioBuff, IOSIZE, s, args)
    (msg-attr @ioBuff, attr))

;; Return true if not giving error messages right now:
;; If "emsg_off" is set: no error messages at the moment.
;; If "emsg_skip" is set: never do error messages.

(defn- #_boolean emsg-not-now []
    (or (< 0 @emsg_off) (< 0 @emsg_skip)))

;; emsg() - display an error message.
;;
;; Rings the bell, if appropriate, and calls message() to do the real work.
;;
;; Return true if wait-return not called.

(defn- #_boolean emsg [#_Bytes s]
    ;; Skip this if not giving error messages at the moment.
    (or (emsg-not-now)
        (do
            (reset! called_emsg true)

            (when (zero? @emsg_off)
                (if @p_eb
                    (beep-flush)                    ;; also includes flush-buffers()
                    (flush-buffers false))          ;; flush internal buffers
                (reset! did_emsg true))             ;; flag for DoOneCmd()

            (reset! emsg_on_display true)           ;; remember there is an error message
            (reset! msg_scroll true)                ;; don't overwrite a previous message

            ;; needed in case emsg() is called after wait-return has reset need_wait_return
            ;; and a redraw is expected because msg_scrolled is non-zero
            (when (non-zero? @msg_scrolled)
                (reset! need_wait_return true))

            (reset! msg_nowait false)               ;; wait for this msg
            (msg-attr s, (hl-attr HLF_E))           ;; highlight mode for error messages
        )
    ))

;; Print an error message with one "%s" and one string argument.

(defn- #_boolean emsg2 [#_Bytes s, #_Bytes a1]
    (emsg3 s, a1, nil))

;; emsg3() and emsgn() are in misc.c to avoid warnings for the prototypes.

(defn- #_void emsg-invreg [#_int name]
    (emsg2 (u8 "E354: Invalid register name: '%s'"), (transchar name))
    nil)

;; Wait for the user to hit a key (normally a RETURN).
;;
;; If 'redraw' is TRUE, clear and redraw the screen;
;; if 'redraw' is FALSE, just redraw the screen;
;; if 'redraw' is -1, don't redraw at all.

(defn- #_window_C wait-return [#_window_C win, #_int redraw]
    (when (== redraw TRUE)
        (reset! must_redraw CLEAR))
    ;; When inside vgetc(), we can't wait for a typed character at all.
    ;; With the global command (and some others) we only need one return at the end.
    ;; Adjust cmdline_row to avoid the next message overwriting the last one.
    (if (< 0 @vgetc_busy)
        win
        (do (reset! need_wait_return true)
            (if (non-zero? @no_wait_return)
                (do (reset! cmdline_row @msg_row) win)
                (let [#_int o'State @State
                      #_int c
                        (if @quit_more
                            (do (reset! quit_more false) (reset! got_int false) CAR) ;; just pretend CR was hit
                            (do ;; Make sure the hit-return prompt is on screen when 'guioptions' was just changed.
                                (screen-alloc false)
                                (reset! State HITRETURN)
                                (hit-return-msg)
                                (let [c (loop []
                                            ;; Remember "got_int": if it is set, vgetc() probably returns a CTRL-C, but we need to loop then.
                                            ;; Temporarily disable Recording.  If Recording is active, the character will be recorded later,
                                            ;; since it will be added to the typebuf after the loop.
                                            (let [o'got_int @got_int o'Recording @Recording
                                                _ (reset! Recording false)
                                                ;; Don't do mappings here, we put the character back in the typeahead buffer.
                                                _ (swap! no_mapping inc) _ (swap! allow_keys inc) c (safe-vgetc) _ (swap! no_mapping dec) _ (swap! allow_keys dec)
                                                _ (reset! Recording o'Recording)
                                                _ (when o'got_int (reset! got_int false))
                                                ;; Allow scrolling back in the messages.
                                                ;; Also accept scroll-down commands when messages fill the screen,
                                                ;; to avoid that typing one 'j' too many makes the messages disappear.
                                                c (if @p_more
                                                        (cond (any == c (byte \b) (byte \k) (byte \u) (byte \g) K_UP K_PAGEUP)
                                                            (let [c (if (< @Rows @msg_scrolled) ;; scroll back to show older messages
                                                                        (do (do-more-prompt c) c)
                                                                        (do (reset! msg_didout false) (reset! msg_col 0) K_IGNORE)
                                                                    )]
                                                                (cond
                                                                    @quit_more (do (reset! quit_more false) (reset! got_int false) CAR) ;; just pretend CR was hit
                                                                    (!= c K_IGNORE) (do (hit-return-msg) K_IGNORE)
                                                                    :else c
                                                                ))
                                                        (and (< (- @Rows 2) @msg_scrolled) (any == c (byte \j) (byte \d) (byte \f) K_DOWN K_PAGEDOWN))
                                                            K_IGNORE
                                                        :else
                                                            c)
                                                        c
                                                    )]
                                                (recur-if (or (and o'got_int (== c Ctrl_C)) (== c K_IGNORE)) [] => c))
                                        )]
                                    (ui-breakcheck)
                                    (when-not (any == c (byte \return) (byte \newline) (byte \space) Ctrl_C)
                                        ;; Put the character back in the typeahead buffer.
                                        ;; Don't use the stuff buffer, because lmaps wouldn't work.
                                        (ins-char-typebuf c)
                                        (reset! do_redraw true))    ;; need a redraw even though there is typeahead
                                    c
                                ))
                        )]
                    ;; If the user hits ':', '?' or '/' we get a command line from the next line.
                    (when (any == c (byte \:) (byte \?) (byte \/))
                        (reset! cmdline_row @msg_row)
                        (reset! skip_redraw true)                   ;; skip redraw once
                        (reset! do_redraw false))
                    ;; If the window size changed set-shellsize() will redraw the screen.
                    ;; Otherwise the screen is only redrawn if 'redraw' is set and no ':' typed.
                    (let [state' @State _ (reset! State o'State)]   ;; restore State before set-shellsize
                        (msg-check)
                        ;; When switching screens, we need to output an extra newline on exit.
                        (when (and (swapping-screen) (not @termcap_active))
                            (reset! newline_on_exit true))
                        (reset! need_wait_return false)
                        (reset! did_wait_return true)
                        (reset! emsg_on_display false)              ;; can delete error message now
                        (reset! lines_left -1)                      ;; reset lines_left at next msg-start()
                        (when (and (some? @keep_msg) (<= (+ (* (- @Rows @cmdline_row 1) @Cols) @sc_col) (mb-string2cells @keep_msg)))
                            (reset! keep_msg nil))                  ;; don't redisplay message, it's too long
                        (cond (== state' SETWSIZE)                  ;; got resize event while in vgetc()
                            (do (start-termcap)                     ;; start termcap before redrawing
                                (shell-resized)
                                win)
                        (and (not @skip_redraw) (or (== redraw TRUE) (and (non-zero? @msg_scrolled) (!= redraw -1))))
                            (do (start-termcap)                     ;; start termcap before redrawing
                                (redraw-later win, VALID))
                        :else
                            win)
                    ))
            ))
    ))

;; Write the hit-return prompt.

(defn- #_void hit-return-msg []
    (let [o'p_more @p_more _ (reset! p_more false)] ;; don't want see this message when scrolling back
        (when @msg_didout
            (msg-putchar (byte \newline)))          ;; start on a new line
        (when @got_int
            (msg-puts (u8 "Interrupt: ")))
        (msg-puts-attr (u8 "Press ENTER or type command to continue"), (hl-attr HLF_R))
        (when (not (msg-use-printf))
            (msg-clr-eos))
        (reset! p_more o'p_more))
    nil)

;; Set "keep_msg" to "s".  Free the old value and check for null pointer.

(defn- #_void set-keep-msg [#_Bytes s, #_int attr]
    (reset! keep_msg (if (some? s) (STRDUP s) nil))
    (reset! keep_msg_more false)
    (reset! keep_msg_attr attr)
    nil)

;; Prepare for outputting characters in the command line.

(defn- #_void msg-start []
    (reset! keep_msg nil)                       ;; don't display old message now
    (cond (and (not @msg_scroll) @full_screen)  ;; overwrite last message
    (do
        (reset! msg_row @cmdline_row)
        (reset! msg_col 0)
    )
    @msg_didout                                 ;; start message on next line
    (do
        (msg-putchar (byte \newline))
        (reset! cmdline_row @msg_row)
    ))
    (when (or (not @msg_didany) (< @lines_left 0))
        (msg-starthere))
    (reset! msg_didout false)                   ;; no output on current line yet
    (cursor-off)
    nil)

;; Note that the current msg position is where messages start.

(defn- #_void msg-starthere []
    (reset! lines_left @cmdline_row)
    (reset! msg_didany false)
    nil)

(defn- #_void msg-putchar [#_int c]
    (msg-putchar-attr c, 0))

(defn- #_void msg-putchar-attr [#_int c, #_int attr]
    (let [#_Bytes buf (Bytes. (inc MB_MAXBYTES))]
        (if (is-special c)
            (-> buf (.be 0, KB_SPECIAL) (.be 1, (KB-SECOND c)) (.be 2, (KB-THIRD c)) (eos! 3))
            (eos! buf (utf-char2bytes c, buf)))
        (msg-puts-attr buf, attr)
        nil))

;; Output 'len' characters in 'p' (including NULs) with translation
;; if 'len' is -1, output upto a NUL character.
;; Use attributes 'attr'.
;; Return the number of characters it takes on the screen.

(defn- #_int msg-outtrans [#_Bytes p]
    (msg-outtrans-attr p, 0))

(defn- #_int msg-outtrans-attr [#_Bytes p, #_int attr]
    (msg-outtrans-len-attr p, (STRLEN p), attr))

(defn- #_int msg-outtrans-len [#_Bytes p, #_int len]
    (msg-outtrans-len-attr p, len, 0))

(defn- #_int msg-outtrans-len-attr [#_Bytes p, #_int len, #_int attr]
    ;; If the string starts with a composing character,
    ;; first draw a space on which the composing char can be drawn.
    (when (utf-iscomposing (us-ptr2char p))
        (msg-puts-attr (u8 " "), attr))
    ;; Go over the string.  Special characters are translated and printed.
    ;; Normal characters are printed several at a time.
    (let [[#_int cells #_Bytes q p]
            (loop-when [cells 0 q p p p len len] (< 0 len) => [cells q p]
                ;; Don't include composing chars after the end.
                (let [#_int l (us-ptr2len-cc-len p, len)]
                    (cond (< 1 l)
                        (let [#_int c (us-ptr2char p)
                              [cells q]
                                (if (vim-isprintc c) ;; printable multi-byte char: count the cells
                                    [(+ cells (us-ptr2cells p)) q]
                                    (do ;; unprintable multi-byte char: print the printable chars
                                        ;; so far and the translation of the unprintable char
                                        (when (BLT q, p)
                                            (msg-puts-attr-len q, (BDIFF p, q), attr))
                                        (msg-puts-attr (transchar c), (if (zero? attr) (hl-attr HLF_8) attr))
                                        [(+ cells (mb-char2cells c)) (.plus p l)])
                                )]
                            (recur cells q (.plus p l) (- len l)))
                    :else
                        (let [#_Bytes s (transchar-byte (.at p 0))
                              [cells q]
                                (if (eos? s 1)
                                    [(inc cells) q]
                                    (do ;; unprintable char: print the printable chars so far
                                        ;; and the translation of the unprintable char
                                        (when (BLT q, p)
                                            (msg-puts-attr-len q, (BDIFF p, q), attr))
                                        (msg-puts-attr s, (if (zero? attr) (hl-attr HLF_8) attr))
                                        [(+ cells (STRLEN s)) (.plus p 1)])
                                )]
                            (recur cells q (.plus p 1) (dec len)))
                    ))
            )]
        (when (BLT q, p)
            ;; print the printable chars at the end
            (msg-puts-attr-len q, (BDIFF p, q), attr))
        cells
    ))

;; Use screen-puts() to output one multi-byte character.
;; Return the pointer "s" advanced to the next character.

(defn- #_Bytes screen-puts-mbyte [#_Bytes s, #_int len, #_int attr]
    (reset! msg_didout true) ;; remember that line is not empty
    (let [#_int cells (us-ptr2cells s)]
        (if (and (< 1 cells) (== @msg_col (dec @Cols)))
            ;; Doesn't fit, print a highlighted '>' to fill it up.
            (do (msg-screen-putchar (byte \>), (hl-attr HLF_AT)) s)
            (do
                (screen-puts-len s, len, @msg_row, @msg_col, attr)
                (swap! msg_col + cells)
                (when (<= @Cols @msg_col)
                    (reset! msg_col 0)
                    (swap! msg_row inc))
                (.plus s len)
            ))
    ))

;; Output a string to the screen at position msg_row, msg_col.
;; Update msg_row and msg_col for the next message.

(defn- #_void msg-puts [#_Bytes s]
    (msg-puts-attr s, 0)
    nil)

(defn- #_void msg-puts-title [#_Bytes s]
    (msg-puts-attr s, (hl-attr HLF_T))
    nil)

;; Basic function for writing a message with highlight attributes.

(defn- #_void msg-puts-attr [#_Bytes s, #_int attr]
    (msg-puts-attr-len s, -1, attr)
    nil)

;; Like msg-puts-attr(), but with a maximum length "maxlen" (in bytes).
;; When "maxlen" is -1 there is no maximum length.
;; When "maxlen" is >= 0 the message is not put in the history.

(defn- #_void msg-puts-attr-len [#_Bytes str, #_int maxlen, #_int attr]
    ;; When writing something to the screen after it has scrolled, requires
    ;; a wait-return prompt later.  Needed when scrolling, resetting need_wait_return
    ;; after some prompt, and then outputting something without scrolling.

    (when (and (non-zero? @msg_scrolled) (not @msg_scrolled_ign))
        (reset! need_wait_return true))
    (reset! msg_didany true)          ;; remember that something was outputted

    ;; If there is no valid screen, use fprintf so we can see error messages.
    ;; If termcap is not active, we may be writing in an alternate console window,
    ;; cursor positioning may not work correctly (window size may be different,
    ;; e.g. for Win32 console) or we just don't know where the cursor is.

    (if (msg-use-printf)
        (msg-puts-printf str, maxlen)
        (msg-puts-display str, maxlen, attr, false))
    nil)

;; The display part of msg-puts-attr-len().
;; May be called recursively to display scroll-back text.

(defn- #_void msg-puts-display [#_Bytes str, #_int maxlen, #_int attr, #_boolean recurse]
    (reset! did_wait_return false)
    (let-when [a'sb_str (atom (#_Bytes object str)) a'sb_col (atom (int @msg_col))
          [#_int t_col #_Bytes t_s #_Bytes s :as _]
            (loop-when [t_col 0 t_s str s str] (and (or (< maxlen 0) (< (BDIFF s, str) maxlen)) (non-eos? s)) => [t_col t_s s]
                ;; We are at the end of the screen line when: outputting a newline; outputting a character in the last column.
                (let [[t_col s _]
                        (if (and (not recurse)
                                 (<= (dec @Rows) @msg_row)
                                 (or (at? s (byte \newline))
                                     (<= (dec @Cols) (+ @msg_col t_col))
                                     (and (at? s TAB) (<= (& (dec @Cols) (bit-not 7)) (+ @msg_col t_col)))
                                     (and (< 1 (us-ptr2cells s)) (<= (- @Cols 2) (+ @msg_col t_col)))))
                                  ;; output any postponed text
                            (let [t_col (if (< 0 t_col) (t-puts t_col, t_s, s, attr) t_col)]
                                ;; When no more prompt and no more room, truncate here.
                                (if (and @msg_no_more (zero? @lines_left))
                                    [t_col s :break]
                                    (do ;; Scroll the screen up one line.
                                        (msg-scroll-up)
                                        (reset! msg_row (- @Rows 2))
                                        (when (<= @Cols @msg_col)     ;; can happen after screen resize
                                            (reset! msg_col (dec @Cols)))
                                        ;; Display char in last column before showing more-prompt.
                                        (let [[s #_boolean did_last_char]
                                                (if (<= (byte \space) (.at s 0))
                                                    (let [#_int len
                                                            (if (<= 0 maxlen) ;; avoid including composing chars after the end
                                                                (us-ptr2len-cc-len s, (BDIFF (.plus str maxlen), s))
                                                                (us-ptr2len-cc s)
                                                            )]
                                                        [(screen-puts-mbyte s, len, attr) true])
                                                    [s false]
                                                )]
                                            (when @p_more ;; store text for scrolling back
                                                (store-sb-text a'sb_str, s, attr, a'sb_col, true))
                                            (inc-msg-scrolled)
                                            (reset! need_wait_return true)    ;; may need wait-return in main()
                                            (when (< @must_redraw VALID)
                                                (reset! must_redraw VALID))
                                            (reset! redraw_cmdline true)
                                            (when (< 0 @cmdline_row)
                                                (swap! cmdline_row dec))
                                            ;; If screen is completely filled and 'more' is set then wait for a character.
                                            (when (< 0 @lines_left)
                                                (swap! lines_left dec))
                                            (let-when [[s _]
                                                (if (and @p_more (zero? @lines_left) (!= @State HITRETURN) (not @msg_no_more))
                                                    [(if (do-more-prompt NUL) @confirm_msg_tail s) (when @quit_more :return)]
                                                    [s nil]
                                                )] (nil? _) => [t_col s _]
                                                ;; When we displayed a char in last column need to check if there is still more.
                                                [t_col s (when did_last_char :continue)])
                                        ))
                                ))
                            [t_col s nil]
                        )]
                    (condp == _
                        :break [t_col t_s s]
                        :return nil
                        :continue (recur t_col t_s s)
                        (let [#_boolean wrap (or (at? s (byte \newline)) (<= @Cols (+ @msg_col t_col)) (and (< 1 (us-ptr2cells s)) (<= (dec @Cols) (+ @msg_col t_col))))
                              ;; output any postponed text
                              t_col (if (and (< 0 t_col) (or wrap (any == (.at s 0) (byte \return) (byte \backspace) TAB BELL))) (t-puts t_col, t_s, s, attr) t_col)
                              ;; store text for scrolling back
                              _ (when (and wrap @p_more (not recurse))
                                    (store-sb-text a'sb_str, s, attr, a'sb_col, true))
                              [t_col t_s s] (let [_ [t_col t_s (.plus s 1)]]
                                (condp == (.at s 0)
                                    (byte \newline)                                 ;; go to next line
                                        (do (reset! msg_didout false)               ;; remember that line is empty
                                            (reset! msg_col 0)
                                            (when (<= @Rows (swap! msg_row inc))    ;; safety check
                                                (reset! msg_row (dec @Rows)))
                                            _)
                                    (byte \return)                                  ;; go to column 0
                                        (do (reset! msg_col 0)
                                            _)
                                    (byte \backspace)                               ;; go to previous char
                                        (do (when (< 0 @msg_col)
                                                (swap! msg_col dec))
                                            _)
                                    TAB                                             ;; translate Tab into spaces
                                        (do (loop [] (msg-screen-putchar (byte \space), attr) (recur-if (non-zero? (& @msg_col 7)) []))
                                            _)
                                    BELL                                            ;; beep (from ":sh")
                                        (do (vim-beep)
                                            _)
                                    (let [#_int cells (us-ptr2cells s)
                                          #_int len (if (<= 0 maxlen) ;; avoid including composing chars after the end
                                                (us-ptr2len-cc-len s, (BDIFF (.plus str maxlen), s))
                                                (us-ptr2len-cc s)
                                            )]
                                        ;; When a double-wide character doesn't fit, draw a single character here.
                                        ;; Otherwise collect characters and draw them all at once later.
                                        (if (and (< 1 cells) (<= (dec @Cols) (+ @msg_col t_col)))
                                            (let [s (if (< 1 len) (screen-puts-mbyte s, len, attr) (do (msg-screen-putchar (.at s 0), attr) (.plus s 1)))]
                                                [t_col t_s s])
                                            ;; postpone this character until later
                                            (let [t_s (if (zero? t_col) s t_s)]
                                                [(+ t_col cells) t_s (.plus s len)])
                                        ))
                                ))]
                            (recur t_col t_s s)
                        ))
                ))
    ] (some? _)
        ;; output any postponed text
        (when (pos? t_col)
            (t-puts t_col, t_s, s, attr))
        (when (and @p_more (not recurse))
            (store-sb-text a'sb_str, s, attr, a'sb_col, false))
        (msg-check))
    nil)

;; Scroll the screen up one line for displaying the next message line.

(defn- #_void msg-scroll-up []
    (let [rows @Rows cols @Cols]
        ;; scrolling up always works
        (screen-del-lines 0, 0, 1, rows, true, nil)

        (when (not (can-clear (u8 " ")))
            ;; Scrolling up doesn't result in the right background.
            ;; Set the background here.  It's not efficient,
            ;; but avoids that we have to do it all over the code.
            (screen-fill (- rows 1), rows, 0, cols, (byte \space), (byte \space), 0)

            ;; Also clear the last char of the last but one line
            ;; if it was not cleared before to avoid a scroll-up.
            (when (== (... @screenAttrs (+ (... @lineOffset (- rows 2)) (- cols 1))) -1)
                (screen-fill (- rows 2), (- rows 1), (- cols 1), cols, (byte \space), (byte \space), 0))
        ))
    nil)

;; Increment "msg_scrolled".

(defn- #_void inc-msg-scrolled []
    (swap! msg_scrolled inc)
    nil)

;; To be able to scroll back at the "more" and "hit-enter" prompts we need to
;; store the displayed text and remember where screen lines start.

(class! #_final msgchunk_C
    [
        (field msgchunk_C   sb_next)
        (field msgchunk_C   sb_prev)
        (field boolean      sb_eol)         ;; true when line ends after this text
        (field int          sb_msg_col)     ;; column in which text starts
        (field int          sb_attr)        ;; text attributes
        (field Bytes        sb_text)        ;; text to be displayed, actually longer
    ])

(atom! msgchunk_C last_msgchunk)    ;; last displayed text

(atom! boolean do_clear_sb_text)    ;; clear text on next msg

;; Store part of a printed message for displaying when scrolling back.

(defn- #_void store-sb-text [#_Bytes' a'sb_str, #_Bytes s, #_int attr, #_int' a'sb_col, #_boolean finish]
    ;; sb_str: start of string
    ;; s: just after string
    ;; finish: line ends
    (ยง
        (when @do_clear_sb_text
            (clear-sb-text)
            (reset! do_clear_sb_text false)
        )

        (cond (BLT @a'sb_str, s)
        (do
            ((ร msgchunk_C mp =) (NEW_msgchunk_C))

            ((ร mp =) (assoc mp :sb_eol finish))
            ((ร mp =) (assoc mp :sb_msg_col @a'sb_col))
            ((ร mp =) (assoc mp :sb_attr attr))
            ((ร mp =) (assoc mp :sb_text (STRNDUP @a'sb_str, (BDIFF s, @a'sb_str))))

            (cond (nil? @last_msgchunk)
            (do
                (reset! last_msgchunk mp)
                ((ร mp =) (assoc mp :sb_prev nil))
            )
            :else
            (do
                ((ร mp =) (assoc mp :sb_prev @last_msgchunk))
                (swap! last_msgchunk assoc :sb_next mp)
                (reset! last_msgchunk mp)
            ))
            ((ร mp =) (assoc mp :sb_next nil))
        )
        (and finish (some? @last_msgchunk))
        (do
            (swap! last_msgchunk assoc :sb_eol true)
        ))

        (reset! a'sb_str s)
        (reset! a'sb_col 0)
        nil
    ))

;; Finished showing messages, clear the scroll-back text on the next message.

(defn- #_void may-clear-sb-text []
    (reset! do_clear_sb_text true)
    nil)

;; Clear any text remembered for scrolling back.
;; Called when redrawing the screen.

(defn- #_void clear-sb-text []
    (reset! last_msgchunk nil)
    nil)

;; "g<" command.

(defn- #_window_C show-sb-text [#_window_C win]
    ;; Only show something if there is more than one line, otherwise it looks weird.
    ;; Typing a command without output results in one line.
    (let-when [#_msgchunk_C mp (msg-sb-start @last_msgchunk)] (and (some? mp) (some? (:sb_prev mp))) => (do (vim-beep) win)
        (do-more-prompt (byte \G))
        (wait-return win, FALSE)
    ))

;; Move to the start of screen line in already displayed text.

(defn- #_msgchunk_C msg-sb-start [#_msgchunk_C mp]
    (loop-when-recur mp (and (some? mp) (some? (:sb_prev mp)) (not (:sb_eol (:sb_prev mp)))) (:sb_prev mp) => mp))

;; Display a screen line from previously displayed text at row "row".
;; Returns a pointer to the text for the next line (can be null).

(defn- #_msgchunk_C disp-sb-line [#_int row, #_msgchunk_C mp]
    (loop [mp mp]
        (reset! msg_row row)
        (reset! msg_col (:sb_msg_col mp))
        (let [#_Bytes p (:sb_text mp) p (if (at? p (byte \newline)) (.plus p 1) p)] ;; don't display the line break
            (msg-puts-display p, -1, (:sb_attr mp), true))
        (recur-if (and (not (:sb_eol mp)) (some? (:sb_next mp))) (:sb_next mp) => (:sb_next mp))
    ))

;; Output any postponed text for msg-puts-attr-len().

(defn- #_int t-puts [#_int t_col, #_Bytes t_s, #_Bytes s, #_int attr]
    (reset! msg_didout true)          ;; remember that line is not empty
    (screen-puts-len t_s, (BDIFF s, t_s), @msg_row, @msg_col, attr)
    ;; If the string starts with a composing character, don't increment the column position for it.
    (let [n (if (utf-iscomposing (us-ptr2char t_s)) (dec t_col) t_col)]
        (swap! msg_col + n))
    (when (<= @Cols @msg_col)
        (reset! msg_col 0)
        (swap! msg_row inc))
    0)

;; Returns true when messages should be printed with mch_errmsg().
;; This is used when there is no valid screen, so we can see error messages.
;; If termcap is not active, we may be writing in an alternate console window,
;; cursor positioning may not work correctly (window size may be different)
;; or we just don't know where the cursor is.

(defn- #_boolean msg-use-printf []
    (or (not (msg-check-screen)) (and (swapping-screen) (not @termcap_active))))

;; Print a message when there is no valid screen.

(defn- #_void msg-puts-printf [#_Bytes s, #_int maxlen]
    (let [#_Bytes buf (Bytes. 3)]
        (loop-when-recur [#_int i 0] (and (non-eos? s i) (or (< maxlen 0) (< i maxlen))) [(inc i)]
            (let [#_int n 0 ;; NL --> CR NL translation (for Unix, not for "--version")
                  n (if (and (at? s i (byte \newline)) (not @info_message)) (do (.be buf n, (byte \return)) (inc n)) n)]
                (-> buf (.be n, (.at s i)) (eos! (inc n)))
;%%             (if @info_message   ;; informative message, not an error
;%%                 (.fprintf libC stdout, (u8 "%s"), buf)
;%%                 (.fprintf libC stderr, (u8 "%s"), buf))
                ;; primitive way to compute the current column
                (if (or (at? s i (byte \return)) (at? s i (byte \newline)))
                    (reset! msg_col 0)
                    (swap! msg_col inc))
            )))
    (reset! msg_didout true)      ;; assume that line is not empty
    nil)

;; Show the more-prompt and handle the user response.
;; This takes care of scrolling back and displaying previously displayed text.
;; When at hit-enter prompt, "typed_char" is the already typed character, otherwise it's NUL.
;; Returns true when jumping ahead to "confirm_msg_tail".

(defn- #_boolean do-more-prompt [#_int typed_char] ;; was typed at hit-enter prompt
    (let [#_msgchunk_C lm
            (when (== typed_char (byte \G)) ;; "g<": Find first line on the last page.
                (loop-when-recur [#_int i 0 lm (msg-sb-start @last_msgchunk)]
                                 (and (< i (- @Rows 2)) (some? lm) (some? (:sb_prev lm)))
                                 [(inc i) (msg-sb-start (:sb_prev lm))]
                              => lm))
          #_int state' @State _ (reset! State ASKMORE)
          _ (when (== typed_char NUL) (msg-moremsg false))
          #_boolean ask?
            (loop [#_int tc typed_char lm lm ask? false]
                ;; Get a typed character directly from the user.
                (let-when [#_int c (if (!= tc NUL) tc (get-keystroke)) tc NUL
                      esc- (fn [ask?]
                        (let [ask? (or (non-zero? @confirm_msg_used) ;; Jump to the choices of the dialog.
                                       (do (reset! got_int true)
                                           (reset! quit_more true)
                                           ask?)
                                   )]
                            ;; When there is some more output (wrapping line), display that without another prompt.
                            (reset! lines_left (dec @Rows))
                            [0 ask?]
                        ))
                      [#_int sl ask? :as _]
                        (condp ==? c
                           [BS K_BS (byte \k) K_UP] [-1 ask?]               ;; scroll one line back
                           [CAR NL (byte \j) K_DOWN] [1 ask?]               ;; one extra line

                            (byte \u) [(- (/ @Rows 2)) ask?]                ;; up half a page
                            (byte \d) [   (/ @Rows 2)  ask?]                ;; down half a page

                           [              (byte \b) K_PAGEUP  ] [(- (dec @Rows)) ask?]  ;; one page back
                           [(byte \space) (byte \f) K_PAGEDOWN] [   (dec @Rows)  ask?]  ;; one extra page

                            (byte \g) [                  -999999  ask?]     ;; all the way back to the start
                            (byte \G) [(reset! lines_left 999999) ask?]     ;; all the way to the end

                            (byte \:)                                       ;; start new command line
                                (do (when (zero? @confirm_msg_used)
                                        ;; Since got_int is set all typeahead will be flushed, but
                                        ;; we want to keep this ':', remember that in a special way.
                                        (typeahead-noflush (byte \:))
                                        (reset! cmdline_row (dec @Rows))    ;; put ':' on this line
                                        (reset! skip_redraw true)           ;; skip redraw once
                                        (reset! need_wait_return false))    ;; don't wait in main()
                                    (esc- ask?))

                           [(byte \q) Ctrl_C ESC] (esc- ask?)               ;; quit

                            ;; Strange way to allow copying (yanking) a modeless selection at the more prompt.
                            ;; Use CTRL-Y, because the same is used in Cmdline-mode and at the hit-enter prompt.
                            ;; However, scrolling one line up might be expected...
                            Ctrl_Y
                                nil	;; %% not yet

                            (do (msg-moremsg true) ;; no valid response
                                nil))

                ] (some? _) => (recur tc lm ask?)

                    (if (zero? sl)
                        ask?
                        (let [[lm sl]
                                (cond (< sl 0) ;; go to start of last line ;; go to start of line at top of the screen
                                    (let-when [#_msgchunk_C m (cond (nil? lm) (msg-sb-start @last_msgchunk) (some? (:sb_prev lm)) (msg-sb-start (:sb_prev lm)))
                                               m (loop-when-recur [#_int i 0 m m]
                                                                   (and (< i (- @Rows 2)) (some? m) (some? (:sb_prev m)))
                                                                   [(inc i) (msg-sb-start (:sb_prev m))]
                                                                => m)
                                    ] (and (some? m) (some? (:sb_prev m))) => [lm sl]
                                        (let [[m lm] ;; Find line to be displayed at top.
                                                (loop-when [#_int i 0 m m lm lm] (and (< sl i) (some? m) (some? (:sb_prev m))) => [m lm]
                                                    (recur (dec i) (msg-sb-start (:sb_prev m)) (msg-sb-start (if (nil? lm) @last_msgchunk (:sb_prev lm))))
                                                )]
                                            (if (and (== sl -1) (screen-ins-lines 0, 0, 1, @Rows, nil))
                                                (disp-sb-line 0, m) ;; display line at top
                                                (do (screen-clear) ;; redisplay all lines
                                                    (loop-when [#_int i 0 m m] (and (some? m) (< i (dec @Rows)))
                                                        (let [m (disp-sb-line i, m)] (swap! msg_scrolled inc) (recur (inc i) m)))
                                                ))
                                            [lm 0]))
                                :else
                                    ;; First display any text that we scrolled back.
                                    (loop-when [lm lm sl sl] (and (< 0 sl) (some? lm)) => [lm sl]
                                        (msg-scroll-up) ;; scroll up, display line at bottom
                                        (inc-msg-scrolled)
                                        (screen-fill (- @Rows 2), (dec @Rows), 0, @Cols, (byte \space), (byte \space), 0)
                                        (recur (disp-sb-line (- @Rows 2), lm) (dec sl)))
                                )]
                            (if (<= sl 0)
                                (do ;; displayed the requested text, more prompt again
                                    (screen-fill (dec @Rows), @Rows, 0, @Cols, (byte \space), (byte \space), 0)
                                    (msg-moremsg false)
                                    (recur tc lm ask?))
                                (do (reset! lines_left sl)
                                    ask?)
                            ))
                    ))
            )]
        ;; clear the --more-- message
        (screen-fill (dec @Rows), @Rows, 0, @Cols, (byte \space), (byte \space), 0)
        (reset! State state')
        (when @quit_more
            (reset! msg_row (dec @Rows))
            (reset! msg_col 0))
        ask?
    ))

;; Put a character on the screen at the current message position and advance to the next position.
;; Only for printable ASCII!

(defn- #_void msg-screen-putchar [#_int c, #_int attr]
    (reset! msg_didout true)          ;; remember that line is not empty
    (screen-putchar c, @msg_row, @msg_col, attr)
    (when (<= @Cols (swap! msg_col inc))
        (reset! msg_col 0)
        (swap! msg_row inc))
    nil)

(defn- #_void msg-moremsg [#_boolean full]
    (let [#_Bytes more (u8 "-- More --") #_int attr (hl-attr HLF_M)]
        (screen-puts more, (dec @Rows), 0, attr)
        (when full
            (screen-puts (u8 " SPACE/d/j: screen/page/line down, b/u/k: up, q: quit "), (dec @Rows), (mb-string2cells more), attr)))
    nil)

;; Repeat the message for the current mode: ASKMORE or CONFIRM.

(defn- #_void repeat-message []
    (cond (== @State ASKMORE)
    (do
        (msg-moremsg true)      ;; display --more-- message again
        (reset! msg_row (dec @Rows))
    )
    (== @State CONFIRM)
    (do
        (display-confirm-msg)  ;; display ":confirm" message again
        (reset! msg_row (dec @Rows))
    )
    (any == @State HITRETURN SETWSIZE)
    (do
        (when (== @msg_row (dec @Rows))
            ;; Avoid drawing the "hit-enter" prompt below the previous one,
            ;; overwrite it.  Esp. useful when regaining focus and a
            ;; FocusGained autocmd exists but didn't draw anything.
            (reset! msg_didout false)
            (reset! msg_col 0)
            (msg-clr-eos)
        )
        (hit-return-msg)
        (reset! msg_row (dec @Rows))
    ))
    nil)

;; msg-check-screen - check if the screen is initialized.
;; Also check msg_row and msg_col, if they are too big it may cause a crash.
;; While starting the GUI the terminal codes will be set for the GUI, but the
;; output goes to the terminal.  Don't use the terminal codes then.

(defn- #_boolean msg-check-screen []
    (if (and @full_screen (screen-valid false))
        (do
            (swap! msg_row min (dec @Rows))
            (swap! msg_col min (dec @Cols))
            true
        )
        false
    ))

;; Clear from current message position to end of screen.
;; Skip this when ":silent" was used, no need to clear for redirection.

(defn- #_void msg-clr-eos []
    (msg-clr-eos-force)
    nil)

;; Clear from current message position to end of screen.
;; Note: msg_col is not updated, so we remember the end of the message for msg-check().

(defn- #_void msg-clr-eos-force []
    (cond (msg-use-printf)
    (do
        (when @full_screen        ;; only when termcap codes are valid
            (cond
                (non-eos? @T_CD) (out-str @T_CD)  ;; clear to end of display
                (non-eos? @T_CE) (out-str @T_CE)  ;; clear to end of line
            )
        )
    )
    :else
    (do
        (screen-fill @msg_row, (inc @msg_row), @msg_col, @Cols, (byte \space), (byte \space), 0)
        (screen-fill (inc @msg_row), @Rows, 0, @Cols, (byte \space), (byte \space), 0)
    ))
    nil)

;; Clear the command line.

(defn- #_void msg-clr-cmdline []
    (reset! msg_row @cmdline_row)
    (reset! msg_col 0)
    (msg-clr-eos-force)
    nil)

;; End putting a message on the screen.
;; Call wait-return if the message does not fit in the available space.
;; Return true if wait-return not called.

(defn- #_boolean msg-end []
    ;; If the string is larger than the window, or the ruler option is set and we run into it, we have to redraw the window.
    ;; Do not do this if we are abandoning the file or editing the command line.
    (if (and (not @exiting) @need_wait_return (non-flag? @State CMDLINE))
        (do (swap! curwin wait-return FALSE) false)
        (do (out-flush) true)
    ))

;; If the written message runs into the shown command or ruler, we have to wait for hit-return and redraw the window later.

(defn- #_void msg-check []
    (when (and (== @msg_row (dec @Rows)) (<= @sc_col @msg_col))
        (reset! need_wait_return true)
        (reset! redraw_cmdline true))
    nil)

;; Give a warning message (for searching).
;; Use 'w' highlighting and may repeat the message after redrawing

(defn- #_void give-warning [#_Bytes message, #_boolean hl]
    ;; Don't want a hit-enter prompt here.
    (swap! no_wait_return inc)

    (reset! keep_msg nil)
    (reset! keep_msg_attr (if hl (hl-attr HLF_W) 0))
    (when (and (msg-attr message, @keep_msg_attr) (zero? @msg_scrolled))
        (set-keep-msg message, @keep_msg_attr))
    (reset! msg_didout false)     ;; overwrite this message
    (reset! msg_nowait true)      ;; don't wait for this message
    (reset! msg_col 0)

    (swap! no_wait_return dec)
    nil)

;; Display the ":confirm" message.  Also called when screen resized.

(defn- #_void display-confirm-msg []
    ;; avoid that 'q' at the more prompt truncates the message here
    (swap! confirm_msg_used inc)
    (when (some? @confirm_msg)
        (msg-puts-attr @confirm_msg, (hl-attr HLF_M)))
    (swap! confirm_msg_used dec)
    nil)

;; Code to handle user-settable options.  This is all pretty much table-
;; driven.  Checklist for adding a new option:
;; - Put it in the options array below (copy an existing entry).
;; - For a global option: Add a variable for it in option.h.
;; - For a buffer or window local option:
;;   - Add a PV_XX entry to the enum below.
;;   - Add a variable to the window or buffer struct in structs.h.
;;   - For a window option, add some code to copy-winopt().
;; - If it's a numeric option, add any necessary bounds checks to do-set().
;; - If it's a list of flags, add some code in do-set(), search for WW_ALL.
;; When making changes:
;; - When an entry has the P_VIM flag, or is lacking the P_VI_DEF flag,
;;   add a comment at the help for the 'compatible' option.

;; The options that are local to a window or buffer have "indir" set to
;; one of these values.  Special values:
;; 0: global option.
;; PV_WIN is added: window-local option.
;; PV_BUF is added: buffer-local option.

(final int
    PV_WIN  0x2000,
    PV_BUF  0x4000)

;; Definition of the PV_ values for buffer-local options.
;; The BV_ values are defined in option.h.

(final int
    PV_AI   (| BV_AI   PV_BUF),
    PV_CI   (| BV_CI   PV_BUF),
    PV_CINW (| BV_CINW PV_BUF),
    PV_ET   (| BV_ET   PV_BUF),
    PV_ISK  (| BV_ISK  PV_BUF),
    PV_KP   (| BV_KP   PV_BUF),
    PV_MOD  (| BV_MOD  PV_BUF),
    PV_MPS  (| BV_MPS  PV_BUF),
    PV_NF   (| BV_NF   PV_BUF),
    PV_PI   (| BV_PI   PV_BUF),
    PV_QE   (| BV_QE   PV_BUF),
    PV_SI   (| BV_SI   PV_BUF),
    PV_STS  (| BV_STS  PV_BUF),
    PV_SW   (| BV_SW   PV_BUF),
    PV_TS   (| BV_TS   PV_BUF),
    PV_UL   (| BV_UL   PV_BUF))

;; Definition of the PV_ values for window-local options.
;; The WV_ values are defined in option.h.

(final int
    PV_COCU   (| WV_COCU   PV_WIN),
    PV_COLE   (| WV_COLE   PV_WIN),
    PV_CRBIND (| WV_CRBIND PV_WIN),
    PV_BRI    (| WV_BRI    PV_WIN),
    PV_BRIOPT (| WV_BRIOPT PV_WIN),
    PV_LBR    (| WV_LBR    PV_WIN),
    PV_NU     (| WV_NU     PV_WIN),
    PV_RNU    (| WV_RNU    PV_WIN),
    PV_NUW    (| WV_NUW    PV_WIN),
    PV_SCBIND (| WV_SCBIND PV_WIN),
    PV_SCROLL (| WV_SCROLL PV_WIN),
    PV_CUC    (| WV_CUC    PV_WIN),
    PV_CUL    (| WV_CUL    PV_WIN),
    PV_CC     (| WV_CC     PV_WIN),
    PV_WFH    (| WV_WFH    PV_WIN),
    PV_WFW    (| WV_WFW    PV_WIN),
    PV_WRAP   (| WV_WRAP   PV_WIN))

(class! #_final vimoption_C
    [
        (field Bytes    fullname)   ;; full option name
        (field Bytes    shortname)  ;; permissible abbreviation
        (field long     flags)      ;; see below
        (field Object   var)        ;; pointer to variable
        (field int      indir)      ;; indirect option index
        (field Object   def_val)    ;; default value for variable
    ])

;; Flags

(final int P_BOOL               0x01)   ;; the option is boolean
(final int P_NUM                0x02)   ;; the option is numeric
(final int P_STRING             0x04)   ;; the option is a string

                                        ;; when option changed, what to display:
(final int P_RSTAT            0x1000)   ;; redraw status lines
(final int P_RWIN             0x2000)   ;; redraw current window
(final int P_RBUF             0x4000)   ;; redraw current buffer
(final int P_RALL             0x6000)   ;; redraw all windows
(final int P_RCLR             0x7000)   ;; clear and redraw all

(final int P_COMMA            0x8000)   ;; comma separated list
(final int P_NODUP           0x10000)   ;; don't allow duplicate strings
(final int P_FLAGLIST        0x20000)   ;; list of single-char flags

(final int P_CURSWANT      0x2000000)   ;; update curswant required; not needed when there is a redraw flag

(final Bytes HIGHLIGHT_INIT (u8 "8:SpecialKey,@:NonText,e:ErrorMsg,i:IncSearch,l:Search,m:MoreMsg,M:ModeMsg,n:LineNr,N:CursorLineNr,r:Question,s:StatusLine,S:StatusLineNC,c:VertSplit,t:Title,v:Visual,w:WarningMsg,-:Conceal,!:CursorColumn,.:CursorLine,o:ColorColumn"))

(defn- #_vimoption_C bool-opt [#_Bytes fname, #_Bytes sname, #_long flags, #_"/*boolean[]*/Object" var, #_int indir, #_boolean def]
    (->vimoption_C fname, sname, (| P_BOOL flags), var, indir, def))

(defn- #_vimoption_C long-opt [#_Bytes fname, #_Bytes sname, #_long flags, #_"/*long[]*/Object" var, #_int indir, #_long def]
    (->vimoption_C fname, sname, (| P_NUM flags), var, indir, def))

(defn- #_vimoption_C utf8-opt [#_Bytes fname, #_Bytes sname, #_long flags, #_"/*Bytes[]*/Object" var, #_int indir, #_Bytes def]
    (->vimoption_C fname, sname, (| P_STRING flags), var, indir, def))

;; vimoptions[] are initialized here.
;;
;; The order of the options MUST be alphabetic for ":set all" and findoption().
;; All option names MUST start with a lowercase letter (for findoption()).

(final vimoption_C* vimoptions
    [
        (bool-opt (u8 "autoindent"),     (u8 "ai"),        0,                           nil,         PV_AI,      false),
        (utf8-opt (u8 "backspace"),      (u8 "bs"),     (| P_COMMA P_NODUP),            p_bs,        0,         (u8 "")),
        (utf8-opt (u8 "breakat"),        (u8 "brk"),    (| P_RALL P_FLAGLIST),          p_breakat,   0,         (u8 " \t!@*-+;:,./?")),
        (bool-opt (u8 "breakindent"),    (u8 "bri"),       P_RWIN,                      nil,         PV_BRI,     false),
        (utf8-opt (u8 "breakindentopt"), (u8 "briopt"), (| P_RBUF P_COMMA P_NODUP),     nil,         PV_BRIOPT, (u8 "")),
        (utf8-opt (u8 "cinwords"),       (u8 "cinw"),   (| P_COMMA P_NODUP),            nil,         PV_CINW,   (u8 "if,else,while,do,for,switch")),
        (long-opt (u8 "cmdheight"),      (u8 "ch"),        P_RALL,                      p_ch,        0,          1),
        (long-opt (u8 "cmdwinheight"),   (u8 "cwh"),       0,                           p_cwh,       0,          7),
        (utf8-opt (u8 "colorcolumn"),    (u8 "cc"),     (| P_COMMA P_NODUP P_RWIN),     nil,         PV_CC,     (u8 "")),
        (utf8-opt (u8 "concealcursor"),  (u8 "cocu"),      P_RWIN,                      nil,         PV_COCU,   (u8 "")),
        (long-opt (u8 "conceallevel"),   (u8 "cole"),      P_RWIN,                      nil,         PV_COLE,    0),
        (bool-opt (u8 "copyindent"),     (u8 "ci"),        0,                           nil,         PV_CI,      false),
        (utf8-opt (u8 "cpoptions"),      (u8 "cpo"),    (| P_RALL P_FLAGLIST),          p_cpo,       0,          CPO_VIM),
        (bool-opt (u8 "cursorbind"),     (u8 "crb"),       0,                           nil,         PV_CRBIND,  false),
        (bool-opt (u8 "cursorcolumn"),   (u8 "cuc"),       P_RWIN,                      nil,         PV_CUC,     false),
        (bool-opt (u8 "cursorline"),     (u8 "cul"),       P_RWIN,                      nil,         PV_CUL,     false),
        (bool-opt (u8 "delcombine"),     (u8 "deco"),      0,                           p_deco,      0,          false),
        (bool-opt (u8 "digraph"),        (u8 "dg"),        0,                           p_dg,        0,          false),
        (utf8-opt (u8 "display"),        (u8 "dy"),     (| P_COMMA P_RALL P_NODUP),     p_dy,        0,         (u8 "")),
        (utf8-opt (u8 "eadirection"),    (u8 "ead"),       0,                           p_ead,       0,         (u8 "both")),
        (bool-opt (u8 "equalalways"),    (u8 "ea"),        P_RALL,                      p_ea,        0,          true),
        (bool-opt (u8 "errorbells"),     (u8 "eb"),        0,                           p_eb,        0,          false),
        (bool-opt (u8 "esckeys"),        (u8 "ek"),        0,                           p_ek,        0,          true),
        (bool-opt (u8 "expandtab"),      (u8 "et"),        0,                           nil,         PV_ET,      false),
        (bool-opt (u8 "gdefault"),       (u8 "gd"),        0,                           p_gd,        0,          false),
        (utf8-opt (u8 "highlight"),      (u8 "hl"),     (| P_RCLR P_COMMA P_NODUP),     p_hl,        0,          HIGHLIGHT_INIT),
        (long-opt (u8 "history"),        (u8 "hi"),        0,                           p_hi,        0,          50),
        (bool-opt (u8 "hlsearch"),       (u8 "hls"),       P_RALL,                      p_hls,       0,          false),
        (bool-opt (u8 "ignorecase"),     (u8 "ic"),        0,                           p_ic,        0,          false),
        (bool-opt (u8 "incsearch"),      (u8 "is"),        0,                           p_is,        0,          false),
        (bool-opt (u8 "insertmode"),     (u8 "im"),        0,                           p_im,        0,          false),
        (utf8-opt (u8 "isfname"),        (u8 "isf"),    (| P_COMMA P_NODUP),            p_isf,       0,         (u8 "@,48-57,/,.,-,_,+,,,#,$,%,~,=")),
        (utf8-opt (u8 "isident"),        (u8 "isi"),    (| P_COMMA P_NODUP),            p_isi,       0,         (u8 "@,48-57,_,192-255")),
        (utf8-opt (u8 "iskeyword"),      (u8 "isk"),    (| P_COMMA P_NODUP),            nil,         PV_ISK,    (u8 "@,48-57,_,192-255")),
        (utf8-opt (u8 "isprint"),        (u8 "isp"),    (| P_RALL P_COMMA P_NODUP),     p_isp,       0,         (u8 "@,161-255")),
        (bool-opt (u8 "joinspaces"),     (u8 "js"),        0,                           p_js,        0,          true),
        (utf8-opt (u8 "keymodel"),       (u8 "km"),     (| P_COMMA P_NODUP),            p_km,        0,         (u8 "")),
        (utf8-opt (u8 "keywordprg"),     (u8 "kp"),        0,                           nil,         PV_KP,     (u8 ":echo")),
        (long-opt (u8 "laststatus"),     (u8 "ls"),        P_RALL,                      p_ls,        0,          1),
        (bool-opt (u8 "lazyredraw"),     (u8 "lz"),        0,                           p_lz,        0,          false),
        (bool-opt (u8 "linebreak"),      (u8 "lbr"),       P_RWIN,                      nil,         PV_LBR,     false),
        (bool-opt (u8 "magic"),           nil,             0,                           p_magic,     0,          true),
        (utf8-opt (u8 "matchpairs"),     (u8 "mps"),    (| P_COMMA P_NODUP),            nil,         PV_MPS,    (u8 "(:),{:},[:]")),
        (long-opt (u8 "matchtime"),      (u8 "mat"),       0,                           p_mat,       0,          5),
        (long-opt (u8 "maxcombine"),     (u8 "mco"),       P_CURSWANT,                  p_mco,       0,          2),
        (long-opt (u8 "maxmempattern"),  (u8 "mmp"),       0,                           p_mmp,       0,          1000),
        (bool-opt (u8 "modified"),       (u8 "mod"),       P_RSTAT,                     nil,         PV_MOD,     false),
        (bool-opt (u8 "more"),            nil,             0,                           p_more,      0,          true),
        (utf8-opt (u8 "nrformats"),      (u8 "nf"),     (| P_COMMA P_NODUP),            nil,         PV_NF,     (u8 "octal,hex")),
        (bool-opt (u8 "number"),         (u8 "nu"),        P_RWIN,                      nil,         PV_NU,      false),
        (long-opt (u8 "numberwidth"),    (u8 "nuw"),       P_RWIN,                      nil,         PV_NUW,     4),
        (utf8-opt (u8 "operatorfunc"),   (u8 "opfunc"),    0,                           p_opfunc,    0,         (u8 "")),
        (bool-opt (u8 "paste"),           nil,             0,                           p_paste,     0,          false),
        (bool-opt (u8 "preserveindent"), (u8 "pi"),        0,                           nil,         PV_PI,      false),
        (bool-opt (u8 "prompt"),          nil,             0,                           p_prompt,    0,          true),
        (utf8-opt (u8 "quoteescape"),    (u8 "qe"),        0,                           nil,         PV_QE,     (u8 "\\")),
        (long-opt (u8 "redrawtime"),     (u8 "rdt"),       0,                           p_rdt,       0,          2000),
        (long-opt (u8 "regexpengine"),   (u8 "re"),        0,                           p_re,        0,          0),
        (bool-opt (u8 "relativenumber"), (u8 "rnu"),       P_RWIN,                      nil,         PV_RNU,     false),
        (long-opt (u8 "report"),          nil,             0,                           p_report,    0,          2),
        (bool-opt (u8 "ruler"),          (u8 "ru"),        P_RSTAT,                     p_ru,        0,          false),
        (long-opt (u8 "scroll"),         (u8 "scr"),       0,                           nil,         PV_SCROLL,  1),
        (bool-opt (u8 "scrollbind"),     (u8 "scb"),       0,                           nil,         PV_SCBIND,  false),
        (long-opt (u8 "scrolljump"),     (u8 "sj"),        0,                           p_sj,        0,          1),
        (long-opt (u8 "scrolloff"),      (u8 "so"),        P_RALL,                      p_so,        0,          0),
        (utf8-opt (u8 "scrollopt"),      (u8 "sbo"),    (| P_COMMA P_NODUP),            p_sbo,       0,         (u8 "ver,jump")),
        (utf8-opt (u8 "selection"),      (u8 "sel"),       0,                           p_sel,       0,         (u8 "inclusive")),
        (utf8-opt (u8 "selectmode"),     (u8 "slm"),    (| P_COMMA P_NODUP),            p_slm,       0,         (u8 "")),
        (bool-opt (u8 "shiftround"),     (u8 "sr"),        0,                           p_sr,        0,          false),
        (long-opt (u8 "shiftwidth"),     (u8 "sw"),        0,                           nil,         PV_SW,      8),
        (utf8-opt (u8 "showbreak"),      (u8 "sbr"),       P_RALL,                      p_sbr,       0,         (u8 "")),
        (bool-opt (u8 "showcmd"),        (u8 "sc"),        0,                           p_sc,        0,          false),
        (bool-opt (u8 "showmatch"),      (u8 "sm"),        0,                           p_sm,        0,          false),
        (bool-opt (u8 "showmode"),       (u8 "smd"),       0,                           p_smd,       0,          true),
        (long-opt (u8 "sidescroll"),     (u8 "ss"),        0,                           p_ss,        0,          0),
        (long-opt (u8 "sidescrolloff"),  (u8 "siso"),      P_RBUF,                      p_siso,      0,          0),
        (bool-opt (u8 "smartcase"),      (u8 "scs"),       0,                           p_scs,       0,          false),
        (bool-opt (u8 "smartindent"),    (u8 "si"),        0,                           nil,         PV_SI,      false),
        (bool-opt (u8 "smarttab"),       (u8 "sta"),       0,                           p_sta,       0,          false),
        (long-opt (u8 "softtabstop"),    (u8 "sts"),       0,                           nil,         PV_STS,     0),
        (bool-opt (u8 "splitbelow"),     (u8 "sb"),        0,                           p_sb,        0,          false),
        (bool-opt (u8 "splitright"),     (u8 "spr"),       0,                           p_spr,       0,          false),
        (bool-opt (u8 "startofline"),    (u8 "sol"),       0,                           p_sol,       0,          true),
        (long-opt (u8 "tabstop"),        (u8 "ts"),        P_RBUF,                      nil,         PV_TS,      8),
        (bool-opt (u8 "tildeop"),        (u8 "top"),       0,                           p_to,        0,          false),
        (bool-opt (u8 "timeout"),        (u8 "to"),        0,                           p_timeout,   0,          true),
        (long-opt (u8 "timeoutlen"),     (u8 "tm"),        0,                           p_tm,        0,          1000),
        (bool-opt (u8 "ttimeout"),        nil,             0,                           p_ttimeout,  0,          false),
        (long-opt (u8 "ttimeoutlen"),    (u8 "ttm"),       0,                           p_ttm,       0,          -1),
        (long-opt (u8 "ttyscroll"),      (u8 "tsl"),       0,                           p_ttyscroll, 0,          999),
        (long-opt (u8 "undolevels"),     (u8 "ul"),        0,                           nil,         PV_UL,      1000),
        (long-opt (u8 "updatetime"),     (u8 "ut"),        0,                           p_ut,        0,          4000),
        (long-opt (u8 "verbose"),        (u8 "vbs"),       0,                           p_verbose,   0,          0),
        (utf8-opt (u8 "virtualedit"),    (u8 "ve"),     (| P_COMMA P_NODUP P_CURSWANT), p_ve,        0,         (u8 "")),
        (bool-opt (u8 "visualbell"),     (u8 "vb"),        0,                           p_vb,        0,          false),
        (utf8-opt (u8 "whichwrap"),      (u8 "ww"),     (| P_COMMA P_FLAGLIST),         p_ww,        0,         (u8 "b,s")),
        (long-opt (u8 "winheight"),      (u8 "wh"),        0,                           p_wh,        0,          1),
        (bool-opt (u8 "winfixheight"),   (u8 "wfh"),       P_RSTAT,                     nil,         PV_WFH,     false),
        (bool-opt (u8 "winfixwidth"),    (u8 "wfw"),       P_RSTAT,                     nil,         PV_WFW,     false),
        (long-opt (u8 "winminheight"),   (u8 "wmh"),       0,                           p_wmh,       0,          1),
        (long-opt (u8 "winminwidth"),    (u8 "wmw"),       0,                           p_wmw,       0,          1),
        (long-opt (u8 "winwidth"),       (u8 "wiw"),       0,                           p_wiw,       0,          20),
        (bool-opt (u8 "wrap"),            nil,             P_RWIN,                      nil,         PV_WRAP,    true),
        (bool-opt (u8 "wrapscan"),       (u8 "ws"),        0,                           p_ws,        0,          true),
        (long-opt (u8 "writedelay"),     (u8 "wd"),        0,                           p_wd,        0,          0),
    ])

(final Bytes*
    p_nf_values     [ (u8 "octal"), (u8 "hex"), (u8 "alpha"), nil ],
    p_sel_values    [ (u8 "inclusive"), (u8 "exclusive"), (u8 "old"), nil ],
    p_slm_values    [ (u8 "key"), (u8 "cmd"), nil ],
    p_km_values     [ (u8 "startsel"), (u8 "stopsel"), nil ],
    p_scbopt_values [ (u8 "ver"), (u8 "hor"), (u8 "jump"), nil ],
    p_ead_values    [ (u8 "both"), (u8 "ver"), (u8 "hor"), nil ],
    p_bs_values     [ (u8 "indent"), (u8 "eol"), (u8 "start"), nil ])

;; Initialize the options, first part.
;;
;; Called only once from main(), just after creating the first buffer.

(defn- #_void set-init-1 []
    ;; Set all the options (except the terminal options) to their default value.
    ;; Also set the global value for local options.

    (set-options-default)
    (didset-options)

    (fill-breakat-flags)
    (highlight-changed)
    (init-chartab true)
    (screen-alloc false)
    nil)

;; Set an option to its default value.
;; This does not take care of side effects!

(defn- #_void set-option-default [#_vimoption_C v]
    (let [#_Object' varp (get-varp v)]
        (cond
            (flag? (:flags v) P_STRING)                                                      (reset! varp (STRDUP (#_Bytes object (:def_val v))))
            (flag? (:flags v) P_NUM) (if (== (:indir v) PV_SCROLL) (win-comp-scroll @curwin) (reset! varp (long (:def_val v))))
            (flag? (:flags v) P_BOOL)                                                        (reset! varp (boolean (:def_val v)))
        ))
    nil)

;; Set all options (except terminal options) to their default value.

(defn- #_void set-options-default []
    (doseq [#_vimoption_C v vimoptions]
        (set-option-default v))
    ;; The 'scroll' option must be computed for all windows.
    (loop-when-recur [#_window_C win @firstwin] (some? win) [(:w_next win)]
        (win-comp-scroll win))
    nil)

;; Initialize the options, part two: After getting Rows and Cols and setting 'term'.

(defn- #_void set-init-2 [#_window_C win]
    (win-comp-scroll win)
    (comp-col)
    nil)

;; Parse 'arg' for option settings.
;;
;; returns false if an error is detected, true otherwise

(defn- #_boolean do-set [#_Bytes arg]
    ;; arg: option string (may be written to!)
    (ยง
        ((ร boolean did_show =) false)           ;; already showed one value

        (loop-when-recur arg (non-eos? arg) (skipwhite arg) => true             ;; loop to process all options
            ((ร Bytes errmsg =) nil)
            ((ร Bytes startarg =) arg)      ;; remember for error message

            ((ร int prefix =) 1)     ;; 1: nothing, 0: "no", 2: "inv" in front of name
            (cond (and (zero? (STRNCMP arg, (u8 "no"), 2)) (non-zero? (STRNCMP arg, (u8 "novice"), 6)))
            (do
                ((ร prefix =) 0)
                ((ร arg =) (.plus arg 2))
            )
            (zero? (STRNCMP arg, (u8 "inv"), 3))
            (do
                ((ร prefix =) 2)
                ((ร arg =) (.plus arg 3))
            ))

;           skip:
;           {
                (when (at? arg (byte \<))
                    ((ร errmsg =) e_invarg)
                    (ร BREAK skip)
                )

                (ร int nextchar)           ;; next non-white char after option name

                ;; find end of name
                ((ร int len =) 0)
                (loop-when [] (or (asc-isalnum (.at arg len)) (at? arg len (byte \_)))
                    ((ร len =) (inc len))
                    (recur)
                )
                ((ร nextchar =) (.at arg len))
                (eos! arg len)                           ;; put NUL after name
                ((ร vimoption_C v =) (findoption arg))
                (.be arg len, nextchar)                      ;; restore nextchar

                (when (nil? v)      ;; found a mismatch: skip
                    ((ร errmsg =) (u8 "E518: Unknown option"))
                    (ร BREAK skip)
                )

                ;; remember character after option name
                ((ร byte afterchar =) (.at arg len))

                ;; skip white space, allow ":set ai  ?"
                (loop-when [] (vim-iswhite (.at arg len))
                    ((ร len =) (inc len))
                    (recur)
                )

                ((ร nextchar =) (.at arg len))

                (when (and (!= nextchar NUL) (at? arg (inc len) (byte \=)))
                    ((ร errmsg =) e_invarg)
                    (ร BREAK skip)
                )

                (when (some? (vim-strchr (u8 "?=:!&<"), nextchar))
                    ((ร arg =) (.plus arg len))
                    (when (and (some? (vim-strchr (u8 "?!&<"), nextchar)) (non-eos? arg 1) (not (vim-iswhite (.at arg 1))))
                        ((ร errmsg =) e_trailing)
                        (ร BREAK skip)
                    )
                )

                ((ร Object varp =) (get-varp v))

                ;; allow '=' and ':' as MSDOS command.com allows
                ;; only one '=' character per "set" command line

                (cond (or (== nextchar (byte \?)) (and (== prefix 1) (nil? (vim-strchr (u8 "=:&<"), nextchar)) (non-flag? (:flags v) P_BOOL)))
                (do
                    ;; print value
                    (cond did_show
                    (do
                        (msg-putchar (byte \newline))      ;; cursor below last one
                    )
                    :else
                    (do
                        (gotocmdline true)      ;; cursor at status line
                        ((ร did_show =) true)        ;; remember that we did a line
                    ))

                    (showoneopt v)

                    ((ร errmsg =) (if (and (!= nextchar (byte \?)) (!= nextchar NUL) (not (vim-iswhite afterchar))) e_trailing errmsg))
                )
                :else
                (do
                    (cond (flag? (:flags v) P_BOOL)          ;; boolean
                    (do
                        (when (or (== nextchar (byte \=)) (== nextchar (byte \:)) (== nextchar (byte \<)))
                            ((ร errmsg =) e_invarg)
                            (ร BREAK skip)
                        )

                        (ร boolean value)

                        ;; ":set opt!": invert
                        ;; ":set opt&": reset to default value

                        (cond (== nextchar (byte \!))
                        (do
                            ((ร value =) (not (boolean @varp)))
                        )
                        (== nextchar (byte \&))
                        (do
                            ((ร value =) (boolean (:def_val v)))
                        )
                        :else
                        (do
                            ;; ":set invopt": invert
                            ;; ":set opt" or ":set noopt": set or reset

                            (when (and (!= nextchar NUL) (not (vim-iswhite afterchar)))
                                ((ร errmsg =) e_trailing)
                                (ร BREAK skip)
                            )
                            ((ร value =) (if (== prefix 2) (not (boolean @varp)) (!= prefix 0)))
                        ))

                        ((ร errmsg =) (set-bool-option v, #_boolean' varp, value))
                    )
                    :else                                ;; numeric or string
                    (do
                        (when (or (nil? (vim-strchr (u8 "=:&"), nextchar)) (!= prefix 1))
                            ((ร errmsg =) e_invarg)
                            (ร BREAK skip)
                        )

                        (cond (flag? (:flags v) P_NUM)       ;; numeric
                        (do
                            (ร long value)

                            ;; Different ways to set a number option:
                            ;; &        set to default value
                            ;; <xx>     accept special key codes for 'wildchar'
                            ;; c        accept any non-digit for 'wildchar'
                            ;; [-]0-9   set number
                            ;; other    error

                            ((ร arg =) (.plus arg 1))
                            (cond (== nextchar (byte \&))
                            (do
                                ((ร value =) (long (:def_val v)))
                            )
                            (or (at? arg (byte \-)) (asc-isdigit (.at arg 0)))
                            (do
                                ((ร int[] a'ip =) (atom (int)))

                                ;; Allow negative (for 'undolevels'), octal and hex numbers.
                                ((ร value =) (let [__ (atom (long))] (vim-str2nr arg, nil, a'ip, true, true, __) @__))
                                (when (and (non-eos? arg @a'ip) (not (vim-iswhite (.at arg @a'ip))))
                                    ((ร errmsg =) e_invarg)
                                    (ร BREAK skip)
                                )
                            )
                            :else
                            (do
                                ((ร errmsg =) (u8 "E521: Number required after ="))
                                (ร BREAK skip)
                            ))

                            ((ร errmsg =) (set-num-option v, #_long' varp, value))
                        )
                        :else                  ;; string
                        (do
                            ;; The old value is kept until we are sure that the new value is valid.
                            ((ร Bytes oldval =) #_Bytes @varp)

                            ((ร Bytes save_arg =) nil)
                            (ร Bytes newval)

                            (cond (== nextchar (byte \&))    ;; set to default val
                            (do
                                ((ร newval =) (STRDUP #_Bytes (:def_val v)))
                            )
                            :else
                            (do
                                ((ร arg =) (.plus arg 1))      ;; jump to after the '=' or ':'

                                ;; Set 'keywordprg' to ":echo" if an empty value was passed to :set by the user.

                                (when (and (== varp @(:b_p_kp @curbuf)) (or (eos? arg) (at? arg (byte \space))))
                                    ((ร save_arg =) arg)
                                    ((ร arg =) (u8 ":echo"))
                                )

                                ((ร Bytes origval =) oldval)

                                ((ร newval =) (Bytes. (inc (STRLEN arg))))
                                ((ร Bytes s =) newval)

                                ;; Copy the string, skip over escaped chars.

                                (loop-when [] (and (non-eos? arg) (not (vim-iswhite (.at arg 0))))
                                    ((ร arg =) (if (and (at? arg (byte \\)) (non-eos? arg 1)) (.plus arg 1) arg))      ;; remove backslash
                                    ((ร int i =) (us-ptr2len-cc arg))
                                    (cond (< 1 i)
                                    (do
                                        ;; copy multibyte char
                                        (BCOPY s, arg, i)
                                        ((ร arg =) (.plus arg i))
                                        ((ร s =) (.plus s i))
                                    )
                                    :else
                                    (do
                                        (.be s 0, (.at arg 0))
                                        ((ร arg =) (.plus arg 1))
                                        ((ร s =) (.plus s 1))
                                    ))
                                    (recur)
                                )
                                (eos! s)

                                ;; Locate newval[] in origval[] when removing it and when adding to avoid duplicates.
                                ((ร int i =) 0)
                                (when (flag? (:flags v) P_NODUP)
                                    ((ร i =) (STRLEN newval))
                                    ((ร int bs =) 0)
                                    ((ร s =) (loop-when-recur [s origval] (non-eos? s) [(.plus s 1)] => s
                                        (if (and (or (non-flag? (:flags v) P_COMMA) (BEQ s, origval) (and (at? s -1 (byte \,)) (zero? (& bs 1)))) (zero? (STRNCMP s, newval, i)) (or (non-flag? (:flags v) P_COMMA) (at? s i (byte \,)) (eos? s i)))
                                            (ร BREAK)
                                        )
                                        ;; Count backslashes.
                                        ;; Only a comma with an even number of backslashes before it is recognized as a separator.
                                        ((ร bs =) (if (and (BLT origval, s) (at? s -1 (byte \\))) (inc bs) 0))
                                    ))
                                )

                                (when (flag? (:flags v) P_FLAGLIST)
                                    ;; Remove flags that appear twice.
                                    ((ร s =) (loop-when-recur [s newval] (non-eos? s) [(.plus s 1)] => s
                                        (when (and (or (non-flag? (:flags v) P_COMMA) (not-at? s (byte \,))) (some? (vim-strbyte (.plus s 1), (.at s 0))))
                                            (BCOPY s, 0, s, 1, (inc (STRLEN s, 1)))
                                            ((ร s =) (.minus s 1))
                                        )
                                    ))
                                )

                                ((ร arg =) (if (some? save_arg) save_arg arg))   ;; number for 'whichwrap'
                            ))

                            ;; Set the new value.
                            ((ร (Bytes)@varp =) newval)

                            ;; Handle side effects, and set the global value for ":set" on local options.
                            ((ร errmsg =) (did-set-string-option v, #_Bytes' varp, oldval))

                            ;; If error detected, print the error message.
                            (if (some? errmsg)
                                (ร BREAK skip)
                            )
                        ))
                    ))
                ))
;           }

            ;; Advance to next argument.
            ;; - skip until a blank found, taking care of backslashes
            ;; - skip blanks
            ;; - skip one "=val" argument (for hidden options ":set gfn =xx")

            (dotimes [_ 2]
                (loop-when [] (and (non-eos? arg) (not (vim-iswhite (.at arg 0))))
                    (if (and (at? ((ร arg =) (.plus arg 1)) -1 (byte \\)) (non-eos? arg))
                        ((ร arg =) (.plus arg 1))
                    )
                    (recur)
                )
                ((ร arg =) (skipwhite arg))
                (if (not-at? arg (byte \=))
                    (ร BREAK)
                )
            )

            (when (some? errmsg)
                (vim-strncpy @ioBuff, errmsg, (dec IOSIZE))
                ((ร int i =) (+ (STRLEN @ioBuff) 2))
                (when (< (+ i (BDIFF arg, startarg)) IOSIZE)
                    ;; append the argument with the error
                    (STRCAT @ioBuff, (u8 ": "))
                    (BCOPY @ioBuff, i, startarg, 0, (BDIFF arg, startarg))
                    (eos! @ioBuff (+ i (BDIFF arg, startarg)))
                )
                ;; make sure all characters are printable
                (trans-characters @ioBuff, IOSIZE)

                (swap! no_wait_return inc)       ;; wait-return done later
                (emsg @ioBuff)           ;; show error highlighted
                (swap! no_wait_return dec)

                ((ร RETURN) false)
            )
        )
    ))

(defn- #_Bytes illegal-char [#_int c]
    (let [#_Bytes errbuf (Bytes. 80)]
;%%     (.sprintf libC errbuf, (u8 "E539: Illegal character <%s>"), (transchar c))
        errbuf
    ))

;; After setting various option values: recompute variables that depend on option values.

(defn- #_void didset-options []
    ;; initialize the table for 'iskeyword' et al.
    (init-chartab true)

    (opt-strings-flags @p_dy, p_dy_values, dy_flags, true)
    (opt-strings-flags @p_ve, p_ve_values, ve_flags, true)

    (briopt-check @curwin)
    nil)

;; Handle string options that need some action to perform when changed.
;; Returns null for success, or an error message for an error.

(defn- #_Bytes did-set-string-option [#_vimoption_C v, #_Bytes' varp, #_Bytes oldval]
    (let [a'undo_chartab (atom (boolean false))
          #_Bytes errmsg
            (cond (== varp (:wo_briopt (:w_options @curwin))) ;; 'breakindentopt'
                (when-not (briopt-check @curwin) e_invarg)

            (any == varp p_isi p_isp p_isf (:b_p_isk @curbuf)) ;; 'isident', 'isprint', 'isfname' or 'iskeyword'
                (when-not (init-chartab true)
                    (reset! a'undo_chartab true) ;; need to restore it below
                    e_invarg)

            (== varp (:wo_cc (:w_options @curwin))) ;; 'colorcolumn'
                (check-colorcolumn @curwin)

            (== varp p_hl) ;; 'highlight'
                (when-not (highlight-changed) e_invarg)

            (== varp (:b_p_nf @curbuf)) ;; 'nrformats'
                (when-not (check-opt-strings @varp, p_nf_values, true) e_invarg)

            (== varp p_sbo) ;; 'scrollopt'
                (when-not (check-opt-strings @p_sbo, p_scbopt_values, true) e_invarg)

            (== varp (:b_p_mps @curbuf)) ;; 'matchpairs'
                (loop-when [#_Bytes p @varp] (non-eos? p)
                    (let [p (.plus p (us-ptr2len-cc p))
                          [#_int x2 p] (if (non-eos? p) [(.at p 0) (.plus p 1)] [-1 p])
                          [#_int x3 p] (if (non-eos? p) [(us-ptr2char p) (.plus p (us-ptr2len-cc p))] [-1 p])]
                        (cond (or (!= x2 (byte \:)) (== x3 -1) (and (non-eos? p) (not-at? p (byte \,)))) e_invarg (non-eos? p) (recur (.plus p 1)))
                    ))

            (== varp p_sbr) ;; 'showbreak'
                (loop-when [#_Bytes s @p_sbr] (non-eos? s)
                    (recur-if (== (mb-ptr2cells s) 1) [(.plus s (us-ptr2len-cc s))] => (u8 "E595: contains unprintable or wide character")))

            (== varp p_breakat) ;; 'breakat'
                (do (fill-breakat-flags) nil)

            (== varp p_sel) ;; 'selection'
                (when (or (eos? @p_sel) (not (check-opt-strings @p_sel, p_sel_values, false))) e_invarg)

            (== varp p_slm) ;; 'selectmode'
                (when-not (check-opt-strings @p_slm, p_slm_values, true) e_invarg)

            (== varp p_km) ;; 'keymodel'
                (if (check-opt-strings @p_km, p_km_values, true)
                    (do (reset! km_stopsel (some? (vim-strchr @p_km, (byte \o))))
                        (reset! km_startsel (some? (vim-strchr @p_km, (byte \a))))
                        nil)
                    e_invarg)

            (== varp p_dy) ;; 'display'
                (if (opt-strings-flags @p_dy, p_dy_values, dy_flags, true)
                    (do (init-chartab true)
                        nil)
                    e_invarg)

            (== varp p_ead) ;; 'eadirection'
                (when-not (check-opt-strings @p_ead, p_ead_values, false) e_invarg)

            (== varp p_bs) ;; 'backspace'
                (when-not (check-opt-strings @p_bs, p_bs_values, true) e_invarg)

            (== varp p_ve) ;; 'virtualedit'
                (cond (not (opt-strings-flags @p_ve, p_ve_values, ve_flags, true))
                    e_invarg
                (non-zero? (STRCMP @p_ve, oldval))
                    (do ;; Recompute cursor position in case the new 've' setting changes something.
                        (swap! curwin validate-virtcol)
                        (swap! curwin coladvance (:w_virtcol @curwin))
                        nil
                    ))

            :else ;; Options that are a list of flags.
                (let-when [#_Bytes p (condp == varp p_ww WW_ALL p_cpo CPO_ALL (:wo_cocu (:w_options @curwin)) COCU_ALL nil)] (some? p)
                    (loop-when [#_Bytes s @varp] (non-eos? s)
                        (recur-if (some? (vim-strchr p, (.at s 0))) [(.plus s 1)] => (illegal-char (.at s 0)))
                    ))
            )]

        ;; If error detected, restore the previous value.
        (when (some? errmsg)
            (reset! varp oldval)
            ;; When resetting some values, need to act on it.
            (when @a'undo_chartab
                (init-chartab true))
            (when (== varp p_hl)
                (highlight-changed)
            ))

        (when (and (!= (:w_curswant @curwin) MAXCOL) (flag? (:flags v) (| P_CURSWANT P_RALL)))
            (swap! curwin assoc :w_set_curswant true))
        (check-redraw (:flags v))

        errmsg
    ))

;; Handle setting 'colorcolumn' in window "win".
;; Returns error message, null if it's OK.

(defn- #_Bytes check-colorcolumn [#_window_C win]
    (ยง
        ((ร int[] color_cols =) (ร new int[256]))

        ((ร int n =) (loop-when [#_Bytes s @(:wo_cc (:w_options win)) n 0] (and (non-eos? s) (< n 255)) => n
            (if (not (asc-isdigit (.at s 0)))
                ((ร RETURN) e_invarg)
            )

            (ร int col)
            (let [__ (atom (#_Bytes object s))]
                ((ร col =) (int (getdigits __)))
                ((ร s =) @__))

            ((ร color_cols[n] =) (dec col))  ;; 1-based to 0-based
            ((ร n =) (inc n))

            (if (eos? s)
                (ร BREAK)
            )
            (if (not-at? s (byte \,))
                ((ร RETURN) e_invarg)
            )
            ((ร s =) (.plus s 1))
            (if (eos? s)
                ((ร RETURN) e_invarg)    ;; illegal trailing comma as in "set cc=80,"
            )
            (recur s n)
        ))

        (cond (zero? n)
        (do
            ((ร win =) (assoc win :w_p_cc_cols nil))
        )
        :else
        (do
            ((ร win =) (assoc win :w_p_cc_cols (ร new int[n + 1])))

            ;; sort the columns for faster usage on screen redraw inside win-line()
            (Arrays/sort color_cols, 0, n)

            ((ร int j =) 0)
            (dotimes [#_int i n]
                ;; skip duplicates
                (if (or (zero? j) (!= (... (:w_p_cc_cols win) (dec j)) (... color_cols i)))
                    ((ร win.w_p_cc_cols[j++] =) (... color_cols i))
                )
            )
            ((ร win.w_p_cc_cols[j] =) -1)     ;; end marker
        ))

        nil    ;; no error
    ))

;; Set the value of a boolean option, and take care of side effects.
;; Returns null for success, or an error message for an error.

(defn- #_Bytes set-bool-option [#_vimoption_C v, #_boolean' varp, #_boolean value]
    (let [o'value @varp _ (reset! varp value)]

        (cond (== varp p_paste)                             ;; when 'paste' is set or reset, also change other options
            (paste-option-changed)

        (== varp p_im)                                      ;; when 'insertmode' is set from an autocommand, need to do work here
            (cond @p_im
            (do
                (when (non-flag? @State INSERT)
                    (reset! need_start_insertmode true))
                (reset! stop_insert_mode false)
            )
            :else
            (do
                (reset! need_start_insertmode false)
                (reset! stop_insert_mode true)
                (when (and (non-zero? @restart_edit) @mode_displayed) ;; remove "(insert)"
                    (reset! clear_cmdline true))
                (reset! restart_edit 0)
            ))

        (and (== varp p_ic) @p_hls)                         ;; when 'ignorecase' is set or reset and 'hlsearch' is set, redraw
            (redraw-all-later SOME_VALID)

        (== varp p_hls)                                     ;; when 'hlsearch' is set or reset, reset no_hlsearch
            (reset! no_hlsearch false)

        (== varp (:wo_scb (:w_options @curwin)))            ;; when 'scrollbind' is set, snapshot current position to avoid a jump at the end of normal-cmd()
            (when @varp
                (swap! curwin do-check-scrollbind false)
                (swap! curwin assoc :w_scbind_pos (:w_topline @curwin))
            )

        (== varp (:wo_wrap (:w_options @curwin)))           ;; when 'wrap' is set, set "w_leftcol" to zero
            (when @varp
                (swap! curwin assoc :w_leftcol 0))

        (== varp p_ea)
            (when (and @p_ea (not o'value))
                (win-equal @curwin, false, 0))
        )

        (comp-col) ;; in case 'ruler' or 'showcmd' changed
        (when (and (!= (:w_curswant @curwin) MAXCOL) (flag? (:flags v) (| P_CURSWANT P_RALL)))
            (swap! curwin assoc :w_set_curswant true))
        (check-redraw (:flags v)))
    nil)

;; Set the value of a number option, and take care of side effects.
;; Returns null for success, or an error message for an error.

(defn- #_Bytes set-num-option [#_vimoption_C v, #_long' varp, #_long value]
    (let [a'errmsg (atom (#_Bytes object nil))
          o'Rows @Rows o'Cols @Cols
          o'value @varp _ (reset! varp value)]

        (when (< @(:b_p_ts @curbuf) 1)  (reset! (:b_p_ts @curbuf) 8)                  (reset! a'errmsg e_positive))
        (when (< @(:b_p_sw @curbuf) 0)  (reset! (:b_p_sw @curbuf) @(:b_p_ts @curbuf)) (reset! a'errmsg e_positive))

        (cond (== varp p_ch) ;; 'cmdheight'
            (let [m (inc (- @Rows (min-rows)))]
                (when (< @p_ch 1)       (reset! p_ch 1)       (reset! a'errmsg e_positive))
                (when (< m @p_ch)       (reset! p_ch m))
                ;; Only compute the new window layout when startup has been completed,
                ;; otherwise the frame sizes may be wrong.
                (when (and (!= @p_ch o'value) @full_screen)
                    (command-height)
                ))

        (== varp p_cwh) ;; 'cmdwinheight'
            (when (< @p_cwh 1)          (reset! p_cwh 1)      (reset! a'errmsg e_positive))

        (== varp p_wh) ;; 'winheight'
            (do (when (< @p_wh 1)       (reset! p_wh 1)       (reset! a'errmsg e_positive))
                (when (< @p_wh @p_wmh)  (reset! p_wh @p_wmh)  (reset! a'errmsg e_winheight))
                ;; Change window height NOW.
                (when (and (!= @lastwin @firstwin) (< (:w_height @curwin) @p_wh))
                    (win-setheight @curwin, @p_wh)
                ))

        (== varp p_wiw) ;; 'winwidth'
            (do (when (< @p_wiw 1)      (reset! p_wiw 1)      (reset! a'errmsg e_positive))
                (when (< @p_wiw @p_wmw) (reset! p_wiw @p_wmw) (reset! a'errmsg e_winwidth))
                ;; Change window width NOW.
                (when (and (!= @lastwin @firstwin) (< (:w_width @curwin) @p_wiw))
                    (win-setwidth @curwin, @p_wiw)
                ))

        (== varp p_wmh) ;; 'winminheight'
            (do (when (< @p_wmh 0)      (reset! p_wmh 0)      (reset! a'errmsg e_positive))
                (when (< @p_wh @p_wmh)  (reset! p_wmh @p_wh)  (reset! a'errmsg e_winheight))
                (win-setminheight))

        (== varp p_wmw) ;; 'winminwidth'
            (do (when (< @p_wmw 0)      (reset! p_wmw 0)      (reset! a'errmsg e_positive))
                (when (< @p_wiw @p_wmw) (reset! p_wmw @p_wiw) (reset! a'errmsg e_winwidth))
                (win-setminheight))

        (== varp p_hi) ;; 'history'
            (cond
                (< @p_hi 0)     (do     (reset! p_hi 0)       (reset! a'errmsg e_positive))
                (< 10000 @p_hi) (do     (reset! p_hi 10000)   (reset! a'errmsg e_invarg)))

        (== varp p_ls) ;; (re)set last window status line
            (last-status false)

        (== varp p_mco) ;; 'maxcombine'
            (do (swap! p_mco #(max 0 (min % MAX_MCO)))
                (screen-clear)) ;; will re-allocate the screen

        (== varp p_re) ;; 'regexpengine'
            (when-not (<= 0 @p_re 2)    (reset! p_re 0)       (reset! a'errmsg e_invarg))

        (== varp p_report) ;; 'report'
            (when (< @p_report 0)       (reset! p_report 1)   (reset! a'errmsg e_positive))

        (== varp p_ss) ;; 'sidescroll'
            (when (< @p_ss 0)           (reset! p_ss 0)       (reset! a'errmsg e_positive))

        (== varp p_tm) ;; 'timeoutlen'
            (when (< @p_tm 0)           (reset! p_tm 0)       (reset! a'errmsg e_positive))

        (== varp (:wo_cole (:w_options @curwin))) ;; 'conceallevel'
            (cond
                (< @varp 0) (do         (reset! varp 0)       (reset! a'errmsg e_positive))
                (< 3 @varp) (do         (reset! varp 3)       (reset! a'errmsg e_invarg)))

        (== varp (:wo_nuw (:w_options @curwin))) ;; 'numberwidth'
            (do (when (< @varp 1)       (reset! varp 1)       (reset! a'errmsg e_positive))
                (when (< 10 @varp)      (reset! varp 10)      (reset! a'errmsg e_invarg))
                (swap! curwin assoc :w_nrwidth_line_count 0)) ;; trigger a redraw

        (== varp (:b_p_ul @curbuf)) ;; sync undo before 'undolevels' changes
            (do ;; use the old value, otherwise u-sync() may not work properly
                (reset! (:b_p_ul @curbuf) o'value)
                (u-sync true)
                (reset! (:b_p_ul @curbuf) value))

        (== varp p_ut) ;; 'updatetime'
            (when (< @p_ut 0)           (reset! p_ut 2000)    (reset! a'errmsg e_positive))
        )

        (when @full_screen
            (let-when [m (min-rows)] (< @Rows m)
                (reset! Rows m)
                (let [#_Bytes errbuf (Bytes. 80)]
;%%                 (vim_snprintf errbuf, (.size errbuf), (u8 "E593: Need at least %d lines"), m)
                    (reset! a'errmsg errbuf)
                ))
            (let-when [m MIN_COLS] (< @Cols m)
                (reset! Cols m)
                (let [#_Bytes errbuf (Bytes. 80)]
;%%                 (vim_snprintf errbuf, (.size errbuf), (u8 "E594: Need at least %d columns"), m)
                    (reset! a'errmsg errbuf)
                ))
        )

        (limit-screen-size)

        ;; If the screen (shell) height has been changed, assume it is the physical screenheight.
        (when (or (!= o'Rows @Rows) (!= o'Cols @Cols))
            ;; Changing the screen size is not allowed while updating the screen.
            (cond @updating_screen
                (reset! varp o'value)
            @full_screen
                (set-shellsize @Cols, @Rows, true)
            :else
                (do ;; Postpone the resizing; check the size and cmdline position for messages.
                    (check-shellsize)
                    (when (and (< (- @Rows @p_ch) @cmdline_row) (< @p_ch @Rows))
                        (reset! cmdline_row (- @Rows @p_ch)))
                ))
        )

        (when @full_screen
            (let-when [a'scr (:wo_scr (:w_options @curwin))] (or (< @a'scr 1) (< 0 (:w_height @curwin) @a'scr))
                (cond (== varp a'scr)
                    (do (when (!= @a'scr 0)
                            (reset! a'errmsg e_scroll))
                        (win-comp-scroll @curwin))
                ;; If 'scroll' became invalid because of a side effect, silently adjust it.
                (< @a'scr 1)
                    (reset! a'scr 1)
                (< (:w_height @curwin) @a'scr)
                    (reset! a'scr (:w_height @curwin))
                ))

            (when-not (and (<= -100 @p_sj) (< @p_sj @Rows))
                (if (!= @Rows o'Rows)   ;; Rows changed, just adjust 'scrolljump'
                    (reset! p_sj (/ @Rows 2))
                    (do (reset! p_sj 1) (reset! a'errmsg e_scroll))
                ))

            (when (< @p_so 0)   (reset! p_so 0)   (reset! a'errmsg e_scroll)) ;; 'scrolloff'
            (when (< @p_siso 0) (reset! p_siso 0) (reset! a'errmsg e_positive)) ;; 'sidescrolloff'
        )

        (comp-col) ;; in case 'columns' or 'ls' changed
        (when (and (!= (:w_curswant @curwin) MAXCOL) (flag? (:flags v) (| P_CURSWANT P_RALL)))
            (swap! curwin assoc :w_set_curswant true))
        (check-redraw (:flags v))

        @a'errmsg
    ))

;; Called after an option changed: check if something needs to be redrawn.

(defn- #_void check-redraw [#_long flags]
    ;; Careful: P_RCLR and P_RALL are a combination of other P_ flags.
    (let [#_boolean doclear (== (& flags P_RCLR) P_RCLR)
          #_boolean all (or (== (& flags P_RALL) P_RALL) doclear)]

        (when (or (flag? flags P_RSTAT) all)      ;; mark all status lines dirty
            (status-redraw-all))
        (when (or (flag? flags P_RBUF) (flag? flags P_RWIN) all)
            (swap! curwin changed-window-setting))
        (when (flag? flags P_RBUF)
            (redraw-curbuf-later NOT_VALID))
        (cond
            doclear (redraw-all-later CLEAR)
            all (redraw-all-later NOT_VALID)
        ))
    nil)

(defn- #_vimoption_C findoption [#_Bytes name]
    (when (<= (byte \a) (.at name 0) (byte \z))
        (let [n (count vimoptions)]
            (or
                ;; match full name
                (loop-when [#_int i 0] (< i n) => nil
                    (let [v (... vimoptions i) #_Bytes s (:fullname v)] (if (zero? (STRCMP name, s)) v (recur (inc i)))))
                ;; match short name
                (loop-when [#_int i 0] (< i n) => nil
                    (let [v (... vimoptions i) #_Bytes s (:shortname v)] (if (and (some? s) (zero? (STRCMP name, s))) v (recur (inc i)))))
            ))
    ))

(defn- #_Bytes get-highlight-default []
    (let [#_vimoption_C v (findoption (u8 "hl"))]
        (when (some? v) #_Bytes (:def_val v))
    ))

;; showoneopt: show the value of one option

(defn- #_void showoneopt [#_vimoption_C v]
    (reset! info_message true)
    (let [#_Object' varp (get-varp v)]
        (if (and (flag? (:flags v) P_BOOL) (not (boolean @varp)))
            (msg-puts (u8 "no"))
            (msg-puts (u8 "  ")))
        (msg-puts (:fullname v))
        (when (non-flag? (:flags v) P_BOOL)
            (msg-putchar (byte \=))
            (let [#_Bytes s (Bytes. MAXPATHL)]
;%%             (cond (flag? (:flags v) P_NUM)
;%%                 (.sprintf libC s, (u8 "%ld"), (long @varp))
;%%             (flag? (:flags v) P_STRING)
;%%                 (if (nil? @varp)              ;; just in case
;%%                     (eos! s)
;%%                     (vim-strncpy s, #_Bytes @varp, (dec MAXPATHL))))
                (msg-outtrans s)
            ))
        (reset! info_message false))
    nil)

;; Compute columns for ruler and shown command. 'sc_col' is also used to
;; decide what the maximum length of a message on the status line can be.
;; If there is a status line for the last window, 'sc_col' is independent
;; of 'ru_col'.

(final int COL_RULER 17)        ;; columns needed by standard ruler

(defn- #_void comp-col []
    (let [#_boolean last_has_status (or (== @p_ls 2) (and (== @p_ls 1) (!= @firstwin @lastwin)))]
        (reset! sc_col 0)
        (reset! ru_col 0)
        (when @p_ru
            (reset! ru_col (inc (if (non-zero? @ru_wid) @ru_wid COL_RULER)))
            ;; no last status line, adjust sc_col
            (when (not last_has_status)
                (reset! sc_col @ru_col))
        )
        (when @p_sc
            (swap! sc_col + SHOWCMD_COLS)
            (when (or (not @p_ru) last_has_status) ;; no need for separating space
                (swap! sc_col inc))
        )
        (swap! sc_col #(max 1 (- @Cols %)))
        (swap! ru_col #(max 1 (- @Cols %)))
    )
    nil)

;; Get pointer to option variable.

(defn- #_Object get-varp [#_vimoption_C v]
    (let [wops (:w_options @curwin)]
        (condp == (:indir v)
            PV_BRI    (:wo_bri wops)
            PV_BRIOPT (:wo_briopt wops)
            PV_CC     (:wo_cc wops)
            PV_COCU   (:wo_cocu wops)
            PV_COLE   (:wo_cole wops)
            PV_CRBIND (:wo_crb wops)
            PV_CUC    (:wo_cuc wops)
            PV_CUL    (:wo_cul wops)
            PV_LBR    (:wo_lbr wops)
            PV_NU     (:wo_nu wops)
            PV_NUW    (:wo_nuw wops)
            PV_RNU    (:wo_rnu wops)
            PV_SCBIND (:wo_scb wops)
            PV_SCROLL (:wo_scr wops)
            PV_WFH    (:wo_wfh wops)
            PV_WFW    (:wo_wfw wops)
            PV_WRAP   (:wo_wrap wops)

            PV_AI     (:b_p_ai @curbuf)
            PV_CI     (:b_p_ci @curbuf)
            PV_CINW   (:b_p_cinw @curbuf)
            PV_ET     (:b_p_et @curbuf)
            PV_ISK    (:b_p_isk @curbuf)
            PV_KP     (:b_p_kp @curbuf)
            PV_MOD    (:b_changed @curbuf)
            PV_MPS    (:b_p_mps @curbuf)
            PV_NF     (:b_p_nf @curbuf)
            PV_PI     (:b_p_pi @curbuf)
            PV_QE     (:b_p_qe @curbuf)
            PV_SI     (:b_p_si @curbuf)
            PV_STS    (:b_p_sts @curbuf)
            PV_SW     (:b_p_sw @curbuf)
            PV_TS     (:b_p_ts @curbuf)
            PV_UL     (:b_p_ul @curbuf)

            (:var v)
        )
    ))

;; Copy options from one window to another.
;; Used when splitting a window.

(defn- #_window_C win-copy-options [#_window_C win, #_window_C won]
    (copy-winopt (:w_options win), (:w_options won))
    (briopt-check win)
    win)

;; Copy the options from one winopt_C to another.

(defn- #_void copy-winopt [#_winopt_C win, #_winopt_C won]
    (reset! (:wo_bri win)            @(:wo_bri won))
    (reset! (:wo_briopt win) (STRDUP @(:wo_briopt won)))
    (reset! (:wo_cc win)     (STRDUP @(:wo_cc won)))
    (reset! (:wo_cocu win)   (STRDUP @(:wo_cocu won)))
    (reset! (:wo_cole win)           @(:wo_cole won))
    (reset! (:wo_crb win)            @(:wo_crb won))
    (reset! (:wo_cuc win)            @(:wo_cuc won))
    (reset! (:wo_cul win)            @(:wo_cul won))
    (reset! (:wo_lbr win)            @(:wo_lbr won))
    (reset! (:wo_nu win)             @(:wo_nu won))
    (reset! (:wo_nuw win)            @(:wo_nuw won))
    (reset! (:wo_rnu win)            @(:wo_rnu won))
    (reset! (:wo_scb win)            @(:wo_scb won))
    ;; 'scroll' is omitted as it depends on window height
    ;; 'winfixheight' ... ?
    ;; 'winfixwidth' ... ?
    (reset! (:wo_wrap win)           @(:wo_wrap won))
    nil)

(atom! boolean old_p_paste)
(atom! boolean save_sm)
(atom! boolean save_ru)

;; Called after 'paste' was set or reset.

(defn- #_void paste-option-changed []
    (cond @p_paste
    (do ;; Paste switched from off to on.
        (when (not @old_p_paste)
            ;; save options
            (swap! curbuf assoc :b_p_sts_nopaste @(:b_p_sts @curbuf))
            (swap! curbuf assoc :b_p_ai_nopaste @(:b_p_ai @curbuf))
            ;; save global options
            (reset! save_sm @p_sm)
            (reset! save_ru @p_ru)
        )
        ;; Always set the option values, also when 'paste' is set when it is already on.
        ;; set options
        (reset! (:b_p_sts @curbuf) 0)       ;; softtabstop is 0
        (reset! (:b_p_ai @curbuf) false)    ;; no auto-indent
        ;; set global options
        (reset! p_sm false)                 ;; no showmatch
        (when @p_ru
            (status-redraw-all))            ;; redraw to remove the ruler
        (reset! p_ru false)                 ;; no ruler
    )
    @old_p_paste
    (do ;; Paste switched from on to off.
        ;; restore options
        (reset! (:b_p_sts @curbuf) (:b_p_sts_nopaste @curbuf))
        (reset! (:b_p_ai @curbuf) (:b_p_ai_nopaste @curbuf))
        ;; restore global options
        (reset! p_sm @save_sm)
        (when (!= @p_ru @save_ru)
            (status-redraw-all))            ;; redraw to draw the ruler
        (reset! p_ru @save_ru)
    ))
    (reset! old_p_paste @p_paste)
    nil)

;; Called when 'breakat' changes value.

(defn- #_void fill-breakat-flags []
    (swap! breakat_flags #(into (empty %) (map (constantly false) %)))
    (let-when [#_Bytes p @p_breakat] (some? p)
        (loop-when-recur [#_int i 0] (non-eos? p i) [(inc i)]
            (swap! breakat_flags assoc (char_u (.at p i)) true)
        ))
    nil)

;; Check an option that can be a range of string values.
;;
;; Return true for correct value, false otherwise.
;; Empty is always OK.

(defn- #_boolean check-opt-strings [#_Bytes val, #_Bytes* values, #_boolean list]
    ;; list: when true: accept a list of values
    (opt-strings-flags val, values, nil, list))

;; Handle an option that can be a range of string values.
;; Set a flag in "*flags" for each value present.
;;
;; Return false for a malformed "val", true otherwise.
;; Empty "val" is OK.

(defn- #_boolean opt-strings-flags [#_Bytes val, #_Bytes* values, #_int' a'flags, #_boolean list?]
    ;; val: new value
    ;; values: array of valid string values
    ;; list?: when true: accept a list of values
    (let-when [#_int flags
            (loop-when [#_Bytes s val flags 0] (non-eos? s) => flags
                (let-when [[s flags :as _]
                        (loop-when [#_int i 0] (some? (... values i)) => nil
                            (let [#_int n (STRLEN (... values i))]
                                (if (and (zero? (STRNCMP (... values i), s, n)) (or (and list? (at? s n (byte \,))) (eos? s n)))
                                    [(.plus s (+ n (if (at? s n (byte \,)) 1 0))) (| flags (<< 1 i))]
                                    (recur (inc i))
                                ))
                        )] (some? _) => nil
                    (recur s flags))
            )] (some? flags) => false
        (when (some? a'flags)
            (reset! a'flags flags))
        true
    ))

;; Check if backspacing over something is allowed.

(defn- #_boolean can-bs [#_int what]
    ;; what: BS_INDENT, BS_EOL or BS_START
    (some? (vim-strchr @p_bs, what)))

;; Return the effective shiftwidth value for current buffer,
;; using the 'tabstop' value when 'shiftwidth' is zero.

(defn- #_long get-sw-value []
    (let [sw @(:b_p_sw @curbuf)]
        (if (non-zero? sw) sw @(:b_p_ts @curbuf))
    ))

;; Return the effective softtabstop value for the current buffer,
;; using the 'tabstop' value when 'softtabstop' is negative.

(defn- #_long get-sts-value []
    (let [sts @(:b_p_sts @curbuf)]
        (if (neg? sts) (get-sw-value) sts)
    ))

;; Check matchpairs option for "*initc".
;; If there is a match set "*initc" to the matching character and "*findc" to the opposite.
;; Set "*backwards" to the direction.
;; When "switchit" is true, swap the direction.

(defn- #_void find-mps-values [#_int' a'initc, #_int' a'findc, #_boolean' a'backwards, #_boolean switchit]
    (loop-when [#_Bytes s @(:b_p_mps @curbuf)] (non-eos? s)
        (if (== (us-ptr2char s) @a'initc)
            (let [c (us-ptr2char s, (inc (us-ptr2len-cc s)))]
                (if switchit
                    (do (reset! a'findc @a'initc) (reset! a'initc c) (reset! a'backwards true))
                    (do (reset! a'findc c) (reset! a'backwards false)))
            )
            (let [c (us-ptr2char s) s (.plus s (inc (us-ptr2len-cc s)))]
                (if (== (us-ptr2char s) @a'initc)
                    (if switchit
                        (do (reset! a'findc @a'initc) (reset! a'initc c) (reset! a'backwards false))
                        (do (reset! a'findc c) (reset! a'backwards true)))
                    (let [s (.plus s (us-ptr2len-cc s)) s (if (at? s (byte \,)) (.plus s 1) s)]
                        (recur s)
                    )
                )
            )
        ))
    nil)

;; This is called when 'breakindentopt' is changed and when a window is initialized.

(defn- #_boolean briopt-check [#_window_C win]
    (ยง
        ((ร int bri_shift =) 0)
        ((ร int bri_min =) 20)
        ((ร boolean bri_sbr =) false)

        (loop-when [#_Bytes p @(:wo_briopt (:w_options win))] (non-eos? p)
            (cond (and (zero? (STRNCMP p, (u8 "shift:"), 6)) (or (and (at? p 6 (byte \-)) (asc-isdigit (.at p 7))) (asc-isdigit (.at p 6))))
            (do
                ((ร p =) (.plus p 6))
                (let [__ (atom (#_Bytes object p))]
                    ((ร bri_shift =) (int (getdigits __)))
                    ((ร p =) @__))
            )
            (and (zero? (STRNCMP p, (u8 "min:"), 4)) (asc-isdigit (.at p 4)))
            (do
                ((ร p =) (.plus p 4))
                (let [__ (atom (#_Bytes object p))]
                    ((ร bri_min =) (int (getdigits __)))
                    ((ร p =) @__))
            )
            (zero? (STRNCMP p, (u8 "sbr"), 3))
            (do
                ((ร p =) (.plus p 3))
                ((ร bri_sbr =) true)
            ))
            (if (or (at? p (byte \,)) (eos? p))
                (recur (if (at? p (byte \,)) (.plus p 1) p))
                ((ร RETURN) false)
            )
        )

        ((ร win =) (assoc win :w_p_brishift bri_shift))
        ((ร win =) (assoc win :w_p_brimin bri_min))
        ((ร win =) (assoc win :w_p_brisbr bri_sbr))

        true
    ))

;; ex_cmds.c: some functions for command line commands --------------------------------------------

;; ":ascii" and "ga".

(defn- #_void do-ascii [#_window_C win]
    (let-when [#_int* cc (int-array MAX_MCO) #_int c (us-ptr2char-cc (ml-get-cursor win), cc)] (!= c NUL) => (msg (u8 "NUL"))
        (let [#_Bytes buf (Bytes. IOSIZE)
              [c #_int ci]
                (if (< c 0x80)
                    (let [#_Bytes buf1 (Bytes. 20) #_Bytes buf2 (Bytes. 20) c (if (== c NL) NUL c)] ;; NUL is stored as NL
                        (if (and (vim-isprintc c) (or (< c (byte \space)) (< (byte \~) c)))
                            (let [#_Bytes buf3 (Bytes. 7)]
                                (transchar-nonprint buf3, c)
;%%                             (vim_snprintf buf1, (.size buf1), (u8 "  <%s>"), buf3)
                            )
                            (eos! buf1)
                        )
                        (if (<= 0x80 c)
;%%                         (vim_snprintf buf2, (.size buf2), (u8 "  <M-%s>"), (transchar (& c 0x7f)))
                            (eos! buf2)
                        )
;%%                     (vim_snprintf buf, IOSIZE, (u8 "<%s>%s%s  %d,  Hex %02x,  Octal %03o"), (transchar c), buf1, buf2, c, c, c)
                        [(aget cc 0) 1]
                    )
                    [c 0]
                )]
            ;; Repeat for combining characters.
            (loop-when [c c ci ci] (<= 0x80 c)
                (let [#_int n (STRLEN buf)
                      ;; This assumes every multi-byte char is printable...
                      n (if (pos? n)            (do (.be buf n, (byte \space)) (inc n)) n)
                      n                         (do (.be buf n, (byte \<))     (inc n))
                      n (if (utf-iscomposing c) (do (.be buf n, (byte \space)) (inc n)) n) ;; draw composing char on top of a space
                      n (+ n (utf-char2bytes c, (.plus buf n)))]
;%%                 (vim_snprintf (.plus buf n), (- IOSIZE n), (if (< c 0x10000) (u8 "> %d, Hex %04x, Octal %o") (u8 "> %d, Hex %08x, Octal %o")), c, c, c)
                    (recur-if (< ci MAX_MCO) [(aget cc ci) (inc ci)])
                ))
            (msg buf)
        ))
    nil)

;; ":retab".

(defn- #_exarg_C ex-retab [#_exarg_C eap]
    (let-when [__ (atom (#_Bytes object (:arg eap))) #_int ts (getdigits __) eap (assoc eap :arg @__)] (<= 0 ts) => (do (emsg e_positive) eap)
        (let [ts (if (zero? ts) @(:b_p_ts @curbuf) ts)
              m { #_boolean :got_tab false, #_int :num_spaces 0, #_int :start_vcol 0, #_int :start_col 0, #_long :first_line 0, #_long :last_line 0 }
              m (loop-when [m m #_long lnum (:line1 eap)] (and (not @got_int) (<= lnum (:line2 eap))) => m
                    (let-when [[m abort]
                        (loop [m m #_Bytes s (ml-get lnum) x { #_int :vcol 0, #_int :col 0, #_boolean :did_undo false }]
                            (let [[m s x abort]
                                    (if (vim-iswhite (.at s (:col x)))
                                        (let [m (if (and (not (:got_tab m)) (zero? (:num_spaces m)))
                                                    ;; First consecutive white-space.
                                                    (assoc m :start_vcol (:vcol x) :start_col (:col x))
                                                    m)
                                              m (if (at? s (:col x) (byte \space))
                                                    (update m :num_spaces inc)
                                                    (assoc m :got_tab true)
                                                )]
                                            [m s x false])
                                        (let [[m s x abort] ;; Retabulate this string of white-space.
                                                (if (or (:got_tab m) (and (:forceit eap) (< 1 (:num_spaces m))))
                                                    ;; len is virtual length of white string
                                                    (let [#_int len (- (:vcol x) (:start_vcol m)) m (assoc m :num_spaces len)
                                                          [#_int num_tabs m]
                                                            (if (not @(:b_p_et @curbuf))
                                                                (let [#_int t' (- ts (% (:start_vcol m) ts)) ns (:num_spaces m)
                                                                      [ns num_tabs] (if (<= t' ns) [(- ns t') 1] [ns 0])]
                                                                    [(+ num_tabs (/ ns ts)) (assoc m :num_spaces (- ns (* (/ ns ts) ts)))])
                                                                [0 m]
                                                            )]
                                                        (if (or @(:b_p_et @curbuf) (:got_tab m) (< (+ num_tabs (:num_spaces m)) len))
                                                            (let-when [[x abort]
                                                                (if (not (:did_undo x))
                                                                    [(assoc x :did_undo true) (not (u-save (dec lnum), (inc lnum)))]
                                                                    [x false])
                                                            ] (not abort) => [m s x abort]
                                                                ;; len is actual number of white characters used
                                                                (let [len (+ num_tabs (:num_spaces m)) #_int old_len (STRLEN s)
                                                                      #_Bytes line (Bytes. (+ (- old_len (:col x)) (:start_col m) len 1))
                                                                      _ (when (< 0 (:start_col m))
                                                                            (BCOPY line, s, (:start_col m)))
                                                                      _ (BCOPY line, (+ (:start_col m) len), s, (:col x), (inc (- old_len (:col x))))
                                                                      s (.plus line (:start_col m))]
                                                                    (dotimes [i len]
                                                                        (.be s i, (if (< i num_tabs) TAB (byte \space))))
                                                                    (ml-replace lnum, line)
                                                                    (let [m (assoc m :first_line (if (zero? (:first_line m)) lnum (:first_line m)) :last_line lnum)
                                                                          x (assoc x :col (+ (:start_col m) len))]
                                                                        [m line x false]
                                                                    )
                                                                ))
                                                            [m s x false]
                                                        ))
                                                    [m s x false]
                                                )]
                                            [(assoc m :got_tab false :num_spaces 0) s x abort])
                                    )]
                                (if (or (eos? s (:col x)) abort)
                                    [m abort]
                                    (recur m s (assoc x :vcol (+ (:vcol x) (chartabsize s, (:col x), (:vcol x))) :col (+ (:col x) (us-ptr2len-cc s, (:col x)))))
                                )
                            ))
                    ] (not abort) => m
                        (slow-breakcheck)
                        (recur m (inc lnum))
                    )
                )]
            (when @got_int
                (emsg e_interr))
            (when (!= @(:b_p_ts @curbuf) ts)
                (redraw-curbuf-later NOT_VALID))
            (when (non-zero? (:first_line m))
                (changed-lines (:first_line m), 0, (inc (:last_line m)), 0))
            (reset! (:b_p_ts @curbuf) ts)
            (swap! curwin coladvance (:w_curswant @curwin))
            (u-clearline)
            eap)
    ))

;; Implementation of ":fixdel", also used by get-stty().
;;  <BS>    resulting <Del>
;;   ^?         ^H
;; not ^?       ^?

(defn- #_exarg_C ex-fixdel [#_exarg_C _eap]
    (let [#_Bytes code (find-termcode (u8 "kb"))]
        (add-termcode (u8 "kD"), (if (and (some? code) (at? code DEL)) CTRL_H_STR DEL_STR))
        _eap
    ))

(atom! Bytes old_sub)              ;; previous substitute pattern

(atom! boolean do__all)                 ;; do multiple substitutions per line
(atom! boolean do__count)               ;; count only
(atom! boolean do__error true)        ;; if false, ignore errors
(atom! int do__ic)                      ;; ignore case flag

;; Perform a substitution from line eap.line1 to line eap.line2 using
;; the command pointed to by eap.arg which should be of the form:
;;
;; /pattern/substitution/{flags}
;;
;; The usual escapes are supported as described in the regexp docs.

(defn- #_exarg_C ex-sub [#_exarg_C eap]
    (let-when [win @curwin o'cursor (:w_cursor win) o'line_count (line-count @curbuf)
          _ (reset! sub_nsubs 0) _ (reset! sub_nlines 0) o'sub_nsubs @sub_nsubs
          #_Bytes cmd (:arg eap) which? (if #_(== (:cmdidx eap) (ร CMD_tilde)) nil RE_LAST RE_SUBST) ;; use last used/substitute regexp

          [cmd which? #_Bytes pat #_Bytes sub eol? :as _]
            (cond (and (at? (:cmd eap) (byte \s)) (non-eos? cmd) (not (vim-iswhite (.at cmd 0))) (nil? (vim-strbyte (u8 "0123456789cegriIp|\""), (.at cmd 0))))
                (if (asc-isalpha (.at cmd 0)) ;; don't accept alphanumeric for separator
                    (do (emsg (u8 "E146: Regular expressions can't be delimited by letters"))
                        nil)
                    ;; Undocumented Vi feature:
                    ;; "\/sub/" and "\?sub?" use last used search pattern (almost like //sub/r).
                    ;; "\&sub&" use last substitute pattern (like //sub/).
                    (let-when [[which? #_byte delimiter pat cmd :as _]
                            (if (at? cmd (byte \\))
                                (let-when [cmd (.plus cmd 1)] (some? (vim-strbyte (u8 "/?&"), (.at cmd 0))) => (do (emsg e_backslash) nil)
                                    [(if (at? cmd (byte \&)) which? RE_SEARCH) (.at cmd 0) (u8 "") (.plus cmd 1)])
                                (let [delimiter (.at cmd 0) cmd (.plus cmd 1) pat cmd                                   ;; remember start of search pattern
                                      cmd (skip-regexp cmd, delimiter, @p_magic, nil)]                                  ;; find the end of the regexp
                                    [RE_LAST delimiter pat (if (at? cmd delimiter) (.plus (eos! cmd) 1) cmd)])          ;; replace it with a NUL
                            )] (some? _) => nil

                        ;; Small incompatibility: Vi sees '\n' as end of the command,
                        ;; but in Vim we want to use '\n' to find/substitute a NUL.
                        (let-when [sub cmd                                                                              ;; remember the start of the substitution
                              cmd (loop-when cmd (non-eos? cmd) => cmd
                                    (if (at? cmd delimiter)                                                             ;; end delimiter found
                                        (.plus (eos! cmd) 1)                                                            ;; replace it with a NUL
                                        (let [cmd (if (and (at? cmd (byte \\)) (non-eos? cmd 1)) (.plus cmd 1) cmd)]    ;; skip escaped characters
                                            (recur (.plus cmd (us-ptr2len-cc cmd))))
                                    ))
                              sub (cond (:skip eap)
                                    sub
                                ;; In POSIX vi ":s/pat/%/" uses the previous substitution string.
                                (and (zero? (STRCMP sub, (u8 "%"))) (some? (vim-strbyte @p_cpo, CPO_SUBPERCENT)))
                                    (if (nil? @old_sub)
                                        (do (emsg e_nopresub)
                                            nil)
                                        @old_sub)
                                :else
                                    (do (reset! old_sub (STRDUP sub))
                                        sub)
                                )] (some? sub) => nil

                            [cmd which? pat sub false])
                    ))
            (not (:skip eap))                   ;; use previous pattern and substitution
                (if (nil? @old_sub)
                    (do (emsg e_nopresub)
                        nil)
                    (let [pat nil sub @old_sub] ;; search-regcomp() will use previous pattern
                        ;; Vi compatibility quirk:
                        ;; repeating with ":s" keeps the cursor in the last column after using "$".
                        [cmd which? pat sub (== (:w_curswant win) MAXCOL)]
                    ))
            :else
                [cmd which? nil nil false])

    ] (some? _) => (do (reset! curwin win) eap)

        ;; Recognize ":%s/\n//" and turn it into a join command, which is much more efficient.
        (if (and (some? pat) (zero? (STRCMP pat, (u8 "\\n"))) (eos? sub) (or (eos? cmd) (and (at? cmd (byte \g)) (eos? cmd 1))))
            (let [win (assoc-in win [:w_cursor :lnum] (:line1 eap))
                  ;; The number of lines joined is the number of lines in the range plus one.
                  ;; One less when the last line is included.
                  n (inc (- (:line2 eap) (:line1 eap)))
                  n (if (< (:line2 eap) (line-count @curbuf)) (inc n) n)
                  win (if (< 1 n)
                        (let [win (do-join win, n, false, true, true)]
                            (reset! sub_nsubs (dec n))
                            (reset! sub_nlines 1)
                            (do-sub-msg false)
                            win)
                        win
                    )]
                (save-re-pat RE_SUBST, pat, @p_magic)
                (add-to-history HIST_SEARCH, pat, NUL)
                (do (reset! curwin win) eap))

            ;; Find trailing options.  When '&' is used, keep old options.
            (let-when [cmd (if (at? cmd (byte \&))
                        (.plus cmd 1)
                        (do (reset! do__all @p_gd) ;; default is global on
                            (reset! do__error true)
                            (reset! do__count false)
                            (reset! do__ic 0)
                            cmd
                        ))
                  [which? cmd]
                    (loop-when [which? which? cmd cmd] (non-eos? cmd) => [which? cmd]
                        ;; Note: 'g' and 'c' are always inverted; 'r' is never inverted.
                        (condp == (.at cmd 0)
                            (byte \g) (do (swap! do__all not)       (recur which? (.plus cmd 1)))
                            (byte \n) (do (reset! do__count true)   (recur which? (.plus cmd 1)))
                            (byte \e) (do (swap! do__error not)     (recur which? (.plus cmd 1)))
                            (byte \r)                               (recur RE_LAST (.plus cmd 1)) ;; use last used regexp
                            (byte \i) (do (reset! do__ic (byte \i)) (recur which? (.plus cmd 1))) ;; ignore case
                            (byte \I) (do (reset! do__ic (byte \I)) (recur which? (.plus cmd 1))) ;; don't ignore case
                            [which? cmd]
                        ))
                  ;; check for a trailing count
                  cmd (skipwhite cmd)
                  [eap cmd]
                    (if (asc-isdigit (.at cmd 0))
                        (let [[i cmd] (let [a'cmd (atom (#_Bytes object cmd))] [(getdigits a'cmd) @a'cmd])]
                            (if (and (<= i 0) (not (:skip eap)) @do__error)
                                (do (emsg e_zerocount)
                                    [eap nil])
                                (let [eap (assoc eap :line1 (:line2 eap))
                                      eap (update eap :line2 #(min (+ % (dec i)) (line-count @curbuf)))]
                                    [eap cmd])
                            ))
                        [eap cmd])

            ] (some? cmd) => (do (reset! curwin win) eap)

                ;; check for trailing command or garbage
                (let-when [cmd (skipwhite cmd)
                      [eap _]
                        (if (and (non-eos? cmd) (not-at? cmd (byte \"))) ;; if not end-of-line, nor comment """
                            (let [eap (assoc eap :nextcmd (check-nextcmd cmd))]
                                (if (nil? (:nextcmd eap))
                                    (do (emsg e_trailing)
                                        [eap nil])
                                    [eap :_]
                                ))
                            [eap :_])

                ] (some? _) => (do (reset! curwin win) eap)

                    (if (:skip eap) ;; not executing commands, only parsing
                        (do (reset! curwin win) eap)

                        (let-when [#_regmmatch_C regmatch (NEW_regmmatch_C)
                              regmatch
                                (if (not (search-regcomp pat, RE_SUBST, which?, SEARCH_HIS, regmatch))
                                    (do (when @do__error (emsg e_invcmd))
                                        nil)
                                    regmatch)

                        ] (some? regmatch) => (do (reset! curwin win) eap)

                            ;; the 'i' or 'I' flag overrules 'ignorecase' and 'smartcase'
                            (let [regmatch
                                    (condp == @do__ic
                                        (byte \i) (assoc regmatch :rmm_ic true)
                                        (byte \I) (assoc regmatch :rmm_ic false)
                                        regmatch)
                                  ;; ~ in the substitute pattern is replaced with the old pattern.
                                  ;; We do it here once to avoid it to be replaced over and over again.
                                  ;; But don't do it when it starts with "\=", then it's an expression.
                                  sub (if (not (and (at? sub (byte \\)) (at? sub 1 (byte \=)))) (regtilde sub, @p_magic) sub)

                                  a'first_line (atom (long 0))  ;; first changed line
                                  a'last_line (atom (long 0))   ;; below last changed line AFTER the change
                                  a'line2 (atom (long (:line2 eap)))
                                  a'got_match (atom (boolean false))
                                  ;; Check for a match on each line.
                                  win (loop-when [win win #_long lnum (:line1 eap)] (and (<= lnum @a'line2) (not @got_int)) => win
                                        (let [#_long nmatch (vim-regexec-multi regmatch, lnum, 0, nil) ;; number of lines in match
                                              [win lnum]
                                                (if (non-zero? nmatch)
                                                    ;; The new text is build up step by step, to avoid too much copying.
                                                    ;; There are these pieces:
                                                    ;;
                                                    ;; sub_firstline    The old text, unmodified.
                                                    ;; copycol          Column in the old text where we started looking for a match;
                                                    ;;                  from here old text still needs to be copied to the new text.
                                                    ;; matchcol         Column number of the old text where to look for the next match.
                                                    ;;                  It's just after the previous match or one further.
                                                    ;; prev_matchcol    Column just after the previous match (if any).
                                                    ;;                  Mostly equal to "matchcol", except for the first match
                                                    ;;                  and after skipping an empty match.
                                                    ;; regmatch.*pos    Where the pattern matched in the old text.
                                                    ;; new_start        The new text, all that has been produced so far.
                                                    ;; new_end          The new text, where to append new text.
                                                    ;;
                                                    ;; lnum             The line number where we found the start of the match.
                                                    ;;                  Can be below the line we searched when there is a \n
                                                    ;;                  before a \zs in the pattern.
                                                    ;; sub_firstlnum    The line number in the buffer where to look for a match.
                                                    ;;                  Can be different from "lnum" when the pattern or substitute
                                                    ;;                  string contains line breaks.
                                                    ;;
                                                    ;; Special situations:
                                                    ;; - When the substitute string contains a line break, the part up to the line
                                                    ;;   break is inserted in the text, but the copy of the original line is kept.
                                                    ;;   "sub_firstlnum" is adjusted for the inserted lines.
                                                    ;; - When the matched pattern contains a line break, the old line is taken from
                                                    ;;   the line at the end of the pattern.  The lines in the match are deleted
                                                    ;;   later, "sub_firstlnum" is adjusted accordingly.
                                                    ;;
                                                    ;; The new text is built up in new_start[].  It has some extra room to avoid
                                                    ;; using calloc()/free() too often.  new_start_len is the length of the allocated
                                                    ;; memory at new_start.
                                                    ;;
                                                    ;; Make a copy of the old line, so it won't be taken away when updating the screen
                                                    ;; or handling a multi-line match.  The "old_" pointers point into this copy.
                                                    (let [a'did_sub (atom (boolean false))
                                                          ;; At first match, remember current cursor position.
                                                          win (if (not @a'got_match)
                                                                (let [win (setpcmark win)] (reset! a'got_match true) win)
                                                                win)

                                                          l'sub_firstlnum (atom (long lnum))            ;; lnum of first sub line
                                                          l'sub_firstline (atom (#_Bytes object nil))   ;; allocated copy of first sub line

                                                          l'new_start (atom (#_Bytes object nil))
                                                          l'new_start_len (atom (int 0))
                                                          l'nmatch_tl (atom (long 0))                   ;; nr of lines matched below lnum
                                                          l'skip_match (atom (boolean false))

                                                          l'prev_matchcol (atom (int MAXCOL))
                                                          l'matchcol (atom (int 0))
                                                          l'copycol (atom (int 0))

                                                          ;; Loop until nothing more to replace in this line.
                                                          ;; 1. Handle match with empty string.
                                                          ;; 3. Substitute the string.
                                                          ;; 4. If do__all is set, find next match.
                                                          ;; 5. Break if there isn't another match in this line.
                                                          => [win lnum]
                                                    ]

                                                            (ยง loop [win win lnum lnum nmatch nmatch]
                                                                ;; Advance "lnum" to the line where the match starts.
                                                                ;; The match does not start in the first line when there is a line break before \zs.
                                                                (when (< 0 (:lnum (... (:startpos regmatch) 0)))
                                                                    ((ร lnum =) (+ lnum (:lnum (... (:startpos regmatch) 0))))
                                                                    ((ร @l'sub_firstlnum =) (+ @l'sub_firstlnum (:lnum (... (:startpos regmatch) 0))))
                                                                    ((ร nmatch =) (- nmatch (:lnum (... (:startpos regmatch) 0))))
                                                                    ((ร @l'sub_firstline =) nil)
                                                                )

                                                                ((ร @l'sub_firstline =) (if (nil? @l'sub_firstline) (STRDUP (ml-get @l'sub_firstlnum)) @l'sub_firstline))

                                                                ;; Save the line number of the last change for the final cursor position (just like Vi).
                                                                (swap! curwin assoc-in [:w_cursor :lnum] lnum)
                                                                ((ร boolean do_again =) false)               ;; do it again after joining lines

                                            ;                   skip:
                                            ;                   {
                                                                    ;; 1. Match empty string does not count, except for first match.
                                                                    ;; This reproduces the strange vi behaviour.
                                                                    ;; This also catches endless loops.

                                                                    (when (and (== @l'matchcol @l'prev_matchcol) (zero? (:lnum (... (:endpos regmatch) 0))) (== @l'matchcol (:col (... (:endpos regmatch) 0))))
                                                                        (cond (eos? @l'sub_firstline @l'matchcol)
                                                                        (do
                                                                            ;; We already were at the end of the line.
                                                                            ;; Don't look for a match in this line again.
                                                                            ((ร @l'skip_match =) true)
                                                                        )
                                                                        :else
                                                                        (do
                                                                            ;; search for a match at next column
                                                                            ((ร @l'matchcol =) (+ @l'matchcol (us-ptr2len-cc @l'sub_firstline, @l'matchcol)))
                                                                        ))
                                                                        (ร BREAK skip)
                                                                    )

                                                                    ;; Normally we continue searching for a match just after the previous match.
                                                                    ((ร @l'matchcol =) (:col (... (:endpos regmatch) 0)))
                                                                    ((ร @l'prev_matchcol =) @l'matchcol)

                                                                    ;; 2. If do__count is set only increase the counter.

                                                                    (when @do__count
                                                                        ;; For a multi-line match, put matchcol at the NUL at
                                                                        ;; the end of the line and set nmatch to one, so that
                                                                        ;; we continue looking for a match on the next line.
                                                                        ;; Avoids that ":s/\nB\@=//gc" get stuck.
                                                                        (when (< 1 nmatch)
                                                                            ((ร @l'matchcol =) (STRLEN @l'sub_firstline))
                                                                            ((ร nmatch =) 1)
                                                                            ((ร @l'skip_match =) true)
                                                                        )
                                                                        (swap! sub_nsubs inc)
                                                                        ((ร @a'did_sub =) true)
                                                                        ;; Skip the substitution, unless an expression is used,
                                                                        ;; then it is evaluated in the sandbox.
                                                                        (if (not (and (at? sub (byte \\)) (at? sub 1 (byte \=))))
                                                                            (ร BREAK skip)
                                                                        )
                                                                    )

                                                                    ;; Move the cursor to the start of the match, so that we can use "\=col(".").
                                                                    (swap! curwin assoc-in [:w_cursor :col] (:col (... (:startpos regmatch) 0)))

                                                                    ;; 3. substitute the string.

                                                                    ;; get length of substitution part
                                                                    ((ร int sublen =) (vim-regsub-multi regmatch, (- @l'sub_firstlnum (:lnum (... (:startpos regmatch) 0))), sub, @l'sub_firstline, false, @p_magic, true))

                                                                    (if @do__count
                                                                        (ร BREAK skip)
                                                                    )

                                                                    ;; When the match included the "$" of the last line it may
                                                                    ;; go beyond the last line of the buffer.
                                                                    (let-when [n' (inc (- (line-count @curbuf) @l'sub_firstlnum))] (< n' nmatch)
                                                                        ((ร nmatch =) n')
                                                                        ((ร @l'skip_match =) true)
                                                                    )

                                                                    ;; Need room for:
                                                                    ;; - result so far in "new_start" (not for first sub in line)
                                                                    ;; - original text up to match
                                                                    ;; - length of substituted part
                                                                    ;; - original text after match

                                                                    (ร Bytes p1)
                                                                    (cond (== nmatch 1)
                                                                    (do
                                                                        ((ร p1 =) @l'sub_firstline)
                                                                    )
                                                                    :else
                                                                    (do
                                                                        ((ร p1 =) (ml-get (dec (+ @l'sub_firstlnum nmatch))))
                                                                        ((ร @l'nmatch_tl =) (+ @l'nmatch_tl (dec nmatch)))
                                                                    ))
                                                                    ((ร int copy_len =) (- (:col (... (:startpos regmatch) 0)) @l'copycol))
                                                                    ((ร int needed_len =) (+ copy_len (- (STRLEN p1) (:col (... (:endpos regmatch) 0))) sublen 1))
                                                                    (ร Bytes new_end)
                                                                    (cond (nil? @l'new_start)
                                                                    (do
                                                                        ;; Get some space for a temporary buffer to do the substitution into
                                                                        ;; (and some extra space to avoid too many calls to calloc()/free()).

                                                                        ((ร @l'new_start_len =) (+ needed_len 50))
                                                                        ((ร @l'new_start =) (Bytes. @l'new_start_len))
                                                                        (eos! @l'new_start)
                                                                        ((ร new_end =) @l'new_start)
                                                                    )
                                                                    :else
                                                                    (do
                                                                        ;; Check if the temporary buffer is long enough to do the
                                                                        ;; substitution into.  If not, make it larger (with a bit
                                                                        ;; extra to avoid too many calls to calloc()/free()).

                                                                        ((ร int len =) (STRLEN @l'new_start))
                                                                        ((ร needed_len =) (+ needed_len len))
                                                                        (when (< @l'new_start_len needed_len)
                                                                            ((ร @l'new_start_len =) (+ needed_len 50))
                                                                            ((ร p1 =) (Bytes. @l'new_start_len))
                                                                            (BCOPY p1, @l'new_start, (inc len))
                                                                            ((ร @l'new_start =) p1)
                                                                        )
                                                                        ((ร new_end =) (.plus @l'new_start len))
                                                                    ))

                                                                    ;; copy the text up to the part that matched

                                                                    (BCOPY new_end, 0, @l'sub_firstline, @l'copycol, copy_len)
                                                                    ((ร new_end =) (.plus new_end copy_len))

                                                                    (vim-regsub-multi regmatch, (- @l'sub_firstlnum (:lnum (... (:startpos regmatch) 0))), sub, new_end, true, @p_magic, true)

                                                                    (swap! sub_nsubs inc)
                                                                    ((ร @a'did_sub =) true)

                                                                    ;; Move the cursor to the start of the line, to avoid that
                                                                    ;; it is beyond the end of the line after the substitution.
                                                                    (swap! curwin assoc-in [:w_cursor :col] 0)

                                                                    ;; For a multi-line match, make a copy of the last matched
                                                                    ;; line and continue in that one.
                                                                    (when (< 1 nmatch)
                                                                        ((ร @l'sub_firstlnum =) (+ @l'sub_firstlnum (dec nmatch)))
                                                                        ((ร @l'sub_firstline =) (STRDUP (ml-get @l'sub_firstlnum)))
                                                                        ;; When going beyond the last line, stop substituting.
                                                                        (if (<= @l'sub_firstlnum @a'line2)
                                                                            ((ร do_again =) true)
                                                                            (reset! do__all false))
                                                                    )

                                                                    ;; Remember next character to be copied.
                                                                    ((ร @l'copycol =) (:col (... (:endpos regmatch) 0)))

                                                                    (when @l'skip_match
                                                                        ;; Already hit end of the buffer,
                                                                        ;; sub_firstlnum is one less than what it ought to be.
                                                                        ((ร @l'sub_firstline =) (STRDUP (u8 "")))
                                                                        ((ร @l'copycol =) 0)
                                                                    )

                                                                    ;; Now the trick is to replace CTRL-M chars with a real line break.
                                                                    ;; This would make it impossible to insert a CTRL-M in the text.
                                                                    ;; The line break can be avoided by preceding the CTRL-M with a backslash.
                                                                    ;; To be able to insert a backslash, they must be doubled in the string
                                                                    ;; and are halved here.
                                                                    ;; That is Vi compatible.

                                                                    ((ร p1 =) (loop-when-recur [p1 new_end] (non-eos? p1) [(.plus p1 1)] => p1
                                                                        (cond (and (at? p1 (byte \\)) (non-eos? p1 1))  ;; remove backslash
                                                                        (do
                                                                            (BCOPY p1, 0, p1, 1, (inc (STRLEN p1, 1)))
                                                                        )
                                                                        (at? p1 CAR)
                                                                        (do
                                                                            (when (u-inssub lnum)     ;; prepare for undo
                                                                                (eos! p1)                  ;; truncate up to the CR
                                                                                (ml-append (dec lnum), @l'new_start)
                                                                                (mark-adjust (inc lnum), MAXLNUM, 1, 0)

                                                                                ((ร @a'first_line =) (if (zero? @a'first_line) lnum @a'first_line))
                                                                                ((ร @a'last_line =) (inc lnum))

                                                                                ;; All line numbers increase.
                                                                                ((ร @l'sub_firstlnum =) (inc @l'sub_firstlnum))
                                                                                ((ร lnum =) (inc lnum))
                                                                                ((ร @a'line2 =) (inc @a'line2))
                                                                                ;; move the cursor to the new line, like Vi
                                                                                (swap! curwin update-in [:w_cursor :lnum] inc)
                                                                                ;; copy the rest
                                                                                (BCOPY @l'new_start, 0, p1, 1, (inc (STRLEN p1, 1)))
                                                                                ((ร p1 =) (.minus @l'new_start 1))
                                                                            )
                                                                        )
                                                                        :else
                                                                        (do
                                                                            ((ร p1 =) (.plus p1 (dec (us-ptr2len-cc p1))))
                                                                        ))
                                                                    ))
                                            ;                   }

                                                                ;; 4. If do__all is set, find next match.
                                                                ;; Prevent endless loop with patterns that match empty
                                                                ;; strings, e.g. :s/$/pat/g or :s/[a-z]* /(&)/g.
                                                                ;; But ":s/\n/#/" is OK.

                                                                ;; We already know that we did the last subst when we are at the end of the line,
                                                                ;; except that a pattern like "bar\|\nfoo" may match at the NUL.
                                                                ;; "lnum" can be below "line2" when there is a \zs in the pattern after a line break.

                                                                ((ร boolean lastone =) (or @l'skip_match @got_int (< @a'line2 lnum) (not (or @do__all do_again)) (and (eos? @l'sub_firstline @l'matchcol) (<= nmatch 1) (not (re-multiline (:regprog regmatch))))))
                                                                ((ร nmatch =) -1)

                                                                ;; Replace the line in the buffer when needed.
                                                                ;; This is skipped when there are more matches.
                                                                ;; The check for nmatch_tl is needed for when multi-line matching must replace
                                                                ;; the lines before trying to do another match, otherwise "\@<=" won't work.
                                                                ;; When the match starts below where we start searching
                                                                ;; also need to replace the line first (using \zs after \n).

                                                                (when (or lastone (< 0 @l'nmatch_tl) (zero? ((ร nmatch =) (vim-regexec-multi regmatch, @l'sub_firstlnum, @l'matchcol, nil))) (< 0 (:lnum (... (:startpos regmatch) 0))))
                                                                    (when (some? @l'new_start)
                                                                        ;; Copy the rest of the line, that didn't match.
                                                                        ;; "matchcol" has to be adjusted, we use the end of the line as reference,
                                                                        ;; because the substitute may have changed the number of characters.
                                                                        ;; Same for "prev_matchcol".

                                                                        (STRCAT @l'new_start, (.plus @l'sub_firstline @l'copycol))
                                                                        ((ร @l'matchcol =) (- (STRLEN @l'sub_firstline) @l'matchcol))
                                                                        ((ร @l'prev_matchcol =) (- (STRLEN @l'sub_firstline) @l'prev_matchcol))

                                                                        (if (!= (u-savesub lnum) true)
                                                                            (ร BREAK)
                                                                        )
                                                                        (ml-replace lnum, @l'new_start)

                                                                        (when (< 0 @l'nmatch_tl)
                                                                            ;; Matched lines have now been substituted and are useless, delete them.
                                                                            ;; The part after the match has been appended to "new_start", we don't need
                                                                            ;; it in the buffer.

                                                                            ((ร lnum =) (inc lnum))
                                                                            (if (not (u-savedel lnum, @l'nmatch_tl))
                                                                                (ร BREAK)
                                                                            )
                                                                            (dotimes [_ @l'nmatch_tl]
                                                                                (ml-delete lnum, false)
                                                                            )
                                                                            (mark-adjust lnum, (dec (+ lnum @l'nmatch_tl)), MAXLNUM, (- @l'nmatch_tl))
                                                                            ((ร lnum =) (dec lnum))
                                                                            ((ร @a'line2 =) (- @a'line2 @l'nmatch_tl)) ;; nr of lines decreases
                                                                            ((ร @l'nmatch_tl =) 0)
                                                                        )

                                                                        ((ร @a'first_line =) (if (zero? @a'first_line) lnum @a'first_line))
                                                                        ((ร @a'last_line =) (inc lnum))

                                                                        ((ร @l'sub_firstlnum =) lnum)
                                                                        ((ร @l'sub_firstline =) @l'new_start)
                                                                        ((ร @l'new_start =) nil)
                                                                        ((ร @l'matchcol =) (- (STRLEN @l'sub_firstline) @l'matchcol))
                                                                        ((ร @l'prev_matchcol =) (- (STRLEN @l'sub_firstline) @l'prev_matchcol))
                                                                        ((ร @l'copycol =) 0)
                                                                    )
                                                                    ((ร nmatch =) (if (and (== nmatch -1) (not lastone)) (vim-regexec-multi regmatch, @l'sub_firstlnum, @l'matchcol, nil) nmatch))

                                                                    ;; 5. break if there isn't another match in this line

                                                                    (when (<= nmatch 0)
                                                                        ;; If the match found didn't start where we were
                                                                        ;; searching, do the next search in the line where we
                                                                        ;; found the match.
                                                                        ((ร lnum =) (if (== nmatch -1) (- lnum (:lnum (... (:startpos regmatch) 0))) lnum))
                                                                        (ร BREAK)
                                                                    )
                                                                )

                                                                (slow-breakcheck)
                                                                (recur win lnum nmatch)
                                                            )

                                                        (when @a'did_sub
                                                            (swap! sub_nlines inc))
                                                        [win lnum])
                                                    [win lnum]
                                                )]
                                            (slow-breakcheck)
                                            (recur win (inc lnum))
                                        )
                                    )]
                                (when (non-zero? @a'first_line)
                                    ;; Need to subtract the number of added lines from "last_line" to get the line number
                                    ;; before the change (same as adding the number of deleted lines).
                                    (let [n (- (line-count @curbuf) o'line_count)]
                                        (changed-lines @a'first_line, 0, (- @a'last_line n), n)
                                    ))
                                ;; ":s/pat//n" doesn't move the cursor
                                (let [win (if @do__count (assoc win :w_cursor o'cursor) win)
                                      win (if (< o'sub_nsubs @sub_nsubs)
                                            ;; Set the '[ and '] marks.
                                            (let [_ (swap! curbuf update :b_op_start assoc :lnum (:line1 eap) :col 0)
                                                  _ (swap! curbuf update :b_op_end assoc :lnum @a'line2 :col 0)
                                                  win (if eol?
                                                        (coladvance win, MAXCOL)
                                                        (beginline win, (| BL_WHITE BL_FIX))
                                                    )]
                                                (do-sub-msg @do__count)
                                                win)
                                            (do (cond
                                                    @got_int     (emsg e_interr)                       ;; interrupted
                                                    @a'got_match (msg (u8 ""))                         ;; found something, but nothing substituted
                                                    @do__error   (emsg2 e_patnotf2, (get-search-pat))) ;; nothing found
                                                win)
                                        )]
                                    (do (reset! curwin win) eap))
                            ))
                    ))
            ))
    ))

;; Give message for number of substitutions.
;; Return true if a message was given.

(defn- #_boolean do-sub-msg [#_boolean count_only] ;; count_only: used 'n' flag for ":s"
    ;; Only report substitutions when:
    ;; - more than 'report' substitutions
    ;; - command was typed by user, or number of changed lines > 'report'
    ;; - giving messages is not disabled by 'lazyredraw'
    (cond (and (or (and (< @p_report @sub_nsubs) (or @keyTyped (< 1 @sub_nlines) (< @p_report 1))) count_only) (messaging))
        (let [#_Bytes buf (Bytes. MSG_BUF_LEN)]
            (if @got_int
                (STRCPY buf, (u8 "(Interrupted) "))
                (eos! buf)
            )
            (ยง if (== @sub_nsubs 1)
                (vim_snprintf_add buf, MSG_BUF_LEN, (u8 "%s"), (if count_only (u8 "1 match") (u8 "1 substitution")))
                (vim_snprintf_add buf, MSG_BUF_LEN, (if count_only (u8 "%ld matches") (u8 "%ld substitutions")), @sub_nsubs)
            )
            (ยง if (== @sub_nlines 1)
                (vim_snprintf_add buf, MSG_BUF_LEN, (u8 "%s"), (u8 " on 1 line"))
                (vim_snprintf_add buf, MSG_BUF_LEN, (u8 " on %ld lines"), @sub_nlines)
            )
            (when (msg buf) (set-keep-msg buf, 0)) ;; save message to display it after redraw
            true)
    @got_int
        (do (emsg e_interr) true)
    :else
        false
    ))

;; ex_getln.c: Functions for entering and editing an Ex command line ------------------------------

;; Variables shared between getcmdline(), redrawcmdline() and others.
;; These need to be saved when using CTRL-R |, that's why they are in a structure.

(class! #_final cmdline_info_C
    [
        (field Bytes        cmdbuff)        ;; pointer to command line buffer
        (field int          cmdbufflen)     ;; length of "cmdbuff"
        (field int          cmdlen)         ;; number of chars in command line
        (field int          cmdpos)         ;; current cursor position
        (field int          cmdspos)        ;; cursor column on screen
        (field int          cmdfirstc)      ;; ':', '/', '?', '=' or NUL
        (field int          cmdindent)      ;; number of spaces before cmdline
        (field Bytes        cmdprompt)      ;; message in front of cmdline
        (field int          cmdattr)        ;; attributes for prompt
        (field boolean      overstrike)     ;; Typing mode on the command line.  Shared by getcmdline() and put-on-cmdline().
    ])

;; The current cmdline_info.
;; Initialized in getcmdline() then used by other functions.
;; When invoking getcmdline() recursively, it needs to be saved
;; with save-cmdline() and restored with restore-cmdline().
;; TODO: make it local to getcmdline() and pass it around.

(atom! cmdline_info_C ccline (NEW_cmdline_info_C))

(atom! int new_cmdpos)  ;; position set by set_cmdline_pos()

(class! #_final histentry_C
    [
        (field int      hisnum)     ;; identifying number
        (field Bytes    hisstr)     ;; actual entry, separator char after the NUL
    ])

(defn- #_void COPY-histentry [#_histentry_C he1, #_histentry_C he0]
    (ยง
        ((ร he1.hisnum =) (:hisnum he0))
        ((ร he1.hisstr =) (:hisstr he0))
        nil
    ))

(defn- #_histentry_C* ARRAY-histentry [#_int n]
    (vec (repeatedly n NEW_histentry_C)))

(atom! histentry_C**    history     HIST_COUNT)
(atom! int*             hisidx      (repeat HIST_COUNT -1))     ;; last used entry
;; identifying (unique) number of newest history entry
(atom! int*             hisnum      HIST_COUNT)
(atom! int              hislen)                                 ;; actual length of history tables

;; getcmdline() - accept a command line starting with firstc.
;;
;; firstc == ':'            get ":" command line
;; firstc == '/' or '?'     get search pattern
;; firstc == '='            get expression
;; firstc == '@'            get text for input() function
;; firstc == '>'            get text for debug mode
;; firstc == NUL            get text for :insert command
;; firstc == -1             like NUL, and break on CTRL-C
;;
;; The line is collected in ccline.cmdbuff, which is reallocated to fit the command line.
;;
;; Careful: getcmdline() can be called recursively!
;;
;; Everything that may work recursively should save and restore the current command line.
;; That includes update-screen(), a custom status line may invoke ":normal".
;;
;; Return pointer to allocated string if there is a command line, null otherwise.

(defn- #_Bytes getcmdline [#_int firstc, #_long count]
    ;; count: only used for incremental search
    (ยง
        ((ร int save_State =) @State)                 ;; remember State when called
        ((ร boolean save_msg_scroll =) @msg_scroll)

        ((ร boolean break_ctrl_c =) (== firstc -1))
        ((ร firstc =) (if break_ctrl_c NUL firstc))

        ((ร pos_C old_cursor =) (:w_cursor @curwin))      ;; needs to be restored later
        ((ร int old_curswant =) (:w_curswant @curwin))
        ((ร int old_leftcol =) (:w_leftcol @curwin))
        ((ร long old_topline =) (:w_topline @curwin))
        ((ร long old_botline =) (:w_botline @curwin))

        (swap! ccline assoc :overstrike false)                  ;; always start in insert mode

        ;; set some variables for redrawcmd()
        (swap! ccline assoc :cmdfirstc (if (== firstc (byte \@)) 0 firstc) :cmdindent 0)

        ;; alloc initial ccline.cmdbuff
        (alloc-cmdbuff 1)
        (swap! ccline assoc :cmdpos 0 :cmdlen 0)
        (eos! (:cmdbuff @ccline))

        ;; autoindent for :insert and :append
        (when (<= firstc 0)
;           (copy-chars (:cmdbuff @ccline), 0, 0, (byte \space));
            (eos! (:cmdbuff @ccline))
            (swap! ccline assoc :cmdpos 0 :cmdspos 0 :cmdlen 0)
        )

;       {
            ((ร int i =) @msg_scrolled)
            (reset! msg_scrolled 0)               ;; avoid wait-return message
            (gotocmdline true)
            (swap! msg_scrolled + i)
            (redrawcmdprompt)
            (set-cmdspos)
;       }

        ;; Avoid scrolling when called by a recursive do-cmdline(),
        ;; e.g. when doing ":@0" when register 0 doesn't contain a CR.

        (reset! msg_scroll false)

        (reset! State CMDLINE)

        (ui-cursor-shape)          ;; may show different cursor shape

        ;; When inside an autocommand for writing "exiting" may be set and terminal mode set to cooked.
        ;; Need to set raw mode here then.
        (settmode TMODE_RAW)

        (init-history)
        ((ร int hiscnt =) @hislen)        ;; current history line in use; set to impossible history value
        ((ร int histype =) (hist-char2type firstc))   ;; history type to be used

        (do-digraph -1)             ;; init digraph typeahead

        ;; If something above caused an error, reset the flags, we do want to type and execute commands.
        ;; Display may be messed up a bit.
        (if @did_emsg
            (redrawcmd))
        (reset! did_emsg false)
        (reset! got_int false)

        ((ร boolean gotesc =) false)                 ;; true when <ESC> just typed
        ((ร Bytes lookfor =) nil)                  ;; string to match
        ((ร boolean did_incsearch =) false)
        ((ร boolean incsearch_postponed =) false)
        ((ร boolean some_key_typed =) false)         ;; one of the keys was typed

        ;; Collect the command string, handling editing keys.

;       returncmd:
        (loop []
            (reset! quit_more false)  ;; reset after CTRL-D which had a more-prompt

            (cursorcmd)        ;; set the cursor on the right spot

            ;; Get a character.
            ;; Ignore K_IGNORE, it should not do anything, such as stop completion.
            ((ร int c =) (loop-when-recur [c (safe-vgetc)] (== c K_IGNORE) [(safe-vgetc)] => c))

            ((ร some_key_typed =) (or @keyTyped some_key_typed))

            ;; Ignore got_int when CTRL-C was typed here.
            ;; Don't ignore it in :global, we really need to break then,
            ;; e.g. for ":g/pat/normal /pat" (without the <CR>).
            ;; Don't ignore it for the input() function.

            (when (and (any == c Ctrl_C @intr_char) (!= firstc (byte \@)) (not break_ctrl_c))
                (reset! got_int false))

            ;; free old command line when finished moving around in the history list
            ((ร lookfor =) (if (or (nil? lookfor) (any == c K_S_DOWN K_S_UP K_DOWN K_UP K_PAGEDOWN K_PAGEUP K_KPAGEDOWN K_KPAGEUP K_LEFT K_RIGHT Ctrl_P Ctrl_N)) lookfor))

;           cmdline_changed:
;           {
;               cmdline_not_changed:
;               {
                    ;; CTRL-\ CTRL-N goes to Normal mode,
                    ;; CTRL-\ CTRL-G goes to Insert mode when 'insertmode' is set,
                    ;; CTRL-\ e prompts for an expression.
                    (when (== c Ctrl_BSL)
                        (swap! no_mapping inc)
                        (swap! allow_keys inc)
                        ((ร c =) (plain-vgetc))
                        (swap! no_mapping dec)
                        (swap! allow_keys dec)
                        ;; CTRL-\ e doesn't work when obtaining an expression, unless it is in a mapping.
                        (cond (and (!= c Ctrl_N) (!= c Ctrl_G) (or (!= c (byte \e)) (and (== (:cmdfirstc @ccline) (byte \=)) @keyTyped)))
                        (do
                            (vungetc c)
                            ((ร c =) Ctrl_BSL)
                        )
                        (== c (byte \e))
                        (do
                            ;; Replace the command line with the result of an expression.
                            ;; Need to save and restore the current command line, to be able to enter a new one...

                            (reset! new_cmdpos (if (== (:cmdpos @ccline) (:cmdlen @ccline)) 99999 (:cmdpos @ccline))) ;; 99999: keep it at the end

                            ((ร cmdline_info_C save_cli =) (save-cmdline))
                            ((ร c =) (get-expr-register))
                            (restore-cmdline save_cli)

                            (when (== c (byte \=))
                                ;; Need to save and restore ccline, and set "textlock" to avoid nasty things
                                ;; like going to another buffer when evaluating an expression.
                                ((ร cmdline_info_C save_cli =) (save-cmdline))
                                (swap! textlock inc)
                                ((ร Bytes p =) (get-expr-line))
                                (swap! textlock dec)
                                (restore-cmdline save_cli)

                                (when (some? p)
                                    ((ร int len =) (STRLEN p))
                                    (realloc-cmdbuff (inc len))

                                    (swap! ccline assoc :cmdlen len)
                                    (STRCPY (:cmdbuff @ccline), p)

                                    ;; Restore the cursor or use the position set with set_cmdline_pos().
                                    (swap! ccline assoc :cmdpos (min @new_cmdpos (:cmdlen @ccline)))

                                    (reset! keyTyped false)   ;; Don't do 'wildchar' completion.
                                    (redrawcmd)
                                    (ร BREAK cmdline_changed)
                                )
                            )

                            (beep-flush)
                            (reset! got_int false)        ;; don't abandon the command line
                            (reset! did_emsg false)
                            (reset! emsg_on_display false)
                            (redrawcmd)
                            (ร BREAK cmdline_not_changed)
                        )
                        :else
                        (do
                            (if (and (== c Ctrl_G) @p_im (zero? @restart_edit))
                                (reset! restart_edit (byte \a)))
                            ((ร gotesc =) true)          ;; will free ccline.cmdbuff after putting it in history
                            (ร BREAK returncmd)        ;; back to Normal mode
                        ))
                    )

                    (cond (any == c @cedit_key K_CMDWIN)
                    (do
                        (when (not @got_int)
                            ;; Open a window to edit the command line (and history).
                            ((ร c =) (ex-window))
                            ((ร some_key_typed =) true)
                        )
                    )
                    :else
                    (do
                        ((ร c =) (do-digraph c))
                    ))

                    (when (or (any == c (byte \newline) (byte \return) K_KENTER) (and (== c ESC) (or (not @keyTyped) (some? (vim-strbyte @p_cpo, CPO_ESC)))))
                        ((ร gotesc =) false)                     ;; Might have typed ESC previously, don't truncate the cmdline now.
                        (windgoto @msg_row, 0)
                        (out-flush)
                        (ร BREAK)
                    )

                    ((ร gotesc =) false)

                    ((ร c =) (if (any == c NUL K_ZERO) NL c))        ;; NUL is stored as NL

                    ((ร boolean do_abbr =) true)             ;; default: check for abbreviation

                    ;; Big switch for a typed command line character.

                    (condp ==? c
                       [K_BS Ctrl_H K_DEL K_KDEL Ctrl_W]
                        (do
                            ((ร c =) (if (== c K_KDEL) K_DEL c))

                            ;; Delete current character is the same as backspace on next character, except at end of line.

                            (when (and (== c K_DEL) (!= (:cmdpos @ccline) (:cmdlen @ccline)))
                                (swap! ccline update :cmdpos inc))
                            (when (== c K_DEL)
                                (swap! ccline update :cmdpos #(+ % (us-off-next (:cmdbuff @ccline), (.plus (:cmdbuff @ccline) %)))))
                            (cond (< 0 (:cmdpos @ccline))
                            (do
                                ((ร int j =) (:cmdpos @ccline))
                                ((ร Bytes p =) (us-prevptr (:cmdbuff @ccline), (.plus (:cmdbuff @ccline) j)))

                                (when (== c Ctrl_W)
                                    ((ร p =) (loop-when-recur p (and (BLT (:cmdbuff @ccline), p) (vim-isspace (.at p 0))) (us-prevptr (:cmdbuff @ccline), p) => p))
                                    ((ร int cls =) (us-get-class p))
                                    ((ร p =) (loop-when-recur p (and (BLT (:cmdbuff @ccline), p) (== (us-get-class p) cls)) (us-prevptr (:cmdbuff @ccline), p) => p))
                                    ((ร p =) (if (!= (us-get-class p) cls) (.plus p (us-ptr2len-cc p)) p))
                                )

                                (swap! ccline assoc :cmdpos (BDIFF p, (:cmdbuff @ccline)))
                                (swap! ccline update :cmdlen - (- j (:cmdpos @ccline)))
                                (loop-when-recur [#_int i (:cmdpos @ccline) j j] (< i (:cmdlen @ccline)) [(inc i) (inc j)]
                                    (.be (:cmdbuff @ccline) i, (.at (:cmdbuff @ccline) j))
                                )
                                ;; Truncate at the end, required for multi-byte chars.
                                (eos! (:cmdbuff @ccline) (:cmdlen @ccline))
                                (redrawcmd)
                            )
                            (and (zero? (:cmdlen @ccline)) (!= c Ctrl_W) (nil? (:cmdprompt @ccline)))
                            (do
                                (swap! ccline assoc :cmdbuff nil)     ;; no commandline to return

                                (reset! msg_col 0)
                                (msg-putchar (byte \space))           ;; delete ':'

                                (reset! redraw_cmdline true)
                                (ร BREAK returncmd)            ;; back to cmd mode
                            ))
                            (ร BREAK cmdline_changed)
                        )

                       [K_INS K_KINS]
                        (do
                            (swap! ccline update :overstrike not)
                            (ui-cursor-shape)              ;; may show different cursor shape
                            (ร BREAK cmdline_not_changed)
                        )

                        Ctrl_HAT
                        (do
                            (ร BREAK cmdline_not_changed)
                        )

                        Ctrl_U
                        (do
                            ;; delete all characters left of the cursor
                            ((ร int i =) 0)
                            ((ร int j =) (:cmdpos @ccline))
                            (swap! ccline assoc :cmdpos i)
                            (swap! ccline update :cmdlen - j)
                            ((ร int n =) (:cmdlen @ccline))
                            (loop-when-recur [i i j j] (< i n) [(inc i) (inc j)]
                                (.be (:cmdbuff @ccline) i, (.at (:cmdbuff @ccline) j))
                            )
                            ;; Truncate at the end, required for multi-byte chars.
                            (eos! (:cmdbuff @ccline) n)
                            (redrawcmd)
                            (ร BREAK cmdline_changed)
                        )

                       [ESC Ctrl_C]       ;; get here when ESC typed twice
                        (do
                            ((ร gotesc =) true)              ;; will free ccline.cmdbuff after putting it in history
                            (ร BREAK returncmd)            ;; back to cmd mode
                        )

                        Ctrl_R                    ;; insert register
                        (do
                            (putcmdline (byte \"), true)    ;; """
                            (swap! no_mapping inc)
                            ((ร int k =) ((ร c =) (plain-vgetc)))  ;; CTRL-R <char>
                            ((ร k =) (if (== k Ctrl_O) Ctrl_R k))             ;; CTRL-R CTRL-O == CTRL-R CTRL-R
                            ((ร c =) (if (== k Ctrl_R) (plain-vgetc) c))      ;; CTRL-R CTRL-R <char>
                            (swap! no_mapping dec)

                            ;; Insert the result of an expression.
                            ;; Need to save the current command line, to be able to enter a new one...

                            (reset! new_cmdpos -1)
                            (when (== c (byte \=))
                                (cond (== (:cmdfirstc @ccline) (byte \=))    ;; can't do this recursively
                                (do
                                    (beep-flush)
                                    ((ร c =) ESC)
                                )
                                :else
                                (do
                                    ((ร cmdline_info_C save_cli =) (save-cmdline))
                                    ((ร c =) (get-expr-register))
                                    (restore-cmdline save_cli)
                                ))
                            )
                            (when (!= c ESC)               ;; use ESC to cancel inserting register
                                (cmdline-paste c, (== k Ctrl_R), false)

                                ;; When there was a serious error abort getting the command line.
                                (when @got_int
                                    ((ร gotesc =) true)      ;; will free ccline.cmdbuff after putting it in history
                                    (ร BREAK returncmd)    ;; back to cmd mode
                                )
                                (reset! keyTyped false)       ;; Don't do 'wildchar' completion.
                                (when (<= 0 @new_cmdpos)
                                    ;; set_cmdline_pos() was used
                                    (swap! ccline assoc :cmdpos (min @new_cmdpos (:cmdlen @ccline)))
                                )
                            )
                            (redrawcmd)
                            (ร BREAK cmdline_changed)
                        )

                       [K_RIGHT K_S_RIGHT K_C_RIGHT]
                        (do
                            (loop-when [] (< (:cmdpos @ccline) (:cmdlen @ccline))
                                ((ร int n =) (cmdline-charsize (:cmdpos @ccline)))
                                (if (and @keyTyped (<= (* @Cols @Rows) (+ (:cmdspos @ccline) n)))
                                    (ร BREAK)
                                )
                                (swap! ccline update :cmdspos + n)
                                (swap! ccline update :cmdpos #(+ % (us-ptr2len-cc (:cmdbuff @ccline), %)))
                                (recur-if (and (or (== c K_S_RIGHT) (== c K_C_RIGHT) (flag? @mod_mask (| MOD_MASK_SHIFT MOD_MASK_CTRL))) (not-at? (:cmdbuff @ccline) (:cmdpos @ccline) (byte \space))) [])
                            )
                            (set-cmdspos-cursor)
                            (ร BREAK cmdline_not_changed)
                        )

                       [K_LEFT K_S_LEFT K_C_LEFT]
                        (do
                            (if (zero? (:cmdpos @ccline))
                                (ร BREAK cmdline_not_changed)
                            )
                            (loop []
                                (swap! ccline update :cmdpos dec)
                                ;; move to first byte of char
                                (swap! ccline update :cmdpos #(- % (us-head-off (:cmdbuff @ccline), (.plus (:cmdbuff @ccline) %))))
                                (swap! ccline update :cmdspos - (cmdline-charsize (:cmdpos @ccline)))
                                (recur-if (and (< 0 (:cmdpos @ccline)) (or (== c K_S_LEFT) (== c K_C_LEFT) (flag? @mod_mask (| MOD_MASK_SHIFT MOD_MASK_CTRL))) (not-at? (:cmdbuff @ccline) (dec (:cmdpos @ccline)) (byte \space))) [])
                            )
                            (set-cmdspos-cursor)
                            (ร BREAK cmdline_not_changed)
                        )

                        K_IGNORE
                        (do
                            (ร BREAK cmdline_not_changed)          ;; Ignore mouse event or ex-window() result.
                        )

                        K_DROP
                        (do
                            (cmdline-paste (byte \~), true, false)
                            (redrawcmd)
                            (ร BREAK cmdline_changed)
                        )

                        K_SELECT      ;; end of Select mode mapping - ignore
                        (do
                            (ร BREAK cmdline_not_changed)
                        )

                       [Ctrl_B K_HOME K_KHOME K_S_HOME K_C_HOME]        ;; begin of command line
                        (do
                            (swap! ccline assoc :cmdpos 0)
                            (set-cmdspos)
                            (ร BREAK cmdline_not_changed)
                        )

                       [Ctrl_E K_END K_KEND K_S_END K_C_END]        ;; end of command line
                        (do
                            (swap! ccline assoc :cmdpos (:cmdlen @ccline))
                            (set-cmdspos-cursor)
                            (ร BREAK cmdline_not_changed)
                        )

                        Ctrl_L
                        (do
                            (when (and @p_is (any == firstc (byte \/) (byte \?)))
                                ;; Add a character from under the cursor for 'incsearch'.
                                (when (and did_incsearch (not (eqpos (:w_cursor @curwin), old_cursor)))
                                    ((ร c =) (gchar-cursor @curwin))
                                    ;; If 'ignorecase' and 'smartcase' are set and the command line
                                    ;; has no uppercase characters, convert the character to lowercase.
                                    ((ร c =) (if (and @p_ic @p_scs (not (pat-has-uppercase (:cmdbuff @ccline)))) (utf-tolower c) c))
                                    (when (!= c NUL)
                                        (when (or (== c firstc) (!= (vim-strchr (if @p_magic (u8 "\\^$.*[") (u8 "\\^$")), c) nil))
                                            ;; put a backslash before special characters
                                            (stuff-char c)
                                            ((ร c =) (byte \\))
                                        )
                                        (ร BREAK)
                                    )
                                )
                                (ร BREAK cmdline_not_changed)
                            )

                            (ร BREAK)
                        )

                       [Ctrl_P K_UP   K_S_UP   K_PAGEUP   K_KPAGEUP     ;; previous match
                        Ctrl_N K_DOWN K_S_DOWN K_PAGEDOWN K_KPAGEDOWN]  ;; next match
                        (do
                            (if (or (zero? @hislen) (== firstc NUL))    ;; no history
                                (ร BREAK cmdline_not_changed)
                            )

                            ((ร int i =) hiscnt)

                            ;; save current command string so it can be restored later
                            (when (nil? lookfor)
                                ((ร lookfor =) (STRDUP (:cmdbuff @ccline)))
                                (if (nil? lookfor)
                                    (ร BREAK cmdline_not_changed)
                                )
                                (eos! lookfor (:cmdpos @ccline))
                            )

                            (loop []
                                ;; one step backwards
                                (cond (any == c K_UP K_S_UP Ctrl_P K_PAGEUP K_KPAGEUP)
                                (do
                                    (cond (== hiscnt @hislen)   ;; first time
                                    (do
                                        ((ร hiscnt =) (... @hisidx histype))
                                    )
                                    (and (zero? hiscnt) (!= (... @hisidx histype) (dec @hislen)))
                                    (do
                                        ((ร hiscnt =) (dec @hislen))
                                    )
                                    (!= hiscnt (inc (... @hisidx histype)))
                                    (do
                                        ((ร hiscnt =) (dec hiscnt))
                                    )
                                    :else                    ;; at top of list
                                    (do
                                        ((ร hiscnt =) i)
                                        (ร BREAK)
                                    ))
                                )
                                :else    ;; one step forwards
                                (do
                                    ;; on last entry, clear the line
                                    (when (== hiscnt (... @hisidx histype))
                                        ((ร hiscnt =) @hislen)
                                        (ร BREAK)
                                    )

                                    ;; not on a history line, nothing to do
                                    (if (== hiscnt @hislen)
                                        (ร BREAK)
                                    )
                                    ((ร hiscnt =) (if (== hiscnt (dec @hislen)) 0 (inc hiscnt)))   ;; wrap around
                                ))
                                (when (or (< hiscnt 0) (nil? (:hisstr (... (... @history histype) hiscnt))))
                                    ((ร hiscnt =) i)
                                    (ร BREAK)
                                )
                                (when (or (and (!= c K_UP) (!= c K_DOWN)) (== hiscnt i) (zero? (STRNCMP (:hisstr (... (... @history histype) hiscnt)), lookfor, (STRLEN lookfor))))
                                    (ร BREAK)
                                )
                                (recur)
                            )

                            (when (!= hiscnt i)        ;; jumped to other entry
                                (swap! ccline assoc :cmdbuff nil)

                                ((ร Bytes p =) (if (== hiscnt @hislen)
                                    lookfor    ;; back to the old one
                                    (:hisstr (... (... @history histype) hiscnt))
                                ))

                                (ร int old_firstc)
                                (cond (and (== histype HIST_SEARCH) (BNE p, lookfor) (!= ((ร old_firstc =) (.at p (inc (STRLEN p)))) firstc))
                                (do
                                    ;; Correct for the separator character used when
                                    ;; adding the history entry vs the one used now.
                                    ;; First loop: count length.
                                    ;; Second loop: copy the characters.
                                    (dotimes [round 2]
                                        (let [n (loop-when-recur [n 0 i 0] (non-eos? p i) [(inc n) (inc i)] => n
                                                    (if (and (at? p i old_firstc) (or (zero? i) (not-at? p (dec i) (byte \\))))
                                                        ;; Replace old sep with new sep, unless it is escaped.
                                                        (if (< 0 round) (.be (:cmdbuff @ccline) n, firstc))
                                                        (do
                                                            ;; Escape new sep, unless it is already escaped.
                                                            (when (and (at? p i firstc) (or (zero? i) (not-at? p (dec i) (byte \\))))
                                                                (if (< 0 round) (.be (:cmdbuff @ccline) n, (byte \\)))
                                                                ((ร n =) (inc n))
                                                            )
                                                            (if (< 0 round) (.be (:cmdbuff @ccline) n, (.at p i)))
                                                        ))
                                                )]
                                            (if (< 0 round) (eos! (:cmdbuff @ccline) n) (alloc-cmdbuff n))
                                        ))
                                )
                                :else
                                (do
                                    (alloc-cmdbuff (STRLEN p))
                                    (STRCPY (:cmdbuff @ccline), p)
                                ))

                                (let [n (STRLEN (:cmdbuff @ccline))] (swap! ccline assoc :cmdpos n :cmdlen n))
                                (redrawcmd)
                                (ร BREAK cmdline_changed)
                            )
                            (beep-flush)
                            (ร BREAK cmdline_not_changed)
                        )

                       [Ctrl_V Ctrl_Q]
                        (do
                            (putcmdline (byte \^), true)
                            ((ร c =) (get-literal))          ;; get next (two) character(s)
                            ((ร do_abbr =) false)            ;; don't do abbreviation now
                            ;; may need to remove ^ when composing char was typed
                            (when (utf-iscomposing c)
                                (draw-cmdline (:cmdpos @ccline), (- (:cmdlen @ccline) (:cmdpos @ccline)))
                                (msg-putchar (byte \space))
                                (cursorcmd)
                            )
                            (ร BREAK)
                        )

                        Ctrl_K
                        (do
                            (putcmdline (byte \?), true)
                            ((ร c =) (get-digraph true))
                            (if (!= c NUL)
                                (ร BREAK)
                            )

                            (redrawcmd)
                            (ร BREAK cmdline_not_changed)
                        )

                        (do
                            (when (== c @intr_char)
                                ((ร gotesc =) true)      ;; will free ccline.cmdbuff after putting it in history
                                (ร BREAK returncmd)    ;; back to Normal mode
                            )

                            ;; Normal character with no special meaning.  Just set mod_mask
                            ;; to 0x0 so that typing Shift-Space in the GUI doesn't enter
                            ;; the string <S-Space>.  This should only happen after ^V.

                            (if (not (is-special c))
                                (reset! mod_mask 0x0))
                            (ร BREAK)
                        )
                    )

                    ;; End of switch on command line character.
                    ;; We come here if we have a normal character.

                    (if (and do_abbr (or (is-special c) (not (vim-iswordc c))) (== c Ctrl_RSB))
                        (ร BREAK cmdline_changed)
                    )

                    ;; put the character in the command line

                    (cond (or (is-special c) (non-zero? @mod_mask))
                    (do
                        (put-on-cmdline (get-special-key-name c, @mod_mask), -1, true)
                    )
                    :else
                    (do
                        ((ร int j =) (utf-char2bytes c, @ioBuff))
                        (eos! @ioBuff j)          ;; exclude composing chars
                        (put-on-cmdline @ioBuff, j, true)
                    ))
                    (ร BREAK cmdline_changed)
;               }

                ;; This part implements incremental searches for "/" and "?"
                ;; Jump to cmdline_not_changed when a character has been read but the command
                ;; line did not change.  Then we only search and redraw if something changed in the past.
                ;; Jump to cmdline_changed when the command line did change.

                (if (not incsearch_postponed)
                    (ร CONTINUE)
                )
;           }

            ;; 'incsearch' highlighting.

            (when (and @p_is (any == firstc (byte \/) (byte \?)))
                ;; if there is a character waiting, search and redraw later
                (when (char-avail)
                    ((ร incsearch_postponed =) true)
                    (ร CONTINUE)
                )
                ((ร incsearch_postponed =) false)
                (swap! curwin assoc :w_cursor old_cursor) ;; start at old position

                ;; If there is no command line, don't do anything.
                (ร int i)
                (cond (zero? (:cmdlen @ccline))
                (do
                    ((ร i =) 0)
                )
                :else
                (do
                    (cursor-off)               ;; so the user knows we're busy
                    (out-flush)
                    (swap! emsg_off inc)                 ;; so it doesn't beep if bad expr
                    ;; Set the time limit to half a second.
                    ((ร long nsec =) (profile-setlimit 500))
                    ((ร i =) (do-search nil, (byte firstc), (:cmdbuff @ccline), count, (+ SEARCH_KEEP SEARCH_OPT SEARCH_NOOF SEARCH_PEEK), nsec))
                    (swap! emsg_off dec)
                    ;; if interrupted while searching, behave like it failed
                    (cond @got_int
                    (do
                        (vpeekc)               ;; remove <C-C> from input stream
                        (reset! got_int false)        ;; don't abandon the command line
                        ((ร i =) 0)
                    )
                    (char-avail)
                    (do
                        ;; cancelled searching because a char was typed
                        ((ร incsearch_postponed =) true)
                    ))
                ))
                (reset! highlight_match (non-zero? i))

                ;; First restore the old curwin values, so the screen is
                ;; positioned in the same way as the actual search command.
                (swap! curwin assoc :w_leftcol old_leftcol, :w_topline old_topline, :w_botline old_botline)
                (swap! curwin changed-cline-bef-curs)
                (swap! curwin update-topline)

                ((ร pos_C end_pos =) (NEW_pos_C))
                (cond (non-zero? i)
                (do
                    ((ร pos_C save_pos =) (:w_cursor @curwin))

                    ;; First move the cursor to the end of the match, then to the start.
                    ;; This moves the whole match onto the screen when 'nowrap' is set.

                    (swap! curwin update-in [:w_cursor :lnum] + @search_match_lines)
                    (swap! curwin assoc-in [:w_cursor :col] @search_match_endcol)
                    (when (< (line-count @curbuf) (:lnum (:w_cursor @curwin)))
                        (swap! curwin assoc-in [:w_cursor :lnum] (line-count @curbuf))
                        (swap! curwin coladvance MAXCOL)
                    )
                    (swap! curwin validate-cursor)
                    ((ร end_pos =) (:w_cursor @curwin))
                    (swap! curwin assoc :w_cursor save_pos)
                )
                :else
                (do
                    ((ร end_pos =) (:w_cursor @curwin))
                ))

                (swap! curwin validate-cursor)
                ;; May redraw the status line to show the cursor position.
                (when (and @p_ru (< 0 (:w_status_height @curwin)))
                    (swap! curwin assoc :w_redr_status true))

                ((ร cmdline_info_C save_cli =) (save-cmdline))
                (update-screen SOME_VALID)
                (restore-cmdline save_cli)

                ;; Leave it at the end to make CTRL-R CTRL-W work.
                (when (non-zero? i)
                    (swap! curwin assoc :w_cursor end_pos))

                (msg-starthere)
                (redrawcmdline)
                ((ร did_incsearch =) true)
            )
            (recur)
        )

        (when did_incsearch
            (swap! curwin assoc :w_cursor old_cursor, :w_curswant old_curswant, :w_leftcol old_leftcol, :w_topline old_topline, :w_botline old_botline)
            (reset! highlight_match false)
            (swap! curwin validate-cursor)      ;; needed for TAB
            (swap! curwin redraw-later SOME_VALID)
        )

        (when (some? (:cmdbuff @ccline))
            ;; Put line in history buffer (":" and "=" only when it was typed).

            (when (and (non-zero? (:cmdlen @ccline)) (!= firstc NUL) (or some_key_typed (== histype HIST_SEARCH)))
                (add-to-history histype, (:cmdbuff @ccline), (if (== histype HIST_SEARCH) firstc NUL))
                (if (== firstc (byte \:))
                    (reset! new_last_cmdline (STRDUP (:cmdbuff @ccline))))
            )

            (when gotesc         ;; abandon command line
                (swap! ccline assoc :cmdbuff nil)
                (if (zero? @msg_scrolled)
                    (compute-cmdrow))
                (msg (u8 ""))
                (reset! redraw_cmdline true)
            )
        )

        ;; If the screen was shifted up, redraw the whole screen (later).
        ;; If the line is too long, clear it, so ruler and shown command
        ;; do not get printed in the middle of it.

        (msg-check)
        (reset! msg_scroll save_msg_scroll)

        ;; When the command line was typed, no need for a wait-return prompt.
        (when some_key_typed
            (reset! need_wait_return false))

        (reset! State save_State)
        (ui-cursor-shape)          ;; may show different cursor shape

        ((ร Bytes p =) (:cmdbuff @ccline))
        ;; Make ccline empty, getcmdline() may try to use it.
        (swap! ccline assoc :cmdbuff nil)
        p
    ))

;; Return true when the text must not be changed and we can't switch to
;; another window or buffer.  Used when editing the command line, etc.

(defn- #_boolean text-locked []
    (or (non-zero? @cmdwin_type) (non-zero? @textlock)))

;; Give an error message for a command that isn't allowed while the cmdline
;; window is open or editing the cmdline in another way.

(defn- #_void text-locked-msg []
    (emsg (if (non-zero? @cmdwin_type) e_cmdwin e_secure))
    nil)

(defn- #_int cmdline-charsize [#_int idx]
    (mb-ptr2cells (:cmdbuff @ccline), idx))

;; Compute the offset of the cursor on the command line for the prompt.

(defn- #_void set-cmdspos []
    (swap! ccline assoc :cmdspos (+ (if (!= (:cmdfirstc @ccline) NUL) 1 0) (:cmdindent @ccline)))
    nil)

;; Compute the screen position for the cursor on the command line.

(defn- #_void set-cmdspos-cursor []
    (set-cmdspos)
    (let [#_int m (if @keyTyped (let [m (* @Cols @Rows)] (if (< m 0) MAXCOL m)) MAXCOL)]
        (loop-when [#_int i 0] (and (< i (:cmdlen @ccline)) (< i (:cmdpos @ccline)))
            (let [#_int c (cmdline-charsize i)]
                ;; Count ">" for double-wide multi-byte char that doesn't fit.
                (correct-cmdspos i, c)
                ;; If the cmdline doesn't fit, show cursor on last visible char.
                ;; Don't move the cursor itself, so we can still append.
                (when (< (+ (:cmdspos @ccline) c) m)
                    (swap! ccline update :cmdspos + c)
                    (recur (+ i (us-ptr2len-cc (:cmdbuff @ccline), i)))
                )
            ))
    )
    nil)

;; Check if the character at "idx", which is "cells" wide, is a multi-byte
;; character that doesn't fit, so that a ">" must be displayed.

(defn- #_void correct-cmdspos [#_int idx, #_int cells]
    (let [pos (.plus (:cmdbuff @ccline) idx) cols @Cols]
        (when (and (< 1 (us-ptr2len-cc pos)) (< 1 (us-ptr2cells pos)) (< cols (+ (% (:cmdspos @ccline) cols) cells)))
            (swap! ccline update :cmdspos inc)
        ))
    nil)

;; Get an Ex command line for the ":" command.

(defn- #_Bytes getexline []
    ;; When executing a register, remove ':' that's in front of each line.
    (when (and @exec_from_reg (== (vpeekc) (byte \:)))
        (vgetc))
    (getcmdline (byte \:), 1))

;; Allocate a new command line buffer.
;; Assigns the new buffer to ccline.cmdbuff and ccline.cmdbufflen.
;; Returns the new value of ccline.cmdbuff and ccline.cmdbufflen.

(defn- #_void alloc-cmdbuff [#_int len]
    (let [len (if (< len 80) 100 (+ len 20))] ;; give some extra space to avoid having to allocate all the time
        (swap! ccline assoc :cmdbuff (Bytes. len) :cmdbufflen len))
    nil)

;; Re-allocate the command line to length len + something extra.

(defn- #_void realloc-cmdbuff [#_int len]
    (if-not (< len (:cmdbufflen @ccline))
        (let [#_Bytes p (:cmdbuff @ccline)]
            (alloc-cmdbuff len)                     ;; will get some more
            ;; There isn't always a NUL after the command, but it may need to be there,
            ;; thus copy up to the NUL and add a NUL.
            (BCOPY (:cmdbuff @ccline), p, (:cmdlen @ccline))
            (eos! (:cmdbuff @ccline) (:cmdlen @ccline))
        )
    )
    nil)

;; Draw part of the cmdline at the current cursor position.

(defn- #_void draw-cmdline [#_int start, #_int len]
    (msg-outtrans-len (.plus (:cmdbuff @ccline) start), len)
    nil)

;; Put a character on the command line.  Shifts the following text to the
;; right when "shift" is true.  Used for CTRL-V, CTRL-K, etc.
;; "c" must be printable (fit in one display cell)!

(defn- #_void putcmdline [#_int c, #_boolean shift]
    (reset! msg_no_more true)
    (msg-putchar c)
    (if shift (let [pos (:cmdpos @ccline) len (:cmdlen @ccline)]
        (draw-cmdline pos, (- len pos))))
    (reset! msg_no_more false)
    (cursorcmd)
    nil)

;; Undo a putcmdline(c, false).

(defn- #_void unputcmdline []
    (reset! msg_no_more true)
    (let [pos (:cmdpos @ccline) len (:cmdlen @ccline)]
        (if (== len pos)
            (msg-putchar (byte \space))
            (draw-cmdline pos, (us-ptr2len-cc (:cmdbuff @ccline), pos))))
    (reset! msg_no_more false)
    (cursorcmd)
    nil)

;; Put the given string, of the given length, onto the command line.
;; If len is -1, then STRLEN() is used to calculate the length.
;; If 'redraw' is true then the new part of the command line, and the remaining part
;; will be redrawn, otherwise it will not.  If this function is called twice in a row,
;; then 'redraw' should be false and redrawcmd() should be called afterwards.

(defn- #_void put-on-cmdline [#_Bytes str, #_int len, #_boolean redraw]
    (let [len (if (< len 0) (STRLEN str) len)]

        ;; Check if ccline.cmdbuff needs to be longer.
        (let-when [more (+ (:cmdlen @ccline) len 1)] (<= (:cmdbufflen @ccline) more)
            (realloc-cmdbuff more))

        (let [cbuf (:cmdbuff @ccline) cpos (:cmdpos @ccline)]
            (swap! ccline update :cmdlen #(if (not (:overstrike @ccline))
                (do
                    (BCOPY cbuf, (+ cpos len), cbuf, cpos, (- % cpos))
                    (+ % len)
                )
                (let [#_int m (loop [#_int m 0 #_int n 0] (if (< n len) (recur (inc m) (+ n (us-ptr2len-cc str, n))) m))
                      #_int n (loop [m m #_int n cpos] (if (and (< n %) (< 0 m)) (recur (dec m) (+ n (us-ptr2len-cc cbuf, n))) n))]
                    ;; m: nof characters in the new string ;; n: nof bytes in cmdline that are overwritten by these characters
                    (if (< n %)
                        (do
                            (BCOPY cbuf, (+ cpos len), cbuf, n, (- % n))
                            (+ % (- (+ cpos len) n))
                        )
                        (+ cpos len)
                    )
                )))
            (BCOPY cbuf, cpos, str, 0, len)
            (eos! cbuf (:cmdlen @ccline))
        )

        (let [cbuf (:cmdbuff @ccline)
              ;; When the inserted text starts with a composing character, backup to the character before it.  There could be two of them.
              [_ len] (loop-when [#_int i 0 len len] (and (< 0 (:cmdpos @ccline)) (utf-iscomposing (us-ptr2char cbuf, (:cmdpos @ccline)))) => [(non-zero? i) len]
                        (let [i (inc (us-head-off cbuf, (.plus cbuf (dec (:cmdpos @ccline)))))]
                            (swap! ccline update :cmdpos - i)
                            (recur i (+ len i))
                        ))]
            (when _ ;; Also backup the cursor position.
                (let [#_int i (mb-ptr2cells cbuf, (:cmdpos @ccline))]
                    (swap! ccline update :cmdspos - i)
                    (swap! msg_col - i)
                    (when (< @msg_col 0) (swap! msg_col + @Cols) (swap! msg_row dec))
                ))

            (when redraw
                (reset! msg_no_more true)
                (let [#_int i @cmdline_row]
                    (cursorcmd)
                    (draw-cmdline (:cmdpos @ccline), (- (:cmdlen @ccline) (:cmdpos @ccline)))
                    ;; Avoid clearing the rest of the line too often.
                    (when (or (!= @cmdline_row i) (:overstrike @ccline))
                        (msg-clr-eos)
                    ))
                (reset! msg_no_more false))

            (let [#_int m (if @keyTyped (let [m (* @Cols @Rows)] (if (< m 0) MAXCOL m)) MAXCOL)]

                (loop-when [#_int i 0] (< i len)
                    (let [#_int n (cmdline-charsize (:cmdpos @ccline))]
                        ;; Count ">" for a double-wide char that doesn't fit.
                        (correct-cmdspos (:cmdpos @ccline), n)
                        ;; Stop cursor at the end of the screen, but do increment the insert position,
                        ;; so that entering a very long command works, even though you can't see it.
                        (when (< (+ (:cmdspos @ccline) n) m)
                            (swap! ccline update :cmdspos + n))
                        (let [n (min (dec (us-ptr2len-cc cbuf, (:cmdpos @ccline))) (- len i 1))]
                            (swap! ccline update :cmdpos + n 1)
                            (recur (+ i n 1))
                        )
                    ))

                (when redraw (msg-check))
            )
        ))
    nil)

;; Save ccline, because obtaining the "=" register may execute "normal :cmd" and overwrite it.

(defn- #_cmdline_info_C save-cmdline []
    (let [#_cmdline_info_C cli @ccline]
        (swap! ccline assoc :cmdbuff nil :cmdprompt nil)
        cli
    ))

;; Restore ccline after it has been saved with save-cmdline().

(defn- #_void restore-cmdline [#_cmdline_info_C cli]
    (reset! ccline cli)
    nil)

;; Paste a yank register into the command line.
;; Used by CTRL-R command in command-line mode.
;; insert-reg() can't be used here, because special characters from the register contents will be interpreted as commands.
;;
;; return false for failure, true otherwise

(defn- #_boolean cmdline-paste [#_int regname, #_boolean literally, #_boolean remcr]
    ;; literally: insert text literally instead of "as typed"
    ;; remcr: remove trailing CR
    (and
        ;; Check for valid regname.  ;; Also accept special characters for CTRL-R in the command line.
        (or (any == regname Ctrl_F Ctrl_P Ctrl_W Ctrl_A) (valid-yank-reg regname, false))
        ;; A register containing CTRL-R can cause an endless loop.  ;; Allow using CTRL-C to break the loop.
        (not (slow-breakcheck))
        (let [regname (may-get-selection regname)
                ;; Need to save and restore ccline.
                #_cmdline_info_C save_cli (save-cmdline)
                ;; Also set "textlock" to avoid nasty things like going to another buffer when evaluating an expression.
                _ (swap! textlock inc)
                a'arg (atom (#_Bytes object))
                #_boolean got (get-spec-reg regname, a'arg, true)
                _ (swap! textlock dec)
                _ (restore-cmdline save_cli)]
            (if got ;; Got the value of a special register in "arg".
                (and (some? @a'arg)
                    (let [#_Bytes p ;; When 'incsearch' is set and CTRL-R CTRL-W used: skip the duplicate part of the word.
                            (if (and @p_is (== regname Ctrl_W))
                                (let [#_Bytes w ;; Locate start of last word in the cmd buffer.
                                        (loop-when [w (.plus (:cmdbuff @ccline) (:cmdpos @ccline))] (BLT (:cmdbuff @ccline), w) => w
                                            (let [#_int len (inc (us-head-off (:cmdbuff @ccline), (.minus w 1)))]
                                                (recur-if (vim-iswordc (us-ptr2char w, (- len))) [(.minus w len)] => w)
                                            ))
                                        #_int len (BDIFF (.plus (:cmdbuff @ccline) (:cmdpos @ccline)), w)]
                                    (if (if @p_ic (zero? (STRNCASECMP w, @a'arg, len)) (zero? (STRNCMP w, @a'arg, len))) (.plus @a'arg len) @a'arg))
                                @a'arg
                            )]
                        (cmdline-paste-str p, literally)
                    true))
                (cmdline-paste-reg regname, literally, remcr)
            ))
    ))

;; Put a string on the command line.
;; When "literally" is true, insert literally.
;; When "literally" is false, insert as typed, but don't leave the command line.

(defn- #_void cmdline-paste-str [#_Bytes _s, #_boolean literally]
    (let [a's (atom (#_Bytes object _s))]
        (if literally
            (put-on-cmdline @a's, -1, true)
            (while (non-eos? @a's)
                (let [#_int cv (.at @a's 0)]
                    (when (and (== cv Ctrl_V) (non-eos? @a's 1))
                        (swap! a's plus 1))
                    (let [#_int c (us-ptr2char-adv a's, false)]
                        (when (or (== cv Ctrl_V) (any == c ESC Ctrl_C CAR NL Ctrl_L @intr_char) (and (== c Ctrl_BSL) (at? @a's Ctrl_N)))
                            (stuff-char Ctrl_V))
                        (stuff-char c))
                ))
        ))
    nil)

;; this function is called when the screen size changes and with incremental search

(defn- #_void redrawcmdline []
    (reset! need_wait_return false)
    (compute-cmdrow)
    (redrawcmd)
    (cursorcmd)
    nil)

(defn- #_void redrawcmdprompt []
    (let [firstc (:cmdfirstc @ccline) prompt (:cmdprompt @ccline)]
        (when (!= firstc NUL)
            (msg-putchar firstc))
        (if (some? prompt)
            (do
                (msg-puts-attr prompt, (:cmdattr @ccline))
                (swap! ccline assoc :cmdindent (+ @msg_col (* (- @msg_row @cmdline_row) @Cols)))
                ;; do the reverse of set-cmdspos()
                (when (!= firstc NUL)
                    (swap! ccline update :cmdindent dec))
            )
            (dotimes [_ (:cmdindent @ccline)] (msg-putchar (byte \space)))
        ))
    nil)

;; Redraw what is currently on the command line.

(defn- #_void redrawcmd []
    ;; when 'incsearch' is set there may be no command line while redrawing
    (cond (nil? (:cmdbuff @ccline))
    (do
        (windgoto @cmdline_row, 0)
        (msg-clr-eos)
    )
    :else
    (do
        (msg-start)
        (redrawcmdprompt)

        ;; Don't use more prompt, truncate the cmdline if it doesn't fit.
        (reset! msg_no_more true)
        (draw-cmdline 0, (:cmdlen @ccline))
        (msg-clr-eos)
        (reset! msg_no_more false)

        (set-cmdspos-cursor)

        ;; An emsg() before may have set msg_scroll.
        ;; This is used in normal mode, in cmdline mode we can reset them now.

        (reset! msg_scroll false)       ;; next message overwrites cmdline

        ;; Typing ':' at the more prompt may set skip_redraw.
        ;; We don't want this in cmdline mode.
        (reset! skip_redraw false)
    ))
    nil)

(defn- #_void compute-cmdrow []
    (reset! cmdline_row (if (non-zero? @msg_scrolled) (dec @Rows) (+ (:w_winrow @lastwin) (:w_height @lastwin) (:w_status_height @lastwin))))
    nil)

(defn- #_void cursorcmd []
    (reset! msg_row (+ @cmdline_row (/ (:cmdspos @ccline) @Cols)))
    (reset! msg_col (% (:cmdspos @ccline) @Cols))
    (when (<= @Rows @msg_row)
        (reset! msg_row (dec @Rows)))

    (windgoto @msg_row, @msg_col)
    nil)

(defn- #_void gotocmdline [#_boolean clr]
    (msg-start)
    (reset! msg_col 0)           ;; always start in column 0
    (if clr                ;; clear the bottom line(s)
        (msg-clr-eos))      ;; will reset clear_cmdline

    (windgoto @cmdline_row, 0)
    nil)

;; Command line history stuff

;; Translate a history character to the associated type number.

(defn- #_int hist-char2type [#_int c]
    (condp == c (byte \:) HIST_CMD (byte \=) HIST_EXPR (byte \@) HIST_INPUT HIST_SEARCH)) ;; must be '?' or '/'

;; init-history() - Initialize the command line history.
;; Also used to re-allocate the history when the size changes.

(defn- #_void init-history []
    (ยง
        ;; If size of history table changed, reallocate it.

        ((ร int newlen =) (int @p_hi))
        (when (!= newlen @hislen)                                   ;; history length changed
            (dotimes [#_int type HIST_COUNT]       ;; adjust the tables
                ((ร histentry_C[] temp =) nil)

                ((ร temp =) (if (non-zero? newlen) (ARRAY-histentry newlen) temp))

                (when (or (zero? newlen) (some? temp))
                    (cond (< (... @hisidx type) 0)                       ;; there are no entries yet
                    (do
                        (dotimes [#_int i newlen]
                            (clear-hist-entry (... temp i))
                        )
                    )
                    (< @hislen newlen)                   ;; array becomes bigger
                    (do
                        ((ร int j =) (loop-when-recur [j 0] (<= j (... @hisidx type)) [(inc j)] => j
                            (COPY-histentry (... temp j), (... (... @history type) j))
                        ))
                        ((ร int i =) (loop-when-recur i (<= i (- newlen (- @hislen (... @hisidx type)))) (inc i) => i
                            (clear-hist-entry (... temp i))
                        ))
                        (loop-when-recur [i i j j] (< j @hislen) [(inc i) (inc j)]
                            (COPY-histentry (... temp i), (... (... @history type) j))
                        )
                    )
                    :else                                        ;; array becomes smaller or 0
                    (do
                        ((ร int j =) (... @hisidx type))
                        (loop-when-recur [#_int i (dec newlen)] true [(dec i)]
                            (if (<= 0 i)
                                (COPY-histentry (... temp i), (... (... @history type) j))      ;; copy newest entries
                                ((ร @history[type][j].hisstr =) nil)                    ;; remove older entries
                            )
                            (if (< ((ร j =) (dec j)) 0)
                                ((ร j =) (dec @hislen))
                            )
                            (if (== j (... @hisidx type))
                                (ร BREAK)
                            )
                        )
                        ((ร @hisidx[type] =) (dec newlen))
                    ))
                    ((ร @history[type] =) temp)
                )
            )
            (reset! hislen newlen)
        )
        nil
    ))

(defn- #_void clear-hist-entry [#_histentry_C hisptr]
    (ยง
        ((ร hisptr =) (assoc hisptr :hisnum 0))
        ((ร hisptr =) (assoc hisptr :hisstr nil))
        nil
    ))

;; Check if command line 'str' is already in history.
;; If 'move_to_front' is true, matching entry is moved to end of history.

(defn- #_boolean in-history [#_int type, #_Bytes str, #_boolean move_to_front, #_int sep]
    ;; move_to_front: Move the entry to the front if it exists
    (ยง
        (if (< (... @hisidx type) 0)
            ((ร RETURN) false)
        )

        ((ร int last_i =) -1)

        ((ร int i =) (... @hisidx type))
        (loop []
            (if (nil? (:hisstr (... (... @history type) i)))
                ((ร RETURN) false)
            )

            ;; For search history, check that the separator character matches as well.
            ((ร Bytes p =) (:hisstr (... (... @history type) i)))
            (when (and (zero? (STRCMP str, p)) (or (!= type HIST_SEARCH) (== sep (.at p (inc (STRLEN p))))))
                (if (not move_to_front)
                    ((ร RETURN) true)
                )
                ((ร last_i =) i)
                (ร BREAK)
            )
            ((ร i =) (dec i))
            ((ร i =) (if (< i 0) (dec @hislen) i))
            (recur-if (!= i (... @hisidx type)) [])
        )

        (when (<= 0 last_i)
            ((ร str =) (:hisstr (... (... @history type) i)))
            (loop-when [] (!= i (... @hisidx type))
                ((ร i =) (inc i))
                ((ร i =) (if (<= @hislen i) 0 i))
                (COPY-histentry (... (... @history type) last_i), (... (... @history type) i))
                ((ร last_i =) i)
                (recur)
            )
            ((ร @history[type][i].hisnum =) (ร ++@hisnum[type]))
            ((ร @history[type][i].hisstr =) str)
            ((ร RETURN) true)
        )

        false
    ))

(atom! int      last_maptick -1)      ;; last seen maptick

;; Add the given string to the given history.  If the string is already in the
;; history then it is moved to the front.  "histype" may be one of he HIST_ values.

(defn- #_void add-to-history [#_int histype, #_Bytes new_entry, #_int sep]
    ;; sep: separator character used (search hist)
    (ยง
        (if (zero? @hislen)            ;; no history
            ((ร RETURN) nil)
        )

        ;; Searches inside the same mapping overwrite each other, so that only
        ;; the last line is kept.  Be careful not to remove a line that was moved
        ;; down, only lines that were added.

        (when (== histype HIST_SEARCH)
            (when (== @maptick @last_maptick)
                ;; Current line is from the same mapping, remove it.
                ((ร histentry_C hisptr =) (... (... @history HIST_SEARCH) (... @hisidx HIST_SEARCH)))
                ((ร hisptr =) (assoc hisptr :hisstr nil))
                (clear-hist-entry hisptr)
                (ร --@hisnum[histype])
                (if (< (ร --@hisidx[HIST_SEARCH]) 0)
                    ((ร @hisidx[HIST_SEARCH] =) (dec @hislen))
                )
            )
            (reset! last_maptick -1)
        )

        (when (not (in-history histype, new_entry, true, sep))
            (if (== (ร ++@hisidx[histype]) @hislen)
                ((ร @hisidx[histype] =) 0)
            )

            ((ร histentry_C hisptr =) (... (... @history histype) (... @hisidx histype)))

            ;; Store the separator after the NUL of the string.
            ((ร int len =) (STRLEN new_entry))
            ((ร hisptr =) (assoc hisptr :hisstr (STRNDUP new_entry, (+ len 2))))
;           hisptr.hisstr.be(len + 1, sep);

            ((ร hisptr =) (assoc hisptr :hisnum (ร ++@hisnum[histype])))
            (if (== histype HIST_SEARCH)
                (reset! last_maptick @maptick))
        )
        nil
    ))

;; Open a window on the current command line and history.
;; Allow editing in the window.  When the window is closed,
;; returns:
;;      CR       if the command is to be executed
;;      Ctrl_C   if it is to be abandoned
;;      K_IGNORE if editing continues

(defn- #_int ex-window []
    (beep-flush)
    K_IGNORE)

;; ex_docmd.c: functions for executing an Ex command line -----------------------------------------

(atom! int      quitmore)
(atom! boolean  ex_pressedreturn)

;;; ============================================================================================== VimI

;; This file defines the Ex commands.
;;
;; When adding an Ex command:
;; 1. Add an entry in the table below.  Keep it sorted on the shortest
;;    version of the command name that works.  If it doesn't start with a
;;    lower case letter, add it at the end.
;; 2. Add a "case: CMD_xxx" in the big switch in ex_docmd.c.

;; This array maps ex command names to command codes.
;; The order in which command names are listed below is significant --
;; ambiguous abbreviations are always resolved to be the first possible match
;; (e.g. "r" is taken to mean "read", not "rewind", because "read" comes before "rewind").
;; Not supported commands are included to avoid ambiguities.

(class! #_final cmdname_C
    [
        (field Bytes        cmd_name)       ;; name of the command
        (field ex_func_F    cmd_func)       ;; function for this command
        (field long         cmd_argt)       ;; flags declared above
        (field int          cmd_addr_type)  ;; flag for address type
    ])

;; ----------------------------------------------------------------------- ;;

;; Execute a simple command line.  Used for translated commands like "*".

(defn- #_boolean do-cmdline-cmd [#_Bytes cmd]
    (do-cmdline cmd, false, (| DOCMD_VERBOSE DOCMD_NOWAIT DOCMD_KEYTYPED)))

(atom! int _0_recurse)              ;; recursive depth

;; do-cmdline(): execute one Ex command line
;;
;; 1. Execute "cmdline" when it is not null.
;;    If "cmdline" is null, or more lines are needed, getexline() is used.
;; 2. Split up in parts separated with '|'.
;;
;; This function can be called recursively!
;;
;; flags:
;; DOCMD_VERBOSE  - The command will be included in the error message.
;; DOCMD_NOWAIT   - Don't call wait-return() and friends.
;; DOCMD_KEYTYPED - Don't reset keyTyped.
;; DOCMD_KEEPLINE - Store first typed line (for repeating with ".").
;;
;; return false if cmdline could not be executed, true otherwise

(defn- #_boolean do-cmdline [#_Bytes cmdline, #_boolean use_getline, #_int flags]
    ;; "did_emsg" will be set to true when emsg() is used,
    ;; in which case we cancel the whole command line.
    (reset! did_emsg false)
    ;; "keyTyped" is only set when calling vgetc().
    ;; Reset it here when not calling vgetc() (sourced command lines).
    (when (and (non-flag? flags DOCMD_KEYTYPED) (not use_getline))
        (reset! keyTyped false))

    (let [a'cmdline (atom (#_Bytes object nil)) a'did_out (atom (boolean false)) a'did_inc (atom (boolean false)) ;; incremented no_redraw
          #_boolean retval
            (loop [cmdline cmdline #_boolean used_getline false #_int count 0]
                (let-when [[cmdline used_getline :as _]
                    ;; If no line given, get an allocated line with getexline().
                    (cond (nil? cmdline)
                        ;; stop skipping cmds for an error msg after all endif/while/for
                        (do (reset! did_emsg false)
                            ;; Need to set msg_didout for the first line after an ":if",
                            ;; otherwise the ":if" will be overwritten.
                            (when (and (== count 1) use_getline)
                                (reset! msg_didout true))
                            (let [cmdline (when use_getline (getexline))]
                                (if (nil? cmdline)
                                    (do ;; Don't call wait-return for aborted command line.  The null
                                        ;; returned for the end of a sourced file or executed function
                                        ;; doesn't do this.
                                        (when @keyTyped
                                            (reset! need_wait_return false))
                                        nil)
                                    (do ;; Keep the first typed line.  Clear it when more lines are typed.
                                        (when (flag? flags DOCMD_KEEPLINE)
                                            (reset! repeat_cmdline (if (zero? count) (STRDUP cmdline) nil)))
                                        [cmdline true]
                                    ))
                            ))
                    ;; Make a copy of the command so we can mess with it.
                    (nil? @a'cmdline)
                        [(STRDUP cmdline) used_getline]
                    :else
                        [cmdline used_getline])
                ] (some? _) => false

                    (reset! a'cmdline cmdline)
                    (let [count (inc count)]
                        (when (== count 1)
                            ;; All output from the commands is put below each other, without waiting for a return.
                            ;; Don't do this when executing commands from a script or when being called recursive.
                            (when (and (non-flag? flags DOCMD_NOWAIT) (zero? @_0_recurse))
                                (reset! a'did_out @msg_didout)
                                (reset! msg_didany false)   ;; no output yet
                                (msg-start)
                                (reset! msg_scroll true)    ;; put messages below each other
                                (swap! no_wait_return inc)  ;; don't wait for return until finished
                                (swap! no_redraw inc)
                                (reset! a'did_inc true)
                            ))
                        ;; Execute one '|' separated command.
                        ;; do-one-cmd() will return null if there is no trailing '|'.
                        ;; "a'cmdline" can change, e.g. for '%' and '#' expansion.
                        (let [_ (swap! _0_recurse inc)
                              cmdline (do-one-cmd a'cmdline, (flag? flags DOCMD_VERBOSE))
                              _ (swap! _0_recurse dec)
                              cmdline
                                (if (nil? cmdline)
                                    (do (reset! a'cmdline nil)
                                        ;; If the command was typed, remember it for the ':' register.
                                        ;; Do this AFTER executing the command to make :@: work.
                                        (when (and use_getline (some? @new_last_cmdline))
                                            (reset! last_cmdline @new_last_cmdline)
                                            (reset! new_last_cmdline nil))
                                        nil)
                                    (do ;; Need to copy the command after the '|' to "a'cmdline"
                                        ;; for the next do-one-cmd().
                                        (BCOPY @a'cmdline, cmdline, (inc (STRLEN cmdline)))
                                        @a'cmdline)
                                )]
                            ;; Continue executing command lines when:
                            ;; - no CTRL-C typed, no aborting error, no exception thrown or try conditionals need
                            ;;   to be checked for executing finally clauses or catching an interrupt exception
                            ;; - didn't get an error message or lines are not typed
                            ;; - there is a command after '|', inside a :if, :while, :for or :try, or looping
                            ;;   for ":source" command or function call.
                            (recur-if (and (not @got_int) (not (and @did_emsg used_getline use_getline)) (some? cmdline)) [cmdline used_getline count] => true)
                        ))
                ))]
        (reset! did_emsg_syntax false)
        ;; If there was too much output to fit on the command line, ask the user to
        ;; hit return before redrawing the screen.  With the ":global" command we do
        ;; this only once after the command is finished.
        (when @a'did_inc
            (swap! no_redraw dec)
            (swap! no_wait_return dec)
            (reset! msg_scroll false)
            ;; When just finished an ":if"-":else" which was typed, no need to
            ;; wait for hit-return.  Also for an error situation.
            (cond (not retval)
                (do (reset! need_wait_return false)
                    (reset! msg_didany false)) ;; don't wait when restarting edit
            @need_wait_return
                (do ;; The msg-start() above clears msg_didout.  The wait-return we do here
                    ;; should not overwrite the command that may be shown before doing that.
                    (swap! msg_didout | @a'did_out)
                    (swap! curwin wait-return FALSE))
            ))
        retval
    ))

(defn- #_int current-win-nr [#_window_C win]
    (loop-when [#_int n 0 #_window_C w @firstwin] (some? w) => n
        (let [n (inc n)] (if (== w win) n (recur n (:w_next w))))
    ))

;; Execute one Ex command.
;;
;; If 'verbose' is true, the command will be included in the error message.
;;
;; 1. skip comment lines and leading space
;; 2. handle command modifiers
;; 3. find the command
;; 4. parse range
;; 5. parse the command
;; 6. parse arguments
;; 7. switch on command name
;;
;; This function may be called recursively!

(defn- #_Bytes do-one-cmd [#_Bytes' a'cmdlinep, #_boolean verbose]
    (ยง
        ((ร Bytes errormsg =) nil)         ;; error message
        ((ร boolean save_msg_scroll =) @msg_scroll)
        ((ร int did_esilent =) 0)

        ((ร exarg_C ea =) (NEW_exarg_C))     ;; Ex command arguments
        ((ร ea =) (assoc ea :line1 1))
        ((ร ea =) (assoc ea :line2 1))

        ;; When the last file has not been edited :q has to be typed twice.
        (when (non-zero? @quitmore)
            (swap! quitmore dec))

;       doend:
;       {
            ;; "#!anything" is handled like a comment.
            (if (and (at? @a'cmdlinep (byte \#)) (at? @a'cmdlinep 1 (byte \!)))
                (ร BREAK doend)
            )

            ;; Repeat until no more command modifiers are found.

            ((ร ea =) (assoc ea :cmd @a'cmdlinep))
            (loop []
                ;; 1. Skip comment lines and leading white space and colons.

                (loop-when [] (or (at? (:cmd ea) (byte \space)) (at? (:cmd ea) TAB) (at? (:cmd ea) (byte \:)))
                    ((ร ea =) (update ea :cmd plus 1))
                    (recur)
                )

                ;; ignore comment and empty lines
                (if (at? (:cmd ea) (byte \")) ;; """
                    (ร BREAK doend)
                )
                (when (eos? (:cmd ea))
                    (reset! ex_pressedreturn true)
                    (ร BREAK doend)
                )

                ;; 2. Handle command modifiers.

                ((ร Bytes[] a'p =) (atom (#_Bytes object (:cmd ea))))
                (when (asc-isdigit (.at @a'p 0))
                    (reset! a'p (skipwhite (skipdigits @a'p))))
                ((ร SWITCH) (.at @a'p 0)
;                   
                )
                (ร BREAK)
                (recur)
            )

            ((ร ea =) (assoc ea :skip (or @did_emsg @got_int)))

            ;; 3. Skip over the range to find the command.  Let "p" point to after it.
            ;;
            ;; We need the command to know what kind of range it uses.

            ((ร Bytes cmd =) (:cmd ea))
            ((ร ea =) (update ea :cmd skip-range))
            (if (at? (:cmd ea) (byte \*))
                ((ร ea =) (assoc ea :cmd (skipwhite (.plus (:cmd ea) 1))))
            )

            ((ร Bytes p =) (find-command ea))

            ;; 4. parse a range specifier of the form: addr [,addr] [;addr] ..
            ;;
            ;; where 'addr' is:
            ;;
            ;; %          (entire file)
            ;; $  [+-NUM]
            ;; 'x [+-NUM] (where x denotes a currently defined mark)
            ;; .  [+-NUM]
            ;; [+-NUM]..
            ;; NUM
            ;;
            ;; The ea.cmd pointer is updated to point to the first character following the range spec.
            ;; If an initial address is found, but no second, the upper bound is equal to the lower.

            ((ร ea =) (assoc ea :addr_type (if (!= (:cmdidx ea) CMD_SIZE) (:cmd_addr_type (... cmdnames (:cmdidx ea))) ADDR_LINES)))

            (ร long lnum)

            ;; repeat for all ',' or ';' separated addresses
            ((ร ea =) (assoc ea :cmd cmd))
            (loop []
                ((ร ea =) (assoc ea :line1 (:line2 ea)))
                (condp == (:addr_type ea)
                    ADDR_LINES
                    (do
                        ;; default is current line number
                        ((ร ea =) (assoc ea :line2 (:lnum (:w_cursor @curwin))))
                        (ร BREAK)
                    )

                    ADDR_WINDOWS
                    (do
                        ((ร lnum =) (current-win-nr @curwin))
                        ((ร ea =) (assoc ea :line2 lnum))
                        (ร BREAK)
                    )
                )
                ((ร ea =) (update ea :cmd skipwhite))
                (let [__ (atom (#_Bytes object (:cmd ea)))]
                    ((ร lnum =) (get-address __, (:addr_type ea), (:skip ea), (zero? (:addr_count ea))))
                    ((ร ea =) (assoc ea :cmd @__)))
                (if (nil? (:cmd ea))                 ;; error detected
                    (ร BREAK doend)
                )
                (cond (== lnum MAXLNUM)
                (do
                    (cond (at? (:cmd ea) (byte \%))          ;; '%' - all lines
                    (do
                        ((ร ea =) (update ea :cmd plus 1))
                        (condp == (:addr_type ea)
                            ADDR_LINES
                            (do
                                ((ร ea =) (assoc ea :line1 1))
                                ((ร ea =) (assoc ea :line2 (line-count @curbuf)))
                                (ร BREAK)
                            )

                            ADDR_WINDOWS
                            (do
                                ;; There is no Vim command which uses '%' and ADDR_WINDOWS.
                                ((ร errormsg =) e_invrange)
                                (ร BREAK doend)
                            )
                        )
                        ((ร ea =) (update ea :addr_count inc))
                    )
                    (at? (:cmd ea) (byte \*))     ;; '*' - visual area
                    (do
                        (when (!= (:addr_type ea) ADDR_LINES)
                            ((ร errormsg =) e_invrange)
                            (ร BREAK doend)
                        )

                        ((ร ea =) (update ea :cmd plus 1))
                        (when (not (:skip ea))
                            ((ร pos_C fp =) (getmark (byte \<), false))
                            (if (not (check-mark fp))
                                (ร BREAK doend)
                            )
                            ((ร ea =) (assoc ea :line1 (:lnum fp)))
                            ((ร fp =) (getmark (byte \>), false))
                            (if (not (check-mark fp))
                                (ร BREAK doend)
                            )
                            ((ร ea =) (assoc ea :line2 (:lnum fp)))
                            ((ร ea =) (update ea :addr_count inc))
                        )
                    ))
                )
                :else
                (do
                    ((ร ea =) (assoc ea :line2 lnum))
                ))
                ((ร ea =) (update ea :addr_count inc))

                (cond (at? (:cmd ea) (byte \;))
                (do
                    (when (not (:skip ea))
                        (swap! curwin assoc-in [:w_cursor :lnum] (:line2 ea)))
                )
                (not-at? (:cmd ea) (byte \,))
                (do
                    (ร BREAK)
                ))
                ((ร ea =) (update ea :cmd plus 1))
                (recur)
            )

            ;; One address given: set start and end lines.
            (when (== (:addr_count ea) 1)
                ((ร ea =) (assoc ea :line1 (:line2 ea)))
                ;; ... but only implicit: really no address given
                (if (== lnum MAXLNUM)
                    ((ร ea =) (assoc ea :addr_count 0))
                )
            )

            ;; Don't leave the cursor on an illegal line (caused by ';').
            (swap! curwin check-cursor-lnum)

            ;; 5. Parse the command.

            ;; Skip ':' and any white space

            ((ร ea =) (update ea :cmd skipwhite))
            (loop-when [] (at? (:cmd ea) (byte \:))
                ((ร ea =) (assoc ea :cmd (skipwhite (.plus (:cmd ea) 1))))
                (recur)
            )

            ;; If we got a line, but no command, then go to the line.
            ;; If we find a '|' or '\n' we set ea.nextcmd.

            ((ร ea =) (assoc ea :nextcmd (check-nextcmd (:cmd ea))))
            (when (or (eos? (:cmd ea)) (at? (:cmd ea) (byte \")) (some? (:nextcmd ea)))  ;; """
                ;; strange vi behaviour:
                ;; ":3"         jumps to line 3
                ;; ":3|..."     prints line 3
                ;; ":|"         prints current line

                (if (:skip ea)    ;; skip this if inside :if
                    (ร BREAK doend)
                )
                (cond (at? (:cmd ea) (byte \|))
                (do
                    ((ร ea =) (assoc ea :cmdidx (ร CMD_print)))
                    ((ร ea =) (assoc ea :argt (+ RANGE COUNT)))
                    (when (nil? ((ร errormsg =) (invalid-range ea)))
                        ((ร ea =) (correct-range ea))
;                       ex_print(ea);
                    )
                )
                (non-zero? (:addr_count ea))
                (do
                    (when (< (line-count @curbuf) (:line2 ea))
                        ;; With '-' in 'cpoptions' a line number past the file is an error,
                        ;; otherwise put it at the end of the file.
                        ((ร ea =) (assoc ea :line2 (if (some? (vim-strbyte @p_cpo, CPO_MINUS)) -1 (line-count @curbuf))))
                    )

                    (cond (< (:line2 ea) 0)
                    (do
                        ((ร errormsg =) e_invrange)
                    )
                    :else
                    (do
                        (swap! curwin assoc-in [:w_cursor :lnum] (if (zero? (:line2 ea)) 1 (:line2 ea)))
                        (swap! curwin beginline (| BL_SOL BL_FIX))
                    ))
                ))
                (ร BREAK doend)
            )

            (when (nil? p)
                ((ร errormsg =) (if (not (:skip ea)) (u8 "E464: Ambiguous use of user-defined command") errormsg))
                (ร BREAK doend)
            )

            (when (== (:cmdidx ea) CMD_SIZE)
                (when (not (:skip ea))
                    (STRCPY @ioBuff, (u8 "E492: Not an editor command"))
                    (if (not verbose)
                        (append-command @a'cmdlinep))
                    ((ร errormsg =) @ioBuff)
                    (reset! did_emsg_syntax true)
                )
                (ร BREAK doend)
            )

            ;; forced commands
            (cond (and (at? p (byte \!)) (!= (:cmdidx ea) CMD_substitute))
            (do
                ((ร p =) (.plus p 1))
                ((ร ea =) (assoc ea :forceit true))
            )
            :else
            (do
                ((ร ea =) (assoc ea :forceit false))
            ))

            ;; 6. Parse arguments.

            ((ร ea =) (assoc ea :argt (:cmd_argt (... cmdnames (:cmdidx ea)))))

            (when (not (:skip ea))
                (when (and (text-locked) (non-flag? (:argt ea) CMDWIN))
                    ;; Command not allowed when editing the command line.
                    ((ร errormsg =) (if (non-zero? @cmdwin_type) e_cmdwin e_secure))
                    (ร BREAK doend)
                )

                (when (and (non-flag? (:argt ea) RANGE) (< 0 (:addr_count ea)))
                    ;; no range allowed
                    ((ร errormsg =) e_norange)
                    (ร BREAK doend)
                )
            )

            (when (and (non-flag? (:argt ea) BANG) (:forceit ea)) ;; no <!> allowed
                ((ร errormsg =) e_nobang)
                (ร BREAK doend)
            )

            ;; Don't complain about the range if it is not used
            ;; (could happen if line_count is accidentally set to 0).

            (when (not (:skip ea))
                ;; If the range is backwards, ask for confirmation and, if given,
                ;; swap ea.line1 & ea.line2 so it's forwards again.

                (when (< (:line2 ea) (:line1 ea))
                    (when verbose
                        ((ร errormsg =) (u8 "E493: Backwards range given"))
                        (ร BREAK doend)
                    )
                    (if (!= (ask-yesno (u8 "Backwards range given, OK to swap"), false) (byte \y))
                        (ร BREAK doend)
                    )

                    ((ร lnum =) (:line1 ea))
                    ((ร ea =) (assoc ea :line1 (:line2 ea)))
                    ((ร ea =) (assoc ea :line2 lnum))
                )
                (if (some? ((ร errormsg =) (invalid-range ea)))
                    (ร BREAK doend)
                )
            )

            (if (and (flag? (:argt ea) NOTADR) (zero? (:addr_count ea))) ;; default is 1, not cursor
                ((ร ea =) (assoc ea :line2 1))
            )

            ((ร ea =) (correct-range ea))

            ;; Skip to start of argument.

            ((ร ea =) (assoc ea :arg (skipwhite p)))

            (when (and (flag? (:argt ea) DFLALL) (zero? (:addr_count ea)))
                ((ร ea =) (assoc ea :line1 1))
                (condp == (:addr_type ea)
                    ADDR_LINES
                    (do
                        ((ร ea =) (assoc ea :line2 (line-count @curbuf)))
                        (ร BREAK)
                    )

                    ADDR_WINDOWS
                    (do
                        ((ร ea =) (assoc ea :line2 (current-win-nr nil)))
                        (ร BREAK)
                    )
                )
            )

            ;; Check for a count.

            (when (and (flag? (:argt ea) COUNT) (asc-isdigit (.at (:arg ea) 0)))
                (ร long n)
                (let [__ (atom (#_Bytes object (:arg ea)))]
                    ((ร n =) (getdigits __))
                    ((ร ea =) (assoc ea :arg @__)))
                ((ร ea =) (update ea :arg skipwhite))
                (when (and (<= n 0) (non-flag? (:argt ea) ZEROR))
                    ((ร errormsg =) e_zerocount)
                    (ร BREAK doend)
                )
                (cond (flag? (:argt ea) NOTADR)    ;; e.g. :buffer 2, :sleep 3
                (do
                    ((ร ea =) (assoc ea :line2 n))
                    (if (zero? (:addr_count ea))
                        ((ร ea =) (assoc ea :addr_count 1))
                    )
                )
                :else
                (do
                    ((ร ea =) (assoc ea :line1 (:line2 ea)))
                    ((ร ea =) (update ea :line2 + (dec n)))
                    ((ร ea =) (update ea :addr_count inc))

                    ;; Be vi compatible: no error message for out of range.

                    ((ร ea =) (update ea :line2 min (line-count @curbuf)))
                ))
            )

            (when (and (non-flag? (:argt ea) EXTRA) (non-eos? (:arg ea)) (not-at? (:arg ea) (byte \"))) ;; """
                ((ร errormsg =) e_trailing)
                (ร BREAK doend)
            )

            (when (and (flag? (:argt ea) NEEDARG) (eos? (:arg ea)))
                ((ร errormsg =) e_argreq)
                (ร BREAK doend)
            )

            ;; Skip the command when it's not going to be executed.
            ;; The commands like :if, :endif, etc. always need to be executed.
            ;; Also make an exception for commands that handle a trailing command themselves.

            (when (:skip ea)
                (condp ==? (:cmdidx ea)
                    ;; Commands that handle '|' themselves.  Check: A command should
                    ;; either have the TRLBAR flag, appear in this list or appear in
                    ;; the list at ":help :bar".
                    CMD_substitute
                    (do
                        (ร BREAK)
                    )

                    (ร DEFAULT)
                    (do
                        (ร BREAK doend)
                    )
                )
            )

            ;; 7. Switch on command name.
            ;;
            ;; The "ea" structure holds the arguments that can be used.

            ((ร ea =) (assoc ea :cmdlinep a'cmdlinep))

            ;; Call the function to execute the command.

            ((ร ea =) (assoc ea :errmsg nil))
;           ea = cmdnames[ea.cmdidx].cmd_func(ea);
            ((ร errormsg =) (if (some? (:errmsg ea)) (:errmsg ea) errormsg))
;       }

        (if (zero? (:lnum (:w_cursor @curwin)))  ;; can happen with zero line number
            (swap! curwin assoc-in [:w_cursor :lnum] 1)
        )

        (when (and (some? errormsg) (non-eos? errormsg) (not @did_emsg))
            (when verbose
                (when (BNE errormsg, @ioBuff)
                    (STRCPY @ioBuff, errormsg)
                    ((ร errormsg =) @ioBuff)
                )
                (append-command @a'cmdlinep)
            )
            (emsg errormsg)
        )

        (if (and (some? (:nextcmd ea)) (eos? (:nextcmd ea)))      ;; not really a next command
            ((ร ea =) (assoc ea :nextcmd nil))
        )

        (:nextcmd ea)
    ))

;; Append "cmd" to the error message in ioBuff.
;; Takes care of limiting the length and handling 0xa0,
;; which would be invisible otherwise.

(defn- #_void append-command [#_Bytes cmd]
    (STRCAT @ioBuff, (u8 ": "))
    (loop [#_Bytes d (.plus @ioBuff (STRLEN @ioBuff)) #_Bytes s cmd] (if (and (non-eos? s) (< (BDIFF d, @ioBuff) (- IOSIZE 7)))
        (if (and (== (char_u (.at s 0)) 0xc2) (== (char_u (.at s 1)) 0xa0))
            (do (STRCPY d, (u8 "<a0>")) (recur (.plus d 4) (.plus s 2)))
            (let [#_int len (us-ptr2len-cc s)] (BCOPY d, s, len) (recur (.plus d len) (.plus s len))))
        (eos! d)
    ))
    nil)

;; Find an Ex command by its name, either built-in or user.
;; Start of the name can be found at eap.cmd.
;; Returns pointer to char after the command name.
;; Returns null for an ambiguous user command.

(defn- #_Bytes find-command [#_exarg_C eap]
    (ยง
        ;; Isolate the command and search for it in the command table.
        ;; Exceptions:
        ;; - the 's' command can be followed directly by 'c', 'g', 'i', 'I' or 'r',
        ;;      but :sre[wind] is another command, as are :scr[iptnames], :scs[cope], :sim[alt], :sig[ns] and :sil[ent].

        ((ร Bytes p =) (:cmd eap))
        (cond (and (at? p (byte \s))
                   (or (and (at? p 1 (byte \c)) (not-at? p 2 (byte \s)) (not-at? p 2 (byte \r)) (not-at? p 3 (byte \i)) (not-at? p 4 (byte \p)))
                       (at? p 1 (byte \g))
                       (and (at? p 1 (byte \i)) (not-at? p 2 (byte \m)) (not-at? p 2 (byte \l)) (not-at? p 2 (byte \g)))
                       (at? p 1 (byte \I))
                       (and (at? p 1 (byte \r)) (not-at? p 2 (byte \e)))))
        (do
            ((ร eap =) (assoc eap :cmdidx CMD_substitute))
            ((ร p =) (.plus p 1))
        )
        :else
        (do
            (loop-when [] (asc-isalpha (.at p 0))
                ((ร p =) (.plus p 1))
                (recur)
            )

            ;; check for non-alpha command
            ((ร p =) (if (and (BEQ p, (:cmd eap)) (some? (vim-strbyte (u8 "@*!=><&~#"), (.at p 0)))) (.plus p 1) p))

            ((ร int len =) (BDIFF p, (:cmd eap)))

            (loop-when-recur [eap (assoc eap :cmdidx 0)] (< (:cmdidx eap) CMD_SIZE) [(update eap :cmdidx inc)]
                (if (zero? (STRNCMP (:cmd_name (... cmdnames (:cmdidx eap))), (:cmd eap), len))
                    (ร BREAK)
                )
            )

            ;; Look for a user defined command as a last resort.
            (when (and (== (:cmdidx eap) CMD_SIZE) (<= (byte \A) (.at (:cmd eap) 0) (byte \Z)))
                ;; User defined commands may contain digits.
                (loop-when [] (asc-isalnum (.at p 0))
                    ((ร p =) (.plus p 1))
                    (recur)
                )
            )

            (if (BEQ p, (:cmd eap))
                ((ร eap =) (assoc eap :cmdidx CMD_SIZE))
            )
        ))

        p
    ))

;; skip a range specifier of the form: addr [,addr] [;addr] ..
;;
;; Backslashed delimiters after / or ? will be skipped, and commands
;; will not be expanded between /'s and ?'s or after "'".
;;
;; Also skip white space and ":" characters.
;; Returns the "s" pointer advanced to beyond the range.

(defn- #_Bytes skip-range [#_Bytes s]
    (let [s (loop-when s (some? (vim-strbyte (u8 " \t0123456789.$%'/?-+,;"), (.at s 0))) => s
                (let [s (cond (at? s (byte \'))
                            (.plus s 1)
                        (or (at? s (byte \/)) (at? s (byte \?)))
                            (let [x (.at s 0)]
                                (loop-when-recur [s (.plus s 1)] (and (non-eos? s) (not-at? s x)) [(if (and (at? s 0 (byte \\)) (non-eos? s 1)) (.plus s 2) (.plus s 1))] => s))
                        :else s)]
                    (recur (if (non-eos? s) (.plus s 1) s))
                ))]
        (loop-when-recur s (at? s (byte \:)) [(skipwhite (.plus s 1))] => s) ;; skip ":" and white space
    ))

;; get a single EX address
;;
;; Set ptr to the next character after the part that was interpreted.
;; Set ptr to null when an error is encountered.
;;
;; Return MAXLNUM when no Ex address was found.

(defn- #_long get-address [#_Bytes' a'ptr, #_int addr_type, #_boolean skip, #_boolean to_other_file]
    ;; addr_type: flag: one of ADDR_LINES, ...
    ;; skip: only skip the address, don't use it
    ;; to_other_file: flag: may jump to other file
    (ยง
        ((ร long lnum =) MAXLNUM)
        ((ร Bytes cmd =) (skipwhite @a'ptr))

;       error:
        (loop []
            (condp ==? (.at cmd 0)
                (byte \.)                       ;; '.' = cursor position
                (do
                    ((ร cmd =) (.plus cmd 1))
                    ((ร lnum =) (condp == addr_type ADDR_LINES (:lnum (:w_cursor @curwin)) ADDR_WINDOWS (current-win-nr @curwin) lnum))
                    (ร BREAK)
                )

                (byte \$)                       ;; '$' = last line
                (do
                    ((ร cmd =) (.plus cmd 1))
                    ((ร lnum =) (condp == addr_type ADDR_LINES (line-count @curbuf) ADDR_WINDOWS (current-win-nr nil) lnum))
                    (ร BREAK)
                )

                (byte \')                      ;; ''' = mark
                (do
                    ((ร cmd =) (.plus cmd 1))
                    (when (eos? cmd)
                        ((ร cmd =) nil)
                        (ร BREAK error)
                    )
                    (when (!= addr_type ADDR_LINES)
                        (emsg e_invaddr)
                        ((ร cmd =) nil)
                        (ร BREAK error)
                    )
                    (cond skip
                    (do
                        ((ร cmd =) (.plus cmd 1))
                    )
                    :else
                    (do
                        ;; Only accept a mark in another file when it is used by itself: ":'M".
                        ((ร pos_C fp =) (getmark (.at cmd 0), (and to_other_file (eos? cmd 1))))
                        ((ร cmd =) (.plus cmd 1))
                        (when (not (check-mark fp))
                            ((ร cmd =) nil)
                            (ร BREAK error)
                        )
                        ((ร lnum =) (:lnum fp))
                    ))
                    (ร BREAK)
                )

               [(byte \/) (byte \?)]                  ;; '/' or '?' = search
                (do
                    ((ร byte c =) (.at ((ร cmd =) (.plus cmd 1)) -1))
                    (when (!= addr_type ADDR_LINES)
                        (emsg e_invaddr)
                        ((ร cmd =) nil)
                        (ร BREAK error)
                    )
                    (cond skip       ;; skip "/pat/"
                    (do
                        ((ร cmd =) (skip-regexp cmd, c, @p_magic, nil))
                        ((ร cmd =) (if (at? cmd c) (.plus cmd 1) cmd))
                    )
                    :else
                    (do
                        ((ร pos_C save_pos =) (NEW_pos_C))
                        (COPY-pos save_pos, (:w_cursor @curwin))

                        ;; When '/' or '?' follows another address, start from there.

                        (when (!= lnum MAXLNUM)
                            (swap! curwin assoc-in [:w_cursor :lnum] lnum))

                        ;; Start a forward search at the end of the line.
                        ;; Start a backward search at the start of the line.
                        ;; This makes sure we never match in the current line,
                        ;; and can match anywhere in the next/previous line.

                        (swap! curwin assoc-in [:w_cursor :col] (if (== c (byte \/)) MAXCOL 0))
                        (reset! searchcmdlen 0)
                        (when (zero? (do-search nil, c, cmd, 1, (| SEARCH_HIS SEARCH_MSG), nil))
                            (swap! curwin assoc :w_cursor save_pos)
                            ((ร cmd =) nil)
                            (ร BREAK error)
                        )
                        ((ร lnum =) (:lnum (:w_cursor @curwin)))
                        (swap! curwin assoc :w_cursor save_pos)
                        ;; adjust command string pointer
                        ((ร cmd =) (.plus cmd @searchcmdlen))
                    ))
                    (ร BREAK)
                )

                (byte \\)              ;; "\?", "\/" or "\&" = repeat search
                (do
                    ((ร cmd =) (.plus cmd 1))
                    (when (!= addr_type ADDR_LINES)
                        (emsg e_invaddr)
                        ((ร cmd =) nil)
                        (ร BREAK error)
                    )
                    (ร int i)
                    (cond (at? cmd (byte \&))
                    (do
                        ((ร i =) RE_SUBST)
                    )
                    (or (at? cmd (byte \?)) (at? cmd (byte \/)))
                    (do
                        ((ร i =) RE_SEARCH)
                    )
                    :else
                    (do
                        (emsg e_backslash)
                        ((ร cmd =) nil)
                        (ร BREAK error)
                    ))

                    (when (not skip)
                        ((ร pos_C pos =) (NEW_pos_C))

                        ;; When search follows another address, start from there.

                        ((ร pos =) (assoc pos :lnum (if (!= lnum MAXLNUM) lnum (:lnum (:w_cursor @curwin)))))

                        ;; Start the search just like for the above do-search().

                        ((ร pos =) (assoc pos :col (if (not-at? cmd (byte \?)) MAXCOL 0)))

                        (cond (!= (searchit pos, (if (at? cmd (byte \?)) BACKWARD FORWARD), (u8 ""), 1, SEARCH_MSG, i, 0, nil) 0)
                        (do
                            ((ร lnum =) (:lnum pos))
                        )
                        :else
                        (do
                            ((ร cmd =) nil)
                            (ร BREAK error)
                        ))
                    )
                    ((ร cmd =) (.plus cmd 1))
                    (ร BREAK)
                )

                (do
                    (when (asc-isdigit (.at cmd 0))     ;; absolute line number
                        (let [__ (atom (#_Bytes object cmd))]
                            ((ร lnum =) (getdigits __))
                            ((ร cmd =) @__))
                    )
                    (ร BREAK)
                )
            )

            (loop []
                ((ร cmd =) (skipwhite cmd))
                (if (and (not-at? cmd (byte \-)) (not-at? cmd (byte \+)) (not (asc-isdigit (.at cmd 0))))
                    (ร BREAK)
                )

                ((ร lnum =) (if (== lnum MAXLNUM) (condp == addr_type ADDR_LINES (:lnum (:w_cursor @curwin)) ADDR_WINDOWS (current-win-nr @curwin) lnum) lnum)) ;; "+1" is same as ".+1"

                ((ร int m =) (if (asc-isdigit (.at cmd 0))
                    (byte \+)                    ;; "number" is same as "+number"
                    (.at ((ร cmd =) (.plus cmd 1)) -1)
                ))
                (ร int n)
                (cond (not (asc-isdigit (.at cmd 0)))    ;; '+' is '+1', but '+0' is not '+1'
                (do
                    ((ร n =) 1)
                )
                :else
                (do
                    (let [__ (atom (#_Bytes object cmd))]
                        ((ร n =) (int (getdigits __)))
                        ((ร cmd =) @__))
                ))
                ((ร lnum =) ((if (== m (byte \-)) - +) lnum n))
                (recur)
            )

            (recur-if (or (at? cmd (byte \/)) (at? cmd (byte \?))) [])
        )

        (reset! a'ptr cmd)
        lnum
    ))

;; Check range in Ex command for validity.
;; Return null when valid, error message when invalid.

(defn- #_Bytes invalid-range [#_exarg_C eap]
    (if (or (< (:line1 eap) 0) (< (:line2 eap) 0) (< (:line2 eap) (:line1 eap)))
        e_invrange
        (when (flag? (:argt eap) RANGE)
            (condp == (:addr_type eap)
                ADDR_LINES
                    (when (and (non-flag? (:argt eap) NOTADR) (< (line-count @curbuf) (:line2 eap))) e_invrange)
                ADDR_WINDOWS
                    (when (< (current-win-nr nil) (:line2 eap)) e_invrange)
            ))
    ))

;; Correct the range for zero line number, if required.

(defn- #_exarg_C correct-range [#_exarg_C eap]
    (if (non-flag? (:argt eap) ZEROR)    ;; zero in range not allowed
        (let [eap (if (zero? (:line1 eap)) (assoc eap :line1 1) eap)
              eap (if (zero? (:line2 eap)) (assoc eap :line2 1) eap)]
            eap)
        eap
    ))

;; Check if *cmd is a separator between Ex commands.
;; Return null if it isn't, (cmd + 1) if it is.

(defn- #_Bytes check-nextcmd [#_Bytes cmd]
    (let-when [cmd (skipwhite cmd)] (or (at? cmd (byte \|)) (at? cmd (byte \newline))) (.plus cmd 1)))

;; ":close": close current window, unless it is the last one

(defn- #_exarg_C ex-close [#_exarg_C eap]
    (cond (non-zero? @cmdwin_type)
        (reset! cmdwin_result Ctrl_C)
    (not (text-locked))
        (ex-win-close (:forceit eap), (if (zero? (:addr_count eap))
            @curwin
            (loop-when-recur [win @firstwin n 1] (and (some? win) (!= n (:line2 eap))) [(:w_next win) (inc n)] => (or win @lastwin)))
        ))
    eap)

;; Close window "win" and take care of handling closing the last window for a modified buffer.

(defn- #_void ex-win-close [#_boolean forceit, #_window_C win]
    (let [#_boolean need_hide (and @(:b_changed @curbuf) (<= (:b_nwindows @curbuf) 1))]
        (if (or (not need_hide) forceit)
            (win-close win, (not need_hide))
            (emsg e_nowrtmsg)
        ))
    nil)

;; ":only".

(defn- #_exarg_C ex-only [#_exarg_C eap]
    (when (< 0 (:addr_count eap))
        (win-goto (loop-when-recur [win @firstwin n (:line2 eap)] (and (< 1 n) (some? (:w_next win))) [(:w_next win) (dec n)] => win)))
    (close-others true, (:forceit eap))
    eap)

;; ":stop" and ":suspend": Suspend Vim.

(defn- #_exarg_C ex-stop [#_exarg_C eap]
    (windgoto (dec @Rows), 0)
    (out-char (byte \newline))
    (out-flush)
    (stop-termcap)
    (out-flush)            ;; needed for SUN to restore xterm buffer
    (ui-suspend)           ;; call machine specific function
    (start-termcap)
    (scroll-start)         ;; scroll screen before redrawing
    (redraw-later-clear)
    (shell-resized)        ;; may have resized window
    eap)

;; ":syncbind" forces all 'scrollbind' windows to have the same relative offset.

(defn- #_exarg_C ex-syncbind [#_exarg_C _eap]
    (let [#_window_C win' @curwin #_long lnum' (:lnum (:w_cursor @curwin))]
        (swap! curwin setpcmark)
        (let [lmax (line-count @curbuf) #_long topline ;; determine max topline
                (if @(:wo_scb (:w_options @curwin))
                    (loop-when [t (:w_topline @curwin) #_window_C w @firstwin] (some? w) => (max 1 t)
                        (recur (if @(:wo_scb (:w_options w)) (min t (- lmax @p_so)) t) (:w_next w)))	;; red?
                    1
                )]
            ;; Set all scrollbind windows to the same topline.
            (loop-when-recur (reset! curwin @firstwin) (some? @curwin) (swap! curwin :w_next)
                (when @(:wo_scb (:w_options @curwin))
                    (let [#_long y (- topline (:w_topline @curwin))]
                        (if (< 0 y)
                            (swap! curwin scrollup y)
                            (swap! curwin scrolldown (- y)))
                    )
                    (swap! curwin assoc :w_scbind_pos topline)
                    (swap! curwin redraw-later VALID)
                    (swap! curwin cursor-correct)
                    (swap! curwin assoc :w_redr_status true)
                )
            )
        )
        (reset! curwin win')
        (when @(:wo_scb (:w_options @curwin))
            (reset! did_syncbind true)
            (swap! curwin checkpcmark)
            (when (!= lnum' (:lnum (:w_cursor @curwin)))
                (ins-typebuf (-> (Bytes. 2) (.be 0, Ctrl_O) (eos! 1)))
            ))
        _eap
    ))

;; Sleep for "msec" milliseconds, but keep checking for a CTRL-C every second.

(defn- #_void do-sleep [#_long msec]
    (cursor-on)
    (out-flush)
    (loop-when-recur [#_long done 0] (and (not @got_int) (< done msec)) [(+ done 1000)]
        (ui-delay (min (- msec done) 1000), true)
        (ui-breakcheck)
    )
    nil)

;; ":set"

(defn- #_exarg_C ex-set [#_exarg_C eap]
    (do-set (:arg eap))
    eap)

;;; ============================================================================================== VimJ

;; eval.c: Expression evaluation ------------------------------------------------------------------

;; Top level evaluation function, returning a string.

(defn- #_Bytes eval-to-string [#_Bytes arg, #_Bytes* nextcmd]
    ;; %% not yet
    nil)

;; Return the time 'msec' past now.

(defn- #_long profile-setlimit [#_long msec]
    (if (< 0 msec)
        (+ (System/nanoTime) (* msec 1000 1000))
        0)) ;; no limit

;; Return true if the current time is past 'nsec'.

(defn- #_boolean profile-passed-limit [#_long nsec]
    (if (zero? nsec) ;; timer was not set
        false
        (< nsec (System/nanoTime))))

;;; ============================================================================================== VimK

;; normal.c ---------------------------------------------------------------------------------------
;; Contains the main routine for processing characters in command mode.
;; Communicates closely with the code in ops.c to handle the operators.

;; The Visual area is remembered for reselection.

(atom! int      resel_VIsual_mode       NUL)    ;; 'v', 'V', or Ctrl-V
(atom! long     resel_VIsual_lmax)              ;; number of lines
(atom! int      resel_VIsual_vcol)              ;; nr of cols or end col
(atom! int      VIsual_mode_orig        NUL)    ;; saved Visual mode

(atom! int      restart_VIsual_select)

;; nv_*(): functions called to handle Normal and Visual mode commands.
;; n_*(): functions called to handle Normal mode commands.
;; v_*(): functions called to handle Visual mode commands.

(final Bytes e_noident (u8 "E349: No identifier under cursor"))

;; Values for cmd_flags.
(final int NV_NCH      0x01)            ;; may need to get a second char
(final int NV_NCH_NOP  (| 0x02 NV_NCH))   ;; get second char when no operator pending
(final int NV_NCH_ALW  (| 0x04 NV_NCH))   ;; always get a second char
(final int NV_LANG     0x08)            ;; second char needs language adjustment

(final int NV_SS       0x10)            ;; may start selection
(final int NV_SSS      0x20)            ;; may start selection with shift modifier
(final int NV_STS      0x40)            ;; may stop selection without shift modif.
(final int NV_RL       0x80)            ;; 'rightleft' modifies command
(final int NV_KEEPREG  0x100)           ;; don't clear regname
(final int NV_NCW      0x200)           ;; not allowed in command-line window

;; Generally speaking, every Normal mode command should either clear any
;; pending operator (with *clearop*()), or set the motion type variable
;; oap.motion_type.
;;
;; When a cursor motion command is made, it is marked as being a character or
;; line oriented motion.  Then, if an operator is in effect, the operation
;; becomes character or line oriented accordingly.

;; Function to be called for a Normal or Visual mode command.
;; The argument is a cmdarg_C.

(class! #_final nv_cmd_C
    [
        (field int          cmd_char)           ;; (first) command character
        (field nv_func_F    cmd_func)           ;; function for this command
        (field int          cmd_flags)          ;; NV_ flags
        (field int          cmd_arg)            ;; value for ca.arg
    ])

;; Search for a command in the commands table.
;; Returns -1 for invalid command.

(defn- #_int find--command [#_int cmdchar]
    ;; A multi-byte character is never a command.
    (if (<= 0x100 cmdchar)
        -1
;       %% return nv_cmds index for cmd_char or -1
    )
)

;; Execute a command in Normal mode.

(defn- #_void normal-cmd [#_oparg_C oap, #_boolean toplevel]
    ;; toplevel: true when called from main()
    (ยง
        ((ร int old_col =) (:w_curswant @curwin))

        ((ร cmdarg_C ca =) (NEW_cmdarg_C))   ;; command arguments
        ((ร ca =) (assoc ca :oap oap))

        ;; Use a count remembered from before entering an operator.
        ;; After typing "3d" we return from normal-cmd() and come back here,
        ;; the "3" is remembered in "opcount".
        ((ร ca =) (assoc ca :opcount @opcount))

        ;; If there is an operator pending, then the command we take this time
        ;; will terminate it.  finish_op tells us to finish the operation before
        ;; returning this time (unless the operation was cancelled).

        ((ร boolean save_finish_op =) @finish_op)
        (reset! finish_op (!= (:op_type oap) OP_NOP))
        (when (!= @finish_op save_finish_op)
            (ui-cursor-shape)              ;; may show different cursor shape
        )

        ;; When not finishing an operator and no register name typed, reset the count.
        (when (and (not @finish_op) (zero? (:regname oap)))
            ((ร ca =) (assoc ca :opcount 0))
        )

        ;; Restore counts from before receiving K_CURSORHOLD.
        ;; This means after typing "3", handling K_CURSORHOLD
        ;; and then typing "2" we get "32", not "3 * 2".
        (when (or (< 0 (:prev_opcount oap)) (< 0 (:prev_count0 oap)))
            ((ร ca =) (assoc ca :opcount (:prev_opcount oap)))
            ((ร ca =) (assoc ca :count0 (:prev_count0 oap)))
            ((ร oap =) (assoc oap :prev_opcount 0))
            ((ร oap =) (assoc oap :prev_count0 0))
        )

        (reset! State NORMAL_BUSY)

        ;; Get the command character from the user.

        ((ร int c =) (safe-vgetc))

        ((ร c =) (if (== c NUL) K_ZERO c))

        ;; In Select mode, typed text replaces the selection.

        (when (and @VIsual_active @VIsual_select (or (vim-isprintc c) (== c NL) (== c CAR) (== c K_KENTER)))
            ;; Fake a "c"hange command.
            ;; When "restart_edit" is set (e.g., because 'insertmode' is set)
            ;; fake a "d"elete command, Insert mode will restart automatically.
            ;; Insert the typed character in the typeahead buffer, so it can be
            ;; mapped in Insert mode.  Required for ":lmap" to work.
            (ins-char-typebuf c)
            ((ร c =) (if (non-zero? @restart_edit) (byte \d) (byte \c)))
            (reset! msg_nowait true)      ;; don't delay going to insert mode
        )

        ((ร boolean need_flushbuf =) (add-to-showcmd c))      ;; need to call out-flush()
        ((ร boolean ctrl_w =) false)                         ;; got CTRL-W command

;       getcount:
        (loop []
            (when (not (and @VIsual_active @VIsual_select))
                ;; Handle a count before a command and compute ca.count0.
                ;; Note that '0' is a command and not the start of a count,
                ;; but it's part of a count after other digits.

                (loop-when [] (or (<= (byte \1) c (byte \9)) (and (!= (:count0 ca) 0) (any == c K_DEL K_KDEL (byte \0))))
                    (cond (any == c K_DEL K_KDEL)
                    (do
                        ((ร ca =) (assoc ca :count0 (/ (:count0 ca) 10)))
                        (del-from-showcmd 4)    ;; delete the digit and ~@%
                    )
                    :else
                    (do
                        ((ร ca =) (assoc ca :count0 (+ (* (:count0 ca) 10) (- c (byte \0)))))
                    ))
                    (if (< (:count0 ca) 0)          ;; got too large!
                        ((ร ca =) (assoc ca :count0 999999999))
                    )

                    (when ctrl_w
                        (swap! no_mapping inc)
                        (swap! allow_keys inc)           ;; no mapping for nchar, but keys
                    )
                    ((ร c =) (plain-vgetc))
                    (when ctrl_w
                        (swap! no_mapping dec)
                        (swap! allow_keys dec)
                    )
                    ((ร need_flushbuf =) (| need_flushbuf (add-to-showcmd c)))
                    (recur)
                )

                ;; If we got CTRL-W there may be a/another count

                (when (and (== c Ctrl_W) (not ctrl_w) (== (:op_type oap) OP_NOP))
                    ((ร ctrl_w =) true)
                    ((ร ca =) (assoc ca :opcount (:count0 ca)))     ;; remember first count
                    ((ร ca =) (assoc ca :count0 0))
                    (swap! no_mapping inc)
                    (swap! allow_keys inc)               ;; no mapping for nchar, but keys
                    ((ร c =) (plain-vgetc))          ;; get next character
                    (swap! no_mapping dec)
                    (swap! allow_keys dec)
                    ((ร need_flushbuf =) (| need_flushbuf (add-to-showcmd c)))
                    (ร CONTINUE getcount)              ;; jump back
                )
            )

            (ร BREAK)
            (recur)
        )

        (cond (== c K_CURSORHOLD)
        (do
            ;; Save the count values so that ca.opcount and ca.count0 are exactly
            ;; the same when coming back here after handling K_CURSORHOLD.
            ((ร oap =) (assoc oap :prev_opcount (:opcount ca)))
            ((ร oap =) (assoc oap :prev_count0 (:count0 ca)))
        )
        (non-zero? (:opcount ca))
        (do
            ;; If we're in the middle of an operator (including after entering a
            ;; yank buffer with '"') AND we had a count before the operator, then
            ;; that count overrides the current value of ca.count0.
            ;; What this means effectively, is that commands like "3dw" get turned
            ;; into "d3w" which makes things fall into place pretty neatly.
            ;; If you give a count before AND after the operator, they are multiplied.

            ((ร ca =) (assoc ca :count0 (if (non-zero? (:count0 ca)) (* (:count0 ca) (:opcount ca)) (:opcount ca))))
        ))

        ;; Always remember the count.
        ;; It will be set to zero (on the next call, above) when there is no pending operator.
        ;; When called from main(), save the count for use by the "count" built-in variable.

        ((ร ca =) (assoc ca :opcount (:count0 ca)))
        ((ร ca =) (assoc ca :count1 (if (zero? (:count0 ca)) 1 (:count0 ca))))

        ;; Find the command character in the table of commands.
        ;; For CTRL-W we already got nchar when looking for a count.

        (cond ctrl_w
        (do
            ((ร ca =) (assoc ca :nchar c))
            ((ร ca =) (assoc ca :cmdchar Ctrl_W))
        )
        :else
        (do
            ((ร ca =) (assoc ca :cmdchar c))
        ))

;       normal_end:
;       {
            ((ร int idx =) (find--command (:cmdchar ca)))
            (when (< idx 0)
                ;; Not a known command: beep.
                (clearopbeep oap)
                (ร BREAK normal_end)
            )

            (when (and (text-locked) (flag? (:cmd_flags (... nv_cmds idx)) NV_NCW))
                ;; This command is not allowed while editing a cmdline: beep.
                (clearopbeep oap)
                (text-locked-msg)
                (ร BREAK normal_end)
            )

            ;; In Visual/Select mode, a few keys are handled in a special way.

            (when @VIsual_active
                ;; when 'keymodel' contains "stopsel" may stop Select/Visual mode
                (when (and @km_stopsel (flag? (:cmd_flags (... nv_cmds idx)) NV_STS) (non-flag? @mod_mask MOD_MASK_SHIFT))
                    (swap! curwin end-visual-mode)
                    (redraw-curbuf-later INVERTED)
                )

                ;; Keys that work different when 'keymodel' contains "startsel".
                (when @km_startsel
                    (cond (flag? (:cmd_flags (... nv_cmds idx)) NV_SS)
                    (do
                        ((ร ca =) (unshift-special ca))
                        ((ร idx =) (find--command (:cmdchar ca)))
                        (when (< idx 0)
                            ;; Just in case.
                            (clearopbeep oap)
                            (ร BREAK normal_end)
                        )
                    )
                    (and (flag? (:cmd_flags (... nv_cmds idx)) NV_SSS) (flag? @mod_mask MOD_MASK_SHIFT))
                    (do
                        (swap! mod_mask & (bit-not MOD_MASK_SHIFT))
                    ))
                )
            )

            ;; Get an additional character if we need one.

            (when (and (!= (& (:cmd_flags (... nv_cmds idx)) NV_NCH) 0) (or (and (== (& (:cmd_flags (... nv_cmds idx)) NV_NCH_NOP) NV_NCH_NOP) (== (:op_type oap) OP_NOP)) (== (& (:cmd_flags (... nv_cmds idx)) NV_NCH_ALW) NV_NCH_ALW) (and (== (:cmdchar ca) (byte \q)) (== (:op_type oap) OP_NOP) (not @Recording) (not @execReg)) (and (any == (:cmdchar ca) (byte \a) (byte \i)) (or (!= (:op_type oap) OP_NOP) @VIsual_active))))
                ((ร boolean repl =) false)                   ;; get character for replace mode
                ((ร boolean lit =) false)                    ;; get extra character literally

                (swap! no_mapping inc)
                (swap! allow_keys inc)                           ;; no mapping for nchar, but allow key codes
                ;; Don't generate a CursorHold event here,
                ;; most commands can't handle it, e.g. nv-replace(), nv-csearch().
                (reset! did_cursorhold true)
                (ร keyword k'char)
                (cond (== (:cmdchar ca) (byte \g))
                (do
                    ;; For 'g' get the next character now, so that we can check for "gr", "g'" and "g`".

                    ((ร ca =) (assoc ca :nchar (plain-vgetc)))
                    ((ร need_flushbuf =) (| need_flushbuf (add-to-showcmd (:nchar ca))))
                    (cond (any == (:nchar ca) (byte \r) (byte \') (byte \`) Ctrl_BSL)
                    (do
                        ((ร k'char =) :extra_char)            ;; need to get a third character
                        (if (!= (:nchar ca) (byte \r))
                            ((ร lit =) true)                 ;; get it literally
                            ((ร repl =) true)                ;; get it in replace mode
                        )
                    )
                    :else
                    (do
                        ((ร k'char =) nil)                      ;; no third character needed
                    ))
                )
                :else
                (do
                    ((ร repl =) (or (== (:cmdchar ca) (byte \r)) repl))              ;; get it in replace mode
                    ((ร k'char =) :nchar)
                ))

                ((ร boolean lang =) (or repl (!= (& (:cmd_flags (... nv_cmds idx)) NV_LANG) 0)))

                ;; Get a second or third character.

                (when (some? k'char)
                    (when repl
                        (reset! State REPLACE)                ;; pretend Replace mode
                        (ui-cursor-shape)              ;; show different cursor shape
                    )

                    ((ร ca.k'char =) (plain-vgetc))

                    (reset! State NORMAL_BUSY)
                    ((ร need_flushbuf =) (| need_flushbuf (add-to-showcmd (k'char ca))))

                    (when (not lit)
                        ;; Typing CTRL-K gets a digraph.
                        (when (and (== (k'char ca) Ctrl_K) (or (flag? (:cmd_flags (... nv_cmds idx)) NV_LANG) (== k'char :extra_char)) (nil? (vim-strbyte @p_cpo, CPO_DIGRAPH)))
                            ((ร c =) (get-digraph false))
                            (when (< 0 c)
                                ((ร ca.k'char =) c)
                                ;; Guessing how to update showcmd here...
                                (del-from-showcmd 3)
                                ((ร need_flushbuf =) (| need_flushbuf (add-to-showcmd (k'char ca))))
                            )
                        )
                    )

                    ;; When the next character is CTRL-\ a following CTRL-N means
                    ;; the command is aborted and we go to Normal mode.

                    (cond (and (== k'char :extra_char) (== (:nchar ca) Ctrl_BSL) (any == (:extra_char ca) Ctrl_N Ctrl_G))
                    (do
                        ((ร ca =) (assoc ca :cmdchar Ctrl_BSL))
                        ((ร ca =) (assoc ca :nchar (:extra_char ca)))
                        ((ร idx =) (find--command (:cmdchar ca)))
                    )
                    (and (any == (:nchar ca) (byte \n) (byte \N)) (== (:cmdchar ca) (byte \g)))
                    (do
                        ((ร ca =) (assoc-in ca [:oap :op_type] (get-op-type (k'char ca), NUL)))
                    )
                    (== (k'char ca) Ctrl_BSL)
                    (do
                        ((ร long towait =) (if (<= 0 @p_ttm) @p_ttm @p_tm))

                        ;; There is a busy wait here when typing "f<C-\>" and then
                        ;; something different from CTRL-N.  Can't be avoided.
                        (loop-when [] (and (<= ((ร c =) (vpeekc)) 0) (< 0 towait))
                            (do-sleep (min towait 50))
                            ((ร towait =) (- towait 50))
                            (recur)
                        )
                        (when (< 0 c)
                            ((ร c =) (plain-vgetc))
                            (cond (and (!= c Ctrl_N) (!= c Ctrl_G))
                            (do
                                (vungetc c)
                            )
                            :else
                            (do
                                ((ร ca =) (assoc ca :cmdchar Ctrl_BSL))
                                ((ร ca =) (assoc ca :nchar c))
                                ((ร idx =) (find--command (:cmdchar ca)))
                            ))
                        )
                    ))

                    ;; When getting a text character and the next character is a multi-byte character,
                    ;; it could be a composing character.  However, don't wait for it to arrive.
                    ;; Also, do enable mapping, because if it's put back with vungetc() it's too late
                    ;; to apply mapping.
                    (swap! no_mapping dec)
                    (loop-when [] (and lang (< 0 ((ร c =) (vpeekc))) (or (<= 0x100 c) (< 1 (mb-byte2len (vpeekc)))))
                        ((ร c =) (plain-vgetc))
                        (cond (not (utf-iscomposing c))
                        (do
                            (vungetc c)         ;; it wasn't, put it back
                            (ร BREAK)
                        )
                        (zero? (:ncharC1 ca))
                        (do
                            ((ร ca.ncharC1 =) c)
                        )
                        :else
                        (do
                            ((ร ca.ncharC2 =) c)
                        ))
                        (recur)
                    )
                    (swap! no_mapping inc)
                )
                (swap! no_mapping dec)
                (swap! allow_keys dec)
            )

            ;; Flush the showcmd characters onto the screen so we can see them while the command
            ;; is being executed.  Only do this when the shown command was actually displayed,
            ;; otherwise this will slow down a lot when executing mappings.

            (when need_flushbuf
                (out-flush))
            (when (!= (:cmdchar ca) K_IGNORE)
                (reset! did_cursorhold false))

            (reset! State NORMAL)

            (when (== (:nchar ca) ESC)
                (clearop oap)
                (if (and (zero? @restart_edit) (goto-im))
                    (reset! restart_edit (byte \a)))
                (ร BREAK normal_end)
            )

            (when (!= (:cmdchar ca) K_IGNORE)
                (reset! msg_didout false)         ;; don't scroll screen up for normal command
                (reset! msg_col 0)
            )

            ((ร pos_C old_pos =) (NEW_pos_C))
            (COPY-pos old_pos, (:w_cursor @curwin))     ;; remember where cursor was

            ;; When 'keymodel' contains "startsel" some keys start Select/Visual mode.
            (when (and (not @VIsual_active) @km_startsel)
                (cond (flag? (:cmd_flags (... nv_cmds idx)) NV_SS)
                (do
                    (swap! curwin start-selection)
                    ((ร ca =) (unshift-special ca))
                    ((ร idx =) (find--command (:cmdchar ca)))
                )
                (and (flag? (:cmd_flags (... nv_cmds idx)) NV_SSS) (flag? @mod_mask MOD_MASK_SHIFT))
                (do
                    (swap! curwin start-selection)
                    (swap! mod_mask & (bit-not MOD_MASK_SHIFT))
                ))
            )

            ;; Execute the command!
            ;; Call the command function found in the commands table.

            ((ร ca =) (assoc ca :arg (:cmd_arg (... nv_cmds idx))))
;           ca = nv_cmds[idx].cmd_func(ca);

            ;; If we didn't start or finish an operator, reset oap.regname, unless we need it later.

            (when (and (not @finish_op) (== (:op_type oap) OP_NOP) (or (< idx 0) (zero? (& (:cmd_flags (... nv_cmds idx)) NV_KEEPREG))))
                (clearop oap)
            )

            ;; If an operation is pending, handle it...

            ((ร ca =) (do-pending-operator ca, old_col))

            ;; Wait for a moment when a message is displayed that will be overwritten by the mode message.
            ;; In Visual mode and with "^O" in Insert mode, a short message will be
            ;; overwritten by the mode message.  Wait a bit, until a key is hit.
            ;; In Visual mode, it's more important to keep the Visual area updated
            ;; than keeping a message (e.g. from a /pat search).
            ;; Only do this if the command was typed, not from a mapping.
            ;; Also wait a bit after an error message, e.g. for "^O:".
            ;; Don't redraw the screen, it would remove the message.

            (when (and (or (and @p_smd (or (!= @restart_edit 0) (and @VIsual_active (== (:lnum old_pos) (:lnum (:w_cursor @curwin))) (== (:col old_pos) (:col (:w_cursor @curwin))))) (or @clear_cmdline @redraw_cmdline) (or @msg_didout (and @msg_didany @msg_scroll)) (not @msg_nowait) @keyTyped) (and (!= @restart_edit 0) (not @VIsual_active) (or @msg_scroll @emsg_on_display))) (== (:regname oap) 0) (non-flag? (:retval ca) CA_COMMAND_BUSY) (stuff-empty) (not @did_wait_return) (== (:op_type oap) OP_NOP))
                ((ร int save_State =) @State)

                ;; Draw the cursor with the right shape here.
                (when (non-zero? @restart_edit)
                    (reset! State INSERT))

                ;; If need to redraw, and there is a "keep_msg", redraw before the delay.
                (when (and (non-zero? @must_redraw) (some? @keep_msg) (not @emsg_on_display))
                    ((ร Bytes kmsg =) @keep_msg)
                    (reset! keep_msg nil)
                    ;; showmode() will clear "keep_msg", but we want to use it anyway
                    (update-screen 0)
                    ;; now reset it, otherwise it's put in the history again
                    (reset! keep_msg kmsg)
                    (msg-attr kmsg, @keep_msg_attr)
                )
                (setcursor)
                (cursor-on)
                (out-flush)
                (if (or @msg_scroll @emsg_on_display)
                    (ui-delay 1000, true))      ;; wait at least one second
                (ui-delay 3000, false)         ;; wait up to three seconds
                (reset! State save_State)

                (reset! msg_scroll false)
                (reset! emsg_on_display false)
            )
;       }

        ;; Finish up after executing a Normal mode command.

        (reset! msg_nowait false)

        ;; Reset finish_op, in case it was set.
        ((ร save_finish_op =) @finish_op)
        (reset! finish_op false)
        ;; Redraw the cursor with another shape,
        ;; if we were in Operator-pending mode or did a replace command.
        (when (or save_finish_op (== (:cmdchar ca) (byte \r)))
            (ui-cursor-shape)              ;; may show different cursor shape
        )

        (when (and (== (:op_type oap) OP_NOP) (zero? (:regname oap)) (!= (:cmdchar ca) K_CURSORHOLD))
            (clear-showcmd @curwin))

        (swap! curwin checkpcmark)                      ;; check if we moved since setting pcmark
        ((ร ca =) (assoc ca :searchbuf nil))

        (swap! curwin update :w_cursor mb-adjust-pos)

        (when (and @(:wo_scb (:w_options @curwin)) toplevel)
            (swap! curwin validate-cursor)              ;; may need to update "w_leftcol"
            (swap! curwin do-check-scrollbind true)
        )

        (when (and @(:wo_crb (:w_options @curwin)) toplevel)
            (swap! curwin validate-cursor)              ;; may need to update "w_leftcol"
            (do-check-cursorbind)
        )

        ;; May restart edit(), if we got here with CTRL-O in Insert mode
        ;; (but not if still inside a mapping that started in Visual mode).
        ;; May switch from Visual to Select mode after CTRL-O command.

        (when (and (== (:op_type oap) OP_NOP) (or (and (non-zero? @restart_edit) (not @VIsual_active)) (== @restart_VIsual_select 1)) (non-flag? (:retval ca) CA_COMMAND_BUSY) (stuff-empty) (zero? (:regname oap)))
            (when (== @restart_VIsual_select 1)
                (reset! VIsual_select true)
                (showmode)
                (reset! restart_VIsual_select 0)
            )
            (if (and (non-zero? @restart_edit) (not @VIsual_active))
                (edit @restart_edit, false, 1))
        )

        (when (== @restart_VIsual_select 2)
            (reset! restart_VIsual_select 1))

        ;; Save count before an operator for next time.
        (reset! opcount (:opcount ca))
        nil
    ))

;; The visual area is remembered for redo.
(atom! int      redo_VIsual_mode NUL)       ;; 'v', 'V', or Ctrl-V
(atom! long     redo_VIsual_lmax)           ;; number of lines
(atom! int      redo_VIsual_vcol)           ;; number of cols or end column
(atom! long     redo_VIsual_count)          ;; count for Visual operator

;; Handle an operator after visual mode or when the movement is finished.

(defn- #_cmdarg_C do-pending-operator [#_cmdarg_C cap, #_int o'col]
    (let [win @curwin o'lbr @(:wo_lbr (:w_options win))
          ;; If an operation is pending, handle it...
          [win cap oap]
            (let-when [oap (:oap cap)] (and (or @finish_op @VIsual_active) (!= (:op_type oap) OP_NOP)) => [win cap oap]
                ;; Avoid a problem with unwanted linebreaks in block mode.
                (let [_ (reset! (:wo_lbr (:w_options win)) false)
                      oap (assoc oap :is_VIsual @VIsual_active)
                      oap (condp == (:motion_force oap)
                            (byte \V)
                                (assoc oap :motion_type MLINE)
                            (byte \v)
                                ;; If the motion was linewise, "inclusive" will not have been set.
                                ;; Use "exclusive" to be consistent.  Makes "dvj" work nice.
                                (let [oap (condp == (:motion_type oap)
                                            MLINE (assoc oap :inclusive false)
                                            ;; If the motion already was characterwise, toggle "inclusive".
                                            MCHAR (update oap :inclusive not)
                                                  oap
                                        )]
                                    (assoc oap :motion_type MCHAR))
                            Ctrl_V
                                (do ;; Change line- or characterwise motion into Visual block mode.
                                    (reset! VIsual_active true)
                                    (reset! VIsual_cursor (:op_start oap))
                                    (reset! VIsual_mode Ctrl_V)
                                    (reset! VIsual_select false)
                                    (reset! VIsual_reselect false)
                                    oap)
                            oap
                        )]
                    (let-when [t (:op_type oap)]
                          (and (or (some? (vim-strbyte @p_cpo, CPO_YANK)) (!= t OP_YANK)) ;; Only redo yank when 'y' flag is in 'cpoptions'.
                               (or (not @VIsual_active) (non-zero? (:motion_force oap)) (and @VIsual_active (== (:cmdchar cap) (byte \:)) (!= t OP_COLON)))
                               (!= (:cmdchar cap) (byte \D)))
                        (prep-redo (:regname oap), (:count0 cap), (get-op-char t), (get-extra-op-char t), (:motion_force oap), (:cmdchar cap), (:nchar cap))
                        (cond (any == (:cmdchar cap) (byte \/) (byte \?)) ;; was a search
                            (do ;; If 'cpoptions' does not contain 'r',
                                ;; insert the search pattern to really repeat the same command.
                                (when (nil? (vim-strbyte @p_cpo, CPO_REDO))
                                    (append-redo-lit (:searchbuf cap), -1))
                                (append-redo NL_STR))
                        (== (:cmdchar cap) (byte \:))
                            ;; do-cmdline() has stored the first typed line in "repeat_cmdline".
                            ;; When several lines are typed, repeating won't be possible.
                            (if (some? @repeat_cmdline)
                                (do (append-redo-lit @repeat_cmdline, -1)
                                    (append-redo NL_STR)
                                    (reset! repeat_cmdline nil))
                                (reset-redo))
                        ))
                    (let [[win cap oap include_eol?]
                            (cond @redo_VIsual_busy
                                ;; Redo of an operation on a Visual area.
                                ;; Use the same size from redo_VIsual_lmax and redo_VIsual_vcol.
                                (let [oap (assoc oap :op_start (:w_cursor win))
                                      win (update-in win [:w_cursor :lnum] #(min (+ % (dec @redo_VIsual_lmax)) (line-count @curbuf)))
                                      _ (reset! VIsual_mode @redo_VIsual_mode)
                                      win (if (or (== @redo_VIsual_vcol MAXCOL) (== @VIsual_mode (byte \v)))
                                            (let [win (if (== @VIsual_mode (byte \v))
                                                        (if (<= @redo_VIsual_lmax 1)
                                                            (let [win (validate-virtcol win)]
                                                                (assoc win :w_curswant (dec (+ (:w_virtcol win) @redo_VIsual_vcol))))
                                                            (assoc win :w_curswant @redo_VIsual_vcol))
                                                        (assoc win :w_curswant MAXCOL)
                                                    )]
                                                (coladvance win, (:w_curswant win)))
                                            win)
                                      cap (assoc cap :count0 @redo_VIsual_count, :count1 (if (non-zero? @redo_VIsual_count) @redo_VIsual_count 1))]
                                    [win cap oap false])
                            @VIsual_active
                                (do ;; Save the current VIsual area for '< and '> marks, and "gv".
                                    (swap! curbuf update :b_visual assoc :vi_start @VIsual_cursor, :vi_end (:w_cursor win), :vi_mode @VIsual_mode)
                                    (when (!= @VIsual_mode_orig NUL)
                                        (swap! curbuf assoc-in [:b_visual :vi_mode] @VIsual_mode_orig)
                                        (reset! VIsual_mode_orig NUL))
                                    (swap! curbuf assoc-in [:b_visual :vi_curswant] (:w_curswant win))
                                    ;; In Select mode,
                                    ;; a linewise selection is operated upon like a characterwise selection.
                                    (let [[win include_eol?]
                                            (cond (and @VIsual_select (== @VIsual_mode (byte \V)))
                                                (let [win (if (ltpos @VIsual_cursor, (:w_cursor win))
                                                            (let [_ (swap! VIsual_cursor assoc :col 0)
                                                                  win (assoc-in win [:w_cursor :col] (STRLEN (ml-get (:lnum (:w_cursor win)))))]
                                                                win)
                                                            (let [win (assoc-in win [:w_cursor :col] 0)
                                                                  _ (swap! VIsual_cursor assoc :col (STRLEN (ml-get (:lnum @VIsual_cursor))))]
                                                                win)
                                                        )]
                                                    (reset! VIsual_mode (byte \v))
                                                    [win false])
                                            ;; If 'selection' is "exclusive", backup one character for charwise selections.
                                            (== @VIsual_mode (byte \v))
                                                [win (unadjust-for-sel)]
                                            :else
                                                [win false])
                                          oap (assoc oap :op_start @VIsual_cursor)
                                          oap (if (== @VIsual_mode (byte \V)) (assoc-in oap [:op_start :col] 0) oap)]
                                        [win cap oap include_eol?]
                                    ))
                            :else
                                [win cap oap false])
                          ;; Set oap.op_start to the first position of the operated text, oap.op_end
                          ;; to the end of the operated text.  "w_cursor" is equal to oap.op_start.
                          [win oap]
                            (if (ltpos (:op_start oap), (:w_cursor win))
                                (let [oap (assoc oap :op_end (:w_cursor win))
                                      win (assoc win :w_cursor (:op_start oap))]
                                    ;; "w_virtcol" may have been updated;
                                    ;; if the cursor goes back to its previous position,
                                    ;; "w_virtcol" becomes invalid and isn't updated automatically.
                                    [(update win :w_valid & (bit-not VALID_VIRTCOL)) oap])
                                (let [oap (assoc oap :op_end (:op_start oap))
                                      oap (assoc oap :op_start (:w_cursor win))]
                                    [win oap]
                                ))
                          oap (assoc oap :line_count (inc (- (:lnum (:op_end oap)) (:lnum (:op_start oap)))))
                          ;; Set "virtual_op" before resetting VIsual_active.
                          _ (reset! virtual_op (if (virtual-active) TRUE FALSE))
                          [win oap]
                            (if (or @VIsual_active @redo_VIsual_busy)
                                (let [[win oap]
                                        (if (== @VIsual_mode Ctrl_V)  ;; block mode
                                            (let [oap (assoc oap :block_mode true)
                                                  a'start (atom (int (:start_vcol oap))) a'end (atom (int (:end_vcol oap)))
                                                  _ (getvvcol win, (:op_start oap), a'start, nil, a'end)
                                                  oap (assoc oap :start_vcol @a'start :end_vcol @a'end)
                                                  oap (if (not @redo_VIsual_busy)
                                                        (let [_ (getvvcol win, (:op_end oap), a'start, nil, a'end)
                                                              oap (update oap :start_vcol min @a'start)]
                                                            (if (< (:end_vcol oap) @a'end)
                                                                (assoc oap :end_vcol
                                                                    (if (and (at? @p_sel (byte \e)) (<= 1 @a'start) (<= (:end_vcol oap) (dec @a'start))) (dec @a'start) @a'end))
                                                                oap
                                                            ))
                                                        oap)
                                                  ;; if '$' was used, get oap.end_vcol from longest line
                                                  [win oap]
                                                    (cond (== (:w_curswant win) MAXCOL)
                                                        (let [win (update win :w_cursor assoc :lnum (:lnum (:op_start oap)) :col MAXCOL)]
                                                            (loop-when [win win oap (assoc oap :end_vcol 0)] (<= (:lnum (:w_cursor win)) (:lnum (:op_end oap))) => [win oap]
                                                                (let [_ (getvvcol win, (:w_cursor win), nil, nil, a'end)
                                                                      oap (update oap :end_vcol max @a'end)
                                                                      win (update-in win [:w_cursor :lnum] inc)]
                                                                    (recur win oap))
                                                            ))
                                                    @redo_VIsual_busy
                                                        [win (assoc oap :end_vcol (dec (+ (:start_vcol oap) @redo_VIsual_vcol)))]
                                                    :else
                                                        [win oap])
                                                  ;; Correct oap.op_end.col and oap.op_start.col to be the
                                                  ;; upper-left and lower-right corner of the block area.
                                                  ;;
                                                  ;; (Actually, this does convert column positions into character positions.)
                                                  win (assoc-in win [:w_cursor :lnum] (:lnum (:op_end oap)))
                                                  win (coladvance win, (:end_vcol oap))
                                                  oap (assoc oap :op_end (:w_cursor win))
                                                  win (assoc win :w_cursor (:op_start oap))
                                                  win (coladvance win, (:start_vcol oap))
                                                  oap (assoc oap :op_start (:w_cursor win))]
                                                [win oap])
                                            [win oap])
                                      oap (if (not @redo_VIsual_busy)
                                            ;; Prepare to reselect and redo Visual:
                                            ;; this is based on the size of the Visual text.
                                            (let [_ (reset! resel_VIsual_mode @VIsual_mode)
                                                  oap (if (== (:w_curswant win) MAXCOL)
                                                        (do (reset! resel_VIsual_vcol MAXCOL)
                                                            oap)
                                                        (let [oap (if (!= @VIsual_mode Ctrl_V)
                                                                    (assoc oap :end_vcol
                                                                        (let [__ (atom (int (:end_vcol oap)))] (getvvcol win, (:op_end oap), nil, nil, __) @__))
                                                                    oap
                                                                )]
                                                            (if (or (== @VIsual_mode Ctrl_V) (<= (:line_count oap) 1))
                                                                (let [oap (if (!= @VIsual_mode Ctrl_V)
                                                                            (assoc oap :start_vcol
                                                                                (let [__ (atom (int (:start_vcol oap)))] (getvvcol win, (:op_start oap), __, nil, nil) @__))
                                                                            oap
                                                                        )]
                                                                    (reset! resel_VIsual_vcol (inc (- (:end_vcol oap) (:start_vcol oap))))
                                                                    oap)
                                                                (do (reset! resel_VIsual_vcol (:end_vcol oap))
                                                                    oap)
                                                            ))
                                                    )]
                                                (reset! resel_VIsual_lmax (:line_count oap))
                                                oap)
                                            oap
                                        )]
                                    ;; can't redo yank (unless 'y' is in 'cpoptions') and ":"
                                    (let-when [t (:op_type oap)] (and (or (some? (vim-strbyte @p_cpo, CPO_YANK)) (!= t OP_YANK)) (!= t OP_COLON) (zero? (:motion_force oap)))
                                        ;; Prepare for redoing.
                                        ;; Only use the nchar field for "r", otherwise it might be the second char of the operator.
                                        (cond (and (== (:cmdchar cap) (byte \g)) (any == (:nchar cap) (byte \n) (byte \N)))
                                            (prep-redo (:regname oap), (:count0 cap), (get-op-char t), (get-extra-op-char t), (:motion_force oap), (:cmdchar cap), (:nchar cap))
                                        (!= (:cmdchar cap) (byte \:))
                                            (prep-redo (:regname oap), 0, NUL, (byte \v), (get-op-char t), (get-extra-op-char t), (if (== t OP_REPLACE) (:nchar cap) NUL))
                                        )
                                        (when (not @redo_VIsual_busy)
                                            (reset! redo_VIsual_mode @resel_VIsual_mode)
                                            (reset! redo_VIsual_vcol @resel_VIsual_vcol)
                                            (reset! redo_VIsual_lmax @resel_VIsual_lmax)
                                            (reset! redo_VIsual_count (:count0 cap))
                                        ))
                                    ;; oap.inclusive defaults to true.
                                    ;; If oap.op_end is on a NUL (empty line) oap.inclusive becomes false.
                                    ;; This makes "d}P" and "v}dP" work the same.
                                    (let [oap (if (or (== (:motion_force oap) NUL) (== (:motion_type oap) MLINE)) (assoc oap :inclusive true) oap)
                                          oap (if (== @VIsual_mode (byte \V))
                                                (assoc oap :motion_type MLINE)
                                                (let [oap (assoc oap :motion_type MCHAR)]
                                                    (if (and (!= @VIsual_mode Ctrl_V) (eos? (ml-get-pos (:op_end oap))) (or include_eol? (== @virtual_op FALSE)))
                                                        ;; Try to include the newline, unless it's an operator that works on lines only.
                                                        (cond (or (at? @p_sel (byte \o)) (op-on-lines (:op_type oap)))
                                                            (assoc oap :inclusive false)
                                                        (< (:lnum (:op_end oap)) (line-count @curbuf))
                                                            (let [oap (update oap :op_end assoc :lnum (inc (:lnum (:op_end oap))) :col 0 :coladd 0)
                                                                  oap (update oap :line_count inc)]
                                                                (assoc oap :inclusive false))
                                                        :else
                                                            ;; Cannot move below the last line, make the op inclusive
                                                            ;; to tell the operation to include the line break.
                                                            (assoc oap :inclusive true))
                                                        oap
                                                    ))
                                            )]
                                        (reset! redo_VIsual_busy false)
                                        ;; Switch Visual off now, so screen updating does not show inverted text when the screen is redrawn.
                                        ;; With OP_YANK and sometimes with OP_COLON and OP_FILTER there is no screen redraw,
                                        ;; so it is done here to remove the inverted part.
                                        (reset! VIsual_active false)
                                        (if @mode_displayed
                                            (reset! clear_cmdline true) ;; unshow visual mode later
                                            (clear-showcmd win))
                                        (when (and (any == (:op_type oap) OP_YANK OP_COLON OP_FUNCTION OP_FILTER) (== (:motion_force oap) NUL))
                                            (reset! (:wo_lbr (:w_options win)) o'lbr) ;; make sure redrawing is correct
                                            (redraw-curbuf-later INVERTED))
                                        [win oap]
                                    ))
                                [win oap])
                          ;; Include the trailing byte of a multi-byte char.
                          oap (if (:inclusive oap)
                                (let [#_int l (us-ptr2len-cc (ml-get-pos (:op_end oap)))]
                                    (if (< 1 l) (update-in oap [:op_end :col] + (dec l)) oap))
                                oap)
                          win (assoc win :w_set_curswant true)
                          ;; oap.empty is set when start and end are the same.
                          ;; The inclusive flag affects this too, unless yanking and the end is on a NUL.
                          oap (assoc oap :empty (and (== (:motion_type oap) MCHAR)
                                                     (or (not (:inclusive oap)) (and (== (:op_type oap) OP_YANK) (== (gchar-pos (:op_end oap)) NUL)))
                                                     (eqpos (:op_start oap), (:op_end oap))
                                                     (not (and (!= @virtual_op FALSE) (!= (:coladd (:op_start oap)) (:coladd (:op_end oap)))))))
                          ;; For delete, change and yank, it's an error to operate on an
                          ;; empty region, when 'E' included in 'cpoptions' (Vi compatible).
                          empty_region? (and (:empty oap) (some? (vim-strbyte @p_cpo, CPO_EMPTYREGION)))
                          ;; Force a redraw when operating on an empty Visual region,
                          ;; when 'modifiable' is off or creating a fold.
                          _ (when (and (:is_VIsual oap) (:empty oap))
                                (reset! (:wo_lbr (:w_options win)) o'lbr)
                                (redraw-curbuf-later INVERTED))
                          ;; If the end of an operator is in column one while oap.motion_type
                          ;; is MCHAR and oap.inclusive is false, we put op_end after the last
                          ;; character in the previous line.  If op_start is on or before the
                          ;; first non-blank in the line, the operator becomes linewise
                          ;; (strange, but that's the way vi does it).
                          oap (if (and (== (:motion_type oap) MCHAR)
                                     (not (:inclusive oap))
                                     (non-flag? (:retval cap) CA_NO_ADJ_OP_END)
                                     (== (:col (:op_end oap)) 0)
                                     (or (not (:is_VIsual oap)) (at? @p_sel (byte \o)))
                                     (not (:block_mode oap))
                                     (< 1 (:line_count oap))
                                )
                                (let [oap (assoc oap :end_adjusted true) ;; remember that we did this
                                      oap (update oap :line_count dec)
                                      oap (update-in oap [:op_end :lnum] dec)]
                                    (if (inindent win, 0)
                                        (assoc oap :motion_type MLINE)
                                        (let [oap (assoc-in oap [:op_end :col] (STRLEN (ml-get (:lnum (:op_end oap)))))]
                                            (if (< 0 (:col (:op_end oap)))
                                                (-> oap (update-in [:op_end :col] dec) (assoc :inclusive true))
                                                oap
                                            ))
                                    ))
                                (assoc oap :end_adjusted false))
                          [win cap oap]
                            (condp ==? (:op_type oap)

                               [OP_LSHIFT OP_RSHIFT]
                                    [(op-shift win, oap, true, (if (:is_VIsual oap) (:count1 cap) 1)) cap oap]

                               [OP_JOIN_NS OP_JOIN]
                                    (let [oap (update oap :line_count max 2)
                                          win (if (<= (dec (+ (:lnum (:w_cursor win)) (:line_count oap))) (line-count @curbuf))
                                                (do-join win, (:line_count oap), (== (:op_type oap) OP_JOIN), true, true)
                                                (do (beep-flush) win)
                                            )]
                                        [win cap oap])

                                OP_DELETE
                                    (do (reset! VIsual_reselect false) ;; don't reselect now
                                        (if empty_region?
                                            (do (vim-beep) (cancel-redo))
                                            (op-delete oap))
                                        [win cap oap])

                                OP_YANK
                                    (do (if empty_region?
                                            (do (vim-beep) (cancel-redo))
                                            (do
                                                (reset! (:wo_lbr (:w_options win)) o'lbr)
                                                (op-yank oap, false, true)
                                            ))
                                        [(check-cursor-col win) cap oap])

                                OP_CHANGE
                                    (let [_ (reset! VIsual_reselect false) ;; don't reselect now
                                          cap (if empty_region?
                                                (do (vim-beep) (cancel-redo) cap)
                                                ;; This is a new edit command, not a restart.
                                                ;; Need to remember it to make 'insertmode' work with mappings for Visual mode.
                                                ;; But do this only once and not when typed and 'insertmode' isn't set.
                                                (let [o'restart_edit (if (or @p_im (not @keyTyped)) @restart_edit 0) _ (reset! restart_edit 0)
                                                      ;; Restore linebreak, so that when the user edits, it looks as before.
                                                      _ (reset! (:wo_lbr (:w_options win)) o'lbr)
                                                      ;; Reset "finish_op" now, don't want it set inside edit().
                                                      _ (reset! finish_op false)
                                                      cap (if (op-change oap) ;; will call edit()
                                                            (update cap :retval | CA_COMMAND_BUSY)
                                                            cap
                                                        )]
                                                    (when (zero? @restart_edit)
                                                        (reset! restart_edit o'restart_edit))
                                                    cap)
                                            )]
                                        [win cap oap])

                                OP_INDENT
                                    (do (ยง op-reindent oap, (ร get_c_indent))
                                        [win cap oap])

                                OP_FILTER
                                    (do (if (some? (vim-strbyte @p_cpo, CPO_FILTER))
                                            (append-redo (u8 "!\r"))    ;; use any last used !cmd
                                            (reset! bangredo true))     ;; do_bang() will put cmd in redo buffer
                                        (op-colon oap)
                                        [win cap oap])

                                OP_COLON
                                    (do (op-colon oap)
                                        [win cap oap])

                               [OP_TILDE OP_UPPER OP_LOWER OP_ROT13]
                                    (let [oap (if empty_region?
                                                (do (vim-beep) (cancel-redo) oap)
                                                (op-tilde oap)
                                            )]
                                        [(check-cursor-col win) cap oap])

                                OP_FORMAT
                                    (do (ยง op-format oap, false)  ;; use internal function
                                        [win cap oap])

                                OP_FORMAT2
                                    (do (ยง op-format oap, true)   ;; use internal function
                                        [win cap oap])

                                OP_FUNCTION
                                    (do (op-function oap) ;; call 'operatorfunc'
                                        [win cap oap])

                               [OP_INSERT OP_APPEND]
                                    (do (reset! VIsual_reselect false) ;; don't reselect now
                                        (if empty_region?
                                            (do (vim-beep) (cancel-redo))
                                            ;; This is a new edit command, not a restart.
                                            ;; Need to remember it to make 'insertmode' work with mappings for Visual mode.
                                            ;; But do this only once.
                                            (let [o'restart_edit @restart_edit _ (reset! restart_edit 0)]
                                                ;; Restore linebreak, so that when the user edits, it looks as before.
                                                (reset! (:wo_lbr (:w_options win)) o'lbr)
                                                (op-insert oap, (:count1 cap))
                                                ;; Reset linebreak, so that formatting works correctly.
                                                (reset! (:wo_lbr (:w_options win)) false)
                                                (when (zero? @restart_edit)
                                                    (reset! restart_edit o'restart_edit))
                                            ))
                                        [win cap oap])

                                OP_REPLACE
                                    (do (reset! VIsual_reselect false) ;; don't reselect now
                                        (if empty_region?
                                            (do (vim-beep) (cancel-redo))
                                            (do ;; Restore linebreak, so that when the user edits, it looks as before.
                                                (reset! (:wo_lbr (:w_options win)) o'lbr)
                                                (op-replace oap, (:nchar cap))
                                            ))
                                        [win cap oap])

                                (do (clearopbeep oap) [win cap oap])
                            )]
                        (reset! virtual_op MAYBE)
                        ;; If 'sol' not set, go back to old column for some commands.
                        (let [win (if (and (not @p_sol) (== (:motion_type oap) MLINE) (not (:end_adjusted oap)) (any == (:op_type oap) OP_LSHIFT OP_RSHIFT OP_DELETE))
                                    (let [_ (reset! (:wo_lbr (:w_options win)) false)]
                                        (-> win
                                            (assoc :w_curswant o'col)
                                            (coladvance o'col)
                                        ))
                                    win)
                              oap (assoc oap :block_mode false)]
                            (clearop oap)
                            [win cap oap])
                    ))
            )]
        (reset! (:wo_lbr (:w_options win)) o'lbr)
        (do (reset! curwin win) (assoc cap :oap oap))
    ))

;; Handle filter operator and visual mode ":".

(defn- #_void op-colon [#_oparg_C oap]
    (stuff-char (byte \:))
    (if (:is_VIsual oap)
        (stuff-string (u8 "'<,'>"))
        (let [start (:lnum (:op_start oap)) end (:lnum (:op_end oap)) cursor (:lnum (:w_cursor @curwin)) lmax (line-count @curbuf)]
            ;; Make the range look nice, so it can be repeated.
            (if (== start cursor)
                (stuff-char (byte \.))
                (stuff-num start))
            (when (!= end start)
                (stuff-char (byte \,))
                (cond
                    (== end cursor) (stuff-char (byte \.))
                    (== end lmax) (stuff-char (byte \$))
                    (== start cursor) (do (stuff-string (u8 ".+")) (stuff-num (dec (:line_count oap))))
                    :else (stuff-num end)
                ))
        ))
    (when (!= (:op_type oap) OP_COLON)
        (stuff-string (u8 "!")))
    ;; do-cmdline() does the rest
    nil)

;; Handle the "g@" operator: call 'operatorfunc'.

(defn- #_void op-function [#_oparg_C oap]
    (if (eos? @p_opfunc)
        (emsg (u8 "E774: 'operatorfunc' is empty"))
        ;; Set '[ and '] marks to text to be operated on.
        (let [start (:op_start oap) end (:op_end oap)
              end (if (and (!= (:motion_type oap) MLINE) (not (:inclusive oap)))
                    (let [[_ ?] (decl end)] _) ;; exclude the end position
                    end
                )]
            (swap! curbuf assoc :b_op_start start, :b_op_end end)
            (let [#_maybean _ @virtual_op a'argv (atom (#_Bytes object))]
                (reset! a'argv (cond (:block_mode oap) (u8 "block") (== (:motion_type oap) MLINE) (u8 "line") :else (u8 "char")))
                ;; Reset "virtual_op" so that 'virtualedit' can be changed in the function.
                (reset! virtual_op MAYBE)
                (ยง call_func_retnr @p_opfunc, 1, a'argv, false)
                (reset! virtual_op _)
            )
        ))
    nil)

(atom! boolean did_check_visual_highlight)

;; Check if highlighting for visual mode is possible, give a warning message if not.

(defn- #_void check-visual-highlight []
    (when @full_screen
        (when (and (not @did_check_visual_highlight) (zero? (hl-attr HLF_V)))
            (msg (u8 "Warning: terminal cannot highlight")))
        (reset! did_check_visual_highlight true))
    nil)

;; End Visual mode.
;; This function should ALWAYS be called to end Visual mode, except from do-pending-operator().

(defn- #_window_C end-visual-mode [#_window_C win]
    (reset! VIsual_active false)
    ;; Save the current VIsual area for '< and '> marks, and "gv".
    (swap! curbuf update :b_visual assoc :vi_mode @VIsual_mode, :vi_start @VIsual_cursor, :vi_end (:w_cursor win), :vi_curswant (:w_curswant win))
    (let [win (if (not (virtual-active)) (assoc-in win [:w_cursor :coladd] 0) win)]
        (if @mode_displayed
            (reset! clear_cmdline true) ;; unshow visual mode later
            (clear-showcmd win))
        (adjust-cursor-eol win)
    ))

;; Reset VIsual_active and VIsual_reselect.

(defn- #_void reset-VIsual-and-resel []
    (when @VIsual_active
        (swap! curwin end-visual-mode)
        (redraw-curbuf-later INVERTED)) ;; delete the inversion later
    (reset! VIsual_reselect false)
    nil)

;; Reset VIsual_active and VIsual_reselect if it's set.

(defn- #_void reset-VIsual []
    (when @VIsual_active
        (swap! curwin end-visual-mode)
        (redraw-curbuf-later INVERTED)  ;; delete the inversion later
        (reset! VIsual_reselect false))
    nil)

;; Find the identifier under or to the right of the cursor.
;;
;; "find_type" can have one of three values:
;; FIND_IDENT:   find an identifier (keyword)
;; FIND_STRING:  find any non-white string
;; FIND_IDENT + FIND_STRING: find any non-white string, identifier preferred.
;;
;; There are three steps:
;; 1. Search forward for the start of an identifier/string.
;;    Doesn't move if already on one.
;; 2. Search backward for the start of this identifier/string.
;;    This doesn't match the real Vi but I like it a little better and it shouldn't bother anyone.
;; 3. Search forward to the end of this identifier/string.
;;    When FIND_IDENT isn't defined, we backup until a blank.
;;
;; Returns the length of the string, or zero if no string is found.
;; If a string is found, a pointer to the string is put in "*string".
;; This string is not always NUL terminated.

(defn- #_int find-ident-under-cursor [#_window_C win, #_Bytes' a'string, #_int find_type]
    (let [cursor (:w_cursor win) #_Bytes s (ml-get (:lnum cursor)) #_int startcol (:col cursor)
          ;; if round == 0: try to find an identifier ;; if round == 1: try to find any non-white string
          [#_int i #_int cls #_int round]
            (loop-when [i 0 cls 0 round (if (flag? find_type FIND_IDENT) 0 1)] (< round 2) => [i cls round]
                ;; 1. Skip to start of identifier/string.
                (let-when [i (loop-when [i startcol] (non-eos? s i) => i
                            (let-when [#_int cls (us-get-class (.plus s i))] (or (zero? cls) (and (zero? round) (== cls 1))) => i
                                (recur (+ i (us-ptr2len-cc s, i)))
                            ))
                      ;; 2. Back up to start of identifier/string.
                      cls (us-get-class (.plus s i)) ;; remember class of character under cursor
                      i (loop-when i (and (< 0 i) (!= cls 0)) => i
                            (let [#_int i' (- (dec i) (us-head-off s, (.plus s (dec i)))) #_int cls' (us-get-class (.plus s i'))]
                                (if (and (!= cls' cls) (or (zero? round) (zero? cls') (flag? find_type FIND_IDENT))) i (recur i'))
                            ))
                      ;; If we don't want just any old string, or we've found an identifier, stop searching.
                      cls (min cls 2)
                ] (and (flag? find_type FIND_STRING) (!= cls 2)) => [i cls round]
                    (recur i cls (inc round)))
            )]
        (if (or (eos? s i) (and (zero? round) (!= cls 2)))
            (do (emsg (if (flag? find_type FIND_STRING) (u8 "E348: No string under cursor") e_noident))
                0)
            (let [s (.plus s i) _ (reset! a'string s)
                  ;; 3. Find the end of the identifier/string.
                  cls (us-get-class s)]
                (loop-when-recur [i 0] ;; Search for point of changing multibyte character class.
                                 (and (non-eos? s i) (let [cls' (us-get-class (.plus s i))] (if (zero? round) (== cls' cls) (!= cls' 0))))
                                 [(+ i (us-ptr2len-cc s, i))]
                              => i)
            ))
    ))

;; Prepare for redo of a normal command.

(defn- #_void prep-redo-cmd [#_cmdarg_C cap]
    (prep-redo (:regname (:oap cap)), (:count0 cap), NUL, (:cmdchar cap), NUL, NUL, (:nchar cap))
    nil)

;; Prepare for redo of any command.
;; Note that only the last argument can be a multi-byte char.

(defn- #_void prep-redo [#_int regname, #_long num, #_int cmd1, #_int cmd2, #_int cmd3, #_int cmd4, #_int cmd5]
    (reset-redo)
    (when (non-zero? regname)   ;; yank from specified buffer
        (append-redo-char (byte \"))    ;; """
        (append-redo-char regname))
    (when (non-zero? num)
        (append-redo-number num))
    (when (!= cmd1 NUL) (append-redo-char cmd1))
    (when (!= cmd2 NUL) (append-redo-char cmd2))
    (when (!= cmd3 NUL) (append-redo-char cmd3))
    (when (!= cmd4 NUL) (append-redo-char cmd4))
    (when (!= cmd5 NUL) (append-redo-char cmd5))
    nil)

;; Check for operator active and clear it.

(defn- #_boolean checkclearop [#_oparg_C oap]
    (if (== (:op_type oap) OP_NOP) false (do (clearopbeep oap) true)))

;; Check for operator or Visual active.  Clear active operator.

(defn- #_boolean checkclearopq [#_oparg_C oap]
    (if (and (== (:op_type oap) OP_NOP) (not @VIsual_active)) false (do (clearopbeep oap) true)))

(defn- #_void clearop [#_oparg_C oap]
    (ยง
        ((ร oap =) (assoc oap :op_type OP_NOP))
        ((ร oap =) (assoc oap :regname 0))
        ((ร oap =) (assoc oap :motion_force NUL))
        ((ร oap =) (assoc oap :use_reg_one false))
        nil
    ))

(defn- #_void clearopbeep [#_oparg_C oap]
    (clearop oap)
    (beep-flush)
    nil)

;; Remove the shift modifier from a special key.

(defn- #_cmdarg_C unshift-special [#_cmdarg_C cap]
    (let [unsh- #(condp == %
            K_S_RIGHT K_RIGHT
            K_S_LEFT  K_LEFT
            K_S_UP    K_UP
            K_S_DOWN  K_DOWN
            K_S_HOME  K_HOME
            K_S_END   K_END
            %)
          simp- #(let [__ (atom (int @mod_mask)) _ (simplify-key %, __)] (reset! mod_mask @__) _)]
        (-> cap (update :cmdchar unsh-) (update :cmdchar simp-))
    ))

;; Routines for displaying a partly typed command

(final int SHOWCMD_BUFLEN (+ SHOWCMD_COLS 1 30))
(final Bytes    showcmd_buf     (Bytes. SHOWCMD_BUFLEN))
(final Bytes    old_showcmd_buf (Bytes. SHOWCMD_BUFLEN))    ;; for push-showcmd()
(atom! boolean  showcmd_is_clear true)
(atom! boolean  showcmd_visual)

(defn- #_void clear-showcmd [#_window_C win]
    (when @p_sc
        (if (and @VIsual_active (not (char-avail)))
            (let [#_boolean cursor_bot (ltpos @VIsual_cursor, (:w_cursor win))
                  [#_long top #_long bot] (if cursor_bot [(:lnum @VIsual_cursor) (:lnum (:w_cursor win))] [(:lnum (:w_cursor win)) (:lnum @VIsual_cursor)])
                  #_long lines (inc (- bot top))]

                (ยง cond (== @VIsual_mode Ctrl_V)
                    (let [o'sbr @p_sbr a'leftcol (atom (int)) a'rightcol (atom (int))]
                        ;; Make 'sbr' empty for a moment to get the correct size.
                        (reset! p_sbr EMPTY_OPTION)
                        (getvcols win, (:w_cursor win), @VIsual_cursor, a'leftcol, a'rightcol)
                        (reset! p_sbr o'sbr)
                        (.sprintf libC showcmd_buf, (u8 "%ldx%ld"), lines, (long (inc (- @a'rightcol @a'leftcol))))
                    )
                (or (== @VIsual_mode (byte \V)) (!= (:lnum @VIsual_cursor) (:lnum (:w_cursor win))))
                    (.sprintf libC showcmd_buf, (u8 "%ld"), lines)
                :else
                    (let [[#_Bytes s #_Bytes e] (if cursor_bot [(ml-get-pos @VIsual_cursor) (ml-get-cursor win)] [(ml-get-cursor win) (ml-get-pos @VIsual_cursor)])
                          [#_int bytes #_int chars]
                            (loop-when [bytes 0 chars 0 s s] (if (not-at? @p_sel (byte \e)) (BLE s, e) (BLT s, e)) => [bytes chars]
                                (let-when [#_int n (us-ptr2len-cc s)] (pos? n) => [(inc bytes) (inc chars)] ;; end of line
                                    (recur (+ bytes n) (inc chars) (.plus s n))
                                ))]
                        (if (== bytes chars)
                            (.sprintf libC showcmd_buf, (u8 "%d"), chars)
                            (.sprintf libC showcmd_buf, (u8 "%d-%d"), chars, bytes)
                        ))
                )

                (eos! showcmd_buf SHOWCMD_COLS)      ;; truncate
                (reset! showcmd_visual true)
                (display-showcmd)
            )
            (do
                (eos! showcmd_buf)
                (reset! showcmd_visual false)
                ;; Don't actually display something if there is nothing to clear.
                (when-not @showcmd_is_clear (display-showcmd))
            )
        ))
    nil)

(final int* ignore_showcmd
    [
        K_IGNORE,
        K_CURSORHOLD,
        0
    ])

;; Add 'c' to string of shown command chars.
;; Return true if output has been written (and setcursor() has been called).

(defn- #_boolean add-to-showcmd [#_int c]
    (and @p_sc
        (do
            (when @showcmd_visual (eos! showcmd_buf) (reset! showcmd_visual false))
            ;; Ignore keys that are scrollbar updates and mouse clicks.
            (let-when [_ (when (is-special c) (loop-when [#_int i 0] (!= (... ignore_showcmd i) 0) (recur-if (!= (... ignore_showcmd i) c) [(inc i)] => false)))] (nil? _) => _
                (let [#_Bytes p (transchar c)]
                    (when (at? p (byte \space))
                        (STRCPY p, (u8 "<20>")))
                    (let [#_int olen (STRLEN showcmd_buf) #_int elen (STRLEN p) #_int overflow (- (+ olen elen) SHOWCMD_COLS)]
                        (when (< 0 overflow)
                            (BCOPY showcmd_buf, 0, showcmd_buf, overflow, (inc (- olen overflow))))
                        (STRCAT showcmd_buf, p)
                    ))
                (and (not (char-avail)) (do (display-showcmd) true))
            ))
    ))

(defn- #_void add-to-showcmd-c [#_int c]
    (when (not (add-to-showcmd c))
        (setcursor))
    nil)

;; Delete 'len' characters from the end of the shown command.

(defn- #_void del-from-showcmd [#_int len]
    (when @p_sc
        (let [#_int o'len (STRLEN showcmd_buf) len (min len o'len)]
            (eos! showcmd_buf (- o'len len)))
        (when (not (char-avail))
            (display-showcmd)))
    nil)

;; push-showcmd() and pop-showcmd() are used when waiting for
;; the user to type something and there is a partial mapping.

(defn- #_void push-showcmd []
    (when @p_sc
        (STRCPY old_showcmd_buf, showcmd_buf))
    nil)

(defn- #_void pop-showcmd []
    (when @p_sc
        (STRCPY showcmd_buf, old_showcmd_buf)
        (display-showcmd))
    nil)

(defn- #_void display-showcmd []
    (cursor-off)

    (let [#_int len (STRLEN showcmd_buf)]
        (when (pos? len)
            (screen-puts showcmd_buf, (dec @Rows), @sc_col, 0))
        ;; clear the rest of an old message by outputting up to SHOWCMD_COLS spaces
        (screen-puts (.plus (u8 "          ") len), (dec @Rows), (+ @sc_col len), 0)
        (reset! showcmd_is_clear (zero? len))
    )

    (setcursor)            ;; put cursor back where it belongs
    nil)

(atom! window_C scr_old_curwin)
(atom! long scr_old_topline)
(atom! int scr_old_leftcol)

;; When "check" is false, prepare for commands that scroll the window.
;; When "check" is true, take care of scroll-binding after the window has scrolled.
;; Called from normal-cmd() and edit().

(defn- #_window_C do-check-scrollbind [#_window_C win, #_boolean check]
    (let [win (if (and check @(:wo_scb (:w_options win)))
                (do (cond @did_syncbind
                    (do
                        ;; If a ":syncbind" command was just used, don't scroll, only reset the values.
                        (reset! did_syncbind false)
                    )
                    (== win @scr_old_curwin)
                    (do
                        ;; Synchronize other windows, as necessary according to 'scrollbind'.
                        (when (or (!= (:w_topline win) @scr_old_topline) (!= (:w_leftcol win) @scr_old_leftcol))
                            (check-scrollbind (- (:w_topline win) @scr_old_topline), (- (:w_leftcol win) @scr_old_leftcol)))
                    )
                    (some? (vim-strchr @p_sbo, (byte \j))) ;; jump flag set in 'scrollopt'
                    (do
                        ;; When switching between windows, make sure that the relative vertical offset is valid for the new window.
                        ;; The relative offset is invalid whenever another 'scrollbind' window has scrolled to a point that would
                        ;; force the current window to scroll past the beginning or end of its buffer.  When the resync is performed,
                        ;; some of the other 'scrollbind' windows may need to jump so that the current window's relative position
                        ;; is visible on-screen.
                        (check-scrollbind (- (:w_topline win) (:w_scbind_pos win)), 0)
                    ))
                    (assoc win :w_scbind_pos (:w_topline win)))
                win
            )]
        (reset! scr_old_curwin win)
        (reset! scr_old_topline (:w_topline win))
        (reset! scr_old_leftcol (:w_leftcol win))
        win
    ))

;; Synchronize any windows that have "scrollbind" set,
;; based on the number of rows by which the current window has changed.

(defn- #_void check-scrollbind [#_long topline_diff, #_long leftcol_diff]
    (let [o'curwin @curwin o'VIsual_select @VIsual_select o'VIsual_active @VIsual_active
          #_int tgt_leftcol (:w_leftcol @curwin)
          ;; check 'scrollopt' string for vertical and horizontal scroll options
          #_boolean want_ver (and (some? (vim-strchr @p_sbo, (byte \v))) (!= topline_diff 0))
          #_boolean want_hor (and (some? (vim-strchr @p_sbo, (byte \h))) (or (!= leftcol_diff 0) (!= topline_diff 0)))
          lmax (line-count @curbuf)]
        ;; loop through the scrollbound windows and scroll accordingly
        (reset! VIsual_select (reset! VIsual_active false))
        (loop-when-recur (reset! curwin @firstwin) (some? @curwin) (swap! curwin :w_next)
            ;; skip original window and windows with 'noscrollbind'
            (when (and (!= @curwin o'curwin) @(:wo_scb (:w_options @curwin)))
                ;; do the vertical scroll
                (when want_ver
                    (swap! curwin update :w_scbind_pos + topline_diff)
                    (let [#_long topline (max 1 (min (:w_scbind_pos @curwin) lmax))
                          #_long y (- topline (:w_topline @curwin))]
                        (if (< 0 y)
                            (swap! curwin scrollup y)
                            (swap! curwin scrolldown (- y)))
                        (swap! curwin redraw-later VALID)
                        (swap! curwin cursor-correct)
                        (swap! curwin assoc :w_redr_status true)
                    ))
                ;; do the horizontal scroll
                (when (and want_hor (!= (:w_leftcol @curwin) tgt_leftcol))
                    (swap! curwin assoc :w_leftcol tgt_leftcol)
                    (swap! curwin leftcol-changed))
            ))
        ;; reset current-window
        (reset! VIsual_select o'VIsual_select)
        (reset! VIsual_active o'VIsual_active)
        (reset! curwin o'curwin))
    nil)

;; Command character that's ignored.
;; Used for CTRL-Q and CTRL-S to avoid problems with terminals that use xon/xoff.

(defn- #_cmdarg_C nv-ignore [#_cmdarg_C cap]
    (update cap :retval | CA_COMMAND_BUSY)      ;; don't call edit() now
)

;; Command character that doesn't do anything, but unlike nv-ignore()
;; does start edit().  Used for "startinsert" executed while starting up.

(defn- #_cmdarg_C nv-nop [#_cmdarg_C _cap]
    _cap)

;; Command character doesn't exist.

(defn- #_cmdarg_C nv-error [#_cmdarg_C cap]
    (clearopbeep (:oap cap))
    cap)

;; CTRL-A and CTRL-X: Add or subtract from letter or number under cursor.

(defn- #_cmdarg_C nv-addsub [#_cmdarg_C cap]
    (if (not (checkclearopq (:oap cap))) (if (do-addsub (:cmdchar cap), (:count1 cap)) (prep-redo-cmd cap)))
    cap)

;; CTRL-F, CTRL-B, etc: Scroll page up or down.

(defn- #_cmdarg_C nv-page [#_cmdarg_C cap]
    (if (not (checkclearop (:oap cap))) (if (non-flag? @mod_mask MOD_MASK_CTRL) (swap! curwin onepage (:arg cap), (:count1 cap))))
    cap)

;; Move "dist" screen rows in direction "dir".
;; "dist" must be positive.
;;
;; Return true if able to move cursor, false otherwise.

(defn- #_[window_C cmdarg_C boolean] nv-screengo [#_window_C win, #_cmdarg_C cap, #_int dir, #_long dist]
    (let [cap (update cap :oap assoc :motion_type MCHAR :inclusive (== (:w_curswant win) MAXCOL))
          [#_int width1 #_int width2]
            (let [o       (win-col-off  win)  w  (- (:w_width win) o)   ;; margin offset for first/wrapped screen line
                  o' (- o (win-col-off2 win)) w' (- (:w_width win) o')] ;; text width for first/wrapped screen line
                [w (if (zero? w') 1 w')])                               ;; avoid divide by zero
          [win #_boolean atend #_boolean moved]
            (if (non-zero? (:w_width win))
                ;; Instead of sticking at the last character of the buffer line we try to stick in the last column of the screen.
                (let [#_int linelen (linetabsize (ml-get (:lnum (:w_cursor win))))
                      [win atend]
                        (if (== (:w_curswant win) MAXCOL)
                            (let [win (validate-virtcol win)]
                                (if (< 0 width1)
                                    (let [win (assoc win :w_curswant (dec width1))
                                          win (if (< (:w_curswant win) (:w_virtcol win))
                                                (update win :w_curswant #(+ % (* (inc (/ (- (:w_virtcol win) % 1) width2)) width2)))
                                                win
                                            )]
                                        [win true])
                                    [(assoc win :w_curswant 0) true]
                                ))
                            (let [n (if (< width1 linelen) (+ (* (inc (/ (- linelen width1 1) width2)) width2) width1) width1)
                                  win (if (< (inc n) (:w_curswant win))
                                        (update win :w_curswant #(- % (* (inc (/ (- % n) width2)) width2)))
                                        win
                                    )]
                                [win false])
                        )]
                    (loop-when [win win linelen linelen dist dist] (< 0 dist) => [win atend true]
                        (let [[win linelen]
                                (cond (== dir BACKWARD)
                                    (if (<= width2 (:w_curswant win))
                                        ;; move back within line
                                        [(update win :w_curswant - width2) linelen]
                                        ;; to previous line
                                        (if (== (:lnum (:w_cursor win)) 1)
                                            [win nil]
                                            (let [win (update-in win [:w_cursor :lnum] dec)
                                                  linelen (linetabsize (ml-get (:lnum (:w_cursor win))))
                                                  win (if (< width1 linelen)
                                                        (update win :w_curswant + (* (inc (/ (- linelen width1 1) width2)) width2))
                                                        win
                                                    )]
                                                [win linelen])
                                        ))
                                :else ;; (== dir FORWARD)
                                    (let [#_int n (if (< width1 linelen) (+ (* (inc (/ (- linelen width1 1) width2)) width2) width1) width1)]
                                        (if (< (+ (:w_curswant win) width2) n)
                                            ;; move forward within line
                                            [(update win :w_curswant + width2) linelen]
                                            ;; to next line
                                            (if (== (:lnum (:w_cursor win)) (line-count @curbuf))
                                                [win nil]
                                                (let [win (update-in win [:w_cursor :lnum] inc)
                                                      win (update win :w_curswant % width2)]
                                                    [win (linetabsize (ml-get (:lnum (:w_cursor win))))]
                                                ))
                                        ))
                                )]
                            (recur-if (some? linelen) [win linelen (dec dist)] => [win atend false]))
                    ))
                [win false true])
          win (coladvance win, (if (and (virtual-active) atend) MAXCOL (:w_curswant win)))
          win (if (and (< 0 (:col (:w_cursor win))) @(:wo_wrap (:w_options win)))
                ;; Check for landing on a character that got split at the end of the last line.
                ;; We want to advance a screenline, not end up in the same screenline or move two screenlines.
                (let-when [win (validate-virtcol win) vcol (:w_virtcol win)
                      vcol (- vcol (if (and (< width1 vcol) (non-eos? @p_sbr)) (mb-string2cells @p_sbr) 0))
                      i (:w_curswant win)] (and (< i vcol) (if (< i width1) (< (/ width1 2) i) (< (/ width2 2) (% (- i width1) width2)))) => win
                    (update-in win [:w_cursor :col] dec))
                win)
          win (if atend
                (assoc win :w_curswant MAXCOL) ;; stick in the last column
                win
            )]
        [win cap moved]
    ))

;; Handle CTRL-E and CTRL-Y commands: scroll a line up or down.
;; cap.arg must be TRUE for CTRL-E.

(defn- #_cmdarg_C nv-scroll-line [#_cmdarg_C cap]
    (when (not (checkclearop (:oap cap)))
        (swap! curwin scroll-redraw (non-zero? (:arg cap)), (:count1 cap)))
    cap)

;; Scroll "count" lines up or down, and redraw.

(defn- #_window_C scroll-redraw [#_window_C win, #_boolean up, #_long count]
    (let [o'topline (:w_topline win) o'lnum (:lnum (:w_cursor win))
          win (if up (scrollup win, count) (scrolldown win, count))
          win (if (non-zero? @p_so)
                ;; Adjust the cursor position for 'scrolloff'.
                ;; Mark "w_topline" as valid, otherwise the screen jumps back at the end of the file.
                (let [win (-> win (cursor-correct) (check-cursor-moved) (update :w_valid | VALID_TOPLINE))]
                    ;; If moved back to where we were, at least move the cursor, otherwise we get stuck at one position.
                    ;; Don't move the cursor up if the first line of the buffer is already on the screen.
                    (loop-when [win win] (== (:w_topline win) o'topline) => win
                        (let-when [[win ?] (if up
                                    (if      (<= (:lnum (:w_cursor win)) o'lnum)                  (cursor-down? win, 1, false) [win false])
                                    (if (and (<= o'lnum (:lnum (:w_cursor win))) (< 1 o'topline)) (cursor-up?   win, 1, false) [win false])
                                )] ? => win
                            ;; Mark "w_topline" as valid, otherwise the screen jumps back at the end of the file.
                            (recur (-> win (check-cursor-moved) (update :w_valid | VALID_TOPLINE))))
                    ))
                win)
          win (if (!= (:lnum (:w_cursor win)) o'lnum) (coladvance win, (:w_curswant win)) win)]
        (redraw-later win, VALID)
    ))

;; Commands that start with "z".

(defn- #_cmdarg_C nv-zet [#_cmdarg_C cap]
    (if (checkclearop (:oap cap))
        cap
        (let-when [nchar (:nchar cap)
              [cap nchar]
                (if (asc-isdigit nchar) ;; "z123{nchar}": edit the count before obtaining {nchar}
                    (loop [n (- nchar (byte \0))]
                        ;; no mapping for nchar, but allow key codes
                        (let [_ (swap! no_mapping inc) _ (swap! allow_keys inc) nchar (plain-vgetc) _ (swap! no_mapping dec) _ (swap! allow_keys dec)]
                            (add-to-showcmd nchar)
                            (cond
                                (any == nchar K_DEL K_KDEL)                       (recur (/ n 10))
                                (asc-isdigit nchar)                               (recur (+ (* n 10) (- nchar (byte \0))))
                                (== nchar CAR)                                    (do (win-setheight @curwin, n) [cap nil])
                                (any == nchar (byte \l) (byte \h) K_LEFT K_RIGHT) [(update cap :count1 #(if (non-zero? n) (* n %) %)) nchar]
                                :else                                             (do (clearopbeep (:oap cap)) [cap nil]))
                        ))
                    [cap nchar]
                )] (some? nchar) => cap

            (let [win @curwin
                  ;; For "z+", "z<CR>", "zt", "z.", "zz", "z^", "z-", "zb":  If line number given, set cursor.
                  win (if (and (some? (vim-strchr (u8 "+\r\nt.z^-b"), nchar)) (non-zero? (:count0 cap)) (!= (:count0 cap) (:lnum (:w_cursor win))))
                        (-> win
                            (setpcmark)
                            (assoc-in [:w_cursor :lnum] (min (:count0 cap) (line-count @curbuf)))
                            (check-cursor-col))
                        win)
                  -t- (fn [win cap y? x?]
                        (let [win (if (and y? (zero? (:count0 cap))) ;; No count given: put cursor at the line below screen.
                                    (let [win (validate-botline win)] (assoc-in win [:w_cursor :lnum] (min (:w_botline win) (line-count @curbuf))))
                                    win)
                              win (if (or y? x?) (beginline win, (| BL_WHITE BL_FIX)) win)]
                            [(-> win (scroll-cursor-top 0, true) (redraw-later VALID)) cap]
                        ))
                  -z- (fn [win cap z?]
                        (let [win (if z? (beginline win, (| BL_WHITE BL_FIX)) win)]
                            [(-> win (scroll-cursor-halfway true) (redraw-later VALID)) cap]
                        ))
                  -b- (fn [win cap y? x?]
                        (let [win (cond (not y?)
                                    win
                                (zero? (:count0 cap))
                                    (assoc-in win, [:w_cursor :lnum] (max 1 (- (:w_topline win) 1)))
                                :else
                                    ;; Strange Vi behavior:
                                    ;; <count>z^ finds line at top of window when <count> is at bottom of window,
                                    ;; and puts that one at bottom of window.
                                    (let [win (scroll-cursor-bot win, 0, true)]
                                        (assoc-in win, [:w_cursor :lnum] (:w_topline win))
                                    ))
                              win (if (or y? x?) (beginline win, (| BL_WHITE BL_FIX)) win)]
                            [(-> win (scroll-cursor-bot 0, true) (redraw-later VALID)) cap]
                        ))
                  -h- (fn [win cap z?]
                        (let [cap (if z? (update cap :count1 * (/ (:w_width win) 2)) cap)
                              win (if (not @(:wo_wrap (:w_options win)))
                                    (let [win (assoc win :w_leftcol (max 0 (- (:w_leftcol win) (:count1 cap))))]
                                        (leftcol-changed win))
                                    win
                                )]
                            [win cap]
                        ))
                  -l- (fn [win cap z?]
                        (let [cap (if z? (update cap :count1 * (/ (:w_width win) 2)) cap)
                              win (if (not @(:wo_wrap (:w_options win)))
                                    (let [win (update win :w_leftcol + (:count1 cap))]
                                        (leftcol-changed win))
                                    win
                                )]
                            [win cap]
                        ))
                  [win cap]
                    (condp ==? nchar

                        (byte \+)           (-t- win, cap, :y?, :x?)            ;; put cursor at top of screen
                       [NL CAR K_KENTER]    (-t- win, cap, nil, :x?)
                        (byte \t)           (-t- win, cap, nil, nil)

                        (byte \.)           (-z- win, cap, :z?)                 ;; put cursor in middle of screen
                        (byte \z)           (-z- win, cap, nil)

                        (byte \^)           (-b- win, cap, :y?, :x?)            ;; put cursor at bottom of screen
                        (byte \-)           (-b- win, cap, nil, :x?)
                        (byte \b)           (-b- win, cap, nil, nil)

                        (byte \H)           (-h- win, cap, :z?)                 ;; scroll screen right half-page
                       [(byte \h) K_LEFT]   (-h- win, cap, nil)                 ;; scroll screen to the right

                        (byte \L)           (-l- win, cap, :z?)                 ;; scroll screen left half-page
                       [(byte \l) K_RIGHT]  (-l- win, cap, nil)                 ;; scroll screen to the left

                        (byte \s)                                               ;; scroll screen, cursor at the start
                            (let [win (if (not @(:wo_wrap (:w_options win)))
                                        (let [a'col (atom (int)) _ (getvcol win, (:w_cursor win), a'col, nil, nil)
                                              _ (reset! a'col (max 0 (- @a'col @p_siso)))]
                                            (if (!= (:w_leftcol win) @a'col)
                                                (-> win (assoc :w_leftcol @a'col) (redraw-later NOT_VALID))
                                                win
                                            ))
                                        win
                                    )]
                                [win cap])

                        (byte \e)                                               ;; scroll screen, cursor at the end
                            (let [win (if (not @(:wo_wrap (:w_options win)))
                                        (let [a'col (atom (int)) _ (getvcol win, (:w_cursor win), nil, nil, a'col)
                                            n (- (:w_width win) (win-col-off win))
                                            _ (reset! a'col (max 0 (inc (+ @a'col (- @p_siso n)))))]
                                            (if (!= (:w_leftcol win) @a'col)
                                                (-> win (assoc :w_leftcol @a'col) (redraw-later NOT_VALID))
                                                win
                                            ))
                                        win
                                    )]
                                [win cap])

                        (do (clearopbeep (:oap cap)) [win cap])
                    )]
                (do (reset! curwin win) cap)
            ))
    ))

;; Handle a ":" command.

(defn- #_cmdarg_C nv-colon [#_cmdarg_C cap]
    (if @VIsual_active
        (nv-operator cap)
        (let [cap (if (!= (:op_type (:oap cap)) OP_NOP)
                    ;; using ":" as a movement is characterwise exclusive
                    (update cap :oap assoc :motion_type MCHAR :inclusive false)
                    (do ;; translate "count:" into ":.,.+(count - 1)"
                        (when (non-zero? (:count0 cap))
                            (stuff-char (byte \.))
                            (when (< 1 (:count0 cap))
                                (stuff-string (u8 ",.+"))
                                (stuff-num (dec (:count0 cap)))
                            ))
                    cap)
                )]
            ;; When typing, don't type below an old message.
            (when @keyTyped
                (compute-cmdrow))
            (let [o'im @p_im ? (do-cmdline nil, true, (if (!= (:op_type (:oap cap)) OP_NOP) DOCMD_KEEPLINE 0))] ;; get a command line and execute it
                ;; If 'insertmode' changed, enter or exit Insert mode.
                (when (!= @p_im o'im)
                    (reset! restart_edit (if @p_im (byte \i) 0)))
                (let [start (:op_start (:oap cap)) lmax (line-count @curbuf)]
                    (cond (not ?)
                        (clearop (:oap cap)) ;; the Ex command failed, do not execute the operator
                    (and (!= (:op_type (:oap cap)) OP_NOP) (or (< lmax (:lnum start)) (< (STRLEN (ml-get (:lnum start))) (:col start)) @did_emsg))
                        (clearopbeep (:oap cap))) ;; the start of the operator has become invalid by the Ex command
                cap)
            ))
    ))

;; Handle CTRL-G command.

(defn- #_cmdarg_C nv-ctrlg [#_cmdarg_C cap]
    (cond @VIsual_active ;; toggle Selection/Visual mode
        (do (swap! VIsual_select not) (showmode))
    (not (checkclearop (:oap cap)))
        (fileinfo (:count0 cap)) ;; print full name if count given
    )
    cap)

;; Handle CTRL-H <Backspace> command.

(defn- #_cmdarg_C nv-ctrlh [#_cmdarg_C cap]
    (if (and @VIsual_active @VIsual_select)
        (v-visop (assoc cap :cmdchar (byte \x))) ;; BS key behaves like 'x' in Select mode
        (nv-left cap)
    ))

;; CTRL-L: clear screen and redraw.

(defn- #_cmdarg_C nv-clear [#_cmdarg_C cap]
    (when (not (checkclearop (:oap cap)))
        (swap! curwin redraw-later CLEAR))
    cap)

;; CTRL-O: In Select mode: switch to Visual mode for one command.
;; Otherwise: Go to older pcmark.

(defn- #_cmdarg_C nv-ctrlo [#_cmdarg_C cap]
    (if (and @VIsual_active @VIsual_select)
        (do
            (reset! VIsual_select false)
            (showmode)
            (reset! restart_VIsual_select 2)      ;; restart Select mode later
            cap
        )
        (nv-pcmark (update cap :count1 -))
    ))

;; "Z" commands.

(defn- #_cmdarg_C nv-Zet [#_cmdarg_C cap]
    (when (not (checkclearopq (:oap cap)))
        (if (== (:nchar cap) (byte \Z)) ;; "ZZ": equivalent to ":x".
            (do-cmdline-cmd (u8 "x"))
            (clearopbeep (:oap cap))
        ))
    cap)

;; Handle the commands that use the word under the cursor.
;; [g] 'K'      run program for current identifier
;; [g] '*'      / to current identifier or string
;; [g] '#'      ? to current identifier or string

(defn- #_cmdarg_C nv-ident [#_cmdarg_C cap]
    (let-when [#_int cmd (:cmd cap) #_boolean g_cmd (== cmd (byte \g))
          cmd (if g_cmd (:nchar cap) cmd)                   ;; "g*" and "g#"
          cmd (if (== cmd (char_u POUND)) (byte \#) cmd)    ;; the pound sign, '#' for English keyboards
          a'ident (atom (#_Bytes object nil)) a'count (atom (int 0))
          ;; The "K" command accepts an argument in Visual mode.
          _ (when (== cmd (byte \K)) (cond
                (and @VIsual_active (not (get-visual-text cap, a'ident, a'count))) :_
                (checkclearopq (:oap cap)) :_
            ))
    ] (nil? _) => cap

        (let-when [sea? (any == cmd (byte \*) (byte \#))
              _ (when (nil? @a'ident)
                    (let [#_int type (if sea? (| FIND_IDENT FIND_STRING) FIND_IDENT)]
                        (reset! a'count (find-ident-under-cursor @curwin, a'ident, type))
                        (when (zero? @a'count)
                            (clearop (:oap cap))
                            :_)
                    ))
        ] (nil? _) => cap

            ;; Allocate buffer to put the command in.
            ;; Inserting backslashes can double the length of the word.
            ;; 'keywordprg' could be added and some numbers.
            (let-when [#_Bytes kp @(:b_p_kp @curbuf)
                  #_Bytes buf (Bytes. (+ (* @a'count 2) 30 (STRLEN kp)))
                  _ (if sea?
                        (do ;; Put cursor at start of word, makes search skip the word under the cursor.
                            ;; Call setpcmark() first, so "*``" puts the cursor back where it was.
                            (swap! curwin setpcmark)
                            (swap! curwin assoc-in [:w_cursor :col] (BDIFF @a'ident, (ml-get (:lnum (:w_cursor @curwin)))))
                            (when (and (not g_cmd) (us-iswordp @a'ident))
                                (STRCPY buf, (u8 "\\<")))
                            (reset! no_smartcase true)        ;; don't use 'smartcase' now
                            nil)
                        (do ;; An external command will probably use an argument starting
                            ;; with "-" as an option.  To avoid trouble we skip the "-".
                            (while (and (pos? @a'count) (at? @a'ident (byte \-)))
                                (swap! a'ident plus 1) (swap! a'count dec))
                            (if (zero? @a'count)
                                (do (emsg e_noident)        ;; found dashes only
                                    :_)
                                (do ;; When a count is given, turn it into a range.  Is this really what we want?
;%%                                 (when (non-zero? (:count0 cap))
;%%                                     (.sprintf libC buf, (u8 ".,.+%ld"), (dec (:count0 cap))))
                                    (when (not-at? kp (byte \:))
                                        (STRCAT buf, (u8 "!")))
                                    (STRCAT buf, (if (at? kp (byte \:)) (.plus kp 1) kp))
                                    (STRCAT buf, (u8 " "))
                                    nil
                                ))
                        ))
            ] (nil? _) => cap

                (let [#_Bytes aux
                        (condp == cmd
                            (byte \*) (if @p_magic (u8 "/.*~[^$\\") (u8 "/^$\\"))
                            (byte \#) (if @p_magic (u8 "/?.*~[^$\\") (u8 "/?^$\\"))
                                      (u8 "\\|\"\n*?[")
                        )]
                    ;; now grab the chars in the identifier
                    (loop-when [i (STRLEN buf)] (< 0 @a'count) => (eos! buf i)
                        ;; put a backslash before \ and some others
                        (let [i (if (some? (vim-strchr aux, (.at @a'ident 0))) (do (.be buf i, (byte \\)) (inc i)) i)]
                            ;; when current byte is part of multibyte character, copy all bytes of the character
                            (let [i (let [n (dec (us-ptr2len-cc @a'ident))]
                                        (loop-when-recur i (and (< i n) (< 1 @a'count)) (inc i) => i
                                            (.be buf i, (.at @a'ident 0)) (swap! a'ident plus 1) (swap! a'count dec)
                                        ))]
                                (.be buf i, (.at @a'ident 0)) (swap! a'ident plus 1) (swap! a'count dec)
                                (recur (inc i))
                            ))
                    ))
                ;; Execute the command.
                (if sea?
                    (do (when (and (not g_cmd) (us-iswordp (us-prevptr (ml-get (:lnum (:w_cursor @curwin))), @a'ident)))
                            (STRCAT buf, (u8 "\\>")))
                        ;; put pattern in search history
                        (init-history)
                        (add-to-history HIST_SEARCH, buf, NUL)
                        (normal-search cap, (if (== cmd (byte \*)) (byte \/) (byte \?)), buf, 0))
                    (do-cmdline-cmd buf))
                cap
            ))
    ))

;; Get visually selected text, within one line only.
;; Returns false if more than one line selected.

(defn- #_boolean get-visual-text [#_cmdarg_C cap, #_Bytes' a'start, #_int' a'count]
    (when (!= @VIsual_mode (byte \V))
        (unadjust-for-sel))

    (if (!= (:lnum @VIsual_cursor) (:lnum (:w_cursor @curwin)))
        (do
            (if (some? cap)
                (clearopbeep (:oap cap)))
            false
        )
        (do
            (cond (== @VIsual_mode (byte \V))
            (do
                (reset! a'start (ml-get (:lnum (:w_cursor @curwin))))
                (reset! a'count (STRLEN @a'start))
            )
            :else
            (do
                (cond (ltpos (:w_cursor @curwin), @VIsual_cursor)
                (do
                    (reset! a'start (ml-get-pos (:w_cursor @curwin)))
                    (reset! a'count (inc (- (:col @VIsual_cursor) (:col (:w_cursor @curwin)))))
                )
                :else
                (do
                    (reset! a'start (ml-get-pos @VIsual_cursor))
                    (reset! a'count (inc (- (:col (:w_cursor @curwin)) (:col @VIsual_cursor))))
                ))

                ;; Correct the length to include the whole last character.
                (swap! a'count #(+ % (dec (us-ptr2len-cc @a'start, (dec %)))))
            ))
            (reset-VIsual-and-resel)
            true
        )
    ))

;; Handle scrolling command 'H', 'L' and 'M'.

(defn- #_cmdarg_C nv-scroll [#_cmdarg_C cap]
    (let [cap (update cap :oap assoc :motion_type MLINE)]
        (swap! curwin setpcmark)
        (let [n (if (== (:cmdchar cap) (byte \L))
                    (let [_ (swap! curwin validate-botline)]
                        (max 1 (- (dec (:w_botline @curwin)) (dec (:count1 cap)))))
                    (let [lmax (line-count @curbuf)
                          n (if (== (:cmdchar cap) (byte \M))
                                (let [_ (swap! curwin validate-botline) ;; make sure "w_empty_rows" is valid
                                      half (/ (inc (- (:w_height @curwin) (:w_empty_rows @curwin))) 2)
                                      [used n]
                                        (loop-when [used 0 n 0] (< (+ (:w_topline @curwin) n) lmax) => [used n]
                                            (let [used (+ used (plines @curwin, (+ (:w_topline @curwin) n), true))]
                                                (recur-if (< used half) [used (inc n)] => [used n]))
                                        )]
                                    (if (and (< 0 n) (< (:w_height @curwin) used)) (dec n) n))
                        ;; :else (== (:cmdchar cap) (byte \H))
                                (dec (:count1 cap))
                            )]
                        (min (+ (:w_topline @curwin) n) lmax))
                )]
            (swap! curwin assoc-in [:w_cursor :lnum] n))
        (swap! curwin cursor-correct)   ;; correct for 'so'
        (swap! curwin beginline (| BL_SOL BL_FIX))
        cap
    ))

;; Cursor right commands.

(defn- #_cmdarg_C nv-right [#_cmdarg_C cap]
    (if (flag? @mod_mask (| MOD_MASK_SHIFT MOD_MASK_CTRL))
        (let [cap (if (flag? @mod_mask MOD_MASK_CTRL) (assoc cap :arg TRUE) cap)] ;; <C-Right> and <S-Right> move a word or WORD right
            (nv-wordcmd cap)
        )
        ;; In virtual edit mode, there's no such thing as "past_line", as lines are (theoretically) infinitely long.
        (let [#_boolean past_line (and @VIsual_active (not-at? @p_sel (byte \o)) (not (virtual-active)))]
            (loop-when [cap (update cap :oap assoc :motion_type MCHAR :inclusive false) n (:count1 cap)] (< 0 n) => cap
                (if (and (or past_line (let [[_ ?] (oneright? @curwin)] (reset! curwin _) ?)) (or (not past_line) (non-eos? (ml-get-cursor @curwin))))
                    (do
                        (when past_line
                            (swap! curwin assoc :w_set_curswant true)
                            (if (virtual-active)
                                (swap! curwin oneright)
                                (swap! curwin update-in [:w_cursor :col] + (us-ptr2len-cc (ml-get-cursor @curwin)))
                            )
                        )
                        (recur cap (dec n))
                    )
                    ;;    <Space> wraps to next line if 'whichwrap' has 's'.
                    ;;        'l' wraps to next line if 'whichwrap' has 'l'.
                    ;; CURS_RIGHT wraps to next line if 'whichwrap' has '>'.
                    (if (and (or (and (== (:cmdchar cap) (byte \space)) (some? (vim-strchr @p_ww, (byte \s))))
                                 (and (== (:cmdchar cap) (byte \l))     (some? (vim-strchr @p_ww, (byte \l))))
                                 (and (== (:cmdchar cap) K_RIGHT)       (some? (vim-strchr @p_ww, (byte \>)))))
                             (< (:lnum (:w_cursor @curwin)) (line-count @curbuf)))
                        ;; When deleting we also count the NL as a character.
                        ;; Set cap.oap.inclusive when last char in the line is included, move to next line after that.
                        (let [_ (and (!= (:op_type (:oap cap)) OP_NOP) (not (:inclusive (:oap cap))) (not (lineempty (:lnum (:w_cursor @curwin)))))
                              cap (update cap :oap assoc :inclusive _)]
                            (when-not _
                                (swap! curwin update :w_cursor #(assoc % :lnum (inc (:lnum %)) :col 0 :coladd 0))
                                (swap! curwin assoc :w_set_curswant true)
                            )
                            (recur cap (dec n))
                        )
                        (if (== (:op_type (:oap cap)) OP_NOP)
                            (do
                                (when (== n (:count1 cap)) (beep-flush)) ;; only beep and flush if not moved at all
                                cap
                            )
                            (if (not (lineempty (:lnum (:w_cursor @curwin))))
                                (update cap :oap assoc :inclusive true)
                                cap
                            )
                        )
                    )
                )
            ))
    ))

;; Cursor left commands.

(defn- #_window_C skip-cc [#_window_C win] (let [#_Bytes s (ml-get-cursor win)] (if (non-eos? s) (update-in win [:w_cursor :col] + (us-ptr2len-cc s)) win)))

(defn- #_cmdarg_C nv-left [#_cmdarg_C cap]
    (if (flag? @mod_mask (| MOD_MASK_SHIFT MOD_MASK_CTRL))
        (let [cap (if (flag? @mod_mask MOD_MASK_CTRL) (assoc cap :arg 1) cap)] ;; <C-Left> and <S-Left> move a word or WORD left
            (nv-bck-word cap)
        )
        (loop-when [cap (update cap :oap assoc :motion_type MCHAR :inclusive false) n (:count1 cap)] (< 0 n) => cap
            (if (let [[_ ?] (oneleft? @curwin)] (reset! curwin _) ?)
                (recur cap (dec n))
                ;; <BS> and <Del> wrap to previous line if 'whichwrap' has 'b'.
                ;;           'h' wraps to previous line if 'whichwrap' has 'h'.
                ;;     CURS_LEFT wraps to previous line if 'whichwrap' has '<'.
                (if (and (or (and (any == (:cmdchar cap) K_BS Ctrl_H) (some? (vim-strchr @p_ww, (byte \b))))
                             (or (and (== (:cmdchar cap) (byte \h))   (some? (vim-strchr @p_ww, (byte \h))))
                                 (and (== (:cmdchar cap) K_LEFT)      (some? (vim-strchr @p_ww, (byte \<))))))
                         (< 1 (:lnum (:w_cursor @curwin))))
                    (do
                        (swap! curwin update-in [:w_cursor :lnum] dec)
                        (swap! curwin coladvance MAXCOL)
                        (swap! curwin assoc :w_set_curswant true)
                        ;; When the NL before the first char has to be deleted we put the cursor on the NUL after the previous line.
                        ;; This is a very special case, be careful!  Don't adjust op_end now, otherwise it won't work.
                        (let [_ (and (or (== (:op_type (:oap cap)) OP_DELETE) (== (:op_type (:oap cap)) OP_CHANGE)) (not (lineempty (:lnum (:w_cursor @curwin)))))
                              cap (if _ (do (swap! curwin skip-cc) (update cap :retval | CA_NO_ADJ_OP_END)) cap)]
                            (recur cap (dec n))
                        )
                    )
                    (do
                        (when (and (== (:op_type (:oap cap)) OP_NOP) (== n (:count1 cap))) (beep-flush)) ;; only beep and flush if not moved at all
                        cap
                    ))
            ))
    ))

;; Cursor up commands.
;; cap.arg is TRUE for "-": Move cursor to first non-blank.

(defn- #_cmdarg_C nv-up [#_cmdarg_C cap]
    (cond (flag? @mod_mask MOD_MASK_SHIFT) ;; <S-Up> is page up
        (nv-page (assoc cap :arg BACKWARD))
    :else
        (let [cap (assoc-in cap [:oap :motion_type] MLINE)]
            (cond (not (let [[_ ?] (cursor-up? @curwin, (:count1 cap), (== (:op_type (:oap cap)) OP_NOP))] (reset! curwin _) ?))
                (clearopbeep (:oap cap))
            (non-zero? (:arg cap))
                (swap! curwin beginline (| BL_WHITE BL_FIX))
            )
            cap)
    ))

;; Cursor down commands.
;; cap.arg is TRUE for CR and "+": Move cursor to first non-blank.

(defn- #_cmdarg_C nv-down [#_cmdarg_C cap]
    (cond (flag? @mod_mask MOD_MASK_SHIFT) ;; <S-Down> is page down
        (nv-page (assoc cap :arg FORWARD))
    (and (non-zero? @cmdwin_type) (== (:cmdchar cap) CAR)) ;; in the cmdline window a <CR> executes the command
        (do (reset! cmdwin_result CAR) cap)
    :else
        (let [cap (assoc-in cap [:oap :motion_type] MLINE)]
            (cond (not (let [[_ ?] (cursor-down? @curwin, (:count1 cap), (== (:op_type (:oap cap)) OP_NOP))] (reset! curwin _) ?))
                (clearopbeep (:oap cap))
            (non-zero? (:arg cap))
                (swap! curwin beginline (| BL_WHITE BL_FIX))
            )
            cap)
    ))

;; <End> command: to end of current line or last line.

(defn- #_cmdarg_C nv-end [#_cmdarg_C cap]
    (let [cap (if (or (non-zero? (:arg cap)) (flag? @mod_mask MOD_MASK_CTRL)) (-> cap (assoc :arg TRUE) (nv-goto) (assoc :count1 1)) cap)] ;; CTRL-END = goto last line
        (nv-dollar cap)
    ))

;; Handle the "$" command.

(defn- #_cmdarg_C nv-dollar [#_cmdarg_C cap]
    (let [cap (update cap :oap assoc :motion_type MCHAR :inclusive true) nop (== (:op_type (:oap cap)) OP_NOP)]
        ;; In virtual mode when off the edge of a line and an operator is pending (whew!) keep the cursor where it is.
        ;; Otherwise, send it to the end of the line.
        (if (or (not (virtual-active)) (!= (gchar-cursor @curwin) NUL) nop)
            (swap! curwin assoc :w_curswant MAXCOL))     ;; so we stay at the end
        (if (not (let [[_ ?] (cursor-down? @curwin, (dec (:count1 cap)), nop)] (reset! curwin _) ?))
            (clearopbeep (:oap cap)))
        cap
    ))

;; Implementation of '?' and '/' commands.
;; If cap.arg is TRUE, don't set PC mark.

(defn- #_cmdarg_C nv-search [#_cmdarg_C cap]
    (if (and (== (:cmdchar cap) (byte \?)) (== (:op_type (:oap cap)) OP_ROT13))
        (nv-operator (assoc cap :cmdchar (byte \g) :nchar (byte \?))) ;; translate "g??" to "g?g?"
        (let [cap (assoc cap :searchbuf (getcmdline (:cmdchar cap), (:count1 cap)))]
            (if (some? (:searchbuf cap))
                (normal-search cap, (:cmdchar cap), (:searchbuf cap), (if (zero? (:arg cap)) SEARCH_MARK 0))
                (clearop (:oap cap))
            )
            cap
        )
    ))

;; Handle "N" and "n" commands.
;; cap.arg is SEARCH_REV for "N", 0 for "n".

(defn- #_cmdarg_C nv-next [#_cmdarg_C cap]
    (let [#_pos_C cold (:w_cursor @curwin) #_int i (normal-search cap, NUL, nil, (| SEARCH_MARK (:arg cap)))]
        (if (and (== i 1) (eqpos cold, (:w_cursor @curwin)))
            ;; Avoid getting stuck on the current cursor position, which can happen when an offset is given
            ;; and the cursor is on the last char in the buffer: Repeat with count + 1.
            (let [cap (update cap :count1 inc) _ (normal-search cap, NUL, nil, (| SEARCH_MARK (:arg cap))) cap (update cap :count1 dec)]
                cap)
            cap
        )
    ))

;; Search for "pat" in direction "dirc" ('/' or '?', 0 for repeat).
;; Uses only cap.count1 and cap.oap from "cap".
;; Return 0 for failure, 1 for found, 2 for found and line offset added.

(defn- #_int normal-search [#_cmdarg_C cap, #_byte dirc, #_Bytes pat, #_int opt]
    ;; opt: extra flags for do-search()
    (ยง
        ((ร cap =) (assoc-in cap [:oap :motion_type] MCHAR))
        ((ร cap =) (assoc-in cap [:oap :inclusive] false))
        ((ร cap =) (assoc-in cap [:oap :use_reg_one] true))
        (swap! curwin assoc :w_set_curswant true)

        ((ร int i =) (do-search (:oap cap), dirc, pat, (:count1 cap), (| opt SEARCH_OPT SEARCH_ECHO SEARCH_MSG), nil))
        (cond (zero? i)
        (do
            (clearop (:oap cap))
        )
        :else
        (do
            (if (== i 2)
                ((ร cap =) (assoc-in cap [:oap :motion_type] MLINE))
            )
            (swap! curwin assoc-in [:w_cursor :coladd] 0)
        ))

        ;; "/$" will put the cursor after the end of the line, may need to correct that here
        (swap! curwin check-cursor)
        i
    ))

;; Character search commands.
;; cap.arg is BACKWARD for 'F' and 'T', FORWARD for 'f' and 't', TRUE for ',' and FALSE for ';'.
;; cap.nchar is NUL for ',' and ';' (repeat the search).

(defn- #_cmdarg_C nv-csearch [#_cmdarg_C cap]
    (let [#_boolean t_cmd (any == (:cmdchar cap) (byte \t) (byte \T)) cap (assoc-in cap [:oap :motion_type] MCHAR)]
        (if (or (is-special (:nchar cap)) (not (searchc cap, t_cmd)))
            (do (clearopbeep (:oap cap)) cap)
            (do
                (swap! curwin assoc :w_set_curswant true)
                ;; Include a Tab for "tx" and for "dfx".
                (swap! curwin assoc-in [:w_cursor :coladd]
                    (if (and (== (gchar-cursor @curwin) TAB) (virtual-active) (== (:arg cap) FORWARD) (or t_cmd (!= (:op_type (:oap cap)) OP_NOP)))
                        (let [a'scol (atom (int)) a'ecol (atom (int))] (getvcol @curwin, (:w_cursor @curwin), a'scol, nil, a'ecol) (- @a'ecol @a'scol))
                        0
                    ))
                (let [[win cap] (adjust-for-sel @curwin, cap)] (reset! curwin win) cap)
            ))
    ))

;; "[" and "]" commands.
;; cap.arg is BACKWARD for "[" and FORWARD for "]".

(defn- #_cmdarg_C nv-brackets [#_cmdarg_C cap]
    (let [cap (update cap :oap assoc :motion_type MCHAR :inclusive false) #_pos_C cold (:w_cursor @curwin)]
        (swap! curwin assoc-in [:w_cursor :coladd] 0)             ;; TODO: don't do this for an error

        ;; "[{", "[(", "]}" or "])": go to Nth unclosed '{', '(', '}' or ')'
        ;; "[#", "]#": go to start/end of Nth innermost #if..#endif construct.
        ;; "[/", "[*", "]/", "]*": go to Nth comment start/end.

        (cond (or (and (== (:cmdchar cap) (byte \[)) (some? (vim-strchr (u8 "{(*/#"), (:nchar cap))))
                  (and (== (:cmdchar cap) (byte \])) (some? (vim-strchr (u8 "})*/#"), (:nchar cap)))))
            (let [#_int findc (if (== (:nchar cap) (byte \*)) (byte \/) (:nchar cap)) dir (if (== (:cmdchar cap) (byte \[)) FM_BACKWARD FM_FORWARD)
                  #_pos_C pos
                    (loop-when [pos nil n (:count1 cap)] (< 0 n) => pos
                        (let [#_pos_C prior pos, pos (findmatchlimit (:oap cap), findc, dir, 0)]
                            (if (some? pos)
                                (do (swap! curwin assoc :w_cursor pos) (recur pos (dec n)))
                                (if (some? prior) prior (do (clearopbeep (:oap cap)) nil))
                            ))
                    )]
                (if (some? pos)
                    (do (swap! curwin setpcmark) (swap! curwin assoc :w_cursor pos :w_set_curswant true))
                    (swap! curwin assoc :w_cursor cold))
                cap)

        ;; "[p", "[P", "]P" and "]p": put with indent adjustment

        (any == (:nchar cap) (byte \p) (byte \P))
            (if (checkclearop (:oap cap))
                cap
                (let [visual? @VIsual_active
                      #_int dir (if (and (== (:cmdchar cap) (byte \])) (== (:nchar cap) (byte \p))) FORWARD BACKWARD)
                      [start end]
                        (when visual?
                            (let [c (:w_cursor @curwin) v @VIsual_cursor s (if (ltoreq v, c) v c) e (if (eqpos s, v) c v)]
                                (swap! curwin assoc :w_cursor (if (== dir BACKWARD) s e))
                                [s e]))
                      #_long lmax (line-count @curbuf)
                      #_int regname (adjust-clip-reg (:regname (:oap cap)))]
                    (prep-redo-cmd cap)

                    (do-put regname, dir, (:count1 cap), PUT_FIXINDENT)

                    (if visual?
                        (let [n (if (== dir BACKWARD) (- (line-count @curbuf) lmax) 0)]
                            (reset! VIsual_cursor (update start :lnum + n))
                            (swap! curwin assoc :w_cursor (update end :lnum + n))
                            (reset! VIsual_active true)
                            (let [cap (if (== @VIsual_mode (byte \V)) ;; delete visually selected lines
                                        (-> cap (assoc :cmdchar (byte \d) :nchar NUL) (assoc-in [:oap :regname] regname) (nv-operator) (do-pending-operator 0))
                                        cap)]
                                (when @VIsual_active
                                    (swap! curwin end-visual-mode)
                                    (swap! curwin redraw-later SOME_VALID))
                                cap))
                        cap)
                ))

        ;; "['", "[`", "]'" and "]`": jump to next mark

        (any == (:nchar cap) (byte \') (byte \`))
            (let [dir (if (== (:cmdchar cap) (byte \[)) BACKWARD FORWARD) sol (== (:nchar cap) (byte \'))
                  pos (loop-when [pos (:w_cursor @curwin) n (:count1 cap)] (< 0 n) => pos
                            (let [next (getnextmark pos, dir, sol)]
                                (recur-if (some? next) [next (dec n)] => pos))
                        )]
                (nv-cursormark cap, sol, pos))

        ;; Not a valid cap.nchar.

        :else (do (clearopbeep (:oap cap)) cap))
    ))

;; Handle Normal mode "%" command.

(defn- #_cmdarg_C nv-percent [#_cmdarg_C cap]
    (let [cap (assoc-in cap [:oap :inclusive] true)]
        (if (non-zero? (:count0 cap))
            ;; {cnt}% : goto {cnt} percentage in file
            (if (< 100 (:count0 cap))
                (do (clearopbeep (:oap cap)) cap)
                (let [cap (assoc-in cap [:oap :motion_type] MLINE)]
                    (swap! curwin setpcmark)
                    (let [lmax (line-count @curbuf)]
                        ;; Round up, so CTRL-G will give same value.
                        (swap! curwin assoc-in [:w_cursor :lnum] (min (/ (+ (* lmax (:count0 cap)) 99) 100) lmax)))
                    (swap! curwin beginline (| BL_SOL BL_FIX))
                    cap
                ))
            ;; "%" : go to matching paren
            (let [cap (update cap :oap assoc :motion_type MCHAR :use_reg_one true) #_pos_C pos (findmatch (:oap cap), NUL)]
                (if (nil? pos)
                    (do (clearopbeep (:oap cap)) cap)
                    (do
                        (swap! curwin setpcmark)
                        (swap! curwin assoc :w_cursor (assoc pos :coladd 0) :w_set_curswant true)
                        (let [[win cap] (adjust-for-sel @curwin, cap)] (reset! curwin win) cap)
                    ))
            ))
    ))

;; "m" command: Mark a position.

(defn- #_cmdarg_C nv-mark [#_cmdarg_C cap]
    (if (not (checkclearop (:oap cap))) (if (not (setmark (:nchar cap))) (clearopbeep (:oap cap))))
    cap)

;; "u" command: Undo or make lower case.

(defn- #_cmdarg_C nv-undo [#_cmdarg_C cap]
    (if (or (== (:op_type (:oap cap)) OP_LOWER) @VIsual_active)
        (nv-operator (assoc cap :cmdchar (byte \g) :nchar (byte \u))) ;; translate "<Visual>u" to "<Visual>gu" and "guu" to "gugu"
        (nv-kundo cap)
    ))

;; <Undo> command.

(defn- #_cmdarg_C nv-kundo [#_cmdarg_C cap]
    (when (not (checkclearopq (:oap cap)))
        (u-undo (:count1 cap))
        (swap! curwin assoc :w_set_curswant true))
    cap)

;; Handle the "r" command.

(defn- #_cmdarg_C nv-replace [#_cmdarg_C cap]
    (if (checkclearop (:oap cap))
        cap
        (let [[cap #_int had_ctrl_v]
                (if (== (:nchar cap) Ctrl_V) ;; get another character
                    (let [cap (assoc cap :nchar (get-literal))]
                        ;; Don't redo a multibyte character with CTRL-V.
                        [cap (if (< DEL (:nchar cap)) NUL Ctrl_V)])
                    [cap NUL]
                )]
            (cond (is-special (:nchar cap))
                ;; Abort if the character is a special key.
                (do (clearopbeep (:oap cap)) cap)
            @VIsual_active
                ;; Visual mode "r".
                (let [_ (when @got_int (reset-VIsual))
                      cap (if (!= had_ctrl_v NUL) (update cap :nchar #(condp == % (byte \return) -1 (byte \newline) -2 %)) cap)]
                    (nv-operator cap))
            :else
                ;; Break tabs, etc.
                (let-when [_
                    (when (virtual-active)
                        (if (not (u-save-cursor))
                            :_
                            (condp == (gchar-cursor @curwin)
                                NUL (do ;; Add extra space and put the cursor on the first one.
                                        (swap! curwin coladvance-force (+ (getviscol @curwin) (:count1 cap)))
                                        (swap! curwin update-in [:w_cursor :col] - (:count1 cap))
                                        nil)
                                TAB (do (swap! curwin coladvance-force (getviscol @curwin))
                                        nil)
                                nil)
                        ))
                ] (nil? _) => cap

                    (let [#_Bytes s (ml-get-cursor @curwin)]
                        (cond (< (min (us-charlen s) (STRLEN s)) (:count1 cap))
                            ;; Abort if not enough characters to replace.
                            (do (clearopbeep (:oap cap)) cap)

                        (and (!= had_ctrl_v Ctrl_V) (== (:nchar cap) TAB) (or @(:b_p_et @curbuf) @p_sta))
                            ;; Replacing with a TAB is done by edit() when it is complicated because
                            ;; 'expandtab' or 'smarttab' is set.  CTRL-V TAB inserts a literal TAB.
                            ;; Other characters are done below to avoid problems with things like
                            ;; CTRL-V 048 (for edit() this would be R CTRL-V 0 ESC).
                            (do (stuff-num (:count1 cap))
                                (stuff-char (byte \R))
                                (stuff-char TAB)
                                (stuff-char ESC)
                                cap)

                        ;; save line for undo
                        (not (u-save-cursor))
                            cap

                        (and (!= had_ctrl_v Ctrl_V) (any == (:nchar cap) (byte \return) (byte \newline)))
                            ;; Replace character(s) by a single newline.
                            ;; Strange vi behaviour:  Only one newline is inserted.
                            ;; Delete the characters here.
                            ;; Insert the newline with an insert command, takes care of autoindent.
                            ;; The insert command depends on being on the last character of a line or not.
                            (do (swap! curwin del-chars (:count1 cap), false)
                                (stuff-char (byte \return))
                                (stuff-char ESC)
                                ;; Give 'r' to edit(), to get the redo command right.
                                (invoke-edit cap, true, (byte \r), false))

                        :else
                            (do (prep-redo (:regname (:oap cap)), (:count1 cap), NUL, (byte \r), NUL, had_ctrl_v, (:nchar cap))
                                (swap! curbuf assoc :b_op_start (:w_cursor @curwin))
                                (let [state' @State]
                                    (when (non-zero? (:ncharC1 cap)) (append-redo-char (:ncharC1 cap)))
                                    (when (non-zero? (:ncharC2 cap)) (append-redo-char (:ncharC2 cap)))
                                    ;; This is slow, but it handles replacing a single-byte with a multi-byte and the other way around.
                                    ;; Also handles adding composing characters for utf-8.
                                    (loop-when-recur [n (:count1 cap)] (pos? n) [(dec n)]
                                        (reset! State REPLACE)
                                        (if (any == (:nchar cap) Ctrl_E Ctrl_Y)
                                            (let [[_ #_int c] (ins-copychar @curwin, (+ (:lnum (:w_cursor @curwin)) (if (== (:nchar cap) Ctrl_Y) -1 1))) _ (reset! curwin _)]
                                                (if (!= c NUL)
                                                    (swap! curwin ins-char c)
                                                    (swap! curwin update-in [:w_cursor :col] inc)   ;; will be decremented further down
                                                ))
                                            (swap! curwin ins-char (:nchar cap)))
                                        (reset! State state')
                                        (when (non-zero? (:ncharC1 cap)) (swap! curwin ins-char (:ncharC1 cap)))
                                        (when (non-zero? (:ncharC2 cap)) (swap! curwin ins-char (:ncharC2 cap)))
                                    ))
                                (swap! curwin update-in [:w_cursor :col] dec)                       ;; cursor on the last replaced char
                                ;; If the character on the left of the current cursor
                                ;; is a multi-byte character, move two characters left.
                                (swap! curwin update :w_cursor mb-adjust-pos)
                                (swap! curbuf assoc :b_op_end (:w_cursor @curwin))
                                (swap! curwin assoc :w_set_curswant true)
                                (set-last-insert (:nchar cap))
                                cap)
                        )))
            ))
    ))

;; 'o': Exchange start and end of Visual area;
;; 'O': same, but in block mode exchange left and right corners.

(defn- #_window_C v-swap-corners [#_window_C win, #_int cmdchar]
    (let [o'cursor (:w_cursor win)]
        (if (and (== cmdchar (byte \O)) (== @VIsual_mode Ctrl_V))
            (let [a'left (atom (int)) a'right (atom (int)) _ (getvcols win, o'cursor, @VIsual_cursor, a'left, a'right)
                  win (assoc-in win [:w_cursor :lnum] (:lnum @VIsual_cursor))
                  win (coladvance win, @a'left)
                  _ (reset! VIsual_cursor (:w_cursor win))
                  win (assoc-in win [:w_cursor :lnum] (:lnum o'cursor))
                  win (assoc win :w_curswant @a'right)
                  ;; 'selection "exclusive" and cursor at right-bottom corner: move it right one column
                  win (if (and (<= (:lnum @VIsual_cursor) (:lnum o'cursor)) (at? @p_sel (byte \e))) (update win :w_curswant inc) win)
                  win (coladvance win, (:w_curswant win))]
                (if (and (== (:col (:w_cursor win)) (:col o'cursor)) (or (not (virtual-active)) (== (:coladd (:w_cursor win)) (:coladd o'cursor))))
                    (let [win (assoc-in win [:w_cursor :lnum] (:lnum @VIsual_cursor))
                          _ (when (and (<= (:lnum o'cursor) (:lnum @VIsual_cursor)) (at? @p_sel (byte \e)))
                                (swap! a'right inc))
                          win (coladvance win, @a'right)
                          _ (reset! VIsual_cursor (:w_cursor win))
                          win (assoc-in win [:w_cursor :lnum] (:lnum o'cursor))
                          win (coladvance win, @a'left)
                          win (assoc win :w_curswant @a'left)]
                        win)
                    win
                ))
            (let [win (assoc win :w_cursor @VIsual_cursor)
                  _ (reset! VIsual_cursor o'cursor)
                  win (assoc win :w_set_curswant true)]
                win
            ))
    ))

;; "R" (cap.arg is FALSE) and "gR" (cap.arg is TRUE).

(defn- #_cmdarg_C nv-Replace [#_cmdarg_C cap]
    (cond @VIsual_active
        (do ;; "R" is replace lines
            (reset! VIsual_mode_orig @VIsual_mode) ;; remember original area for gv
            (reset! VIsual_mode (byte \V))
            (nv-operator (assoc cap :cmdchar (byte \c) :nchar NUL)))
    (checkclearopq (:oap cap))
        cap
    :else
        (do (when (virtual-active)
                (swap! curwin coladvance (getviscol @curwin)))
            (invoke-edit cap, false, (if (non-zero? (:arg cap)) (byte \V) (byte \R)), false))
    ))

;; "gr".

(defn- #_cmdarg_C nv-vreplace [#_cmdarg_C cap]
    (cond @VIsual_active
        (nv-replace (assoc cap :cmdchar (byte \r) :nchar (:extra_char cap))) ;; do same as "r" in Visual mode for now
    (checkclearopq (:oap cap))
        cap
    :else
        (let [cap (if (== (:extra_char cap) Ctrl_V) (assoc cap :extra_char (get-literal)) cap)] ;; get another character
            (stuff-char (:extra_char cap))
            (stuff-char ESC)
            (when (virtual-active)
                (swap! curwin coladvance (getviscol @curwin)))
            (invoke-edit cap, true, (byte \v), false))
    ))

;; Swap case for "~" command, when it does not work like an operator.

(defn- #_pos_C crlf [#_pos_C pos] (assoc pos :lnum (inc (:lnum pos)) :col 0))

(defn- #_cmdarg_C n-swapchar [#_cmdarg_C cap]
    (cond (checkclearopq (:oap cap))
        cap
    (and (lineempty (:lnum (:w_cursor @curwin))) (nil? (vim-strchr @p_ww, (byte \~))))
        (do (clearopbeep (:oap cap)) cap)
    :else
        (do (prep-redo-cmd cap)
            (if (not (u-save-cursor))
                cap
                (let [more- #(or (!= (gchar-cursor @curwin) NUL)
                                 (and (some? (vim-strchr @p_ww, (byte \~))) (< (:lnum (:w_cursor @curwin)) (line-count @curbuf))
                                      (do (swap! curwin update :w_cursor crlf)
                                          (if (< 1 %) (if (u-savesub (:lnum (:w_cursor @curwin))) (do (u-clearline) true) false) true))))
                      startpos (:w_cursor @curwin)
                      changed (loop-when [changed false n (:count1 cap)] (< 0 n) => changed
                                    (let [[_ ?] (swapchar (:op_type (:oap cap)), (:w_cursor @curwin)) _ (swap! curwin assoc :w_cursor _) changed (or ? changed)]
                                        (swap! curwin inc-cursor false)
                                        (recur-if (more- n) [changed (dec n)] => changed)
                                    ))]
                    (swap! curwin check-cursor)
                    (swap! curwin assoc :w_set_curswant true)
                    (when changed
                        (changed-lines (:lnum startpos), (:col startpos), (inc (:lnum (:w_cursor @curwin))), 0)
                        (let [endpos (update (:w_cursor @curwin) :col #(max 0 (dec %)))]
                            (swap! curbuf assoc :b_op_start startpos, :b_op_end endpos)
                        ))
                    cap)
            ))
    ))

;; Move cursor to mark.

(defn- #_cmdarg_C nv-cursormark [#_cmdarg_C cap, #_boolean flag, #_pos_C pos]
    (if (check-mark pos)
        (do
            (when (any == (:cmdchar cap) (byte \') (byte \`) (byte \[) (byte \]))
                (swap! curwin setpcmark))
            (swap! curwin assoc :w_cursor pos)
            (if flag
                (swap! curwin beginline (| BL_WHITE BL_FIX))
                (swap! curwin check-cursor)
            ))
        (clearop (:oap cap)))
    (let [cap (update cap :oap assoc :motion_type (if flag MLINE MCHAR))
          cap (if (== (:cmdchar cap) (byte \`)) (update cap :oap assoc :use_reg_one true) cap)
          cap (update cap :oap assoc :inclusive false)] ;; ignored if not MCHAR
        (swap! curwin assoc :w_set_curswant true)
        cap
    ))

(final Bytes visop_trans (u8 "YyDdCcxdXdAAIIrr"))

;; Handle commands that are operators in Visual mode.

(defn- #_cmdarg_C v-visop [#_cmdarg_C cap]
    ;; Uppercase means linewise, except in block mode, then "D" deletes, and "C" replaces till EOL.
    (when (asc-isupper (:cmdchar cap))
        (cond (!= @VIsual_mode Ctrl_V)
        (do
            (reset! VIsual_mode_orig @VIsual_mode)
            (reset! VIsual_mode (byte \V))
        )
        (any == (:cmdchar cap) (byte \C) (byte \D))
        (do
            (swap! curwin assoc :w_curswant MAXCOL)
        ))
    )
    (nv-operator (update cap :cmdchar #(.at (vim-strchr visop_trans, %) 1))))

;; "s" and "S" commands.

(defn- #_cmdarg_C nv-subst [#_cmdarg_C cap]
    (if @VIsual_active  ;; "vs" and "vS" are the same as "vc"
        (do (when (== (:cmdchar cap) (byte \S))
                (reset! VIsual_mode_orig @VIsual_mode)
                (reset! VIsual_mode (byte \V)))
            (nv-operator (assoc cap :cmdchar (byte \c))))
        (nv-optrans cap)
    ))

;; Abbreviated commands.

(defn- #_cmdarg_C nv-abbrev [#_cmdarg_C cap]
    (let [cap (if (any == (:cmdchar cap) K_DEL K_KDEL) (assoc cap :cmdchar (byte \x)) cap)] ;; DEL key behaves like 'x'
        ;; in Visual mode these commands are operators
        (if @VIsual_active (v-visop cap) (nv-optrans cap))
    ))

(final Bytes* #_"[/*8*/]" optrans_ar
    [
        (u8 "dl"), (u8 "dh"),
        (u8 "d$"), (u8 "c$"),
        (u8 "cl"), (u8 "cc"),
        (u8 "yy"), (u8 ":s\r")
    ])
(final Bytes optrans_str (u8 "xXDCsSY&"))

;; Translate a command into another command.

(defn- #_cmdarg_C nv-optrans [#_cmdarg_C cap]
    (let [cap
            (if (checkclearopq (:oap cap))
                cap
                (if (and (== (:cmdchar cap) (byte \D)) (some? (vim-strbyte @p_cpo, CPO_HASH)))
                    ;; In Vi "2D" doesn't delete the next line.
                    ;; Can't translate it either, because "2." should also not use the count.
                    (let [cap (-> cap (update :oap assoc :op_start (:w_cursor @curwin) :op_type OP_DELETE) (assoc :count1 1) (nv-dollar))]
                        (reset! finish_op true)
                        (reset-redo)
                        (append-redo-char (byte \D))
                        cap)
                    (do
                        (when (non-zero? (:count0 cap))
                            (stuff-num (:count0 cap)))
                        (stuff-string (... optrans_ar (BDIFF (vim-strchr optrans_str, (:cmdchar cap)), optrans_str)))
                        cap
                    ))
            )]
        (assoc cap :opcount 0)
    ))

;; "'" and "`" commands.  Also for "g'" and "g`".
;; cap.arg is TRUE for "'" and "g'".

(defn- #_cmdarg_C nv-gomark [#_cmdarg_C cap]
    (let [#_int c (if (== (:cmdchar cap) (byte \g)) (:extra_char cap) (:nchar cap))
          cap (nv-cursormark cap, (non-zero? (:arg cap)), (getmark c, (== (:op_type (:oap cap)) OP_NOP)))]
        ;; May need to clear the coladd that a mark includes.
        (when-not (virtual-active)
            (swap! curwin assoc-in [:w_cursor :coladd] 0))
        cap
    ))

;; Handle CTRL-O, CTRL-I, "g;" and "g," commands.

(defn- #_cmdarg_C nv-pcmark [#_cmdarg_C cap]
    (if (checkclearopq (:oap cap))
        cap
        (let [#_pos_C pos (if (== (:cmdchar cap) (byte \g)) (movechangelist (:count1 cap)) (movemark (:count1 cap)))]
            (if (some? pos)
                (nv-cursormark cap, false, pos)
                (do
                    (if (== (:cmdchar cap) (byte \g))
                        (emsg (cond
                            (zero? (:b_changelistlen @curbuf)) (u8 "E664: changelist is empty")
                            (< (:count1 cap) 0) (u8 "E662: At start of changelist")
                            :else (u8 "E663: At end of changelist")
                        ))
                        (clearopbeep (:oap cap)))
                    cap)
            ))
    ))

;; Handle '"' command.

(defn- #_cmdarg_C nv-regname [#_cmdarg_C cap]
    (if (checkclearop (:oap cap))
        cap
        (let [cap (if (== (:nchar cap) (byte \=)) (assoc cap :nchar (get-expr-register)) cap)]
            (if (and (!= (:nchar cap) NUL) (valid-yank-reg (:nchar cap), false))
                (as-> (update cap :oap assoc :regname (:nchar cap)) cap
                      (assoc cap :opcount (:count0 cap))) ;; remember count before '"'
                (do (clearopbeep (:oap cap)) cap)
            ))
    ))

;; Handle "v", "V" and "CTRL-V" commands.
;; Also for "gh", "gH" and "g^H" commands: Always start Select mode, cap.arg is TRUE.
;; Handle CTRL-Q just like CTRL-V.

(defn- #_cmdarg_C nv-visual [#_cmdarg_C cap]
    (let [cap (if (== (:cmdchar cap) Ctrl_Q) (assoc cap :cmdchar Ctrl_V) cap)]
        ;; 'v', 'V' and CTRL-V can be used while an operator is pending to make it characterwise, linewise, or blockwise
        (if (!= (:op_type (:oap cap)) OP_NOP)
            (do
                (reset! finish_op false)      ;; operator doesn't finish now but later
                (update cap :oap assoc :motion_force (:cmdchar cap))
            )
            (do
                (reset! VIsual_select (non-zero? (:arg cap)))
                (cond @VIsual_active      ;; change Visual mode
                (do
                    (if (== @VIsual_mode (:cmdchar cap))     ;; stop visual mode
                        (swap! curwin end-visual-mode)
                        (do
                            (reset! VIsual_mode (:cmdchar cap))
                            (showmode)
                        ))
                    (redraw-curbuf-later INVERTED)      ;; update the inversion
                    cap
                )
                :else                    ;; start Visual mode
                (do
                    (check-visual-highlight)
                    (cond (and (< 0 (:count0 cap)) (!= @resel_VIsual_mode NUL))
                    (do
                        (reset! VIsual_cursor (:w_cursor @curwin)) ;; use previously selected part
                        (reset! VIsual_active true)
                        (reset! VIsual_reselect true)

                        (if (zero? (:arg cap))
                            (may-start-select (byte \c))) ;; start Select mode when 'selectmode' contains "cmd"
                        (if @p_smd
                            (reset! redraw_cmdline true))      ;; show visual mode later

                        ;; For V and ^V, we multiply the number of lines even if there was only one.
                        (when (or (!= @resel_VIsual_mode (byte \v)) (< 1 @resel_VIsual_lmax))
                            (swap! curwin update-in [:w_cursor :lnum] #(min (+ % (dec (* @resel_VIsual_lmax (:count0 cap)))) (line-count @curbuf))))

                        (reset! VIsual_mode @resel_VIsual_mode)

                        (when (== @VIsual_mode (byte \v))
                            (swap! curwin assoc :w_curswant (if (<= @resel_VIsual_lmax 1)
                                                                (do (swap! curwin validate-virtcol) (dec (+ (:w_virtcol @curwin) (* @resel_VIsual_vcol (:count0 cap)))))
                                                                @resel_VIsual_vcol))
                            (swap! curwin coladvance (:w_curswant @curwin))
                        )

                        (cond (== @resel_VIsual_vcol MAXCOL)
                        (do
                            (swap! curwin assoc :w_curswant MAXCOL)
                            (swap! curwin coladvance MAXCOL)
                        )
                        (== @VIsual_mode Ctrl_V)
                        (do
                            (swap! curwin assoc :w_curswant (do (swap! curwin validate-virtcol) (dec (+ (:w_virtcol @curwin) (* @resel_VIsual_vcol (:count0 cap))))))
                            (swap! curwin coladvance (:w_curswant @curwin))
                        )
                        :else
                            (swap! curwin assoc :w_set_curswant true)
                        )

                        (redraw-curbuf-later INVERTED)      ;; show the inversion
                        cap
                    )
                    :else
                    (do
                        (if (zero? (:arg cap))
                            (may-start-select (byte \c))) ;; start Select mode when 'selectmode' contains "cmd"

                        (swap! curwin n-start-visual-mode (:cmdchar cap))

                        (let [cap (if (and (!= @VIsual_mode (byte \V)) (at? @p_sel (byte \e))) (update cap :count1 inc) cap)]   ;; include one more char
                            (if (< 0 (:count0 cap))
                                (let [cap (update cap :count1 dec)]
                                    (if (< 0 (:count1 cap)) ;; with a count select that many characters or lines
                                        (cond
                                            (any == @VIsual_mode (byte \v) Ctrl_V) (nv-right cap)
                                            (== @VIsual_mode (byte \V)) (nv-down cap)
                                            :else cap
                                        )
                                        cap
                                    ))
                                cap
                            ))
                    ))
                ))
            )
        )
    ))

;; Start selection for Shift-movement keys.

(defn- #_window_C start-selection [#_window_C win]
    (may-start-select (byte \k)) ;; if 'selectmode' contains "key", start Select mode
    (n-start-visual-mode win, (byte \v)))

;; Start Select mode, if "c" is in 'selectmode' and not in a mapping or menu.

(defn- #_void may-start-select [#_int c]
    (reset! VIsual_select (and (stuff-empty) (some? (vim-strchr @p_slm, c))))
    nil)

;; Start Visual mode "c".
;; Should set VIsual_select before calling this.

(defn- #_window_C n-start-visual-mode [#_window_C win, #_int c]
    ;; Check for redraw before changing the state.
    (let [win (conceal-check-cursor-line win)
          _ (reset! VIsual_mode c)
          _ (reset! VIsual_active true)
          _ (reset! VIsual_reselect true)
          ;; Corner case: the 0 position in a tab may change when going into virtualedit.
          ;; Recalculate "w_cursor" to avoid bad hilighting.
          win (if (and (== c Ctrl_V) (flag? @ve_flags VE_BLOCK) (== (gchar-cursor win) TAB))
                (let [win (validate-virtcol win)]
                    (coladvance win, (:w_virtcol win)))
                win)
          _ (reset! VIsual_cursor (:w_cursor win))
          ;; Check for redraw after changing the state.
          win (conceal-check-cursor-line win)]
        (when @p_smd ;; show visual mode later
            (reset! redraw_cmdline true))
        ;; Only need to redraw this line, unless still need to redraw
        ;; an old Visual area (when 'lazyredraw' is set).
        (if (< (:w_redr_type win) INVERTED)
            (let [cln (:lnum (:w_cursor win))]
                (assoc win :w_old_cursor_lnum cln, :w_old_visual_lnum cln))
            win)
    ))

;; CTRL-W: Window commands

(defn- #_cmdarg_C nv-window [#_cmdarg_C cap]
    (when (not (checkclearop (:oap cap)))
        (do-window (:nchar cap), (:count0 cap), NUL))
    cap)

;; CTRL-Z: Suspend

(defn- #_cmdarg_C nv-suspend [#_cmdarg_C cap]
    (clearop (:oap cap))
    (when @VIsual_active
        (swap! curwin end-visual-mode)) ;; stop Visual mode
    (do-cmdline-cmd (u8 "st"))
    cap)

;; Commands starting with "g".

(defn- #_cmdarg_C nv-g-cmd [#_cmdarg_C cap]
    (let [win @curwin [_ cap]
            (condp ==? (:nchar cap)
                ;; "gR": Enter virtual replace mode.

                (byte \R)
                    [win (nv-Replace (assoc cap :arg TRUE))]

                (byte \r)
                    [win (nv-vreplace cap)]

                (byte \&)
                    (do (do-cmdline-cmd (u8 "%s//~/&")) [win cap])

                ;; "gv": Reselect the previous Visual area.
                ;;       If Visual already active, exchange previous and current Visual area.

                (byte \v)
                    (let [lmax (line-count @curbuf)]
                        (cond (checkclearop (:oap cap))
                            [win cap]
                        (or (zero? (:lnum (:vi_start (:b_visual @curbuf)))) (< lmax (:lnum (:vi_start (:b_visual @curbuf)))) (zero? (:lnum (:vi_end (:b_visual @curbuf)))))
                            (do (beep-flush) [win cap])
                        :else ;; Set "w_cursor" to the start of the Visual area, "tpos" to the end.
                            (let [[win tpos]
                                    (cond @VIsual_active
                                        (let [? @VIsual_mode
                                              _ (reset! VIsual_mode (:vi_mode (:b_visual @curbuf)))
                                              _ (swap! curbuf assoc-in [:b_visual :vi_mode] ?)
                                              ? (:w_curswant win)
                                              win (assoc win :w_curswant (:vi_curswant (:b_visual @curbuf)))
                                              _ (swap! curbuf assoc-in [:b_visual :vi_curswant] ?)
                                              tpos (:vi_end (:b_visual @curbuf))
                                              _ (swap! curbuf assoc-in [:b_visual :vi_end] (:w_cursor win))
                                              win (assoc win :w_cursor (:vi_start (:b_visual @curbuf)))
                                              _ (swap! curbuf assoc-in [:b_visual :vi_start] @VIsual_cursor)]
                                            [win tpos])
                                    :else
                                        (let [_ (reset! VIsual_mode (:vi_mode (:b_visual @curbuf)))
                                              win (assoc win :w_curswant (:vi_curswant (:b_visual @curbuf)))
                                              tpos (:vi_end (:b_visual @curbuf))
                                              win (assoc win :w_cursor (:vi_start (:b_visual @curbuf)))]
                                            [win tpos])
                                    )]
                                (reset! VIsual_active true)
                                (reset! VIsual_reselect true)
                                ;; Set "VIsual_cursor" to the start and "w_cursor" to the end of the Visual area.
                                ;; Make sure they are on an existing character.
                                (let [win (check-cursor win)
                                      _ (reset! VIsual_cursor (:w_cursor win))
                                      win (assoc win :w_cursor tpos)
                                      win (check-cursor win)
                                      win (update-topline win)]
                                    ;; Normal "g" command: start Select mode when 'selectmode' contains "cmd".
                                    ;; K_SELECT: always start Select mode.
                                    (if (non-zero? (:arg cap))
                                        (reset! VIsual_select true)
                                        (may-start-select (byte \c)))
                                    (redraw-curbuf-later INVERTED)
                                    (showmode)
                                    [win cap]
                                ))
                        ))

                ;; "gV": Don't reselect the previous Visual area after a Select mode mapping of menu.

                (byte \V)
                    (do (reset! VIsual_reselect false) [win cap])

                ;; "gh":  start Select mode.
                ;; "gH":  start Select line mode.
                ;; "g^H": start Select block mode.

               [K_BS (byte \h) (byte \H) Ctrl_H]
                    (let [cap (if (== (:nchar cap) K_BS) (assoc cap :nchar Ctrl_H) cap)
                          cap (assoc cap :cmdchar (+ (:nchar cap) (- (byte \v) (byte \h))) :arg TRUE)]
                        [win (nv-visual cap)])

                ;; "gn", "gN" visually select next/previous search match
                ;; "gn" selects next match
                ;; "gN" selects previous match

               [(byte \N) (byte \n)]
                    (do (when (not (current-search (:count1 cap), (== (:nchar cap) (byte \n))))
                            (clearopbeep (:oap cap)))
                        [win cap])

                ;; "gj" and "gk" two new funny movement keys -- up and down movement based on *screen* line rather than *file* line.

               [(byte \j) K_DOWN]
                    (let [[win cap ?] ;; with 'nowrap' it works just like the normal "j" command
                            (if (not @(:wo_wrap (:w_options win)))
                                (let [cap (update cap :oap assoc :motion_type MLINE)
                                      [win ?] (cursor-down? win, (:count1 cap), (== (:op_type (:oap cap)) OP_NOP))]
                                    [win cap ?])
                                (nv-screengo win, cap, FORWARD, (:count1 cap))
                            )]
                        (when (not ?)
                            (clearopbeep (:oap cap)))
                        [win cap])

               [(byte \k) K_UP]
                    (let [[win cap ?] ;; with 'nowrap' it works just like the normal "k" command
                            (if (not @(:wo_wrap (:w_options win)))
                                (let [cap (update cap :oap assoc :motion_type MLINE)
                                      [win ?] (cursor-up? win, (:count1 cap), (== (:op_type (:oap cap)) OP_NOP))]
                                    [win cap ?])
                                (nv-screengo win, cap, BACKWARD, (:count1 cap))
                            )]
                        (when (not ?)
                            (clearopbeep (:oap cap)))
                        [win cap])

                ;; "gJ": join two lines without inserting a space.

                (byte \J)
                    [win (nv-join cap)]

                ;; "g0", "g^" and "g$": Like "0", "^" and "$" but for screen lines.
                ;; "gm": middle of "g0" and "g$".

               [(byte \0) (byte \^) (byte \m) K_HOME K_KHOME]
                    (let [cap (update cap :oap assoc :motion_type MCHAR :inclusive false)
                          wrap? @(:wo_wrap (:w_options win))
                          [win i]
                            (if (and wrap? (non-zero? (:w_width win)))
                                (let [width1 (- (:w_width win) (win-col-off win)) width2 (+ width1 (win-col-off2 win))
                                      win (validate-virtcol win)]
                                    [win (if (and (<= width1 (:w_virtcol win)) (< 0 width2)) (+ (* (/ (- (:w_virtcol win) width1) width2) width2) width1) 0)])
                                [win (:w_leftcol win)])
                          ;; Go to the middle of the screen line.
                          ;; When 'number' or 'relativenumber' is on and lines are wrapping, the middle can be more to the left.
                          i (if (== (:nchar cap) (byte \m)) (+ i (/ (+ (- (:w_width win) (win-col-off win)) (if (and wrap? (< 0 i)) (win-col-off2 win) 0)) 2)) i)
                          win (coladvance win, i)
                          win (if (== (:nchar cap) (byte \^))
                                (loop-when win (vim-iswhite (gchar-cursor win)) => win
                                    (let [[win ?] (oneright? win)] (recur-if ? win => win)))
                                win
                            )]
                        [(assoc win :w_set_curswant true) cap])

                ;; "g_": to the last non-blank character in the line or <count> lines downward.

                (byte \_)
                    (let [cap (update cap :oap assoc :motion_type MCHAR :inclusive true)
                          win (assoc win :w_curswant MAXCOL)
                          [win ?] (cursor-down? win, (dec (:count1 cap)), (== (:op_type (:oap cap)) OP_NOP))]
                        (if (not ?)
                            (do (clearopbeep (:oap cap)) [win cap])
                            (let [s (ml-get (:lnum (:w_cursor win))) i (:col (:w_cursor win))
                                  ;; In Visual mode we may end up after the line.
                                  i (if (and (< 0 i) (eos? s i)) (dec i) i)
                                  ;; Decrease the cursor column until it's on a non-blank.
                                  win (loop-when-recur i (and (< 0 i) (vim-iswhite (.at s i))) (dec i) => (assoc-in win [:w_cursor :col] i))
                                  win (assoc win :w_set_curswant true)]
                                (adjust-for-sel win, cap))
                        ))

               [(byte \$) K_END K_KEND]
                    (let [cap (update cap :oap assoc :motion_type MCHAR :inclusive true)
                          wrap? @(:wo_wrap (:w_options win)) off (win-col-off win)]
                        (if (and wrap? (non-zero? (:w_width win)))
                            (let [win (assoc win :w_curswant MAXCOL)] ;; so we stay at the end
                                (cond (== (:count1 cap) 1)
                                    (let [width1 (- (:w_width win) off) width2 (+ width1 (win-col-off2 win))
                                          win (validate-virtcol win)
                                          i (+ (dec width1) (if (<= width1 (:w_virtcol win)) (* (inc (/ (- (:w_virtcol win) width1) width2)) width2) 0))
                                          win (coladvance win, i)
                                          ;; Make sure we stick in this column.
                                          win (validate-virtcol win)
                                          win (assoc win :w_curswant (:w_virtcol win) :w_set_curswant false)
                                          ;; Check for landing on a character that got split at the end of the line.
                                          ;; We do not want to advance to the next screen line.
                                          win (if (and (< 0 (:col (:w_cursor win))) wrap? (< i (:w_virtcol win)))
                                                (update-in win [:w_cursor :col] dec)
                                                win
                                            )]
                                        [win cap])
                                :else
                                    (let [[win cap ?] (nv-screengo win, cap, FORWARD, (dec (:count1 cap)))]
                                        (when (not ?)
                                            (clearopbeep (:oap cap)))
                                        [win cap])
                                ))
                            (let [i (dec (- (+ (:w_leftcol win) (:w_width win)) off))
                                  win (coladvance win, i)
                                  ;; Make sure we stick in this column.
                                  win (validate-virtcol win)
                                  win (assoc win :w_curswant (:w_virtcol win) :w_set_curswant false)]
                                [win cap])
                        ))

                ;; "g*" and "g#", like "*" and "#" but without using "\<" and "\>"

               [(byte \*) (byte \#) (char_u POUND)] ;; pound sign (sometimes equal to '#')
                    [win (nv-ident cap)]

                ;; ge and gE: go back to end of word

               [(byte \e) (byte \E)]
                    (let [cap (update cap :oap assoc :motion_type MCHAR :inclusive true)
                          win (assoc win :w_set_curswant true)
                          [win ?] (bckend-word? win, (:count1 cap), (== (:nchar cap) (byte \E)), false)]
                        (when (not ?)
                            (clearopbeep (:oap cap)))
                        [win cap])

                ;; "g CTRL-G": display info about cursor position.

                Ctrl_G
                    [(cursor-pos-info win) cap]

                ;; "gi": start Insert at the last position.

                (byte \i)
                    (let [win (if (non-zero? (:lnum (:b_last_insert @curbuf)))
                                (let [win (assoc win :w_cursor (:b_last_insert @curbuf))
                                      win (check-cursor-lnum win)
                                      i (STRLEN (ml-get (:lnum (:w_cursor win)))) j (- (:col (:w_cursor win)) i)]
                                    (if (< 0 j)
                                        (let [win (if (virtual-active) (update-in win [:w_cursor :coladd] + j) win)]
                                            (assoc-in win [:w_cursor :col] i))
                                        win
                                    ))
                                win
                            )]
                        [win (nv-edit (assoc cap :cmdchar (byte \i)))])

                ;; "gI": Start insert in column 1.

                (byte \I)
                    (let [win (beginline win, 0)
                          cap (if (not (checkclearopq (:oap cap)))
                                (invoke-edit cap, false, (byte \g), false)
                                cap
                            )]
                        [win cap])

                ;; "g'm" and "g`m": jump to mark without setting pcmark.

                (byte \')
                    [win (nv-gomark (assoc cap :arg TRUE))]

                (byte \`)
                    [win (nv-gomark cap)]

                ;; "gs": Goto sleep.

                (byte \s)
                    (do (do-sleep (* (:count1 cap) 1000)) [win cap])

                ;; "ga": Display the ascii value of the character under the cursor.
                ;;       It is displayed in decimal, hex, and octal.

                (byte \a)
                    (do (do-ascii win) [win cap])

                ;; "g8": Display the bytes used for the UTF-8 character under the cursor.
                ;;       It is displayed in hex.
                ;; "8g8" finds illegal byte sequence.

                (byte \8)
                    [(if (== (:count0 cap) 8) (utf-find-illegal win) (do (show-utf8 win) win)) cap]

                (byte \<)
                    [(show-sb-text win) cap]

                ;; "gg": Goto the first line in file.
                ;;       With a count it goes to that line number like for "G".

                (byte \g)
                    [win (nv-goto (assoc cap :arg FALSE))]

                ;; Two-character operators:
                ;;  "gq"    Format text.
                ;;  "gw"    Format text and keep cursor position.
                ;;  "g~"    Toggle the case of the text.
                ;;  "gu"    Change text to lower case.
                ;;  "gU"    Change text to upper case.
                ;;  "g?"    rot13 encoding
                ;;  "g@"    call 'operatorfunc'

               [(byte \q) (byte \w)]
                    (let [cap (assoc-in cap [:oap :cursor_start] (:w_cursor win))]
                        [win (nv-operator cap)])

               [(byte \~) (byte \u) (byte \U) (byte \?) (byte \@)]
                    [win (nv-operator cap)]

                ;; "gP" and "gp": same as "P" and "p" but leave cursor just after new text.

               [(byte \p) (byte \P)]
                    [win (nv-put cap)]

                (byte \,)
                    [win (nv-pcmark cap)]

                (byte \;)
                    [win (nv-pcmark (update cap :count1 -))]

                ;; "g+" and "g-": undo or redo along the timeline.

               [(byte \+) (byte \-)]
                    (do (when (not (checkclearopq (:oap cap)))
                            (undo-time (if (== (:nchar cap) (byte \-)) (- (:count1 cap)) (:count1 cap)), false, false))
                        [win cap])

                K_IGNORE
                    [win cap]

                (do (clearopbeep (:oap cap)) [win cap])
            )]
        (reset! curwin _)
        cap
    ))

;; Handle "o" and "O" commands.

(defn- #_cmdarg_C n-opencmd [#_cmdarg_C cap]
    (if (not (checkclearopq (:oap cap)))
        (let [#_long lold (:lnum (:w_cursor @curwin)) back (== (:cmdchar cap) (byte \O)) fore (== (:cmdchar cap) (byte \o))]
            (if (and (u-save (- lold (if back 1 0)), (+ lold (if fore 1 0))) (let [[_ ?] (open-line? @curwin, (if back BACKWARD FORWARD), 0, 0)] (reset! curwin _) ?))
                (do
                    (when (and (< 0 @(:wo_cole (:w_options @curwin))) (!= lold (:lnum (:w_cursor @curwin))))
                        (swap! curwin update-single-line lold))
                    ;; When '#' is in 'cpoptions' ignore the count.
                    (let [cap (if (some? (vim-strbyte @p_cpo, CPO_HASH)) (assoc cap :count1 1) cap)]
                        (invoke-edit cap, false, (:cmdchar cap), true))
                )
                cap
            ))
        cap
    ))

;; "." command: redo last change.

(defn- #_cmdarg_C nv-dot [#_cmdarg_C cap]
    (when (not (checkclearopq (:oap cap)))
        ;; If "restart_edit" is true, the last but one command is repeated instead of the last command (inserting text).
        ;; This is used for CTRL-O <.> in insert mode.
        (when (not (start-redo @curwin, (:count0 cap), (and (non-zero? @restart_edit) (not @arrow_used))))
            (clearopbeep (:oap cap)))
    )
    cap)

;; CTRL-R: undo undo

(defn- #_cmdarg_C nv-redo [#_cmdarg_C cap]
    (when (not (checkclearopq (:oap cap)))
        (u-redo (:count1 cap))
        (swap! curwin assoc :w_set_curswant true)
    )
    cap)

;; Handle "U" command.

(defn- #_cmdarg_C nv-Undo [#_cmdarg_C cap]
    ;; In Visual mode and typing "gUU" triggers an operator.
    (cond (or (== (:op_type (:oap cap)) OP_UPPER) @VIsual_active)
        (nv-operator (assoc cap :cmdchar (byte \g) :nchar (byte \U))) ;; translate "gUU" to "gUgU"
    (checkclearopq (:oap cap))
        cap
    :else
        (do (swap! curwin u-undoline) (swap! curwin assoc :w_set_curswant true) cap)
    ))

;; '~' command: If tilde is not an operator and Visual is off: swap case of a single character.

(defn- #_cmdarg_C nv-tilde [#_cmdarg_C cap]
    (if (or @p_to @VIsual_active (== (:op_type (:oap cap)) OP_TILDE)) (nv-operator cap) (n-swapchar cap)))

;; Handle an operator command.
;; The actual work is done by do-pending-operator().

(defn- #_cmdarg_C nv-operator [#_cmdarg_C cap]
    (let [#_int op_type (get-op-type (:cmdchar cap), (:nchar cap))]
        (cond (== op_type (:op_type (:oap cap))) ;; double operator works on lines
            (nv-lineop cap)
        (checkclearop (:oap cap))
            cap
        :else
            (update cap :oap assoc :op_start (:w_cursor @curwin) :op_type op_type)
        )
    ))

;; Handle linewise operator "dd", "yy", etc.
;;
;; "_" is is a strange motion command that helps make operators more logical.
;; It is actually implemented, but not documented in the real Vi.  This motion
;; command actually refers to "the current line".  Commands like "dd" and "yy"
;; are really an alternate form of "d_" and "y_".  It does accept a count, so
;; "d3_" works to delete 3 lines.

(defn- #_cmdarg_C nv-lineop [#_cmdarg_C cap]
    (let [cap (update cap :oap assoc :motion_type MLINE) motion_force (:motion_force (:oap cap)) op_type (:op_type (:oap cap))]
        (cond (not (let [[_ ?] (cursor-down? @curwin, (dec (:count1 cap)), (== op_type OP_NOP))] (reset! curwin _) ?))
            (clearopbeep (:oap cap))
        ;; only with linewise motions
        (or (and (== op_type OP_DELETE) (!= motion_force (byte \v)) (!= motion_force Ctrl_V)) (== op_type OP_LSHIFT) (== op_type OP_RSHIFT))
            (swap! curwin beginline (| BL_SOL BL_FIX))
        (!= op_type OP_YANK)        ;; 'Y' does not move cursor
            (swap! curwin beginline (| BL_WHITE BL_FIX))
        )
        cap
    ))

;; <Home> command.

(defn- #_cmdarg_C nv-home [#_cmdarg_C cap]
    ;; CTRL-HOME is like "gg"
    (let [cap (if (flag? @mod_mask MOD_MASK_CTRL) (nv-goto cap) (nv-pipe (assoc cap :count0 1)))]
        (reset! ins_at_eol false)     ;; don't move cursor past eol (only necessary in a one-character line)
        cap
    ))

;; "|" command.

(defn- #_cmdarg_C nv-pipe [#_cmdarg_C cap]
    (let [cap (update cap :oap assoc :motion_type MCHAR :inclusive false) col (max 0 (dec (:count0 cap)))]
        (swap! curwin beginline 0)
        (swap! curwin coladvance col)
        ;; Keep curswant at the column where we wanted to go,
        ;; not where we ended; differs if line is too short.
        (swap! curwin assoc :w_curswant col :w_set_curswant false)
        cap
    ))

;; Handle back-word command "b" and "B".
;; cap.arg is 1 for "B"

(defn- #_cmdarg_C nv-bck-word [#_cmdarg_C cap]
    (let [cap (update cap :oap assoc :motion_type MCHAR :inclusive false)]
        (swap! curwin assoc :w_set_curswant true)
        (when (not (let [[_ ?] (bck-word? @curwin, (:count1 cap), (non-zero? (:arg cap)), false)] (reset! curwin _) ?))
            (clearopbeep (:oap cap))
        )
        cap
    ))

;; Handle word motion commands "e", "E", "w" and "W".
;; cap.arg is TRUE for "E" and "W".

(defn- #_cmdarg_C nv-wordcmd [#_cmdarg_C cap]
    (let-when [win @curwin end? (any == (:cmdchar cap) (byte \e) (byte \E))
          ;; set inclusive for the "E" and "e" command
          cap (update cap :oap assoc :motion_type MCHAR :inclusive end?)
          ;; "cw" and "cW" are special
          [cap [end? #_boolean flag :as _]]
            (let-when [__ [cap [end? false]]] (and (not end?) (== (:op_type (:oap cap)) OP_CHANGE)) => __
                (let-when [c (gchar-cursor win)] (!= c NUL) => __                   ;; empty line
                    ;; This is a little strange:  To match what the real Vi does,
                    ;; we effectively map 'cw' to 'ce', and 'cW' to 'cE', provided
                    ;; that we are not on a space or a TAB.  This seems impolite
                    ;; at first, but it's really more what we mean when we say 'cw'.
                    ;;
                    ;; Another strangeness:  When standing on the end of a word,
                    ;; "ce" will change until the end of the next word, but "cw" will
                    ;; change only one character!  This is done by setting "flag".
                    (cond (not (vim-iswhite c))
                        [(assoc-in cap [:oap :inclusive] true) [true true]]
                    ;; Reproduce a funny Vi behaviour:  "cw" on a blank only changes
                    ;; one character, not all blanks until the start of the next word.
                    ;; Only do this when the 'w' flag is included in 'cpoptions'.
                    (and (== (:count1 cap) 1) (some? (vim-strbyte @p_cpo, CPO_CW)))
                        [(assoc-in cap [:oap :inclusive] true) nil]
                    :else
                        __
                    ))
            )] (some? _) => (do (reset! curwin win) cap)

        (let [o'cursor (:w_cursor win) win (assoc win :w_set_curswant true)
              [win ?]
                (if end?
                    (end-word? win, (:count1 cap), (non-zero? (:arg cap)), flag, false)
                    (fwd-word? win, (:count1 cap), (non-zero? (:arg cap)), (!= (:op_type (:oap cap)) OP_NOP)))
              ;; Don't leave the cursor on the NUL past the end of line.
              ;; Unless we didn't move it forward.
              [win cap] (if (ltpos o'cursor, (:w_cursor win)) (adjust-cursor win, cap) [win cap])
              [win cap]
                (if (and (not ?) (== (:op_type (:oap cap)) OP_NOP))
                    (do (clearopbeep (:oap cap)) [win cap])
                    (adjust-for-sel win, cap)
                )]
            (do (reset! curwin win) cap))
    ))

;; Used after a movement command: if the cursor ends up on the NUL after the end of the line,
;; may move it back to the last character and make the motion inclusive.

(defn- #_[window_C cmdarg_C] adjust-cursor [#_window_C win, #_cmdarg_C cap]
    ;; The cursor cannot remain on the NUL when: the column is > 0; not in Visual mode or 'selection' is "o"; 'virtualedit' is not "all" and not "onemore".
    (if (and (< 0 (:col (:w_cursor win))) (== (gchar-cursor win) NUL) (or (not @VIsual_active) (at? @p_sel (byte \o))) (not (virtual-active)) (non-flag? @ve_flags VE_ONEMORE))
        [(-> win (update-in [:w_cursor :col] dec) (update :w_cursor mb-adjust-pos)) (assoc-in cap [:oap :inclusive] true)]
        [win cap]
    ))

;; "0" and "^" commands.
;; cap.arg is the argument for beginline().

(defn- #_cmdarg_C nv-beginline [#_cmdarg_C cap]
    (let [cap (update cap :oap assoc :motion_type MCHAR :inclusive false)]
        (swap! curwin beginline (:arg cap))
        (reset! ins_at_eol false) ;; don't move cursor past eol (only necessary in a one-character line)
        cap
    ))

;; In exclusive Visual mode, may include the last character.

(defn- #_[window_C cmdarg_C] adjust-for-sel [#_window_C win, #_cmdarg_C cap]
    (if (and @VIsual_active (:inclusive (:oap cap)) (at? @p_sel (byte \e)) (!= (gchar-cursor win) NUL) (ltpos @VIsual_cursor, (:w_cursor win)))
        [(inc-cursor win, false) (assoc-in cap [:oap :inclusive] false)]
        [win cap]
    ))

;; Exclude last character at end of Visual area for 'selection' is "exclusive".
;; Should check VIsual_mode before calling this.
;; Returns true when backed up to the previous line.

(defn- #_boolean unadjust-for-sel []
    (ยง
        (when (and (at? @p_sel (byte \e)) (not (eqpos @VIsual_cursor, (:w_cursor @curwin))))
            ((ร pos_C pp =) (if (ltpos @VIsual_cursor, (:w_cursor @curwin)) (:w_cursor @curwin) @VIsual_cursor))
            (cond (< 0 (:coladd pp))
            (do
                ((ร pp =) (update pp :coladd dec))
            )
            (< 0 (:col pp))
            (do
                ((ร pp =) (update pp :col dec))
                ((ร pp =) (mb-adjust-pos pp))
            )
            (< 1 (:lnum pp))
            (do
                ((ร pp =) (update pp :lnum dec))
                ((ร pp =) (assoc pp :col (STRLEN (ml-get (:lnum pp)))))
                ((ร RETURN) true)
            ))
        )
        false
    ))

;; SELECT key in Normal or Visual mode: end of Select mode mapping.

(defn- #_cmdarg_C nv-select [#_cmdarg_C cap]
    (cond
        @VIsual_active (do (reset! VIsual_select true) cap)
        @VIsual_reselect (nv-g-cmd (assoc cap :nchar (byte \v) :arg TRUE)) ;; fake "gv" command
        :else cap
    ))

;; "G", "gg", CTRL-END, CTRL-HOME.
;; cap.arg is TRUE for "G".

(defn- #_cmdarg_C nv-goto [#_cmdarg_C cap]
    (let [lmax (line-count @curbuf) lnum (if (zero? (:arg cap)) 1 lmax) cap (assoc-in cap [:oap :motion_type] MLINE)]
        (swap! curwin setpcmark)
        (let [lnum (if (non-zero? (:count0 cap)) (:count0 cap) lnum)] ;; when a count is given, use it instead of the default lnum
            (swap! curwin assoc-in [:w_cursor :lnum] (max 1 (min lnum lmax)))
            (swap! curwin beginline (| BL_SOL BL_FIX))
        )
        cap
    ))

;; CTRL-\ in Normal mode.

(defn- #_cmdarg_C nv-normal [#_cmdarg_C cap]
    (let [key (:nchar cap)]
        (if (any == key Ctrl_N Ctrl_G)
            (do
                (clearop (:oap cap))
                (if (and (non-zero? @restart_edit) @mode_displayed)
                    (reset! clear_cmdline true))               ;; unshow mode later
                (reset! restart_edit 0)
                (if (non-zero? @cmdwin_type)
                    (reset! cmdwin_result Ctrl_C))
                (when @VIsual_active
                    (swap! curwin end-visual-mode)          ;; stop Visual
                    (redraw-curbuf-later INVERTED)
                )
                ;; CTRL-\ CTRL-G restarts Insert mode when 'insertmode' is set.
                (if (and (== key Ctrl_G) @p_im)
                    (reset! restart_edit (byte \a)))
            )
            (clearopbeep (:oap cap))
        )
        cap
    ))

;; ESC in Normal mode: beep, but don't flush buffers.
;; Don't even beep if we are canceling a command.

(defn- #_cmdarg_C nv-esc [#_cmdarg_C cap]
    (let [#_boolean no_reason (and (== (:op_type (:oap cap)) OP_NOP) (== (:opcount cap) 0) (== (:count0 cap) 0) (zero? (:regname (:oap cap))) (not @p_im))
          _ (if (non-zero? (:arg cap)) ;; true for CTRL-C
                (do
                    (if (and (zero? @restart_edit) (zero? @cmdwin_type) (not @VIsual_active) no_reason)
                        (msg (u8 "Type  :quit<Enter>  to exit Vim")))
                    (if (not @p_im) ;; don't reset "restart_edit" when 'insertmode' is set
                        (reset! restart_edit 0))
                    (if (non-zero? @cmdwin_type)
                        (do (reset! cmdwin_result K_IGNORE) (reset! got_int false) false)
                        true)
                )
                true)]
        (when _
            (cond @VIsual_active
                (do
                    (swap! curwin end-visual-mode)              ;; stop Visual
                    (swap! curwin check-cursor-col)             ;; make sure cursor is not beyond EOL
                    (swap! curwin assoc :w_set_curswant true)
                    (redraw-curbuf-later INVERTED)
                )
                no_reason (vim-beep))
            (clearop (:oap cap))
            ;; When 'insertmode' is set, return to Insert mode afterwards.
            (if (and (zero? @restart_edit) (goto-im))
                (reset! restart_edit (byte \a)))
        )
        cap
    ))

;; Handle "A", "a", "I", "i" and <Insert> commands.

(defn- #_cmdarg_C nv-edit [#_cmdarg_C cap]
    (let [cap (if (any == (:cmdchar cap) K_INS K_KINS) (assoc cap :cmdchar (byte \i)) cap)] ;; <Insert> is equal to "i"
        ;; in Visual mode "A" and "I" are an operator
        (cond (and @VIsual_active (any == (:cmdchar cap) (byte \A) (byte \I)))
            (v-visop cap)
        ;; in Visual mode and after an operator "a" and "i" are for text objects
        (and (any == (:cmdchar cap) (byte \a) (byte \i)) (or (!= (:op_type (:oap cap)) OP_NOP) @VIsual_active))
            (nv-object cap)
        (checkclearopq (:oap cap))
            cap
        :else
            ;; Pretend Insert mode here to allow the cursor on the character past the end of the line.
            (let [cola- #(let [_ @State] (reset! State INSERT) (swap! curwin coladvance %) (reset! State _)) curl (ml-get-cursor @curwin)]
                (condp == (:cmdchar cap)
                    (byte \A)   ;; "A"ppend after the line
                        (do
                            (swap! curwin assoc :w_set_curswant true)
                            (if (== @ve_flags VE_ALL)
                                (cola- MAXCOL)
                                (swap! curwin update-in [:w_cursor :col] + (STRLEN curl)))
                        )
                    (byte \I)   ;; "I"nsert before the first non-blank
                        (swap! curwin beginline (if (nil? (vim-strbyte @p_cpo, CPO_INSEND)) BL_WHITE (| BL_WHITE BL_FIX)))
                    (byte \a)   ;; "a"ppend is like "i"nsert on the next character
                        (cond
                            ;; Increment coladd when in virtual space, increment the column otherwise, also to append after an unprintable char.
                            (and (virtual-active) (or (< 0 (:coladd (:w_cursor @curwin))) (eos? curl) (at? curl TAB)))
                                (swap! curwin update-in [:w_cursor :coladd] inc)
                            (non-eos? curl)
                                (swap! curwin inc-cursor false)
                        )
                )
                (when (and (non-zero? (:coladd (:w_cursor @curwin))) (!= (:cmdchar cap) (byte \A)))
                    (cola- (getviscol @curwin))
                )
                (invoke-edit cap, false, (:cmdchar cap), false)
            )
        )
    ))

;; Invoke edit() and take care of "restart_edit" and the return value.

(defn- #_cmdarg_C invoke-edit [#_cmdarg_C cap, #_boolean repl, #_int cmd, #_boolean startln]
    ;; repl: "r" or "gr" command
    (let [_ (if (or repl (not (stuff-empty))) @restart_edit 0)]
        ;; Complicated: when the user types "a<C-O>a", we don't want to do Insert mode recursively.
        ;; But when doing "a<C-O>." or "a<C-O>rx", we do allow it.

        ;; Always reset "restart_edit", this is not a restarted edit.
        (reset! restart_edit 0)
        (let [cap (if (edit cmd, startln, (:count1 cap)) (update cap :retval | CA_COMMAND_BUSY) cap)]
            (if (zero? @restart_edit) (reset! restart_edit _))
            cap
        )
    ))

;; "a" or "i" while an operator is pending or in Visual mode: object motion.

(defn- #_cmdarg_C nv-object [#_cmdarg_C cap]
    (let [#_Bytes mps_save @(:b_p_mps @curbuf)] (reset! (:b_p_mps @curbuf) (u8 "(:),{:},[:],<:>")) ;; make sure (), [], {} and <> are in 'matchpairs'
        ;; "ax" = an object: include white space ;; "ix" = inner object: exclude white space
        (let [#_boolean include (!= (:cmdchar cap) (byte \i)) x (:nchar cap)
              #_boolean ok (cond
                (== x (byte \w)) ;; "aw" = a word
                    (current-word (:oap cap), (:count1 cap), include, false)
                (== x (byte \W)) ;; "aW" = a WORD
                    (current-word (:oap cap), (:count1 cap), include, true)
            (or (== x (byte \b)) ;; "ab" = a braces block
                (== x (byte \())
                (== x (byte \))))
                    (current-block (:oap cap), (:count1 cap), include, (byte \(), (byte \)))
            (or (== x (byte \B)) ;; "aB" = a Brackets block
                (== x (byte \{))
                (== x (byte \})))
                    (current-block (:oap cap), (:count1 cap), include, (byte \{), (byte \}))
            (or (== x (byte \[)) ;; "a[" = a [] block
                (== x (byte \])))
                    (current-block (:oap cap), (:count1 cap), include, (byte \[), (byte \]))
            (or (== x (byte \<)) ;; "a<" = a <> block
                (== x (byte \>)))
                    (current-block (:oap cap), (:count1 cap), include, (byte \<), (byte \>))
            (or (== x (byte \")) ;; "a"" = a double quoted string
                (== x (byte \')) ;; "a'" = a single quoted string
                (== x (byte \`))) ;; "a`" = a backtick quoted string
                    (current-quote (:oap cap), (:count1 cap), include, (:nchar cap))
                :else
                    false
                )]
            (reset! (:b_p_mps @curbuf) mps_save)
            (when-not ok
                (clearopbeep (:oap cap)))
            (swap! curwin adjust-cursor-col)
            (swap! curwin assoc :w_set_curswant true)
            cap
        )))

;; "q" command: Start/stop recording.
;; "q:", "q/", "q?": edit command-line in command-line window.

(defn- #_cmdarg_C nv-record [#_cmdarg_C cap]
    (cond (== (:op_type (:oap cap)) OP_FORMAT)
        (nv-operator (assoc cap :cmdchar (byte \g) :nchar (byte \q))) ;; "gqq" is the same as "gqgq": format line
    (checkclearop (:oap cap))
        cap
    :else
        (let [nchar (:nchar cap)]
            (cond (any == nchar (byte \:) (byte \/) (byte \?))
                (do (stuff-char nchar) (stuff-char K_CMDWIN))
            (and (not @execReg) (not (do-record nchar))) ;; (stop) recording into a named register, unless executing a register
                (clearopbeep (:oap cap))
            )
            cap
        )
    ))

;; Handle the "@r" command.

(defn- #_cmdarg_C nv-at [#_cmdarg_C cap]
    (cond (checkclearop (:oap cap))
        cap
    (and (== (:nchar cap) (byte \=)) (== (get-expr-register) NUL))
        cap
    :else
        (loop-when cap (and (< 0 (:count1 cap)) (not @got_int)) => cap
            (if (do-execreg (:nchar cap))
                (do
                    (slow-breakcheck)
                    (recur (update cap :count1 dec))
                )
                (do
                    (clearopbeep (:oap cap))
                    cap
                )
            )
        )
    ))

;; Handle the CTRL-U and CTRL-D commands.

(defn- #_cmdarg_C nv-halfpage [#_cmdarg_C cap]
    (let [key (:cmdchar cap) lnum (:lnum (:w_cursor @curwin)) lmax (line-count @curbuf)]
        (cond
            (or (and (== key Ctrl_U) (== lnum 1)) (and (== key Ctrl_D) (== lnum lmax)))
                (clearopbeep (:oap cap))
            (not (checkclearop (:oap cap)))
                (swap! curwin halfpage (== key Ctrl_D), (:count0 cap))
        )
        cap
    ))

;; Handle "J" or "gJ" command.

(defn- #_cmdarg_C nv-join [#_cmdarg_C cap]
    (cond @VIsual_active ;; join the visual lines
        (nv-operator cap)
    (checkclearop (:oap cap))
        cap
    :else
        (let [cap (update cap :count0 max 2)] ;; default for join is two lines!
            (if (<= (dec (+ (:lnum (:w_cursor @curwin)) (:count0 cap))) (line-count @curbuf))
                (do
                    (prep-redo (:regname (:oap cap)), (:count0 cap), NUL, (:cmdchar cap), NUL, NUL, (:nchar cap))
                    (swap! curwin do-join (:count0 cap), (== (:nchar cap) NUL), true, true)
                )
                (clearopbeep (:oap cap))) ;; beyond last line
            cap)
    ))

;; "P", "gP", "p" and "gp" commands.

(defn- #_cmdarg_C nv-put [#_cmdarg_C cap]
    (if (!= (:op_type (:oap cap)) OP_NOP)
        (do (clearopbeep (:oap cap)) cap)
        (let [visual? @VIsual_active]
            (prep-redo-cmd cap)
            (let [#_int dir (if (or (== (:cmdchar cap) (byte \P)) (and (== (:cmdchar cap) (byte \g)) (== (:nchar cap) (byte \P)))) BACKWARD FORWARD)
                  #_int flags (if (== (:cmdchar cap) (byte \g)) PUT_CURSEND 0)
                  [cap dir flags #_int regname #_yankreg_C reg2]
                    (if visual?
                        ;; Putting in Visual mode: The put text replaces the selected text.
                        ;; First delete the selected text, then put the new text.
                        ;; Need to save and restore the registers that the delete overwrites if the old contents is being put.
                        (let [regname (adjust-clip-reg (:regname (:oap cap)))
                              ;; The delete is going to overwrite the register we want to put, save it first.
                              #_yankreg_C reg1 (when (or (zero? regname) (== regname (byte \")) (asc-isdigit regname) (== regname (byte \-)))  ;; """
                                    (get-register regname, true))
                              ;; Now delete the selected text.
                              cap (-> cap (assoc-in [:oap :regname] NUL)
                                          (assoc :cmdchar (byte \d) :nchar NUL) (nv-operator) (do-pending-operator 0)
                                          (assoc-in [:oap :regname] regname))
                              ;; Delete probably changed the register we want to put, save it first.
                              ;; Then put back what was there before the delete.
                              reg2 (when (some? reg1) (let [_ (get-register regname, false)] (put-register regname, reg1) _))
                              ;; When deleted a linewise Visual area, put the register as lines to avoid it joined with the next line.
                              ;; When deletion was characterwise, split a line when putting lines.
                              mode @VIsual_mode
                              flags (| flags (cond (== mode (byte \V)) PUT_LINE (== mode (byte \v)) PUT_LINE_SPLIT :else 0)
                                             (if (and (== mode Ctrl_V) (== dir FORWARD)) PUT_LINE_FORWARD 0))
                              dir (if (or (and (!= mode (byte \V)) (< (:col (:w_cursor @curwin)) (:col (:b_op_start @curbuf))))
                                          (and (== mode (byte \V)) (< (:lnum (:w_cursor @curwin)) (:lnum (:b_op_start @curbuf)))))
                                    FORWARD ;; cursor is at the end of the line or end of file, put forward
                                    BACKWARD)]
                            (reset! VIsual_active true) ;; may have been reset in do-put()
                            [cap dir flags regname reg2]
                        )
                        [cap dir flags 0 nil])
                  empty? (flag? (:ml_flags (:b_ml @curbuf)) ML_EMPTY)]

                (do-put (:regname (:oap cap)), dir, (:count1 cap), flags)

                ;; If a register was saved, put it back now.
                (if (some? reg2)
                    (put-register regname, reg2))
                ;; What to reselect with "gv"?
                ;; Selecting the just put text seems to be the most useful, since the original was removed.
                (if visual?
                    (swap! curbuf update :b_visual assoc :vi_start (:b_op_start @curbuf) :vi_end (:b_op_end @curbuf)))
                ;; When all lines were selected and deleted do-put() leaves an empty line that needs to be deleted now.
                (let-when [lmax (line-count @curbuf)] (and empty? (eos? (ml-get lmax)))
                    (ml-delete lmax, true)
                    ;; If the cursor was in that line, move it to the end of the last line.
                    (let-when [lmax (line-count @curbuf)] (< lmax (:lnum (:w_cursor @curwin)))
                        (swap! curwin assoc-in [:w_cursor :lnum] lmax)
                        (swap! curwin coladvance MAXCOL)
                    ))
                cap
            ))
    ))

;; "o" and "O" commands.

(defn- #_cmdarg_C nv-open [#_cmdarg_C cap]
    (if @VIsual_active
        (do (swap! curwin v-swap-corners (:cmdchar cap)) cap) ;; switch start and end of visual
        (n-opencmd cap)))

(defn- #_cmdarg_C nv-drop [#_cmdarg_C _cap]
    (do-put (byte \~), BACKWARD, 1, PUT_CURSEND)
    _cap)

;; Trigger CursorHold event.
;; When waiting for a character for 'updatetime' K_CURSORHOLD is put in the
;; input buffer.  "did_cursorhold" is set to avoid retriggering.

(defn- #_cmdarg_C nv-cursorhold [#_cmdarg_C cap]
    (reset! did_cursorhold true)
    (update cap :retval | CA_COMMAND_BUSY)) ;; don't call edit() now

;; This table contains one entry for every Normal or Visual mode command.
;; The order doesn't matter, init_normal_cmds() will create a sorted index.
;; It is faster when all keys from zero to '~' are present.

(final nv_cmd_C* nv_cmds
    [
        (->nv_cmd_C NUL,              nv-error,       0,                      0               ),
        (->nv_cmd_C Ctrl_A,           nv-addsub,      0,                      0               ),
        (->nv_cmd_C Ctrl_B,           nv-page,        NV_STS,                 BACKWARD        ),
        (->nv_cmd_C Ctrl_C,           nv-esc,         0,                      TRUE            ),
        (->nv_cmd_C Ctrl_D,           nv-halfpage,    0,                      0               ),
        (->nv_cmd_C Ctrl_E,           nv-scroll-line, 0,                      TRUE            ),
        (->nv_cmd_C Ctrl_F,           nv-page,        NV_STS,                 FORWARD         ),
        (->nv_cmd_C Ctrl_G,           nv-ctrlg,       0,                      0               ),
        (->nv_cmd_C Ctrl_H,           nv-ctrlh,       0,                      0               ),
        (->nv_cmd_C Ctrl_I,           nv-pcmark,      0,                      0               ),
        (->nv_cmd_C NL,               nv-down,        0,                      FALSE           ),
        (->nv_cmd_C Ctrl_K,           nv-error,       0,                      0               ),
        (->nv_cmd_C Ctrl_L,           nv-clear,       0,                      0               ),
        (->nv_cmd_C Ctrl_M,           nv-down,        0,                      TRUE            ),
        (->nv_cmd_C Ctrl_N,           nv-down,        NV_STS,                 FALSE           ),
        (->nv_cmd_C Ctrl_O,           nv-ctrlo,       0,                      0               ),
        (->nv_cmd_C Ctrl_P,           nv-up,          NV_STS,                 FALSE           ),
        (->nv_cmd_C Ctrl_Q,           nv-visual,      0,                      FALSE           ),
        (->nv_cmd_C Ctrl_R,           nv-redo,        0,                      0               ),
        (->nv_cmd_C Ctrl_S,           nv-ignore,      0,                      0               ),
        (->nv_cmd_C Ctrl_T,           nv-error,       0,                      0               ),
        (->nv_cmd_C Ctrl_U,           nv-halfpage,    0,                      0               ),
        (->nv_cmd_C Ctrl_V,           nv-visual,      0,                      FALSE           ),
        (->nv_cmd_C (int \V),         nv-visual,      0,                      FALSE           ),
        (->nv_cmd_C (int \v),         nv-visual,      0,                      FALSE           ),
        (->nv_cmd_C Ctrl_W,           nv-window,      0,                      0               ),
        (->nv_cmd_C Ctrl_X,           nv-addsub,      0,                      0               ),
        (->nv_cmd_C Ctrl_Y,           nv-scroll-line, 0,                      FALSE           ),
        (->nv_cmd_C Ctrl_Z,           nv-suspend,     0,                      0               ),
        (->nv_cmd_C ESC,              nv-esc,         0,                      FALSE           ),
        (->nv_cmd_C Ctrl_BSL,         nv-normal,      NV_NCH_ALW,             0               ),
        (->nv_cmd_C Ctrl_RSB,         nv-error,       0,                      0               ),
        (->nv_cmd_C Ctrl_HAT,         nv-error,       0,                      0               ),
        (->nv_cmd_C Ctrl__,           nv-error,       0,                      0               ),
        (->nv_cmd_C (int \space),     nv-right,       0,                      0               ),
        (->nv_cmd_C (int \!),         nv-operator,    0,                      0               ),
        (->nv_cmd_C (int \"),         nv-regname,  (| NV_NCH_NOP NV_KEEPREG), 0               ),    ;; """
        (->nv_cmd_C (int \#),         nv-ident,       0,                      0               ),
        (->nv_cmd_C (int \$),         nv-dollar,      0,                      0               ),
        (->nv_cmd_C (int \%),         nv-percent,     0,                      0               ),
        (->nv_cmd_C (int \&),         nv-optrans,     0,                      0               ),
        (->nv_cmd_C (int \'),         nv-gomark,      NV_NCH_ALW,             TRUE            ),
        (->nv_cmd_C (int \(),         nv-error,       0,                      0               ),
        (->nv_cmd_C (int \)),         nv-error,       0,                      0               ),
        (->nv_cmd_C (int \*),         nv-ident,       0,                      0               ),
        (->nv_cmd_C (int \+),         nv-down,        0,                      TRUE            ),
        (->nv_cmd_C (int \,),         nv-csearch,     0,                      TRUE            ),
        (->nv_cmd_C (int \-),         nv-up,          0,                      TRUE            ),
        (->nv_cmd_C (int \.),         nv-dot,         NV_KEEPREG,             0               ),
        (->nv_cmd_C (int \/),         nv-search,      0,                      FALSE           ),
        (->nv_cmd_C (int \0),         nv-beginline,   0,                      0               ),
        (->nv_cmd_C (int \1),         nv-ignore,      0,                      0               ),
        (->nv_cmd_C (int \2),         nv-ignore,      0,                      0               ),
        (->nv_cmd_C (int \3),         nv-ignore,      0,                      0               ),
        (->nv_cmd_C (int \4),         nv-ignore,      0,                      0               ),
        (->nv_cmd_C (int \5),         nv-ignore,      0,                      0               ),
        (->nv_cmd_C (int \6),         nv-ignore,      0,                      0               ),
        (->nv_cmd_C (int \7),         nv-ignore,      0,                      0               ),
        (->nv_cmd_C (int \8),         nv-ignore,      0,                      0               ),
        (->nv_cmd_C (int \9),         nv-ignore,      0,                      0               ),
        (->nv_cmd_C (int \:),         nv-colon,       0,                      0               ),
        (->nv_cmd_C (int \;),         nv-csearch,     0,                      FALSE           ),
        (->nv_cmd_C (int \<),         nv-operator,    NV_RL,                  0               ),
        (->nv_cmd_C (int \=),         nv-operator,    0,                      0               ),
        (->nv_cmd_C (int \>),         nv-operator,    NV_RL,                  0               ),
        (->nv_cmd_C (int \?),         nv-search,      0,                      FALSE           ),
        (->nv_cmd_C (int \@),         nv-at,          NV_NCH_NOP,             FALSE           ),
        (->nv_cmd_C (int \A),         nv-edit,        0,                      0               ),
        (->nv_cmd_C (int \B),         nv-bck-word,    0,                      1               ),
        (->nv_cmd_C (int \C),         nv-abbrev,      NV_KEEPREG,             0               ),
        (->nv_cmd_C (int \D),         nv-abbrev,      NV_KEEPREG,             0               ),
        (->nv_cmd_C (int \E),         nv-wordcmd,     0,                      TRUE            ),
        (->nv_cmd_C (int \F),         nv-csearch,  (| NV_NCH_ALW NV_LANG),    BACKWARD        ),
        (->nv_cmd_C (int \G),         nv-goto,        0,                      TRUE            ),
        (->nv_cmd_C (int \H),         nv-scroll,      0,                      0               ),
        (->nv_cmd_C (int \I),         nv-edit,        0,                      0               ),
        (->nv_cmd_C (int \J),         nv-join,        0,                      0               ),
        (->nv_cmd_C (int \K),         nv-ident,       0,                      0               ),
        (->nv_cmd_C (int \L),         nv-scroll,      0,                      0               ),
        (->nv_cmd_C (int \M),         nv-scroll,      0,                      0               ),
        (->nv_cmd_C (int \N),         nv-next,        0,                      SEARCH_REV      ),
        (->nv_cmd_C (int \O),         nv-open,        0,                      0               ),
        (->nv_cmd_C (int \P),         nv-put,         0,                      0               ),
        (->nv_cmd_C (int \Q),         nv-error,       0,                      0               ),
        (->nv_cmd_C (int \R),         nv-Replace,     0,                      FALSE           ),
        (->nv_cmd_C (int \S),         nv-subst,       NV_KEEPREG,             0               ),
        (->nv_cmd_C (int \T),         nv-csearch,  (| NV_NCH_ALW NV_LANG),    BACKWARD        ),
        (->nv_cmd_C (int \U),         nv-Undo,        0,                      0               ),
        (->nv_cmd_C (int \W),         nv-wordcmd,     0,                      TRUE            ),
        (->nv_cmd_C (int \X),         nv-abbrev,      NV_KEEPREG,             0               ),
        (->nv_cmd_C (int \Y),         nv-abbrev,      NV_KEEPREG,             0               ),
        (->nv_cmd_C (int \Z),         nv-Zet,      (| NV_NCH_NOP NV_NCW),     0               ),
        (->nv_cmd_C (int \[),         nv-brackets,    NV_NCH_ALW,             BACKWARD        ),
        (->nv_cmd_C (int \\),         nv-error,       0,                      0               ),
        (->nv_cmd_C (int \]),         nv-brackets,    NV_NCH_ALW,             FORWARD         ),
        (->nv_cmd_C (int \^),         nv-beginline,   0,                   (| BL_WHITE BL_FIX)),
        (->nv_cmd_C (int \_),         nv-lineop,      0,                      0               ),
        (->nv_cmd_C (int \`),         nv-gomark,      NV_NCH_ALW,             FALSE           ),
        (->nv_cmd_C (int \a),         nv-edit,        NV_NCH,                 0               ),
        (->nv_cmd_C (int \b),         nv-bck-word,    0,                      0               ),
        (->nv_cmd_C (int \c),         nv-operator,    0,                      0               ),
        (->nv_cmd_C (int \d),         nv-operator,    0,                      0               ),
        (->nv_cmd_C (int \e),         nv-wordcmd,     0,                      FALSE           ),
        (->nv_cmd_C (int \f),         nv-csearch,  (| NV_NCH_ALW NV_LANG),    FORWARD         ),
        (->nv_cmd_C (int \g),         nv-g-cmd,       NV_NCH_ALW,             FALSE           ),
        (->nv_cmd_C (int \h),         nv-left,        NV_RL,                  0               ),
        (->nv_cmd_C (int \i),         nv-edit,        NV_NCH,                 0               ),
        (->nv_cmd_C (int \j),         nv-down,        0,                      FALSE           ),
        (->nv_cmd_C (int \k),         nv-up,          0,                      FALSE           ),
        (->nv_cmd_C (int \l),         nv-right,       NV_RL,                  0               ),
        (->nv_cmd_C (int \m),         nv-mark,        NV_NCH_NOP,             0               ),
        (->nv_cmd_C (int \n),         nv-next,        0,                      0               ),
        (->nv_cmd_C (int \o),         nv-open,        0,                      0               ),
        (->nv_cmd_C (int \p),         nv-put,         0,                      0               ),
        (->nv_cmd_C (int \q),         nv-record,      NV_NCH,                 0               ),
        (->nv_cmd_C (int \r),         nv-replace,  (| NV_NCH_NOP NV_LANG),    0               ),
        (->nv_cmd_C (int \s),         nv-subst,       NV_KEEPREG,             0               ),
        (->nv_cmd_C (int \t),         nv-csearch,  (| NV_NCH_ALW NV_LANG),    FORWARD         ),
        (->nv_cmd_C (int \u),         nv-undo,        0,                      0               ),
        (->nv_cmd_C (int \w),         nv-wordcmd,     0,                      FALSE           ),
        (->nv_cmd_C (int \x),         nv-abbrev,      NV_KEEPREG,             0               ),
        (->nv_cmd_C (int \y),         nv-operator,    0,                      0               ),
        (->nv_cmd_C (int \z),         nv-zet,         NV_NCH_ALW,             0               ),
        (->nv_cmd_C (int \{),         nv-error,       0,                      0               ),
        (->nv_cmd_C (int \|),         nv-pipe,        0,                      0               ),
        (->nv_cmd_C (int \}),         nv-error,       0,                      0               ),
        (->nv_cmd_C (int \~),         nv-tilde,       0,                      0               ),

        ;; pound sign
        (->nv_cmd_C (char_u POUND),   nv-ident,       0,                      0               ),
        (->nv_cmd_C K_IGNORE,         nv-ignore,      NV_KEEPREG,             0               ),
        (->nv_cmd_C K_NOP,            nv-nop,         0,                      0               ),
        (->nv_cmd_C K_INS,            nv-edit,        0,                      0               ),
        (->nv_cmd_C K_KINS,           nv-edit,        0,                      0               ),
        (->nv_cmd_C K_BS,             nv-ctrlh,       0,                      0               ),
        (->nv_cmd_C K_UP,             nv-up,       (| NV_SSS NV_STS),         FALSE           ),
        (->nv_cmd_C K_S_UP,           nv-page,        NV_SS,                  BACKWARD        ),
        (->nv_cmd_C K_DOWN,           nv-down,     (| NV_SSS NV_STS),         FALSE           ),
        (->nv_cmd_C K_S_DOWN,         nv-page,        NV_SS,                  FORWARD         ),
        (->nv_cmd_C K_LEFT,           nv-left,     (| NV_SSS NV_STS NV_RL),   0               ),
        (->nv_cmd_C K_S_LEFT,         nv-bck-word, (| NV_SS NV_RL),           0               ),
        (->nv_cmd_C K_C_LEFT,         nv-bck-word, (| NV_SSS NV_RL NV_STS),   1               ),
        (->nv_cmd_C K_RIGHT,          nv-right,    (| NV_SSS NV_STS NV_RL),   0               ),
        (->nv_cmd_C K_S_RIGHT,        nv-wordcmd,  (| NV_SS NV_RL),           FALSE           ),
        (->nv_cmd_C K_C_RIGHT,        nv-wordcmd,  (| NV_SSS NV_RL NV_STS),   TRUE            ),
        (->nv_cmd_C K_PAGEUP,         nv-page,     (| NV_SSS NV_STS),         BACKWARD        ),
        (->nv_cmd_C K_KPAGEUP,        nv-page,     (| NV_SSS NV_STS),         BACKWARD        ),
        (->nv_cmd_C K_PAGEDOWN,       nv-page,     (| NV_SSS NV_STS),         FORWARD         ),
        (->nv_cmd_C K_KPAGEDOWN,      nv-page,     (| NV_SSS NV_STS),         FORWARD         ),
        (->nv_cmd_C K_END,            nv-end,      (| NV_SSS NV_STS),         FALSE           ),
        (->nv_cmd_C K_KEND,           nv-end,      (| NV_SSS NV_STS),         FALSE           ),
        (->nv_cmd_C K_S_END,          nv-end,         NV_SS,                  FALSE           ),
        (->nv_cmd_C K_C_END,          nv-end,      (| NV_SSS NV_STS),         TRUE            ),
        (->nv_cmd_C K_HOME,           nv-home,     (| NV_SSS NV_STS),         0               ),
        (->nv_cmd_C K_KHOME,          nv-home,     (| NV_SSS NV_STS),         0               ),
        (->nv_cmd_C K_S_HOME,         nv-home,        NV_SS,                  0               ),
        (->nv_cmd_C K_C_HOME,         nv-goto,     (| NV_SSS NV_STS),         FALSE           ),
        (->nv_cmd_C K_DEL,            nv-abbrev,      0,                      0               ),
        (->nv_cmd_C K_KDEL,           nv-abbrev,      0,                      0               ),
        (->nv_cmd_C K_UNDO,           nv-kundo,       0,                      0               ),
        (->nv_cmd_C K_SELECT,         nv-select,      0,                      0               ),
        (->nv_cmd_C K_DROP,           nv-drop,        NV_STS,                 0               ),
        (->nv_cmd_C K_CURSORHOLD,     nv-cursorhold,  NV_KEEPREG,             0               ),
    ])

;; ops.c: implementation of op-shift, op-delete, op-tilde, op-change, op-yank, do-put and do-join

;; Number of registers.
;;      0 = unnamed register, for normal yanks and puts
;;   1..9 = registers '1' to '9', for deletes
;; 10..35 = registers 'a' to 'z'
;;     36 = delete register '-'
;;     37 = Selection register '*'.  Only if FEAT_CLIPBOARD defined
;;     38 = Clipboard register '+'.  Only if FEAT_CLIPBOARD and FEAT_X11 defined

;; Symbolic names for some registers.

(final int DELETION_REGISTER       36)
(final int STAR_REGISTER           37)
(final int PLUS_REGISTER           STAR_REGISTER)           ;; there is only one
(final int TILDE_REGISTER          (inc PLUS_REGISTER))

(final int NUM_REGISTERS           (inc TILDE_REGISTER))

;; Each yank register is an array of pointers to lines.

(class! #_final yankreg_C
    [
        (field Bytes*       y_array)            ;; pointer to array of line pointers
        (field int          y_size)             ;; number of lines in "y_array"
        (field byte         y_type)             ;; MLINE, MCHAR or MBLOCK
        (field int          y_width)            ;; only set if y_type == MBLOCK
    ])

(defn- #_void COPY-yankreg [#_yankreg_C y1, #_yankreg_C y0]
    (ยง
        ((ร y1.y_array =) (:y_array y0))
        ((ร y1.y_size =) (:y_size y0))
        ((ร y1.y_type =) (:y_type y0))
        ((ร y1.y_width =) (:y_width y0))
        nil
    ))

(defn- #_yankreg_C* ARRAY-yankreg [#_int n]
    (vec (repeatedly n NEW_yankreg_C)))

(final yankreg_C*   y_regs    (ARRAY-yankreg NUM_REGISTERS))

(atom! yankreg_C    y_current)      ;; ptr to current yankreg
(atom! boolean      y_append)       ;; true when appending
(atom! yankreg_C    y_previous)     ;; ptr to last written yankreg

;; structure used by block-prep, op-delete and op-yank for blockwise operators
;; also op-change, op-shift, op-insert, op-replace

(class! #_final block_def_C
    [
        (field int          startspaces)        ;; 'extra' cols before first char
        (field int          endspaces)          ;; 'extra' cols after last char
        (field int          textlen)            ;; chars in block
        (field Bytes        textstart)          ;; pointer to 1st char (partially) in block
        (field int          textcol)            ;; index of chars (partially) in block
        (field int          start_vcol)         ;; start col of 1st char wholly inside block
        (field int          end_vcol)           ;; start col of 1st char wholly after block
        (field boolean      is_short)           ;; true if line is too short to fit in block
        (field boolean      is_MAX)             ;; true if curswant == MAXCOL when starting
        (field boolean      is_oneChar)         ;; true if block within one character
        (field int          pre_whitesp)        ;; screen cols of ws before block
        (field int          pre_whitesp_c)      ;; chars of ws before block
        (field int          end_char_vcols)     ;; number of vcols of post-block char
        (field int          start_char_vcols)   ;; number of vcols of pre-block char
    ])

;; The names of operators.
;; IMPORTANT: Index must correspond with defines in vim.h!!!
;; The third field indicates whether the operator always works on lines.

(final byte** #_"[/*3*/]" opchars
    [
        [ NUL, NUL, FALSE ],    ;; OP_NOP
        [ \d,  NUL, FALSE ],    ;; OP_DELETE
        [ \y,  NUL, FALSE ],    ;; OP_YANK
        [ \c,  NUL, FALSE ],    ;; OP_CHANGE
        [ \<,  NUL, TRUE  ],    ;; OP_LSHIFT
        [ \>,  NUL, TRUE  ],    ;; OP_RSHIFT
        [ \!,  NUL, TRUE  ],    ;; OP_FILTER
        [ \g,  \~,  FALSE ],    ;; OP_TILDE
        [ \=,  NUL, TRUE  ],    ;; OP_INDENT
        [ \g,  \q,  TRUE  ],    ;; OP_FORMAT
        [ \:,  NUL, TRUE  ],    ;; OP_COLON
        [ \g,  \U,  FALSE ],    ;; OP_UPPER
        [ \g,  \u,  FALSE ],    ;; OP_LOWER
        [ \J,  NUL, TRUE  ],    ;; DO_JOIN
        [ \g,  \J,  TRUE  ],    ;; DO_JOIN_NS
        [ \g,  \?,  FALSE ],    ;; OP_ROT13
        [ \r,  NUL, FALSE ],    ;; OP_REPLACE
        [ \I,  NUL, FALSE ],    ;; OP_INSERT
        [ \A,  NUL, FALSE ],    ;; OP_APPEND
        [ \g,  \w,  TRUE  ],    ;; OP_FORMAT2
        [ \g,  \@,  FALSE ],    ;; OP_FUNCTION
    ])

;; Translate a command name into an operator type.
;; Must only be called with a valid operator name!

(defn- #_int get-op-type [#_int char1, #_int char2]
    (cond
        (== char1 (byte \r))           ;; ignore second character
            OP_REPLACE
        (== char1 (byte \~))           ;; when tilde is an operator
            OP_TILDE
        :else
            (loop-when-recur [#_int i 0] (not (and (== (... (... opchars i) 0) char1) (== (... (... opchars i) 1) char2))) [(inc i)] => i)
    ))

;; Return true if operator "op" always works on whole lines.

(defn- #_boolean op-on-lines [#_int op]
    (!= (... (... opchars op) 2) FALSE))

;; Get first operator command character.
;; Returns 'g' or 'z' if there is another command character.

(defn- #_int get-op-char [#_int optype]
    (... (... opchars optype) 0))

;; Get second operator command character.

(defn- #_int get-extra-op-char [#_int optype]
    (... (... opchars optype) 1))

;; op-shift - handle a shift operation

(defn- #_window_C op-shift [#_window_C win, #_oparg_C oap, #_boolean curs_top, #_int amount]
    (if (u-save (dec (:lnum (:op_start oap))), (inc (:lnum (:op_end oap))))
        (let [#_int block_col (if (:block_mode oap) (:col (:w_cursor win)) 0)
              win (loop-when [win win #_long n (:line_count oap)] (< 0 n) => win
                    (let [win (cond
                                (eos? (ml-get (:lnum (:w_cursor win)))) (assoc-in win [:w_cursor :col] 0)
                                (:block_mode oap)                       (shift-block win, oap, amount)
                                :else                                   (shift-line win, (== (:op_type oap) OP_LSHIFT), @p_sr, amount, false)
                            )]
                        (recur (update-in win [:w_cursor :lnum] inc) (dec n))
                    ))
              _ (changed-lines (:lnum (:op_start oap)), 0, (inc (:lnum (:op_end oap))), 0)
              win (cond (:block_mode oap)
                    (update win :w_cursor assoc :lnum (:lnum (:op_start oap)) :col block_col)
                curs_top ;; put cursor on first line, for ">>"
                    (-> win
                        (assoc-in [:w_cursor :lnum] (:lnum (:op_start oap)))
                        (beginline (| BL_SOL BL_FIX)) ;; shift-line() may have set cursor.col
                    )
                :else ;; put cursor on last line, for ":>"
                    (update-in win [:w_cursor :lnum] dec)
                )]
            (let-when [n (:line_count oap)] (< @p_report n)
                (let [#_Bytes s (if (== (:op_type oap) OP_RSHIFT) (u8 ">") (u8 "<"))]
                    (cond (== n 1)
;%%                     (if (== amount 1)
;%%                         (.sprintf libC @ioBuff, (u8 "1 line %sed 1 time"), s)
;%%                         (.sprintf libC @ioBuff, (u8 "1 line %sed %d times"), s, amount))
                    :else
;%%                     (if (== amount 1)
;%%                         (.sprintf libC @ioBuff, (u8 "%ld lines %sed 1 time"), n, s)
;%%                         (.sprintf libC @ioBuff, (u8 "%ld lines %sed %d times"), n, s, amount))
                    )
                    (msg @ioBuff)
                ))
            ;; Set "'[" and "']" marks.
            (let [enum (:lnum (:op_end oap)) ecol (STRLEN (ml-get enum)) ecol (if (< 0 ecol) (dec ecol) ecol)]
                (swap! curbuf assoc :b_op_start (:op_start oap))
                (swap! curbuf update :b_op_end assoc :lnum enum :col ecol))
            win)
        win
    ))

;; Shift the current line one shiftwidth left (if "left" is true) or right.
;; Leaves cursor on first blank in the line.

(defn- #_window_C shift-line [#_window_C win, #_boolean left, #_boolean round?, #_int amount, #_boolean call_changed_bytes]
    (let [#_int sw (get-sw-value) #_int n (get-indent win) n (if round?
            (let [#_int a (if (and (non-zero? (% n sw)) left) (dec amount) amount) n (/ n sw)]
                (* (if left (max 0 (- n a)) (+ n a)) sw)            ;; round off indent
            )
            (let [#_int a (* amount sw)]
                (if left (max 0 (- n a)) (+ n a))                   ;; original vi indent
            ))]
        (if (flag? @State VREPLACE_FLAG)
            (change-indent win, INDENT_SET, n, false, NUL, call_changed_bytes)
            (set-indent win, n, (if call_changed_bytes SIN_CHANGED 0))
        )
    ))

;; Shift one line of the current block one shiftwidth right or left.
;; Leaves cursor on first character in block.

(defn- #_window_C shift-block [#_window_C win, #_oparg_C oap, #_int amount]
    (let-when [#_boolean left (== (:op_type oap) OP_LSHIFT) o'col (:col (:w_cursor win))
          q_sw (get-sw-value) q_ts @(:b_p_ts @curbuf) q_et @(:b_p_et @curbuf)
          o'State @State _ (reset! State INSERT) ;; don't want REPLACE for State
          #_block_def_C bd (block-prep oap, false, (:lnum (:w_cursor win)), true)
    ] (not (:is_short bd)) => win
        ;; total is number of screen columns to be inserted/removed
        (let [#_int total (* amount q_sw) #_Bytes oldp (ml-get (:lnum (:w_cursor win)))
              [bd #_Bytes newp]
                (if (not left)
                    (let [total (+ total (:pre_whitesp bd)) ;; all virtual WS upto & incl. a split TAB
                          #_int ws_vcol (- (:start_vcol bd) (:pre_whitesp bd))
                          bd (if (non-zero? (:startspaces bd)) (update bd :textstart #(.plus % (us-ptr2len-cc %))) bd)
                          [total bd]
                            (loop-when [total total bd bd] (vim-iswhite (.at (:textstart bd) 0)) => [total bd]
                                ;; TODO: is passing bd.textstart for start of the line OK?
                                (let [__ (atom (#_Bytes object (:textstart bd)))
                                      #_int n (lbr-chartabsize-adv (:textstart bd), __, (:start_vcol bd))
                                      bd (assoc bd :textstart @__)]
                                    (recur (+ total n) (update bd :start_vcol + n))
                                ))
                          ;; OK, now total=all the VWS reqd, and textstart points at the 1st non-ws char in the block.
                          #_int i (if (not q_et) (/ (+ (% ws_vcol q_ts) total) q_ts) 0) ;; number of tabs
                          #_int j (if (non-zero? i) (% (+ (% ws_vcol q_ts) total) q_ts) total) ;; number of spp
                          ;; if we're splitting a TAB, allow for it
                          bd (update bd :textcol - (- (:pre_whitesp_c bd) (if (non-zero? (:startspaces bd)) 1 0)))
                          #_int m (:textcol bd) #_int n (inc (STRLEN (:textstart bd))) newp (Bytes. (+ m i j n))]
                        (BCOPY newp, oldp, m)
                        (copy-chars newp, m, i, TAB)
                        (copy-chars newp, (+ m i), j, (byte \space))
                        (BCOPY newp, (+ m i j), (:textstart bd), 0, n)
                        [bd newp]
                    )
                    ;; Firstly, let's find the first non-whitespace character that is displayed
                    ;; after the block's start column and the character's column number.
                    ;; Also, let's calculate the width of all the whitespace characters that are
                    ;; displayed in the block and precede the searched non-whitespace character.
                    ;;
                    ;; If "bd.startspaces" is set, "bd.textstart" points to the character,
                    ;; the part of which is displayed at the block's beginning.
                    ;; Let's start searching from the next character.
                    (let [a'non_white (atom (#_Bytes object (:textstart bd)))
                          _ (when (non-zero? (:startspaces bd))
                                (swap! a'non_white #(.plus % (us-ptr2len-cc %))))
                          ;; The character's column is in "bd.start_vcol".
                          #_int non_white_col
                            (loop-when [non_white_col (:start_vcol bd)] (vim-iswhite (.at @a'non_white 0)) => non_white_col
                                (let [#_int n (lbr-chartabsize-adv (:textstart bd), a'non_white, non_white_col)]
                                    (recur (+ non_white_col n))
                                ))
                          #_int block_space_width (- non_white_col (:start_vcol oap))
                          ;; We will shift by "total" or "block_space_width", whichever is less.
                          #_int shift_amount (min block_space_width total)
                          ;; The column to which we will shift the text.
                          #_int dest_col (- non_white_col shift_amount)
                          ;; Now let's find out how much of the beginning of the line we can reuse without modification.
                          #_Bytes verb_end (:textstart bd) ;; end of the part of the line which is copied verbatim
                          #_int verb_width (:start_vcol bd) ;; the (displayed) width of this part of line
                          ;; If "bd.startspaces" is set, "bd.textstart" points to the character preceding the block.
                          ;; We have to subtract its width to obtain its column number.
                          verb_width (- verb_width (if (non-zero? (:startspaces bd)) (:start_char_vcols bd) 0))
                          [verb_width verb_end]
                            (loop-when [verb_width verb_width verb_end verb_end] (< verb_width dest_col) => [verb_width verb_end]
                                ;; TODO: is passing "verb_end" for start of the line OK?
                                (let [#_int n (lbr-chartabsize verb_end, verb_end, verb_width)]
                                    (if (< dest_col (+ verb_width n))
                                        [verb_width verb_end]
                                        (recur (+ verb_width n) (.plus verb_end (us-ptr2len-cc verb_end)))
                                    )))
                          ;; If "dest_col" is different from the width of the initial part of the line that will be copied,
                          ;; it means we encountered a tab character, which we will have to partly replace with spaces.
                          #_int n (- dest_col verb_width)
                          ;; The replacement line will consist of:
                          ;; - the beginning of the original line up to "verb_end",
                          ;; - "n" number of spaces,
                          ;; - the rest of the line, pointed to by "non_white".
                          #_int m (BDIFF verb_end, oldp) ;; the length of the line after the block shift
                          newp (Bytes. (+ m n (STRLEN @a'non_white) 1))]
                        (BCOPY newp, oldp, m)
                        (copy-chars newp, m, n, (byte \space))
                        (BCOPY newp, (+ m n), @a'non_white, 0, (inc (STRLEN @a'non_white)))
                        [bd newp]
                    )
                )]
            (ml-replace (:lnum (:w_cursor win)), newp)
            (changed-bytes (:lnum (:w_cursor win)), (:textcol bd))
            (reset! State o'State)
            (assoc-in win [:w_cursor :col] o'col)
        )
    ))

;; Insert string "s" ("ins" ? before : after) block.
;; Caller must prepare for undo.

(defn- #_void block-insert [#_oparg_C oap, #_Bytes s, #_boolean ins, #_boolean is_MAX]
    (let [#_int state' @State _ (reset! State INSERT) ;; don't want REPLACE for State
          #_int n (STRLEN s)]
        ;; ct: non-zero if cutting a TAB ;; es: extra spaces to replace a cut TAB
        (loop-when [#_int ct 0 #_int es 0 #_long y (inc (:lnum (:op_start oap)))] (<= y (:lnum (:op_end oap)))
            (let [#_block_def_C bd (block-prep oap, is_MAX, y, true)]
                (if (and (:is_short bd) ins)
                    (recur ct es (inc y))                       ;; OP_INSERT, line ends before block start
                    (let [#_Bytes p (ml-get y)
                          [#_int ts ct es #_int x]
                            (if ins
                                (let [ts (:start_char_vcols bd) ct (:startspaces bd)]
                                    [ts ct (if (non-zero? ct) (dec ts) es) (:textcol bd)])
                                (let [ts (:end_char_vcols bd)]
                                    (if (not (:is_short bd))
                                        ;; ct = padding after block
                                        (let [ct (if (non-zero? (:endspaces bd)) (- ts (:endspaces bd)) 0)]
                                            [ts ct (if (non-zero? ct) (dec ts) es) (- (+ (:textcol bd) (:textlen bd)) (if (non-zero? ct) 1 0))])
                                        ;; ct = padding to block edge ;; if $ used, just append to EOL (ie ct==0)
                                        (let [ct (if (not (:is_MAX bd)) (inc (- (:end_vcol oap) (:end_vcol bd))) ct)]
                                            [ts ct ct (+ (:textcol bd) (:textlen bd))])
                                    )))
                          [ct es x]
                            (if (< 0 ct) ;; Avoid starting halfway a multi-byte character.
                                (let [[#_int i x] (if ins [(us-head-off p, (.plus p (+ x ct))) x] (let [i (us-off-next p, (.plus p x))] [i (+ x i)]))]
                                    [(- ct i) (- es i) x])
                                [ct es x])
                          #_Bytes q (Bytes. (+ (STRLEN p) n es 1))
                          _ (BCOPY q, p, x)                             ;; copy up to shifted part
                          p (.plus p x)
                          _ (copy-chars q, x, ct, (byte \space))        ;; insert pre-padding
                          _ (BCOPY q, (+ x ct), s, 0, n)                ;; copy the new text
                          x (+ x n)
                          [p es]
                            (if (and (< 0 ct) (not (:is_short bd)))
                                (do (copy-chars q, (+ x ct), (- ts ct), (byte \space)) ;; insert post-padding
                                    ;; We're splitting a TAB, don't copy it.
                                    ;; We allowed for that TAB, remember this now.
                                    [(.plus p 1) (inc es)])
                                [p es])
                          x (if (< 0 ct) (+ x es) x)
                          _ (BCOPY q, x, p, 0, (inc (STRLEN p)))]
                        (ml-replace y, q)
                        (when (== y (:lnum (:op_end oap)))
                            ;; Set "']" mark to the end of the block instead of the end of the insert in the first line.
                            (swap! curbuf update :b_op_end assoc :lnum y :col x))
                        (recur ct es (inc y))
                    ))
            ))
        (changed-lines (inc (:lnum (:op_start oap))), 0, (inc (:lnum (:op_end oap))), 0)
        (reset! State state'))
    nil)

;; op-reindent - handle reindenting a block of lines.

(defn- #_void op-reindent [#_oparg_C oap, #_getindent_F getindent]
    (let [#_long n (:lnum (:w_cursor @curwin)) m (:line_count oap)
          [#_long x #_long y #_long i]
            (loop-when [x 0 y 0 i (dec m)] (and (<= 0 i) (not @got_int)) => [x y i]
                ;; It's a slow thing to do, so give feedback, so there's no worry that the computer's just hung.
                (when (and (< 1 i) (or (zero? (% i 50)) (== i (dec m))) (< @p_report m))
                    (smsg (u8 "%ld lines to indent... "), i))
                (let [[x y] (if (let [[_ ?] (set-indent? @curwin, (if (non-eos? (skipwhite (ml-get (:lnum (:w_cursor @curwin))))) (getindent) 0), SIN_UNDO)] (reset! curwin _) ?)
                                (let [l (:lnum (:w_cursor @curwin))] [(if (zero? x) l x) l])
                                [x y]
                            )]
                    (swap! curwin update :w_cursor crlf)
                    (recur x y (dec i)))
            )]
        ;; put cursor on first non-blank of indented line
        (swap! curwin assoc-in [:w_cursor :lnum] n)
        (swap! curwin beginline (| BL_SOL BL_FIX))
        ;; Mark changed lines so that they will be redrawn.
        ;; When Visual highlighting was present, need to continue until the last line.
        ;; When there is no change, still need to remove the Visual highlighting.
        (cond
            (non-zero? y)    (changed-lines x, 0, (if (:is_VIsual oap) (+ n m) (inc y)), 0)
            (:is_VIsual oap) (redraw-curbuf-later INVERTED)
        )
        (when (< @p_report m)
            (let [i (- m (inc i))]
                (if (== i 1)
                    (msg (u8 "1 line indented "))
                    (smsg (u8 "%ld lines indented "), i))
            ))
        ;; set '[ and '] marks
        (swap! curbuf assoc :b_op_start (:op_start oap) :b_op_end (:op_end oap)))
    nil)

;; Keep the last expression line here, for repeating.

(atom! Bytes expr_line)

;; Get an expression for the "\"=expr1" or "CTRL-R =expr1"
;; Returns '=' when OK, NUL otherwise.

(defn- #_int get-expr-register []
    (let-when [#_Bytes s (getcmdline (byte \=), 0)] (some? s) => NUL
        (when (non-eos? s)
            (reset! expr_line s)) ;; else use previous line
        (byte \=)
    ))

(atom! int __nested)

;; Get the result of the '=' register expression.
;; Returns a pointer to allocated memory, or null for failure.

(defn- #_Bytes get-expr-line []
    (let-when [#_Bytes e @expr_line] (some? e) => nil
        ;; Make a copy of the expression, because evaluating it may cause it to be changed.
        ;; When invoked recursively, limit the evaluation to 10 levels, then return the string as-is.
        (let-when [e (STRDUP e)] (< @__nested 10) => e
            (swap! __nested inc) (let [e (eval-to-string e, nil)] (swap! __nested dec) e))
    ))

;; Check if 'regname' is a valid name of a yank register.
;; Note: There is no check for 0 (default register), caller should do this.

(defn- #_boolean valid-yank-reg [#_int regname, #_boolean writing]
    ;; writing: if true check for writable registers
    (or (and (< 0 regname) (asc-isalnum regname))
        (and (not writing) (some? (vim-strchr (u8 "/.%:="), regname)))
        (== regname (byte \#))
        (== regname (byte \"))   ;; """
        (== regname (byte \-))
        (== regname (byte \_))
        (== regname (byte \*))
        (== regname (byte \+))
        (and (not writing) (== regname (byte \~)))
    ))

;; Set y_current and y_append, according to the value of "regname".
;; Cannot handle the '_' register.
;; Must only be called with a valid register name!
;;
;; If regname is 0 and writing, use register 0.
;; If regname is 0 and reading, use previous register.

(defn- #_void get-yank-register [#_int regname, #_boolean writing]
    (reset! y_append false)
    (if (and (or (zero? regname) (== regname (byte \"))) (not writing) (some? @y_previous))    ;; """
        (reset! y_current @y_previous)
        (let [#_int i regname
              i (cond
                    (asc-isdigit i) (- i (byte \0))
                    (asc-islower i) (+ (lowerOrd i) 10)
                    (asc-isupper i) (do (reset! y_append true) (+ (upperOrd i) 10))
                    (== regname (byte \-)) DELETION_REGISTER
                    (and (not writing) (== regname (byte \~))) TILDE_REGISTER
                    :else 0 ;; not 0-9, a-z, A-Z or '-': use register 0
                )]
            (reset! y_current (... y_regs i))
            (when writing        ;; remember the register we write into for do-put()
                (reset! y_previous @y_current))
        ))
    nil)

;; Obtain the contents of a "normal" register.  The register is made empty.
;; The returned pointer has allocated memory, use put-register() later.

(defn- #_yankreg_C get-register [#_int name, #_boolean copy]
    ;; copy: make a copy, if false make register empty.
    (ยง
        (get-yank-register name, false)

        ((ร yankreg_C reg =) (NEW_yankreg_C))

        (COPY-yankreg reg, @y_current)
        (cond copy
        (do
            ;; If we run out of memory some or all of the lines are empty.
            (cond (zero? (:y_size reg))
            (do
                ((ร reg =) (assoc reg :y_array nil))
            )
            :else
            (do
                ((ร reg =) (assoc reg :y_array (ร new Bytes[reg.y_size])))

                (dotimes [#_int i (:y_size reg)]
                    ((ร reg.y_array[i] =) (STRDUP (... (:y_array @y_current) i)))
                )
            ))
        )
        :else
        (do
            (swap! y_current assoc :y_array nil)
        ))

        reg
    ))

;; Put "reg" into register "name".  Free any previous contents and "reg".

(defn- #_void put-register [#_int name, #_yankreg_C reg]
    (get-yank-register name, false)
    (swap! y_current assoc :y_array nil)
    (COPY-yankreg @y_current, reg)
    nil)

(atom! int rec__regname)

;; Start or stop recording into a yank register.
;;
;; Return false for failure, true otherwise.

(defn- #_boolean do-record [#_int c]
    (cond (not @Recording)          ;; start recording
    (do
        ;; registers 0-9, a-z and " are allowed
        (if (or (< c 0) (and (not (asc-isalnum c)) (!= c (byte \")))) ;; """
            false
            (do (reset! Recording true)
                (showmode)
                (reset! rec__regname c)
                true))
    )
    :else                           ;; stop recording
    (do
        ;; Get the recorded key hits.
        ;; KB_SPECIAL will be escaped, this needs to be removed again to put it in a register.
        ;; exec_reg then adds the escaping back later.
        (reset! Recording false)
        (msg (u8 ""))
        (let-when [#_Bytes p (get-recorded)] (some? p) => false
            ;; Remove escaping for KB_SPECIAL in multi-byte chars.
            (vim-unescape-special p)
            ;; We don't want to change the default register here,
            ;; so save and restore the current register name.
            (let [#_yankreg_C yp @y_previous #_yankreg_C yc @y_current #_boolean b (stuff-yank @rec__regname, p) _ (reset! y_previous yp) _ (reset! y_current yc)]
                b)
        ))
    ))

;; Stuff string "p" into yank register "regname" as a single line (append if uppercase).
;;
;; Return false for failure, true otherwise.

(defn- #_boolean stuff-yank [#_int regname, #_Bytes p]
    (ยง
        ;; check for read-only register
        (if (and (non-zero? regname) (not (valid-yank-reg regname, true)))
            ((ร RETURN) false)
        )
        (if (== regname (byte \_))             ;; black hole: don't do anything
            ((ร RETURN) true)
        )

        (get-yank-register regname, true)

        (cond (and @y_append (some? (:y_array @y_current)))
        (do
            ((ร Bytes[] a =) (:y_array @y_current))
            ((ร int i =) (dec (:y_size @y_current)))

            ((ร Bytes lp =) (Bytes. (+ (STRLEN (... a i)) (STRLEN p) 1)))
            (STRCPY lp, (... a i))
            (STRCAT lp, p)
            ((ร a[i] =) lp)
        )
        :else
        (do
            (swap! y_current assoc :y_array (ร new Bytes[1]))
            ((ร @y_current.y_array[0] =) p)
            (swap! y_current assoc :y_size 1)
            (swap! y_current assoc :y_type MCHAR)   ;; used to be MLINE, why?
        ))

        true
    ))

(final Bytes CTRL_1_31 (u8 "\001\002\003\004\005\006\007\010\011\012\013\014\015\016\017\020\021\022\023\024\025\026\027\030\031\032\033\034\035\036\037"))

(atom! int execreg_lastc NUL)

;; Execute a yank register: copy it into the stuff buffer.
;;
;; Return false for failure, true otherwise.

(defn- #_boolean do-execreg [#_int regname]
    (let-when [[regname :as _]
            (if (== regname (byte \@))                                                      ;; repeat previous one
                (let [regname @execreg_lastc] (if (== regname NUL) nil [regname]))
                [regname]
            )] (some? _) => (do (emsg (u8 "E748: No previously used register")) false)

        (if (or (any == regname (byte \%) (byte \#)) (not (valid-yank-reg regname, false))) ;; check for valid regname
            (do (emsg-invreg regname)
                false)
            (let [_ (reset! execreg_lastc regname) regname (may-get-selection regname)]
                (condp == regname
                    (byte \_)                                                               ;; black hole: don't stuff anything
                        true
                    (byte \:)                                                               ;; use last command line
                        (if (some? @last_cmdline)
                            (let [_ (reset! new_last_cmdline nil)                           ;; don't keep the cmdline containing @:
                                  ;; Escape all control characters with a CTRL-V.
                                  #_Bytes p (vim-strsave-escaped @last_cmdline, CTRL_1_31, Ctrl_V)
                                  ;; When in Visual mode "'<,'>" will be prepended to the command.
                                  ;; Remove it when it's already there.
                                  p (if (and @VIsual_active (zero? (STRNCMP p, (u8 "'<,'>"), 5))) (.plus p 5) p)]
                                (put-in-typebuf p, true, true)
                                true)
                            (do (emsg e_nolastcmd)
                                false))
                    (byte \=)
                        (let-when [#_Bytes p (get-expr-line)] (some? p) => false
                            (put-in-typebuf p, true, false)
                            true)
                    (byte \.)                                                               ;; use last inserted text
                        (let-when [#_Bytes p (get-last-insert-save)] (some? p) => (do (emsg e_noinstext) false)
                            (put-in-typebuf p, false, false)
                            true)
                    (let-when [_ (get-yank-register regname, false)] (some? (:y_array @y_current)) => false
                        ;; Insert lines into typeahead buffer, from last one to first one.
                        (put-reedit-in-typebuf)
                        (loop-when-recur [#_int i (:y_size @y_current)] (< 0 i) [(dec i)]
                            ;; insert NL between lines and after last line if type is MLINE
                            (when (or (== (:y_type @y_current) MLINE) (< i (:y_size @y_current)))
                                (ins-typebuf (u8 "\n")))
                            (ins-typebuf (vim-strsave-escape-special (... (:y_array @y_current) (dec i)))))
                        (reset! execReg true)                                               ;; disable the 'q' command
                        true
                    ))
            ))
    ))

;; If "restart_edit" is not zero, put it in the typeahead buffer,
;; so that it's used only after other typeahead has been processed.

(defn- #_void put-reedit-in-typebuf []
    (when (!= @restart_edit NUL)
        (let [#_Bytes buf (Bytes. 3)]
            (if (== @restart_edit (byte \V))
                (-> buf (.be 0, (byte \g)) (.be 1, (byte \R)) (eos! 2))
                (-> buf (.be 0, (if (== @restart_edit (byte \I)) (byte \i) @restart_edit)) (eos! 1))
            )
            (ins-typebuf buf)
            (reset! restart_edit NUL)
        ))
    nil)

;; Insert register contents "s" into the typeahead buffer, so that it will be executed again.
;; When "esc" is true it is to be taken literally: escape CSI characters and no remapping.

(defn- #_void put-in-typebuf [#_Bytes s, #_boolean esc, #_boolean colon]
    (put-reedit-in-typebuf)
    (when colon
        (ins-typebuf (u8 "\n")))
    (ins-typebuf (if esc (vim-strsave-escape-special s) s))
    (when colon
        (ins-typebuf (u8 ":")))
    nil)

;; Insert a yank register: copy it into the Read buffer.
;; Used by CTRL-R command and middle mouse button in insert mode.
;;
;; return false for failure, true otherwise

(defn- #_boolean insert-reg [#_int regname, #_boolean literally] ;; literally: insert literally, not as if typed
    ;; It is possible to get into an endless loop by having CTRL-R a in register a and then, in insert mode, doing CTRL-R a.
    ;; If you hit CTRL-C, the loop will be broken here.
    (ui-breakcheck)
    (if (or @got_int (and (!= regname NUL) (not (valid-yank-reg regname, false)))) ;; check for valid regname
        false
        (let [regname (may-get-selection regname) a'arg (atom (#_Bytes object))]
            (cond (== regname (byte \.))                 ;; insert last inserted text
                (stuff-inserted NUL, 1, true)
            (get-spec-reg regname, a'arg, true)
                (if (some? @a'arg) (do (stuffescaped @a'arg, literally) true) false)
            :else                                ;; name or number register
            (do
                (get-yank-register regname, false)
                (if (nil? (:y_array @y_current))
                    false
                    (do
                        (dotimes [#_int i (:y_size @y_current)]
                            (stuffescaped (... (:y_array @y_current) i), literally)
                            ;; Insert a newline between lines and after last line if y_type is MLINE.
                            (if (or (== (:y_type @y_current) MLINE) (< i (dec (:y_size @y_current))))
                                (stuff-char (byte \newline)))
                        )
                        true
                    ))
            ))
        )
    ))

;; Stuff a string into the typeahead buffer, such that edit() will insert it
;; literally ("literally" true) or interpret is as typed characters.

(defn- #_void stuffescaped [#_Bytes _arg, #_boolean literally]
    (let [a'arg (atom (#_Bytes object _arg))]
        (while (non-eos? @a'arg)
            ;; Stuff a sequence of normal ASCII characters, that's fast.
            ;; Also stuff KB_SPECIAL to get the effect of a special key when "literally" is true.
            (let [#_Bytes start @a'arg]
                (while (or (and (<= (byte \space) (.at @a'arg 0)) (< (.at @a'arg 0) DEL)) (and (at? @a'arg KB_SPECIAL) (not literally)))
                    (swap! a'arg plus 1))
                (when (BLT start, @a'arg)
                    (stuff-redo-len start, (BDIFF @a'arg, start)))
            )
            ;; stuff a single special character
            (when (non-eos? @a'arg)
                (let [#_int c (us-ptr2char-adv a'arg, false)]
                    (when (and literally (or (and (< c (byte \space)) (!= c TAB)) (== c DEL)))
                        (stuff-char Ctrl_V))
                    (stuff-char c)
                ))
        ))
    nil)

;; If "regname" is a special register, return true and store a pointer to its value in "value".

(defn- #_boolean get-spec-reg [#_int regname, #_Bytes' a'value, #_boolean errmsg]
    (condp ==? regname
        (byte \=)                                       ;; result of expression
        (do
            (reset! a'value (get-expr-line))
            true
        )
        (byte \:)                                       ;; last command line
        (do
            (reset! a'value @last_cmdline)
            (when (and (nil? @a'value) errmsg) (emsg e_nolastcmd))
            true
        )
        (byte \/)                                       ;; last search-pattern
        (do
            (reset! a'value (last-search-pat))
            (when (and (nil? @a'value) errmsg) (emsg e_noprevre))
            true
        )
        (byte \.)                                       ;; last inserted text
        (do
            (reset! a'value (get-last-insert-save))
            (when (and (nil? @a'value) errmsg) (emsg e_noinstext))
            true
        )
        [Ctrl_W Ctrl_A]         ;; word under cursor ;; WORD (mnemonic All) under cursor
        (do
            (reset! a'value nil)
            (when errmsg
                (let [#_int n (find-ident-under-cursor @curwin, a'value, (if (== regname Ctrl_W) (| FIND_IDENT FIND_STRING) FIND_STRING))]
                    (reset! a'value (if (pos? n) (STRNDUP @a'value, n) nil))
                ))
            errmsg
        )
        (byte \_)               ;; black hole: always empty
        (do
            (reset! a'value (u8 ""))
            true
        )
     ;; :else
        (do
            (reset! a'value nil)
            false
        )
    ))

;; Paste a yank register into the command line.
;; Only for non-special registers.
;; Used by CTRL-R command in command-line mode.
;; insert-reg() can't be used here, because special characters from the register contents will be interpreted as commands.
;;
;; return false for failure, true otherwise

(defn- #_boolean cmdline-paste-reg [#_int regname, #_boolean literally, #_boolean remcr]
    ;; literally: insert text literally instead of "as typed"
    ;; remcr: don't add trailing CR
    (get-yank-register regname, false)
    (if (some? (:y_array @y_current))
        (loop-when [#_int i 0] (< i (:y_size @y_current)) => true
            (cmdline-paste-str (... (:y_array @y_current) i), literally)
            ;; Insert ^M between lines and after last line if type is MLINE.
            ;; Don't do this when "remcr" is true and the next line is empty.
            (when (or (== (:y_type @y_current) MLINE)
                        (and (< i (dec (:y_size @y_current)))
                            (not (and remcr (== i (- (:y_size @y_current) 2)) (eos? (... (:y_array @y_current) (inc i)))))))
                (cmdline-paste-str (u8 "\r"), literally))
            ;; Check for CTRL-C in case someone tries to paste a few thousand lines and gets bored.
            (ui-breakcheck)
            (if @got_int false (recur (inc i)))
        )
        false
    ))

;; Adjust the register name "reg" for the clipboard being used always and the clipboard being available.

(defn- #_int adjust-clip-reg [#_int reg]
    (if (any == reg (byte \*) (byte \+)) 0 reg))

;; When "reg" is a clipboard register, obtain the selection.
;; If it's not available return zero, otherwise return "reg".

(defn- #_int may-get-selection [#_int reg]
    (if (any == reg (byte \*) (byte \+)) 0 reg))

;; Handle a delete operation.
;;
;; Return false if undo failed, true otherwise.

(defn- #_boolean op-delete [#_oparg_C oap]
    (ยง
        ((ร long old_lcount =) (line-count @curbuf))
        ((ร boolean did_yank =) false)
        ((ร int orig_regname =) (:regname oap))

        (if (flag? (:ml_flags (:b_ml @curbuf)) ML_EMPTY) ;; nothing to do
            ((ร RETURN) true)
        )

        ;; Nothing to delete, return here.  Do prepare undo, for op-change().
        (if (:empty oap)
            ((ร RETURN) (u-save-cursor))
        )

        ((ร oap =) (update oap :regname adjust-clip-reg))

        ((ร oap =) (mb-adjust-opend oap))

        ;; Imitate the strange Vi behaviour: If the delete spans more than one
        ;; line and motion_type == MCHAR and the result is a blank line, make the
        ;; delete linewise.  Don't do this for the change command or Visual mode.

        (when (and (== (:motion_type oap) MCHAR) (not (:is_VIsual oap)) (not (:block_mode oap)) (< 1 (:line_count oap)) (== (:motion_force oap) NUL) (== (:op_type oap) OP_DELETE))
            ((ร Bytes ptr =) (.plus (ml-get (:lnum (:op_end oap))) (:col (:op_end oap))))
            ((ร ptr =) (if (and (non-eos? ptr) (:inclusive oap)) (.plus ptr 1) ptr))
            ((ร ptr =) (skipwhite ptr))
            (if (and (eos? ptr) (inindent @curwin, 0))
                ((ร oap =) (assoc oap :motion_type MLINE))
            )
        )

;       setmarks:
;       {
            ;; Check for trying to delete (e.g. "D") in an empty line.
            ;; Note: For the change operator it is ok.

            (when (and (== (:motion_type oap) MCHAR) (== (:line_count oap) 1) (== (:op_type oap) OP_DELETE) (eos? (ml-get (:lnum (:op_start oap)))))
                ;; It's an error to operate on an empty region,
                ;; when 'E' included in 'cpoptions' (Vi compatible).

                (when (!= @virtual_op FALSE)
                    ;; Virtual editing: nothing gets deleted,
                    ;; but we set the '[ and '] marks as if it happened.
                    (ร BREAK setmarks)
                )
                (if (some? (vim-strbyte @p_cpo, CPO_EMPTYREGION))
                    (beep-flush))
                ((ร RETURN) true)
            )

            ;; Do a yank of whatever we're about to delete.
            ;; If a yank register was specified, put the deleted text into that register.
            ;; For the black hole register '_' don't yank anything.

            (when (!= (:regname oap) (byte \_))
                (when (non-zero? (:regname oap))
                    ;; check for read-only register
                    (when (not (valid-yank-reg (:regname oap), true))
                        (beep-flush)
                        ((ร RETURN) true)
                    )
                    (get-yank-register (:regname oap), true)       ;; yank into specif'd reg.
                    ((ร did_yank =) (or (op-yank oap, true, false) did_yank))      ;; yank without message
                )

                ;; Put deleted text into register 1 and shift number registers if the
                ;; delete contains a line break, or when a regname has been specified.
                ;; Use the register name from before adjust-clip-reg() may have changed it.

                (when (or (non-zero? orig_regname) (== (:motion_type oap) MLINE) (< 1 (:line_count oap)) (:use_reg_one oap))
                    (reset! y_current (... y_regs 9))
                    (swap! y_current assoc :y_array nil)               ;; free register nine
                    (loop-when-recur [#_int n 9] (< 1 n) [(dec n)]
                        (COPY-yankreg (... y_regs n), (... y_regs (dec n)))
                    )
                    (reset! y_previous (reset! y_current (... y_regs 1)))
                    ((ร y_regs[1].y_array =) nil)               ;; set register one to empty
                    ((ร did_yank =) (or (op-yank oap, true, false) did_yank))
                )

                ;; Yank into small delete register when no named register specified
                ;; and the delete is within one line.
                (when (and (zero? (:regname oap)) (!= (:motion_type oap) MLINE) (== (:line_count oap) 1))
                    ((ร oap =) (assoc oap :regname (byte \-)))
                    (get-yank-register (:regname oap), true)
                    ((ร did_yank =) (or (op-yank oap, true, false) did_yank))
                    ((ร oap =) (assoc oap :regname 0))
                )

                ;; If there's too much stuff to fit in the yank register, then get a
                ;; confirmation before doing the delete.  This is crude, but simple.
                ;; And it avoids doing a delete of something we can't put back if we want.

                (when (and (not did_yank) (!= (ask-yesno (u8 "cannot yank; delete anyway"), true) (byte \y)))
                    (emsg e_abort)
                    ((ร RETURN) false)
                )
            )

            ;; block mode delete

            (cond (:block_mode oap)
            (do
                (if (not (u-save (dec (:lnum (:op_start oap))), (inc (:lnum (:op_end oap)))))
                    ((ร RETURN) false)
                )

                (loop-when-recur [#_long lnum (:lnum (:w_cursor @curwin))] (<= lnum (:lnum (:op_end oap))) [(inc lnum)]
                    ((ร block_def_C bd =) (block-prep oap, false, lnum, true))
                    (if (zero? (:textlen bd))    ;; nothing to delete
                        (ร CONTINUE)
                    )

                    ;; Adjust cursor position for tab replaced by spaces and 'lbr'.
                    (when (== lnum (:lnum (:w_cursor @curwin)))
                        (swap! curwin update :w_cursor assoc :col (+ (:textcol bd) (:startspaces bd)) :coladd 0))

                    ;; n == number of chars deleted
                    ;; If we delete a TAB, it may be replaced by several characters.
                    ;; Thus the number of characters may increase!

                    ((ร int n =) (- (:textlen bd) (:startspaces bd) (:endspaces bd)))
                    ((ร Bytes oldp =) (ml-get lnum))
                    ((ร Bytes newp =) (Bytes. (- (inc (STRLEN oldp)) n)))

                    ;; copy up to deleted part
                    (BCOPY newp, oldp, (:textcol bd))
                    ;; insert spaces
                    (copy-chars newp, (:textcol bd), (+ (:startspaces bd) (:endspaces bd)), (byte \space))
                    ;; copy the part after the deleted part
                    ((ร oldp =) (.plus oldp (+ (:textcol bd) (:textlen bd))))
                    (BCOPY newp, (+ (:textcol bd) (:startspaces bd) (:endspaces bd)), oldp, 0, (inc (STRLEN oldp)))
                    ;; replace the line
                    (ml-replace lnum, newp)
                )

                (swap! curwin check-cursor-col)
                (changed-lines (:lnum (:w_cursor @curwin)), (:col (:w_cursor @curwin)), (inc (:lnum (:op_end oap))), 0)
                ((ร oap =) (assoc oap :line_count 0))     ;; no lines deleted
            )
            (== (:motion_type oap) MLINE)
            (do
                (cond (== (:op_type oap) OP_CHANGE)
                (do
                    ;; Delete the lines except the first one.  Temporarily move the
                    ;; cursor to the next line.  Save the current line number, if the
                    ;; last line is deleted it may be changed.

                    (when (< 1 (:line_count oap))
                        ((ร long lnum =) (:lnum (:w_cursor @curwin)))
                        (swap! curwin update-in [:w_cursor :lnum] inc)
                        (swap! curwin del-lines (dec (:line_count oap)), true)
                        (swap! curwin assoc-in [:w_cursor :lnum] lnum)
                    )
                    (if (not (u-save-cursor))
                        ((ร RETURN) false)
                    )
                    (cond @(:b_p_ai @curbuf)                  ;; don't delete indent
                    (do
                        (swap! curwin beginline BL_WHITE)            ;; cursor on first non-white
                        (reset! did_ai true)                  ;; delete the indent when ESC hit
                        (reset! ai_col (:col (:w_cursor @curwin)))
                    )
                    :else
                    (do
                        (swap! curwin beginline 0)                   ;; cursor in column 0
                    ))
                    (swap! curwin truncate-line false)               ;; delete the rest of the line
                                                        ;; leave cursor past last char in line
                    (if (< 1 (:line_count oap))
                        (u-clearline))                  ;; "U" command not possible after "2cc"
                )
                :else
                (do
                    (swap! curwin del-lines (:line_count oap), true)
                    (swap! curwin beginline (| BL_WHITE BL_FIX))
                    (u-clearline)                      ;; "U" command not possible after "dd"
                ))
            )
            :else
            (do
                (when (!= @virtual_op FALSE)
                    ((ร int endcol =) 0)

                    ;; For virtualedit: break the tabs that are partly included.
                    (when (== (gchar-pos (:op_start oap)) TAB)
                        (if (not (u-save-cursor))       ;; save first line for undo
                            ((ร RETURN) false)
                        )
                        ((ร endcol =) (if (== (:line_count oap) 1) (getviscol2 @curwin, (:col (:op_end oap)), (:coladd (:op_end oap))) endcol))
                        (swap! curwin coladvance-force (getviscol2 @curwin, (:col (:op_start oap)), (:coladd (:op_start oap))))
                        (COPY-pos (:op_start oap), (:w_cursor @curwin))
                        (when (== (:line_count oap) 1)
                            (swap! curwin coladvance endcol)
                            ((ร oap =) (assoc-in oap [:op_end :col] (:col (:w_cursor @curwin))))
                            ((ร oap =) (assoc-in oap [:op_end :coladd] (:coladd (:w_cursor @curwin))))
                            (swap! curwin assoc :w_cursor (:op_start oap))
                        )
                    )

                    ;; Break a tab only when it's included in the area.
                    (when (and (== (gchar-pos (:op_end oap)) TAB) (< (:coladd (:op_end oap)) (if (:inclusive oap) 1 0)))
                        ;; save last line for undo
                        (if (not (u-save (dec (:lnum (:op_end oap))), (inc (:lnum (:op_end oap)))))
                            ((ร RETURN) false)
                        )
                        (swap! curwin assoc :w_cursor (:op_end oap))
                        (swap! curwin coladvance-force (getviscol2 @curwin, (:col (:op_end oap)), (:coladd (:op_end oap))))
                        (COPY-pos (:op_end oap), (:w_cursor @curwin))
                        (swap! curwin assoc :w_cursor (:op_start oap))
                    )
                )

                (cond (== (:line_count oap) 1)            ;; delete characters within one line
                (do
                    (if (not (u-save-cursor))           ;; save line for undo
                        ((ร RETURN) false)
                    )

                    ((ร int n =) (- (+ (- (:col (:op_end oap)) (:col (:op_start oap))) 1) (if (not (:inclusive oap)) 1 0)))

                    (when (!= @virtual_op FALSE)
                        ;; fix up things for virtualedit-delete:
                        ;; break the tabs which are going to get in our way

                        ((ร Bytes curline =) (ml-get (:lnum (:w_cursor @curwin))))
                        ((ร int len =) (STRLEN curline))

                        ((ร n =) (if (and (non-zero? (:coladd (:op_end oap))) (<= (dec len) (:col (:op_end oap))) (not (and (non-zero? (:coladd (:op_start oap))) (<= (dec len) (:col (:op_end oap)))))) (inc n) n))
                        ;; Delete at least one char (e.g, when on a control char).
                        ((ร n =) (if (and (zero? n) (!= (:coladd (:op_start oap)) (:coladd (:op_end oap)))) 1 n))

                        ;; When deleted a char in the line, reset coladd.
                        (when (!= (gchar-cursor @curwin) NUL)
                            (swap! curwin assoc-in [:w_cursor :coladd] 0))
                    )
                    (cond (and (== (:op_type oap) OP_DELETE) (:inclusive oap) (== (:lnum (:op_end oap)) (line-count @curbuf)) (< (STRLEN (ml-get (:lnum (:op_end oap)))) n))
                    (do
                        ;; Special case: gH<Del> deletes the last line.
                        (swap! curwin del-lines 1, false)
                    )
                    :else
                    (do
                        (swap! curwin del-bytes n, (== @virtual_op FALSE), (and (== (:op_type oap) OP_DELETE) (not (:is_VIsual oap))))
                    ))
                )
                :else                                    ;; delete characters between lines
                (do
                    ;; save deleted and changed lines for undo
                    (if (not (u-save (dec (:lnum (:w_cursor @curwin))), (+ (:lnum (:w_cursor @curwin)) (:line_count oap))))
                        ((ร RETURN) false)
                    )

                    ((ร boolean delete_last_line =) (== (:lnum (:op_end oap)) (line-count @curbuf)))
                    (swap! curwin truncate-line true)                ;; delete from cursor to end of line

                    ((ร pos_C curpos =) (NEW_pos_C))
                    (COPY-pos curpos, (:w_cursor @curwin))

                    (swap! curwin update-in [:w_cursor :lnum] inc)
                    (swap! curwin del-lines (- (:line_count oap) 2), false)

                    (if delete_last_line
                        ((ร oap =) (assoc-in oap [:op_end :lnum] (line-count @curbuf)))
                    )

                    ((ร int n =) (- (inc (:col (:op_end oap))) (if (not (:inclusive oap)) 1 0)))
                    (cond (and (:inclusive oap) delete_last_line (< (STRLEN (ml-get (:lnum (:op_end oap)))) n))
                    (do
                        ;; Special case: gH<Del> deletes the last line.
                        (swap! curwin del-lines 1, false)
                        (swap! curwin assoc :w_cursor curpos)
                        (swap! curwin assoc-in [:w_cursor :lnum] (min (:lnum (:w_cursor @curwin)) (line-count @curbuf)))
                    )
                    :else
                    (do
                        ;; delete from start of line until op_end
                        (swap! curwin assoc-in [:w_cursor :col] 0)
                        (swap! curwin del-bytes n, (== @virtual_op FALSE), (and (== (:op_type oap) OP_DELETE) (not (:is_VIsual oap))))
                        (swap! curwin assoc :w_cursor curpos)
                    ))
                    (when (< (:lnum (:w_cursor @curwin)) (line-count @curbuf))
                        (swap! curwin do-join 2, false, false, false))
                ))
            ))

            (msgmore (- (line-count @curbuf) old_lcount))
;       }

        (cond (:block_mode oap)
        (do
            (swap! curbuf assoc-in [:b_op_end :lnum] (:lnum (:op_end oap)))
            (swap! curbuf assoc-in [:b_op_end :col] (:col (:op_start oap)))
        )
        :else
        (do
            (swap! curbuf assoc :b_op_end (:op_start oap))
        ))
        (swap! curbuf assoc :b_op_start (:op_start oap))

        true
    ))

;; Adjust end of operating area for ending on a multi-byte character.
;; Used for deletion.

(defn- #_oparg_C mb-adjust-opend [#_oparg_C oap]
    (if (:inclusive oap)
        (let [#_Bytes s (ml-get (:lnum (:op_end oap)))]
            (update-in oap [:op_end :col] #(+ % (us-tail-off s, (.plus s %)))))
        oap
    ))

;; Replace a whole area with one character.

(defn- #_boolean op-replace [#_oparg_C oap, #_int c]
    (ยง
        ((ร Bytes after_p =) nil)
        ((ร boolean had_ctrl_v_cr =) (any == c -1 -2))

        (if (or (flag? (:ml_flags (:b_ml @curbuf)) ML_EMPTY) (:empty oap))
            ((ร RETURN) true)            ;; nothing to do
        )

        ((ร c =) (if had_ctrl_v_cr (if (== c -1) (byte \return) (byte \newline)) c))

        ((ร oap =) (mb-adjust-opend oap))

        (if (not (u-save (dec (:lnum (:op_start oap))), (inc (:lnum (:op_end oap)))))
            ((ร RETURN) false)
        )

        ;; block mode replace

        (cond (:block_mode oap)
        (do
            ((ร boolean is_MAX =) (== (:w_curswant @curwin) MAXCOL))

            (loop-when [] (<= (:lnum (:w_cursor @curwin)) (:lnum (:op_end oap)))
                (swap! curwin assoc-in [:w_cursor :col] 0)    ;; make sure cursor position is valid
                ((ร block_def_C bd =) (block-prep oap, is_MAX, (:lnum (:w_cursor @curwin)), true))
                (when (and (zero? (:textlen bd)) (or (== @virtual_op FALSE) (:is_MAX bd)))
                    (swap! curwin update-in [:w_cursor :lnum] inc)
                    (ร CONTINUE)               ;; nothing to replace
                )

                ;; n == number of extra chars required
                ;; If we split a TAB, it may be replaced by several characters.
                ;; Thus the number of characters may increase!

                ;; If the range starts in virtual space,
                ;; count the initial coladd offset as part of "startspaces".
                (ร int n)
                (cond (and (!= @virtual_op FALSE) (:is_short bd) (eos? (:textstart bd)))
                (do
                    ((ร pos_C vpos =) (->pos_C (:lnum (:w_cursor @curwin)), 0, 0))
                    ((ร [@curwin vpos] =) (getvpos @curwin, vpos, (:start_vcol oap)))
                    ((ร bd =) (update bd :startspaces + (:coladd vpos)))
                    ((ร n =) (:startspaces bd))
                )
                :else
                (do
                    ;; allow for pre spaces
                    ((ร n =) (if (non-zero? (:startspaces bd)) (dec (:start_char_vcols bd)) 0))
                ))

                ;; allow for post spp
                ((ร n =) (+ n (if (and (non-zero? (:endspaces bd)) (not (:is_oneChar bd)) (< 0 (:end_char_vcols bd))) (dec (:end_char_vcols bd)) 0)))
                ;; Figure out how many characters to replace.
                ((ร int numc =) (inc (- (:end_vcol oap) (:start_vcol oap))))
                ((ร numc =) (if (and (:is_short bd) (or (== @virtual_op FALSE) (:is_MAX bd))) (- numc (inc (- (:end_vcol oap) (:end_vcol bd)))) numc))

                ;; A double-wide character can be replaced only up to half the times.
                (when (< 1 (utf-char2cells c))
                    (when (and (non-zero? (& numc 1)) (not (:is_short bd)))
                        ((ร bd =) (update bd :endspaces inc))
                        ((ร n =) (inc n))
                    )
                    ((ร numc =) (/ numc 2))
                )

                ;; Compute bytes needed, move character count to num_chars.
                ((ร int num_chars =) numc)
                ((ร numc =) (* numc (utf-char2len c)))
                ;; oldlen includes textlen, so don't double count
                ((ร n =) (+ n (- numc (:textlen bd))))

                ((ร Bytes oldp =) (ml-get (:lnum (:w_cursor @curwin))))
                ((ร int oldlen =) (STRLEN oldp))
                ((ร Bytes newp =) (Bytes. (+ oldlen 1 n)))

                ;; copy up to deleted part
                (BCOPY newp, oldp, (:textcol bd))
                ((ร oldp =) (.plus oldp (+ (:textcol bd) (:textlen bd))))
                ;; insert pre-spaces
                (copy-chars newp, (:textcol bd), (:startspaces bd), (byte \space))
                ;; insert replacement chars CHECK FOR ALLOCATED SPACE
                ;; -1/-2 is used for entering CR literally.
                (cond (or had_ctrl_v_cr (and (!= c (byte \return)) (!= c (byte \newline))))
                (do
                    ((ร n =) (STRLEN newp))
                    (loop-when [] (<= 0 ((ร num_chars =) (dec num_chars)))
                        ((ร n =) (+ n (utf-char2bytes c, (.plus newp n))))
                        (recur)
                    )

                    (when (not (:is_short bd))
                        ;; insert post-spaces
                        (copy-chars newp, (STRLEN newp), (:endspaces bd), (byte \space))
                        ;; copy the part after the changed part
                        (BCOPY newp, (STRLEN newp), oldp, 0, (inc (STRLEN oldp)))
                    )
                )
                :else
                (do
                    ;; Replacing with \r or \n means splitting the line.
                    ((ร after_p =) (Bytes. (- (+ oldlen 1 n) (STRLEN newp))))
                    (BCOPY after_p, oldp, (inc (STRLEN oldp)))
                ))
                ;; replace the line
                (ml-replace (:lnum (:w_cursor @curwin)), newp)
                (when (some? after_p)
                    (ml-append (:lnum (:w_cursor @curwin)), after_p)
                    (swap! curwin update-in [:w_cursor :lnum] inc)
                    (appended-lines-mark (:lnum (:w_cursor @curwin)), 1)
                    ((ร oap =) (update-in oap [:op_end :lnum] inc))
                )
                (swap! curwin update-in [:w_cursor :lnum] inc)
                (recur)
            )
        )
        :else
        (do
            ;; MCHAR and MLINE motion replace.

            (cond (== (:motion_type oap) MLINE)
            (do
                ((ร oap =) (assoc-in oap [:op_start :col] 0))
                (swap! curwin assoc-in [:w_cursor :col] 0)
                ((ร oap =) (assoc-in oap [:op_end :col] (STRLEN (ml-get (:lnum (:op_end oap))))))
                (if (non-zero? (:col (:op_end oap)))
                    ((ร oap =) (update-in oap [:op_end :col] dec))
                )
            )
            (not (:inclusive oap))
            (do
                ((ร oap =) (update oap :op_end #(let [[_ ?] (decp %)] _)))
            ))

            (loop-when [] (ltoreq (:w_cursor @curwin), (:op_end oap))
                ((ร int n =) (gchar-cursor @curwin))
                (cond (!= n NUL)
                (do
                    (cond (or (< 1 (utf-char2len c)) (< 1 (utf-char2len n)))
                    (do
                        ;; This is slow, but it handles replacing a single-byte with a multi-byte and the other way around.
                        (if (== (:lnum (:w_cursor @curwin)) (:lnum (:op_end oap)))
                            ((ร oap =) (update-in oap [:op_end :col] + (- (utf-char2len c) (utf-char2len n))))
                        )
                        ((ร n =) @State)
                        (reset! State REPLACE)
                        (swap! curwin ins-char c)
                        (reset! State n)
                        ;; Backup to the replaced character.
                        (swap! curwin dec-cursor false)
                    )
                    :else
                    (do
                        (when (== n TAB)
                            ((ร int end_vcol =) 0)

                            ;; oap.op_end has to be recalculated when the tab breaks
                            ((ร end_vcol =) (if (== (:lnum (:w_cursor @curwin)) (:lnum (:op_end oap))) (getviscol2 @curwin, (:col (:op_end oap)), (:coladd (:op_end oap))) end_vcol))
                            (swap! curwin coladvance-force (getviscol @curwin))
                            (when (== (:lnum (:w_cursor @curwin)) (:lnum (:op_end oap)))
                                ((ร [@curwin oap.op_end] =) (getvpos @curwin, (:op_end oap), end_vcol)))
                        )
                        (.be (ml-get (:lnum (:w_cursor @curwin))) (:col (:w_cursor @curwin)), c)
                    ))
                )
                (and (!= @virtual_op FALSE) (== (:lnum (:w_cursor @curwin)) (:lnum (:op_end oap))))
                (do
                    ((ร int virtcols =) (:coladd (:op_end oap)))

                    ((ร virtcols =) (if (and (== (:lnum (:w_cursor @curwin)) (:lnum (:op_start oap))) (== (:col (:op_start oap)) (:col (:op_end oap))) (non-zero? (:coladd (:op_start oap)))) (- virtcols (:coladd (:op_start oap))) virtcols))

                    ;; 'oap.op_end' has been trimmed, so it's effectively inclusive;
                    ;; as a result, an extra +1 must be counted, so we don't trample the NUL byte.
                    (swap! curwin coladvance-force (inc (getviscol2 @curwin, (:col (:op_end oap)), (:coladd (:op_end oap)))))
                    (swap! curwin update-in [:w_cursor :col] - (inc virtcols))
                    (loop-when-recur virtcols (<= 0 virtcols) (dec virtcols)
                        (.be (ml-get (:lnum (:w_cursor @curwin))) (:col (:w_cursor @curwin)), c)
                        (if (== (let [[_ ?] (inc-cursor? @curwin, false)] (reset! curwin _) ?) -1)
                            (ร BREAK)
                        )
                    )
                ))

                ;; Advance to next character, stop at the end of the file.
                (if (== (let [[_ ?] (inc-cursor? @curwin, false)] (reset! curwin _) ?) -1)
                    (ร BREAK)
                )
                (recur)
            )
        ))

        (swap! curwin assoc :w_cursor (:op_start oap))
        (swap! curwin check-cursor)
        (changed-lines (:lnum (:op_start oap)), (:col (:op_start oap)), (inc (:lnum (:op_end oap))), 0)

        ;; Set "'[" and "']" marks.
        (swap! curbuf assoc :b_op_start (:op_start oap) :b_op_end (:op_end oap))

        true
    ))

;; Handle the (non-standard vi) tilde operator.  Also for "gu", "gU" and "g?".

(defn- #_oparg_C op-tilde [#_oparg_C oap]
    (if-not (u-save (dec (:lnum (:op_start oap))), (inc (:lnum (:op_end oap))))
        oap
        (let [[oap #_boolean changed]
                (if (:block_mode oap)
                    (let [changed
                            (loop-when [#_pos_C pos (:op_start oap) changed false] (<= (:lnum pos) (:lnum (:op_end oap))) => changed
                                (let [#_block_def_C bd (block-prep oap, false, (:lnum pos), false)
                                      pos (assoc pos :col (:textcol bd))
                                      [pos ?] (swapchars (:op_type oap), pos, (:textlen bd)) changed (or ? changed)]
                                    (recur (update pos :lnum inc) changed))
                            )]
                        (when changed
                            (changed-lines (:lnum (:op_start oap)), 0, (inc (:lnum (:op_end oap))), 0))
                        [oap changed]
                    )
                    (let [#_pos_C pos (:op_start oap)
                          [oap pos]
                            (cond (== (:motion_type oap) MLINE)
                                (let [oap (assoc-in oap [:op_start :col] 0)
                                      oap (assoc-in oap [:op_end :col] (STRLEN (ml-get (:lnum (:op_end oap)))))
                                      oap (if (non-zero? (:col (:op_end oap))) (update-in oap [:op_end :col] dec) oap)]
                                    [oap (assoc pos :col 0)])
                            (not (:inclusive oap))
                                [(update oap :op_end #(let [[_ ?] (decp %)] _)) pos]
                            :else
                                [oap pos])
                          changed
                            (if (== (:lnum pos) (:lnum (:op_end oap)))
                                (let [[_ ?] (swapchars (:op_type oap), pos, (inc (- (:col (:op_end oap)) (:col pos))))] ?)
                                (loop [pos pos changed false]
                                    (let [[pos ?] (swapchars (:op_type oap), pos, (if (== (:lnum pos) (:lnum (:op_end oap))) (inc (:col (:op_end oap))) (STRLEN (ml-get-pos pos))))
                                        changed (or ? changed)]
                                        (if (ltoreq (:op_end oap), pos)
                                            changed
                                            (let [[pos ?] (incp pos)]
                                                (recur-if (!= ? -1) [pos changed] => changed)
                                            ))
                                    ))
                            )]
                        (when changed
                            (changed-lines (:lnum (:op_start oap)), (:col (:op_start oap)), (inc (:lnum (:op_end oap))), 0))
                        [oap changed])
                )]
            ;; No change: need to remove the Visual selection.
            (when (and (not changed) (:is_VIsual oap))
                (redraw-curbuf-later INVERTED))
            ;; Set '[ and '] marks.
            (swap! curbuf assoc :b_op_start (:op_start oap), :b_op_end (:op_end oap))
            (let-when [n (:line_count oap)] (< @p_report n)
                (if (== n 1) (msg (u8 "1 line changed")) (smsg (u8 "%ld lines changed"), n)))
            oap
        )
    ))

;; Invoke swapchar() on "len" bytes at position "pos".
;; "pos" is advanced to just after the changed characters.
;; "len" is rounded up to include the whole last multi-byte character.
;; Also works correctly when the number of bytes changes.
;; Returns true if any character has been changed.

(defn- #_[pos_C boolean] swapchars [#_int op_type, #_pos_C pos, #_int len]
    (loop-when [pos pos changed false len len] (< 0 len) => [pos changed]
        (let [n (us-ptr2len-cc (ml-get-pos pos)) len (- len (if (< 0 n) (dec n) 0)) ;; we're counting bytes, not characters
              [pos ?] (swapchar op_type, pos) changed (or ? changed)
              [pos ?] (incp pos)]
            (recur-if (!= ? -1) [pos changed (dec len)] => [pos changed])) ;; at end of file
    ))

;; If op_type == OP_UPPER: make uppercase,
;; if op_type == OP_LOWER: make lowercase,
;; if op_type == OP_ROT13: do rot13 encoding,
;; else swap case of character at "pos".
;; Returns true when something actually changed.

(defn- #_[pos_C boolean] swapchar [#_int op_type, #_pos_C pos]
    ;; Only do rot13 encoding for ASCII characters.
    (let-when [#_int c (gchar-pos pos)] (or (< c 0x80) (!= op_type OP_ROT13)) => [pos false]
        (let [pos (if (and (== op_type OP_UPPER) (== c 0xdf))
                    (let [o'cursor (:w_cursor @curwin)]
                        ;; Special handling of German sharp s: change to "SS".
                        (swap! curwin assoc :w_cursor pos)
                        (swap! curwin del-char false)
                        (swap! curwin ins-char (byte \S))
                        (swap! curwin ins-char (byte \S))
                        (swap! curwin assoc :w_cursor o'cursor)
                        (let [[_ ?] (incp pos)] _))
                    pos
                )]
            (let-when [#_int nc (cond
                        (utf-islower c) (cond (== op_type OP_ROT13) (rot13 c, (byte \a)) (!= op_type OP_LOWER) (utf-toupper c) :else c)
                        (utf-isupper c) (cond (== op_type OP_ROT13) (rot13 c, (byte \A)) (!= op_type OP_UPPER) (utf-tolower c) :else c)
                        :else c)] (!= nc c) => [pos false]
                (if (or (<= 0x80 c) (<= 0x80 nc))
                    (let [o'cursor (:w_cursor @curwin)]
                        (swap! curwin assoc :w_cursor pos)
                        ;; don't use del-char(), it also removes composing chars
                        (swap! curwin del-bytes (us-ptr2len (ml-get-cursor @curwin)), false, false)
                        (swap! curwin ins-char nc)
                        (swap! curwin assoc :w_cursor o'cursor))
                    (.be (ml-get (:lnum pos)) (:col pos), nc))
                [pos true]
            ))
    ))

;; op-insert - Insert and append operators for Visual mode.

(defn- #_void op-insert [#_oparg_C oap, #_long count1]
    (ยง
        ((ร int pre_textlen =) 0)

        ;; edit() changes this - record it for OP_APPEND
        ((ร block_def_C bd =) (NEW_block_def_C))
        ((ร bd.is_MAX =) (== (:w_curswant @curwin) MAXCOL))

        ;; vis block is still marked.  Get rid of it now.
        (swap! curwin assoc-in [:w_cursor :lnum] (:lnum (:op_start oap)))
        (update-screen INVERTED)

        (when (:block_mode oap)
            ;; When 'virtualedit' is used, need to insert the extra spaces before doing block-prep().
            ;; When only "block" is used, virtual edit is already disabled,
            ;; but still need it when calling coladvance-force().
            (when (< 0 (:coladd (:w_cursor @curwin)))
                ((ร int old_ve_flags =) @ve_flags)

                (reset! ve_flags VE_ALL)
                (if (not (u-save-cursor))
                    ((ร RETURN) nil)
                )

                (swap! curwin coladvance-force (if (== (:op_type oap) OP_APPEND) (inc (:end_vcol oap)) (getviscol @curwin)))
                (when (== (:op_type oap) OP_APPEND)
                    (swap! curwin update-in [:w_cursor :col] dec))
                (reset! ve_flags old_ve_flags)
            )
            ;; Get the info about the block before entering the text.
            ((ร bd =) (block-prep oap, (:is_MAX bd), (:lnum (:op_start oap)), true))
            ((ร Bytes firstline =) (.plus (ml-get (:lnum (:op_start oap))) (:textcol bd)))
            ((ร firstline =) (if (== (:op_type oap) OP_APPEND) (.plus firstline (:textlen bd)) firstline))
            ((ร pre_textlen =) (STRLEN firstline))
        )

        (when (== (:op_type oap) OP_APPEND)
            (cond (and (:block_mode oap) (zero? (:coladd (:w_cursor @curwin))))
            (do
                ;; Move the cursor to the character right of the block.
                (swap! curwin assoc :w_set_curswant true)
                (while (and (non-eos? (ml-get-cursor @curwin)) (< (:col (:w_cursor @curwin)) (+ (:textcol bd) (:textlen bd))))
                    (swap! curwin update-in [:w_cursor :col] inc))
                (when (and (:is_short bd) (not (:is_MAX bd)))
                    ;; First line was too short, make it longer and adjust the values in "bd".
                    (if (not (u-save-cursor))
                        ((ร RETURN) nil)
                    )

                    (dotimes [_ (:endspaces bd)]
                        (swap! curwin ins-char (byte \space)))
                    ((ร bd =) (update bd :textlen + (:endspaces bd)))
                )
            )
            :else
            (do
                (swap! curwin assoc :w_cursor (:op_end oap))
                (swap! curwin check-cursor-col)

                ;; Works just like an 'i'nsert on the next character.
                (when (and (not (lineempty (:lnum (:w_cursor @curwin)))) (!= (:start_vcol oap) (:end_vcol oap)))
                    (swap! curwin inc-cursor false))
            ))
        )

        ((ร pos_C t1 =) (NEW_pos_C))
        (COPY-pos t1, (:op_start oap))

        (edit NUL, false, count1)

        ;; When a tab was inserted, and the characters in front of the tab
        ;; have been converted to a tab as well, the column of the cursor
        ;; might have actually been reduced, so need to adjust here.
        (when (and (== (:lnum t1) (:lnum (:b_op_start_orig @curbuf))) (ltpos (:b_op_start_orig @curbuf), t1))
            (COPY-pos (:op_start oap), (:b_op_start_orig @curbuf)))

        ;; If user has moved off this line, we don't know what to do, so do nothing.
        ;; Also don't repeat the insert when Insert mode ended with CTRL-C.
        (if (or (!= (:lnum (:w_cursor @curwin)) (:lnum (:op_start oap))) @got_int)
            ((ร RETURN) nil)
        )

        (when (:block_mode oap)

            ;; The user may have moved the cursor before inserting something,
            ;; try to adjust the block for that.
            (when (and (== (:lnum (:op_start oap)) (:lnum (:b_op_start_orig @curbuf))) (not (:is_MAX bd)))
                (cond (and (== (:op_type oap) OP_INSERT) (!= (+ (:col (:op_start oap)) (:coladd (:op_start oap))) (+ (:col (:b_op_start_orig @curbuf)) (:coladd (:b_op_start_orig @curbuf)))))
                (do
                    ((ร int t =) (getviscol2 @curwin, (:col (:b_op_start_orig @curbuf)), (:coladd (:b_op_start_orig @curbuf))))
                    ((ร oap =) (assoc-in oap [:op_start :col] (:col (:b_op_start_orig @curbuf))))
                    ((ร pre_textlen =) (- pre_textlen (- t (:start_vcol oap))))
                    ((ร oap =) (assoc oap :start_vcol t))
                )
                (and (== (:op_type oap) OP_APPEND) (<= (+ (:col (:b_op_start_orig @curbuf)) (:coladd (:b_op_start_orig @curbuf))) (+ (:col (:op_end oap)) (:coladd (:op_end oap)))))
                (do
                    ((ร int t =) (getviscol2 @curwin, (:col (:b_op_start_orig @curbuf)), (:coladd (:b_op_start_orig @curbuf))))
                    ((ร oap =) (assoc-in oap [:op_start :col] (:col (:b_op_start_orig @curbuf))))
                    ;; reset pre_textlen to the value of OP_INSERT
                    ((ร pre_textlen =) (+ pre_textlen (:textlen bd)))
                    ((ร pre_textlen =) (- pre_textlen (- t (:start_vcol oap))))
                    ((ร oap =) (assoc oap :start_vcol t))
                    ((ร oap =) (assoc oap :op_type OP_INSERT))
                ))
            )

            ;; Spaces and tabs in the indent may have changed to other spaces and tabs.
            ;; Get the starting column again and correct the length.
            ;; Don't do this when "$" used, end-of-line will have changed.

            ((ร block_def_C bd2 =) (block-prep oap, false, (:lnum (:op_start oap)), true))
            (when (or (not (:is_MAX bd)) (< (:textlen bd2) (:textlen bd)))
                (when (== (:op_type oap) OP_APPEND)
                    ((ร pre_textlen =) (+ pre_textlen (- (:textlen bd2) (:textlen bd))))
                    (if (non-zero? (:endspaces bd2))
                        ((ร bd2.textlen =) (dec (:textlen bd2)))
                    )
                )
                ((ร bd =) (assoc bd :textcol (:textcol bd2)))
                ((ร bd =) (assoc bd :textlen (:textlen bd2)))
            )

            ;; Subsequent calls to ml-get() flush the firstline data
            ;; - take a copy of the required string.

            ((ร Bytes firstline =) (.plus (ml-get (:lnum (:op_start oap))) (:textcol bd)))
            ((ร firstline =) (if (== (:op_type oap) OP_APPEND) (.plus firstline (:textlen bd)) firstline))

            (ร int ins_len)
            (when (and (<= 0 pre_textlen) (< 0 ((ร ins_len =) (- (STRLEN firstline) pre_textlen))))
                ((ร Bytes ins_text =) (STRNDUP firstline, ins_len))

                ;; block handled here
                (when (u-save (:lnum (:op_start oap)), (inc (:lnum (:op_end oap))))
                    (block-insert oap, ins_text, (== (:op_type oap) OP_INSERT), (:is_MAX bd)))

                (swap! curwin assoc-in [:w_cursor :col] (:col (:op_start oap)))
                (swap! curwin check-cursor)
            )
        )
        nil
    ))

;; op-change - handle a change operation
;;
;; return true if edit() returns because of a CTRL-O command

(defn- #_boolean op-change [#_oparg_C oap]
    (ยง
        ((ร int pre_textlen =) 0)
        ((ร int pre_indent =) 0)

        ((ร int l =) (:col (:op_start oap)))
        (when (== (:motion_type oap) MLINE)
            ((ร l =) 0)
            (if (and (not @p_paste) @(:b_p_si @curbuf))
                (reset! can_si true))      ;; It's like opening a new line, do si
        )

        ;; First delete the text in the region.  In an empty buffer only need to save for undo.
        (cond (flag? (:ml_flags (:b_ml @curbuf)) ML_EMPTY)
        (do
            (if (not (u-save-cursor))
                ((ร RETURN) false)
            )
        )
        (not (op-delete oap))
        (do
            ((ร RETURN) false)
        ))

        (when (and (< (:col (:w_cursor @curwin)) l) (not (lineempty (:lnum (:w_cursor @curwin)))) (== @virtual_op FALSE))
            (swap! curwin inc-cursor false))

        ((ร int textcol =) 0)
        ;; check for still on same line (<CR> in inserted text meaningless); skip blank lines too
        (when (:block_mode oap)
            ;; Add spaces before getting the current line length.
            (if (and (!= @virtual_op FALSE) (or (< 0 (:coladd (:w_cursor @curwin))) (== (gchar-cursor @curwin) NUL)))
                (swap! curwin coladvance-force (getviscol @curwin)))
            ((ร Bytes s =) (ml-get (:lnum (:op_start oap))))
            ((ร pre_textlen =) (STRLEN s))
            ((ร pre_indent =) (BDIFF (skipwhite s), s))
            ((ร textcol =) (:col (:w_cursor @curwin)))
        )

        ((ร boolean retval =) (edit NUL, false, 1))

        ;; In Visual block mode, handle copying the new text to all lines of the block.
        ;; Don't repeat the insert when Insert mode ended with CTRL-C.

        (when (and (:block_mode oap) (!= (:lnum (:op_start oap)) (:lnum (:op_end oap))) (not @got_int))
            ;; Auto-indenting may have changed the indent.  If the cursor was past
            ;; the indent, exclude that indent change from the inserted text.
            ((ร Bytes s =) (ml-get (:lnum (:op_start oap))))
            (when (< pre_indent textcol)
                ((ร int new_indent =) (BDIFF (skipwhite s), s))

                ((ร pre_textlen =) (+ pre_textlen (- new_indent pre_indent)))
                ((ร textcol =) (+ textcol (- new_indent pre_indent)))
            )

            ((ร int ins_len =) (- (STRLEN s) pre_textlen))
            (when (< 0 ins_len)
                ;; Subsequent calls to ml-get() flush the "s" data
                ;; -- take a copy of the inserted text.
                ((ร Bytes ins_text =) (STRNDUP (.plus s textcol), ins_len))

                (loop-when-recur [#_long linenr (inc (:lnum (:op_start oap)))] (<= linenr (:lnum (:op_end oap))) [(inc linenr)]
                    ((ร block_def_C bd =) (block-prep oap, false, linenr, true))
                    (when (or (not (:is_short bd)) (!= @virtual_op FALSE))
                        ((ร pos_C vpos =) (->pos_C linenr, 0, 0))

                        ;; If the block starts in virtual space, count the
                        ;; initial coladd offset as part of "startspaces".
                        (when (:is_short bd)
                            ((ร [@curwin vpos] =) (getvpos @curwin, vpos, (:start_vcol oap)))
                        )
                        ((ร Bytes oldp =) (ml-get linenr))
                        ((ร Bytes newp =) (Bytes. (+ (STRLEN oldp) (:coladd vpos) ins_len 1)))

                        ;; copy up to block start
                        (BCOPY newp, oldp, (:textcol bd))
                        ((ร int offset =) (:textcol bd))
                        (copy-chars newp, offset, (:coladd vpos), (byte \space))
                        ((ร offset =) (+ offset (:coladd vpos)))
                        (BCOPY newp, offset, ins_text, 0, ins_len)
                        ((ร offset =) (+ offset ins_len))
                        ((ร oldp =) (.plus oldp (:textcol bd)))
                        (BCOPY newp, offset, oldp, 0, (inc (STRLEN oldp)))
                        (ml-replace linenr, newp)
                    )
                )
                (swap! curwin check-cursor)

                (changed-lines (inc (:lnum (:op_start oap))), 0, (inc (:lnum (:op_end oap))), 0)
            )
        )

        retval
    ))

;; set all the yank registers to empty (called from main())

(defn- #_void init-yank []
    (ยง
        (dotimes [#_int i NUM_REGISTERS]
            ((ร y_regs[i].y_array =) nil)
        )
        nil
    ))

;; Yank the text between "oap.op_start" and "oap.op_end" into a yank register.
;; If we are to append (uppercase register), we first yank into a new yank
;; register and then concatenate the old and the new one (so we keep the old
;; one in case of out-of-memory).
;;
;; Return false for failure, true otherwise.

(defn- #_boolean op-yank [#_oparg_C oap, #_boolean deleting, #_boolean mess]
    (ยง
        ((ร byte yanktype =) (:motion_type oap))
        ((ร int yanklines =) (int (:line_count oap)))
        ((ร long yankendlnum =) (:lnum (:op_end oap)))

                                                        ;; check for read-only register
        (when (and (non-zero? (:regname oap)) (not (valid-yank-reg (:regname oap), true)))
            (beep-flush)
            ((ร RETURN) false)
        )
        (if (== (:regname oap) (byte \_))                         ;; black hole: nothing to do
            ((ร RETURN) true)
        )

        (if (any == (:regname oap) (byte \*) (byte \+))
            ((ร oap =) (assoc oap :regname 0))
        )

        (when (not deleting)                                  ;; op-delete() already set y_current
            (get-yank-register (:regname oap), true))

        ((ร yankreg_C curr =) @y_current)                     ;; copy of y_current
        ((ร yankreg_C newreg =) (NEW_yankreg_C))             ;; new yank register when appending
        (if (and @y_append (some? (:y_array @y_current)))      ;; append to existing contents
            (reset! y_current newreg)
            (swap! y_current assoc :y_array nil)                   ;; free previously yanked lines
        )

        ;; If the cursor was in column 1 before and after the movement,
        ;; and the operator is not inclusive, the yank is always linewise.

        (when (and (== (:motion_type oap) MCHAR) (zero? (:col (:op_start oap))) (not (:inclusive oap)) (or (not (:is_VIsual oap)) (at? @p_sel (byte \o))) (not (:block_mode oap)) (zero? (:col (:op_end oap))) (< 1 yanklines))
            ((ร yanktype =) MLINE)
            ((ร yankendlnum =) (dec yankendlnum))
            ((ร yanklines =) (dec yanklines))
        )

        (swap! y_current assoc :y_size yanklines)
        (swap! y_current assoc :y_type yanktype)                    ;; set the yank register type
        (swap! y_current assoc :y_width 0)
        (swap! y_current assoc :y_array (ร new Bytes[yanklines]))

        ((ร int y_idx =) 0)                                 ;; index in y_array[]
        ((ร long lnum =) (:lnum (:op_start oap)))                  ;; current line number

        (when (:block_mode oap)
            ;; Visual block mode.
            (swap! y_current assoc :y_type MBLOCK)                  ;; set the yank register type
            (swap! y_current assoc :y_width (- (:end_vcol oap) (:start_vcol oap)))

            (when (and (== (:w_curswant @curwin) MAXCOL) (< 0 (:y_width @y_current)))
                (swap! y_current update :y_width dec))
        )

        ((ร FOR) (ร nil (<= lnum yankendlnum) (ร lnum++, y_idx++))
            (condp == (:y_type @y_current)
                MBLOCK
                (do
                    ((ร block_def_C bd =) (block-prep oap, false, lnum, false))
                    (yank-copy-line bd, y_idx)
                    (ร BREAK)
                )

                MLINE
                (do
                    ((ร @y_current.y_array[y_idx] =) (STRDUP (ml-get lnum)))
                    (ร BREAK)
                )

                MCHAR
                (do
                    ((ร block_def_C bd =) (NEW_block_def_C))

                    ((ร int startcol =) (ร 0, endcol = MAXCOL))
                    ((ร boolean is_oneChar =) false)
                    ((ร Bytes p =) (ml-get lnum))

                    (when (== lnum (:lnum (:op_start oap)))
                        ((ร startcol =) (:col (:op_start oap)))
                        (when (!= @virtual_op FALSE)
                            ((ร int[] a'cs =) (atom (int)))
                            ((ร int[] a'ce =) (atom (int)))
                            (getvcol @curwin, (:op_start oap), a'cs, nil, a'ce)
                            (when (and (!= @a'ce @a'cs) (< 0 (:coladd (:op_start oap))))
                                ;; Part of a tab selected -- but don't double-count it.
                                ((ร bd =) (assoc bd :startspaces (- (inc (- @a'ce @a'cs)) (:coladd (:op_start oap)))))
                                ((ร startcol =) (inc startcol))
                            )
                        )
                    )

                    (when (== lnum (:lnum (:op_end oap)))
                        ((ร endcol =) (:col (:op_end oap)))
                        (when (!= @virtual_op FALSE)
                            ((ร int[] a'cs =) (atom (int)))
                            ((ร int[] a'ce =) (atom (int)))
                            (getvcol @curwin, (:op_end oap), a'cs, nil, a'ce)
                            ;; Don't add space for double-wide char; endcol will be on last byte of multi-byte char.
                            (when (or (eos? p endcol) (and (< (+ @a'cs (:coladd (:op_end oap))) @a'ce) (zero? (us-head-off p, (.plus p endcol)))))
                                (cond (and (== (:lnum (:op_start oap)) (:lnum (:op_end oap))) (== (:col (:op_start oap)) (:col (:op_end oap))))
                                (do
                                    ;; Special case: inside a single char.
                                    ((ร is_oneChar =) true)
                                    ((ร bd =) (assoc bd :startspaces (+ (- (:coladd (:op_end oap)) (:coladd (:op_start oap))) (if (:inclusive oap) 1 0))))
                                    ((ร endcol =) startcol)
                                )
                                :else
                                (do
                                    ((ร bd =) (assoc bd :endspaces (+ (:coladd (:op_end oap)) (if (:inclusive oap) 1 0))))
                                    ((ร endcol =) (- endcol (if (:inclusive oap) 1 0)))
                                ))
                            )
                        )
                    )
                    ((ร endcol =) (if (== endcol MAXCOL) (STRLEN p) endcol))
                    ((ร bd =) (assoc bd :textlen (if (or (< endcol startcol) is_oneChar) 0 (+ (- endcol startcol) (if (:inclusive oap) 1 0)))))
                    ((ร bd =) (assoc bd :textstart (.plus p startcol)))
                    (yank-copy-line bd, y_idx)
                    (ร BREAK)
                )
            )
        )

        (when (!= curr @y_current)      ;; append the new block to the old block
            ((ร Bytes[] new_ptr =) (ร new Bytes[curr.y_size + @y_current.y_size]))

            ((ร int j =) (loop-when-recur [j 0] (< j (:y_size curr)) [(inc j)] => j
                ((ร new_ptr[j] =) (... (:y_array curr) j))
            ))
            ((ร curr =) (assoc curr :y_array new_ptr))

            (if (== yanktype MLINE)  ;; MLINE overrides MCHAR and MBLOCK
                ((ร curr =) (assoc curr :y_type MLINE))
            )

            ;; Concatenate the last line of the old block with the first line of the new block,
            ;; unless being Vi compatible.
            (cond (and (== (:y_type curr) MCHAR) (nil? (vim-strbyte @p_cpo, CPO_REGAPPEND)))
            (do
                ((ร Bytes p =) (Bytes. (+ (STRLEN (... (:y_array curr) (dec (:y_size curr)))) (STRLEN (... (:y_array @y_current) 0)) 1)))

                (STRCPY p, (... (:y_array curr) ((ร j =) (dec j))))
                (STRCAT p, (... (:y_array @y_current) 0))
                ((ร @y_current.y_array[0] =) nil)
                ((ร curr.y_array[j++] =) p)
                ((ร y_idx =) 1)
            )
            :else
            (do
                ((ร y_idx =) 0)
            ))
            (loop-when [] (< y_idx (:y_size @y_current))
                ((ร curr.y_array[j++] =) (... (:y_array @y_current) (ร y_idx++)))
                (recur)
            )
            ((ร curr =) (assoc curr :y_size j))
            (swap! y_current assoc :y_array nil)
            (reset! y_current curr)
        )

        (when @(:wo_rnu (:w_options @curwin))
            (swap! curwin redraw-later SOME_VALID))       ;; cursor moved to start

        (when mess                   ;; Display message about yank?
            ((ร yanklines =) (if (and (== yanktype MCHAR) (not (:block_mode oap)) (== yanklines 1)) 0 yanklines))
            ;; Some versions of Vi use ">=" here, some don't...
            (when (< @p_report yanklines)
                ;; redisplay now, so message is not deleted
                (swap! curwin update-topline-redraw)
                (if (== yanklines 1)
                    (msg (if (:block_mode oap) (u8 "block of 1 line yanked") (u8 "1 line yanked")))
                    (smsg (if (:block_mode oap) (u8 "block of %ld lines yanked") (u8 "%ld lines yanked")), yanklines)
                )
            )
        )

        ;; Set "'[" and "']" marks.

        (swap! curbuf assoc :b_op_start (:op_start oap))
        (swap! curbuf assoc :b_op_end (:op_end oap))
        (when (and (== yanktype MLINE) (not (:block_mode oap)))
            (swap! curbuf assoc-in [:b_op_start :col] 0)
            (swap! curbuf assoc-in [:b_op_end :col] MAXCOL)
        )

        true
    ))

(defn- #_void yank-copy-line [#_block_def_C bd, #_int y_idx]
    (ยง
        ((ร Bytes pnew =) (Bytes. (+ (:startspaces bd) (:endspaces bd) (:textlen bd) 1)))

        ((ร @y_current.y_array[y_idx] =) pnew)
        (copy-chars pnew, 0, (:startspaces bd), (byte \space))
        ((ร pnew =) (.plus pnew (:startspaces bd)))
        (BCOPY pnew, (:textstart bd), (:textlen bd))
        ((ร pnew =) (.plus pnew (:textlen bd)))
        (copy-chars pnew, 0, (:endspaces bd), (byte \space))
        ((ร pnew =) (.plus pnew (:endspaces bd)))
        (eos! pnew)
        nil
    ))

;; Put contents of register "regname" into the text.
;; Caller must check "regname" to be valid!
;; "flags": PUT_FIXINDENT   make indent look nice
;;          PUT_CURSEND     leave cursor after end of new text
;;          PUT_LINE        force linewise put (":put")

(defn- #_void do-put [#_int regname, #_int dir, #_int count, #_int flags]
    ;; dir: BACKWARD for 'P', FORWARD for 'p'
    (ยง
        ((ร int y_width =) 0)
        ((ร int incr =) 0)
        ((ร long nr_lines =) 0)
        ((ร int orig_indent =) 0)
        ((ร int indent_diff =) 0)
        ((ร boolean first_indent =) true)
        ((ร int lendiff =) 0)

        ;; Adjust register name for "unnamed" in 'clipboard'.
        ((ร regname =) (adjust-clip-reg regname))
        (may-get-selection regname)

        ((ร orig_indent =) (if (flag? flags PUT_FIXINDENT) (get-indent @curwin) orig_indent))

        (swap! curbuf assoc :b_op_start (:w_cursor @curwin))   ;; default for '[ mark
        (swap! curbuf assoc :b_op_end (:w_cursor @curwin))     ;; default for '] mark

        ;; Using inserted text works differently, because the register includes special characters (newlines, etc.).

        (when (== regname (byte \.))
            (stuff-inserted (if (== dir FORWARD) (if (== count -1) (byte \o) (byte \a)) (if (== count -1) (byte \O) (byte \i))), count, false)
            ;; Putting the text is done later, so can't really move the cursor to the next character.
            ;; Use "l" to simulate it.
            (if (and (flag? flags PUT_CURSEND) (!= (gchar-cursor @curwin) NUL))
                (stuff-char (byte \l)))
            ((ร RETURN) nil)
        )

        ;; For special registers '%' (file name), '#' (alternate file name) and
        ;; ':' (last command line), etc. we have to create a fake yank register.

        ((ร Bytes[] a'insert_string =) (atom (#_Bytes object nil)))
        (when (get-spec-reg regname, a'insert_string, true)
            (if (nil? @a'insert_string)
                ((ร RETURN) nil)
            )
        )

        ;; Autocommands may be executed when saving lines for undo,
        ;; which may make "y_array" invalid.  Start undo now to avoid that.
        (u-save (:lnum (:w_cursor @curwin)), (inc (:lnum (:w_cursor @curwin))))

        (ร int y_type)
        (ร int y_size)
        ((ร Bytes[] y_array =) nil)

        (cond (some? @a'insert_string)
        (do
            ((ร y_type =) MCHAR)
            (cond (== regname (byte \=))
            (do
                ;; For the = register we need to split the string at NL characters.
                ;; Loop twice: count the number of lines and save them.
                (loop []
                    ((ร y_size =) 0)
                    (loop-when [#_Bytes p @a'insert_string] (some? p)
                        (if (some? y_array)
                            ((ร y_array[y_size] =) p)
                        )
                        ((ร y_size =) (inc y_size))
                        ((ร p =) (vim-strchr p, (byte \newline)))
                        (when (some? p)
                            (when (some? y_array)
                                (eos! p))
                            ((ร p =) (.plus p 1))
                            ;; A trailing '\n' makes the register linewise.
                            (when (eos? p)
                                ((ร y_type =) MLINE)
                                (ร BREAK)
                            )
                        )
                        (recur p)
                    )
                    (if (some? y_array)
                        (ร BREAK)
                    )
                    ((ร y_array =) (ร new Bytes[y_size]))
                    (recur)
                )
            )
            :else
            (do
                ((ร y_size =) 1)         ;; use fake one-line yank register
; %%            ((ร y_array =) (ร new Bytes[] { insert_string[0] }))
            ))
        )
        :else
        (do
            (get-yank-register regname, false)

            ((ร y_type =) (:y_type @y_current))
            ((ร y_width =) (:y_width @y_current))
            ((ร y_size =) (:y_size @y_current))
            ((ร y_array =) (:y_array @y_current))
        ))

;       theend:
;       {
            (when (== y_type MLINE)
                (when (flag? flags PUT_LINE_SPLIT)
                    ;; "p" or "P" in Visual mode: split the lines to put the text in between.
                    (if (not (u-save-cursor))
                        (ร BREAK theend)
                    )

                    ((ร Bytes p =) (STRDUP (ml-get-cursor @curwin)))
                    (ml-append (:lnum (:w_cursor @curwin)), p)
                    ((ร p =) (STRNDUP (ml-get (:lnum (:w_cursor @curwin))), (:col (:w_cursor @curwin))))
                    (ml-replace (:lnum (:w_cursor @curwin)), p)
                    ((ร nr_lines =) (inc nr_lines))
                    ((ร dir =) FORWARD)
                )
                (when (flag? flags PUT_LINE_FORWARD)
                    ;; Must be "p" for a Visual block, put lines below the block.
                    (swap! curwin assoc :w_cursor (:vi_end (:b_visual @curbuf)))
                    ((ร dir =) FORWARD)
                )
                (swap! curbuf assoc :b_op_start (:w_cursor @curwin))   ;; default for '[ mark
                (swap! curbuf assoc :b_op_end (:w_cursor @curwin))     ;; default for '] mark
            )

            ((ร y_type =) (if (flag? flags PUT_LINE) MLINE y_type))        ;; :put command or "p" in Visual line mode.

            (when (or (zero? y_size) (nil? y_array))
                (emsg2 (u8 "E353: Nothing in register %s"), (if (zero? regname) (u8 "\"") (transchar regname)))
                (ร BREAK theend)
            )

            (ร long lnum)
            (cond (== y_type MBLOCK)
            (do
                ((ร lnum =) (min (+ (:lnum (:w_cursor @curwin)) y_size 1) (inc (line-count @curbuf))))
                (if (not (u-save (dec (:lnum (:w_cursor @curwin))), lnum))
                    (ร BREAK theend)
                )
            )
            (== y_type MLINE)
            (do
                ((ร lnum =) (:lnum (:w_cursor @curwin)))
                ((ร lnum =) (if (== dir FORWARD) (inc lnum) lnum))
                ;; In an empty buffer the empty line is going to be replaced, include it in the saved lines.
                (if (not (if (bufempty) (u-save 0, 2) (u-save (dec lnum), lnum)))
                    (ร BREAK theend)
                )
            )
            (not (u-save-cursor))
            (do
                (ร BREAK theend)
            ))

            ((ร int yanklen =) (STRLEN (... y_array 0)))

            (when (and (== @ve_flags VE_ALL) (== y_type MCHAR))
                (cond (== (gchar-cursor @curwin) TAB)
                (do
                    ;; Don't need to insert spaces when "p" on the last position of a tab or "P" on the first position.
                    (cond (if (== dir FORWARD) (< (:coladd (:w_cursor @curwin)) (dec @(:b_p_ts @curbuf))) (< 0 (:coladd (:w_cursor @curwin))))
                    (do
                        (swap! curwin coladvance-force (getviscol @curwin))
                    )
                    :else
                    (do
                        (swap! curwin assoc-in [:w_cursor :coladd] 0)
                    ))
                )
                (or (< 0 (:coladd (:w_cursor @curwin))) (== (gchar-cursor @curwin) NUL))
                (do
                    (swap! curwin coladvance-force (+ (getviscol @curwin) (if (== dir FORWARD) 1 0)))
                ))
            )

            ((ร lnum =) (:lnum (:w_cursor @curwin)))
            ((ร int[] a'col =) (atom (int (:col (:w_cursor @curwin)))))

            ;; Block mode

            (cond (== y_type MBLOCK)
            (do
                ((ร block_def_C bd =) (NEW_block_def_C))
                ((ร int c =) (gchar-cursor @curwin))
                ((ร int[] a'endcol2 =) (atom (int 0)))

                (cond (and (== dir FORWARD) (!= c NUL))
                (do
                    (if (== @ve_flags VE_ALL)
                        (getvcol @curwin, (:w_cursor @curwin), a'col, nil, a'endcol2)
                        (getvcol @curwin, (:w_cursor @curwin), nil, nil, a'col))

                    ;; move to start of next multi-byte character
                    (swap! curwin update-in [:w_cursor :col] + (us-ptr2len-cc (ml-get-cursor @curwin)))

                    (swap! a'col inc)
                )
                :else
                (do
                    (getvcol @curwin, (:w_cursor @curwin), a'col, nil, a'endcol2)
                ))

                (swap! a'col + (:coladd (:w_cursor @curwin)))
                (when (and (== @ve_flags VE_ALL) (or (< 0 (:coladd (:w_cursor @curwin))) (== @a'endcol2 (:col (:w_cursor @curwin)))))
                    (when (and (== dir FORWARD) (== c NUL))
                        (swap! a'col inc))
                    (when (and (!= dir FORWARD) (!= c NUL))
                        (swap! curwin update-in [:w_cursor :col] inc))
                    (when (== c TAB)
                        (when (and (== dir BACKWARD) (< 0 (:col (:w_cursor @curwin))))
                            (swap! curwin update-in [:w_cursor :col] dec))
                        (when (and (== dir FORWARD) (== (- @a'col 1) @a'endcol2))
                            (swap! curwin update-in [:w_cursor :col] inc))
                    )
                )
                (swap! curwin assoc-in [:w_cursor :coladd] 0)
                ((ร bd =) (assoc bd :textcol 0))
                ((ร int totlen =) 0)
                (loop-when-recur [#_int i 0] [< i y_size] [(inc i)]
                    ((ร bd =) (assoc bd :startspaces 0))
                    ((ร bd =) (assoc bd :endspaces 0))
                    ((ร int vcol =) 0)
                    ((ร int delcount =) 0)

                    ;; add a new line
                    (when (< (line-count @curbuf) (:lnum (:w_cursor @curwin)))
                        (if (not (ml-append (line-count @curbuf), (u8 "")))
                            (ร BREAK)
                        )
                        ((ร nr_lines =) (inc nr_lines))
                    )
                    ;; get the old line and advance to the position to insert at
                    ((ร Bytes oldp =) (ml-get (:lnum (:w_cursor @curwin))))
                    ((ร int oldlen =) (STRLEN oldp))
                    ((ร Bytes[] a'pp =) (atom (#_Bytes object oldp)))
                    (loop-when [] (and (< vcol @a'col) (non-eos? @a'pp))
                        ;; Count a tab for what it's worth (if list mode not on).
                        ((ร incr =) (lbr-chartabsize-adv oldp, a'pp, vcol))
                        ((ร vcol =) (+ vcol incr))
                        (recur)
                    )
                    ((ร bd =) (assoc bd :textcol (BDIFF @a'pp, oldp)))

                    ((ร boolean shortline =) (or (< vcol @a'col) (and (== vcol @a'col) (eos? @a'pp))))

                    (cond (< vcol @a'col) ;; line too short, padd with spaces
                    (do
                        ((ร bd =) (assoc bd :startspaces (- @a'col vcol)))
                    )
                    (< @a'col vcol)
                    (do
                        ((ร bd =) (assoc bd :endspaces (- vcol @a'col)))
                        ((ร bd =) (assoc bd :startspaces (- incr (:endspaces bd))))
                        ((ร bd =) (update bd :textcol dec))
                        ((ร delcount =) 1)
                        ((ร bd =) (update bd :textcol #(- % (us-head-off oldp, (.plus oldp %)))))
                        (when (not-at? oldp (:textcol bd) TAB)
                            ;; Only a Tab can be split into spaces.
                            ;; Other characters will have to be moved to after the block,
                            ;; causing misalignment.
                            ((ร delcount =) 0)
                            ((ร bd =) (assoc bd :endspaces 0))
                        )
                    ))

                    ((ร yanklen =) (STRLEN (... y_array i)))

                    ;; calculate number of spaces required to fill right side of block
                    ((ร int spaces =) (inc y_width))
                    (dotimes [#_int j yanklen]
                        ((ร spaces =) (- spaces (lbr-chartabsize nil, (.plus (... y_array i) j), 0)))
                    )
                    ((ร spaces =) (max 0 spaces))

                    ;; insert the new text
                    ((ร totlen =) (+ (* count (+ yanklen spaces)) (:startspaces bd) (:endspaces bd)))
                    ((ร Bytes newp =) (Bytes. (+ totlen oldlen 1)))

                    ;; copy part up to cursor to new line
                    ((ร Bytes p =) newp)
                    (BCOPY p, oldp, (:textcol bd))
                    ((ร p =) (.plus p (:textcol bd)))
                    ;; may insert some spaces before the new text
                    (copy-chars p, 0, (:startspaces bd), (byte \space))
                    ((ร p =) (.plus p (:startspaces bd)))
                    ;; insert the new text
                    (dotimes [#_int j count]
                        (BCOPY p, (... y_array i), yanklen)
                        ((ร p =) (.plus p yanklen))

                        ;; insert block's trailing spaces only if there's text behind
                        (when (and (or (< j (dec count)) (not shortline)) (non-zero? spaces))
                            (copy-chars p, 0, spaces, (byte \space))
                            ((ร p =) (.plus p spaces))
                        )
                    )
                    ;; may insert some spaces after the new text
                    (copy-chars p, 0, (:endspaces bd), (byte \space))
                    ((ร p =) (.plus p (:endspaces bd)))
                    ;; move the text after the cursor to the end of the line.
                    (BCOPY p, 0, oldp, (+ (:textcol bd) delcount), (inc (- oldlen (:textcol bd) delcount)))
                    (ml-replace (:lnum (:w_cursor @curwin)), newp)

                    (swap! curwin update-in [:w_cursor :lnum] inc)
                    (when (zero? i)
                        (swap! curwin update-in [:w_cursor :col] + (:startspaces bd)))
                )

                (changed-lines lnum, 0, (:lnum (:w_cursor @curwin)), nr_lines)

                ;; Set '[ mark.
                (swap! curbuf assoc :b_op_start (:w_cursor @curwin))
                (swap! curbuf assoc-in [:b_op_start :lnum] lnum)

                ;; Adjust '] mark.
                (swap! curbuf assoc-in [:b_op_end :lnum] (dec (:lnum (:w_cursor @curwin))))
                (swap! curbuf assoc-in [:b_op_end :col] (dec (+ (:textcol bd) totlen)))
                (swap! curbuf assoc-in [:b_op_end :coladd] 0)
                (cond (flag? flags PUT_CURSEND)
                (do
                    (swap! curwin assoc :w_cursor (:b_op_end @curbuf))
                    (swap! curwin update-in [:w_cursor :col] inc)
                    ;; in Insert mode we might be after the NUL, correct for that
                    (swap! curwin update-in [:w_cursor :col] min (STRLEN (ml-get (:lnum (:w_cursor @curwin)))))
                )
                :else
                (do
                    (swap! curwin assoc-in [:w_cursor :lnum] lnum)
                ))
            )
            :else
            (do
                ;; Character or Line mode

                (cond (== y_type MCHAR)
                (do
                    ;; if type is MCHAR, FORWARD is the same as BACKWARD on the next char
                    (when (and (== dir FORWARD) (!= (gchar-cursor @curwin) NUL))
                        ((ร int bytelen =) (us-ptr2len-cc (ml-get-cursor @curwin)))

                        ;; put it on the next of the multi-byte character.
                        (swap! a'col + bytelen)
                        (when (non-zero? yanklen)
                            (swap! curwin update-in [:w_cursor :col] + bytelen)
                            (swap! curbuf update-in [:b_op_end :col] + bytelen)
                        )
                    )
                    (swap! curbuf assoc :b_op_start (:w_cursor @curwin))
                )

                ;; Line mode: BACKWARD is the same as FORWARD on the previous line

                (== dir BACKWARD)
                (do
                    ((ร lnum =) (dec lnum))
                ))

                ((ร pos_C new_cursor =) (:w_cursor @curwin))

                ;; simple case: insert into current line

                (cond (and (== y_type MCHAR) (== y_size 1))
                (do
                    ((ร int totlen =) 0)
                    ((ร lnum =) (loop [lnum lnum]
                        ((ร totlen =) (* count yanklen))
                        (when (< 0 totlen)
                            ((ร Bytes oldp =) (ml-get lnum))
                            ((ร Bytes newp =) (Bytes. (+ (STRLEN oldp) totlen 1)))

                            (BCOPY newp, oldp, @a'col)
                            ((ร Bytes p =) (.plus newp @a'col))
                            (dotimes [_ count]
                                (BCOPY p, (... y_array 0), yanklen)
                                ((ร p =) (.plus p yanklen))
                            )
                            (BCOPY p, 0, oldp, @a'col, (inc (STRLEN oldp, @a'col)))
                            (ml-replace lnum, newp)
                            ;; Place cursor on last putted char.
                            (when (== lnum (:lnum (:w_cursor @curwin)))
                                ;; make sure curwin.w_virtcol is updated
                                (swap! curwin changed-cline-bef-curs)
                                (swap! curwin update-in [:w_cursor :col] + (dec totlen))
                            )
                        )
                        ((ร lnum =) (if @VIsual_active (inc lnum) lnum))
                        (recur-if (and @VIsual_active (<= lnum (:lnum (:vi_end (:b_visual @curbuf))))) [lnum] => lnum)
                    ))

                    ((ร lnum =) (if @VIsual_active (dec lnum) lnum)) ;; reset lnum to the last visual line

                    (swap! curbuf assoc :b_op_end (:w_cursor @curwin))
                    ;; For "CTRL-O p" in Insert mode, put cursor after last char.
                    (when (and (non-zero? totlen) (or (non-zero? @restart_edit) (flag? flags PUT_CURSEND)))
                        (swap! curwin update-in [:w_cursor :col] inc))
                    (changed-bytes lnum, @a'col)
                )
                :else
                (do
                    ;; Insert at least one line.  When y_type is MCHAR, break the first line in two.

;                   error:
                    (loop-when-recur [#_long cnt 1] (<= cnt count) [(inc cnt)]
                        ((ร int i =) 0)
                        (when (== y_type MCHAR)
                            ;; Split the current line in two at the insert position.
                            ;; First insert y_array[size - 1] in front of second line.
                            ;; Then append y_array[0] to first line.

                            ((ร lnum =) (:lnum new_cursor))
                            ((ร Bytes p =) (.plus (ml-get lnum) @a'col))
                            ((ร int totlen =) (STRLEN (... y_array (dec y_size))))
                            ((ร Bytes newp =) (Bytes. (+ (STRLEN p) totlen 1)))
                            (STRCPY newp, (... y_array (dec y_size)))
                            (STRCAT newp, p)
                            ;; insert second line
                            (ml-append lnum, newp)

                            ((ร Bytes oldp =) (ml-get lnum))
                            ((ร newp =) (Bytes. (+ @a'col yanklen 1)))
                            ;; copy first part of line
                            (BCOPY newp, oldp, @a'col)
                            ;; append to first line
                            (BCOPY newp, @a'col, (... y_array 0), 0, (inc yanklen))
                            (ml-replace lnum, newp)

                            (swap! curwin assoc-in [:w_cursor :lnum] lnum)
                            ((ร i =) 1)
                        )

                        (loop-when-recur i (< i y_size) (inc i)
                            (if (and (or (!= y_type MCHAR) (< i (dec y_size))) (not (ml-append lnum, (... y_array i))))
                                (ร BREAK error)
                            )
                            ((ร lnum =) (inc lnum))
                            ((ร nr_lines =) (inc nr_lines))
                            (when (flag? flags PUT_FIXINDENT)
                                ((ร pos_C old_pos =) (NEW_pos_C))
                                (COPY-pos old_pos, (:w_cursor @curwin))
                                (swap! curwin assoc-in [:w_cursor :lnum] lnum)
                                ((ร Bytes p =) (ml-get lnum))
                                ((ร lendiff =) (if (and (== cnt count) (== i (dec y_size))) (STRLEN p) lendiff))
                                (ร int indent)
                                (cond (eos? p)
                                (do
                                    ((ร indent =) 0)     ;; ignore empty lines
                                )
                                first_indent
                                (do
                                    ((ร indent_diff =) (- orig_indent (get-indent @curwin)))
                                    ((ร indent =) orig_indent)
                                    ((ร first_indent =) false)
                                )
                                (< ((ร indent =) (+ (get-indent @curwin) indent_diff)) 0)
                                (do
                                    ((ร indent =) 0)
                                ))
                                (swap! curwin set-indent indent, 0)
                                (swap! curwin assoc :w_cursor old_pos)
                                ;; remember how many chars were removed
                                ((ร lendiff =) (if (and (== cnt count) (== i (dec y_size))) (- lendiff (STRLEN (ml-get lnum))) lendiff))
                            )
                        )
                    )

                    ;; Adjust marks.
                    (when (== y_type MLINE)
                        (swap! curbuf assoc-in [:b_op_start :col] 0)
                        (when (== dir FORWARD)
                            (swap! curbuf update-in [:b_op_start :lnum] inc))
                    )
                    (mark-adjust (+ (:lnum (:b_op_start @curbuf)) (if (== y_type MCHAR) 1 0)), MAXLNUM, nr_lines, 0)

                    ;; note changed text for displaying and folding
                    (if (== y_type MCHAR)
                        (changed-lines (:lnum (:w_cursor @curwin)), @a'col, (inc (:lnum (:w_cursor @curwin))), nr_lines)
                        (changed-lines (:lnum (:b_op_start @curbuf)), 0, (:lnum (:b_op_start @curbuf)), nr_lines))

                    ;; put '] mark at last inserted character
                    (swap! curbuf assoc-in [:b_op_end :lnum] lnum)
                    ;; correct length for change in indent
                    (reset! a'col (- (STRLEN (... y_array (dec y_size))) lendiff))
                    (swap! curbuf assoc-in [:b_op_end :col] (if (< 1 @a'col) (dec @a'col) 0))

                    (cond (flag? flags PUT_CURSLINE)
                    (do
                        ;; ":put": put cursor on last inserted line
                        (swap! curwin assoc-in [:w_cursor :lnum] lnum)
                        (swap! curwin beginline (| BL_WHITE BL_FIX))
                    )
                    (flag? flags PUT_CURSEND)
                    (do
                        ;; put cursor after inserted text
                        (cond (== y_type MLINE)
                        (do
                            (swap! curwin assoc-in [:w_cursor :lnum] (min (inc lnum) (line-count @curbuf)))
                            (swap! curwin assoc-in [:w_cursor :col] 0)
                        )
                        :else
                        (do
                            (swap! curwin assoc-in [:w_cursor :lnum] lnum)
                            (swap! curwin assoc-in [:w_cursor :col] @a'col)
                        ))
                    )
                    (== y_type MLINE)
                    (do
                        ;; put cursor on first non-blank in first inserted line
                        (swap! curwin assoc-in [:w_cursor :col] 0)
                        (when (== dir FORWARD)
                            (swap! curwin update-in [:w_cursor :lnum] inc))
                        (swap! curwin beginline (| BL_WHITE BL_FIX))
                    )
                    :else        ;; put cursor on first inserted character
                    (do
                        (swap! curwin assoc :w_cursor new_cursor)
                    ))
                ))
            ))

            (msgmore nr_lines)
            (swap! curwin assoc :w_set_curswant true)
;       }

        (reset! VIsual_active false)

        ;; If the cursor is past the end of the line put it at the end.
        (swap! curwin adjust-cursor-eol)
        nil
    ))

;; When the cursor is on the NUL past the end of the line and it should not be there, move it left.

(defn- #_window_C adjust-cursor-eol [#_window_C win]
    (if (and (< 0 (:col (:w_cursor win))) (== (gchar-cursor win) NUL) (non-flag? @ve_flags VE_ONEMORE) (zero? @restart_edit) (non-flag? @State INSERT))
        ;; Put the cursor on the last character in the line.
        (let [win (dec-cursor win, false)]
            (if (== @ve_flags VE_ALL)
                ;; Coladd is set to the width of the last character.
                (let [a'scol (atom (int)) a'ecol (atom (int)) _ (getvcol win, (:w_cursor win), a'scol, nil, a'ecol)]
                    (assoc-in win [:w_cursor :coladd] (inc (- @a'ecol @a'scol))))
                win
            ))
        win
    ))

;; Join "count" lines (minimal 2) at cursor position.
;; When "save_undo" is true, save lines for undo first.
;; When "setmark" is true, sets the '[ and '] marks, else the caller is expected to set those marks.
;;
;; Return false for failure, true otherwise.

(defn- #_[window_C boolean] do-join? [#_window_C win, #_int count, #_boolean insert_space, #_boolean save_undo, #_boolean setmark]
    (let-when [lnum (:lnum (:w_cursor win))] (or (not save_undo) (u-save (dec lnum), (+ lnum count))) => [win false]
        ;; Allocate an array to store the number of spaces inserted before each line.
        ;; We will use it to pre-compute the length of the new line and the
        ;; proper placement of each original line in the new one.
        (let-when [#_int* spaces (int-array count)
            ;; Don't move anything, just compute the final line length and set the array of space lengths up.
            [#_Bytes s0 #_Bytes s #_int n #_int m :as _]
                (loop-when [s0 nil s nil n 0 m 0 #_int e1 NUL #_int e2 NUL #_int i 0] (< i count) => [s0 s n m]
                    (let [s0 (ml-get (+ lnum i)) s s0]
                        (when (and (zero? i) setmark) ;; Set the '[ mark.
                            (swap! curbuf update :b_op_start assoc :lnum lnum :col (STRLEN s)))
                        (let [s (if (and insert_space (pos? i))
                                    (let [s (skipwhite s)]
                                        (when (and (not-at? s (byte \))) (non-zero? n) (!= e1 TAB))
                                            ;; don't add a space if the line is ending in a space
                                            (let [e1 (if (== e1 (byte \space)) e2 (do (aset spaces i (inc (aget spaces i))) e1))]
                                                ;; extra space when 'joinspaces' set and line ends in '.'
                                                (when (and @p_js (or (== e1 (byte \.)) (and (any == e1 (byte \?) (byte \!)) (nil? (vim-strbyte @p_cpo, CPO_JOINSP)))))
                                                    (aset spaces i (inc (aget spaces i))))
                                            ))
                                        s)
                                    s)
                              n (STRLEN s) m (+ m n (aget spaces i))
                              [e1 e2]
                                (if (and insert_space (pos? n))
                                    (let [#_Bytes q (.plus s n) q (.minus q (us-ptr-back s, q))]
                                        [(us-ptr2char q) (if (BLT s, q) (us-ptr2char (.minus q (us-ptr-back s, q))) NUL)])
                                    [NUL NUL]
                                )]
                            (if (slow-breakcheck) nil (recur s0 s n m e1 e2 (inc i)))
                        ))
                )] (some? _) => [win false]

            (let [#_int col (- m n (aget spaces (dec count))) ;; column position before last line
                  #_Bytes line (Bytes. (inc m))
                  ;; Move affected lines to the new long one.
                  ;; Also move marks from each deleted line to the joined line, adjusting the column.
                  ;; This is not Vi compatible, but since Vi deletes the marks, it should not be a problem.
                  n (loop [s0 s0 s s n n #_Bytes q (eos! (.plus line m)) #_int i (dec count)]
                        (let [t (aget spaces i)
                              q (.minus q n)
                              _ (BCOPY q, s, n)
                              q (if (pos? t) (let [q (.minus q t)] (copy-chars q, 0, t, (byte \space)) q) q)]
                            (mark-col-adjust (+ lnum i), 0, (- i), (- (+ (BDIFF q, line) t) (BDIFF s, s0)))
                            (if (zero? i)
                                n
                                (let [s0 (ml-get (+ lnum (dec i))) s (if (and insert_space (< 1 i)) (skipwhite s0) s0) n (STRLEN s)]
                                    (recur s0 s n q (dec i)))
                            ))
                    )]
                (ml-replace lnum, line)
                (when setmark ;; Set the '] mark.
                    (swap! curbuf update :b_op_end assoc :lnum lnum :col (STRLEN line)))
                ;; Only report the change in the first line here, del-lines() will report the deleted lines.
                (changed-lines lnum, n, (inc lnum), 0)
                ;; Delete following lines.  To do this we move the cursor there briefly, and then move it back.
                ;; After del-lines() the cursor may have moved up (last line deleted), so the current lnum is kept.
                [(-> win
                    (update-in [:w_cursor :lnum] inc)
                    (del-lines (dec count), false)
                    (assoc-in [:w_cursor :lnum] lnum)
                    ;; Set the cursor column:
                    ;; Vi compatible: use the column of the first join
                    ;; Vim:           use the column of the last join
                    (assoc-in [:w_cursor :col] (if (some? (vim-strbyte @p_cpo, CPO_JOINCOL)) n col))
                    (check-cursor-col)
                    (assoc-in [:w_cursor :coladd] 0)
                    (assoc :w_set_curswant true))
                true]
            ))
    ))

(defn- #_window_C do-join [#_window_C win, #_int count, #_boolean insert_space, #_boolean save_undo, #_boolean setmark]
    (let [[win _] (do-join? win, count, insert_space, save_undo, setmark)]
        win
    ))

;; prepare a few things for block mode yank/delete/tilde
;;
;; for delete:
;; - textlen includes the first/last char to be (partly) deleted
;; - start/endspaces is the number of columns that are taken by the
;;   first/last deleted char minus the number of columns that have to be deleted.
;;
;; for yank and tilde:
;; - textlen includes the first/last char to be wholly yanked
;; - start/endspaces is the number of columns of the first/last yanked char
;;   that are to be yanked.

(defn- #_block_def_C block-prep [#_oparg_C oap, #_boolean is_MAX, #_long lnum, #_boolean is_del]
    (let [#_block_def_C bd (assoc (NEW_block_def_C) :is_MAX is_MAX)
          #_Bytes line (ml-get lnum)
          [#_int t bd #_Bytes p #_Bytes s]
            (loop-when [t 0 bd bd p line s line] (and (< (:start_vcol bd) (:start_vcol oap)) (non-eos? s)) => [t bd p s]
                ;; Count a tab for what it's worth (if list mode not on).
                (let [t (lbr-chartabsize line, s, (:start_vcol bd))
                      bd (update bd :start_vcol + t)
                      bd (if (vim-iswhite (.at s 0))
                            (-> bd (update :pre_whitesp + t) (update :pre_whitesp_c inc))
                            (assoc bd :pre_whitesp 0 :pre_whitesp_c 0)
                        )]
                    (recur t bd s (.plus s (us-ptr2len-cc s)))
                ))
          bd (assoc bd :start_char_vcols t)
          [bd s]
            (cond (< (:start_vcol bd) (:start_vcol oap))        ;; line too short
                (let [bd (assoc bd :end_vcol (:start_vcol bd) :is_short true)
                      bd (if (or (not is_del) (== (:op_type oap) OP_APPEND)) (assoc bd :endspaces (inc (- (:end_vcol oap) (:start_vcol oap)))) bd)]
                    [bd s])
            :else ;; notice: this converts partly selected multibyte characters to spaces, too
                (let [bd (assoc bd :startspaces (- (:start_vcol bd) (:start_vcol oap)))
                      bd (if (and is_del (non-zero? (:startspaces bd))) (assoc bd :startspaces (- (:start_char_vcols bd) (:startspaces bd))) bd)
                      a'pend (atom (#_Bytes object s))
                      bd (assoc bd :end_vcol (:start_vcol bd))
                      [bd t]
                        (cond (< (:end_vcol oap) (:end_vcol bd))        ;; it's all in one character
                            [(let [bd (assoc bd :is_oneChar true)] (cond
                                (== (:op_type oap) OP_INSERT)
                                    (assoc bd :endspaces (- (:start_char_vcols bd) (:startspaces bd)))
                                (== (:op_type oap) OP_APPEND)
                                    (let [bd (update bd :startspaces + (inc (- (:end_vcol oap) (:start_vcol oap))))]
                                        (assoc bd :endspaces (- (:start_char_vcols bd) (:startspaces bd))))
                                :else
                                    (let-when [bd (assoc bd :startspaces (inc (- (:end_vcol oap) (:start_vcol oap))))] (and is_del (!= (:op_type oap) OP_LSHIFT)) => bd
                                        ;; just putting the sum of those two into bd.startspaces doesn't work for Visual replace, so we have to split the tab in two
                                        (assoc bd :startspaces (- (:start_char_vcols bd) (- (:start_vcol bd) (:start_vcol oap)))
                                                  :endspaces (- (:end_vcol bd) (:end_vcol oap) 1)))
                                )) t]
                        :else
                            (let [[#_Bytes prev_pend t bd]
                                    (loop-when [prev_pend @a'pend t t bd bd] (and (<= (:end_vcol bd) (:end_vcol oap)) (non-eos? @a'pend)) => [prev_pend t bd]
                                        ;; Count a tab for what it's worth (if list mode not on).
                                        (let [prev_pend @a'pend t (lbr-chartabsize-adv line, a'pend, (:end_vcol bd))]
                                            (recur prev_pend t (update bd :end_vcol + t)))
                                    )]
                                (cond (and (<= (:end_vcol bd) (:end_vcol oap)) (or (not is_del) (== (:op_type oap) OP_APPEND) (== (:op_type oap) OP_REPLACE))) ;; line too short
                                    [(let [bd (assoc bd :is_short true)]
                                        ;; Alternative: include spaces to fill up the block.
                                        ;; Disadvantage: can lead to trailing spaces when the line is short where the text is put.
                                        (assoc bd :endspaces (if (or (== (:op_type oap) OP_APPEND) (!= @virtual_op FALSE))
                                            (+ (- (:end_vcol oap) (:end_vcol bd)) (if (:inclusive oap) 1 0))
                                            0 ;; replace doesn't add characters
                                        ))) t]
                                (< (:end_vcol oap) (:end_vcol bd))
                                    [(let-when [bd (assoc bd :endspaces (- (:end_vcol bd) (:end_vcol oap) 1))] (and (not is_del) (non-zero? (:endspaces bd))) => bd
                                        (when (BNE @a'pend, s) (reset! a'pend prev_pend))
                                        (assoc bd :endspaces (- t (:endspaces bd)))) t]
                                :else
                                    [bd t])
                            ))
                      bd (assoc bd :end_char_vcols t)
                      s (if (and is_del (non-zero? (:startspaces bd))) p s)]
                    [(assoc bd :textlen (BDIFF @a'pend, s)) s])
            )]
        (assoc bd :textstart s :textcol (BDIFF s, line))
    ))

(final int NUMBUFLEN 30)        ;; length of a buffer to store a number in ASCII

(atom! boolean hexupper)                                ;; 0xABC

;; add/subtract 'Prenum1' to/from a number in a line
;; 'command' is CTRL-A for add, CTRL-X for subtract
;;
;; return false for failure, true otherwise

(defn- #_boolean do-addsub [#_int command, #_long Prenum1]
    (let-when [nf @(:b_p_nf @curbuf)
          #_boolean dohex (some? (vim-strchr nf, (byte \x)))   ;; "heXadecimal"
          #_boolean dooct (some? (vim-strchr nf, (byte \o)))   ;; "Octal"
          #_boolean doalp (some? (vim-strchr nf, (byte \p)))   ;; "alPha"
          #_Bytes s (ml-get (:lnum (:w_cursor @curwin)))
          ;; First check if we are on a hexadecimal number, after the "0x".
          #_int col (:col (:w_cursor @curwin))
          col (if dohex (loop-when-recur col (and (< 0 col) (asc-isxdigit (.at s col))) (dec col) => col) col)
          col (if (and dohex (< 0 col) (or (at? s col (byte \X)) (at? s col (byte \x))) (at? s (dec col) (byte \0)) (asc-isxdigit (.at s (inc col))))
                ;; Found hexadecimal number, move to its start.
                (dec col)
                ;; Search forward and then backward to find the start of number.
                (let [col (:col (:w_cursor @curwin))
                      col (loop-when-recur col (and (non-eos? s col) (not (asc-isdigit (.at s col))) (not (and doalp (asc-isalpha (.at s col))))) (inc col) => col)
                      col (loop-when-recur col (and (< 0 col) (asc-isdigit (.at s (dec col))) (not (and doalp (asc-isalpha (.at s col))))) (dec col) => col)]
                    col))
          ;; If a number was found, and saving for undo works, replace the number.
          #_int d (.at s col)
    ] (and (or (asc-isdigit d) (and doalp (asc-isalpha d))) (u-save-cursor)) => (do (beep-flush) false)
        ;; get 's' again, because u-save() may have changed it
        (let [s (ml-get (:lnum (:w_cursor @curwin)))]
            (cond (and doalp (asc-isalpha d))
                ;; decrement or increment alphabetic character
                (let [d (if (== command Ctrl_X)
                            (if (<       (alphaOrd d)    Prenum1) (if (asc-isupper d) (byte \A) (byte \a)) (- d Prenum1))
                            (if (< (- 26 (alphaOrd d) 1) Prenum1) (if (asc-isupper d) (byte \Z) (byte \z)) (+ d Prenum1))
                        )]
                    (swap! curwin assoc-in [:w_cursor :col] col)
                    (swap! curwin del-char false)
                    (swap! curwin ins-char d))
            :else
                (let [[col #_boolean negative] (if (and (< 0 col) (at? s (dec col) (byte \-))) [(dec col) true] [col false])
                      a'hex (atom (int))            ;; 'X' or 'x': hex; '0': octal
                      a'len (atom (int 0))          ;; character length of the number
                      a'n (atom (long))]
                    ;; get the number value (unsigned)
                    (vim-str2nr (.plus s col), a'hex, a'len, dooct, dohex, a'n)
                    (when (neg? @a'n) (swap! a'n -))
                    ;; ignore leading '-' for hex and octal numbers
                    (let [[col negative] (if (and (non-zero? @a'hex) negative) (do (swap! a'len dec) [(inc col) false]) [col negative])
                          #_boolean subtract (== command Ctrl_X) subtract (if negative (not subtract) subtract)
                          #_long oldn @a'n
                          _ (swap! a'n (if subtract - +) Prenum1)
                          #_final #_long roof 0x7fffffffffffffff
                          _ (swap! a'n & roof)
                          ;; handle wraparound for decimal numbers
                          negative
                            (if (zero? @a'hex)
                                (let [negative (if subtract
                                            (if (< oldn @a'n) (do (swap! a'n #(inc (bit-xor % roof))) (not negative)) negative)
                                            (if (< @a'n oldn) (do (swap! a'n        bit-xor   roof)   (not negative)) negative)
                                        )]
                                    (if (zero? @a'n) false negative))
                                negative
                            )]
                        ;; Delete the old number.
                        (swap! curwin assoc-in [:w_cursor :col] col)
                        (let [#_int n @a'len #_int c (gchar-cursor @curwin)]
                            ;; Don't include the '-' in the length.
                            (when (== c (byte \-)) (swap! a'len dec))
                            (loop-when-recur [n n c c] (< 0 n) [(dec n) (gchar-cursor @curwin)]
                                (when (and (< c 0x100) (asc-isalpha c))
                                    (reset! hexupper (asc-isupper c)))
                                ;; del-char() will mark line needing displaying
                                (swap! curwin del-char false)
                            ))
                        ;; Prepare the leading characters in buf1[].
                        ;; When there are many leading zeros it could be very long.
                        ;; Allocate a bit too much.
                        (let [#_Bytes buf1 (Bytes. (+ @a'len NUMBUFLEN)) s buf1
                              s (if negative (-> s (.be 0, (byte \-)) (.plus 1)) s)
                              s (if (non-zero? @a'hex) (do (swap! a'len dec) (-> s (.be 0, (byte \0)) (.plus 1))) s)
                              s (if (or (== @a'hex (byte \x)) (== @a'hex (byte \X))) (do (swap! a'len dec) (-> s (.be 0, @a'hex) (.plus 1))) s)
                              ;; Put the number characters in buf2[].
                              #_Bytes buf2 (Bytes. NUMBUFLEN)]
                            (ยง cond
                                (zero? @a'hex)                     (.sprintf libC buf2, (u8 "%ld"), @a'n)
                                (== @a'hex (byte \0))              (.sprintf libC buf2, (u8 "%lo"), @a'n)
                                (and (non-zero? @a'hex) @hexupper) (.sprintf libC buf2, (u8 "%lX"), @a'n)
                                :else                              (.sprintf libC buf2, (u8 "%lx"), @a'n)
                            )
                            (swap! a'len - (STRLEN buf2))
                            ;; Adjust number of zeros to the new number of digits,
                            ;; so the total length of the number remains the same.
                            ;; Don't do this when the result may look like an octal number.
                            (let [s (if (and (== d (byte \0)) (not (and dooct (zero? @a'hex))))
                                        (loop-when-recur s (<= 0 (swap! a'len dec)) (-> s (.be 0, (byte \0)) (.plus 1)) => s)
                                        s)]
                                (eos! s)
                                (STRCAT buf1, buf2)
                                (swap! curwin ins-str buf1))          ;; insert the new number
                        ))
                ))
            (swap! curwin update-in [:w_cursor :col] dec)
            (swap! curwin assoc :w_set_curswant true)
        true)
    ))

;; Count the number of bytes, characters and "words" in a line.
;;
;; "Words" are counted by looking for boundaries between non-space and
;; space characters.  (It seems to produce results that match 'wc'.)
;;
;; Return value is byte count; word count for the line is added to "*wc".
;; Char count is added to "*cc".
;;
;; The function will only examine the first "limit" characters in the
;; line, stopping if it encounters an end-of-line (NUL byte).  In that
;; case, eol_size will be added to the character count to account for
;; the size of the EOL character.

(defn- #_int line-count-info [#_Bytes line, #_int' a'wc, #_int' a'cc, #_int limit, #_int eol_size]
    (let [[#_int words #_boolean word? #_int chars #_int bytes]
            (loop-when [w* 0 w? false c* 0 b* 0] (and (< b* limit) (non-eos? line b*)) => [w* w? c* b*]
                (let [[w* w?] (or (cond w? (when (vim-isspace (.at line b*)) [(inc w*) false]) (not (vim-isspace (.at line b*))) [w* true]) [w* w?])]
                    (recur w* w? (inc c*) (+ b* (us-ptr2len-cc line, b*)))
                ))
          words (if word? (inc words) words)]
        (swap! a'wc + words)
        ;; Add eol_size if the end of line was reached before hitting limit.
        (let [[bytes chars] (if (and (< bytes limit) (eos? line bytes)) [(+ bytes eol_size) (+ chars eol_size)] [bytes chars])]
            (swap! a'cc + chars)
            bytes)
    ))

;; Give some info about the position of the cursor (for "g CTRL-G").
;; In Visual mode, give some info about the selected region.  (In this case,
;; the *_count_cursor variables store running totals for the selection.)

(defn- #_window_C cursor-pos-info [#_window_C win]
    (if (flag? (:ml_flags (:b_ml @curbuf)) ML_EMPTY)
        (do (msg no_lines_msg) win)
        (let-when [[#_pos_C min_pos #_pos_C max_pos #_oparg_C oparg #_long selected_lines]
                (if @VIsual_active
                    (let [[min_pos max_pos] (if (ltpos @VIsual_cursor, (:w_cursor win)) [@VIsual_cursor (:w_cursor win)] [(:w_cursor win) @VIsual_cursor])
                          max_pos (update max_pos :col #(if (and (at? @p_sel (byte \e)) (< 0 %)) (dec %) %))
                          oparg (when (== @VIsual_mode Ctrl_V)
                                    (let [oparg (assoc (NEW_oparg_C) :is_VIsual true :block_mode true :op_type OP_NOP)
                                          o'sbr @p_sbr
                                          ;; Make 'sbr' empty for a moment to get the correct size.
                                          _ (reset! p_sbr EMPTY_OPTION)
                                          a'scol (atom (int (:start_vcol oparg))) a'ecol (atom (int (:end_vcol oparg)))
                                          _ (getvcols win, min_pos, max_pos, a'scol, a'ecol)
                                          oparg (assoc oparg :start_vcol @a'scol :end_vcol @a'ecol)
                                          _ (reset! p_sbr o'sbr)
                                          oparg (if (== (:w_curswant win) MAXCOL) (assoc oparg :end_vcol MAXCOL) oparg)]
                                        ;; Swap the start, end vcol if needed.
                                        (if (< (:end_vcol oparg) (:start_vcol oparg))
                                            (assoc oparg :start_vcol (:end_vcol oparg) :end_vcol (:start_vcol oparg))
                                            oparg)
                                    ))]
                        [min_pos max_pos oparg (inc (- (:lnum max_pos) (:lnum min_pos)))])
                    [nil nil nil 0])
              lmin 1 lmax (line-count @curbuf)
              a'bytes (atom (int 0)) a'cursor_bytes (atom (int 0))
              a'chars (atom (int 0)) a'cursor_chars (atom (int 0))
              a'words (atom (int 0)) a'cursor_words (atom (int 0))
              _ (loop-when [#_int miles (+ @a'bytes 100000) #_long lnum lmin] (<= lnum lmax) => :_
                    ;; Check for a CTRL-C every 100000 characters.
                    (let-when [miles (if (< miles @a'bytes) (do (ui-breakcheck) (if @got_int nil (+ @a'bytes 100000))) miles)] (some? miles) => nil
                        ;; Do extra processing for VIsual mode.
                        (cond (and @VIsual_active (<= (:lnum min_pos) lnum (:lnum max_pos)))
                            (let [[#_Bytes s #_int n]
                                    (condp == @VIsual_mode
                                        Ctrl_V
                                            (let [_ (reset! virtual_op (if (virtual-active) TRUE FALSE))
                                                  #_block_def_C bd (block-prep oparg, false, lnum, false)
                                                  _ (reset! virtual_op MAYBE)]
                                                [(:textstart bd) (:textlen bd)])
                                        (byte \V)
                                            [(ml-get lnum) MAXCOL]
                                        (byte \v)
                                            (let [#_int start_col (if (== lnum (:lnum min_pos)) (:col min_pos) 0)
                                                  #_int end_col (if (== lnum (:lnum max_pos)) (inc (- (:col max_pos) start_col)) MAXCOL)]
                                                [(.plus (ml-get lnum) start_col) end_col])
                                        [nil 0]
                                    )]
                                (swap! a'cursor_bytes #(if (some? s) (+ % (line-count-info s, a'cursor_words, a'cursor_chars, n, 1)) %)))
                        :else
                            ;; In non-visual mode, check for the line the cursor is on.
                            (when (== lnum (:lnum (:w_cursor win)))
                                (swap! a'cursor_words + @a'words)
                                (swap! a'cursor_chars + @a'chars)
                                (reset! a'cursor_bytes (+ @a'bytes (line-count-info (ml-get lnum), a'cursor_words, a'cursor_chars, (inc (:col (:w_cursor win))), 1)))
                            ))
                        ;; Add to the running totals.
                        (swap! a'bytes + (line-count-info (ml-get lnum), a'words, a'chars, MAXCOL, 1))
                        (recur miles (inc lnum)))
                )] (some? _) => win

            (ยง let [#_Bytes buf (Bytes. IOSIZE) win (if @VIsual_active
                        (let [#_Bytes buf1 (Bytes. 50)]
                            (if (and (== @VIsual_mode Ctrl_V) (< (:w_curswant win) MAXCOL))
;%%                             (vim_snprintf buf1, (.size buf1), (u8 "%ld Cols; "), (inc (- (:end_vcol oparg) (:start_vcol oparg))))
                                (eos! buf1))
                            (if (and (== @a'cursor_chars @a'cursor_bytes) (== @a'chars @a'bytes))
;%%                             (vim_snprintf buf, IOSIZE, (u8 "Selected %s%ld of %ld Lines; %ld of %ld Words; %ld of %ld Bytes"), buf1, selected_lines, lmax, @a'cursor_words, @a'words, @a'cursor_bytes, @a'bytes)
;%%                             (vim_snprintf buf, IOSIZE, (u8 "Selected %s%ld of %ld Lines; %ld of %ld Words; %ld of %ld Chars; %ld of %ld Bytes"), buf1, selected_lines, lmax, @a'cursor_words, @a'words, @a'cursor_chars, @a'chars, @a'cursor_bytes, @a'bytes)
                            )
                            win)
                        (let [#_Bytes s (ml-get (:lnum (:w_cursor win))) #_Bytes buf1 (Bytes. 50) #_Bytes buf2 (Bytes. 40)
                              win (validate-virtcol win)]
                            (col-print buf1, (.size buf1), (inc (:col (:w_cursor win))), (inc (:w_virtcol win)))
                            (col-print buf2, (.size buf2), (STRLEN s), (linetabsize s))
                            (if (and (== @a'cursor_chars @a'cursor_bytes) (== @a'chars @a'bytes))
;%%                             (vim_snprintf buf, IOSIZE, (u8 "Col %s of %s; Line %ld of %ld; Word %ld of %ld; Byte %ld of %ld"), buf1, buf2, (:lnum (:w_cursor win)), lmax, @a'cursor_words, @a'words, @a'cursor_bytes, @a'bytes)
;%%                             (vim_snprintf buf, IOSIZE, (u8 "Col %s of %s; Line %ld of %ld; Word %ld of %ld; Char %ld of %ld; Byte %ld of %ld"), buf1, buf2, (:lnum (:w_cursor win)), lmax, @a'cursor_words, @a'words, @a'cursor_chars, @a'chars, @a'cursor_bytes, @a'bytes)
                            )
                            win)
                    )]
                (msg buf)
                win
            ))
    ))

;; mark.c: functions for setting marks and jumping to them ----------------------------------------

;; If a named file mark's lnum is non-zero, it is valid.
;; There are marks 'A - 'Z (set by user) and '0 to '9 (set when writing viminfo).

(final int EXTRA_MARKS 10)                                              ;; marks 0-9
(final fmark_C*    namedfm    (ARRAY-fmark (+ NMARKS EXTRA_MARKS)))   ;; marks with file nr

;; Set named mark "c" at current cursor position.
;; Returns true on success, false if bad name given.

(defn- #_boolean setmark [#_int c]
    (setmark-pos c, (:w_cursor @curwin)))

;; Set named mark "c" to position "pos".
;; Returns true on success, false if bad name given.

(defn- #_boolean setmark-pos [#_int c, #_pos_C pos]
    (cond
        ;; Check for a special key (may cause islower() to crash).
        (< c 0)
            false

        (any == c (byte \') (byte \`))
            (do (if (== pos (:w_cursor @curwin))
                    (do (swap! curwin setpcmark) (swap! curwin assoc :w_prev_pcmark (:w_pcmark @curwin))) ;; keep it even when the cursor doesn't move
                    (swap! curwin assoc :w_pcmark pos))
                true)

        (== c (byte \"))  ;; """
            (do (swap! curbuf assoc :b_last_cursor pos)
                true)

        ;; Allow setting '[ and '] for an autocommand that simulates reading a file.
        (== c (byte \[))
            (do (swap! curbuf assoc :b_op_start pos)
                true)

        (== c (byte \]))
            (do (swap! curbuf assoc :b_op_end pos)
                true)

        (any == c (byte \<) (byte \>))
            (do (swap! curbuf update :b_visual assoc (if (== c (byte \<)) :vi_start :vi_end) pos)
                ;; Visual_mode has not yet been set, use a sane default.
                (when (== (:vi_mode (:b_visual @curbuf)) NUL)
                    (swap! curbuf assoc-in [:b_visual :vi_mode] (byte \v)))
                true)

        (< (byte \z) c)        ;; some islower() and isupper() cannot handle characters above 127
            false

        (asc-islower c)
            (let [#_int i (- c (byte \a))]
;%%             (COPY-pos (... (:b_namedm @curbuf) i), pos)
                true)

        (asc-isupper c)
            (let [#_int i (- c (byte \A))]
;%%             (COPY-pos (:mark (... namedfm i)), pos)
                true)

        :else
            false
    ))

;; Set the previous context mark to the current position and add it to the jump list.

(defn- #_window_C setpcmark [#_window_C win]
    (ยง let [win (assoc win :w_prev_pcmark (:w_pcmark win), :w_pcmark (:w_cursor win))]

        ;; If jumplist is full: remove oldest entry.
        ((ร win =) (update win :w_jumplistlen inc))
        (when (< JUMPLISTSIZE (:w_jumplistlen win))
            ((ร win =) (assoc win :w_jumplistlen JUMPLISTSIZE))
            (loop-when-recur [#_int i 1] (< i JUMPLISTSIZE) [(inc i)]
                (COPY-fmark (... (:w_jumplist win) (dec i)), (... (:w_jumplist win) i))
            )
        )
        ((ร win =) (assoc win :w_jumplistidx (:w_jumplistlen win)))
        ((ร fmark_C fm =) (... (:w_jumplist win) (dec (:w_jumplistlen win))))

        (COPY-pos (:mark fm), (:w_pcmark win))
        win
    ))

;; To change context, call setpcmark(), then move the current position to where ever, then call checkpcmark().
;; This ensures that the previous context will only be changed if the cursor moved to a different line.
;; If pcmark was deleted (with "dG") the previous mark is restored.

(defn- #_window_C checkpcmark [#_window_C win]
    (if (and (non-zero? (:lnum (:w_prev_pcmark win))) (or (zero? (:lnum (:w_pcmark win))) (eqpos (:w_pcmark win), (:w_cursor win))))
        (let [win (assoc win :w_pcmark (:w_prev_pcmark win))]
            (assoc-in win [:w_prev_pcmark :lnum] 0)) ;; show it has been checked
        win
    ))

;; Move "m" positions in the jump list ("m" may be negative).

(defn- #_pos_C movemark [#_int m]
    (swap! curwin dedupe-jumplist)
    (let-when [n (:w_jumplistlen @curwin)] (< -1 (+ (:w_jumplistidx @curwin) m) n) => nil
        ;; If first CTRL-O or CTRL-I command after a jump, add cursor position
        ;; to list.  Careful: If there are duplicates (CTRL-O immediately after
        ;; starting Vim on a file), another entry may have been removed.
        (let-when [_ (if (== (:w_jumplistidx @curwin) n)
                    (do
                        (swap! curwin setpcmark)
                        (swap! curwin update :w_jumplistidx dec)         ;; skip the new entry
                        (if (< -1 (+ (:w_jumplistidx @curwin) m)) :_ nil)
                    )
                    :_)] (some? _) => nil
            (swap! curwin update :w_jumplistidx + m)
            (:mark (... (:w_jumplist @curwin) (:w_jumplistidx @curwin)))
        )
    ))

;; Move "m" positions in the changelist ("m" may be negative).

(defn- #_pos_C movechangelist [#_int m]
    (let-when [n (:b_changelistlen @curbuf)] (non-zero? n) => nil
        (let-when [i (:w_changelistidx @curwin)
                   i (cond
                        (< (+ i m) 0) (if (zero? i) nil 0)
                        (<= n (+ i m)) (if (== i (dec n)) nil (dec n))
                        :else (+ i m)
                    )] (some? i) => nil
            (swap! curwin assoc :w_changelistidx i)
            (... (:b_changelist @curbuf) i))
    ))

(defn- #_pos_C getmark [#_int c, #_boolean _changefile]
    (cond
        (or (< c 0) (< (byte \~) c))           nil
        (any == c (byte \') (byte \`)) (:w_pcmark @curwin)              ;; previous context mark
        (== c (byte \"))                       (:b_last_cursor @curbuf) ;; to pos when leaving buffer """
        (== c (byte \^))                       (:b_last_insert @curbuf) ;; to where Insert mode stopped
        (== c (byte \.))                       (:b_last_change @curbuf) ;; to where last change was made
        (== c (byte \[))                       (:b_op_start @curbuf)    ;; to start of previous operator
        (== c (byte \]))                       (:b_op_end @curbuf)      ;; to end of previous operator
        (any == c (byte \{) (byte \})) nil                              ;; to previous/next paragraph
        (any == c (byte \() (byte \))) nil                              ;; to previous/next sentence
        (any == c (byte \<) (byte \>))                                  ;; start/end of visual area
            (let [visual (:b_visual @curbuf) #_pos_C startp (:vi_start visual) #_pos_C endp (:vi_end visual)
                  #_pos_C p (if (== (== c (byte \<)) (ltpos startp, endp)) startp endp)]
                ;; for Visual line mode, set mark at begin or end of line
                (if (== (:vi_mode visual) (byte \V)) (assoc p :col (if (== c (byte \<)) 0 MAXCOL) :coladd 0) p)
            )
        (asc-islower c) (... (:b_namedm @curbuf) (- c (byte \a)))
        (asc-isupper c) (:mark (... namedfm (- c (byte \A))))
        (asc-isdigit c) (:mark (... namedfm (+ (- c (byte \0)) NMARKS)))
        :else nil))

;; Search for the next named mark in the current file.
;;
;; Returns pointer to pos_C of the next mark or null if no mark is found.

(defn- #_pos_C getnextmark [#_pos_C startpos, #_int dir, #_boolean begin_line] ;; startpos: where to start ;; dir: direction for search
    ;; When searching backward/forward and leaving the cursor on the first non-blank, position must be in a previous/next line.
    (let [#_pos_C pos (cond (and (== dir BACKWARD) begin_line) (assoc startpos :col 0) (and (== dir FORWARD) begin_line) (assoc startpos :col MAXCOL) :else startpos)]
        (loop-when [#_pos_C mark nil #_int i 0] (< i NMARKS) => mark
            (let [mi (... (:b_namedm @curbuf) i)
                  mark (if (< 0 (:lnum mi))
                            (if (== dir FORWARD)
                                (if (and (or (nil? mark) (ltpos mi, mark)) (ltpos pos, mi)) mi mark)
                                (if (and (or (nil? mark) (ltpos mark, mi)) (ltpos mi, pos)) mi mark))
                            mark)]
                (recur mark (inc i))
            ))
    ))

;; Check a if a position from a mark is valid.
;; Give and error message and return false if not.

(defn- #_boolean check-mark [#_pos_C pos]
    (cond
        (nil? pos)
            (do (emsg e_umark) false)
        ;; 'lnum' is negative if mark is in another file and can't get that file, error message already give then.
        (<= (:lnum pos) 0)
            (do (when (zero? (:lnum pos)) (emsg e_marknotset)) false)
        (< (line-count @curbuf) (:lnum pos))
            (do (emsg e_markinval) false)
        :else
            true
    ))

(defn- #_long one-adjust [#_long add, #_long line1, #_long line2, #_long amount, #_long amount_after]
    (cond
        (<= line1 add line2)
            (if (== amount MAXLNUM) 0 (+ add amount))
        (and (non-zero? amount_after) (< line2 add))
            (+ add amount_after)
        :else
            add
    ))

;; don't delete the line, just put at first deleted line
(defn- #_long one-adjust-nodel [#_long add, #_long line1, #_long line2, #_long amount, #_long amount_after]
    (cond
        (<= line1 add line2)
            (if (== amount MAXLNUM) line1 (+ add amount))
        (and (non-zero? amount_after) (< line2 add))
            (+ add amount_after)
        :else
            add
    ))

(atom! pos_C mark_initpos (->pos_C 1, 0, 0))

;; Adjust marks between line1 and line2 (inclusive) to move 'amount' lines.
;; Must be called before changed_*(), appended-lines() or deleted-lines().
;; May be called before or after changing the text.
;; When deleting lines line1 to line2, use an 'amount' of MAXLNUM:
;; The marks within this range are made invalid.
;; If 'amount_after' is non-zero adjust marks after line2.
;; Example: Delete lines 34 and 35: mark-adjust(34, 35, MAXLNUM, -2);
;; Example: Insert two lines below 55: mark-adjust(56, MAXLNUM, 2, 0);
;;                                 or: mark-adjust(56, 55, MAXLNUM, 2);

(defn- #_void mark-adjust [#_long line1, #_long line2, #_long amount, #_long amount_after]
    (ยง
        (when-not (and (< line2 line1) (zero? amount_after))
            ;; named marks, lower case and upper case
            (dotimes [#_int i NMARKS]
                ((ร @curbuf.b_namedm[i].lnum =) (one-adjust (:lnum (... (:b_namedm @curbuf) i)), line1, line2, amount, amount_after))
                ((ร namedfm[i].mark.lnum =) (one-adjust-nodel (:lnum (:mark (... namedfm i))), line1, line2, amount, amount_after))
            )
            (loop-when-recur [#_int i NMARKS] (< i (+ NMARKS EXTRA_MARKS)) [(inc i)]
                ((ร namedfm[i].mark.lnum =) (one-adjust-nodel (:lnum (:mark (... namedfm i))), line1, line2, amount, amount_after))
            )

            (swap! curbuf update-in [:b_last_insert :lnum] one-adjust line1, line2, amount, amount_after) ;; last insert position
            (swap! curbuf update-in [:b_last_change :lnum] one-adjust line1, line2, amount, amount_after) ;; last change position

            ;; last cursor position, if it was set
            (when (not (eqpos (:b_last_cursor @curbuf), @mark_initpos))
                (swap! curbuf update-in [:b_last_cursor :lnum] one-adjust line1, line2, amount, amount_after))

            ;; list of change positions
            (dotimes [#_int i (:b_changelistlen @curbuf)]
                ((ร @curbuf.b_changelist[i].lnum =) (one-adjust-nodel (:lnum (... (:b_changelist @curbuf) i)), line1, line2, amount, amount_after))
            )

            ;; Visual area.
            (swap! curbuf update-in [:b_visual :vi_start :lnum] one-adjust-nodel line1, line2, amount, amount_after)
            (swap! curbuf update-in [:b_visual :vi_end :lnum] one-adjust-nodel line1, line2, amount, amount_after)

            (swap! curwin update-in [:w_pcmark :lnum] one-adjust line1, line2, amount, amount_after) ;; previous context mark
            (swap! curwin update-in [:w_prev_pcmark :lnum] one-adjust line1, line2, amount, amount_after) ;; previous pcmark

            ;; Adjust items in all windows related to the current buffer.

            (loop-when-recur [#_window_C win @firstwin] (some? win) [(:w_next win)]
                ;; Marks in the jumplist.  When deleting lines, this may create
                ;; duplicate marks in the jumplist, they will be removed later.
                (dotimes [#_int i (:w_jumplistlen win)]
                    ((ร win.w_jumplist[i].mark.lnum =) (one-adjust-nodel (:lnum (:mark (... (:w_jumplist win) i))), line1, line2, amount, amount_after))
                )

                ;; the displayed Visual area
                (when (non-zero? (:w_old_cursor_lnum win))
                    ((ร win =) (update win :w_old_cursor_lnum one-adjust-nodel line1, line2, amount, amount_after))
                    ((ร win =) (update win :w_old_visual_lnum one-adjust-nodel line1, line2, amount, amount_after))
                )

                ;; topline and cursor position for windows with the same buffer
                ;; other than the current window
                (when (!= win @curwin)
                    (cond (<= line1 (:w_topline win) line2)
                    (do
                        ;; topline is deleted ;; keep topline on the same line
                        ((ร win =) (assoc win :w_topline (if (== amount MAXLNUM) (max 1 (dec line1)) (+ (:w_topline win) amount))))
                    )
                    (and (non-zero? amount_after) (< line2 (:w_topline win)))
                    (do
                        ((ร win =) (update win :w_topline + amount_after))
                    ))

                    (cond (<= line1 (:lnum (:w_cursor win)) line2)
                    (do
                        (cond (== amount MAXLNUM)              ;; line with cursor is deleted
                        (do
                            ((ร win =) (update win :w_cursor assoc :lnum (max 1 (dec line1)) :col 0))
                        )
                        :else                                ;; keep cursor on the same line
                        (do
                            ((ร win =) (update-in win [:w_cursor :lnum] + amount))
                        ))
                    )
                    (and (non-zero? amount_after) (< line2 (:lnum (:w_cursor win))))
                    (do
                        ((ร win =) (update-in win [:w_cursor :lnum] + amount_after))
                    ))
                )
            )
        )
        nil
    ))

;; This code is used often, needs to be fast.
(defn- #_void col-adjust [#_pos_C posp, #_long lnum, #_int mincol, #_long lnum_amount, #_long col_amount]
    (ยง
        (when (and (== (:lnum posp) lnum) (<= mincol (:col posp)))
            ((ร posp =) (update posp :lnum + lnum_amount))
            ((ร posp =) (assoc posp :col (if (and (< col_amount 0) (<= (:col posp) (- col_amount))) 0 (+ (:col posp) col_amount))))
        )
        nil
    ))

;; Adjust marks in line "lnum" at column "mincol" and further: add
;; "lnum_amount" to the line number and add "col_amount" to the column position.

(defn- #_void mark-col-adjust [#_long lnum, #_int mincol, #_long lnum_amount, #_long col_amount]
    (when-not (and (zero? col_amount) (zero? lnum_amount))
        ;; named marks, lower case and upper case
        (dotimes [#_int i NMARKS]
            (col-adjust (... (:b_namedm @curbuf) i), lnum, mincol, lnum_amount, col_amount)
            (col-adjust (:mark (... namedfm i)), lnum, mincol, lnum_amount, col_amount)
        )
        (loop-when-recur [#_int i NMARKS] (< i (+ NMARKS EXTRA_MARKS)) [(inc i)]
            (col-adjust (:mark (... namedfm i)), lnum, mincol, lnum_amount, col_amount)
        )

        ;; last insert position
        (col-adjust (:b_last_insert @curbuf), lnum, mincol, lnum_amount, col_amount)

        ;; last change position
        (col-adjust (:b_last_change @curbuf), lnum, mincol, lnum_amount, col_amount)

        ;; list of change positions
        (dotimes [#_int i (:b_changelistlen @curbuf)]
            (col-adjust (... (:b_changelist @curbuf) i), lnum, mincol, lnum_amount, col_amount)
        )

        ;; Visual area.
        (col-adjust (:vi_start (:b_visual @curbuf)), lnum, mincol, lnum_amount, col_amount)
        (col-adjust (:vi_end (:b_visual @curbuf)), lnum, mincol, lnum_amount, col_amount)

        ;; previous context mark
        (col-adjust (:w_pcmark @curwin), lnum, mincol, lnum_amount, col_amount)

        ;; previous pcmark
        (col-adjust (:w_prev_pcmark @curwin), lnum, mincol, lnum_amount, col_amount)

        ;; Adjust items in all windows related to the current buffer.

        (loop-when-recur [#_window_C win @firstwin] (some? win) [(:w_next win)]
            ;; marks in the jumplist
            (dotimes [#_int i (:w_jumplistlen win)]
                (col-adjust (:mark (... (:w_jumplist win) i)), lnum, mincol, lnum_amount, col_amount)
            )

            ;; cursor position for other windows with the same buffer
            (if (!= win @curwin)
                (col-adjust (:w_cursor win), lnum, mincol, lnum_amount, col_amount))
        )
    )
    nil)

;; When deleting lines, this may create duplicate marks in the jumplist.
;; They will be removed here for the current window.

(defn- #_window_C dedupe-jumplist [#_window_C win]
    (ยง let [n (:w_jumplistlen win)
          e (loop-when [e 0 i 0] (< i n) => e
                (when (== (:w_jumplistidx win) i)
                    ((ร win =) (assoc win :w_jumplistidx e)))
                (let [m (loop-when-recur [m (inc i)] (and (< m n) (!= (:lnum (:mark (... (:w_jumplist win) m))) (:lnum (:mark (... (:w_jumplist win) i))))) [(inc m)] => m)
                      e (if (<= n m) (do (COPY-fmark (... (:w_jumplist win) e), (... (:w_jumplist win) i)) (inc e)) e)]
                    (recur e (inc i))
                ))]
        (when (== (:w_jumplistidx win) n)
            ((ร win =) (assoc win :w_jumplistidx e)))
        ((ร win =) (assoc win :w_jumplistlen e))
        win
    ))

;; Copy the jumplist from window "won" to window "win".

(defn- #_window_C copy-jumplist [#_window_C win, #_window_C won]
    (ยง
        (dotimes [#_int i (:w_jumplistlen won)]
            (COPY-fmark (... (:w_jumplist win) i), (... (:w_jumplist won) i))
        )
        ((ร win =) (assoc win :w_jumplistlen (:w_jumplistlen won)))
        ((ร win =) (assoc win :w_jumplistidx (:w_jumplistidx won)))
        win
    ))

;;; ============================================================================================== VimL

;; getchar.c --------------------------------------------------------------------------------------
;;
;; functions related with getting a character from the user/mapping/redo/...
;;
;; manipulations with redo buffer and stuff buffer
;; mappings and abbreviations

;; These buffers are used for storing:
;; - stuffed characters: A command that is translated into another command.
;; - redo characters: will redo the last change.
;; - recorded characters: for the "q" command.
;;
;; The bytes are stored like in the typeahead buffer:
;; - KB_SPECIAL introduces a special key (two more bytes follow).
;;   A literal KB_SPECIAL is stored as KB_SPECIAL KS_SPECIAL KE_FILLER.
;; These translations are also done on multi-byte characters!
;;
;; Escaping KB_SPECIAL is done by inchar().
;; Un-escaping is done by vgetc().

(atom! buffheader_C redobuff        (NEW_buffheader_C))
(atom! buffheader_C old_redobuff    (NEW_buffheader_C))
(atom! buffheader_C recordbuff      (NEW_buffheader_C))

(atom! int typeahead_char)      ;; typeahead char that's not flushed

;; When block_redo is true redo buffer will not be changed;
;; used by edit() to repeat insertions and 'V' command for redoing.

(atom! boolean block_redo)

;; Variables used by vgetorpeek() and flush-buffers().
;;
;; typebuf.tb_buf[] contains all characters that are not consumed yet.
;; typebuf.tb_buf[typebuf.tb_off] is the first valid character.
;; typebuf.tb_buf[typebuf.tb_off + typebuf.tb_len - 1] is the last valid char.
;; typebuf.tb_buf[typebuf.tb_off + typebuf.tb_len] must be NUL.
;;
;; After the head are characters that come from the terminal.

;; typebuf.tb_buf has three parts:
;;  room in front (for result of mappings),
;;  the middle for typeahead and
;;  room for new characters (which needs to be 3 * MAXMAPLEN).

(atom! int      last_recorded_len)          ;; number of last recorded chars

;; Free and clear a buffer.

(defn- #_void free-buff [#_buffheader_C buf]
    (ยง
        ((ร buf =) (assoc-in buf [:bh_first :bb_next] nil))
        nil
    ))

;; Return the contents of a buffer as a single string.
;; KB_SPECIAL in the returned string is escaped.

(defn- #_Bytes get-buffcont [#_buffheader_C buffer, #_boolean dozero]
    ;; dozero: n == zero is not an error
    (let-when [n (loop-when-recur [n 0 #_buffblock_C bp (:bb_next (:bh_first buffer))] (some? bp) [(+ n (STRLEN (:bb_str bp))) (:bb_next bp)] => n)] (or (< 0 n) dozero) => nil
        (let [#_Bytes p (Bytes. (inc n))
              n (loop-when [n 0 #_buffblock_C bp (:bb_next (:bh_first buffer))] (some? bp) => n
                    (let [#_Bytes s (:bb_str bp)
                          n (loop-when-recur [n n i 0] (non-eos? s i) [(inc n) (inc i)] => n
                                (.be p n, (.at s i))
                            )]
                        (recur n (:bb_next bp))
                    ))]
            (eos! p n)
        )))

;; Return the contents of the record buffer as a single string and clear the record buffer.
;; KB_SPECIAL in the returned string is escaped.

(defn- #_Bytes get-recorded []
    (let [#_Bytes p (get-buffcont @recordbuff, true)]
        (free-buff @recordbuff)
        ;; Remove the characters that were added the last time, these must be the
        ;; (possibly mapped) characters that stopped the recording.
        (let [n (STRLEN p) m @last_recorded_len
              n (if (<= m n) (let [n (- n m)] (eos! p n) n) n)]
            ;; When stopping recording from Insert mode with CTRL-O q, also remove the CTRL-O.
            (when (and (< 0 n) (non-zero? @restart_edit) (at? p (dec n) Ctrl_O))
                (eos! p (dec n)))
            p)
    ))

;; Return the contents of the redo buffer as a single string.
;; KB_SPECIAL in the returned string is escaped.

(defn- #_Bytes get-inserted []
    (get-buffcont @redobuff, false))

;; Add string "s" after the current block of buffer "buf".
;; KB_SPECIAL should have been escaped already.

(defn- #_void add-buff [#_buffheader_C buf, #_Bytes s, #_long slen]
    ;; slen: length of "s" or -1
    (ยง
        ((ร slen =) (if (< slen 0) (STRLEN s) slen))
        (if (zero? slen)                          ;; don't add empty strings
            ((ร RETURN) nil)
        )

        (cond (nil? (:bb_next (:bh_first buf)))       ;; first add to list
        (do
            ((ร buf =) (assoc buf :bh_space 0))
            ((ร buf =) (assoc buf :bh_curr (:bh_first buf)))
        )
        (nil? (:bh_curr buf))           ;; buffer has already been read
        (do
            (emsg (u8 "E222: Add to read buffer"))
            ((ร RETURN) nil)
        )
        (non-zero? (:bh_index buf))
        (do
            ((ร buffblock_C bp =) (:bb_next (:bh_first buf)))
            ((ร int len =) (+ (STRLEN (.plus (:bb_str bp) (:bh_index buf))) 1))
            (BCOPY (:bb_str bp), 0, (:bb_str bp), (:bh_index buf), len)
        ))
        ((ร buf =) (assoc buf :bh_index 0))

        (cond (<= (int slen) (:bh_space buf))
        (do
            ((ร int len =) (STRLEN (:bb_str (:bh_curr buf))))
            (vim-strncpy (.plus (:bb_str (:bh_curr buf)) len), s, (int slen))
            ((ร buf =) (update buf :bh_space - slen))
        )
        :else
        (do
            ((ร int len =) (max 20 (int slen)))            ;; minimal size for bb_str

            ((ร buffblock_C bp =) (NEW_buffblock_C))

            ((ร bp =) (assoc bp :bb_str (Bytes. (inc len))))
            (vim-strncpy (:bb_str bp), s, (int slen))
            ((ร buf =) (assoc buf :bh_space (- len (int slen))))

            ((ร bp =) (assoc bp :bb_next (:bb_next (:bh_curr buf))))
            ((ร buf =) (assoc-in buf [:bh_curr :bb_next] bp))
            ((ร buf =) (assoc buf :bh_curr bp))
        ))
        nil
    ))

;; Add number "n" to buffer "buf".

(defn- #_void add-num-buff [#_buffheader_C buf, #_long n]
    (let [#_Bytes number (Bytes. 32)]
;%%     (.sprintf libC number, (u8 "%ld"), n)
        (add-buff buf, number, -1)
        nil
    ))

;; Add character 'c' to buffer "buf".
;; Translates special keys, NUL, KB_SPECIAL and multibyte characters.

(defn- #_void add-char-buff [#_buffheader_C buf, #_int c]
    (let [bytes (Bytes. (inc MB_MAXBYTES)) n (if (is-special c) 1 (utf-char2bytes c, bytes)) temp (Bytes. 4)]
        (loop-when [c c i 0] (< i n)
            (let [c (if (not (is-special c)) (char_u (.at bytes i)) c)]
                (if (or (is-special c) (== c (char_u KB_SPECIAL)) (== c NUL))
                    (-> temp (.be 0, KB_SPECIAL) (.be 1, (KB-SECOND c)) (.be 2, (KB-THIRD c)) (eos! 3)) ;; translate special key code into three byte sequence
                    (-> temp (.be 0, c) (eos! 1)))
                (add-buff buf, temp, -1)
                (recur c (inc i))
            )))
    nil)

;; First read ahead buffer.  Used for translated commands.
(atom! buffheader_C readbuf1    (NEW_buffheader_C))

;; Second read ahead buffer.  Used for redo.
(atom! buffheader_C readbuf2    (NEW_buffheader_C))

;; Get one byte from a read buffer.
;; If advance == true go to the next char.
;; No translation is done KB_SPECIAL is escaped.

(defn- #_byte read-readbuf [#_buffheader_C buf, #_boolean advance]
    (ยง
        ((ร buffblock_C bp =) (:bb_next (:bh_first buf)))
        (if (nil? bp) ;; buffer is empty
            ((ร RETURN) NUL)
        )

        ((ร byte b =) (.at (:bb_str bp) (:bh_index buf)))

        (when (and advance (at? (:bb_str bp) (ร ++buf.bh_index) NUL))
            ((ร buf =) (assoc-in buf [:bh_first :bb_next] (:bb_next bp)))
            ((ร buf =) (assoc buf :bh_index 0))
        )

        b
    ))

;; Get one byte from the read buffers.
;; Use readbuf1 one first, use readbuf2 if that one is empty.
;; If advance == true go to the next char.
;; No translation is done KB_SPECIAL is escaped.

(defn- #_byte read-readbuffers [#_boolean advance]
    (let [#_byte b (read-readbuf @readbuf1, advance)]
        (if (== b NUL) (read-readbuf @readbuf2, advance) b)
    ))

;; Prepare the read buffers for reading (if they contain something).

(defn- #_void start-stuff []
    (when (some? (:bb_next (:bh_first @readbuf1))) (swap! readbuf1 assoc :bh_curr (:bh_first @readbuf1) :bh_space 0))
    (when (some? (:bb_next (:bh_first @readbuf2))) (swap! readbuf2 assoc :bh_curr (:bh_first @readbuf2) :bh_space 0))
    nil)

;; Return true if the stuff buffer is empty.

(defn- #_boolean stuff-empty []
    (and (nil? (:bb_next (:bh_first @readbuf1))) (nil? (:bb_next (:bh_first @readbuf2)))))

;; Set a typeahead character that won't be flushed.

(defn- #_void typeahead-noflush [#_int c]
    (reset! typeahead_char c)
    nil)

;; Remove the contents of the stuff buffer and the mapped characters
;; in the typeahead buffer (used in case of an error).
;; If "flush_typeahead" is true, flush all typeahead characters
;; (used when interrupted by a CTRL-C).

(defn- #_void flush-buffers [#_boolean flush_typeahead]
    (init-typebuf)

    (start-stuff)
    (while (!= (read-readbuffers true) NUL)
        ;
    )

    (when flush_typeahead            ;; remove all typeahead
        ;; We have to get all characters, because we may delete the first part of an escape sequence.
        ;; In an xterm we get one char at a time and we have to get them all.

        (while (non-zero? (inchar (:tb_buf @typebuf), (dec (:tb_buflen @typebuf)), 10, (:tb_change_cnt @typebuf)))
            ;
        )
        (swap! typebuf assoc :tb_off MAXMAPLEN :tb_len 0)
    )
    nil)

;; The previous contents of the redo buffer is kept in old_redobuffer.
;; This is used for the CTRL-O <.> command in insert mode.

(defn- #_void reset-redo []
    (when (not @block_redo)
        (free-buff @old_redobuff)
        (COPY-buffheader @old_redobuff, @redobuff)
        (swap! redobuff assoc-in [:bh_first :bb_next] nil)
    )
    nil)

;; Discard the contents of the redo buffer and restore the previous redo buffer.

(defn- #_void cancel-redo []
    (when (not @block_redo)
        (free-buff @redobuff)
        (COPY-buffheader @redobuff, @old_redobuff)
        (swap! old_redobuff assoc-in [:bh_first :bb_next] nil)
        (start-stuff)
        (while (!= (read-readbuffers true) NUL)
            ;
        )
    )
    nil)

;; Append "s" to the redo buffer.
;; KB_SPECIAL should already have been escaped.

(defn- #_void append-redo [#_Bytes s]
    (when (not @block_redo)
        (add-buff @redobuff, s, -1))
    nil)

;; Append to Redo buffer literally, escaping special characters with CTRL-V.
;; KB_SPECIAL is escaped as well.

(defn- #_void append-redo-lit [#_Bytes str, #_int len]
    ;; len: length of "str" or -1 for up to the NUL
    (when-not @block_redo
        (let [a's (atom (#_Bytes object str))]
            (loop-when [] (if (< len 0) (non-eos? @a's) (< (BDIFF @a's, str) len))
                ;; Put a string of normal characters in the redo buffer (that's faster).
                (let [#_Bytes start @a's]
                    (while (and (<= (byte \space) (.at @a's 0)) (< (.at @a's 0) DEL) (or (< len 0) (< (BDIFF @a's, str) len)))
                        (swap! a's inc))
                    ;; Don't put '0' or '^' as last character, just in case a CTRL-D is typed next.
                    (when (and (eos? @a's) (any == (.at @a's -1) (byte \0) (byte \^)))
                        (swap! a's dec))
                    (when (BLT start, @a's)
                        (add-buff @redobuff, start, (BDIFF @a's, start)))
                    (when (and (non-eos? @a's) (not (<= 0 len (BDIFF @a's, str))))
                        ;; Handle a special or multibyte character.  ;; Handle composing chars separately.
                        (let [#_int c (us-ptr2char-adv a's, false)]
                            (when (or (< c (byte \space)) (== c DEL) (and (eos? @a's) (any == c (byte \0) (byte \^))))
                                (add-char-buff @redobuff, Ctrl_V))
                            ;; CTRL-V '0' must be inserted as CTRL-V 048
                            (if (and (eos? @a's) (== c (byte \0)))
                                (add-buff @redobuff, (u8 "048"), 3)
                                (add-char-buff @redobuff, c))
                            (recur)
                        ))
                ))
        ))
    nil)

;; Append a character to the redo buffer.
;; Translates special keys, NUL, KB_SPECIAL and multibyte characters.

(defn- #_void append-redo-char [#_int c]
    (when (not @block_redo)
        (add-char-buff @redobuff, c))
    nil)

;; Append a number to the redo buffer.

(defn- #_void append-redo-number [#_long n]
    (when (not @block_redo)
        (add-num-buff @redobuff, n))
    nil)

;; Append string "s" to the stuff buffer.
;; KB_SPECIAL must already have been escaped.

(defn- #_void stuff-string [#_Bytes s]
    (add-buff @readbuf1, s, -1)
    nil)

;; Append string "s" to the redo stuff buffer.
;; KB_SPECIAL must already have been escaped.

(defn- #_void stuff-redo [#_Bytes s]
    (add-buff @readbuf2, s, -1)
    nil)

(defn- #_void stuff-redo-len [#_Bytes s, #_long len]
    (add-buff @readbuf1, s, len)
    nil)

;; Append a character to the stuff buffer.
;; Translates special keys, NUL, KB_SPECIAL and multibyte characters.

(defn- #_void stuff-char [#_int c]
    (add-char-buff @readbuf1, c)
    nil)

;; Append a number to the stuff buffer.

(defn- #_void stuff-num [#_long n]
    (add-num-buff @readbuf1, n)
    nil)

(atom! buffblock_C redo_bp)
(atom! Bytes redo_sp)

;; Prepare for redo; return false if nothing to redo, true otherwise.
;; If old_redo is true, use old_redobuff instead of redobuff.

(defn- #_boolean init-redo [#_boolean old_redo]
    (reset! redo_bp (:bb_next (:bh_first (if old_redo @old_redobuff @redobuff))))
    (if (some? @redo_bp)
        (do (reset! redo_sp (:bb_str @redo_bp)) true)
        false
    ))

;; Read a character from the redo buffer.
;; Translates KB_SPECIAL and multibyte characters.
;; The redo buffer is left as it is.

(defn- #_int read-redo []
    (if (non-eos? @redo_sp)
        ;; For a multi-byte character get all the bytes and return the converted character.
        (let [n (if (or (not-at? @redo_sp KB_SPECIAL) (at? @redo_sp 1 KS_SPECIAL)) (mb-byte2len (char_u (.at @redo_sp 0))) 1) buf (Bytes. (inc MB_MAXBYTES))]
            (loop [i 0]
                (let [c (if (at? @redo_sp KB_SPECIAL) ;; special key or escaped KB_SPECIAL
                            (let [c (toSpecial (.at @redo_sp 1), (.at @redo_sp 2))] (swap! redo_sp plus 3) c)
                            (let [c (char_u (.at @redo_sp 0))] (swap! redo_sp plus 1) c))]
                    (when (and (eos? @redo_sp) (some? (:bb_next @redo_bp)))
                        (swap! redo_bp :bb_next)
                        (reset! redo_sp (:bb_str @redo_bp)))
                    (.be buf i, c)
                    (cond
                        (== i (dec n)) (if (!= n 1) (us-ptr2char buf) c) ;; last byte of a character
                        (eos? @redo_sp) NUL ;; cannot happen?
                        :else (recur (inc i))
                    ))
            ))
        NUL
    ))

;; Stuff the redo buffer into readbuf2.
;; Insert the redo count into the command.
;; If "old_redo" is true, the last but one command is repeated instead of the last command (inserting text).
;; This is used for CTRL-O <.> in insert mode.
;;
;; Return false for failure, true otherwise.

(defn- #_boolean start-redo [#_window_C win, #_long count, #_boolean old_redo]
    (and (init-redo old_redo)
        (let [c (read-redo)
              ;; copy the buffer name, if present
              c (if (== c (byte \"))  ;; """
                    (let [_ (add-buff @readbuf2, (u8 "\""), 1)
                          c (read-redo) c (if (< (byte \0) c (byte \9)) (inc c) c)] ;; if a numbered buffer is used, increment the number
                        (add-char-buff @readbuf2, c)
                        (read-redo))
                    c)
              c (if (== c (byte \v))   ;; redo Visual
                    (do
                        (reset! VIsual_cursor (:w_cursor win))
                        (reset! VIsual_active true)
                        (reset! VIsual_select false)
                        (reset! VIsual_reselect true)
                        (reset! redo_VIsual_busy true)
                        (read-redo))
                    c)
              ;; try to enter the count (in place of a previous count)
              c (if (non-zero? count)
                    (let [c (loop-when-recur c (asc-isdigit c) (read-redo) => c)] ;; skip "old" count
                        (add-num-buff @readbuf2, count)
                        c)
                    c)]
            ;; copy from the redo buffer into the stuff buffer
            (add-char-buff @readbuf2, c)
            (loop-when-recur [c (read-redo)] (!= c NUL) [(read-redo)] => true
                (add-char-buff @readbuf2, c)
            ))
    ))

;; Repeat the last insert (R, o, O, a, A, i or I command) by stuffing the redo buffer into readbuf2.
;; Return false for failure, true otherwise.

(defn- #_boolean start-redo-ins []
    (and (init-redo false)
        (do (start-stuff)
            ;; skip the count and the command character
            (loop-when [c (read-redo)] (!= c NUL)
                (if (some? (vim-strchr (u8 "AaIiRrOo"), c))
                    (when (any == c (byte \O) (byte \o))
                        (add-buff @readbuf2, NL_STR, -1))
                    (recur (read-redo))
                ))
            ;; copy the typed text from the redo buffer into the stuff buffer
            (loop-when-recur [c (read-redo)] (!= c NUL) [(read-redo)]
                (add-char-buff @readbuf2, c))
            (reset! block_redo true)
            true)
    ))

(defn- #_void stop-redo-ins []
    (reset! block_redo false)
    nil)

(final int TYPELEN_INIT    (* 5 (+ MAXMAPLEN 3)))

;; Initialize typebuf.

(defn- #_void init-typebuf []
    (when (nil? (:tb_buf @typebuf))
        (swap! typebuf assoc
            :tb_buf (Bytes. TYPELEN_INIT)
            :tb_buflen TYPELEN_INIT
            :tb_len 0
            :tb_off 0
            :tb_change_cnt 1)
    )
    nil)

;; Insert a string in the typeahead buffer.

(defn- #_void ins-typebuf [#_Bytes str]
    (init-typebuf)
    (swap! typebuf update :tb_change_cnt inc)
    (if (zero? (:tb_change_cnt @typebuf))
        (swap! typebuf assoc :tb_change_cnt 1))
    (let [#_int addlen (STRLEN str)]
        ;; Easy case: there is room in front of typebuf.tb_buf[typebuf.tb_off].
        (cond (<= addlen (:tb_off @typebuf))
        (do
            (swap! typebuf update :tb_off - addlen)
            (BCOPY (:tb_buf @typebuf), (:tb_off @typebuf), str, 0, addlen)
        )
        :else
        ;; Need to allocate a new buffer.
        ;; In typebuf.tb_buf there must always be room for 3 * MAXMAPLEN + 4 characters.
        ;; We add some extra room to avoid having to allocate too often.
        (let [#_int newoff (+ MAXMAPLEN 4)
              #_int newlen (+ (:tb_len @typebuf) addlen newoff (* 4 (+ MAXMAPLEN 4)))
              #_Bytes newbuf (Bytes. newlen)]
            ;; copy the new chars
            (BCOPY newbuf, newoff, str, 0, addlen)
            ;; copy the old chars, after the insertion point, including the NUL at the end
            (BCOPY newbuf, (+ newoff addlen), (:tb_buf @typebuf), (:tb_off @typebuf), (inc (:tb_len @typebuf)))
            (swap! typebuf assoc :tb_buf newbuf :tb_buflen newlen :tb_off newoff)
        ))
        (swap! typebuf update :tb_len + addlen))
    nil)

;; Put character "c" back into the typeahead buffer.
;; Can be used for a character obtained by vgetc() that needs to be put back.
;; Uses keyTyped to restore the flags belonging to the char.

(defn- #_void ins-char-typebuf [#_int c]
    (let [#_Bytes buf (Bytes. (inc MB_MAXBYTES))]
        (if (is-special c)
            (-> buf (.be 0, KB_SPECIAL) (.be 1, (KB-SECOND c)) (.be 2, (KB-THIRD c)) (eos! 3))
            (eos! buf (utf-char2bytes c, buf)))
        (ins-typebuf buf))
    nil)

;; Return true if the typeahead buffer was changed (while waiting for a character to arrive).
;; Happens when a message was received from a client or from feedkeys().
;; But check in a more generic way to avoid trouble: When "typebuf.tb_buf"
;; changed it was reallocated and the old pointer can no longer be used.
;; Or "typebuf.tb_off" may have been changed and we would overwrite characters that was just added.

(defn- #_boolean typebuf-changed [#_int cnt]
    ;; cnt: old value of typebuf.tb_change_cnt
    (and (non-zero? cnt) (!= (:tb_change_cnt @typebuf) cnt)))

;; remove "len" characters from typebuf.tb_buf[typebuf.tb_off]

(defn- #_void del-typebuf [#_int len]
    (when (non-zero? len)
        (swap! typebuf update :tb_len - len)
        (if (<= (+ (* 3 MAXMAPLEN) 3) (- (:tb_buflen @typebuf) (+ (:tb_off @typebuf) len)))
            (swap! typebuf update :tb_off + len)
            (let [#_int i (:tb_off @typebuf)]
                ;; leave some extra room at the end to avoid reallocation
                (swap! typebuf update :tb_off min MAXMAPLEN)
                ;; adjust typebuf.tb_buf (include the NUL at the end)
                (BCOPY (:tb_buf @typebuf), (:tb_off @typebuf), (:tb_buf @typebuf), (+ i len), (inc (:tb_len @typebuf)))
            ))
        (swap! typebuf update :tb_change_cnt inc)
        (when (zero? (:tb_change_cnt @typebuf))
            (swap! typebuf assoc :tb_change_cnt 1)
        ))
    nil)

;; Write typed characters to script file.
;; If recording is on put the character in the recordbuffer.

(defn- #_void gotchars [#_Bytes chars, #_int len]
    (let [#_Bytes buf (Bytes. 2)]
        ;; Remember how many chars were last recorded.
        (when @Recording (swap! last_recorded_len + len))
        ;; Handle one byte at a time; no translation to be done.
        (dotimes [#_int i len]
            (let [#_byte c (.at chars i)]
                (updatescript c)
                (when @Recording (.be buf 0, c) (add-buff @recordbuff, buf, 1))
            ))
        (may-sync-undo)
        ;; Since characters have been typed, consider the following to be in another mapping.
        ;; Search string will be kept in history.
        (swap! maptick inc))
    nil)

;; Sync undo.  Called when typed characters are obtained from the typeahead
;; buffer, or when a menu is used.
;; Do not sync:
;; - In Insert mode, unless cursor key has been used.
;; - While reading a script file.
;; - When no_u_sync is non-zero.

(defn- #_void may-sync-undo []
    (when (or (non-flag? @State (+ INSERT CMDLINE)) @arrow_used)
        (u-sync false))
    nil)

(atom! int old_char         -1) ;; character put back by vungetc()
(atom! int old_mod_mask)        ;; mod_mask for ungotten character

;; This function is called just before doing a blocking wait.
;; Thus after waiting 'updatetime' for a character to arrive.

(defn- #_void before-blocking []
    (updatescript NUL)
    nil)

;; updatescipt() is called when a character can be written into the script file
;; or when we have waited some time for a character (c == 0)

(defn- #_void updatescript [#_byte c]
;   
    nil)

;; Get the next input character.
;; Can return a special key or a multi-byte character.
;; Can return NUL when called recursively, use safe-vgetc() if that's not wanted.
;; This translates escaped KB_SPECIAL bytes to a KB_SPECIAL byte.
;; Collects the bytes of a multibyte character into the whole character.
;; Returns the modifiers in the global "mod_mask".

(defn- #_int vgetc []
    (if (!= @old_char -1)
        (let [#_int c @old_char]
            ;; If a character was put back with vungetc, it was already processed.
            ;; Return it directly.
            (reset! old_char -1)
            (reset! mod_mask @old_mod_mask)
            c
        )
        (do
            (reset! mod_mask 0)
            (reset! last_recorded_len 0)

            (let [#_int c
                    (loop []                     ;; this is done twice if there are modifiers
                        (when (non-zero? @mod_mask) (swap! no_mapping inc) (swap! allow_keys inc)) ;; no mapping after modifier has been read
                        (let [c1 (vgetorpeek true)]
                            (when (non-zero? @mod_mask) (swap! no_mapping dec) (swap! allow_keys dec))
                            (if (== c1 (char_u KB_SPECIAL)) ;; get two extra bytes for special keys
                                (let [_ @allow_keys]
                                    (swap! no_mapping inc)
                                    (reset! allow_keys 0)                 ;; make sure BS is not found
                                    (let [c2 (vgetorpeek true) c3 (vgetorpeek true)] ;; no mapping for these chars
                                        (swap! no_mapping dec)
                                        (reset! allow_keys _)
                                        (if (== c2 (char_u KS_MODIFIER))
                                            (do (reset! mod_mask c3) (recur))
                                            (toSpecial (byte c2), (byte c3))
                                        )))
                                c1
                            )))

                  ;; a keypad or special function key was not mapped, use it like its ASCII equivalent
                  c (condp ==? c
                        K_KPLUS     (byte \+)
                        K_KMINUS    (byte \-)
                        K_KDIVIDE   (byte \/)
                        K_KMULTIPLY (byte \*)
                        K_KENTER    CAR
                        K_KPOINT    (byte \.)
                        K_K0        (byte \0)
                        K_K1        (byte \1)
                        K_K2        (byte \2)
                        K_K3        (byte \3)
                        K_K4        (byte \4)
                        K_K5        (byte \5)
                        K_K6        (byte \6)
                        K_K7        (byte \7)
                        K_K8        (byte \8)
                        K_K9        (byte \9)
                       [K_XHOME
                        K_ZHOME]    (cond (== @mod_mask MOD_MASK_SHIFT) (do (reset! mod_mask 0) K_S_HOME)
                                          (== @mod_mask MOD_MASK_CTRL)  (do (reset! mod_mask 0) K_C_HOME) :else K_HOME)
                       [K_XEND
                        K_ZEND]     (cond (== @mod_mask MOD_MASK_SHIFT) (do (reset! mod_mask 0) K_S_END)
                                          (== @mod_mask MOD_MASK_CTRL)  (do (reset! mod_mask 0) K_C_END)  :else K_END)
                        K_XUP       K_UP
                        K_XDOWN     K_DOWN
                        K_XLEFT     K_LEFT
                        K_XRIGHT    K_RIGHT
                    c)

                  #_int n (mb-byte2len c)]
                ;; For a multi-byte character get all the bytes and return the converted character.
                ;; Note: This will loop until enough bytes are received!
                (if (< 1 n)
                    (let [#_Bytes buf (Bytes. (inc MB_MAXBYTES))]
                        (.be buf 0, c)
                        (swap! no_mapping inc)
                        (loop-when-recur [i 1] (< i n) [(inc i)]
                            (.be buf i, (vgetorpeek true))
                            ;; Must be a KB_SPECIAL - KS_SPECIAL - KE_FILLER sequence, which represents a KB_SPECIAL (0x80).
                            (when (at? buf i KB_SPECIAL) (vgetorpeek true))
                        )
                        (swap! no_mapping dec)
                        (us-ptr2char buf)
                    )
                    c
                )
            ))
    ))

;; Like vgetc(), but never return a NUL when called recursively,
;; get a key directly from the user (ignoring typeahead).

(defn- #_int safe-vgetc []
    (let [#_int c (vgetc)] (if (== c NUL) (get-keystroke) c)))

;; Like safe-vgetc(), but loop to handle K_IGNORE.
;; Also ignore scrollbar events.

(defn- #_int plain-vgetc []
    (loop-when-recur [#_int c (safe-vgetc)] (any == c K_IGNORE K_VER_SCROLLBAR K_HOR_SCROLLBAR) [(safe-vgetc)] => c))

;; Check if a character is available, such that vgetc() will not block.
;; If the next character is a special character or multi-byte, the returned character is not valid!

(defn- #_int vpeekc []
    (if (!= @old_char -1) @old_char (vgetorpeek false)))

;; Call vpeekc() without causing anything to be mapped.
;; Return true if a character is available, false otherwise.

(defn- #_boolean char-avail []
    (swap! no_mapping inc) (let [#_int c (vpeekc)] (swap! no_mapping dec) (!= c NUL)))

;; unget one character (can only be done once!)
(defn- #_void vungetc [#_int c]
    (reset! old_char c)
    (reset! old_mod_mask @mod_mask)
    nil)

(atom! int __tc)

;; Get a character:
;; 1. from the stuffbuffer
;;      This is used for abbreviated commands like "D" -> "d$".
;;      Also used to redo a command for ".".
;; 2. from the typeahead buffer
;;      Stores text obtained previously but not used yet.
;;      Also stores the result of mappings.
;;      Also used for the ":normal" command.
;; 3. from the user
;;      This may do a blocking wait if "advance" is true.
;;
;; If "advance" is true (vgetc()):
;;      Really get the character.
;;      keyTyped is set to true in the case the user typed the key.
;;      keyStuffed is true if the character comes from the stuff buffer.
;; If "advance" is false (vpeekc()):
;;      Just look whether there is a character available.
;;
;; When "no_mapping" is zero, checks for mappings in the current mode.
;; Only returns one byte (of a multi-byte character).
;; KB_SPECIAL may be escaped, need to get two more bytes then.

(defn- #_int vgetorpeek [#_boolean advance]
    ;; This function doesn't work very well when called recursively.
    ;; It may happen though, because of:
    ;;
    ;; 1. The call to add-to-showcmd(). char-avail() is then used to check
    ;; if there is a character available, which calls this function.
    ;; In that case we must return NUL, to indicate no character is available.
    ;;
    ;; 2. A GUI callback function writes to the screen, causing a wait-return().
    ;; Using ":normal" can also do this, but it saves the typeahead buffer,
    ;; thus it should be OK.  But don't get a key from the user then.
    (if (pos? @vgetc_busy)
        NUL
        (do (swap! vgetc_busy inc)
            (when advance
                (reset! keyStuffed false))
            (init-typebuf)
            (start-stuff)
            (when advance
                (reset! execReg false))
            (let [a'timedout (atom (boolean false))       ;; waited for more than 1 second for mapping to complete
                  a'mode_deleted (atom (boolean false))   ;; set when mode has been deleted
                  #_int c (loop []
                    ;; get a character: 1. from the stuffbuffer
                    (let [c (if (non-zero? @typeahead_char)
                                (let [c @typeahead_char] (when advance (reset! typeahead_char 0)) c)
                                (char_u (read-readbuffers advance)))
                          c (if (and (!= c NUL) (not @got_int))
                                (do (when advance
                                        ;; keyTyped = false;
                                        ;; When the command that stuffed something was typed,
                                        ;; behave like the stuffed command was typed;
                                        ;; needed e.g. for CTRL-W CTRl-] to open a fold.
                                        (reset! keyStuffed true))
                                    c)
                                ;; Loop until we either find a matching mapped key,
                                ;; or we are sure that it is not a mapped key.
                                ;; If a mapped key sequence is found, we go back to the start to try re-mapping.
                                (loop []
                                    (ui-breakcheck)            ;; check for CTRL-C
                                    (cond @got_int
                                        (let [#_int len (inchar (:tb_buf @typebuf), (dec (:tb_buflen @typebuf)), 0, (:tb_change_cnt @typebuf)) ;; flush all input
                                              ;; If inchar() returns true (script file was active)
                                              ;; or we are inside a mapping, get out of insert mode.
                                              ;; Otherwise we behave like having gotten a CTRL-C.
                                              ;; As a result typing CTRL-C in insert mode will really insert a CTRL-C.
                                              c (if (and (non-zero? len) (flag? @State (+ INSERT CMDLINE))) ESC Ctrl_C)]
                                            (flush-buffers true)        ;; flush all typeahead
                                            (when advance
                                                ;; Also record this character, it might be needed to get out of Insert mode.
                                                (.be (:tb_buf @typebuf) 0, c)
                                                (gotchars (:tb_buf @typebuf), 1))
                                            c)
                                    :else

                                        (ยง
                                            ((ร int keylen =) (if (< 0 (:tb_len @typebuf))
                                                ;; When no matching mapping found or found a non-matching mapping
                                                ;; that matches at least what the matching mapping matched:
                                                ;; Check if we have a terminal code, when:
                                                ;; - mapping is allowed,
                                                ;; - keys have not been mapped,
                                                ;; - and when not timed out.
                                                (let [keylen
                                                        (if (and (or (zero? @no_mapping) (non-zero? @allow_keys)) (not @a'timedout))
                                                            (let [keylen (check-termcode nil, 0, nil)]
                                                                ;; When getting a partial match, but the last characters were not typed,
                                                                ;; don't wait for a typed character to complete the termcode.
                                                                ;; This helps a lot when a ":normal" command ends in an ESC.
                                                                (if (and (< keylen 0) (zero? (:tb_len @typebuf))) 0 keylen))
                                                            0)]
                                                    (cond (zero? keylen)        ;; no matching terminal code
                                                        ;; get a character: 2. from the typeahead buffer
                                                        (let [c (& (.at (:tb_buf @typebuf) (:tb_off @typebuf)) 0xff)]
                                                            (when advance    ;; remove chars from tb_buf
                                                                (reset! keyTyped true)
                                                                ;; write char to script file(s)
                                                                (gotchars (.plus (:tb_buf @typebuf) (:tb_off @typebuf)), 1)
                                                                (del-typebuf 1))
                                                            (ร BREAK)          ;; got character, break for loop
                                                        )
                                                    (< 0 keylen)         ;; full matching terminal code
                                                        (ร CONTINUE)           ;; try mapping again
                                                    :else
                                                        ;; Partial match: get some more characters.
                                                        KEYLEN_PART_KEY
                                                    ))
                                                0
                                            ))

                                            ;; get a character: 3. from the user - handle <Esc> in Insert mode

                                            ;; Special case: if we get an <ESC> in insert mode and there are no more
                                            ;; characters at once, we pretend to go out of insert mode.  This prevents
                                            ;; the one second delay after typing an <ESC>.  If we get something after
                                            ;; all, we may have to redisplay the mode.  That the cursor is in the wrong
                                            ;; place does not matter.

                                            ((ร int len =) 0)
                                            ((ร int new_wcol =) (:w_wcol @curwin))
                                            ((ร int new_wrow =) (:w_wrow @curwin))
                                            (when (and advance (== (:tb_len @typebuf) 1) (at? (:tb_buf @typebuf) (:tb_off @typebuf) ESC) (zero? @no_mapping) (flag? @State INSERT) (or @p_timeout (and (== keylen KEYLEN_PART_KEY) @p_ttimeout)) (zero? ((ร len =) (inchar (.plus (:tb_buf @typebuf) (+ (:tb_off @typebuf) (:tb_len @typebuf))), 3, 25, (:tb_change_cnt @typebuf)))))
                                                (when @mode_displayed
                                                    (unshowmode true)
                                                    (reset! a'mode_deleted true))
                                                (swap! curwin validate-cursor)
                                                ((ร int o'wcol =) (:w_wcol @curwin))
                                                ((ร int o'wrow =) (:w_wrow @curwin))

                                                ;; move cursor left, if possible
                                                (when (non-zero? (:col (:w_cursor @curwin)))
                                                    ((ร int col =) 0)
                                                    (cond (< 0 (:w_wcol @curwin))
                                                    (do
                                                        (cond @did_ai
                                                        (do
                                                            ;; We are expecting to truncate the trailing white-space,
                                                            ;; so find the last non-white character.
                                                            (reset! curwin assoc :w_wcol 0)
                                                            ((ร Bytes s =) (ml-get (:lnum (:w_cursor @curwin))))
                                                            (loop-when-recur [#_int vcol 0 #_int i 0] (< i (:col (:w_cursor @curwin))) [(+ vcol (lbr-chartabsize s, (.plus s i), vcol)) (+ i (us-ptr2len-cc s, i))]
                                                                (when (not (vim-iswhite (.at s i)))
                                                                    (swap! curwin assoc :w_wcol vcol))
                                                            )
                                                            (swap! curwin assoc :w_wrow (+ (:w_cline_row @curwin) (/ (:w_wcol @curwin) (:w_width @curwin))))
                                                            (swap! curwin update :w_wcol % (:w_width @curwin))
                                                            (swap! curwin update :w_wcol + (win-col-off @curwin))
                                                            ((ร col =) 0)        ;; no correction needed
                                                        )
                                                        :else
                                                        (do
                                                            (swap! curwin update :w_wcol dec)
                                                            ((ร col =) (dec (:col (:w_cursor @curwin))))
                                                        ))
                                                    )
                                                    (and @(:wo_wrap (:w_options @curwin)) (< 0 (:w_wrow @curwin)))
                                                    (do
                                                        (swap! curwin update :w_wrow dec)
                                                        (swap! curwin assoc :w_wcol (dec (:w_width @curwin)))
                                                        ((ร col =) (dec (:col (:w_cursor @curwin))))
                                                    ))

                                                    (when (and (< 0 col) (< 0 (:w_wcol @curwin)))
                                                        ;; Correct when the cursor is on the right halve of a double-wide character.
                                                        ((ร Bytes s =) (ml-get (:lnum (:w_cursor @curwin))))
                                                        ((ร col =) (- col (us-head-off s, (.plus s col))))
                                                        (when (< 1 (us-ptr2cells s, col))
                                                            (swap! curwin update :w_wcol dec))
                                                    )
                                                )
                                                (setcursor)
                                                (out-flush)
                                                ((ร new_wcol =) (:w_wcol @curwin))
                                                ((ร new_wrow =) (:w_wrow @curwin))
                                                (swap! curwin assoc :w_wcol o'wcol)
                                                (swap! curwin assoc :w_wrow o'wrow)
                                            )

                                            (if (< len 0)
                                                (ร CONTINUE)   ;; end of input script reached
                                            )

                                            (swap! typebuf update :tb_len + len)

                                            ;; buffer full, don't map
                                            (when (<= MAXMAPLEN (:tb_len @typebuf))
                                                (reset! a'timedout true)
                                                (ร CONTINUE)
                                            )

                                            ;; get a character: 3. from the user - update display

                                            ;; In insert mode a screen update is skipped when characters are still available.
                                            ;; But when those available characters are part of a mapping, and we are going
                                            ;; to do a blocking wait here.  Need to update the screen to display the changed
                                            ;; text so far.  Also for when 'lazyredraw' is set and redrawing was postponed
                                            ;; because there was something in the input buffer (e.g., termresponse).

                                            (when (and (or (flag? @State INSERT) @p_lz) (non-flag? @State CMDLINE) advance (non-zero? @must_redraw) (not @need_wait_return))
                                                (update-screen 0)
                                                (setcursor)            ;; put cursor back where it belongs
                                            )

                                            ;; If we have a partial match (and are going to wait for more input from the user),
                                            ;; show the partially matched characters to the user with showcmd.

                                            ((ร int i =) 0)
                                            ((ร int c1 =) 0)
                                            (when (and (< 0 (:tb_len @typebuf)) advance)
                                                (when (and (flag? @State (| NORMAL INSERT)) (!= @State HITRETURN))
                                                    ;; this looks nice when typing a dead character map
                                                    (when (and (flag? @State INSERT) (== (mb-ptr2cells (:tb_buf @typebuf), (dec (+ (:tb_off @typebuf) (:tb_len @typebuf)))) 1))
                                                        (swap! curwin edit-putchar (.at (:tb_buf @typebuf) (dec (+ (:tb_off @typebuf) (:tb_len @typebuf)))), false)
                                                        (setcursor)    ;; put cursor back where it belongs
                                                        ((ร c1 =) 1)
                                                    )
                                                    ;; need to use the col and row from above here
                                                    ((ร int o'wcol =) (:w_wcol @curwin))
                                                    ((ร int o'wrow =) (:w_wrow @curwin))
                                                    (swap! curwin assoc :w_wcol new_wcol)
                                                    (swap! curwin assoc :w_wrow new_wrow)
                                                    (push-showcmd)
                                                    ((ร i =) (if (< SHOWCMD_COLS (:tb_len @typebuf)) (- (:tb_len @typebuf) SHOWCMD_COLS) i))
                                                    ((ร i =) (loop-when-recur i (< i (:tb_len @typebuf)) (inc i) => i
                                                        (add-to-showcmd (.at (:tb_buf @typebuf) (+ (:tb_off @typebuf) i)))
                                                    ))
                                                    (swap! curwin assoc :w_wcol o'wcol)
                                                    (swap! curwin assoc :w_wrow o'wrow)
                                                )

                                                ;; this looks nice when typing a dead character map
                                                (when (and (flag? @State CMDLINE) (== (mb-ptr2cells (:tb_buf @typebuf), (dec (+ (:tb_off @typebuf) (:tb_len @typebuf)))) 1))
                                                    (putcmdline (.at (:tb_buf @typebuf) (dec (+ (@typebuf.tb_off) (@typebuf.tb_len)))), false)
                                                    ((ร c1 =) 1)
                                                )
                                            )

                                            ;; get a character: 3. from the user - get it

                                            ((ร int wait_tb_len =) (:tb_len @typebuf))
                                            ((ร len =) (inchar (.plus (:tb_buf @typebuf) (+ (:tb_off @typebuf) (:tb_len @typebuf))), (- (:tb_buflen @typebuf) (:tb_off @typebuf) (:tb_len @typebuf) 1), (if (not advance) 0 (if (or (zero? (:tb_len @typebuf)) (not (or @p_timeout (and @p_ttimeout (== keylen KEYLEN_PART_KEY))))) -1 (if (and (== keylen KEYLEN_PART_KEY) (<= 0 @p_ttm)) @p_ttm @p_tm))), (:tb_change_cnt @typebuf)))

                                            (if (non-zero? i)
                                                (pop-showcmd))
                                            (when (== c1 1)
                                                (if (flag? @State INSERT)
                                                    (swap! curwin edit-unputchar))
                                                (if (flag? @State CMDLINE)
                                                    (unputcmdline)
                                                    (setcursor))            ;; put cursor back where it belongs
                                            )

                                            (if (< len 0)
                                                (ร CONTINUE)                   ;; end of input script reached
                                            )

                                            (cond (zero? len)                   ;; no character available
                                            (do
                                                (when (not advance)
                                                    ((ร c =) NUL)
                                                    (ร BREAK)
                                                )
                                                (when (< 0 wait_tb_len)        ;; timed out
                                                    (reset! a'timedout true)
                                                    (ร CONTINUE)
                                                )
                                            )
                                            :else
                                            (do
                                                (while (non-eos? (:tb_buf @typebuf) (+ (:tb_off @typebuf) (:tb_len @typebuf)))
                                                    (swap! typebuf update :tb_len inc))
                                            ))

                                            (recur)
                                        )

                                    ))
                            )]
                        (recur-if (or (< c 0) (and advance (== c NUL))) [] => c)   ;; if advance is false don't loop on NULs
                    ))]
                ;; The "INSERT" message is taken care of here:
                ;;   if we return an ESC to exit insert mode, the message is deleted;
                ;;   if we don't return an ESC, but deleted the message before, redisplay it.
                (when (and advance @p_smd (flag? @State INSERT))
                    (cond (and (== c ESC) (not @a'mode_deleted) (zero? @no_mapping) @mode_displayed)
                        (if (and (non-zero? (:tb_len @typebuf)) (not @keyTyped))
                            (reset! redraw_cmdline true)          ;; delete mode later
                            (unshowmode false))
                    (and (!= c ESC) @a'mode_deleted)
                        (if (and (non-zero? (:tb_len @typebuf)) (not @keyTyped))
                            (reset! redraw_cmdline true)          ;; show mode later
                            (showmode))
                    ))
                (swap! vgetc_busy dec)
            c))
    ))

;; inchar() - get one character from
;;      1. a scriptfile
;;      2. the keyboard
;;
;; As much characters as we can get (upto 'maxlen') are put in "buf" and
;; NUL terminated (buffer length must be 'maxlen' + 1).
;; Minimum for "maxlen" is 3!!!!
;;
;; "tb_change_cnt" is the value of typebuf.tb_change_cnt if "buf" points into it.
;; When typebuf.tb_change_cnt changes (e.g., when a message is received from
;; a remote client) "buf" can no longer be used.  "tb_change_cnt" is 0 otherwise.
;;
;; If we got an interrupt all input is read until none is available.
;;
;; If wait_time == 0  there is no waiting for the char.
;; If wait_time == n  we wait for n msec for a character to arrive.
;; If wait_time == -1 we wait forever for a character to arrive.
;;
;; Return the number of obtained characters.
;; Return -1 when end of input script reached.

(defn- #_int inchar [#_Bytes buf, #_int maxlen, #_long wait_time, #_int tb_change_cnt]
    ;; wait_time: milli seconds
    (when (or (== wait_time -1) (< 100 wait_time))   ;; flush output before waiting
        (cursor-on)
        (out-flush))
    ;; If we got an interrupt, skip all previously typed characters and return true if quit reading script file.
    ;; Stop reading typeahead when a single CTRL-C was read, fill-input-buf() returns this when not able to read from stdin.
    ;; Don't use *buf here, closescript() may have freed typebuf.tb_buf[] and "buf" may be pointing inside typebuf.tb_buf[].
    (if @got_int
        (let [#_final #_int DUM_LEN (+ (* MAXMAPLEN 3) 3) #_Bytes dum (Bytes. (inc DUM_LEN)) #_boolean retesc false] ;; return ESC with gotint
            (loop [] (let [#_int n (ui-inchar dum, DUM_LEN, 0, 0)] (if (or (zero? n) (and (== n 1) (at? dum Ctrl_C))) (if retesc 1 0) (recur)))))
        (do ;; Always flush the output characters when getting input characters from the user.
            (out-flush)
            ;; Fill up to a third of the buffer, because each character may be tripled below.
            (let [#_int len (ui-inchar buf, (/ maxlen 3), wait_time, tb_change_cnt)]
                (if (typebuf-changed tb_change_cnt) 0 (fix-input-buffer buf, len))
            ))
    ))

;; Fix typed characters for use by vgetc() and check-termcode().
;; buf[] must have room to triple the number of bytes!
;; Returns the new length.

(defn- #_int fix-input-buffer [#_Bytes buf, #_int len]
    ;; Two characters are special: NUL and KB_SPECIAL.
    ;; Replace        NUL by KB_SPECIAL KS_ZERO    KE_FILLER
    ;; Replace KB_SPECIAL by KB_SPECIAL KS_SPECIAL KE_FILLER
    (loop [#_Bytes p buf #_int n len #_int i (dec n)] (if (<= 0 i)
        ;; timeout may generate K_CURSORHOLD
        (if (or (eos? p) (and (at? p KB_SPECIAL) (or (< i 2) (not-at? p 1 KS_EXTRA) (not-at? p 2 KE_CURSORHOLD))))
            (do
                (BCOPY p, 3, p, 1, i)
                (let [c (char_u (.at p 0))] (-> p (.be 2, (KB-THIRD c)) (.be 1, (KB-SECOND c)) (.be 0, KB_SPECIAL)))
                (recur (.plus p 3) (+ n 2) (dec i))
            )
            (recur (.plus p 1) n (dec i)))
        (do (eos! p) n))
    ))

;; Return true when bytes are in the input buffer or in the typeahead buffer.

(defn- #_boolean input-available []
    (not (is-input-buf-empty)))

;; Escape KB_SPECIAL so that the result can be put in the typeahead buffer.

(defn- #_Bytes vim-strsave-escape-special [#_Bytes p]
    ;; Need a buffer to hold up to three times as much.
    (let [#_Bytes res (Bytes. (inc (* (STRLEN p) 3)))]
        (loop [#_Bytes d res #_Bytes s p] (if (non-eos? s)
            (if (and (at? s KB_SPECIAL) (non-eos? s 1) (non-eos? s 2))
            (do
                ;; Copy special key unmodified.
                (.be d 0, (.at s 0)) (.be d 1, (.at s 1)) (.be d 2, (.at s 2))
                (recur (.plus d 3) (.plus s 3))
            )
            (let [#_int end (us-ptr2len-cc s)
                ;; Add character, possibly multi-byte to destination, escaping KB_SPECIAL.
                  d (loop [#_int c (us-ptr2char s) d (add-char2buf c, d) #_int n (utf-char2len c)] (if (< n end)
                    ;; Add following combining char.
                    (recur (us-ptr2char s, n) (add-char2buf c, d) (+ n (utf-char2len c)))
                    d))]
                (recur d (.plus s end))
            ))
            (eos! d)
        ))
        res
    ))

;; Remove escaping from KB_SPECIAL characters.
;; Reverse of vim-strsave-escape-special().
;; Works in-place.

(defn- #_void vim-unescape-special [#_Bytes p]
    (loop [#_Bytes d p #_Bytes s p] (if (non-eos? s)
        (let [n (if (and (at? s KB_SPECIAL) (at? s 1 KS_SPECIAL) (at? s 2 KE_FILLER)) 3 1)]
            (recur (.plus (.be d 0, (.at s 0)) 1) (.plus s n)))
        (eos! d)
    ))
    nil)

;;; ============================================================================================== VimM

;; edit.c: functions for Insert mode --------------------------------------------------------------

(final int
    BACKSPACE_CHAR           1,
    BACKSPACE_WORD           2,
    BACKSPACE_WORD_NOT_SPACE 3,
    BACKSPACE_LINE           4)

(atom! int      insStart_textlen)               ;; length of line when insert started
(atom! int      insStart_blank_vcol)            ;; vcol for first inserted blank
(atom! boolean  update_insStart_orig    true)   ;; set insStart_orig to insStart

(atom! Bytes    last_insert)                    ;; the text of the previous insert, KB_SPECIAL is escaped
(atom! int      last_insert_skip)               ;; nr of chars in front of previous insert
(atom! int      new_insert_skip)                ;; nr of chars in front of current insert
(atom! int      did_restart_edit)               ;; "restart_edit" when calling edit()

(atom! boolean  can_cindent)                    ;; may do cindenting on this line

(atom! int      old_indent)                     ;; for ^^D command in insert mode

(atom! boolean  ins_need_undo)                  ;; call u-save() before inserting a char; set when edit() is called; after that arrow_used is used

(atom! long     o_lnum)

;; edit(): Start inserting text.
;;
;; "cmdchar" can be:
;; 'i'  normal insert command
;; 'a'  normal append command
;; 'R'  replace command
;; 'r'  "r<CR>" command: insert one <CR>.  Note: count can be > 1, for redo,
;;      but still only one <CR> is inserted.  The <Esc> is not used for redo.
;; 'g'  "gI" command.
;; 'V'  "gR" command for Virtual Replace mode.
;; 'v'  "gr" command for single character Virtual Replace mode.
;;
;; This function is not called recursively.  For CTRL-O commands, it returns
;; and lets the caller handle the Normal-mode command.
;;
;; Return true if a CTRL-O command caused the return (insert mode pending).

(defn- #_boolean edit [#_int cmdchar, #_boolean startln, #_long _count]
    ;; startln: if set, insert at start of line
    (let [a'count (atom (long _count))]
        ;; Remember whether editing was restarted after CTRL-O.
        (reset! did_restart_edit @restart_edit)
        ;; sleep before redrawing, needed for "CTRL-O :" that results in an error message
        (check-for-delay true)
        ;; set insStart_orig to insStart
        (reset! update_insStart_orig true)
        ;; Don't allow changes in the buffer while editing the cmdline.
        ;; The caller of getcmdline() may get confused.
        (cond (non-zero? @textlock)
            (do (emsg e_secure) false)
        :else
        (do ;; Check if the cursor line needs redrawing before changing State.
            ;; If 'concealcursor' is "n", it needs to be redrawn without concealing.
            (swap! curwin conceal-check-cursor-line)
            ;; When doing a paste with the middle mouse button,
            ;; insStart is set to where the paste started.
            (if (non-zero? (:lnum @where_paste_started))
                (reset! insStart @where_paste_started)
                (do
                    (reset! insStart (:w_cursor @curwin))
                    (when startln
                        (swap! insStart assoc :col 0))
                ))
            (reset! insStart_textlen (linetabsize (ml-get (:lnum (:w_cursor @curwin)))))
            (reset! insStart_blank_vcol MAXCOL)
            (when (not @did_ai)
                (reset! ai_col 0))
            (when (and (!= cmdchar NUL) (zero? @restart_edit))
                (reset-redo)
                (append-redo-number @a'count)
                (if (any == cmdchar (byte \V) (byte \v))
                    (do ;; "gR" or "gr" command
                        (append-redo-char (byte \g))
                        (append-redo-char (if (== cmdchar (byte \v)) (byte \r) (byte \R))))
                    (do
                        (append-redo-char cmdchar)
                        (cond
                            (== cmdchar (byte \g)) (append-redo-char (byte \I)) ;; "gI" command
                            (== cmdchar (byte \r)) (reset! a'count 1)           ;; "r<CR>" command ;; insert only one <CR>
                        ))
                ))
            (let [#_int replaceState
                    (cond (== cmdchar (byte \R))
                        (do (reset! State REPLACE)
                            REPLACE)
                    (any == cmdchar (byte \V) (byte \v))
                        (do (reset! State VREPLACE)
                            (reset! orig_line_count (line-count @curbuf))
                            (reset! vr_lines_changed 1)
                            VREPLACE)
                    :else
                        (do (reset! State INSERT)
                            REPLACE)
                    )]
                (reset! stop_insert_mode false)
                ;; Need to recompute the cursor position,
                ;; it might move when the cursor is on a TAB or special character.
                (swap! curwin curs-columns true)
                (clear-showcmd @curwin)
                ;; Handle restarting Insert mode.
                ;; Don't do this for "CTRL-O ." (repeat an insert):
                ;; we get here with restart_edit non-zero, and something in the stuff buffer.
                (cond (and (non-zero? @restart_edit) (stuff-empty))
                (do ;; After a paste we consider text typed to be part of the insert for
                    ;; the pasted text.  You can backspace over the pasted text too.
                    (reset! arrow_used (zero? (:lnum @where_paste_started)))
                    (reset! restart_edit 0)
                    ;; If the cursor was after the end-of-line before the CTRL-O and it is
                    ;; now at the end-of-line, put it after the end-of-line (this is not
                    ;; correct in very rare cases).
                    ;; Also do this if curswant is greater than the current virtual column.
                    ;; E.g. after "^O$" or "^O80|".
                    (swap! curwin validate-virtcol)
                    (swap! curwin update-curswant)
                    (when (or (and @ins_at_eol (== (:lnum (:w_cursor @curwin)) @o_lnum)) (< (:w_virtcol @curwin) (:w_curswant @curwin)))
                        (let-when [#_Bytes s (.plus (ml-get (:lnum (:w_cursor @curwin))) (:col (:w_cursor @curwin)))] (non-eos? s)
                            (if (eos? s 1)
                                (swap! curwin update-in [:w_cursor :col] inc)
                                (let-when [#_int n (us-ptr2len-cc s)] (eos? s n)
                                    (swap! curwin update-in [:w_cursor :col] + n)
                                ))
                        ))
                    (reset! ins_at_eol false))
                :else
                    (reset! arrow_used false))
                ;; We are in insert mode now, don't need to start it anymore.
                (reset! need_start_insertmode false)
                ;; Need to save the line for undo before inserting the first char.
                (reset! ins_need_undo true)
                (swap! where_paste_started assoc :lnum 0)
                (reset! can_cindent true)
                ;; If 'showmode' is set, show the current (insert/replace/...) mode.
                ;; A warning message for changing a readonly file is given here, before
                ;; actually changing anything.  It's put after the mode, if any.
                (when @p_smd (showmode))
                (ui-cursor-shape)           ;; may show different cursor shape
                (do-digraph -1)             ;; clear digraphs
                ;; Get the current length of the redo buffer,
                ;; those characters have to be skipped if we want to get to the inserted characters.
                (let [#_Bytes s (get-inserted)]
                    (reset! new_insert_skip (if (some? s) (STRLEN s) 0)))
                (reset! old_indent 0)
                (let [a'inserted_space (atom (boolean false))   ;; just inserted a space
                      a'did_backspace (atom (boolean true))     ;; previous char was backspace
                      a'old_topline (atom (long 0))             ;; topline before insertion
                      a'nomove (atom (boolean false))]          ;; don't move cursor on return

                    ;; Main loop in Insert mode: repeat until Insert mode is left.
                (ยง
                    (loop [#_int lastc 0 #_int c 0]
                        (when @arrow_used     ;; don't repeat insert when arrow key used
                            (reset! a'count 0))

                        (when @update_insStart_orig
                            (reset! insStart_orig @insStart))

;                       doESCkey:
;                       {
                            (when @stop_insert_mode
                                ;; ":stopinsert" used or 'insertmode' reset
                                (reset! a'count 0)
                                (ร BREAK doESCkey)
                            )

                            ;; set curwin.w_curswant for next K_DOWN or K_UP
                            (when (not @arrow_used)
                                (swap! curwin assoc :w_set_curswant true))

                            ;; When emsg() was called msg_scroll will have been set.

                            (reset! msg_scroll false)

                            ;; If we inserted a character at the last position of the last line in the window,
                            ;; scroll the window one line up.  This avoids an extra redraw.
                            ;; This is detected when the cursor column is smaller after inserting something.
                            ;; Don't do this when the topline changed already,
                            ;; it has already been adjusted (by insert-char() calling open-line()).

                            (when (and (:b_mod_set @curbuf) @(:wo_wrap (:w_options @curwin)) (not @a'did_backspace) (== (:w_topline @curwin) @a'old_topline))
                                (let [#_int mincol (:w_wcol @curwin)]
                                    (swap! curwin validate-cursor-col)
                                    (when (and (< (:w_wcol @curwin) (- mincol @(:b_p_ts @curbuf)))
                                               (== (:w_wrow @curwin) (- (dec (+ (:w_winrow @curwin) (:w_height @curwin))) @p_so))
                                               (!= (:lnum (:w_cursor @curwin)) (:w_topline @curwin)))
                                        ((ร @curwin =) (set-topline @curwin, (inc (:w_topline @curwin)))))
                                ))

                            ;; May need to adjust "w_topline" to show the cursor.
                            (swap! curwin update-topline)

                            (reset! a'did_backspace false)

                            (swap! curwin validate-cursor)              ;; may set must_redraw

                            ;; Redraw the display when no characters are waiting.
                            ;; Also shows mode, ruler and positions cursor.

                            (swap! curwin ins-redraw true)

                            (when @(:wo_scb (:w_options @curwin))
                                (swap! curwin do-check-scrollbind true))

                            (when @(:wo_crb (:w_options @curwin))
                                (do-check-cursorbind))
                            (swap! curwin update-curswant)
                            (reset! a'old_topline (:w_topline @curwin))

                            ;; Get a character for Insert mode.  Ignore K_IGNORE.

                            ((ร lastc =) (if (!= c K_CURSORHOLD) c lastc))          ;; remember the previous char for CTRL-D
                            ((ร c =) (loop [] (let [c (safe-vgetc)] (recur-if (== c K_IGNORE) [] => c))))

                            ;; Don't want K_CURSORHOLD for the second key, e.g., after CTRL-V.
                            (reset! did_cursorhold true)

                            ;; CTRL-\ CTRL-N goes to Normal mode,
                            ;; CTRL-\ CTRL-G goes to mode selected with 'insertmode',
                            ;; CTRL-\ CTRL-O is like CTRL-O but without moving the cursor.
                            (when (== c Ctrl_BSL)
                                ;; may need to redraw when no more chars available now
                                (swap! curwin ins-redraw false)

                                (swap! no_mapping inc)
                                (swap! allow_keys inc)
                                ((ร c =) (plain-vgetc))
                                (swap! no_mapping dec)
                                (swap! allow_keys dec)

                                (cond (and (!= c Ctrl_N) (!= c Ctrl_G) (!= c Ctrl_O))
                                (do
                                    ;; it's something else
                                    (vungetc c)
                                    ((ร c =) Ctrl_BSL)
                                )
                                (and (== c Ctrl_G) @p_im)
                                (do
                                    (ร CONTINUE)
                                )
                                :else
                                (do
                                    (when (== c Ctrl_O)
                                        (ins-ctrl-o @curwin)
                                        (reset! ins_at_eol false) ;; cursor keeps its column
                                        (reset! a'nomove true)
                                    )
                                    (reset! a'count 0)
                                    (ร BREAK doESCkey)
                                ))
                            )

                            ((ร c =) (do-digraph c))

                            (when (any == c Ctrl_V Ctrl_Q)
                                (swap! curwin ins-ctrl-v)
                                ((ร c =) Ctrl_V)         ;; pretend CTRL-V is last typed character
                                (ร CONTINUE)
                            )

                            ;; If 'keymodel' contains "startsel", may start selection.
                            ;; If it does, a CTRL-O and c will be stuffed, we need to get these characters.

                            (if (let [[_ ?] (ins-start-select? @curwin, c)] (reset! curwin _) ?)
                                (ร CONTINUE)
                            )

;                           normalchar:
;                           {
                                ;; The big switch to handle a character in insert mode.

                                (condp ==? c
                                    ESC                           ;; end input mode
                                    (do
                                        (ร FALLTHROUGH)
                                    )

                                    Ctrl_C                        ;; end input mode
                                    (do
                                        (when (and (== c Ctrl_C) (non-zero? @cmdwin_type))
                                            ;; Close the cmdline window.
                                            (reset! cmdwin_result K_IGNORE)
                                            (reset! got_int false)            ;; don't stop executing autocommands et al.
                                            (reset! a'nomove true)
                                            (ร BREAK doESCkey)
                                        )

                                        ;; When 'insertmode' set, and not halfway a mapping, don't leave Insert mode.
                                        (when (goto-im)
                                            (cond @got_int
                                            (do
                                                (vgetc)                ;; flush all buffers
                                                (reset! got_int false)
                                            )
                                            :else
                                            (do
                                                (vim-beep)
                                            ))
                                            (ร BREAK normalchar)
                                        )
                                        (ร BREAK doESCkey)
                                    )

                                    Ctrl_Z                        ;; suspend when 'insertmode' set
                                    (do
                                        (if (not @p_im)
                                            (ร BREAK)            ;; insert CTRL-Z as normal char
                                        )
                                        (stuff-string (u8 ":st\r"))
                                        ((ร c =) Ctrl_O)
                                        (ร FALLTHROUGH)
                                    )

                                    Ctrl_O                        ;; execute one command
                                    (do
                                        (ins-ctrl-o @curwin)

                                        ;; Don't move the cursor left when 'virtualedit' has "onemore".
                                        (when (flag? @ve_flags VE_ONEMORE)
                                            (reset! ins_at_eol false)
                                            (reset! a'nomove true)
                                        )
                                        (reset! a'count 0)
                                        (ร BREAK doESCkey)
                                    )

                                   [K_INS K_KINS]                         ;; toggle insert/replace mode
                                    (do
                                        (ins-insert replaceState)
                                        (ร BREAK normalchar)
                                    )

                                    K_SELECT                      ;; end of Select mode mapping - ignore
                                    (do
                                        (ร BREAK normalchar)
                                    )

                                   [K_HELP K_F1 K_XF1]                        ;; Help key works like <ESC> <Help>
                                    (do
                                        (stuff-char K_HELP)
                                        (when @p_im
                                            (reset! need_start_insertmode true))
                                        (ร BREAK doESCkey)
                                    )

                                   [K_ZERO NUL Ctrl_A]                        ;; insert the previously inserted text
                                    (do
                                        ;; For ^@ the trailing ESC will end the insert, unless there is an error.
                                        (if (and (not (stuff-inserted NUL, 1, (== c Ctrl_A))) (!= c Ctrl_A) (not @p_im))
                                            (ร BREAK doESCkey)             ;; quit insert mode
                                        )
                                        (reset! a'inserted_space false)
                                        (ร BREAK normalchar)
                                    )

                                    Ctrl_R                        ;; insert the contents of a register
                                    (do
                                        (swap! curwin ins-reg)
                                        (reset! a'inserted_space false)
                                        (ร BREAK normalchar)
                                    )

                                    Ctrl_G                        ;; commands starting with CTRL-G
                                    (do
                                        (swap! curwin ins-ctrl-g)
                                        (ร BREAK normalchar)
                                    )

                                    Ctrl_HAT                      ;; switch input mode and/or langmap
                                    (do
                                        (ins-ctrl-hat)
                                        (ร BREAK normalchar)
                                    )

                                    Ctrl__                        ;; switch between languages
                                    (do
                                        (ร BREAK)
                                    )

                                   [Ctrl_D Ctrl_T]                        ;; make indent one shiftwidth smaller/greater
                                    (do
                                        (swap! curwin ins-shift c, lastc)
                                        (reset! a'inserted_space false)
                                        (ร BREAK normalchar)
                                    )

                                   [K_DEL K_KDEL]                        ;; delete character under the cursor
                                    (do
                                        (swap! curwin ins-del)
                                        (ร BREAK normalchar)
                                    )

                                   [K_BS Ctrl_H]                         ;; delete character before the cursor
                                    (do
                                        (reset! a'did_backspace (let [[_ ?] (ins-bs? @curwin, c, BACKSPACE_CHAR, a'inserted_space)] (reset! curwin _) ?))
                                        (ร BREAK normalchar)
                                    )

                                    Ctrl_W                        ;; delete word before the cursor
                                    (do
                                        (reset! a'did_backspace (let [[_ ?] (ins-bs? @curwin, c, BACKSPACE_WORD, a'inserted_space)] (reset! curwin _) ?))
                                        (ร BREAK normalchar)
                                    )

                                    Ctrl_U                        ;; delete all inserted text in current line
                                    (do
                                        (reset! a'did_backspace (let [[_ ?] (ins-bs? @curwin, c, BACKSPACE_LINE, a'inserted_space)] (reset! curwin _) ?))
                                        (reset! a'inserted_space false)
                                        (ร BREAK normalchar)
                                    )

                                    K_IGNORE                      ;; something mapped to nothing
                                    (do
                                        (ร BREAK normalchar)
                                    )

                                    K_CURSORHOLD                  ;; didn't type something for a while
                                    (do
                                        (reset! did_cursorhold true)
                                        (ร BREAK normalchar)
                                    )

                                   [K_HOME K_KHOME K_S_HOME K_C_HOME]                        ;; <Home>
                                    (do
                                        (swap! curwin ins-home c)
                                        (ร BREAK normalchar)
                                    )

                                   [K_END K_KEND K_S_END K_C_END]                         ;; <End>
                                    (do
                                        (swap! curwin ins-end c)
                                        (ร BREAK normalchar)
                                    )

                                    K_LEFT                        ;; <Left>
                                    (do
                                        (if (flag? @mod_mask (| MOD_MASK_SHIFT MOD_MASK_CTRL))
                                            (swap! curwin ins-s-left)
                                            (swap! curwin ins-left))
                                        (ร BREAK normalchar)
                                    )

                                   [K_S_LEFT K_C_LEFT]                     ;; <S-Left>
                                    (do
                                        (swap! curwin ins-s-left)
                                        (ร BREAK normalchar)
                                    )

                                    K_RIGHT                       ;; <Right>
                                    (do
                                        (if (flag? @mod_mask (| MOD_MASK_SHIFT MOD_MASK_CTRL))
                                            (swap! curwin ins-s-right)
                                            (swap! curwin ins-right))
                                        (ร BREAK normalchar)
                                    )

                                   [K_S_RIGHT K_C_RIGHT]                    ;; <S-Right>
                                    (do
                                        (swap! curwin ins-s-right)
                                        (ร BREAK normalchar)
                                    )

                                    K_UP                          ;; <Up>
                                    (do
                                        (if (flag? @mod_mask MOD_MASK_SHIFT)
                                            (swap! curwin ins-pageup)
                                            (swap! curwin ins-up false))
                                        (ร BREAK normalchar)
                                    )

                                   [K_S_UP K_PAGEUP K_KPAGEUP]                       ;; <S-Up>
                                    (do
                                        (swap! curwin ins-pageup)
                                        (ร BREAK normalchar)
                                    )

                                    K_DOWN                        ;; <Down>
                                    (do
                                        (if (flag? @mod_mask MOD_MASK_SHIFT)
                                            (swap! curwin ins-pagedown)
                                            (swap! curwin ins-down false))
                                        (ร BREAK normalchar)
                                    )

                                   [K_S_DOWN K_PAGEDOWN K_KPAGEDOWN]                     ;; <S-Down>
                                    (do
                                        (swap! curwin ins-pagedown)
                                        (ร BREAK normalchar)
                                    )

                                    K_DROP                        ;; drag-n-drop event
                                    (do
                                        (swap! curwin ins-drop)
                                        (ร BREAK normalchar)
                                    )

                                    K_S_TAB                       ;; when not mapped, use like a normal TAB
                                    (do
                                        ((ร c =) TAB)
                                        (ร FALLTHROUGH)
                                    )
                                    TAB                           ;; TAB or Complete patterns along path
                                    (do
                                        (reset! a'inserted_space false)
                                        (if (let [[_ ?] (ins-tab? @curwin)] (reset! curwin _) ?)
                                            (ร BREAK)            ;; insert TAB as a normal char
                                        )
                                        (ร BREAK normalchar)
                                    )

                                    K_KENTER                      ;; <Enter>
                                    (do
                                        ((ร c =) CAR)
                                        (ร FALLTHROUGH)
                                    )
                                   [CAR NL]
                                    (do
                                        (when (non-zero? @cmdwin_type)
                                            ;; Execute the command in the cmdline window.
                                            (reset! cmdwin_result CAR)
                                            (ร BREAK doESCkey)
                                        )
                                        (if (and (not (let [[_ ?] (ins-eol? @curwin, c)] (reset! curwin _) ?)) (not @p_im))
                                            (ร BREAK doESCkey)             ;; out of memory
                                        )
                                        (reset! a'inserted_space false)
                                        (ร BREAK normalchar)
                                    )

                                    Ctrl_K                        ;; digraph or keyword completion
                                    (do
                                        ((ร [@curwin c] =) (ins-digraph @curwin))
                                        (if (== c NUL)
                                            (ร BREAK normalchar)
                                        )
                                        (ร BREAK)
                                    )

                                    Ctrl_L                        ;; whole line completion after ^X
                                    (do
                                        ;; CTRL-L with 'insertmode' set: Leave Insert mode.
                                        (if @p_im
                                            (ร BREAK doESCkey)
                                        )
                                        (ร BREAK)
                                    )

                                   [Ctrl_Y Ctrl_E]                        ;; copy from previous/next line or scroll down/up
                                    (do
                                        ((ร [@curwin c] =) (ins-ctrl-ey @curwin, c))
                                        (ร BREAK normalchar)
                                    )

                                    (do
                                        (when (== c @intr_char)             ;; special interrupt char
                                            ;; When 'insertmode' set, and not halfway a mapping, don't leave Insert mode.
                                            (when (goto-im)
                                                (cond @got_int
                                                (do
                                                    (vgetc)                ;; flush all buffers
                                                    (reset! got_int false)
                                                )
                                                :else
                                                (do
                                                    (vim-beep)
                                                ))
                                                (ร BREAK normalchar)
                                            )
                                            (ร BREAK doESCkey)
                                        )
                                        (ร BREAK)
                                    )
                                )

                                ;; Insert a normal character.

                                (when (not @p_paste)
                                    ;; Trigger InsertCharPre.
                                    ((ร Bytes s =) (do-insert-char-pre c))

                                    (when (some? s)
                                        (when (and (non-eos? s) (stop-arrow @curwin))
                                            ;; Insert the new value of v:char literally.
                                            (loop-when-recur [#_Bytes p s] (non-eos? p) [(.plus p (us-ptr2len-cc p))]
                                                ((ร c =) (us-ptr2char p))
                                                (if (any == c CAR K_KENTER NL)
                                                    (swap! curwin ins-eol c)
                                                    (swap! curwin ins-char c))
                                            )
                                            (append-redo-lit s, -1)
                                        )
                                        ((ร c =) NUL)
                                    )

                                    ;; If the new value is already inserted or an empty string,
                                    ;; then don't insert any character.
                                    (if (== c NUL)
                                        (ร BREAK normalchar)
                                    )
                                )
                                ;; Try to perform smart-indenting.
                                (swap! curwin ins-try-si c)

                                (when (== c (byte \space))
                                    (reset! a'inserted_space true)
                                    (when (inindent @curwin, 0)
                                        (reset! can_cindent false))
                                    (when (and (== @insStart_blank_vcol MAXCOL) (== (:lnum (:w_cursor @curwin)) (:lnum @insStart)))
                                        (swap! curwin validate-virtcol)
                                        (reset! insStart_blank_vcol (:w_virtcol @curwin)))
                                )

                                ;; Insert a normal character and check for abbreviations on a special character.
                                ;; Let CTRL-] expand abbreviations without inserting it.
                                (when (or (vim-iswordc c) (!= c Ctrl_RSB))
                                    (swap! curwin insert-special c, false, false)
                                )
;                           }

                            ;; If typed something may trigger CursorHoldI again.
                            (when (!= c K_CURSORHOLD)
                                (reset! did_cursorhold false))

                            ;; If the cursor was moved we didn't just insert a space.
                            (when @arrow_used
                                (reset! a'inserted_space false))

                            (ร CONTINUE)
;                       }

                        ;; This is the ONLY return from edit()!

                        ;; Always update "o_lnum", so that a "CTRL-O ." that adds a line
                        ;; still puts the cursor back after the inserted text.
                        (when (and @ins_at_eol (== (gchar-cursor @curwin) NUL))
                            (reset! o_lnum (:lnum (:w_cursor @curwin))))

                        (when (let [[_ ?] (ins-esc? @curwin, a'count, cmdchar, @a'nomove)] (reset! curwin _) ?)
                            (reset! did_cursorhold false)
                            ((ร RETURN) (== c Ctrl_O))
                        )
                        (recur lastc c)
                    )
                )
                )
            )
        ))
    ))

;; Redraw for Insert mode.
;; This is postponed until getting the next character to make '$' in the 'cpo' option work correctly.
;; Only redraw when there are no characters available.
;; This speeds up inserting sequences of characters (e.g. for CTRL-R).

(defn- #_window_C ins-redraw [#_window_C win, #_boolean ready]
    ;; ready: not busy with something
    (if (char-avail)
        win
        (let [#_boolean lupd (and ready (pos? @(:wo_cole (:w_options win))) (not (eqpos @last_cursormoved, (:w_cursor win))))
              ;; Trigger CursorMoved if the cursor moved.
              [#_long lold #_long lnew]
                (if lupd
                    (let [lold (:lnum @last_cursormoved)
                          _ (reset! last_cursormoved (:w_cursor win))
                          lnew (:lnum @last_cursormoved)]
                        [lold lnew])
                    [0 0])]
            (cond
                (non-zero? @must_redraw) (update-screen 0)
                (or @clear_cmdline @redraw_cmdline) (showmode) ;; clear cmdline and show mode
            )
            (let [win (if (or (and lupd (or (!= lold lnew) (conceal-cursor-line win))) (:w_redraw_cline win))
                        (let [win (if (!= lold lnew) (update-single-line win, lold) win)
                              win (update-single-line win, (if (zero? lnew) (:lnum (:w_cursor win)) lnew))]
                            (update win :w_valid & (bit-not VALID_CROW)))
                        win)
                  win (showruler win, false)]
                (setcursor)
                (reset! emsg_on_display false)    ;; may remove error message now
                win
            ))
    ))

;; Handle a CTRL-V or CTRL-Q typed in Insert mode.

(defn- #_window_C ins-ctrl-v [#_window_C win]
    (let [win (ins-redraw win, false) ;; may need to redraw when no more chars available now
          #_boolean putchar? (and (redrawing) (not (char-avail)))
          win (if putchar? (edit-putchar win, (byte \^), true) win)]
        (append-redo CTRL_V_STR)
        (add-to-showcmd-c Ctrl_V)
        (let [#_int c (get-literal)
              ;; When the line fits in 'columns' the '^' is at the start
              ;; of the next line and will not be removed by the redraw.
              win (if putchar? (edit-unputchar win) win)]
            (clear-showcmd win)
            (insert-special win, c, false, true)
        )
    ))

;; Put a character directly onto the screen.  It's not stored in a buffer.
;; Used while handling CTRL-K, CTRL-V, etc. in Insert mode.

(final int
    PC_STATUS_UNSET 0,                   ;; "pc_bytes" was not set
    PC_STATUS_RIGHT 1,                   ;; right halve of double-wide char
    PC_STATUS_LEFT  2,                   ;; left halve of double-wide char
    PC_STATUS_SET   3)                   ;; "pc_bytes" was filled
(atom! int  pc_status)

(final Bytes pc_bytes (Bytes. (inc MB_MAXBYTES)))   ;; saved bytes
(atom! int  pc_attr)
(atom! int  pc_row)
(atom! int  pc_col)

(defn- #_window_C edit-putchar [#_window_C win, #_int c, #_boolean highlight]
    (if (some? @screenLines)
        (let [win (update-topline win) ;; just in case "w_topline" isn't valid
              win (validate-cursor win)
              #_int attr (if highlight (hl-attr HLF_8) 0)]
            (reset! pc_row (+ (:w_winrow win) (:w_wrow win)))
            (reset! pc_col (+ (:w_wincol win) (:w_wcol win)))
            (if (mb-lefthalve @pc_row, @pc_col)
                (reset! pc_status PC_STATUS_LEFT)
                (do ;; save the character to be able to put it back
                    (screen-getbytes @pc_row, @pc_col, pc_bytes, pc_attr)
                    (reset! pc_status PC_STATUS_SET)
                ))
            (screen-putchar c, @pc_row, @pc_col, attr)
            win)
        win
    ))

;; Undo the previous edit-putchar().

(defn- #_window_C edit-unputchar [#_window_C win]
    (if (and (!= @pc_status PC_STATUS_UNSET) (<= @msg_scrolled @pc_row))
        (let [win (if (== @pc_status PC_STATUS_RIGHT) (update win :w_wcol inc) win)]
            (if (any == @pc_status PC_STATUS_RIGHT PC_STATUS_LEFT)
                (redraw-winline win, (:lnum (:w_cursor win)))
                (do (screen-puts pc_bytes, (- @pc_row @msg_scrolled), @pc_col, @pc_attr) win)
            ))
        win
    ))

;; Insert an indent (for <Tab> or CTRL-T) or delete an indent (for CTRL-D).
;; Keep the cursor on the same character.
;; type == INDENT_INC   increase indent (for CTRL-T or <Tab>)
;; type == INDENT_DEC   decrease indent (for CTRL-D)
;; type == INDENT_SET   set indent to "amount"
;; If "round?" is true, round the indent to 'shiftwidth' (only with _INC and _DEC).
;; replaced: replaced character, put on replace stack

(defn- #_window_C change-indent [#_window_C win, #_int type, #_int amount, #_boolean round?, #_int replaced, #_boolean call_changed_bytes]
    ;; VREPLACE mode needs to know what the line was like before changing.
    (let [[o'line o'col] (if (flag? @State VREPLACE_FLAG) [(STRDUP (ml-get (:lnum (:w_cursor win)))) (:col (:w_cursor win))] [nil 0])
          #_int vcol (getvcol-nolist (:w_cursor win))
          ;; For Replace mode we need to fix the replace stack later, which is only possible when the
          ;; cursor is in the indent.  Remember the number of chars before the cursor if it's possible.
          #_int start_col (:col (:w_cursor win))
          ;; determine offset from first non-blank
          win (beginline win, BL_WHITE)
          #_int new_cursor_col (- start_col (:col (:w_cursor win)))
          #_int insstart_less (:col (:w_cursor win))    ;; reduction for insStart.col
          ;; If the cursor is in the indent, compute how many screen columns
          ;; the cursor is to the left of the first non-blank.
          vcol (if (< new_cursor_col 0) (- (get-indent win) vcol) vcol)
          start_col (if (< 0 new_cursor_col) -1 start_col) ;; can't fix replace stack

          ;; Set the new indent.  The cursor will be put on the first non-blank.

          win (if (== type INDENT_SET)
                (set-indent win, amount, (if call_changed_bytes SIN_CHANGED 0))
                (let [state' @State ;; Avoid being called recursively.
                      _ (when (flag? @State VREPLACE_FLAG)
                            (reset! State INSERT))
                      win (shift-line win, (== type INDENT_DEC), round?, 1, call_changed_bytes)]
                    (reset! State state')
                    win
                ))
          insstart_less (- insstart_less (:col (:w_cursor win)))

          ;; Try to put cursor on same character.
          ;; If the cursor is at or after the first non-blank in the line,
          ;; compute the cursor column relative to the column of the first non-blank character.
          ;; If we are not in insert mode, leave the cursor on the first non-blank.
          ;; If the cursor is before the first non-blank, position it relative
          ;; to the first non-blank, counted in screen columns.

          [win insstart_less new_cursor_col]
            (cond (<= 0 new_cursor_col)
                ;; When changing the indent while the cursor is touching it, reset insStart_col to 0.
                [win (if (zero? new_cursor_col) MAXCOL insstart_less) (+ new_cursor_col (:col (:w_cursor win)))]
            (non-flag? @State INSERT)
                [win insstart_less (:col (:w_cursor win))]
            :else ;; Compute the screen column where the cursor should be.
                (let [win (assoc win :w_virtcol (max 0 (- (get-indent win) vcol)))
                      ;; Advance the cursor until we reach the right screen column.
                      #_Bytes s (ml-get (:lnum (:w_cursor win)))
                      [vcol new_cursor_col]
                        (loop-when [#_int last_vcol 0 #_int i -1 #_int vcol 0] (<= vcol (:w_virtcol win)) => [last_vcol i]
                            (let [i (+ i (if (<= 0 i) (us-ptr2len-cc s, i) 1))]
                                (recur vcol i (+ vcol (lbr-chartabsize s, (.plus s i), vcol)))
                            ))
                      ;; May need to insert spaces to be able to position the cursor on the right screen column.
                      [win new_cursor_col]
                        (if (!= vcol (:w_virtcol win))
                            (let [win (assoc-in win [:w_cursor :col] new_cursor_col)
                                  #_int i (- (:w_virtcol win) vcol) #_Bytes p (-> (Bytes. (inc i)) (eos! i))
                                  _ (loop-when-recur [i (dec i)] (<= 0 i) [(dec i)] (.be p i, (byte \space)))]
                                [(ins-str win, p) (+ new_cursor_col i)])
                            [win new_cursor_col]
                        )]
                    ;; When changing the indent while the cursor is in it, reset insStart_col to 0.
                    [win MAXCOL new_cursor_col]
                ))
          win (assoc-in win [:w_cursor :col] (max 0 new_cursor_col))
          win (assoc win :w_set_curswant true)
          win (changed-cline-bef-curs win)]

        ;; May have to adjust the start of the insert.

        (when (flag? @State INSERT)
            (when (and (== (:lnum (:w_cursor win)) (:lnum @insStart)) (non-zero? (:col @insStart)))
                (swap! insStart update :col #(max 0 (- % insstart_less))))
            (swap! ai_col #(max 0 (- % insstart_less))))

        ;; For REPLACE mode, may have to fix the replace stack, if it's possible.
        ;; If the number of characters before the cursor decreased, need to pop a
        ;; few characters from the replace stack.
        ;; If the number of characters before the cursor increased, need to push a
        ;; few NULs onto the replace stack.

        (when (and (flag? @State REPLACE_FLAG) (non-flag? @State VREPLACE_FLAG) (<= 0 start_col))
            (let [start_col
                    (loop-when-recur start_col (< (:col (:w_cursor win)) start_col) (dec start_col) => start_col
                        (replace-join 0) ;; remove a NUL from the replace stack
                    )]
                (loop-when-recur [#_int i start_col #_int r replaced] (or (< i (:col (:w_cursor win))) (!= r NUL)) [(inc i) NUL]
                    (replace-push NUL)
                    (when (!= r NUL) (replace-push r)))
            ))

        ;; For VREPLACE mode, we also have to fix the replace stack.  In this case
        ;; it is always possible because we backspace over the whole line and then
        ;; put it back again the way we wanted it.

        (if (and (flag? @State VREPLACE_FLAG) (some? o'line))
            ;; Save new line.
            (let [#_Bytes line (STRDUP (ml-get (:lnum (:w_cursor win))))
                  ;; We only put back the new line up to the cursor.
                  _ (eos! line (:col (:w_cursor win)))
                  ;; Put back original line.
                  _ (ml-replace (:lnum (:w_cursor win)), o'line)
                  win (assoc-in win [:w_cursor :col] o'col)
                  ;; Backspace from cursor to start of line.
                  win (backspace-until-column win, 0)]
                ;; Insert new stuff into line again.
                (ins-bytes win, line))
            win)
    ))

;; Truncate the space at the end of a line.  This is to be used only in an insert mode.
;; It handles fixing the replace stack for REPLACE and VREPLACE modes.

(defn- #_void truncate-spaces [#_Bytes line]
    (let [#_int i ;; find start of trailing white space
            (loop-when-recur [i (dec (STRLEN line))] (and (<= 0 i) (vim-iswhite (.at line i))) [(dec i)] => i
                (when (flag? @State REPLACE_FLAG)
                    (replace-join 0))        ;; remove a NUL from the replace stack
            )]
        (eos! line (inc i)))
    nil)

;; Backspace the cursor until the given column.  Handles REPLACE and VREPLACE
;; modes correctly.  May also be used when not in insert mode at all.
;; Will attempt not to go before "col" even when there is a composing character.

(defn- #_window_C backspace-until-column [#_window_C win, #_int col]
    (loop-when win (< col (:col (:w_cursor win))) => win
        (let [win (update-in win [:w_cursor :col] dec)]
            (if (flag? @State REPLACE_FLAG)
                (recur (replace-do-bs win, col))
                (let-when [[win ?] (del-char-after-col? col)] ? => win
                    (recur win))
            ))
    ))

;; Like del-char(), but make sure not to go before column "limit_col".
;; Only matters when there are composing characters.
;; Return true when something was deleted.

(defn- #_[window_C boolean] del-char-after-col? [#_window_C win, #_int limit_col]
    (if (<= 0 limit_col)
        (let [#_int ecol (inc (:col (:w_cursor win)))
              ;; Make sure the cursor is at the start of a character, but skip forward
              ;; again when going too far back because of a composing character.
              win (update win :w_cursor mb-adjust-pos)
              win (loop-when win (< (:col (:w_cursor win)) limit_col) => win
                    (let-when [#_int n (us-ptr2len (ml-get-cursor win))] (pos? n) => win
                        (recur (update-in win [:w_cursor :col] + n)))
                )]
            (if (or (eos? (ml-get-cursor win)) (== (:col (:w_cursor win)) ecol))
                [win false]
                (del-bytes? win, (- ecol (:col (:w_cursor win))), false, true)
            ))
        (del-char? win, false)
    ))

(defn- #_window_C del-char-after-col [#_window_C win, #_int limit_col]
    (let [[win _] (del-char-after-col? win, limit_col)]
        win
    ))

;; Next character is interpreted literally.
;; A one, two or three digit decimal number is interpreted as its byte value.
;; If one or two digits are entered, the next character is given to vungetc().
;; For Unicode a character > 255 may be returned.

(defn- #_int get-literal []
    (if @got_int
        Ctrl_C
        (do (swap! no_mapping inc)                  ;; don't map the next key hits
            (let [[#_int i #_int nc #_int cc]
                    (loop [i 0 cc 0 m {#_boolean :hex false, #_boolean :oct false, #_int :unicode 0}]
                        (let [nc (plain-vgetc)]
                            (when (and (non-flag? @State CMDLINE) (== (mb-byte2len nc) 1))
                                (add-to-showcmd nc))
                            (let-when [[m cc i :as _]
                                    (cond
                                        (any == nc (byte \x) (byte \X)) [(assoc m :hex true) cc i]
                                        (any == nc (byte \o) (byte \O)) [(assoc m :oct true) cc i]
                                        (any == nc (byte \u) (byte \U)) [(assoc m :unicode nc) cc i]
                                    :else (cond
                                        (or (:hex m) (non-zero? (:unicode m))) (when (asc-isxdigit nc) [m (+ (* cc 16) (hex2nr nc)) (inc i)])
                                        (:oct m)                               (when (asc-isodigit nc) [m (+ (* cc 8) (- nc (byte \0))) (inc i)])
                                        :else                                  (when (asc-isdigit nc) [m (+ (* cc 10) (- nc (byte \0))) (inc i)])
                                    ))] (some? _) => [i nc cc]
                                (let-when [cc (if (and (< 255 cc) (zero? (:unicode m))) 255 cc) ;; limit range to 0-255
                                      nc 0
                                      _ (cond (:hex m)              ;; hex: up to two chars
                                            (when (< i 2) :_)
                                        (non-zero? (:unicode m))    ;; unicode: up to four or eight chars
                                            (when-not (or (and (== (:unicode m) (byte \u)) (<= 4 i)) (and (== (:unicode m) (byte \U)) (<= 8 i))) :_)
                                        (< i 3)                     ;; decimal or octal: up to three chars
                                            :_
                                        )] (some? _) => [i nc cc]
                                    (recur i cc m)
                                ))
                        ))]
                (swap! no_mapping dec)
                (let [cc (if (zero? i) (if (== nc K_ZERO) 0 nc) cc)]    ;; no number entered
                    (let-when [nc (if (zero? i) 0 nc)] (non-zero? nc) (vungetc nc))
                    (reset! got_int false)                              ;; CTRL-C typed after CTRL-V is not an interrupt
                    (if (zero? cc) (byte \newline) cc)                  ;; NUL is stored as NL
                )))
    ))

;; Insert character, taking care of special keys and mod_mask.

(defn- #_window_C insert-special [#_window_C win, #_int c, #_boolean allow_modmask, #_boolean ctrl_v]
    ;; ctrl_v: c was typed after CTRL-V
    (let [[win [c ctrl_v :as _]]
          ;; Special function key, translate into "<Key>".
          ;; Up to the last '>' is inserted with ins-str(), so as not to replace characters in replace mode.
          ;; Only use mod_mask for special keys, to avoid things like <S-Space>, unless 'allow_modmask' is true.
            (if (or (is-special c) (and (non-zero? @mod_mask) allow_modmask))
                (let-when [#_Bytes s (get-special-key-name c, @mod_mask) #_int n (STRLEN s) c (.at s (dec n))] (< 2 n) => [win [c ctrl_v]]
                    (if (stop-arrow win)
                        (let [_ (eos! s (dec n)) win (ins-str win, s)]
                            (append-redo-lit s, -1)
                            [win [c false]])
                        [win nil]
                    ))
                [win [c ctrl_v]]
            )]
        (if (and (some? _) (stop-arrow win)) (insert-char win, c, ctrl_v) win)
    ))

;; Special characters in this context are those that need processing other
;; than the simple insertion that can be performed here.  This includes ESC
;; which terminates the insert, and CR/NL which need special processing to
;; open up a new line.  This routine tries to optimize insertions performed by
;; the "redo", "undo" or "put" commands, so it needs to know when it should
;; stop and defer processing to the "normal" mechanism.
;; '0' and '^' are special, because they can be followed by CTRL-D.

(defn- #_boolean isspecial [#_int c]
    (or (< c (byte \space)) (<= DEL c) (== c (byte \0)) (== c (byte \^))))

(defn- #_window_C insert-char [#_window_C win, #_int c, #_boolean ctrl_v]
    (if (== c NUL) ;; only formatting was wanted
        win
        (do (reset! did_ai false) (reset! did_si false) (reset! can_si false) (reset! can_si_back false)
            ;; If there's any pending input, grab up to INPUT_BUFLEN at once.
            ;; This speeds up normal text input considerably.
            (if (and (not (isspecial c)) (== (utf-char2len c) 1) (!= (vpeekc) NUL) (non-flag? @State REPLACE_FLAG))
                (let [#_final #_int INPUT_BUFLEN 100 #_Bytes buf (-> (Bytes. (inc INPUT_BUFLEN)) (.be 0, c))
                      #_int i ;; eos! when: no more chars available; finding a special char (command key); buffer is full; running into the 'textwidth' boundary
                        (loop-when-recur [i 1 c (vpeekc)] (and (!= c NUL) (not (isspecial c)) (== (mb-byte2len c) 1) (< i INPUT_BUFLEN)) [(inc i) (vpeekc)] => i
                            (.be buf i, (vgetc)))
                      _ (eos! buf i)]
                    (do-digraph -1)                     ;; clear digraphs
                    (do-digraph (.at buf (dec i)))      ;; may be the start of a digraph
                    (let [win (ins-str win, buf)]
                        (let-when [i (if ctrl_v (do (redo-literal (.at buf 0)) 1) 0)] (non-eos? buf i) (append-redo-lit (.plus buf i), -1))
                        win
                    ))
                (let [#_int n (utf-char2len c)]
                    (if (< 1 n)
                        (let [#_Bytes buf (Bytes. (inc MB_MAXBYTES)) _ (utf-char2bytes c, buf) _ (eos! buf n)
                              win (ins-char-bytes win, buf, n)]
                            (append-redo-char c)
                            win)
                        (let [win (ins-char win, c)]
                            (if ctrl_v (redo-literal c) (append-redo-char c))
                            win)
                    ))
            ))
    ))

;; Put a character in the redo buffer, for when just after a CTRL-V.

(defn- #_void redo-literal [#_int c]
    ;; Only digits need special treatment.  Translate them into a string of three digits.
    (if (asc-isdigit c)
        (let [#_Bytes buf (Bytes. 10)]
;%%         (vim_snprintf buf, (.size buf), (u8 "%03d"), c)
            (append-redo buf))
        (append-redo-char c))
    nil)

;; start-arrow() is called when an arrow key is used in Insert mode.
;; For undo/redo it resembles hitting the <ESC> key.

(defn- #_window_C start-arrow [#_window_C win, #_pos_C eoi]
    ;; eoi: can be null
    (if (not @arrow_used)               ;; something has been inserted
        (let [_ (append-redo ESC_STR)
              win (stop-insert win, eoi, false, false)]
            (reset! arrow_used true)    ;; this means we stopped the current insert
            win)
        win
    ))

;; stop-arrow() is called before a change is made in Insert mode.
;; If an arrow key has been used, start a new insertion.
;; Returns false if undo is impossible, shouldn't insert then.

(defn- #_boolean stop-arrow [#_window_C win]
    (cond @arrow_used
    (do
        (reset! insStart (:w_cursor win)) ;; new insertion starts here
        (when (and (< (:col @insStart_orig) (:col @insStart)) (not @ins_need_undo))
            ;; Don't update the original insert position when moved to the right,
            ;; except when nothing was inserted yet.
            (reset! update_insStart_orig false))
        (reset! insStart_textlen (linetabsize (ml-get (:lnum (:w_cursor win)))))
        (when (u-save-cursor)
            (reset! arrow_used false)
            (reset! ins_need_undo false))
        (reset! ai_col 0)
        (when (flag? @State VREPLACE_FLAG)
            (reset! orig_line_count (line-count @curbuf))
            (reset! vr_lines_changed 1))
        (reset-redo)
        (append-redo (u8 "1i")) ;; pretend we start an insertion
        (reset! new_insert_skip 2)
    )
    @ins_need_undo
    (do
        (when (u-save-cursor)
            (reset! ins_need_undo false))
    ))

    (or @arrow_used (not @ins_need_undo)))

;; Do a few things to stop inserting.
;; "eoi" is where insert ended.
;; It is null when we already jumped to another window/buffer.

(defn- #_window_C stop-insert [#_window_C win, #_pos_C eoi, #_boolean esc, #_boolean nomove]
    ;; nomove: <c-\><c-o>, do not move the cursor
    (stop-redo-ins)
    (replace-flush) ;; abandon replace stack
    ;; Save the inserted text for later redo with ^@ and CTRL-A.
    ;; Don't do it when "restart_edit" was set and nothing was inserted,
    ;; otherwise CTRL-O w and then <Left> will clear "last_insert".
    (let-when [#_Bytes s (get-inserted)] (or (zero? @did_restart_edit) (and (some? s) (< @new_insert_skip (STRLEN s))))
        (reset! last_insert s)
        (reset! last_insert_skip @new_insert_skip))
    ;; If we just did an auto-indent, remove the white space from the end of the line, and put the cursor back.
    ;; Do this when ESC was used or moving the cursor up/down.
    ;; Check for the old position still being valid, just in case the text got changed unexpectedly.
    (let [win (if (and (not @arrow_used) (some? eoi) (not nomove) @did_ai
                       (or esc (and (nil? (vim-strbyte @p_cpo, CPO_INDENT)) (!= (:lnum (:w_cursor win)) (:lnum eoi))))
                       (<= (:lnum eoi) (line-count @curbuf)))
                (let [#_pos_C tpos (:w_cursor win)
                      win (assoc win :w_cursor eoi)
                      win (check-cursor-col win) ;; make sure it is not past the line
                      [win #_int x]
                        (loop [win win]
                            (let-when [win (if (and (== (gchar-cursor win) NUL) (< 0 (:col (:w_cursor win)))) (update-in win [:w_cursor :col] dec) win)
                                  x (gchar-cursor win)] (vim-iswhite x) => [win x]
                                (let [[win ?] (del-char? win, true)] (recur-if ? [win] => [win x]))
                            ))
                      win (if (!= (:lnum (:w_cursor win)) (:lnum tpos))
                            (assoc win :w_cursor tpos)
                            (let [tpos (update (:w_cursor win) :col inc)] ;; reset tpos, could have been invalidated in the loop above
                                (if (and (!= x NUL) (== (gchar-pos tpos) NUL)) (assoc win :w_cursor tpos) win)) ;; put cursor back on the NUL
                        )]
                    ;; <C-S-Right> may have started Visual mode, adjust the position for deleted characters.
                    (when (and @VIsual_active (== (:lnum @VIsual_cursor) (:lnum (:w_cursor win))))
                        (let [#_int len (STRLEN (ml-get (:lnum (:w_cursor win))))]
                            (when (< len (:col @VIsual_cursor))
                                (swap! VIsual_cursor assoc :col len :coladd 0))
                        ))
                    win)
                win
            )]
        (reset! did_ai false) (reset! did_si false) (reset! can_si false) (reset! can_si_back false)
        ;; Set '[ and '] to the inserted text.  ;; When "eoi" is null, we are now in a different buffer.
        (when (some? eoi)
            (swap! curbuf assoc :b_op_start @insStart, :b_op_start_orig @insStart_orig, :b_op_end eoi))
        win
    ))

;; Set the last inserted text to a single character.
;; Used for the replace command.

(defn- #_void set-last-insert [#_int c]
    (let [#_Bytes s (reset! last_insert (Bytes. (+ (* MB_MAXBYTES 3) 5)))
          ;; Use the CTRL-V only when entering a special char.
          s (if (or (< c (byte \space)) (== c DEL)) (-> s (.be 0, Ctrl_V) (.plus 1)) s)]
        (-> (add-char2buf c, s) (.be 0, ESC) (eos! 1))
        (reset! last_insert_skip 0))
    nil)

;; Add character "c" to buffer "s".
;; Escape the special meaning of KB_SPECIAL.
;; Handle multi-byte characters.
;; Returns a pointer to after the added bytes.

(defn- #_Bytes add-char2buf [#_int c, #_Bytes s]
    (let [#_Bytes bytes (Bytes. (inc MB_MAXBYTES)) #_int n (utf-char2bytes c, bytes)]
        (loop-when [s s #_int i 0] (< i n) => s
            (let [#_byte b (.at bytes i)
                  ;; Need to escape KB_SPECIAL like in the typeahead buffer.
                  s (if (== b KB_SPECIAL)
                        (-> s (.be 0, KB_SPECIAL) (.be 1, KS_SPECIAL) (.be 2, KE_FILLER) (.plus 3))
                        (-> s (.be 0, b) (.plus 1)))]
                (recur s (inc i))
            ))
    ))

;; Move cursor to start of line:
;;  if (flags & BL_WHITE) move to first non-white;
;;  if (flags & BL_SOL)   move to first non-white if 'startofline' is set, otherwise keep "curswant" column;
;;  if (flags & BL_FIX)   don't leave the cursor on a NUL.

(defn- #_window_C beginline [#_window_C win, #_int flags]
    (if (and (flag? flags BL_SOL) (not @p_sol))
        (coladvance win, (:w_curswant win))
        (let [win (update win :w_cursor assoc :col 0 :coladd 0)
              win (if (flag? flags (| BL_WHITE BL_SOL))
                    (let [s (ml-get (:lnum (:w_cursor win))) fix? (flag? flags BL_FIX)]
                        (loop-when-recur [i (:col (:w_cursor win))] (and (vim-iswhite (.at s i)) (not (and fix? (eos? s (inc i))))) [(inc i)] => (assoc-in win [:w_cursor :col] i)))
                    win
                )]
            (assoc win :w_set_curswant true))
    ))

;; oneright, oneleft, cursor-down, cursor-up
;;
;; Move one char [right, left, down, up].
;; Doesn't move onto the NUL past the end of the line, unless it is allowed.
;;
;; Return true when successful, false when we hit a line of file boundary.

(defn- #_[window_C boolean] oneright? [#_window_C win]
    (let [#_Bytes s (ml-get-cursor win)]
        (cond (virtual-active)
            (let [#_pos_C prior (:w_cursor win)
                  ;; Adjust for multi-wide char (excluding TAB).
                  win (coladvance win, (+ (getviscol win) (if (and (not-at? s TAB) (vim-isprintc (us-ptr2char s))) (mb-ptr2cells s) 1)))
                  win (assoc win :w_set_curswant true)]
                ;; Return true if the cursor moved, false otherwise (at window edge).
                [win (or (!= (:col prior) (:col (:w_cursor win))) (!= (:coladd prior) (:coladd (:w_cursor win))))]
            )
        (eos? s)
            [win false] ;; already at the very end
        :else
            (let [#_int n (us-ptr2len-cc s)]
                ;; Move "n" bytes right, but don't end up on the NUL, unless 'virtualedit' contains "onemore".
                (if (and (eos? s n) (non-flag? @ve_flags VE_ONEMORE))
                    [win false]
                    (let [win (update-in win [:w_cursor :col] + n)
                          win (assoc win :w_set_curswant true)]
                        [win true]
                    )
                ))
        )
    ))

(defn- #_window_C oneright [#_window_C win]
    (let [[win _] (oneright? win)]
        win
    ))

(defn- #_[window_C boolean] oneleft? [#_window_C win]
    (cond (virtual-active)
        (let [#_int v (getviscol win)]
            (if (zero? v)
                [win false]
                ;; We might get stuck on 'showbreak', skip over it.
                (let [win (loop [win win #_int width 1] (let [win (coladvance win, (- v width))] (if (< (getviscol win) v) win (recur win (inc width)))))
                      win (if (== (:coladd (:w_cursor win)) 1)
                            ;; Adjust for multi-wide char (not a TAB).
                            (let-when [#_Bytes s (ml-get-cursor win)] (and (not-at? s TAB) (vim-isprintc (us-ptr2char s)) (< 1 (mb-ptr2cells s))) => win
                                (assoc-in win [:w_cursor :coladd] 0))
                            win)
                      win (assoc win :w_set_curswant true)]
                    [win true]
                )
            ))
    (zero? (:col (:w_cursor win)))
        [win false]
    :else
        (let [win (update-in win [:w_cursor :col] dec)
              win (assoc win :w_set_curswant true)
              ;; If the char on the left of the cursor is multi-byte, move to its first byte.
              win (update win :w_cursor mb-adjust-pos)]
            [win true]
        )
    ))

(defn- #_window_C oneleft [#_window_C win]
    (let [[win _] (oneleft? win)]
        win
    ))

(defn- #_[window_C boolean] cursor-up? [#_window_C win, #_long n, #_boolean upd_topline]
    (let [[win ?] (if (< 0 n)
                (let [lmin 1 lnum (:lnum (:w_cursor win))]
                    ;; This fails if the cursor is already in the first line
                    ;; or the count is larger than the line number and '-' is in 'cpoptions'.
                    (if (or (<= lnum lmin) (and (< (- lnum n) lmin) (some? (vim-strbyte @p_cpo, CPO_MINUS))))
                        [win false]
                        [(assoc-in win [:w_cursor :lnum] (max lmin (- lnum n))) true]
                    ))
                [win true])
          win (if ?
                (let [win (coladvance win, (:w_curswant win))] ;; try to advance to the column we want to be at
                    (if upd_topline (update-topline win) win)) ;; make sure "w_topline" is valid
                win
            )]
        [win ?]
    ))

(defn- #_window_C cursor-up [#_window_C win, #_long n, #_boolean upd_topline]
    (let [[win _] (cursor-up? win, n, upd_topline)]
        win
    ))

(defn- #_[window_C boolean] cursor-down? [#_window_C win, #_long n, #_boolean upd_topline]
    (let [[win ?] (if (< 0 n)
                (let [lnum (:lnum (:w_cursor win)) lmax (line-count @curbuf)]
                    ;; This fails if the cursor is already in the last line
                    ;; or would move beyond the last line and '-' is in 'cpoptions'.
                    (if (or (<= lmax lnum) (and (< lmax (+ lnum n)) (some? (vim-strbyte @p_cpo, CPO_MINUS))))
                        [win false]
                        [(assoc-in win [:w_cursor :lnum] (min (+ lnum n) lmax)) true]
                    ))
                [win true])
          win (if ?
                (let [win (coladvance win, (:w_curswant win))] ;; try to advance to the column we want to be at
                    (if upd_topline (update-topline win) win)) ;; make sure "w_topline" is valid
                win
            )]
        [win ?]
    ))

(defn- #_window_C cursor-down [#_window_C win, #_long n, #_boolean upd_topline]
    (let [[win _] (cursor-down? win, n, upd_topline)]
        win
    ))

;; Stuff the last inserted text in the read buffer.
;; 'last_insert' actually is a copy of the redo buffer,
;; so we first have to remove the command.

(defn- #_boolean stuff-inserted [#_int c, #_long n, #_boolean no_esc]
    ;; c: command character to be inserted
    ;; n: repeat this many times
    ;; no_esc: don't add an ESC at the end
    (let-when [#_Bytes p (get-last-insert)] (some? p) => (do (emsg e_noinstext) false)
        ;; may want to stuff the command character, to start Insert mode
        (when (!= c NUL)
            (stuff-char c))
        (let [#_Bytes e (vim-strrchr p, ESC)
              _ (when (some? e) (eos! e)) ;; remove the ESC
              ;; when the last char is either "0" or "^" it will be quoted if no ESC comes
              ;; after it OR if it will inserted more than once and "p" starts with ^D
              #_Bytes q (if (some? e) (.minus e 1) (.plus p (dec (STRLEN p))))
              #_byte x (if (and (BLE p, q) (any == (.at q 0) (byte \0) (byte \^)) (or no_esc (and (at? p Ctrl_D) (< 1 n))))
                                (let [x (.at q 0)] (eos! q) x)
                                NUL)]
            (loop [n n]
                (stuff-string p)
                ;; a trailing "0" is inserted as "<C-V>048", "^" as "<C-V>^"
                (when (!= x NUL)
                    (stuff-string (if (== x (byte \0)) (u8 "\026\060\064\070") (u8 "\026^"))))
                (let-when [n (dec n)] (< 0 n)
                    (recur n)
                ))
            (when (!= x NUL) (.be q 0, x))
            (when (some? e) (.be e 0, ESC)) ;; put the ESC back
            ;; may want to stuff a trailing ESC, to get out of Insert mode
            (when (not no_esc)
                (stuff-char ESC)))
        true
    ))

(defn- #_Bytes get-last-insert []
    (if (nil? @last_insert) nil (.plus @last_insert @last_insert_skip)))

;; Get last inserted string, and remove trailing <Esc>.
;; Returns pointer to allocated memory (must be freed) or null.

(defn- #_Bytes get-last-insert-save []
    (let [#_Bytes s (get-last-insert)]
        (when (some? s)
            (let [s (STRDUP s) #_int len (STRLEN s)]
                (when (and (< 0 len) (at? s (dec len) ESC))       ;; remove trailing ESC
                    (eos! s (dec len)))
            ))
    s))

;; replace-stack functions
;;
;; When replacing characters, the replaced characters are remembered for each
;; new character.  This is used to re-insert the old text when backspacing.
;;
;; There is a NUL headed list of characters for each character that is
;; currently in the file after the insertion point.  When BS is used, one NUL
;; headed list is put back for the deleted character.
;;
;; For a newline, there are two NUL headed lists.  One contains the characters
;; that the NL replaced.  The extra one stores the characters after the cursor
;; that were deleted (always white space).
;;
;; Replace_offset is normally 0, in which case replace-push will add a new
;; character at the end of the stack.  If replace_offset is not 0, that many
;; characters will be left on the stack above the newly inserted character.

(atom! Bytes    replace_stack)
(atom! int      replace_stack_nr)       ;; next entry in replace stack
(atom! int      replace_stack_len)      ;; max. number of entries

(defn- #_void replace-push [#_int c]
    ;; c: character that is replaced (NUL is none)
    (when (<= @replace_offset @replace_stack_nr)
        (when (<= @replace_stack_len @replace_stack_nr)
            (swap! replace_stack_len + 50)
            (let [#_Bytes p (Bytes. @replace_stack_len)]
                (when (some? @replace_stack)
                    (BCOPY p, @replace_stack, @replace_stack_nr))
                (reset! replace_stack p)
            ))
        (let [#_Bytes p (.plus @replace_stack (- @replace_stack_nr @replace_offset))]
            (when (non-zero? @replace_offset)
                (BCOPY p, 1, p, 0, @replace_offset))
            (.be p 0, c)
            (swap! replace_stack_nr inc)
        ))
    nil)

;; Push a character onto the replace stack.
;; Handles a multi-byte character in reverse byte order, so that the first byte is popped off first.
;; Return the number of bytes done (includes composing characters).

(defn- #_int replace-push-mb [#_Bytes p]
    (let [#_int n (us-ptr2len-cc p)]
        (loop-when-recur [#_int i (dec n)] (<= 0 i) [(dec i)]
            (replace-push (.at p i)))
    n))

;; Pop one item from the replace stack.
;; return -1 if stack empty
;; return replaced character or NUL otherwise

(defn- #_int replace-pop []
    (if (zero? @replace_stack_nr) -1 (.at @replace_stack (swap! replace_stack_nr dec))))

;; Join the top two items on the replace stack.  This removes to "off"'th NUL encountered.

(defn- #_void replace-join [#_int off]
    ;; off: offset for which NUL to remove
    (loop-when [off off #_int i (dec @replace_stack_nr)] (<= 0 i)
        (if (eos? @replace_stack i)
            (let-when [off (dec off)] (< off 0) => (recur off (dec i))
                (swap! replace_stack_nr dec)
                (BCOPY @replace_stack, i, @replace_stack, (inc i), (- @replace_stack_nr i)))
            (recur off (dec i))
        ))
    nil)

;; Pop bytes from the replace stack until a NUL is found, and insert them
;; before the cursor.  Can only be used in REPLACE or VREPLACE mode.

(defn- #_window_C replace-pop-ins [#_window_C win]
    (let [o'State @State _ (reset! State NORMAL) ;; don't want REPLACE here
          win (loop-when [win win c (replace-pop)] (< 0 c) => win
                (let [win (mb-replace-pop-ins win, c)
                      win (dec-cursor win, false)]
                    (recur win (replace-pop)))
            )]
        (reset! State o'State)
        win
    ))

;; Insert bytes popped from the replace stack.  "c" is the first byte.
;; If it indicates a multi-byte char, pop the other bytes too.

(defn- #_window_C mb-replace-pop-ins [#_window_C win, #_int c]
    (let [s (Bytes. (inc MB_MAXBYTES))
          bees- (fn [c n] (.be s 0, c) (loop-when-recur [i 1] (< i n) [(inc i)] (.be s i, (replace-pop))))
          win (let-when [n (mb-byte2len c)] (< 1 n) => (ins-char win, c)
                (bees- c n)
                (ins-bytes-len win, s, n)
            )]
        (loop [win win] ;; Handle composing chars.
            (let-when [c (replace-pop)] (!= c -1) => win ;; => stack empty
                (let-when [n (mb-byte2len c)] (< 1 n) => (do (replace-push c) win) ;; Not a multi-byte char, put it back.
                    (bees- c n)
                    (recur-if (utf-iscomposing (us-ptr2char s)) [(ins-bytes-len win, s, n)] =>
                        (loop-when-recur [i (dec n)] (<= 0 i) [(dec i)] => win
                            (replace-push (.at s i)))
                    ))
            ))
    ))

;; make the replace stack empty
;; (called when exiting replace mode)

(defn- #_void replace-flush []
    (reset! replace_stack nil)
    (reset! replace_stack_len 0)
    (reset! replace_stack_nr 0)
    nil)

;; Handle doing a BS for one character.
;;
;; "c" < 0: replace stack empty, just move cursor
;; "c" == 0: character was inserted, delete it
;; "c" > 0: character was replaced, put "c" (first byte of original char) back and check for more to be put back
;;
;; When "limit_col" is >= 0, don't delete before this column.
;; Matters when using composing characters, use del-char-after-col() instead of del-char().

(defn- #_window_C replace-do-bs [#_window_C win, #_int limit_col]
    (let [c (replace-pop)]
        (cond (< 0 c)
            (let [vrep? (flag? @State VREPLACE_FLAG) a'start (atom (int)) o'vcol
                    (if vrep?
                        (do ;; Get the number of screen cells used by the character we are going to delete.
                            (getvcol win, (:w_cursor win), nil, a'start, nil)
                            (chartabsize (ml-get-cursor win), @a'start))
                        0)
                  win (del-char-after-col win, limit_col)
                  n (if vrep? (STRLEN (ml-get-cursor win)) 0)
                  _ (replace-push c)
                  win (replace-pop-ins win)
                  win (if vrep?
                        (let [s (ml-get-cursor win) n (- (STRLEN s) n)
                              ;; Get the number of screen cells used by the inserted characters.
                              vcol (loop-when-recur [vcol @a'start i 0] (< i n) [(+ vcol (chartabsize s, i, vcol)) (+ i (us-ptr2len-cc s, i))] => (- vcol @a'start))
                              ;; Delete spaces that were inserted after the cursor to keep the text aligned.
                              win (update-in win [:w_cursor :col] + n)
                              win (loop-when-recur [win win i o'vcol] (and (< i vcol) (== (gchar-cursor win) (byte \space))) [(del-char win, false) (inc i)] => win)
                              win (update-in win [:w_cursor :col] - n)]
                            win)
                        win
                    )]
                ;; mark the buffer as changed and prepare for displaying
                (changed-bytes (:lnum (:w_cursor win)), (:col (:w_cursor win)))
                win
            )
        (zero? c)
            (del-char-after-col win, limit_col)
        :else
            win
        )
    ))

(defn- #_window_C ins-reg [#_window_C win]
    (let [o'VIsual_active @VIsual_active
          ;; If we are going to wait for a character, show a '"'.
          _ (reset! pc_status PC_STATUS_UNSET)
          win (if (and (redrawing) (not (char-avail)))
                ;; May need to redraw when no more chars available now.
                (let [win (ins-redraw win, false) win (edit-putchar win, (byte \"), true)] ;; """
                    (add-to-showcmd-c Ctrl_R)
                    win)
                win)
          ;; Don't map the register name.  This also prevents the mode message to be deleted when ESC is hit.
          _ (swap! no_mapping inc)
          #_int regname (plain-vgetc)
          ;; Get a third key for literal register insertion.
          [#_int literally regname] (if (any == regname Ctrl_R Ctrl_O Ctrl_P) (do (add-to-showcmd-c regname) [regname (plain-vgetc)]) [0 regname])
          _ (swap! no_mapping dec)
          ;; Don't call u-sync() while typing the expression or giving an error message for it.  Only call it explicitly.
          _ (swap! no_u_sync inc)
          regname
            (if (== regname (byte \=))
                ;; Sync undo when evaluating the expression calls setline() or append(), so that it can be undone separately.
                (do (reset! u_sync_once 2) (get-expr-register))
                regname)
          #_boolean need_redraw
            (cond (or (== regname NUL) (not (valid-yank-reg regname, false)))
                (do (vim-beep) true) ;; remove the '"'
            (any == literally Ctrl_O Ctrl_P)
                (do ;; Append the command to the redo buffer.
                    (append-redo-char Ctrl_R) (append-redo-char literally) (append-redo-char regname)
                    (do-put regname, BACKWARD, 1, (| (if (== literally Ctrl_P) PUT_FIXINDENT 0) PUT_CURSEND))
                    false)
            (not (insert-reg regname, (non-zero? literally)))
                (do (vim-beep) true) ;; remove the '"'
            :else ;; When the '=' register was used and a function was invoked that did ":stopinsert",
                ;; then stuff-empty() returns false, but we won't insert anything, need to remove the '"'.
                @stop_insert_mode
            )
          _ (swap! no_u_sync dec)]
        (when (== @u_sync_once 1)
            (reset! ins_need_undo true))
        (reset! u_sync_once 0)
        (clear-showcmd win)
        ;; If the inserted register is empty, we need to remove the '"'.
        (let [win (if (or need_redraw (stuff-empty)) (edit-unputchar win) win)]
            ;; Disallow starting Visual mode here, would get a weird mode.
            (if (and (not o'VIsual_active) @VIsual_active) (end-visual-mode win) win)
        )
    ))

;; CTRL-G commands in Insert mode.

(defn- #_window_C ins-ctrl-g [#_window_C win]
    ;; Don't map the second key.  This also prevents the mode message to be deleted when ESC is hit.
    (let [_ (swap! no_mapping inc) #_int c (plain-vgetc) _ (swap! no_mapping dec)]
        (condp ==? c
           [K_UP   Ctrl_K (byte \k)] (ins-up win, true)   ;; CTRL-G k and CTRL-G <Up>: cursor up to insStart.col
           [K_DOWN Ctrl_J (byte \j)] (ins-down win, true) ;; CTRL-G j and CTRL-G <Down>: cursor down to insStart.col

            (byte \u)                                     ;; CTRL-G u: start new undoable edit
                (do (u-sync true)
                    (reset! ins_need_undo true)
                    ;; Need to reset insStart,
                    ;; esp. because a BS that joins a line to the previous one must save for undo.
                    (reset! update_insStart_orig false)
                    (reset! insStart (:w_cursor win))
                    win)

            ;; Unknown CTRL-G command, reserved for future expansion.
            (do (vim-beep) win)
        )
    ))

;; CTRL-^ in Insert mode.

(defn- #_void ins-ctrl-hat []
;   
    (showmode)
    nil)

(atom! boolean disabled_redraw)

;; Handle ESC in Insert mode.
;; Returns true when leaving Insert mode, false when going to repeat the insert.

(defn- #_[window_C boolean] ins-esc? [#_window_C win, #_long' a'count, #_int cmdchar, #_boolean nomove]
    ;; nomove: do not move the cursor
    (let [o'col (:col (:w_cursor win))]
        (when @disabled_redraw
            (swap! no_redraw dec)
            (reset! disabled_redraw false))
        (let-when [[win ? :as _]
                    (if (not @arrow_used)
                        (do ;; Don't append the ESC for "r<CR>" and "grx".
                            ;; When 'insertmode' is set, only CTRL-L stops Insert mode.
                            ;; Needed for when "count" is non-zero.
                            (when (and (!= cmdchar (byte \r)) (!= cmdchar (byte \v)))
                                (append-redo (if @p_im (u8 "\014") ESC_STR)))
                            ;; Repeating insert may take a long time.  Check for interrupt now and then.
                            (when (and (< 0 @a'count) (slow-breakcheck))
                                (reset! a'count 0))
                            (if (< 0 (swap! a'count dec)) ;; repeat what was typed
                                (do ;; Vi repeats the insert without replacing characters.
                                    (when (some? (vim-strbyte @p_cpo, CPO_REPLCNT))
                                        (swap! State & (bit-not REPLACE_FLAG)))
                                    (start-redo-ins)
                                    (when (any == cmdchar (byte \r) (byte \v))
                                        (stuff-redo ESC_STR)) ;; no ESC in redo buffer
                                    (swap! no_redraw inc)
                                    (reset! disabled_redraw true)
                                    [win false])
                                [(stop-insert win, (:w_cursor win), true, nomove) true]
                            ))
                        [win true]
                    )] ? => _ ;; repeat the insert

            ;; When an autoindent was removed, curswant stays after the indent.
            (let [win (if (and (== @restart_edit NUL) (== (:col (:w_cursor win)) o'col)) (assoc win :w_set_curswant true) win)
                  ;; Remember the last Insert position in the '^ mark.
                  _ (swap! curbuf assoc :b_last_insert (:w_cursor win))
                  ;; The cursor should end up on the last inserted character.
                  ;; Don't do it for CTRL-O, unless past the end of the line.
                  win (if (and (not nomove)
                             (or (pos? (:col (:w_cursor win))) (pos? (:coladd (:w_cursor win))))
                             (or (== @restart_edit NUL) (and (== (gchar-cursor win) NUL) (not @VIsual_active))))
                        (if (or (pos? (:coladd (:w_cursor win))) (== @ve_flags VE_ALL))
                            (let [win (oneleft win)]
                                (if (!= @restart_edit NUL) (update-in win [:w_cursor :coladd] inc) win))
                            (-> win
                                (update-in [:w_cursor :col] dec)
                                (update :w_cursor mb-adjust-pos)
                            ))
                        win)
                  _ (reset! State NORMAL)
                  win (changed-cline-bef-curs win)] ;; need to position the cursor again (e.g. when on a TAB)
                (ui-cursor-shape)
                ;; When recording or for CTRL-O, need to display the new mode.
                ;; Otherwise remove the mode message.
                (cond (or @Recording (!= @restart_edit NUL)) (showmode) @p_smd (msg (u8 "")))
                ;; exit Insert mode
                [win true]
            ))
    ))

;; If 'keymodel' contains "startsel", may start selection.
;; Returns true when a CTRL-O and other keys stuffed.

(defn- #_[window_C boolean] ins-start-select? [#_window_C win, #_int c]
    (let-when [iss-
            (fn [win c] ;; start selection right away, the cursor can move with CTRL-O when beyond the end of the line
                (let [win (start-selection win)]
                    (stuff-char Ctrl_O) ;; execute the key in (insert) Select mode
                    (when (non-zero? @mod_mask)
                        (stuff-string (-> (Bytes. 4) (.be 0, KB_SPECIAL) (.be 1, KS_MODIFIER) (.be 2, @mod_mask) (eos! 3))))
                    (stuff-char c)
                    [win true]
                )
            )] @km_startsel => [win false]
        (condp ==? c
            [K_KHOME K_KEND K_PAGEUP K_KPAGEUP K_PAGEDOWN K_KPAGEDOWN]
                (if (flag? @mod_mask MOD_MASK_SHIFT) (iss- win, c) [win false])
            [K_S_LEFT K_S_RIGHT K_S_UP K_S_DOWN K_S_END K_S_HOME]
                (iss- win, c)
            [win false]
        )
    ))

;; <Insert> key in Insert mode: toggle insert/replace mode.

(defn- #_void ins-insert [#_int replaceState]
    (swap! State #(if (flag? % REPLACE_FLAG) INSERT replaceState))
    (append-redo-char K_INS)
    (showmode)
    (ui-cursor-shape)          ;; may show different cursor shape
    nil)

;; Pressed CTRL-O in Insert mode.

(defn- #_void ins-ctrl-o [#_window_C win]
    (reset! restart_edit (cond (flag? @State VREPLACE_FLAG) (byte \V) (flag? @State REPLACE_FLAG) (byte \R) :else (byte \I)))
    (reset! ins_at_eol (if (virtual-active)
        false     ;; cursor always keeps its column
        (== (gchar-cursor win) NUL)))
    nil)

;; If the cursor is on an indent, ^T/^D insert/delete one 'shiftwidth'.
;; Otherwise ^T/^D behave like a "<<" or ">>".
;; Always round the indent to 'shiftwidth', this is compatible with vi.
;; But vi only supports ^T and ^D after an autoindent, we support it everywhere.

(defn- #_window_C ins-shift [#_window_C win, #_int c, #_int lastc]
    (if (stop-arrow win)
        (let [_ (append-redo-char c)
              ;; 0^D and ^^D: remove all indent.
              win (if (and (== c Ctrl_D) (any == lastc (byte \0) (byte \^)) (< 0 (:col (:w_cursor win))))
                    (let [win (update-in win [:w_cursor :col] dec)
                          win (del-char win, false)                 ;; delete the '^' or '0'
                          ;; In Replace mode, restore the characters that '^' or '0' replaced.
                          win (if (flag? @State REPLACE_FLAG) (replace-pop-ins win) win)]
                        (when (== lastc (byte \^))
                            (reset! old_indent (get-indent win)))   ;; remember curr. indent
                        (change-indent win, INDENT_SET, 0, true, NUL, true))
                    (change-indent win, (if (== c Ctrl_D) INDENT_DEC INDENT_INC), 0, true, NUL, true)
                )]
            (when (and @did_ai (non-eos? (skipwhite (ml-get (:lnum (:w_cursor win))))))
                (reset! did_ai false))
            (reset! did_si false)
            (reset! can_si false)
            (reset! can_si_back false)
            (reset! can_cindent false) ;; no cindenting after ^D or ^T
            win)
        win
    ))

(defn- #_window_C ins-del [#_window_C win]
    (if (stop-arrow win)
        (let [win (if (== (gchar-cursor win) NUL)
                    ;; delete newline ;; only if "eol" included
                    (let-when [] (can-bs BS_EOL) => (do (vim-beep) win)
                        (let-when [o'col (:col (:w_cursor win)) [win ?] (do-join? win, 2, false, true, false)] ? => (do (vim-beep) win)
                            (assoc-in win [:w_cursor :col] o'col)
                        ))
                    ;; delete char under cursor
                    (let-when [[win ?] (del-char? win, false)] ? => (do (vim-beep) win)
                        win)
                )]
            (reset! did_ai false) (reset! did_si false) (reset! can_si false) (reset! can_si_back false)
            (append-redo-char K_DEL)
            win)
        win
    ))

;; Delete one character for ins-bs().

(defn- #_window_C ins-bs-one [#_window_C win, #_int' a'vcol]
    (let [win (dec-cursor win, false)]
        (getvcol win, (:w_cursor win), a'vcol, nil, nil)
        (if (flag? @State REPLACE_FLAG) ;; Don't delete characters before the insert point when in Replace mode.
            (when (or (!= (:lnum (:w_cursor win)) (:lnum @insStart)) (<= (:col @insStart) (:col (:w_cursor win))))
                (replace-do-bs win, -1))
            (del-char win, false)
        )
    ))

;; Handle backspace, delete-word and delete-line in Insert mode.
;; Return true when backspace was actually used.

(defn- #_[window_C boolean] ins-bs? [#_window_C win, #_int c, #_int mode, #_boolean' a'inserted_space]
    ;; can't delete anything in an empty file
    ;; can't backup past first character in buffer
    ;; can't backup past starting point unless 'backspace' > 1
    ;; can backup to a previous line if 'backspace' == 0
    (cond (or (bufempty)
              (and (== (:lnum (:w_cursor win)) 1) (zero? (:col (:w_cursor win))))
              (and (not (can-bs BS_START)) (or @arrow_used (and (== (:lnum (:w_cursor win)) (:lnum @insStart_orig)) (<= (:col (:w_cursor win)) (:col @insStart_orig)))))
              (and (not (can-bs BS_INDENT)) (not @arrow_used) (< 0 @ai_col) (<= (:col (:w_cursor win)) @ai_col))
              (and (not (can-bs BS_EOL)) (zero? (:col (:w_cursor win)))))
            (do (vim-beep) [win false])

    (not (stop-arrow win))
        [win false]

    :else
        (let [#_boolean in_indent (inindent win, 0)]
            (when in_indent
                (reset! can_cindent false))
            ;; virtualedit:
            ;;  BACKSPACE_CHAR eats a virtual space
            ;;  BACKSPACE_WORD eats all coladd
            ;;  BACKSPACE_LINE eats all coladd and keeps going
            (let-when [[win ? :as _]
                    (if (pos? (:coladd (:w_cursor win)))
                        (condp == mode
                            BACKSPACE_CHAR [(update-in win [:w_cursor :coladd] dec) true]
                            BACKSPACE_WORD [(assoc-in win [:w_cursor :coladd] 0) true]
                            BACKSPACE_LINE [(assoc-in win [:w_cursor :coladd] 0) nil])
                        [win nil]
                    )] (not ?) => _

                (let-when [[win #_boolean did_backspace]
                        (cond (zero? (:col (:w_cursor win))) ;; Delete newline!
                            (let-when [#_long lnum (:lnum @insStart)
                                       _ (cond
                                            (!= lnum (:lnum (:w_cursor win))) :_
                                            (u-save (- lnum 2), (+ lnum 1)) (do (swap! insStart update :lnum dec) (swap! insStart assoc :col MAXCOL) :_)
                                            :else nil
                                        )] (some? _) => [win nil]
                                ;; In REPLACE mode:
                                ;; "x" < 0: NL was inserted, delete it
                                ;; "x" >= 0: NL was replaced, put original characters back
                                (let [rep? (flag? @State REPLACE_FLAG) #_int x (if rep? (replace-pop) -1) ;; returns -1 if NL was inserted
                                      ;; In REPLACE mode, in the line we started replacing, we only move the cursor.
                                      win (if (and rep? (<= (:lnum (:w_cursor win)) lnum))
                                            (dec-cursor win, false)
                                            (let [win (if (and rep? (<= (:lnum (:w_cursor win)) @orig_line_count))
                                                        (dec-cursor win, false)
                                                        (let [_ (gchar-cursor win) win (update-in win [:w_cursor :lnum] dec) win (do-join win, 2, false, false, false)]
                                                            (if (and (== _ NUL) (!= (gchar-cursor win) NUL))
                                                                (inc-cursor win, false)
                                                                win
                                                            ))
                                                    )]
                                                ;; In REPLACE mode we have to put back the text that was replaced by the NL.
                                                ;; On the replace stack is first a NUL-terminated sequence of characters
                                                ;; that were deleted and then the characters that NL replaced.
                                                (if rep?
                                                    ;; Do the next ins-char() in NORMAL state, to prevent it
                                                    ;; from replacing characters and avoiding showmatch().
                                                    (let [o'State @State _ (reset! State NORMAL)
                                                          ;; restore characters (blanks) deleted after cursor
                                                          win (loop-when [win win x x] (< 0 x) => win
                                                                (let [o'col (:col (:w_cursor win)) win (mb-replace-pop-ins win, x) win (assoc-in win [:w_cursor :col] o'col)]
                                                                    (recur win (replace-pop))
                                                                ))
                                                          ;; restore the characters that NL replaced
                                                          win (replace-pop-ins win)
                                                          _ (reset! State o'State)]
                                                        win)
                                                    win
                                                ))
                                        )]
                                    (reset! did_ai false)
                                    [win false]
                                ))
                        :else ;; Delete character(s) before the cursor.
                            (let [[win #_int mincol] ;; keep indent
                                    (if (and (== mode BACKSPACE_LINE) @(:b_p_ai @curbuf))
                                        (let [o'col (:col (:w_cursor win)) win (beginline win, BL_WHITE)
                                              mincol (if (< (:col (:w_cursor win)) o'col) (:col (:w_cursor win)) 0)]
                                            [(assoc-in win [:w_cursor :col] o'col) mincol])
                                        [win 0]
                                    )]
                                ;; Handle deleting one 'shiftwidth' or 'softtabstop'.
                                (cond (and (== mode BACKSPACE_CHAR)
                                           (or (and @p_sta in_indent)
                                               (and (non-zero? (get-sts-value))
                                                    (< 0 (:col (:w_cursor win)))
                                                    (let [s (ml-get-cursor win)] (or (at? s -1 TAB) (and (at? s -1 (byte \space)) (or (not @a'inserted_space) @arrow_used)))))))
                                    (let [_ (reset! a'inserted_space false)
                                          #_int ts (if (and @p_sta in_indent) (get-sw-value) (get-sts-value))
                                          ;; Compute the virtual column where we want to be.
                                          ;; Since 'showbreak' may get in the way, need to get the last column of the previous character.
                                          a'vcol (atom (int)) _ (getvcol win, (:w_cursor win), a'vcol, nil, nil) #_int from @a'vcol win (dec-cursor win, false)
                                          a'over (atom (int)) _ (getvcol win, (:w_cursor win), nil, nil, a'over)                    win (inc-cursor win, false)
                                          _ (swap! a'over #(* (/ % ts) ts))
                                          ;; delete characters until we are at or before "over"
                                          win (if (and (< @a'over @a'vcol) (vim-iswhite (.at (ml-get-cursor win) -1)))
                                                (ins-bs-one win, a'vcol)
                                                win)
                                          ;; insert extra spaces until we are at "over"
                                          win (loop-when win (< @a'vcol @a'over) => win
                                                ;; Remember the first char we inserted.
                                                (when (and (== (:lnum (:w_cursor win)) (:lnum @insStart_orig)) (< (:col (:w_cursor win)) (:col @insStart_orig)))
                                                    (swap! insStart_orig assoc :col (:col (:w_cursor win))))
                                                (let [win (if (flag? @State VREPLACE_FLAG)
                                                            (ins-char win, (byte \space))
                                                            (let [win (ins-str win, (u8 " "))]
                                                                (when (flag? @State REPLACE_FLAG)
                                                                    (replace-push NUL))
                                                                win)
                                                        )]
                                                    (getvcol win, (:w_cursor win), a'vcol, nil, nil)
                                                    (recur win)
                                                ))
                                          ;; If we are now back where we started delete one character.
                                          ;; Can happen when using 'sts' and 'linebreak'.
                                          win (if (<= from @a'vcol) (ins-bs-one win, a'vcol) win)]
                                        [win true]
                                    )
                                :else ;; Delete upto starting point, start of line or previous word.
                                    (loop [#_int pls 0 #_int cls (us-get-class (ml-get-cursor win)) mode mode #_boolean word? false]
                                        (let-when [win (dec-cursor win, false) ;; put cursor on char to be deleted
                                              #_int x (gchar-cursor win) pls cls cls (us-get-class (ml-get-cursor win)) ;; look multi-byte character class
                                              [win [mode word? :as _]]
                                                (cond (and (== mode BACKSPACE_WORD) (not (vim-isspace x))) ;; start of word?
                                                    [win [BACKSPACE_WORD_NOT_SPACE (vim-iswordc x)]]
                                                (and (== mode BACKSPACE_WORD_NOT_SPACE) (or (vim-isspace x) (!= (vim-iswordc x) word?) (!= pls cls))) ;; end of word?
                                                    [(inc-cursor win, false) nil]
                                                :else
                                                    [win [mode word?]]
                                                )] (some? _) => [win true]

                                            (let [win (if (flag? @State REPLACE_FLAG)
                                                        (replace-do-bs win, -1)
                                                        (let [#_int* cpc (int-array MAX_MCO) _ (when @p_deco (us-ptr2char-cc (ml-get-cursor win), cpc)) ;; composing characters
                                                              win (del-char win, false)]
                                                            ;; If there are combining characters and 'delcombine' is set,
                                                            ;; move the cursor back.  Don't back up before the base character.
                                                            (if (and @p_deco (non-zero? (aget cpc 0))) (inc-cursor win, false) win))
                                                    )]
                                                (recur-if (and (!= mode BACKSPACE_CHAR) ;; !Just a single backspace?
                                                               (< mincol (:col (:w_cursor win)))
                                                               (or (!= (:lnum (:w_cursor win)) (:lnum @insStart_orig)) (!= (:col (:w_cursor win)) (:col @insStart_orig))))
                                                          [pls cls mode word?]
                                                       => [win true])
                                            ))
                                    ))
                            ))
                ] (some? did_backspace) => [win false]

                    (reset! did_si false) (reset! can_si false) (reset! can_si_back false) (when (<= (:col (:w_cursor win)) 1) (reset! did_ai false))
                    ;; It's a little strange to put backspaces into the redo buffer, but it makes auto-indent a lot easier to deal with.
                    (append-redo-char c)
                    ;; If deleted before the insertion point, adjust it.
                    (when (and (== (:lnum (:w_cursor win)) (:lnum @insStart_orig)) (< (:col (:w_cursor win)) (:col @insStart_orig)))
                        (swap! insStart_orig assoc :col (:col (:w_cursor win))))
                    [win did_backspace])
            ))
    ))

(defn- #_window_C ins-left [#_window_C win]
    (let [lmin 1 o'cursor (:w_cursor win) [win ?] (oneleft? win)]
        (cond ?
            (start-arrow win, o'cursor)
        ;; if 'whichwrap' set for cursor in insert mode, may go to previous line
        (and (some? (vim-strchr @p_ww, (byte \[))) (< lmin (:lnum (:w_cursor win))))
            (-> win
                (start-arrow o'cursor)
                (update-in [:w_cursor :lnum] dec)
                (coladvance MAXCOL)
                (assoc :w_set_curswant true)) ;; so we stay at the end
        :else
            (do (vim-beep) win))
    ))

(defn- #_window_C ins-home [#_window_C win, #_int c]
    (let [lmin 1 o'cursor (:w_cursor win)
          win (if (== c K_C_HOME) (assoc-in win, [:w_cursor :lnum] lmin) win)]
        (-> win
            (update :w_cursor assoc :col 0 :coladd 0)
            (assoc :w_curswant 0)
            (start-arrow o'cursor))
    ))

(defn- #_window_C ins-end [#_window_C win, #_int c]
    (let [lmax (line-count @curbuf) o'cursor (:w_cursor win)
          win (if (== c K_C_END) (assoc-in win, [:w_cursor :lnum] lmax) win)]
        (-> win
            (coladvance MAXCOL)
            (assoc :w_curswant MAXCOL)
            (start-arrow o'cursor))
    ))

(defn- #_window_C ins-s-left [#_window_C win]
    (let-when [lmin 1 o'cursor (:w_cursor win)] (or (< lmin (:lnum o'cursor)) (< 0 (:col o'cursor))) => (do (vim-beep) win)
        (-> win
            (start-arrow o'cursor)
            (bck-word 1, false, false)
            (assoc :w_set_curswant true))
    ))

(defn- #_window_C ins-right [#_window_C win]
    (let [lmax (line-count @curbuf) o'cursor (:w_cursor win) s (ml-get-cursor win)]
        (cond (or (!= (us-ptr2char s) NUL) (virtual-active))
            (let [win (start-arrow win, o'cursor)
                  win (assoc win :w_set_curswant true)]
                (if (virtual-active)
                    (oneright win)
                    (update-in win [:w_cursor :col] + (us-ptr2len-cc s))
                ))
        ;; if 'whichwrap' set for cursor in insert mode, may go to next line
        (and (some? (vim-strchr @p_ww, (byte \]))) (< (:lnum o'cursor) lmax))
            (-> win
                (start-arrow o'cursor)
                (assoc :w_set_curswant true)
                (update-in [:w_cursor :lnum] inc)
                (assoc-in [:w_cursor :col] 0))
        :else
            (do (vim-beep) win))
    ))

(defn- #_window_C ins-s-right [#_window_C win]
    (let-when [lmax (line-count @curbuf) o'cursor (:w_cursor win)] (or (< (:lnum o'cursor) lmax) (!= (gchar-cursor win) NUL)) => (do (vim-beep) win)
        (-> win
            (start-arrow o'cursor)
            (fwd-word 1, false, false)
            (assoc :w_set_curswant true))
    ))

(defn- #_window_C ins-up [#_window_C win, #_boolean startcol]
    ;; startcol: when true move to insStart.col
    (let-when [o'topline (:w_topline win) tpos (:w_cursor win) [win ?] (cursor-up? win, 1, true)] ? => (do (vim-beep) win)
        (let [win (if startcol (coladvance win, (getvcol-nolist @insStart)) win)
              win (if (!= (:w_topline win) o'topline) (redraw-later win, VALID) win)
              win (start-arrow win, tpos)]
            (reset! can_cindent true)
            win)
    ))

(defn- #_window_C ins-pageup [#_window_C win]
    (if (non-flag? @mod_mask MOD_MASK_CTRL)
        (let-when [tpos (:w_cursor win) [win ?] (onepage? win, BACKWARD, 1)] ? => (do (vim-beep) win)
            (let [win (start-arrow win, tpos)]
                (reset! can_cindent true)
                win
            ))
        win
    ))

(defn- #_window_C ins-down [#_window_C win, #_boolean startcol]
    ;; startcol: when true move to insStart.col
    (let-when [o'topline (:w_topline win) tpos (:w_cursor win) [win ?] (cursor-down? win, 1, true)] ? => (do (vim-beep) win)
        (let [win (if startcol (coladvance win, (getvcol-nolist @insStart)) win)
              win (if (!= (:w_topline win) o'topline) (redraw-later win, VALID) win)
              win (start-arrow win, tpos)]
            (reset! can_cindent true)
            win)
    ))

(defn- #_window_C ins-pagedown [#_window_C win]
    (if (non-flag? @mod_mask MOD_MASK_CTRL)
        (let-when [tpos (:w_cursor win) [win ?] (onepage? win, FORWARD, 1)] ? => (do (vim-beep) win)
            (let [win (start-arrow win, tpos)]
                (reset! can_cindent true)
                win
            ))
        win
    ))

(defn- #_window_C ins-drop [#_window_C win]
    (do-put (byte \~), BACKWARD, 1, PUT_CURSEND)
    win)

;; Handle TAB in Insert or Replace mode.
;; Return true when the TAB needs to be inserted like a normal character.

(defn- #_[window_C boolean] ins-tab? [#_window_C win]
    (let [et @(:b_p_et @curbuf) ts @(:b_p_ts @curbuf) sw' (get-sw-value) sts @(:b_p_sts @curbuf) sts' (get-sts-value)
          win (if (and (== @insStart_blank_vcol MAXCOL) (== (:lnum (:w_cursor win)) (:lnum @insStart)))
                (let [win (validate-virtcol win)] (reset! insStart_blank_vcol (:w_virtcol win)) win)
                win)
          #_boolean ind (inindent win, 0) rep? (flag? @State REPLACE_FLAG) vrep? (flag? @State VREPLACE_FLAG)]
        (when ind
            (reset! can_cindent false))
        ;; When nothing special, insert TAB like a normal character
        (if (or (and (not et) (not (and @p_sta ind (!= ts sw'))) (zero? sts')) (not (stop-arrow win)))
            [win true]
            (do
                (reset! did_ai false) (reset! did_si false) (reset! can_si false) (reset! can_si_back false)
                (append-redo (u8 "\t"))
                (let-when [win (validate-virtcol win)
                      ;; Insert tab in indent: use 'shiftwidth', 'softtabstop' or 'tabstop'.
                      #_int t (cond (and @p_sta ind) sw' (!= sts 0) sts' :else ts) t (- t (% (:w_virtcol win) t))
                      ;; Insert the first space with ins-char().  It will delete one char in Replace mode.
                      ;; Insert the rest with ins-str().  It will not delete any chars.
                      ;; For VREPLACE mode, we use ins-char() for all characters.
                      win (loop-when [win (ins-char win, (byte \space)) t (dec t)] (< 0 t) => win
                            (let [win (if vrep?
                                        (ins-char win, (byte \space))
                                        (let [win (ins-str win, (u8 " "))] (when rep? (replace-push NUL)) win)
                                    )]
                                (recur win (dec t)))
                           ;; When 'expandtab' not set: replace spaces with TABs where possible.
                        )] (and (not et) (or (non-zero? sts') (and @p_sta ind))) => [win false]

                    ;; Get the current line.  ;; For VREPLACE mode, don't make real changes yet, just work on a copy of the line.
                    (let-when [#_pos_C cpos (:w_cursor win)
                          [#_Bytes s' #_Bytes s] (if vrep? (let [s' (STRDUP (ml-get (:lnum cpos)))] [s' (.plus s' (:col cpos))]) [nil (ml-get-cursor win)])
                          ;; Find first white before the cursor.
                          [#_pos_C fpos s]
                            (loop-when-recur [fpos cpos s s] (and (< 0 (:col fpos)) (vim-iswhite (.at s -1))) [(update fpos :col dec) (.minus s 1)] => [fpos s])
                          ;; In Replace mode, don't change characters before the insert point.
                          [s fpos]
                            (if (and rep? (== (:lnum fpos) (:lnum @insStart)) (< (:col fpos) (:col @insStart)))
                                [(.plus s (- (:col @insStart) (:col fpos))) (assoc fpos :col (:col @insStart))]
                                [s fpos])
                          ;; Compute virtual column numbers of first white and cursor.
                          a'vcol (atom (int))      _ (getvcol win, fpos, a'vcol, nil, nil)
                          a'want_vcol (atom (int)) _ (getvcol win, cpos, a'want_vcol, nil, nil)
                          ;; Use as many TABs as possible.  ;; Beware of 'breakindent', 'showbreak' and 'linebreak' adding extra virtual columns.
                          [#_int x fpos s]
                            (loop-when [x -1 fpos fpos s s] (vim-iswhite (.at s 0)) => [x fpos s]
                                (let-when [#_int i (lbr-chartabsize nil, (u8 "\t"), @a'vcol)] (not (< @a'want_vcol (+ @a'vcol i))) => [x fpos s]
                                    (swap! a'vcol + i)
                                    (let [x (if (not-at? s TAB) (do (.be s 0, TAB)
                                                (if (< x 0)
                                                    (let [x (:col fpos)] ;; column of first change
                                                        (when (and (== (:lnum fpos) (:lnum @insStart)) (< (:col fpos) (:col @insStart)))
                                                            (swap! insStart assoc :col (:col fpos)))
                                                        x)
                                                    x))
                                                x)]
                                        (recur x (update fpos :col inc) (.plus s 1)))
                                ))] (< -1 x) => [win false]

                        (let [#_Bytes line s
                              ;; Skip over the spaces we need.
                              [s #_int roff]
                                (loop-when-recur [s s roff 0] (and (< @a'vcol @a'want_vcol) (at? s (byte \space))) [(.plus s 1) (inc roff)] => [s roff]
                                    (swap! a'vcol #(+ % (lbr-chartabsize line, s, %))))
                              ;; Must have a char with 'showbreak' just before it.
                              [s roff]
                                (if (< @a'want_vcol @a'vcol) [(.minus s 1) (dec roff)] [s roff])
                              fpos (update fpos :col + roff)
                              ;; Delete following spaces.
                              #_int i (- (:col cpos) (:col fpos))]
                            (when (< 0 i)
                                (BCOPY s, 0, s, i, (inc (STRLEN s, i)))
                                ;; Correct replace stack.
                                (when (and rep? (not vrep?))
                                    (loop-when-recur [#_int t i] (< 0 t) [(dec t)] (replace-join roff))
                                ))
                            ;; In VREPLACE mode, we haven't changed anything yet.
                            ;; Do it now by backspacing over the changed spacing and then inserting the new spacing.
                            (let [win (if vrep?
                                        (-> win (backspace-until-column x) (ins-bytes-len (.plus s' x), (- (:col cpos) i x)))
                                        (update-in win [:w_cursor :col] - i)
                                    )]
                                [win false]
                            ))
                    ))
            ))
    ))

;; Handle CR or NL in Insert mode.
;; Return false when can't undo.

(defn- #_[window_C boolean] ins-eol? [#_window_C win, #_int c]
    (if (stop-arrow win)
        (do ;; Strange Vi behaviour:
            ;; In Replace mode, typing a NL will not delete the character under the cursor.
            ;; Only push a NUL on the replace stack, nothing to put back when the NL is deleted.
            (when (and (flag? @State REPLACE_FLAG) (non-flag? @State VREPLACE_FLAG))
                (replace-push NUL))
            ;; In VREPLACE mode, a NL replaces the rest of the line, and starts replacing the next line,
            ;; so we push all of the characters left on the line onto the replace stack.
            ;; This is not done here though, it is done in open-line().
            ;; Put cursor on NUL if on the last char and coladd is 1 (happens after CTRL-O).
            (let [win (if (and (virtual-active) (< 0 (:coladd (:w_cursor win)))) (coladvance win, (getviscol win)) win)
                  _ (append-redo NL_STR)
                  [win ?] (open-line? win, FORWARD, 0, @old_indent) _ (reset! old_indent 0)]
                (reset! can_cindent true)
                [win ?]
            ))
        [win false]
    ))

(defn- #_window_C ins-eol [#_window_C win, #_int c]
    (let [[win _] (ins-eol? win, c)]
        win
    ))

;; Handle digraph in Insert mode.
;; Returns character still to be inserted, or NUL when nothing remaining to be done.

(defn- #_[window_C int] ins-digraph [#_window_C win]
    (reset! pc_status PC_STATUS_UNSET)
    (let [a'putchar? (atom (boolean false))
          win (if (and (redrawing) (not (char-avail)))
                ;; May need to redraw when no more chars available now.
                (let [win (ins-redraw win, false)
                      win (edit-putchar win, (byte \?), true) _ (reset! a'putchar? true)]
                    (add-to-showcmd-c Ctrl_K)
                    win)
                win)
          ;; Don't map the digraph chars.  ;; This also prevents the mode message to be deleted when ESC is hit.
          _ (swap! no_mapping inc) _ (swap! allow_keys inc) #_int c1 (plain-vgetc) _ (swap! no_mapping dec) _ (swap! allow_keys dec)
          ;; When the line fits in 'columns', the '?' is at the start of the next line and will not be removed by the redraw.
          win (if @a'putchar? (edit-unputchar win) win)]

        (cond (or (is-special c1) (non-zero? @mod_mask)) ;; special key
            (do (clear-showcmd win) [(insert-special win, c1, true, false) NUL])
        (!= c1 ESC)
            (let [_ (reset! a'putchar? false)
                  win (if (and (redrawing) (not (char-avail)))
                        ;; May need to redraw when no more chars available now.
                        (let [win (ins-redraw win, false)
                              win (if (== (mb-char2cells c1) 1)
                                    (let [win (ins-redraw win, false)
                                          win (edit-putchar win, c1, true) _ (reset! a'putchar? true)]
                                        win)
                                    win)]
                            (add-to-showcmd-c c1)
                            win)
                        win)
                  _ (swap! no_mapping inc) _ (swap! allow_keys inc) #_int c2 (plain-vgetc) _ (swap! no_mapping dec) _ (swap! allow_keys dec)
                  ;; When the line fits in 'columns', the '?' is at the start of the next line and will not be removed by a redraw.
                  win (if @a'putchar? (edit-unputchar win) win)

                  #_int c3 (if (!= c2 ESC) (do (append-redo CTRL_V_STR) (getdigraph c1, c2, true)) NUL)]
                (do (clear-showcmd win) [win c3])
            )
        :else
            (do (clear-showcmd win) [win NUL])
        )
    ))

;; Handle CTRL-E and CTRL-Y in Insert mode: copy char from other line.
;; Returns the char to be inserted, or NUL if none found.

(defn- #_[window_C int] ins-copychar [#_window_C win, #_long lnum]
    (let [[win c]
            (if (<= 1 lnum (line-count @curbuf))
                (let [#_Bytes line (ml-get lnum) a's (atom (#_Bytes object line))
                      win (validate-virtcol win) vcol (:w_virtcol win)]
                    (loop-when-recur [#_Bytes prior @a's #_int i 0] ;; try to advance to the cursor column
                                     (and (< i vcol) (non-eos? @a's))
                                     [@a's (+ i (lbr-chartabsize-adv line, a's, i))]
                                  => (when (< vcol i) (reset! a's prior)))
                    [win (us-ptr2char @a's)])
                [win NUL]
            )]
        (when (== c NUL) (vim-beep))
        [win c]
    ))

;; CTRL-Y or CTRL-E typed in Insert mode.

(defn- #_[window_C int] ins-ctrl-ey [#_window_C win, #_int c]
    (let [[win c] (ins-copychar win, (+ (:lnum (:w_cursor win)) (if (== c Ctrl_Y) -1 1)))]
        (if (!= c NUL)
            (do ;; The character must be taken literally, insert like it was typed after a CTRL-V.
                ;; Digits, 'o' and 'x' are special after a CTRL-V, don't use it for these.
                (when (and (< c 256) (not (asc-isalnum c)))
                    (append-redo CTRL_V_STR))
                [(insert-special win, c, true, false) Ctrl_V]) ;; pretend CTRL-V is last character
            [win NUL])
    ))

;; Try to do some very smart auto-indenting.
;; Used when inserting a "normal" character.

(defn- #_window_C ins-try-si [#_window_C win, #_int c]
    ;; do some very smart indenting when entering '{' or '}'
    (let [win (if (or (and (or @did_si @can_si_back) (== c (byte \{))) (and @can_si (== c (byte \}))))
                (let [a'pos (atom (#_pos_C object))]
                    ;; for '}' set indent equal to indent of line containing matching '{'
                    (cond (and (== c (byte \})) (some? (reset! a'pos (findmatch nil, (byte \{)))))
                        ;; If the matching '{' has a ')' immediately before it (ignoring white-space),
                        ;; then line up with the start of the line containing the matching '(' if there is one.
                        ;; This handles the case where an "if (..\n..) {" statement continues over multiple lines.
                        (let [o'cursor (:w_cursor win) #_Bytes s (ml-get (:lnum @a'pos)) #_int i (:col @a'pos)
                              i (if (< 0 i) (loop-when-recur [i (dec i)] (and (< 0 i) (vim-iswhite (.at s i))) [(dec i)] => i) i) ;; skip blanks before '{'
                              win (update win :w_cursor assoc :lnum (:lnum @a'pos) :col i)
                              win (if (and (at? s i (byte \))) (some? (reset! a'pos (findmatch nil, (byte \()))))
                                    (assoc win :w_cursor @a'pos)
                                    win)
                              #_int i (get-indent win) win (assoc win :w_cursor o'cursor)]
                            (if (flag? @State VREPLACE_FLAG)
                                (change-indent win, INDENT_SET, i, false, NUL, true)
                                (set-indent win, i, SIN_CHANGED)
                            ))
                    (< 0 (:col (:w_cursor win)))
                        ;; when inserting '{' after "O" reduce indent, but not more than indent of previous line
                        (let [[win shl?]
                                (if (and (== c (byte \{)) @can_si_back (< 1 (:lnum (:w_cursor win))))
                                    (let [o'cursor (:w_cursor win) o'indent (get-indent win)
                                          skip- #(loop-when [l %] (< 1 l) => l ;; ignore empty lines and lines starting with '#'
                                                    (let [l (dec l) s (skipwhite (ml-get l))] (recur-if (or (at? s (byte \#)) (eos? s)) l => l)))
                                          win (update-in win [:w_cursor :lnum] skip-)
                                          shl? (< (get-indent win) o'indent)]
                                        [(assoc win :w_cursor o'cursor) shl?])
                                    [win true]
                                )]
                            (if shl? (shift-line win, true, false, 1, true) win))
                    :else
                        win))
                win)
          ;; set indent of '#' always to 0
          win (if (and (< 0 (:col (:w_cursor win))) @can_si (== c (byte \#)))
                (do ;; remember current indent for next line
                    (reset! old_indent (get-indent win))
                    (set-indent win, 0, SIN_CHANGED))
                win
            )]
        ;; Adjust ai_col, the char at this position can be deleted.
        (when (< (:col (:w_cursor win)) @ai_col)
            (reset! ai_col (:col (:w_cursor win))))
        win
    ))

;; Handle the InsertCharPre autocommand.
;; "c" is the character that was typed.
;; Return a pointer to allocated memory with the replacement string.
;; Return null to continue inserting "c".

(defn- #_Bytes do-insert-char-pre [#_int c]
    ;; %% not yet
    nil)

;;; ============================================================================================== VimN

;; regexp.c ---------------------------------------------------------------------------------------

;; Handling of regular expressions: vim-regcomp(), vim-regexec(), vim-regsub()
;;
;; Beware that some of this code is subtly aware of the way operator
;; precedence is structured in regular expressions.  Serious changes in
;; regular-expression syntax might require a total rethink.

;; The "internal use only" fields in regexp.h are present to pass info from
;; compile to execute that permits the execute phase to run lots faster on
;; simple cases.  They are:
;;
;; regstart     char that must begin a match; NUL if none obvious; Can be a
;;              multi-byte character.
;; reganch      is the match anchored (at beginning-of-line only)?
;; regmust      string (pointer into program) that match must include, or null
;; regmlen      length of regmust string
;; regflags     RF_ values or'ed together
;;
;; Regstart and reganch permit very fast decisions on suitable starting points
;; for a match, cutting down the work a lot.  Regmust permits fast rejection
;; of lines that cannot possibly match.  The regmust tests are costly enough
;; that vim-regcomp() supplies a regmust only if the r.e. contains something
;; potentially expensive (at present, the only such thing detected is * or +
;; at the start of the r.e., which can involve a lot of backup).  Regmlen is
;; supplied because the test in vim-regexec() needs it and vim-regcomp() is
;; computing it anyway.

;; Structure for regexp "program".  This is essentially a linear encoding
;; of a nondeterministic finite-state machine (aka syntax charts or
;; "railroad normal form" in parsing technology).  Each node is an opcode
;; plus a "next" pointer, possibly plus an operand.  "Next" pointers of
;; all nodes except BRANCH and BRACES_COMPLEX implement concatenation; a "next"
;; pointer with a BRANCH on both ends of it is connecting two alternatives.
;; (Here we have one of the subtle syntax dependencies: an individual BRANCH
;; (as opposed to a collection of them) is never concatenated with anything
;; because of operator precedence).  The "next" pointer of a BRACES_COMPLEX
;; node points to the node after the stuff to be repeated.
;; The operand of some types of node is a literal string; for others, it is a
;; node leading into a sub-FSM.  In particular, the operand of a BRANCH node
;; is the first node of the branch.
;; (NB this is *not* a tree structure: the tail of the branch connects to the
;; thing following the set of BRANCHes.)
;;
;; pattern      is coded like:
;;
;;                        +-----------------+
;;                        |                 V
;; <aa>\|<bb>   BRANCH <aa> BRANCH <bb> --> END
;;                   |      ^    |          ^
;;                   +------+    +----------+
;;
;;                     +------------------+
;;                     V                  |
;; <aa>*        BRANCH BRANCH <aa> --> BACK BRANCH --> NOTHING --> END
;;                   |      |               ^                      ^
;;                   |      +---------------+                      |
;;                   +---------------------------------------------+
;;
;;                     +----------------------+
;;                     V                      |
;; <aa>\+       BRANCH <aa> --> BRANCH --> BACK  BRANCH --> NOTHING --> END
;;                   |               |           ^                      ^
;;                   |               +-----------+                      |
;;                   +--------------------------------------------------+
;;
;;                                      +-------------------------+
;;                                      V                         |
;; <aa>\{}      BRANCH BRACE_LIMITS --> BRACE_COMPLEX <aa> --> BACK  END
;;                   |                              |                ^
;;                   |                              +----------------+
;;                   +-----------------------------------------------+
;;
;; <aa>\@!<bb>  BRANCH NOMATCH <aa> --> END  <bb> --> END
;;                   |       |                ^       ^
;;                   |       +----------------+       |
;;                   +--------------------------------+
;;
;;                                                    +---------+
;;                                                    |         V
;; \z[abc]      BRANCH BRANCH  a  BRANCH  b  BRANCH  c  BRANCH  NOTHING --> END
;;                   |      |          |          |     ^                   ^
;;                   |      |          |          +-----+                   |
;;                   |      |          +----------------+                   |
;;                   |      +---------------------------+                   |
;;                   +------------------------------------------------------+
;;
;; They all start with a BRANCH for "\|" alternatives, even when there is only
;; one alternative.

;; The opcodes are:

;; definition   number             opnd?    meaning
(final int END             0)       ;;      End of program or NOMATCH operand.
(final int BOL             1)       ;;      Match "" at beginning of line.
(final int EOL             2)       ;;      Match "" at end of line.
(final int BRANCH          3)       ;; node Match this alternative, or the next...
(final int BACK            4)       ;;      Match "", "next" ptr points backward.
(final int EXACTLY         5)       ;; str  Match this string.
(final int NOTHING         6)       ;;      Match empty string.
(final int STAR            7)       ;; node Match this (simple) thing 0 or more times.
(final int PLUS            8)       ;; node Match this (simple) thing 1 or more times.
(final int MATCH           9)       ;; node match the operand zero-width
(final int NOMATCH         10)      ;; node check for no match with operand
(final int BEHIND          11)      ;; node look behind for a match with operand
(final int NOBEHIND        12)      ;; node look behind for no match with operand
(final int SUBPAT          13)      ;; node match the operand here
(final int BRACE_SIMPLE    14)      ;; node Match this (simple) thing between m and
                                    ;;      n times (\{m,n\}).
(final int BOW             15)      ;;      Match "" after [^a-zA-Z0-9_]
(final int EOW             16)      ;;      Match "" at    [^a-zA-Z0-9_]
(final int BRACE_LIMITS    17)      ;; nr nr  define the min & max for BRACE_SIMPLE
                                    ;;      and BRACE_COMPLEX.
(final int NEWL            18)      ;;      Match line-break
(final int BHPOS           19)      ;;      End position for BEHIND or NOBEHIND

;; character classes: 20-48 normal, 50-78 include a line-break
(final int ADD_NL          30)

(final int ANY             20)      ;;      Match any one character.
(final int ANYOF           21)      ;; str  Match any character in this string.
(final int ANYBUT          22)      ;; str  Match any character not in this string.
(final int IDENT           23)      ;;      Match identifier char
(final int SIDENT          24)      ;;      Match identifier char but no digit
(final int KWORD           25)      ;;      Match keyword char
(final int SKWORD          26)      ;;      Match word char but no digit
(final int FNAME           27)      ;;      Match file name char
(final int SFNAME          28)      ;;      Match file name char but no digit
(final int PRINT           29)      ;;      Match printable char
(final int SPRINT          30)      ;;      Match printable char but no digit
(final int WHITE           31)      ;;      Match whitespace char
(final int NWHITE          32)      ;;      Match non-whitespace char
(final int DIGIT           33)      ;;      Match digit char
(final int NDIGIT          34)      ;;      Match non-digit char
(final int HEX             35)      ;;      Match hex char
(final int NHEX            36)      ;;      Match non-hex char
(final int OCTAL           37)      ;;      Match octal char
(final int NOCTAL          38)      ;;      Match non-octal char
(final int WORD            39)      ;;      Match word char
(final int NWORD           40)      ;;      Match non-word char
(final int HEAD            41)      ;;      Match head char
(final int NHEAD           42)      ;;      Match non-head char
(final int ALPHA           43)      ;;      Match alpha char
(final int NALPHA          44)      ;;      Match non-alpha char
(final int LOWER           45)      ;;      Match lowercase char
(final int NLOWER          46)      ;;      Match non-lowercase char
(final int UPPER           47)      ;;      Match uppercase char
(final int NUPPER          48)      ;;      Match non-uppercase char

(final int FIRST_NL        (+ ANY ADD_NL))
(final int LAST_NL         (+ NUPPER ADD_NL))

(defn- #_boolean with-nl [#_int op]
    (<= FIRST_NL op LAST_NL))

(final int MOPEN           80)  ;; -89       Mark this point in input as start of \( subexpr.  MOPEN + 0 marks start of match.
(final int MCLOSE          90)  ;; -99       Analogous to MOPEN.  MCLOSE + 0 marks end of match.
(final int BACKREF         100) ;; -109 node Match same string again \1-\9

(final int ZOPEN           110) ;; -119      Mark this point in input as start of \z( subexpr.
(final int ZCLOSE          120) ;; -129      Analogous to ZOPEN.
(final int ZREF            130) ;; -139 node Match external submatch \z1-\z9

(final int BRACE_COMPLEX   140) ;; -149 node Match nodes between m & n times

(final int NOPEN           150)     ;;      Mark this point in input as start of \%( subexpr.
(final int NCLOSE          151)     ;;      Analogous to NOPEN.

(final int MULTIBYTECODE   200)     ;; mbc  Match one multi-byte character
(final int RE_BOF          201)     ;;      Match "" at beginning of file.
(final int RE_EOF          202)     ;;      Match "" at end of file.
(final int CURSOR          203)     ;;      Match location of cursor.

(final int RE_LNUM         204)     ;; nr cmp  Match line number
(final int RE_COL          205)     ;; nr cmp  Match column number
(final int RE_VCOL         206)     ;; nr cmp  Match virtual column number

(final int RE_MARK         207)     ;; mark cmp  Match mark position
(final int RE_VISUAL       208)     ;;      Match Visual area
(final int RE_COMPOSING    209)     ;; any composing characters

;; Magic characters have a special meaning, they don't match literally.
;; Magic characters are negative.  This separates them from literal characters
;; (possibly multi-byte).  Only ASCII characters can be Magic.

(defn- #_final #_int Magic [#_int x]
    (- x 256))

(defn- #_int un-Magic [#_int x]
    (+ x 256))

(defn- #_boolean is-Magic [#_int x]
    (< x 0))

(defn- #_int no-Magic [#_int x]
    (if (is-Magic x) (un-Magic x) x))

(defn- #_int toggle-Magic [#_int x]
    (if (is-Magic x) (un-Magic x) (Magic x)))

;; The first byte of the regexp internal "program" is actually this magic number;
;; the start node begins in the second byte.
;; It's used to catch the most severe mutilation of the program by the caller.

(final byte! REGMAGIC 0234)

;; Opcode notes:
;;
;; BRANCH           The set of branches constituting a single choice are hooked
;;                  together with their "next" pointers, since precedence prevents
;;                  anything being concatenated to any individual branch.  The
;;                  "next" pointer of the last BRANCH in a choice points to the
;;                  thing following the whole choice.  This is also where the
;;                  final "next" pointer of each individual branch points; each
;;                  branch starts with the operand node of a BRANCH node.
;;
;; BACK             Normal "next" pointers all implicitly point forward; BACK
;;                  exists to make loop structures possible.
;;
;; STAR,PLUS        '=', and complex '*' and '+', are implemented as circular
;;                  BRANCH structures using BACK.  Simple cases (one character
;;                  per match) are implemented with STAR and PLUS for speed
;;                  and to minimize recursive plunges.
;;
;; BRACE_LIMITS     This is always followed by a BRACE_SIMPLE or BRACE_COMPLEX
;;                  node, and defines the min and max limits to be used for that node.
;;
;; MOPEN, MCLOSE    ... are numbered at compile time.
;; ZOPEN, ZCLOSE    ... ditto

;; A node is one char of opcode followed by two chars of "next" pointer.
;; "Next" pointers are stored as two 8-bit bytes, high order first.  The
;; value is a positive offset from the opcode of the node containing it.
;; An operand, if any, simply follows the node.  (Note that much of the
;; code generation knows about this implicit relationship.)
;;
;; Using two bytes for the "next" pointer is vast overkill for most things,
;; but allows patterns to get big without disasters.

(defn- #_int re-op [#_Bytes p]
    (int (.at p 0)))

(defn- #_int re-next [#_Bytes p]
    (+ (<< (int (.at p 1)) 8) (int (.at p 2))))

(defn- #_Bytes operand [#_Bytes p]
    (.plus p 3))

;; Obtain an operand that was stored as four bytes, MSB first.
(defn- #_long operand-min [#_Bytes p]
    (+ (<< (long (.at p 3)) 24) (<< (long (.at p 4)) 16) (<< (long (.at p 5)) 8) (long (.at p 6))))

;; Obtain a second operand stored as four bytes.
(defn- #_long operand-max [#_Bytes p]
    (operand-min (.plus p 4)))

;; Obtain a second single-byte operand stored after a four bytes operand.
(defn- #_byte operand-cmp [#_Bytes p]
    (.at p 7))

(final long MAX_LIMIT       (<< 32767 16))

(final Bytes e_missingbracket  (u8 "E769: Missing ] after %s["))
(final Bytes e_unmatchedpp     (u8 "E53: Unmatched %s%%("))
(final Bytes e_unmatchedp      (u8 "E54: Unmatched %s("))
(final Bytes e_unmatchedpar    (u8 "E55: Unmatched %s)"))
(final Bytes e_z_not_allowed   (u8 "E66: \\z( not allowed here"))
(final Bytes e_z1_not_allowed  (u8 "E67: \\z1 et al. not allowed here"))
(final Bytes e_missing_sb      (u8 "E69: Missing ] after %s%%["))
(final Bytes e_empty_sb        (u8 "E70: Empty %s%%[]"))

(final int
    NOT_MULTI       0,
    MULTI_ONE       1,
    MULTI_MULT      2)

;; Return NOT_MULTI if c is not a "multi" operator.
;; Return MULTI_ONE if c is a single "multi" operator.
;; Return MULTI_MULT if c is a multi "multi" operator.

(defn- #_int re-multi-type [#_int c]
    (condp ==? c
        [(Magic (byte \@)) (Magic (byte \=)) (Magic (byte \?))]
            MULTI_ONE
        [(Magic (byte \*)) (Magic (byte \+)) (Magic (byte \{))]
            MULTI_MULT
     ;; :else
            NOT_MULTI
    ))

;; Flags to be passed up and down.

(final int HASWIDTH        0x1)     ;; Known never to match null string.
(final int SIMPLE          0x2)     ;; Simple enough to be STAR/PLUS operand.
(final int SPSTART         0x4)     ;; Starts with * or +.
(final int HASNL           0x8)     ;; Contains some \n.
(final int HASLOOKBH       0x10)    ;; Contains "\@<=" or "\@<!".
(final int WORST           0)       ;; Worst case.

;; When regcode is set to this value, code is not emitted and size is computed instead.

(final Bytes JUST_CALC_SIZE (u8 ""))

(atom! Bytes reg_prev_sub)

;; REGEXP_INRANGE contains all characters which are always special in a [] range after '\'.
;; REGEXP_ABBR contains all characters which act as abbreviations after '\'.
;; These are:
;;  \n  - New line (NL).
;;  \r  - Carriage Return (CR).
;;  \t  - Tab (TAB).
;;  \e  - Escape (ESC).
;;  \b  - Backspace (Ctrl_H).
;;  \d  - Character code in decimal, e.g. \d123
;;  \o  - Character code in octal, e.g. \o80
;;  \x  - Character code in hex, e.g. \x4a
;;  \\u (sic!) - Multibyte character code, e.g. \u20ac
;;  \U  - Long multibyte character code, e.g. \U12345678

(final Bytes REGEXP_INRANGE (u8 "]^-n\\"))
(final Bytes REGEXP_ABBR (u8 "nrtebdoxuU"))

;; Translate '\x' to its control character, except "\n", which is Magic.

(defn- #_int backslash-trans [#_int c]
    (condp == c
        (byte \r) CAR
        (byte \t) TAB
        (byte \e) ESC
        (byte \b) BS
                  c
    ))

(final int
    CLASS_ALNUM      0,
    CLASS_ALPHA      1,
    CLASS_BLANK      2,
    CLASS_CNTRL      3,
    CLASS_DIGIT      4,
    CLASS_GRAPH      5,
    CLASS_LOWER      6,
    CLASS_PRINT      7,
    CLASS_PUNCT      8,
    CLASS_SPACE      9,
    CLASS_UPPER     10,
    CLASS_XDIGIT    11,
    CLASS_TAB       12,
    CLASS_RETURN    13,
    CLASS_BACKSPACE 14,
    CLASS_ESCAPE    15,
    CLASS_NONE      99)

(final Bytes* class_names
    [
        (u8 "alnum:]")
        (u8 "alpha:]")
        (u8 "blank:]")
        (u8 "cntrl:]")
        (u8 "digit:]")
        (u8 "graph:]")
        (u8 "lower:]")
        (u8 "print:]")
        (u8 "punct:]")
        (u8 "space:]")
        (u8 "upper:]")
        (u8 "xdigit:]")
        (u8 "tab:]")
        (u8 "return:]")
        (u8 "backspace:]")
        (u8 "escape:]")
    ])

;; Check for a character class name "[:name:]".  "s" points to the '['.
;; Returns one of the CLASS_ items.  CLASS_NONE means that no item was
;; recognized.  Otherwise "s" is advanced to after the item.

(defn- #_int get-char-class [#_Bytes' a's]
    (if (at? @a's 1 (byte \:))
        (loop-when [#_int i 0] (< i (:length class_names)) => CLASS_NONE
            (let [#_int n (STRLEN (... class_names i))]
                (if (zero? (STRNCMP (.plus @a's 2), (... class_names i), n))
                    (do (swap! a's plus (+ 2 n)) i)
                    (recur (inc i))
                )))
        CLASS_NONE
    ))

;; Specific version of character class functions.
;; Using a table to keep this fast.

(final int
    RI_DIGIT    0x01,
    RI_HEX      0x02,
    RI_OCTAL    0x04,
    RI_WORD     0x08,
    RI_HEAD     0x10,
    RI_ALPHA    0x20,
    RI_LOWER    0x40,
    RI_UPPER    0x80,
    RI_WHITE    0x100)

(defn- #_int* init-class-tab []
    (let [cls- #(cond
                    (any == % TAB (byte \space))  RI_WHITE
                    (<= (byte \0) % (byte \7)) (+ RI_DIGIT RI_HEX RI_OCTAL RI_WORD)
                    (<= (byte \8) % (byte \9)) (+ RI_DIGIT RI_HEX RI_WORD)
                    (<= (byte \a) % (byte \f)) (+ RI_HEX RI_WORD RI_HEAD RI_ALPHA RI_LOWER)
                    (<= (byte \g) % (byte \z)) (+ RI_WORD RI_HEAD RI_ALPHA RI_LOWER)
                    (<= (byte \A) % (byte \F)) (+ RI_HEX RI_WORD RI_HEAD RI_ALPHA RI_UPPER)
                    (<= (byte \G) % (byte \Z)) (+ RI_WORD RI_HEAD RI_ALPHA RI_UPPER)
                    (== % (byte \_))           (+ RI_WORD RI_HEAD)
                :else 0
            )]
        (vec (map cls- (range 256)))
    ))

(final int* class_tab (init-class-tab))

(defn- #_boolean ri-digit [#_int c] (and (< c 0x100) (flag? (... class_tab c) RI_DIGIT)))
(defn- #_boolean ri-hex   [#_int c] (and (< c 0x100) (flag? (... class_tab c) RI_HEX)))
(defn- #_boolean ri-octal [#_int c] (and (< c 0x100) (flag? (... class_tab c) RI_OCTAL)))
(defn- #_boolean ri-word  [#_int c] (and (< c 0x100) (flag? (... class_tab c) RI_WORD)))
(defn- #_boolean ri-head  [#_int c] (and (< c 0x100) (flag? (... class_tab c) RI_HEAD)))
(defn- #_boolean ri-alpha [#_int c] (and (< c 0x100) (flag? (... class_tab c) RI_ALPHA)))
(defn- #_boolean ri-lower [#_int c] (and (< c 0x100) (flag? (... class_tab c) RI_LOWER)))
(defn- #_boolean ri-upper [#_int c] (and (< c 0x100) (flag? (... class_tab c) RI_UPPER)))
(defn- #_boolean ri-white [#_int c] (and (< c 0x100) (flag? (... class_tab c) RI_WHITE)))

;; flags for regflags
(final int
    RF_ICASE    1,   ;; ignore case
    RF_NOICASE  2,   ;; don't ignore case
    RF_HASNL    4,   ;; can match a NL
    RF_ICOMBINE 8,   ;; ignore combining characters
    RF_LOOKBH   16)  ;; uses "\@<=" or "\@<!"

;; Global work variables for vim-regcomp().

(atom! Bytes    regparse)                   ;; input-scan pointer
(atom! int      prevchr_len)                ;; byte length of previous char
(atom! int      num_complex_braces)         ;; complex \{...} count
(atom! int      regnpar)                    ;; () count
(atom! int      regnzpar)                   ;; \z() count
(atom! int      re_has_z)                   ;; \z item detected
(atom! Bytes    regcode)                    ;; code-emit pointer, or JUST_CALC_SIZE
(atom! int      regsize)                    ;; code size
(atom! boolean  reg_toolong)                ;; true when offset out of range
(atom! boolean* had_endbrace    NSUBEXP)    ;; flags, true if end of () found
(atom! int      regflags)                   ;; RF_ flags for prog
(atom! long*    brace_min       10)         ;; minimums for complex brace repeats
(atom! long*    brace_max       10)         ;; maximums for complex brace repeats
(atom! int*     brace_count     10)         ;; current counts for complex brace repeats
(atom! boolean  one_exactly)                ;; only do one char for EXACTLY

(atom! int      reg_magic)                  ;; magicness of the pattern:
(final int
    MAGIC_NONE  1,                   ;; "\V" very unmagic
    MAGIC_OFF   2,                   ;; "\M" or 'magic' off
    MAGIC_ON    3,                   ;; "\m" or 'magic'
    MAGIC_ALL   4)                   ;; "\v" very magic

(atom! boolean  reg_string)                 ;; matching with a string instead of a buffer line
(atom! boolean  reg_strict)                 ;; "[abc" is illegal

;; META contains all characters that may be magic, except '^' and '$'.

;; META[] is used often enough to justify turning it into a table.
(final byte* META_flags
    [
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
;;                     %  &     (  )  *  +        .
        0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 1, 0,
;;         1  2  3  4  5  6  7  8  9        <  =  >  ?
        0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1,
;;      @  A     C  D     F     H  I     K  L  M     O
        1, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 1, 1, 0, 1,
;;      P        S     U  V  W  X     Z  [           _
        1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 1,
;;         a     c  d     f     h  i     k  l  m  n  o
        0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1,
;;      p        s     u  v  w  x     z  {  |     ~
        1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1
    ])

(atom! int      curchr)             ;; currently parsed character

;; Previous character.  Note: prevchr is sometimes -1 when we are not at the start,
;; e.g. in /[ ^I]^ the pattern was never found even if it existed,
;; because ^ was taken to be magic.

(atom! int      prevchr)
(atom! int      prevprevchr)        ;; previous-previous character
(atom! int      nextchr)            ;; used for ungetchr()

;; arguments for reg()
(final int REG_NOPAREN     0)           ;; toplevel reg()
(final int REG_PAREN       1)           ;; \(\)
(final int REG_ZPAREN      2)           ;; \z(\)
(final int REG_NPAREN      3)           ;; \%(\)

(class! #_final parse_state_C
    [
        (field Bytes        regparse)
        (field int          prevchr_len)
        (field int          curchr)
        (field int          prevchr)
        (field int          prevprevchr)
        (field int          nextchr)
        (field boolean      at_start)
        (field boolean      prev_at_start)
        (field int          regnpar)
    ])

;; Forward declarations for vim-regcomp()'s friends.

;   static regengine_C bt_regengine = new regengine_C()
;   {
;       public regprog_C regcomp(Bytes expr, int re_flags)
;       {
; %%        ((ร RETURN) (bt-regcomp expr, re_flags))
;       }

;       public long regexec_nl(regmatch_C rmp, Bytes line, int col, boolean line_lbr)
;       {
; %%        ((ร RETURN) (bt-regexec-nl rmp, line, col, line_lbr))
;       }

;       public long regexec_multi(regmmatch_C rmp, long lnum, int col, long nsec)
;       {
; %%        ((ร RETURN) (bt-regexec-multi rmp, lnum, col, nsec))
;       }
;   };

;   static regengine_C nfa_regengine = new regengine_C()
;   {
;       public regprog_C regcomp(Bytes expr, int re_flags)
;       {
; %%        ((ร RETURN) (nfa-regcomp expr, re_flags))
;       }

;       public long regexec_nl(regmatch_C rmp, Bytes line, int col, boolean line_lbr)
;       {
; %%        ((ร RETURN) (nfa-regexec-nl rmp, line, col, line_lbr))
;       }

;       public long regexec_multi(regmmatch_C rmp, long lnum, int col, long nsec)
;       {
; %%        ((ร RETURN) (nfa-regexec-multi rmp, lnum, col, nsec))
;       }
;   };

;; Return true if compiled regular expression "prog" can match a line break.

(defn- #_boolean re-multiline [#_regprog_C prog]
    (flag? (:regflags prog) RF_HASNL))

;; Return true if compiled regular expression "prog" looks before the start
;; position (pattern contains "\@<=" or "\@<!").

(defn- #_boolean re-lookbehind [#_regprog_C prog]
    (flag? (:regflags prog) RF_LOOKBH))

;; Check for an equivalence class name "[=a=]".  "s" points to the '['.
;; Returns a character representing the class.  Zero means that no item
;; was recognized.  Otherwise "s" is advanced to after the item.

(defn- #_int get-equi-class [#_Bytes' a's]
    (let-when [s @a's] (at? s 1 (byte \=)) => 0
        (let-when [n (us-ptr2len-cc s, 2)] (and (at? s (+ n 2) (byte \=)) (at? s (+ n 3) (byte \]))) => 0
            (let [c (us-ptr2char s, 2)] (swap! a's plus (+ n 4)) c)
        )))

;; Produce the bytes for equivalence class "c".
;; Currently only handles latin1, latin9 and utf-8.
;;
;; NOTE! When changing this function, also change nfa-emit-equi-class()

(defn- #_void reg-equi-class [#_int c]
    (condp ==? c
        [(byte \A), 0xc0 0xc1 0xc2, 0xc3 0xc4 0xc5, 0x100 0x102 0x104, 0x1cd 0x1de 0x1e0, 0x1ea2]
        (do
            (regmbc (byte \A))
            (regmbc 0xc0) (regmbc 0xc1) (regmbc 0xc2)
            (regmbc 0xc3) (regmbc 0xc4) (regmbc 0xc5)
            (regmbc 0x100) (regmbc 0x102) (regmbc 0x104)
            (regmbc 0x1cd) (regmbc 0x1de) (regmbc 0x1e0)
            (regmbc 0x1ea2)
        )

        [(byte \a), 0xe0 0xe1 0xe2, 0xe3 0xe4 0xe5, 0x101 0x103 0x105, 0x1ce 0x1df 0x1e1, 0x1ea3]
        (do
            (regmbc (byte \a))
            (regmbc 0xe0) (regmbc 0xe1) (regmbc 0xe2)
            (regmbc 0xe3) (regmbc 0xe4) (regmbc 0xe5)
            (regmbc 0x101) (regmbc 0x103) (regmbc 0x105)
            (regmbc 0x1ce) (regmbc 0x1df) (regmbc 0x1e1)
            (regmbc 0x1ea3)
        )

        [(byte \B), 0x1e02 0x1e06]
        (do
            (regmbc (byte \B))
            (regmbc 0x1e02) (regmbc 0x1e06)
        )

        [(byte \b), 0x1e03 0x1e07]
        (do
            (regmbc (byte \b))
            (regmbc 0x1e03) (regmbc 0x1e07)
        )

        [(byte \C), 0xc7, 0x106 0x108 0x10a 0x10c]
        (do
            (regmbc (byte \C))
            (regmbc 0xc7)
            (regmbc 0x106) (regmbc 0x108) (regmbc 0x10a) (regmbc 0x10c)
        )

        [(byte \c), 0xe7, 0x107 0x109 0x10b 0x10d]
        (do
            (regmbc (byte \c))
            (regmbc 0xe7)
            (regmbc 0x107) (regmbc 0x109) (regmbc 0x10b) (regmbc 0x10d)
        )

        [(byte \D), 0x10e 0x110, 0x1e0a 0x1e0c 0x1e0e 0x1e10 0x1e12]
        (do
            (regmbc (byte \D))
            (regmbc 0x10e) (regmbc 0x110)
            (regmbc 0x1e0a) (regmbc 0x1e0c) (regmbc 0x1e0e) (regmbc 0x1e10) (regmbc 0x1e12)
        )

        [(byte \d), 0x10f 0x111, 0x1e0b 0x1e0d 0x1e0f 0x1e11 0x1e13]
        (do
            (regmbc (byte \d))
            (regmbc 0x10f) (regmbc 0x111)
            (regmbc 0x1e0b) (regmbc 0x1e0d) (regmbc 0x1e0f) (regmbc 0x1e11) (regmbc 0x1e13)
        )

        [(byte \E), 0xc8 0xc9 0xca 0xcb, 0x112 0x114 0x116 0x118 0x11a, 0x1eba 0x1ebc]
        (do
            (regmbc (byte \E))
            (regmbc 0xc8) (regmbc 0xc9) (regmbc 0xca) (regmbc 0xcb)
            (regmbc 0x112) (regmbc 0x114) (regmbc 0x116) (regmbc 0x118) (regmbc 0x11a)
            (regmbc 0x1eba) (regmbc 0x1ebc)
        )

        [(byte \e), 0xe8 0xe9 0xea 0xeb, 0x113 0x115 0x117 0x119 0x11b, 0x1ebb 0x1ebd]
        (do
            (regmbc (byte \e))
            (regmbc 0xe8) (regmbc 0xe9) (regmbc 0xea) (regmbc 0xeb)
            (regmbc 0x113) (regmbc 0x115) (regmbc 0x117) (regmbc 0x119) (regmbc 0x11b)
            (regmbc 0x1ebb) (regmbc 0x1ebd)
        )

        [(byte \F), 0x1e1e]
        (do
            (regmbc (byte \F))
            (regmbc 0x1e1e)
        )

        [(byte \f), 0x1e1f]
        (do
            (regmbc (byte \f))
            (regmbc 0x1e1f)
        )

        [(byte \G), 0x11c 0x11e 0x120 0x122, 0x1e4 0x1e6 0x1f4, 0x1e20]
        (do
            (regmbc (byte \G))
            (regmbc 0x11c) (regmbc 0x11e) (regmbc 0x120) (regmbc 0x122)
            (regmbc 0x1e4) (regmbc 0x1e6) (regmbc 0x1f4)
            (regmbc 0x1e20)
        )

        [(byte \g), 0x11d 0x11f 0x121 0x123, 0x1e5 0x1e7 0x1f5, 0x1e21]
        (do
            (regmbc (byte \g))
            (regmbc 0x11d) (regmbc 0x11f) (regmbc 0x121) (regmbc 0x123)
            (regmbc 0x1e5) (regmbc 0x1e7) (regmbc 0x1f5)
            (regmbc 0x1e21)
        )

        [(byte \H), 0x124 0x126, 0x1e22 0x1e26 0x1e28]
        (do
            (regmbc (byte \H))
            (regmbc 0x124) (regmbc 0x126)
            (regmbc 0x1e22) (regmbc 0x1e26) (regmbc 0x1e28)
        )

        [(byte \h), 0x125 0x127, 0x1e23 0x1e27 0x1e29 0x1e96]
        (do
            (regmbc (byte \h))
            (regmbc 0x125) (regmbc 0x127)
            (regmbc 0x1e23) (regmbc 0x1e27) (regmbc 0x1e29) (regmbc 0x1e96)
        )

        [(byte \I), 0xcc 0xcd 0xce 0xcf, 0x128 0x12a 0x12c 0x12e 0x130, 0x1cf, 0x1ec8]
        (do
            (regmbc (byte \I))
            (regmbc 0xcc) (regmbc 0xcd) (regmbc 0xce) (regmbc 0xcf)
            (regmbc 0x128) (regmbc 0x12a) (regmbc 0x12c) (regmbc 0x12e) (regmbc 0x130)
            (regmbc 0x1cf)
            (regmbc 0x1ec8)
        )

        [(byte \i), 0xec 0xed 0xee 0xef, 0x129 0x12b 0x12d 0x12f 0x131, 0x1d0, 0x1ec9]
        (do
            (regmbc (byte \i))
            (regmbc 0xec) (regmbc 0xed) (regmbc 0xee) (regmbc 0xef)
            (regmbc 0x129) (regmbc 0x12b) (regmbc 0x12d) (regmbc 0x12f) (regmbc 0x131)
            (regmbc 0x1d0)
            (regmbc 0x1ec9)
        )

        [(byte \J), 0x134]
        (do
            (regmbc (byte \J))
            (regmbc 0x134)
        )

        [(byte \j), 0x135 0x1f0]
        (do
            (regmbc (byte \j))
            (regmbc 0x135) (regmbc 0x1f0)
        )

        [(byte \K), 0x136 0x1e8, 0x1e30 0x1e34]
        (do
            (regmbc (byte \K))
            (regmbc 0x136) (regmbc 0x1e8)
            (regmbc 0x1e30) (regmbc 0x1e34)
        )

        [(byte \k), 0x137 0x1e9, 0x1e31 0x1e35]
        (do
            (regmbc (byte \k))
            (regmbc 0x137) (regmbc 0x1e9)
            (regmbc 0x1e31) (regmbc 0x1e35)
        )

        [(byte \L), 0x139 0x13b 0x13d 0x13f 0x141, 0x1e3a]
        (do
            (regmbc (byte \L))
            (regmbc 0x139) (regmbc 0x13b) (regmbc 0x13d) (regmbc 0x13f) (regmbc 0x141)
            (regmbc 0x1e3a)
        )

        [(byte \l), 0x13a 0x13c 0x13e 0x140 0x142, 0x1e3b]
        (do
            (regmbc (byte \l))
            (regmbc 0x13a) (regmbc 0x13c) (regmbc 0x13e) (regmbc 0x140) (regmbc 0x142)
            (regmbc 0x1e3b)
        )

        [(byte \M), 0x1e3e 0x1e40]
        (do
            (regmbc (byte \M))
            (regmbc 0x1e3e) (regmbc 0x1e40)
        )

        [(byte \m), 0x1e3f 0x1e41]
        (do
            (regmbc (byte \m))
            (regmbc 0x1e3f) (regmbc 0x1e41)
        )

        [(byte \N), 0xd1, 0x143 0x145 0x147, 0x1e44 0x1e48]
        (do
            (regmbc (byte \N))
            (regmbc 0xd1)
            (regmbc 0x143) (regmbc 0x145) (regmbc 0x147)
            (regmbc 0x1e44) (regmbc 0x1e48)
        )

        [(byte \n), 0xf1, 0x144 0x146 0x148 0x149, 0x1e45 0x1e49]
        (do
            (regmbc (byte \n))
            (regmbc 0xf1)
            (regmbc 0x144) (regmbc 0x146) (regmbc 0x148) (regmbc 0x149)
            (regmbc 0x1e45) (regmbc 0x1e49)
        )

        [(byte \O), 0xd2 0xd3 0xd4, 0xd5 0xd6 0xd8, 0x14c 0x14e 0x150, 0x1a0 0x1d1 0x1ea 0x1ec, 0x1ece]
        (do
            (regmbc (byte \O))
            (regmbc 0xd2) (regmbc 0xd3) (regmbc 0xd4)
            (regmbc 0xd5) (regmbc 0xd6) (regmbc 0xd8)
            (regmbc 0x14c) (regmbc 0x14e) (regmbc 0x150)
            (regmbc 0x1a0) (regmbc 0x1d1) (regmbc 0x1ea) (regmbc 0x1ec)
            (regmbc 0x1ece)
        )

        [(byte \o), 0xf2 0xf3 0xf4, 0xf5 0xf6 0xf8, 0x14d 0x14f 0x151, 0x1a1 0x1d2 0x1eb 0x1ed, 0x1ecf]
        (do
            (regmbc (byte \o))
            (regmbc 0xf2) (regmbc 0xf3) (regmbc 0xf4)
            (regmbc 0xf5) (regmbc 0xf6) (regmbc 0xf8)
            (regmbc 0x14d) (regmbc 0x14f) (regmbc 0x151)
            (regmbc 0x1a1) (regmbc 0x1d2) (regmbc 0x1eb) (regmbc 0x1ed)
            (regmbc 0x1ecf)
        )

        [(byte \P), 0x1e54 0x1e56]
        (do
            (regmbc (byte \P))
            (regmbc 0x1e54) (regmbc 0x1e56)
        )

        [(byte \p), 0x1e55 0x1e57]
        (do
            (regmbc (byte \p))
            (regmbc 0x1e55) (regmbc 0x1e57)
        )

        [(byte \R), 0x154 0x156 0x158, 0x1e58 0x1e5e]
        (do
            (regmbc (byte \R))
            (regmbc 0x154) (regmbc 0x156) (regmbc 0x158)
            (regmbc 0x1e58) (regmbc 0x1e5e)
        )

        [(byte \r), 0x155 0x157 0x159, 0x1e59 0x1e5f]
        (do
            (regmbc (byte \r))
            (regmbc 0x155) (regmbc 0x157) (regmbc 0x159)
            (regmbc 0x1e59) (regmbc 0x1e5f)
        )

        [(byte \S), 0x15a 0x15c 0x15e 0x160, 0x1e60]
        (do
            (regmbc (byte \S))
            (regmbc 0x15a) (regmbc 0x15c) (regmbc 0x15e) (regmbc 0x160)
            (regmbc 0x1e60)
        )

        [(byte \s), 0x15b 0x15d 0x15f 0x161, 0x1e61]
        (do
            (regmbc (byte \s))
            (regmbc 0x15b) (regmbc 0x15d) (regmbc 0x15f) (regmbc 0x161)
            (regmbc 0x1e61)
        )

        [(byte \T), 0x162 0x164 0x166, 0x1e6a 0x1e6e]
        (do
            (regmbc (byte \T))
            (regmbc 0x162) (regmbc 0x164) (regmbc 0x166)
            (regmbc 0x1e6a) (regmbc 0x1e6e)
        )

        [(byte \t), 0x163 0x165 0x167, 0x1e6b 0x1e6f 0x1e97]
        (do
            (regmbc (byte \t))
            (regmbc 0x163) (regmbc 0x165) (regmbc 0x167)
            (regmbc 0x1e6b) (regmbc 0x1e6f) (regmbc 0x1e97)
        )

        [(byte \U), 0xd9 0xda 0xdb 0xdc, 0x168 0x16a 0x16c 0x16e, 0x170 0x172 0x1af 0x1d3, 0x1ee6]
        (do
            (regmbc (byte \U))
            (regmbc 0xd9) (regmbc 0xda) (regmbc 0xdb) (regmbc 0xdc)
            (regmbc 0x168) (regmbc 0x16a) (regmbc 0x16c) (regmbc 0x16e)
            (regmbc 0x170) (regmbc 0x172) (regmbc 0x1af) (regmbc 0x1d3)
            (regmbc 0x1ee6)
        )

        [(byte \u), 0xf9 0xfa 0xfb 0xfc, 0x169 0x16b 0x16d 0x16f, 0x171 0x173 0x1b0 0x1d4, 0x1ee7]
        (do
            (regmbc (byte \u))
            (regmbc 0xf9) (regmbc 0xfa) (regmbc 0xfb) (regmbc 0xfc)
            (regmbc 0x169) (regmbc 0x16b) (regmbc 0x16d) (regmbc 0x16f)
            (regmbc 0x171) (regmbc 0x173) (regmbc 0x1b0) (regmbc 0x1d4)
            (regmbc 0x1ee7)
        )

        [(byte \V), 0x1e7c]
        (do
            (regmbc (byte \V))
            (regmbc 0x1e7c)
        )

        [(byte \v), 0x1e7d]
        (do
            (regmbc (byte \v))
            (regmbc 0x1e7d)
        )

        [(byte \W), 0x174, 0x1e80 0x1e82 0x1e84 0x1e86]
        (do
            (regmbc (byte \W))
            (regmbc 0x174)
            (regmbc 0x1e80) (regmbc 0x1e82) (regmbc 0x1e84) (regmbc 0x1e86)
        )

        [(byte \w), 0x175, 0x1e81 0x1e83 0x1e85 0x1e87 0x1e98]
        (do
            (regmbc (byte \w))
            (regmbc 0x175)
            (regmbc 0x1e81) (regmbc 0x1e83) (regmbc 0x1e85) (regmbc 0x1e87) (regmbc 0x1e98)
        )

        [(byte \X), 0x1e8a 0x1e8c]
        (do
            (regmbc (byte \X))
            (regmbc 0x1e8a) (regmbc 0x1e8c)
        )

        [(byte \x), 0x1e8b 0x1e8d]
        (do
            (regmbc (byte \x))
            (regmbc 0x1e8b) (regmbc 0x1e8d)
        )

        [(byte \Y), 0xdd, 0x176 0x178, 0x1e8e 0x1ef2 0x1ef6 0x1ef8]
        (do
            (regmbc (byte \Y))
            (regmbc 0xdd)
            (regmbc 0x176) (regmbc 0x178)
            (regmbc 0x1e8e) (regmbc 0x1ef2) (regmbc 0x1ef6) (regmbc 0x1ef8)
        )

        [(byte \y), 0xfd 0xff, 0x177, 0x1e8f 0x1e99 0x1ef3 0x1ef7 0x1ef9]
        (do
            (regmbc (byte \y))
            (regmbc 0xfd) (regmbc 0xff)
            (regmbc 0x177)
            (regmbc 0x1e8f) (regmbc 0x1e99) (regmbc 0x1ef3) (regmbc 0x1ef7) (regmbc 0x1ef9)
        )

        [(byte \Z), 0x179 0x17b 0x17d 0x1b5, 0x1e90 0x1e94]
        (do
            (regmbc (byte \Z))
            (regmbc 0x179) (regmbc 0x17b) (regmbc 0x17d) (regmbc 0x1b5)
            (regmbc 0x1e90) (regmbc 0x1e94)
        )

        [(byte \z), 0x17a 0x17c 0x17e 0x1b6, 0x1e91 0x1e95]
        (do
            (regmbc (byte \z))
            (regmbc 0x17a) (regmbc 0x17c) (regmbc 0x17e) (regmbc 0x1b6)
            (regmbc 0x1e91) (regmbc 0x1e95)
        )

     ;; :else
            (regmbc c))
    nil)

;; Check for a collating element "[.a.]".  "s" points to the '['.
;; Returns a character.  Zero means that no item was recognized.
;; Otherwise "s" is advanced to after the item.
;; Currently only single characters are recognized!

(defn- #_int get-coll-element [#_Bytes' a's]
    (let-when [s @a's] (at? s 1 (byte \.)) => 0
        (let-when [n (us-ptr2len-cc s, 2)] (and (at? s (+ n 2) (byte \.)) (at? s (+ n 3) (byte \]))) => 0
            (let [c (us-ptr2char s, 2)] (swap! a's plus (+ n 4)) c)
        )))

(atom! boolean reg_cpo_lit)     ;; 'cpoptions' contains 'l' flag
(atom! boolean reg_cpo_bsl)     ;; 'cpoptions' contains '\' flag

(defn- #_void get-cpo-flags []
    (reset! reg_cpo_lit (some? (vim-strbyte @p_cpo, CPO_LITERAL)))
    (reset! reg_cpo_bsl (some? (vim-strbyte @p_cpo, CPO_BACKSL)))
    nil)

;; Skip over a "[]" range.
;; "s" must point to the character after the '['.
;; The returned pointer is on the matching ']', or the terminating NUL.

(defn- #_Bytes skip-anyof [#_Bytes s]
    (let [s (if (at? s (byte \^)) (.plus s 1) s) ;; complement of range
          s (if (or (at? s (byte \])) (at? s (byte \-))) (.plus s 1) s)]
        (loop-when s (and (non-eos? s) (not-at? s (byte \]))) => s
            (let [#_int n (us-ptr2len-cc s)
                  s (cond (< 1 n)
                        (.plus s n)
                    (at? s (byte \-))
                        (let [s (.plus s 1)]
                            (if (and (not-at? s (byte \])) (non-eos? s)) (.plus s (us-ptr2len-cc s)) s))
                    (and (at? s (byte \\))
                            (not @reg_cpo_bsl)
                                (or (some? (vim-strchr REGEXP_INRANGE, (.at s 1))) (and (not @reg_cpo_lit) (some? (vim-strchr REGEXP_ABBR, (.at s 1))))))
                        (.plus s 2)
                    (at? s (byte \[))
                        (let [[#_boolean b s]
                                (let [__ (atom (#_Bytes object s))]
                                    [(and (== (get-char-class __) CLASS_NONE) (zero? (get-equi-class __)) (zero? (get-coll-element __))) @__])]
                            (if b (.plus s 1) s)) ;; not a class name
                    :else
                        (.plus s 1)
                    )]
                (recur s)
            ))
    ))

;; Skip past regular expression.
;; Stop at end of "s" or where "dirc" is found ('/', '?', etc).
;; Take care of characters with a backslash in front of it.
;; Skip strings inside [ and ].
;; When "q" is not null and "dirc" is '?', make an allocated copy of the expression
;; and change "\?" to "?".  If "*q" is not null the expression is changed in-place.

(defn- #_Bytes skip-regexp [#_Bytes s, #_byte dirc, #_boolean magic, #_Bytes' a'q]
    (get-cpo-flags)
    (loop-when [#_int m (if magic MAGIC_ON MAGIC_OFF) #_Bytes p s] (and (non-eos? p) (not-at? p dirc)) => p
        (let-when [[m p]
                (cond (or (and (at? p (byte \[)) (<= MAGIC_ON m)) (and (at? p (byte \\)) (at? p 1 (byte \[)) (<= m MAGIC_OFF)))
                    (let [p (skip-anyof (.plus p 1))]
                        [(if (eos? p) nil m) p])
                (and (at? p (byte \\)) (non-eos? p 1))
                    (let [p (if (and (== dirc (byte \?)) (some? a'q) (at? p 1 (byte \?))) ;; change "\?" to "?", make a copy first
                                (let [p (if (nil? @a'q) (do (reset! a'q (STRDUP s)) (.plus @a'q (BDIFF p, s))) p)] (BCOPY p, 0, p, 1, (inc (STRLEN p, 1))) p)
                                (.plus p 1))] ;; skip next character
                        [(cond (at? p (byte \v)) MAGIC_ALL (at? p (byte \V)) MAGIC_NONE :else m) p])
                :else [m p])] (some? m) => p
            (recur m (.plus p (us-ptr2len-cc p))))
    ))

;; bt-regcomp() - compile a regular expression into internal code for the
;; traditional back track matcher.
;; Returns the program in allocated space.  Returns null for an error.
;;
;; We can't allocate space until we know how big the compiled form will be,
;; but we can't compile it (and thus know how big it is) until we've got a
;; place to put the code.  So we cheat:  we compile it twice, once with code
;; generation turned off and size counting turned on, and once "for real".
;; This also means that we don't allocate space until we are sure that the
;; thing really will compile successfully, and we never have to move the
;; code and thus invalidate pointers into it.
;;
;; Whether upper/lower case is to be ignored is decided when executing the
;; program, it does not matter here.
;;
;; Beware that the optimization-preparation code in here knows about some
;; of the structure of the compiled regexp.
;; "re_flags": RE_MAGIC and/or RE_STRING.

(defn- #_regprog_C bt-regcomp [#_Bytes expr, #_int re_flags]
    (ยง
        (when (nil? expr)
            (emsg e_null)
            (reset! rc_did_emsg true)
            ((ร RETURN) nil)
        )

        ;; First pass: determine size, legality.

        (regcomp-start expr, re_flags)
        (reset! regcode JUST_CALC_SIZE)
        (regc REGMAGIC)
        ((ร int[] a'flags =) (atom (int)))
        (if (nil? (reg REG_NOPAREN, a'flags))
            ((ร RETURN) nil)
        )

        ;; Allocate space.
        ((ร bt_regprog_C r =) (new bt_regprog_C))
        ((ร r =) (assoc r :program (Bytes. (inc @regsize))))

        ;; Second pass: emit code.

        (regcomp-start expr, re_flags)
        (reset! regcode (:program r))
        (regc REGMAGIC)
        (when (or (nil? (reg REG_NOPAREN, a'flags)) @reg_toolong)
            (when @reg_toolong
                (emsg (u8 "E339: Pattern too long"))
                (reset! rc_did_emsg true)
            )
            ((ร RETURN) nil)
        )

        ;; Dig out information for optimizations.
        ((ร r =) (assoc r :regstart NUL))                   ;; Worst-case defaults.
        ((ร r =) (assoc r :reganch 0))
        ((ร r =) (assoc r :regmust nil))
        ((ร r =) (assoc r :regmlen 0))
        ((ร r =) (assoc r :regflags @regflags))
        (if (flag? @a'flags HASNL)
            ((ร r =) (update r :regflags | RF_HASNL))
        )
        (if (flag? @a'flags HASLOOKBH)
            ((ร r =) (update r :regflags | RF_LOOKBH))
        )
        ;; Remember whether this pattern has any \z specials in it.
        ((ร r =) (assoc r :reghasz @re_has_z))

        ((ร Bytes scan =) (.plus (:program r) 1))        ;; First BRANCH.
        (when (== (re-op (regnext scan)) END)    ;; Only one top-level choice.
            ((ร scan =) (operand scan))

            ;; Starting-point info.
            (when (any == (re-op scan) BOL RE_BOF)
                ((ร r =) (update r :reganch inc))
                ((ร scan =) (regnext scan))
            )

            (cond (== (re-op scan) EXACTLY)
            (do
                ((ร r =) (assoc r :regstart (us-ptr2char (operand scan))))
            )
            (and (any == (re-op scan) BOW EOW NOTHING (+ MOPEN 0) NOPEN (+ MCLOSE 0) NCLOSE) (== (re-op (regnext scan)) EXACTLY))
            (do
                ((ร r =) (assoc r :regstart (us-ptr2char (operand (regnext scan)))))
            ))

            ;; If there's something expensive in the r.e., find the longest literal string
            ;; that must appear and make it the regmust.  Resolve ties in favor of later strings,
            ;; since the regstart check works with the beginning of the r.e. and avoiding duplication
            ;; strengthens checking.  Not a strong reason, but sufficient in the absence of others.

            ;; When the r.e. starts with BOW, it is faster to look for a regmust first.
            ;; Used a lot for "#" and "*" commands.

            (when (and (or (flag? @a'flags SPSTART) (== (re-op scan) BOW) (== (re-op scan) EOW)) (non-flag? @a'flags HASNL))
                ((ร Bytes longest =) nil)
                ((ร int len =) 0)
                (loop-when-recur scan (some? scan) (regnext scan)
                    (when (and (== (re-op scan) EXACTLY) (<= len (STRLEN (operand scan))))
                        ((ร longest =) (operand scan))
                        ((ร len =) (STRLEN (operand scan)))
                    )
                )
                ((ร r =) (assoc r :regmust longest))
                ((ร r =) (assoc r :regmlen len))
            )
        )

        ((ร r =) (assoc r :engine bt_regengine))
        (ร (regprog_C)r)
    ))

;; Setup to parse the regexp.  Used once to get the length and once to do it.

(defn- #_void regcomp-start [#_Bytes expr, #_int re_flags]
    ;; re_flags: see vim-regcomp()
    (initchr expr)
    (reset! reg_magic (if (flag? re_flags RE_MAGIC) MAGIC_ON MAGIC_OFF))
    (reset! reg_string (flag? re_flags RE_STRING))
    (reset! reg_strict (flag? re_flags RE_STRICT))
    (get-cpo-flags)

    (reset! num_complex_braces 0)
    (reset! regnpar 1)
    (swap! had_endbrace #(into (empty %) (map (constantly false) %)))
    (reset! regnzpar 1)
    (reset! re_has_z 0)
    (reset! regsize 0)
    (reset! reg_toolong false)
    (reset! regflags 0)
    nil)

;; Parse regular expression, i.e. main body or parenthesized thing.
;;
;; Caller must absorb opening parenthesis.
;;
;; Combining parenthesis handling with the base level of regular expression
;; is a trifle forced, but the need to tie the tails of the branches to what
;; follows makes it hard to avoid.
;;
;; paren: REG_NOPAREN, REG_PAREN, REG_NPAREN or REG_ZPAREN

(defn- #_Bytes reg [#_int paren, #_int' a'fl]
    (reset! a'fl HASWIDTH)                      ;; Tentatively.
    (let-when [[#_int parno #_Bytes ret :as _]
            (condp == paren
                REG_ZPAREN                      ;; Make a ZOPEN node.
                    (if (<= NSUBEXP @regnzpar)
                        (do (emsg (u8 "E50: Too many \\z("))
                            (reset! rc_did_emsg true)
                            nil)
                        (let [parno @regnzpar]
                            (swap! regnzpar inc)
                            [parno (regnode (+ ZOPEN parno))]
                        ))
                REG_PAREN                       ;; Make a MOPEN node.
                    (if (<= NSUBEXP @regnpar)
                        (do (emsg2 (u8 "E51: Too many %s("), (if (== @reg_magic MAGIC_ALL) (u8 "") (u8 "\\")))
                            (reset! rc_did_emsg true)
                            nil)
                        (let [parno @regnpar]
                            (swap! regnpar inc)
                            [parno (regnode (+ MOPEN parno))]
                        ))
                REG_NPAREN                      ;; Make a NOPEN node.
                    [0 (regnode NOPEN)]
                [0 nil]
            )] (some? _) => nil
        ;; Pick up the branches, linking them together.
        (let-when [a'flags (atom (int)) #_Bytes br (regbranch a'flags)] (some? br) => nil
            ;; [MZ]OPEN -> first.
            (let [ret (if (some? ret) (do (regtail ret, br) ret) br)]
                ;; If one of the branches can be zero-width, the whole thing can.
                ;; If one of the branches has * at start or matches a line-break, the whole thing can.
                (when (non-flag? @a'flags HASWIDTH)
                    (swap! a'fl & (bit-not HASWIDTH)))
                (swap! a'fl | (& @a'flags (| SPSTART HASNL HASLOOKBH)))
                (let-when [_
                        (loop-when [] (== (peekchr) (Magic (byte \|))) => :_
                            (skipchr)
                            (let-when [#_Bytes br (regbranch a'flags)] (and (some? br) (not @reg_toolong)) => nil
                                (regtail ret, br)       ;; BRANCH -> BRANCH.
                                (when (non-flag? @a'flags HASWIDTH)
                                    (swap! a'fl & (bit-not HASWIDTH)))
                                (swap! a'fl | (& @a'flags (| SPSTART HASNL HASLOOKBH)))
                                (recur))
                        )] (some? _) => nil
                    ;; Make a closing node, and hook it on the end.
                    (let [#_Bytes ender (regnode (condp == paren REG_ZPAREN (+ ZCLOSE parno) REG_PAREN (+ MCLOSE parno) REG_NPAREN NCLOSE END))]
                        (regtail ret, ender)
                        ;; Hook the tails of the branches to the closing node.
                        (loop-when-recur [#_Bytes br ret] (some? br) [(regnext br)]
                            (regoptail br, ender))
                        ;; Check for proper termination.
                        (cond (and (!= paren REG_NOPAREN) (!= (getchr) (Magic (byte \)))))
                            (do (condp == paren
                                    REG_ZPAREN (emsg (u8 "E52: Unmatched \\z("))
                                    REG_NPAREN (emsg2 e_unmatchedpp, (if (== @reg_magic MAGIC_ALL) (u8 "") (u8 "\\")))
                                               (emsg2 e_unmatchedp,  (if (== @reg_magic MAGIC_ALL) (u8 "") (u8 "\\"))))
                                (reset! rc_did_emsg true)
                                nil)
                        (and (== paren REG_NOPAREN) (!= (peekchr) NUL))     ;; "Can't happen".
                            (do (if (== @curchr (Magic (byte \))))
                                    (emsg2 e_unmatchedpar, (if (== @reg_magic MAGIC_ALL) (u8 "") (u8 "\\")))
                                    (emsg e_trailing))
                                (reset! rc_did_emsg true)
                                nil)
                        :else ;; Here we set the flag allowing back references to this set of parentheses.
                            (do (when (== paren REG_PAREN)
                                    (swap! had_endbrace assoc parno true))     ;; have seen the close paren
                                ret
                            ))
                    ))
            ))
    ))

;; Parse one alternative of an | operator.
;; Implements the & operator.

(defn- #_Bytes regbranch [#_int' a'fl]
    (reset! a'fl (| WORST HASNL))               ;; Tentatively.
    (let [#_Bytes ret (regnode BRANCH)]
        (loop [#_Bytes chain nil]
            (let-when [a'flags (atom (int)) #_Bytes latest (regconcat a'flags)] (some? latest) => nil
                ;; If one of the branches has width, the whole thing has.
                ;; If one of the branches anchors at start-of-line, the whole thing does.
                ;; If one of the branches uses look-behind, the whole thing does.
                (swap! a'fl | (& @a'flags (| HASWIDTH SPSTART HASLOOKBH)))
                ;; If one of the branches doesn't match a line-break, the whole thing doesn't.
                (swap! a'fl & (| (bit-not HASNL) (& @a'flags HASNL)))
                (when (some? chain)
                    (regtail chain, latest))
                (if (!= (peekchr) (Magic (byte \&)))
                    ret
                    (do (skipchr)
                        (regtail latest, (regnode END)) ;; operand ends
                        (if @reg_toolong
                            ret
                            (do
                                (reginsert MATCH, latest)
                                (recur latest)
                            ))
                    ))
            ))
    ))

;; Parse one alternative of an | or & operator.
;; Implements the concatenation operator.

(defn- #_Bytes regconcat [#_int' a'fl]
    (reset! a'fl WORST)                         ;; Tentatively.
    (let-when [[#_Bytes first :as _]
            (loop [first nil #_Bytes chain nil]
                (condp ==? (peekchr)
                   [NUL (Magic (byte \|)) (Magic (byte \&)) (Magic (byte \)))]                                  [first]

                    (Magic (byte \Z)) (do (swap! regflags | RF_ICOMBINE) (skipchr-keepstart)                    (recur first chain))
                    (Magic (byte \c)) (do (swap! regflags | RF_ICASE)    (skipchr-keepstart)                    (recur first chain))
                    (Magic (byte \C)) (do (swap! regflags | RF_NOICASE)  (skipchr-keepstart)                    (recur first chain))

                    (Magic (byte \v)) (do (reset! reg_magic MAGIC_ALL)   (skipchr-keepstart) (reset! curchr -1) (recur first chain))
                    (Magic (byte \m)) (do (reset! reg_magic MAGIC_ON)    (skipchr-keepstart) (reset! curchr -1) (recur first chain))
                    (Magic (byte \M)) (do (reset! reg_magic MAGIC_OFF)   (skipchr-keepstart) (reset! curchr -1) (recur first chain))
                    (Magic (byte \V)) (do (reset! reg_magic MAGIC_NONE)  (skipchr-keepstart) (reset! curchr -1) (recur first chain))

                    (let-when [a'flags (atom (int)) #_Bytes latest (regpiece a'flags)] (and (some? latest) (not @reg_toolong)) => nil
                        (swap! a'fl | (& @a'flags (| HASWIDTH HASNL HASLOOKBH)))
                        (if (nil? chain)  ;; First piece.
                            (swap! a'fl | (& @a'flags SPSTART))
                            (regtail chain, latest))
                        (recur (if (some? first) first latest) latest)
                    ))
            )] (some? _) => nil
        (if (some? first) first (regnode NOTHING))          ;; Loop ran zero times.
    ))

;; Parse something followed by possible [*+=].
;;
;; Note that the branching code sequences used for = and the general cases
;; of * and + are somewhat optimized:  they use the same NOTHING node as
;; both the endmarker for their branch list and the body of the last branch.
;; It might seem that this node could be dispensed with entirely, but the
;; endmarker role is not redundant.

(defn- #_Bytes regpiece [#_int' a'fl]
    (let-when [a'flags (atom (int)) #_Bytes ret (regatom a'flags)] (some? ret) => nil
        (let [#_int op (peekchr)]
            (cond (== (re-multi-type op) NOT_MULTI)
                (do (reset! a'fl @a'flags) ret)
            :else
                (do (reset! a'fl (| WORST SPSTART (& @a'flags (| HASNL HASLOOKBH)))) ;; default flags
                    (skipchr)
                    (let-when [_
                            (condp ==? op
                                (Magic (byte \*))
                                    (do (if (flag? @a'flags SIMPLE)
                                            (reginsert STAR, ret)
                                            (do ;; Emit x* as (x&|), where & means "self".
                                                (reginsert BRANCH, ret)             ;; Either x
                                                (regoptail ret, (regnode BACK))     ;; and loop
                                                (regoptail ret, ret)                ;; back
                                                (regtail ret, (regnode BRANCH))     ;; or
                                                (regtail ret, (regnode NOTHING))    ;; null.
                                            ))
                                        :_)

                                (Magic (byte \+))
                                    (do (if (flag? @a'flags SIMPLE)
                                            (reginsert PLUS, ret)
                                            ;; Emit x+ as x(&|), where & means "self".
                                            (let [#_Bytes next (regnode BRANCH)]    ;; Either
                                                (regtail ret, next)
                                                (regtail (regnode BACK), ret)       ;; loop back
                                                (regtail next, (regnode BRANCH))    ;; or
                                                (regtail ret, (regnode NOTHING))    ;; null.
                                            ))
                                        (reset! a'fl (| WORST HASWIDTH (& @a'flags (| HASNL HASLOOKBH))))
                                        :_)

                                (Magic (byte \@))
                                    (let [#_int nr (getdecchrs)
                                          #_int lop (condp == (no-Magic (getchr))
                                                (byte \=) MATCH                     ;; \@=
                                                (byte \!) NOMATCH                   ;; \@!
                                                (byte \>) SUBPAT                    ;; \@>
                                                (byte \<)
                                                    (condp == (no-Magic (getchr))
                                                        (byte \=) BEHIND            ;; \@<=
                                                        (byte \!) NOBEHIND          ;; \@<!
                                                        END)
                                                END)]
                                        (if (== lop END)
                                            (do (emsg2 (u8 "E59: invalid character after %s@"), (if (== @reg_magic MAGIC_ALL) (u8 "") (u8 "\\")))
                                                (reset! rc_did_emsg true)
                                                nil)
                                            (do ;; Look behind must match with behind_pos.
                                                (when (any == lop BEHIND NOBEHIND)
                                                    (regtail ret, (regnode BHPOS))
                                                    (swap! a'fl | HASLOOKBH))
                                                (regtail ret, (regnode END))                ;; operand ends
                                                (if (any == lop BEHIND NOBEHIND)
                                                    (reginsert-nr lop, (max 0 nr), ret)     ;; no limit is same as zero limit
                                                    (reginsert lop, ret))
                                                :_)
                                        ))

                               [(Magic (byte \?)) (Magic (byte \=))]
                                    (do ;; Emit x= as (x|).
                                        (reginsert BRANCH, ret)                     ;; Either x
                                        (regtail ret, (regnode BRANCH))             ;; or
                                        (let [#_Bytes next (regnode NOTHING)]       ;; null.
                                            (regtail ret, next)
                                            (regoptail ret, next))
                                        :_)

                                (Magic (byte \{))
                                    (let-when [a'minval (atom (long)) a'maxval (atom (long))] (read-limits a'minval, a'maxval) => nil
                                        (cond (flag? @a'flags SIMPLE)
                                            (do
                                                (reginsert BRACE_SIMPLE, ret)
                                                (reginsert-limits BRACE_LIMITS, @a'minval, @a'maxval, ret)
                                                (when (and (< 0 @a'minval) (< 0 @a'maxval))
                                                    (reset! a'fl (| HASWIDTH (& @a'flags (| HASNL HASLOOKBH)))))
                                                :_)
                                        (< @num_complex_braces 10)
                                            (do
                                                (reginsert (+ BRACE_COMPLEX @num_complex_braces), ret)
                                                (regoptail ret, (regnode BACK))
                                                (regoptail ret, ret)
                                                (reginsert-limits BRACE_LIMITS, @a'minval, @a'maxval, ret)
                                                (swap! num_complex_braces inc)
                                                (when (and (< 0 @a'minval) (< 0 @a'maxval))
                                                    (reset! a'fl (| HASWIDTH (& @a'flags (| HASNL HASLOOKBH)))))
                                                :_)
                                        :else
                                            (do (emsg2 (u8 "E60: Too many complex %s{...}s"), (if (== @reg_magic MAGIC_ALL) (u8 "") (u8 "\\")))
                                                (reset! rc_did_emsg true)
                                                nil)
                                        ))
                            )] (some? _) => nil
                        (if (!= (re-multi-type (peekchr)) NOT_MULTI)
                            (do ;; Can't have a multi follow a multi.
;%%                             (if (== (peekchr) (Magic (byte \*)))
;%%                                 (.sprintf libC @ioBuff, (u8 "E61: Nested %s*"), (if (<= MAGIC_ON @reg_magic) (u8 "") (u8 "\\")))
;%%                                 (.sprintf libC @ioBuff, (u8 "E62: Nested %s%c"), (if (== @reg_magic MAGIC_ALL) (u8 "") (u8 "\\")), (no-Magic (peekchr))))
                                (emsg @ioBuff)
                                (reset! rc_did_emsg true)
                                nil)
                            ret)
                    ))
            ))
    ))

;; When making changes to "classchars" also change "nfa_classcodes".
(final Bytes classchars (u8 ".iIkKfFpPsSdDxXoOwWhHaAlLuU"))
(final int* classcodes
    [
        ANY,
        IDENT, SIDENT,
        KWORD, SKWORD,
        FNAME, SFNAME,
        PRINT, SPRINT,
        WHITE, NWHITE,
        DIGIT, NDIGIT,
        HEX,   NHEX,
        OCTAL, NOCTAL,
        WORD,  NWORD,
        HEAD,  NHEAD,
        ALPHA, NALPHA,
        LOWER, NLOWER,
        UPPER, NUPPER
    ])

(defn- #_Bytes regcoll- [#_int c, #_int extra, #_int' a'fl]
    ;; If there is no matching ']', we assume the '[' is a normal character.
    ;; This makes 'incsearch' and ":help [" work.
    (let [#_Bytes lp (skip-anyof @regparse)]
        (cond (at? lp (byte \]))     ;; there is a matching ']'
            ;; In a character class, different parsing rules apply.
            ;; Not even \ is special anymore, nothing is.
            (let-when [#_Bytes ret ;; Complement of range.
                    (if (at? @regparse (byte \^)) (let [ret (regnode (+ ANYBUT extra))] (swap! regparse plus 1) ret) (regnode (+ ANYOF extra)))
                  ;; At the start ']' and '-' mean the literal character.
                  #_int startc ;; > 0 when next '-' is a range
                    (let [startc (.at @regparse 0)] (if (any == startc (byte \]) (byte \-)) (do (regc startc) (swap! regparse plus 1) startc) -1))
                  _ (loop-when startc (and (non-eos? @regparse) (not-at? @regparse (byte \]))) => :_
                        (cond (at? @regparse (byte \-))
                        (do (swap! regparse plus 1)
                            ;; The '-' is not used for a range at the end and after or before a '\n'.
                            (if (or (at? @regparse (byte \])) (eos? @regparse) (== startc -1) (and (at? @regparse (byte \\)) (at? @regparse 1 (byte \n))))
                                ;; [--x] is a range
                                (let [startc (byte \-)] (regc startc) (recur startc))
                                ;; also accept "a-[.z.]"
                                (let [#_int endc (if (at? @regparse (byte \[)) (get-coll-element regparse) 0)
                                      endc (if (zero? endc) (us-ptr2char-adv regparse, true) endc)
                                      ;; Handle \o40, \x20 and \u20AC style sequences.
                                      endc (if (and (== endc (byte \\)) (not @reg_cpo_lit) (not @reg_cpo_bsl)) (coll-get-char) endc)]
                                    (cond (< endc startc)
                                        (do (emsg e_invrange)
                                            (reset! rc_did_emsg true)
                                            nil)
                                    (or (< 1 (utf-char2len startc)) (< 1 (utf-char2len endc)))
                                        ;; Limit to a range of 256 chars.
                                        (if (< (+ startc 256) endc)
                                            (do (emsg e_invrange)
                                                (reset! rc_did_emsg true)
                                                nil)
                                            (do (loop-when [startc (inc startc)] (<= startc endc) (regmbc startc) (recur (inc startc)))
                                                (recur -1)
                                            ))
                                    :else
                                        (do (loop-when [startc (inc startc)] (<= startc endc) (regc startc) (recur (inc startc)))
                                            (recur -1))
                                    ))
                            ))
                        ;; Only "\]", "\^", "\]" and "\\" are special in Vi.
                        ;; Vim accepts "\t", "\e", etc., but only when the 'l' flag in 'cpoptions' is not included.
                        ;; Posix doesn't recognize backslash at all.
                        (and (at? @regparse (byte \\))
                             (not @reg_cpo_bsl)
                             (or (some? (vim-strchr REGEXP_INRANGE, (.at @regparse 1))) (and (not @reg_cpo_lit) (some? (vim-strchr REGEXP_ABBR, (.at @regparse 1))))))
                        (do (swap! regparse plus 1)
                            (cond (at? @regparse (byte \n))
                                (do ;; '\n' in range: also match NL
                                    (when (!= ret JUST_CALC_SIZE)
                                        ;; Using \n inside [^] does not change what matches.  "[^\n]" is the same as ".".
                                        (when (at? ret ANYOF)
                                            (.be ret 0, (+ ANYOF ADD_NL))
                                            (swap! a'fl | HASNL)
                                        )) ;; else: must have had a \n already
                                    (swap! regparse plus 1)
                                    (recur -1))
                            (or (at? @regparse (byte \d)) (at? @regparse (byte \o)) (at? @regparse (byte \x)) (at? @regparse (byte \u)) (at? @regparse (byte \U)))
                                (let [startc (coll-get-char)]
                                    (if (zero? startc) (regc 0x0a) (regmbc startc))
                                    (recur startc))
                            :else
                                (let [startc (backslash-trans (.at (swap! regparse plus 1) -1))]
                                    (regc startc)
                                    (recur startc))
                            ))
                        (at? @regparse (byte \[))
                        (let [#_int c_class (get-char-class regparse) a'startc (atom -1)]
                            ;; Characters assumed to be 8 bits!
                            (condp == c_class
                                CLASS_NONE
                                    (let [c_class (get-equi-class regparse)]
                                        (if (non-zero? c_class)
                                            (reg-equi-class c_class) ;; produce equivalence class
                                            (let [c_class (get-coll-element regparse)]
                                                (if (non-zero? c_class)
                                                    (regmbc c_class) ;; produce a collating element
                                                    (regc (reset! a'startc (.at (swap! regparse plus 1) -1))) ;; literal '[', allow [[-x] as a range
                                                ))
                                        ))
                                CLASS_ALNUM     (loop-when-recur [#_int cu 1] (<= cu 255) [(inc cu)] (when (asc-isalnum cu)  (regc cu)))
                                CLASS_ALPHA     (loop-when-recur [#_int cu 1] (<= cu 255) [(inc cu)] (when (asc-isalpha cu)  (regc cu)))
                                CLASS_BLANK (do (regc (byte \space)) (regc TAB))
                                CLASS_CNTRL     (loop-when-recur [#_int cu 1] (<= cu 255) [(inc cu)] (when (asc-iscntrl cu)  (regc cu)))
                                CLASS_DIGIT     (loop-when-recur [#_int cu 1] (<= cu 255) [(inc cu)] (when (asc-isdigit cu)  (regc cu)))
                                CLASS_GRAPH     (loop-when-recur [#_int cu 1] (<= cu 255) [(inc cu)] (when (asc-isgraph cu)  (regc cu)))
                                CLASS_LOWER     (loop-when-recur [#_int cu 1] (<= cu 255) [(inc cu)] (when (utf-islower cu)  (regc cu)))
                                CLASS_PRINT     (loop-when-recur [#_int cu 1] (<= cu 255) [(inc cu)] (when (vim-isprintc cu) (regc cu)))
                                CLASS_PUNCT     (loop-when-recur [#_int cu 1] (<= cu 255) [(inc cu)] (when (asc-ispunct cu)  (regc cu)))
                                CLASS_SPACE (do (loop-when-recur [#_int cu 9] (<= cu  13) [(inc cu)]                         (regc cu)) (regc (byte \space)))
                                CLASS_UPPER     (loop-when-recur [#_int cu 1] (<= cu 255) [(inc cu)] (when (utf-isupper cu)  (regc cu)))
                                CLASS_XDIGIT    (loop-when-recur [#_int cu 1] (<= cu 255) [(inc cu)] (when (asc-isxdigit cu) (regc cu)))
                                CLASS_TAB       (regc TAB)
                                CLASS_RETURN    (regc (byte \return))
                                CLASS_BACKSPACE (regc (byte \backspace))
                                CLASS_ESCAPE    (regc ESC)
                            )
                            (recur @a'startc)
                        )
                        :else
                        ;; produce a multibyte character including any following composing characters
                        (let [startc (us-ptr2char @regparse) #_int n (us-ptr2len-cc @regparse)
                              startc (if (!= (utf-char2len startc) n) -1 startc)] ;; composing chars
                            (loop-when-recur n (< 0 n) (dec n) (regc (.at (swap! regparse plus 1) -1)))
                            (recur startc)
                        ))
                    )] (some? _) => nil
                (regc NUL)
                (reset! prevchr_len 1)                  ;; last char was the ']'
                (if (not-at? @regparse (byte \]))
                    (do (emsg e_toomsbra)
                        (reset! rc_did_emsg true)
                        nil)                            ;; Cannot happen?
                    (do (skipchr)                       ;; let's be friends with the lexer again
                        (swap! a'fl | HASWIDTH SIMPLE)
                        ret)
                ))
        @reg_strict
            (do (emsg2 e_missingbracket, (if (< MAGIC_OFF @reg_magic) (u8 "") (u8 "\\")))
                (reset! rc_did_emsg true)
                nil)
        :else
            (do-multibyte c, a'fl))
    ))

(defn- #_Bytes regclass- [#_int c, #_int extra, #_int' a'fl]
    (let [#_Bytes p (vim-strchr classchars, (no-Magic c))]
        (cond (nil? p)
            (do (emsg (u8 "E63: invalid use of \\_"))
                (reset! rc_did_emsg true)
                nil)
        ;; When '.' is followed by a composing char ignore the dot,
        ;; so that the composing char is matched here.
        (and (== c (Magic (byte \.))) (utf-iscomposing (peekchr)))
            (let [c (getchr) #_Bytes ret (regnode MULTIBYTECODE)]
                (regmbc c)
                (swap! a'fl | HASWIDTH SIMPLE)
                ret)
        :else
            (let [#_Bytes ret (regnode (+ (... classcodes (BDIFF p, classchars)) extra))]
                (swap! a'fl | HASWIDTH SIMPLE)
                ret
            ))
    ))

;; Parse the lowest level.
;;
;; Optimization: gobbles an entire sequence of ordinary characters so
;; it can turn them into a single node, which is smaller to store and
;; faster to run.  Don't do this when one_exactly is set.

(defn- #_Bytes regatom [#_int' a'fl]
    (reset! a'fl WORST)                         ;; Tentatively.
    (let [#_int c (getchr)]
        (condp ==? c
            (Magic (byte \^)) (regnode BOL)
            (Magic (byte \$)) (regnode EOL)
            (Magic (byte \<)) (regnode BOW)
            (Magic (byte \>)) (regnode EOW)

            (Magic (byte \_))
                (let [c (no-Magic (getchr))]
                    (condp == c
                        (byte \^) (regnode BOL)             ;; "\_^" is start-of-line
                        (byte \$) (regnode EOL)             ;; "\_$" is end-of-line
                        (let [#_int extra ADD_NL]
                            (swap! a'fl | HASNL)
                            (if (== c (byte \[))
                                (regcoll- c, extra, a'fl)   ;; "\_[" is character range plus newline
                                (regclass- c, extra, a'fl)  ;; "\_x" is character class plus newline
                            ))
                    ))

           [(Magic (byte \.))                   ;; Character classes.
            (Magic (byte \i)) (Magic (byte \I))
            (Magic (byte \k)) (Magic (byte \K))
            (Magic (byte \f)) (Magic (byte \F))
            (Magic (byte \p)) (Magic (byte \P))
            (Magic (byte \s)) (Magic (byte \S))
            (Magic (byte \d)) (Magic (byte \D))
            (Magic (byte \x)) (Magic (byte \X))
            (Magic (byte \o)) (Magic (byte \O))
            (Magic (byte \w)) (Magic (byte \W))
            (Magic (byte \h)) (Magic (byte \H))
            (Magic (byte \a)) (Magic (byte \A))
            (Magic (byte \l)) (Magic (byte \L))
            (Magic (byte \u)) (Magic (byte \U))] (regclass- c, 0, a'fl)

            (Magic (byte \n))
                (if @reg_string
                    ;; In a string "\n" matches a newline character.
                    (let [#_Bytes ret (regnode EXACTLY)] (regc NL) (regc NUL) (swap! a'fl | HASWIDTH SIMPLE) ret)
                    ;; In buffer text "\n" matches the end of a line.
                    (let [#_Bytes ret (regnode NEWL)] (swap! a'fl | HASWIDTH HASNL) ret))

            (Magic (byte \())
                (if @one_exactly
                    (do (emsg2 (u8 "E369: invalid item in %s%%[]"), (if (== @reg_magic MAGIC_ALL) (u8 "") (u8 "\\")))
                        (reset! rc_did_emsg true)
                        nil)
                    (let [a'flags (atom (int)) #_Bytes ret (reg REG_PAREN, a'flags)]
                        (if (some? ret) (do (swap! a'fl | (& @a'flags (| HASWIDTH SPSTART HASNL HASLOOKBH))) ret) nil)
                    ))

           [NUL (Magic (byte \|)) (Magic (byte \&)) (Magic (byte \)))]
                (do (if @one_exactly
                        (emsg2 (u8 "E369: invalid item in %s%%[]"), (if (== @reg_magic MAGIC_ALL) (u8 "") (u8 "\\")))
                        (emsg e_internal))       ;; Supposed to be caught earlier.
                    (reset! rc_did_emsg true)
                    nil)

           [(Magic (byte \=)) (Magic (byte \?)) (Magic (byte \+)) (Magic (byte \@)) (Magic (byte \{)) (Magic (byte \*))]
                (let [c (no-Magic c)]
;%%                 (.sprintf libC @ioBuff, (u8 "E64: %s%c follows nothing"), (if (if (== c (byte \*)) (<= MAGIC_ON @reg_magic) (== @reg_magic MAGIC_ALL)) (u8 "") (u8 "\\")), c)
                    (emsg @ioBuff)
                    (reset! rc_did_emsg true)
                    nil)

            (Magic (byte \~))                    ;; previous substitute pattern
                (if (some? @reg_prev_sub)
                    (let [#_Bytes ret (regnode EXACTLY)
                          #_Bytes s (loop-when-recur [s @reg_prev_sub] (non-eos? s) [(.plus s 1)] => s
                                (regc (.at s 0))
                            )]
                        (regc NUL)
                        (when (non-eos? @reg_prev_sub)
                            (swap! a'fl | HASWIDTH)
                            (when (== (BDIFF s, @reg_prev_sub) 1)
                                (swap! a'fl | SIMPLE)))
                        ret)
                    (do (emsg e_nopresub)
                        (reset! rc_did_emsg true)
                        nil))

           [(Magic (byte \1)) (Magic (byte \2)) (Magic (byte \3)) (Magic (byte \4)) (Magic (byte \5)) (Magic (byte \6)) (Magic (byte \7)) (Magic (byte \8)) (Magic (byte \9))]
                (let [#_int refnum (- c (Magic (byte \0)))]
                    ;; Check if the back reference is legal.  We must have seen the close brace.
                    ;; TODO:  Should also check that we don't refer to something
                    ;; that is repeated (+*=): what instance of the repetition should we match?
                    (if (... @had_endbrace refnum)
                        (regnode (+ BACKREF refnum))
                        ;; Trick: check if "@<=" or "@<!" follows, in which case the \1 can appear before the referenced match.
                        (let [#_Bytes p (loop-when [p @regparse] (non-eos? p) => p
                                    (recur-if (not (and (at? p (byte \@)) (at? p 1 (byte \<)) (or (at? p 2 (byte \!)) (at? p 2 (byte \=))))) [(.plus p 1)] => p)
                                )]
                            (if (eos? p)
                                (do (emsg (u8 "E65: Illegal back reference"))
                                    (reset! rc_did_emsg true)
                                    nil)
                                (regnode (+ BACKREF refnum))
                            ))
                    ))

            (Magic (byte \z))
                (let [c (no-Magic (getchr))]
                    (condp ==? c
                        (byte \()
                            (cond (!= @reg_do_extmatch REX_SET)
                                (do (emsg e_z_not_allowed)
                                    (reset! rc_did_emsg true)
                                    nil)
                            @one_exactly
                                (do (emsg2 (u8 "E369: invalid item in %s%%[]"), (if (== @reg_magic MAGIC_ALL) (u8 "") (u8 "\\")))
                                    (reset! rc_did_emsg true)
                                    nil)
                            :else
                                (let [a'flags (atom (int)) #_Bytes ret (reg REG_ZPAREN, a'flags)]
                                    (if (some? ret) (do (swap! a'fl | (& @a'flags (| HASWIDTH SPSTART HASNL HASLOOKBH))) (reset! re_has_z REX_SET) ret) nil)
                                ))

                       [(byte \1) (byte \2) (byte \3) (byte \4) (byte \5) (byte \6) (byte \7) (byte \8) (byte \9)]
                            (if (!= @reg_do_extmatch REX_USE)
                                (do (emsg e_z1_not_allowed)
                                    (reset! rc_did_emsg true)
                                    nil)
                                (let [#_Bytes ret (regnode (- (+ ZREF c) (byte \0)))]
                                    (reset! re_has_z REX_USE)
                                    ret
                                ))

                        (byte \s) (let [#_Bytes ret (regnode (+ MOPEN 0))] (if (re-mult-next (u8 "\\zs")) ret nil))
                        (byte \e) (let [#_Bytes ret (regnode (+ MCLOSE 0))] (if (re-mult-next (u8 "\\ze")) ret nil))

                        (do (emsg (u8 "E68: Invalid character after \\z"))
                            (reset! rc_did_emsg true)
                            nil)
                    ))

            (Magic (byte \%))
                (let [c (no-Magic (getchr))]
                    (condp ==? c
                        (byte \() ;; () without a back reference
                            (if @one_exactly
                                (do (emsg2 (u8 "E369: invalid item in %s%%[]"), (if (== @reg_magic MAGIC_ALL) (u8 "") (u8 "\\")))
                                    (reset! rc_did_emsg true)
                                    nil)
                                (let [a'flags (atom (int)) #_Bytes ret (reg REG_NPAREN, a'flags)]
                                    (if (some? ret) (do (swap! a'fl | (& @a'flags (| HASWIDTH SPSTART HASNL HASLOOKBH))) ret) nil)
                                ))

                        ;; Catch \%^ and \%$ regardless of where they appear in the pattern -- regardless of whether or not it makes sense.
                        (byte \^) (regnode RE_BOF)
                        (byte \$) (regnode RE_EOF)
                        (byte \#) (regnode CURSOR)
                        (byte \V) (regnode RE_VISUAL)
                        (byte \C) (regnode RE_COMPOSING)

                        ;; \%[abc]: Emit as a list of branches, all ending at the last branch which matches nothing.
                        (byte \[)
                            (if @one_exactly        ;; doesn't nest
                                (do (emsg2 (u8 "E369: invalid item in %s%%[]"), (if (== @reg_magic MAGIC_ALL) (u8 "") (u8 "\\")))
                                    (reset! rc_did_emsg true)
                                    nil)
                                (let-when [[#_Bytes lastnode #_Bytes ret :as _]
                                        (loop-when [lastnode nil ret nil c (getchr)] (!= c (byte \])) => [lastnode ret]
                                            (if (== c NUL)
                                                (do (emsg2 e_missing_sb, (if (== @reg_magic MAGIC_ALL) (u8 "") (u8 "\\")))
                                                    (reset! rc_did_emsg true)
                                                    nil)
                                                (let [#_Bytes br (regnode BRANCH) ret (if (nil? ret) br (do (regtail lastnode, br) ret))]
                                                    (ungetchr)
                                                    (let [_ (reset! one_exactly true) lastnode (regatom a'fl) _ (reset! one_exactly false)]
                                                        (recur-if (some? lastnode) [lastnode ret (getchr)] => nil)
                                                    ))
                                            ))] (some? _) => nil
                                    (if (nil? ret)
                                        (do (emsg2 e_empty_sb, (if (== @reg_magic MAGIC_ALL) (u8 "") (u8 "\\")))
                                            (reset! rc_did_emsg true)
                                            nil)
                                        (let [#_Bytes lastbranch (regnode BRANCH) #_Bytes br (regnode NOTHING)]
                                            (when (!= ret JUST_CALC_SIZE)
                                                (regtail lastnode, br)
                                                (regtail lastbranch, br)
                                                ;; connect all branches to the NOTHING branch at the end
                                                (loop-when [br ret] (BNE br, lastnode)
                                                    (recur (if (== (re-op br) BRANCH) (do (regtail br, lastbranch) (operand br)) (regnext br)))
                                                ))
                                            (swap! a'fl & (bit-not (| HASWIDTH SIMPLE)))
                                            ret
                                        ))
                                ))

                       [(byte \d)   ;; %d123 decimal
                        (byte \o)   ;; %o123 octal
                        (byte \x)   ;; %xab hex 2
                        (byte \u)   ;; %uabcd hex 4
                        (byte \U)]  ;; %U1234abcd hex 8
                            (let [#_int i (condp == c
                                        (byte \d) (getdecchrs)
                                        (byte \o) (getoctchrs)
                                        (byte \x) (gethexchrs 2)
                                        (byte \u) (gethexchrs 4)
                                        (byte \U) (gethexchrs 8)
                                    -1)]
                                (if (< i 0)
                                    (do (emsg2 (u8 "E678: Invalid character after %s%%[dxouU]"), (if (== @reg_magic MAGIC_ALL) (u8 "") (u8 "\\")))
                                        (reset! rc_did_emsg true)
                                        nil)
                                    (let [#_Bytes ret (regnode (if (use-multibytecode i) MULTIBYTECODE EXACTLY))]
                                        (if (zero? i) (regc 0x0a) (regmbc i))
                                        (regc NUL)
                                        (swap! a'fl | HASWIDTH)
                                        ret)
                                ))

                        (let-when [[ret :as _]
                                (when (or (asc-isdigit c) (== c (byte \<)) (== c (byte \>)) (== c (byte \')))
                                    (let [#_int cmp c c (if (any == cmp (byte \<) (byte \>)) (getchr) c)
                                          [#_long n c] (loop-when-recur [n 0 c c] (asc-isdigit c) [(+ (* n 10) (- c (byte \0))) (getchr)] => [n c])]
                                        (cond (and (== c (byte \')) (zero? n))
                                            (let [c (getchr) #_Bytes ret (regnode RE_MARK)] ;; "\%'m", "\%<'m" and "\%>'m": Mark
                                                (if (== ret JUST_CALC_SIZE)
                                                    (swap! regsize + 2)
                                                    (do
                                                        (-> @regcode (.be 0, c) (.be 1, cmp))
                                                        (swap! regcode plus 2)
                                                    ))
                                                [ret])
                                        (any == c (byte \l) (byte \c) (byte \v))
                                            (let [#_Bytes ret (regnode (cond (== c (byte \l)) RE_LNUM (== c (byte \c)) RE_COL :else RE_VCOL))]
                                                (if (== ret JUST_CALC_SIZE)
                                                    (swap! regsize + 5)
                                                    (do ;; put the number and the optional comparator after the opcode
                                                        (swap! regcode re-put-long n)
                                                        (.be @regcode 0, cmp)
                                                        (swap! regcode plus 1)
                                                    ))
                                                [ret])
                                        ))
                                )] (nil? _) => ret
                            (do (emsg2 (u8 "E71: Invalid character after %s%%"), (if (== @reg_magic MAGIC_ALL) (u8 "") (u8 "\\")))
                                (reset! rc_did_emsg true)
                                nil))
                    ))

            (Magic (byte \[)) (regcoll- c, 0, a'fl)

            (do-multibyte c, a'fl))
    ))

(defn- #_final #_Bytes do-multibyte [#_int c, #_int' a'fl]
    ;; A multi-byte character is handled as a separate atom if it's before a multi and when it's a composing char.
    (if (use-multibytecode c)
        (let [#_Bytes s (regnode MULTIBYTECODE)]
            (regmbc c)
            (swap! a'fl | HASWIDTH SIMPLE)
        s)
        (let [#_Bytes s (regnode EXACTLY)
              ;; Append characters as long as:
              ;; - there is no following multi, we then need the character in front of it as a single character operand;
              ;; - not running into a Magic character;
              ;; - "one_exactly" is not set.
              ;; But always emit at least one character.  Might be a Multi, e.g. a "[" without matching "]".
              #_int n
                (loop-when-recur [c c n 0]
                                 (and (!= c NUL) (or (== n 0) (and (== (re-multi-type (peekchr)) NOT_MULTI) (not @one_exactly) (not (is-Magic c)))))
                                 [(getchr) (inc n)]
                              => n
                    (regmbc (no-Magic c))
                    ;; Need to get composing character too.
                    (while (utf-iscomposing (us-ptr2char @regparse, (us-ptr2len @regparse)))
                        (regmbc (us-ptr2char @regparse))
                        (skipchr))
                )]
            (ungetchr)
            (regc NUL)
            (swap! a'fl | HASWIDTH)
            (when (== n 1) (swap! a'fl | SIMPLE))
        s)
    ))

;; Return true if MULTIBYTECODE should be used instead of EXACTLY for character "c".

(defn- #_boolean use-multibytecode [#_int c]
    (and (< 1 (utf-char2len c)) (or (!= (re-multi-type (peekchr)) NOT_MULTI) (utf-iscomposing c))))

;; Emit a node.
;; Return pointer to generated code.

(defn- #_Bytes regnode [#_int op]
    (let [#_Bytes ret @regcode]
        (if (== ret JUST_CALC_SIZE)
            (swap! regsize + 3)
            (-> (swap! regcode plus 3) (.be -3, op) (eos! -2) (eos! -1))       ;; Null "next" pointer.
        )
        ret
    ))

;; Emit (if appropriate) a byte of code.

(defn- #_void regc [#_int b]
    (if (== @regcode JUST_CALC_SIZE)
        (swap! regsize inc)
        (.be (swap! regcode plus 1) -1, b)
    )
    nil)

;; Emit (if appropriate) a multi-byte character of code.

(defn- #_void regmbc [#_int c]
    (if (== @regcode JUST_CALC_SIZE)
        (swap! regsize + (utf-char2len c))
        (swap! regcode #(.plus % (utf-char2bytes c, %))))
    nil)

;; Insert an operator in front of already-emitted operand.
;;
;; Means relocating the operand.

(defn- #_void reginsert [#_int op, #_Bytes opnd]
    (if (== @regcode JUST_CALC_SIZE)
        (swap! regsize + 3)
        (do
            (loop-when-recur [src @regcode dst (swap! regcode plus 3)] (BLT opnd, src) [(.minus src 1) (.minus dst 1)]
                (.be dst -1, (.at src -1)))
            ;; Op node, where operand used to be.
            (-> opnd (.be 0, op) (eos! 1) (eos! 2))
        ))
    nil)

;; Insert an operator in front of already-emitted operand.
;; Add a number to the operator.

(defn- #_void reginsert-nr [#_int op, #_long val, #_Bytes opnd]
    (if (== @regcode JUST_CALC_SIZE)
        (swap! regsize + 7)
        (do
            (loop-when-recur [src @regcode dst (swap! regcode plus 7)] (BLT opnd, src) [(.minus src 1) (.minus dst 1)]
                (.be dst -1, (.at src -1)))
            ;; Op node, where operand used to be.
            (-> opnd (.be 0, op) (eos! 1) (eos! 2))
            (re-put-long (.plus opnd 3), val)
        ))
    nil)

;; Insert an operator in front of already-emitted operand.
;; The operator has the given limit values as operands.
;; Also set next pointer.
;;
;; Means relocating the operand.

(defn- #_void reginsert-limits [#_int op, #_long minval, #_long maxval, #_Bytes opnd]
    (if (== @regcode JUST_CALC_SIZE)
        (swap! regsize + 11)
        (do
            (loop-when-recur [src @regcode dst (swap! regcode plus 11)] (BLT opnd, src) [(.minus src 1) (.minus dst 1)]
                (.be dst -1, (.at src -1)))
            ;; Op node, where operand used to be.
            (-> opnd (.be 0, op) (eos! 1) (eos! 2))
            (regtail opnd, (-> (.plus opnd 3) (re-put-long minval) (re-put-long maxval)))
        ))
    nil)

;; Write a long as four bytes at "p" and return pointer to the next char.

(defn- #_Bytes re-put-long [#_Bytes p, #_long val]
    (.be p 0, (byte (& (>>> val 24) 0xff)))
    (.be p 1, (byte (& (>>> val 16) 0xff)))
    (.be p 2, (byte (& (>>> val  8) 0xff)))
    (.be p 3, (byte (&      val     0xff)))
    (.plus p 4))

;; Set the next-pointer at the end of a node chain.

(defn- #_void regtail [#_Bytes p, #_Bytes val]
    (when-not (== p JUST_CALC_SIZE)
        (let [p (loop [p p] (let [#_Bytes q (regnext p)] (if (some? q) (recur q) p))) ;; find last node
              #_int offset (if (== (re-op p) BACK) (BDIFF p, val) (BDIFF val, p))]
            ;; When the offset uses more than 16 bits it can no longer fit in the two bytes available.
            ;; Use a global flag to avoid having to check return values in too many places.
            (if (< 0xffff offset)
                (reset! reg_toolong true)
                (-> p
                    (.be 1, (byte (& (>>> offset 8) 0xff)))
                    (.be 2, (byte (&      offset    0xff)))
                ))
        ))
    nil)

;; Like regtail, on item after a BRANCH; nop if none.

(defn- #_void regoptail [#_Bytes p, #_Bytes val]
    (let [op (re-op p)]
        ;; When op is neither BRANCH nor BRACE_COMPLEX0-9, it is "operandless".
        (when-not (or (nil? p) (== p JUST_CALC_SIZE) (and (!= op BRANCH) (or (< op BRACE_COMPLEX) (< (+ BRACE_COMPLEX 9) op))))
            (regtail (operand p), val)
        ))
    nil)

;; Functions for getting characters from the regexp input.

(atom! boolean at_start)        ;; true when on the first character
(atom! boolean prev_at_start)   ;; true when on the second character

;; Start parsing at "str".

(defn- #_void initchr [#_Bytes str]
    (reset! regparse str)
    (reset! prevchr_len 0)
    (reset! curchr (reset! prevprevchr (reset! prevchr (reset! nextchr -1))))
    (reset! at_start true)
    (reset! prev_at_start false)
    nil)

;; Save the current parse state, so that it can be restored and parsing starts in the same state again.

(defn- #_parse_state_C save-parse-state []
    (->parse_state_C @regparse @prevchr_len @curchr @prevchr @prevprevchr @nextchr @at_start @prev_at_start @regnpar))

;; Restore a previously saved parse state.

(defn- #_void restore-parse-state [#_parse_state_C ps]
    (reset! regparse (:regparse ps))
    (reset! prevchr_len (:prevchr_len ps))
    (reset! curchr (:curchr ps))
    (reset! prevchr (:prevchr ps))
    (reset! prevprevchr (:prevprevchr ps))
    (reset! nextchr (:nextchr ps))
    (reset! at_start (:at_start ps))
    (reset! prev_at_start (:prev_at_start ps))
    (reset! regnpar (:regnpar ps))
    nil)

(atom! int after_slash)

;; Get the next character without advancing.

(defn- #_int peekchr []
    (when (== @curchr -1)
        (condp ==? (reset! curchr (.at @regparse 0))
           [(byte \.)
            (byte \[)
            (byte \~)]
                (when (<= MAGIC_ON @reg_magic) ;; magic when 'magic' is on
                    (swap! curchr Magic))

           [(byte \()
            (byte \))
            (byte \{)
            (byte \%)
            (byte \+)
            (byte \=)
            (byte \?)
            (byte \@)
            (byte \!)
            (byte \&)
            (byte \|)
            (byte \<)
            (byte \>)
            (byte \#)   ;; future ext.
            (byte \")   ;; future ext. """
            (byte \')   ;; future ext.
            (byte \,)   ;; future ext.
            (byte \-)   ;; future ext.
            (byte \:)   ;; future ext.
            (byte \;)   ;; future ext.
            (byte \`)   ;; future ext.
            (byte \/)]  ;; can't be used in / command
                (when (== @reg_magic MAGIC_ALL) ;; magic only after "\v"
                    (swap! curchr Magic))

            (byte \*)
                ;; * is not magic as the very first character, e.g. "?*ptr",
                ;; when after '^', e.g. "/^*ptr" and when after "\(", "\|", "\&",
                ;; but "\(\*" is not magic, thus must be magic if "after_slash"
                (when (and (<= MAGIC_ON @reg_magic)
                           (not @at_start)
                           (not (and @prev_at_start (== @prevchr (Magic (byte \^)))))
                           (or (!= @after_slash 0) (and (!= @prevchr (Magic (byte \())) (!= @prevchr (Magic (byte \&))) (!= @prevchr (Magic (byte \|))))))
                    (swap! curchr Magic))

            (byte \^)
                ;; '^' is only magic as the very first character
                ;; and if it's after "\(", "\|", "\&' or "\n"
                (when (and (<= MAGIC_OFF @reg_magic)
                           (or @at_start (== @reg_magic MAGIC_ALL)
                                         (== @prevchr (Magic (byte \())) (== @prevchr (Magic (byte \|))) (== @prevchr (Magic (byte \&))) (== @prevchr (Magic (byte \n)))
                                         (and (== (no-Magic @prevchr) (byte \()) (== @prevprevchr (Magic (byte \%))))))
                    (swap! curchr Magic)
                    (reset! at_start true)
                    (reset! prev_at_start false))

            (byte \$)
                ;; '$' is only magic as the very last character
                ;; and if it's in front of either "\|", "\)", "\&", or "\n"
                (when (<= MAGIC_OFF @reg_magic)
                    (let [[ma? re] ;; ignore \c \C \m \M \v \V and \Z after '$'
                            (loop-when-recur [ma? (boolean (== @reg_magic MAGIC_ALL)) re (.plus @regparse 1)]
                                             (and (at? re (byte \\)) (any == (.at re 1) (byte \c) (byte \C) (byte \m) (byte \M) (byte \v) (byte \V) (byte \Z)))
                                             [(cond (at? re 1 (byte \v)) true (any == (.at re 1) (byte \m) (byte \M) (byte \V)) false :else ma?) (.plus re 2)]
                                          => [ma? re])]
                        (when (or (eos? re)
                                  (and (at? re (byte \\)) (any == (.at re 1) (byte \|) (byte \&) (byte \)) (byte \n)))
                                  (and ma?                (any == (.at re 0) (byte \|) (byte \&) (byte \))))
                                  (== @reg_magic MAGIC_ALL))
                            (swap! curchr Magic)
                        )))

            (byte \\)
                (let [#_int c (.at @regparse 1)]
                    (cond (== c NUL)
                    (do
                        (reset! curchr (byte \\))      ;; trailing '\'
                    )
                    (and (<= (char_u (byte c)) (byte \~)) (non-zero? (... META_flags c)))
                    (do
                        ;; META contains everything that may be magic sometimes,
                        ;; except ^ and $ ("\^" and "\$" are only magic after "\v").
                        ;; We now fetch the next character and toggle its magicness.
                        ;; Therefore, \ is so meta-magic that it is not in META.
                        (reset! curchr -1)
                        (reset! prev_at_start @at_start)
                        (reset! at_start false)   ;; be able to say "/\*ptr"
                        (swap! regparse plus 1)
                        (swap! after_slash inc)
                        (peekchr)
                        (swap! regparse minus 1)
                        (swap! after_slash dec)
                        (swap! curchr toggle-Magic)
                    )
                    (some? (vim-strchr REGEXP_ABBR, c))
                    (do
                        ;; Handle abbreviations, like "\t" for TAB.
                        (reset! curchr (backslash-trans c))
                    )
                    (and (== @reg_magic MAGIC_NONE) (any == c (byte \$) (byte \^)))
                    (do
                        (reset! curchr (toggle-Magic c))
                    )
                    :else
                    (do
                        ;; Next character can never be (made) magic?
                        ;; Then backslashing it won't do anything.
                        (reset! curchr (us-ptr2char @regparse, 1))
                    ))
                )

         ;; :else
            (reset! curchr (us-ptr2char @regparse))
        ))
    @curchr)

;; Eat one lexed character.  Do this in a way that we can undo it.

(defn- #_void skipchr []
    ;; peekchr() eats a backslash, do the same here
    (reset! prevchr_len (if (at? @regparse (byte \\)) 1 0))
    (when (non-eos? @regparse @prevchr_len)
        ;; exclude composing chars that us-ptr2len-cc does include
        (swap! prevchr_len #(+ % (us-ptr2len @regparse %)))
    )
    (swap! regparse plus @prevchr_len)
    (reset! prev_at_start @at_start)
    (reset! at_start false)
    (reset! prevprevchr @prevchr)
    (reset! prevchr @curchr)
    (reset! curchr @nextchr)       ;; use previously unget char, or -1
    (reset! nextchr -1)
    nil)

;; Skip a character while keeping the value of prev_at_start for at_start.
;; prevchr and prevprevchr are also kept.

(defn- #_void skipchr-keepstart []
    (let [#_boolean as @prev_at_start, #_int pr @prevchr, #_int prpr @prevprevchr]
        (skipchr)
        (reset! at_start as)
        (reset! prevchr pr)
        (reset! prevprevchr prpr)
        nil
    ))

;; Get the next character from the pattern.  We know about magic and such, so
;; therefore we need a lexical analyzer.

(defn- #_int getchr []
    (let [#_int chr (peekchr)] (skipchr) chr))

;; put character back.  Works only once!

(defn- #_void ungetchr []
    (reset! nextchr @curchr)
    (reset! curchr @prevchr)
    (reset! prevchr @prevprevchr)
    (reset! at_start @prev_at_start)
    (reset! prev_at_start false)

    ;; Backup "regparse", so that it's at the same position as before the getchr().
    (swap! regparse minus @prevchr_len)
    nil)

;; Get and return the value of the hex string at the current position.
;; Return -1 if there is no valid hex number.
;; The position is updated:
;;     blahblah\%x20asdf
;;         before-^ ^-after
;; The parameter controls the maximum number of input characters.  This will be
;; 2 when reading a \%x20 sequence and 4 when reading a \%u20AC sequence.

(defn- #_int gethexchrs [#_int maxinputlen]
    (let [[#_int n #_int i]
            (loop-when [n 0 i 0] (< i maxinputlen) => [n i]
                (let-when [#_int c (.at @regparse 0)] (asc-isxdigit c) => [n i]
                    (swap! regparse plus 1)
                    (recur (| (<< n 4) (hex2nr c)) (inc i))
                ))]
        (if (zero? i) -1 n)
    ))

;; Get and return the value of the decimal string immediately after the
;; current position.  Return -1 for invalid.  Consumes all digits.

(defn- #_int getdecchrs []
    (let [[#_int n #_int i]
            (loop [n 0 i 0]
                (let-when [#_int c (.at @regparse 0)] (asc-isdigit c) => [n i]
                    (swap! regparse plus 1)
                    (reset! curchr -1)    ;; no longer valid
                    (recur (+ (* n 10) (- c (byte \0))) (inc i))
                ))]
        (if (zero? i) -1 n)
    ))

;; Get and return the value of the octal string immediately after the current
;; position.  Return -1 for invalid, or 0-255 for valid.  Smart enough to handle
;; numbers > 377 correctly (for example, 400 is treated as 40) and doesn't
;; treat 8 or 9 as recognised characters.  Position is updated:
;;     blahblah\%o210asdf
;;         before-^  ^-after

(defn- #_int getoctchrs []
    (let [[#_int n #_int i]
            (loop-when [n 0 i 0] (and (< i 3) (< n 040)) => [n i]
                (let-when [#_int c (.at @regparse 0)] (asc-isodigit c) => [n i]
                    (swap! regparse plus 1)
                    (recur (| (<< n 3) (hex2nr c)) (inc i))
                ))]
        (if (zero? i) -1 n)
    ))

;; Get a number after a backslash that is inside [].
;; When nothing is recognized return a backslash.

(defn- #_int coll-get-char []
    (let [#_int nr
            (condp == (.at (swap! regparse plus 1) -1)
                (byte \d) (getdecchrs)
                (byte \o) (getoctchrs)
                (byte \x) (gethexchrs 2)
                (byte \u) (gethexchrs 4)
                (byte \U) (gethexchrs 8)
            -1)]
        (if (neg? nr) ;; if getting the number fails, be backwards compatible: the character is a backslash
            (do (swap! regparse minus 1) (byte \\))
            nr)
    ))

;; read-limits - Read two integers to be taken as a minimum and maximum.
;; If the first character is '-', then the range is reversed.
;; Should end with 'end'.  If minval is missing, zero is default,
;; if maxval is missing, a very big number is the default.

(defn- #_boolean read-limits [#_long' a'min, #_long' a'max]
    (let [#_boolean reverse (at? @regparse (byte \-))
          _ (when reverse (swap! regparse plus 1))
          #_Bytes start @regparse]
        (reset! a'min (getdigits regparse))
        (reset! a'max (cond
            (at? @regparse (byte \,)) (if (asc-isdigit (.at (swap! regparse plus 1) 0)) (getdigits regparse) MAX_LIMIT)
            (asc-isdigit (.at start 0)) @a'min                      ;; it was \{n} or \{-n}
            :else MAX_LIMIT                                         ;; it was \{} or \{-}
        ))
        (when (at? @regparse (byte \\)) (swap! regparse plus 1))    ;; allow either \{...} or \{...\}
        (if (not-at? @regparse (byte \}))
            (do
;%%             (.sprintf libC @ioBuff, (u8 "E554: Syntax error in %s{...}"), (if (== @reg_magic MAGIC_ALL) (u8 "") (u8 "\\")))
                (emsg @ioBuff)
                (reset! rc_did_emsg true)
                false)
            (do ;; Reverse the range if there was a '-', or make sure it is in the right order otherwise.
                (when (or (and (not reverse) (< @a'max @a'min)) (and reverse (< @a'min @a'max)))
                    (let [_ @a'min] (reset! a'min @a'max) (reset! a'max _)))
                (skipchr)          ;; let's be friends with the lexer again
                true)
        )
    ))

;; Global work variables for vim-regexec().

;; The current match-position is remembered with these variables:
(atom! long     reglnum)                ;; line number, relative to first line
(atom! Bytes    regline)                ;; start of current line
(atom! Bytes    reginput)               ;; current input, points into "regline"

(atom! boolean  need_clear_subexpr)     ;; subexpressions still need to be cleared
(atom! boolean  need_clear_zsubexpr)    ;; extmatch subexpressions still need to be cleared

;; Structure used to save the current input state, when it needs to be
;; restored after trying a match.  Used by reg-save() and reg-restore().
;; Also stores the length of "backpos".

(class! #_final regsave_C
    [
        (field Bytes        rs_ptr)     ;; reginput pointer, for single-line regexp
        (field lpos_C       rs_pos      (NEW_lpos_C)) ;; reginput pos, for multi-line regexp
        (field int          rs_len)
    ])

(defn- #_void COPY-regsave [#_regsave_C rs1, #_regsave_C rs0]
    (ยง
        ((ร rs1.rs_ptr =) (:rs_ptr rs0))
        (COPY-lpos (:rs_pos rs1), (:rs_pos rs0))
        ((ร rs1.rs_len =) (:rs_len rs0))
        nil
    ))

;; struct to save start/end pointer/position in for \(\)
(class! #_final save_se_C
    [
        (field Bytes        se_ptr)
        (field lpos_C       se_pos      (NEW_lpos_C))
    ])

(defn- #_save_se_C* ARRAY-save-se [#_int n]
    (vec (repeatedly n NEW_save_se_C)))

;; used for BEHIND and NOBEHIND matching
(class! #_final regbehind_C
    [
        (field regsave_C    save_after      (NEW_regsave_C))
        (field regsave_C    save_behind     (NEW_regsave_C))
        (field boolean      save_need_clear_subexpr)
        (field save_se_C*   save_start  (ARRAY-save-se NSUBEXP))
        (field save_se_C*   save_end    (ARRAY-save-se NSUBEXP))
    ])

;; Internal copy of 'ignorecase'.  It is set at each call to vim-regexec().
;; Normally it gets the value of "rm_ic" or "rmm_ic", but when the pattern
;; contains '\c' or '\C' the value is overruled.

(atom! boolean ireg_ic)

;; Similar to ireg_ic, but only for 'combining' characters.  Set with \Z flag
;; in the regexp.  Defaults to false, always.

(atom! boolean ireg_icombine)

;; Copy of "rmm_maxcol": maximum column to search for a match.  Zero when
;; there is no maximum.

(atom! int     ireg_maxcol)

;; Sometimes need to save a copy of a line.  Since calloc()/free() is very
;; slow, we keep one allocated piece of memory and only re-allocate it when
;; it's too small.  It's freed in bt-regexec-both() when finished.

(atom! Bytes reg_tofree)
(atom! int reg_tofree_len)

;; These variables are set when executing a regexp to speed up the execution.
;; Which ones are set depends on whether a single-line or multi-line match is
;; done:
;;                      single-line             multi-line
;; reg_match            regmatch_C              null
;; reg_mmatch           null                    regmmatch_C
;; reg_startp           reg_match.startp        <invalid>
;; reg_endp             reg_match.endp          <invalid>
;; reg_startpos         <invalid>               reg_mmatch.startpos
;; reg_endpos           <invalid>               reg_mmatch.endpos
;; reg_firstlnum        <invalid>               first line in which to search
;; reg_maxline          0                       last line nr
;; reg_line_lbr         false or true           false

(atom! regmatch_C   reg_match)
(atom! regmmatch_C  reg_mmatch)
(atom! Bytes*       reg_startp)
(atom! Bytes*       reg_endp)
(atom! lpos_C*      reg_startpos)
(atom! lpos_C*      reg_endpos)
(atom! long         reg_firstlnum)
(atom! long         reg_maxline)
(atom! boolean      reg_line_lbr)       ;; "\n" in string is line break

;; Values for rs_state in regitem_C.
(final int
    RS_NOPEN 0,           ;; NOPEN and NCLOSE
    RS_MOPEN 1,           ;; MOPEN + [0-9]
    RS_MCLOSE 2,          ;; MCLOSE + [0-9]
    RS_ZOPEN 3,           ;; ZOPEN + [0-9]
    RS_ZCLOSE 4,          ;; ZCLOSE + [0-9]
    RS_BRANCH 5,          ;; BRANCH
    RS_BRCPLX_MORE 6,     ;; BRACE_COMPLEX and trying one more match
    RS_BRCPLX_LONG 7,     ;; BRACE_COMPLEX and trying longest match
    RS_BRCPLX_SHORT 8,    ;; BRACE_COMPLEX and trying shortest match
    RS_NOMATCH 9,         ;; NOMATCH
    RS_BEHIND1 10,        ;; BEHIND / NOBEHIND matching rest
    RS_BEHIND2 11,        ;; BEHIND / NOBEHIND matching behind part
    RS_STAR_LONG 12,      ;; STAR/PLUS/BRACE_SIMPLE longest match
    RS_STAR_SHORT 13)     ;; STAR/PLUS/BRACE_SIMPLE shortest match

;; When there are alternatives, a RS_ is put on the regstack to remember what we are doing.
;; Before it may be another type of item, depending on "rs_state", to remember more things.

(class! #_final regitem_C
    [
        (field int          rs_state)       ;; what we are doing, one of RS_ above
        (field Bytes        rs_scan)        ;; current node in program
        (field save_se_C    rs_sesave       (NEW_save_se_C))  ;; union room for saving reginput
        (field regsave_C    rs_regsave      (NEW_regsave_C))  ;; union room for saving reginput
        (field int          rs_no)          ;; submatch nr or BEHIND/NOBEHIND
    ])

;; Used for STAR, PLUS and BRACE_SIMPLE matching.
(class! #_final regstar_C
    [
        (field int          nextb)          ;; next byte
        (field int          nextb_ic)       ;; next byte reverse case
        (field long         count)
        (field long         minval)
        (field long         maxval)
    ])

;; Used to store input position when a BACK was encountered,
;; so that we now if we made any progress since the last time.

(class! #_final backpos_C
    [
        (field Bytes        bp_scan)        ;; "scan" where BACK was encountered
        (field regsave_C    bp_pos      (NEW_regsave_C))  ;; last input position
    ])

;; "regstack" and "backpos" are used by regmatch().
;; They are kept over calls to avoid invoking calloc() and free() often.
;; "regstack" is a stack with regitem_C items, sometimes preceded by regstar_C or regbehind_C.
;; "backpos" is a table with backpos_C items for BACK.

(atom! Object*      regstack)
(atom! backpos_C*   backpos)

;; Both for regstack and backpos tables we use the following strategy of allocation
;; (to reduce calloc/free calls):
;; - Initial size is fairly small.
;; - When needed, the tables are grown bigger (8 times at first, double after that).
;; - After executing the match we free the memory only if the array has grown.
;;   Thus the memory is kept allocated when it's at the initial size.
;; This makes it fast while not keeping a lot of memory allocated.
;; A three times speed increase was observed when using many simple patterns.

(final int REGSTACK_INITIAL 2048)
(final int BACKPOS_INITIAL    64)

;; Create "regstack" and "backpos".
;; We allocate *_INITIAL amount of bytes first and then set the grow size to much bigger value
;; to avoid many calloc calls in case of deep regular expressions.

(defn- #_void create-regstack []
    (ยง
        ;; Use Object item, since we push different things onto the regstack.
        (reset! regstack (ร new Growing<Object>(Object.class, REGSTACK_INITIAL)))
        (.ga_grow @regstack REGSTACK_INITIAL)
        (swap! regstack assoc :ga_growsize (* REGSTACK_INITIAL 8))
        nil
    ))

(defn- #_void create-backpos []
    (ยง
        (reset! backpos (ร new Growing<backpos_C>(backpos_C.class, BACKPOS_INITIAL)))
        (.ga_grow @backpos BACKPOS_INITIAL)
        (swap! backpos assoc :ga_growsize (* BACKPOS_INITIAL 8))
        nil
    ))

;; Get pointer to the line "lnum", which is relative to "reg_firstlnum".

(defn- #_Bytes reg-getline [#_long lnum]
    (cond
        (< (+ @reg_firstlnum lnum) 1) ;; When looking behind for a match/no-match, lnum is negative, but we can't go before line 1.
            nil
        (< @reg_maxline lnum) ;; Must have matched the "\n" in the last line.
            (u8 "")
        :else
            (ml-get (+ @reg_firstlnum lnum))
    ))

(atom! regsave_C    behind_pos      (NEW_regsave_C))

(final Bytes*       reg_startzp     NSUBEXP)                ;; Workspace to mark beginning
(final Bytes*       reg_endzp       NSUBEXP)                ;;   and end of \z(...\) matches
(final lpos_C*      reg_startzpos   (ARRAY-lpos NSUBEXP))   ;; idem, beginning pos
(final lpos_C*      reg_endzpos     (ARRAY-lpos NSUBEXP))   ;; idem, end pos

;; Match a regexp against a string.
;; "rmp.regprog" is a compiled regexp as returned by vim-regcomp().
;; Uses curbuf for line count and 'iskeyword'.
;; If "line_lbr" is true, consider a "\n" in "line" to be a line break.
;;
;; Returns 0 for failure, number of lines contained in the match otherwise.

(defn- #_long bt-regexec-nl [#_regmatch_C rmp, #_Bytes line, #_int col, #_boolean line_lbr]
    ;; line: string to match against
    ;; col: column to start looking for match
    (reset! reg_match rmp)
    (reset! reg_mmatch nil)
    (reset! reg_maxline 0)
    (reset! reg_line_lbr line_lbr)
    (reset! ireg_ic (:rm_ic rmp))
    (reset! ireg_icombine false)
    (reset! ireg_maxcol 0)

    (bt-regexec-both line, col, nil))

;; Match a regexp against multiple lines.
;; "rmp.regprog" is a compiled regexp as returned by vim-regcomp().
;;
;; Return zero if there is no match.  Return number of lines contained in the match otherwise.

(defn- #_long bt-regexec-multi [#_regmmatch_C rmp, #_long lnum, #_int col, #_long nsec]
    ;; lnum: nr of line to start looking for match
    ;; col: column to start looking for match
    ;; nsec: timeout limit or 0
    (reset! reg_match nil)
    (reset! reg_mmatch rmp)
    (reset! reg_firstlnum lnum)
    (reset! reg_maxline (- (line-count @curbuf) lnum))
    (reset! reg_line_lbr false)
    (reset! ireg_ic (:rmm_ic rmp))
    (reset! ireg_icombine false)
    (reset! ireg_maxcol (:rmm_maxcol rmp))

    (bt-regexec-both nil, col, nsec))

;; Match a regexp against a string ("line" points to the string)
;; or multiple lines ("line" is null, use reg-getline()).
;; Returns 0 for failure, number of lines contained in the match otherwise.

(defn- #_long bt-regexec-both [#_Bytes line, #_int col, #_long nsec]
    ;; col: column to start looking for match
    ;; nsec: timeout limit or 0
    (ยง
        ((ร long retval =) 0)

        (when (nil? @regstack)
            (create-regstack))
        (when (nil? @backpos)
            (create-backpos))

        (ร bt_regprog_C prog)
        (cond (nil? @reg_match)
        (do
            ((ร prog =) (ร (bt_regprog_C)(@reg_mmatch.regprog)))
            ((ร line =) (reg-getline 0))
            (reset! reg_startpos (:startpos @reg_mmatch))
            (reset! reg_endpos (:endpos @reg_mmatch))
        )
        :else
        (do
            ((ร prog =) (ร (bt_regprog_C)(@reg_match.regprog)))
            (reset! reg_startp (:startp @reg_match))
            (reset! reg_endp (:endp @reg_match))
        ))

;       theend:
;       {
            ;; Be paranoid...
            (when (or (nil? prog) (nil? line))
                (emsg e_null)
                (ร BREAK theend)
            )

            ;; Check validity of program.
            (if (prog-magic-wrong)
                (ร BREAK theend)
            )

            ;; If the start column is past the maximum column: no need to try.
            (if (and (< 0 @ireg_maxcol) (<= @ireg_maxcol col))
                (ร BREAK theend)
            )

            ;; If pattern contains "\c" or "\C": overrule value of ireg_ic.
            (cond (flag? (:regflags prog) RF_ICASE)
            (do
                (reset! ireg_ic true)
            )
            (flag? (:regflags prog) RF_NOICASE)
            (do
                (reset! ireg_ic false)
            ))

            ;; If pattern contains "\Z" overrule value of ireg_icombine.
            (when (flag? (:regflags prog) RF_ICOMBINE)
                (reset! ireg_icombine true))

            ;; If there is a "must appear" string, look for it.
            (when (some? (:regmust prog))
                ((ร int c =) (us-ptr2char (:regmust prog)))
                ((ร Bytes s =) (.plus line col))

                ;; This is used very often, esp. for ":global".
                ;; Use three versions of the loop to avoid overhead of conditions.

                (cond (not @ireg_ic)
                (do
                    (loop-when [] (!= ((ร s =) (vim-strchr s, c)) nil)
                        (ร int cmp)
                        (let [__ (atom (int (:regmlen prog)))]
                            ((ร cmp =) (cstrncmp s, (:regmust prog), __))
                            ((ร prog =) (assoc prog :regmlen @__)))
                        (if (zero? cmp)
                            (ร BREAK)              ;; Found it.
                        )
                        ((ร s =) (.plus s (us-ptr2len-cc s)))
                        (recur)
                    )
                )
                :else
                (do
                    (loop-when [] (!= ((ร s =) (cstrchr s, c)) nil)
                        (ร int cmp)
                        (let [__ (atom (int (:regmlen prog)))]
                            ((ร cmp =) (cstrncmp s, (:regmust prog), __))
                            ((ร prog =) (assoc prog :regmlen @__)))
                        (if (zero? cmp)
                            (ร BREAK)              ;; Found it.
                        )
                        ((ร s =) (.plus s (us-ptr2len-cc s)))
                        (recur)
                    )
                ))
                (if (nil? s)          ;; Not present.
                    (ร BREAK theend)
                )
            )

            (reset! regline line)
            (reset! reglnum 0)
            (reset! reg_toolong false)

            ;; Simplest case: Anchored match need be tried only once.
            (cond (non-zero? (:reganch prog))
            (do
                ((ร int c =) (us-ptr2char @regline, col))
                (cond (or (== (:regstart prog) NUL) (== (:regstart prog) c) (and @ireg_ic (or (== (utf-fold (:regstart prog)) (utf-fold c)) (and (< c 255) (< (:regstart prog) 255) (== (utf-tolower (:regstart prog)) (utf-tolower c))))))
                (do
                    ((ร retval =) (regtry prog, col))
                )
                :else
                (do
                    ((ร retval =) 0)
                ))
            )
            :else
            (do
                ((ร int tm_count =) 0)
                ;; Messy cases: Unanchored match.
                (loop-when [] (not @got_int)
                    (when (!= (:regstart prog) NUL)
                        ;; Skip until the char we know it must start with.
                        ;; Used often, do some work to avoid call overhead.
                        ((ร Bytes s =) (cstrchr (.plus @regline col), (:regstart prog)))
                        (when (nil? s)
                            ((ร retval =) 0)
                            (ร BREAK)
                        )
                        ((ร col =) (BDIFF s, @regline))
                    )

                    ;; Check for maximum column to try.
                    (when (and (< 0 @ireg_maxcol) (<= @ireg_maxcol col))
                        ((ร retval =) 0)
                        (ร BREAK)
                    )

                    ((ร retval =) (regtry prog, col))
                    (if (< 0 retval)
                        (ร BREAK)
                    )

                    ;; if not currently on the first line, get it again
                    (when (non-zero? @reglnum)
                        (reset! reglnum 0)
                        (reset! regline (reg-getline 0))
                    )
                    (if (eos? @regline col)
                        (ร BREAK)
                    )
                    ((ร col =) (+ col (us-ptr2len-cc @regline, col)))
                    ;; Check for timeout once in a twenty times to avoid overhead.
                    (when (and (non-zero? nsec) (== ((ร tm_count =) (inc tm_count)) 20))
                        ((ร tm_count =) 0)
                        (if (profile-passed-limit nsec)
                            (ร BREAK)
                        )
                    )
                    (recur)
                )
            ))
;       }

        ;; Free "reg_tofree" when it's a bit big.
        (when (< 400 @reg_tofree_len)
            (reset! reg_tofree nil))

        ;; Free backpos and regstack if they are bigger than their initial size.
        (when (< BACKPOS_INITIAL (:ga_maxlen @backpos))
            ((ร backpos_C[] bpp =) (:ga_data @backpos))
            (loop-when [] (< 0 (ร @backpos.ga_len--))
                ((ร bpp[@backpos.ga_len] =) nil)
                (recur)
            )
            (.ga_clear @backpos)
            (reset! backpos nil)
        )
        (when (< REGSTACK_INITIAL (:ga_maxlen @regstack))
            ((ร Object[] rpp =) (:ga_data @regstack))
            (loop-when [] (< 0 (ร @regstack.ga_len--))
                ((ร rpp[@regstack.ga_len] =) nil)
                (recur)
            )
            (.ga_clear @regstack)
            (reset! regstack nil)
        )

        retval
    ))

;; Create a new extmatch and mark it as referenced once.

(defn- #_reg_extmatch_C make-extmatch []
    (NEW_reg_extmatch_C))

;; Try match of "prog" with at regline[col].
;; Returns 0 for failure, number of lines contained in the match otherwise.

(defn- #_long regtry [#_bt_regprog_C prog, #_int col]
    (ยง
        (reset! reginput (.plus @regline col))
        (reset! need_clear_subexpr true)
        ;; Clear the external match subpointers if necessary.
        (when (== (:reghasz prog) REX_SET)
            (reset! need_clear_zsubexpr true))

        (if (not (regmatch (.plus (:program prog) 1)))
            ((ร RETURN) 0)
        )

        (cleanup-subexpr)
        (cond (nil? @reg_match)
        (do
            (when (< (:lnum (... @reg_startpos 0)) 0)
                ((ร @reg_startpos[0].lnum =) 0)
                ((ร @reg_startpos[0].col =) col)
            )
            (cond (< (:lnum (... @reg_endpos 0)) 0)
            (do
                ((ร @reg_endpos[0].lnum =) @reglnum)
                ((ร @reg_endpos[0].col =) (BDIFF @reginput, @regline))
            )
            :else
            (do
                ;; Use line number of "\ze".
                (reset! reglnum (:lnum (... @reg_endpos 0)))
            ))
        )
        :else
        (do
            (if (nil? (... @reg_startp 0))
                ((ร @reg_startp[0] =) (.plus @regline col))
            )
            (if (nil? (... @reg_endp 0))
                ((ร @reg_endp[0] =) @reginput)
            )
        ))
        ;; Package any found \z(...\) matches for export.  Default is none.
        (reset! re_extmatch_out nil)

        (when (== (:reghasz prog) REX_SET)
            (cleanup-zsubexpr)
            (reset! re_extmatch_out (make-extmatch))
            (dotimes [#_int i NSUBEXP]
                (cond (nil? @reg_match)
                (do
                    ;; Only accept single line matches.
                    (when (and (<= 0 (:lnum (... reg_startzpos i))) (== (:lnum (... reg_endzpos i)) (:lnum (... reg_startzpos i))) (>= (:col (... reg_endzpos i)) (:col (... reg_startzpos i))))
                        ((ร @re_extmatch_out.matches[i] =) (STRNDUP (.plus (reg-getline (:lnum (... reg_startzpos i))) (:col (... reg_startzpos i))), (- (:col (... reg_endzpos i)) (:col (... reg_startzpos i)))))
                    )
                )
                :else
                (do
                    (when (and (some? (... reg_startzp i)) (some? (... reg_endzp i)))
                        ((ร @re_extmatch_out.matches[i] =) (STRNDUP (... reg_startzp i), (BDIFF (... reg_endzp i), (... reg_startzp i))))
                    )
                ))
            )
        )
        (+ 1 @reglnum)
    ))

;; Get class of previous character.

(defn- #_int reg-prev-class []
    (if (BLT @regline, @reginput) (us-get-class (.minus @reginput (inc (us-head-off @regline, (.minus @reginput 1))))) -1))

;; Return true if the current reginput position matches the Visual area.

(defn- #_boolean reg-match-visual []
    (if (zero? (:lnum @VIsual_cursor))
        false
        (let-when [[#_pos_C top #_pos_C bot #_int mode]
                (if @VIsual_active
                    (let [v @VIsual_cursor c (:w_cursor @curwin) m @VIsual_mode]
                        (if (ltpos v, c) [v c m] [c v m]))
                    (let [v (:b_visual @curbuf) s (:vi_start v) e (:vi_end v) m (:vi_mode v)]
                        (if (ltpos s, e) [s e m] [e s m])
                    ))
              #_long lnum (+ @reglnum @reg_firstlnum)
        ] (<= (:lnum top) lnum (:lnum bot)) => false

            (condp == mode
                (byte \v)
                    (let [#_int col (BDIFF @reginput, @regline)]
                        (and (or (!= lnum (:lnum top)) (<= (:col top) col))
                             (or (!= lnum (:lnum bot)) (< col (+ (:col bot) (if (not-at? @p_sel (byte \e)) 1 0))))
                        ))
                Ctrl_V
                    (let [a's1 (atom (int)) a'e1 (atom (int)) _ (getvvcol @curwin, top, a's1, nil, a'e1)
                          a's2 (atom (int)) a'e2 (atom (int)) _ (getvvcol @curwin, bot, a's2, nil, a'e2)]
                        (reset! a's1 (min @a's1 @a's2))
                        (reset! a'e1 (max @a'e2 @a'e1))
                        (when (or (== (:col top) MAXCOL) (== (:col bot) MAXCOL))
                            (reset! a'e1 MAXCOL))
                        (let [#_int cols (win-linetabsize @curwin, @regline, (BDIFF @reginput, @regline))]
                            (<= @a's1 cols (- @a'e1 (if (at? @p_sel (byte \e)) 1 0)))
                        ))
                true
            ))
    ))

;; The arguments from BRACE_LIMITS are stored here.  They are actually local
;; to regmatch(), but they are here to reduce the amount of stack space used
;; (it can be called recursively many times).

(atom! long     bl_minval)
(atom! long     bl_maxval)

(final int
    RA_FAIL 1,            ;; something failed, abort
    RA_CONT 2,            ;; continue in inner loop
    RA_BREAK 3,           ;; break inner loop
    RA_MATCH 4,           ;; successful match
    RA_NOMATCH 5)         ;; didn't match

;; regmatch - main matching routine
;;
;; Conceptually the strategy is simple:
;; check to see whether the current node matches, push an item onto the regstack
;; and loop to see whether the rest matches, and then act accordingly.
;;
;; In practice we make some effort to avoid using the regstack,
;; in particular by going through "ordinary" nodes (that don't need to know
;; whether the rest of the match failed) by a nested loop.
;;
;; Returns true when there is a match.
;; Leaves reginput and reglnum just after the last matched character.
;;
;; Returns false when there is no match.
;; Leaves reginput and reglnum in an undefined state!

(defn- #_boolean regmatch [#_Bytes scan]
    ;; scan: Current node.
    (ยง
        (ร int status)                 ;; one of the RA_ values:

        ;; Make "regstack" and "backpos" empty.
        ;; They are allocated and freed in bt-regexec-both() to reduce calloc()/free() calls.
        (swap! regstack assoc :ga_len 0)
        (swap! backpos assoc :ga_len 0)

        ;; Repeat until "regstack" is empty.

        (loop []
            ;; Some patterns may take a long time to match, e.g., "\([a-z]\+\)\+Q".
            ;; Allow interrupting them with CTRL-C.
            (fast-breakcheck)

            ;; Repeat for items that can be matched sequentially, without using the regstack.

            (loop []
                (when (or @got_int (nil? scan))
                    ((ร status =) RA_FAIL)
                    (ร BREAK)
                )
                ((ร status =) RA_CONT)

                ((ร Bytes next =) (regnext scan))        ;; Next node.

                ((ร int op =) (re-op scan))
                ;; Check for character class with NL added.
                (cond (and (not @reg_line_lbr) (with-nl op) (nil? @reg_match) (eos? @reginput) (<= @reglnum @reg_maxline))
                (do
                    (reg-nextline)
                    (fast-breakcheck)
                )
                (and @reg_line_lbr (with-nl op) (at? @reginput (byte \newline)))
                (do
                    (reg-nextchar)
                )
                :else
                (do
                    ((ร op =) (if (with-nl op) (- op ADD_NL) op))
                    ((ร int c =) (us-ptr2char @reginput))
                    (condp ==? op
                        BOL
                        (do
                            ((ร status =) (if (BNE @reginput, @regline) RA_NOMATCH status))
                            (ร BREAK)
                        )

                        EOL
                        (do
                            ((ร status =) (if (!= c NUL) RA_NOMATCH status))
                            (ร BREAK)
                        )

                        RE_BOF
                        (do
                            ;; We're not at the beginning of the file when below the first
                            ;; line where we started, not at the start of the line or we
                            ;; didn't start at the first line of the buffer.
                            ((ร status =) (if (or (non-zero? @reglnum) (BNE @reginput, @regline) (and (nil? @reg_match) (< 1 @reg_firstlnum))) RA_NOMATCH status))
                            (ร BREAK)
                        )

                        RE_EOF
                        (do
                            ((ร status =) (if (or (!= @reglnum @reg_maxline) (!= c NUL)) RA_NOMATCH status))
                            (ร BREAK)
                        )

                        CURSOR
                        (do
                            ;; Compare the cursor position to the match position.
                            ((ร status =) (if (or (!= (+ @reglnum @reg_firstlnum) (:lnum (:w_cursor @curwin))) (!= (BDIFF @reginput, @regline) (:col (:w_cursor @curwin)))) RA_NOMATCH status))
                            (ร BREAK)
                        )

                        RE_MARK
                        (do
                            ;; Compare the mark position to the match position.
                            ((ร int mark =) (.at (operand scan) 0))
                            ((ร int cmp =) (.at (operand scan) 1))

                            ((ร pos_C pos =) (getmark mark, false))
                            ((ร status =) (if (or (nil? pos) (< (:lnum pos) 1) (if (== (:lnum pos) (+ @reglnum @reg_firstlnum)) (if (== (:col pos) (BDIFF @reginput, @regline)) (any == cmp (byte \<) (byte \>)) (if (< (:col pos) (BDIFF @reginput, @regline)) (!= cmp (byte \>)) (!= cmp (byte \<)))) (if (< (:lnum pos) (+ @reglnum @reg_firstlnum)) (!= cmp (byte \>)) (!= cmp (byte \<))))) RA_NOMATCH status))
                            (ร BREAK)
                        )

                        RE_VISUAL
                        (do
                            ((ร status =) (if (not (reg-match-visual)) RA_NOMATCH status))
                            (ร BREAK)
                        )

                        RE_LNUM
                        (do
                            ((ร status =) (if (or (some? @reg_match) (not (re-num-cmp (+ @reglnum @reg_firstlnum), scan))) RA_NOMATCH status))
                            (ร BREAK)
                        )

                        RE_COL
                        (do
                            ((ร status =) (if (not (re-num-cmp (inc (BDIFF @reginput, @regline)), scan)) RA_NOMATCH status))
                            (ร BREAK)
                        )

                        RE_VCOL
                        (do
                            ((ร status =) (if (not (re-num-cmp (+ (long (win-linetabsize @curwin, @regline, (BDIFF @reginput, @regline))) 1), scan)) RA_NOMATCH status))
                            (ร BREAK)
                        )

                        BOW                           ;; \<word; reginput points to w
                        (do
                            (cond (== c NUL)                   ;; can't match at end of line
                            (do
                                ((ร status =) RA_NOMATCH)
                            )
                            :else
                            (do
                                ;; Get class of current and previous char (if it exists).
                                ((ร int this_class =) (us-get-class @reginput))
                                (cond (<= this_class 1)
                                (do
                                    ((ร status =) RA_NOMATCH)    ;; not on a word at all
                                )
                                (== (reg-prev-class) this_class)
                                (do
                                    ((ร status =) RA_NOMATCH)    ;; previous char is in same word
                                ))
                            ))
                            (ร BREAK)
                        )

                        EOW                           ;; word\>; reginput points after d
                        (do
                            (cond (BEQ @reginput, @regline)        ;; can't match at start of line
                            (do
                                ((ร status =) RA_NOMATCH)
                            )
                            :else
                            (do
                                ;; Get class of current and previous char (if it exists).
                                ((ร int this_class =) (us-get-class @reginput))
                                ((ร int prev_class =) (reg-prev-class))
                                ((ร status =) (if (or (== this_class prev_class) (zero? prev_class) (== prev_class 1)) RA_NOMATCH status))
                            ))
                            (ร BREAK) ;; Matched with EOW.
                        )

                        ANY
                        (do
                            ;; ANY does not match new lines.
                            (if (== c NUL)
                                ((ร status =) RA_NOMATCH)
                                (reg-nextchar))
                            (ร BREAK)
                        )

                        IDENT
                        (do
                            (if (not (vim-isidentc c))
                                ((ร status =) RA_NOMATCH)
                                (reg-nextchar))
                            (ร BREAK)
                        )

                        SIDENT
                        (do
                            (if (or (asc-isdigit (.at @reginput 0)) (not (vim-isidentc c)))
                                ((ร status =) RA_NOMATCH)
                                (reg-nextchar))
                            (ร BREAK)
                        )

                        KWORD
                        (do
                            (if (not (us-iswordp @reginput))
                                ((ร status =) RA_NOMATCH)
                                (reg-nextchar))
                            (ร BREAK)
                        )

                        SKWORD
                        (do
                            (if (or (asc-isdigit (.at @reginput 0)) (not (us-iswordp @reginput)))
                                ((ร status =) RA_NOMATCH)
                                (reg-nextchar))
                            (ร BREAK)
                        )

                        FNAME
                        (do
                            (if (not (vim-isfnamec c))
                                ((ร status =) RA_NOMATCH)
                                (reg-nextchar))
                            (ร BREAK)
                        )

                        SFNAME
                        (do
                            (if (or (asc-isdigit (.at @reginput 0)) (not (vim-isfnamec c)))
                                ((ร status =) RA_NOMATCH)
                                (reg-nextchar))
                            (ร BREAK)
                        )

                        PRINT
                        (do
                            (if (not (vim-isprintc (us-ptr2char @reginput)))
                                ((ร status =) RA_NOMATCH)
                                (reg-nextchar))
                            (ร BREAK)
                        )

                        SPRINT
                        (do
                            (if (or (asc-isdigit (.at @reginput 0)) (not (vim-isprintc (us-ptr2char @reginput))))
                                ((ร status =) RA_NOMATCH)
                                (reg-nextchar))
                            (ร BREAK)
                        )

                        WHITE
                        (do
                            (if (not (vim-iswhite c))
                                ((ร status =) RA_NOMATCH)
                                (reg-nextchar))
                            (ร BREAK)
                        )

                        NWHITE
                        (do
                            (if (or (== c NUL) (vim-iswhite c))
                                ((ร status =) RA_NOMATCH)
                                (reg-nextchar))
                            (ร BREAK)
                        )

                        DIGIT
                        (do
                            (if (not (ri-digit c))
                                ((ร status =) RA_NOMATCH)
                                (reg-nextchar))
                            (ร BREAK)
                        )

                        NDIGIT
                        (do
                            (if (or (== c NUL) (ri-digit c))
                                ((ร status =) RA_NOMATCH)
                                (reg-nextchar))
                            (ร BREAK)
                        )

                        HEX
                        (do
                            (if (not (ri-hex c))
                                ((ร status =) RA_NOMATCH)
                                (reg-nextchar))
                            (ร BREAK)
                        )

                        NHEX
                        (do
                            (if (or (== c NUL) (ri-hex c))
                                ((ร status =) RA_NOMATCH)
                                (reg-nextchar))
                            (ร BREAK)
                        )

                        OCTAL
                        (do
                            (if (not (ri-octal c))
                                ((ร status =) RA_NOMATCH)
                                (reg-nextchar))
                            (ร BREAK)
                        )

                        NOCTAL
                        (do
                            (if (or (== c NUL) (ri-octal c))
                                ((ร status =) RA_NOMATCH)
                                (reg-nextchar))
                            (ร BREAK)
                        )

                        WORD
                        (do
                            (if (not (ri-word c))
                                ((ร status =) RA_NOMATCH)
                                (reg-nextchar))
                            (ร BREAK)
                        )

                        NWORD
                        (do
                            (if (or (== c NUL) (ri-word c))
                                ((ร status =) RA_NOMATCH)
                                (reg-nextchar))
                            (ร BREAK)
                        )

                        HEAD
                        (do
                            (if (not (ri-head c))
                                ((ร status =) RA_NOMATCH)
                                (reg-nextchar))
                            (ร BREAK)
                        )

                        NHEAD
                        (do
                            (if (or (== c NUL) (ri-head c))
                                ((ร status =) RA_NOMATCH)
                                (reg-nextchar))
                            (ร BREAK)
                        )

                        ALPHA
                        (do
                            (if (not (ri-alpha c))
                                ((ร status =) RA_NOMATCH)
                                (reg-nextchar))
                            (ร BREAK)
                        )

                        NALPHA
                        (do
                            (if (or (== c NUL) (ri-alpha c))
                                ((ร status =) RA_NOMATCH)
                                (reg-nextchar))
                            (ร BREAK)
                        )

                        LOWER
                        (do
                            (if (not (ri-lower c))
                                ((ร status =) RA_NOMATCH)
                                (reg-nextchar))
                            (ร BREAK)
                        )

                        NLOWER
                        (do
                            (if (or (== c NUL) (ri-lower c))
                                ((ร status =) RA_NOMATCH)
                                (reg-nextchar))
                            (ร BREAK)
                        )

                        UPPER
                        (do
                            (if (not (ri-upper c))
                                ((ร status =) RA_NOMATCH)
                                (reg-nextchar))
                            (ร BREAK)
                        )

                        NUPPER
                        (do
                            (if (or (== c NUL) (ri-upper c))
                                ((ร status =) RA_NOMATCH)
                                (reg-nextchar))
                            (ร BREAK)
                        )

                        EXACTLY
                        (do
                            ((ร Bytes opnd =) (operand scan))
                            ;; Inline the first byte, for speed.
                            (cond (and (not-at? opnd (.at @reginput 0)) (not @ireg_ic))
                            (do
                                ((ร status =) RA_NOMATCH)
                            )
                            (eos? opnd)
                            (do
                                ;; match empty string always works; happens when "~" is empty.
                            )
                            :else
                            (do
                                ((ร int[] a'len =) (atom (int)))
                                (cond (and (eos? opnd 1) (not @ireg_ic))
                                (do
                                    (reset! a'len 1)        ;; matched a single byte above
                                )
                                :else
                                (do
                                    ;; Need to match first byte again for multi-byte.
                                    (reset! a'len (STRLEN opnd))
                                    ((ร status =) (if (non-zero? (cstrncmp opnd, @reginput, a'len)) RA_NOMATCH status))
                                ))
                                ;; Check for following composing character, unless %C follows (skips over all composing chars).
                                (when (and (!= status RA_NOMATCH) (utf-iscomposing (us-ptr2char @reginput, @a'len)) (not @ireg_icombine) (!= (re-op next) RE_COMPOSING))
                                    ;; This code makes a composing character get ignored,
                                    ;; which is the correct behavior (sometimes)
                                    ;; for voweled Hebrew texts.
                                    ((ร status =) RA_NOMATCH)
                                )
                                (if (!= status RA_NOMATCH)
                                    (swap! reginput plus @a'len))
                            ))
                            (ร BREAK)
                        )

                       [ANYOF ANYBUT]
                        (do
                            (cond (== c NUL)
                            (do
                                ((ร status =) RA_NOMATCH)
                            )
                            (== (nil? (cstrchr (operand scan), c)) (== op ANYOF))
                            (do
                                ((ร status =) RA_NOMATCH)
                            )
                            :else
                            (do
                                (reg-nextchar)
                            ))
                            (ร BREAK)
                        )

                        MULTIBYTECODE
                        (do
                            ((ร Bytes opnd =) (operand scan))
                            ;; Safety check (just in case 'encoding' was changed since compiling the program).
                            ((ร int len =) (us-ptr2len-cc opnd))
                            (when (< len 2)
                                ((ร status =) RA_NOMATCH)
                                (ร BREAK)
                            )
                            ((ร int opndc =) (us-ptr2char opnd))
                            (cond (utf-iscomposing opndc)
                            (do
                                ;; When only a composing char is given match at any
                                ;; position where that composing char appears.
                                ((ร status =) RA_NOMATCH)
                                (loop-when-recur [#_int i 0] (non-eos? @reginput i) [(+ i (us-ptr2len @reginput, i))]
                                    ((ร int inpc =) (us-ptr2char @reginput, i))
                                    (cond (not (utf-iscomposing inpc))
                                    (do
                                        (if (< 0 i)
                                            (ร BREAK)
                                        )
                                    )
                                    (== opndc inpc)
                                    (do
                                        ;; Include all following composing chars.
                                        ((ร len =) (+ i (us-ptr2len-cc @reginput, i)))
                                        ((ร status =) RA_MATCH)
                                        (ร BREAK)
                                    ))
                                )
                            )
                            :else
                            (do
                                (dotimes [#_int i len]
                                    (when (not-at? opnd i (.at @reginput i))
                                        ((ร status =) RA_NOMATCH)
                                        (ร BREAK)
                                    )
                                )
                            ))

                            (swap! reginput plus len)
                            (ร BREAK)
                        )

                        RE_COMPOSING
                        (do
                            ;; Skip composing characters.
                            (while (utf-iscomposing (us-ptr2char @reginput))
                                (swap! reginput #(.plus % (us-ptr2len %))))
                            (ร BREAK)
                        )

                        NOTHING
                        (do
                            (ร BREAK)
                        )

                        BACK
                        (do
                            ;; When we run into BACK we need to check if we don't keep
                            ;; looping without matching any input.  The second and later
                            ;; times a BACK is encountered it fails if the input is still
                            ;; at the same position as the previous time.
                            ;; The positions are stored in "backpos" and found by the
                            ;; current value of "scan", the position in the RE program.

                            ((ร backpos_C[] bpp =) (:ga_data @backpos))

                            ((ร int i =) (loop-when-recur [i 0] (< i (:ga_len @backpos)) [(inc i)] => i
                                (if (BEQ (:bp_scan (... bpp i)), scan)
                                    (ร BREAK)
                                )
                            ))
                            (cond (== i (:ga_len @backpos))
                            (do
                                ;; First time at this BACK, make room to store the pos.
                                ((ร bpp =) (.ga_grow @backpos 1))
                                ((ร bpp[i] =) (NEW_backpos_C))
                                ((ร bpp[i].bp_scan =) scan)
                                (swap! backpos update :ga_len inc)
                            )
                            (reg-save-equal (:bp_pos (... bpp i)))
                            (do
                                ;; Still at same position as last time, fail.
                                ((ร status =) RA_NOMATCH)
                            ))

                            (when (and (!= status RA_FAIL) (!= status RA_NOMATCH))
                                (reg-save (:bp_pos (... bpp i)), @backpos))

                            (ร BREAK)
                        )

                       [(+ MOPEN 0)     ;; Match start: \zs
                        (+ MOPEN 1)     ;; \(
                        (+ MOPEN 2)
                        (+ MOPEN 3)
                        (+ MOPEN 4)
                        (+ MOPEN 5)
                        (+ MOPEN 6)
                        (+ MOPEN 7)
                        (+ MOPEN 8)
                        (+ MOPEN 9)]
                        (do
                            ((ร int no =) (- op MOPEN))
                            (cleanup-subexpr)
                            ((ร regitem_C rip =) (push-regitem RS_MOPEN, scan))
                            (cond (nil? rip)
                            (do
                                ((ร status =) RA_FAIL)
                            )
                            :else
                            (do
                                ((ร rip =) (assoc rip :rs_no no))
                                ((ร @reg_startp[no] =) (save-se (:rs_sesave rip), (... @reg_startpos no), (... @reg_startp no)))
                                ;; We simply continue and handle the result when done.
                            ))
                            (ร BREAK)
                        )

                       [NOPEN         ;; \%(                   ;; sic!)
                        NCLOSE]       ;; \) after \%(          ;; sic!)
                        (do
                            ((ร status =) (if (nil? (push-regitem RS_NOPEN, scan)) RA_FAIL status))
                            ;; We simply continue and handle the result when done.
                            (ร BREAK)
                        )

                       [(+ ZOPEN 1)
                        (+ ZOPEN 2)
                        (+ ZOPEN 3)
                        (+ ZOPEN 4)
                        (+ ZOPEN 5)
                        (+ ZOPEN 6)
                        (+ ZOPEN 7)
                        (+ ZOPEN 8)
                        (+ ZOPEN 9)]
                        (do
                            ((ร int no =) (- op ZOPEN))
                            (cleanup-zsubexpr)
                            ((ร regitem_C rip =) (push-regitem RS_ZOPEN, scan))
                            (cond (nil? rip)
                            (do
                                ((ร status =) RA_FAIL)
                            )
                            :else
                            (do
                                ((ร rip =) (assoc rip :rs_no no))
                                ((ร reg_startzp[no] =) (save-se (:rs_sesave rip), (... reg_startzpos no), (... reg_startzp no)))
                                ;; We simply continue and handle the result when done.
                            ))
                            (ร BREAK)
                        )

                       [(+ MCLOSE 0)    ;; Match end: \ze
                        (+ MCLOSE 1)    ;; \)
                        (+ MCLOSE 2)
                        (+ MCLOSE 3)
                        (+ MCLOSE 4)
                        (+ MCLOSE 5)
                        (+ MCLOSE 6)
                        (+ MCLOSE 7)
                        (+ MCLOSE 8)
                        (+ MCLOSE 9)]
                        (do
                            ((ร int no =) (- op MCLOSE))
                            (cleanup-subexpr)
                            ((ร regitem_C rip =) (push-regitem RS_MCLOSE, scan))
                            (cond (nil? rip)
                            (do
                                ((ร status =) RA_FAIL)
                            )
                            :else
                            (do
                                ((ร rip =) (assoc rip :rs_no no))
                                ((ร @reg_endp[no] =) (save-se (:rs_sesave rip), (... @reg_endpos no), (... @reg_endp no)))
                                ;; We simply continue and handle the result when done.
                            ))
                            (ร BREAK)
                        )

                       [(+ ZCLOSE 1)    ;; \) after \z(        ;; sic!)
                        (+ ZCLOSE 2)
                        (+ ZCLOSE 3)
                        (+ ZCLOSE 4)
                        (+ ZCLOSE 5)
                        (+ ZCLOSE 6)
                        (+ ZCLOSE 7)
                        (+ ZCLOSE 8)
                        (+ ZCLOSE 9)]
                        (do
                            ((ร int no =) (- op ZCLOSE))
                            (cleanup-zsubexpr)
                            ((ร regitem_C rip =) (push-regitem RS_ZCLOSE, scan))
                            (cond (nil? rip)
                            (do
                                ((ร status =) RA_FAIL)
                            )
                            :else
                            (do
                                ((ร rip =) (assoc rip :rs_no no))
                                ((ร reg_endzp[no] =) (save-se (:rs_sesave rip), (... reg_endzpos no), (... reg_endzp no)))
                                ;; We simply continue and handle the result when done.
                            ))
                            (ร BREAK)
                        )

                       [(+ BACKREF 1)
                        (+ BACKREF 2)
                        (+ BACKREF 3)
                        (+ BACKREF 4)
                        (+ BACKREF 5)
                        (+ BACKREF 6)
                        (+ BACKREF 7)
                        (+ BACKREF 8)
                        (+ BACKREF 9)]
                        (do
                            ((ร int[] a'len =) (atom (int)))

                            ((ร int no =) (- op BACKREF))
                            (cleanup-subexpr)
                            (cond (some? @reg_match)       ;; Single-line regexp
                            (do
                                (cond (or (nil? (... @reg_startp no)) (nil? (... @reg_endp no)))
                                (do
                                    ;; Backref was not set: Match an empty string.
                                    (reset! a'len 0)
                                )
                                :else
                                (do
                                    ;; Compare current input with back-ref in the same line.
                                    (reset! a'len (BDIFF (... @reg_endp no), (... @reg_startp no)))
                                    ((ร status =) (if (non-zero? (cstrncmp (... @reg_startp no), @reginput, a'len)) RA_NOMATCH status))
                                ))
                            )
                            :else                            ;; Multi-line regexp
                            (do
                                (cond (or (< (:lnum (... @reg_startpos no)) 0) (< (:lnum (... @reg_endpos no)) 0))
                                (do
                                    ;; Backref was not set: Match an empty string.
                                    (reset! a'len 0)
                                )
                                :else
                                (do
                                    (cond (and (== (:lnum (... @reg_startpos no)) @reglnum) (== (:lnum (... @reg_endpos no)) @reglnum))
                                    (do
                                        ;; Compare back-ref within the current line.
                                        (reset! a'len (- (:col (... @reg_endpos no)) (:col (... @reg_startpos no))))
                                        ((ร status =) (if (non-zero? (cstrncmp (.plus @regline (:col (... @reg_startpos no))), @reginput, a'len)) RA_NOMATCH status))
                                    )
                                    :else
                                    (do
                                        ;; Messy situation: Need to compare between two lines.
                                        ((ร int r =) (match-with-backref (:lnum (... @reg_startpos no)), (:col (... @reg_startpos no)), (:lnum (... @reg_endpos no)), (:col (... @reg_endpos no)), a'len))

                                        ((ร status =) (if (!= r RA_MATCH) r status))
                                    ))
                                ))
                            ))

                            ;; Matched the backref, skip over it.
                            (swap! reginput plus @a'len)
                            (ร BREAK)
                        )

                       [(+ ZREF 1)
                        (+ ZREF 2)
                        (+ ZREF 3)
                        (+ ZREF 4)
                        (+ ZREF 5)
                        (+ ZREF 6)
                        (+ ZREF 7)
                        (+ ZREF 8)
                        (+ ZREF 9)]
                        (do
                            (cleanup-zsubexpr)
                            ((ร int no =) (- op ZREF))
                            (cond (and (some? @re_extmatch_in) (some? (... (:matches @re_extmatch_in) no)))
                            (do
                                ((ร int[] a'len =) (atom (int (STRLEN (... (:matches @re_extmatch_in) no)))))
                                (if (non-zero? (cstrncmp (... (:matches @re_extmatch_in) no), @reginput, a'len))
                                    ((ร status =) RA_NOMATCH)
                                    (swap! reginput plus @a'len))
                            )
                            :else
                            (do
                                ;; Backref was not set: Match an empty string.
                            ))
                            (ร BREAK)
                        )

                        BRANCH
                        (do
                            (cond (!= (re-op next) BRANCH) ;; No choice.
                            (do
                                ((ร next =) (operand scan))       ;; Avoid recursion.
                            )
                            :else
                            (do
                                ((ร regitem_C rip =) (push-regitem RS_BRANCH, scan))
                                ((ร status =) (if (nil? rip) RA_FAIL RA_BREAK))      ;; rest is below
                            ))
                            (ร BREAK)
                        )

                        BRACE_LIMITS
                        (do
                            (cond (== (re-op next) BRACE_SIMPLE)
                            (do
                                (reset! bl_minval (operand-min scan))
                                (reset! bl_maxval (operand-max scan))
                            )
                            (and (<= BRACE_COMPLEX (re-op next)) (< (re-op next) (+ BRACE_COMPLEX 10)))
                            (do
                                ((ร int no =) (- (re-op next) BRACE_COMPLEX))
                                (swap! brace_min assoc no (operand-min scan))
                                (swap! brace_max assoc no (operand-max scan))
                                (swap! brace_count assoc no 0)
                            )
                            :else
                            (do
                                (emsg e_internal)       ;; Shouldn't happen.
                                ((ร status =) RA_FAIL)
                            ))
                            (ร BREAK)
                        )

                       [(+ BRACE_COMPLEX 0)
                        (+ BRACE_COMPLEX 1)
                        (+ BRACE_COMPLEX 2)
                        (+ BRACE_COMPLEX 3)
                        (+ BRACE_COMPLEX 4)
                        (+ BRACE_COMPLEX 5)
                        (+ BRACE_COMPLEX 6)
                        (+ BRACE_COMPLEX 7)
                        (+ BRACE_COMPLEX 8)
                        (+ BRACE_COMPLEX 9)]
                        (do
                            ((ร int no =) (- op BRACE_COMPLEX))
                            (swap! brace_count update no inc)

                            ;; If not matched enough times yet, try one more.
                            (when (<= (... @brace_count no) (min (... @brace_min no) (... @brace_max no)))
                                ((ร regitem_C rip =) (push-regitem RS_BRCPLX_MORE, scan))
                                (cond (nil? rip)
                                (do
                                    ((ร status =) RA_FAIL)
                                )
                                :else
                                (do
                                    ((ร rip =) (assoc rip :rs_no no))
                                    (reg-save (:rs_regsave rip), @backpos)
                                    ((ร next =) (operand scan))
                                    ;; We continue and handle the result when done.
                                ))
                                (ร BREAK)
                            )

                            ;; If matched enough times, may try matching some more.
                            (cond (<= (... @brace_min no) (... @brace_max no))
                            (do
                                ;; Range is the normal way around, use longest match.
                                (when (<= (... @brace_count no) (... @brace_max no))
                                    ((ร regitem_C rip =) (push-regitem RS_BRCPLX_LONG, scan))
                                    (cond (nil? rip)
                                    (do
                                        ((ร status =) RA_FAIL)
                                    )
                                    :else
                                    (do
                                        ((ร rip =) (assoc rip :rs_no no))
                                        (reg-save (:rs_regsave rip), @backpos)
                                        ((ร next =) (operand scan))
                                        ;; We continue and handle the result when done.
                                    ))
                                )
                            )
                            :else
                            (do
                                ;; Range is backwards, use shortest match first.
                                (when (<= (... @brace_count no) (... @brace_min no))
                                    ((ร regitem_C rip =) (push-regitem RS_BRCPLX_SHORT, scan))
                                    (cond (nil? rip)
                                    (do
                                        ((ร status =) RA_FAIL)
                                    )
                                    :else
                                    (do
                                        (reg-save (:rs_regsave rip), @backpos)
                                        ;; We continue and handle the result when done.
                                    ))
                                )
                            ))
                            (ร BREAK)
                        )

                       [BRACE_SIMPLE STAR PLUS]
                        (do
                            ((ร regstar_C rst =) (NEW_regstar_C))

                            ;; Lookahead to avoid useless match attempts when we know
                            ;; what character comes next.

                            (cond (== (re-op next) EXACTLY)
                            (do
                                ((ร rst =) (assoc rst :nextb (.at (operand next) 0)))
                                (cond @ireg_ic
                                (do
                                    ((ร rst =) (assoc rst :nextb_ic (if (utf-isupper (:nextb rst)) (utf-tolower (:nextb rst)) (utf-toupper (:nextb rst)))))
                                )
                                :else
                                (do
                                    ((ร rst =) (assoc rst :nextb_ic (:nextb rst)))
                                ))
                            )
                            :else
                            (do
                                ((ร rst =) (assoc rst :nextb NUL))
                                ((ร rst =) (assoc rst :nextb_ic NUL))
                            ))

                            (cond (!= op BRACE_SIMPLE)
                            (do
                                ((ร rst =) (assoc rst :minval (if (== op STAR) 0 1)))
                                ((ร rst =) (assoc rst :maxval MAX_LIMIT))
                            )
                            :else
                            (do
                                ((ร rst =) (assoc rst :minval @bl_minval))
                                ((ร rst =) (assoc rst :maxval @bl_maxval))
                            ))

                            ;; When maxval > minval, try matching as much as possible, up to maxval.
                            ;; When maxval < minval, try matching at least the minimal number
                            ;; (since the range is backwards, that's also maxval!).

                            ((ร rst =) (assoc rst :count (regrepeat (operand scan), (:maxval rst))))
                            (when @got_int
                                ((ร status =) RA_FAIL)
                                (ร BREAK)
                            )

                            (cond (if (<= (:minval rst) (:maxval rst)) (<= (:minval rst) (:count rst)) (<= (:maxval rst) (:count rst)))
                            (do
                                ;; It could match.  Prepare for trying to match
                                ;; what follows.  The code is below.  Parameters
                                ;; are stored in a regstar_C on the regstack.
                                (cond (<= @p_mmp (>>> (:ga_len @regstack) 10))
                                (do
                                    (emsg e_maxmempat)
                                    ((ร status =) RA_FAIL)
                                )
                                :else
                                (do
                                    (.ga_grow @regstack 1)
                                    ((ร @regstack.ga_data[@regstack.ga_len++] =) rst)
                                    ((ร rst =) nil)

                                    ((ร regitem_C rip =) (push-regitem (if (<= (:minval rst) (:maxval rst)) RS_STAR_LONG RS_STAR_SHORT), scan))
                                    ((ร status =) (if (nil? rip) RA_FAIL RA_BREAK))      ;; skip the restore bits
                                ))
                            )
                            :else
                            (do
                                ((ร status =) RA_NOMATCH)
                            ))

                            (ร BREAK)
                        )

                       [NOMATCH MATCH SUBPAT]
                        (do
                            ((ร regitem_C rip =) (push-regitem RS_NOMATCH, scan))
                            (cond (nil? rip)
                            (do
                                ((ร status =) RA_FAIL)
                            )
                            :else
                            (do
                                ((ร rip =) (assoc rip :rs_no op))
                                (reg-save (:rs_regsave rip), @backpos)
                                ((ร next =) (operand scan))
                                ;; We continue and handle the result when done.
                            ))
                            (ร BREAK)
                        )

                       [BEHIND NOBEHIND]
                        (do
                            ;; Need a bit of room to store extra positions.
                            (cond (<= @p_mmp (>>> (:ga_len @regstack) 10))
                            (do
                                (emsg e_maxmempat)
                                ((ร status =) RA_FAIL)
                            )
                            :else
                            (do
                                ((ร regbehind_C rbp =) (NEW_regbehind_C))

                                (.ga_grow @regstack 1)
                                ((ร @regstack.ga_data[@regstack.ga_len++] =) rbp)

                                ((ร regitem_C rip =) (push-regitem RS_BEHIND1, scan))
                                (cond (nil? rip)
                                (do
                                    ((ร status =) RA_FAIL)
                                )
                                :else
                                (do
                                    ;; Need to save the subexpr to be able to restore them
                                    ;; when there is a match but we don't use it.
                                    (save-subexpr rbp)

                                    ((ร rip =) (assoc rip :rs_no op))
                                    (reg-save (:rs_regsave rip), @backpos)
                                    ;; First try if what follows matches.
                                    ;; If it does, then we check the behind match by looping.
                                ))
                            ))
                            (ร BREAK)
                        )

                        BHPOS
                        (do
                            (cond (nil? @reg_match)
                            (do
                                ((ร status =) (if (or (!= (:col (:rs_pos @behind_pos)) (BDIFF @reginput, @regline)) (!= (:lnum (:rs_pos @behind_pos)) @reglnum)) RA_NOMATCH status))
                            )
                            (BNE (:rs_ptr @behind_pos), @reginput)
                            (do
                                ((ร status =) RA_NOMATCH)
                            ))
                            (ร BREAK)
                        )

                        NEWL
                        (do
                            (cond (and (or (!= c NUL) (some? @reg_match) (< @reg_maxline @reglnum) @reg_line_lbr) (or (!= c (byte \newline)) (not @reg_line_lbr)))
                            (do
                                ((ร status =) RA_NOMATCH)
                            )
                            @reg_line_lbr
                            (do
                                (reg-nextchar)
                            )
                            :else
                            (do
                                (reg-nextline)
                                (fast-breakcheck)
                            ))
                            (ร BREAK)
                        )

                        END
                        (do
                            ((ร status =) RA_MATCH)  ;; Success!
                            (ร BREAK)
                        )

                        (do
                            (emsg e_re_corr)
                            ((ร status =) RA_FAIL)
                            (ร BREAK)
                        )
                    )
                ))

                ;; If we can't continue sequentially, break the inner loop.
                (if (!= status RA_CONT)
                    (ร BREAK)
                )

                ;; Continue in inner loop, advance to next item.
                ((ร scan =) next)
                (recur)
            )

            ;; If there is something on the regstack, execute the code for the state.
            ;; If the state is popped then loop and use the older state.

            (loop-when [] (and (< 0 (:ga_len @regstack)) (!= status RA_FAIL))
                ((ร Object vip =) (if (< 1 (:ga_len @regstack)) (... (:ga_data @regstack) (- (:ga_len @regstack) 2)) nil))
                ((ร regitem_C rip =) (ร (regitem_C)(@regstack.ga_data[@regstack.ga_len - 1])))

                (condp ==? (:rs_state rip)
                    RS_NOPEN
                    (do
                        ;; Result is passed on as-is, simply pop the state.
                        ((ร scan =) (pop-regitem))
                        (ร BREAK)
                    )

                    RS_MOPEN
                    (do
                        ;; Pop the state.  Restore pointers when there is no match.
                        (when (== status RA_NOMATCH)
                            ((ร @reg_startp[rip.rs_no] =) (restore-se (:rs_sesave rip), (... @reg_startpos (:rs_no rip)), (... @reg_startp (:rs_no rip))))
                        )
                        ((ร scan =) (pop-regitem))
                        (ร BREAK)
                    )

                    RS_ZOPEN
                    (do
                        ;; Pop the state.  Restore pointers when there is no match.
                        (when (== status RA_NOMATCH)
                            ((ร reg_startzp[rip.rs_no] =) (restore-se (:rs_sesave rip), (... reg_startzpos (:rs_no rip)), (... reg_startzp (:rs_no rip))))
                        )
                        ((ร scan =) (pop-regitem))
                        (ร BREAK)
                    )

                    RS_MCLOSE
                    (do
                        ;; Pop the state.  Restore pointers when there is no match.
                        (when (== status RA_NOMATCH)
                            ((ร @reg_endp[rip.rs_no] =) (restore-se (:rs_sesave rip), (... @reg_endpos (:rs_no rip)), (... @reg_endp (:rs_no rip))))
                        )
                        ((ร scan =) (pop-regitem))
                        (ร BREAK)
                    )

                    RS_ZCLOSE
                    (do
                        ;; Pop the state.  Restore pointers when there is no match.
                        (when (== status RA_NOMATCH)
                            ((ร reg_endzp[rip.rs_no] =) (restore-se (:rs_sesave rip), (... reg_endzpos (:rs_no rip)), (... reg_endzp (:rs_no rip))))
                        )
                        ((ร scan =) (pop-regitem))
                        (ร BREAK)
                    )

                    RS_BRANCH
                    (do
                        (cond (== status RA_MATCH)
                        (do
                            ;; this branch matched, use it
                            ((ร scan =) (pop-regitem))
                        )
                        :else
                        (do
                            (when (!= status RA_BREAK)
                                ;; After a non-matching branch: try next one.
                                (reg-restore (:rs_regsave rip), @backpos)
                                ((ร scan =) (:rs_scan rip))
                            )
                            (cond (or (nil? scan) (!= (re-op scan) BRANCH))
                            (do
                                ;; no more branches, didn't find a match
                                ((ร status =) RA_NOMATCH)
                                ((ร scan =) (pop-regitem))
                            )
                            :else
                            (do
                                ;; Prepare to try a branch.
                                ((ร rip =) (assoc rip :rs_scan (regnext scan)))
                                (reg-save (:rs_regsave rip), @backpos)
                                ((ร scan =) (operand scan))
                            ))
                        ))
                        (ร BREAK)
                    )

                    RS_BRCPLX_MORE
                    (do
                        ;; Pop the state.  Restore pointers when there is no match.
                        (when (== status RA_NOMATCH)
                            (reg-restore (:rs_regsave rip), @backpos)
                            (swap! brace_count update (:rs_no rip) dec)       ;; decrement match count
                        )
                        ((ร scan =) (pop-regitem))
                        (ร BREAK)
                    )

                    RS_BRCPLX_LONG
                    (do
                        ;; Pop the state.  Restore pointers when there is no match.
                        (when (== status RA_NOMATCH)
                            ;; There was no match, but we did find enough matches.
                            (reg-restore (:rs_regsave rip), @backpos)
                            (swap! brace_count update (:rs_no rip) dec)
                            ;; continue with the items after "\{}"
                            ((ร status =) RA_CONT)
                        )
                        ((ร scan =) (pop-regitem))
                        ((ร scan =) (if (== status RA_CONT) (regnext scan) scan))
                        (ร BREAK)
                    )

                    RS_BRCPLX_SHORT
                    (do
                        ;; Pop the state.  Restore pointers when there is no match.
                        (when (== status RA_NOMATCH)
                            ;; There was no match, try to match one more item.
                            (reg-restore (:rs_regsave rip), @backpos)
                        )
                        ((ร scan =) (pop-regitem))
                        (when (== status RA_NOMATCH)
                            ((ร scan =) (operand scan))
                            ((ร status =) RA_CONT)
                        )
                        (ร BREAK)
                    )

                    RS_NOMATCH
                    (do
                        ;; Pop the state.  If the operand matches for NOMATCH or
                        ;; doesn't match for MATCH/SUBPAT, we fail.  Otherwise backup,
                        ;; except for SUBPAT, and continue with the next item.
                        (cond (== status (if (== (:rs_no rip) NOMATCH) RA_MATCH RA_NOMATCH))
                        (do
                            ((ร status =) RA_NOMATCH)
                        )
                        :else
                        (do
                            ((ร status =) RA_CONT)
                            (if (!= (:rs_no rip) SUBPAT)        ;; zero-width
                                (reg-restore (:rs_regsave rip), @backpos))
                        ))
                        ((ร scan =) (pop-regitem))
                        ((ร scan =) (if (== status RA_CONT) (regnext scan) scan))
                        (ร BREAK)
                    )

                    RS_BEHIND1
                    (do
                        (cond (== status RA_NOMATCH)
                        (do
                            ((ร scan =) (pop-regitem))
                            (drop-regbehind)
                        )
                        :else
                        (do
                            ;; The stuff after BEHIND/NOBEHIND matches.
                            ;; Now try if the behind part does (not) match before the current
                            ;; position in the input.  This must be done at every position in the
                            ;; input and checking if the match ends at the current position.

                            ;; save the position after the found match for next
                            (reg-save (:save_after (ร (regbehind_C)vip)), @backpos)

                            ;; Start looking for a match with operand at the current position.
                            ;; Go back one character until we find the result, hitting the start
                            ;; of the line or the previous line (for multi-line matching).
                            ;; Set behind_pos to where the match should end, BHPOS will match it.
                            ;; Save the current value.
                            (COPY-regsave (:save_behind (ร (regbehind_C)vip)), @behind_pos)
                            (COPY-regsave @behind_pos, (:rs_regsave rip))

                            ((ร rip =) (assoc rip :rs_state RS_BEHIND2))

                            (reg-restore (:rs_regsave rip), @backpos)
                            ((ร scan =) (.plus (operand (:rs_scan rip)) 4))
                        ))
                        (ร BREAK)
                    )

                    RS_BEHIND2
                    (do
                        ;; Looping for BEHIND / NOBEHIND match.

                        (cond (and (== status RA_MATCH) (reg-save-equal @behind_pos))
                        (do
                            ;; found a match that ends where "next" started
                            (COPY-regsave @behind_pos, (:save_behind (ร (regbehind_C)vip)))
                            (cond (== (:rs_no rip) BEHIND)
                            (do
                                (reg-restore (:save_after (ร (regbehind_C)vip)), @backpos)
                            )
                            :else
                            (do
                                ;; But we didn't want a match.  Need to restore the subexpr,
                                ;; because what follows matched, so they have been set.
                                ((ร status =) RA_NOMATCH)
                                (restore-subexpr (ร (regbehind_C)vip))
                            ))
                            ((ร scan =) (pop-regitem))
                            (drop-regbehind)
                        )
                        :else
                        (do
                            ;; No match or a match that doesn't end where we want it:
                            ;; go back one character.  May go to previous line once.
                            ((ร boolean no =) true)
                            ((ร long limit =) (operand-min (:rs_scan rip)))
                            (cond (nil? @reg_match)
                            (do
                                (cond (and (< 0 limit) (<= limit (- (if (< (:lnum (:rs_pos (:rs_regsave rip))) (:lnum (:rs_pos @behind_pos))) (STRLEN @regline) (:col (:rs_pos @behind_pos))) (:col (:rs_pos (:rs_regsave rip))))))
                                (do
                                    ((ร no =) false)
                                )
                                (zero? (:col (:rs_pos (:rs_regsave rip))))
                                (do
                                    (cond (or (< (:lnum (:rs_pos (:rs_regsave rip))) (:lnum (:rs_pos @behind_pos))) (nil? (reg-getline (ร --rip.rs_regsave.rs_pos.lnum))))
                                    (do
                                        ((ร no =) false)
                                    )
                                    :else
                                    (do
                                        (reg-restore (:rs_regsave rip), @backpos)
                                        ((ร rip.rs_regsave.rs_pos.col =) (STRLEN @regline))
                                    ))
                                )
                                :else
                                (do
                                    ((ร rip.rs_regsave.rs_pos.col =) (- (:col (:rs_pos (:rs_regsave rip))) (inc (us-head-off @regline, (.plus @regline (dec (:col (:rs_pos (:rs_regsave rip)))))))))
                                ))
                            )
                            :else
                            (do
                                (cond (BEQ (:rs_ptr (:rs_regsave rip)), @regline)
                                (do
                                    ((ร no =) false)
                                )
                                :else
                                (do
                                    ((ร rip =) (update-in rip [:rs_regsave :rs_ptr] #(.minus % (us-ptr-back @regline, %))))
                                    ((ร no =) (if (and (< 0 limit) (< limit (BDIFF (:rs_ptr @behind_pos), (:rs_ptr (:rs_regsave rip))))) false no))
                                ))
                            ))
                            (cond no
                            (do
                                ;; Advanced, prepare for finding match again.
                                (reg-restore (:rs_regsave rip), @backpos)
                                ((ร scan =) (.plus (operand (:rs_scan rip)) 4))
                                (when (== status RA_MATCH)
                                    ;; We did match, so subexpr may have been changed,
                                    ;; need to restore them for the next try.
                                    ((ร status =) RA_NOMATCH)
                                    (restore-subexpr (ร (regbehind_C)vip))
                                )
                            )
                            :else
                            (do
                                ;; Can't advance.  For NOBEHIND that's a match.
                                (COPY-regsave @behind_pos, (:save_behind (ร (regbehind_C)vip)))
                                (cond (== (:rs_no rip) NOBEHIND)
                                (do
                                    (reg-restore (:save_after (ร (regbehind_C)vip)), @backpos)
                                    ((ร status =) RA_MATCH)
                                )
                                :else
                                (do
                                    ;; We do want a proper match.  Need to restore the subexpr
                                    ;; if we had a match, because they may have been set.
                                    (when (== status RA_MATCH)
                                        ((ร status =) RA_NOMATCH)
                                        (restore-subexpr (ร (regbehind_C)vip))
                                    )
                                ))
                                ((ร scan =) (pop-regitem))
                                (drop-regbehind)
                            ))
                        ))
                        (ร BREAK)
                    )

                   [RS_STAR_LONG RS_STAR_SHORT]
                    (do
                        ((ร regstar_C rst =) (ร (regstar_C)vip))

                        (when (== status RA_MATCH)
                            ((ร scan =) (pop-regitem))
                            (drop-regstar)
                            (ร BREAK)
                        )

                        ;; Tried once already, restore input pointers.
                        (when (!= status RA_BREAK)
                            (reg-restore (:rs_regsave rip), @backpos))

                        ;; Repeat until we found a position where it could match.
                        (loop []
                            (cond (!= status RA_BREAK)
                            (do
                                ;; Tried first position already, advance.
                                (cond (== (:rs_state rip) RS_STAR_LONG)
                                (do
                                    ;; Trying for longest match, but couldn't
                                    ;; or didn't match -- back up one char.
                                    (if (< (ร --rst.count) (:minval rst))
                                        (ร BREAK)
                                    )
                                    (cond (BEQ @reginput, @regline)
                                    (do
                                        ;; backup to last char of previous line
                                        (swap! reglnum dec)
                                        (reset! regline (reg-getline @reglnum))
                                        ;; Just in case regrepeat() didn't count right.
                                        (if (nil? @regline)
                                            (ร BREAK)
                                        )
                                        (reset! reginput (.plus @regline (STRLEN @regline)))
                                        (fast-breakcheck)
                                    )
                                    :else
                                    (do
                                        (swap! reginput #(.minus % (us-ptr-back @regline, %)))
                                    ))
                                )
                                :else
                                (do
                                    ;; Range is backwards, use shortest match first.
                                    ;; Careful: maxval and minval are exchanged!
                                    ;; Couldn't or didn't match: try advancing one char.
                                    (if (or (== (:count rst) (:minval rst)) (zero? (regrepeat (operand (:rs_scan rip)), 1)))
                                        (ร BREAK)
                                    )
                                    ((ร rst =) (update rst :count inc))
                                ))
                                (if @got_int
                                    (ร BREAK)
                                )
                            )
                            :else
                            (do
                                ((ร status =) RA_NOMATCH)
                            ))

                            ;; If it could match, try it.
                            (when (or (== (:nextb rst) NUL) (at? @reginput (:nextb rst)) (at? @reginput (:nextb_ic rst)))
                                (reg-save (:rs_regsave rip), @backpos)
                                ((ร scan =) (regnext (:rs_scan rip)))
                                ((ร status =) RA_CONT)
                                (ร BREAK)
                            )
                            (recur)
                        )
                        (when (!= status RA_CONT)
                            ;; Failed.
                            ((ร scan =) (pop-regitem))
                            (drop-regstar)
                            ((ร status =) RA_NOMATCH)
                        )
                        (ร BREAK)
                    )
                )

                ;; If we want to continue the inner loop or didn't pop a state continue matching loop.
                (if (or (== status RA_CONT) (== rip (ร (regitem_C)(@regstack.ga_data[@regstack.ga_len - 1]))))
                    (ร BREAK)
                )
                (recur)
            )

            ;; May need to continue with the inner loop, starting at "scan".
            (if (== status RA_CONT)
                (ร CONTINUE)
            )

            ;; If the regstack is empty or something failed we are done.

            (when (or (zero? (:ga_len @regstack)) (== status RA_FAIL))
                (when (nil? scan)
                    ;; We get here only if there's trouble -- normally
                    ;; "case END" is the terminating point.

                    (emsg e_re_corr)
                )
                (if (== status RA_FAIL)
                    (reset! got_int true))
                ((ร RETURN) (== status RA_MATCH))
            )
            (recur)
        )

        ;; NOTREACHED
    ))

;; Push an item onto the regstack.
;; Returns pointer to new item.  Returns null when out of memory.

(defn- #_regitem_C push-regitem [#_int state, #_Bytes scan]
    (ยง
        (when (<= @p_mmp (>>> (:ga_len @regstack) 10))
            (emsg e_maxmempat)
            ((ร RETURN) nil)
        )

        ((ร regitem_C rip =) (NEW_regitem_C))

        (.ga_grow @regstack 1)
        ((ร @regstack.ga_data[@regstack.ga_len++] =) rip)

        ((ร rip =) (assoc rip :rs_state state))
        ((ร rip =) (assoc rip :rs_scan scan))

        rip
    ))

;; Pop an item from the regstack.

(defn- #_Bytes pop-regitem []
    (ยง
        ((ร regitem_C rip =) (ร (regitem_C)(@regstack.ga_data[--@regstack.ga_len])))
        ((ร @regstack.ga_data[@regstack.ga_len] =) nil)

        (:rs_scan rip)
    ))

(defn- #_void drop-regbehind []
    (ยง
        ((ร @regstack.ga_data[--@regstack.ga_len] =) nil)
        nil
    ))

(defn- #_void drop-regstar []
    (ยง
        ((ร @regstack.ga_data[--@regstack.ga_len] =) nil)
        nil
    ))

;; Repeatedly match something simple, return how many.
;; Advances reginput (and reglnum) to just after the matched chars.

(defn- #_int regrepeat [#_Bytes p, #_long m] ;; m(axcount): maximum number of matches allowed
    (let [#_Bytes s @reginput #_long n 0
          ret- (fn [s n] (reset! reginput s) n)
          eor- (fn [p] (or (some? @reg_match) (not (with-nl (re-op p))) (< @reg_maxline @reglnum) @reg_line_lbr))
          eol- (fn [s p] (and @reg_line_lbr (at? s (byte \newline)) (with-nl (re-op p))))
          fun- (fn [s n m p f t]
                    (let [[s n] (loop-when [s s n n] (< n m) => [s n]
                                    (cond (eos? s)
                                        (if (eor- p) [s n] (let [s (reg-nextline)] (if (fast-breakcheck) [s n] (recur s (inc n)))))
                                    (and (f s) (or t (not (asc-isdigit (.at s 0)))))
                                        (recur (.plus s (us-ptr2len-cc s)) (inc n))
                                    (eol- s p)
                                        (recur (.plus s 1) (inc n))
                                    :else
                                        [s n]
                                    ))]
                        (ret- s n)
                    ))
          cls- (fn [s n m p e v]
                    (let [[s n] (loop-when [s s n n] (< n m) => [s n]
                                    (if (eos? s)
                                        (if (eor- p) [s n] (let [s (reg-nextline)] (if (fast-breakcheck) [s n] (recur s (inc n)))))
                                        (let [#_int l (us-ptr2len-cc s)]
                                            (cond
                                                (< 1 l)                           (if (zero? v) (recur (.plus s l) (inc n)) [s n])
                                                (== (& (... class_tab (char_u (.at s 0))) e) v) (recur (.plus s 1) (inc n))
                                                (eol- s p)                                      (recur (.plus s 1) (inc n))
                                                :else                                           [s n]
                                            ))
                                    ))]
                        (ret- s n)
                    ))
          any- (fn [s n m p t]
                    (let [#_Bytes op (operand p)
                          [s n] (loop-when [s s n n] (< n m) => [s n]
                                    (cond (eos? s)
                                        (if (eor- p) [s n] (let [s (reg-nextline)] (if (fast-breakcheck) [s n] (recur s (inc n)))))
                                    (eol- s p)
                                        (recur (.plus s 1) (inc n))
                                    :else
                                        (let [#_int l (us-ptr2len-cc s)]
                                            (if (< 1 l)
                                                (if (== (nil? (cstrchr op, (us-ptr2char s))) t) [s n] (recur (.plus s l) (inc n)))
                                                (if (== (nil? (cstrchr op, (.at s 0)))       t) [s n] (recur (.plus s 1) (inc n)))
                                            ))
                                    ))]
                        (ret- s n)
                    ))
          ident? #(vim-isidentc (us-ptr2char %))
          kword? us-iswordp
          fname? #(vim-isfnamec (us-ptr2char %))
          print? #(vim-isprintc (us-ptr2char %))]

        (condp ==? (re-op p)
            [ANY (+ ANY ADD_NL)]
                (let [[s n] (loop-when [s s n n] (< n m) => [s n]
                        ;; Matching anything means we continue until end-of-line (or end-of-file for ANY + ADD_NL), only limited by m(axcount).
                        (let [[s n] (loop-when-recur [s s n n] (and (non-eos? s) (< n m)) [(.plus s (us-ptr2len-cc s)) (inc n)] => [s n])]
                            (if (or (eor- p) (== n m)) [s n] (let [s (reg-nextline) n (inc n)] (if (fast-breakcheck) [s n] (recur s n)))) ;; count the line-break
                        ))]
                    (ret- s n))

            [IDENT (+ IDENT ADD_NL)] (fun- s n m p ident? true)         [SIDENT (+ SIDENT ADD_NL)] (fun- s n m p ident? false)
            [KWORD (+ KWORD ADD_NL)] (fun- s n m p kword? true)         [SKWORD (+ SKWORD ADD_NL)] (fun- s n m p kword? false)
            [FNAME (+ FNAME ADD_NL)] (fun- s n m p fname? true)         [SFNAME (+ SFNAME ADD_NL)] (fun- s n m p fname? false)
            [PRINT (+ PRINT ADD_NL)] (fun- s n m p print? true)         [SPRINT (+ SPRINT ADD_NL)] (fun- s n m p print? false)

            [WHITE (+ WHITE ADD_NL)] (cls- s n m p RI_WHITE RI_WHITE)   [NWHITE (+ NWHITE ADD_NL)] (cls- s n m p RI_WHITE 0)
            [DIGIT (+ DIGIT ADD_NL)] (cls- s n m p RI_DIGIT RI_DIGIT)   [NDIGIT (+ NDIGIT ADD_NL)] (cls- s n m p RI_DIGIT 0)
            [HEX   (+ HEX   ADD_NL)] (cls- s n m p RI_HEX   RI_HEX)     [NHEX   (+ NHEX   ADD_NL)] (cls- s n m p RI_HEX   0)
            [OCTAL (+ OCTAL ADD_NL)] (cls- s n m p RI_OCTAL RI_OCTAL)   [NOCTAL (+ NOCTAL ADD_NL)] (cls- s n m p RI_OCTAL 0)
            [WORD  (+ WORD  ADD_NL)] (cls- s n m p RI_WORD  RI_WORD)    [NWORD  (+ NWORD  ADD_NL)] (cls- s n m p RI_WORD  0)
            [HEAD  (+ HEAD  ADD_NL)] (cls- s n m p RI_HEAD  RI_HEAD)    [NHEAD  (+ NHEAD  ADD_NL)] (cls- s n m p RI_HEAD  0)
            [ALPHA (+ ALPHA ADD_NL)] (cls- s n m p RI_ALPHA RI_ALPHA)   [NALPHA (+ NALPHA ADD_NL)] (cls- s n m p RI_ALPHA 0)
            [LOWER (+ LOWER ADD_NL)] (cls- s n m p RI_LOWER RI_LOWER)   [NLOWER (+ NLOWER ADD_NL)] (cls- s n m p RI_LOWER 0)
            [UPPER (+ UPPER ADD_NL)] (cls- s n m p RI_UPPER RI_UPPER)   [NUPPER (+ NUPPER ADD_NL)] (cls- s n m p RI_UPPER 0)

            EXACTLY
                (let [#_Bytes op (operand p)
                      ;; This doesn't do a multi-byte character, because a MULTIBYTECODE would have
                      ;; been used for it.  It does handle single-byte characters, such as latin1.
                      [s n] (if @ireg_ic
                                (let [#_int cu (utf-toupper (.at op 0)) #_int cl (utf-tolower (.at op 0))]
                                    (loop-when-recur [s s n n] (and (< n m) (or (at? s cu) (at? s cl))) [(.plus s 1) (inc n)] => [s n]))
                                (let [#_int cu (.at op 0)]
                                    (loop-when-recur [s s n n] (and (< n m) (at? s cu)) [(.plus s 1) (inc n)] => [s n]))
                            )]
                    (ret- s n))

            MULTIBYTECODE
                (let [#_Bytes op (operand p) #_int l (us-ptr2len-cc op)
                      ;; Safety check (just in case 'encoding' was changed since compiling the program).
                      [s n] (if (< 1 l)
                                (let [#_int cf (if @ireg_ic (utf-fold (us-ptr2char op)) 0)]
                                    (loop-when [s s n n] (< n m) => [s n]
                                        (let [#_int i (loop-when-recur [i 0] (and (< i l) (at? op i (.at s i))) [(inc i)] => i)]
                                            (if (and (< i l) (or (not @ireg_ic) (!= (utf-fold (us-ptr2char s)) cf)))
                                                [s n]
                                                (recur (.plus s l) (inc n))
                                            ))
                                    ))
                                [s n]
                            )]
                    (ret- s n))

            [ANYOF (+ ANYOF ADD_NL)] (any- s n m p true)                [ANYBUT (+ ANYBUT ADD_NL)] (any- s n m p false)

            NEWL
                (let [[s n] (loop-when [s s n n] (and (< n m) (or (and (eos? s) (<= @reglnum @reg_maxline) (not @reg_line_lbr) (nil? @reg_match))
                                                                  (and (at? s (byte \newline)) @reg_line_lbr))) => [s n]
                                (let [s (if @reg_line_lbr (reg-nextchar) (reg-nextline)) n (inc n)]
                                    (if (and (not @reg_line_lbr) (fast-breakcheck)) [s n] (recur s n)))
                            )]
                    (ret- s n))

            (do (emsg e_re_corr) (ret- s n)) ;; Oh dear, called inappropriately.
        )
    ))

;; Dig the "next" pointer out of a node.
;; Returns null when calculating size, when there is no next item and when there is an error.

(defn- #_Bytes regnext [#_Bytes p]
    (if (or (== p JUST_CALC_SIZE) @reg_toolong)
        nil
        (let [#_int offset (re-next p)]
            (if (zero? offset) nil (if (== (re-op p) BACK) (.minus p offset) (.plus p offset))))
    ))

;; Check the regexp program for its magic number.
;; Return true if it's wrong.

(defn- #_boolean prog-magic-wrong []
    (let [#_regprog_C prog (if (nil? @reg_match) (:regprog @reg_mmatch) (:regprog @reg_match))]
        (cond
; %%        (== (:engine prog) nfa_regengine) ;; For NFA matcher we don't check the magic.
; %%            false
; %%        (not-at? (:program (ร (bt_regprog_C)prog)) REGMAGIC)
; %%            (do (emsg e_re_corr) true)
            :else
                false
        )))

;; Cleanup the subexpressions, if this wasn't done yet.
;; This construction is used to clear the subexpressions
;; only when they are used (to increase speed).

(defn- #_void cleanup-subexpr []
    (ยง
        (when @need_clear_subexpr
            (if (nil? @reg_match)
                (dotimes [#_int i NSUBEXP] (MIN1-lpos (... @reg_startpos i)) (MIN1-lpos (... @reg_endpos i)))
                (dotimes [#_int i NSUBEXP] ((ร @reg_startp[i] =) nil) ((ร @reg_endp[i] =) nil))
            )
            (reset! need_clear_subexpr false)
        )
        nil
    ))

(defn- #_void cleanup-zsubexpr []
    (ยง
        (when @need_clear_zsubexpr
            (if (nil? @reg_match)
                (dotimes [#_int i NSUBEXP] (MIN1-lpos (... reg_startzpos i)) (MIN1-lpos (... reg_endzpos i)))
                (dotimes [#_int i NSUBEXP] ((ร reg_startzp[i] =) nil) ((ร reg_endzp[i] =) nil))
            )
            (reset! need_clear_zsubexpr false)
        )
        nil
    ))

;; Save the current subexpr to "bp", so that they can be restored later by restore-subexpr().

(defn- #_void save-subexpr [#_regbehind_C bp]
    (ยง
        ;; When "need_clear_subexpr" is set we don't need to save the values,
        ;; only remember that this flag needs to be set again when restoring.
        ((ร bp =) (assoc bp :save_need_clear_subexpr @need_clear_subexpr))
        (when (not @need_clear_subexpr)
            (dotimes [#_int i NSUBEXP]
                (cond (nil? @reg_match)
                (do
                    (COPY-lpos (:se_pos (... (:save_start bp) i)), (... @reg_startpos i))
                    (COPY-lpos (:se_pos (... (:save_end bp) i)), (... @reg_endpos i))
                )
                :else
                (do
                    ((ร bp.save_start[i].se_ptr =) (... @reg_startp i))
                    ((ร bp.save_end[i].se_ptr =) (... @reg_endp i))
                ))
            )
        )
        nil
    ))

;; Restore the subexpr from "bp".

(defn- #_void restore-subexpr [#_regbehind_C bp]
    (ยง
        ;; Only need to restore saved values when they are not to be cleared.
        (reset! need_clear_subexpr (:save_need_clear_subexpr bp))
        (when (not @need_clear_subexpr)
            (dotimes [#_int i NSUBEXP]
                (cond (nil? @reg_match)
                (do
                    (COPY-lpos (... @reg_startpos i), (:se_pos (... (:save_start bp) i)))
                    (COPY-lpos (... @reg_endpos i), (:se_pos (... (:save_end bp) i)))
                )
                :else
                (do
                    ((ร @reg_startp[i] =) (:se_ptr (... (:save_start bp) i)))
                    ((ร @reg_endp[i] =) (:se_ptr (... (:save_end bp) i)))
                ))
            )
        )
        nil
    ))

;; Advance "reginput" to the next char.

(defn- #_Bytes reg-nextchar []
    (swap! reginput #(.plus % (us-ptr2len-cc %))))

;; Advance "reglnum", "regline" and "reginput" to the next line.

(defn- #_Bytes reg-nextline []
    (reset! reginput (reset! regline (reg-getline (swap! reglnum inc)))))

;; Save the input line and position in a regsave_C.

(defn- #_void reg-save [#_regsave_C save, #_backpos_C* gap]
    (ยง
        (cond (nil? @reg_match)
        (do
            ((ร save =) (assoc-in save [:rs_pos :col] (BDIFF @reginput, @regline)))
            ((ร save =) (assoc-in save [:rs_pos :lnum] @reglnum))
        )
        :else
        (do
            ((ร save =) (assoc save :rs_ptr @reginput))
        ))
        ((ร save =) (assoc save :rs_len (:ga_len gap)))
        nil
    ))

;; Restore the input line and position from a regsave_C.

(defn- #_void reg-restore [#_regsave_C save, #_backpos_C* gap]
    (ยง
        (cond (nil? @reg_match)
        (do
            (when (!= @reglnum (:lnum (:rs_pos save)))
                ;; only call reg-getline() when the line number changed to save a bit of time
                (reset! reglnum (:lnum (:rs_pos save)))
                (reset! regline (reg-getline @reglnum))
            )
            (reset! reginput (.plus @regline (:col (:rs_pos save))))
        )
        :else
        (do
            (reset! reginput (:rs_ptr save))
        ))
        ((ร gap =) (assoc gap :ga_len (:rs_len save)))
        nil
    ))

;; Return true if current position is equal to saved position.

(defn- #_boolean reg-save-equal [#_regsave_C save]
    (if (nil? @reg_match)
        (let [pos (:rs_pos save)] (and (== @reglnum (:lnum pos)) (BEQ @reginput, (.plus @regline (:col pos)))))
        (BEQ @reginput, (:rs_ptr save))
    ))

;; Tentatively set the sub-expression start to the current position (after calling regmatch()
;; they will have changed).  Need to save the existing values for when there is no match.
;; Use se_save() to use pointer (save-se-multi()) or position (save-se-one()),
;; depending on REG_MULTI.

(defn- #_void save-se-multi [#_save_se_C savep, #_lpos_C posp]
    (ยง
        (COPY-lpos (:se_pos savep), posp)
        ((ร posp =) (assoc posp :lnum @reglnum))
        ((ร posp =) (assoc posp :col (BDIFF @reginput, @regline)))
        nil
    ))

(defn- #_Bytes save-se-one [#_save_se_C savep, #_Bytes pp]
    (ยง
        ((ร savep =) (assoc savep :se_ptr pp))
        ((ร pp =) @reginput)
        pp
    ))

;; Save the sub-expressions before attempting a match.
(defn- #_Bytes save-se [#_save_se_C savep, #_lpos_C posp, #_Bytes pp]
    (if (nil? @reg_match)
        (do (save-se-multi savep, posp) pp)
        (save-se-one savep, pp)
    ))

;; After a failed match restore the sub-expressions.
(defn- #_Bytes restore-se [#_save_se_C savep, #_lpos_C posp, #_Bytes pp]
    (if (nil? @reg_match)
        (do (COPY-lpos posp, (:se_pos savep)) pp)
        (:se_ptr savep)
    ))

;; Compare a number with the operand of RE_LNUM, RE_COL or RE_VCOL.

(defn- #_boolean re-num-cmp [#_long val, #_Bytes scan]
    (let [#_long n (operand-min scan)]
        (condp == (operand-cmp scan) (byte \>) (> val n) (byte \<) (< val n) (== val n))
    ))

;; Check whether a backreference matches.
;; Returns RA_FAIL, RA_NOMATCH or RA_MATCH.
;; If "len" is not null, it is set to the byte length of the match in the last line.

(defn- #_int match-with-backref [#_long start_lnum, #_int start_col, #_long end_lnum, #_int end_col, #_int' a'len]
    (when (some? a'len)
        (reset! a'len 0))
    (loop [#_long lnum start_lnum #_int col start_col]
        ;; Since getting one line may invalidate the other, need to make copy.
        ;; Slow!
        (when (BNE @regline, @reg_tofree)
            (let [#_int len (STRLEN @regline)]
                (when (or (nil? @reg_tofree) (<= @reg_tofree_len len))
                    (let [len (+ len 50)] ;; get some extra
                        (reset! reg_tofree (Bytes. len))
                        (reset! reg_tofree_len len)
                    ))
                (STRCPY @reg_tofree, @regline)
                (reset! reginput (.plus @reg_tofree (BDIFF @reginput, @regline)))
                (reset! regline @reg_tofree)
            ))
        ;; Get the line to compare with.
        (let-when [#_Bytes p (reg-getline lnum)
                   a'n (atom (int (if (== lnum end_lnum) (- end_col col) (STRLEN p, col))))
        ] (zero? (cstrncmp (.plus p col), @reginput, a'n)) => RA_NOMATCH ;; doesn't match
            (when (some? a'len)
                (swap! a'len + @a'n))
            (cond (== lnum end_lnum) ;; match and at end
                ;; Found a match!
                ;; Note that regline may now point to a copy of the line, that should not matter.
                RA_MATCH
            (<= @reg_maxline @reglnum) ;; text too short
                RA_NOMATCH
            :else ;; Advance to next line.
                (do (reg-nextline)
                    (when (some? a'len)
                        (reset! a'len 0))
                    (if (fast-breakcheck)
                        RA_FAIL
                        (recur (inc lnum) 0)
                    ))
            ))
    ))

;; Used in a place where no * or \+ can follow.

(defn- #_boolean re-mult-next [#_Bytes what]
    (if (== (re-multi-type (peekchr)) MULTI_MULT)
        (do (emsg2 (u8 "E888: (NFA regexp) cannot repeat %s"), what)
            (reset! rc_did_emsg true)
            false)
        true
    ))

(class! #_final decomp_C
    [
        (field int a) (field int b) (field int c)
    ])

;; 0xfb20 - 0xfb4f
(final decomp_C* decomp_table
    [
        (->decomp_C  0x5e2,     0,     0)   ;; 0xfb20   alt ayin
        (->decomp_C  0x5d0,     0,     0)   ;; 0xfb21   alt alef
        (->decomp_C  0x5d3,     0,     0)   ;; 0xfb22   alt dalet
        (->decomp_C  0x5d4,     0,     0)   ;; 0xfb23   alt he
        (->decomp_C  0x5db,     0,     0)   ;; 0xfb24   alt kaf
        (->decomp_C  0x5dc,     0,     0)   ;; 0xfb25   alt lamed
        (->decomp_C  0x5dd,     0,     0)   ;; 0xfb26   alt mem-sofit
        (->decomp_C  0x5e8,     0,     0)   ;; 0xfb27   alt resh
        (->decomp_C  0x5ea,     0,     0)   ;; 0xfb28   alt tav
        (->decomp_C (int \+),   0,     0)   ;; 0xfb29   alt plus
        (->decomp_C  0x5e9, 0x5c1,     0)   ;; 0xfb2a   shin+shin-dot
        (->decomp_C  0x5e9, 0x5c2,     0)   ;; 0xfb2b   shin+sin-dot
        (->decomp_C  0x5e9, 0x5c1, 0x5bc)   ;; 0xfb2c   shin+shin-dot+dagesh
        (->decomp_C  0x5e9, 0x5c2, 0x5bc)   ;; 0xfb2d   shin+sin-dot+dagesh
        (->decomp_C  0x5d0, 0x5b7,     0)   ;; 0xfb2e   alef+patah
        (->decomp_C  0x5d0, 0x5b8,     0)   ;; 0xfb2f   alef+qamats
        (->decomp_C  0x5d0, 0x5b4,     0)   ;; 0xfb30   alef+hiriq
        (->decomp_C  0x5d1, 0x5bc,     0)   ;; 0xfb31   bet+dagesh
        (->decomp_C  0x5d2, 0x5bc,     0)   ;; 0xfb32   gimel+dagesh
        (->decomp_C  0x5d3, 0x5bc,     0)   ;; 0xfb33   dalet+dagesh
        (->decomp_C  0x5d4, 0x5bc,     0)   ;; 0xfb34   he+dagesh
        (->decomp_C  0x5d5, 0x5bc,     0)   ;; 0xfb35   vav+dagesh
        (->decomp_C  0x5d6, 0x5bc,     0)   ;; 0xfb36   zayin+dagesh
        (->decomp_C 0xfb37,     0,     0)   ;; 0xfb37 - UNUSED
        (->decomp_C  0x5d8, 0x5bc,     0)   ;; 0xfb38   tet+dagesh
        (->decomp_C  0x5d9, 0x5bc,     0)   ;; 0xfb39   yud+dagesh
        (->decomp_C  0x5da, 0x5bc,     0)   ;; 0xfb3a   kaf sofit+dagesh
        (->decomp_C  0x5db, 0x5bc,     0)   ;; 0xfb3b   kaf+dagesh
        (->decomp_C  0x5dc, 0x5bc,     0)   ;; 0xfb3c   lamed+dagesh
        (->decomp_C 0xfb3d,     0,     0)   ;; 0xfb3d - UNUSED
        (->decomp_C  0x5de, 0x5bc,     0)   ;; 0xfb3e   mem+dagesh
        (->decomp_C 0xfb3f,     0,     0)   ;; 0xfb3f - UNUSED
        (->decomp_C  0x5e0, 0x5bc,     0)   ;; 0xfb40   nun+dagesh
        (->decomp_C  0x5e1, 0x5bc,     0)   ;; 0xfb41   samech+dagesh
        (->decomp_C 0xfb42,     0,     0)   ;; 0xfb42 - UNUSED
        (->decomp_C  0x5e3, 0x5bc,     0)   ;; 0xfb43   pe sofit+dagesh
        (->decomp_C  0x5e4, 0x5bc,     0)   ;; 0xfb44   pe+dagesh
        (->decomp_C 0xfb45,     0,     0)   ;; 0xfb45 - UNUSED
        (->decomp_C  0x5e6, 0x5bc,     0)   ;; 0xfb46   tsadi+dagesh
        (->decomp_C  0x5e7, 0x5bc,     0)   ;; 0xfb47   qof+dagesh
        (->decomp_C  0x5e8, 0x5bc,     0)   ;; 0xfb48   resh+dagesh
        (->decomp_C  0x5e9, 0x5bc,     0)   ;; 0xfb49   shin+dagesh
        (->decomp_C  0x5ea, 0x5bc,     0)   ;; 0xfb4a   tav+dagesh
        (->decomp_C  0x5d5, 0x5b9,     0)   ;; 0xfb4b   vav+holam
        (->decomp_C  0x5d1, 0x5bf,     0)   ;; 0xfb4c   bet+rafe
        (->decomp_C  0x5db, 0x5bf,     0)   ;; 0xfb4d   kaf+rafe
        (->decomp_C  0x5e4, 0x5bf,     0)   ;; 0xfb4e   pe+rafe
        (->decomp_C  0x5d0, 0x5dc,     0)   ;; 0xfb4f   alef-lamed
    ])

(defn- #_void mb-decompose [#_int c, #_int' a'c1, #_int' a'c2, #_int' a'c3]
    (if (<= 0xfb20 c 0xfb4f)
        (let [#_decomp_C d (... decomp_table (- c 0xfb20))]
            (reset! a'c1 (:a d))
            (reset! a'c2 (:b d))
            (reset! a'c3 (:c d))
        )
        (do
            (reset! a'c1 c)
            (reset! a'c2 0)
            (reset! a'c3 0)
        ))
    nil)

;; Compare two strings, ignore case if ireg_ic set.
;; Return 0 if strings match, non-zero otherwise.
;; Correct the length "*n" when composing characters are ignored.

(defn- #_int cstrncmp [#_Bytes s1, #_Bytes s2, #_int' a'n]
    (let-when [#_int cmp (if (not @ireg_ic) (STRNCMP s1, s2, @a'n) (us-strnicmp s1, s2, @a'n))] (and (non-zero? cmp) @ireg_icombine) => cmp
        ;; if it failed and it's utf8 and we want to combineignore
        (let [a's1 (atom (#_Bytes object s1)) a's2 (atom (#_Bytes object s2))
              ;; We have to handle the strcmp() ourselves, since it is necessary
              ;; to deal with the composing characters by ignoring them.
              cmp (loop-when [#_int c1 0 #_int c2 0] (< (BDIFF @a's1, s1) @a'n) => (- c2 c1)
                    (let [c1 (us-ptr2char-adv a's1, true) c2 (us-ptr2char-adv a's2, true)]
                        ;; Decompose the character if necessary into 'base' characters,
                        ;; because I don't care about Arabic, I will hard-code the Hebrew
                        ;; which I *do* care about!  So sue me...
                        (if (and (!= c1 c2) (or (not @ireg_ic) (!= (utf-fold c1) (utf-fold c2))))
                            (let [a'c1 (atom (int)) a'c2 (atom (int)) _ (atom (int))]
                                ;; decomposition necessary?
                                (mb-decompose c1, a'c1, _, _)
                                (mb-decompose c2, a'c2, _, _)
                                (let-when [c1 @a'c1 c2 @a'c2] (or (== @a'c1 @a'c2) (and @ireg_ic (== (utf-fold @a'c1) (utf-fold @a'c2)))) => (- c2 c1)
                                    (recur c1 c2)
                                ))
                            (recur c1 c2)
                        ))
                )]
            (when (zero? cmp)
                (reset! a'n (BDIFF @a's2, s2)))
            cmp)
    ))

;; This function is used a lot for simple searches, keep it fast!

(defn- #_Bytes cstrchr [#_Bytes s, #_int c]
    (if @ireg_ic
        (let-when [cc (cond (<= 0x80 c) (utf-fold c) (utf-isupper c) (utf-tolower c) (utf-islower c) (utf-toupper c))] (some? cc) => (vim-strchr s, c)
            (loop-when [i 0] (non-eos? s i) => nil
                (let-when [_ (cond (<= 0x80 c) (when (== (utf-fold (us-ptr2char s, i)) cc) i) (or (at? s i c) (at? s i cc)) i)] (nil? _) => (.plus s _)
                    (recur (+ i (us-ptr2len-cc s, i)))
                )))
        (vim-strchr s, c)
    ))

;; regsub stuff

;; We should define ftpr as a pointer to a function returning
;; a pointer to a function returning a pointer to a function ...
;; This is impossible, so we declare a pointer to a function
;; returning a pointer to a function returning void.

(ร
;   static abstract class fptr_C
    (ยง
;       public abstract fptr_C flip(int[] d, int c);
    ))

;   static final fptr_C do_upper = new fptr_C()
;   {
;       public fptr_C flip(int[] d, int c) { d[0] = utf-toupper(c); return null; }
;   };

;   static final fptr_C do_Upper = new fptr_C()
;   {
;       public fptr_C flip(int[] d, int c) { d[0] = utf-toupper(c); return this; }
;   };

;   static final fptr_C do_lower = new fptr_C()
;   {
;       public fptr_C flip(int[] d, int c) { d[0] = utf-tolower(c); return null; }
;   };

;   static final fptr_C do_Lower = new fptr_C()
;   {
;       public fptr_C flip(int[] d, int c) { d[0] = utf-tolower(c); return this; }
;   };

;; regtilde(): Replace tildes in the pattern by the old pattern.
;;
;; Short explanation of the tilde: It stands for the previous replacement pattern.
;; If that previous pattern also contains a ~ we should go back a step further...
;; But we insert the previous pattern into the current one and remember that.
;; This still does not handle the case where "magic" changes.
;; So require the user to keep his hands off of "magic".
;;
;; The tildes are parsed once before the first call to vim-regsub().

(defn- #_Bytes regtilde [#_Bytes source, #_boolean magic]
    (let [#_Bytes newsub
            (loop-when [newsub source #_Bytes s source] (non-eos? s) => newsub
                (if (or (and (at? s (byte \~)) magic) (and (at? s (byte \\)) (at? s 1 (byte \~)) (not magic)))
                    (cond (some? @reg_prev_sub)
                    (let [#_int m (STRLEN @reg_prev_sub)
                          #_Bytes t (Bytes. (+ (STRLEN newsub) m))
                          #_int n (BDIFF s, newsub)                     ;; not including ~
                          _ (BCOPY t, newsub, n)                        ;; copy prefix
                          _ (BCOPY t, n, @reg_prev_sub, 0, m)           ;; interpret tilde
                          s (if (not magic) (.plus s 1) s)              ;; back off \
                          _ (STRCPY (.plus t (+ n m)), (.plus s 1))]    ;; copy postfix
                        (recur t (.plus t (+ n m)))
                    )
                    magic
                    (let [_ (BCOPY s, 0, s, 1, (inc (STRLEN s, 1)))]    ;; remove '~'
                        (recur newsub s)
                    )
                    :else
                    (let [_ (BCOPY s, 0, s, 2, (inc (STRLEN s, 2)))]    ;; remove '\~'
                        (recur newsub s)
                    ))
                    (let [s (if (and (at? s (byte \\)) (non-eos? s 1)) (.plus s 1) s)]        ;; skip escaped characters
                        (recur newsub (.plus s (us-ptr2len-cc s)))
                    ))
            )]
        ;; if: "newsub" was allocated, just keep it ;; else: no ~ found, need to save "newsub"
        (reset! reg_prev_sub (if (BNE newsub, source) newsub (STRDUP newsub)))
        newsub
    ))

(atom! boolean can_f_submatch)          ;; true when submatch() can be used

;; These pointers are used instead of reg_match and reg_mmatch for reg_submatch().
;; Needed when the substitution string is an expression
;; that contains a call to substitute() and submatch().

(atom! regmatch_C       submatch_match)
(atom! regmmatch_C      submatch_mmatch)
(atom! long             submatch_firstlnum)
(atom! long             submatch_maxline)
(atom! boolean          submatch_line_lbr)

;; vim-regsub() - perform substitutions after a vim-regexec() or vim-regexec-multi() match.
;;
;; If "copy" is true really copy into "dest".
;; If "copy" is false nothing is copied, this is just to find out the length of the result.
;;
;; If "backslash" is true, a backslash will be removed later, need to double them to keep them,
;; and insert a backslash before a CR to avoid it being replaced with a line break later.
;;
;; Note: The matched text must not change between the call of vim-regexec()/vim-regexec-multi()
;; and vim-regsub()!  It would make the back references invalid!
;;
;; Returns the size of the replacement, including terminating NUL.

(defn- #_int vim-regsub [#_regmatch_C rmp, #_Bytes source, #_Bytes dest, #_boolean copy, #_boolean magic, #_boolean backslash]
    (reset! reg_match rmp)
    (reset! reg_mmatch nil)
    (reset! reg_maxline 0)
    (reset! reg_line_lbr true)

    (vim-regsub-both source, dest, copy, magic, backslash))

(defn- #_int vim-regsub-multi [#_regmmatch_C rmp, #_long lnum, #_Bytes source, #_Bytes dest, #_boolean copy, #_boolean magic, #_boolean backslash]
    (reset! reg_match nil)
    (reset! reg_mmatch rmp)
    (reset! reg_firstlnum lnum)
    (reset! reg_maxline (- (line-count @curbuf) lnum))
    (reset! reg_line_lbr false)

    (vim-regsub-both source, dest, copy, magic, backslash))

(atom! Bytes eval_result)

(defn- #_int vim-regsub-both [#_Bytes source, #_Bytes dest, #_boolean copy, #_boolean magic, #_boolean backslash]
    (ยง
        ;; Be paranoid...
        (when (or (nil? source) (nil? dest))
            (emsg e_null)
            ((ร RETURN) 0)
        )
        (if (prog-magic-wrong)
            ((ร RETURN) 0)
        )

        ((ร Bytes dst =) dest)

        ;; When the substitute part starts with "\=" evaluate it as an expression.

        (cond (and (at? source (byte \\)) (at? source 1 (byte \=)) (not @can_f_submatch))   ;; can't do this recursively
        (do
            ;; To make sure that the length doesn't change between checking the length
            ;; and copying the string, and to speed up things, the resulting string is saved
            ;; from the call with "copy" == false to the call with "copy" == true.
            (cond copy
            (do
                (when (some? @eval_result)
                    (STRCPY dest, @eval_result)
                    ((ร dst =) (.plus dst (STRLEN @eval_result)))
                    (reset! eval_result nil)
                )
            )
            :else
            (do
                ;; The expression may contain substitute(), which calls us recursively.
                ;; Make sure submatch() gets the text from the first level.

                (reset! submatch_match @reg_match)
                (reset! submatch_mmatch @reg_mmatch)
                (reset! submatch_firstlnum @reg_firstlnum)
                (reset! submatch_maxline @reg_maxline)
                (reset! submatch_line_lbr @reg_line_lbr)

                ((ร boolean save_ireg_ic =) @ireg_ic)
                (reset! can_f_submatch true)

                (reset! eval_result (eval-to-string (.plus source 2), nil))
                (when (some? @eval_result)
                    ((ร boolean had_backslash =) false)

                    (loop-when-recur [#_Bytes s @eval_result] (non-eos? s) [(.plus s (us-ptr2len-cc s))]
                        ;; Change NL to CR, so that it becomes a line break,
                        ;; unless called from vim-regexec-nl().
                        ;; Skip over a backslashed character.
                        (cond (and (at? s NL) (not @submatch_line_lbr))
                        (do
                            (.be s 0, CAR)
                        )
                        (and (at? s (byte \\)) (non-eos? s 1))
                        (do
                            ((ร s =) (.plus s 1))
                            ;; Change NL to CR here too, so that this works:
                            ;; :s/abc\\\ndef/\="aaa\\\nbbb"/  on text:
                            ;;   abc\
                            ;;   def
                            ;; Not when called from vim-regexec-nl().

                            (if (and (at? s NL) (not @submatch_line_lbr))
                                (.be s 0, CAR)
                            )
                            ((ร had_backslash =) true)
                        ))
                    )
                    (when (and had_backslash backslash)
                        ;; Backslashes will be consumed, need to double them.
                        (swap! eval_result vim-strsave-escaped (u8 "\\"), (byte \\))
                    )

                    ((ร dst =) (.plus dst (STRLEN @eval_result)))
                )

                (reset! reg_match @submatch_match)
                (reset! reg_mmatch @submatch_mmatch)
                (reset! reg_firstlnum @submatch_firstlnum)
                (reset! reg_maxline @submatch_maxline)
                (reset! reg_line_lbr @submatch_line_lbr)
                (reset! ireg_ic save_ireg_ic)
                (reset! can_f_submatch false)
            ))
        )
        :else
        (do
            ((ร fptr_C func_one =) nil)
            ((ร fptr_C func_all =) nil)

            ((ร int no =) -1)
            ((ร long clnum =) 0)
            ((ร int len =) 0)

            ((ร Bytes src =) source)

            (loop-when-recur [#_byte b (.at src 0) src (.plus src 1)] (!= b NUL) [(.at src 0) (.plus src 1)]
                (cond (and (== b (byte \&)) magic)
                (do
                    ((ร no =) 0)
                )
                (and (== b (byte \\)) (non-eos? src))
                (do
                    (cond (and (at? src (byte \&)) (not magic))
                    (do
                        ((ร src =) (.plus src 1))
                        ((ร no =) 0)
                    )
                    (and (<= (byte \0) (.at src 0)) (<= (.at src 0) (byte \9)))
                    (do
                        ((ร no =) (- (.at ((ร src =) (.plus src 1)) -1) (byte \0)))
                    )
                    (some? (vim-strbyte (u8 "uUlLeE"), (.at src 0)))
                    (do
                        (condp ==? (.at ((ร src =) (.plus src 1)) -1)
                            (byte \u)
                            (do
                                ((ร func_one =) do_upper)
                                (ร CONTINUE)
                            )
                            (byte \U)
                            (do
                                ((ร func_all =) do_Upper)
                                (ร CONTINUE)
                            )
                            (byte \l)
                            (do
                                ((ร func_one =) do_lower)
                                (ร CONTINUE)
                            )
                            (byte \L)
                            (do
                                ((ร func_all =) do_Lower)
                                (ร CONTINUE)
                            )
                           [(byte \e) (byte \E)]
                            (do
                                ((ร func_one =) nil)
                                ((ร func_all =) nil)
                                (ร CONTINUE)
                            )
                        )
                    ))
                ))
                (cond (< no 0)             ;; Ordinary character.
                (do
                    (when (and (== b KB_SPECIAL) (non-eos? src) (non-eos? src 1))
                        ;; Copy a special key as-is.
                        (cond copy
                        (do
                            (.be ((ร dst =) (.plus dst 1)) -1, b)
                            (.be ((ร dst =) (.plus dst 1)) -1, (.at ((ร src =) (.plus src 1)) -1))
                            (.be ((ร dst =) (.plus dst 1)) -1, (.at ((ร src =) (.plus src 1)) -1))
                        )
                        :else
                        (do
                            ((ร dst =) (.plus dst 3))
                            ((ร src =) (.plus src 2))
                        ))
                        (ร CONTINUE)
                    )

                    (ร int c)
                    (cond (and (== b (byte \\)) (non-eos? src))
                    (do
                        ;; Check for abbreviations.
                        (condp == (.at src 0)
                            (byte \r)
                            (do
                                ((ร b =) CAR)
                                ((ร src =) (.plus src 1))
                                (ร BREAK)
                            )
                            (byte \n)
                            (do
                                ((ร b =) NL)
                                ((ร src =) (.plus src 1))
                                (ร BREAK)
                            )
                            (byte \t)
                            (do
                                ((ร b =) TAB)
                                ((ร src =) (.plus src 1))
                                (ร BREAK)
                            )
                         ;; case (byte \e):     ;; Oh no!  \e already has meaning in subst pat.
                         ;; {
                         ;;     b = ESC;
                         ;;     src = src.plus(1);
                         ;;     break;
                         ;; }
                            (byte \b)
                            (do
                                ((ร b =) Ctrl_H)
                                ((ร src =) (.plus src 1))
                                (ร BREAK)
                            )

                            ;; If "backslash" is true the backslash will be removed later.
                            ;; Used to insert a literal CR.
                            (do
                                (when backslash
                                    (if copy
                                        (.be dst 0, (byte \\))
                                    )
                                    ((ร dst =) (.plus dst 1))
                                )
                                ((ร b =) (.at ((ร src =) (.plus src 1)) -1))
                                (ร BREAK)
                            )
                        )
                        ((ร c =) (char_u b))
                    )
                    :else
                    (do
                        ((ร c =) (us-ptr2char src, -1))
                    ))

                    ;; Write to buffer, if copy is set.
                    ((ร int[] a'cc =) (atom (int)))
                    (cond (some? func_one)
                    (do
                        ((ร func_one =) (.flip func_one a'cc, c))
                    )
                    (some? func_all)
                    (do
                        ((ร func_all =) (.flip func_all a'cc, c))
                    )
                    :else ;; just copy
                    (do
                        (reset! a'cc c)
                    ))

                    ((ร int totlen =) (us-ptr2len-cc src, -1))

                    (if copy
                        (utf-char2bytes @a'cc, dst))
                    ((ร dst =) (.plus dst (dec (utf-char2len @a'cc))))

                    ((ร int clen =) (us-ptr2len src, -1))

                    ;; If the character length is shorter than "totlen",
                    ;; there are composing characters; copy them as-is.
                    (when (< clen totlen)
                        (if copy
                            (BCOPY dst, 1, src, (+ -1 clen), (- totlen clen)))
                        ((ร dst =) (.plus dst (- totlen clen)))
                    )

                    ((ร src =) (.plus src (dec totlen)))
                    ((ร dst =) (.plus dst 1))
                )
                :else
                (do
                    (ร Bytes s)
                    (cond (nil? @reg_match)
                    (do
                        ((ร clnum =) (:lnum (... (:startpos @reg_mmatch) no)))
                        (cond (or (< clnum 0) (< (:lnum (... (:endpos @reg_mmatch) no)) 0))
                        (do
                            ((ร s =) nil)
                        )
                        :else
                        (do
                            ((ร s =) (.plus (reg-getline clnum) (:col (... (:startpos @reg_mmatch) no))))
                            ((ร len =) (if (== (:lnum (... (:endpos @reg_mmatch) no)) clnum)
                                (- (:col (... (:endpos @reg_mmatch) no)) (:col (... (:startpos @reg_mmatch) no)))
                                (STRLEN s)
                            ))
                        ))
                    )
                    :else
                    (do
                        ((ร s =) (... (:startp @reg_match) no))
                        (if (nil? (... (:endp @reg_match) no))
                            ((ร s =) nil)
                            ((ร len =) (BDIFF (... (:endp @reg_match) no), s))
                        )
                    ))
                    (when (some? s)
                        (loop []
                            (cond (zero? len)
                            (do
                                (cond (nil? @reg_match)
                                (do
                                    (if (== (:lnum (... (:endpos @reg_mmatch) no)) clnum)
                                        (ร BREAK)
                                    )
                                    (if copy
                                        (.be dst 0, CAR)
                                    )
                                    ((ร dst =) (.plus dst 1))
                                    ((ร s =) (reg-getline ((ร clnum =) (inc clnum))))
                                    ((ร len =) (if (== (:lnum (... (:endpos @reg_mmatch) no)) clnum)
                                        (:col (... (:endpos @reg_mmatch) no))
                                        (STRLEN s)
                                    ))
                                )
                                :else
                                (do
                                    (ร BREAK)
                                ))
                            )
                            (eos? s)
                            (do
                                (if copy
                                    (emsg e_re_damg))
                                ((ร RETURN) (inc (BDIFF dst, dest)))
                            )
                            :else
                            (do
                                (cond (and backslash (or (at? s CAR) (at? s (byte \\))))
                                (do
                                    ;; Insert a backslash in front of a CR,
                                    ;; otherwise it will be replaced by a line break.
                                    ;; Number of backslashes will be halved later, double them here.

                                    (when copy
                                        (.be dst 0, (byte \\))
                                        (.be dst 1, (.at s 0))
                                    )
                                    ((ร dst =) (.plus dst 2))
                                )
                                :else
                                (do
                                    ((ร int c =) (us-ptr2char s))

                                    ((ร int[] a'cc =) (atom (int)))
                                    (cond (some? func_one)
                                    (do
                                        ((ร func_one =) (.flip func_one a'cc, c))
                                    )
                                    (some? func_all)
                                    (do
                                        ((ร func_all =) (.flip func_all a'cc, c))
                                    )
                                    :else ;; just copy
                                    (do
                                        (reset! a'cc c)
                                    ))

                                    ;; Copy composing characters separately, one at a time.
                                    ((ร int l =) (dec (us-ptr2len s)))

                                    ((ร s =) (.plus s l))
                                    ((ร len =) (- len l))
                                    (if copy
                                        (utf-char2bytes @a'cc, dst))
                                    ((ร dst =) (.plus dst (dec (utf-char2len @a'cc))))

                                    ((ร dst =) (.plus dst 1))
                                ))

                                ((ร s =) (.plus s 1))
                                ((ร len =) (dec len))
                            ))
                            (recur)
                        )
                    )
                    ((ร no =) -1)
                ))
            )
        ))

        (when copy (eos! dst))

        (inc (BDIFF dst, dest))
    ))

;;; ============================================================================================== VimO

;; NFA regular expression implementation.

;; Added to NFA_ANY - NFA_NUPPER_IC to include a NL.
(final int NFA_ADD_NL 31)

(final int
    NFA_SPLIT -1024,
    NFA_MATCH -1023,
    NFA_EMPTY -1022,                      ;; matches 0-length

    NFA_START_COLL -1021,                 ;; [abc] start
    NFA_END_COLL -1020,                   ;; [abc] end
    NFA_START_NEG_COLL -1019,             ;; [^abc] start
    NFA_END_NEG_COLL -1018,               ;; [^abc] end (postfix only)
    NFA_RANGE -1017,                      ;; range of the two previous items (postfix only)
    NFA_RANGE_MIN -1016,                  ;; low end of a range
    NFA_RANGE_MAX -1015,                  ;; high end of a range

    NFA_CONCAT -1014,                     ;; concatenate two previous items (postfix only)
    NFA_OR -1013,                         ;; \| (postfix only)
    NFA_STAR -1012,                       ;; greedy * (posfix only)
    NFA_STAR_NONGREEDY -1011,             ;; non-greedy * (postfix only)
    NFA_QUEST -1010,                      ;; greedy \? (postfix only)
    NFA_QUEST_NONGREEDY -1009,            ;; non-greedy \? (postfix only)

    NFA_BOL -1008,                        ;; ^    Begin line
    NFA_EOL -1007,                        ;; $    End line
    NFA_BOW -1006,                        ;; \<   Begin word
    NFA_EOW -1005,                        ;; \>   End word
    NFA_BOF -1004,                        ;; \%^  Begin file
    NFA_EOF -1003,                        ;; \%$  End file
    NFA_NEWL -1002,
    NFA_ZSTART -1001,                     ;; Used for \zs
    NFA_ZEND -1000,                       ;; Used for \ze
    NFA_NOPEN -999,                       ;; Start of subexpression marked with \%(
    NFA_NCLOSE -998,                      ;; End of subexpr. marked with \%( ... \)
    NFA_START_INVISIBLE -997,
    NFA_START_INVISIBLE_FIRST -996,
    NFA_START_INVISIBLE_NEG -995,
    NFA_START_INVISIBLE_NEG_FIRST -994,
    NFA_START_INVISIBLE_BEFORE -993,
    NFA_START_INVISIBLE_BEFORE_FIRST -992,
    NFA_START_INVISIBLE_BEFORE_NEG -991,
    NFA_START_INVISIBLE_BEFORE_NEG_FIRST -990,
    NFA_START_PATTERN -989,
    NFA_END_INVISIBLE -988,
    NFA_END_INVISIBLE_NEG -987,
    NFA_END_PATTERN -986,
    NFA_COMPOSING -985,                   ;; Next nodes in NFA are part of the composing multibyte char
    NFA_END_COMPOSING -984,               ;; End of a composing char in the NFA
    NFA_ANY_COMPOSING -983,               ;; \%C: Any composing characters.
    NFA_OPT_CHARS -982,                   ;; \%[abc]

    ;; The following are used only in the postfix form, not in the NFA.
    NFA_PREV_ATOM_NO_WIDTH -981,          ;; Used for \@=
    NFA_PREV_ATOM_NO_WIDTH_NEG -980,      ;; Used for \@!
    NFA_PREV_ATOM_JUST_BEFORE -979,       ;; Used for \@<=
    NFA_PREV_ATOM_JUST_BEFORE_NEG -978,   ;; Used for \@<!
    NFA_PREV_ATOM_LIKE_PATTERN -977,      ;; Used for \@>

    NFA_BACKREF1 -976,                    ;; \1
    NFA_BACKREF2 -975,                    ;; \2
    NFA_BACKREF3 -974,                    ;; \3
    NFA_BACKREF4 -973,                    ;; \4
    NFA_BACKREF5 -972,                    ;; \5
    NFA_BACKREF6 -971,                    ;; \6
    NFA_BACKREF7 -970,                    ;; \7
    NFA_BACKREF8 -969,                    ;; \8
    NFA_BACKREF9 -968,                    ;; \9
    NFA_ZREF1 -967,                       ;; \z1
    NFA_ZREF2 -966,                       ;; \z2
    NFA_ZREF3 -965,                       ;; \z3
    NFA_ZREF4 -964,                       ;; \z4
    NFA_ZREF5 -963,                       ;; \z5
    NFA_ZREF6 -962,                       ;; \z6
    NFA_ZREF7 -961,                       ;; \z7
    NFA_ZREF8 -960,                       ;; \z8
    NFA_ZREF9 -959,                       ;; \z9
    NFA_SKIP -958,                        ;; Skip characters

    NFA_MOPEN -957,
    NFA_MOPEN1 -956,
    NFA_MOPEN2 -955,
    NFA_MOPEN3 -954,
    NFA_MOPEN4 -953,
    NFA_MOPEN5 -952,
    NFA_MOPEN6 -951,
    NFA_MOPEN7 -950,
    NFA_MOPEN8 -949,
    NFA_MOPEN9 -948,

    NFA_MCLOSE -947,
    NFA_MCLOSE1 -946,
    NFA_MCLOSE2 -945,
    NFA_MCLOSE3 -944,
    NFA_MCLOSE4 -943,
    NFA_MCLOSE5 -942,
    NFA_MCLOSE6 -941,
    NFA_MCLOSE7 -940,
    NFA_MCLOSE8 -939,
    NFA_MCLOSE9 -938,

    NFA_ZOPEN -937,
    NFA_ZOPEN1 -936,
    NFA_ZOPEN2 -935,
    NFA_ZOPEN3 -934,
    NFA_ZOPEN4 -933,
    NFA_ZOPEN5 -932,
    NFA_ZOPEN6 -931,
    NFA_ZOPEN7 -930,
    NFA_ZOPEN8 -929,
    NFA_ZOPEN9 -928,

    NFA_ZCLOSE -927,
    NFA_ZCLOSE1 -926,
    NFA_ZCLOSE2 -925,
    NFA_ZCLOSE3 -924,
    NFA_ZCLOSE4 -923,
    NFA_ZCLOSE5 -922,
    NFA_ZCLOSE6 -921,
    NFA_ZCLOSE7 -920,
    NFA_ZCLOSE8 -919,
    NFA_ZCLOSE9 -918,

    ;; NFA_FIRST_NL
    NFA_ANY -917,                        ;; Match any one character.
    NFA_IDENT -916,                      ;; Match identifier char
    NFA_SIDENT -915,                     ;; Match identifier char but no digit
    NFA_KWORD -914,                      ;; Match keyword char
    NFA_SKWORD -913,                     ;; Match word char but no digit
    NFA_FNAME -912,                      ;; Match file name char
    NFA_SFNAME -911,                     ;; Match file name char but no digit
    NFA_PRINT -910,                      ;; Match printable char
    NFA_SPRINT -909,                     ;; Match printable char but no digit
    NFA_WHITE -908,                      ;; Match whitespace char
    NFA_NWHITE -907,                     ;; Match non-whitespace char
    NFA_DIGIT -906,                      ;; Match digit char
    NFA_NDIGIT -905,                     ;; Match non-digit char
    NFA_HEX -904,                        ;; Match hex char
    NFA_NHEX -903,                       ;; Match non-hex char
    NFA_OCTAL -902,                      ;; Match octal char
    NFA_NOCTAL -901,                     ;; Match non-octal char
    NFA_WORD -900,                       ;; Match word char
    NFA_NWORD -899,                      ;; Match non-word char
    NFA_HEAD -898,                       ;; Match head char
    NFA_NHEAD -897,                      ;; Match non-head char
    NFA_ALPHA -896,                      ;; Match alpha char
    NFA_NALPHA -895,                     ;; Match non-alpha char
    NFA_LOWER -894,                      ;; Match lowercase char
    NFA_NLOWER -893,                     ;; Match non-lowercase char
    NFA_UPPER -892,                      ;; Match uppercase char
    NFA_NUPPER -891,                     ;; Match non-uppercase char
    NFA_LOWER_IC -890,                   ;; Match [a-z]
    NFA_NLOWER_IC -889,                  ;; Match [^a-z]
    NFA_UPPER_IC -888,                   ;; Match [A-Z]
    NFA_NUPPER_IC -887,                  ;; Match [^A-Z]

    NFA_FIRST_NL (+ NFA_ANY NFA_ADD_NL),
    NFA_LAST_NL (+ NFA_NUPPER_IC NFA_ADD_NL),

    NFA_CURSOR -855,                     ;; Match cursor pos
    NFA_LNUM -854,                       ;; Match line number
    NFA_LNUM_GT -853,                    ;; Match > line number
    NFA_LNUM_LT -852,                    ;; Match < line number
    NFA_COL -851,                        ;; Match cursor column
    NFA_COL_GT -850,                     ;; Match > cursor column
    NFA_COL_LT -849,                     ;; Match < cursor column
    NFA_VCOL -848,                       ;; Match cursor virtual column
    NFA_VCOL_GT -847,                    ;; Match > cursor virtual column
    NFA_VCOL_LT -846,                    ;; Match < cursor virtual column
    NFA_MARK -845,                       ;; Match mark
    NFA_MARK_GT -844,                    ;; Match > mark
    NFA_MARK_LT -843,                    ;; Match < mark
    NFA_VISUAL -842,                     ;; Match Visual area

    ;; Character classes [:alnum:] etc.
    NFA_CLASS_ALNUM -841,
    NFA_CLASS_ALPHA -840,
    NFA_CLASS_BLANK -839,
    NFA_CLASS_CNTRL -838,
    NFA_CLASS_DIGIT -837,
    NFA_CLASS_GRAPH -836,
    NFA_CLASS_LOWER -835,
    NFA_CLASS_PRINT -834,
    NFA_CLASS_PUNCT -833,
    NFA_CLASS_SPACE -832,
    NFA_CLASS_UPPER -831,
    NFA_CLASS_XDIGIT -830,
    NFA_CLASS_TAB -829,
    NFA_CLASS_RETURN -828,
    NFA_CLASS_BACKSPACE -827,
    NFA_CLASS_ESCAPE -826)

;; Keep in sync with "classchars".
(final int* nfa_classcodes
    [
        NFA_ANY, NFA_IDENT, NFA_SIDENT, NFA_KWORD, NFA_SKWORD,
        NFA_FNAME, NFA_SFNAME, NFA_PRINT, NFA_SPRINT,
        NFA_WHITE, NFA_NWHITE, NFA_DIGIT, NFA_NDIGIT,
        NFA_HEX, NFA_NHEX, NFA_OCTAL, NFA_NOCTAL,
        NFA_WORD, NFA_NWORD, NFA_HEAD, NFA_NHEAD,
        NFA_ALPHA, NFA_NALPHA, NFA_LOWER, NFA_NLOWER,
        NFA_UPPER, NFA_NUPPER
    ])

(final Bytes e_nul_found       (u8 "E865: (NFA) Regexp end encountered prematurely"))
(final Bytes e_misplaced       (u8 "E866: (NFA regexp) Misplaced %c"))
(final Bytes e_ill_char_class  (u8 "E877: (NFA regexp) Invalid character class: %ld"))

;; re_flags passed to nfa-regcomp()
(atom! int nfa_re_flags)

;; NFA regexp \ze operator encountered.
(atom! boolean nfa_has_zend)

;; NFA regexp \1 .. \9 encountered.
(atom! boolean nfa_has_backref)

;; NFA regexp has \z( ), set zsubexpr.
(atom! boolean nfa_has_zsubexpr)

;; Number of sub expressions actually being used during execution.
;; 1 if only the whole match (subexpr 0) is used.

(atom! int nfa_nsubexpr)

(atom! int* post_array)    ;; holds the postfix form of r.e.
(atom! int post_index)

;; If not null match must end at this position.
(atom! save_se_C nfa_endp)

;; 'listid' is global, so that it increases on recursive calls to nfa-regmatch(),
;; which means we don't have to clear the lastlist field of all the states.

(atom! int nfa_listid)
(atom! int nfa_alt_listid)

;; 0 for first call to nfa-regmatch(), 1 for recursive call.
(atom! int nfa_ll_index)

;; Initialize internal variables before NFA compilation.
;; Return true on success, false otherwise.

(defn- #_void nfa-regcomp-start [#_Bytes expr, #_int re_flags]
    ;; re_flags: see vim-regcomp()
    (ยง
        ;; A reasonable estimation for maximum size.
        ((ร int nstate_max =) (* (inc (STRLEN expr)) 25))

        ;; Some items blow up in size, such as [A-z].  Add more space for that.
        ;; When it is still not enough grow-post-array() will be used.
        ((ร nstate_max =) (+ nstate_max 1000))

        (reset! post_array (ร new int[nstate_max]))
        (reset! post_index 0)

        (reset! nfa_has_zend false)
        (reset! nfa_has_backref false)

        ;; shared with BT engine
        (regcomp-start expr, re_flags)
        nil
    ))

;; Figure out if the NFA state list starts with an anchor, must match at start of the line.

(defn- #_boolean nfa-get-reganch [#_nfa_state_C start, #_int depth]
    (if (< 4 depth)
        false
        (loop-when [#_nfa_state_C state start] (some? state) => false
            (condp ==? (:c state)
               [NFA_BOL
                NFA_BOF]
                    true ;; yes!

               [NFA_ZSTART
                NFA_ZEND
                NFA_CURSOR
                NFA_VISUAL

                NFA_MOPEN
                NFA_MOPEN1
                NFA_MOPEN2
                NFA_MOPEN3
                NFA_MOPEN4
                NFA_MOPEN5
                NFA_MOPEN6
                NFA_MOPEN7
                NFA_MOPEN8
                NFA_MOPEN9
                NFA_NOPEN
                NFA_ZOPEN
                NFA_ZOPEN1
                NFA_ZOPEN2
                NFA_ZOPEN3
                NFA_ZOPEN4
                NFA_ZOPEN5
                NFA_ZOPEN6
                NFA_ZOPEN7
                NFA_ZOPEN8
                NFA_ZOPEN9]
                    (recur (.out0 state))

                NFA_SPLIT
                    (and (nfa-get-reganch (.out0 state), (inc depth)) (nfa-get-reganch (.out1 state), (inc depth)))

             ;; :else
                false ;; noooo!
            ))
    ))

;; Figure out if the NFA state list starts with a character which must match at start of the match.

(defn- #_int nfa-get-regstart [#_nfa_state_C start, #_int depth]
    (if (< 4 depth)
        0
        (loop-when [#_nfa_state_C state start] (some? state) => 0
            (condp ==? (:c state)
                ;; all kinds of zero-width matches
               [NFA_BOL
                NFA_BOF
                NFA_BOW
                NFA_EOW
                NFA_ZSTART
                NFA_ZEND
                NFA_CURSOR
                NFA_VISUAL
                NFA_LNUM
                NFA_LNUM_GT
                NFA_LNUM_LT
                NFA_COL
                NFA_COL_GT
                NFA_COL_LT
                NFA_VCOL
                NFA_VCOL_GT
                NFA_VCOL_LT
                NFA_MARK
                NFA_MARK_GT
                NFA_MARK_LT

                NFA_MOPEN
                NFA_MOPEN1
                NFA_MOPEN2
                NFA_MOPEN3
                NFA_MOPEN4
                NFA_MOPEN5
                NFA_MOPEN6
                NFA_MOPEN7
                NFA_MOPEN8
                NFA_MOPEN9
                NFA_NOPEN
                NFA_ZOPEN
                NFA_ZOPEN1
                NFA_ZOPEN2
                NFA_ZOPEN3
                NFA_ZOPEN4
                NFA_ZOPEN5
                NFA_ZOPEN6
                NFA_ZOPEN7
                NFA_ZOPEN8
                NFA_ZOPEN9]
                    (recur (.out0 state))

                NFA_SPLIT
                    (let [l (nfa-get-regstart (.out0 state), (inc depth)) r (nfa-get-regstart (.out1 state), (inc depth))]
                        (if (== l r) l 0))

             ;; :else
                (max 0 (:c state))
            ))
    ))

;; Figure out if the NFA state list contains just literal text and nothing else.
;; If so return a string in allocated memory with what must match after regstart.
;; Otherwise return null.

(defn- #_Bytes nfa-get-match-text [#_nfa_state_C start]
    (let-when [p start] (== (:c p) NFA_MOPEN) => nil
        (let-when [[n p] (loop-when-recur [n 0 p (.out0 p)] (< 0 (:c p)) [(+ n (utf-char2len (:c p))) (.out0 p)] => [n p])]
                  (and (== (:c p) NFA_MCLOSE) (== (.. p (out0) c) NFA_MATCH)) => nil
            (let [q (Bytes. n) ;; skip first char, it goes into regstart
                  _ (loop-when-recur [s q p (.. start (out0) (out0))] (< 0 (:c p)) [(.plus s (utf-char2bytes (:c p), s)) (.out0 p)] => (eos! s))]
            q))
    ))

;; Allocate more space for post_array.
;; Called when running above the estimated number of states.

(defn- #_void grow-post-array [#_int more]
    (swap! post_array #(Arrays/copyOf %, (+ (:length %) more)))
    nil)

;; Search between "start" and "end" and try to recognize a character class in expanded form.
;; For example [0-9].
;; On success, return the id the character class to be emitted.
;; On failure, return 0 (=false).
;; Start points to the first char of the range, while end should point to the closing brace.
;; Keep in mind that 'ignorecase' applies at execution time,
;; thus [a-z] may need to be interpreted as [a-zA-Z].

(final int
    CLASS_not        0x80,
    CLASS_af         0x40,
    CLASS_AF         0x20,
    CLASS_az         0x10,
    CLASS_AZ         0x08,
    CLASS_o7         0x04,
    CLASS_o9         0x02,
    CLASS_underscore 0x01)

(defn- #_int nfa-recognize-char-class [#_Bytes start, #_Bytes end, #_boolean newl]
    (if (not-at? end (byte \]))
        0
        (let-when [[#_int x #_Bytes p] (if (at? start (byte \^)) [CLASS_not (.plus start 1)] [0 start])
              [x p newl :as _]
                (loop-when [x x p p newl newl] (BLT p, end) => [x p newl]
                    (cond (and (BLT (.plus p 2), end) (at? p 1 (byte \-)))
                        (let-when [x (condp == (.at p 0)
                                    (byte \0) (condp == (.at p 2) (byte \9) (| x CLASS_o9) (byte \7) (| x CLASS_o7) nil)
                                    (byte \a) (condp == (.at p 2) (byte \z) (| x CLASS_az) (byte \f) (| x CLASS_af) nil)
                                    (byte \A) (condp == (.at p 2) (byte \Z) (| x CLASS_AZ) (byte \F) (| x CLASS_AF) nil)
                                nil)] (some? x) => nil
                            (recur x (.plus p 3) newl))
                    (and (BLT (.plus p 1), end) (at? p (byte \\)) (at? p 1 (byte \n)))
                        (recur x (.plus p 2) true)
                    (at? p (byte \_))
                        (recur (| x CLASS_underscore) (.plus p 1) newl)
                    (at? p (byte \newline))
                        (recur x (.plus p 1) true)
                    ))
        ] (some? _) => 0
            (if (BNE p, end)
                0
                (let [#_int nfa_add_nl (if newl NFA_ADD_NL 0)]
                    (condp == x
                        CLASS_o9                                               (+ nfa_add_nl NFA_DIGIT)
                     (| CLASS_not CLASS_o9)                                    (+ nfa_add_nl NFA_NDIGIT)
                     (| CLASS_af CLASS_AF CLASS_o9)                            (+ nfa_add_nl NFA_HEX)
                     (| CLASS_not CLASS_af CLASS_AF CLASS_o9)                  (+ nfa_add_nl NFA_NHEX)
                        CLASS_o7                                               (+ nfa_add_nl NFA_OCTAL)
                     (| CLASS_not CLASS_o7)                                    (+ nfa_add_nl NFA_NOCTAL)
                     (| CLASS_az CLASS_AZ CLASS_o9 CLASS_underscore)           (+ nfa_add_nl NFA_WORD)
                     (| CLASS_not CLASS_az CLASS_AZ CLASS_o9 CLASS_underscore) (+ nfa_add_nl NFA_NWORD)
                     (| CLASS_az CLASS_AZ CLASS_underscore)                    (+ nfa_add_nl NFA_HEAD)
                     (| CLASS_not CLASS_az CLASS_AZ CLASS_underscore)          (+ nfa_add_nl NFA_NHEAD)
                     (| CLASS_az CLASS_AZ)                                     (+ nfa_add_nl NFA_ALPHA)
                     (| CLASS_not CLASS_az CLASS_AZ)                           (+ nfa_add_nl NFA_NALPHA)
                        CLASS_az                                               (+ nfa_add_nl NFA_LOWER_IC)
                     (| CLASS_not CLASS_az)                                    (+ nfa_add_nl NFA_NLOWER_IC)
                        CLASS_AZ                                               (+ nfa_add_nl NFA_UPPER_IC)
                     (| CLASS_not CLASS_AZ)                                    (+ nfa_add_nl NFA_NUPPER_IC)
                0))
            ))
    ))

;; helper functions used when doing re2post() ... regatom() parsing

(defn- #_boolean emc1 [#_int c]
    (ยง
        (when (<= (:length @post_array) @post_index)
            (grow-post-array 1000))

        ((ร @post_array[@post_index++] =) c)

        true
    ))

(defn- #_boolean emc2 [#_int c]
    (and (emc1 c) (emc1 NFA_CONCAT)))

;; Produce the bytes for equivalence class "c".
;; Currently only handles latin1, latin9 and utf-8.
;; Emits bytes in postfix notation: 'a,b,NFA_OR,c,NFA_OR' is equivalent to 'a OR b OR c'.
;;
;; NOTE! When changing this function, also update reg-equi-class()

(defn- #_boolean nfa-emit-equi-class [#_int c]
    (condp ==? c
       [(byte \A), 0xc0 0xc1 0xc2, 0xc3 0xc4 0xc5, 0x100 0x102 0x104, 0x1cd 0x1de 0x1e0, 0x1ea2]
        (and (emc2 (byte \A))
            (emc2 0xc0) (emc2 0xc1) (emc2 0xc2)
            (emc2 0xc3) (emc2 0xc4) (emc2 0xc5)
            (emc2 0x100) (emc2 0x102) (emc2 0x104)
            (emc2 0x1cd) (emc2 0x1de) (emc2 0x1e0)
            (emc2 0x1ea2))

       [(byte \a), 0xe0 0xe1 0xe2, 0xe3 0xe4 0xe5, 0x101 0x103 0x105, 0x1ce 0x1df 0x1e1, 0x1ea3]
        (and (emc2 (byte \a))
            (emc2 0xe0) (emc2 0xe1) (emc2 0xe2)
            (emc2 0xe3) (emc2 0xe4) (emc2 0xe5)
            (emc2 0x101) (emc2 0x103) (emc2 0x105)
            (emc2 0x1ce) (emc2 0x1df) (emc2 0x1e1)
            (emc2 0x1ea3))

       [(byte \B), 0x1e02 0x1e06]
        (and (emc2 (byte \B))
            (emc2 0x1e02) (emc2 0x1e06))

       [(byte \b), 0x1e03 0x1e07]
        (and (emc2 (byte \b))
            (emc2 0x1e03) (emc2 0x1e07))

       [(byte \C), 0xc7, 0x106 0x108 0x10a 0x10c]
        (and (emc2 (byte \C))
            (emc2 0xc7)
            (emc2 0x106) (emc2 0x108) (emc2 0x10a) (emc2 0x10c))

       [(byte \c), 0xe7, 0x107 0x109 0x10b 0x10d]
        (and (emc2 (byte \c))
            (emc2 0xe7)
            (emc2 0x107) (emc2 0x109) (emc2 0x10b) (emc2 0x10d))

       [(byte \D), 0x10e 0x110, 0x1e0a 0x1e0c 0x1e0e 0x1e10 0x1e12]
        (and (emc2 (byte \D))
            (emc2 0x10e) (emc2 0x110)
            (emc2 0x1e0a) (emc2 0x1e0c) (emc2 0x1e0e) (emc2 0x1e10) (emc2 0x1e12))

       [(byte \d), 0x10f 0x111, 0x1e0b 0x1e0d 0x1e0f 0x1e11 0x1e13]
        (and (emc2 (byte \d))
            (emc2 0x10f) (emc2 0x111)
            (emc2 0x1e0b) (emc2 0x1e0d) (emc2 0x1e0f) (emc2 0x1e11) (emc2 0x1e13))

       [(byte \E), 0xc8 0xc9 0xca 0xcb, 0x112 0x114 0x116 0x118 0x11a, 0x1eba 0x1ebc]
        (and (emc2 (byte \E))
            (emc2 0xc8) (emc2 0xc9) (emc2 0xca) (emc2 0xcb)
            (emc2 0x112) (emc2 0x114) (emc2 0x116) (emc2 0x118) (emc2 0x11a)
            (emc2 0x1eba) (emc2 0x1ebc))

       [(byte \e), 0xe8 0xe9 0xea 0xeb, 0x113 0x115 0x117 0x119 0x11b, 0x1ebb 0x1ebd]
        (and (emc2 (byte \e))
            (emc2 0xe8) (emc2 0xe9) (emc2 0xea) (emc2 0xeb)
            (emc2 0x113) (emc2 0x115) (emc2 0x117) (emc2 0x119) (emc2 0x11b)
            (emc2 0x1ebb) (emc2 0x1ebd))

       [(byte \F), 0x1e1e]
        (and (emc2 (byte \F))
            (emc2 0x1e1e))

       [(byte \f), 0x1e1f]
        (and (emc2 (byte \f))
            (emc2 0x1e1f))

       [(byte \G), 0x11c 0x11e 0x120 0x122, 0x1e4 0x1e6 0x1f4, 0x1e20]
        (and (emc2 (byte \G))
            (emc2 0x11c) (emc2 0x11e) (emc2 0x120) (emc2 0x122)
            (emc2 0x1e4) (emc2 0x1e6) (emc2 0x1f4)
            (emc2 0x1e20))

       [(byte \g), 0x11d 0x11f 0x121 0x123, 0x1e5 0x1e7 0x1f5, 0x1e21]
        (and (emc2 (byte \g))
            (emc2 0x11d) (emc2 0x11f) (emc2 0x121) (emc2 0x123)
            (emc2 0x1e5) (emc2 0x1e7) (emc2 0x1f5)
            (emc2 0x1e21))

       [(byte \H), 0x124 0x126, 0x1e22 0x1e26 0x1e28]
        (and (emc2 (byte \H))
            (emc2 0x124) (emc2 0x126)
            (emc2 0x1e22) (emc2 0x1e26) (emc2 0x1e28))

       [(byte \h), 0x125 0x127, 0x1e23 0x1e27 0x1e29 0x1e96]
        (and (emc2 (byte \h))
            (emc2 0x125) (emc2 0x127)
            (emc2 0x1e23) (emc2 0x1e27) (emc2 0x1e29) (emc2 0x1e96))

       [(byte \I), 0xcc 0xcd 0xce 0xcf, 0x128 0x12a 0x12c 0x12e 0x130, 0x1cf, 0x1ec8]
        (and (emc2 (byte \I))
            (emc2 0xcc) (emc2 0xcd) (emc2 0xce) (emc2 0xcf)
            (emc2 0x128) (emc2 0x12a) (emc2 0x12c) (emc2 0x12e) (emc2 0x130)
            (emc2 0x1cf)
            (emc2 0x1ec8))

       [(byte \i), 0xec 0xed 0xee 0xef, 0x129 0x12b 0x12d 0x12f 0x131, 0x1d0, 0x1ec9]
        (and (emc2 (byte \i))
            (emc2 0xec) (emc2 0xed) (emc2 0xee) (emc2 0xef)
            (emc2 0x129) (emc2 0x12b) (emc2 0x12d) (emc2 0x12f) (emc2 0x131)
            (emc2 0x1d0)
            (emc2 0x1ec9))

       [(byte \J), 0x134]
        (and (emc2 (byte \J))
            (emc2 0x134))

       [(byte \j), 0x135 0x1f0]
        (and (emc2 (byte \j))
            (emc2 0x135) (emc2 0x1f0))

       [(byte \K), 0x136 0x1e8, 0x1e30 0x1e34]
        (and (emc2 (byte \K))
            (emc2 0x136) (emc2 0x1e8)
            (emc2 0x1e30) (emc2 0x1e34))

       [(byte \k), 0x137 0x1e9, 0x1e31 0x1e35]
        (and (emc2 (byte \k))
            (emc2 0x137) (emc2 0x1e9)
            (emc2 0x1e31) (emc2 0x1e35))

       [(byte \L), 0x139 0x13b 0x13d 0x13f 0x141, 0x1e3a]
        (and (emc2 (byte \L))
            (emc2 0x139) (emc2 0x13b) (emc2 0x13d) (emc2 0x13f) (emc2 0x141)
            (emc2 0x1e3a))

       [(byte \l), 0x13a 0x13c 0x13e 0x140 0x142, 0x1e3b]
        (and (emc2 (byte \l))
            (emc2 0x13a) (emc2 0x13c) (emc2 0x13e) (emc2 0x140) (emc2 0x142)
            (emc2 0x1e3b))

       [(byte \M), 0x1e3e 0x1e40]
        (and (emc2 (byte \M))
            (emc2 0x1e3e) (emc2 0x1e40))

       [(byte \m), 0x1e3f 0x1e41]
        (and (emc2 (byte \m))
            (emc2 0x1e3f) (emc2 0x1e41))

       [(byte \N), 0xd1, 0x143 0x145 0x147, 0x1e44 0x1e48]
        (and (emc2 (byte \N))
            (emc2 0xd1)
            (emc2 0x143) (emc2 0x145) (emc2 0x147)
            (emc2 0x1e44) (emc2 0x1e48))

       [(byte \n), 0xf1, 0x144 0x146 0x148 0x149, 0x1e45 0x1e49]
        (and (emc2 (byte \n))
            (emc2 0xf1)
            (emc2 0x144) (emc2 0x146) (emc2 0x148) (emc2 0x149)
            (emc2 0x1e45) (emc2 0x1e49))

       [(byte \O), 0xd2 0xd3 0xd4, 0xd5 0xd6 0xd8, 0x14c 0x14e 0x150, 0x1a0 0x1d1 0x1ea 0x1ec, 0x1ece]
        (and (emc2 (byte \O))
            (emc2 0xd2) (emc2 0xd3) (emc2 0xd4)
            (emc2 0xd5) (emc2 0xd6) (emc2 0xd8)
            (emc2 0x14c) (emc2 0x14e) (emc2 0x150)
            (emc2 0x1a0) (emc2 0x1d1) (emc2 0x1ea) (emc2 0x1ec)
            (emc2 0x1ece))

       [(byte \o), 0xf2 0xf3 0xf4, 0xf5 0xf6 0xf8, 0x14d 0x14f 0x151, 0x1a1 0x1d2 0x1eb 0x1ed, 0x1ecf]
        (and (emc2 (byte \o))
            (emc2 0xf2) (emc2 0xf3) (emc2 0xf4)
            (emc2 0xf5) (emc2 0xf6) (emc2 0xf8)
            (emc2 0x14d) (emc2 0x14f) (emc2 0x151)
            (emc2 0x1a1) (emc2 0x1d2) (emc2 0x1eb) (emc2 0x1ed)
            (emc2 0x1ecf))

       [(byte \P), 0x1e54 0x1e56]
        (and (emc2 (byte \P))
            (emc2 0x1e54) (emc2 0x1e56))

       [(byte \p), 0x1e55 0x1e57]
        (and (emc2 (byte \p))
            (emc2 0x1e55) (emc2 0x1e57))

       [(byte \R), 0x154 0x156 0x158, 0x1e58 0x1e5e]
        (and (emc2 (byte \R))
            (emc2 0x154) (emc2 0x156) (emc2 0x158)
            (emc2 0x1e58) (emc2 0x1e5e))

       [(byte \r), 0x155 0x157 0x159, 0x1e59 0x1e5f]
        (and (emc2 (byte \r))
            (emc2 0x155) (emc2 0x157) (emc2 0x159)
            (emc2 0x1e59) (emc2 0x1e5f))

       [(byte \S), 0x15a 0x15c 0x15e 0x160, 0x1e60]
        (and (emc2 (byte \S))
            (emc2 0x15a) (emc2 0x15c) (emc2 0x15e) (emc2 0x160)
            (emc2 0x1e60))

       [(byte \s), 0x15b 0x15d 0x15f 0x161, 0x1e61]
        (and (emc2 (byte \s))
            (emc2 0x15b) (emc2 0x15d) (emc2 0x15f) (emc2 0x161)
            (emc2 0x1e61))

       [(byte \T), 0x162 0x164 0x166, 0x1e6a 0x1e6e]
        (and (emc2 (byte \T))
            (emc2 0x162) (emc2 0x164) (emc2 0x166)
            (emc2 0x1e6a) (emc2 0x1e6e))

       [(byte \t), 0x163 0x165 0x167, 0x1e6b 0x1e6f 0x1e97]
        (and (emc2 (byte \t))
            (emc2 0x163) (emc2 0x165) (emc2 0x167)
            (emc2 0x1e6b) (emc2 0x1e6f) (emc2 0x1e97))

       [(byte \U), 0xd9 0xda 0xdb 0xdc, 0x168 0x16a 0x16c 0x16e, 0x170 0x172 0x1af 0x1d3, 0x1ee6]
        (and (emc2 (byte \U))
            (emc2 0xd9) (emc2 0xda) (emc2 0xdb) (emc2 0xdc)
            (emc2 0x168) (emc2 0x16a) (emc2 0x16c) (emc2 0x16e)
            (emc2 0x170) (emc2 0x172) (emc2 0x1af) (emc2 0x1d3)
            (emc2 0x1ee6))

       [(byte \u), 0xf9 0xfa 0xfb 0xfc, 0x169 0x16b 0x16d 0x16f, 0x171 0x173 0x1b0 0x1d4, 0x1ee7]
        (and (emc2 (byte \u))
            (emc2 0xf9) (emc2 0xfa) (emc2 0xfb) (emc2 0xfc)
            (emc2 0x169) (emc2 0x16b) (emc2 0x16d) (emc2 0x16f)
            (emc2 0x171) (emc2 0x173) (emc2 0x1b0) (emc2 0x1d4)
            (emc2 0x1ee7))

       [(byte \V), 0x1e7c]
        (and (emc2 (byte \V))
            (emc2 0x1e7c))

       [(byte \v), 0x1e7d]
        (and (emc2 (byte \v))
            (emc2 0x1e7d))

       [(byte \W), 0x174, 0x1e80 0x1e82 0x1e84 0x1e86]
        (and (emc2 (byte \W))
            (emc2 0x174)
            (emc2 0x1e80) (emc2 0x1e82) (emc2 0x1e84) (emc2 0x1e86))

       [(byte \w), 0x175, 0x1e81 0x1e83 0x1e85 0x1e87 0x1e98]
        (and (emc2 (byte \w))
            (emc2 0x175)
            (emc2 0x1e81) (emc2 0x1e83) (emc2 0x1e85) (emc2 0x1e87) (emc2 0x1e98))

       [(byte \X), 0x1e8a 0x1e8c]
        (and (emc2 (byte \X))
            (emc2 0x1e8a) (emc2 0x1e8c))

       [(byte \x), 0x1e8b 0x1e8d]
        (and (emc2 (byte \x))
            (emc2 0x1e8b) (emc2 0x1e8d))

       [(byte \Y), 0xdd, 0x176 0x178, 0x1e8e 0x1ef2 0x1ef6 0x1ef8]
        (and (emc2 (byte \Y))
            (emc2 0xdd)
            (emc2 0x176) (emc2 0x178)
            (emc2 0x1e8e) (emc2 0x1ef2) (emc2 0x1ef6) (emc2 0x1ef8))

       [(byte \y), 0xfd 0xff, 0x177, 0x1e8f 0x1e99 0x1ef3 0x1ef7 0x1ef9]
        (and (emc2 (byte \y))
            (emc2 0xfd) (emc2 0xff)
            (emc2 0x177)
            (emc2 0x1e8f) (emc2 0x1e99) (emc2 0x1ef3) (emc2 0x1ef7) (emc2 0x1ef9))

       [(byte \Z), 0x179 0x17b 0x17d 0x1b5, 0x1e90 0x1e94]
        (and (emc2 (byte \Z))
            (emc2 0x179) (emc2 0x17b) (emc2 0x17d) (emc2 0x1b5)
            (emc2 0x1e90) (emc2 0x1e94))

       [(byte \z), 0x17a 0x17c 0x17e 0x1b6, 0x1e91 0x1e95]
        (and (emc2 (byte \z))
            (emc2 0x17a) (emc2 0x17c) (emc2 0x17e) (emc2 0x1b6)
            (emc2 0x1e91) (emc2 0x1e95))

        ;; default: character itself
        (emc2 c)
    ))

;; Code to parse regular expression.
;;
;; We try to reuse parsing functions in regexp.c to
;; minimize surprise and keep the syntax consistent.

(defn- #_boolean nfa-regcoll- [#_int c, #_int extra, #_Bytes old_regparse]
    ;; [abc]  uses NFA_START_COLL - NFA_END_COLL
    ;; [^abc] uses NFA_START_NEG_COLL - NFA_END_NEG_COLL
    ;; Each character is produced as a regular state,
    ;; using NFA_CONCAT to bind them together.
    ;; Besides normal characters there can be:
    ;; - character classes  NFA_CLASS_*
    ;; - ranges, two characters followed by NFA_RANGE.
    (let [#_Bytes p @regparse #_Bytes endp (skip-anyof p)]
        (cond (at? endp (byte \]))
            ;; Try to reverse engineer character classes.  For example,
            ;; recognize that [0-9] stands for \d and [A-Za-z_] for \h,
            ;; and perform the necessary substitutions in the NFA.
            (let [#_int result (nfa-recognize-char-class @regparse, endp, (== extra NFA_ADD_NL))]
                (if (non-zero? result)
                    (do (if (<= NFA_FIRST_NL result NFA_LAST_NL)
                            (and (emc1 (- result NFA_ADD_NL)) (emc1 NFA_NEWL) (emc1 NFA_OR))
                            (emc1 result))
                        (reset! regparse endp)
                        (swap! regparse #(.plus % (us-ptr2len-cc %)))
                        true)
                    ;; Failed to recognize a character class.
                    ;; Use the simple version that turns [abc] into 'a' OR 'b' OR 'c'.
                    (let-when [#_boolean negated (at? @regparse (byte \^))
                          _ (if negated
                                (do (swap! regparse #(.plus % (us-ptr2len-cc %)))
                                    (emc1 NFA_START_NEG_COLL))
                                (emc1 NFA_START_COLL))
                          #_int startc
                            (let-when [startc (byte \-)] (at? @regparse startc) => -1
                                (swap! regparse #(.plus % (us-ptr2len-cc %)))
                                (emc2 startc)
                                startc)
                          [extra :as _]
                            ;; Emit the OR branches for each character in the [].
                            (loop-when [startc startc #_boolean emit_range false extra extra] (BLT @regparse, endp) => [extra]
                                (let-when [#_int oldstartc startc
                                      [startc recur? :as _]
                                        (if (at? @regparse (byte \[))
                                            ;; Check for [: :], [= =], [. .].
                                            (let [#_int charclass (get-char-class regparse)
                                                  #_int equiclass (if (== charclass CLASS_NONE) (get-equi-class regparse) 0)
                                                  #_int collclass (if (and (== charclass CLASS_NONE) (zero? equiclass)) (get-coll-element regparse) 0)]
                                                ;; Character class like [:alpha:].
                                                (cond (!= charclass CLASS_NONE)
                                                    (do (condp == charclass
                                                            CLASS_ALNUM     (emc2 NFA_CLASS_ALNUM)
                                                            CLASS_ALPHA     (emc2 NFA_CLASS_ALPHA)
                                                            CLASS_BLANK     (emc2 NFA_CLASS_BLANK)
                                                            CLASS_CNTRL     (emc2 NFA_CLASS_CNTRL)
                                                            CLASS_DIGIT     (emc2 NFA_CLASS_DIGIT)
                                                            CLASS_GRAPH     (emc2 NFA_CLASS_GRAPH)
                                                            CLASS_LOWER     (emc2 NFA_CLASS_LOWER)
                                                            CLASS_PRINT     (emc2 NFA_CLASS_PRINT)
                                                            CLASS_PUNCT     (emc2 NFA_CLASS_PUNCT)
                                                            CLASS_SPACE     (emc2 NFA_CLASS_SPACE)
                                                            CLASS_UPPER     (emc2 NFA_CLASS_UPPER)
                                                            CLASS_XDIGIT    (emc2 NFA_CLASS_XDIGIT)
                                                            CLASS_TAB       (emc2 NFA_CLASS_TAB)
                                                            CLASS_RETURN    (emc2 NFA_CLASS_RETURN)
                                                            CLASS_BACKSPACE (emc2 NFA_CLASS_BACKSPACE)
                                                            CLASS_ESCAPE    (emc2 NFA_CLASS_ESCAPE)
                                                        )
                                                        [-1 true])
                                                ;; Try equivalence class [=a=] and the like.
                                                (non-zero? equiclass)
                                                    (if-not (nfa-emit-equi-class equiclass)
                                                        (do ;; should never happen
                                                            (emsg (u8 "E868: Error building NFA with equivalence class!"))
                                                            (reset! rc_did_emsg true)
                                                            nil)
                                                        [-1 true])
                                                ;; Try collating class like [. .].
                                                (non-zero? collclass)
                                                    ;; Will emit the proper atom at the end of the while loop.
                                                    [collclass false]     ;; allow [.a.]-x as a range
                                                :else
                                                    [-1 false]
                                                ))
                                            [-1 false])
                                ] (some? _) => nil
                                    (cond recur?
                                        (recur startc emit_range extra)
                                    ;; Try a range like 'a-x' or '\t-z'.  Also allows '-' as a start character.
                                    (and (at? @regparse (byte \-)) (!= oldstartc -1))
                                        (do (swap! regparse #(.plus % (us-ptr2len-cc %)))
                                            (recur oldstartc true extra))       ;; reading the end of the range
                                    :else
                                        ;; Now handle simple and escaped characters.
                                        ;; Only "\]", "\^", "\]" and "\\" are special in Vi.
                                        ;; Vim accepts "\t", "\e", etc., but only when the 'l' flag in 'cpoptions' is not included.
                                        ;; Posix doesn't recognize backslash at all.
                                        (let-when [[startc #_boolean got_coll_char]
                                                (if (and (at? @regparse (byte \\)) (not @reg_cpo_bsl) (BLE (.plus @regparse 1), endp)
                                                         (or (some? (vim-strchr REGEXP_INRANGE, (.at @regparse 1)))
                                                             (and (not @reg_cpo_lit) (some? (vim-strchr REGEXP_ABBR, (.at @regparse 1))))))
                                                    (do (swap! regparse #(.plus % (us-ptr2len-cc %)))
                                                        (let [#_int c (.at @regparse 0)]
                                                            (cond (== c (byte \n))
                                                                [(if @reg_string NL NFA_NEWL) false]
                                                            (any == c (byte \d) (byte \o) (byte \x) (byte \u) (byte \U))
                                                                (let [startc (coll-get-char)] ;; TODO(RE) This needs more testing.
                                                                    (swap! regparse #(.minus % (us-ptr-back old_regparse, %)))
                                                                    [startc true])
                                                            :else ;; \r,\t,\e,\b
                                                                [(backslash-trans c) false])
                                                        ))
                                                    [startc false])
                                              ;; Normal printable char.
                                              startc (if (== startc -1) (us-ptr2char @regparse) startc)
                                              [startc emit_range extra :as _]
                                                ;; Previous char was '-', so this char is end of range.
                                                (cond emit_range
                                                    (let [#_int endc startc startc oldstartc]
                                                        (if (< endc startc)
                                                            (do (emsg e_invrange)
                                                                (reset! rc_did_emsg true)
                                                                nil)
                                                            (do
                                                                (cond (< (+ startc 2) endc)
                                                                (do ;; Emit a range instead of the sequence of individual characters.
                                                                    (if (zero? startc)
                                                                        (emc1 1) ;; \x00 is translated to \x0a, start at \x01
                                                                        (swap! post_index dec)) ;; remove NFA_CONCAT
                                                                    (and (emc1 endc) (emc1 NFA_RANGE) (emc1 NFA_CONCAT)))
                                                                :else ;; Emit the range.  "startc" was already emitted, so skip it.
                                                                    (loop-when-recur [#_int c (inc startc)] (<= c endc) [(inc c)] (emc2 c)))
                                                                [-1 false extra])
                                                        ))
                                                :else
                                                    ;; This char (startc) is not part of a range.  Normally, just emit it.
                                                    ;; But if we get NUL from a collating char, then replace it with 0x0a.
                                                    ;; Needed to completely mimic the behaviour of the backtracking engine.
                                                    (let [extra (if (== startc NFA_NEWL)
                                                                    ;; Line break can't be matched as part of the collection,
                                                                    ;; add an OR below.  But not for negated range.
                                                                    (if (not negated) NFA_ADD_NL extra)
                                                                    (do (emc2 (if (and got_coll_char (zero? startc)) 0x0a startc)) extra)
                                                                )]
                                                        [startc emit_range extra]
                                                    ))
                                        ] (some? _) => nil
                                            (swap! regparse #(.plus % (us-ptr2len-cc %)))
                                            (recur startc emit_range extra)
                                        ))
                                ))
                    ] (some? _) => false
                        (swap! regparse #(.minus % (us-ptr-back old_regparse, %)))
                        (when (at? @regparse (byte \-))       ;; if last, '-' is just a char
                            (emc2 (byte \-)))
                        ;; skip the trailing ]
                        (reset! regparse endp)
                        (swap! regparse #(.plus % (us-ptr2len-cc %)))
                        ;; Mark end of the collection.
                        (emc1 (if negated NFA_END_NEG_COLL NFA_END_COLL))
                        ;; \_[] also matches \n but it's not negated
                        (when (== extra NFA_ADD_NL)
                            (emc1 (if @reg_string NL NFA_NEWL))
                            (emc1 NFA_OR))
                        true)
                ))
        @reg_strict
            (do (emsg e_missingbracket)
                (reset! rc_did_emsg true)
                false)
        :else
            (nfa-do-multibyte c, old_regparse))
    ))

(defn- #_boolean nfa-regclass- [#_int c, #_int extra, #_Bytes old_regparse]
    (let [#_Bytes p (vim-strchr classchars, (no-Magic c))]
        (cond (nil? p)
            (if (== extra NFA_ADD_NL)
                (do (emsgn e_ill_char_class, (long c))
                    (reset! rc_did_emsg true)
                    false)
                (do (emsgn (u8 "INTERNAL: Unknown character class char: %ld"), (long c))
                    false
                ))
        ;; When '.' is followed by a composing char ignore the dot, so that the composing char is matched here.
        (and (== c (Magic (byte \.))) (utf-iscomposing (peekchr)))
            (let [old_regparse @regparse c (getchr)]
                (nfa-do-multibyte c, old_regparse))
        :else
            (do (emc1 (... nfa_classcodes (BDIFF p, classchars)))
                (when (== extra NFA_ADD_NL)
                    (emc1 NFA_NEWL)
                    (emc1 NFA_OR)
                    (swap! regflags | RF_HASNL))
                true
            ))
    ))

;; Parse the lowest level.
;;
;; An atom can be one of a long list of items.
;; Many atoms match one character in the text.
;; It is often an ordinary character or a character class.
;; Braces can be used to make a pattern into an atom.
;; The "\z(\)" construct is only for syntax highlighting.
;;
;; atom    ::=     ordinary-atom
;;     or  \( pattern \)
;;     or  \%( pattern \)
;;     or  \z( pattern \)

(defn- #_boolean nfa-regatom []
    (let [#_Bytes old_regparse @regparse #_int c (getchr)]
        (condp ==? c
            NUL (do (emsg e_nul_found) (reset! rc_did_emsg true) false)

            (Magic (byte \^)) (emc1 NFA_BOL)
            (Magic (byte \$)) (emc1 NFA_EOL)
            (Magic (byte \<)) (emc1 NFA_BOW)
            (Magic (byte \>)) (emc1 NFA_EOW)

            (Magic (byte \_))
                (let [c (no-Magic (getchr))]
                    (condp == c
                        NUL       (do (emsg e_nul_found) (reset! rc_did_emsg true) false)
                        (byte \^) (emc1 NFA_BOL)                                 ;; "\_^" is start-of-line
                        (byte \$) (emc1 NFA_EOL)                                 ;; "\_$" is end-of-line
                        (byte \[) (nfa-regcoll- c, NFA_ADD_NL, old_regparse)     ;; "\_[" is collection plus newline
                        #_else    (nfa-regclass- c, NFA_ADD_NL, old_regparse)    ;; "\_x" is character class plus newline
                    ))

           [(Magic (byte \.))                   ;; Character classes.
            (Magic (byte \i)) (Magic (byte \I))
            (Magic (byte \k)) (Magic (byte \K))
            (Magic (byte \f)) (Magic (byte \F))
            (Magic (byte \p)) (Magic (byte \P))
            (Magic (byte \s)) (Magic (byte \S))
            (Magic (byte \d)) (Magic (byte \D))
            (Magic (byte \x)) (Magic (byte \X))
            (Magic (byte \o)) (Magic (byte \O))
            (Magic (byte \w)) (Magic (byte \W))
            (Magic (byte \h)) (Magic (byte \H))
            (Magic (byte \a)) (Magic (byte \A))
            (Magic (byte \l)) (Magic (byte \L))
            (Magic (byte \u)) (Magic (byte \U))] (nfa-regclass- c, 0, old_regparse)

            (Magic (byte \n))
                ;; In a string "\n" matches a newline character.  ;; In buffer text "\n" matches the end of a line.
                (if @reg_string (emc1 NL) (do (emc1 NFA_NEWL) (swap! regflags | RF_HASNL) true))

            (Magic (byte \()) (nfa-reg REG_PAREN) ;; false: cascaded error

           [(Magic (byte \|)) (Magic (byte \&)) (Magic (byte \)))]
                (do (emsgn e_misplaced, (long (no-Magic c))) false)

           [(Magic (byte \=)) (Magic (byte \?)) (Magic (byte \+)) (Magic (byte \@)) (Magic (byte \*)) (Magic (byte \{))]
                ;; these should follow an atom, not form an atom
                (do (emsgn e_misplaced, (long (no-Magic c))) false)

            (Magic (byte \~))
                ;; Previous substitute pattern.  ;; Generated as "\%(pattern\)".
                (let-when [#_Bytes s @reg_prev_sub] (some? s) => (do (emsg e_nopresub) false)
                    (loop-when-recur [#_int i 0] (non-eos? s i) [(+ i (us-ptr2len s, i))]
                        (emc1 (us-ptr2char s, i))
                        (when (pos? i)
                            (emc1 NFA_CONCAT)))
                    (emc1 NFA_NOPEN))

           [(Magic (byte \1)) (Magic (byte \2)) (Magic (byte \3)) (Magic (byte \4)) (Magic (byte \5)) (Magic (byte \6)) (Magic (byte \7)) (Magic (byte \8)) (Magic (byte \9))]
                (do (emc1 (+ NFA_BACKREF1 (- (no-Magic c) (byte \1)))) (reset! nfa_has_backref true) true)

            (Magic (byte \z))
                (let [c (no-Magic (getchr))]
                    (condp ==? c
                        (byte \s) (do (emc1 NFA_ZSTART)                          (re-mult-next (u8 "\\zs")))
                        (byte \e) (do (emc1 NFA_ZEND) (reset! nfa_has_zend true) (re-mult-next (u8 "\\ze")))

                       [(byte \1) (byte \2) (byte \3) (byte \4) (byte \5) (byte \6) (byte \7) (byte \8) (byte \9)] ;; \z1...\z9
                            (if (!= @reg_do_extmatch REX_USE)
                                (do (emsg e_z1_not_allowed) (reset! rc_did_emsg true) false)
                                ;; No need to set nfa_has_backref, the sub-matches don't change when \z1 .. \z9 matches or not.
                                (do (emc1 (+ NFA_ZREF1 (- (no-Magic c) (byte \1)))) (reset! re_has_z REX_USE) true))

                        (byte \() ;; \z(    ;; sic!)
                            (cond (!= @reg_do_extmatch REX_SET)
                                (do (emsg e_z_not_allowed) (reset! rc_did_emsg true) false)
                            (nfa-reg REG_ZPAREN)
                                (do (reset! re_has_z REX_SET) true)
                            :else
                                false) ;; cascaded error

                        (do (emsgn (u8 "E867: (NFA) Unknown operator '\\z%c'"), (long (no-Magic c))) false)
                    ))

            (Magic (byte \%))
                (let [c (no-Magic (getchr))]
                    (condp ==? c
                        (byte \() (and (nfa-reg REG_NPAREN) (emc1 NFA_NOPEN)) ;; () without a back reference

                       [(byte \d)   ;; %d123 decimal
                        (byte \o)   ;; %o123 octal
                        (byte \x)   ;; %xab hex 2
                        (byte \u)   ;; %uabcd hex 4
                        (byte \U)]  ;; %U1234abcd hex 8
                        (let [#_int nr (condp == c
                                (byte \d) (getdecchrs)
                                (byte \o) (getoctchrs)
                                (byte \x) (gethexchrs 2)
                                (byte \u) (gethexchrs 4)
                                (byte \U) (gethexchrs 8)
                                          -1)]
                            (if (< nr 0)
                                (do (emsg2 (u8 "E678: Invalid character after %s%%[dxouU]"), (if (== @reg_magic MAGIC_ALL) (u8 "") (u8 "\\")))
                                    (reset! rc_did_emsg true)
                                    false)
                                ;; A NUL is stored in the text as NL.
                                ;; TODO: what if a composing character follows?
                                (emc1 (if (zero? nr) 0x0a nr))
                            ))

                        ;; Catch \%^ and \%$ regardless of where they appear in the pattern -- regardless of whether or not it makes sense.
                        (byte \^) (emc1 NFA_BOF)
                        (byte \$) (emc1 NFA_EOF)
                        (byte \#) (emc1 NFA_CURSOR)
                        (byte \V) (emc1 NFA_VISUAL)
                        (byte \C) (emc1 NFA_ANY_COMPOSING)

                        (byte \[) ;; \%[abc]
                            (let-when [[#_int n c :as _]
                                (loop-when [n 0 c (peekchr)] (!= c (byte \])) => [n c]
                                    (cond (== c NUL)
                                        (do (emsg2 e_missing_sb, (if (== @reg_magic MAGIC_ALL) (u8 "") (u8 "\\")))
                                            (reset! rc_did_emsg true)
                                            nil)
                                    (nfa-regatom) ;; recursive call!
                                        (recur (inc n) (peekchr))
                                    ))
                            ] (some? _) => false
                                (getchr)       ;; get the ]
                                (if (zero? n)
                                    (do (emsg2 e_empty_sb, (if (== @reg_magic MAGIC_ALL) (u8 "") (u8 "\\")))
                                        (reset! rc_did_emsg true)
                                        false)
                                    (do
                                        (emc1 NFA_OPT_CHARS)
                                        (emc1 n)

                                        ;; Emit as "\%(\%[abc]\)" to be able to handle "\%[abc]*" which would
                                        ;; cause the empty string to be matched an unlimited number of times.
                                        ;; NFA_NOPEN is added only once at a position, while NFA_SPLIT is added
                                        ;; multiple times.  This is more efficient than not allowing NFA_SPLIT
                                        ;; multiple times, it is used a lot.

                                        (emc1 NFA_NOPEN))
                                ))

                        (let [#_int cmp c [#_int n c]
                                (loop-when-recur [n 0 c (if (any == c (byte \<) (byte \>)) (getchr) c)] (asc-isdigit c) [(+ (* n 10) (- c (byte \0))) (getchr)] => [n c])]
                            (cond (any == c (byte \l) (byte \c) (byte \v))
                            (do
                                (condp == c
                                    (byte \l) (emc1 (condp == cmp (byte \<) NFA_LNUM_LT (byte \>) NFA_LNUM_GT NFA_LNUM)) ;; \%{n}l  \%{n}<l  \%{n}>l
                                    (byte \c) (emc1 (condp == cmp (byte \<) NFA_COL_LT  (byte \>) NFA_COL_GT  NFA_COL))  ;; \%{n}c  \%{n}<c  \%{n}>c
                                    (byte \v) (emc1 (condp == cmp (byte \<) NFA_VCOL_LT (byte \>) NFA_VCOL_GT NFA_VCOL)) ;; \%{n}v  \%{n}<v  \%{n}>v
                                )
                                (emc1 n)
                            )
                            (and (== c (byte \')) (zero? n))
                            (do
                                (emc1 (condp == cmp (byte \<) NFA_MARK_LT (byte \>) NFA_MARK_GT NFA_MARK)) ;; \%'m  \%<'m  \%>'m
                                (emc1 (getchr))
                            )
                            :else
                            (do
                                (emsgn (u8 "E867: (NFA) Unknown operator '\\%%%c'"), (long (no-Magic c)))
                                false
                            ))
                        )
                    ))

            (Magic (byte \[)) (nfa-regcoll- c, 0, old_regparse)

            #_else            (nfa-do-multibyte c, old_regparse))
    ))

(defn- #_final #_boolean nfa-do-multibyte [#_int c, #_Bytes old_regparse]
    ;; plen is length of current char with composing chars
    (let-when [#_int plen (us-ptr2len-cc old_regparse)] (or (!= (utf-char2len c) plen) (utf-iscomposing c)) => (emc1 (no-Magic c))
        ;; A base character plus composing characters, or just one or more composing characters.
        ;; This requires creating a separate atom as if enclosing the characters in (), where
        ;; NFA_COMPOSING is the ( and NFA_END_COMPOSING is the ).
        ;; Note that right now we are building the postfix form, not the NFA itself; a composing
        ;; char could be: a, b, c, NFA_COMPOSING where 'b' and 'c' are chars with codes > 256.
        (loop [#_int i 0 c c]
            (emc1 c)
            (when (< 0 i)
                (emc1 NFA_CONCAT))
            (let [i (+ i (utf-char2len c))]
                (recur-if (< i plen) [i (us-ptr2char old_regparse, i)])
            ))
        (emc1 NFA_COMPOSING)
        (reset! regparse (.plus old_regparse plen)))
    true)

;; Parse something followed by possible [*+=].
;;
;; A piece is an atom, possibly followed by a multi, an indication of how many
;; times the atom can be matched.  Example: "a*" matches any sequence of "a"
;; characters: "", "a", "aa", etc.
;;
;; piece   ::=      atom
;;      or  atom  multi

(defn- #_boolean nfa-regpiece []
    ;; Save the current parse state, so that we can use it if <atom>{m,n} is next.
    (let-when [#_parse_state_C old_state (save-parse-state)
          ;; store current pos in the postfix form for \{m,n} involving 0s
          #_int my_post_start @post_index
    ] (nfa-regatom) => false           ;; cascaded error

        (let-when [#_int op (peekchr)] (!= (re-multi-type op) NOT_MULTI) => true
            (skipchr)

            (let-when [_ (condp ==? op
                (Magic (byte \*)) (do (emc1 NFA_STAR) nil)
                (Magic (byte \+))
                    (do ;; Trick:  Normally, (a*)\+ would match the whole input "aaa".  The first and
                        ;; only submatch would be "aaa".  But the backtracking engine interprets the
                        ;; plus as "try matching one more time", and a* matches a second time at the
                        ;; end of the input, the empty string.  The submatch will be the empty string.
                        ;;
                        ;; In order to be consistent with the old engine,
                        ;; we replace <atom>+ with <atom><atom>*
                        (restore-parse-state old_state)
                        (reset! curchr -1)
                        (if (nfa-regatom)
                            (do (emc1 NFA_STAR) (emc1 NFA_CONCAT) (skipchr) nil) ;; skip the \+
                            false
                        ))
                (Magic (byte \@))
                    (let [#_int c2 (getdecchrs) op (no-Magic (getchr))
                          [op #_int i]
                            (condp == op
                                (byte \=) [op NFA_PREV_ATOM_NO_WIDTH]                       ;; \@=
                                (byte \!) [op NFA_PREV_ATOM_NO_WIDTH_NEG]                   ;; \@!
                                (byte \<)
                                    (let [op (no-Magic (getchr))]
                                        (condp == op
                                            (byte \=) [op NFA_PREV_ATOM_JUST_BEFORE]        ;; \@<=
                                            (byte \!) [op NFA_PREV_ATOM_JUST_BEFORE_NEG]    ;; \@<!
                                                      [op 0]))
                                (byte \>) [op NFA_PREV_ATOM_LIKE_PATTERN]                   ;; \@>
                                          [op 0]
                            )]
                        (if (zero? i)
                            (do (emsgn (u8 "E869: (NFA) Unknown operator '\\@%c'"), (long op)) false)
                            (do (emc1 i)
                                (when (any == i NFA_PREV_ATOM_JUST_BEFORE NFA_PREV_ATOM_JUST_BEFORE_NEG)
                                    (emc1 c2))
                                nil)
                        ))
               [(Magic (byte \?)) (Magic (byte \=))] (do (emc1 NFA_QUEST) nil)
                (Magic (byte \{))
                    ;; a{2,5} will expand to 'aaa?a?a?'
                    ;; a{-1,3} will expand to 'aa??a??', where ?? is the nongreedy version of '?'
                    ;; \v(ab){2,3} will expand to '(ab)(ab)(ab)?', where all the parenthesis have the same id
                    (let [#_int c2 (peekchr)
                          #_boolean greedy (if (any == c2 (byte \-) (Magic (byte \-))) (do (skipchr) false) true)
                          a'minval (atom (long)) a'maxval (atom (long))]

                        (cond (not (read-limits a'minval, a'maxval))
                            (do (emsg (u8 "E870: (NFA regexp) Error reading repetition limits"))
                                (reset! rc_did_emsg true)
                                false)
                        ;; <atom>{0,inf}, <atom>{0,} and <atom>{} are equivalent to <atom>*
                        (and (zero? @a'minval) (== @a'maxval MAX_LIMIT))
                            (do (if greedy
                                    (emc1 NFA_STAR)             ;; {{   ;; \{}, \{0,}
                                    (emc1 NFA_STAR_NONGREEDY))  ;; {{   ;; \{-}, \{-0,}
                                nil)
                        ;; Special case: x{0} or x{-0}.
                        (zero? @a'maxval)
                            (do ;; Ignore result of previous call to nfa-regatom().
                                (reset! post_index my_post_start)
                                ;; NFA_EMPTY is 0-length and works everywhere.
                                (emc1 NFA_EMPTY)
                                true)
                        ;; The engine is very inefficient (uses too many states) when the maximum
                        ;; is much larger than the minimum and when the maximum is large.
                        ;; Bail out if we can use the other engine.
                        (and (flag? @nfa_re_flags RE_AUTO) (< (min (+ @a'minval 200) 500) @a'maxval))
                            false
                        :else     ;; Ignore previous call to nfa-regatom().
                            (let-when [_ (reset! post_index my_post_start)
                                  ;; Save parse state after the repeated atom and the \{}.
                                  #_parse_state_C new_state (save-parse-state)
                                  #_int quest (if greedy NFA_QUEST NFA_QUEST_NONGREEDY)
                                  _ (loop-when [#_int i 0] (< i @a'maxval) => nil
                                        ;; Goto beginning of the repeated atom.
                                        (restore-parse-state old_state)
                                        (let [#_int old_post_pos @post_index]
                                            (if (nfa-regatom)
                                                (do ;; after "minval" times, atoms are optional
                                                    (when (< @a'minval (inc i))
                                                        (if (== @a'maxval MAX_LIMIT)
                                                            (emc1 (if greedy NFA_STAR NFA_STAR_NONGREEDY))
                                                            (emc1 quest)
                                                        ))
                                                    (when (!= old_post_pos my_post_start)
                                                        (emc1 NFA_CONCAT))
                                                    (if (and (< @a'minval (inc i)) (== @a'maxval MAX_LIMIT))
                                                        nil
                                                        (recur (inc i))
                                                    ))
                                                false
                                            ))
                                    )] (nil? _) => _
                                ;; Go to just after the repeated atom and the \{}.
                                (restore-parse-state new_state)
                                (reset! curchr -1)
                                nil)
                        ))
                nil)] (nil? _) => _

                (if (!= (re-multi-type (peekchr)) NOT_MULTI)
                    (do (emsg (u8 "E871: (NFA regexp) Can't have a multi follow a multi !"))
                        (reset! rc_did_emsg true)
                        false)
                    true)
            ))
    ))

;; Parse one or more pieces, concatenated.  It matches a match for the
;; first piece, followed by a match for the second piece, etc.  Example:
;; "f[0-9]b", first matches "f", then a digit and then "b".
;;
;; concat  ::=      piece
;;      or  piece piece
;;      or  piece piece piece
;;      etc.

(defn- #_boolean nfa-regconcat []
    (loop [#_boolean first true]
        (condp ==? (peekchr)
           [NUL
            (Magic (byte \|))
            (Magic (byte \&))
            (Magic (byte \)))]
                true

            (Magic (byte \Z)) (do (swap! regflags | RF_ICOMBINE) (skipchr-keepstart)                    (recur first))
            (Magic (byte \c)) (do (swap! regflags | RF_ICASE)    (skipchr-keepstart)                    (recur first))
            (Magic (byte \C)) (do (swap! regflags | RF_NOICASE)  (skipchr-keepstart)                    (recur first))

            (Magic (byte \v)) (do (reset! reg_magic MAGIC_ALL)   (skipchr-keepstart) (reset! curchr -1) (recur first))
            (Magic (byte \m)) (do (reset! reg_magic MAGIC_ON)    (skipchr-keepstart) (reset! curchr -1) (recur first))
            (Magic (byte \M)) (do (reset! reg_magic MAGIC_OFF)   (skipchr-keepstart) (reset! curchr -1) (recur first))
            (Magic (byte \V)) (do (reset! reg_magic MAGIC_NONE)  (skipchr-keepstart) (reset! curchr -1) (recur first))

            ;; :else
            (if (not (nfa-regpiece))
                false
                (do
                    (when (not first) (emc1 NFA_CONCAT))
                    (recur false)
                )
            ))
    ))

;; Parse a branch, one or more concats, separated by "\&".  It matches the
;; last concat, but only if all the preceding concats also match at the same
;; position.  Examples:
;;      "foobeep\&..." matches "foo" in "foobeep".
;;      ".*Peter\&.*Bob" matches in a line containing both "Peter" and "Bob"
;;
;; branch ::=       concat
;;              or  concat \& concat
;;              or  concat \& concat \& concat
;;              etc.

(defn- #_boolean nfa-regbranch []
    (let [i @post_index]
        (if (not (nfa-regconcat)) ;; first branch, possibly the only one
            false
            (let [i (loop-when i (== (peekchr) (Magic (byte \&))) => i ;; try next concats
                        (skipchr)
                        (emc1 NFA_NOPEN)
                        (emc1 NFA_PREV_ATOM_NO_WIDTH)
                        (let [i @post_index]
                            (if (not (nfa-regconcat))
                                false
                                (do ;; if concat is empty, emit a node
                                    (when (== @post_index i) (emc1 NFA_EMPTY))
                                    (emc1 NFA_CONCAT)
                                    (recur i)
                                ))
                        ))]
                (if i
                    (do ;; if branch is empty, emit a node
                        (when (== @post_index i) (emc1 NFA_EMPTY))
                        true
                    )
                    false
                )
            ))
    ))

;; Parse a pattern, one or more branches, separated by "\|".
;; It matches anything that matches one of the branches.
;; Example: "foo\|beep" matches "foo" and matches "beep".
;; If more than one branch matches, the first one is used.
;;
;; pattern ::=     branch
;;     or  branch \| branch
;;     or  branch \| branch \| branch
;;     etc.
;;
;; paren: REG_NOPAREN, REG_PAREN, REG_NPAREN or REG_ZPAREN

(defn- #_boolean nfa-reg [#_int paren]
    (let-when [[#_int parno :as _]
            (condp == paren
                REG_PAREN
                    (if (<= NSUBEXP @regnpar)
                        (do (emsg (u8 "E872: (NFA regexp) Too many '('"))
                            (reset! rc_did_emsg true)
                            nil)
                        (let [parno @regnpar]
                            (swap! regnpar inc)
                            [parno]
                        ))
                REG_ZPAREN ;; Make a ZOPEN node.
                    (if (<= NSUBEXP @regnzpar)
                        (do (emsg (u8 "E879: (NFA regexp) Too many \\z("))
                            (reset! rc_did_emsg true)
                            nil)
                        (let [parno @regnzpar]
                            (swap! regnzpar inc)
                            [parno]
                        ))
                [0]
            )] (and (some? _) (nfa-regbranch)) => false

        (let-when [_
                (loop-when [] (== (peekchr) (Magic (byte \|))) => :_
                    (skipchr)
                    (when (nfa-regbranch) (emc1 NFA_OR) (recur))
                )] (some? _) => false

            ;; Check for proper termination.
            (cond (and (!= paren REG_NOPAREN) (!= (getchr) (Magic (byte \)))))
                (do (if (== paren REG_NPAREN)
                        (emsg2 e_unmatchedpp, (if (== @reg_magic MAGIC_ALL) (u8 "") (u8 "\\")))
                        (emsg2 e_unmatchedp,  (if (== @reg_magic MAGIC_ALL) (u8 "") (u8 "\\"))))
                    (reset! rc_did_emsg true)
                    false)
            (and (== paren REG_NOPAREN) (!= (peekchr) NUL))
                (do (if (== (peekchr) (Magic (byte \))))
                        (emsg2 e_unmatchedpar, (if (== @reg_magic MAGIC_ALL) (u8 "") (u8 "\\")))
                        (emsg (u8 "E873: (NFA regexp) proper termination error")))
                    (reset! rc_did_emsg true)
                    false)
            :else ;; Here we set the flag allowing back references to this set of parentheses.
                (do (condp == paren
                        REG_PAREN
                            (do (swap! had_endbrace assoc parno true)     ;; have seen the close paren
                                (emc1 (+ NFA_MOPEN parno)))
                        REG_ZPAREN
                            (emc1 (+ NFA_ZOPEN parno))
                        nil)
                    true)
            ))
    ))

;; Parse r.e. @expr and convert it into postfix form.
;; Return the postfix string on success, null otherwise.

(defn- #_int* re2post []
    (when (nfa-reg REG_NOPAREN) (emc1 NFA_MOPEN) @post_array))

;; Represents an NFA state plus zero or one or two arrows exiting.
;; if c == MATCH, no arrows out; matching state.
;; If c == SPLIT, unlabeled arrows to out0 and out1 (if != null).
;; If c < 256, labeled arrow with character c to out0.

(atom! nfa_state_C* nfa_states) ;; points to nfa_prog.states

;; Allocate and initialize nfa_state_C.

(defn- #_nfa_state_C alloc-state [#_nfa_regprog_C prog, #_int c, #_nfa_state_C out0, #_nfa_state_C out1]
    (ยง
        (if (<= (:nstate prog) (:istate prog))
            ((ร RETURN) nil)
        )

        ((ร nfa_state_C state =) (ร @nfa_states[prog.istate++] =) (NEW_nfa_state_C))

        ((ร state =) (assoc state :c c))
        (.out0 state out0)
        (.out1 state out1)
        ((ร state =) (assoc state :val 0))

        ((ร state =) (assoc state :id (:istate prog)))
        ((ร state.lastlist[0] =) 0)
        ((ร state.lastlist[1] =) 0)

        state
    ))

;; Estimate the maximum byte length of anything matching "state".
;; When unknown or unlimited return -1.

(defn- #_int nfa-max-width [#_nfa_state_C startstate, #_int depth]
    (if (< 4 depth) ;; detect looping in a NFA_SPLIT
        -1
        (loop-when [#_int len 0 #_nfa_state_C state startstate] (some? state) => -1 ;; unrecognized, "cannot happen"
            (condp ==? (:c state)
               [NFA_END_INVISIBLE
                NFA_END_INVISIBLE_NEG]
                    len ;; the end, return what we have

                NFA_SPLIT
                    ;; two alternatives, use the maximum
                    (let [l (nfa-max-width (.out0 state), (inc depth)) r (nfa-max-width (.out1 state), (inc depth))]
                        (if (or (neg? l) (neg? r)) -1 (+ len (max l r))))

               [NFA_ANY
                NFA_START_COLL
                NFA_START_NEG_COLL]
                    ;; matches some character, including composing chars
                    (recur (+ len MB_MAXBYTES) (if (!= (:c state) NFA_ANY) (.. state (out1) (out0)) (.out0 state)))

               [NFA_DIGIT
                NFA_WHITE
                NFA_HEX
                NFA_OCTAL]
                    (recur (inc len) (.out0 state)) ;; ascii

               [NFA_IDENT
                NFA_SIDENT
                NFA_KWORD
                NFA_SKWORD
                NFA_FNAME
                NFA_SFNAME
                NFA_PRINT
                NFA_SPRINT
                NFA_NWHITE
                NFA_NDIGIT
                NFA_NHEX
                NFA_NOCTAL
                NFA_WORD
                NFA_NWORD
                NFA_HEAD
                NFA_NHEAD
                NFA_ALPHA
                NFA_NALPHA
                NFA_LOWER
                NFA_NLOWER
                NFA_UPPER
                NFA_NUPPER
                NFA_LOWER_IC
                NFA_NLOWER_IC
                NFA_UPPER_IC
                NFA_NUPPER_IC
                NFA_ANY_COMPOSING]
                    (recur (+ len 3) (.out0 state)) ;; possibly non-ascii

               [NFA_START_INVISIBLE
                NFA_START_INVISIBLE_NEG
                NFA_START_INVISIBLE_BEFORE
                NFA_START_INVISIBLE_BEFORE_NEG]
                    (recur len (.. state (out1) (out0))) ;; zero-width, out1 points to the END state

               [NFA_BACKREF1
                NFA_BACKREF2
                NFA_BACKREF3
                NFA_BACKREF4
                NFA_BACKREF5
                NFA_BACKREF6
                NFA_BACKREF7
                NFA_BACKREF8
                NFA_BACKREF9
                NFA_ZREF1
                NFA_ZREF2
                NFA_ZREF3
                NFA_ZREF4
                NFA_ZREF5
                NFA_ZREF6
                NFA_ZREF7
                NFA_ZREF8
                NFA_ZREF9
                NFA_NEWL
                NFA_SKIP]
                    -1 ;; unknown width

               [NFA_BOL
                NFA_EOL
                NFA_BOF
                NFA_EOF
                NFA_BOW
                NFA_EOW
                NFA_MOPEN
                NFA_MOPEN1
                NFA_MOPEN2
                NFA_MOPEN3
                NFA_MOPEN4
                NFA_MOPEN5
                NFA_MOPEN6
                NFA_MOPEN7
                NFA_MOPEN8
                NFA_MOPEN9
                NFA_ZOPEN
                NFA_ZOPEN1
                NFA_ZOPEN2
                NFA_ZOPEN3
                NFA_ZOPEN4
                NFA_ZOPEN5
                NFA_ZOPEN6
                NFA_ZOPEN7
                NFA_ZOPEN8
                NFA_ZOPEN9
                NFA_ZCLOSE
                NFA_ZCLOSE1
                NFA_ZCLOSE2
                NFA_ZCLOSE3
                NFA_ZCLOSE4
                NFA_ZCLOSE5
                NFA_ZCLOSE6
                NFA_ZCLOSE7
                NFA_ZCLOSE8
                NFA_ZCLOSE9
                NFA_MCLOSE
                NFA_MCLOSE1
                NFA_MCLOSE2
                NFA_MCLOSE3
                NFA_MCLOSE4
                NFA_MCLOSE5
                NFA_MCLOSE6
                NFA_MCLOSE7
                NFA_MCLOSE8
                NFA_MCLOSE9
                NFA_NOPEN
                NFA_NCLOSE

                NFA_LNUM_GT
                NFA_LNUM_LT
                NFA_COL_GT
                NFA_COL_LT
                NFA_VCOL_GT
                NFA_VCOL_LT
                NFA_MARK_GT
                NFA_MARK_LT
                NFA_VISUAL
                NFA_LNUM
                NFA_CURSOR
                NFA_COL
                NFA_VCOL
                NFA_MARK

                NFA_ZSTART
                NFA_ZEND
                NFA_OPT_CHARS
                NFA_EMPTY
                NFA_START_PATTERN
                NFA_END_PATTERN
                NFA_COMPOSING
                NFA_END_COMPOSING]
                    (recur len (.out0 state)) ;; zero-width

             ;; :else
                (if (< (:c state) 0)
                    ;; don't know what this is
                    -1
                    ;; normal character
                    (recur (+ len (utf-char2len (:c state))) (.out0 state))
                )
            ))
    ))

;; A partially built NFA without the matching state filled in.
;; frag_C.fr_start points at the start state.
;; frag_C.fr_out is a list of places that need to be set to the next state for this fragment.

;; Since the out pointers in the list are always uninitialized,
;; we use the pointers themselves as storage for the fragnode_C.

(class! #_final fragnode_C
    [
        (field #_"/*fragnode_C*/"Object     fn_next)
    ])

(class! #_final frag_C
    [
        (field nfa_state_C  fr_start)
        (field fragnode_C   fr_out)
    ])

(defn- #_void COPY-frag [#_frag_C fr1, #_frag_C fr0]
    (ยง
        ((ร fr1.fr_start =) (:fr_start fr0))
        ((ร fr1.fr_out =) (:fr_out fr0))
        nil
    ))

;; Initialize a frag_C struct and return it.

(defn- #_frag_C alloc-frag [#_nfa_state_C start, #_fragnode_C out]
    (->frag_C start out))

;; Create singleton list containing just outp.

(defn- #_fragnode_C fr-single [#_fragnode_C node]
    (ยง
        ((ร node =) (assoc node :fn_next nil))
        node
    ))

;; Patch the list of states at out to point to start.

(defn- #_void fr-patch [#_fragnode_C node, #_nfa_state_C start]
    (ยง
        (loop-when node (some? node)
            ((ร fragnode_C next =) (ร (fragnode_C)(node.fn_next)))
            ((ร node =) (assoc node :fn_next start))
            (recur next)
        )
        nil
    ))

;; Join the two lists returning the concatenation.

(defn- #_fragnode_C fr-append [#_fragnode_C head, #_fragnode_C tail]
    (ยง
        ((ร fragnode_C list =) head)

        (loop-when [] (some? (:fn_next head))
            ((ร head =) (ร (fragnode_C)(head.fn_next)))
            (recur)
        )
        ((ร head =) (assoc head :fn_next tail))

        list
    ))

;; Stack used for transforming postfix form into NFA.

(class! #_final nfa_stack_C
    [
        (field frag_C*      st_base)
        (field int          st_next)
        (field int          st_over)
    ])

(defn- #_nfa_stack_C new-nfa-stack [#_int n]
    (->nfa_stack_C (frag_C* n) 0 n))

;; Push an item onto the stack.

(defn- #_boolean st-push [#_nfa_stack_C stack, #_frag_C frag]
    (ยง
        (when (< (:st_next stack) (:st_over stack))
            ((ร stack.st_base[stack.st_next++] =) frag)
            ((ร RETURN) true)
        )

        false
    ))

;; Pop an item from the stack.

(defn- #_frag_C st-pop [#_nfa_stack_C stack]
    (ยง
        (if (< (ร --stack.st_next) 0)
            ((ร RETURN) nil)
        )

        ((ร frag_C frag =) (... (:st_base stack) (:st_next stack)))
        ((ร stack.st_base[stack.st_next] =) nil)
        frag
    ))

(defn- #_nfa_state_C st-error [#_int* _postfix, #_int _i, #_int _over]
    (emsg (u8 "E874: (NFA) Could not pop the stack !"))
    nil)

;; Convert a postfix form into its equivalent NFA.
;; Return the NFA start state on success, null otherwise.

(defn- #_nfa_state_C post2nfa [#_int* postfix, #_int over, #_nfa_regprog_C prog, #_boolean nfa_calc_size]
    (ยง
        (if (nil? postfix)
            ((ร RETURN) nil)
        )

        ((ร nfa_stack_C stack =) (if nfa_calc_size nil (new-nfa-stack (inc (:nstate prog)))))

        ((ร int i =) (loop-when-recur [i 0] (< i over) [(inc i)] => i
            (condp ==? (... postfix i)
                NFA_CONCAT
                (do
                    ;; Concatenation.
                    ;; Pay attention: this operator does not exist in the r.e. itself (it is implicit, really).
                    ;; It is added when r.e. is translated to postfix form in re2post().
                    (when nfa_calc_size
                        ;; prog.nstate += 0;
                        (ร BREAK)
                    )

                    ((ร frag_C e2 =) (st-pop stack))
                    (if (nil? e2)
                        ((ร RETURN) (st-error postfix, i, over))
                    )
                    ((ร frag_C e1 =) (st-pop stack))
                    (if (nil? e1)
                        ((ร RETURN) (st-error postfix, i, over))
                    )
                    (fr-patch (:fr_out e1), (:fr_start e2))
                    (st-push stack, (alloc-frag (:fr_start e1), (:fr_out e2)))
                    (ร BREAK)
                )

                NFA_OR
                (do
                    ;; Alternation.
                    (when nfa_calc_size
                        ((ร prog =) (update prog :nstate inc))
                        (ร BREAK)
                    )

                    ((ร frag_C e2 =) (st-pop stack))
                    (if (nil? e2)
                        ((ร RETURN) (st-error postfix, i, over))
                    )
                    ((ร frag_C e1 =) (st-pop stack))
                    (if (nil? e1)
                        ((ร RETURN) (st-error postfix, i, over))
                    )
                    ((ร nfa_state_C s0 =) (alloc-state prog, NFA_SPLIT, (:fr_start e1), (:fr_start e2)))
                    (if (nil? s0)
                        ((ร RETURN) nil)
                    )
                    (st-push stack, (alloc-frag s0, (fr-append (:fr_out e1), (:fr_out e2))))
                    (ร BREAK)
                )

                NFA_STAR
                (do
                    ;; Zero or more, prefer more.
                    (when nfa_calc_size
                        ((ร prog =) (update prog :nstate inc))
                        (ร BREAK)
                    )

                    ((ร frag_C e0 =) (st-pop stack))
                    (if (nil? e0)
                        ((ร RETURN) (st-error postfix, i, over))
                    )
                    ((ร nfa_state_C s0 =) (alloc-state prog, NFA_SPLIT, (:fr_start e0), nil))
                    (if (nil? s0)
                        ((ร RETURN) nil)
                    )
                    (fr-patch (:fr_out e0), s0)
                    (st-push stack, (alloc-frag s0, (fr-single (:out1 s0))))
                    (ร BREAK)
                )

                NFA_STAR_NONGREEDY
                (do
                    ;; Zero or more, prefer zero.
                    (when nfa_calc_size
                        ((ร prog =) (update prog :nstate inc))
                        (ร BREAK)
                    )

                    ((ร frag_C e0 =) (st-pop stack))
                    (if (nil? e0)
                        ((ร RETURN) (st-error postfix, i, over))
                    )
                    ((ร nfa_state_C s0 =) (alloc-state prog, NFA_SPLIT, nil, (:fr_start e0)))
                    (if (nil? s0)
                        ((ร RETURN) nil)
                    )
                    (fr-patch (:fr_out e0), s0)
                    (st-push stack, (alloc-frag s0, (fr-single (:out0 s0))))
                    (ร BREAK)
                )

                NFA_QUEST
                (do
                    ;; one or zero atoms=> greedy match
                    (when nfa_calc_size
                        ((ร prog =) (update prog :nstate inc))
                        (ร BREAK)
                    )

                    ((ร frag_C e0 =) (st-pop stack))
                    (if (nil? e0)
                        ((ร RETURN) (st-error postfix, i, over))
                    )
                    ((ร nfa_state_C s0 =) (alloc-state prog, NFA_SPLIT, (:fr_start e0), nil))
                    (if (nil? s0)
                        ((ร RETURN) nil)
                    )
                    (st-push stack, (alloc-frag s0, (fr-append (:fr_out e0), (fr-single (:out1 s0)))))
                    (ร BREAK)
                )

                NFA_QUEST_NONGREEDY
                (do
                    ;; zero or one atoms => non-greedy match
                    (when nfa_calc_size
                        ((ร prog =) (update prog :nstate inc))
                        (ร BREAK)
                    )

                    ((ร frag_C e0 =) (st-pop stack))
                    (if (nil? e0)
                        ((ร RETURN) (st-error postfix, i, over))
                    )
                    ((ร nfa_state_C s0 =) (alloc-state prog, NFA_SPLIT, nil, (:fr_start e0)))
                    (if (nil? s0)
                        ((ร RETURN) nil)
                    )
                    (st-push stack, (alloc-frag s0, (fr-append (:fr_out e0), (fr-single (:out0 s0)))))
                    (ร BREAK)
                )

               [NFA_END_COLL NFA_END_NEG_COLL]
                (do
                    ;; On the stack is the sequence starting with NFA_START_COLL or
                    ;; NFA_START_NEG_COLL and all possible characters.  Patch it to
                    ;; add the output to the start.
                    (when nfa_calc_size
                        ((ร prog =) (update prog :nstate inc))
                        (ร BREAK)
                    )

                    ((ร frag_C e0 =) (st-pop stack))
                    (if (nil? e0)
                        ((ร RETURN) (st-error postfix, i, over))
                    )
                    ((ร nfa_state_C s0 =) (alloc-state prog, NFA_END_COLL, nil, nil))
                    (if (nil? s0)
                        ((ร RETURN) nil)
                    )
                    (fr-patch (:fr_out e0), s0)
;                   e0.fr_start.out1(s0);
                    (st-push stack, (alloc-frag (:fr_start e0), (fr-single (:out0 s0))))
                    (ร BREAK)
                )

                NFA_RANGE
                (do
                    ;; Before this are two characters, the low and high end of a range.
                    ;; Turn them into two states with MIN and MAX.
                    (when nfa_calc_size
                        ;; prog.nstate += 0;
                        (ร BREAK)
                    )

                    ((ร frag_C e2 =) (st-pop stack))
                    (if (nil? e2)
                        ((ร RETURN) (st-error postfix, i, over))
                    )
                    ((ร frag_C e1 =) (st-pop stack))
                    (if (nil? e1)
                        ((ร RETURN) (st-error postfix, i, over))
                    )
                    ((ร e2.fr_start.val =) (:c (:fr_start e2)))
                    ((ร e2.fr_start.c =) NFA_RANGE_MAX)
                    ((ร e1.fr_start.val =) (:c (:fr_start e1)))
                    ((ร e1.fr_start.c =) NFA_RANGE_MIN)
                    (fr-patch (:fr_out e1), (:fr_start e2))
                    (st-push stack, (alloc-frag (:fr_start e1), (:fr_out e2)))
                    (ร BREAK)
                )

                NFA_EMPTY
                (do
                    ;; 0-length, used in a repetition with max/min count of 0
                    (when nfa_calc_size
                        ((ร prog =) (update prog :nstate inc))
                        (ร BREAK)
                    )

                    ((ร nfa_state_C s0 =) (alloc-state prog, NFA_EMPTY, nil, nil))
                    (if (nil? s0)
                        ((ร RETURN) nil)
                    )
                    (st-push stack, (alloc-frag s0, (fr-single (:out0 s0))))
                    (ร BREAK)
                )

                NFA_OPT_CHARS
                (do
                    ;; \%[abc] implemented as:
                    ;;    NFA_SPLIT
                    ;;    +-CHAR(a)
                    ;;    | +-NFA_SPLIT
                    ;;    |   +-CHAR(b)
                    ;;    |   | +-NFA_SPLIT
                    ;;    |   |   +-CHAR(c)
                    ;;    |   |   | +-next
                    ;;    |   |   +- next
                    ;;    |   +- next
                    ;;    +- next

                    ((ร int n =) (... postfix ((ร i =) (inc i))))                           ;; get number of characters
                    (when nfa_calc_size
                        ((ร prog =) (update prog :nstate + n))
                        (ร BREAK)
                    )

                    ((ร frag_C e1 =) (alloc-frag nil, nil))     ;; e1.fr_out: stores list with out1's
                    ((ร nfa_state_C s0 =) (loop-when [s0 nil #_nfa_state_C s1 nil n n] (< 0 n) => s0  ;; s1: previous NFA_SPLIT to connect to
                        ((ร frag_C e0 =) (st-pop stack))          ;; get character
                        (if (nil? e0)
                            ((ร RETURN) (st-error postfix, i, over))
                        )
                        ((ร s0 =) (alloc-state prog, NFA_SPLIT, (:fr_start e0), nil))
                        (if (nil? s0)
                            ((ร RETURN) nil)
                        )
                        (if (nil? (:fr_out e1))
                            (COPY-frag e1, e0))
                        (fr-patch (:fr_out e0), s1)
                        (fr-append (:fr_out e1), (fr-single (:out1 s0)))
                        (recur s0 s0 (dec n))
                    ))
                    (st-push stack, (alloc-frag s0, (:fr_out e1)))
                    (ร BREAK)
                )

               [NFA_PREV_ATOM_NO_WIDTH
                NFA_PREV_ATOM_NO_WIDTH_NEG
                NFA_PREV_ATOM_JUST_BEFORE
                NFA_PREV_ATOM_JUST_BEFORE_NEG
                NFA_PREV_ATOM_LIKE_PATTERN]
                (do
                    ((ร boolean before =) (any == (... postfix i) NFA_PREV_ATOM_JUST_BEFORE NFA_PREV_ATOM_JUST_BEFORE_NEG))
                    ((ร boolean pattern =) (== (... postfix i) NFA_PREV_ATOM_LIKE_PATTERN))

                    ((ร int start_state, end_state =)
                        (condp == (... postfix i)
                            NFA_PREV_ATOM_NO_WIDTH        [NFA_START_INVISIBLE            NFA_END_INVISIBLE]
                            NFA_PREV_ATOM_NO_WIDTH_NEG    [NFA_START_INVISIBLE_NEG        NFA_END_INVISIBLE_NEG]
                            NFA_PREV_ATOM_JUST_BEFORE     [NFA_START_INVISIBLE_BEFORE     NFA_END_INVISIBLE]
                            NFA_PREV_ATOM_JUST_BEFORE_NEG [NFA_START_INVISIBLE_BEFORE_NEG NFA_END_INVISIBLE_NEG]
                            NFA_PREV_ATOM_LIKE_PATTERN    [NFA_START_PATTERN              NFA_END_PATTERN]
                        ))

                    ((ร int n =) (if before (... postfix ((ร i =) (inc i))) 0))    ;; get the count

                    ;; The \@= operator: match the preceding atom with zero width.
                    ;; The \@! operator: no match for the preceding atom.
                    ;; The \@<= operator: match for the preceding atom.
                    ;; The \@<! operator: no match for the preceding atom.
                    ;; Surrounds the preceding atom with START_INVISIBLE and END_INVISIBLE, similarly to MOPEN.

                    (when nfa_calc_size
                        ((ร prog =) (update prog :nstate + (if pattern 4 2)))
                        (ร BREAK)
                    )

                    ((ร frag_C e0 =) (st-pop stack))
                    (if (nil? e0)
                        ((ร RETURN) (st-error postfix, i, over))
                    )

                    ((ร nfa_state_C s1 =) (alloc-state prog, end_state, nil, nil))
                    (if (nil? s1)
                        ((ร RETURN) nil)
                    )

                    ((ร nfa_state_C s0 =) (alloc-state prog, start_state, (:fr_start e0), s1))
                    (if (nil? s0)
                        ((ร RETURN) nil)
                    )

                    (cond pattern
                    (do
                        ;; NFA_ZEND -> NFA_END_PATTERN -> NFA_SKIP -> what follows.
                        ((ร nfa_state_C skip =) (alloc-state prog, NFA_SKIP, nil, nil))
                        ((ร nfa_state_C zend =) (alloc-state prog, NFA_ZEND, s1, nil))
                        (.out0 s1 skip)
                        (fr-patch (:fr_out e0), zend)
                        (st-push stack, (alloc-frag s0, (fr-single (:out0 skip))))
                    )
                    :else
                    (do
                        (fr-patch (:fr_out e0), s1)
                        (st-push stack, (alloc-frag s0, (fr-single (:out0 s1))))
                        (when before
                            ;; See if we can guess the maximum width, it avoids a lot of pointless tries.
                            ((ร n =) (if (<= n 0) (nfa-max-width (:fr_start e0), 0) n))
                            ((ร s0.val =) n) ;; store the count
                        )
                    ))
                    (ร BREAK)
                )

                NFA_COMPOSING     ;; char with composing char
                (do
                    (when (flag? @regflags RF_ICOMBINE)
                        ;; TODO: use the base character only
                    )
                    (ร FALLTHROUGH)
                )

               [NFA_MOPEN ;; \( \) Submatch
                NFA_MOPEN1
                NFA_MOPEN2
                NFA_MOPEN3
                NFA_MOPEN4
                NFA_MOPEN5
                NFA_MOPEN6
                NFA_MOPEN7
                NFA_MOPEN8
                NFA_MOPEN9
                NFA_ZOPEN ;; \z( \) Submatch
                NFA_ZOPEN1
                NFA_ZOPEN2
                NFA_ZOPEN3
                NFA_ZOPEN4
                NFA_ZOPEN5
                NFA_ZOPEN6
                NFA_ZOPEN7
                NFA_ZOPEN8
                NFA_ZOPEN9
                NFA_NOPEN] ;; \%( \) "Invisible Submatch"
                (do
                    (when nfa_calc_size
                        ((ร prog =) (update prog :nstate + 2))
                        (ร BREAK)
                    )

                    ((ร int mopen =) (... postfix i))
                    ((ร int mclose =) (condp == mopen
                        NFA_NOPEN     NFA_NCLOSE
                        NFA_ZOPEN     NFA_ZCLOSE
                        NFA_ZOPEN1    NFA_ZCLOSE1
                        NFA_ZOPEN2    NFA_ZCLOSE2
                        NFA_ZOPEN3    NFA_ZCLOSE3
                        NFA_ZOPEN4    NFA_ZCLOSE4
                        NFA_ZOPEN5    NFA_ZCLOSE5
                        NFA_ZOPEN6    NFA_ZCLOSE6
                        NFA_ZOPEN7    NFA_ZCLOSE7
                        NFA_ZOPEN8    NFA_ZCLOSE8
                        NFA_ZOPEN9    NFA_ZCLOSE9
                        NFA_COMPOSING NFA_END_COMPOSING
                        (+ mopen NSUBEXP) ;; NFA_MOPEN, NFA_MOPEN1 .. NFA_MOPEN9
                    ))

                    ;; Allow "NFA_MOPEN" as a valid postfix representation for the empty regexp "".
                    ;; In this case, the NFA will be NFA_MOPEN -> NFA_MCLOSE.  Note that this also
                    ;; allows empty groups of parenthesis, and empty mbyte chars.
                    (when (zero? (:st_next stack))
                        ((ร nfa_state_C s0 =) (alloc-state prog, mopen, nil, nil))
                        (if (nil? s0)
                            ((ร RETURN) nil)
                        )
                        ((ร nfa_state_C s1 =) (alloc-state prog, mclose, nil, nil))
                        (if (nil? s1)
                            ((ร RETURN) nil)
                        )
                        (fr-patch (fr-single (:out0 s0)), s1)
                        (st-push stack, (alloc-frag s0, (fr-single (:out0 s1))))
                        (ร BREAK)
                    )

                    ;; At least one node was emitted before NFA_MOPEN, so
                    ;; at least one node will be between NFA_MOPEN and NFA_MCLOSE.
                    ((ร frag_C e0 =) (st-pop stack))
                    (if (nil? e0)
                        ((ร RETURN) (st-error postfix, i, over))
                    )
                    ((ร nfa_state_C s0 =) (alloc-state prog, mopen, (:fr_start e0), nil))   ;; `('
                    (if (nil? s0)
                        ((ร RETURN) nil)
                    )

                    ((ร nfa_state_C s1 =) (alloc-state prog, mclose, nil, nil))         ;; `)'
                    (if (nil? s1)
                        ((ร RETURN) nil)
                    )
                    (fr-patch (:fr_out e0), s1)

                    (when (== mopen NFA_COMPOSING)
                        ;; COMPOSING.out1 = END_COMPOSING
                        (fr-patch (fr-single (:out1 s0)), s1)
                    )

                    (st-push stack, (alloc-frag s0, (fr-single (:out0 s1))))
                    (ร BREAK)
                )

               [NFA_BACKREF1
                NFA_BACKREF2
                NFA_BACKREF3
                NFA_BACKREF4
                NFA_BACKREF5
                NFA_BACKREF6
                NFA_BACKREF7
                NFA_BACKREF8
                NFA_BACKREF9
                NFA_ZREF1
                NFA_ZREF2
                NFA_ZREF3
                NFA_ZREF4
                NFA_ZREF5
                NFA_ZREF6
                NFA_ZREF7
                NFA_ZREF8
                NFA_ZREF9]
                (do
                    (when nfa_calc_size
                        ((ร prog =) (update prog :nstate + 2))
                        (ร BREAK)
                    )

                    ((ร nfa_state_C s0 =) (alloc-state prog, (... postfix i), nil, nil))
                    (if (nil? s0)
                        ((ร RETURN) nil)
                    )
                    ((ร nfa_state_C s1 =) (alloc-state prog, NFA_SKIP, nil, nil))
                    (if (nil? s1)
                        ((ร RETURN) nil)
                    )
                    (fr-patch (fr-single (:out0 s0)), s1)
                    (st-push stack, (alloc-frag s0, (fr-single (:out0 s1))))
                    (ร BREAK)
                )

               [NFA_LNUM NFA_LNUM_GT NFA_LNUM_LT
                NFA_VCOL NFA_VCOL_GT NFA_VCOL_LT
                NFA_COL  NFA_COL_GT  NFA_COL_LT
                NFA_MARK NFA_MARK_GT NFA_MARK_LT]
                (do
                    ((ร int n =) (... postfix ((ร i =) (inc i)))) ;; lnum, col or mark name

                    (when nfa_calc_size
                        ((ร prog =) (update prog :nstate inc))
                        (ร BREAK)
                    )

                    ((ร nfa_state_C s0 =) (alloc-state prog, (... postfix (dec i)), nil, nil))
                    (if (nil? s0)
                        ((ร RETURN) nil)
                    )
                    ((ร s0.val =) n)
                    (st-push stack, (alloc-frag s0, (fr-single (:out0 s0))))
                    (ร BREAK)
                )

               [NFA_ZSTART NFA_ZEND]
                (ร DEFAULT)
                (do
                    ;; Operands.
                    (when nfa_calc_size
                        ((ร prog =) (update prog :nstate inc))
                        (ร BREAK)
                    )

                    ((ร nfa_state_C s0 =) (alloc-state prog, (... postfix i), nil, nil))
                    (if (nil? s0)
                        ((ร RETURN) nil)
                    )
                    (st-push stack, (alloc-frag s0, (fr-single (:out0 s0))))
                    (ร BREAK)
                )
            )
        ))

        (when nfa_calc_size
            ((ร prog =) (update prog :nstate inc))
            ((ร RETURN) nil)  ;; Return value when counting size is ignored anyway.
        )

        ((ร frag_C e0 =) (st-pop stack))
        (if (nil? e0)
            ((ร RETURN) (st-error postfix, i, over))
        )
        (when (< 0 (:st_next stack))
            (emsg (u8 "E875: (NFA regexp) (While converting from postfix to NFA), too many states left on stack"))
            (reset! rc_did_emsg true)
            ((ร RETURN) nil)
        )

        (when (<= (:nstate prog) (:istate prog))
            (emsg (u8 "E876: (NFA regexp) Not enough space to store the whole NFA"))
            (reset! rc_did_emsg true)
            ((ร RETURN) nil)
        )

        ((ร nfa_state_C state =) (ร @nfa_states[prog.istate++] =) (NEW_nfa_state_C))
        ((ร state =) (assoc state :c NFA_MATCH))
        (.out0 state nil)
        (.out1 state nil)
        ((ร state =) (assoc state :id 0))

        (fr-patch (:fr_out e0), state)
        (:fr_start e0)
    ))

;; After building the NFA program, inspect it to add optimization hints.

(defn- #_void nfa-postprocess [#_nfa_regprog_C prog]
    (ยง
        (dotimes [#_int i (:nstate prog)]
            ((ร nfa_state_C state =) (... (:states prog) i))
            (if (nil? state)
                (ร CONTINUE)
            )

            ((ร int c =) (:c state))
            (when (any == c NFA_START_INVISIBLE NFA_START_INVISIBLE_NEG NFA_START_INVISIBLE_BEFORE NFA_START_INVISIBLE_BEFORE_NEG)
                (ร boolean directly)

                ;; Do it directly when what follows is possibly the end of the match.
                (cond (match-follows (.. state (out1) (out0)), 0)
                (do
                    ((ร directly =) true)
                )
                :else
                (do
                    ((ร int ch_invisible =) (failure-chance (.out0 state), 0))
                    ((ร int ch_follows =) (failure-chance (.. state (out1) (out0)), 0))

                    ;; Postpone when the invisible match is expensive or has a lower chance of failing.
                    (cond (any == c NFA_START_INVISIBLE_BEFORE NFA_START_INVISIBLE_BEFORE_NEG)
                    (do
                        ;; "before" matches are very expensive when unbounded,
                        ;; always prefer what follows then, unless what follows will always match.
                        ;; Otherwise strongly prefer what follows.
                        ((ร directly =) (if (and (<= (:val state) 0) (< 0 ch_follows)) false (< (* ch_follows 10) ch_invisible)))
                    )
                    :else
                    (do
                        ;; normal invisible, first do the one with the highest failure chance
                        ((ร directly =) (< ch_follows ch_invisible))
                    ))
                ))
                (when directly
                    ;; switch to the _FIRST state
                    ((ร state =) (update state :c inc))
                )
            )
        )
        nil
    ))

;; NFA execution code.

(class! #_final multipos_C
    [
        (field long         start_lnum)
        (field long         end_lnum)
        (field int          start_col)
        (field int          end_col)
    ])

(defn- #_void MIN1-multipos [#_multipos_C mp]
    (ยง
        ((ร mp =) (assoc mp :start_lnum -1))
        ((ร mp =) (assoc mp :end_lnum -1))
        ((ร mp =) (assoc mp :start_col -1))
        ((ร mp =) (assoc mp :end_col -1))
        nil
    ))

(defn- #_void COPY-multipos [#_multipos_C mp1, #_multipos_C mp0]
    (ยง
        ((ร mp1.start_lnum =) (:start_lnum mp0))
        ((ร mp1.end_lnum =) (:end_lnum mp0))
        ((ร mp1.start_col =) (:start_col mp0))
        ((ร mp1.end_col =) (:end_col mp0))
        nil
    ))

(defn- #_multipos_C* ARRAY-multipos [#_int n]
    (vec (repeatedly n NEW_multipos_C)))

(defn- #_void COPY--multipos [#_multipos_C* a1, #_multipos_C* a0, #_int n]
    (dotimes [#_int i n]
        (COPY-multipos (... a1 i), (... a0 i))
    )
    nil)

(class! #_final linepos_C
    [
        (field Bytes        start)
        (field Bytes        end)
    ])

(defn- #_void ZER0-linepos [#_linepos_C lp]
    (ยง
        ((ร lp =) (assoc lp :start nil))
        ((ร lp =) (assoc lp :end nil))
        nil
    ))

(defn- #_void COPY-linepos [#_linepos_C lp1, #_linepos_C lp0]
    (ยง
        ((ร lp1.start =) (:start lp0))
        ((ร lp1.end =) (:end lp0))
        nil
    ))

(defn- #_linepos_C* ARRAY-linepos [#_int n]
    (vec (repeatedly n NEW_linepos_C)))

(defn- #_void COPY--linepos [#_linepos_C* a1, #_linepos_C* a0, #_int n]
    (dotimes [#_int i n]
        (COPY-linepos (... a1 i), (... a0 i))
    )
    nil)

(class! #_final regsub_C
    [
        (field int          in_use)         ;; number of subexpr with useful info

        (field multipos_C*  rs_multi    (ARRAY-multipos NSUBEXP))   ;; union: when reg_match == null
        (field linepos_C*   rs_line     (ARRAY-linepos NSUBEXP))    ;; union: when reg_match != null
    ])

(defn- #_void COPY-regsub [#_regsub_C rs1, #_regsub_C rs0]
    (ยง
        ((ร rs1.in_use =) (:in_use rs0))

        (COPY--multipos (:rs_multi rs1), (:rs_multi rs0), NSUBEXP)
        (COPY--linepos (:rs_line rs1), (:rs_line rs0), NSUBEXP)
        nil
    ))

(class! #_final regsubs_C
    [
        (field regsub_C     rs_norm     (NEW_regsub_C))   ;; \( .. \) matches
        (field regsub_C     rs_synt     (NEW_regsub_C))   ;; \z( .. \) matches
    ])

(defn- #_void COPY-regsubs [#_regsubs_C rs1, #_regsubs_C rs0]
    (COPY-regsub (:rs_norm rs1), (:rs_norm rs0))
    (COPY-regsub (:rs_synt rs1), (:rs_synt rs0))
    nil)

;; nfa_pim_C stores a Postponed Invisible Match.
(class! #_final nfa_pim_C
    [
        (field int          result)         ;; NFA_PIM_*, see below
        (field nfa_state_C  state)          ;; the invisible match start state
        (field regsubs_C    np_subs     (NEW_regsubs_C))  ;; submatch info, only party used

        (field lpos_C       end_pos     (NEW_lpos_C))     ;; union upon reg_match: where the match must end
        (field Bytes        end_ptr)        ;; union upon reg_match: where the match must end
    ])

(defn- #_void COPY-nfa-pim [#_nfa_pim_C np1, #_nfa_pim_C np0]
    (ยง
        ((ร np1.result =) (:result np0))
        ((ร np1.state =) (:state np0))
        (COPY-regsubs (:np_subs np1), (:np_subs np0))

        (COPY-lpos (:end_pos np1), (:end_pos np0))
        ((ร np1.end_ptr =) (:end_ptr np0))
        nil
    ))

;; Values for done in nfa_pim_C.
(final int NFA_PIM_UNUSED   0)      ;; pim not used
(final int NFA_PIM_TODO     1)      ;; pim not done yet
(final int NFA_PIM_MATCH    2)      ;; pim executed, matches
(final int NFA_PIM_NOMATCH  3)      ;; pim executed, no match

;; nfa_thread_C contains execution information of a NFA state
(class! #_final nfa_thread_C
    [
        (field nfa_state_C  state)
        (field int          count)
        (field nfa_pim_C    th_pim      (NEW_nfa_pim_C))  ;; if pim.result != NFA_PIM_UNUSED: postponed invisible match
        (field regsubs_C    th_subs     (NEW_regsubs_C))  ;; submatch info, only party used
    ])

(defn- #_void COPY-nfa-thread [#_nfa_thread_C th1, #_nfa_thread_C th0]
    (ยง
        ((ร th1.state =) (:state th0))
        ((ร th1.count =) (:count th0))
        (COPY-nfa-pim (:th_pim th1), (:th_pim th0))
        (COPY-regsubs (:th_subs th1), (:th_subs th0))
        nil
    ))

(defn- #_nfa_thread_C* ARRAY-nfa-thread [#_int n]
    (vec (repeatedly n NEW_nfa_thread_C)))

;; nfa_list_C contains the alternative NFA execution states.
(class! #_final nfa_list_C
    [
        (field nfa_thread_C*    threads)        ;; allocated array of states
        (field int              n)              ;; nr of states currently in "t"
        (field int              len)            ;; max nr of states in "t"
        (field int              id)             ;; ID of the list
        (field boolean          has_pim)        ;; true when any state has a PIM
    ])

(defn- #_nfa_list_C* ARRAY-nfa-list [#_int n]
    (vec (repeatedly n NEW_nfa_list_C)))

;; Used during execution: whether a match has been found.
(atom! int nfa_match)
(atom! long nfa_time_limit)
(atom! int nfa_time_count)

;; Copy postponed invisible match info from "from" to "to".

(defn- #_void copy-pim [#_nfa_pim_C to, #_nfa_pim_C from]
    (ยง
        ((ร to =) (assoc to :result (:result from)))
        ((ร to =) (assoc to :state (:state from)))
        (copy-sub (:rs_norm (:np_subs to)), (:rs_norm (:np_subs from)))
        (if @nfa_has_zsubexpr
            (copy-sub (:rs_synt (:np_subs to)), (:rs_synt (:np_subs from))))
        (COPY-lpos (:end_pos to), (:end_pos from))
        ((ร to =) (assoc to :end_ptr (:end_ptr from)))
        nil
    ))

(defn- #_void clear-sub [#_regsub_C sub]
    (ยง
        (if (nil? @reg_match)
            (dotimes [#_int i @nfa_nsubexpr] (MIN1-multipos (... (:rs_multi sub) i)))
            (dotimes [#_int i @nfa_nsubexpr] (ZER0-linepos (... (:rs_line sub) i)))
        )
        ((ร sub =) (assoc sub :in_use 0))
        nil
    ))

;; Copy the submatches from "from" to "to".

(defn- #_void copy-sub [#_regsub_C to, #_regsub_C from]
    (ยง
        ((ร to =) (assoc to :in_use (:in_use from)))
        (when (< 0 (:in_use from))
            ;; Copy the match start and end positions.
            (if (nil? @reg_match)
                (dotimes [#_int i (:in_use from)] (COPY-multipos (... (:rs_multi to) i), (... (:rs_multi from) i)))
                (dotimes [#_int i (:in_use from)] (COPY-linepos (... (:rs_line to) i), (... (:rs_line from) i)))
            )
        )
        nil
    ))

;; Like copy-sub() but exclude the main match.

(defn- #_void copy-sub-off [#_regsub_C to, #_regsub_C from]
    (ยง
        ((ร to =) (update to :in_use max (:in_use from)))
        (when (< 1 (:in_use from))
            ;; Copy the match start and end positions.
            (if (nil? @reg_match)
                (loop-when-recur [#_int i 1] (< i (:in_use from)) [(inc i)] (COPY-multipos (... (:rs_multi to) i), (... (:rs_multi from) i)))
                (loop-when-recur [#_int i 1] (< i (:in_use from)) [(inc i)] (COPY-linepos (... (:rs_line to) i), (... (:rs_line from) i)))
            )
        )
        nil
    ))

;; Like copy-sub() but only do the end of the main match if \ze is present.

(defn- #_void copy-ze-off [#_regsub_C to, #_regsub_C from]
    (ยง
        (when @nfa_has_zend
            (cond (nil? @reg_match)
            (do
                (when (<= 0 (:end_lnum (... (:rs_multi from) 0)))
                    ((ร to.rs_multi[0].end_lnum =) (:end_lnum (... (:rs_multi from) 0)))
                    ((ร to.rs_multi[0].end_col =) (:end_col (... (:rs_multi from) 0)))
                )
            )
            :else
            (do
                (if (some? (:end (... (:rs_line from) 0)))
                    ((ร to.rs_line[0].end =) (:end (... (:rs_line from) 0)))
                )
            ))
        )
        nil
    ))

;; Return true if "sub1" and "sub2" have the same start positions.
;; When using back-references also check the end position.

(defn- #_boolean sub-equal [#_regsub_C sub1, #_regsub_C sub2]
    (let [n1 (:in_use sub1) n2 (:in_use sub2) #_int n (max n1 n2)]
        (cond (nil? @reg_match)
            (loop-when [#_int i 0] (< i n) => true
                (let-when [r1 (... (:rs_multi sub1) i) #_long s1 (if (< i n1) (:start_lnum r1) -1)
                           r2 (... (:rs_multi sub2) i) #_long s2 (if (< i n2) (:start_lnum r2) -1)
                ] (and (== s1 s2) (or (== s1 -1) (== (:start_col r1) (:start_col r2)))) => false
                    (let [_ (when @nfa_has_backref
                                (let-when [s1 (if (< i n1) (:end_lnum r1) -1)
                                           s2 (if (< i n2) (:end_lnum r2) -1)
                                ] (and (== s1 s2) (or (== s1 -1) (== (:end_col r1) (:end_col r2)))) => false)
                            )]
                        (if (some? _) _ (recur (inc i))))
                ))
        :else
            (loop-when [#_int i 0] (< i n) => true
                (let-when [r1 (... (:rs_line sub1) i) #_Bytes s1 (if (< i n1) (:start r1) nil)
                           r2 (... (:rs_line sub2) i) #_Bytes s2 (if (< i n2) (:start r2) nil)
                ] (BEQ s1, s2) => false
                    (let [_ (when @nfa_has_backref
                                (let-when [s1 (if (< i n1) (:end r1) nil)
                                           s2 (if (< i n2) (:end r2) nil)
                                ] (BEQ s1, s2) => false)
                            )]
                        (if (some? _) _ (recur (inc i))))
                ))
        )))

;; Return true if the same state is already in list "nfl" with the same positions as "subs".

(defn- #_boolean has-state-with-pos [#_nfa_list_C nfl, #_nfa_state_C state, #_regsubs_C subs, #_nfa_pim_C pim]
    ;; nfl: runtime state list
    ;; state: state to update
    ;; subs: pointers to subexpressions
    ;; pim: postponed match or null
    (loop-when [i 0] (< i (:n nfl)) => false
        (let [#_nfa_thread_C thread (... (:threads nfl) i)]
            (if (and (== (:id (:state thread)) (:id state))
                     (sub-equal (:rs_norm (:th_subs thread)), (:rs_norm subs))
                     (or (not @nfa_has_zsubexpr) (sub-equal (:rs_synt (:th_subs thread)), (:rs_synt subs)))
                     (pim-equal (:th_pim thread), pim))
                true
                (recur (inc i))
            ))
    ))

;; Return true if "one" and "two" are equal.  That includes when both are not set.

(defn- #_boolean pim-equal [#_nfa_pim_C one, #_nfa_pim_C two]
    (let [#_boolean one_unused (or (nil? one) (== (:result one) NFA_PIM_UNUSED))
          #_boolean two_unused (or (nil? two) (== (:result two) NFA_PIM_UNUSED))]
        (cond
            one_unused ;; one is unused: equal when two is also unused
                two_unused
            two_unused ;; one is used and two is not: not equal
                false
            (!= (:id (:state one)) (:id (:state two))) ;; compare the state id
                false
            (nil? @reg_match) ;; compare the position
                (and (== (:lnum (:end_pos one)) (:lnum (:end_pos two))) (== (:col (:end_pos one)) (:col (:end_pos two))))
            :else
                (BEQ (:end_ptr one), (:end_ptr two))
        )))

;; Return true if "state" leads to a NFA_MATCH without advancing the input.

(defn- #_boolean match-follows [#_nfa_state_C startstate, #_int depth]
    (if (< 10 depth) ;; avoid too much recursion
        false
        (loop-when [#_nfa_state_C state startstate] (some? state) => false
            (condp ==? (:c state)
               [NFA_MATCH
                NFA_MCLOSE
                NFA_END_INVISIBLE
                NFA_END_INVISIBLE_NEG
                NFA_END_PATTERN]
                    true

                NFA_SPLIT
                    (or (match-follows (.out0 state), (inc depth)) (match-follows (.out1 state), (inc depth)))

               [NFA_START_INVISIBLE
                NFA_START_INVISIBLE_FIRST
                NFA_START_INVISIBLE_BEFORE
                NFA_START_INVISIBLE_BEFORE_FIRST
                NFA_START_INVISIBLE_NEG
                NFA_START_INVISIBLE_NEG_FIRST
                NFA_START_INVISIBLE_BEFORE_NEG
                NFA_START_INVISIBLE_BEFORE_NEG_FIRST
                NFA_COMPOSING]
                    (recur (.. state (out1) (out0))) ;; skip ahead to next state

               [NFA_ANY
                NFA_ANY_COMPOSING
                NFA_IDENT
                NFA_SIDENT
                NFA_KWORD
                NFA_SKWORD
                NFA_FNAME
                NFA_SFNAME
                NFA_PRINT
                NFA_SPRINT
                NFA_WHITE
                NFA_NWHITE
                NFA_DIGIT
                NFA_NDIGIT
                NFA_HEX
                NFA_NHEX
                NFA_OCTAL
                NFA_NOCTAL
                NFA_WORD
                NFA_NWORD
                NFA_HEAD
                NFA_NHEAD
                NFA_ALPHA
                NFA_NALPHA
                NFA_LOWER
                NFA_NLOWER
                NFA_UPPER
                NFA_NUPPER
                NFA_LOWER_IC
                NFA_NLOWER_IC
                NFA_UPPER_IC
                NFA_NUPPER_IC
                NFA_START_COLL
                NFA_START_NEG_COLL
                NFA_NEWL]
                    false ;; state will advance input

             ;; :else
                (if (< 0 (:c state))
                    ;; state will advance input
                    false
                    ;; Others: zero-width or possibly zero-width, might still find a match at the same position, keep looking.
                    (recur (.out0 state))
                )
            ))
    ))

;; Return true if "state" is already in list "nfl".

(defn- #_boolean state-in-list [#_nfa_list_C nfl, #_nfa_state_C state, #_regsubs_C subs]
    ;; nfl: runtime state list
    ;; state: state to update
    ;; subs: pointers to subexpressions
    (and (== (... (:lastlist state) @nfa_ll_index) (:id nfl)) (or (not @nfa_has_backref) (has-state-with-pos nfl, state, subs, nil))))

(atom! regsubs_C temp_subs  (NEW_regsubs_C))

;; Add "state" and possibly what follows to state list ".".
;; Returns "subs_arg", possibly copied into temp_subs.

(defn- #_regsubs_C addstate [#_nfa_list_C nfl, #_nfa_state_C state, #_regsubs_C subs_arg, #_nfa_pim_C pim, #_int off]
    ;; nfl: runtime state list
    ;; state: state to update
    ;; subs_arg: pointers to subexpressions
    ;; pim: postponed look-behind match
    ;; off: byte offset, when -1 go to next line
    (ยง
        ((ร regsubs_C subs =) subs_arg)

        (condp ==? (:c state)
           [NFA_NCLOSE
            NFA_MCLOSE NFA_MCLOSE1 NFA_MCLOSE2 NFA_MCLOSE3 NFA_MCLOSE4 NFA_MCLOSE5 NFA_MCLOSE6 NFA_MCLOSE7 NFA_MCLOSE8 NFA_MCLOSE9
            NFA_ZCLOSE NFA_ZCLOSE1 NFA_ZCLOSE2 NFA_ZCLOSE3 NFA_ZCLOSE4 NFA_ZCLOSE5 NFA_ZCLOSE6 NFA_ZCLOSE7 NFA_ZCLOSE8 NFA_ZCLOSE9
            NFA_MOPEN
            NFA_ZEND
            NFA_SPLIT
            NFA_EMPTY]
            (do
                ;; These nodes are not added themselves
                ;; but their "out0" and/or "out1" may be added below.
                (ร BREAK)
            )

           [NFA_BOL NFA_BOF]
            (do
                ;; "^" won't match past end-of-line, don't bother trying.
                ;; Except when at the end of the line, or when we are going
                ;; to the next line for a look-behind match.
                (when (and (BLT @regline, @reginput) (non-eos? @reginput) (or (nil? @nfa_endp) (some? @reg_match) (== @reglnum (:lnum (:se_pos @nfa_endp)))))
                    ((ร RETURN) subs)
                )
                (ร FALLTHROUGH)
            )

           [NFA_MOPEN1 NFA_MOPEN2 NFA_MOPEN3 NFA_MOPEN4 NFA_MOPEN5 NFA_MOPEN6 NFA_MOPEN7 NFA_MOPEN8 NFA_MOPEN9
            NFA_ZOPEN
            NFA_ZOPEN1 NFA_ZOPEN2 NFA_ZOPEN3 NFA_ZOPEN4 NFA_ZOPEN5 NFA_ZOPEN6 NFA_ZOPEN7 NFA_ZOPEN8 NFA_ZOPEN9
            NFA_NOPEN
            NFA_ZSTART]

                ;; These nodes need to be added so that we can bail out
                ;; when it was added to this list before at the same
                ;; position to avoid an endless loop for "\(\)*"

            (ร DEFAULT)
            (do
                (when (and (== (... (:lastlist state) @nfa_ll_index) (:id nfl)) (!= (:c state) NFA_SKIP))
                    ;; This state is already in the list, don't add it again,
                    ;; unless it is an MOPEN that is used for a backreference or
                    ;; when there is a PIM.  For NFA_MATCH check the position,
                    ;; lower position is preferred.
                    (if (and (not @nfa_has_backref) (nil? pim) (not (:has_pim nfl)) (!= (:c state) NFA_MATCH))
                        ((ร RETURN) subs)
                    )

                    ;; Do not add the state again when it exists with the same positions.
                    (if (has-state-with-pos nfl, state, subs, pim)
                        ((ร RETURN) subs)
                    )
                )

                ;; When there are backreferences or PIMs,
                ;; the number of states may be (a lot) bigger than anticipated.
                (when (== (:n nfl) (:len nfl))
                    (when (!= subs @temp_subs)
                        ;; "subs" may point into the current array,
                        ;; need to make a copy before it becomes invalid.
                        (copy-sub (:rs_norm @temp_subs), (:rs_norm subs))
                        (if @nfa_has_zsubexpr
                            (copy-sub (:rs_synt @temp_subs), (:rs_synt subs)))
                        ((ร subs =) @temp_subs)
                    )

                    ((ร int newlen =) (+ (/ (* (:len nfl) 3) 2) 50))
                    ((ร nfa_thread_C[] a =) (ARRAY-nfa-thread newlen))
                    (dotimes [#_int i (:n nfl)]
                        (COPY-nfa-thread (... a i), (... (:threads nfl) i))
                    )
                    ((ร nfl =) (assoc nfl :threads a))
                    ((ร nfl =) (assoc nfl :len newlen))
                )

                ;; add the state to the list
                ((ร state.lastlist[@nfa_ll_index] =) (:id nfl))
                ((ร nfa_thread_C thread =) (... (:threads nfl) (ร nfl.n++)))
                ((ร thread =) (assoc thread :state state))
                (cond (nil? pim)
                (do
                    ((ร thread =) (assoc-in thread [:th_pim :result] NFA_PIM_UNUSED))
                )
                :else
                (do
                    (copy-pim (:th_pim thread), pim)
                    ((ร nfl =) (assoc nfl :has_pim true))
                ))
                (copy-sub (:rs_norm (:th_subs thread)), (:rs_norm subs))
                (when @nfa_has_zsubexpr
                    (copy-sub (:rs_synt (:th_subs thread)), (:rs_synt subs)))

                (ร BREAK)
            )
        )

        (condp ==? (:c state)
            NFA_MATCH
            (do
                (ร BREAK)
            )

            NFA_SPLIT
            (do
                ;; order matters here
                ((ร subs =) (addstate nfl, (.out0 state), subs, pim, off))
                ((ร subs =) (addstate nfl, (.out1 state), subs, pim, off))
                (ร BREAK)
            )

           [NFA_EMPTY NFA_NOPEN NFA_NCLOSE]
            (do
                ((ร subs =) (addstate nfl, (.out0 state), subs, pim, off))
                (ร BREAK)
            )

           [NFA_MOPEN NFA_MOPEN1 NFA_MOPEN2 NFA_MOPEN3 NFA_MOPEN4 NFA_MOPEN5 NFA_MOPEN6 NFA_MOPEN7 NFA_MOPEN8 NFA_MOPEN9
            NFA_ZOPEN NFA_ZOPEN1 NFA_ZOPEN2 NFA_ZOPEN3 NFA_ZOPEN4 NFA_ZOPEN5 NFA_ZOPEN6 NFA_ZOPEN7 NFA_ZOPEN8 NFA_ZOPEN9
            NFA_ZSTART]
            (do
                (ร int subidx)
                (ร regsub_C sub)
                (cond (== (:c state) NFA_ZSTART)
                (do
                    ((ร subidx =) 0)
                    ((ร sub =) (:rs_norm subs))
                )
                (and (<= NFA_ZOPEN (:c state)) (<= (:c state) NFA_ZOPEN9))
                (do
                    ((ร subidx =) (- (:c state) NFA_ZOPEN))
                    ((ร sub =) (:rs_synt subs))
                )
                :else
                (do
                    ((ร subidx =) (- (:c state) NFA_MOPEN))
                    ((ร sub =) (:rs_norm subs))
                ))

                ((ร lpos_C save_lpos =) (NEW_lpos_C))
                ((ร save_lpos.lnum =) 0)
                ((ร save_lpos.col =) 0)
                ((ร Bytes save_ptr =) nil)

                (ร int save_in_use)
                ;; Set the position (with "off" added) in the subexpression.
                ;; Save and restore it when it was in use.
                ;; Otherwise fill any gap.
                (cond (nil? @reg_match)
                (do
                    (cond (< subidx (:in_use sub))
                    (do
                        ((ร save_lpos.lnum =) (:start_lnum (... (:rs_multi sub) subidx)))
                        ((ร save_lpos.col =) (:start_col (... (:rs_multi sub) subidx)))
                        ((ร save_in_use =) -1)
                    )
                    :else
                    (do
                        ((ร save_in_use =) (:in_use sub))
                        (loop-when-recur [#_int i (:in_use sub)] (< i subidx) [(inc i)]
                            ((ร sub.rs_multi[i].start_lnum =) -1)
                            ((ร sub.rs_multi[i].end_lnum =) -1)
                        )
                        ((ร sub =) (assoc sub :in_use (inc subidx)))
                    ))
                    (cond (== off -1)
                    (do
                        ((ร sub.rs_multi[subidx].start_lnum =) (inc @reglnum))
                        ((ร sub.rs_multi[subidx].start_col =) 0)
                    )
                    :else
                    (do
                        ((ร sub.rs_multi[subidx].start_lnum =) @reglnum)
                        ((ร sub.rs_multi[subidx].start_col =) (+ (BDIFF @reginput, @regline) off))
                    ))
                )
                :else
                (do
                    (cond (< subidx (:in_use sub))
                    (do
                        ((ร save_ptr =) (:start (... (:rs_line sub) subidx)))
                        ((ร save_in_use =) -1)
                    )
                    :else
                    (do
                        ((ร save_in_use =) (:in_use sub))
                        (loop-when-recur [#_int i (:in_use sub)] (< i subidx) [(inc i)]
                            ((ร sub.rs_line[i].start =) nil)
                            ((ร sub.rs_line[i].end =) nil)
                        )
                        ((ร sub =) (assoc sub :in_use (inc subidx)))
                    ))
                    ((ร sub.rs_line[subidx].start =) (.plus @reginput off))
                ))

                ((ร subs =) (addstate nfl, (.out0 state), subs, pim, off))
                ;; "subs" may have changed, need to set "sub" again
                ((ร sub =) (if (<= NFA_ZOPEN (:c state) NFA_ZOPEN9) (:rs_synt subs) (:rs_norm subs)))

                (cond (== save_in_use -1)
                (do
                    (cond (nil? @reg_match)
                    (do
                        ((ร sub.rs_multi[subidx].start_lnum =) (:lnum save_lpos))
                        ((ร sub.rs_multi[subidx].start_col =) (:col save_lpos))
                    )
                    :else
                    (do
                        ((ร sub.rs_line[subidx].start =) save_ptr)
                    ))
                )
                :else
                (do
                    ((ร sub =) (assoc sub :in_use save_in_use))
                ))

                (ร BREAK)
            )

            NFA_MCLOSE
            (do
                (when (and @nfa_has_zend (if (nil? @reg_match)) (<= 0 (:end_lnum (... (:rs_multi (:rs_norm subs)) 0))) (some? (:end (... (:rs_line (:rs_norm subs)) 0))))
                    ;; Do not overwrite the position set by \ze.
                    ((ร subs =) (addstate nfl, (.out0 state), subs, pim, off))
                    (ร BREAK)
                )
            )
           [NFA_MCLOSE1 NFA_MCLOSE2 NFA_MCLOSE3 NFA_MCLOSE4 NFA_MCLOSE5 NFA_MCLOSE6 NFA_MCLOSE7 NFA_MCLOSE8 NFA_MCLOSE9
            NFA_ZCLOSE
            NFA_ZCLOSE1 NFA_ZCLOSE2 NFA_ZCLOSE3 NFA_ZCLOSE4 NFA_ZCLOSE5 NFA_ZCLOSE6 NFA_ZCLOSE7 NFA_ZCLOSE8 NFA_ZCLOSE9
            NFA_ZEND]
            (do
                (ร int subidx)
                (ร regsub_C sub)
                (cond (== (:c state) NFA_ZEND)
                (do
                    ((ร subidx =) 0)
                    ((ร sub =) (:rs_norm subs))
                )
                (and (<= NFA_ZCLOSE (:c state)) (<= (:c state) NFA_ZCLOSE9))
                (do
                    ((ร subidx =) (- (:c state) NFA_ZCLOSE))
                    ((ร sub =) (:rs_synt subs))
                )
                :else
                (do
                    ((ร subidx =) (- (:c state) NFA_MCLOSE))
                    ((ร sub =) (:rs_norm subs))
                ))

                ((ร lpos_C save_lpos =) (NEW_lpos_C))
                (ร Bytes save_ptr)

                ;; We don't fill in gaps here, there must have been an MOPEN that has done that.
                ((ร int save_in_use =) (:in_use sub))
                ((ร sub =) (update sub :in_use max (inc subidx)))
                (cond (nil? @reg_match)
                (do
                    ((ร save_lpos.lnum =) (:end_lnum (... (:rs_multi sub) subidx)))
                    ((ร save_lpos.col =) (:end_col (... (:rs_multi sub) subidx)))
                    (cond (== off -1)
                    (do
                        ((ร sub.rs_multi[subidx].end_lnum =) (inc @reglnum))
                        ((ร sub.rs_multi[subidx].end_col =) 0)
                    )
                    :else
                    (do
                        ((ร sub.rs_multi[subidx].end_lnum =) @reglnum)
                        ((ร sub.rs_multi[subidx].end_col =) (+ (BDIFF @reginput, @regline) off))
                    ))
                    ((ร save_ptr =) nil)
                )
                :else
                (do
                    ((ร save_ptr =) (:end (... (:rs_line sub) subidx)))
                    ((ร sub.rs_line[subidx].end =) (.plus @reginput off))

                    ((ร save_lpos.lnum =) 0)
                    ((ร save_lpos.col =) 0)
                ))

                ((ร subs =) (addstate nfl, (.out0 state), subs, pim, off))
                ;; "subs" may have changed, need to set "sub" again
                ((ร sub =) (if (<= NFA_ZCLOSE (:c state) NFA_ZCLOSE9) (:rs_synt subs) (:rs_norm subs)))

                (cond (nil? @reg_match)
                (do
                    ((ร sub.rs_multi[subidx].end_lnum =) (:lnum save_lpos))
                    ((ร sub.rs_multi[subidx].end_col =) (:col save_lpos))
                )
                :else
                (do
                    ((ร sub.rs_line[subidx].end =) save_ptr)
                ))
                ((ร sub =) (assoc sub :in_use save_in_use))

                (ร BREAK)
            )
        )

        subs
    ))

;; Like addstate(), but the new state(s) are put at position "*ip".
;; Used for zero-width matches, next state to use is the added one.
;; This makes sure the order of states to be tried does not change,
;; which matters for alternatives.

(defn- #_void addstate-here [#_nfa_list_C nfl, #_nfa_state_C state, #_regsubs_C subs, #_nfa_pim_C pim, #_int* ip]
    ;; nfl: runtime state list
    ;; state: state to update
    ;; subs: pointers to subexpressions
    ;; pim: postponed look-behind match
    (ยง
        ((ร int tlen =) (:n nfl))
        ((ร int lidx =) (... ip 0))

        ;; first add the state(s) at the end, so that we know how many there are
        (addstate nfl, state, subs, pim, 0)

        ;; when "*ip" was at the end of the list, nothing to do
        (if (== (inc lidx) tlen)
            ((ร RETURN) nil)
        )

        ;; re-order to put the new state at the current position
        ((ร int count =) (- (:n nfl) tlen))
        (if (zero? count)
            ((ร RETURN) nil) ;; no state got added
        )

        (cond (== count 1)
        (do
            ;; overwrite the current state
            (COPY-nfa-thread (... (:threads nfl) lidx), (... (:threads nfl) (dec (:n nfl))))
        )
        (< 1 count)
        (do
            (cond (<= (:len nfl) (dec (+ (:n nfl) count)))
            (do
                ;; not enough space to move the new states,
                ;; reallocate the list and move the states to the right position
                ((ร int newlen =) (+ (/ (* (:len nfl) 3) 2) 50))
                ((ร nfa_thread_C[] a =) (ARRAY-nfa-thread newlen))
                (dotimes [#_int i lidx]
                    (COPY-nfa-thread (... a i), (... (:threads nfl) i))
                )
                (dotimes [#_int i count]
                    (COPY-nfa-thread (... a (+ lidx i)), (... (:threads nfl) (+ (- (:n nfl) count) i)))
                )
                (loop-when-recur [#_int i 0] (< i (- (:n nfl) count lidx 1)) [(inc i)]
                    (COPY-nfa-thread (... a (+ lidx count i)), (... (:threads nfl) (+ lidx 1 i)))
                )
                ((ร nfl =) (assoc nfl :threads a))
                ((ร nfl =) (assoc nfl :len newlen))
            )
            :else
            (do
                ;; make space for new states, then move them from the end to the current position
                (loop-when-recur [#_int i (dec (:n nfl))] (<= (inc lidx) i) [(dec i)]
                    (COPY-nfa-thread (... (:threads nfl) (dec (+ i count))), (... (:threads nfl) i))
                )
                (dotimes [#_int i count]
                    (COPY-nfa-thread (... (:threads nfl) (+ lidx i)), (... (:threads nfl) (+ (dec (:n nfl)) i)))
                )
            ))
        ))

        ((ร nfl =) (update nfl :n dec))
        ((ร ip[0] =) (dec lidx))
        nil
    ))

;; Check character class "class" against current character c.

(defn- #_boolean check-char-class [#_int klass, #_int c]
    (condp == klass
        NFA_CLASS_ALNUM     (and (<= 1 c 255) (asc-isalnum c))
        NFA_CLASS_ALPHA     (and (<= 1 c 255) (asc-isalpha c))
        NFA_CLASS_BLANK     (any == c (byte \space) TAB)
        NFA_CLASS_CNTRL     (and (<= 1 c 255) (asc-iscntrl c))
        NFA_CLASS_DIGIT     (asc-isdigit c)
        NFA_CLASS_GRAPH     (and (<= 1 c 255) (asc-isgraph c))
        NFA_CLASS_LOWER     (utf-islower c)
        NFA_CLASS_PRINT     (vim-isprintc c)
        NFA_CLASS_PUNCT     (and (<= 1 c 255) (asc-ispunct c))
        NFA_CLASS_SPACE     (or (<= TAB c CAR) (== c (byte \space)))
        NFA_CLASS_UPPER     (utf-isupper c)
        NFA_CLASS_XDIGIT    (asc-isxdigit c)
        NFA_CLASS_TAB       (== c TAB)
        NFA_CLASS_RETURN    (== c (byte \return))
        NFA_CLASS_BACKSPACE (== c (byte \backspace))
        NFA_CLASS_ESCAPE    (== c ESC)
        (do (emsgn e_ill_char_class, (long klass)) false) ;; should not be here :P
    ))

;; Check for a match with subexpression "i".
;; Return true if it matches.

(defn- #_boolean match-backref [#_regsub_C sub, #_int i, #_int' a'len]
    ;; sub: pointers to subexpressions
    ;; len: out: length of match in bytes
    (cond (<= (:in_use sub) i)
        (do (reset! a'len 0) true) ;; backref was not set, match an empty string
    (nil? @reg_match)
        (let [rsi (... (:rs_multi sub) i)]
            (cond (or (neg? (:start_lnum rsi)) (neg? (:end_lnum rsi)))
                (do (reset! a'len 0) true) ;; backref was not set, match an empty string
            (and (== (:start_lnum rsi) @reglnum) (== (:end_lnum rsi) @reglnum))
                (let [a'n (atom (int (- (:end_col rsi) (:start_col rsi))))]
                    (if (zero? (cstrncmp (.plus @regline (:start_col rsi)), @reginput, a'n))
                        (do (reset! a'len @a'n) true)
                        false
                    ))
            :else
                (== (match-with-backref (:start_lnum rsi), (:start_col rsi), (:end_lnum rsi), (:end_col rsi), a'len) RA_MATCH)
            ))
    :else
        (let [rsi (... (:rs_line sub) i)]
            (cond (or (nil? (:start rsi)) (nil? (:end rsi)))
                (do (reset! a'len 0) true) ;; backref was not set, match an empty string
            :else
                (let [a'n (atom (int (BDIFF (:end rsi), (:start rsi))))]
                    (if (zero? (cstrncmp (:start rsi), @reginput, a'n))
                        (do (reset! a'len @a'n) true)
                        false
                    ))
            ))
    ))

;; Check for a match with \z subexpression "i".
;; Return true if it matches.

(defn- #_boolean match-zref [#_int i, #_int' a'len] ;; len: out: length of match in bytes
    (cleanup-zsubexpr)
    (if (or (nil? @re_extmatch_in) (nil? (... (:matches @re_extmatch_in) i)))
        ;; backref was not set, match an empty string
        (do (reset! a'len 0) true)
        (let [a'n (atom (int (STRLEN (... (:matches @re_extmatch_in) i))))]
            (if (zero? (cstrncmp (... (:matches @re_extmatch_in) i), @reginput, a'n))
                (do (reset! a'len @a'n) true)
                false
            ))
    ))

;; Save list IDs for all NFA states of "prog" into "list".
;; Also reset the IDs to zero.
;; Only used for the recursive value lastlist[1].

(defn- #_void nfa-save-listids [#_nfa_regprog_C prog, #_int* list]
    (ยง
        ;; Order in the list is reverse, it's a bit faster that way.
        (loop-when-recur [#_int i 0 #_int n (dec (:nstate prog))] (<= 0 n) [(inc i) (dec n)]
            ((ร nfa_state_C state =) (... (:states prog) i))
            (when (nil? state)
                ((ร list[n] =) 0)
                (ร CONTINUE)
            )

            ((ร list[n] =) (... (:lastlist state) 1))
            ((ร state.lastlist[1] =) 0)
        )
        nil
    ))

;; Restore list IDs from "list" to all NFA states.

(defn- #_void nfa-restore-listids [#_nfa_regprog_C prog, #_int* list]
    (ยง
        (loop-when-recur [#_int i 0 #_int n (dec (:nstate prog))] (<= 0 n) [(inc i) (dec n)]
            ((ร nfa_state_C state =) (... (:states prog) i))
            (if (nil? state)
                (ร CONTINUE)
            )

            ((ร state.lastlist[1] =) (... list n))
        )
        nil
    ))

(defn- #_boolean nfa-re-num-cmp [#_long val, #_int op, #_long pos]
    (condp == op 1 (< val pos) 2 (< pos val) (== val pos)))

;; Recursively call nfa-regmatch()
;; "pim" is null or contains info about a Postponed Invisible Match (start position).

(defn- #_int recursive-regmatch [#_nfa_state_C state, #_nfa_pim_C pim, #_nfa_regprog_C prog, #_regsubs_C submatch, #_regsubs_C m, #_int** listids]
    (ยง
        ((ร int save_reginput_col =) (BDIFF @reginput, @regline))
        ((ร long save_reglnum =) @reglnum)
        ((ร int save_nfa_match =) @nfa_match)
        ((ร int save_nfa_listid =) @nfa_listid)
        ((ร save_se_C save_nfa_endp =) @nfa_endp)
        ((ร save_se_C endpos =) (NEW_save_se_C))
        ((ร save_se_C endposp =) nil)
        ((ร boolean need_restore =) false)

        (when (some? pim)
            ;; start at the position where the postponed match was
            (if (nil? @reg_match)
                (reset! reginput (.plus @regline (:col (:end_pos pim))))
                (reset! reginput (:end_ptr pim)))
        )

        (when (any == (:c state) NFA_START_INVISIBLE_BEFORE NFA_START_INVISIBLE_BEFORE_FIRST NFA_START_INVISIBLE_BEFORE_NEG NFA_START_INVISIBLE_BEFORE_NEG_FIRST)
            ;; The recursive match must end at the current position.
            ;; When "pim" is not null it specifies the current position.
            ((ร endposp =) endpos)
            (cond (nil? @reg_match)
            (do
                (cond (nil? pim)
                (do
                    ((ร endpos =) (assoc-in endpos [:se_pos :col] (BDIFF @reginput, @regline)))
                    ((ร endpos =) (assoc-in endpos [:se_pos :lnum] @reglnum))
                )
                :else
                (do
                    (COPY-lpos (:se_pos endpos), (:end_pos pim))
                ))
            )
            :else
            (do
                ((ร endpos =) (assoc endpos :se_ptr (if (nil? pim) @reginput (:end_ptr pim))))
            ))

            ;; Go back the specified number of bytes, or as far as the start of
            ;; the previous line, to try matching "\@<=" or not matching "\@<!".
            ;; This is very inefficient, limit the number of bytes if possible.

            (cond (<= (:val state) 0)
            (do
                (when (nil? @reg_match)
                    (reset! regline (reg-getline (swap! reglnum dec)))
                    (when (nil? @regline)
                        ;; can't go before the first line
                        (reset! regline (reg-getline (swap! reglnum inc)))
                    )
                )
                (reset! reginput @regline)
            )
            :else
            (do
                (when (and (nil? @reg_match) (< (BDIFF @reginput, @regline) (:val state)))
                    ;; Not enough bytes in this line, go to end of previous line.
                    (reset! regline (reg-getline (swap! reglnum dec)))
                    (cond (nil? @regline)
                    (do
                        ;; can't go before the first line
                        (reset! regline (reg-getline (swap! reglnum inc)))
                        (reset! reginput @regline)
                    )
                    :else
                    (do
                        (reset! reginput (.plus @regline (STRLEN @regline)))
                    ))
                )
                (cond (<= (:val state) (BDIFF @reginput, @regline))
                (do
                    (swap! reginput minus (:val state))
                    (swap! reginput #(.minus % (us-head-off @regline, %)))
                )
                :else
                (do
                    (reset! reginput @regline)
                ))
            ))
        )

        ;; Have to clear the lastlist field of the NFA nodes, so that
        ;; nfa-regmatch() and addstate() can run properly after recursion.
        (cond (== @nfa_ll_index 1)
        (do
            ;; Already calling nfa-regmatch() recursively.
            ;; Save the lastlist[1] values and clear them.
            (if (nil? (... listids 0))
                ((ร listids[0] =) (ร new int[prog.nstate]))
            )
            (nfa-save-listids prog, (... listids 0))
            ((ร need_restore =) true)
            ;; any value of nfa_listid will do
        )
        :else
        (do
            ;; First recursive nfa-regmatch() call, switch to the second lastlist entry.
            ;; Make sure nfa_listid is different from a previous recursive call,
            ;; because some states may still have this ID.
            (swap! nfa_ll_index inc)
            (if (<= @nfa_listid @nfa_alt_listid)
                (reset! nfa_listid @nfa_alt_listid))
        ))

        ;; Call nfa-regmatch() to check if the current concat matches at this position.
        ;; The concat ends with the node NFA_END_INVISIBLE.
        (reset! nfa_endp endposp)
        ((ร int result =) (nfa-regmatch prog, (.out0 state), submatch, m))

        (cond need_restore
        (do
            (nfa-restore-listids prog, (... listids 0))
        )
        :else
        (do
            (swap! nfa_ll_index dec)
            (reset! nfa_alt_listid @nfa_listid)
        ))

        ;; restore position in input text
        (reset! reglnum save_reglnum)
        (if (nil? @reg_match)
            (reset! regline (reg-getline @reglnum)))
        (reset! reginput (.plus @regline save_reginput_col))
        (reset! nfa_match save_nfa_match)
        (reset! nfa_endp save_nfa_endp)
        (reset! nfa_listid save_nfa_listid)

        result
    ))

;; Estimate the chance of a match with "state" failing.
;; empty match: 0
;; NFA_ANY: 1
;; specific character: 99

(defn- #_int failure-chance [#_nfa_state_C state, #_int depth]
    (if (< 4 depth) ;; detect looping
        1
        (let [#_int c (:c state)]
            (condp ==? c
                NFA_SPLIT
                    (if (or (== (.. state (out0) c) NFA_SPLIT) (== (.. state (out1) c) NFA_SPLIT))
                        1 ;; avoid recursive stuff
                        (min (failure-chance (.out0 state), (inc depth)) ;; two alternatives, use the lowest failure chance
                             (failure-chance (.out1 state), (inc depth))))

                NFA_ANY
                    1 ;; matches anything, unlikely to fail

               [NFA_MATCH
                NFA_MCLOSE
                NFA_ANY_COMPOSING]
                    0 ;; empty match works always

               [NFA_START_INVISIBLE
                NFA_START_INVISIBLE_FIRST
                NFA_START_INVISIBLE_NEG
                NFA_START_INVISIBLE_NEG_FIRST
                NFA_START_INVISIBLE_BEFORE
                NFA_START_INVISIBLE_BEFORE_FIRST
                NFA_START_INVISIBLE_BEFORE_NEG
                NFA_START_INVISIBLE_BEFORE_NEG_FIRST
                NFA_START_PATTERN]
                    5 ;; recursive regmatch is expensive, use low failure chance

               [NFA_BOL
                NFA_EOL
                NFA_BOF
                NFA_EOF
                NFA_NEWL]
                    99

               [NFA_BOW
                NFA_EOW]
                    90

               [NFA_MOPEN
                NFA_MOPEN1
                NFA_MOPEN2
                NFA_MOPEN3
                NFA_MOPEN4
                NFA_MOPEN5
                NFA_MOPEN6
                NFA_MOPEN7
                NFA_MOPEN8
                NFA_MOPEN9
                NFA_ZOPEN
                NFA_ZOPEN1
                NFA_ZOPEN2
                NFA_ZOPEN3
                NFA_ZOPEN4
                NFA_ZOPEN5
                NFA_ZOPEN6
                NFA_ZOPEN7
                NFA_ZOPEN8
                NFA_ZOPEN9
                NFA_ZCLOSE
                NFA_ZCLOSE1
                NFA_ZCLOSE2
                NFA_ZCLOSE3
                NFA_ZCLOSE4
                NFA_ZCLOSE5
                NFA_ZCLOSE6
                NFA_ZCLOSE7
                NFA_ZCLOSE8
                NFA_ZCLOSE9
                NFA_NOPEN
                NFA_MCLOSE1
                NFA_MCLOSE2
                NFA_MCLOSE3
                NFA_MCLOSE4
                NFA_MCLOSE5
                NFA_MCLOSE6
                NFA_MCLOSE7
                NFA_MCLOSE8
                NFA_MCLOSE9
                NFA_NCLOSE]
                    (failure-chance (.out0 state), (inc depth))

               [NFA_BACKREF1
                NFA_BACKREF2
                NFA_BACKREF3
                NFA_BACKREF4
                NFA_BACKREF5
                NFA_BACKREF6
                NFA_BACKREF7
                NFA_BACKREF8
                NFA_BACKREF9
                NFA_ZREF1
                NFA_ZREF2
                NFA_ZREF3
                NFA_ZREF4
                NFA_ZREF5
                NFA_ZREF6
                NFA_ZREF7
                NFA_ZREF8
                NFA_ZREF9]
                    94 ;; backreferences don't match in many places

               [NFA_LNUM_GT
                NFA_LNUM_LT
                NFA_COL_GT
                NFA_COL_LT
                NFA_VCOL_GT
                NFA_VCOL_LT
                NFA_MARK_GT
                NFA_MARK_LT
                NFA_VISUAL]
                    85 ;; before/after positions don't match very often

                NFA_LNUM
                    90

               [NFA_CURSOR
                NFA_COL
                NFA_VCOL
                NFA_MARK]
                    98 ;; specific positions rarely match

                NFA_COMPOSING
                    95

                (if (< 0 c)
                    95 ;; character match fails often
                    50 ;; something else, includes character classes
                )
            ))
    ))

;; Skip until the char "c" we know a match must start with.

(defn- #_boolean skip-to-start [#_int c, #_int' a'col]
    ;; Used often, do some work to avoid call overhead.
    (let [#_Bytes s (cstrchr (.plus @regline @a'col), c)]
        (if (some? s) (do (reset! a'col (BDIFF s, @regline)) true) false)
    ))

;; Check for a match with match_text.
;; Called after skip-to-start() has found regstart.
;; Returns zero for no match, 1 for a match.

(defn- #_long find-match-text [#_int startcol, #_int regstart, #_Bytes match_text]
    (ยง
        ((ร int[] a'col =) (atom (int startcol)))
        (loop []
            ((ร boolean match =) true)

            ((ร int len2 =) (loop-when [#_int len1 0 len2 (utf-char2len regstart)] (non-eos? match_text len1) => len2 ;; skip regstart
                ((ร int c1 =) (us-ptr2char match_text, len1))
                ((ร int c2 =) (us-ptr2char @regline, (+ @a'col len2)))
                (when (and (!= c1 c2) (or (not @ireg_ic) (!= (utf-tolower c1) (utf-tolower c2))))
                    ((ร match =) false)
                    (ร BREAK)
                )
                (recur (+ len1 (utf-char2len c1)) (+ len2 (utf-char2len c2)))
            ))

            ;; check that no composing char follows
            (when (and match (not (utf-iscomposing (us-ptr2char @regline, (+ @a'col len2)))))
                (cleanup-subexpr)
                (cond (nil? @reg_match)
                (do
                    ((ร @reg_startpos[0].lnum =) @reglnum)
                    ((ร @reg_startpos[0].col =) @a'col)
                    ((ร @reg_endpos[0].lnum =) @reglnum)
                    ((ร @reg_endpos[0].col =) (+ @a'col len2))
                )
                :else
                (do
                    ((ร @reg_startp[0] =) (.plus @regline @a'col))
                    ((ร @reg_endp[0] =) (.plus @regline (+ @a'col len2)))
                ))
                ((ร RETURN) 1)
            )

            ;; Try finding regstart after the current match.
            (swap! a'col + (utf-char2len regstart))                          ;; skip regstart
            (if (not (skip-to-start regstart, a'col))
                (ร BREAK)
            )
            (recur)
        )

        0
    ))

;; Main matching routine.
;;
;; Run NFA to determine whether it matches reginput.
;;
;; When "nfa_endp" is not null it is a required end-of-match position.
;;
;; Return true if there is a match, false otherwise.
;; When there is a match "submatch" contains the positions.
;; Note: Caller must ensure that: start != null.

(defn- #_int nfa-regmatch [#_nfa_regprog_C prog, #_nfa_state_C start, #_regsubs_C submatch, #_regsubs_C m]
    (ยง
        ((ร boolean toplevel =) (== (:c start) NFA_MOPEN))

        ;; Some patterns may take a long time to match, especially when using recursive-regmatch().
        ;; Allow interrupting them with CTRL-C.
        (if (fast-breakcheck)
            ((ร RETURN) FALSE)
        )
        (if (and (non-zero? @nfa_time_limit) (profile-passed-limit @nfa_time_limit))
            ((ร RETURN) FALSE)
        )

        (reset! nfa_match FALSE)

        ((ร nfa_list_C[] list =) (ARRAY-nfa-list 2))
        ((ร list[0].threads =) (ARRAY-nfa-thread ((ร list[0].len =) (inc (:nstate prog)))))
        ((ร list[1].threads =) (ARRAY-nfa-thread ((ร list[1].len =) (inc (:nstate prog)))))

        ((ร nfa_list_C thislist =) (... list 0))
        ((ร thislist =) (assoc thislist :n 0))
        ((ร thislist =) (assoc thislist :has_pim false))
        ((ร nfa_list_C nextlist =) (... list 1))
        ((ร nextlist =) (assoc nextlist :n 0))
        ((ร nextlist =) (assoc nextlist :has_pim false))
        ((ร thislist =) (assoc thislist :id (inc @nfa_listid)))

        ;; Inline optimized code for addstate(thislist, start, m, 0) if we know it's the first MOPEN.
        (cond toplevel
        (do
            (cond (nil? @reg_match)
            (do
                ((ร m.rs_norm.rs_multi[0].start_lnum =) @reglnum)
                ((ร m.rs_norm.rs_multi[0].start_col =) (BDIFF @reginput, @regline))
            )
            :else
            (do
                ((ร m.rs_norm.rs_line[0].start =) @reginput)
            ))
            ((ร m =) (assoc-in m [:rs_norm :in_use] 1))
            (addstate thislist, (.out0 start), m, nil, 0)
        )
        :else
        (do
            (addstate thislist, start, m, nil, 0)
        ))

        ((ร boolean go_to_nextline =) false)
        ((ร int flag =) 0)
; %%    ((ร int[][] listids =) (ร { null }))
        ((ร int add_off =) 0)

        ;; Run for each character.

        (loop []
            ((ร int curc =) (us-ptr2char @reginput))
            ((ร int clen =) (us-ptr2len-cc @reginput))
            (when (== curc NUL)
                ((ร clen =) 0)
                ((ร go_to_nextline =) false)
            )

            ;; swap lists
            ((ร thislist =) (... list flag))
            ((ร nextlist =) (... list ((ร flag =) (bit-xor flag 1))))
            ((ร nextlist =) (assoc nextlist :n 0))                 ;; clear nextlist
            ((ร nextlist =) (assoc nextlist :has_pim false))
            (swap! nfa_listid inc)
            (when (and (== (:re_engine prog) AUTOMATIC_ENGINE) (<= NFA_MAX_STATES @nfa_listid))
                ;; too many states, retry with old engine
                (reset! nfa_match NFA_TOO_EXPENSIVE)
                ((ร RETURN) @nfa_match)
            )

            ((ร thislist =) (assoc thislist :id @nfa_listid))
            ((ร nextlist =) (assoc nextlist :id (inc @nfa_listid)))

            ;; If the state lists are empty we can stop.

            (if (zero? (:n thislist))
                (ร BREAK)
            )

;           nextchar:
;           {
                ;; compute nextlist
                ((ร int[] a'lidx =) (atom (int)))
                (loop-when-recur (reset! a'lidx 0) (< @a'lidx (:n thislist)) (swap! a'lidx inc)
                    ((ร nfa_thread_C thread =) (... (:threads thislist) @a'lidx))

                    ;; Handle the possible codes of the current state.
                    ;; The most important is NFA_MATCH.

                    ((ร nfa_state_C add_state =) nil)
                    ((ร boolean add_here =) false)
                    ((ร int add_count =) 0)

                    (condp ==? (:c (:state thread))
                        NFA_MATCH
                        (do
                            ;; If the match ends before a composing characters and
                            ;; ireg_icombine is not set, that is not really a match.
                            (if (and (not @ireg_icombine) (utf-iscomposing curc))
                                (ร BREAK)
                            )
                            (reset! nfa_match TRUE)
                            (copy-sub (:rs_norm submatch), (:rs_norm (:th_subs thread)))
                            (if @nfa_has_zsubexpr
                                (copy-sub (:rs_synt submatch), (:rs_synt (:th_subs thread))))
                            ;; Found the left-most longest match, do not look at any other states
                            ;; at this position.  When the list of states is going to be empty
                            ;; quit without advancing, so that "reginput" is correct.
                            ((ร clen =) (if (zero? (:n nextlist)) 0 clen))
                            (ร BREAK nextchar)
                        )

                       [NFA_END_INVISIBLE NFA_END_INVISIBLE_NEG NFA_END_PATTERN]
                        (do
                            ;; This is only encountered after a NFA_START_INVISIBLE or
                            ;; NFA_START_INVISIBLE_BEFORE node.
                            ;; They surround a zero-width group, used with "\@=", "\&",
                            ;; "\@!", "\@<=" and "\@<!".
                            ;; If we got here, it means that the current "invisible" group
                            ;; finished successfully, so return control to the parent
                            ;; nfa-regmatch().  For a look-behind match only when it ends
                            ;; in the position in "nfa_endp".
                            ;; Submatches are stored in *m, and used in the parent call.

                            ;; If "nfa_endp" is set it's only a match if it ends at "nfa_endp".
                            (if (and (some? @nfa_endp) (if (nil? @reg_match) (or (!= @reglnum (:lnum (:se_pos @nfa_endp))) (!= (BDIFF @reginput, @regline) (:col (:se_pos @nfa_endp)))) (BNE @reginput, (:se_ptr @nfa_endp))))
                                (ร BREAK)
                            )

                            ;; do not set submatches for \@!
                            (when (!= (:c (:state thread)) NFA_END_INVISIBLE_NEG)
                                (copy-sub (:rs_norm m), (:rs_norm (:th_subs thread)))
                                (if @nfa_has_zsubexpr
                                    (copy-sub (:rs_synt m), (:rs_synt (:th_subs thread))))
                            )
                            (reset! nfa_match TRUE)
                            ;; See comment above at "goto nextchar".
                            ((ร clen =) (if (zero? (:n nextlist)) 0 clen))
                            (ร BREAK nextchar)
                        )

                       [NFA_START_INVISIBLE
                        NFA_START_INVISIBLE_FIRST
                        NFA_START_INVISIBLE_NEG
                        NFA_START_INVISIBLE_NEG_FIRST
                        NFA_START_INVISIBLE_BEFORE
                        NFA_START_INVISIBLE_BEFORE_FIRST
                        NFA_START_INVISIBLE_BEFORE_NEG
                        NFA_START_INVISIBLE_BEFORE_NEG_FIRST]
                        (do
                            ;; Do it directly if there already is a PIM or when
                            ;; nfa-postprocess() detected it will work better.
                            (cond (or (!= (:result (:th_pim thread)) NFA_PIM_UNUSED) (== (:c (:state thread)) NFA_START_INVISIBLE_FIRST) (== (:c (:state thread)) NFA_START_INVISIBLE_NEG_FIRST) (== (:c (:state thread)) NFA_START_INVISIBLE_BEFORE_FIRST) (== (:c (:state thread)) NFA_START_INVISIBLE_BEFORE_NEG_FIRST))
                            (do
                                ((ร int in_use =) (:in_use (:rs_norm m)))

                                ;; Copy submatch info for the recursive call,
                                ;; opposite of what happens on success below.
                                (copy-sub-off (:rs_norm m), (:rs_norm (:th_subs thread)))
                                (when @nfa_has_zsubexpr
                                    (copy-sub-off (:rs_synt m), (:rs_synt (:th_subs thread))))

                                ;; First try matching the invisible match, then what follows.

                                ((ร int result =) (recursive-regmatch (:state thread), nil, prog, submatch, m, listids))
                                (when (== result NFA_TOO_EXPENSIVE)
                                    (reset! nfa_match result)
                                    ((ร RETURN) @nfa_match)
                                )

                                ;; for \@! and \@<! it is a match when the result is false
                                (when (!= (!= result FALSE) (or (== (:c (:state thread)) NFA_START_INVISIBLE_NEG) (== (:c (:state thread)) NFA_START_INVISIBLE_NEG_FIRST) (== (:c (:state thread)) NFA_START_INVISIBLE_BEFORE_NEG) (== (:c (:state thread)) NFA_START_INVISIBLE_BEFORE_NEG_FIRST)))
                                    ;; Copy submatch info from the recursive call.
                                    (copy-sub-off (:rs_norm (:th_subs thread)), (:rs_norm m))
                                    (if @nfa_has_zsubexpr
                                        (copy-sub-off (:rs_synt (:th_subs thread)), (:rs_synt m)))
                                    ;; If the pattern has \ze and it matched in the sub pattern, use it.
                                    (copy-ze-off (:rs_norm (:th_subs thread)), (:rs_norm m))

                                    ;; thread.state.out1 is the corresponding END_INVISIBLE node.
                                    ;; Add its out0 to the current list (zero-width match).
                                    ((ร add_here =) true)
                                    ((ร add_state =) (.. thread state (out1) (out0)))
                                )
                                ((ร m =) (assoc-in m [:rs_norm :in_use] in_use))
                            )
                            :else
                            (do
                                ((ร nfa_pim_C pim =) (NEW_nfa_pim_C))

                                ;; First try matching what follows.  Only if a match
                                ;; is found verify the invisible match matches.  Add a
                                ;; nfa_pim_C to the following states, it contains info
                                ;; about the invisible match.

                                ((ร pim =) (assoc pim :state (:state thread)))
                                ((ร pim =) (assoc pim :result NFA_PIM_TODO))
                                ((ร pim.np_subs.rs_norm.in_use =) 0)
                                ((ร pim.np_subs.rs_synt.in_use =) 0)
                                (cond (nil? @reg_match)
                                (do
                                    ((ร pim =) (assoc-in pim [:end_pos :col] (BDIFF @reginput, @regline)))
                                    ((ร pim =) (assoc-in pim [:end_pos :lnum] @reglnum))
                                )
                                :else
                                (do
                                    ((ร pim =) (assoc pim :end_ptr @reginput))
                                ))

                                ;; thread.state.out1 is the corresponding END_INVISIBLE node.
                                ;; Add its out0 to the current list (zero-width match).
                                (addstate-here thislist, (.. thread state (out1) (out0)), (:th_subs thread), pim, lidx)
                            ))
                            (ร BREAK)
                        )

                        NFA_START_PATTERN
                        (do
                            ((ร nfa_state_C skip =) nil)

                            ;; There is no point in trying to match the pattern
                            ;; if the output state is not going to be added to the list.
                            (cond (state-in-list nextlist, (.. thread state (out1) (out0)), (:th_subs thread))
                            (do
                                ((ร skip =) (.. thread state (out1) (out0)))
                            )
                            (state-in-list nextlist, (.. thread state (out1) (out0) (out0)), (:th_subs thread))
                            (do
                                ((ร skip =) (.. thread state (out1) (out0) (out0)))
                            )
                            (state-in-list thislist, (.. thread state (out1) (out0) (out0)), (:th_subs thread))
                            (do
                                ((ร skip =) (.. thread state (out1) (out0) (out0)))
                            ))

                            (if (some? skip)
                                (ร BREAK)
                            )

                            ;; Copy submatch info to the recursive call, opposite of what happens afterwards.
                            (copy-sub-off (:rs_norm m), (:rs_norm (:th_subs thread)))
                            (when @nfa_has_zsubexpr
                                (copy-sub-off (:rs_synt m), (:rs_synt (:th_subs thread))))

                            ;; First try matching the pattern.
                            ((ร int result =) (recursive-regmatch (:state thread), nil, prog, submatch, m, listids))
                            (when (== result NFA_TOO_EXPENSIVE)
                                (reset! nfa_match result)
                                ((ร RETURN) @nfa_match)
                            )
                            (when (!= result FALSE)
                                (ร int bytelen)

                                ;; Copy submatch info from the recursive call.
                                (copy-sub-off (:rs_norm (:th_subs thread)), (:rs_norm m))
                                (if @nfa_has_zsubexpr
                                    (copy-sub-off (:rs_synt (:th_subs thread)), (:rs_synt m)))
                                ;; Now we need to skip over the matched text and
                                ;; then continue with what follows.
                                (cond (nil? @reg_match)
                                (do
                                    ;; TODO: multi-line match
                                    ((ร bytelen =) (- (:end_col (... (:rs_multi (:rs_norm m)) 0)) (BDIFF @reginput, @regline)))
                                )
                                :else
                                (do
                                    ((ร bytelen =) (BDIFF (:end (... (:rs_line (:rs_norm m)) 0)), @reginput))
                                ))

                                (cond (zero? bytelen)
                                (do
                                    ;; Empty match: output of corresponding NFA_END_PATTERN/NFA_SKIP
                                    ;; to be used at current position.
                                    ((ร add_here =) true)
                                    ((ร add_state =) (.. thread state (out1) (out0) (out0)))
                                )
                                (<= bytelen clen)
                                (do
                                    ;; Match current character, output of corresponding
                                    ;; NFA_END_PATTERN to be used at next position.
                                    ((ร add_state =) (.. thread state (out1) (out0) (out0)))
                                    ((ร add_off =) clen)
                                )
                                :else
                                (do
                                    ;; Skip over the matched characters, set character count in NFA_SKIP.
                                    ((ร add_state =) (.. thread state (out1) (out0)))
                                    ((ร add_off =) bytelen)
                                    ((ร add_count =) (- bytelen clen))
                                ))
                            )
                            (ร BREAK)
                        )

                        NFA_BOL
                        (do
                            (when (BEQ @reginput, @regline)
                                ((ร add_here =) true)
                                ((ร add_state =) (.. thread state (out0)))
                            )
                            (ร BREAK)
                        )

                        NFA_EOL
                        (do
                            (when (== curc NUL)
                                ((ร add_here =) true)
                                ((ร add_state =) (.. thread state (out0)))
                            )
                            (ร BREAK)
                        )

                        NFA_BOW
                        (do
                            ((ร boolean result =) true)
                            (cond (== curc NUL)
                            (do
                                ((ร result =) false)
                            )
                            :else
                            (do
                                ;; Get class of current and previous char (if it exists).
                                ((ร int this_class =) (us-get-class @reginput))
                                (cond (<= this_class 1)
                                (do
                                    ((ร result =) false)
                                )
                                (== (reg-prev-class) this_class)
                                (do
                                    ((ร result =) false)
                                ))
                            ))
                            (when result
                                ((ร add_here =) true)
                                ((ร add_state =) (.. thread state (out0)))
                            )
                            (ร BREAK)
                        )

                        NFA_EOW
                        (do
                            ((ร boolean result =) true)
                            (cond (BEQ @reginput, @regline)
                            (do
                                ((ร result =) false)
                            )
                            :else
                            (do
                                ;; Get class of current and previous char (if it exists).
                                ((ร int this_class =) (us-get-class @reginput))
                                ((ร int prev_class =) (reg-prev-class))
                                ((ร result =) (if (or (== this_class prev_class) (zero? prev_class) (== prev_class 1)) false result))
                            ))
                            (when result
                                ((ร add_here =) true)
                                ((ร add_state =) (.. thread state (out0)))
                            )
                            (ร BREAK)
                        )

                        NFA_BOF
                        (do
                            (when (and (zero? @reglnum) (BEQ @reginput, @regline) (or (some? @reg_match) (== @reg_firstlnum 1)))
                                ((ร add_here =) true)
                                ((ร add_state =) (.. thread state (out0)))
                            )
                            (ร BREAK)
                        )

                        NFA_EOF
                        (do
                            (when (and (== @reglnum @reg_maxline) (== curc NUL))
                                ((ร add_here =) true)
                                ((ร add_state =) (.. thread state (out0)))
                            )
                            (ร BREAK)
                        )

                        NFA_COMPOSING
                        (do
                            ((ร int mc =) curc)
                            ((ร int[] cchars =) (ร new int[MAX_MCO]))
                            ((ร int ccount =) 0)

                            ((ร nfa_state_C sta =) (.. thread state (out0)))
                            ((ร int len =) 0)
                            (when (utf-iscomposing (:c sta))
                                ;; Only match composing character(s), ignore base character.
                                ;; Used for ".{composing}" and "{composing}" (no preceding character).
                                ((ร len =) (+ len (utf-char2len mc)))
                            )

                            (ร boolean result)
                            (cond (and @ireg_icombine (zero? len))
                            (do
                                ;; If \Z was present, then ignore composing characters.
                                ;; When ignoring the base character this always matches.
                                ((ร result =) (not (and (zero? len) (!= (:c sta) curc))))
                                (loop-when [] (!= (:c sta) NFA_END_COMPOSING)
                                    ((ร sta =) (.out0 sta))
                                    (recur)
                                )
                            )
                            ;; Check base character matches first, unless ignored.
                            (or (< 0 len) (== mc (:c sta)))
                            (do
                                (when (zero? len)
                                    ((ร len =) (+ len (utf-char2len mc)))
                                    ((ร sta =) (.out0 sta))
                                )

                                ;; We don't care about the order of composing characters.
                                ;; Get them into cchars[] first.
                                (loop-when [] (< len clen)
                                    ((ร mc =) (us-ptr2char @reginput, len))
                                    ((ร cchars[ccount++] =) mc)
                                    ((ร len =) (+ len (utf-char2len mc)))
                                    (if (== ccount MAX_MCO)
                                        (ร BREAK)
                                    )
                                    (recur)
                                )

                                ;; Check that each composing char in the pattern matches
                                ;; a composing char in the text.
                                ;; We do not check if all composing chars are matched.
                                ((ร result =) true)
                                (loop-when [] (!= (:c sta) NFA_END_COMPOSING)
                                    ((ร int j =) (loop-when-recur [j 0] (< j ccount) [(inc j)] => j
                                        (if (== (... cchars j) (:c sta))
                                            (ร BREAK)
                                        )
                                    ))
                                    (when (== j ccount)
                                        ((ร result =) false)
                                        (ร BREAK)
                                    )
                                    ((ร sta =) (.out0 sta))
                                    (recur)
                                )
                            )
                            :else
                            (do
                                ((ร result =) false)
                            ))

                            ((ร nfa_state_C end =) (.. thread state (out1)))    ;; NFA_END_COMPOSING

                            (when result
                                ((ร add_state =) (.out0 end))
                                ((ร add_off =) clen)
                            )
                            (ร BREAK)
                        )

                        NFA_NEWL
                        (do
                            (cond (and (== curc NUL) (not @reg_line_lbr) (nil? @reg_match) (<= @reglnum @reg_maxline))
                            (do
                                ((ร go_to_nextline =) true)
                                ;; Pass -1 for the offset, which means
                                ;; taking the position at the start of the next line.
                                ((ร add_state =) (.. thread state (out0)))
                                ((ร add_off =) -1)
                            )
                            (and (== curc (byte \newline)) @reg_line_lbr)
                            (do
                                ;; match \n as if it is an ordinary character
                                ((ร add_state =) (.. thread state (out0)))
                                ((ร add_off =) 1)
                            ))
                            (ร BREAK)
                        )

                       [NFA_START_COLL NFA_START_NEG_COLL]
                        (do
                            ;; What follows is a list of characters, until NFA_END_COLL.
                            ;; One of them must match or none of them must match.

                            ;; Never match EOL.
                            ;; If it's part of the collection it is added as a separate state with an OR.
                            (if (== curc NUL)
                                (ร BREAK)
                            )

                            ((ร boolean result_if_matched =) (== (:c (:state thread)) NFA_START_COLL))

                            ((ร boolean result =) false)	;; %% anno dunno
                            (loop-when-recur [#_nfa_state_C state (.. thread state (out0))] true [(.out0 state)]
                                (when (== (:c state) NFA_END_COLL)
                                    ((ร result =) (not result_if_matched))
                                    (ร BREAK)
                                )
                                (cond (== (:c state) NFA_RANGE_MIN)
                                (do
                                    ((ร int c1 =) (:val state))
                                    ((ร state =) (.out0 state)) ;; advance to NFA_RANGE_MAX
                                    ((ร int c2 =) (:val state))
                                    (when (<= c1 curc c2)
                                        ((ร result =) result_if_matched)
                                        (ร BREAK)
                                    )
                                    (when @ireg_ic
                                        ((ร int curc_low =) (utf-tolower curc))
                                        ((ร boolean done =) false)

                                        (loop-when c1 (<= c1 c2)
                                            (when (== (utf-tolower c1) curc_low)
                                                ((ร result =) result_if_matched)
                                                ((ร done =) true)
                                                (ร BREAK)
                                            )
                                            (recur (inc c1))
                                        )
                                        (if done
                                            (ร BREAK)
                                        )
                                    )
                                )
                                (if (< (:c state) 0) (check-char-class (:c state), curc) (or (== curc (:c state)) (and @ireg_ic (== (utf-tolower curc) (utf-tolower (:c state))))))
                                (do
                                    ((ร result =) result_if_matched)
                                    (ร BREAK)
                                ))
                            )
                            (when result
                                ;; next state is in out of the NFA_END_COLL,
                                ;; out1 of START points to the END state
                                ((ร add_state =) (.. thread state (out1) (out0)))
                                ((ร add_off =) clen)
                            )
                            (ร BREAK)
                        )

                        NFA_ANY
                        (do
                            ;; Any char except NUL, (end of input) does not match.
                            (when (< 0 curc)
                                ((ร add_state =) (.. thread state (out0)))
                                ((ร add_off =) clen)
                            )
                            (ร BREAK)
                        )

                        NFA_ANY_COMPOSING
                        (do
                            ;; On a composing character skip over it.
                            ;; Otherwise do nothing.
                            ;; Always matches.
                            (cond (utf-iscomposing curc)
                            (do
                                ((ร add_off =) clen)
                            )
                            :else
                            (do
                                ((ร add_here =) true)
                                ((ร add_off =) 0)
                            ))
                            ((ร add_state =) (.. thread state (out0)))
                            (ร BREAK)
                        )

                        ;; Character classes like \a for alpha, \d for digit etc.

                        NFA_IDENT     ;;  \i
                        (do
                            ((ร boolean result =) (vim-isidentc curc))
                            (when result
                                ((ร add_state =) (.. thread state (out0)))
                                ((ร add_off =) clen)
                            )
                            (ร BREAK)
                        )

                        NFA_SIDENT    ;;  \I
                        (do
                            ((ร boolean result =) (and (not (asc-isdigit curc)) (vim-isidentc curc)))
                            (when result
                                ((ร add_state =) (.. thread state (out0)))
                                ((ร add_off =) clen)
                            )
                            (ร BREAK)
                        )

                        NFA_KWORD     ;;  \k
                        (do
                            ((ร boolean result =) (us-iswordp @reginput))
                            (when result
                                ((ร add_state =) (.. thread state (out0)))
                                ((ร add_off =) clen)
                            )
                            (ร BREAK)
                        )

                        NFA_SKWORD    ;;  \K
                        (do
                            ((ร boolean result =) (and (not (asc-isdigit curc)) (us-iswordp @reginput)))
                            (when result
                                ((ร add_state =) (.. thread state (out0)))
                                ((ร add_off =) clen)
                            )
                            (ร BREAK)
                        )

                        NFA_FNAME     ;;  \f
                        (do
                            ((ร boolean result =) (vim-isfnamec curc))
                            (when result
                                ((ร add_state =) (.. thread state (out0)))
                                ((ร add_off =) clen)
                            )
                            (ร BREAK)
                        )

                        NFA_SFNAME    ;;  \F
                        (do
                            ((ร boolean result =) (and (not (asc-isdigit curc)) (vim-isfnamec curc)))
                            (when result
                                ((ร add_state =) (.. thread state (out0)))
                                ((ร add_off =) clen)
                            )
                            (ร BREAK)
                        )

                        NFA_PRINT     ;;  \p
                        (do
                            ((ร boolean result =) (vim-isprintc (us-ptr2char @reginput)))
                            (when result
                                ((ร add_state =) (.. thread state (out0)))
                                ((ร add_off =) clen)
                            )
                            (ร BREAK)
                        )

                        NFA_SPRINT    ;;  \P
                        (do
                            ((ร boolean result =) (and (not (asc-isdigit curc)) (vim-isprintc (us-ptr2char @reginput))))
                            (when result
                                ((ร add_state =) (.. thread state (out0)))
                                ((ร add_off =) clen)
                            )
                            (ร BREAK)
                        )

                        NFA_WHITE     ;;  \s
                        (do
                            ((ร boolean result =) (vim-iswhite curc))
                            (when result
                                ((ร add_state =) (.. thread state (out0)))
                                ((ร add_off =) clen)
                            )
                            (ร BREAK)
                        )

                        NFA_NWHITE    ;;  \S
                        (do
                            ((ร boolean result =) (and (!= curc NUL) (not (vim-iswhite curc))))
                            (when result
                                ((ร add_state =) (.. thread state (out0)))
                                ((ร add_off =) clen)
                            )
                            (ร BREAK)
                        )

                        NFA_DIGIT     ;;  \d
                        (do
                            ((ร boolean result =) (ri-digit curc))
                            (when result
                                ((ร add_state =) (.. thread state (out0)))
                                ((ร add_off =) clen)
                            )
                            (ร BREAK)
                        )

                        NFA_NDIGIT    ;;  \D
                        (do
                            ((ร boolean result =) (and (!= curc NUL) (not (ri-digit curc))))
                            (when result
                                ((ร add_state =) (.. thread state (out0)))
                                ((ร add_off =) clen)
                            )
                            (ร BREAK)
                        )

                        NFA_HEX       ;;  \x
                        (do
                            ((ร boolean result =) (ri-hex curc))
                            (when result
                                ((ร add_state =) (.. thread state (out0)))
                                ((ร add_off =) clen)
                            )
                            (ร BREAK)
                        )

                        NFA_NHEX      ;;  \X
                        (do
                            ((ร boolean result =) (and (!= curc NUL) (not (ri-hex curc))))
                            (when result
                                ((ร add_state =) (.. thread state (out0)))
                                ((ร add_off =) clen)
                            )
                            (ร BREAK)
                        )

                        NFA_OCTAL     ;;  \o
                        (do
                            ((ร boolean result =) (ri-octal curc))
                            (when result
                                ((ร add_state =) (.. thread state (out0)))
                                ((ร add_off =) clen)
                            )
                            (ร BREAK)
                        )

                        NFA_NOCTAL    ;;  \O
                        (do
                            ((ร boolean result =) (and (!= curc NUL) (not (ri-octal curc))))
                            (when result
                                ((ร add_state =) (.. thread state (out0)))
                                ((ร add_off =) clen)
                            )
                            (ร BREAK)
                        )

                        NFA_WORD      ;;  \w
                        (do
                            ((ร boolean result =) (ri-word curc))
                            (when result
                                ((ร add_state =) (.. thread state (out0)))
                                ((ร add_off =) clen)
                            )
                            (ร BREAK)
                        )

                        NFA_NWORD     ;;  \W
                        (do
                            ((ร boolean result =) (and (!= curc NUL) (not (ri-word curc))))
                            (when result
                                ((ร add_state =) (.. thread state (out0)))
                                ((ร add_off =) clen)
                            )
                            (ร BREAK)
                        )

                        NFA_HEAD      ;;  \h
                        (do
                            ((ร boolean result =) (ri-head curc))
                            (when result
                                ((ร add_state =) (.. thread state (out0)))
                                ((ร add_off =) clen)
                            )
                            (ร BREAK)
                        )

                        NFA_NHEAD     ;;  \H
                        (do
                            ((ร boolean result =) (and (!= curc NUL) (not (ri-head curc))))
                            (when result
                                ((ร add_state =) (.. thread state (out0)))
                                ((ร add_off =) clen)
                            )
                            (ร BREAK)
                        )

                        NFA_ALPHA     ;;  \a
                        (do
                            ((ร boolean result =) (ri-alpha curc))
                            (when result
                                ((ร add_state =) (.. thread state (out0)))
                                ((ร add_off =) clen)
                            )
                            (ร BREAK)
                        )

                        NFA_NALPHA    ;;  \A
                        (do
                            ((ร boolean result =) (and (!= curc NUL) (not (ri-alpha curc))))
                            (when result
                                ((ร add_state =) (.. thread state (out0)))
                                ((ร add_off =) clen)
                            )
                            (ร BREAK)
                        )

                        NFA_LOWER     ;;  \l
                        (do
                            ((ร boolean result =) (ri-lower curc))
                            (when result
                                ((ร add_state =) (.. thread state (out0)))
                                ((ร add_off =) clen)
                            )
                            (ร BREAK)
                        )

                        NFA_NLOWER    ;;  \L
                        (do
                            ((ร boolean result =) (and (!= curc NUL) (not (ri-lower curc))))
                            (when result
                                ((ร add_state =) (.. thread state (out0)))
                                ((ร add_off =) clen)
                            )
                            (ร BREAK)
                        )

                        NFA_UPPER     ;;  \\u (sic!)
                        (do
                            ((ร boolean result =) (ri-upper curc))
                            (when result
                                ((ร add_state =) (.. thread state (out0)))
                                ((ร add_off =) clen)
                            )
                            (ร BREAK)
                        )

                        NFA_NUPPER    ;;  \U
                        (do
                            ((ร boolean result =) (and (!= curc NUL) (not (ri-upper curc))))
                            (when result
                                ((ร add_state =) (.. thread state (out0)))
                                ((ร add_off =) clen)
                            )
                            (ร BREAK)
                        )

                        NFA_LOWER_IC  ;; [a-z]
                        (do
                            ((ร boolean result =) (or (ri-lower curc) (and @ireg_ic (ri-upper curc))))
                            (when result
                                ((ร add_state =) (.. thread state (out0)))
                                ((ร add_off =) clen)
                            )
                            (ร BREAK)
                        )

                        NFA_NLOWER_IC ;; [^a-z]
                        (do
                            ((ร boolean result =) (and (!= curc NUL) (not (or (ri-lower curc) (and @ireg_ic (ri-upper curc))))))
                            (when result
                                ((ร add_state =) (.. thread state (out0)))
                                ((ร add_off =) clen)
                            )
                            (ร BREAK)
                        )

                        NFA_UPPER_IC  ;; [A-Z]
                        (do
                            ((ร boolean result =) (or (ri-upper curc) (and @ireg_ic (ri-lower curc))))
                            (when result
                                ((ร add_state =) (.. thread state (out0)))
                                ((ร add_off =) clen)
                            )
                            (ร BREAK)
                        )

                        NFA_NUPPER_IC ;; ^[A-Z]
                        (do
                            ((ร boolean result =) (and (!= curc NUL) (not (or (ri-upper curc) (and @ireg_ic (ri-lower curc))))))
                            (when result
                                ((ร add_state =) (.. thread state (out0)))
                                ((ร add_off =) clen)
                            )
                            (ร BREAK)
                        )

                       [NFA_BACKREF1
                        NFA_BACKREF2
                        NFA_BACKREF3
                        NFA_BACKREF4
                        NFA_BACKREF5
                        NFA_BACKREF6
                        NFA_BACKREF7
                        NFA_BACKREF8
                        NFA_BACKREF9
                        NFA_ZREF1
                        NFA_ZREF2
                        NFA_ZREF3
                        NFA_ZREF4
                        NFA_ZREF5
                        NFA_ZREF6
                        NFA_ZREF7
                        NFA_ZREF8
                        NFA_ZREF9] ;; \1 .. \9  \z1 .. \z9
                        (do
                            (ร int subidx)
                            ((ร int[] a'bytelen =) (atom (int)))

                            (ร boolean result)
                            (cond (<= (:c (:state thread)) NFA_BACKREF9)
                            (do
                                ((ร subidx =) (+ (- (:c (:state thread)) NFA_BACKREF1) 1))
                                ((ร result =) (match-backref (:rs_norm (:th_subs thread)), subidx, a'bytelen))
                            )
                            :else
                            (do
                                ((ร subidx =) (+ (- (:c (:state thread)) NFA_ZREF1) 1))
                                ((ร result =) (match-zref subidx, a'bytelen))
                            ))

                            (when result
                                (cond (zero? @a'bytelen)
                                (do
                                    ;; Empty match always works, output of NFA_SKIP to be used next.
                                    ((ร add_here =) true)
                                    ((ร add_state =) (.. thread state (out0) (out0)))
                                )
                                (<= @a'bytelen clen)
                                (do
                                    ;; Match current character, jump ahead to out of NFA_SKIP.
                                    ((ร add_state =) (.. thread state (out0) (out0)))
                                    ((ร add_off =) clen)
                                )
                                :else
                                (do
                                    ;; Skip over the matched characters, set character count in NFA_SKIP.
                                    ((ร add_state =) (.. thread state (out0)))
                                    ((ร add_off =) @a'bytelen)
                                    ((ร add_count =) (- @a'bytelen clen))
                                ))
                            )
                            (ร BREAK)
                        )

                        NFA_SKIP
                        (do
                            ;; character of previous matching \1 .. \9  or \@>
                            (cond (<= (- (:count thread) clen) 0)
                            (do
                                ;; end of match, go to what follows
                                ((ร add_state =) (.. thread state (out0)))
                                ((ร add_off =) clen)
                            )
                            :else
                            (do
                                ;; add state again with decremented count
                                ((ร add_state =) (:state thread))
                                ((ร add_off =) 0)
                                ((ร add_count =) (- (:count thread) clen))
                            ))
                            (ร BREAK)
                        )

                       [NFA_LNUM NFA_LNUM_GT NFA_LNUM_LT]
                        (do
                            ((ร boolean result =) (and (nil? @reg_match) (nfa-re-num-cmp (:val (:state thread)), (- (:c (:state thread)) NFA_LNUM), (+ @reglnum @reg_firstlnum))))
                            (when result
                                ((ร add_here =) true)
                                ((ร add_state =) (.. thread state (out0)))
                            )
                            (ร BREAK)
                        )

                       [NFA_COL NFA_COL_GT NFA_COL_LT]
                        (do
                            ((ร boolean result =) (nfa-re-num-cmp (:val (:state thread)), (- (:c (:state thread)) NFA_COL), (inc (BDIFF @reginput, @regline))))
                            (when result
                                ((ร add_here =) true)
                                ((ร add_state =) (.. thread state (out0)))
                            )
                            (ร BREAK)
                        )

                       [NFA_VCOL NFA_VCOL_GT NFA_VCOL_LT]
                        (do
                            ((ร int op =) (- (:c (:state thread)) NFA_VCOL))
                            ((ร int col =) (BDIFF @reginput, @regline))

                            ;; Bail out quickly when there can't be a match,
                            ;; avoid the overhead of win-linetabsize() on long lines.
                            (if (and (!= op 1) (< (* (:val (:state thread)) MB_MAXBYTES) col))
                                (ร BREAK)
                            )

                            ((ร boolean result =) false)
                            (when (and (== op 1) (< (:val (:state thread)) (dec col)) (< 100 col))
                                ;; Guess that a character won't use more columns than 'tabstop',
                                ;; with a minimum of 4.
                                ((ร int ts =) (max 4 (int @(:b_p_ts @curbuf))))
                                ((ร result =) (< (* (:val (:state thread)) ts) col))
                            )
                            ((ร result =) (if (not result) (nfa-re-num-cmp (:val (:state thread)), op, (inc (long (win-linetabsize @curwin, @regline, col)))) result))
                            (when result
                                ((ร add_here =) true)
                                ((ร add_state =) (.. thread state (out0)))
                            )
                            (ร BREAK)
                        )

                       [NFA_MARK NFA_MARK_GT NFA_MARK_LT]
                        (do
                            ((ร pos_C pos =) (getmark (:val (:state thread)), false))

                            ;; Compare the mark position to the match position.
                            ((ร boolean result =) (and (some? pos) (< 0 (:lnum pos)) (if (== (:lnum pos) (+ @reglnum @reg_firstlnum)) (if (== (:col pos) (BDIFF @reginput, @regline)) (== (:c (:state thread)) NFA_MARK) (if (< (:col pos) (BDIFF @reginput, @regline)) (== (:c (:state thread)) NFA_MARK_GT) (== (:c (:state thread)) NFA_MARK_LT))) (if (< (:lnum pos) (+ @reglnum @reg_firstlnum)) (== (:c (:state thread)) NFA_MARK_GT) (== (:c (:state thread)) NFA_MARK_LT)))))
                            (when result
                                ((ร add_here =) true)
                                ((ร add_state =) (.. thread state (out0)))
                            )
                            (ร BREAK)
                        )

                        NFA_CURSOR
                        (do
                            ((ร boolean result =) (and (== (+ @reglnum @reg_firstlnum) (:lnum (:w_cursor @curwin))) (== (BDIFF @reginput, @regline) (:col (:w_cursor @curwin)))))
                            (when result
                                ((ร add_here =) true)
                                ((ร add_state =) (.. thread state (out0)))
                            )
                            (ร BREAK)
                        )

                        NFA_VISUAL
                        (do
                            ((ร boolean result =) (reg-match-visual))
                            (when result
                                ((ร add_here =) true)
                                ((ร add_state =) (.. thread state (out0)))
                            )
                            (ร BREAK)
                        )

                       [NFA_MOPEN1 NFA_MOPEN2 NFA_MOPEN3 NFA_MOPEN4 NFA_MOPEN5 NFA_MOPEN6 NFA_MOPEN7 NFA_MOPEN8 NFA_MOPEN9
                        NFA_ZOPEN
                        NFA_ZOPEN1 NFA_ZOPEN2 NFA_ZOPEN3 NFA_ZOPEN4 NFA_ZOPEN5 NFA_ZOPEN6 NFA_ZOPEN7 NFA_ZOPEN8 NFA_ZOPEN9
                        NFA_NOPEN
                        NFA_ZSTART]
                        (do
                            ;; These states are only added to be able to bail out when
                            ;; they are added again, nothing is to be done.
                            (ร BREAK)
                        )

                        (ร DEFAULT)    ;; regular character
                        (do
                            ((ร int c =) (:c (:state thread)))

                            ((ร boolean result =) (== c curc))
                            ((ร result =) (if (and (not result) @ireg_ic) (== (utf-tolower c) (utf-tolower curc)) result))

                            ;; If ireg_icombine is not set only skip over the character itself.
                            ;; When it is set skip over composing characters.
                            ((ร clen =) (if (and result (not @ireg_icombine)) (utf-char2len curc) clen))

                            (when result
                                ((ร add_state =) (.. thread state (out0)))
                                ((ร add_off =) clen)
                            )
                            (ร BREAK)
                        )
                    )

                    (when (some? add_state)
                        ((ร nfa_pim_C pim =) (if (!= (:result (:th_pim thread)) NFA_PIM_UNUSED) (:th_pim thread) nil))

                        ;; Handle the postponed invisible match if the match might end
                        ;; without advancing and before the end of the line.
                        (when (and (some? pim) (or (zero? clen) (match-follows add_state, 0)))
                            (ร int result)
                            (cond (== (:result pim) NFA_PIM_TODO)
                            (do
                                ((ร result =) (recursive-regmatch (:state pim), pim, prog, submatch, m, listids))
                                ((ร pim =) (assoc pim :result (if (!= result FALSE) NFA_PIM_MATCH NFA_PIM_NOMATCH)))
                                ;; for \@! and \@<! it is a match when the result is false
                                (when (!= (!= result FALSE) (or (== (:c (:state pim)) NFA_START_INVISIBLE_NEG) (== (:c (:state pim)) NFA_START_INVISIBLE_NEG_FIRST) (== (:c (:state pim)) NFA_START_INVISIBLE_BEFORE_NEG) (== (:c (:state pim)) NFA_START_INVISIBLE_BEFORE_NEG_FIRST)))
                                    ;; Copy submatch info from the recursive call.
                                    (copy-sub-off (:rs_norm (:np_subs pim)), (:rs_norm m))
                                    (if @nfa_has_zsubexpr
                                        (copy-sub-off (:rs_synt (:np_subs pim)), (:rs_synt m)))
                                )
                            )
                            :else
                            (do
                                ((ร result =) (if (== (:result pim) NFA_PIM_MATCH) TRUE FALSE))
                            ))

                            ;; for \@! and \@<! it is a match when result is false
                            (cond (!= (!= result FALSE) (or (== (:c (:state pim)) NFA_START_INVISIBLE_NEG) (== (:c (:state pim)) NFA_START_INVISIBLE_NEG_FIRST) (== (:c (:state pim)) NFA_START_INVISIBLE_BEFORE_NEG) (== (:c (:state pim)) NFA_START_INVISIBLE_BEFORE_NEG_FIRST)))
                            (do
                                ;; Copy submatch info from the recursive call.
                                (copy-sub-off (:rs_norm (:th_subs thread)), (:rs_norm (:np_subs pim)))
                                (if @nfa_has_zsubexpr
                                    (copy-sub-off (:rs_synt (:th_subs thread)), (:rs_synt (:np_subs pim))))
                            )
                            :else
                            (do
                                ;; look-behind match failed, don't add the state
                                (ร CONTINUE)
                            ))

                            ;; Postponed invisible match was handled, don't add it to following states.
                            ((ร pim =) nil)
                        )

                        ((ร nfa_pim_C pim_copy =) (NEW_nfa_pim_C))

                        ;; If "pim" points into nfl.threads,
                        ;; it will become invalid when adding the state causes the list to be reallocated.
                        ;; Make a local copy to avoid that.
                        (when (== pim (:th_pim thread))
                            (copy-pim pim_copy, pim)
                            ((ร pim =) pim_copy)
                        )

                        (cond add_here
                        (do
                            (addstate-here thislist, add_state, (:th_subs thread), pim, lidx)
                        )
                        :else
                        (do
                            (addstate nextlist, add_state, (:th_subs thread), pim, add_off)
                            (if (< 0 add_count)
                                ((ร nextlist.threads[nextlist.n - 1].count =) add_count)
                            )
                        ))
                    )
                )

                ;; Look for the start of a match in the current position
                ;; by adding the start state to the list of states.
                ;; The first found match is the leftmost one, thus the order of states matters!
                ;; Do not add the start state in recursive calls of nfa-regmatch(),
                ;; because recursive calls should only start in the first position.
                ;; Unless "nfa_endp" is not null, then we match the end position.
                ;; Also don't start a match past the first line.

                (when (and (== @nfa_match FALSE) (or (and toplevel (== @reglnum 0) (non-zero? clen) (or (== @ireg_maxcol 0) (< (BDIFF @reginput, @regline) @ireg_maxcol))) (and (some? @nfa_endp) (if (nil? @reg_match) (or (< @reglnum (:lnum (:se_pos @nfa_endp))) (and (== @reglnum (:lnum (:se_pos @nfa_endp))) (< (BDIFF @reginput, @regline) (:col (:se_pos @nfa_endp))))) (BLT @reginput, (:se_ptr @nfa_endp))))))
                    ;; Inline optimized code for addstate() if we know the state is the first MOPEN.
                    (cond toplevel
                    (do
                        ((ร boolean add =) true)

                        (when (and (!= (:regstart prog) NUL) (non-zero? clen))
                            (cond (zero? (:n nextlist))
                            (do
                                ((ร int[] a'col =) (atom (int (+ (BDIFF @reginput, @regline) clen))))

                                ;; Nextlist is empty, we can skip ahead to the
                                ;; character that must appear at the start.
                                (if (not (skip-to-start (:regstart prog), a'col))
                                    (ร BREAK)
                                )
                                (reset! reginput (.plus @regline (- @a'col clen)))
                            )
                            :else
                            (do
                                ;; Checking if the required start character matches is
                                ;; cheaper than adding a state that won't match.
                                ((ร int c =) (us-ptr2char @reginput, clen))
                                ((ร add =) (if (and (!= c (:regstart prog)) (or (not @ireg_ic) (!= (utf-tolower c) (utf-tolower (:regstart prog))))) false add))
                            ))
                        )

                        (when add
                            (if (nil? @reg_match)
                                ((ร m.rs_norm.rs_multi[0].start_col =) (+ (BDIFF @reginput, @regline) clen))
                                ((ร m.rs_norm.rs_line[0].start =) (.plus @reginput clen))
                            )
                            (addstate nextlist, (.out0 start), m, nil, clen)
                        )
                    )
                    :else
                    (do
                        (addstate nextlist, start, m, nil, clen)
                    ))
                )
;           }

            ;; Advance to the next character, or advance to the next line, or finish.
            (cond (non-zero? clen)
            (do
                (swap! reginput plus clen)
            )
            (or go_to_nextline (and (some? @nfa_endp) (nil? @reg_match) (< @reglnum (:lnum (:se_pos @nfa_endp)))))
            (do
                (reg-nextline)
            )
            :else
            (do
                (ร BREAK)
            ))

            ;; Allow interrupting with CTRL-C.
            (if (slow-breakcheck)
                (ร BREAK)
            )

            ;; Check for timeout once in a twenty times to avoid overhead.
            (when (and (non-zero? @nfa_time_limit) (== (swap! nfa_time_count inc) 20))
                (reset! nfa_time_count 0)
                (if (profile-passed-limit @nfa_time_limit)
                    (ร BREAK)
                )
            )
            (recur)
        )

        @nfa_match
    ))

;; Try match of "prog" with at regline[col].
;; Returns <= 0 for failure, number of lines contained in the match otherwise.

(defn- #_long nfa-regtry [#_nfa_regprog_C prog, #_int col, #_long nsec]
    ;; nsec: timeout limit or 0
    (ยง
        ((ร regsubs_C subs =) (NEW_regsubs_C))
        ((ร regsubs_C m =) (NEW_regsubs_C))
        ((ร nfa_state_C start =) (:start prog))

        (reset! reginput (.plus @regline col))
        (reset! nfa_time_limit nsec)
        (reset! nfa_time_count 0)

        (clear-sub (:rs_norm subs))
        (clear-sub (:rs_norm m))
        (clear-sub (:rs_synt subs))
        (clear-sub (:rs_synt m))

        ((ร int result =) (nfa-regmatch prog, start, subs, m))
        (cond (== result FALSE)
        (do
            ((ร RETURN) 0)
        )
        (== result NFA_TOO_EXPENSIVE)
        (do
            ((ร RETURN) result)
        ))

        (cleanup-subexpr)
        (cond (nil? @reg_match)
        (do
            (loop-when-recur [#_int i 0] (< i (:in_use (:rs_norm subs))) [(inc i)]
                ((ร @reg_startpos[i].lnum =) (:start_lnum (... (:rs_multi (:rs_norm subs)) i)))
                ((ร @reg_startpos[i].col =) (:start_col (... (:rs_multi (:rs_norm subs)) i)))

                ((ร @reg_endpos[i].lnum =) (:end_lnum (... (:rs_multi (:rs_norm subs)) i)))
                ((ร @reg_endpos[i].col =) (:end_col (... (:rs_multi (:rs_norm subs)) i)))
            )

            (when (< (:lnum (... @reg_startpos 0)) 0)
                ((ร @reg_startpos[0].lnum =) 0)
                ((ร @reg_startpos[0].col =) col)
            )
            (cond (< (:lnum (... @reg_endpos 0)) 0)
            (do
                ;; pattern has a \ze but it didn't match, use current end
                ((ร @reg_endpos[0].lnum =) @reglnum)
                ((ร @reg_endpos[0].col =) (BDIFF @reginput, @regline))
            )
            :else
            (do
                ;; Use line number of "\ze".
                (reset! reglnum (:lnum (... @reg_endpos 0)))
            ))
        )
        :else
        (do
            (loop-when-recur [#_int i 0] (< i (:in_use (:rs_norm subs))) [(inc i)]
                ((ร @reg_startp[i] =) (:start (... (:rs_line (:rs_norm subs)) i)))
                ((ร @reg_endp[i] =) (:end (... (:rs_line (:rs_norm subs)) i)))
            )

            (if (nil? (... @reg_startp 0))
                ((ร @reg_startp[0] =) (.plus @regline col))
            )
            (if (nil? (... @reg_endp 0))
                ((ร @reg_endp[0] =) @reginput)
            )
        ))

        ;; Package any found \z(...\) matches for export.  Default is none.
        (reset! re_extmatch_out nil)

        (when (== (:reghasz prog) REX_SET)
            (cleanup-zsubexpr)
            (reset! re_extmatch_out (make-extmatch))
            (loop-when-recur [#_int i 0] (< i (:in_use (:rs_synt subs))) [(inc i)]
                (cond (nil? @reg_match)
                (do
                    ((ร multipos_C mp =) (... (:rs_multi (:rs_synt subs)) i))

                    ;; Only accept single line matches that are valid.
                    (if (and (<= 0 (:start_lnum mp)) (== (:start_lnum mp) (:end_lnum mp)) (<= (:start_col mp) (:end_col mp)))
                        ((ร @re_extmatch_out.matches[i] =) (STRNDUP (.plus (reg-getline (:start_lnum mp)) (:start_col mp)), (- (:end_col mp) (:start_col mp))))
                    )
                )
                :else
                (do
                    ((ร linepos_C lp =) (... (:rs_line (:rs_synt subs)) i))

                    (if (and (some? (:start lp)) (some? (:end lp)))
                        ((ร @re_extmatch_out.matches[i] =) (STRNDUP (:start lp), (BDIFF (:end lp), (:start lp))))
                    )
                ))
            )
        )

        (+ 1 @reglnum)
    ))

;; Match a regexp against
;;  a string ("line" points to the string)
;;  or multiple lines ("line" is null, use reg-getline()).
;;
;; Returns <= 0 for failure, number of lines contained in the match otherwise.

(defn- #_long nfa-regexec-both [#_Bytes line, #_int startcol, #_long nsec]
    ;; startcol: column to start looking for match
    ;; nsec: timeout limit or 0
    (ยง
        ((ร int[] a'col =) (atom (int startcol)))

        (ร nfa_regprog_C prog)
        (cond (nil? @reg_match)
        (do
            ((ร prog =) (ร (nfa_regprog_C)(@reg_mmatch.regprog)))
            ((ร line =) (reg-getline 0))              ;; relative to the cursor
            (reset! reg_startpos (:startpos @reg_mmatch))
            (reset! reg_endpos (:endpos @reg_mmatch))
        )
        :else
        (do
            ((ร prog =) (ร (nfa_regprog_C)(@reg_match.regprog)))
            (reset! reg_startp (:startp @reg_match))
            (reset! reg_endp (:endp @reg_match))
        ))

        ;; Be paranoid...
        (when (or (nil? prog) (nil? line))
            (emsg e_null)
            ((ร RETURN) 0)
        )

        ;; If pattern contains "\c" or "\C": overrule value of ireg_ic.
        (cond (flag? (:regflags prog) RF_ICASE)
        (do
            (reset! ireg_ic true)
        )
        (flag? (:regflags prog) RF_NOICASE)
        (do
            (reset! ireg_ic false)
        ))

        ;; If pattern contains "\Z" overrule value of ireg_icombine.
        (when (flag? (:regflags prog) RF_ICOMBINE)
            (reset! ireg_icombine true))

        (reset! regline line)
        (reset! reglnum 0)    ;; relative to line

        (reset! nfa_has_zend (:has_zend prog))
        (reset! nfa_has_backref (:has_backref prog))
        (reset! nfa_nsubexpr (:nsubexp prog))
        (reset! nfa_listid 1)
        (reset! nfa_alt_listid 2)
        ((ร nfa_regengine.expr =) (:pattern prog))

        (if (and (non-zero? (:reganch prog)) (< 0 @a'col))
            ((ร RETURN) 0)
        )

        (reset! need_clear_subexpr true)
        ;; Clear the external match subpointers if necessary.
        (cond (== (:reghasz prog) REX_SET)
        (do
            (reset! nfa_has_zsubexpr true)
            (reset! need_clear_zsubexpr true)
        )
        :else
        (do
            (reset! nfa_has_zsubexpr false)
        ))

        (when (!= (:regstart prog) NUL)
            ;; Skip ahead until a character we know the match must start with.
            ;; When there is none there is no match.
            (if (not (skip-to-start (:regstart prog), a'col))
                ((ร RETURN) 0)
            )

            ;; If match_text is set, it contains the full text that must match.
            ;; Nothing else to try.  Doesn't handle combining chars well.
            (if (and (some? (:match_text prog)) (not @ireg_icombine))
                ((ร RETURN) (find-match-text @a'col, (:regstart prog), (:match_text prog)))
            )
        )

        ;; If the start column is past the maximum column: no need to try.
        (if (and (< 0 @ireg_maxcol) (<= @ireg_maxcol @a'col))
            ((ร RETURN) 0)
        )

        (dotimes [#_int i (:nstate prog)]
            ((ร nfa_state_C state =) (... (:states prog) i))
            (if (nil? state)
                (ร CONTINUE)
            )

            ((ร state =) (assoc state :id i))
            ((ร state.lastlist[0] =) 0)
            ((ร state.lastlist[1] =) 0)
        )

        ((ร long retval =) (nfa-regtry prog, @a'col, nsec))

        ((ร nfa_regengine.expr =) nil)

        retval
    ))

;; Compile a regular expression into internal code for the NFA matcher.
;; Returns the program in allocated space.  Returns null for an error.

(defn- #_regprog_C nfa-regcomp [#_Bytes expr, #_int re_flags]
    (ยง
        (if (nil? expr)
            ((ร RETURN) nil)
        )

        (ร nfa_regprog_C prog)

        ((ร nfa_regengine.expr =) expr)
        (reset! nfa_re_flags re_flags)

        (nfa-regcomp-start expr, re_flags)

;       theend:
;       {
;           fail:
;           {
                ;; Build postfix form of the regexp.  Needed to build the NFA (and count its size).
                ((ร int[] postfix =) (re2post))
                (when (nil? postfix)
                    ;; TODO: only give this error for debugging?
                    (if (<= (:length @post_array) @post_index)
                        (emsgn (u8 "Internal error: estimated max number of states insufficient: %d"), (:length @post_array)))
                    (ร BREAK fail)         ;; cascaded (syntax?) error
                )

                ;; In order to build the NFA, we parse the input regexp twice:
                ;; 1. first pass to count size (so we can allocate space)
                ;; 2. second to emit code

                ((ร prog =) (new nfa_regprog_C))
                ((ร prog =) (assoc prog :nstate 0))

                ;; PASS 1
                ;; Count number of NFA states in "prog.nstate".  Do not build the NFA.

                (post2nfa postfix, @post_index, prog, true)

                ;; allocate space for the compiled regexp
                ((ร prog =) (assoc prog :states (ร new nfa_state_C[prog.nstate])))
                (reset! nfa_states (:states prog))
                ((ร prog =) (assoc prog :istate 0))

                ;; PASS 2
                ;; Build the NFA

                ((ร prog =) (assoc prog :start (post2nfa postfix, @post_index, prog, false)))
                (if (nil? (:start prog))
                    (ร BREAK fail)
                )

                ((ร prog =) (assoc prog :regflags @regflags))
                ((ร prog =) (assoc prog :engine nfa_regengine))
                ((ร prog =) (assoc prog :has_zend @nfa_has_zend))
                ((ร prog =) (assoc prog :has_backref @nfa_has_backref))
                ((ร prog =) (assoc prog :nsubexp @regnpar))

                (nfa-postprocess prog)

                ((ร prog =) (assoc prog :reganch (if (nfa-get-reganch (:start prog), 0) 1 0)))
                ((ร prog =) (assoc prog :regstart (nfa-get-regstart (:start prog), 0)))
                ((ร prog =) (assoc prog :match_text (nfa-get-match-text (:start prog))))

                ;; Remember whether this pattern has any \z specials in it.
                ((ร prog =) (assoc prog :reghasz @re_has_z))
                ((ร prog =) (assoc prog :pattern (STRDUP expr)))
                ((ร nfa_regengine.expr =) nil)
                (ร BREAK theend)
;           }

            ((ร prog =) nil)
            ((ร nfa_regengine.expr =) nil)
;       }

        (reset! post_array nil)
        (reset! post_index 0)
        (reset! nfa_states nil)

        (ร (regprog_C)prog)
    ))

;; Match a regexp against a string.
;; "rmp.regprog" is a compiled regexp as returned by nfa-regcomp().
;; Uses curbuf for line count and 'iskeyword'.
;; If "line_lbr" is true, consider a "\n" in "line" to be a line break.
;;
;; Returns <= 0 for failure, number of lines contained in the match otherwise.

(defn- #_long nfa-regexec-nl [#_regmatch_C rmp, #_Bytes line, #_int col, #_boolean line_lbr]
    ;; line: string to match against
    ;; col: column to start looking for match
    (reset! reg_match rmp)
    (reset! reg_mmatch nil)
    (reset! reg_maxline 0)
    (reset! reg_line_lbr line_lbr)
    (reset! ireg_ic (:rm_ic rmp))
    (reset! ireg_icombine false)
    (reset! ireg_maxcol 0)

    (nfa-regexec-both line, col, nil))

;; Match a regexp against multiple lines.
;; "rmp.regprog" is a compiled regexp as returned by vim-regcomp().
;; Uses curbuf for line count and 'iskeyword'.
;;
;; Return <= 0 if there is no match.  Return number of lines contained in the match otherwise.
;;
;; Note: the body is the same as bt_regexec() except for nfa-regexec-both()
;;
;; ! Also NOTE : match may actually be in another line. e.g.:
;; when r.e. is \nc, cursor is at 'a' and the text buffer looks like
;;
;; +-------------------------+
;; |a                        |
;; |b                        |
;; |c                        |
;; |                         |
;; +-------------------------+
;;
;; then nfa-regexec-multi() returns 3. while the original
;; vim-regexec-multi() returns 0 and a second call at line 2 will return 2.
;;
;; FIXME if this behavior is not compatible.

(defn- #_long nfa-regexec-multi [#_regmmatch_C rmp, #_long lnum, #_int col, #_long nsec]
    ;; lnum: nr of line to start looking for match
    ;; col: column to start looking for match
    ;; nsec: timeout limit or 0
    (reset! reg_match nil)
    (reset! reg_mmatch rmp)
    (reset! reg_firstlnum lnum)
    (reset! reg_maxline (- (line-count @curbuf) lnum))
    (reset! reg_line_lbr false)
    (reset! ireg_ic (:rmm_ic rmp))
    (reset! ireg_icombine false)
    (reset! ireg_maxcol (:rmm_maxcol rmp))

    (nfa-regexec-both nil, col, nsec))

;; ----------------------------------------------------------------------- ;;

;; Which regexp engine to use?  Needed for vim-regcomp().
;; Must match with 'regexpengine'.

(atom! int regexp_engine)

;; Compile a regular expression into internal code.
;; Returns the program in allocated memory.
;; Returns null for an error.

(defn- #_regprog_C vim-regcomp [#_Bytes expr_arg, #_int re_flags]
    (ยง
        ((ร regprog_C prog =) nil)
        ((ร Bytes expr =) expr_arg)

        (reset! regexp_engine (int @p_re))

        ;; Check for prefix "\%#=", that sets the regexp engine.
        (when (zero? (STRNCMP expr, (u8 "\\%#="), 4))
            ((ร int newengine =) (- (.at expr 4) (byte \0)))

            (cond (any == newengine AUTOMATIC_ENGINE BACKTRACKING_ENGINE NFA_ENGINE)
            (do
                (reset! regexp_engine (- (.at expr 4) (byte \0)))
                ((ร expr =) (.plus expr 5))
            )
            :else
            (do
                (emsg (u8 "E864: \\%#= can only be followed by 0, 1, or 2. The automatic engine will be used."))
                (reset! regexp_engine AUTOMATIC_ENGINE)
            ))
        )

        ((ร bt_regengine.expr =) expr)
        ((ร nfa_regengine.expr =) expr)

        ;; First try the NFA engine, unless backtracking was requested.

        ((ร prog =) (if (!= @regexp_engine BACKTRACKING_ENGINE)
            (.regcomp nfa_regengine expr, (+ re_flags (if (== @regexp_engine AUTOMATIC_ENGINE) RE_AUTO 0)))
            (.regcomp bt_regengine expr, re_flags)
        ))

        ;; Check for error compiling regexp with initial engine.
        (when (nil? prog)
            ;; If the NFA engine failed, try the backtracking engine.
            ;; The NFA engine also fails for patterns that it can't handle well
            ;; but are still valid patterns, thus a retry should work.

            (when (== @regexp_engine AUTOMATIC_ENGINE)
                (reset! regexp_engine BACKTRACKING_ENGINE)
                ((ร prog =) (.regcomp bt_regengine expr, re_flags))
            )
        )

        (when (some? prog)
            ;; Store the info needed to call regcomp() again when
            ;; the engine turns out to be very slow executing it.
            ((ร prog =) (assoc prog :re_engine @regexp_engine))
            ((ร prog =) (assoc prog :re_flags re_flags))
        )

        prog
    ))

(defn- #_void report-re-switch [#_Bytes pat]
    (when (< 0 @p_verbose)
        (msg-puts (u8 "Switching to backtracking RE engine for pattern: "))
        (msg-puts pat))
    nil)

;; Match a regexp against a string.
;; "rmp.regprog" is a compiled regexp as returned by vim-regcomp().
;; Note: "rmp.regprog" may be freed and changed.
;; Uses curbuf for line count and 'iskeyword'.
;; When "nl" is true, consider a "\n" in "line" to be a line break.
;;
;; Return true if there is a match, false if not.

(defn- #_boolean vim-regexec-both [#_regmatch_C rmp, #_Bytes line, #_int col, #_boolean nl]
    ;; line: string to match against
    ;; col: column to start looking for match
    (ยง
        ((ร long result =) (.regexec_nl (:engine (:regprog rmp)) rmp, line, col, nl))

        ;; NFA engine aborted because it's very slow.
        (when (and (== (:re_engine (:regprog rmp)) AUTOMATIC_ENGINE) (== result NFA_TOO_EXPENSIVE))
            ((ร long save_p_re =) @p_re)
            ((ร int re_flags =) (:re_flags (:regprog rmp)))
            ((ร Bytes pat =) (STRDUP (:pattern (ร (nfa_regprog_C)(rmp.regprog)))))

            (reset! p_re BACKTRACKING_ENGINE)
            ((ร rmp =) (assoc rmp :regprog nil))
            (when (some? pat)
                (report-re-switch pat)
                ((ร rmp =) (assoc rmp :regprog (vim-regcomp pat, re_flags)))
                ((ร result =) (if (some? (:regprog rmp)) (.regexec_nl (:engine (:regprog rmp)) rmp, line, col, nl) result))
            )
            (reset! p_re save_p_re)
        )

        (< 0 result)
    ))

;; Note: "*prog" may be freed and changed.
;; Return true if there is a match, false if not.

(defn- #_boolean vim-regexec-prog [#_regprog_C* prog, #_boolean ignore_case, #_Bytes line, #_int col]
    (ยง
        ((ร regmatch_C regmatch =) (NEW_regmatch_C))
        ((ร regmatch =) (assoc regmatch :regprog (... prog 0)))
        ((ร regmatch =) (assoc regmatch :rm_ic ignore_case))

        ((ร boolean r =) (vim-regexec-both regmatch, line, col, false))

        ((ร prog[0] =) (:regprog regmatch))
        r
    ))

;; Note: "rmp.regprog" may be freed and changed.
;; Return true if there is a match, false if not.

(defn- #_boolean vim-regexec [#_regmatch_C rmp, #_Bytes line, #_int col]
    (vim-regexec-both rmp, line, col, false))

;; Like vim-regexec(), but consider a "\n" in "line" to be a line break.
;; Note: "rmp.regprog" may be freed and changed.
;; Return true if there is a match, false if not.

(defn- #_boolean vim-regexec-nl [#_regmatch_C rmp, #_Bytes line, #_int col]
    (vim-regexec-both rmp, line, col, true))

;; Match a regexp against multiple lines.
;; "rmp.regprog" is a compiled regexp as returned by vim-regcomp().
;; Note: "rmp.regprog" may be freed and changed.
;;
;; Return zero if there is no match.  Return number of lines contained in the match otherwise.

(defn- #_long vim-regexec-multi [#_regmmatch_C rmp, #_long lnum, #_int col, #_long nsec]
    ;; lnum: nr of line to start looking for match
    ;; col: column to start looking for match
    ;; nsec: timeout limit or 0
    (ยง
        ((ร long result =) (.regexec_multi (:engine (:regprog rmp)) rmp, lnum, col, nsec))

        ;; NFA engine aborted because it's very slow.
        (when (and (== (:re_engine (:regprog rmp)) AUTOMATIC_ENGINE) (== result NFA_TOO_EXPENSIVE))
            (let [#_long save_p_re @p_re]
                ((ร int re_flags =) (:re_flags (:regprog rmp)))
                ((ร Bytes pat =) (STRDUP (:pattern (ร (nfa_regprog_C)(rmp.regprog)))))

                (reset! p_re BACKTRACKING_ENGINE)
                ((ร rmp =) (assoc rmp :regprog nil))
                (when (some? pat)
                    (report-re-switch pat)
                    ((ร rmp =) (assoc rmp :regprog (vim-regcomp pat, re_flags)))
                    ((ร result =) (if (some? (:regprog rmp)) (.regexec_multi (:engine (:regprog rmp)) rmp, lnum, col, nsec) result))
                )
                (reset! p_re save_p_re)
            ))

        (max 0, result)
    ))

;;; ============================================================================================== VimP

;; search.c: code for normal mode searching commands ----------------------------------------------

;; Various search-related routines.  These fall into three groups:
;; 1. string searches (for /, ?, n, and N)
;; 2. character searches within a single line (for f, F, t, T, etc)
;; 3. "other" kinds of searches like the '%' command, and 'word' searches.

;; String searches
;;
;; The string search functions are divided into two levels:
;; lowest: searchit(); uses a pos_C for starting position and found match,
;; highest: do-search(); uses curwin.w_cursor; calls searchit().
;;
;; The last search pattern is remembered for repeating the same search.
;; This pattern is shared between the :g, :s, ? and / commands.
;; This is in search-regcomp().
;;
;; The actual string matching is done using a heavily modified version of
;; Henry Spencer's regular expression library.  See regexp.c.

;; The offset for a search command is store in a soff struct.
;; Note: only spats[0].sp_off is really used.
(class! #_final soffset_C
    [
        (field byte         dir)            ;; search direction, '/' or '?'
        (field boolean      line)           ;; search has line offset
        (field boolean      end)            ;; search set cursor at end
        (field long         off)            ;; line or char offset
    ])

;; A search pattern and its attributes are stored in a spat struct.
(class! #_final spat_C
    [
        (field Bytes        pat)            ;; the pattern (in allocated memory) or null
        (field boolean      magic)          ;; magicness of the pattern
        (field boolean      no_scs)         ;; no smartcase for this pattern
        (field soffset_C    sp_off      (NEW_soffset_C))
    ])

(defn- #_spat_C new-spat []
    (-> (NEW_spat_C) (assoc :magic true) (assoc-in [:sp_off :dir] (byte \/))))

;; Two search patterns are remembered: one for the :substitute command and one for other searches.
;; last_idx points to the one that was used the last time.

(atom! spat_C* #_"/*[2]*/" spats
    [
        (new-spat),         ;; last used search pat
        (new-spat)          ;; last used substitute pat
    ])
(atom! int last_idx)        ;; index in spats[] for RE_LAST

(atom! Bytes mr_pattern)    ;; pattern used by search-regcomp()

;; translate search pattern for vim-regcomp()
;;
;; pat_save == RE_SEARCH: save pat in spats[RE_SEARCH].pat (normal search cmd)
;; pat_save == RE_SUBST: save pat in spats[RE_SUBST].pat (:substitute command)
;; pat_save == RE_BOTH: save pat in both patterns (:global command)
;;
;; pat_use  == RE_SEARCH: use previous search pattern if "pat" is null
;; pat_use  == RE_SUBST: use previous substitute pattern if "pat" is null
;; pat_use  == RE_LAST: use last used pattern if "pat" is null
;;
;; options & SEARCH_HIS: put search string in history
;; options & SEARCH_KEEP: keep previous search pattern
;;
;; returns false if failed, true otherwise.

(defn- #_boolean search-regcomp [#_Bytes pat, #_int pat_save, #_int pat_use, #_int options, #_regmmatch_C regmatch]
    ;; regmatch: return: pattern and ignore-case flag
    (ยง
        (reset! rc_did_emsg false)
        ((ร boolean magic =) @p_magic)

        ;; If no pattern given, use a previously defined pattern.

        (cond (or (nil? pat) (eos? pat))
        (do
            ((ร int i =) (if (== pat_use RE_LAST) @last_idx pat_use))
            (when (nil? (:pat (... @spats i)))           ;; pattern was never defined
                (emsg (if (== pat_use RE_SUBST) e_nopresub e_noprevre))
                (reset! rc_did_emsg true)
                ((ร RETURN) false)
            )
            ((ร pat =) (:pat (... @spats i)))
            ((ร magic =) (:magic (... @spats i)))
            (reset! no_smartcase (:no_scs (... @spats i)))
        )
        (flag? options SEARCH_HIS)   ;; put new pattern in history
        (do
            (add-to-history HIST_SEARCH, pat, NUL)
        ))

        (reset! mr_pattern pat)

        ;; Save the currently used pattern in the appropriate place,
        ;; unless the pattern should not be remembered.

        (when (non-flag? options SEARCH_KEEP)
            ;; search or global command
            (if (any == pat_save RE_SEARCH RE_BOTH)
                (save-re-pat RE_SEARCH, pat, magic))
            ;; substitute or global command
            (if (any == pat_save RE_SUBST RE_BOTH)
                (save-re-pat RE_SUBST, pat, magic))
        )

        ((ร regmatch =) (assoc regmatch :rmm_ic (ignorecase pat)))
        ((ร regmatch =) (assoc regmatch :rmm_maxcol 0))
        ((ร regmatch =) (assoc regmatch :regprog (vim-regcomp pat, (if magic RE_MAGIC 0))))

        (some? (:regprog regmatch))
    ))

;; Get search pattern used by search-regcomp().

(defn- #_Bytes get-search-pat []
    @mr_pattern)

(defn- #_void save-re-pat [#_int idx, #_Bytes pat, #_boolean magic]
    (when (BNE (:pat (... @spats idx)), pat)
        (swap! spats update idx assoc :pat (STRDUP pat) :magic magic :no_scs @no_smartcase)
        (reset! last_idx idx)
        ;; If 'hlsearch' set and search 'pat' changed: need redraw.
        (when @p_hls
            (redraw-all-later SOME_VALID))
        (reset! no_hlsearch false))
    nil)

;; Return true when case should be ignored for search pattern "pat".
;; Uses the 'ignorecase' and 'smartcase' options.

(defn- #_boolean ignorecase [#_Bytes pat]
    (let [#_boolean ic @p_ic ic (if (and ic (not @no_smartcase) @p_scs) (not (pat-has-uppercase pat)) ic)]
        (reset! no_smartcase false)
        ic
    ))

;; Return true if patter "pat" has an uppercase character.

(defn- #_boolean pat-has-uppercase [#_Bytes pat]
    (loop-when [#_Bytes p pat] (non-eos? p) => false
        (let [#_int n (us-ptr2len-cc p)
              n (cond (< 1 n)
                    (if (utf-isupper (us-ptr2char p)) 0 n)
                (at? p (byte \\))
                    (cond
                        (and (at? p 1 (byte \_)) (non-eos? p 2)) 3 ;; skip "\_X"
                        (and (at? p 1 (byte \%)) (non-eos? p 2)) 3 ;; skip "\%X"
                                                 (non-eos? p 1)  2 ;; skip "\X"
                        :else 1)
                (utf-isupper (.at p 0))
                    0
                :else
                    1)]
            (recur-if (pos? n) [(.plus p n)] => true)
        )
    ))

(defn- #_Bytes last-search-pat []
    (:pat (... @spats @last_idx)))

;; Get a regexp program for the last used search pattern.
;; This is used for highlighting all matches in a window.
;; Values returned in regmatch.regprog and regmatch.rmm_ic.

(defn- #_void last-pat-prog [#_regmmatch_C regmatch]
    (ยง
        (when (nil? (:pat (... @spats @last_idx)))
            ((ร regmatch =) (assoc regmatch :regprog nil))
            ((ร RETURN) nil)
        )

        (swap! emsg_off inc)         ;; So it doesn't beep if bad expr
        (search-regcomp (u8 ""), 0, @last_idx, SEARCH_KEEP, regmatch)
        (swap! emsg_off dec)
        nil
    ))

(final Bytes top_bot_msg (u8 "search hit TOP, continuing at BOTTOM"))
(final Bytes bot_top_msg (u8 "search hit BOTTOM, continuing at TOP"))

;; Lowest level search function.
;; Search for 'count'th occurrence of pattern 'pat' in direction 'dir'.
;; Start at position 'pos' and return the found position in 'pos'.
;;
;; if (options & SEARCH_MSG) == 0 don't give any messages
;; if (options & SEARCH_MSG) == SEARCH_NFMSG don't give 'notfound' messages
;; if (options & SEARCH_MSG) == SEARCH_MSG give all messages
;; if (options & SEARCH_HIS) put search pattern in history
;; if (options & SEARCH_END) return position at end of match
;; if (options & SEARCH_START) accept match at pos itself
;; if (options & SEARCH_KEEP) keep previous search pattern
;; if (options & SEARCH_FOLD) match only once in a closed fold
;; if (options & SEARCH_PEEK) check for typed char, cancel search
;;
;; Return false (zero) for failure, non-zero for success.
;; When FEAT_EVAL is defined, returns the index of the first matching
;; subpattern plus one; one if there was none.

(defn- #_int searchit [#_pos_C pos, #_int dir, #_Bytes pat, #_long count, #_int options, #_int pat_use, #_long stop_lnum, #_long nsec]
    ;; pat_use: which pattern to use when "pat" is empty
    ;; stop_lnum: stop after this line number when != 0
    ;; nsec: timeout limit or 0
    (ยง
        ((ร int submatch =) 0)

        ((ร boolean first_match =) true)
        ((ร boolean save_called_emsg =) @called_emsg)
        ((ร boolean break_loop =) false)

        ((ร regmmatch_C regmatch =) (NEW_regmmatch_C))
        (when (not (search-regcomp pat, RE_SEARCH, pat_use, (& options (+ SEARCH_HIS SEARCH_KEEP)), regmatch))
            (if (and (flag? options SEARCH_MSG) (not @rc_did_emsg))
                (emsg2 (u8 "E383: Invalid search string: %s"), @mr_pattern))
            ((ร RETURN) 0)
        )

        (ร boolean found)
        (ร long lnum)

        ((ร pos_C start_pos =) (NEW_pos_C))
        ((ร lpos_C matchpos =) (NEW_lpos_C))
        ((ร lpos_C endpos =) (NEW_lpos_C))

        ;; find the string

        (reset! called_emsg false)
;       do  ;; loop for count
;       {
            ;; When not accepting a match at the start position, set "extra_col" to a non-zero value.
            ;; Don't do that when starting at MAXCOL, since MAXCOL + 1 is zero.
            (ร int extra_col)
            (cond (or (flag? options SEARCH_START) (== (:col pos) MAXCOL))
            (do
                ((ร extra_col =) 0)
            )
            ;; Watch out for the "col" being MAXCOL - 2, used in a closed fold.
            (and (!= dir BACKWARD) (<= 1 (:lnum pos)) (<= (:lnum pos) (line-count @curbuf)) (< (:col pos) (- MAXCOL 2)))
            (do
                ((ร Bytes ptr =) (.plus (ml-get (:lnum pos)) (:col pos)))
                ((ร extra_col =) (if (eos? ptr) 1 (us-ptr2len-cc ptr)))
            )
            :else
            (do
                ((ร extra_col =) 1)
            ))

            (COPY-pos start_pos, pos)       ;; remember start pos for detecting no match
            ((ร found =) false)                  ;; default: not found
            ((ร boolean at_first_line =) true)   ;; default: start in first line
            (when (zero? (:lnum pos))              ;; correct lnum for when starting in line 0
                ((ร pos =) (assoc pos :lnum 1))
                ((ร pos =) (assoc pos :col 0))
                ((ร at_first_line =) false)      ;; not in first line now
            )

            ;; Start searching in current line, unless searching backwards and we're in column 0.
            ;; If we are searching backwards, in column 0, and not including the
            ;; current position, gain some efficiency by skipping back a line.
            ;; Otherwise begin the search in the current line.

            (cond (and (== dir BACKWARD) (zero? (:col start_pos)) (non-flag? options SEARCH_START))
            (do
                ((ร lnum =) (dec (:lnum pos)))
                ((ร at_first_line =) false)
            )
            :else
            (do
                ((ร lnum =) (:lnum pos))
            ))

            (loop-when-recur [#_int loop 0] (< loop 2) [(inc loop)]   ;; loop twice if 'wrapscan' set
                ((ร lnum =) (loop-when-recur lnum (and (< 0 lnum) (<= lnum (line-count @curbuf))) [(+ lnum dir)] => lnum
                    ;; Stop after checking "stop_lnum", if it's set.
                    (if (and (non-zero? stop_lnum) (if (== dir FORWARD) (< stop_lnum lnum) (< lnum stop_lnum)))
                        (ร BREAK)
                    )
                    ;; Stop after passing the 'nsec' time limit.
                    (if (and (non-zero? nsec) (profile-passed-limit nsec))
                        (ร BREAK)
                    )

                    ;; Look for a match somewhere in line "lnum".

                    ((ร long nmatched =) (vim-regexec-multi regmatch, lnum, 0, nsec))
                    ;; Abort searching on an error (e.g., out of stack).
                    (if @called_emsg
                        (ร BREAK)
                    )
                    (when (< 0 nmatched)
                        ;; match may actually be in another line when using \zs
                        (COPY-lpos matchpos, (... (:startpos regmatch) 0))
                        (COPY-lpos endpos, (... (:endpos regmatch) 0))
                        ((ร submatch =) (first-submatch regmatch))
                        ;; "lnum" may be past end of buffer for "\n\zs".
                        ((ร Bytes ptr =) (if (< (line-count @curbuf) (+ lnum (:lnum matchpos))) (u8 "") (ml-get (+ lnum (:lnum matchpos)))))

                        ;; Forward search in the first line: match should be after
                        ;; the start position.  If not, continue at the end of the
                        ;; match (this is vi compatible) or on the next char.

                        (when (and (== dir FORWARD) at_first_line)
                            ((ร boolean match_ok =) true)

                            ;; When the match starts in a next line it's certainly
                            ;; past the start position.
                            ;; When match lands on a NUL the cursor will be put
                            ;; one back afterwards, compare with that position,
                            ;; otherwise "/$" will get stuck on end of line.

                            (loop-when [] (and (zero? (:lnum matchpos)) (if (and (flag? options SEARCH_END) first_match) (and (== nmatched 1) (< (dec (:col endpos)) (+ (:col start_pos) extra_col))) (< (- (:col matchpos) (if (at? ptr (:col matchpos) NUL) 1 0)) (+ (:col start_pos) extra_col))))
                                ;; If vi-compatible searching, continue at the end
                                ;; of the match, otherwise continue one position forward.

                                (ร int matchcol)
                                (cond (some? (vim-strbyte @p_cpo, CPO_SEARCH))
                                (do
                                    (when (< 1 nmatched)
                                        ;; end is in next line, thus no match in this line
                                        ((ร match_ok =) false)
                                        (ร BREAK)
                                    )
                                    ((ร matchcol =) (:col endpos))
                                    ;; for empty match: advance one char
                                    ((ร matchcol =) (if (and (== matchcol (:col matchpos)) (non-eos? ptr matchcol)) (+ matchcol (us-ptr2len-cc ptr, matchcol)) matchcol))
                                )
                                :else
                                (do
                                    ((ร matchcol =) (:col matchpos))
                                    ((ร matchcol =) (if (non-eos? ptr matchcol) (+ matchcol (us-ptr2len-cc ptr, matchcol)) matchcol))
                                ))
                                (if (and (zero? matchcol) (flag? options SEARCH_START))
                                    (ร BREAK)
                                )
                                (when (or (eos? ptr matchcol) (zero? ((ร nmatched =) (vim-regexec-multi regmatch, (+ lnum (:lnum matchpos)), matchcol, nsec))))
                                    ((ร match_ok =) false)
                                    (ร BREAK)
                                )
                                (COPY-lpos matchpos, (... (:startpos regmatch) 0))
                                (COPY-lpos endpos, (... (:endpos regmatch) 0))
                                ((ร submatch =) (first-submatch regmatch))

                                ;; Need to get the line pointer again,
                                ;; a multi-line search may have made it invalid.
                                ((ร ptr =) (ml-get (+ lnum (:lnum matchpos))))
                                (recur)
                            )
                            (when (not match_ok)
                                ((ร at_first_line =) false)
                                (ร CONTINUE)
                            )
                        )
                        (when (== dir BACKWARD)
                            ;; Now, if there are multiple matches on this line,
                            ;; we have to get the last one.  Or the last one before
                            ;; the cursor, if we're on that line.
                            ;; When putting the new cursor at the end, compare
                            ;; relative to the end of the match.

                            ((ร boolean match_ok =) false)
                            (loop []
                                ;; Remember a position that is before the start
                                ;; position, we use it if it's the last match in
                                ;; the line.  Always accept a position after
                                ;; wrapping around.
                                (cond (or (non-zero? loop) (if (flag? options SEARCH_END) (or (< (+ lnum (:lnum (... (:endpos regmatch) 0))) (:lnum start_pos)) (and (== (+ lnum (:lnum (... (:endpos regmatch) 0))) (:lnum start_pos)) (<= (+ (- (:col (... (:endpos regmatch) 0)) 1) extra_col) (:col start_pos)))) (or (< (+ lnum (:lnum (... (:startpos regmatch) 0))) (:lnum start_pos)) (and (== (+ lnum (:lnum (... (:startpos regmatch) 0))) (:lnum start_pos)) (<= (+ (:col (... (:startpos regmatch) 0)) extra_col) (:col start_pos))))))
                                (do
                                    ((ร match_ok =) true)
                                    (COPY-lpos matchpos, (... (:startpos regmatch) 0))
                                    (COPY-lpos endpos, (... (:endpos regmatch) 0))
                                    ((ร submatch =) (first-submatch regmatch))
                                )
                                :else
                                (do
                                    (ร BREAK)
                                ))

                                ;; We found a valid match, now check if there is another one after it.
                                ;; If vi-compatible searching, continue at the end of the match,
                                ;; otherwise continue one position forward.

                                (ร int matchcol)
                                (cond (some? (vim-strbyte @p_cpo, CPO_SEARCH))
                                (do
                                    (if (< 1 nmatched)
                                        (ร BREAK)
                                    )
                                    ((ร matchcol =) (:col endpos))
                                    ;; for empty match: advance one char
                                    ((ร matchcol =) (if (and (== matchcol (:col matchpos)) (non-eos? ptr matchcol)) (+ matchcol (us-ptr2len-cc ptr, matchcol)) matchcol))
                                )
                                :else
                                (do
                                    ;; Stop when the match is in a next line.
                                    (if (< 0 (:lnum matchpos))
                                        (ร BREAK)
                                    )
                                    ((ร matchcol =) (:col matchpos))
                                    ((ร matchcol =) (if (non-eos? ptr matchcol) (+ matchcol (us-ptr2len-cc ptr, matchcol)) matchcol))
                                ))
                                (when (or (eos? ptr matchcol) (zero? ((ร nmatched =) (vim-regexec-multi regmatch, (+ lnum (:lnum matchpos)), matchcol, nsec))))
                                    (ร BREAK)
                                )

                                ;; Need to get the line pointer again,
                                ;; a multi-line search may have made it invalid.
                                ((ร ptr =) (ml-get (+ lnum (:lnum matchpos))))
                                (recur)
                            )

                            ;; If there is only a match after the cursor, skip this match.

                            (when (not match_ok)
                                ((ร at_first_line =) false)
                                (ร CONTINUE)
                            )
                        )

                        ;; With the SEARCH_END option move to the last character of the match.
                        ;; Don't do it for an empty match, end should be same as start then.
                        (cond (and (flag? options SEARCH_END) (non-flag? options SEARCH_NOOF) (or (!= (:lnum matchpos) (:lnum endpos)) (!= (:col matchpos) (:col endpos))))
                        (do
                            ;; For a match in the first column,
                            ;; set the position on the NUL in the previous line.
                            ((ร pos =) (assoc pos :lnum (+ lnum (:lnum endpos)) :col (:col endpos)))
                            (cond (zero? (:col endpos))
                            (do
                                (when (< 1 (:lnum pos))   ;; just in case
                                    ((ร pos =) (update pos :lnum dec))
                                    ((ร pos =) (assoc pos :col (STRLEN (ml-get (:lnum pos)))))
                                )
                            )
                            :else
                            (do
                                ((ร pos =) (update pos :col dec))
                                (when (<= (:lnum pos) (line-count @curbuf))
                                    ((ร ptr =) (ml-get (:lnum pos)))
                                    ((ร pos =) (update pos :col #(- % (us-head-off ptr, (.plus ptr %)))))
                                )
                            ))
                        )
                        :else
                        (do
                            ((ร pos =) (assoc pos :lnum (+ lnum (:lnum matchpos)) :col (:col matchpos)))
                        ))
                        ((ร pos =) (assoc pos :coladd 0))
                        ((ร found =) true)
                        ((ร first_match =) false)

                        ;; Set variables used for 'incsearch' highlighting.
                        (reset! search_match_lines (- (:lnum endpos) (:lnum matchpos)))
                        (reset! search_match_endcol (:col endpos))
                        (ร BREAK)
                    )
                    (if (slow-breakcheck)      ;; stop if ctrl-C typed
                        (ร BREAK)
                    )

                    ;; Cancel searching if a character was typed.  Used for 'incsearch'.
                    ;; Don't check too often, that would slowdown searching too much.
                    (when (and (flag? options SEARCH_PEEK) (zero? (& (- lnum (:lnum pos)) 0x3f)) (char-avail))
                        ((ร break_loop =) true)
                        (ร BREAK)
                    )

                    (if (and (non-zero? loop) (== lnum (:lnum start_pos)))
                        (ร BREAK)              ;; if second loop, stop where started
                    )
                    ((ร at_first_line =) false)
                ))
                ((ร at_first_line =) false)

                ;; Stop the search if wrapscan isn't set, "stop_lnum" is specified,
                ;; after an interrupt, after a match and after looping twice.

                (if (or (not @p_ws) (non-zero? stop_lnum) @got_int @called_emsg break_loop found (non-zero? loop))
                    (ร BREAK)
                )

                ;; If 'wrapscan' is set we continue at the other end of the file.
                ;; This message is also remembered in "keep_msg" for when the screen is redrawn.
                ;; The "keep_msg" is cleared whenever another message is written.

                ((ร lnum =) (if (== dir BACKWARD) (line-count @curbuf) 1))    ;; start second loop at the other end
                (if (flag? options SEARCH_MSG)
                    (give-warning (if (== dir BACKWARD) top_bot_msg bot_top_msg), true))
            )
            (if (or @got_int @called_emsg break_loop)
                (ร BREAK)
            )
;       } while (0 < --count && found);     ;; stop after count matches or no match

        (swap! called_emsg | save_called_emsg)

        (when (not found)             ;; did not find it
            (cond @got_int
            (do
                (emsg e_interr)
            )
            (== (& options SEARCH_MSG) SEARCH_MSG)
            (do
                (cond
                    @p_ws        (emsg2 e_patnotf2, @mr_pattern)
                    (zero? lnum) (emsg2 (u8 "E384: search hit TOP without match for: %s"), @mr_pattern)
                    :else        (emsg2 (u8 "E385: search hit BOTTOM without match for: %s"), @mr_pattern)
                )
            ))
            ((ร RETURN) 0)
        )

        ;; A pattern like "\n\zs" may go past the last line.
        (let-when [lmax (line-count @curbuf)] (< lmax (:lnum pos))
            ((ร pos =) (assoc pos :lnum lmax :col (STRLEN (ml-get lmax))))
            (if (< 0 (:col pos))
                ((ร pos =) (update pos :col dec))
            )
        )

        (+ 1 submatch)
    ))

;; Return the number of the first subpat that matched.

(defn- #_int first-submatch [#_regmmatch_C mm]
    (loop-when [i 1] (neg? (:lnum (... (:startpos mm) i))) => i
        (recur-if (< i 9) [(inc i)] => 0)
    ))

;; Highest level string search function.
;; Search for the 'count'th occurrence of pattern 'pat' in direction 'dirc'
;;                If 'dirc' is 0: use previous dir.
;;    If 'pat' is null or empty : use previous string.
;;    If 'options & SEARCH_REV' : go in reverse of previous dir.
;;    If 'options & SEARCH_ECHO': echo the search command and handle options
;;    If 'options & SEARCH_MSG' : may give error message
;;    If 'options & SEARCH_OPT' : interpret optional flags
;;    If 'options & SEARCH_HIS' : put search pattern in history
;;    If 'options & SEARCH_NOOF': don't add offset to position
;;    If 'options & SEARCH_MARK': set previous context mark
;;    If 'options & SEARCH_KEEP': keep previous search pattern
;;    If 'options & SEARCH_START': accept match at curpos itself
;;    If 'options & SEARCH_PEEK': check for typed char, cancel search
;;
;; Careful: If spats[0].sp_off.line == true and spats[0].sp_off.off == 0,
;; this makes the movement linewise without moving the match position.
;;
;; Return 0 for failure, 1 for found, 2 for found and line offset added.

(defn- #_int do-search [#_oparg_C oap, #_byte dirc, #_Bytes pat, #_long count, #_int options, #_long nsec]
    ;; oap: can be null
    ;; dirc: '/' or '?'
    ;; nsec: timeout limit or 0
    (ยง
        ;; A line offset is not remembered, this is Vi compatible.

        (when (and (:line (:sp_off (... @spats 0))) (some? (vim-strbyte @p_cpo, CPO_LINEOFF)))
            (swap! spats update-in [0 :sp_off] assoc :line false :off 0))

        ;; Save the values for when (options & SEARCH_KEEP) is used.
        ;; (there is no "if ()" around this because gcc wants them initialized)

        ((ร soffset_C old_off =) (:sp_off (... @spats 0)))

        ;; position of the last match
        ((ร pos_C pos =) (:w_cursor @curwin)) ;; start searching at the cursor position

        ;; Find out the direction of the search.

        (if (zero? dirc)
            ((ร dirc =) (:dir (:sp_off (... @spats 0))))
            (swap! spats assoc-in [0 :sp_off :dir] dirc)
        )

        ((ร dirc =) (if (flag? options SEARCH_REV) (if (== dirc (byte \/)) (byte \?) (byte \/)) dirc))

        ;; Turn 'hlsearch' highlighting back on.

        (when (and @no_hlsearch (non-flag? options SEARCH_KEEP))
            (redraw-all-later SOME_VALID)
            (reset! no_hlsearch false)
        )

        (ร int retval)

;       end_do_search:
;       {
            ((ร Bytes[] a'strcopy =) (atom (#_Bytes object nil)))

            ;; Repeat the search when pattern followed by ';', e.g. "/foo/;?bar".

            (loop []
                ((ร Bytes searchstr =) pat)                     ;; use previous pattern
                ((ร Bytes dircp =) nil)

                (when (or (nil? pat) (eos? pat) (at? pat dirc))
                    (cond (nil? (:pat (... @spats RE_SEARCH)))       ;; no previous pattern
                    (do
                        ((ร pat =) (:pat (... @spats RE_SUBST)))
                        (when (nil? pat)
                            (emsg e_noprevre)
                            ((ร retval =) 0)
                            (ร BREAK end_do_search)
                        )
                        ((ร searchstr =) pat)
                    )
                    :else
                    (do
                        ;; make search-regcomp() use spats[RE_SEARCH].pat
                        ((ร searchstr =) (u8 ""))
                    ))
                )

                (when (and (some? pat) (non-eos? pat))            ;; look for (new) offset
                    ;; Find end of regular expression.
                    ;; If there is a matching '/' or '?', toss it.

                    ((ร Bytes ps =) @a'strcopy)
                    ((ร Bytes p =) (skip-regexp pat, dirc, @p_magic, a'strcopy))
                    (when (BNE @a'strcopy, ps)
                        ;; made a copy of "pat" to change "\?" to "?"
                        (swap! searchcmdlen + (- (STRLEN pat) (STRLEN @a'strcopy)))
                        ((ร pat =) @a'strcopy)
                        ((ร searchstr =) @a'strcopy)
                    )
                    (when (at? p dirc)
                        ((ร dircp =) (eos! p))                  ;; remember where we put the NUL
                        ((ร p =) (.plus p 1))
                    )
                    (swap! spats update-in [0 :sp_off] assoc :line false :end false :off 0)

                    ;; Check for a line offset or a character offset.
                    ;; For get-address (echo off) we don't check for a character offset,
                    ;; because it is meaningless and the 's' could be a substitute command.

                    (cond (or (at? p (byte \+)) (at? p (byte \-)) (asc-isdigit (.at p 0)))
                    (do
                        (swap! spats assoc-in [0 :sp_off :line] true)
                    )
                    (and (flag? options SEARCH_OPT) (or (at? p (byte \e)) (at? p (byte \s)) (at? p (byte \b))))
                    (do
                        (if (at? p (byte \e))                           ;; end
                            (swap! spats assoc-in [0 :sp_off :end] (!= SEARCH_END 0))
                        )
                        ((ร p =) (.plus p 1))
                    ))
                    (when (or (asc-isdigit (.at p 0)) (at? p (byte \+)) (at? p (byte \-)))      ;; got an offset
                        (cond (or (asc-isdigit (.at p 0)) (asc-isdigit (.at p 1)))   ;; 'nr' or '+nr' or '-nr'
                        (do
                            (swap! spats assoc-in [0 :sp_off :off] (.atol libC p))
                        )
                        (at? p (byte \-))                      ;; single '-'
                        (do
                            (swap! spats assoc-in [0 :sp_off :off] -1)
                        )
                        :else                                                ;; single '+'
                        (do
                            (swap! spats assoc-in [0 :sp_off :off] 1)
                        ))

                        ((ร p =) (.plus p 1))
                        (loop-when [] (asc-isdigit (.at p 0))                        ;; skip number
                            ((ร p =) (.plus p 1))
                            (recur)
                        )
                    )

                    ;; compute length of search command for get-address()
                    (swap! searchcmdlen + (BDIFF p, pat))

                    ((ร pat =) p)                        ;; put "pat" after search command
                )

                (when (and (flag? options SEARCH_ECHO) (messaging))
                    ((ร Bytes p =) (if (eos? searchstr) (:pat (... @spats @last_idx)) searchstr))

                    ((ร Bytes msgbuf =) (Bytes. (+ (STRLEN p) 40)))

                    (.be msgbuf 0, dirc)
                    (cond (utf-iscomposing (us-ptr2char p))
                    (do
                        ;; Use a space to draw the composing char on.
                        (.be msgbuf 1, (byte \space))
                        (STRCPY (.plus msgbuf 2), p)
                    )
                    :else
                    (do
                        (STRCPY (.plus msgbuf 1), p)
                    ))

                    (when (or (:line (:sp_off (... @spats 0))) (:end (:sp_off (... @spats 0))) (non-zero? (:off (:sp_off (... @spats 0)))))
                        ((ร p =) (.plus msgbuf (STRLEN msgbuf)))
                        (.be p 0, dirc)
                        ((ร p =) (.plus p 1))
                        (cond (:end (:sp_off (... @spats 0)))
                        (do
                            (.be p 0, (byte \e))
                            ((ร p =) (.plus p 1))
                        )
                        (not (:line (:sp_off (... @spats 0))))
                        (do
                            (.be p 0, (byte \s))
                            ((ร p =) (.plus p 1))
                        ))
                        (when (or (< 0 (:off (:sp_off (... @spats 0)))) (:line (:sp_off (... @spats 0))))
                            (.be p 0, (byte \+))
                            ((ร p =) (.plus p 1))
                        )
                        (if (or (non-zero? (:off (:sp_off (... @spats 0)))) (:line (:sp_off (... @spats 0))))
                            (.sprintf libC p, (u8 "%ld"), (:off (:sp_off (... @spats 0))))
                            (eos! p)
                        )
                    )

                    (msg-start)
                    ((ร Bytes trunc =) (msg-strtrunc msgbuf))

                    (msg-outtrans (if (some? trunc) trunc msgbuf))
                    (msg-clr-eos)
                    (msg-check)

                    (gotocmdline false)
                    (out-flush)
                    (reset! msg_nowait true)              ;; don't wait for this message
                )

                ;; If there is a character offset, subtract it from the current
                ;; position, so we don't get stuck at "?pat?e+2" or "/pat/s-2".
                ;; Skip this if pos.col is near MAXCOL (closed fold).
                ;; This is not done for a line offset, because then we would not be vi compatible.

                (when (and (not (:line (:sp_off (... @spats 0)))) (non-zero? (:off (:sp_off (... @spats 0)))) (< (:col pos) (- MAXCOL 2)))
                    (let [(ร long c =) (:off (:sp_off (... @spats 0)))]
                        (if (< 0 c)
                            (do
                                ((ร [pos c] =) (loop-when [pos pos c c] (non-zero? c) => [pos c]
                                    (let [[pos ?] (decl pos)] (recur-if (!= ? -1) [pos (dec c)] => [pos c]))))
                                (when (non-zero? c)                 ;; at start of buffer
                                    ((ร pos =) (assoc pos :lnum 0 :col MAXCOL)) ;; allow lnum == 0 here
                                )
                            )
                            (do
                                ((ร [pos c] =) (loop-when [pos pos c c] (non-zero? c) => [pos c]
                                    (let [[pos ?] (incl pos)] (recur-if (!= ? -1) [pos (inc c)] => [pos c]))))
                                (when (non-zero? c)                 ;; at end of buffer
                                    ((ร pos =) (assoc pos :lnum (inc (line-count @curbuf) :col 0)))
                                )
                            )
                        )
                    )
                )

                ((ร int i =) (searchit pos, (if (== dirc (byte \/)) FORWARD BACKWARD), searchstr, count, (+ (if (:end (:sp_off (... @spats 0))) SEARCH_REV 0) (& options (+ SEARCH_KEEP SEARCH_PEEK SEARCH_HIS SEARCH_MSG SEARCH_START (if (and (some? pat) (at? pat (byte \;))) 0 SEARCH_NOOF)))), RE_LAST, 0, nsec))

                (when (some? dircp)
                    (.be dircp 0, dirc)          ;; restore second '/' or '?' for normal-cmd()
                )
                (when (zero? i)
                    ((ร retval =) 0)
                    (ร BREAK end_do_search)
                )
                (when (and (:end (:sp_off (... @spats 0))) (some? oap))
                    ((ร oap =) (assoc oap :inclusive true))           ;; 'e' includes last character
                )

                ((ร retval =) 1)                         ;; pattern found

                ;; Add character and/or line offset.

                (when (or (non-flag? options SEARCH_NOOF) (and (some? pat) (at? pat (byte \;))))
                    (cond (:line (:sp_off (... @spats 0)))       ;; add the offset to the line number
                        (let [#_long l (+ (:lnum pos) (:off (:sp_off (... @spats 0)))) lmax (line-count @curbuf)]
                            ((ร pos =) (assoc pos :lnum (cond (< l 1) 1 (< lmax l) lmax :else l) :col 0))

                            ((ร retval =) 2)                 ;; pattern found, line offset added
                        )
                    (< (:col pos) (- MAXCOL 2)) ;; just in case
                        (let [#_long c (:off (:sp_off (... @spats 0)))]
                            ((ร pos =) (if (< 0 c)
                                ;; to the right, check for end of file
                                (loop-when [pos pos c c] (< 0 c) => pos
                                    (let [[pos ?] (incl pos)] (recur-if (!= ? -1) [pos (dec c)] => pos)))
                                ;; to the left, check for start of file
                                (loop-when [pos pos c c] (< c 0) => pos
                                    (let [[pos ?] (decl pos)] (recur-if (!= ? -1) [pos (inc c)] => pos)))
                            ))
                        )
                    )
                )

                ;; The search command can be followed by a ';' to do another search.
                ;; For example: "/pat/;/foo/+3;?bar"
                ;; This is like doing another search command, except:
                ;; - The remembered direction '/' or '?' is from the first search.
                ;; - When an error happens the cursor isn't moved at all.
                ;; Don't do this when called by get-address() (it handles ';' itself).

                (if (or (non-flag? options SEARCH_OPT) (nil? pat) (not-at? pat (byte \;)))
                    (ร BREAK)
                )

                ((ร pat =) (.plus pat 1))
                ((ร dirc =) (.at pat 0))
                (when (and (!= dirc (byte \?)) (!= dirc (byte \/)))
                    ((ร retval =) 0)
                    (emsg (u8 "E386: Expected '?' or '/'  after ';'"))
                    (ร BREAK end_do_search)
                )
                ((ร pat =) (.plus pat 1))
                (recur)
            )

            (when (flag? options SEARCH_MARK)
                (swap! curwin setpcmark))
            (swap! curwin assoc :w_cursor pos :w_set_curswant true)
;       }

        (when (flag? options SEARCH_KEEP)
            (swap! spats assoc-in [0 :sp_off] old_off))

        retval
    ))

;; Character Searches

(atom! int sc__lastc NUL)         ;; last character searched for
(atom! int sc__lastcdir)            ;; last direction of character search
(atom! boolean sc__last_t_cmd)      ;; last search t_cmd

(final Bytes sc__bytes (Bytes. (inc MB_MAXBYTES)))
(atom! int sc__bytelen 1)         ;; >1 for multi-byte char

;; Search for a character in a line.  If "t_cmd" is false, move to the
;; position of the character, otherwise move to just before the char.
;; Do this "cap.count1" times.
;; Return false or true.

(defn- #_boolean searchc [#_cmdarg_C cap, #_boolean t_cmd]
    (ยง
        ((ร int c =) (:nchar cap))                      ;; char to search for
        ((ร int dir =) (:arg cap))                      ;; true for searching forward
        ((ร long count =) (:count1 cap))                ;; repeat count

        ((ร boolean stop =) true)

        (cond (!= c NUL)                           ;; normal search: remember args for repeat
        (do
            (when (not @keyStuffed)                    ;; don't remember when redoing
                (reset! sc__lastc c)
                (reset! sc__lastcdir dir)
                (reset! sc__last_t_cmd t_cmd)
                (reset! sc__bytelen (utf-char2bytes c, sc__bytes))
                (when (non-zero? (:ncharC1 cap))
                    (swap! sc__bytelen #(+ % (utf-char2bytes (:ncharC1 cap), (.plus sc__bytes %))))
                    (when (non-zero? (:ncharC2 cap))
                        (swap! sc__bytelen #(+ % (utf-char2bytes (:ncharC2 cap), (.plus sc__bytes %)))))
                )
            )
        )
        :else                                    ;; repeat previous search
        (do
            (if (== @sc__lastc NUL)
                ((ร RETURN) false)
            )
            ((ร dir =) (if (non-zero? dir) (- @sc__lastcdir) @sc__lastcdir))        ;; repeat in opposite direction
            ((ร t_cmd =) @sc__last_t_cmd)
            ((ร c =) @sc__lastc)

            ;; For multi-byte re-use last sc__bytes[] and sc__bytelen.

            ;; Force a move of at least one char, so ";" and "," will move the cursor,
            ;; even if the cursor is right in front of char we are looking at.
            ((ร stop =) (if (and (nil? (vim-strbyte @p_cpo, CPO_SCOLON)) (== count 1) t_cmd) false stop))
        ))

        ((ร cap =) (assoc-in cap [:oap :inclusive] (!= dir BACKWARD)))

        ((ร Bytes p =) (ml-get (:lnum (:w_cursor @curwin))))
        ((ร int col =) (:col (:w_cursor @curwin)))
        ((ร int len =) (STRLEN p))

        (loop-when [] (<= 0 ((ร count =) (dec count)))
            (loop []
                (cond (< 0 dir)
                (do
                    ((ร col =) (+ col (us-ptr2len-cc p, col)))
                    (if (<= len col)
                        ((ร RETURN) false)
                    )
                )
                :else
                (do
                    (if (zero? col)
                        ((ร RETURN) false)
                    )
                    ((ร col =) (- col (+ (us-head-off p, (.plus p (dec col))) 1)))
                ))
                (cond (== @sc__bytelen 1)
                (do
                    (if (and (at? p col c) stop)
                        (ร BREAK)
                    )
                )
                :else
                (do
                    (if (and (zero? (MEMCMP (.plus p col), sc__bytes, @sc__bytelen)) stop)
                        (ร BREAK)
                    )
                ))
                ((ร stop =) true)
                (recur)
            )
            (recur)
        )

        (when t_cmd
            ;; backup to before the character (possibly double-byte)
            ((ร col =) (- col dir))

            (cond (< dir 0)
            (do
                ;; Landed on the search char which is sc__bytelen long.
                ((ร col =) (+ col (dec @sc__bytelen)))
            )
            :else
            (do
                ;; To previous char, which may be multi-byte.
                ((ร col =) (- col (us-head-off p, (.plus p col))))
            ))
        )
        (swap! curwin assoc-in [:w_cursor :col] col)

        true
    ))

;; "Other" Searches

;; findmatch - find the matching paren or brace
;;
;; Improvement over vi: Braces inside quotes are ignored.

(defn- #_pos_C findmatch [#_oparg_C oap, #_int initc]
    (findmatchlimit oap, initc, 0, 0))

;; Return true if the character before "s[col]" equals "ch".
;; Return false if "col" is zero.
;; Update "*prior" to the column of the previous character, unless "prior" is null.
;; Handles multibyte string correctly.

(defn- #_boolean check-prevcol [#_Bytes s, #_int col, #_int ch, #_int' a'prior]
    (let [col (dec col) col (if (< 0 col) (- col (us-head-off s, (.plus s col))) col)]
        (when (some? a'prior) (reset! a'prior col))
        (and (<= 0 col) (at? s col ch))
    ))

(atom! pos_C _2_pos (NEW_pos_C)) ;; current search position

;; findmatchlimit -- find the matching paren or brace, if it exists within
;; maxtravel lines of here.  A maxtravel of 0 means search until falling off
;; the edge of the file.
;;
;; "initc" is the character to find a match for.  NUL means to find the
;; character at or after the cursor.
;;
;; flags: FM_BACKWARD   search backwards (when initc is '/', '*' or '#')
;;        FM_FORWARD    search forwards (when initc is '/', '*' or '#')
;;        FM_BLOCKSTOP  stop at start/end of block ({ or } in column 0)
;;
;; "oap" is only used to set oap.motion_type for a linewise motion, it be null

(defn- #_pos_C findmatchlimit [#_oparg_C oap, #_int _initc, #_int flags, #_int maxtravel]
    (ยง
        ((ร int[] a'initc =) (atom (int _initc)))
        ((ร int[] a'findc =) (atom (int 0)))                    ;; matching brace
        ((ร int count =) 0)                          ;; cumulative number of braces
        ((ร boolean[] a'backwards =) (atom (boolean false)))
        ((ร boolean inquote =) false)                ;; true when inside quotes
        ((ร int hash_dir =) 0)                       ;; Direction searched for # things
        ((ร int comment_dir =) 0)                    ;; Direction searched for comments
        ((ร int traveled =) 0)                       ;; how far we've searched so far
        ((ร boolean ignore_cend =) false)            ;; ignore comment end
        ((ร int match_escaped =) 0)                  ;; search for escaped match
        ((ร int comment_col =) MAXCOL)               ;; start of / / comment

        (reset! _2_pos (:w_cursor @curwin))
        (swap! _2_pos assoc :coladd 0)
        ((ร Bytes linep =) (ml-get (:lnum @_2_pos))) ;; pointer to current line

        ((ร boolean cpo_match =) (some? (vim-strbyte @p_cpo, CPO_MATCH)))    ;; vi compatible matching
        ((ร boolean cpo_bsl =) (some? (vim-strbyte @p_cpo, CPO_MATCHBSL)))   ;; don't recognize backslashes

        ;; Direction to search when initc is '/', '*' or '#'.
        ((ร int dir =) (cond (flag? flags FM_BACKWARD) BACKWARD (flag? flags FM_FORWARD) FORWARD :else 0))

        ;; if initc given, look in the table for the matching character
        ;; '/' and '*' are special cases: look for start or end of comment.
        ;; When '/' is used, we ignore running backwards into an star-slash,
        ;; for "[*" command, we just want to find any comment.

        (cond (or (== @a'initc (byte \/)) (== @a'initc (byte \*)))
        (do
            ((ร comment_dir =) dir)
            ((ร ignore_cend =) (or (== @a'initc (byte \/)) ignore_cend))
            (reset! a'backwards (!= dir FORWARD))
            (reset! a'initc NUL)
        )
        (and (!= @a'initc (byte \#)) (!= @a'initc NUL))
        (do
            (find-mps-values a'initc, a'findc, a'backwards, true)
            (if (== @a'findc NUL)
                ((ร RETURN) nil)
            )
        )
        :else ;; Either initc is '#', or no initc was given and we need to look under the cursor.
        (do
            (cond (== @a'initc (byte \#))
            (do
                ((ร hash_dir =) dir)
            )
            :else
            (do
                ;; initc was not given, must look for something to match under or near the cursor.
                ;; Only check for special things when 'cpo' doesn't have '%'.

                (when (not cpo_match)
                    ;; Are we before or at #if, #else etc.?
                    ((ร Bytes p =) (skipwhite linep))
                    (cond (and (at? p (byte \#)) (<= (:col @_2_pos) (BDIFF p, linep)))
                    (do
                        ((ร p =) (skipwhite (.plus p 1)))
                        ((ร hash_dir =) (if (or (zero? (STRNCMP p, (u8 "if"), 2)) (zero? (STRNCMP p, (u8 "endif"), 5)) (zero? (STRNCMP p, (u8 "el"), 2))) 1 hash_dir))
                    )
                    ;; Are we on a comment?
                    (at? linep (:col @_2_pos) (byte \/))
                    (do
                        (cond (at? linep (inc (:col @_2_pos)) (byte \*))
                        (do
                            ((ร comment_dir =) FORWARD)
                            (reset! a'backwards false)
                            (swap! _2_pos update :col inc)
                        )
                        (and (< 0 (:col @_2_pos)) (at? linep (dec (:col @_2_pos)) (byte \*)))
                        (do
                            ((ร comment_dir =) BACKWARD)
                            (reset! a'backwards true)
                            (swap! _2_pos update :col dec)
                        ))
                    )
                    (at? linep (:col @_2_pos) (byte \*))
                    (do
                        (cond (at? linep (inc (:col @_2_pos)) (byte \/))
                        (do
                            ((ร comment_dir =) BACKWARD)
                            (reset! a'backwards true)
                        )
                        (and (< 0 (:col @_2_pos)) (at? linep (dec (:col @_2_pos)) (byte \/)))
                        (do
                            ((ร comment_dir =) FORWARD)
                            (reset! a'backwards false)
                        ))
                    ))
                )

                ;; If we are not on a comment or the # at the start of a line,
                ;; then look for brace anywhere on this line after the cursor.

                (when (and (zero? hash_dir) (zero? comment_dir))
                    ;; Find the brace under or after the cursor.
                    ;; If beyond the end of the line, use the last character in the line.

                    (when (and (at? linep (:col @_2_pos) NUL) (non-zero? (:col @_2_pos)))
                        (swap! _2_pos update :col dec))
                    (loop []
                        (reset! a'initc (us-ptr2char linep, (:col @_2_pos)))
                        (if (== @a'initc NUL)
                            (ร BREAK)
                        )

                        (find-mps-values a'initc, a'findc, a'backwards, false)
                        (if (!= @a'findc NUL)
                            (ร BREAK)
                        )
                        (swap! _2_pos update :col + (us-ptr2len-cc linep, (:col @_2_pos)))
                        (recur)
                    )
                    (cond (== @a'findc NUL)
                    (do
                        ;; no brace in the line, maybe use "  #if" then
                        (if (and (not cpo_match) (at? (skipwhite linep) (byte \#)))
                            ((ร hash_dir =) 1)
                            ((ร RETURN) nil)
                        )
                    )
                    (not cpo_bsl)
                    (do
                        ;; Set "match_escaped" if there are an odd number of backslashes.
                        ((ร int[] a'col =) (atom (int (:col @_2_pos))))
                        ((ร int bslcnt =) (loop-when-recur [bslcnt 0] (check-prevcol linep, @a'col, (byte \\), a'col) [(inc bslcnt)] => bslcnt))
                        ((ร match_escaped =) (& bslcnt 1))
                    ))
                )
            ))

            (when (non-zero? hash_dir)
                ;; Look for matching #if, #else, #elif, or #endif

                (if (some? oap)
                    ((ร oap =) (assoc oap :motion_type MLINE))    ;; linewise for this case only
                )
                (when (!= @a'initc (byte \#))
                    ((ร Bytes p =) (skipwhite (.plus (skipwhite linep) 1)))
                    (cond (or (zero? (STRNCMP p, (u8 "if"), 2)) (zero? (STRNCMP p, (u8 "el"), 2)))
                    (do
                        ((ร hash_dir =) 1)
                    )
                    (zero? (STRNCMP p, (u8 "endif"), 5))
                    (do
                        ((ร hash_dir =) -1)
                    )
                    :else
                    (do
                        ((ร RETURN) nil)
                    ))
                )
                (swap! _2_pos assoc :col 0)
                (loop-when [] (not @got_int)
                    (cond (< 0 hash_dir)
                    (do
                        (if (== (:lnum @_2_pos) (line-count @curbuf))
                            (ร BREAK)
                        )
                    )
                    (== (:lnum @_2_pos) 1)
                    (do
                        (ร BREAK)
                    ))
                    (swap! _2_pos update :lnum + hash_dir)
                    ((ร linep =) (ml-get (:lnum @_2_pos)))
                    (slow-breakcheck)          ;; check for CTRL-C typed
                    ((ร Bytes p =) (skipwhite linep))
                    (if (not-at? p (byte \#))
                        (ร CONTINUE)
                    )
                    (swap! _2_pos assoc :col (BDIFF p, linep))
                    ((ร p =) (skipwhite (.plus p 1)))
                    (cond (< 0 hash_dir)
                    (do
                        (cond (zero? (STRNCMP p, (u8 "if"), 2))
                        (do
                            ((ร count =) (inc count))
                        )
                        (zero? (STRNCMP p, (u8 "el"), 2))
                        (do
                            (if (zero? count)
                                ((ร RETURN) @_2_pos)
                            )
                        )
                        (zero? (STRNCMP p, (u8 "endif"), 5))
                        (do
                            (if (zero? count)
                                ((ร RETURN) @_2_pos)
                            )
                            ((ร count =) (dec count))
                        ))
                    )
                    :else
                    (do
                        (cond (zero? (STRNCMP p, (u8 "if"), 2))
                        (do
                            (if (zero? count)
                                ((ร RETURN) @_2_pos)
                            )
                            ((ร count =) (dec count))
                        )
                        (and (== @a'initc (byte \#)) (zero? (STRNCMP p, (u8 "el"), 2)))
                        (do
                            (if (zero? count)
                                ((ร RETURN) @_2_pos)
                            )
                        )
                        (zero? (STRNCMP p, (u8 "endif"), 5))
                        (do
                            ((ร count =) (inc count))
                        ))
                    ))
                    (recur)
                )
                ((ร RETURN) nil)
            )
        ))

        ((ร int do_quotes =) -1)                 ;; check for quotes in current line
        ((ร maybean start_in_quotes =) MAYBE)    ;; start position is in quotes
        ((ร pos_C match_pos =) (NEW_pos_C))      ;; where last slash-star was found

        ;; backward search: Check if this line contains a single-line comment
        ((ร comment_col =) (if (and @a'backwards (non-zero? comment_dir)) (check-linecomment linep) comment_col))

        (loop-when [] (not @got_int)
            ;; Go to the next position, forward or backward.
            ;; We could use incp() and decp() here, but that is much slower.

            (cond @a'backwards
            (do
                (cond (zero? (:col @_2_pos))                    ;; at start of line, go to prev. one
                (do
                    (if (== (:lnum @_2_pos) 1)               ;; start of file
                        (ร BREAK)
                    )
                    (swap! _2_pos update :lnum dec)

                    (if (and (< 0 maxtravel) (< maxtravel ((ร traveled =) (inc traveled))))
                        (ร BREAK)
                    )

                    ((ร linep =) (ml-get (:lnum @_2_pos)))
                    (swap! _2_pos assoc :col (STRLEN linep))    ;; _2_pos.col on trailing NUL
                    ((ร do_quotes =) -1)
                    (slow-breakcheck)

                    ;; Check if this line contains a single-line comment.
                    ((ร comment_col =) (if (non-zero? comment_dir) (check-linecomment linep) comment_col))
                )
                :else
                (do
                    (swap! _2_pos update :col dec)
                    (swap! _2_pos update :col - (us-head-off linep, (.plus linep (:col @_2_pos))))
                ))
            )
            :else                            ;; forward search
            (do
                (cond (at? linep (:col @_2_pos) NUL)
                (do
                    (if (== (:lnum @_2_pos) (line-count @curbuf))    ;; end of file
                        (ร BREAK)
                    )
                    (swap! _2_pos update :lnum inc)

                    (if (and (non-zero? maxtravel) (< maxtravel (ร traveled++)))
                        (ร BREAK)
                    )

                    ((ร linep =) (ml-get (:lnum @_2_pos)))
                    (swap! _2_pos assoc :col 0)
                    ((ร do_quotes =) -1)
                    (slow-breakcheck)
                )
                :else
                (do
                    (swap! _2_pos update :col + (us-ptr2len-cc linep, (:col @_2_pos)))
                ))
            ))

            ;; If FM_BLOCKSTOP given, stop at a '{' or '}' in column 0.

            (when (and (zero? (:col @_2_pos)) (flag? flags FM_BLOCKSTOP) (or (at? linep (byte \{)) (at? linep (byte \}))))
                (if (and (at? linep @a'findc) (zero? count))        ;; match!
                    ((ร RETURN) @_2_pos)
                )
                (ร BREAK)                                      ;; out of scope
            )

            (when (non-zero? comment_dir)
                ;; Note: comments do not nest, and we ignore quotes in them.
                ;; TODO: ignore comment brackets inside strings.
                (cond (== comment_dir FORWARD)
                (do
                    (when (and (at? linep (:col @_2_pos) (byte \*)) (at? linep (inc (:col @_2_pos)) (byte \/)))
                        (swap! _2_pos update :col inc)
                        ((ร RETURN) @_2_pos)
                    )
                )
                :else    ;; searching backwards
                (do
                    ;; A comment may contain / * or / /, it may also start or end
                    ;; with / * /.  Ignore a / * after / /.

                    (cond (zero? (:col @_2_pos))
                    (do
                        (ร CONTINUE)
                    )
                    (and (at? linep (dec (:col @_2_pos)) (byte \/)) (at? linep (:col @_2_pos) (byte \*)) (< (:col @_2_pos) comment_col))
                    (do
                        ((ร count =) (inc count))
                        (COPY-pos match_pos, @_2_pos)
                        ((ร match_pos.col =) (dec (:col match_pos)))
                    )
                    (and (at? linep (dec (:col @_2_pos)) (byte \*)) (at? linep (:col @_2_pos) (byte \/)))
                    (do
                        (cond (< 0 count)
                        (do
                            (reset! _2_pos match_pos)
                        )
                        (and (< 1 (:col @_2_pos)) (at? linep (- (:col @_2_pos) 2) (byte \/)) (<= (:col @_2_pos) comment_col))
                        (do
                            (swap! _2_pos update :col - 2)
                        )
                        ignore_cend
                        (do
                            (ร CONTINUE)
                        )
                        :else
                        (do
                            ((ร RETURN) nil)
                        ))

                        ((ร RETURN) @_2_pos)
                    ))
                ))
                (ร CONTINUE)
            )

            ;; If smart matching ('cpoptions' does not contain '%'), braces inside
            ;; of quotes are ignored, but only if there is an even number of
            ;; quotes in the line.

            (cond cpo_match
            (do
                ((ร do_quotes =) 0)
            )
            (== do_quotes -1)
            (do
                ;; Count the number of quotes in the line, skipping \" and '"'.
                ;; Watch out for "\\".

                ((ร int @at_start =) do_quotes)       ;; do_quotes value at start position
                ((ร Bytes p =) (loop-when [p linep] (non-eos? p) => p
                    (when (BEQ p, (.plus linep (+ (:col @_2_pos) (if @a'backwards 1 0))))
                        (reset! at_start (& do_quotes 1)))
                    ((ร do_quotes =) (if (and (at? p (byte \")) (or (BEQ p, linep) (not-at? p -1 (byte \')) (not-at? p 1 (byte \')))) (inc do_quotes) do_quotes))   ;; """
                    (recur (.plus p (if (and (at? p (byte \\)) (non-eos? p 1)) 2 1)))
                ))
                ((ร do_quotes =) (& do_quotes 1))                 ;; result is 1 with even number of quotes

                ;; If we find an uneven count, check current line and previous one for a '\' at the end.

                (when (zero? do_quotes)
                    ((ร inquote =) false)
                    (when (at? p -1 (byte \\))
                        ((ร do_quotes =) 1)
                        (cond (== start_in_quotes MAYBE)
                        (do
                            ;; Do we need to use at_start here?
                            ((ร inquote =) true)
                            ((ร start_in_quotes =) TRUE)
                        )
                        @a'backwards
                        (do
                            ((ร inquote =) true)
                        ))
                    )
                    (when (< 1 (:lnum @_2_pos))
                        ((ร p =) (ml-get (dec (:lnum @_2_pos))))
                        (when (and (non-eos? p) (at? p (dec (STRLEN p)) (byte \\)))
                            ((ร do_quotes =) 1)
                            (cond (== start_in_quotes MAYBE)
                            (do
                                ((ร inquote =) (!= @at_start 0))
                                ((ร start_in_quotes =) (if inquote TRUE start_in_quotes))
                            )
                            (not @a'backwards)
                            (do
                                ((ร inquote =) true)
                            ))
                        )

                        ;; ml-get() only keeps one line, need to get "linep" again
                        ((ร linep =) (ml-get (:lnum @_2_pos)))
                    )
                )
            ))
            ((ร start_in_quotes =) (if (== start_in_quotes MAYBE) FALSE start_in_quotes))

            ;; If 'smartmatch' is set:
            ;;   Things inside quotes are ignored by setting 'inquote'.
            ;;   If we find a quote without a preceding '\' invert 'inquote'.
            ;;   At the end of a line not ending in '\' we reset 'inquote'.
            ;;
            ;;   In lines with an uneven number of quotes (without preceding '\')
            ;;   we do not know which part to ignore.  Therefore we only set
            ;;   inquote if the number of quotes in a line is even, unless this
            ;;   line or the previous one ends in a '\'.  Complicated, isn't it?

            ((ร int c =) (us-ptr2char linep, (:col @_2_pos)))
            (condp == c
                NUL
                (do
                    ;; at end of line without trailing backslash, reset inquote
                    (when (or (zero? (:col @_2_pos)) (not-at? linep (dec (:col @_2_pos)) (byte \\)))
                        ((ร inquote =) false)
                        ((ร start_in_quotes =) FALSE)
                    )
                    (ร BREAK)
                )

                (byte \")  ;; """
                (do
                    ;; a quote that is preceded with an odd number of backslashes is ignored
                    (when (non-zero? do_quotes)
                        ((ร int col =) (loop-when-recur [col (dec (:col @_2_pos))] (and (<= 0 col) (at? linep col (byte \\))) [(dec col)] => col))
                        (when (zero? (& (- (:col @_2_pos) 1 col) 1))
                            ((ร inquote =) (not inquote))
                            ((ร start_in_quotes =) FALSE)
                        )
                    )
                    (ร BREAK)
                )

                ;; If smart matching ('cpoptions' does not contain '%'):
                ;;   Skip things in single quotes: 'x' or '\x'.  Be careful for single
                ;;   single quotes, e.g. jon's.  Things like '\233' or '\x3f' are not
                ;;   skipped, there is never a brace in them.
                ;;   Ignore this when finding matches for `'.

                (byte \')
                (do
                    (when (and (not cpo_match) (!= @a'initc (byte \')) (!= @a'findc (byte \')))
                        (cond @a'backwards
                        (do
                            (when (< 1 (:col @_2_pos))
                                (cond (at? linep (- (:col @_2_pos) 2) (byte \'))
                                (do
                                    (swap! _2_pos update :col - 2)
                                    (ร BREAK)
                                )
                                (and (at? linep (- (:col @_2_pos) 2) (byte \\)) (< 2 (:col @_2_pos)) (at? linep (- (:col @_2_pos) 3) (byte \')))
                                (do
                                    (swap! _2_pos update :col - 3)
                                    (ร BREAK)
                                ))
                            )
                        )
                        (non-eos? linep (inc (:col @_2_pos))) ;; forward search
                        (do
                            (cond (and (at? linep (+ (:col @_2_pos) 1) (byte \\)) (non-eos? linep (+ (:col @_2_pos) 2)) (at? linep (+ (:col @_2_pos) 3) (byte \')))
                            (do
                                (swap! _2_pos update :col + 3)
                                (ร BREAK)
                            )
                            (at? linep (+ (:col @_2_pos) 2) (byte \'))
                            (do
                                (swap! _2_pos update :col + 2)
                                (ร BREAK)
                            ))
                        ))
                    )
                    (ร FALLTHROUGH)
                )

                (ร DEFAULT)
                (do
                    ;; Check for match outside of quotes, and inside of
                    ;; quotes when the start is also inside of quotes.

                    (when (and (or (not inquote) (== start_in_quotes TRUE)) (any == c @a'initc @a'findc))
                        ((ร int bslcnt =) 0)

                        (when (not cpo_bsl)
                            ((ร int[] a'col =) (atom (int (:col @_2_pos))))
                            ((ร bslcnt =) (loop-when-recur bslcnt (check-prevcol linep, @a'col, (byte \\), a'col) (inc bslcnt) => bslcnt))
                        )
                        ;; Only accept a match when 'M' is in 'cpo'
                        ;; or when escaping is what we expect.
                        (when (or cpo_bsl (== (& bslcnt 1) match_escaped))
                            (cond (== c @a'initc)
                            (do
                                ((ร count =) (inc count))
                            )
                            :else
                            (do
                                (if (zero? count)
                                    ((ร RETURN) @_2_pos)
                                )
                                ((ร count =) (dec count))
                            ))
                        )
                    )
                    (ร BREAK)
                )
            )
            (recur)
        )

        (when (and (== comment_dir BACKWARD) (< 0 count))
            (reset! _2_pos match_pos)
            ((ร RETURN) @_2_pos)
        )

        nil    ;; never found it
    ))

;; Check if line contains a / / comment.
;; Return MAXCOL if not, otherwise return the column.
;; TODO: skip strings.

(defn- #_int check-linecomment [#_Bytes line]
    (let [s (loop [s line]
                (let [s (vim-strchr s, (byte \/))]
                    ;; Accept a double /, unless it's preceded with * and followed by *, because * / / * is an end and start of a C comment.
                    (recur-if (and (some? s) (or (not-at? s 1 (byte \/)) (and (BNE s, line) (at? s -1 (byte \*)) (at? s 2 (byte \*))))) [(.plus s 1)] => s))
            )]
        (if (some? s) (BDIFF s, line) MAXCOL)
    ))

;; Move cursor briefly to character matching the one under the cursor.
;; Used for Insert mode and "r" command.
;; Show the match only if it is visible on the screen.
;; If there isn't a match, then beep.

(defn- #_window_C showmatch [#_window_C win, #_int c] ;; c: char to show match for
    ;; Only show match for chars in the 'matchpairs' option.
    (let-when [_ (let [s @(:b_p_mps @curbuf)] ;; 'matchpairs' is "x:y,x:y"
                    (loop-when [i 0] (non-eos? s i) => :_
                        (let-when [i (+ i (inc (us-ptr2len-cc s, i)))] (!= (us-ptr2char s, i) c) => :_
                            (let-when [i (+ i (us-ptr2len-cc s, i))] (non-eos? s i) => nil
                                (recur (inc i))
                            ))
                    ))] (some? _) => win

        (let [lpos (findmatch nil, NUL)]
            (cond (nil? lpos) ;; no match, so beep
                (do (vim-beep) win)
            (and (<= (:w_topline win) (:lnum lpos)) (< (:lnum lpos) (:w_botline win)))
                (let [wrap @(:wo_wrap (:w_options win)) a'vcol (atom (int))]
                    (when (not wrap)
                        (getvcol win, lpos, nil, a'vcol, nil))
                    (if (or wrap (and (<= (:w_leftcol win) @a'vcol) (< @a'vcol (+ (:w_leftcol win) (:w_width win)))))
                        ;; save the pos, update-screen() may change it
                        (let [o'lpos lpos o'cursor (:w_cursor win) o'so @p_so o'siso @p_siso
                              win (update win :w_virtcol inc)               ;; do display ')' just before "$"
                              _ (update-screen VALID)                       ;; show the new char first
                              o'State @State _ (reset! State SHOWMATCH)
                              _ (ui-cursor-shape)                           ;; may show different cursor shape
                              win (assoc win :w_cursor o'lpos)              ;; move to matching char
                              _ (reset! p_so 0)                             ;; don't use 'scrolloff' here
                              _ (reset! p_siso 0)                           ;; don't use 'sidescrolloff' here
                              win (showruler win, false)]
                            (setcursor)
                            (cursor-on)                                     ;; make sure that the cursor is shown
                            (out-flush)
                            ;; brief pause, unless 'm' is present in 'cpo' and a character is available
                            (cond (some? (vim-strbyte @p_cpo, CPO_SHOWMATCH)) (ui-delay (* @p_mat 100), true)
                                  (not (char-avail))                          (ui-delay (* @p_mat 100), false))
                            (let [win (assoc win :w_cursor o'cursor)]       ;; restore cursor position
                                (reset! p_so o'so)
                                (reset! p_siso o'siso)
                                (reset! State o'State)
                                (ui-cursor-shape)                           ;; may show different cursor shape
                                win
                            ))
                        win
                    ))
            :else
                win
            ))
    ))

;; The following routines do the word searches performed
;; by the 'w', 'W', 'b', 'B', 'e', and 'E' commands.

;; To perform these searches, characters are placed into one of three
;; classes, and transitions between classes determine word boundaries.
;;
;; The classes are:
;;
;; 0 - white space
;; 1 - punctuation
;; 2 or higher - keyword characters (letters, digits and underscore)

;; Returns the class of the character at "w_cursor" of "win".
;;
;; If a 'W', 'B', or 'E' motion is being done,
;; chars from class 2 and higher are reported as class 1 since only
;; white space boundaries are of interest.

(defn- #_int cls-cursor [#_window_C win, #_boolean bigword]
    ;; bigword: true for "W", "B" or "E"
    (let [c (gchar-cursor win)] (if (any == c (byte \space) TAB NUL) 0 (let [c (utf-class c)] (if (and (non-zero? c) bigword) 1 c)))))

;; Move forward 'n' words.
;;
;; Returns false if the cursor was already at the end of the file.
;; If eol is true, last word stops at end of line (for operators).

(defn- #_[window_C boolean] fwd-word? [#_window_C win, #_long n, #_boolean bigword, #_boolean eol]
    (let [lmax (line-count @curbuf)]
        (loop-when [win (assoc-in win [:w_cursor :coladd] 0) n n] (pos? n) => [win true]
            ;; always move at least one char, unless on the last one in the buffer
            (let [cls (cls-cursor win, bigword) eof (== (:lnum (:w_cursor win)) lmax) [win ?] (inc-cursor? win, false)]
                (cond (or (== ? -1) (and (<= 1 ?) eof))         ;; started at last char in file
                    [win false]
                (and (<= 1 ?) eol (== n 1))                     ;; started at last char in line
                    [win true]
                :else ;; go one char past end of current word (if any)
                    (let-when [[win ? :as _]
                        (if (non-zero? cls)
                            (loop-when win (== (cls-cursor win, bigword) cls) => [win nil]
                                (let [[win ?] (inc-cursor? win, false)] (if (or (== ? -1) (and (<= 1 ?) eol (== n 1))) [win true] (recur win))))
                            [win nil]
                        )
                    ] (not ?) => _
                        ;; skip white space, but stop on an empty line
                        (let-when [[win ? :as _]
                            (loop-when win (and (zero? (cls-cursor win, bigword)) (not (and (zero? (:col (:w_cursor win))) (lineempty (:lnum (:w_cursor win)))))) => [win nil]
                                (let [[win ?] (inc-cursor? win, false)] (if (or (== ? -1) (and (<= 1 ?) eol (== n 1))) [win true] (recur win)))
                            )
                        ] (not ?) => _
                            (recur win (dec n)))
                    ))
            ))
    ))

(defn- #_window_C fwd-word [#_window_C win, #_long n, #_boolean bigword, #_boolean eol]
    (let [[win _] (fwd-word? [win, n, bigword, eol])]
        win
    ))

;; Move backward 'n' words.
;;
;; If stop is true and we are already on the start of a word, move one less.
;; Returns false if top of the file was reached.

(defn- #_[window_C boolean] bck-word? [#_window_C win, #_long n, #_boolean bigword, #_boolean stop]
    (loop-when [win (assoc-in win [:w_cursor :coladd] 0) n n stop stop] (pos? n) => [win true]
        (let-when [cls (cls-cursor win, bigword) [win ?] (dec-cursor? win, false)] (!= ? -1) => [win false] ;; started at start of file
            (let-when [[win ? :as _]
                (if (or (not stop) (== (cls-cursor win, bigword) cls) (zero? cls))
                    (loop [win win]
                        (let [cls' (cls-cursor win, bigword)]
                            (if (zero? cls')
                                ;; skip white space before the word, but stop on an empty line
                                (if (and (zero? (:col (:w_cursor win))) (lineempty (:lnum (:w_cursor win))))
                                    [win nil]
                                    (let-when [[win ?] (dec-cursor? win, false)] (!= ? -1) => [win true] ;; hit start of file, stop here
                                        (recur win)
                                    ))
                                ;; move backward to start of this word
                                (let-when [[win ?] (skip-chars? win, cls', bigword, BACKWARD)] (not ?) => [win true]
                                    [(inc-cursor win, false) nil] ;; overshot - forward one
                                ))
                        ))
                    [(inc-cursor win, false) nil] ;; overshot - forward one
                )
            ] (not ?) => _
                (recur win (dec n) false)
            ))
    ))

(defn- #_window_C bck-word [#_window_C win, #_long n, #_boolean bigword, #_boolean stop]
    (let [[win _] (bck-word? [win, n, bigword, stop])]
        win
    ))

;; Move to the end of the word.
;;
;; Returns false if end of the file was reached.
;; If stop is true and we are already on the end of a word, move one less.
;; If empty is true stop on an empty line.

(defn- #_[window_C boolean] end-word? [#_window_C win, #_long n, #_boolean bigword, #_boolean stop, #_boolean empty]
    (loop-when [win (assoc-in win [:w_cursor :coladd] 0) n n stop stop] (pos? n) => [win true]
        (let-when [cls (cls-cursor win, bigword) [win ?] (inc-cursor? win, false)] (!= ? -1) => [win false]
            (let-when [[win ? :as _]
                ;; If we're in the middle of a word, we just have to move to the end of it.
                (cond (and (== (cls-cursor win, bigword) cls) (non-zero? cls))
                    ;; move forward to end of the current word
                    (let-when [[win ?] (skip-chars? win, cls, bigword, FORWARD)] (not ?) => [win false]
                        [(dec-cursor win, false) nil] ;; overshot - one char backward
                    )
                (or (not stop) (zero? cls))
                    ;; We were at the end of a word.  Go to the end of the next word.
                    ;; First skip white space, if "empty" is true, stop at empty line.
                    (loop [win win]
                        (let [cls' (cls-cursor win, bigword)]
                            (if (zero? cls')
                                (if (and empty (zero? (:col (:w_cursor win))) (lineempty (:lnum (:w_cursor win))))
                                    [win nil]
                                    (let-when [[win ?] (inc-cursor? win, false)] (!= ? -1) => [win false] ;; hit end of file, stop here
                                        (recur win)
                                    ))
                                ;; move forward to the end of this word
                                (let-when [[win ?] (skip-chars? win, cls', bigword, FORWARD)] (not ?) => [win false]
                                    [(dec-cursor win, false) nil] ;; overshot - one char backward
                                ))
                        ))
                :else
                    [(dec-cursor win, false) nil] ;; overshot - one char backward
                )
            ] (nil? ?) => _
                (recur win (dec n) false) ;; we move only one word less
            ))
    ))

(defn- #_window_C end-word [#_window_C win, #_long n, #_boolean bigword, #_boolean stop, #_boolean empty]
    (let [[win _] (end-word? [win, n, bigword, stop, empty])]
        win
    ))

;; Move back to the end of the word.
;;
;; Returns false if start of the file was reached.
;; If eol is true, stop at end of line.

(defn- #_[window_C boolean] bckend-word? [#_window_C win, #_long n, #_boolean bigword, #_boolean eol]
    (loop-when [win (assoc-in win [:w_cursor :coladd] 0) n n] (pos? n) => [win true]
        (let [cls (cls-cursor win, bigword) [win ?] (dec-cursor? win, false)]
            (cond (== ? -1)
                [win false]
            (and eol (== ? 1))
                [win true]
            :else ;; move backward to before the start of this word
                (let-when [[win ? :as _]
                    (if (non-zero? cls)
                        (loop-when win (== (cls-cursor win, bigword) cls) => [win nil]
                            (let [[win ?] (dec-cursor? win, false)] (if (or (== ? -1) (and eol (== ? 1))) [win true] (recur win))))
                        [win nil]
                    )
                ] (not ?) => _
                    ;; move backward to end of the previous word
                    (let-when [[win ? :as _]
                        (loop-when win (and (zero? (cls-cursor win, bigword)) (not (and (zero? (:col (:w_cursor win))) (lineempty (:lnum (:w_cursor win)))))) => [win nil]
                            (let [[win ?] (dec-cursor? win, false)] (if (or (== ? -1) (and eol (== ? 1))) [win true] (recur win)))
                        )
                    ] (not ?) => _
                        (recur win (dec n))
                    ))
            ))
    ))

(defn- #_window_C bckend-word [#_window_C win, #_long n, #_boolean bigword, #_boolean eol]
    (let [[win _] (bckend-word? [win, n, bigword, eol])]
        win
    ))

;; Skip a row of characters of the same class.
;; Return true when end-of-file reached, false otherwise.

(defn- #_[window_C boolean] skip-chars? [#_window_C win, #_int cclass, #_boolean bigword, #_int dir]
    (loop-when win (== (cls-cursor win, bigword) cclass) => [win false]
        (let [[win ?] ((if (== dir FORWARD) inc-cursor? dec-cursor?) win, false)] (recur-if (!= ? -1) win => [win true]))
    ))

;; Go back to the start of the word or the start of white space.

(defn- #_window_C back-in-line [#_window_C win, #_boolean bigword]
    (let [sclass (cls-cursor win, bigword)] ;; starting class
        (loop-when win (pos? (:col (:w_cursor win))) => win ;; stop at start of line
            (let [win (dec-cursor win, false)]
                (recur-if (== (cls-cursor win, bigword) sclass) win => (inc-cursor win, false)) ;; stop at start of word
            ))
    ))

;; Find word under cursor, cursor at end.
;; Used while an operator is pending, and in Visual mode.

(defn- #_boolean current-word [#_oparg_C oap, #_long count, #_boolean include, #_boolean bigword]
    ;; include: true: include word and white space
    ;; bigword: false == word, true == WORD
    (ยง
        ((ร boolean inclusive =) true)
        ((ร boolean include_white =) false)

        ((ร pos_C start_pos =) (NEW_pos_C))

        ;; Correct cursor when 'selection' is exclusive.
        (when (and @VIsual_active (at? @p_sel (byte \e)) (ltpos @VIsual_cursor, (:w_cursor @curwin)))
            (swap! curwin dec-cursor false))

        ;; When Visual mode is not active, or when the VIsual area is only one
        ;; character, select the word and/or white space under the cursor.

        (when (or (not @VIsual_active) (eqpos (:w_cursor @curwin), @VIsual_cursor))
            ;; Go to start of current word or white space.

            (swap! curwin back-in-line bigword)
            (COPY-pos start_pos, (:w_cursor @curwin))

            ;; If the start is on white space, and white space should be included
            ;; ("   word"), or start is not on white space, and white space should
            ;; not be included ("word"), find end of word.

            (cond (== (zero? (cls-cursor @curwin, bigword)) include)
            (do
                (if (not (let [[_ ?] (end-word? @curwin, 1, bigword, true, true)] (reset! curwin _) ?))
                    ((ร RETURN) false)
                )
            )
            :else
            (do
                ;; If the start is not on white space, and white space should be included ("word   "),
                ;; or start is on white space and white space should not be included ("   "),
                ;; find start of word.
                ;; If we end up in the first column of the next line (single char word)
                ;; back up to end of the line.

                (swap! curwin fwd-word 1, bigword, true)
                (if (zero? (:col (:w_cursor @curwin)))
                    (swap! curwin dec-cursor true)
                    (swap! curwin oneleft))

                ((ร include_white =) (or include include_white))
            ))

            (cond @VIsual_active
            (do
                ;; should do something when inclusive == false !
                (reset! VIsual_cursor start_pos)
                (redraw-curbuf-later INVERTED)      ;; update the inversion
            )
            :else
            (do
                (COPY-pos (:op_start oap), start_pos)
                ((ร oap =) (assoc oap :motion_type MCHAR))
            ))
            ((ร count =) (dec count))
        )

        ;; When count is still > 0, extend with more objects.

        (loop-when [] (< 0 count)
            ((ร inclusive =) true)
            (cond (and @VIsual_active (ltpos (:w_cursor @curwin), @VIsual_cursor))
            (do
                ;; In Visual mode, with cursor at start: move cursor back.

                (if (== (let [[_ ?] (dec-cursor? @curwin, true)] (reset! curwin _) ?) -1)
                    ((ร RETURN) false)
                )

                (cond (!= include (!= (cls-cursor @curwin, bigword) 0))
                (do
                    (if (not (let [[_ ?] (bck-word? @curwin, 1, bigword, true)] (reset! curwin _) ?))
                        ((ร RETURN) false)
                    )
                )
                :else
                (do
                    (if (not (let [[_ ?] (bckend-word? @curwin, 1, bigword, true)] (reset! curwin _) ?))
                        ((ร RETURN) false)
                    )
                    (swap! curwin inc-cursor true)
                ))
            )
            :else
            (do
                ;; Move cursor forward one word and/or white area.

                (if (== (let [[_ ?] (inc-cursor? @curwin, true)] (reset! curwin _) ?) -1)
                    ((ร RETURN) false)
                )

                (cond (!= include (== (cls-cursor @curwin, bigword) 0))
                (do
                    (if (and (not (let [[_ ?] (fwd-word? @curwin, 1, bigword, true)] (reset! curwin _) ?)) (< 1 count))
                        ((ร RETURN) false)
                    )

                    ;; If end is just past a new-line,
                    ;; we don't want to include the first character on the line.
                    ;; Put cursor on last char of white.

                    ((ร inclusive =) (and (let [[_ ?] (oneleft? @curwin)] (reset! curwin _) ?) inclusive))
                )
                :else
                (do
                    (if (not (let [[_ ?] (end-word? @curwin, 1, bigword, true, true)] (reset! curwin _) ?))
                        ((ร RETURN) false)
                    )
                ))
            ))
            ((ร count =) (dec count))
            (recur)
        )

        (when (and include_white (or (non-zero? (cls-cursor @curwin, bigword)) (and (zero? (:col (:w_cursor @curwin))) (not inclusive))))
            ;; If we don't include white space at the end, move the start to include
            ;; some white space there.  This makes "daw" work better on the last word in
            ;; a sentence (and "2daw" on last-but-one word).  Also when "2daw" deletes
            ;; "word." at the end of the line (cursor is at start of next line).
            ;; But don't delete white space at start of line (indent).

            ((ร pos_C pos =) (NEW_pos_C))
            (COPY-pos pos, (:w_cursor @curwin)) ;; save cursor position
            (swap! curwin assoc :w_cursor start_pos)
            (when (let [[_ ?] (oneleft? @curwin)] (reset! curwin _) ?)
                (swap! curwin back-in-line bigword)
                (when (and (zero? (cls-cursor @curwin, bigword)) (< 0 (:col (:w_cursor @curwin))))
                    (if @VIsual_active
                        (reset! VIsual_cursor (:w_cursor @curwin))
                        (COPY-pos (:op_start oap), (:w_cursor @curwin)))
                )
            )
            (swap! curwin assoc :w_cursor pos) ;; put cursor back at end
        )

        (cond @VIsual_active
        (do
            (when (and (at? @p_sel (byte \e)) inclusive (ltoreq @VIsual_cursor, (:w_cursor @curwin)))
                (swap! curwin inc-cursor false))
            (when (== @VIsual_mode (byte \V))
                (reset! VIsual_mode (byte \v))
                (reset! redraw_cmdline true)              ;; show mode later
            )
        )
        :else
        (do
            ((ร oap =) (assoc oap :inclusive inclusive))
        ))

        true
    ))

;; Find block under the cursor, cursor at end.
;; "what" and "other" are two matching parenthesis/brace/etc.

(defn- #_boolean current-block [#_oparg_C oap, #_long count, #_boolean include, #_int what, #_int other]
    ;; include: true == include white space
    ;; what: '(', '{', etc.
    ;; other: ')', '}', etc.
    (ยง
        ((ร pos_C pos =) nil)
        ((ร pos_C start_pos =) (NEW_pos_C))
        (ร pos_C end_pos)
        ((ร boolean sol =) false)                    ;; '{' at start of line

        ((ร pos_C old_pos =) (NEW_pos_C))
        (COPY-pos old_pos, (:w_cursor @curwin))
        ((ร pos_C old_end =) (NEW_pos_C))
        (COPY-pos old_end, (:w_cursor @curwin))     ;; remember where we started
        ((ร pos_C old_start =) (NEW_pos_C))
        (COPY-pos old_start, old_end)

        ;; If we start on '(', '{', ')', '}', etc., use the whole block inclusive.

        (cond (or (not @VIsual_active) (eqpos @VIsual_cursor, (:w_cursor @curwin)))
        (do
            (swap! curwin setpcmark)
            (when (== what (byte \{))                    ;; ignore indent
                (while (and (inindent @curwin, 1) (zero? (let [[_ ?] (inc-cursor? @curwin, false)] (reset! curwin _) ?)))
                    ;
                )
            )
            (when (== (gchar-cursor @curwin) what)
                ;; cursor on '(' or '{', move cursor just after it
                (swap! curwin update-in [:w_cursor :col] inc)
            )
        )
        (ltpos @VIsual_cursor, (:w_cursor @curwin))
        (do
            (COPY-pos old_start, @VIsual_cursor)
            (swap! curwin assoc :w_cursor @VIsual_cursor) ;; cursor at low end of Visual
        )
        :else
        (do
            (COPY-pos old_end, @VIsual_cursor)
        ))

        ;; Search backwards for unclosed '(', '{', etc..
        ;; Put this position in start_pos.
        ;; Ignore quotes here.  Keep the "M" flag in 'cpo', as that is what the user wants.

        ((ร Bytes save_cpo =) @p_cpo)
        (reset! p_cpo (if (some? (vim-strbyte @p_cpo, CPO_MATCHBSL)) (u8 "%M") (u8 "%")))
        (loop-when [] (<= 0 ((ร count =) (dec count)))
            (if (nil? ((ร pos =) (findmatch nil, what)))
                (ร BREAK)
            )
            (swap! curwin assoc :w_cursor pos)
            (COPY-pos start_pos, pos) ;; the findmatch for end_pos will overwrite *pos
            (recur)
        )
        (reset! p_cpo save_cpo)

        ;; Search for matching ')', '}', etc.
        ;; Put this position in curwin.w_cursor.

        (when (or (nil? pos) (nil? ((ร end_pos =) (findmatch nil, other))))
            (swap! curwin assoc :w_cursor old_pos)
            ((ร RETURN) false)
        )
        (swap! curwin assoc :w_cursor end_pos)

        ;; Try to exclude the '(', '{', ')', '}', etc. when "include" is false.
        ;; If the ending '}', ')' or ']' is only preceded by indent, skip that indent.
        ;; But only if the resulting area is not smaller than what we started with.

        (loop-when [] (not include)
            ((ร start_pos =) (let [[_ ?] (incl start_pos)] _))
            ((ร sol =) (== (:col (:w_cursor @curwin)) 0))
            (swap! curwin dec-cursor true)
            (loop-when [] (inindent @curwin, 1)
                ((ร sol =) true)
                (if (!= (let [[_ ?] (dec-cursor? @curwin, true)] (reset! curwin _) ?) 0)
                    (ร BREAK)
                )
                (recur)
            )

            ;; In Visual mode, when the resulting area is not bigger than what we
            ;; started with, extend it to the next block, and then exclude again.

            (cond (and (not (ltpos start_pos, old_start)) (not (ltpos old_end, (:w_cursor @curwin))) @VIsual_active)
            (do
                (swap! curwin assoc :w_cursor old_start)
                (swap! curwin dec-cursor true)
                (when (nil? ((ร pos =) (findmatch nil, what)))
                    (swap! curwin assoc :w_cursor old_pos)
                    ((ร RETURN) false)
                )
                (COPY-pos start_pos, pos)
                (swap! curwin assoc :w_cursor pos)
                (when (nil? ((ร end_pos =) (findmatch nil, other)))
                    (swap! curwin assoc :w_cursor old_pos)
                    ((ร RETURN) false)
                )
                (swap! curwin assoc :w_cursor end_pos)
            )
            :else
            (do
                (ร BREAK)
            ))
            (recur)
        )

        (cond @VIsual_active
        (do
            (when (at? @p_sel (byte \e))
                (swap! curwin update-in [:w_cursor :col] inc))
            (when (and sol (!= (gchar-cursor @curwin) NUL))
                (swap! curwin inc-cursor false))               ;; include the line break
            (reset! VIsual_cursor start_pos)
            (reset! VIsual_mode (byte \v))
            (redraw-curbuf-later INVERTED)          ;; update the inversion
            (showmode)
        )
        :else
        (do
            (COPY-pos (:op_start oap), start_pos)
            ((ร oap =) (assoc oap :motion_type MCHAR :inclusive false))
            (cond sol
            (do
                (swap! curwin inc-cursor true)
            )
            (ltoreq start_pos, (:w_cursor @curwin))
            (do
                ;; Include the character under the cursor.
                ((ร oap =) (assoc oap :inclusive true))
            )
            :else
            (do
                ;; End is before the start (no text in between <>, [], etc.): don't operate on any text.
                (swap! curwin assoc :w_cursor start_pos)
            ))
        ))

        true
    ))

;; Search quote char from string line[col].
;; Quote character escaped by one of the characters in "escape" is not counted as a quote.
;; Returns column number of "quotechar" or -1 when not found.

(defn- #_int find-next-quote [#_Bytes line, #_int col, #_int quotechar, #_Bytes escape]
    ;; escape: escape characters, can be null
    (loop [i col]
        (let [c (.at line i)]
            (cond (== c NUL)
                -1
            (and (some? escape) (some? (vim-strchr escape, c)))
                (let [i (inc i)] (recur (+ i (us-ptr2len-cc line, i))))
            (== c quotechar)
                i
            :else
                (recur (+ i (us-ptr2len-cc line, i)))
            ))
    ))

;; Search backwards in "line" from column "col_start" to find "quotechar".
;; Quote character escaped by one of the characters in "escape" is not counted as a quote.
;; Return the found column or zero.

(defn- #_int find-prev-quote [#_Bytes line, #_int col_start, #_int quotechar, #_Bytes escape]
    ;; escape: escape characters, can be null
    (loop-when [i col_start] (< 0 i) => i
        (let [i (dec i) i (- i (us-head-off line, (.plus line i)))
              n (if (some? escape) (loop-when-recur [n 0] (and (< 0 (- i n)) (some? (vim-strchr escape, (.at line (- i n 1))))) [(inc n)] => n) 0)]
            (cond
                (non-zero? (& n 1)) (recur (- i n)) ;; uneven number of escape chars, skip it
                (at? line i quotechar) i
                :else (recur i)
            ))
    ))

;; Find quote under the cursor, cursor at end.
;; Returns true if found, else false.

(defn- #_boolean current-quote [#_oparg_C oap, #_long count, #_boolean include, #_int quotechar]
    ;; include: true == include quote char
    ;; quotechar: Quote character
    (ยง
        ((ร Bytes line =) (ml-get (:lnum (:w_cursor @curwin))))
        (ร int col_end)
        ((ร int col_start =) (:col (:w_cursor @curwin)))

        ((ร boolean inclusive =) false)
        ((ร boolean vis_empty =) true)           ;; Visual selection <= 1 char
        ((ร boolean vis_bef_curs =) false)       ;; Visual starts before cursor
        ((ร boolean inside_quotes =) false)      ;; Looks like "i'" done before
        ((ร boolean selected_quote =) false)     ;; Has quote inside selection

        ;; Correct cursor when 'selection' is exclusive.
        (when @VIsual_active
            ((ร vis_bef_curs =) (ltpos @VIsual_cursor, (:w_cursor @curwin)))
            (when (and (at? @p_sel (byte \e)) vis_bef_curs)
                (swap! curwin dec-cursor false))
            ((ร vis_empty =) (eqpos @VIsual_cursor, (:w_cursor @curwin)))
        )

        (when (not vis_empty)
            (ร int i)
            ;; Check if the existing selection exactly spans the text inside quotes.
            (cond vis_bef_curs
            (do
                ((ร inside_quotes =) (and (< 0 (:col @VIsual_cursor)) (and (at? line (dec (:col @VIsual_cursor)) quotechar) (non-eos? line (:col (:w_cursor @curwin))) (at? line (inc (:col (:w_cursor @curwin))) quotechar))))
                ((ร i =) (:col @VIsual_cursor))
                ((ร col_end =) (:col (:w_cursor @curwin)))
            )
            :else
            (do
                ((ร inside_quotes =) (and (< 0 (:col (:w_cursor @curwin))) (and (at? line (dec (:col (:w_cursor @curwin))) quotechar) (non-eos? line (:col @VIsual_cursor)) (at? line (inc (:col @VIsual_cursor)) quotechar))))
                ((ร i =) (:col (:w_cursor @curwin)))
                ((ร col_end =) (:col @VIsual_cursor))
            ))

            ;; Find out if we have a quote in the selection.
            (loop-when [] (<= i col_end)
                (when (at? line (ร i++) quotechar)
                    ((ร selected_quote =) true)
                    (ร BREAK)
                )
                (recur)
            )
        )

        (cond (and (not vis_empty) (at? line col_start quotechar))
        (do
            ;; Already selecting something and on a quote character.
            ;; Find the next quoted string.
            (cond vis_bef_curs
            (do
                ;; Assume we are on a closing quote: move to after the next opening quote.
                ((ร col_start =) (find-next-quote line, (inc col_start), quotechar, nil))
                (if (< col_start 0)
                    ((ร RETURN) false)
                )
                ((ร col_end =) (find-next-quote line, (inc col_start), quotechar, @(:b_p_qe @curbuf)))
                (when (< col_end 0)
                    ;; We were on a starting quote perhaps?
                    ((ร col_end =) col_start)
                    ((ร col_start =) (:col (:w_cursor @curwin)))
                )
            )
            :else
            (do
                ((ร col_end =) (find-prev-quote line, col_start, quotechar, nil))
                (if (not-at? line col_end quotechar)
                    ((ร RETURN) false)
                )
                ((ร col_start =) (find-prev-quote line, col_end, quotechar, @(:b_p_qe @curbuf)))
                (when (not-at? line col_start quotechar)
                    ;; We were on an ending quote perhaps?
                    ((ร col_start =) col_end)
                    ((ร col_end =) (:col (:w_cursor @curwin)))
                )
            ))
        )
        (or (at? line col_start quotechar) (not vis_empty))
        (do
            ((ร int first_col =) col_start)

            (when (not vis_empty)
                ((ร first_col =) (if vis_bef_curs
                    (find-next-quote line, col_start, quotechar, nil)
                    (find-prev-quote line, col_start, quotechar, nil)
                ))
            )

            ;; The cursor is on a quote, we don't know if it's the opening or
            ;; closing quote.  Search from the start of the line to find out.
            ;; Also do this when there is a Visual area, a' may leave the cursor
            ;; in between two strings.
            ((ร col_start =) 0)
            (loop []
                ;; Find open quote character.
                ((ร col_start =) (find-next-quote line, col_start, quotechar, nil))
                (if (or (< col_start 0) (< first_col col_start))
                    ((ร RETURN) false)
                )
                ;; Find close quote character.
                ((ร col_end =) (find-next-quote line, (inc col_start), quotechar, @(:b_p_qe @curbuf)))
                (if (< col_end 0)
                    ((ร RETURN) false)
                )
                ;; If is cursor between start and end quote character,
                ;; it is target text object.
                (if (<= col_start first_col col_end)
                    (ร BREAK)
                )
                ((ร col_start =) (inc col_end))
                (recur)
            )
        )
        :else
        (do
            ;; Search backward for a starting quote.
            ((ร col_start =) (find-prev-quote line, col_start, quotechar, @(:b_p_qe @curbuf)))
            (when (not-at? line col_start quotechar)
                ;; No quote before the cursor, look after the cursor.
                ((ร col_start =) (find-next-quote line, col_start, quotechar, nil))
                (if (< col_start 0)
                    ((ร RETURN) false)
                )
            )

            ;; Find close quote character.
            ((ร col_end =) (find-next-quote line, (inc col_start), quotechar, @(:b_p_qe @curbuf)))
            (if (< col_end 0)
                ((ร RETURN) false)
            )
        ))

        ;; When "include" is true,
        ;; include spaces after closing quote or before the starting quote.
        (when include
            (cond (vim-iswhite (.at line (inc col_end)))
            (do
                (loop-when [] (vim-iswhite (.at line (inc col_end)))
                    ((ร col_end =) (inc col_end))
                    (recur)
                )
            )
            :else
            (do
                (loop-when [] (and (< 0 col_start) (vim-iswhite (.at line (dec col_start))))
                    ((ร col_start =) (dec col_start))
                    (recur)
                )
            ))
        )

        ;; Set start position.  After vi" another i" must include the ".
        ;; For v2i" include the quotes.
        ((ร col_start =) (if (and (not include) (< count 2) (or vis_empty (not inside_quotes))) (inc col_start) col_start))
        (swap! curwin assoc-in [:w_cursor :col] col_start)
        (cond @VIsual_active
        (do
            ;; Set the start of the Visual area when the Visual area was empty, we
            ;; were just inside quotes or the Visual area didn't start at a quote
            ;; and didn't include a quote.

            (when (or vis_empty (and vis_bef_curs (not selected_quote) (or inside_quotes (and (not-at? line (:col @VIsual_cursor) quotechar) (or (zero? (:col @VIsual_cursor)) (not-at? line (dec (:col @VIsual_cursor)) quotechar))))))
                (reset! VIsual_cursor (:w_cursor @curwin))
                (redraw-curbuf-later INVERTED)
            )
        )
        :else
        (do
            (COPY-pos (:op_start oap), (:w_cursor @curwin))
            ((ร oap =) (assoc oap :motion_type MCHAR))
        ))

        ;; Set end position.
        (swap! curwin assoc-in [:w_cursor :col] col_end)
        ;; After vi" another i" must include the ".
        ((ร inclusive =) (or (and (or include (< 1 count) (and (not vis_empty) inside_quotes)) (== (let [[_ ?] (inc-cursor? @curwin, false)] (reset! curwin _) ?) 2)) inclusive))
        (cond @VIsual_active
        (do
            (cond (or vis_empty vis_bef_curs)
            (do
                ;; decrement cursor when 'selection' is not exclusive
                (when (not-at? @p_sel (byte \e))
                    (swap! curwin dec-cursor false))
            )
            :else
            (do
                ;; Cursor is at start of Visual area.  Set the end of the Visual area
                ;; when it was just inside quotes or it didn't end at a quote.
                (when (or inside_quotes (and (not selected_quote) (not-at? line (:col @VIsual_cursor) quotechar) (or (at? line (:col @VIsual_cursor) NUL) (not-at? line (inc (:col @VIsual_cursor)) quotechar))))
                    (swap! curwin dec-cursor false)
                    (reset! VIsual_cursor (:w_cursor @curwin))
                )
                (swap! curwin assoc-in [:w_cursor :col] col_start)
            ))
            (when (== @VIsual_mode (byte \V))
                (reset! VIsual_mode (byte \v))
                (reset! redraw_cmdline true)              ;; show mode later
            )
        )
        :else
        (do
            ;; Set inclusive and other oap's flags.
            ((ร oap =) (assoc oap :inclusive inclusive))
        ))

        true
    ))

;; Find next search match under cursor, cursor at end.
;; Used while an operator is pending, and in Visual mode.

(defn- #_boolean current-search [#_long count, #_boolean forward]
    (let [#_pos_C save_VIsual @VIsual_cursor
          o'p_ws @p_ws _ (reset! p_ws false)]           ;; wrapping should not occur
        ;; Correct cursor when 'selection' is exclusive.
        (when (and @VIsual_active (at? @p_sel (byte \e)) (ltpos @VIsual_cursor, (:w_cursor @curwin)))
            (swap! curwin dec-cursor false))
        (let-when [o'cursor (:w_cursor @curwin)         ;; position of the cursor at beginning
              [#_pos_C start_pos #_pos_C pos]           ;; position before/after the pattern
                (if @VIsual_active ;; make sure, searching further will extend the match
                    [@VIsual_cursor (let [[_ ?] ((if forward incl decl) o'cursor)] _)]
                    [o'cursor o'cursor])
              ;; Is the pattern zero-width?
              #_int one_char (is-one-char (:pat (... @spats @last_idx)), true)
        ] (!= one_char -1) => (do (reset! p_ws o'p_ws) false) ;; pattern not found

            ;; The trick is to first search backwards and then search forward again,
            ;; so that a match at the current cursor position will be correctly captured.
            (let-when [pos
                (loop-when [pos pos #_int round 0] (< round 2) => pos
                    (let-when [#_boolean dir (if forward (non-zero? round) (zero? round))
                          #_int flags (if (and (not dir) (zero? one_char)) SEARCH_END 0)
                          #_int result
                            (searchit pos, (if dir FORWARD BACKWARD), (:pat (... @spats @last_idx)), (if (non-zero? round) count 1), (| flags SEARCH_KEEP), RE_SEARCH, 0, nil)
                            ;; First search may fail, but then start searching from the beginning of
                            ;; the file (cursor might be on the search match) except when Visual mode
                            ;; is active, so that extending the visual selection works.
                          pos (cond (non-zero? result)
                                pos
                            (zero? round)
                                (cond forward           ;; try again from start of buffer
                                    (NEW_pos_C)
                                :else                   ;; try again from end of buffer
                                (let [lmax (line-count @curbuf)]
                                    ;; searching backwards, so set pos to last line and col
                                    (assoc pos :lnum lmax :col (STRLEN (ml-get lmax)))
                                ))
                            :else   ;; not found, abort
                                (do (swap! curwin assoc :w_cursor o'cursor)
                                    (when @VIsual_active
                                        (reset! VIsual_cursor save_VIsual))
                                    nil)
                            )] (some? pos) => nil
                        (reset! p_ws o'p_ws)
                        (recur pos (inc round))
                    ))
            ] (some? pos) => (do (reset! p_ws o'p_ws) false)

                (let [start_pos pos
                      #_int flags (if forward SEARCH_END 0)
                      ;; Check again from the current cursor position,
                      ;; since the next match might actually be only one char wide.
                      one_char (is-one-char (:pat (... @spats @last_idx)), false)]
                    ;; Move to match, except for zero-width matches,
                    ;; in which case, we are already on the next match.
                    (when (== one_char FALSE)
                        (searchit pos, (if forward FORWARD BACKWARD), (:pat (... @spats @last_idx)), 0, (| flags SEARCH_KEEP), RE_SEARCH, 0, nil))
                    (when (not @VIsual_active)
                        (reset! VIsual_cursor start_pos))
                    (swap! curwin assoc :w_cursor pos)
                    (reset! VIsual_active true)
                    (reset! VIsual_mode (byte \v))
                    (when @VIsual_active	;; %% true!
                        (redraw-curbuf-later INVERTED)  ;; update the inversion
                        (when (at? @p_sel (byte \e))
                            (cond ;; Correction for exclusive selection depends on the direction.
                                (and      forward  (ltoreq @VIsual_cursor, (:w_cursor @curwin))) (swap! curwin inc-cursor false)
                                (and (not forward) (ltoreq (:w_cursor @curwin), @VIsual_cursor)) (swap! VIsual_cursor #(let [[_ ?] (incp %)] _))
                            )))
                    (may-start-select (byte \c))
                    (redraw-curbuf-later INVERTED)
                    (showmode)
                    true)
            ))
    ))

;; Check if the pattern is one character or zero-width.
;; If move is true, check from the beginning of the buffer, else from the current cursor position.
;; Returns TRUE, FALSE or -1 for failure.

(defn- #_int is-one-char [#_Bytes pattern, #_boolean move]
    (let-when [o'called_emsg @called_emsg
               #_regmmatch_C regmatch (NEW_regmmatch_C)] (search-regcomp pattern, RE_SEARCH, RE_SEARCH, SEARCH_KEEP, regmatch) => -1
        (let [[#_pos_C pos #_int flags] (if move [(NEW_pos_C) 0] [(:w_cursor @curwin) SEARCH_START]) ;; accept a match at the cursor position
              #_int result
                (if (non-zero? (searchit pos, FORWARD, (:pat (... @spats @last_idx)), 1, (| flags SEARCH_KEEP), RE_SEARCH, 0, nil))
                    ;; Zero-width pattern should match somewhere, then we can check if start and end are in the same position.
                    (let [_ (reset! called_emsg false)
                          #_long n (vim-regexec-multi regmatch, (:lnum pos), 0, nil)
                          startpos (... (:startpos regmatch) 0) endpos (... (:endpos regmatch) 0)
                          result (if (not @called_emsg) (if (and (!= n 0) (== (:lnum startpos) (:lnum endpos)) (== (:col startpos) (:col endpos))) TRUE FALSE) -1)]
                        (if (and (== result FALSE) (let [[pos ?] (incp pos)] (and (<= 0 ?) (== (:col pos) (:col endpos))))) TRUE result))
                    -1)]
            (swap! called_emsg | o'called_emsg)
            result)
    ))

;; Return true if line 'lnum' is empty or has white chars only.

(defn- #_boolean linewhite [#_long lnum]
    (eos? (skipwhite (ml-get lnum))))

;; memline.c: Contains the functions for appending, deleting and changing the text lines.

;; Open a new memline.

(defn- #_memline_C ml-open []
    (ยง
        ((ร memline_C ml =) (NEW_memline_C))

        ((ร ml =) (assoc ml :ml_flags ML_EMPTY))
        ((ร ml =) (assoc ml :ml_line_count 1))

        ;; Create an empty line 1.

;       %% insert @0 (u8 "")

        ml
    ))

;; Return a pointer to a (read-only copy of a) line.
;;
;; On failure an error message is given and "???" is returned
;; (to avoid having to check for error everywhere).

(defn- #_Bytes ml-get [#_long lnum]
    (if-not (<= 0 lnum (line-count @curbuf))
        (do
            (emsgn (u8 "E315: ml-get: invalid lnum: %ld"), lnum)
            (u8 "???")
        )
        (let [lnum (max 1 lnum)]           ;; pretend line 0 is line 1
;           %% return @(lnum - 1)
        )
    ))

;; Return pointer to position "pos".

(defn- #_Bytes ml-get-pos [#_pos_C pos]
    (.plus (ml-get (:lnum pos)) (:col pos)))

;; Return pointer to cursor position.

(defn- #_Bytes ml-get-cursor [#_window_C win]
    (.plus (ml-get (:lnum (:w_cursor win))) (:col (:w_cursor win))))

;; Append a line after lnum (may be 0 to insert a line in front of the file).
;; "line" does not need to be allocated, but can't be another line in a buffer,
;; unlocking may make it invalid.
;;
;; Check: The caller of this function should probably also call appended-lines().
;;
;; return false for failure, true otherwise

(defn- #_boolean ml-append [#_long lnum, #_Bytes line]
    ;; lnum: append after this line (can be 0)
    ;; line: text of the new line
    (if-not (<= 0 lnum (line-count @curbuf))
        false
        (do
;           %% insert @lnum STRDUP(line)
            (swap! curbuf update-in [:b_ml :ml_line_count] inc)
            (swap! curbuf update-in [:b_ml :ml_flags] & (bit-not ML_EMPTY))
            true
        )
    ))

;; Replace line lnum in current buffer.
;;
;; Check: The caller of this function should probably also call
;; changed-lines(), unless update-screen(NOT_VALID) is used.
;;
;; return false for failure, true otherwise

(defn- #_boolean ml-replace [#_long lnum, #_Bytes line]
    (if (or (not (<= 1 lnum (line-count @curbuf))) (nil? line))           ;; just checking...
        false
        (do
;           %% replace @(lnum - 1) STRDUP(line)
            (swap! curbuf update-in [:b_ml :ml_flags] & (bit-not ML_EMPTY))
            true
        )
    ))

;; Delete line 'lnum' in the current buffer.
;;
;; Check: The caller of this function should probably also call
;; deleted-lines() after this.
;;
;; return false for failure, true otherwise

(defn- #_boolean ml-delete [#_long lnum, #_boolean message]
    (let [lmax (line-count @curbuf)]
        (cond (not (<= 1 lnum lmax))
            false
        (== lmax 1) ;; if the file becomes empty the last line is replaced by an empty line
            (do
                (if message
                    (set-keep-msg no_lines_msg, 0))
;               %% replace @0 (u8 "")
                (swap! curbuf update-in [:b_ml :ml_flags] | ML_EMPTY)
                true
            )
        :else
            (do
;               %% delete @(lnum - 1)
                (swap! curbuf update-in [:b_ml :ml_line_count] dec)
                true
            )
        )
    ))

;; buffer.c: functions for dealing with the buffer structure --------------------------------------

;; The buffer list is a double linked list of all buffers.
;; Each buffer can be in one of these states:
;;       hidden: b_nwindows == 0, loaded but not displayed in a window
;;       normal: loaded and displayed in a window

;; Close the link to a buffer.

(defn- #_void close-buffer [#_window_C win]
    ;; decrease the link count from windows (unless not in any window)
    (let-when [n (:b_nwindows @curbuf)] (pos? n)
        ;; Set "b_last_cursor" when closing the last window for the buffer.
        ;; Remember the last cursor position and window options of the buffer.
        (when (== n 1)
            (swap! curbuf assoc :b_last_cursor (:w_cursor win)))
        (swap! curbuf update :b_nwindows dec))
    nil)

;; This is the ONLY way to create a new buffer.

(defn- #_buffer_C newBuffer []
    (-> (NEW_buffer_C) (assoc :b_u_synced true) (assoc-in [:b_last_cursor :lnum] 1)))

;; Print info about the current buffer.

(defn- #_void fileinfo [#_int _fullname]
    (let [lnum (:lnum (:w_cursor @curwin)) lmax (line-count @curbuf)
          #_Bytes buf (Bytes. IOSIZE)]
        (let [#_Bytes p (-> buf (.be 0, (byte \")) (.plus 1))] ;; """
            (vim-strncpy p, (u8 "[No Name]"), (- IOSIZE (BDIFF p, buf) 1)))
;%%     (vim_snprintf_add buf, IOSIZE, (u8 "\"%s"), (if @(:b_changed @curbuf) (u8 " [Modified] ") (u8 " ")))
        (let [#_int n (int (/ (* lnum 100) lmax))]
;%%         (cond (flag? (:ml_flags (:b_ml @curbuf)) ML_EMPTY)
;%%             (vim_snprintf_add buf, IOSIZE, (u8 "%s"), no_lines_msg)
;%%         @p_ru ;; Current line and column are already on the screen.
;%%             (if (== lmax 1)
;%%                 (vim_snprintf_add buf, IOSIZE, (u8 "1 line --%d%%--"), n)
;%%                 (vim_snprintf_add buf, IOSIZE, (u8 "%ld lines --%d%%--"), lmax, n))
;%%         :else
;%%         (do
;%%             (vim_snprintf_add buf, IOSIZE, (u8 "line %ld of %ld --%d%%-- col "), lnum, lmax, n)
;%%             (swap! curwin validate-virtcol)
;%%             (let [#_int len (STRLEN buf)]
;%%                 (col-print (.plus buf len), (- IOSIZE len), (inc (:col (:w_cursor @curwin))), (inc (:w_virtcol @curwin))))
;%%         ))
            ;; Temporarily set msg_scroll to avoid the message being truncated.
            ;; First call msg-start() to get the message in the right place.
            (msg-start)
            (let [_ @msg_scroll] (reset! msg_scroll true) (msg buf) (reset! msg_scroll _))
        ))
    nil)

(defn- #_void col-print [#_Bytes buf, #_int buflen, #_int col, #_int vcol]
;%% (if (== col vcol)
;%%     (vim_snprintf buf, buflen, (u8 "%d"), col)
;%%     (vim_snprintf buf, buflen, (u8 "%d-%d"), col, vcol)
;%% )
    nil)

;; Get relative cursor position in window into "buf[buflen]", in the form 99%, using "Top", "Bot" or "All" when appropriate.

(defn- #_void get-rel-pos [#_window_C win, #_Bytes buf, #_int buflen]
    (if (<= 3 buflen) ;; need at least 3 chars for writing
        ;; number of lines above/below window
        (let [above (dec (:w_topline win)) below (inc (- (line-count @curbuf) (:w_botline win)))]
            (cond (<= below 0)
                (vim-strncpy buf, (if (zero? above) (u8 "All") (u8 "Bot")), (dec buflen))
            (<= above 0)
                (vim-strncpy buf, (u8 "Top"), (dec buflen))
            :else
            (let [cent (if (< 1000000 above) (/ above (/ (+ above below) 100)) (/ (* above 100) (+ above below)))]
;%%             (vim_snprintf buf, buflen, (u8 "%2d%%"), cent)
            ))
        ))
    nil)

;;; ============================================================================================== VimQ

;; charset.c --------------------------------------------------------------------------------------

(atom! boolean chartab_initialized)

(defn- #_void set-chartab [#_int c]
    (swap! curbuf update-in [:b_chartab (>>> c 5)] | (<< 1 (& c 0x1f)))
    nil)

(defn- #_void reset-chartab [#_int c]
    (swap! curbuf update-in [:b_chartab (>>> c 5)] & (bit-not (<< 1 (& c 0x1f))))
    nil)

(defn- #_int get-chartab [#_int c]
    (& (... (:b_chartab @curbuf) (>>> c 5)) (<< 1 (& c 0x1f))))

;; Fill chartab[].  Also fills @curbuf.b_chartab[] with flags for keyword characters for current buffer.
;;
;; Depends on the option settings 'isident', 'isprint', 'isfname' and 'iskeyword'.
;;
;; The index in chartab[] depends on 'encoding':
;; - For non-multi-byte index with the byte (same as the character).
;; - For UTF-8 index with the character (when first byte is up to 0x80 it is the same
;;   as the character, if the first byte is 0x80 and above it depends on further bytes).
;;
;; The contents of chartab[]:
;; - The lower three bits, masked by CT_CELL_MASK, give the number of display cells
;;   the character occupies (1, 2 or 4).  Not valid for UTF-8 above 0x80.
;; - CT_PRINT_CHAR bit is set when the character is printable (no need to translate before displaying it).
;; - CT_IDENT_CHAR bit is set when the character can be in an identifier.
;; - CT_FNAME_CHAR bit is set when the character can be in a file name.
;;
;; Return false if 'isident', 'isprint', 'isfname' or 'iskeyword' option has an error, true otherwise.

(defn- #_boolean init-chartab [#_boolean global] ;; global: false: only set @curbuf.b_chartab[]
    (let [wide (if (flag? @dy_flags DY_UHEX) (byte 4) (byte 2))]
        (when global
            (let [cls- #(condp > % (byte \space) wide DEL (inc CT_PRINT_CHAR) 0xa0 wide 256 (inc (+ CT_PRINT_CHAR CT_FNAME_CHAR)))]
                (swap! chartab #(into (empty %) (map cls- %)))
            ))
        (swap! curbuf update :b_chartab #(into (empty %) (map (constantly 0) %)))
        ;; Walk through the 'isident', 'isprint', 'isfname' and 'iskeyword' options:
        ;; characters, numbers or ranges separated by commas, e.g.: "48-57,x,#-37,-"
        (and
            (loop-when-recur [#_int round (if global 0 3)] (<= round 3) [(inc round)] => true
                (loop-when [#_Bytes p (condp == round 0 @p_isi 1 @p_isp 2 @p_isf 3 @(:b_p_isk @curbuf))] (non-eos? p) => true
                    (let-when [gec- #(let [__ (atom (#_Bytes object %))] (if (asc-isdigit (.at % 0)) [(getdigits __) @__] [(us-ptr2char-adv __, true) @__]))
                        [#_boolean ! p] (if (and (at? p (byte \^)) (non-eos? p 1)) [true (.plus p 1)] [false p])
                        [#_int c p] (gec- p)
                        [#_int e p] (if (and (at? p (byte \-)) (non-eos? p 1)) (gec- (.plus p 1)) [-1 p])
                    ] (and (< 0 c) (< c 256) (or (<= c e) (== e -1)) (< e 256) (or (eos? p) (at? p (byte \,)))) => false
                        ;; A single '@' (not "@-@") = any isalpha (islower|isupper).
                        (let [[#_boolean alpha c e] (cond (!= e -1) [false c e] (== c (byte \@)) [true 1 255] :else [false c c])
                            cel- #(-> % (& (bit-not CT_CELL_MASK)) (+ (if ! wide 1)))
                            bit- (fn [x y] (if ! (& x (bit-not y)) (| x y)))]
                            (loop-when-recur c (<= c e) (inc c)
                                (when (or (not alpha) (utf-islower c) (utf-isupper c))
                                    (condp == round
                                        0       (swap! chartab update c              bit- CT_IDENT_CHAR)
                                        1 (when (or (< c (byte \space)) (< (byte \~) c))
                                                (swap! chartab update c #(-> % cel- (bit- CT_PRINT_CHAR))))
                                        2       (swap! chartab update c              bit- CT_FNAME_CHAR)
                                        3 (if ! (reset-chartab c) (set-chartab c))
                                    )))
                            (let [#_int c (.at p 0) p (skip-to-option-part p)]
                                ;; Trailing comma is not allowed.
                                (if (and (== c (byte \,)) (eos? p)) false (recur p)))
                        ))
                ))
            (reset! chartab_initialized true))
    ))

;; Translate any special characters in buf[bufsize] in-place.
;; The result is a string with only printable characters, but if there is not
;; enough room, not all characters will be translated.

(defn- #_void trans-characters [#_Bytes buf, #_int bufsize]
    (loop-when [buf buf #_int len (STRLEN buf) #_int room (- bufsize len)] (non-eos? buf)
        (let-when [#_int n (us-ptr2len-cc buf)
            ;; Assume a multi-byte character doesn't need translation.
            [n len room :as _] (if (< 1 n)
                [n (- len n) room]
                (let-when [#_Bytes s (transchar-byte (.at buf 0)) n (STRLEN s)
                           room (if (< 1 n) (let-when [room (- room (dec n))] (< 0 room) (BCOPY buf, n, buf, 1, len) room) room)]
                (some? room)
                    (BCOPY buf, s, n)
                    [n (dec len) room]
                ))] (some? _)
            (recur (.plus buf n) len room)
        ))
    nil)

;; Catch 22: chartab[] can't be initialized before the options are initialized,
;; and initializing options may cause transchar() to be called!
;; When !chartab_initialized, don't use chartab[].
;; Does NOT work for multi-byte characters, c must be <= 255.
;; Also doesn't work for the first byte of a multi-byte, "c" must be a character!

(final Bytes transchar_buf (Bytes. 7))

(defn- #_Bytes transchar [#_int c]
    (let [buf transchar_buf
          [#_int i c] (if (is-special c) ;; special key code, display as ~@ char
                (do (-> buf (.be 0, (byte \~)) (.be 1, (byte \@))) [2 (char_u (KB-SECOND c))])
                [0 c]
            )]
        (if (or (and (not @chartab_initialized) (<= (byte \space) c (byte \~))) (and (< c 256) (vim-isprintc c)))
            (-> buf (.be i, c) (eos! (inc i))) ;; printable character
            (transchar-nonprint (.plus buf i), c))
        buf
    ))

;; Like transchar(), but called with a byte instead of a character.
;; Checks for an illegal UTF-8 byte.

(defn- #_Bytes transchar-byte [#_byte b]
    (let [c (char_u b)]
        (if (< c 0x80) (transchar c) (transchar-nonprint transchar_buf, c))
    ))

;; Convert non-printable character to two or more printable characters in "buf[]".
;; "buf" needs to be able to hold five bytes.
;; Does NOT work for multi-byte characters, c must be <= 255.

(defn- #_Bytes transchar-nonprint [#_Bytes buf, #_int c]
    (let [c (if (== c NL) NUL c)]                                                           ;; we use newline in place of a NUL
        (cond (flag? @dy_flags DY_UHEX)                                                     ;; 'display' has "uhex"
            (transchar-hex buf, c)
        (<= c 0x7f)                                                                         ;; 0x00 - 0x1f and 0x7f
            (-> buf (.be 0, (byte \^)) (.be 1, (byte (bit-xor c 0x40))) (eos! 2))           ;; DEL displayed as ^?
        (<= 0x80 c)
            (transchar-hex buf, c)
        (and (<= (+ (byte \space) 0x80) c) (<= c (+ (byte \~) 0x80)))                       ;; 0xa0 - 0xfe
            (-> buf (.be 0, (byte \|)) (.be 1, (byte (- c 0x80))) (eos! 2))
        :else                                                                               ;; 0x80 - 0x9f and 0xff
            (-> buf (.be 0, (byte \~)) (.be 1, (byte (bit-xor (- c 0x80) 0x40))) (eos! 2))  ;; 0xff displayed as ~?
        ))
    buf)

(defn- #_Bytes transchar-hex [#_Bytes buf, #_int c]
    (let [#_int' a'i (atom (int 0))]
        (.be buf @a'i, (byte \<))
        (when (< 0xff c)
            (.be buf (swap! a'i inc), (nr2hex (>>> c 12)))
            (.be buf (swap! a'i inc), (nr2hex (>>> c 8)))
        )
        (.be buf (swap! a'i inc), (nr2hex (>>> c 4)))
        (.be buf (swap! a'i inc), (nr2hex c))
        (.be buf (swap! a'i inc), (byte \>))
        (eos! buf (swap! a'i inc))
    )
    buf)

;; Convert the lower 4 bits of byte "c" to its hex character.
;; Lower case letters are used to avoid the confusion of <F1> being 0xf1 or function key 1.

(defn- #_int nr2hex [#_int c]
    (let [n (& c 0xf)]
        (if (< n 10) (+ (byte \0) n) (+ (byte \a) (- n 10)))
    ))

;; Return the number of screen cells occupied by byte "b".
;; For multi-byte mode "b" must be the first byte of a character.
;; A TAB is counted as two cells: "^I".
;; For UTF-8 mode this will return 0 for bytes >= 0x80, because the number of cells depends on further bytes.

(defn- #_int mb-byte2cells [#_byte b]
    (let [c (char_u b)]
        (if (< c 0x80) (& (... @chartab c) CT_CELL_MASK) 0)
    ))

;; Return the number of screen cells occupied by character "c".
;; "c" can be a special key (negative number) in which case 3 or 4 is returned.
;; A TAB is counted as two cells: "^I" or four: "<09>".

(defn- #_int mb-char2cells [#_int c]
    (cond
        (is-special c) (+ (mb-char2cells (char_u (KB-SECOND c))) 2)
        ;; UTF-8: above 0x80 need to check the value.
        (<= 0x80 c) (utf-char2cells c)
        :else (& (... @chartab (& c 0xff)) CT_CELL_MASK)
    ))

;; Return the number of screen cells for character at "*s".
;; TAB is counted as either two: "^I" or four: "<09>".

(defn- mb-ptr2cells
    ([s] (mb-ptr2cells s 0))
    ([s i]
        (let [c (char_u (.at s i))]
            ;; For UTF-8 we need to look at more bytes if the first byte is >= 0x80.
            (if (<= 0x80 c) (us-ptr2cells s, i) (& (... @chartab c) CT_CELL_MASK))
        )))

;; Return the number of screen cells for "*s" counting TABs as two characters: "^I".

(defn- mb-string2cells
    ([s] (mb-string2cells s -1))
    ([s n]
        (loop-when-recur [cells 0 i 0]
                         (and (or (< n 0) (< i n)) (non-eos? s i))
                         [(+ cells (mb-ptr2cells s, i)) (+ i (us-ptr2len-cc s, i))]
                      => cells)))

;; Return the number of screen cells for "*s" taking into account the size of TABs.
;; Also see getvcol() below.

(defn- chartabsize
    ([s col] (chartabsize s 0 col))
    ([s i col]
        (if (at? s i TAB)
            (let [ts @(:b_p_ts @curbuf)] (- ts (% col ts)))
            (mb-ptr2cells s, i)
        )))

;; Return the number of screen cells for "*s" taking into account the size of TABs.

(defn- #_int linetabsize [#_Bytes s]
    (linetabsize-col s, 0))

;; Like linetabsize(), but starting at column "startcol".

(defn- #_int linetabsize-col [#_Bytes _s, #_int startcol]
    (let [#_Bytes' a's (atom (#_Bytes object _s)) #_Bytes line @a's] ;; pointer to start of line, for breakindent
        (loop-when-recur [#_int col startcol] (non-eos? @a's) [(+ col (lbr-chartabsize-adv line, a's, col))] => col)
    ))

;; Like linetabsize(), but for a given window instead of the current one.

(defn- #_int win-linetabsize [#_window_C win, #_Bytes line, #_int len]
    (loop-when-recur [#_int col 0 #_Bytes s line]
                     (and (non-eos? s) (or (== len MAXCOL) (BLT s, (.plus line len))))
                     [(+ col (win-lbr-chartabsize win, line, s, col, nil)) (.plus s (us-ptr2len-cc s))]
                  => col))

;; Return true if 'c' is a normal identifier character:
;; Letters and characters from the 'isident' option.

(defn- #_boolean vim-isidentc [#_int c]
    (and (< 0 c 0x100) (flag? (... @chartab c) CT_IDENT_CHAR)))

;; Return true if 'c' is a keyword character:
;; Letters and characters from 'iskeyword' option for current buffer.
;; For multi-byte characters us-get-class() is used (builtin rules).

(defn- #_boolean vim-iswordc [#_int c]
    (if (<= 0x100 c) (<= 2 (utf-class c)) (and (< 0 c 0x100) (non-zero? (get-chartab c)))))

(defn- #_boolean us-iswordb [#_byte b]
    (and (non-zero? b) (non-zero? (get-chartab (char_u b)))))

(defn- #_boolean us-iswordp [#_Bytes p]
    (if (< 1 (us-byte2len (.at p 0), false)) (<= 2 (us-get-class p)) (us-iswordb (.at p 0))))

;; Return true if 'c' is a valid file-name character.
;; Assume characters above 0x100 are valid (multi-byte).

(defn- #_boolean vim-isfnamec [#_int c]
    (or (<= 0x100 c) (and (< 0 c) (flag? (... @chartab c) CT_FNAME_CHAR))))

;; Return true if 'c' is a printable character.
;; Assume characters above 0x100 are printable (multi-byte), except for Unicode.

(defn- #_boolean vim-isprintc [#_int c]
    (if (<= 0x100 c) (utf-printable c) (or (<= 0x100 c) (and (< 0 c) (flag? (... @chartab c) CT_PRINT_CHAR)))))

;; like chartabsize(), but also check for line breaks on the screen

(defn- #_int lbr-chartabsize [#_Bytes line, #_Bytes s, #_int col]
    ;; line: start of the line
    (let [wops (:w_options @curwin)] (cond
        (or @(:wo_lbr wops) (non-eos? @p_sbr) @(:wo_bri wops))
            (win-lbr-chartabsize @curwin, (if (nil? line) s line), s, col, nil)
        @(:wo_wrap wops)
            (win-nolbr-chartabsize @curwin, s, col, nil)
        :else
            (chartabsize s, col)
    )))

;; Call lbr-chartabsize() and advance the pointer.

(defn- #_int lbr-chartabsize-adv [#_Bytes line, #_Bytes' a's, #_int col]
    ;; line: start of the line
    (let [#_int size (lbr-chartabsize line, @a's, col)]
        (swap! a's #(.plus % (us-ptr2len-cc %)))
        size
    ))

;; This function is used very often, keep it fast!!!!
;;
;; If "head" not null, set "*head" to the size of what we for 'showbreak' string at start of line.
;; Warning: "*head" is only set if it's a non-zero value, init to 0 before calling.

(defn- #_int win-lbr-chartabsize [#_window_C win, #_Bytes line, #_Bytes s, #_int col, #_int' a'head]
    ;; line: start of the line
    (let [lbr @(:wo_lbr (:w_options win)) bri @(:wo_bri (:w_options win)) wrap @(:wo_wrap (:w_options win))]
        ;; No 'linebreak', 'showbreak' and 'breakindent': return quickly.
        (if (and (not lbr) (not bri) (eos? @p_sbr))
            (if wrap (win-nolbr-chartabsize win, s, col, a'head) (chartabsize s, col))
            ;; First get normal size, without 'linebreak'.
            (let [#_int size (chartabsize s, col)
                  #_int col_adj (if (at? s TAB) (dec size) 0) ;; col + screen size of tab
                  breakat? #(... @breakat_flags (char_u (.at %1 %2)))
                  ;; If 'linebreak' set check at a blank before a non-blank if the line needs a break here.
                  [size #_int mb_added]
                        (cond (and lbr (breakat? s 0) (not (breakat? s 1)) wrap (non-zero? (:w_width win)))
                            ;; Count all characters from first non-blank after a blank up to next non-blank after a blank.
                            (let [#_int colmax (let [x (- (:w_width win) (win-col-off win) col_adj)] (if (<= x col)
                                               (let [m (+ x col_adj) n (+ m (win-col-off2 win))]     (if (< 0 n) (+ m (- (* (inc (/ (- col m) n)) n) col_adj)) m)) x))
                                size (loop [s s #_int col2 col]
                                        (let-when [#_Bytes ps s s (.plus s (us-ptr2len-cc s))]
                                                  (and (non-eos? s) (or (breakat? s 0) (and (not (breakat? s 0)) (or (== col2 col) (not (breakat? ps 0)))))) => size
                                            (let-when [col2 (+ col2 (chartabsize s, col2))] (< col2 colmax) => (+ (- colmax col) col_adj) ;; doesn't fit
                                                (recur s col2)
                                            )))]
                                [size 0])
                        (and (== size 2) (< 1 (us-byte2len (.at s 0), false)) wrap (in-win-border win, col))
                            [(inc size) 1] ;; count the ">" in the last column
                        :else
                            [size 0])
                  ;; May have to add something for 'breakindent' and/or 'showbreak' string at start of line.
                  [size #_int added]
                        (if (and (or (non-eos? @p_sbr) bri) (and wrap (non-zero? col)))
                            (let [#_int z (if (non-eos? @p_sbr) (us-charlen @p_sbr) 0)
                                  #_int n (win-col-off win)
                                  col (+ col n mb_added)
                                  [n col] (if (<= (:w_width win) col)
                                            (let [n (- n (win-col-off2 win))
                                                  #_int e (- (:w_width win) n)
                                                  col (- col (:w_width win))
                                                  col (if (and (<= e col) (< 0 e)) (% col e) col)
                                                  col (if (and (non-eos? @p_sbr) (<= z col)) (- col z) col)
                                                  col (cond (and (<= e col) (< 0 e)) (% col e) (and (< 0 col) (< 0 e)) (+ col n) :else col)]
                                                [n col])
                                            [n col])]
                                (if (or (zero? col) (< (:w_width win) (+ col size z)))
                                    (let [#_int m (if (non-eos? @p_sbr)
                                                    (if (< (:w_width win) (+ size z n))
                                                        (let [#_int w (- (:w_width win) z n) w (if (zero? w) (:w_width win) w)
                                                              #_int x (- size (if (non-zero? col) (- (:w_width win) z col) 0))]
                                                            (+ (/ x w) (if (non-zero? (% x w)) 1 0))) ;; if wrapped, add another length of 'sbr'
                                                        1)
                                                    0)
                                          added (* m (mb-string2cells @p_sbr))
                                          added (if bri (+ added (get-breakindent win, line)) added)]
                                        [(+ size added) (if (zero? col) added 0)])
                                    [size 0]
                                ))
                            [size 0]
                        )]
                ;; Set "*head" to the size of what we add.
                (when (some? a'head) (reset! a'head (+ added mb_added)))
                size
            ))
    ))

;; Like win-lbr-chartabsize(), except that we know 'linebreak' is off and 'wrap' is on.
;; This means we need to check for a double-byte character that doesn't fit at the end
;; of the screen line.

(defn- #_int win-nolbr-chartabsize [#_window_C win, #_Bytes s, #_int col, #_int' a'head]
    (if (at? s TAB)
        (let [#_int ts (int @(:b_p_ts @curbuf))] (- ts (% col ts)))
        ;; Add one cell for a double-width character in the last column of the window, displayed with a ">".
        (let-when [#_int n (mb-ptr2cells s)] (and (== n 2) (< 1 (us-byte2len (.at s 0), false)) (in-win-border win, col)) => n
            (when (some? a'head) (reset! a'head 1))
            3)
    ))

;; Return true if virtual column "vcol" is in the rightmost column of window "win".

(defn- #_boolean in-win-border [#_window_C win, #_int vcol]
    (if (zero? (:w_width win))                                          ;; there is no border
        false
        (let [#_int width1 (- (:w_width win) (win-col-off win))]        ;; width of first line (after line number)
            (cond (< vcol (dec width1))
                false
            (== vcol (dec width1))
                true
            :else
                (let [#_int width2 (+ width1 (win-col-off2 win))]       ;; width of further lines
                    (if (<= width2 0)
                        false
                        (== (% (- vcol width1) width2) (dec width2))
                    ))
            ))
    ))

;; Get virtual column number of pos.
;;  start: on the first position of this character (TAB, ctrl)
;; cursor: where the cursor is on this character (first char, except for TAB)
;;    end: on the last position of this character (TAB, ctrl)
;;
;; This is used very often, keep it fast!

(defn- #_void getvcol [#_window_C win, #_pos_C pos, #_int' a'start, #_int' a'cursor, #_int' a'end]
    (let [lbr @(:wo_lbr (:w_options win)) bri @(:wo_bri (:w_options win)) wrap @(:wo_wrap (:w_options win))
          #_Bytes line (ml-get (:lnum pos))
          #_Bytes posp (if (== (:col pos) MAXCOL) nil (.plus line (:col pos)))
          a'head (atom (int))
          tabs- (fn [#_Bytes s, #_int col]
                    (if (at? s TAB)
                        (let [#_int ts (int @(:b_p_ts @curbuf))] (- ts (% col ts)))
                        (let-when [#_int n (mb-ptr2cells s)] (and (== n 2) wrap (< 1 (us-byte2len (.at s 0), false)) (in-win-border win, col)) => n
                            ;; If a double-cell char doesn't fit at eol, it wraps to the next line, like this char is three cells wide.
                            (reset! a'head 1)
                            (inc n))
                    ))
          ;; This function is used very often, do some speed optimizations.
          ;; When 'list', 'linebreak', 'showbreak' and 'breakindent' are not set use a simple loop.
          ;; Also use this when 'list' is set but tabs take their normal size.
          [#_int vcol #_int i #_Bytes p]
            (cond (and (not lbr) (eos? @p_sbr) (not bri))
                (loop [vcol 0 p line] (reset! a'head 0)
                    ;; make sure we don't go past the end of the line
                    (if (eos? p)
                        [vcol 1 p]          ;; NUL at end of line only takes one column
                        ;; A tab gets expanded, depending on the current column.
                        (let [i (tabs- p, vcol)]
                            (if (and (some? posp) (BLE posp, p))
                                [vcol i p]
                                (recur (+ vcol i) (.plus p (us-ptr2len-cc p)))))
                    ))
            :else
                (loop [vcol 0 p line] (reset! a'head 0)
                    ;; A tab gets expanded, depending on the current column.
                    (let [i (win-lbr-chartabsize win, line, p, vcol, a'head)]
                        ;; make sure we don't go past the end of the line
                        (cond (eos? p)
                            [vcol 1 p]       ;; NUL at end of line only takes one column
                        (and (some? posp) (BLE posp, p))
                            [vcol i p]
                        :else
                            (recur (+ vcol i) (.plus p (us-ptr2len-cc p))))
                    ))
            )]
        (when (some? a'start)  (reset! a'start (+ vcol @a'head)))
        (when (some? a'end)    (reset! a'end (dec (+ vcol i))))
        (when (some? a'cursor) (reset! a'cursor
            (if (and (at? p TAB) (flag? @State NORMAL) (not (virtual-active)) (not (and @VIsual_active (or (at? @p_sel (byte \e)) (ltoreq pos, @VIsual_cursor)))))
                (dec (+ vcol i))    ;; cursor at end
                (+ vcol @a'head)    ;; cursor at start
            )))
    )
    nil)

;; Get virtual cursor column in the current window, pretending 'list' is off.

(defn- #_int getvcol-nolist [#_pos_C posp]
    (let [#_int' a'vcol (atom (int))]
        (getvcol @curwin, posp, nil, a'vcol, nil)
        @a'vcol
    ))

;; Get virtual column in virtual mode.

(defn- #_void getvvcol [#_window_C win, #_pos_C pos, #_int' a'start, #_int' a'cursor, #_int' a'end]
    (if (virtual-active)
        (let [#_int' a'col (atom (int))]
            ;; For virtual mode, only want one value.
            (getvcol win, pos, a'col, nil, nil)
            (let [coladd (:coladd pos) [coladd endadd]
                ;; Cannot put the cursor on part of a wide character.
                    (let-when [#_Bytes s (ml-get (:lnum pos))] (< (:col pos) (STRLEN s)) => [coladd 0]
                        (let-when [#_int c (us-ptr2char s, (:col pos))] (and (!= c TAB) (vim-isprintc c)) => [coladd 0]
                            (let-when [endadd (dec (mb-char2cells c))] (< endadd coladd) => [0 endadd]
                                [coladd 0] ;; past end of line
                            )
                        )
                    )]
                (swap! a'col + coladd)
                (when (some? a'start) (reset! a'start @a'col))
                (when (some? a'cursor) (reset! a'cursor @a'col))
                (when (some? a'end) (reset! a'end (+ @a'col endadd)))
            ))
        (getvcol win, pos, a'start, a'cursor, a'end))
    nil)

;; Get the leftmost and rightmost virtual column of pos1 and pos2.
;; Used for Visual block mode.

(defn- #_void getvcols [#_window_C win, #_pos_C pos1, #_pos_C pos2, #_int' a'left, #_int' a'right]
    (let [a'from1 (atom (int)) a'from2 (atom (int)) a'to1 (atom (int)) a'to2 (atom (int))]
        (if (ltpos pos1, pos2)
            (do (getvvcol win, pos1, a'from1, nil, a'to1) (getvvcol win, pos2, a'from2, nil, a'to2))
            (do (getvvcol win, pos2, a'from1, nil, a'to1) (getvvcol win, pos1, a'from2, nil, a'to2))
        )
        (reset! a'left (min @a'from1 @a'from2))
        (reset! a'right (if (< @a'to1 @a'to2) (if (and (at? @p_sel (byte \e)) (<= @a'to1 (dec @a'from2))) (dec @a'from2) @a'to2) @a'to1)))
    nil)

(defn- #_Bytes skipwhite  [#_Bytes s] (loop-when-recur s (vim-iswhite (.at s 0)) (.plus s 1) => s)) ;; skip to next non-white
(defn- #_Bytes skipdigits [#_Bytes s] (loop-when-recur s (asc-isdigit (.at s 0)) (.plus s 1) => s)) ;; skip to next non-digit

(defn- #_boolean asc-isdigit  [#_int c] (<= (byte \0) c (byte \9)))
(defn- #_boolean asc-isodigit [#_int c] (<= (byte \0) c (byte \7)))
(defn- #_boolean asc-isxdigit [#_int c] (or (<= (byte \0) c (byte \9)) (<= (byte \a) c (byte \f)) (<= (byte \A) c (byte \F))))

;; getdigits: Get a number from a string and skip over it.

(defn- #_long getdigits [#_Bytes' a's]
    (ยง let [n (.atol libC @a's)]
        (when (at? @a's (byte \-))                  ;; skip negative sign
            (swap! a's plus 1))
        (swap! a's skipdigits)              ;; skip to next non-digit
        n
    ))

;; Convert a string into a long and/or unsigned long, taking care of
;; hexadecimal and octal numbers.  Accepts a '-' sign.
;; If "t" is not null, returns a flag to indicate the type of the number:
;;  0           decimal
;;  '0'         octal
;;  'x' or 'X'  hexadecimal
;; If "l" is not null, the length of the number in characters is returned.
;; If "dooct" is true, recognize octal numbers.
;; If "dohex" is true, recognize hex numbers.
;; If "n" is not null, the signed result is returned in it.

(defn- #_void vim-str2nr [#_Bytes start, #_int' a't, #_int' a'l, #_boolean dooct, #_boolean dohex, #_long' a'n]
    (let [#_boolean negative (at? start (byte \-))
          #_Bytes s (if negative (.plus start 1) start)
          ;; Recognize hex and octal.
          [#_int x s]
            (if (and (at? s (byte \0)) (not-at? s 1 (byte \8)) (not-at? s 1 (byte \9)))
                (let [x (.at s 1)]
                    (if (and dohex (any == x (byte \X) (byte \x)) (asc-isxdigit (.at s 2)))
                        [x (.plus s 2)]                                                         ;; hexadecimal
                        (if dooct
                            ;; Don't interpret "0", "08" or "0129" as octal.
                            (loop-when [x 0 #_int i 1] (asc-isdigit (.at s i)) => [x s]
                                (if (< (byte \7) (.at s i))
                                    [0 s]                                                       ;; can't be octal
                                    (recur (if (<= (byte \0) (.at s i)) (byte \0) x) (inc i))   ;; assume octal
                                ))
                            [0 s])
                    ))
                [0 s]
            )]
        (let [[#_long nr s] ;; do the conversion "manually" to avoid sscanf quirks
                (cond (== x (byte \0))                                              ;; octal
                    (loop-when [nr 0 #_int i 0] (asc-isodigit (.at s i))
                        (let [#_long a (+ (* 8 nr) (long (- (.at s i) (byte \0))))]
                            (recur-if (<= nr a) [a (inc i)] => [nr (.plus s i)])
                        ))
                (non-zero? x)                                                       ;; hex
                    (loop-when [nr 0 #_int i 0] (asc-isxdigit (.at s i))
                        (let [#_long a (+ (* 16 nr) (long (hex2nr (.at s i))))]
                            (recur-if (<= nr a) [a (inc i)] => [nr (.plus s i)])
                        ))
                :else                                                               ;; decimal
                    (loop-when [nr 0 #_int i 0] (asc-isdigit (.at s i))
                        (let [#_long a (+ (* 10 nr) (long (- (.at s i) (byte \0))))]
                            (recur-if (<= nr a) [a (inc i)] => [nr (.plus s i)])
                        ))
                )]
            (when (some? a't) (reset! a't x))
            (when (some? a'l) (reset! a'l (BDIFF s, start)))
            (when (some? a'n) (reset! a'n (if negative (- nr) nr))) ;; account for leading '-' for decimal numbers
        ))
    nil)

;; Return the value of a single hex character.
;; Only valid when the argument is '0' - '9', 'A' - 'F' or 'a' - 'f'.

(defn- #_int hex2nr [#_int c]
    (cond
        (<= (byte \a) c (byte \f)) (+ (- c (byte \a)) 10)
        (<= (byte \A) c (byte \F)) (+ (- c (byte \A)) 10)
        :else (- c (byte \0))
    ))

;;; ============================================================================================== VimR

;; digraph.c: code for digraphs -------------------------------------------------------------------

(class! #_final digr_C
    [
        (field byte     char1)
        (field byte     char2)
        (field int      result)
    ])

(defn- #_final #_digr_C digr [#_"/*byte*/char" char1, #_"/*byte*/char" char2, #_int result]
    (new digr_C (byte char1), (byte char2), result))

;; digraphs for Unicode from RFC1345 (also work for ISO-8859-1 aka latin1)
(final digr_C* digraphdefault
    [
        (digr \N, \U, 0x0a),       ;; LF for NUL
        (digr \S, \H, 0x01),
        (digr \S, \X, 0x02),
        (digr \E, \X, 0x03),
        (digr \E, \T, 0x04),
        (digr \E, \Q, 0x05),
        (digr \A, \K, 0x06),
        (digr \B, \L, 0x07),
        (digr \B, \S, 0x08),
        (digr \H, \T, 0x09),
        (digr \L, \F, 0x0a),
        (digr \V, \T, 0x0b),
        (digr \F, \F, 0x0c),
        (digr \C, \R, 0x0d),
        (digr \S, \O, 0x0e),
        (digr \S, \I, 0x0f),
        (digr \D, \L, 0x10),
        (digr \D, \1, 0x11),
        (digr \D, \2, 0x12),
        (digr \D, \3, 0x13),
        (digr \D, \4, 0x14),
        (digr \N, \K, 0x15),
        (digr \S, \Y, 0x16),
        (digr \E, \B, 0x17),
        (digr \C, \N, 0x18),
        (digr \E, \M, 0x19),
        (digr \S, \B, 0x1a),
        (digr \E, \C, 0x1b),
        (digr \F, \S, 0x1c),
        (digr \G, \S, 0x1d),
        (digr \R, \S, 0x1e),
        (digr \U, \S, 0x1f),
        (digr \S, \P, 0x20),
        (digr \N, \b, 0x23),
        (digr \D, \O, 0x24),
        (digr \A, \t, 0x40),
        (digr \<, \(, 0x5b),
        (digr \/, \/, 0x5c),
        (digr \), \>, 0x5d),
        (digr \', \>, 0x5e),
        (digr \', \!, 0x60),
        (digr \(, \!, 0x7b),
        (digr \!, \!, 0x7c),
        (digr \!, \), 0x7d),
        (digr \', \?, 0x7e),
        (digr \D, \T, 0x7f),
        (digr \P, \A, 0x80),
        (digr \H, \O, 0x81),
        (digr \B, \H, 0x82),
        (digr \N, \H, 0x83),
        (digr \I, \N, 0x84),
        (digr \N, \L, 0x85),
        (digr \S, \A, 0x86),
        (digr \E, \S, 0x87),
        (digr \H, \S, 0x88),
        (digr \H, \J, 0x89),
        (digr \V, \S, 0x8a),
        (digr \P, \D, 0x8b),
        (digr \P, \U, 0x8c),
        (digr \R, \I, 0x8d),
        (digr \S, \2, 0x8e),
        (digr \S, \3, 0x8f),
        (digr \D, \C, 0x90),
        (digr \P, \1, 0x91),
        (digr \P, \2, 0x92),
        (digr \T, \S, 0x93),
        (digr \C, \C, 0x94),
        (digr \M, \W, 0x95),
        (digr \S, \G, 0x96),
        (digr \E, \G, 0x97),
        (digr \S, \S, 0x98),
        (digr \G, \C, 0x99),
        (digr \S, \C, 0x9a),
        (digr \C, \I, 0x9b),
        (digr \S, \T, 0x9c),
        (digr \O, \C, 0x9d),
        (digr \P, \M, 0x9e),
        (digr \A, \C, 0x9f),
        (digr \N, \S, 0xa0),
        (digr \!, \I, 0xa1),
        (digr \C, \t, 0xa2),
        (digr \P, \d, 0xa3),
        (digr \C, \u, 0xa4),
        (digr \Y, \e, 0xa5),
        (digr \B, \B, 0xa6),
        (digr \S, \E, 0xa7),
        (digr \', \:, 0xa8),
        (digr \C, \o, 0xa9),
        (digr \-, \a, 0xaa),
        (digr \<, \<, 0xab),
        (digr \N, \O, 0xac),
        (digr \-, \-, 0xad),
        (digr \R, \g, 0xae),
        (digr \', \m, 0xaf),
        (digr \D, \G, 0xb0),
        (digr \+, \-, 0xb1),
        (digr \2, \S, 0xb2),
        (digr \3, \S, 0xb3),
        (digr \', \', 0xb4),
        (digr \M, \y, 0xb5),
        (digr \P, \I, 0xb6),
        (digr \., \M, 0xb7),
        (digr \', \,, 0xb8),
        (digr \1, \S, 0xb9),
        (digr \-, \o, 0xba),
        (digr \>, \>, 0xbb),
        (digr \1, \4, 0xbc),
        (digr \1, \2, 0xbd),
        (digr \3, \4, 0xbe),
        (digr \?, \I, 0xbf),
        (digr \A, \!, 0xc0),
        (digr \A, \', 0xc1),
        (digr \A, \>, 0xc2),
        (digr \A, \?, 0xc3),
        (digr \A, \:, 0xc4),
        (digr \A, \A, 0xc5),
        (digr \A, \E, 0xc6),
        (digr \C, \,, 0xc7),
        (digr \E, \!, 0xc8),
        (digr \E, \', 0xc9),
        (digr \E, \>, 0xca),
        (digr \E, \:, 0xcb),
        (digr \I, \!, 0xcc),
        (digr \I, \', 0xcd),
        (digr \I, \>, 0xce),
        (digr \I, \:, 0xcf),
        (digr \D, \-, 0xd0),
        (digr \N, \?, 0xd1),
        (digr \O, \!, 0xd2),
        (digr \O, \', 0xd3),
        (digr \O, \>, 0xd4),
        (digr \O, \?, 0xd5),
        (digr \O, \:, 0xd6),
        (digr \*, \X, 0xd7),
        (digr \O, \/, 0xd8),
        (digr \U, \!, 0xd9),
        (digr \U, \', 0xda),
        (digr \U, \>, 0xdb),
        (digr \U, \:, 0xdc),
        (digr \Y, \', 0xdd),
        (digr \T, \H, 0xde),
        (digr \s, \s, 0xdf),
        (digr \a, \!, 0xe0),
        (digr \a, \', 0xe1),
        (digr \a, \>, 0xe2),
        (digr \a, \?, 0xe3),
        (digr \a, \:, 0xe4),
        (digr \a, \a, 0xe5),
        (digr \a, \e, 0xe6),
        (digr \c, \,, 0xe7),
        (digr \e, \!, 0xe8),
        (digr \e, \', 0xe9),
        (digr \e, \>, 0xea),
        (digr \e, \:, 0xeb),
        (digr \i, \!, 0xec),
        (digr \i, \', 0xed),
        (digr \i, \>, 0xee),
        (digr \i, \:, 0xef),
        (digr \d, \-, 0xf0),
        (digr \n, \?, 0xf1),
        (digr \o, \!, 0xf2),
        (digr \o, \', 0xf3),
        (digr \o, \>, 0xf4),
        (digr \o, \?, 0xf5),
        (digr \o, \:, 0xf6),
        (digr \-, \:, 0xf7),
        (digr \o, \/, 0xf8),
        (digr \u, \!, 0xf9),
        (digr \u, \', 0xfa),
        (digr \u, \>, 0xfb),
        (digr \u, \:, 0xfc),
        (digr \y, \', 0xfd),
        (digr \t, \h, 0xfe),
        (digr \y, \:, 0xff),

        (digr \A, \-, 0x0100),
        (digr \a, \-, 0x0101),
        (digr \A, \(, 0x0102),
        (digr \a, \(, 0x0103),
        (digr \A, \;, 0x0104),
        (digr \a, \;, 0x0105),
        (digr \C, \', 0x0106),
        (digr \c, \', 0x0107),
        (digr \C, \>, 0x0108),
        (digr \c, \>, 0x0109),
        (digr \C, \., 0x010a),
        (digr \c, \., 0x010b),
        (digr \C, \<, 0x010c),
        (digr \c, \<, 0x010d),
        (digr \D, \<, 0x010e),
        (digr \d, \<, 0x010f),
        (digr \D, \/, 0x0110),
        (digr \d, \/, 0x0111),
        (digr \E, \-, 0x0112),
        (digr \e, \-, 0x0113),
        (digr \E, \(, 0x0114),
        (digr \e, \(, 0x0115),
        (digr \E, \., 0x0116),
        (digr \e, \., 0x0117),
        (digr \E, \;, 0x0118),
        (digr \e, \;, 0x0119),
        (digr \E, \<, 0x011a),
        (digr \e, \<, 0x011b),
        (digr \G, \>, 0x011c),
        (digr \g, \>, 0x011d),
        (digr \G, \(, 0x011e),
        (digr \g, \(, 0x011f),
        (digr \G, \., 0x0120),
        (digr \g, \., 0x0121),
        (digr \G, \,, 0x0122),
        (digr \g, \,, 0x0123),
        (digr \H, \>, 0x0124),
        (digr \h, \>, 0x0125),
        (digr \H, \/, 0x0126),
        (digr \h, \/, 0x0127),
        (digr \I, \?, 0x0128),
        (digr \i, \?, 0x0129),
        (digr \I, \-, 0x012a),
        (digr \i, \-, 0x012b),
        (digr \I, \(, 0x012c),
        (digr \i, \(, 0x012d),
        (digr \I, \;, 0x012e),
        (digr \i, \;, 0x012f),
        (digr \I, \., 0x0130),
        (digr \i, \., 0x0131),
        (digr \I, \J, 0x0132),
        (digr \i, \j, 0x0133),
        (digr \J, \>, 0x0134),
        (digr \j, \>, 0x0135),
        (digr \K, \,, 0x0136),
        (digr \k, \,, 0x0137),
        (digr \k, \k, 0x0138),
        (digr \L, \', 0x0139),
        (digr \l, \', 0x013a),
        (digr \L, \,, 0x013b),
        (digr \l, \,, 0x013c),
        (digr \L, \<, 0x013d),
        (digr \l, \<, 0x013e),
        (digr \L, \., 0x013f),
        (digr \l, \., 0x0140),
        (digr \L, \/, 0x0141),
        (digr \l, \/, 0x0142),
        (digr \N, \', 0x0143),
        (digr \n, \', 0x0144),
        (digr \N, \,, 0x0145),
        (digr \n, \,, 0x0146),
        (digr \N, \<, 0x0147),
        (digr \n, \<, 0x0148),
        (digr \', \n, 0x0149),
        (digr \N, \G, 0x014a),
        (digr \n, \g, 0x014b),
        (digr \O, \-, 0x014c),
        (digr \o, \-, 0x014d),
        (digr \O, \(, 0x014e),
        (digr \o, \(, 0x014f),
        (digr \O, \", 0x0150),  ;; """
        (digr \o, \", 0x0151),  ;; """
        (digr \O, \E, 0x0152),
        (digr \o, \e, 0x0153),
        (digr \R, \', 0x0154),
        (digr \r, \', 0x0155),
        (digr \R, \,, 0x0156),
        (digr \r, \,, 0x0157),
        (digr \R, \<, 0x0158),
        (digr \r, \<, 0x0159),
        (digr \S, \', 0x015a),
        (digr \s, \', 0x015b),
        (digr \S, \>, 0x015c),
        (digr \s, \>, 0x015d),
        (digr \S, \,, 0x015e),
        (digr \s, \,, 0x015f),
        (digr \S, \<, 0x0160),
        (digr \s, \<, 0x0161),
        (digr \T, \,, 0x0162),
        (digr \t, \,, 0x0163),
        (digr \T, \<, 0x0164),
        (digr \t, \<, 0x0165),
        (digr \T, \/, 0x0166),
        (digr \t, \/, 0x0167),
        (digr \U, \?, 0x0168),
        (digr \u, \?, 0x0169),
        (digr \U, \-, 0x016a),
        (digr \u, \-, 0x016b),
        (digr \U, \(, 0x016c),
        (digr \u, \(, 0x016d),
        (digr \U, \0, 0x016e),
        (digr \u, \0, 0x016f),
        (digr \U, \", 0x0170),  ;; """
        (digr \u, \", 0x0171),  ;; """
        (digr \U, \;, 0x0172),
        (digr \u, \;, 0x0173),
        (digr \W, \>, 0x0174),
        (digr \w, \>, 0x0175),
        (digr \Y, \>, 0x0176),
        (digr \y, \>, 0x0177),
        (digr \Y, \:, 0x0178),
        (digr \Z, \', 0x0179),
        (digr \z, \', 0x017a),
        (digr \Z, \., 0x017b),
        (digr \z, \., 0x017c),
        (digr \Z, \<, 0x017d),
        (digr \z, \<, 0x017e),
        (digr \O, \9, 0x01a0),
        (digr \o, \9, 0x01a1),
        (digr \O, \I, 0x01a2),
        (digr \o, \i, 0x01a3),
        (digr \y, \r, 0x01a6),
        (digr \U, \9, 0x01af),
        (digr \u, \9, 0x01b0),
        (digr \Z, \/, 0x01b5),
        (digr \z, \/, 0x01b6),
        (digr \E, \D, 0x01b7),
        (digr \A, \<, 0x01cd),
        (digr \a, \<, 0x01ce),
        (digr \I, \<, 0x01cf),
        (digr \i, \<, 0x01d0),
        (digr \O, \<, 0x01d1),
        (digr \o, \<, 0x01d2),
        (digr \U, \<, 0x01d3),
        (digr \u, \<, 0x01d4),
        (digr \A, \1, 0x01de),
        (digr \a, \1, 0x01df),
        (digr \A, \7, 0x01e0),
        (digr \a, \7, 0x01e1),
        (digr \A, \3, 0x01e2),
        (digr \a, \3, 0x01e3),
        (digr \G, \/, 0x01e4),
        (digr \g, \/, 0x01e5),
        (digr \G, \<, 0x01e6),
        (digr \g, \<, 0x01e7),
        (digr \K, \<, 0x01e8),
        (digr \k, \<, 0x01e9),
        (digr \O, \;, 0x01ea),
        (digr \o, \;, 0x01eb),
        (digr \O, \1, 0x01ec),
        (digr \o, \1, 0x01ed),
        (digr \E, \Z, 0x01ee),
        (digr \e, \z, 0x01ef),
        (digr \j, \<, 0x01f0),
        (digr \G, \', 0x01f4),
        (digr \g, \', 0x01f5),
        (digr \;, \S, 0x02bf),
        (digr \', \<, 0x02c7),
        (digr \', \(, 0x02d8),
        (digr \', \., 0x02d9),
        (digr \', \0, 0x02da),
        (digr \', \;, 0x02db),
        (digr \', \", 0x02dd),  ;; """
        (digr \A, \%, 0x0386),
        (digr \E, \%, 0x0388),
        (digr \Y, \%, 0x0389),
        (digr \I, \%, 0x038a),
        (digr \O, \%, 0x038c),
        (digr \U, \%, 0x038e),
        (digr \W, \%, 0x038f),
        (digr \i, \3, 0x0390),
        (digr \A, \*, 0x0391),
        (digr \B, \*, 0x0392),
        (digr \G, \*, 0x0393),
        (digr \D, \*, 0x0394),
        (digr \E, \*, 0x0395),
        (digr \Z, \*, 0x0396),
        (digr \Y, \*, 0x0397),
        (digr \H, \*, 0x0398),
        (digr \I, \*, 0x0399),
        (digr \K, \*, 0x039a),
        (digr \L, \*, 0x039b),
        (digr \M, \*, 0x039c),
        (digr \N, \*, 0x039d),
        (digr \C, \*, 0x039e),
        (digr \O, \*, 0x039f),
        (digr \P, \*, 0x03a0),
        (digr \R, \*, 0x03a1),
        (digr \S, \*, 0x03a3),
        (digr \T, \*, 0x03a4),
        (digr \U, \*, 0x03a5),
        (digr \F, \*, 0x03a6),
        (digr \X, \*, 0x03a7),
        (digr \Q, \*, 0x03a8),
        (digr \W, \*, 0x03a9),
        (digr \J, \*, 0x03aa),
        (digr \V, \*, 0x03ab),
        (digr \a, \%, 0x03ac),
        (digr \e, \%, 0x03ad),
        (digr \y, \%, 0x03ae),
        (digr \i, \%, 0x03af),
        (digr \u, \3, 0x03b0),
        (digr \a, \*, 0x03b1),
        (digr \b, \*, 0x03b2),
        (digr \g, \*, 0x03b3),
        (digr \d, \*, 0x03b4),
        (digr \e, \*, 0x03b5),
        (digr \z, \*, 0x03b6),
        (digr \y, \*, 0x03b7),
        (digr \h, \*, 0x03b8),
        (digr \i, \*, 0x03b9),
        (digr \k, \*, 0x03ba),
        (digr \l, \*, 0x03bb),
        (digr \m, \*, 0x03bc),
        (digr \n, \*, 0x03bd),
        (digr \c, \*, 0x03be),
        (digr \o, \*, 0x03bf),
        (digr \p, \*, 0x03c0),
        (digr \r, \*, 0x03c1),
        (digr \*, \s, 0x03c2),
        (digr \s, \*, 0x03c3),
        (digr \t, \*, 0x03c4),
        (digr \u, \*, 0x03c5),
        (digr \f, \*, 0x03c6),
        (digr \x, \*, 0x03c7),
        (digr \q, \*, 0x03c8),
        (digr \w, \*, 0x03c9),
        (digr \j, \*, 0x03ca),
        (digr \v, \*, 0x03cb),
        (digr \o, \%, 0x03cc),
        (digr \u, \%, 0x03cd),
        (digr \w, \%, 0x03ce),
        (digr \', \G, 0x03d8),
        (digr \,, \G, 0x03d9),
        (digr \T, \3, 0x03da),
        (digr \t, \3, 0x03db),
        (digr \M, \3, 0x03dc),
        (digr \m, \3, 0x03dd),
        (digr \K, \3, 0x03de),
        (digr \k, \3, 0x03df),
        (digr \P, \3, 0x03e0),
        (digr \p, \3, 0x03e1),
        (digr \', \%, 0x03f4),
        (digr \j, \3, 0x03f5),
        (digr \I, \O, 0x0401),
        (digr \D, \%, 0x0402),
        (digr \G, \%, 0x0403),
        (digr \I, \E, 0x0404),
        (digr \D, \S, 0x0405),
        (digr \I, \I, 0x0406),
        (digr \Y, \I, 0x0407),
        (digr \J, \%, 0x0408),
        (digr \L, \J, 0x0409),
        (digr \N, \J, 0x040a),
        (digr \T, \s, 0x040b),
        (digr \K, \J, 0x040c),
        (digr \V, \%, 0x040e),
        (digr \D, \Z, 0x040f),
        (digr \A, \=, 0x0410),
        (digr \B, \=, 0x0411),
        (digr \V, \=, 0x0412),
        (digr \G, \=, 0x0413),
        (digr \D, \=, 0x0414),
        (digr \E, \=, 0x0415),
        (digr \Z, \%, 0x0416),
        (digr \Z, \=, 0x0417),
        (digr \I, \=, 0x0418),
        (digr \J, \=, 0x0419),
        (digr \K, \=, 0x041a),
        (digr \L, \=, 0x041b),
        (digr \M, \=, 0x041c),
        (digr \N, \=, 0x041d),
        (digr \O, \=, 0x041e),
        (digr \P, \=, 0x041f),
        (digr \R, \=, 0x0420),
        (digr \S, \=, 0x0421),
        (digr \T, \=, 0x0422),
        (digr \U, \=, 0x0423),
        (digr \F, \=, 0x0424),
        (digr \H, \=, 0x0425),
        (digr \C, \=, 0x0426),
        (digr \C, \%, 0x0427),
        (digr \S, \%, 0x0428),
        (digr \S, \c, 0x0429),
        (digr \=, \", 0x042a),  ;; """
        (digr \Y, \=, 0x042b),
        (digr \%, \", 0x042c),  ;; """
        (digr \J, \E, 0x042d),
        (digr \J, \U, 0x042e),
        (digr \J, \A, 0x042f),
        (digr \a, \=, 0x0430),
        (digr \b, \=, 0x0431),
        (digr \v, \=, 0x0432),
        (digr \g, \=, 0x0433),
        (digr \d, \=, 0x0434),
        (digr \e, \=, 0x0435),
        (digr \z, \%, 0x0436),
        (digr \z, \=, 0x0437),
        (digr \i, \=, 0x0438),
        (digr \j, \=, 0x0439),
        (digr \k, \=, 0x043a),
        (digr \l, \=, 0x043b),
        (digr \m, \=, 0x043c),
        (digr \n, \=, 0x043d),
        (digr \o, \=, 0x043e),
        (digr \p, \=, 0x043f),
        (digr \r, \=, 0x0440),
        (digr \s, \=, 0x0441),
        (digr \t, \=, 0x0442),
        (digr \u, \=, 0x0443),
        (digr \f, \=, 0x0444),
        (digr \h, \=, 0x0445),
        (digr \c, \=, 0x0446),
        (digr \c, \%, 0x0447),
        (digr \s, \%, 0x0448),
        (digr \s, \c, 0x0449),
        (digr \=, \', 0x044a),
        (digr \y, \=, 0x044b),
        (digr \%, \', 0x044c),
        (digr \j, \e, 0x044d),
        (digr \j, \u, 0x044e),
        (digr \j, \a, 0x044f),
        (digr \i, \o, 0x0451),
        (digr \d, \%, 0x0452),
        (digr \g, \%, 0x0453),
        (digr \i, \e, 0x0454),
        (digr \d, \s, 0x0455),
        (digr \i, \i, 0x0456),
        (digr \y, \i, 0x0457),
        (digr \j, \%, 0x0458),
        (digr \l, \j, 0x0459),
        (digr \n, \j, 0x045a),
        (digr \t, \s, 0x045b),
        (digr \k, \j, 0x045c),
        (digr \v, \%, 0x045e),
        (digr \d, \z, 0x045f),
        (digr \Y, \3, 0x0462),
        (digr \y, \3, 0x0463),
        (digr \O, \3, 0x046a),
        (digr \o, \3, 0x046b),
        (digr \F, \3, 0x0472),
        (digr \f, \3, 0x0473),
        (digr \V, \3, 0x0474),
        (digr \v, \3, 0x0475),
        (digr \C, \3, 0x0480),
        (digr \c, \3, 0x0481),
        (digr \G, \3, 0x0490),
        (digr \g, \3, 0x0491),
        (digr \A, \+, 0x05d0),
        (digr \B, \+, 0x05d1),
        (digr \G, \+, 0x05d2),
        (digr \D, \+, 0x05d3),
        (digr \H, \+, 0x05d4),
        (digr \W, \+, 0x05d5),
        (digr \Z, \+, 0x05d6),
        (digr \X, \+, 0x05d7),
        (digr \T, \j, 0x05d8),
        (digr \J, \+, 0x05d9),
        (digr \K, \%, 0x05da),
        (digr \K, \+, 0x05db),
        (digr \L, \+, 0x05dc),
        (digr \M, \%, 0x05dd),
        (digr \M, \+, 0x05de),
        (digr \N, \%, 0x05df),
        (digr \N, \+, 0x05e0),
        (digr \S, \+, 0x05e1),
        (digr \E, \+, 0x05e2),
        (digr \P, \%, 0x05e3),
        (digr \P, \+, 0x05e4),
        (digr \Z, \j, 0x05e5),
        (digr \Z, \J, 0x05e6),
        (digr \Q, \+, 0x05e7),
        (digr \R, \+, 0x05e8),
        (digr \S, \h, 0x05e9),
        (digr \T, \+, 0x05ea),
        (digr \,, \+, 0x060c),
        (digr \;, \+, 0x061b),
        (digr \?, \+, 0x061f),
        (digr \H, \', 0x0621),
        (digr \a, \M, 0x0622),
        (digr \a, \H, 0x0623),
        (digr \w, \H, 0x0624),
        (digr \a, \h, 0x0625),
        (digr \y, \H, 0x0626),
        (digr \a, \+, 0x0627),
        (digr \b, \+, 0x0628),
        (digr \t, \m, 0x0629),
        (digr \t, \+, 0x062a),
        (digr \t, \k, 0x062b),
        (digr \g, \+, 0x062c),
        (digr \h, \k, 0x062d),
        (digr \x, \+, 0x062e),
        (digr \d, \+, 0x062f),
        (digr \d, \k, 0x0630),
        (digr \r, \+, 0x0631),
        (digr \z, \+, 0x0632),
        (digr \s, \+, 0x0633),
        (digr \s, \n, 0x0634),
        (digr \c, \+, 0x0635),
        (digr \d, \d, 0x0636),
        (digr \t, \j, 0x0637),
        (digr \z, \H, 0x0638),
        (digr \e, \+, 0x0639),
        (digr \i, \+, 0x063a),
        (digr \+, \+, 0x0640),
        (digr \f, \+, 0x0641),
        (digr \q, \+, 0x0642),
        (digr \k, \+, 0x0643),
        (digr \l, \+, 0x0644),
        (digr \m, \+, 0x0645),
        (digr \n, \+, 0x0646),
        (digr \h, \+, 0x0647),
        (digr \w, \+, 0x0648),
        (digr \j, \+, 0x0649),
        (digr \y, \+, 0x064a),
        (digr \:, \+, 0x064b),
        (digr \", \+, 0x064c),  ;; """
        (digr \=, \+, 0x064d),
        (digr \/, \+, 0x064e),
        (digr \', \+, 0x064f),
        (digr \1, \+, 0x0650),
        (digr \3, \+, 0x0651),
        (digr \0, \+, 0x0652),
        (digr \a, \S, 0x0670),
        (digr \p, \+, 0x067e),
        (digr \v, \+, 0x06a4),
        (digr \g, \f, 0x06af),
        (digr \0, \a, 0x06f0),
        (digr \1, \a, 0x06f1),
        (digr \2, \a, 0x06f2),
        (digr \3, \a, 0x06f3),
        (digr \4, \a, 0x06f4),
        (digr \5, \a, 0x06f5),
        (digr \6, \a, 0x06f6),
        (digr \7, \a, 0x06f7),
        (digr \8, \a, 0x06f8),
        (digr \9, \a, 0x06f9),
        (digr \B, \., 0x1e02),
        (digr \b, \., 0x1e03),
        (digr \B, \_, 0x1e06),
        (digr \b, \_, 0x1e07),
        (digr \D, \., 0x1e0a),
        (digr \d, \., 0x1e0b),
        (digr \D, \_, 0x1e0e),
        (digr \d, \_, 0x1e0f),
        (digr \D, \,, 0x1e10),
        (digr \d, \,, 0x1e11),
        (digr \F, \., 0x1e1e),
        (digr \f, \., 0x1e1f),
        (digr \G, \-, 0x1e20),
        (digr \g, \-, 0x1e21),
        (digr \H, \., 0x1e22),
        (digr \h, \., 0x1e23),
        (digr \H, \:, 0x1e26),
        (digr \h, \:, 0x1e27),
        (digr \H, \,, 0x1e28),
        (digr \h, \,, 0x1e29),
        (digr \K, \', 0x1e30),
        (digr \k, \', 0x1e31),
        (digr \K, \_, 0x1e34),
        (digr \k, \_, 0x1e35),
        (digr \L, \_, 0x1e3a),
        (digr \l, \_, 0x1e3b),
        (digr \M, \', 0x1e3e),
        (digr \m, \', 0x1e3f),
        (digr \M, \., 0x1e40),
        (digr \m, \., 0x1e41),
        (digr \N, \., 0x1e44),
        (digr \n, \., 0x1e45),
        (digr \N, \_, 0x1e48),
        (digr \n, \_, 0x1e49),
        (digr \P, \', 0x1e54),
        (digr \p, \', 0x1e55),
        (digr \P, \., 0x1e56),
        (digr \p, \., 0x1e57),
        (digr \R, \., 0x1e58),
        (digr \r, \., 0x1e59),
        (digr \R, \_, 0x1e5e),
        (digr \r, \_, 0x1e5f),
        (digr \S, \., 0x1e60),
        (digr \s, \., 0x1e61),
        (digr \T, \., 0x1e6a),
        (digr \t, \., 0x1e6b),
        (digr \T, \_, 0x1e6e),
        (digr \t, \_, 0x1e6f),
        (digr \V, \?, 0x1e7c),
        (digr \v, \?, 0x1e7d),
        (digr \W, \!, 0x1e80),
        (digr \w, \!, 0x1e81),
        (digr \W, \', 0x1e82),
        (digr \w, \', 0x1e83),
        (digr \W, \:, 0x1e84),
        (digr \w, \:, 0x1e85),
        (digr \W, \., 0x1e86),
        (digr \w, \., 0x1e87),
        (digr \X, \., 0x1e8a),
        (digr \x, \., 0x1e8b),
        (digr \X, \:, 0x1e8c),
        (digr \x, \:, 0x1e8d),
        (digr \Y, \., 0x1e8e),
        (digr \y, \., 0x1e8f),
        (digr \Z, \>, 0x1e90),
        (digr \z, \>, 0x1e91),
        (digr \Z, \_, 0x1e94),
        (digr \z, \_, 0x1e95),
        (digr \h, \_, 0x1e96),
        (digr \t, \:, 0x1e97),
        (digr \w, \0, 0x1e98),
        (digr \y, \0, 0x1e99),
        (digr \A, \2, 0x1ea2),
        (digr \a, \2, 0x1ea3),
        (digr \E, \2, 0x1eba),
        (digr \e, \2, 0x1ebb),
        (digr \E, \?, 0x1ebc),
        (digr \e, \?, 0x1ebd),
        (digr \I, \2, 0x1ec8),
        (digr \i, \2, 0x1ec9),
        (digr \O, \2, 0x1ece),
        (digr \o, \2, 0x1ecf),
        (digr \U, \2, 0x1ee6),
        (digr \u, \2, 0x1ee7),
        (digr \Y, \!, 0x1ef2),
        (digr \y, \!, 0x1ef3),
        (digr \Y, \2, 0x1ef6),
        (digr \y, \2, 0x1ef7),
        (digr \Y, \?, 0x1ef8),
        (digr \y, \?, 0x1ef9),
        (digr \;, \', 0x1f00),
        (digr \,, \', 0x1f01),
        (digr \;, \!, 0x1f02),
        (digr \,, \!, 0x1f03),
        (digr \?, \;, 0x1f04),
        (digr \?, \,, 0x1f05),
        (digr \!, \:, 0x1f06),
        (digr \?, \:, 0x1f07),
        (digr \1, \N, 0x2002),
        (digr \1, \M, 0x2003),
        (digr \3, \M, 0x2004),
        (digr \4, \M, 0x2005),
        (digr \6, \M, 0x2006),
        (digr \1, \T, 0x2009),
        (digr \1, \H, 0x200a),
        (digr \-, \1, 0x2010),
        (digr \-, \N, 0x2013),
        (digr \-, \M, 0x2014),
        (digr \-, \3, 0x2015),
        (digr \!, \2, 0x2016),
        (digr \=, \2, 0x2017),
        (digr \', \6, 0x2018),
        (digr \', \9, 0x2019),
        (digr \., \9, 0x201a),
        (digr \9, \', 0x201b),
        (digr \", \6, 0x201c),  ;; """
        (digr \", \9, 0x201d),  ;; """
        (digr \:, \9, 0x201e),
        (digr \9, \", 0x201f),  ;; """
        (digr \/, \-, 0x2020),
        (digr \/, \=, 0x2021),
        (digr \., \., 0x2025),
        (digr \%, \0, 0x2030),
        (digr \1, \', 0x2032),
        (digr \2, \', 0x2033),
        (digr \3, \', 0x2034),
        (digr \1, \", 0x2035),  ;; """
        (digr \2, \", 0x2036),  ;; """
        (digr \3, \", 0x2037),  ;; """
        (digr \C, \a, 0x2038),
        (digr \<, \1, 0x2039),
        (digr \>, \1, 0x203a),
        (digr \:, \X, 0x203b),
        (digr \', \-, 0x203e),
        (digr \/, \f, 0x2044),
        (digr \0, \S, 0x2070),
        (digr \4, \S, 0x2074),
        (digr \5, \S, 0x2075),
        (digr \6, \S, 0x2076),
        (digr \7, \S, 0x2077),
        (digr \8, \S, 0x2078),
        (digr \9, \S, 0x2079),
        (digr \+, \S, 0x207a),
        (digr \-, \S, 0x207b),
        (digr \=, \S, 0x207c),
        (digr \(, \S, 0x207d),
        (digr \), \S, 0x207e),
        (digr \n, \S, 0x207f),
        (digr \0, \s, 0x2080),
        (digr \1, \s, 0x2081),
        (digr \2, \s, 0x2082),
        (digr \3, \s, 0x2083),
        (digr \4, \s, 0x2084),
        (digr \5, \s, 0x2085),
        (digr \6, \s, 0x2086),
        (digr \7, \s, 0x2087),
        (digr \8, \s, 0x2088),
        (digr \9, \s, 0x2089),
        (digr \+, \s, 0x208a),
        (digr \-, \s, 0x208b),
        (digr \=, \s, 0x208c),
        (digr \(, \s, 0x208d),
        (digr \), \s, 0x208e),
        (digr \L, \i, 0x20a4),
        (digr \P, \t, 0x20a7),
        (digr \W, \=, 0x20a9),
        (digr \=, \e, 0x20ac), ;; euro
        (digr \E, \u, 0x20ac), ;; euro
        (digr \=, \R, 0x20bd), ;; rouble
        (digr \=, \P, 0x20bd), ;; rouble
        (digr \o, \C, 0x2103),
        (digr \c, \o, 0x2105),
        (digr \o, \F, 0x2109),
        (digr \N, \0, 0x2116),
        (digr \P, \O, 0x2117),
        (digr \R, \x, 0x211e),
        (digr \S, \M, 0x2120),
        (digr \T, \M, 0x2122),
        (digr \O, \m, 0x2126),
        (digr \A, \O, 0x212b),
        (digr \1, \3, 0x2153),
        (digr \2, \3, 0x2154),
        (digr \1, \5, 0x2155),
        (digr \2, \5, 0x2156),
        (digr \3, \5, 0x2157),
        (digr \4, \5, 0x2158),
        (digr \1, \6, 0x2159),
        (digr \5, \6, 0x215a),
        (digr \1, \8, 0x215b),
        (digr \3, \8, 0x215c),
        (digr \5, \8, 0x215d),
        (digr \7, \8, 0x215e),
        (digr \1, \R, 0x2160),
        (digr \2, \R, 0x2161),
        (digr \3, \R, 0x2162),
        (digr \4, \R, 0x2163),
        (digr \5, \R, 0x2164),
        (digr \6, \R, 0x2165),
        (digr \7, \R, 0x2166),
        (digr \8, \R, 0x2167),
        (digr \9, \R, 0x2168),
        (digr \a, \R, 0x2169),
        (digr \b, \R, 0x216a),
        (digr \c, \R, 0x216b),
        (digr \1, \r, 0x2170),
        (digr \2, \r, 0x2171),
        (digr \3, \r, 0x2172),
        (digr \4, \r, 0x2173),
        (digr \5, \r, 0x2174),
        (digr \6, \r, 0x2175),
        (digr \7, \r, 0x2176),
        (digr \8, \r, 0x2177),
        (digr \9, \r, 0x2178),
        (digr \a, \r, 0x2179),
        (digr \b, \r, 0x217a),
        (digr \c, \r, 0x217b),
        (digr \<, \-, 0x2190),
        (digr \-, \!, 0x2191),
        (digr \-, \>, 0x2192),
        (digr \-, \v, 0x2193),
        (digr \<, \>, 0x2194),
        (digr \U, \D, 0x2195),
        (digr \<, \=, 0x21d0),
        (digr \=, \>, 0x21d2),
        (digr \=, \=, 0x21d4),
        (digr \F, \A, 0x2200),
        (digr \d, \P, 0x2202),
        (digr \T, \E, 0x2203),
        (digr \/, \0, 0x2205),
        (digr \D, \E, 0x2206),
        (digr \N, \B, 0x2207),
        (digr \(, \-, 0x2208),
        (digr \-, \), 0x220b),
        (digr \*, \P, 0x220f),
        (digr \+, \Z, 0x2211),
        (digr \-, \2, 0x2212),
        (digr \-, \+, 0x2213),
        (digr \*, \-, 0x2217),
        (digr \O, \b, 0x2218),
        (digr \S, \b, 0x2219),
        (digr \R, \T, 0x221a),
        (digr \0, \(, 0x221d),
        (digr \0, \0, 0x221e),
        (digr \-, \L, 0x221f),
        (digr \-, \V, 0x2220),
        (digr \P, \P, 0x2225),
        (digr \A, \N, 0x2227),
        (digr \O, \R, 0x2228),
        (digr \(, \U, 0x2229),
        (digr \), \U, 0x222a),
        (digr \I, \n, 0x222b),
        (digr \D, \I, 0x222c),
        (digr \I, \o, 0x222e),
        (digr \., \:, 0x2234),
        (digr \:, \., 0x2235),
        (digr \:, \R, 0x2236),
        (digr \:, \:, 0x2237),
        (digr \?, \1, 0x223c),
        (digr \C, \G, 0x223e),
        (digr \?, \-, 0x2243),
        (digr \?, \=, 0x2245),
        (digr \?, \2, 0x2248),
        (digr \=, \?, 0x224c),
        (digr \H, \I, 0x2253),
        (digr \!, \=, 0x2260),
        (digr \=, \3, 0x2261),
        (digr \=, \<, 0x2264),
        (digr \>, \=, 0x2265),
        (digr \<, \*, 0x226a),
        (digr \*, \>, 0x226b),
        (digr \!, \<, 0x226e),
        (digr \!, \>, 0x226f),
        (digr \(, \C, 0x2282),
        (digr \), \C, 0x2283),
        (digr \(, \_, 0x2286),
        (digr \), \_, 0x2287),
        (digr \0, \., 0x2299),
        (digr \0, \2, 0x229a),
        (digr \-, \T, 0x22a5),
        (digr \., \P, 0x22c5),
        (digr \:, \3, 0x22ee),
        (digr \., \3, 0x22ef),
        (digr \E, \h, 0x2302),
        (digr \<, \7, 0x2308),
        (digr \>, \7, 0x2309),
        (digr \7, \<, 0x230a),
        (digr \7, \>, 0x230b),
        (digr \N, \I, 0x2310),
        (digr \(, \A, 0x2312),
        (digr \T, \R, 0x2315),
        (digr \I, \u, 0x2320),
        (digr \I, \l, 0x2321),
        (digr \<, \/, 0x2329),
        (digr \/, \>, 0x232a),
        (digr \V, \s, 0x2423),
        (digr \1, \h, 0x2440),
        (digr \3, \h, 0x2441),
        (digr \2, \h, 0x2442),
        (digr \4, \h, 0x2443),
        (digr \1, \j, 0x2446),
        (digr \2, \j, 0x2447),
        (digr \3, \j, 0x2448),
        (digr \4, \j, 0x2449),
        (digr \1, \., 0x2488),
        (digr \2, \., 0x2489),
        (digr \3, \., 0x248a),
        (digr \4, \., 0x248b),
        (digr \5, \., 0x248c),
        (digr \6, \., 0x248d),
        (digr \7, \., 0x248e),
        (digr \8, \., 0x248f),
        (digr \9, \., 0x2490),
        (digr \h, \h, 0x2500),
        (digr \H, \H, 0x2501),
        (digr \v, \v, 0x2502),
        (digr \V, \V, 0x2503),
        (digr \3, \-, 0x2504),
        (digr \3, \_, 0x2505),
        (digr \3, \!, 0x2506),
        (digr \3, \/, 0x2507),
        (digr \4, \-, 0x2508),
        (digr \4, \_, 0x2509),
        (digr \4, \!, 0x250a),
        (digr \4, \/, 0x250b),
        (digr \d, \r, 0x250c),
        (digr \d, \R, 0x250d),
        (digr \D, \r, 0x250e),
        (digr \D, \R, 0x250f),
        (digr \d, \l, 0x2510),
        (digr \d, \L, 0x2511),
        (digr \D, \l, 0x2512),
        (digr \L, \D, 0x2513),
        (digr \u, \r, 0x2514),
        (digr \u, \R, 0x2515),
        (digr \U, \r, 0x2516),
        (digr \U, \R, 0x2517),
        (digr \u, \l, 0x2518),
        (digr \u, \L, 0x2519),
        (digr \U, \l, 0x251a),
        (digr \U, \L, 0x251b),
        (digr \v, \r, 0x251c),
        (digr \v, \R, 0x251d),
        (digr \V, \r, 0x2520),
        (digr \V, \R, 0x2523),
        (digr \v, \l, 0x2524),
        (digr \v, \L, 0x2525),
        (digr \V, \l, 0x2528),
        (digr \V, \L, 0x252b),
        (digr \d, \h, 0x252c),
        (digr \d, \H, 0x252f),
        (digr \D, \h, 0x2530),
        (digr \D, \H, 0x2533),
        (digr \u, \h, 0x2534),
        (digr \u, \H, 0x2537),
        (digr \U, \h, 0x2538),
        (digr \U, \H, 0x253b),
        (digr \v, \h, 0x253c),
        (digr \v, \H, 0x253f),
        (digr \V, \h, 0x2542),
        (digr \V, \H, 0x254b),
        (digr \F, \D, 0x2571),
        (digr \B, \D, 0x2572),
        (digr \T, \B, 0x2580),
        (digr \L, \B, 0x2584),
        (digr \F, \B, 0x2588),
        (digr \l, \B, 0x258c),
        (digr \R, \B, 0x2590),
        (digr \., \S, 0x2591),
        (digr \:, \S, 0x2592),
        (digr \?, \S, 0x2593),
        (digr \f, \S, 0x25a0),
        (digr \O, \S, 0x25a1),
        (digr \R, \O, 0x25a2),
        (digr \R, \r, 0x25a3),
        (digr \R, \F, 0x25a4),
        (digr \R, \Y, 0x25a5),
        (digr \R, \H, 0x25a6),
        (digr \R, \Z, 0x25a7),
        (digr \R, \K, 0x25a8),
        (digr \R, \X, 0x25a9),
        (digr \s, \B, 0x25aa),
        (digr \S, \R, 0x25ac),
        (digr \O, \r, 0x25ad),
        (digr \U, \T, 0x25b2),
        (digr \u, \T, 0x25b3),
        (digr \P, \R, 0x25b6),
        (digr \T, \r, 0x25b7),
        (digr \D, \t, 0x25bc),
        (digr \d, \T, 0x25bd),
        (digr \P, \L, 0x25c0),
        (digr \T, \l, 0x25c1),
        (digr \D, \b, 0x25c6),
        (digr \D, \w, 0x25c7),
        (digr \L, \Z, 0x25ca),
        (digr \0, \m, 0x25cb),
        (digr \0, \o, 0x25ce),
        (digr \0, \M, 0x25cf),
        (digr \0, \L, 0x25d0),
        (digr \0, \R, 0x25d1),
        (digr \S, \n, 0x25d8),
        (digr \I, \c, 0x25d9),
        (digr \F, \d, 0x25e2),
        (digr \B, \d, 0x25e3),
        (digr \*, \2, 0x2605),
        (digr \*, \1, 0x2606),
        (digr \<, \H, 0x261c),
        (digr \>, \H, 0x261e),
        (digr \0, \u, 0x263a),
        (digr \0, \U, 0x263b),
        (digr \S, \U, 0x263c),
        (digr \F, \m, 0x2640),
        (digr \M, \l, 0x2642),
        (digr \c, \S, 0x2660),
        (digr \c, \H, 0x2661),
        (digr \c, \D, 0x2662),
        (digr \c, \C, 0x2663),
        (digr \M, \d, 0x2669),
        (digr \M, \8, 0x266a),
        (digr \M, \2, 0x266b),
        (digr \M, \b, 0x266d),
        (digr \M, \x, 0x266e),
        (digr \M, \X, 0x266f),
        (digr \O, \K, 0x2713),
        (digr \X, \X, 0x2717),
        (digr \-, \X, 0x2720),
        (digr \I, \S, 0x3000),
        (digr \,, \_, 0x3001),
        (digr \., \_, 0x3002),
        (digr \+, \", 0x3003),  ;; """
        (digr \+, \_, 0x3004),
        (digr \*, \_, 0x3005),
        (digr \;, \_, 0x3006),
        (digr \0, \_, 0x3007),
        (digr \<, \+, 0x300a),
        (digr \>, \+, 0x300b),
        (digr \<, \', 0x300c),
        (digr \>, \', 0x300d),
        (digr \<, \", 0x300e),  ;; """
        (digr \>, \", 0x300f),  ;; """
        (digr \(, \", 0x3010),  ;; """
        (digr \), \", 0x3011),  ;; """
        (digr \=, \T, 0x3012),
        (digr \=, \_, 0x3013),
        (digr \(, \', 0x3014),
        (digr \), \', 0x3015),
        (digr \(, \I, 0x3016),
        (digr \), \I, 0x3017),
        (digr \-, \?, 0x301c),
        (digr \A, \5, 0x3041),
        (digr \a, \5, 0x3042),
        (digr \I, \5, 0x3043),
        (digr \i, \5, 0x3044),
        (digr \U, \5, 0x3045),
        (digr \u, \5, 0x3046),
        (digr \E, \5, 0x3047),
        (digr \e, \5, 0x3048),
        (digr \O, \5, 0x3049),
        (digr \o, \5, 0x304a),
        (digr \k, \a, 0x304b),
        (digr \g, \a, 0x304c),
        (digr \k, \i, 0x304d),
        (digr \g, \i, 0x304e),
        (digr \k, \u, 0x304f),
        (digr \g, \u, 0x3050),
        (digr \k, \e, 0x3051),
        (digr \g, \e, 0x3052),
        (digr \k, \o, 0x3053),
        (digr \g, \o, 0x3054),
        (digr \s, \a, 0x3055),
        (digr \z, \a, 0x3056),
        (digr \s, \i, 0x3057),
        (digr \z, \i, 0x3058),
        (digr \s, \u, 0x3059),
        (digr \z, \u, 0x305a),
        (digr \s, \e, 0x305b),
        (digr \z, \e, 0x305c),
        (digr \s, \o, 0x305d),
        (digr \z, \o, 0x305e),
        (digr \t, \a, 0x305f),
        (digr \d, \a, 0x3060),
        (digr \t, \i, 0x3061),
        (digr \d, \i, 0x3062),
        (digr \t, \U, 0x3063),
        (digr \t, \u, 0x3064),
        (digr \d, \u, 0x3065),
        (digr \t, \e, 0x3066),
        (digr \d, \e, 0x3067),
        (digr \t, \o, 0x3068),
        (digr \d, \o, 0x3069),
        (digr \n, \a, 0x306a),
        (digr \n, \i, 0x306b),
        (digr \n, \u, 0x306c),
        (digr \n, \e, 0x306d),
        (digr \n, \o, 0x306e),
        (digr \h, \a, 0x306f),
        (digr \b, \a, 0x3070),
        (digr \p, \a, 0x3071),
        (digr \h, \i, 0x3072),
        (digr \b, \i, 0x3073),
        (digr \p, \i, 0x3074),
        (digr \h, \u, 0x3075),
        (digr \b, \u, 0x3076),
        (digr \p, \u, 0x3077),
        (digr \h, \e, 0x3078),
        (digr \b, \e, 0x3079),
        (digr \p, \e, 0x307a),
        (digr \h, \o, 0x307b),
        (digr \b, \o, 0x307c),
        (digr \p, \o, 0x307d),
        (digr \m, \a, 0x307e),
        (digr \m, \i, 0x307f),
        (digr \m, \u, 0x3080),
        (digr \m, \e, 0x3081),
        (digr \m, \o, 0x3082),
        (digr \y, \A, 0x3083),
        (digr \y, \a, 0x3084),
        (digr \y, \U, 0x3085),
        (digr \y, \u, 0x3086),
        (digr \y, \O, 0x3087),
        (digr \y, \o, 0x3088),
        (digr \r, \a, 0x3089),
        (digr \r, \i, 0x308a),
        (digr \r, \u, 0x308b),
        (digr \r, \e, 0x308c),
        (digr \r, \o, 0x308d),
        (digr \w, \A, 0x308e),
        (digr \w, \a, 0x308f),
        (digr \w, \i, 0x3090),
        (digr \w, \e, 0x3091),
        (digr \w, \o, 0x3092),
        (digr \n, \5, 0x3093),
        (digr \v, \u, 0x3094),
        (digr \", \5, 0x309b),  ;; """
        (digr \0, \5, 0x309c),
        (digr \*, \5, 0x309d),
        (digr \+, \5, 0x309e),
        (digr \a, \6, 0x30a1),
        (digr \A, \6, 0x30a2),
        (digr \i, \6, 0x30a3),
        (digr \I, \6, 0x30a4),
        (digr \u, \6, 0x30a5),
        (digr \U, \6, 0x30a6),
        (digr \e, \6, 0x30a7),
        (digr \E, \6, 0x30a8),
        (digr \o, \6, 0x30a9),
        (digr \O, \6, 0x30aa),
        (digr \K, \a, 0x30ab),
        (digr \G, \a, 0x30ac),
        (digr \K, \i, 0x30ad),
        (digr \G, \i, 0x30ae),
        (digr \K, \u, 0x30af),
        (digr \G, \u, 0x30b0),
        (digr \K, \e, 0x30b1),
        (digr \G, \e, 0x30b2),
        (digr \K, \o, 0x30b3),
        (digr \G, \o, 0x30b4),
        (digr \S, \a, 0x30b5),
        (digr \Z, \a, 0x30b6),
        (digr \S, \i, 0x30b7),
        (digr \Z, \i, 0x30b8),
        (digr \S, \u, 0x30b9),
        (digr \Z, \u, 0x30ba),
        (digr \S, \e, 0x30bb),
        (digr \Z, \e, 0x30bc),
        (digr \S, \o, 0x30bd),
        (digr \Z, \o, 0x30be),
        (digr \T, \a, 0x30bf),
        (digr \D, \a, 0x30c0),
        (digr \T, \i, 0x30c1),
        (digr \D, \i, 0x30c2),
        (digr \T, \U, 0x30c3),
        (digr \T, \u, 0x30c4),
        (digr \D, \u, 0x30c5),
        (digr \T, \e, 0x30c6),
        (digr \D, \e, 0x30c7),
        (digr \T, \o, 0x30c8),
        (digr \D, \o, 0x30c9),
        (digr \N, \a, 0x30ca),
        (digr \N, \i, 0x30cb),
        (digr \N, \u, 0x30cc),
        (digr \N, \e, 0x30cd),
        (digr \N, \o, 0x30ce),
        (digr \H, \a, 0x30cf),
        (digr \B, \a, 0x30d0),
        (digr \P, \a, 0x30d1),
        (digr \H, \i, 0x30d2),
        (digr \B, \i, 0x30d3),
        (digr \P, \i, 0x30d4),
        (digr \H, \u, 0x30d5),
        (digr \B, \u, 0x30d6),
        (digr \P, \u, 0x30d7),
        (digr \H, \e, 0x30d8),
        (digr \B, \e, 0x30d9),
        (digr \P, \e, 0x30da),
        (digr \H, \o, 0x30db),
        (digr \B, \o, 0x30dc),
        (digr \P, \o, 0x30dd),
        (digr \M, \a, 0x30de),
        (digr \M, \i, 0x30df),
        (digr \M, \u, 0x30e0),
        (digr \M, \e, 0x30e1),
        (digr \M, \o, 0x30e2),
        (digr \Y, \A, 0x30e3),
        (digr \Y, \a, 0x30e4),
        (digr \Y, \U, 0x30e5),
        (digr \Y, \u, 0x30e6),
        (digr \Y, \O, 0x30e7),
        (digr \Y, \o, 0x30e8),
        (digr \R, \a, 0x30e9),
        (digr \R, \i, 0x30ea),
        (digr \R, \u, 0x30eb),
        (digr \R, \e, 0x30ec),
        (digr \R, \o, 0x30ed),
        (digr \W, \A, 0x30ee),
        (digr \W, \a, 0x30ef),
        (digr \W, \i, 0x30f0),
        (digr \W, \e, 0x30f1),
        (digr \W, \o, 0x30f2),
        (digr \N, \6, 0x30f3),
        (digr \V, \u, 0x30f4),
        (digr \K, \A, 0x30f5),
        (digr \K, \E, 0x30f6),
        (digr \V, \a, 0x30f7),
        (digr \V, \i, 0x30f8),
        (digr \V, \e, 0x30f9),
        (digr \V, \o, 0x30fa),
        (digr \., \6, 0x30fb),
        (digr \-, \6, 0x30fc),
        (digr \*, \6, 0x30fd),
        (digr \+, \6, 0x30fe),
        (digr \b, \4, 0x3105),
        (digr \p, \4, 0x3106),
        (digr \m, \4, 0x3107),
        (digr \f, \4, 0x3108),
        (digr \d, \4, 0x3109),
        (digr \t, \4, 0x310a),
        (digr \n, \4, 0x310b),
        (digr \l, \4, 0x310c),
        (digr \g, \4, 0x310d),
        (digr \k, \4, 0x310e),
        (digr \h, \4, 0x310f),
        (digr \j, \4, 0x3110),
        (digr \q, \4, 0x3111),
        (digr \x, \4, 0x3112),
        (digr \z, \h, 0x3113),
        (digr \c, \h, 0x3114),
        (digr \s, \h, 0x3115),
        (digr \r, \4, 0x3116),
        (digr \z, \4, 0x3117),
        (digr \c, \4, 0x3118),
        (digr \s, \4, 0x3119),
        (digr \a, \4, 0x311a),
        (digr \o, \4, 0x311b),
        (digr \e, \4, 0x311c),
        (digr \a, \i, 0x311e),
        (digr \e, \i, 0x311f),
        (digr \a, \u, 0x3120),
        (digr \o, \u, 0x3121),
        (digr \a, \n, 0x3122),
        (digr \e, \n, 0x3123),
        (digr \a, \N, 0x3124),
        (digr \e, \N, 0x3125),
        (digr \e, \r, 0x3126),
        (digr \i, \4, 0x3127),
        (digr \u, \4, 0x3128),
        (digr \i, \u, 0x3129),
        (digr \v, \4, 0x312a),
        (digr \n, \G, 0x312b),
        (digr \g, \n, 0x312c),
        (digr \1, \c, 0x3220),
        (digr \2, \c, 0x3221),
        (digr \3, \c, 0x3222),
        (digr \4, \c, 0x3223),
        (digr \5, \c, 0x3224),
        (digr \6, \c, 0x3225),
        (digr \7, \c, 0x3226),
        (digr \8, \c, 0x3227),
        (digr \9, \c, 0x3228),
        ;; Code points 0xe000 - 0xefff excluded;
        ;; they have no assigned characters, only used in proposals.
        (digr \f, \f, 0xfb00),
        (digr \f, \i, 0xfb01),
        (digr \f, \l, 0xfb02),
        (digr \f, \t, 0xfb05),
        (digr \s, \t, 0xfb06),

        ;; Vim 5.x compatible digraphs that don't conflict with the above.
        (digr \~, \!, 161),
        (digr \c, \|, 162),
        (digr \$, \$, 163),
        (digr \o, \x, 164),
        (digr \Y, \-, 165),
        (digr \|, \|, 166),
        (digr \c, \O, 169),
        (digr \-, \,, 172),
        (digr \-, \=, 175),
        (digr \~, \o, 176),
        (digr \2, \2, 178),
        (digr \3, \3, 179),
        (digr \p, \p, 182),
        (digr \~, \., 183),
        (digr \1, \1, 185),
        (digr \~, \?, 191),
        (digr \A, \`, 192),
        (digr \A, \^, 194),
        (digr \A, \~, 195),
        (digr \A, \", 196), ;; """
        (digr \A, \@, 197),
        (digr \E, \`, 200),
        (digr \E, \^, 202),
        (digr \E, \", 203), ;; """
        (digr \I, \`, 204),
        (digr \I, \^, 206),
        (digr \I, \", 207), ;; """
        (digr \N, \~, 209),
        (digr \O, \`, 210),
        (digr \O, \^, 212),
        (digr \O, \~, 213),
        (digr \/, \\, 215),
        (digr \U, \`, 217),
        (digr \U, \^, 219),
        (digr \I, \p, 222),
        (digr \a, \`, 224),
        (digr \a, \^, 226),
        (digr \a, \~, 227),
        (digr \a, \", 228), ;; """
        (digr \a, \@, 229),
        (digr \e, \`, 232),
        (digr \e, \^, 234),
        (digr \e, \", 235), ;; """
        (digr \i, \`, 236),
        (digr \i, \^, 238),
        (digr \n, \~, 241),
        (digr \o, \`, 242),
        (digr \o, \^, 244),
        (digr \o, \~, 245),
        (digr \u, \`, 249),
        (digr \u, \^, 251),
        (digr \y, \", 255)  ;; """
    ])

(atom! int backspaced)  ;; character before K_BS
(atom! int lastchar)    ;; last typed character

;; handle digraphs after typing a character

(defn- #_int do-digraph [#_int c]
    (let [c (cond (== c -1)
                (do (reset! backspaced -1) c)
            @p_dg
                (let [c (if (<= 0 @backspaced) (getdigraph @backspaced, c, false) c)]
                    (reset! backspaced -1)
                    (when (and (any == c K_BS Ctrl_H) (<= 0 @lastchar))
                        (reset! backspaced @lastchar))
                    c)
            :else c)]
        (reset! lastchar c)
    c))

;; Get a digraph.  Used after typing CTRL-K on the command line or in normal mode.
;; Returns composed character, or NUL when ESC was used.

(defn- #_int get-digraph [#_boolean cmdline]
    ;; cmdline: true when called from the cmdline
    (let [_ (swap! no_mapping inc) _ (swap! allow_keys inc) c1 (plain-vgetc) _ (swap! no_mapping dec) _ (swap! allow_keys dec)]
        (cond (== c1 ESC)           ;; ESC cancels CTRL-K
            NUL
        (is-special c1)             ;; insert special key code
            c1
        :else
        (do
            (if cmdline
                (when (== (mb-char2cells c1) 1) (putcmdline c1, true))
                (add-to-showcmd c1))
            (let [_ (swap! no_mapping inc) _ (swap! allow_keys inc) c2 (plain-vgetc) _ (swap! no_mapping dec) _ (swap! allow_keys dec)]
                (if (== c2 ESC)     ;; ESC cancels CTRL-K
                    NUL
                    (getdigraph c1, c2, true)
                ))
        ))
    ))

;; Lookup the pair "char1", "char2" in the digraph tables.
;; If no match, return "char2".
;; If "meta?" is true and "char1" is a space, return "char2" | 0x80.

(defn- #_int getexactdigraph [#_int char1, #_int char2, #_boolean meta?]
    (if (or (is-special char1) (is-special char2))
        char2
        (let [n (:length digraphdefault)
              x (loop-when [i 0] (< i n) => 0
                    (let [y (... digraphdefault i)] (if (and (== (int (:char1 y)) char1) (== (int (:char2 y)) char2)) (:result y) (recur (inc i))))
                )]
            ;; digraph deleted or not found ;; <space> <char> --> meta-char
            (if (zero? x) (if (and (== char1 (byte \space)) meta?) (| char2 0x80) char2) x))
    ))

;; Get digraph.
;; Allow for both char1-char2 and char2-char1

(defn- #_int getdigraph [#_int char1, #_int char2, #_boolean meta?]
    (let-when [x (getexactdigraph char1, char2, meta?)] (and (== x char2) (!= char1 char2)) => x
        (let-when [x (getexactdigraph char2, char1, meta?)] (== x char1) => x
            char2
        )))

;; mbyte.c: Code specifically for handling multi-byte characters.
;;
;; "enc_utf8"   Use Unicode characters in UTF-8 encoding.
;;              The cell width on the display needs to be determined from the character value.
;;              Recognizing bytes is easy: 0xxx.xxxx is a single-byte char, 10xx.xxxx is a
;;              trailing byte, 11xx.xxxx is a leading byte of a multi-byte character.
;;              To make things complicated, up to six composing characters are allowed.
;;              These are drawn on top of the first char.
;;              For most editing the sequence of bytes with composing
;;              characters included is considered to be one character.
;;
;; 'encoding' specifies the encoding used in the core.  This is in registers,
;; text manipulation, buffers, etc.  Conversion has to be done when characters
;; in another encoding are received or send:
;;
;;                     clipboard
;;                         ^
;;                         | (2)
;;                         V
;;                 +---------------+
;;            (1)  |               | (3)
;;  keyboard ----->|     core      |-----> display
;;                 |               |
;;                 +---------------+
;;                         ^
;;                         | (4)
;;                         V
;;                       file
;;
;; (1) Typed characters arrive in the current locale.  Conversion is to be
;;     done when 'encoding' is different from 'termencoding'.
;; (2) Text will be made available with the encoding specified with
;;     'encoding'.  If this is not sufficient, system-specific conversion
;;     might be required.
;; (3) For the GUI the correct font must be selected, no conversion done.
;;     Otherwise, conversion is to be done when 'encoding' differs from
;;     'termencoding'.
;; (4) The encoding of the file is specified with 'fileencoding'.  Conversion
;;     is to be done when it's different from 'encoding'.

;; Lookup table to quickly get the length in bytes of a UTF-8 sequence from the first byte.
;; Bytes which are illegal when used as the first byte have a 0.
;; The NUL byte has length 1.

(final byte* #_"[/*256*/]" utf8len_tab_zero
    [
        1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
        1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
        1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
        1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
        2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
        3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,4,4,4,4,4,4,4,4,5,5,5,5,6,6,0,0
    ])

;; Returns the length of a UTF-8 sequence, obtained from the first byte.
;; For an invalid first byte returns zero ? 0 : 1.

(defn- #_int us-byte2len [#_byte b, #_boolean zero]
    (let [#_int len (... utf8len_tab_zero (char_u b))]
        (if (or zero (< 0 len)) len 1)
    ))

;; Return byte length of character that starts with byte "b".
;; Returns 1 for a single-byte character.
;; mb-byte2len() can be used to count a special key as one byte.

(defn- #_int mb-byte2len [#_int b]
    (if (<= 0 b 0xff) (us-byte2len (byte b), false) 1))

;; Get class of pointer:
;;  0 for blank or NUL
;;  1 for punctuation
;;  2 for an (ASCII) word character
;; >2 for other word characters

(defn- #_int us-get-class [#_Bytes p]
    (let [#_byte b (.at p 0)]
        (cond (!= (us-byte2len b, false) 1) (utf-class (us-ptr2char p)) (or (eos? p) (vim-iswhite b)) 0 (us-iswordb b) 2 :else 1)
    ))

(defn- #_boolean intable [#_int* table, #_int c]
    (if (< c (... table 0))
        false
        (loop-when [bot 0 top (dec (/ (:length table) 2))] (<= bot top) => false
            (let [mid (/ (+ bot top) 2)]
                (cond
                    (<   (... table (inc (* 2 mid))) c) (recur (inc mid) top)
                    (< c (... table      (* 2 mid)))    (recur bot (dec mid))
                    :else true)
            ))
    ))

;; Sorted list of non-overlapping intervals of East Asian double width characters,
;; generated with tools/unicode.vim.

(final int* doublewidth
    [
        0x1100, 0x115f,
        0x2329, 0x232a,
        0x2e80, 0x2e99,
        0x2e9b, 0x2ef3,
        0x2f00, 0x2fd5,
        0x2ff0, 0x2ffb,
        0x3000, 0x303e,
        0x3041, 0x3096,
        0x3099, 0x30ff,
        0x3105, 0x312d,
        0x3131, 0x318e,
        0x3190, 0x31ba,
        0x31c0, 0x31e3,
        0x31f0, 0x321e,
        0x3220, 0x3247,
        0x3250, 0x32fe,
        0x3300, 0x4dbf,
        0x4e00, 0xa48c,
        0xa490, 0xa4c6,
        0xa960, 0xa97c,
        0xac00, 0xd7a3,
        0xf900, 0xfaff,
        0xfe10, 0xfe19,
        0xfe30, 0xfe52,
        0xfe54, 0xfe66,
        0xfe68, 0xfe6b,
        0xff01, 0xff60,
        0xffe0, 0xffe6,
        0x1b000, 0x1b001,
        0x1f200, 0x1f202,
        0x1f210, 0x1f23a,
        0x1f240, 0x1f248,
        0x1f250, 0x1f251,
        0x20000, 0x2fffd,
        0x30000, 0x3fffd
    ])

;; Sorted list of non-overlapping intervals of East Asian Ambiguous characters,
;; generated with tools/unicode.vim.

(final int* ambiguous
    [
        0x00a1, 0x00a1,
        0x00a4, 0x00a4,
        0x00a7, 0x00a8,
        0x00aa, 0x00aa,
        0x00ad, 0x00ae,
        0x00b0, 0x00b4,
        0x00b6, 0x00ba,
        0x00bc, 0x00bf,
        0x00c6, 0x00c6,
        0x00d0, 0x00d0,
        0x00d7, 0x00d8,
        0x00de, 0x00e1,
        0x00e6, 0x00e6,
        0x00e8, 0x00ea,
        0x00ec, 0x00ed,
        0x00f0, 0x00f0,
        0x00f2, 0x00f3,
        0x00f7, 0x00fa,
        0x00fc, 0x00fc,
        0x00fe, 0x00fe,
        0x0101, 0x0101,
        0x0111, 0x0111,
        0x0113, 0x0113,
        0x011b, 0x011b,
        0x0126, 0x0127,
        0x012b, 0x012b,
        0x0131, 0x0133,
        0x0138, 0x0138,
        0x013f, 0x0142,
        0x0144, 0x0144,
        0x0148, 0x014b,
        0x014d, 0x014d,
        0x0152, 0x0153,
        0x0166, 0x0167,
        0x016b, 0x016b,
        0x01ce, 0x01ce,
        0x01d0, 0x01d0,
        0x01d2, 0x01d2,
        0x01d4, 0x01d4,
        0x01d6, 0x01d6,
        0x01d8, 0x01d8,
        0x01da, 0x01da,
        0x01dc, 0x01dc,
        0x0251, 0x0251,
        0x0261, 0x0261,
        0x02c4, 0x02c4,
        0x02c7, 0x02c7,
        0x02c9, 0x02cb,
        0x02cd, 0x02cd,
        0x02d0, 0x02d0,
        0x02d8, 0x02db,
        0x02dd, 0x02dd,
        0x02df, 0x02df,
        0x0300, 0x036f,
        0x0391, 0x03a1,
        0x03a3, 0x03a9,
        0x03b1, 0x03c1,
        0x03c3, 0x03c9,
        0x0401, 0x0401,
        0x0410, 0x044f,
        0x0451, 0x0451,
        0x2010, 0x2010,
        0x2013, 0x2016,
        0x2018, 0x2019,
        0x201c, 0x201d,
        0x2020, 0x2022,
        0x2024, 0x2027,
        0x2030, 0x2030,
        0x2032, 0x2033,
        0x2035, 0x2035,
        0x203b, 0x203b,
        0x203e, 0x203e,
        0x2074, 0x2074,
        0x207f, 0x207f,
        0x2081, 0x2084,
        0x20ac, 0x20ac,
        0x2103, 0x2103,
        0x2105, 0x2105,
        0x2109, 0x2109,
        0x2113, 0x2113,
        0x2116, 0x2116,
        0x2121, 0x2122,
        0x2126, 0x2126,
        0x212b, 0x212b,
        0x2153, 0x2154,
        0x215b, 0x215e,
        0x2160, 0x216b,
        0x2170, 0x2179,
        0x2189, 0x2189,
        0x2190, 0x2199,
        0x21b8, 0x21b9,
        0x21d2, 0x21d2,
        0x21d4, 0x21d4,
        0x21e7, 0x21e7,
        0x2200, 0x2200,
        0x2202, 0x2203,
        0x2207, 0x2208,
        0x220b, 0x220b,
        0x220f, 0x220f,
        0x2211, 0x2211,
        0x2215, 0x2215,
        0x221a, 0x221a,
        0x221d, 0x2220,
        0x2223, 0x2223,
        0x2225, 0x2225,
        0x2227, 0x222c,
        0x222e, 0x222e,
        0x2234, 0x2237,
        0x223c, 0x223d,
        0x2248, 0x2248,
        0x224c, 0x224c,
        0x2252, 0x2252,
        0x2260, 0x2261,
        0x2264, 0x2267,
        0x226a, 0x226b,
        0x226e, 0x226f,
        0x2282, 0x2283,
        0x2286, 0x2287,
        0x2295, 0x2295,
        0x2299, 0x2299,
        0x22a5, 0x22a5,
        0x22bf, 0x22bf,
        0x2312, 0x2312,
        0x2460, 0x24e9,
        0x24eb, 0x254b,
        0x2550, 0x2573,
        0x2580, 0x258f,
        0x2592, 0x2595,
        0x25a0, 0x25a1,
        0x25a3, 0x25a9,
        0x25b2, 0x25b3,
        0x25b6, 0x25b7,
        0x25bc, 0x25bd,
        0x25c0, 0x25c1,
        0x25c6, 0x25c8,
        0x25cb, 0x25cb,
        0x25ce, 0x25d1,
        0x25e2, 0x25e5,
        0x25ef, 0x25ef,
        0x2605, 0x2606,
        0x2609, 0x2609,
        0x260e, 0x260f,
        0x2614, 0x2615,
        0x261c, 0x261c,
        0x261e, 0x261e,
        0x2640, 0x2640,
        0x2642, 0x2642,
        0x2660, 0x2661,
        0x2663, 0x2665,
        0x2667, 0x266a,
        0x266c, 0x266d,
        0x266f, 0x266f,
        0x269e, 0x269f,
        0x26be, 0x26bf,
        0x26c4, 0x26cd,
        0x26cf, 0x26e1,
        0x26e3, 0x26e3,
        0x26e8, 0x26ff,
        0x273d, 0x273d,
        0x2757, 0x2757,
        0x2776, 0x277f,
        0x2b55, 0x2b59,
        0x3248, 0x324f,
        0xe000, 0xf8ff,
        0xfe00, 0xfe0f,
        0xfffd, 0xfffd,
        0x1f100, 0x1f10a,
        0x1f110, 0x1f12d,
        0x1f130, 0x1f169,
        0x1f170, 0x1f19a,
        0xe0100, 0xe01ef,
        0xf0000, 0xffffd,
        0x100000, 0x10fffd
    ])

;; For UTF-8 character "c" return 2 for a double-width character, 1 for others.
;; Returns 4 or 6 for an unprintable character.
;; Is only correct for characters >= 0x80.

(defn- #_int utf-char2cells [#_int c]
    (let [miez? false
          _ (when (<= 0x80 c)
                ;; chars below 0x100 are influenced by 'isprint' ;; 4: unprintable, displays <xx> ;; 6: unprintable, displays <xxxx>
                (let [_ (if (< c 0x100) (when (not (vim-isprintc c)) 4) (cond (not (utf-printable c)) 6 (intable doublewidth, c) 2))]
                    (if (some? _) _ (when (and miez? (intable ambiguous, c)) 2)))
            )]
        (if (some? _) _ 1)
    ))

(defn- us-ptr2cells
    ([s] (us-ptr2cells s 0))
    ([s i]
        (if (< (char_u (.at s i)) 0x80)
            1
            (let [c (us-ptr2char s, i)]
                (cond (or (== (us-ptr2len s, i) 1) (== c NUL)) ;; an illegal byte is displayed as <xx>
                    4
                (< c 0x80) ;; if the char is ASCII, it must be an overlong sequence
                    (mb-char2cells c)
                :else
                    (utf-char2cells c)
                ))
        )))

;; Return the number of cells occupied by string "s".
;; Stop at a NUL character.  When 0 <= "n" stop at character "s[n]".

(defn- #_int us-string2cells [#_Bytes s, #_int n]
    (loop-when-recur [#_int cells 0 #_int i 0] (and (or (< n 0) (< i n)) (non-eos? s i)) [(+ cells (us-ptr2cells s, i)) (+ i (us-ptr2len-cc s, i))] => cells))

(defn- #_int utf-off2cells [#_int off, #_int max_off]
    (if (and (< (inc off) max_off) (at? @screenLines (inc off) 0)) 2 1))

;; Convert a UTF-8 byte sequence to a wide character.
;; If the sequence is illegal or truncated by a NUL the first byte is returned.
;; Does not include composing characters, of course.

(defn- us-ptr2char
    ([s] (us-ptr2char s 0))
    ([s i]
        (let [s0 (.at s i) u0 (char_u s0)] (if (< u0 0x80) ;; be quick for ASCII
            s0
        (let [n (us-byte2len s0, true)] (if (< n 2) ;; illegal value, just return the first byte
            u0
        (let [s1 (.at s (+ i 1))] (if (== (& (char_u s1) 0xc0) 0x80) (if (== n 2)
            (+ (<< (& s0 0x1f) 6) (& s1 0x3f))
        (let [s2 (.at s (+ i 2))] (if (== (& (char_u s2) 0xc0) 0x80) (if (== n 3)
            (+ (<< (& s0 0x0f) 12) (<< (& s1 0x3f) 6) (& s2 0x3f))
        (let [s3 (.at s (+ i 3))] (if (== (& (char_u s3) 0xc0) 0x80) (if (== n 4)
            (+ (<< (& s0 0x07) 18) (<< (& s1 0x3f) 12) (<< (& s2 0x3f) 6) (& s3 0x3f))
        (let [s4 (.at s (+ i 4))] (if (== (& (char_u s4) 0xc0) 0x80) (if (== n 5)
            (+ (<< (& s0 0x03) 24) (<< (& s1 0x3f) 18) (<< (& s2 0x3f) 12) (<< (& s3 0x3f) 6) (& s4 0x3f))
        (let [s5 (.at s (+ i 5))] (if (and (== (& (char_u s5) 0xc0) 0x80) (== n 6))
            (+ (<< (& s0 0x01) 30) (<< (& s1 0x3f) 24) (<< (& s2 0x3f) 18) (<< (& s3 0x3f) 12) (<< (& s4 0x3f) 6) (& s5 0x3f))
            u0
        ))) u0
        ))) u0
        ))) u0
        ))) u0
        ))))))
    ))

;; Convert a UTF-8 byte sequence to a wide character.
;; String is assumed to be terminated by NUL or after "n" bytes, whichever comes first.
;; The function is safe in the sense that it never accesses memory beyond the first "n" bytes of "s".
;;
;; On success, returns decoded codepoint,
;; advances "s" to the beginning of next character and decreases "n" accordingly.
;;
;; If end of string was reached, returns 0 and, if "n" > 0, advances "s" past NUL byte.
;;
;; If byte sequence is illegal or incomplete, returns -1 and does not advance "s".

(defn- #_int us-safe-read-char-adv [#_Bytes' a's, #_int' a'n]
    (if (zero? @a'n)    ;; end of buffer
        0
        (let [#_int k (us-byte2len (.at @a's 0), true)]
            (cond (== k 1)     ;; ASCII character or NUL
                (do (swap! a's plus 1) (swap! a'n dec) (.at @a's -1))
            (<= k @a'n)
                ;; We have a multibyte sequence that isn't truncated, so us-ptr2char() is safe to use;
                ;; or the first byte is illegal (k=0), but it's also safe to use us-ptr2char().
                (let [#_int c (us-ptr2char @a's)]
                    ;; On failure, us-ptr2char() returns the first byte, so here we check equality with the first byte.
                    ;; The only non-ASCII character which equals the first byte of its own UTF-8 representation is
                    ;; U+00C3 (UTF-8: 0xC3 0x83), so need to check that special case too.
                    ;; It's safe even if n=1, else we would have k=2 > n.
                    (if (or (!= c (char_u (.at @a's 0))) (and (== c 0xc3) (== (char_u (.at @a's 1)) 0x83)))
                        (do (swap! a's plus k) (swap! a'n - k) c) ;; byte sequence was successfully decoded
                        -1 ;; byte sequence is illegal
                    ))
            :else
                -1 ;; byte sequence is incomplete
            ))
    ))

;; Get character at **pp and advance *pp to the next character.
;; skip: composing characters are skipped!
;; !skip: composing characters are returned as separate characters.

(defn- #_int us-ptr2char-adv [#_Bytes' a's, #_boolean skip]
    (let [#_int c (us-ptr2char @a's)]
        (swap! a's #(.plus % (if skip (us-ptr2len-cc %) (us-ptr2len %))))
        c
    ))

;; Convert a UTF-8 byte string to a wide character.
;; Also get up to MAX_MCO composing characters.

(defn- #_int us-ptr2char-cc [#_Bytes p, #_int* pcc]
    ;; pcc: return: composing chars, last one is 0
    (let [#_int i (us-ptr2len p)
          #_int j ;; Only accept a composing char when the first char isn't illegal.
            (if (or (< 1 i) (< (char_u (.at p 0)) 0x80))
                (loop-when [i i j 0] (<= 0x80 (char_u (.at p i))) => j
                    (let-when [#_int cc (us-ptr2char p, i)] (utf-iscomposing cc) => j
                        (aset pcc j cc)
                        (let [j (inc j)]
                            (recur-if (< j MAX_MCO) [(+ i (us-ptr2len p, i)) j] => j))
                    ))
                0
            )]
        (when (< j MAX_MCO)    ;; last composing char must be 0
            (aset pcc j 0))
        (us-ptr2char p)
    ))

;; Convert a UTF-8 byte string to a wide character.
;; Also get up to MAX_MCO composing characters.
;; Use no more than p[maxlen].

(defn- #_int us-ptr2char-cc-len [#_Bytes p, #_int* pcc, #_int maxlen]
    ;; pcc: return: composing chars, last one is 0
    (let [#_int i (us-ptr2len-len p, maxlen)
          #_int j ;; Only accept a composing char when the first char isn't illegal.
            (if (or (< 1 i) (< (char_u (.at p 0)) 0x80))
                (loop-when [i i j 0] (and (< i maxlen) (<= 0x80 (char_u (.at p i)))) => j
                    (let-when [#_int cc (us-ptr2char p, i)] (utf-iscomposing cc) => j
                        (aset pcc j cc)
                        (let [j (inc j)]
                            (recur-if (< j MAX_MCO) [(+ i (us-ptr2len-len p, i, (- maxlen i))) j] => j))
                    ))
                0
            )]
        (when (< j MAX_MCO)    ;; last composing char must be 0
            (aset pcc j 0))
        (us-ptr2char p)
    ))

;; Convert the character at screen position "off" to a sequence of bytes.
;; Includes the composing characters.
;; "buf" must at least have the length MB_MAXBYTES + 1.
;; Only to be used when screenLinesUC[off] != 0.
;; Returns the produced number of bytes.

(defn- #_int utfc-char2bytes [#_int off, #_Bytes buf]
    (loop-when-recur [#_int len (utf-char2bytes (... @screenLinesUC off), buf) #_int i 0]
                     (and (< i @screen_mco) (non-zero? (... (... @screenLinesC i) off)))
                     [(+ len (utf-char2bytes (... (... @screenLinesC i) off), (.plus buf len))) (inc i)]
                  => len)
)

;; Get the length of a UTF-8 byte sequence, not including any following composing characters.
;; Returns 0 for "".
;; Returns 1 for an illegal byte sequence.

(defn- us-ptr2len
    ([s] (us-ptr2len s 0))
    ([s i]
        (if (eos? s i)
            0
            (let [n (us-byte2len (.at s i), false)]
                (loop-when [i (inc i)] (< i n) => n
                    (recur-if (== (& (char_u (.at s i)) 0xc0) 0x80) [(inc i)] => 1)
                )
            )
        )))

;; Get the length of UTF-8 byte sequence "s[m]".
;; Does not include any following composing characters.
;; Returns 1 for "".
;; Returns 1 for an illegal byte sequence (also in incomplete byte seq.).
;; Returns number > "m" for an incomplete byte sequence.
;; Never returns zero.

(defn- us-ptr2len-len
    ([s m] (us-ptr2len-len s 0 m))
    ([s i m]
        (let [n (us-byte2len (.at s i), false)]
            (if (== n 1)
                1 ;; NUL, ASCII or illegal lead byte
                (let [m (min n m)] ;; incomplete byte sequence?
                    (loop-when [i (inc i)] (< i m) => n
                        (recur-if (== (& (char_u (.at s i)) 0xc0) 0x80) [(inc i)] => 1)
                    )
                )
            )
        )))

;; Return the number of bytes the UTF-8 encoding of the character at "s" takes.
;; This includes following composing characters.

(defn- us-ptr2len-cc
    ([s] (us-ptr2len-cc 0))
    ([s i]
        (cond
            (eos? s i)
                0
            (and (< (char_u (.at s i)) 0x80) (< (char_u (.at s (inc i))) 0x80)) ;; be quick for ASCII
                1
            :else
                (let [n (us-ptr2len s, i)] ;; skip over first UTF-8 char, stopping at a NUL byte
                    (if (and (== n 1) (<= 0x80 (char_u (.at s i)))) ;; check for illegal byte
                        1
                        (let [a i]
                            ;; Check for composing characters.  We can handle only the first six, but skip all of them (otherwise the cursor would get stuck).
                            (loop-when-recur [i (+ i n)] (and (<= 0x80 (char_u (.at s i))) (utf-iscomposing (us-ptr2char s i))) [(+ i (us-ptr2len s, i))] => (- i a)))
                    ))
        )))

;; Return the number of bytes the UTF-8 encoding of the character at "s[m]" takes.
;; This includes following composing characters.
;; Returns 0 for an empty string.
;; Returns 1 for an illegal char or an incomplete byte sequence.

(defn- us-ptr2len-cc-len
    ([s m] (us-ptr2len-cc-len s 0 m))
    ([s i m]
        (cond
            (or (< m 1) (eos? s i))
                0
            (and (< (char_u (.at s i)) 0x80) (or (== m 1) (< (char_u (.at s (inc i))) 0x80))) ;; be quick for ASCII
                1
            :else
                (let [n (us-ptr2len-len s, i, m)] ;; skip over first UTF-8 char, stopping at a NUL byte
                    (if (or (and (== n 1) (<= 0x80 (char_u (.at s i)))) (< m n)) ;; check for illegal byte and incomplete byte sequence
                        1
                        (let [a i m (+ i m)]
                            ;; Check for composing characters.  We can handle only the first six, but skip all of them (otherwise the cursor would get stuck).
                            (loop-when [i (+ i n)] (and (< i m) (<= 0x80 (char_u (.at s i)))) => (- i a)
                                ;; Next character length should not go beyond size to ensure that UTF_COMPOSINGLIKE(...) does not read beyond size.
                                (let [n (us-ptr2len-len s, i, (- m i))]
                                    (recur-if (and (<= n (- m i)) (utf-iscomposing (us-ptr2char s i))) [(+ i n)] => (- i a))
                                )))
                    ))
        )))

;; Return the number of bytes the UTF-8 encoding of character "c" takes.
;; This does not include composing characters.

(defn- #_int utf-char2len [#_int c]
    (cond (< c 0x80) 1 (< c 0x800) 2 (< c 0x10000) 3 (< c 0x200000) 4 (< c 0x4000000) 5 :else 6))

;; Convert Unicode character "c" to UTF-8 string in "buf[]".
;; Returns the number of bytes.
;; This does not include composing characters.

(defn- #_int utf-char2bytes [#_int c, #_Bytes buf]
    (cond
        (< c 0x80)              ;; 7 bits
        (do
            (.be buf 0, c)
            1
        )
        (< c 0x800)             ;; 11 bits
        (do
            (.be buf 0, (+ 0xc0 (>>> c 6)))
            (.be buf 1, (+ 0x80 (& c 0x3f)))
            2
        )
        (< c 0x10000)           ;; 16 bits
        (do
            (.be buf 0, (+ 0xe0 (>>> c 12)))
            (.be buf 1, (+ 0x80 (& (>>> c 6) 0x3f)))
            (.be buf 2, (+ 0x80 (& c 0x3f)))
            3
        )
        (< c 0x200000)          ;; 21 bits
        (do
            (.be buf 0, (+ 0xf0 (>>> c 18)))
            (.be buf 1, (+ 0x80 (& (>>> c 12) 0x3f)))
            (.be buf 2, (+ 0x80 (& (>>> c 6) 0x3f)))
            (.be buf 3, (+ 0x80 (& c 0x3f)))
            4
        )
        (< c 0x4000000)         ;; 26 bits
        (do
            (.be buf 0, (+ 0xf8 (>>> c 24)))
            (.be buf 1, (+ 0x80 (& (>>> c 18) 0x3f)))
            (.be buf 2, (+ 0x80 (& (>>> c 12) 0x3f)))
            (.be buf 3, (+ 0x80 (& (>>> c 6) 0x3f)))
            (.be buf 4, (+ 0x80 (& c 0x3f)))
            5
        )
        :else                   ;; 31 bits
        (do
            (.be buf 0, (+ 0xfc (>>> c 30)))
            (.be buf 1, (+ 0x80 (& (>>> c 24) 0x3f)))
            (.be buf 2, (+ 0x80 (& (>>> c 18) 0x3f)))
            (.be buf 3, (+ 0x80 (& (>>> c 12) 0x3f)))
            (.be buf 4, (+ 0x80 (& (>>> c 6) 0x3f)))
            (.be buf 5, (+ 0x80 (& c 0x3f)))
            6
        )
    ))

;; Sorted list of non-overlapping intervals.
;; Generated by tools/unicode.vim.

(final int* combining
    [
        0x0300, 0x036f,
        0x0483, 0x0489,
        0x0591, 0x05bd,
        0x05bf, 0x05bf,
        0x05c1, 0x05c2,
        0x05c4, 0x05c5,
        0x05c7, 0x05c7,
        0x0610, 0x061a,
        0x064b, 0x065f,
        0x0670, 0x0670,
        0x06d6, 0x06dc,
        0x06df, 0x06e4,
        0x06e7, 0x06e8,
        0x06ea, 0x06ed,
        0x0711, 0x0711,
        0x0730, 0x074a,
        0x07a6, 0x07b0,
        0x07eb, 0x07f3,
        0x0816, 0x0819,
        0x081b, 0x0823,
        0x0825, 0x0827,
        0x0829, 0x082d,
        0x0859, 0x085b,
        0x08e4, 0x0903,
        0x093a, 0x093c,
        0x093e, 0x094f,
        0x0951, 0x0957,
        0x0962, 0x0963,
        0x0981, 0x0983,
        0x09bc, 0x09bc,
        0x09be, 0x09c4,
        0x09c7, 0x09c8,
        0x09cb, 0x09cd,
        0x09d7, 0x09d7,
        0x09e2, 0x09e3,
        0x0a01, 0x0a03,
        0x0a3c, 0x0a3c,
        0x0a3e, 0x0a42,
        0x0a47, 0x0a48,
        0x0a4b, 0x0a4d,
        0x0a51, 0x0a51,
        0x0a70, 0x0a71,
        0x0a75, 0x0a75,
        0x0a81, 0x0a83,
        0x0abc, 0x0abc,
        0x0abe, 0x0ac5,
        0x0ac7, 0x0ac9,
        0x0acb, 0x0acd,
        0x0ae2, 0x0ae3,
        0x0b01, 0x0b03,
        0x0b3c, 0x0b3c,
        0x0b3e, 0x0b44,
        0x0b47, 0x0b48,
        0x0b4b, 0x0b4d,
        0x0b56, 0x0b57,
        0x0b62, 0x0b63,
        0x0b82, 0x0b82,
        0x0bbe, 0x0bc2,
        0x0bc6, 0x0bc8,
        0x0bca, 0x0bcd,
        0x0bd7, 0x0bd7,
        0x0c00, 0x0c03,
        0x0c3e, 0x0c44,
        0x0c46, 0x0c48,
        0x0c4a, 0x0c4d,
        0x0c55, 0x0c56,
        0x0c62, 0x0c63,
        0x0c81, 0x0c83,
        0x0cbc, 0x0cbc,
        0x0cbe, 0x0cc4,
        0x0cc6, 0x0cc8,
        0x0cca, 0x0ccd,
        0x0cd5, 0x0cd6,
        0x0ce2, 0x0ce3,
        0x0d01, 0x0d03,
        0x0d3e, 0x0d44,
        0x0d46, 0x0d48,
        0x0d4a, 0x0d4d,
        0x0d57, 0x0d57,
        0x0d62, 0x0d63,
        0x0d82, 0x0d83,
        0x0dca, 0x0dca,
        0x0dcf, 0x0dd4,
        0x0dd6, 0x0dd6,
        0x0dd8, 0x0ddf,
        0x0df2, 0x0df3,
        0x0e31, 0x0e31,
        0x0e34, 0x0e3a,
        0x0e47, 0x0e4e,
        0x0eb1, 0x0eb1,
        0x0eb4, 0x0eb9,
        0x0ebb, 0x0ebc,
        0x0ec8, 0x0ecd,
        0x0f18, 0x0f19,
        0x0f35, 0x0f35,
        0x0f37, 0x0f37,
        0x0f39, 0x0f39,
        0x0f3e, 0x0f3f,
        0x0f71, 0x0f84,
        0x0f86, 0x0f87,
        0x0f8d, 0x0f97,
        0x0f99, 0x0fbc,
        0x0fc6, 0x0fc6,
        0x102b, 0x103e,
        0x1056, 0x1059,
        0x105e, 0x1060,
        0x1062, 0x1064,
        0x1067, 0x106d,
        0x1071, 0x1074,
        0x1082, 0x108d,
        0x108f, 0x108f,
        0x109a, 0x109d,
        0x135d, 0x135f,
        0x1712, 0x1714,
        0x1732, 0x1734,
        0x1752, 0x1753,
        0x1772, 0x1773,
        0x17b4, 0x17d3,
        0x17dd, 0x17dd,
        0x180b, 0x180d,
        0x18a9, 0x18a9,
        0x1920, 0x192b,
        0x1930, 0x193b,
        0x19b0, 0x19c0,
        0x19c8, 0x19c9,
        0x1a17, 0x1a1b,
        0x1a55, 0x1a5e,
        0x1a60, 0x1a7c,
        0x1a7f, 0x1a7f,
        0x1ab0, 0x1abe,
        0x1b00, 0x1b04,
        0x1b34, 0x1b44,
        0x1b6b, 0x1b73,
        0x1b80, 0x1b82,
        0x1ba1, 0x1bad,
        0x1be6, 0x1bf3,
        0x1c24, 0x1c37,
        0x1cd0, 0x1cd2,
        0x1cd4, 0x1ce8,
        0x1ced, 0x1ced,
        0x1cf2, 0x1cf4,
        0x1cf8, 0x1cf9,
        0x1dc0, 0x1df5,
        0x1dfc, 0x1dff,
        0x20d0, 0x20f0,
        0x2cef, 0x2cf1,
        0x2d7f, 0x2d7f,
        0x2de0, 0x2dff,
        0x302a, 0x302f,
        0x3099, 0x309a,
        0xa66f, 0xa672,
        0xa674, 0xa67d,
        0xa69f, 0xa69f,
        0xa6f0, 0xa6f1,
        0xa802, 0xa802,
        0xa806, 0xa806,
        0xa80b, 0xa80b,
        0xa823, 0xa827,
        0xa880, 0xa881,
        0xa8b4, 0xa8c4,
        0xa8e0, 0xa8f1,
        0xa926, 0xa92d,
        0xa947, 0xa953,
        0xa980, 0xa983,
        0xa9b3, 0xa9c0,
        0xa9e5, 0xa9e5,
        0xaa29, 0xaa36,
        0xaa43, 0xaa43,
        0xaa4c, 0xaa4d,
        0xaa7b, 0xaa7d,
        0xaab0, 0xaab0,
        0xaab2, 0xaab4,
        0xaab7, 0xaab8,
        0xaabe, 0xaabf,
        0xaac1, 0xaac1,
        0xaaeb, 0xaaef,
        0xaaf5, 0xaaf6,
        0xabe3, 0xabea,
        0xabec, 0xabed,
        0xfb1e, 0xfb1e,
        0xfe00, 0xfe0f,
        0xfe20, 0xfe2d,
        0x101fd, 0x101fd,
        0x102e0, 0x102e0,
        0x10376, 0x1037a,
        0x10a01, 0x10a03,
        0x10a05, 0x10a06,
        0x10a0c, 0x10a0f,
        0x10a38, 0x10a3a,
        0x10a3f, 0x10a3f,
        0x10ae5, 0x10ae6,
        0x11000, 0x11002,
        0x11038, 0x11046,
        0x1107f, 0x11082,
        0x110b0, 0x110ba,
        0x11100, 0x11102,
        0x11127, 0x11134,
        0x11173, 0x11173,
        0x11180, 0x11182,
        0x111b3, 0x111c0,
        0x1122c, 0x11237,
        0x112df, 0x112ea,
        0x11301, 0x11303,
        0x1133c, 0x1133c,
        0x1133e, 0x11344,
        0x11347, 0x11348,
        0x1134b, 0x1134d,
        0x11357, 0x11357,
        0x11362, 0x11363,
        0x11366, 0x1136c,
        0x11370, 0x11374,
        0x114b0, 0x114c3,
        0x115af, 0x115b5,
        0x115b8, 0x115c0,
        0x11630, 0x11640,
        0x116ab, 0x116b7,
        0x16af0, 0x16af4,
        0x16b30, 0x16b36,
        0x16f51, 0x16f7e,
        0x16f8f, 0x16f92,
        0x1bc9d, 0x1bc9e,
        0x1d165, 0x1d169,
        0x1d16d, 0x1d172,
        0x1d17b, 0x1d182,
        0x1d185, 0x1d18b,
        0x1d1aa, 0x1d1ad,
        0x1d242, 0x1d244,
        0x1e8d0, 0x1e8d6,
        0xe0100, 0xe01ef
    ])

;; Return true if "c" is a composing UTF-8 character.
;; This means it will be drawn on top of the preceding character.

(defn- #_boolean utf-iscomposing [#_int c]
    (intable combining, c))

;; Sorted list of non-overlapping intervals.
;; 0xd800-0xdfff is reserved for UTF-16, actually illegal.

(final int* nonprint
    [
        0x070f, 0x070f,
        0x180b, 0x180e,
        0x200b, 0x200f,
        0x202a, 0x202e,
        0x206a, 0x206f,
        0xd800, 0xdfff,
        0xfeff, 0xfeff,
        0xfff9, 0xfffb,
        0xfffe, 0xffff
    ])

;; Return true for characters that can be displayed in a normal way.
;; Only for characters of 0x100 and above!

(defn- #_boolean utf-printable [#_int c]
    (not (intable nonprint, c)))

;; sorted list of non-overlapping intervals
(final int* classes
    [
        0x037e, 0x037e, 1,          ;; Greek question mark
        0x0387, 0x0387, 1,          ;; Greek ano teleia
        0x055a, 0x055f, 1,          ;; Armenian punctuation
        0x0589, 0x0589, 1,          ;; Armenian full stop
        0x05be, 0x05be, 1,
        0x05c0, 0x05c0, 1,
        0x05c3, 0x05c3, 1,
        0x05f3, 0x05f4, 1,
        0x060c, 0x060c, 1,
        0x061b, 0x061b, 1,
        0x061f, 0x061f, 1,
        0x066a, 0x066d, 1,
        0x06d4, 0x06d4, 1,
        0x0700, 0x070d, 1,          ;; Syriac punctuation
        0x0964, 0x0965, 1,
        0x0970, 0x0970, 1,
        0x0df4, 0x0df4, 1,
        0x0e4f, 0x0e4f, 1,
        0x0e5a, 0x0e5b, 1,
        0x0f04, 0x0f12, 1,
        0x0f3a, 0x0f3d, 1,
        0x0f85, 0x0f85, 1,
        0x104a, 0x104f, 1,          ;; Myanmar punctuation
        0x10fb, 0x10fb, 1,          ;; Georgian punctuation
        0x1361, 0x1368, 1,          ;; Ethiopic punctuation
        0x166d, 0x166e, 1,          ;; Canadian Syl. punctuation
        0x1680, 0x1680, 0,
        0x169b, 0x169c, 1,
        0x16eb, 0x16ed, 1,
        0x1735, 0x1736, 1,
        0x17d4, 0x17dc, 1,          ;; Khmer punctuation
        0x1800, 0x180a, 1,          ;; Mongolian punctuation
        0x2000, 0x200b, 0,          ;; spaces
        0x200c, 0x2027, 1,          ;; punctuation and symbols
        0x2028, 0x2029, 0,
        0x202a, 0x202e, 1,          ;; punctuation and symbols
        0x202f, 0x202f, 0,
        0x2030, 0x205e, 1,          ;; punctuation and symbols
        0x205f, 0x205f, 0,
        0x2060, 0x27ff, 1,          ;; punctuation and symbols
        0x2070, 0x207f, 0x2070,     ;; superscript
        0x2080, 0x2094, 0x2080,     ;; subscript
        0x20a0, 0x27ff, 1,          ;; all kinds of symbols
        0x2800, 0x28ff, 0x2800,     ;; braille
        0x2900, 0x2998, 1,          ;; arrows, brackets, etc.
        0x29d8, 0x29db, 1,
        0x29fc, 0x29fd, 1,
        0x2e00, 0x2e7f, 1,          ;; supplemental punctuation
        0x3000, 0x3000, 0,          ;; ideographic space
        0x3001, 0x3020, 1,          ;; ideographic punctuation
        0x3030, 0x3030, 1,
        0x303d, 0x303d, 1,
        0x3040, 0x309f, 0x3040,     ;; Hiragana
        0x30a0, 0x30ff, 0x30a0,     ;; Katakana
        0x3300, 0x9fff, 0x4e00,     ;; CJK Ideographs
        0xac00, 0xd7a3, 0xac00,     ;; Hangul Syllables
        0xf900, 0xfaff, 0x4e00,     ;; CJK Ideographs
        0xfd3e, 0xfd3f, 1,
        0xfe30, 0xfe6b, 1,          ;; punctuation forms
        0xff00, 0xff0f, 1,          ;; half/fullwidth ASCII
        0xff1a, 0xff20, 1,          ;; half/fullwidth ASCII
        0xff3b, 0xff40, 1,          ;; half/fullwidth ASCII
        0xff5b, 0xff65, 1,          ;; half/fullwidth ASCII
        0x20000, 0x2a6df, 0x4e00,   ;; CJK Ideographs
        0x2a700, 0x2b73f, 0x4e00,   ;; CJK Ideographs
        0x2b740, 0x2b81f, 0x4e00,   ;; CJK Ideographs
        0x2f800, 0x2fa1f, 0x4e00    ;; CJK Ideographs
    ])

;; Get class of a Unicode character.
;;  0: white space
;;  1: punctuation
;;  2 or bigger: some class of word character.

(defn- #_int utf-class [#_int c]
    (if (< c 0x100) ;; first quick check for Latin1 characters, use 'iskeyword'
        (cond (any == c (byte \space) TAB NUL 0xa0) 0 (vim-iswordc c) 2 :else 1)    ;; blank ;; word character ;; punctuation
        (loop-when [bot 0 top (dec (/ (:length classes) 3))] (<= bot top) => 2      ;; most other characters are "word" characters
            (let [mid (/ (+ bot top) 2)]
                (cond
                    (<    (... classes (inc (* 3 mid))) c) (recur (inc mid) top)
                    (< c  (... classes      (* 3 mid)))    (recur bot (dec mid))
                    :else (... classes (+   (* 3 mid) 2))
                )))
    ))

;; Code for Unicode case-dependent operations.  Based on notes in
;; http://www.unicode.org/Public/UNIDATA/CaseFolding.txt
;; This code uses simple case folding, not full case folding.
;; Last updated for Unicode 5.2.

;; Generic conversion function for case operations.
;; Return the converted equivalent of "c", which is a UCS-4 character.
;; Use the given conversion "table".
;; Uses binary search on "table".

(defn- #_int utf-convert [#_int c, #_int* table]
    (let [start 0 entries (/ (:length table) 4)
          start (loop-when [start start end entries] (< start end) => start
                    (let [mid (/ (+ start end) 2)] (if (< (... table (inc (* 4 mid))) c) (recur (inc mid) end) (recur start mid)))
                )]
        (if (< start entries)
            (let [i (* 4 start)]
                (if (and (<= (... table i) c) (<= c (... table (inc i))) (zero? (% (- c (... table i)) (... table (+ i 2)))))
                    (+ c (... table (+ i 3)))
                    c
                ))
            c)
    ))

;; The following tables are built by tools/unicode.vim.
;; They must be in numeric order, because we use binary search.
;; An entry such as {0x41,0x5a,1,32} means that Unicode characters in the range from 0x41 to 0x5a inclusive,
;; stepping by 1, are changed to folded/upper/lower by adding 32.

(final int* foldCase
    [
        0x41, 0x5a, 1, 32,
        0xb5, 0xb5,-1, 775,
        0xc0, 0xd6, 1, 32,
        0xd8, 0xde, 1, 32,
        0x100, 0x12e, 2, 1,
        0x132, 0x136, 2, 1,
        0x139, 0x147, 2, 1,
        0x14a, 0x176, 2, 1,
        0x178, 0x178,-1,-121,
        0x179, 0x17d, 2, 1,
        0x17f, 0x17f,-1,-268,
        0x181, 0x181,-1, 210,
        0x182, 0x184, 2, 1,
        0x186, 0x186,-1, 206,
        0x187, 0x187,-1, 1,
        0x189, 0x18a, 1, 205,
        0x18b, 0x18b,-1, 1,
        0x18e, 0x18e,-1, 79,
        0x18f, 0x18f,-1, 202,
        0x190, 0x190,-1, 203,
        0x191, 0x191,-1, 1,
        0x193, 0x193,-1, 205,
        0x194, 0x194,-1, 207,
        0x196, 0x196,-1, 211,
        0x197, 0x197,-1, 209,
        0x198, 0x198,-1, 1,
        0x19c, 0x19c,-1, 211,
        0x19d, 0x19d,-1, 213,
        0x19f, 0x19f,-1, 214,
        0x1a0, 0x1a4, 2, 1,
        0x1a6, 0x1a6,-1, 218,
        0x1a7, 0x1a7,-1, 1,
        0x1a9, 0x1a9,-1, 218,
        0x1ac, 0x1ac,-1, 1,
        0x1ae, 0x1ae,-1, 218,
        0x1af, 0x1af,-1, 1,
        0x1b1, 0x1b2, 1, 217,
        0x1b3, 0x1b5, 2, 1,
        0x1b7, 0x1b7,-1, 219,
        0x1b8, 0x1bc, 4, 1,
        0x1c4, 0x1c4,-1, 2,
        0x1c5, 0x1c5,-1, 1,
        0x1c7, 0x1c7,-1, 2,
        0x1c8, 0x1c8,-1, 1,
        0x1ca, 0x1ca,-1, 2,
        0x1cb, 0x1db, 2, 1,
        0x1de, 0x1ee, 2, 1,
        0x1f1, 0x1f1,-1, 2,
        0x1f2, 0x1f4, 2, 1,
        0x1f6, 0x1f6,-1,-97,
        0x1f7, 0x1f7,-1,-56,
        0x1f8, 0x21e, 2, 1,
        0x220, 0x220,-1,-130,
        0x222, 0x232, 2, 1,
        0x23a, 0x23a,-1, 10795,
        0x23b, 0x23b,-1, 1,
        0x23d, 0x23d,-1,-163,
        0x23e, 0x23e,-1, 10792,
        0x241, 0x241,-1, 1,
        0x243, 0x243,-1,-195,
        0x244, 0x244,-1, 69,
        0x245, 0x245,-1, 71,
        0x246, 0x24e, 2, 1,
        0x345, 0x345,-1, 116,
        0x370, 0x372, 2, 1,
        0x376, 0x376,-1, 1,
        0x37f, 0x37f,-1, 116,
        0x386, 0x386,-1, 38,
        0x388, 0x38a, 1, 37,
        0x38c, 0x38c,-1, 64,
        0x38e, 0x38f, 1, 63,
        0x391, 0x3a1, 1, 32,
        0x3a3, 0x3ab, 1, 32,
        0x3c2, 0x3c2,-1, 1,
        0x3cf, 0x3cf,-1, 8,
        0x3d0, 0x3d0,-1,-30,
        0x3d1, 0x3d1,-1,-25,
        0x3d5, 0x3d5,-1,-15,
        0x3d6, 0x3d6,-1,-22,
        0x3d8, 0x3ee, 2, 1,
        0x3f0, 0x3f0,-1,-54,
        0x3f1, 0x3f1,-1,-48,
        0x3f4, 0x3f4,-1,-60,
        0x3f5, 0x3f5,-1,-64,
        0x3f7, 0x3f7,-1, 1,
        0x3f9, 0x3f9,-1,-7,
        0x3fa, 0x3fa,-1, 1,
        0x3fd, 0x3ff, 1,-130,
        0x400, 0x40f, 1, 80,
        0x410, 0x42f, 1, 32,
        0x460, 0x480, 2, 1,
        0x48a, 0x4be, 2, 1,
        0x4c0, 0x4c0,-1, 15,
        0x4c1, 0x4cd, 2, 1,
        0x4d0, 0x52e, 2, 1,
        0x531, 0x556, 1, 48,
        0x10a0, 0x10c5, 1, 7264,
        0x10c7, 0x10cd, 6, 7264,
        0x1e00, 0x1e94, 2, 1,
        0x1e9b, 0x1e9b,-1,-58,
        0x1e9e, 0x1e9e,-1,-7615,
        0x1ea0, 0x1efe, 2, 1,
        0x1f08, 0x1f0f, 1,-8,
        0x1f18, 0x1f1d, 1,-8,
        0x1f28, 0x1f2f, 1,-8,
        0x1f38, 0x1f3f, 1,-8,
        0x1f48, 0x1f4d, 1,-8,
        0x1f59, 0x1f5f, 2,-8,
        0x1f68, 0x1f6f, 1,-8,
        0x1f88, 0x1f8f, 1,-8,
        0x1f98, 0x1f9f, 1,-8,
        0x1fa8, 0x1faf, 1,-8,
        0x1fb8, 0x1fb9, 1,-8,
        0x1fba, 0x1fbb, 1,-74,
        0x1fbc, 0x1fbc,-1,-9,
        0x1fbe, 0x1fbe,-1,-7173,
        0x1fc8, 0x1fcb, 1,-86,
        0x1fcc, 0x1fcc,-1,-9,
        0x1fd8, 0x1fd9, 1,-8,
        0x1fda, 0x1fdb, 1,-100,
        0x1fe8, 0x1fe9, 1,-8,
        0x1fea, 0x1feb, 1,-112,
        0x1fec, 0x1fec,-1,-7,
        0x1ff8, 0x1ff9, 1,-128,
        0x1ffa, 0x1ffb, 1,-126,
        0x1ffc, 0x1ffc,-1,-9,
        0x2126, 0x2126,-1,-7517,
        0x212a, 0x212a,-1,-8383,
        0x212b, 0x212b,-1,-8262,
        0x2132, 0x2132,-1, 28,
        0x2160, 0x216f, 1, 16,
        0x2183, 0x2183,-1, 1,
        0x24b6, 0x24cf, 1, 26,
        0x2c00, 0x2c2e, 1, 48,
        0x2c60, 0x2c60,-1, 1,
        0x2c62, 0x2c62,-1,-10743,
        0x2c63, 0x2c63,-1,-3814,
        0x2c64, 0x2c64,-1,-10727,
        0x2c67, 0x2c6b, 2, 1,
        0x2c6d, 0x2c6d,-1,-10780,
        0x2c6e, 0x2c6e,-1,-10749,
        0x2c6f, 0x2c6f,-1,-10783,
        0x2c70, 0x2c70,-1,-10782,
        0x2c72, 0x2c75, 3, 1,
        0x2c7e, 0x2c7f, 1,-10815,
        0x2c80, 0x2ce2, 2, 1,
        0x2ceb, 0x2ced, 2, 1,
        0x2cf2, 0xa640, 31054, 1,
        0xa642, 0xa66c, 2, 1,
        0xa680, 0xa69a, 2, 1,
        0xa722, 0xa72e, 2, 1,
        0xa732, 0xa76e, 2, 1,
        0xa779, 0xa77b, 2, 1,
        0xa77d, 0xa77d,-1,-35332,
        0xa77e, 0xa786, 2, 1,
        0xa78b, 0xa78b,-1, 1,
        0xa78d, 0xa78d,-1,-42280,
        0xa790, 0xa792, 2, 1,
        0xa796, 0xa7a8, 2, 1,
        0xa7aa, 0xa7aa,-1,-42308,
        0xa7ab, 0xa7ab,-1,-42319,
        0xa7ac, 0xa7ac,-1,-42315,
        0xa7ad, 0xa7ad,-1,-42305,
        0xa7b0, 0xa7b0,-1,-42258,
        0xa7b1, 0xa7b1,-1,-42282,
        0xff21, 0xff3a, 1, 32,
        0x10400, 0x10427, 1, 40,
        0x118a0, 0x118bf, 1, 32
    ])

;; Return the folded-case equivalent of "c", which is a UCS-4 character.  Uses simple case folding.

(defn- #_int utf-fold [#_int c]
    (utf-convert c, foldCase))

(final int* toLower
    [
        0x41, 0x5a, 1, 32,
        0xc0, 0xd6, 1, 32,
        0xd8, 0xde, 1, 32,
        0x100, 0x12e, 2, 1,
        0x130, 0x130,-1,-199,
        0x132, 0x136, 2, 1,
        0x139, 0x147, 2, 1,
        0x14a, 0x176, 2, 1,
        0x178, 0x178,-1,-121,
        0x179, 0x17d, 2, 1,
        0x181, 0x181,-1, 210,
        0x182, 0x184, 2, 1,
        0x186, 0x186,-1, 206,
        0x187, 0x187,-1, 1,
        0x189, 0x18a, 1, 205,
        0x18b, 0x18b,-1, 1,
        0x18e, 0x18e,-1, 79,
        0x18f, 0x18f,-1, 202,
        0x190, 0x190,-1, 203,
        0x191, 0x191,-1, 1,
        0x193, 0x193,-1, 205,
        0x194, 0x194,-1, 207,
        0x196, 0x196,-1, 211,
        0x197, 0x197,-1, 209,
        0x198, 0x198,-1, 1,
        0x19c, 0x19c,-1, 211,
        0x19d, 0x19d,-1, 213,
        0x19f, 0x19f,-1, 214,
        0x1a0, 0x1a4, 2, 1,
        0x1a6, 0x1a6,-1, 218,
        0x1a7, 0x1a7,-1, 1,
        0x1a9, 0x1a9,-1, 218,
        0x1ac, 0x1ac,-1, 1,
        0x1ae, 0x1ae,-1, 218,
        0x1af, 0x1af,-1, 1,
        0x1b1, 0x1b2, 1, 217,
        0x1b3, 0x1b5, 2, 1,
        0x1b7, 0x1b7,-1, 219,
        0x1b8, 0x1bc, 4, 1,
        0x1c4, 0x1c4,-1, 2,
        0x1c5, 0x1c5,-1, 1,
        0x1c7, 0x1c7,-1, 2,
        0x1c8, 0x1c8,-1, 1,
        0x1ca, 0x1ca,-1, 2,
        0x1cb, 0x1db, 2, 1,
        0x1de, 0x1ee, 2, 1,
        0x1f1, 0x1f1,-1, 2,
        0x1f2, 0x1f4, 2, 1,
        0x1f6, 0x1f6,-1,-97,
        0x1f7, 0x1f7,-1,-56,
        0x1f8, 0x21e, 2, 1,
        0x220, 0x220,-1,-130,
        0x222, 0x232, 2, 1,
        0x23a, 0x23a,-1, 10795,
        0x23b, 0x23b,-1, 1,
        0x23d, 0x23d,-1,-163,
        0x23e, 0x23e,-1, 10792,
        0x241, 0x241,-1, 1,
        0x243, 0x243,-1,-195,
        0x244, 0x244,-1, 69,
        0x245, 0x245,-1, 71,
        0x246, 0x24e, 2, 1,
        0x370, 0x372, 2, 1,
        0x376, 0x376,-1, 1,
        0x37f, 0x37f,-1, 116,
        0x386, 0x386,-1, 38,
        0x388, 0x38a, 1, 37,
        0x38c, 0x38c,-1, 64,
        0x38e, 0x38f, 1, 63,
        0x391, 0x3a1, 1, 32,
        0x3a3, 0x3ab, 1, 32,
        0x3cf, 0x3cf,-1, 8,
        0x3d8, 0x3ee, 2, 1,
        0x3f4, 0x3f4,-1,-60,
        0x3f7, 0x3f7,-1, 1,
        0x3f9, 0x3f9,-1,-7,
        0x3fa, 0x3fa,-1, 1,
        0x3fd, 0x3ff, 1,-130,
        0x400, 0x40f, 1, 80,
        0x410, 0x42f, 1, 32,
        0x460, 0x480, 2, 1,
        0x48a, 0x4be, 2, 1,
        0x4c0, 0x4c0,-1, 15,
        0x4c1, 0x4cd, 2, 1,
        0x4d0, 0x52e, 2, 1,
        0x531, 0x556, 1, 48,
        0x10a0, 0x10c5, 1, 7264,
        0x10c7, 0x10cd, 6, 7264,
        0x1e00, 0x1e94, 2, 1,
        0x1e9e, 0x1e9e,-1,-7615,
        0x1ea0, 0x1efe, 2, 1,
        0x1f08, 0x1f0f, 1,-8,
        0x1f18, 0x1f1d, 1,-8,
        0x1f28, 0x1f2f, 1,-8,
        0x1f38, 0x1f3f, 1,-8,
        0x1f48, 0x1f4d, 1,-8,
        0x1f59, 0x1f5f, 2,-8,
        0x1f68, 0x1f6f, 1,-8,
        0x1f88, 0x1f8f, 1,-8,
        0x1f98, 0x1f9f, 1,-8,
        0x1fa8, 0x1faf, 1,-8,
        0x1fb8, 0x1fb9, 1,-8,
        0x1fba, 0x1fbb, 1,-74,
        0x1fbc, 0x1fbc,-1,-9,
        0x1fc8, 0x1fcb, 1,-86,
        0x1fcc, 0x1fcc,-1,-9,
        0x1fd8, 0x1fd9, 1,-8,
        0x1fda, 0x1fdb, 1,-100,
        0x1fe8, 0x1fe9, 1,-8,
        0x1fea, 0x1feb, 1,-112,
        0x1fec, 0x1fec,-1,-7,
        0x1ff8, 0x1ff9, 1,-128,
        0x1ffa, 0x1ffb, 1,-126,
        0x1ffc, 0x1ffc,-1,-9,
        0x2126, 0x2126,-1,-7517,
        0x212a, 0x212a,-1,-8383,
        0x212b, 0x212b,-1,-8262,
        0x2132, 0x2132,-1, 28,
        0x2160, 0x216f, 1, 16,
        0x2183, 0x2183,-1, 1,
        0x24b6, 0x24cf, 1, 26,
        0x2c00, 0x2c2e, 1, 48,
        0x2c60, 0x2c60,-1, 1,
        0x2c62, 0x2c62,-1,-10743,
        0x2c63, 0x2c63,-1,-3814,
        0x2c64, 0x2c64,-1,-10727,
        0x2c67, 0x2c6b, 2, 1,
        0x2c6d, 0x2c6d,-1,-10780,
        0x2c6e, 0x2c6e,-1,-10749,
        0x2c6f, 0x2c6f,-1,-10783,
        0x2c70, 0x2c70,-1,-10782,
        0x2c72, 0x2c75, 3, 1,
        0x2c7e, 0x2c7f, 1,-10815,
        0x2c80, 0x2ce2, 2, 1,
        0x2ceb, 0x2ced, 2, 1,
        0x2cf2, 0xa640, 31054, 1,
        0xa642, 0xa66c, 2, 1,
        0xa680, 0xa69a, 2, 1,
        0xa722, 0xa72e, 2, 1,
        0xa732, 0xa76e, 2, 1,
        0xa779, 0xa77b, 2, 1,
        0xa77d, 0xa77d,-1,-35332,
        0xa77e, 0xa786, 2, 1,
        0xa78b, 0xa78b,-1, 1,
        0xa78d, 0xa78d,-1,-42280,
        0xa790, 0xa792, 2, 1,
        0xa796, 0xa7a8, 2, 1,
        0xa7aa, 0xa7aa,-1,-42308,
        0xa7ab, 0xa7ab,-1,-42319,
        0xa7ac, 0xa7ac,-1,-42315,
        0xa7ad, 0xa7ad,-1,-42305,
        0xa7b0, 0xa7b0,-1,-42258,
        0xa7b1, 0xa7b1,-1,-42282,
        0xff21, 0xff3a, 1, 32,
        0x10400, 0x10427, 1, 40,
        0x118a0, 0x118bf, 1, 32
    ])

(final int* toUpper
    [
        0x61, 0x7a, 1,-32,
        0xb5, 0xb5,-1, 743,
        0xe0, 0xf6, 1,-32,
        0xf8, 0xfe, 1,-32,
        0xff, 0xff,-1, 121,
        0x101, 0x12f, 2,-1,
        0x131, 0x131,-1,-232,
        0x133, 0x137, 2,-1,
        0x13a, 0x148, 2,-1,
        0x14b, 0x177, 2,-1,
        0x17a, 0x17e, 2,-1,
        0x17f, 0x17f,-1,-300,
        0x180, 0x180,-1, 195,
        0x183, 0x185, 2,-1,
        0x188, 0x18c, 4,-1,
        0x192, 0x192,-1,-1,
        0x195, 0x195,-1, 97,
        0x199, 0x199,-1,-1,
        0x19a, 0x19a,-1, 163,
        0x19e, 0x19e,-1, 130,
        0x1a1, 0x1a5, 2,-1,
        0x1a8, 0x1ad, 5,-1,
        0x1b0, 0x1b4, 4,-1,
        0x1b6, 0x1b9, 3,-1,
        0x1bd, 0x1bd,-1,-1,
        0x1bf, 0x1bf,-1, 56,
        0x1c5, 0x1c5,-1,-1,
        0x1c6, 0x1c6,-1,-2,
        0x1c8, 0x1c8,-1,-1,
        0x1c9, 0x1c9,-1,-2,
        0x1cb, 0x1cb,-1,-1,
        0x1cc, 0x1cc,-1,-2,
        0x1ce, 0x1dc, 2,-1,
        0x1dd, 0x1dd,-1,-79,
        0x1df, 0x1ef, 2,-1,
        0x1f2, 0x1f2,-1,-1,
        0x1f3, 0x1f3,-1,-2,
        0x1f5, 0x1f9, 4,-1,
        0x1fb, 0x21f, 2,-1,
        0x223, 0x233, 2,-1,
        0x23c, 0x23c,-1,-1,
        0x23f, 0x240, 1, 10815,
        0x242, 0x247, 5,-1,
        0x249, 0x24f, 2,-1,
        0x250, 0x250,-1, 10783,
        0x251, 0x251,-1, 10780,
        0x252, 0x252,-1, 10782,
        0x253, 0x253,-1,-210,
        0x254, 0x254,-1,-206,
        0x256, 0x257, 1,-205,
        0x259, 0x259,-1,-202,
        0x25b, 0x25b,-1,-203,
        0x25c, 0x25c,-1, 42319,
        0x260, 0x260,-1,-205,
        0x261, 0x261,-1, 42315,
        0x263, 0x263,-1,-207,
        0x265, 0x265,-1, 42280,
        0x266, 0x266,-1, 42308,
        0x268, 0x268,-1,-209,
        0x269, 0x269,-1,-211,
        0x26b, 0x26b,-1, 10743,
        0x26c, 0x26c,-1, 42305,
        0x26f, 0x26f,-1,-211,
        0x271, 0x271,-1, 10749,
        0x272, 0x272,-1,-213,
        0x275, 0x275,-1,-214,
        0x27d, 0x27d,-1, 10727,
        0x280, 0x283, 3,-218,
        0x287, 0x287,-1, 42282,
        0x288, 0x288,-1,-218,
        0x289, 0x289,-1,-69,
        0x28a, 0x28b, 1,-217,
        0x28c, 0x28c,-1,-71,
        0x292, 0x292,-1,-219,
        0x29e, 0x29e,-1, 42258,
        0x345, 0x345,-1, 84,
        0x371, 0x373, 2,-1,
        0x377, 0x377,-1,-1,
        0x37b, 0x37d, 1, 130,
        0x3ac, 0x3ac,-1,-38,
        0x3ad, 0x3af, 1,-37,
        0x3b1, 0x3c1, 1,-32,
        0x3c2, 0x3c2,-1,-31,
        0x3c3, 0x3cb, 1,-32,
        0x3cc, 0x3cc,-1,-64,
        0x3cd, 0x3ce, 1,-63,
        0x3d0, 0x3d0,-1,-62,
        0x3d1, 0x3d1,-1,-57,
        0x3d5, 0x3d5,-1,-47,
        0x3d6, 0x3d6,-1,-54,
        0x3d7, 0x3d7,-1,-8,
        0x3d9, 0x3ef, 2,-1,
        0x3f0, 0x3f0,-1,-86,
        0x3f1, 0x3f1,-1,-80,
        0x3f2, 0x3f2,-1, 7,
        0x3f3, 0x3f3,-1,-116,
        0x3f5, 0x3f5,-1,-96,
        0x3f8, 0x3fb, 3,-1,
        0x430, 0x44f, 1,-32,
        0x450, 0x45f, 1,-80,
        0x461, 0x481, 2,-1,
        0x48b, 0x4bf, 2,-1,
        0x4c2, 0x4ce, 2,-1,
        0x4cf, 0x4cf,-1,-15,
        0x4d1, 0x52f, 2,-1,
        0x561, 0x586, 1,-48,
        0x1d79, 0x1d79,-1, 35332,
        0x1d7d, 0x1d7d,-1, 3814,
        0x1e01, 0x1e95, 2,-1,
        0x1e9b, 0x1e9b,-1,-59,
        0x1ea1, 0x1eff, 2,-1,
        0x1f00, 0x1f07, 1, 8,
        0x1f10, 0x1f15, 1, 8,
        0x1f20, 0x1f27, 1, 8,
        0x1f30, 0x1f37, 1, 8,
        0x1f40, 0x1f45, 1, 8,
        0x1f51, 0x1f57, 2, 8,
        0x1f60, 0x1f67, 1, 8,
        0x1f70, 0x1f71, 1, 74,
        0x1f72, 0x1f75, 1, 86,
        0x1f76, 0x1f77, 1, 100,
        0x1f78, 0x1f79, 1, 128,
        0x1f7a, 0x1f7b, 1, 112,
        0x1f7c, 0x1f7d, 1, 126,
        0x1f80, 0x1f87, 1, 8,
        0x1f90, 0x1f97, 1, 8,
        0x1fa0, 0x1fa7, 1, 8,
        0x1fb0, 0x1fb1, 1, 8,
        0x1fb3, 0x1fb3,-1, 9,
        0x1fbe, 0x1fbe,-1,-7205,
        0x1fc3, 0x1fc3,-1, 9,
        0x1fd0, 0x1fd1, 1, 8,
        0x1fe0, 0x1fe1, 1, 8,
        0x1fe5, 0x1fe5,-1, 7,
        0x1ff3, 0x1ff3,-1, 9,
        0x214e, 0x214e,-1,-28,
        0x2170, 0x217f, 1,-16,
        0x2184, 0x2184,-1,-1,
        0x24d0, 0x24e9, 1,-26,
        0x2c30, 0x2c5e, 1,-48,
        0x2c61, 0x2c61,-1,-1,
        0x2c65, 0x2c65,-1,-10795,
        0x2c66, 0x2c66,-1,-10792,
        0x2c68, 0x2c6c, 2,-1,
        0x2c73, 0x2c76, 3,-1,
        0x2c81, 0x2ce3, 2,-1,
        0x2cec, 0x2cee, 2,-1,
        0x2cf3, 0x2cf3,-1,-1,
        0x2d00, 0x2d25, 1,-7264,
        0x2d27, 0x2d2d, 6,-7264,
        0xa641, 0xa66d, 2,-1,
        0xa681, 0xa69b, 2,-1,
        0xa723, 0xa72f, 2,-1,
        0xa733, 0xa76f, 2,-1,
        0xa77a, 0xa77c, 2,-1,
        0xa77f, 0xa787, 2,-1,
        0xa78c, 0xa791, 5,-1,
        0xa793, 0xa797, 4,-1,
        0xa799, 0xa7a9, 2,-1,
        0xff41, 0xff5a, 1,-32,
        0x10428, 0x1044f, 1,-40,
        0x118c0, 0x118df, 1,-32
    ])

;; Return the lower-case equivalent of "c", which is a UCS-4 character.  Use simple case folding.

(defn- #_int utf-tolower [#_int c]
    (if (< c 0x80) (asc_tolower c) (utf-convert c, toLower)))

;; Return the upper-case equivalent of "c", which is a UCS-4 character.  Use simple case folding.

(defn- #_int utf-toupper [#_int c]
    (if (< c 0x80) (asc_toupper c) (utf-convert c, toUpper)))

(defn- #_boolean utf-islower [#_int c]
    (if (< c 0x80) (asc-islower c) (or (!= (utf-toupper c) c) (== c 0xdf)))) ;; German sharp s is lower case but has no upper case equivalent.

(defn- #_boolean utf-isupper [#_int c]
    (if (< c 0x80) (asc-isupper c) (!= (utf-tolower c) c)))

(defn- #_int us--strnicmp [#_Bytes _s1, #_Bytes _s2, #_int _n1, #_int _n2]
    (let [a's1 (atom (#_Bytes object _s1)) a'n1 (atom (int _n1))
          a's2 (atom (#_Bytes object _s2)) a'n2 (atom (int _n2))
          [#_int c1 #_int c2 #_int cmp]
            (loop [] (let [c1 (us-safe-read-char-adv a's1, a'n1) c2 (us-safe-read-char-adv a's2, a'n2)]
                (cond
                    (or (<= c1 0) (<= c2 0)) [c1 c2 nil]
                    (== c1 c2) (recur)
                    :else (let [cmp (- (utf-fold c1) (utf-fold c2))] (if (zero? cmp) (recur) [c1 c2 cmp]))
                )
            ))]
        (cond (some? cmp)
            cmp
        (or (zero? c1) (zero? c2)) ;; some string ended: shorter string is smaller
            (if (and (zero? c1) (zero? c2)) 0 (if (zero? c1) -1 1))
        :else ;; some string has an incomplete/illegal character sequence
            (do
                ;; Continue with bytewise comparison to produce some result that
                ;; would make comparison operations involving this function transitive.
                ;;
                ;; If only one string had an error, comparison should be made with
                ;; folded version of the other string.  In this case it is enough
                ;; to fold just one character to determine the result of comparison.

                (let [#_Bytes buf (Bytes. 6)]
                    (cond
                        (and (!= c1 -1) (== c2 -1)) (do (reset! a'n1 (utf-char2bytes (utf-fold c1), buf)) (reset! a's1 buf))
                        (and (!= c2 -1) (== c1 -1)) (do (reset! a'n2 (utf-char2bytes (utf-fold c2), buf)) (reset! a's2 buf))
                    ))

                (let [cmp (loop-when [] (and (< 0 @a'n1) (< 0 @a'n2) (non-eos? @a's1) (non-eos? @a's2)) => nil
                            (let [cmp (- (.at @a's1 0) (.at @a's2 0))]
                                (if (zero? cmp) (do (swap! a's1 plus 1) (swap! a's2 plus 1) (swap! a'n1 dec) (swap! a'n2 dec) (recur)) cmp)
                            ))]
                    (if (some? cmp)
                        cmp
                        (do
                            (when (and (< 0 @a'n1) (eos? @a's1)) (reset! a'n1 0))
                            (when (and (< 0 @a'n2) (eos? @a's2)) (reset! a'n2 0))
                            (if (and (zero? @a'n1) (zero? @a'n2)) 0 (if (zero? @a'n1) -1 1)))
                    ))
            ))
    ))

;; Version of strnicmp() that handles multi-byte characters.
;; Needed for Big5, Shift-JIS and UTF-8 encoding.
;; Returns zero if s1 and s2 are equal (ignoring case),
;; the difference between two characters otherwise.

(defn- #_int us-strnicmp [#_Bytes s1, #_Bytes s2, #_int nn]
    (us--strnicmp s1, s2, nn, nn))

;; "g8": show bytes of the UTF-8 char under the cursor.

(defn- #_void show-utf8 [#_window_C win]
    (let [#_Bytes s (ml-get-cursor win) #_int n (us-ptr2len-cc s)]
        (if (zero? n)
            (msg (u8 "NUL"))
            (let [#_Bytes buf (Bytes. IOSIZE)]
                (loop-when [#_int clen 0 #_int rlen 0 #_int i 0] (< i n)
                    (let [[clen rlen]
                            (if (zero? clen) ;; start of (composing) character, get its length
                                [(us-ptr2len s, i) (if (< 0 i) (do (STRCPY (.plus buf rlen), (u8 "+ ")) (+ rlen 2)) rlen)]
                                [clen rlen]
                            )]
;%%                     (.sprintf libC (.plus buf rlen), (u8 "%02x "), (if (at? s i NL) NUL (.at s i))) ;; NUL is stored as NL
                        (let [rlen (+ rlen (STRLEN buf, rlen))]
                            (when-not (< (- IOSIZE 20) rlen) (recur (dec clen) rlen (inc i))))
                    ))
                (msg buf))
        ))
    nil)

(defn- #_int us-head-off [#_Bytes base, #_Bytes p]
    (if (< (char_u (.at p 0)) 0x80)        ;; be quick for ASCII
        0
        ;; Skip backwards over trailing bytes: 10xx.xxxx.
        ;; Skip backwards again if on a composing char.
        (loop [#_Bytes q p]
            ;; Move 's' to the last byte of this char.
            (let [#_Bytes s (loop-when-recur [s q] (== (& (char_u (.at s 1)) 0xc0) 0x80) [(.plus s 1)] => s)
                  ;; Move 'q' to the first byte of this char.
                  q (loop-when-recur q (and (BLT base, q) (== (& (char_u (.at q 0)) 0xc0) 0x80)) [(.minus q 1)] => q)
                  ;; Check for illegal sequence.  Do allow an illegal byte after where we started.
                  #_int n (us-byte2len (.at q 0), false)]
                (cond
                    (and (!= n (inc (BDIFF s, q))) (!= n (inc (BDIFF p, q)))) 0
                    (or (BLE q, base) (not (utf-iscomposing (us-ptr2char q)))) (BDIFF p, q)
                    :else (recur (.minus q 1))
                ))
        )
    ))

;; Return the offset from "p" to the first byte of a character.  When "p" is
;; at the start of a character 0 is returned, otherwise the offset to the next
;; character.  Can start anywhere in a stream of bytes.

(defn- #_int us-off-next [#_Bytes base, #_Bytes p]
    (if (< (char_u (.at p 0)) 0x80)        ;; be quick for ASCII
        0
        ;; Find the next character that isn't 10xx.xxxx.
        (let-when [#_int i (loop-when-recur [i 0] (== (& (char_u (.at p i)) 0xc0) 0x80) [(inc i)] => i)] (< 0 i) => i
            ;; Check for illegal sequence.
            (let [#_int j (loop-when-recur [j 0] (and (BLT base, (.minus p j)) (== (& (char_u (.at p (- j))) 0xc0) 0x80)) [(inc j)] => j)]
                (if (== (us-byte2len (.at p (- j)), false) (+ i j)) i 0)
            ))
    ))

;; Return the offset from "p" to the last byte of the character it points into.
;; Can start anywhere in a stream of bytes.

(defn- #_int us-tail-off [#_Bytes base, #_Bytes p]
    (if (eos? p)
        0
        ;; Find the last character that is 10xx.xxxx.
        (let [#_int i (loop-when-recur [i 0] (== (& (char_u (.at p (inc i))) 0xc0) 0x80) [(inc i)] => i)
              ;; Check for illegal sequence.
              #_int j (loop-when-recur [j 0] (and (BLT base, (.minus p j)) (== (& (char_u (.at p (- j))) 0xc0) 0x80)) [(inc j)] => j)]
            (if (== (us-byte2len (.at p (- j)), false) (+ i j 1)) i 0)
        )
    ))

;; Find the next illegal byte sequence.

(defn- #_window_C utf-find-illegal [#_window_C win]
    (let-when [lmax (line-count @curbuf)
        win' (loop [lnum (:lnum (:w_cursor win)) col (:col (:w_cursor win))]
                (let-when [s (ml-get lnum)
                    win' (loop-when [i col] (non-eos? s i) => nil
                            ;; Illegal means that there are not enough trail bytes or too many of them (overlong sequence).
                            (let [n (us-ptr2len s, i)]
                                (if (and (<= 0x80 (char_u (.at s i))) (or (== n 1) (!= (utf-char2len (us-ptr2char s, i)) n)))
                                    (assoc win :w_cursor (->pos_C lnum i 0))
                                    (recur (+ i n))
                                ))
                        )] (nil? win') => win'
                    (recur-if (< lnum lmax) [(inc lnum) 0] => nil))
            )] (nil? win') => win'
        ;; didn't find it: don't move and beep
        (beep-flush)
        win
    ))

;; Adjust position to point to the first byte of a multi-byte character.
;; If it points to the tail byte, it's moved backwards to the head byte.

(defn- #_pos_C mb-adjust-pos [#_pos_C pos]
    (if (or (< 0 (:col pos)) (< 1 (:coladd pos)))
        (let [#_Bytes s (ml-get (:lnum pos)) pos (update pos :col #(- % (us-head-off s, (.plus s %))))]
            ;; Reset "coladd" when the cursor would be on the right half of a double-wide character.
            (if (and (== (:coladd pos) 1) (not-at? s (:col pos) TAB) (vim-isprintc (us-ptr2char s, (:col pos))) (< 1 (mb-ptr2cells s, (:col pos))))
                (assoc pos :coladd 0)
                pos
            ))
        pos
    ))

;; Backup multi-byte pointer.  Only use with "base" < "p" !
(defn- #_int us-ptr-back [#_Bytes base, #_Bytes p]
    (inc (us-head-off base, (.minus p 1))))

;; Return a pointer to the character before "*p", if there is one.

(defn- #_Bytes us-prevptr [#_Bytes base, #_Bytes p]
    ;; base: start of the string
    (if (BLT base, p) (.minus p (us-ptr-back base, p)) p))

;; Return the character length of "s".
;; Each multi-byte character (with following composing characters) counts as one.

(defn- #_int us-charlen [#_Bytes s]
    (if (some? s) (loop-when-recur [#_int n 0 i 0] (non-eos? s i) [(inc n) (+ i (us-ptr2len-cc s, i))] => n) 0))

;; Return true if the character at "row"/"col" on the screen
;; is the left side of a double-width character.
;; Caller must make sure "row" and "col" are not invalid!

(defn- #_boolean mb-lefthalve [#_int row, #_int col]
    (let [offset (... @lineOffset row)]
        (< 1 (utf-off2cells (+ offset col), (+ offset @screenCols)))
    ))

;; Correct a position on the screen,
;; if it's the right half of a double-wide char move it to the left half.
;; Returns the corrected column.

(defn- #_int mb-fix-col [#_int col, #_int row]
    (let [col (check-col col) row (check-row row)]
        (if (and (some? @screenLines) (< 0 col) (at? @screenLines (+ (... @lineOffset row) col) 0)) (dec col) col)
    ))

;; misc.c: functions that didn't seem to fit elsewhere --------------------------------------------

;; Count the size (in window cells) of the indent in the current line.

(defn- #_int get-indent [#_window_C win]
    (get-indent-str (ml-get (:lnum (:w_cursor win))), @(:b_p_ts @curbuf)))

;; Count the size (in window cells) of the indent in line "s", with 'tabstop' at "ts".

(defn- #_int get-indent-str [#_Bytes s, #_int ts]
    (loop-when [#_int n 0 i 0] (non-eos? s i) => n
        (cond (at? s i TAB)
            (recur (+ n (- ts (% n ts))) (inc i))   ;; count a tab for what it is worth
        (at? s i (byte \space))
            (recur (inc n) (inc i))                 ;; count a space for one
        :else
            n)
    ))

;; Set the indent of the current line.
;; Leaves the cursor on the first non-blank in the line.
;; Caller must take care of undo.
;; "flags":
;;      SIN_CHANGED:    call changed-bytes() if the line was changed.
;;      SIN_INSERT:     insert the indent in front of the line.
;;      SIN_UNDO:       save line for undo before changing it.
;; Returns true if the line was changed.

(defn- #_[window_C boolean] set-indent? [#_window_C win, #_int size, #_int flags]
    ;; size: measured in spaces
    (let-when [ts @(:b_p_ts @curbuf) et @(:b_p_et @curbuf) pi @(:b_p_pi @curbuf) curl (ml-get (:lnum (:w_cursor win))) ins? (flag? flags SIN_INSERT)
          #_boolean f! false
          #_int oi -1           ;; number of initial whitespace chars when 'et' and 'pi' are both set
          #_int n size
          #_int m 0             ;; measured in spaces
          #_int i 0             ;; measured in characters
          #_Bytes s curl
          ;; If 'expandtab' isn't set: use TABs;
          ;; if both 'expandtab' and 'preserveindent' are set: count the number of chars at the beginning of the line to be copied.
          [f! oi n m i s]
            (if (or (not et) (and (not ins?) pi))
                ;; If 'preserveindent' is set, then reuse as much as possible of the existing indent structure for the new indent.
                (let [[f! oi n m i s]
                        (if (and (not ins?) pi)
                            (let [[n m i s]
                                    (loop-when [n n m 0 i i s s] (and (< 0 n) (vim-iswhite (.at s 0))) => [n m i s]
                                        (let [#_int k (if (at? s TAB) (let [#_int t (- ts (% m ts))] (if (< n t) nil t)) 1)] ;; stop if this tab will overshoot the target
                                            (recur-if (some? k) [(- n k) (+ m k) (inc i) (.plus s 1)] => [n m i s])          ;; count as many characters as we can use
                                        ))
                                  ;; Set initial number of whitespace chars to copy if we are preserving indent but expandtab is set.
                                  oi (if et i oi)
                                  ;; Fill to next tabstop with a tab, if possible.
                                  [f! n #_m i]
                                    (let [#_int t (- ts (% m ts))] (if (and (<= t n) (== oi -1)) [true (- n t) #_(+ m t) (inc i)] [f! n #_m i]))]
                                [f! oi n m i s])
                            [f! oi n m i s])
                      ;; count tabs required for indent
                      [f! n #_m i s]
                        (loop-when [f! f! n n #_m #_m i i s s] (<= ts n) => [f! n #_m i s]
                            (let [[f! s] (if (not-at? s TAB) [true (.plus s 1)] [f! s])] (recur f! (- n ts) #_(+ m ts) (inc i) s))
                        )]
                    [f! oi n m i s])
                [f! oi n m i s])
          ;; count spaces required for indent
          [f! n #_m i s]
            (loop-when [f! f! n n #_m #_m i i s s] (< 0 n) => [f! n #_m i s]
                (let [[f! s] (if (not-at? s (byte \space)) [true (.plus s 1)] [f! s])] (recur f! (- n 1) #_(+ m 1) (inc i) s))
            )
          ;; Return if the indent is OK already.
          ] (or f! (vim-iswhite (.at s 0)) ins?) => [win false]

        ;; Allocate memory for the new line.
        (let [s (if ins? curl (skipwhite s)) #_int l (inc (STRLEN s))
              ;; If 'preserveindent' and 'expandtab' are both set, keep the original chars and allocate accordingly.
              ;; We will fill the rest with spaces after the (when (not et) ...) below.
              [#_int n i s #_Bytes line #_Bytes p]
                (if (!= oi -1)
                    ;; Set total length of indent in chars, which may have been undercounted until now.
                    (let [n (- size m) i (+ oi n) line (Bytes. (+ (- (+ oi size) m) l))
                          [s p] (loop-when-recur [s curl p line oi oi] (< 0 oi) [(.plus s 1) (.plus p 1) (dec oi)] => [s p]
                                    (.be p 0, (.at s 0)))
                          ;; Skip over any additional white space (useful when new indent is less than old).
                          s (loop-when-recur s (vim-iswhite (.at s 0)) (.plus s 1) => s)]
                        [n i s line p])
                    (let [line (Bytes. (+ i l))] [size i s line line]))
              ;; Put the characters in the new line.
              ;; If 'expandtab' isn't set: use TABs.
              [n s p] (if (not et)
                    ;; If 'preserveindent' is set, reuse as much as possible of the existing indent structure for the new indent.
                    (let [[n s p] (if (and (not ins?) pi)
                                (let [[n int m s p]
                                        (loop-when [n n m 0 s curl p p] (and (< 0 n) (vim-iswhite (.at s 0))) => [n m s p]
                                            ;; stop if this tab will overshoot the target
                                            (let-when [#_int k (if (at? s TAB) (let [#_int t (- ts (% m ts))] (if (< n t) nil t)) 1)] (some? k) => [n m s p]
                                                (.be p 0, (.at s 0)) (recur (- n k) (+ m k) (.plus s 1) (.plus p 1))
                                            ))
                                      ;; Fill to next tabstop with a tab, if possible.
                                      [n p] (let [#_int t (- ts (% m ts))] (if (<= t n) [(- n t) (-> p (.be 0, TAB) (.plus 1))] [n p]))]
                                      [n (skipwhite s) p])
                                [n s p])
                          [n p] (loop-when-recur [n n p p] (<= ts n) [(- n ts) (-> p (.be 0, TAB) (.plus 1))] => [n p])]
                        [n s p])
                    [n s p])
              [n p] (loop-when-recur [n n p p] (< 0 n) [(dec n) (-> p (.be 0, (byte \space)) (.plus 1))] => [n p])]

            (BCOPY p, s, l)

            ;; Replace the line (unless undo fails).
            (let [cln (:lnum (:w_cursor win)) #_boolean ok (or (non-flag? flags SIN_UNDO) (u-savesub cln))]
                (when ok
                    (ml-replace cln, line)
                    (when (flag? flags SIN_CHANGED) (changed-bytes cln, 0)))
                [(assoc-in win [:w_cursor :col] i) ok]
            ))
    ))

(defn- #_window_C set-indent [#_window_C win, #_int size, #_int flags]
    (let [[win _] (set-indent? win, size, flags)]
        win
    ))

;; Copy the indent from "src" to the current line (and fill to size).
;; Leaves the cursor on the first non-blank in the line.

(defn- #_window_C copy-indent [#_window_C win, #_int size, #_Bytes src]
    (let [ts @(:b_p_ts @curbuf) et @(:b_p_et @curbuf) be' (fn [p b] (when (some? p) (-> p (.be 0, b) (.plus 1)))) curl (ml-get (:lnum (:w_cursor win))) l' (inc (STRLEN curl))
          ;; Round 1: compute the number of characters needed for the indent.
          ;; Round 2: copy the characters.
          [#_int i #_Bytes line]
            (loop-when [i nil line nil #_Bytes p nil #_int round 0] (< round 2) => [i line]
                (let [[#_int n #_int m i p] ;; Count/copy the usable portion of the source line.
                        (loop-when [n size m 0 i 0 p p #_Bytes s src] (and (< 0 n) (vim-iswhite (.at s 0))) => [n m i p]
                            ;; Stop if this tab will overshoot the target.
                            (let [#_int k (if (at? s TAB) (let [#_int t (- ts (% m ts))] (if (< n t) nil t)) 1)]
                                (recur-if (some? k) [(- n k) (+ m k) (inc i) (be' p (.at s 0)) (.plus s 1)] => [n m i p])
                            ))
                      ;; Fill to next tabstop with a tab, if possible.
                      [n i p] (let [#_int t (- ts (% m ts))] (if (and (<= t n) (not et)) [(- n t) (inc i) (be' p TAB)] [n i p]))
                      ;; Add tabs required for indent.
                      [n i p] (loop-when-recur [n n i i p p] (and (<= ts n) (not et)) [(- n ts) (inc i) (be' p TAB)] => [n i p])
                      ;; Count/add spaces required for indent.
                      [n i p] (loop-when-recur [n n i i p p] (< 0 n) [(dec n) (inc i) (be' p (byte \space))] => [n i p])
                      [line p] (if (nil? p)
                                    ;; Allocate memory for the copied indent, the new indent and the rest of the line.
                                    (let [line (Bytes. (+ i l'))] [line line])
                                    ;; Append the original line.
                                    (do (BCOPY p, curl, l') [line nil])
                                )]
                    (recur i line p (inc round)))
            )]
        ;; Replace the line.
        (ml-replace (:lnum (:w_cursor win)), line)
        ;; Put the cursor after the indent.
        (assoc-in win [:w_cursor :col] i)
    ))

(atom! int      bri_prev_indent)    ;; cached indent value
(atom! long     bri_prev_ts)        ;; cached tabstop value
(atom! Bytes    bri_prev_line)      ;; cached pointer to line
(atom! int      bri_prev_tick)      ;; changedtick of cached value

;; Return appropriate space number for breakindent, taking influencing parameters into account.
;; Window must be specified, since it is not necessarily always the current one.

(defn- #_int get-breakindent [#_window_C win, #_Bytes line]
    ;; window width minus window margin space, i.e. what rests for text
    (let [#_int eff_ww (- (:w_width win) (if (and (or @(:wo_nu (:w_options win)) @(:wo_rnu (:w_options win))) (nil? (vim-strbyte @p_cpo, CPO_NUMCOL))) (inc (number-width win)) 0))]
        ;; used cached indent, unless pointer or 'tabstop' changed
        (when (or (BNE @bri_prev_line, line) (!= @bri_prev_ts @(:b_p_ts @curbuf)) (!= @bri_prev_tick (:b_changedtick @curbuf)))
            (reset! bri_prev_line line)
            (reset! bri_prev_ts @(:b_p_ts @curbuf))
            (reset! bri_prev_tick (:b_changedtick @curbuf))
            (reset! bri_prev_indent (get-indent-str line, @(:b_p_ts @curbuf))))
        (let [#_int bri (+ @bri_prev_indent (:w_p_brishift win))
              ;; indent minus the length of the showbreak string
              bri (if (:w_p_brisbr win) (- bri (mb-string2cells @p_sbr)) bri)
              ;; add offset for number column, if 'n' is in 'cpoptions'
              bri (+ bri (win-col-off2 win))]
            (cond
                ;; never indent past left window margin
                (< bri 0) 0
                ;; always leave at least bri_min characters on the left, if text width is sufficient
                (< (- eff_ww (:w_p_brimin win)) bri) (max 0 (- eff_ww (:w_p_brimin win)))
                :else bri
            ))
    ))

;; Return true if the string "line" starts with a word from 'cinwords'.

(defn- #_boolean cin-is-cinword [#_Bytes line]
    (let [line (skipwhite line)
          a'cinw (atom (#_Bytes object @(:b_p_cinw @curbuf))) #_int size (inc (STRLEN @a'cinw)) #_Bytes word (Bytes. size)]
        (loop-when [] (non-eos? @a'cinw) => false
            (let [#_int n (copy-option-part a'cinw, word, size, (u8 ","))]
                (recur-if (or (non-zero? (STRNCMP line, word, n)) (and (us-iswordb (.at line n)) (us-iswordb (.at line (dec n))))) [] => true)
            ))
    ))

;; Add a new line below or above the current line.
;;
;; For VREPLACE mode, we only add a new line when we get to the end of the file,
;; otherwise we just start replacing the next line.
;;
;; Caller must take care of undo.  Since VREPLACE may affect any number of lines however,
;; it may call u-save-cursor() again when starting to change a new line.
;;
;; "second_line_indent": indent for after ^^D in Insert mode
;;
;; Return true for success, false for failure.

(defn- #_[window_C boolean] open-line? [#_window_C win, #_int dir, #_int flags, #_int second_line_indent]
    ;; dir: FORWARD or BACKWARD
    (let [#_boolean do_si (and (not @p_paste) @(:b_p_si @curbuf))
          ;; make a copy of the current line so we can mess with it
          #_Bytes saved_line (STRDUP (ml-get (:lnum (:w_cursor win))))
          #_Bytes next_line
            (when (flag? @State VREPLACE_FLAG)
                ;; With VREPLACE we make a copy of the next line, which we will be starting to replace.
                ;; First make the new line empty and let vim play with the indenting and comment leader
                ;; to its heart's content.  Then we grab what it ended up putting on the new line, put
                ;; back the original line, and call ins-char() to put each new character onto the line,
                ;; replacing what was there before and pushing the right stuff onto the replace stack.
                (let [lnum (:lnum (:w_cursor win)) col (:col (:w_cursor win))
                      next_line (STRDUP (if (< lnum @orig_line_count) (ml-get (inc lnum)) (u8 "")))]
                    ;; In VREPLACE mode, a NL replaces the rest of the line, and starts replacing the next line,
                    ;; so push all of the characters left on the line onto the replace stack.  We'll push any other
                    ;; characters that might be replaced at the start of the next line (due to autoindent, etc.)
                    ;; a bit later.
                    (replace-push NUL)      ;; call twice because BS over NL expects it
                    (replace-push NUL)
                    (loop-when-recur [#_Bytes s (.plus saved_line col)] (non-eos? s) [(.plus s (replace-push-mb s))] => (eos! saved_line col))
                    next_line
                ))
          [#_Bytes p_extra #_int first_char #_int saved_char]
            (if (and (flag? @State INSERT) (non-flag? @State VREPLACE_FLAG))
                (let [p_extra (.plus saved_line (:col (:w_cursor win)))
                      first_char (if do_si (.at (skipwhite p_extra) 0) NUL) ;; need first char after new line break
                      saved_char (.at p_extra 0)]
                    [(eos! p_extra) first_char saved_char])
                [nil NUL NUL]
            )]
        (u-clearline)              ;; cannot do "U" command when adding lines
        (reset! did_si false)
        (reset! ai_col 0)
        ;; If we just did an auto-indent, we didn't type anything on the prior line, and it should be truncated.
        ;; Do this even if 'ai' is not set, because automatically inserting a comment leader also sets did_ai.
        (let [#_boolean trunc_line (and (== dir FORWARD) @did_ai)   ;; truncate current line afterwards
              ;; If 'autoindent' and/or 'smartindent' is set, try to figure out what indent to use for the new line.
              #_int ni 0                ;; auto-indent of the new line
              #_boolean no_si false     ;; reset did_si afterwards
              [win ni no_si]
                (if (or @(:b_p_ai @curbuf) do_si)
                    (let [ni (get-indent-str saved_line, @(:b_p_ts @curbuf)) ;; count white space on current line
                          ni (if (zero? ni) second_line_indent ni) ;; for ^^D command in insert mode
                          ;; Do smart indenting.
                          ;; In insert/replace mode (only when dir == FORWARD) we may move some text to the next line.
                          ;; If it starts with '{', don't add an indent.  Fixes inserting a NL before '{' in line
                          ;;      "if (condition) {"
                          [win ni no_si]
                            (if (and (not trunc_line) do_si (non-eos? saved_line) (or (nil? p_extra) (!= first_char (byte \{))))
                                (let [o'cursor (:w_cursor win) #_Bytes s saved_line
                                      [win ni no_si]
                                        (cond (== dir FORWARD)
                                            (let [[win s ni] ;; Skip preprocessor directives, unless they are recognised as comments.
                                                    (if (at? s (byte \#))
                                                        (let [[win s] (loop-when [win win s s] (and (at? s (byte \#)) (< 1 (:lnum (:w_cursor win)))) => [win s]
                                                                    (let [win (update-in win [:w_cursor :lnum] dec)]
                                                                        (recur win (ml-get (:lnum (:w_cursor win)))))
                                                                )]
                                                            [win s (get-indent win)])
                                                        [win s ni])
                                                  ;; Find last non-blank in line.
                                                  #_Bytes p (loop-when-recur [p (.plus s (dec (STRLEN s)))] (and (BLT s, p) (vim-iswhite (.at p 0))) (.minus p 1) => p)
                                                  #_byte last_char (.at p 0)
                                                  ;; find the character just before the '{' or ';'
                                                  p (if (any == last_char (byte \{) (byte \;))
                                                        (loop-when-recur [p (if (BLT s, p) (.minus p 1) p)] (and (BLT s, p) (vim-iswhite (.at p 0))) (.minus p 1) => p)
                                                        p)
                                                  ;; Try to catch lines that are split over multiple lines.
                                                  ;;  e.g.:
                                                  ;;      if (condition &&
                                                  ;;                  condition) {
                                                  ;;          Should line up here!
                                                  ;;      }
                                                  [win s ni]
                                                    (if (at? p (byte \)))
                                                        (let [win (assoc-in win [:w_cursor :col] (BDIFF p, s)) #_pos_C pos (findmatch nil, (byte \())]
                                                            (if (some? pos)
                                                                (let [win (assoc-in win [:w_cursor :lnum] (:lnum pos))]
                                                                    [win (ml-get (:lnum (:w_cursor win))) (get-indent win)])
                                                                [win s ni]
                                                            ))
                                                        [win s ni])
                                                  ;; If last character is '{' do indent, without checking for "if" and the like.
                                                  no_si
                                                    (cond (== last_char (byte \{))
                                                        (do (reset! did_si true) true) ;; do indent ;; don't delete it when '{' typed
                                                    ;; Look for "if" and the like, use 'cinwords'.
                                                    ;; Don't do this if the previous line ended in ';' or '}'.
                                                    (and (!= last_char (byte \;)) (!= last_char (byte \})) (cin-is-cinword s))
                                                        (do (reset! did_si true) no_si)
                                                    :else
                                                        no_si
                                                    )]
                                                [win ni no_si])
                                        :else ;; (== dir BACKWARD)
                                            (let [[win s ni] ;; Skip preprocessor directives, unless they are recognised as comments.
                                                    (if (at? s (byte \#))
                                                        (let [lmax (line-count @curbuf)
                                                              [win s #_boolean ?]
                                                                (loop-when [win win s s ? false] (and (or (at? s (byte \#)) ?) (< (:lnum (:w_cursor win)) lmax)) => [win s ?]
                                                                    (let [? (and (non-eos? s) (at? s (dec (STRLEN s)) (byte \\)))
                                                                          win (update-in win [:w_cursor :lnum] inc)]
                                                                        (recur win (ml-get (:lnum (:w_cursor win))) ?))
                                                                )]
                                                            [win s (if ? 0 (get-indent win))])
                                                        [win s ni]
                                                    )]
                                                (if (at? (skipwhite s) (byte \}))
                                                    (reset! did_si true)            ;; line starts with '}': do indent
                                                    (reset! can_si_back true))      ;; can delete indent when '{' typed
                                                [win ni no_si])
                                        )]
                                    [(assoc win :w_cursor o'cursor) ni no_si])
                                [win ni no_si]
                            )]
                        (when do_si
                            (reset! can_si true))
                        (reset! did_ai true)
                        [win ni no_si])
                    [win ni no_si]
                )]

            (let [p_extra
                    (if (some? p_extra)
                        (do (.be p_extra 0, saved_char)          ;; restore char that NUL replaced
                            ;; When 'ai' set, skip to the first non-blank.
                            ;;
                            ;; When in REPLACE mode, put the deleted blanks on the replace stack,
                            ;; preceded by a NUL, so they can be put back when a BS is entered.
                            (when (and (flag? @State REPLACE_FLAG) (non-flag? @State VREPLACE_FLAG))
                                (replace-push NUL))      ;; end of extra blanks
                            (let [p_extra
                                    (if @(:b_p_ai @curbuf)
                                        (loop-when p_extra (and (or (at? p_extra (byte \space)) (at? p_extra TAB)) (not (utf-iscomposing (us-ptr2char p_extra, 1)))) => p_extra
                                            (when (and (flag? @State REPLACE_FLAG) (non-flag? @State VREPLACE_FLAG))
                                                (replace-push (.at p_extra 0)))
                                            (recur (.plus p_extra 1)))
                                        p_extra
                                    )]
                                (when (non-eos? p_extra)
                                    (reset! did_ai false))              ;; append some text, don't truncate now
                                p_extra
                            ))
                        (u8 "") ;; append empty line
                    )]

                (let [o'cursor (:w_cursor win) win (if (== dir BACKWARD) (update-in win [:w_cursor :lnum] dec) win)]
                    (let-when [[win #_boolean did_append]
                            (cond (and (flag? @State VREPLACE_FLAG) (< (:lnum o'cursor) @orig_line_count))
                                ;; In VREPLACE mode we are starting to replace the next line.
                                (let [win (update-in win [:w_cursor :lnum] inc)]
                                    (when (<= (+ (:lnum @insStart) @vr_lines_changed) (:lnum (:w_cursor win)))
                                        ;; In case we NL to a new line, BS to the previous one, and NL
                                        ;; again, we don't want to save the new line for undo twice.
                                        (u-save-cursor)            ;; errors are ignored!
                                        (swap! vr_lines_changed inc))
                                    (ml-replace (:lnum (:w_cursor win)), p_extra)
                                    (changed-bytes (:lnum (:w_cursor win)), 0)
                                    [(update-in win [:w_cursor :lnum] dec) false])
                            (ml-append (:lnum (:w_cursor win)), p_extra)
                                (do ;; Postpone calling changed-lines(), because it would mess up folding with markers.
                                    (mark-adjust (inc (:lnum (:w_cursor win))), MAXLNUM, 1, 0)
                                    [win true])
                            :else
                                [win nil]
                            )] (some? did_append) => [win false]

                        (let [o'pi @(:b_p_pi @curbuf)
                              [win #_int newcol]
                                (if (or (non-zero? ni) @did_si)
                                    (let [win (update-in win [:w_cursor :lnum] inc)
                                          ni (if @did_si (let [#_int sw (get-sw-value)] (+ (if @p_sr (- ni (% ni sw)) ni) sw)) ni)
                                          win (if @(:b_p_ci @curbuf)
                                                (let [win (copy-indent win, ni, saved_line)]
                                                    ;; Set the 'preserveindent' option so that any further screwing with the line
                                                    ;; doesn't entirely destroy our efforts to preserve it.
                                                    ;; It gets restored at the function end.
                                                    (reset! (:b_p_pi @curbuf) true)
                                                    win)
                                                (set-indent win, ni, SIN_INSERT))]
                                        (reset! ai_col (:col (:w_cursor win)))
                                        ;; In REPLACE mode, for each character in the new indent, there must
                                        ;; be a NUL on the replace stack, for when it is deleted with BS.
                                        (when (and (flag? @State REPLACE_FLAG) (non-flag? @State VREPLACE_FLAG))
                                            (dotimes [_ (:col (:w_cursor win))]
                                                (replace-push NUL)
                                            ))
                                        (when no_si
                                            (reset! did_si false))
                                        [win (:col (:w_cursor win))])
                                    [win 0])
                              win (assoc win :w_cursor o'cursor)
                              [win did_append]
                                (if (== dir FORWARD)
                                    (let [did_append
                                            (if (or trunc_line (flag? @State INSERT))
                                                (let [lnum (:lnum (:w_cursor win)) col (:col (:w_cursor win))]
                                                    ;; Truncate current line at cursor.
                                                    (eos! saved_line col)
                                                    ;; Remove trailing white space.
                                                    (when trunc_line
                                                        (truncate-spaces saved_line))
                                                    (ml-replace lnum, saved_line)
                                                    (if did_append
                                                        (changed-lines lnum, col, (inc lnum), 1)
                                                        (changed-bytes lnum, col))
                                                    false)
                                                did_append
                                            )]
                                        ;; Put the cursor on the new line.
                                        ;; Careful: the scrollup() above may have moved "w_cursor", we must use "o'cursor".
                                        [(assoc-in win [:w_cursor :lnum] (inc (:lnum o'cursor))) did_append])
                                    [win did_append]
                                )]
                            (when did_append
                                (changed-lines (:lnum (:w_cursor win)), 0, (:lnum (:w_cursor win)), 1))
                            (let [win (update win :w_cursor assoc :col newcol :coladd 0)
                                  ;; Finally, VREPLACE gets the stuff on the new line, puts back the original line, inserts
                                  ;; the new stuff char by char pushing old stuff onto the replace stack (via ins-char()).
                                  win (if (flag? @State VREPLACE_FLAG)
                                        ;; Put new line in "p_extra".
                                        (let [p_extra (STRDUP (ml-get (:lnum (:w_cursor win))))]
                                            ;; Put back original line.
                                            (ml-replace (:lnum (:w_cursor win)), next_line)
                                            ;; Insert new stuff into line again.
                                            (-> win
                                                (update :w_cursor assoc :col 0 :coladd 0)
                                                (ins-bytes p_extra) ;; will call changed-bytes()
                                            ))
                                        win
                                    )]
                                (reset! (:b_p_pi @curbuf) o'pi)
                                [win true]
                            ))
                    ))
            ))
    ))

;; Return the number of screen rows occupied by buffer line "lnum".

(defn- #_int plines [#_window_C win, #_long lnum, #_boolean limit]
    ;; limit: when true limit to window height
    (if (or (not @(:wo_wrap (:w_options win))) (zero? (:w_width win)))
        1
        (let [n (plines-nowrap win, lnum)]
            (if (and limit (< (:w_height win) n)) (:w_height win) n))
    ))

;; Return the number of screen rows line "lnum" will occupy in window "win".
;; Does not care about 'wrap'.

(defn- #_int plines-nowrap [#_window_C win, #_long lnum]
    (let [#_Bytes s (ml-get lnum)]
        (if (eos? s)     ;; empty line
            1
            (let [col (win-linetabsize win, s, MAXCOL) width (- (:w_width win) (win-col-off win))]
                (cond
                    (<= width 0) 32000
                    (<= col width) 1
                    :else (let [col (- col width) width (+ width (win-col-off2 win))] (inc (/ (+ col (dec width)) width)))
                ))
        )
    ))

;; Like plines(), but only reports the number of screen rows
;; used from the start of the line to the given column number.

(defn- #_int plines-col [#_window_C win, #_long lnum, #_long column]
    (if (or (not @(:wo_wrap (:w_options win))) (zero? (:w_width win)))
        1
        (let [#_Bytes line (ml-get lnum)
              [col s] (loop-when-recur [col 0 s line n column]
                                       (and (non-eos? s) (< 0 n))
                                       [(+ col (win-lbr-chartabsize win, line, s, col, nil)) (.plus s (us-ptr2len-cc s)) (dec n)]
                                    => [col s])
              ;; If s[0] is a TAB, and the TAB is not displayed as ^I, and we're not in INSERT mode,
              ;; then col must be adjusted so that it represents the last screen position of the TAB.
              ;; This only fixes an error when the TAB wraps from one screen line to the next
              ;; (when 'columns' is not a multiple of 'ts').
              col (if (and (at? s TAB) (flag? @State NORMAL)) (+ col (dec (win-lbr-chartabsize win, line, s, col, nil))) col)
              ;; Add column offset for 'number', 'relativenumber', 'foldcolumn', etc.
              width (- (:w_width win) (win-col-off win))]
            (if (< 0 width)
                (if (< width col) (+ 1 (inc (/ (- col width) (+ width (win-col-off2 win))))) 1)
                9999
            ))
    ))

(defn- #_int plines-many [#_window_C win, #_long first, #_long last]
    (loop-when-recur [#_int n 0 #_long i first] (<= i last) [(+ n (plines win, i, true)) (inc i)] => n))

;; Insert string "p" at the cursor position.  Stops at a NUL byte.
;; Handles Replace mode and multi-byte characters.

(defn- #_window_C ins-bytes [#_window_C win, #_Bytes p]
    (ins-bytes-len win, p, (STRLEN p)))

;; Insert string "p" with length "len" at the cursor position.
;; Handles Replace mode and multi-byte characters.

(defn- #_window_C ins-bytes-len [#_window_C win, #_Bytes p, #_int len]
    (loop-when [win win #_int i 0] (< i len) => win
        (let [#_int n (us-ptr2len-cc-len p, i, (- len i))]
            (recur (ins-char-bytes win, (.plus p i), n) (+ i n)))
    ))

;; Insert or replace a single character at the cursor position.
;; When in REPLACE or VREPLACE mode, replace any existing character.
;; Caller must have prepared for undo.
;; For multi-byte characters we get the whole character,
;; the caller must convert bytes to a character.

(defn- #_window_C ins-char [#_window_C win, #_int c]
    (let [#_Bytes buf (Bytes. (inc MB_MAXBYTES)) #_int n (utf-char2bytes c, buf)]
        ;; When "c" is 0x100, 0x200, etc. we don't want to insert a NUL byte.
        ;; Happens for CTRL-Vu9900.
        (when (zero? (.at buf 0))
            (.be buf 0, (byte \newline)))
        (ins-char-bytes win, buf, n)
    ))

(defn- #_window_C ins-char-bytes [#_window_C win, #_Bytes buf, #_int blen]
    ;; Break tabs if needed.
    (let [win (if (and (virtual-active) (< 0 (:coladd (:w_cursor win)))) (coladvance-force win, (getviscol win)) win)
          cln (:lnum (:w_cursor win)) col (:col (:w_cursor win)) o'line (ml-get cln) o'size (inc (STRLEN o'line)) ;; length of old line including NUL
          [#_int olen #_int nlen] ;; nr of bytes deleted (0 when not replacing) ;; nr of bytes inserted
            (if (flag? @State REPLACE_FLAG)
                (let [[olen nlen]
                        (cond (flag? @State VREPLACE_FLAG)
                            ;; In virtual replace mode a char may replace one or more chars (zero if it's a TAB).
                            ;; Count the number of bytes to be deleted to make room for the new character,
                            ;; counting screen cells.  May result in adding spaces to fill a gap.
                            (let [a'vcol (atom (int)) _ (getvcol win, (:w_cursor win), nil, a'vcol, nil)
                                  #_int vcol @a'vcol #_int vcol' (+ vcol (chartabsize buf, vcol))]
                                (loop-when [vcol vcol olen 0 nlen blen] (and (non-eos? o'line (+ col olen)) (< vcol vcol')) => [olen nlen]
                                    (let [vcol (+ vcol (chartabsize o'line, (+ col olen), vcol))]
                                        ;; Don't need to remove a TAB that takes us to the right position.
                                        (if (and (< vcol' vcol) (at? o'line (+ col olen) TAB))
                                            [olen nlen]
                                            ;; Deleted a bit too much, insert spaces.
                                            (recur vcol (+ olen (us-ptr2len-cc o'line, (+ col olen))) (+ nlen (max 0 (- vcol vcol'))))
                                        ))
                                ))
                        (non-eos? o'line col) [(us-ptr2len-cc o'line, col) blen] ;; normal replace
                        :else                 [0 blen])]
                    ;; Push the replaced bytes onto the replace stack, so that they can be put back when BS is used.
                    ;; The bytes of a multi-byte character are done the other way around,
                    ;; so that the first byte is popped off first (it tells the byte length of the character).
                    (replace-push NUL)
                    (loop-when-recur [#_int i 0] (< i olen) [(+ i (replace-push-mb (.plus o'line (+ col i))))])
                    [olen nlen])
                [0 blen])
          #_Bytes line (Bytes. (+ o'size (- nlen olen)))
          _ (when (< 0 col)
                (BCOPY line, o'line, col))                                                  ;; copy bytes before the cursor
          #_Bytes p (.plus line col)
          _ (BCOPY p, nlen, o'line, (+ col olen), (- o'size col olen))                      ;; copy bytes after the changed character(s)
          _ (BCOPY p, buf, blen)                                                            ;; insert or overwrite the new character
          _ (loop-when-recur [#_int i blen] (< i nlen) [(inc i)] (.be p i, (byte \space)))] ;; fill with spaces when necessary
        ;; Replace the line in the buffer.
        (ml-replace cln, line)
        ;; mark the buffer as changed and prepare for displaying
        (changed-bytes cln, col)
        ;; If we're in Insert or Replace mode and 'showmatch' is set, then briefly show the match for right parens and braces.
        (let [win (if (and @p_sm (flag? @State INSERT)) (showmatch win, (us-ptr2char buf)) win)]
            ;; Normal insert: move cursor right.
            (update-in win [:w_cursor :col] + blen))
        ;; TODO: should try to update "w_row" here, to avoid recomputing it later.
    ))

;; Insert a string at the cursor position.
;; Note: Does NOT handle Replace mode.
;; Caller must have prepared for undo.

(defn- #_window_C ins-str [#_window_C win, #_Bytes s]
    (let [win (if (and (virtual-active) (< 0 (:coladd (:w_cursor win)))) (coladvance-force win, (getviscol win)) win)
          cln (:lnum (:w_cursor win)) col (:col (:w_cursor win)) o'line (ml-get cln) o'len (STRLEN o'line)
          #_int n (STRLEN s) #_Bytes line (Bytes. (+ o'len n 1))
          _ (when (< 0 col)
                (BCOPY line, o'line, col))
          _ (BCOPY line, col, s, 0, n)
          _ (BCOPY line, (+ col n), o'line, col, (inc (- o'len col)))]
        (ml-replace cln, line)
        (changed-bytes cln, col)
        (update-in win [:w_cursor :col] + n)
    ))

;; Delete one character under the cursor.
;;
;; If "fixpos" is true, don't leave the cursor on the NUL after the line.
;; Caller must have prepared for undo.
;;
;; Return false for failure, true otherwise.

(defn- #_[window_C boolean] del-char? [#_window_C win, #_boolean fixpos]
    ;; Make sure the cursor is at the start of a character.
    (let-when [win (update win :w_cursor mb-adjust-pos)] (non-eos? (ml-get-cursor win)) => [win false]
        (del-chars? win, 1, fixpos)
    ))

(defn- #_window_C del-char [#_window_C win, #_boolean fixpos]
    (let [[win _] (del-char? win, fixpos)]
        win
    ))

;; Like del-bytes(), but delete characters instead of bytes.

(defn- #_[window_C boolean] del-chars? [#_window_C win, #_int nof, #_boolean fixpos]
    (let [s (ml-get-cursor win) n (loop-when-recur [n 0 i 0] (and (< i nof) (non-eos? s n)) [(+ n (us-ptr2len-cc s, n)) (inc i)] => n)]
        (del-bytes? win, n, fixpos, true)
    ))

(defn- #_window_C del-chars [#_window_C win, #_int nof, #_boolean fixpos]
    (let [[win _] (del-chars? win, nof, fixpos)]
        win
    ))

;; Delete "nof" bytes under the cursor.
;;
;; If "fixpos" is true, don't leave the cursor on the NUL after the line.
;; use_delcombine: 'delcombine' option applies
;; Caller must have prepared for undo.
;;
;; Return false for failure, true otherwise.

(defn- #_[window_C boolean] del-bytes? [#_window_C win, #_int nof, #_boolean fixpos, #_boolean use_delcombine]
    ;; Can't do anything when the cursor is on the NUL after the line.
    (let-when [cln (:lnum (:w_cursor win)) col (:col (:w_cursor win)) o'line (ml-get cln) o'len (STRLEN o'line)] (< col o'len) => [win false]
        ;; If 'delcombine' is set and deleting (less than) one character, only delete the last combining character.
        (let [[col nof fixpos]
                (if (and @p_deco use_delcombine (<= nof (us-ptr2len-cc o'line, col)))
                    (let-when [#_int* cc (int-array MAX_MCO) _ (us-ptr2char-cc (.plus o'line col), cc)] (non-zero? (aget cc 0)) => [col nof fixpos]
                        ;; Find the last composing char, there can be several.
                        (loop [#_int n col]
                            (let [col n nof (us-ptr2len o'line, n) n (+ n nof)]
                                (recur-if (utf-iscomposing (us-ptr2char o'line, n)) [n] => [col nof false]))
                        ))
                    [col nof fixpos])
              ;; When nof is too big, reduce it.
              #_int movelen (inc (- o'len col nof)) ;; includes trailing NUL
              [win nof movelen]
                (if (<= movelen 1)
                    ;; If we just took off the last character of a non-blank line, and fixpos is true, we don't want
                    ;; to end up positioned at the NUL, unless "restart_edit" is set or 'virtualedit' contains "onemore".
                    (let [win (if (and (< 0 col) fixpos (zero? @restart_edit) (non-flag? @ve_flags VE_ONEMORE))
                                (-> win
                                    (update-in [:w_cursor :col] dec)
                                    (assoc-in [:w_cursor :coladd] 0)
                                    (update-in [:w_cursor :col] #(- % (us-head-off o'line, (.plus o'line %)))))
                                win
                            )]
                        [win (- o'len col) 1])
                    [win nof movelen])
              #_Bytes line (Bytes. (- (inc o'len) nof))
              _ (BCOPY line, o'line, col)
              _ (BCOPY line, col, o'line, (+ col nof), movelen)]
            (ml-replace cln, line)
            ;; mark the buffer as changed and prepare for displaying
            (changed-bytes cln, (:col (:w_cursor win)))
            [win true]
        )
    ))

(defn- #_window_C del-bytes [#_window_C win, #_int nof, #_boolean fixpos, #_boolean use_delcombine]
    (let [[win _] (del-bytes? win, nof, fixpos, use_delcombine)]
        win
    ))

;; Delete from cursor to end of line.
;; Caller must have prepared for undo.

(defn- #_window_C truncate-line [#_window_C win, #_boolean fixpos]
    (let [lnum (:lnum (:w_cursor win)) col (:col (:w_cursor win))]
        (ml-replace lnum, (if (zero? col) (STRDUP (u8 "")) (STRNDUP (ml-get lnum), col)))
        ;; mark the buffer as changed and prepare for displaying
        (changed-bytes lnum, col)
        ;; If "fixpos" is true we don't want to end up positioned at the NUL.
        (if (and fixpos (< 0 (:col (:w_cursor win))))
            (update-in win [:w_cursor :col] dec)
            win
        )
    ))

;; Delete "nof" lines at the cursor.
;; Saves the lines for undo first if "undo" is true.

(defn- #_window_C del-lines [#_window_C win, #_long nof, #_boolean undo]
    (let [cln (:lnum (:w_cursor win))]
        (if (and (pos? nof) (or (not undo) (u-savedel cln, nof))) ;; save the deleted lines for undo
            (let [n (loop-when [n 0] (and (< n nof) (non-flag? (:ml_flags (:b_ml @curbuf)) ML_EMPTY)) => n
                        (ml-delete cln, true)
                        ;; If we delete the last line in the file, stop.
                        (recur-if (<= cln (line-count @curbuf)) [(inc n)] => (inc n)))
                  ;; Correct the cursor position before calling deleted-lines-mark(),
                  ;; it may trigger a callback to display the cursor.
                  win (assoc-in win [:w_cursor :col] 0)
                  win (check-cursor-lnum win)]
                ;; Adjust marks, mark the buffer as changed and prepare for displaying.
                (deleted-lines-mark cln, n)
                win)
            win)
    ))

(defn- #_int gchar-pos    [#_pos_C pos]    (us-ptr2char (ml-get-pos pos)))
(defn- #_int gchar-cursor [#_window_C win] (us-ptr2char (ml-get-cursor win)))

;; When extra == 0: Return true if the cursor is before or on the first non-blank in the line.
;; When extra == 1: Return true if the cursor is before the first non-blank in the line.

(defn- #_boolean inindent [#_window_C win, #_int extra]
    (let [#_Bytes s (ml-get (:lnum (:w_cursor win)))]
        (<= (+ (:col (:w_cursor win)) extra) (loop [#_int col 0] (recur-if (vim-iswhite (.at s col)) [(inc col)] => col)))
    ))

;; Skip to next part of an option argument: Skip space and comma.

(defn- #_Bytes skip-to-option-part [#_Bytes p]
    (loop [p (if (at? p (byte \,)) (.plus p 1) p)] (if (at? p (byte \space)) (recur (.plus p 1)) p)))

;; Changed bytes within a single line for the current buffer.
;; - marks the windows on this buffer to be redisplayed
;; - marks the buffer changed by calling changed()
;; - invalidates cached values

(defn- #_void changed-bytes [#_long lnum, #_int col]
    (changed-one-line lnum)
    (changed-common lnum, col, (inc lnum), 0)
    nil)

(defn- #_void changed-one-line [#_long lnum]
    (if (:b_mod_set @curbuf)
        (cond ;; find the maximum area that must be redisplayed
            (< lnum (:b_mod_top @curbuf))  (swap! curbuf assoc :b_mod_top lnum)
            (<= (:b_mod_bot @curbuf) lnum) (swap! curbuf assoc :b_mod_bot (inc lnum)))
        ;; set the area that must be redisplayed to one line
        (swap! curbuf assoc :b_mod_top lnum, :b_mod_bot (inc lnum), :b_mod_xlines 0, :b_mod_set true))
    nil)

;; Appended "count" lines below line "lnum" in the current buffer.
;; Must be called AFTER the change and after mark-adjust().
;; Takes care of marking the buffer to be redrawn and sets the changed flag.

(defn- #_void appended-lines [#_long lnum, #_long count]
    (changed-lines (inc lnum), 0, (inc lnum), count)
    nil)

;; Like appended-lines(), but adjust marks first.

(defn- #_void appended-lines-mark [#_long lnum, #_long count]
    (mark-adjust (inc lnum), MAXLNUM, count, 0)
    (changed-lines (inc lnum), 0, (inc lnum), count)
    nil)

;; Deleted "count" lines at line "lnum" in the current buffer.
;; Must be called AFTER the change and after mark-adjust().
;; Takes care of marking the buffer to be redrawn and sets the changed flag.

(defn- #_void deleted-lines [#_long lnum, #_long count]
    (changed-lines lnum, 0, (+ lnum count), (- count))
    nil)

;; Like deleted-lines(), but adjust marks first.
;; Make sure the cursor is on a valid line before calling,
;; a GUI callback may be triggered to display the cursor.

(defn- #_void deleted-lines-mark [#_long lnum, #_long count]
    (mark-adjust lnum, (dec (+ lnum count)), MAXLNUM, (- count))
    (changed-lines lnum, 0, (+ lnum count), (- count))
    nil)

;; Changed lines for the current buffer.
;; Must be called AFTER the change and after mark-adjust().
;; - mark the buffer changed by calling changed()
;; - mark the windows on this buffer to be redisplayed
;; - invalidate cached values
;; "lnum" is the first line that needs displaying,
;; "lnume" the first line below the changed lines (BEFORE the change).
;; When only inserting lines, "lnum" and "lnume" are equal.
;; Takes care of calling changed() and updating b_mod_*.

(defn- #_void changed-lines [#_long lnum, #_int col, #_long lnume, #_long xtra]
    ;; lnum: first line with change
    ;; col: column in first line with change
    ;; lnume: line below last changed line
    ;; xtra: number of extra lines (negative when deleting)
    (changed-lines-buf lnum, lnume, xtra)
    (changed-common lnum, col, lnume, xtra)
    nil)

(defn- #_void changed-lines-buf [#_long lnum, #_long lnume, #_long xtra]
    ;; lnum: first line with change
    ;; lnume: line below last changed line
    ;; xtra: number of extra lines (negative when deleting)
    (cond (:b_mod_set @curbuf)
    (do
        ;; find the maximum area that must be redisplayed
        (swap! curbuf update :b_mod_top min lnum)
        (when (< lnum (:b_mod_bot @curbuf))
            ;; adjust old bot position for xtra lines
            (swap! curbuf assoc :b_mod_bot (max lnum (+ (:b_mod_bot @curbuf) xtra)))
        )
        (swap! curbuf assoc :b_mod_bot (max (+ lnume xtra) (:b_mod_bot @curbuf)))
        (swap! curbuf update :b_mod_xlines + xtra)
    )
    :else
    (do
        ;; set the area that must be redisplayed
        (swap! curbuf assoc :b_mod_top lnum :b_mod_bot (+ lnume xtra) :b_mod_xlines xtra :b_mod_set true)
    ))
    nil)

;; Common code for when a change is was made.
;; See changed-lines() for the arguments.

(defn- #_void changed-common [#_long lnum, #_int col, #_long lnume, #_long xtra]
    (ยง
        ;; mark the buffer as modified
        (changed)

        ;; set the '. mark
;       {
            (swap! curbuf assoc-in [:b_last_change :lnum] lnum)
            (swap! curbuf assoc-in [:b_last_change :col] col)

            ;; Create a new entry if a new undo-able change was started
            ;; or we don't have an entry yet.
            (when (or (:b_new_change @curbuf) (zero? (:b_changelistlen @curbuf)))
                (ร boolean add)
                (cond (zero? (:b_changelistlen @curbuf))
                (do
                    ((ร add =) true)
                )
                :else
                (do
                    ;; Don't create a new entry when the line number is the
                    ;; same as the last one and the column is not too far away.
                    ;; Avoids creating many entries for typing "xxxxx".
                    ((ร pos_C p =) (... (:b_changelist @curbuf) (dec (:b_changelistlen @curbuf))))
                    (cond (!= (:lnum p) lnum)
                    (do
                        ((ร add =) true)
                    )
                    :else
                    (do
                        ((ร int cols =) 79)
                        ((ร add =) (or (< (+ (:col p) cols) col) (< (+ col cols) (:col p))))
                    ))
                ))

                (when add
                    ;; This is the first of a new sequence of undo-able changes
                    ;; and it's at some distance of the last change.  Use a new
                    ;; position in the changelist.
                    (swap! curbuf assoc :b_new_change false)

                    (when (== (:b_changelistlen @curbuf) JUMPLISTSIZE)
                        ;; changelist is full: remove oldest entry
                        (swap! curbuf assoc :b_changelistlen (dec JUMPLISTSIZE))
                        (dotimes [#_int i (dec JUMPLISTSIZE)]
                            (COPY-pos (... (:b_changelist @curbuf) i), (... (:b_changelist @curbuf) (inc i)))
                        )
                        (loop-when-recur [#_window_C wp @firstwin] (some? wp) [(:w_next wp)]
                            ;; Correct position in changelist for other windows on this buffer.
                            (if (< 0 (:w_changelistidx wp))
                                ((ร wp =) (update wp :w_changelistidx dec))
                            )
                        )
                    )

                    (loop-when-recur [#_window_C wp @firstwin] (some? wp) [(:w_next wp)]
                        ;; For other windows, if the position in the changelist is at the end,
                        ;; it stays at the end.
                        (if (== (:w_changelistidx wp) (:b_changelistlen @curbuf))
                            ((ร wp =) (update wp :w_changelistidx inc))
                        )
                    )

                    (swap! curbuf update :b_changelistlen inc)
                )
            )
            (COPY-pos (... (:b_changelist @curbuf) (dec (:b_changelistlen @curbuf))), (:b_last_change @curbuf))
            ;; The current window is always after the last change, so that "g," takes you back to it.
            (swap! curwin assoc :w_changelistidx (:b_changelistlen @curbuf))
;       }

        (loop-when-recur [#_window_C wp @firstwin] (some? wp) [(:w_next wp)]
            ;; Mark this window to be redrawn later.
            ((ร wp =) (update wp :w_redr_type max VALID))

            ;; Check if a change in the buffer has invalidated the cached values for the cursor.
            (cond (< lnum (:lnum (:w_cursor wp)))
            (do
                ((ร wp =) (changed-line-abv-curs wp))
            )
            (and (== (:lnum (:w_cursor wp)) lnum) (<= col (:col (:w_cursor wp))))
            (do
                ((ร wp =) (changed-cline-bef-curs wp))
            ))

            (when (<= lnum (:w_botline wp))
                ;; Assume that botline doesn't change
                ;; (inserted lines make other lines scroll down below botline).
                ((ร wp =) (approximate-botline wp))
            )

            ;; Check if any w_lines[] entries have become invalid.
            ;; For entries below the change: Correct the lnums for inserted/deleted lines.
            ;; Makes it possible to stop displaying after the change.
            (dotimes [#_int i (:w_lines_valid wp)]
                (when (and (:wl_valid (... (:w_lines wp) i)) (<= lnum (:wl_lnum (... (:w_lines wp) i))))
                    (cond (< (:wl_lnum (... (:w_lines wp) i)) lnume)
                    (do
                        ;; line included in change
                        ((ร wp.w_lines[i].wl_valid =) false)
                    )
                    (non-zero? xtra)
                    (do
                        ;; line below change
                        ((ร wp.w_lines[i].wl_lnum =) (+ (:wl_lnum (... (:w_lines wp) i)) xtra))
                    ))
                )
            )

            ;; relative numbering may require updating more
            (when @(:wo_rnu (:w_options wp))
                ((ร wp =) (redraw-later wp, SOME_VALID)))
        )

        ;; Call update-screen() later, which checks out what needs to be redrawn,
        ;; since it notices b_mod_set and then uses b_mod_*.
        (when (< @must_redraw VALID)
            (reset! must_redraw VALID))

        ;; When the cursor line is changed, always trigger CursorMoved.
        (when (and (<= lnum (:lnum (:w_cursor @curwin))) (< (:lnum (:w_cursor @curwin)) (+ lnume (if (< xtra 0) (- xtra) xtra))))
            (swap! last_cursormoved assoc :lnum 0))
        nil
    ))

(defn- #_void changed []
    (when (not @(:b_changed @curbuf))
        (reset! (:b_changed @curbuf) true)
        (check-status)
    )
    (swap! curbuf update :b_changedtick inc)
    nil)

(defn- #_void unchanged []
    (when @(:b_changed @curbuf)
        (reset! (:b_changed @curbuf) false)
        (check-status)
    )
    (swap! curbuf update :b_changedtick inc)
    nil)

;; called when the status bars for buffer 'buf' need to be updated

(defn- #_void check-status []
    (ยง
        (loop-when-recur [#_window_C win @firstwin] (some? win) [(:w_next win)]
            (when (non-zero? (:w_status_height win))
                ((ร win =) (assoc win :w_redr_status true))
                (if (< @must_redraw VALID)
                    (reset! must_redraw VALID))
            )
        )
        nil
    ))

;; Ask for a reply from the user, a 'y' or a 'n'.
;; No other characters are accepted, the message is repeated
;; until a valid reply is entered or CTRL-C is hit.
;; If direct is true, don't use vgetc() but ui-inchar(),
;; don't get characters from any buffers but directly from the user.
;;
;; Answer 'y' or 'n'.

(defn- #_int ask-yesno [#_Bytes q, #_boolean direct]
    (let [_ @State]
        (when @exiting                          ;; put terminal in raw mode for this question
            (settmode TMODE_RAW))
        (swap! no_wait_return inc)
        (reset! State CONFIRM)                  ;; mouse behaves like with :confirm
        (swap! no_mapping inc)
        (swap! allow_keys inc)                  ;; no mapping here, but recognize keys
        (let [#_int c (loop-when [c (byte \space)] (and (!= c (byte \y)) (!= c (byte \n))) => c
                        (smsg-attr (hl-attr HLF_R), (u8 "%s (y/n)?"), q) ;; same highlighting as for wait-return
                        (let [c (if direct (get-keystroke) (plain-vgetc)) c (if (any == c Ctrl_C ESC) (byte \n) c)]
                            (msg-putchar c)     ;; show what you typed
                            (out-flush)
                            (recur c))
                    )]
            (swap! no_wait_return dec)
            (reset! State _)
            (swap! no_mapping dec)
            (swap! allow_keys dec)
        c)
    ))

;; Get a key stroke directly from the user.
;; Ignores mouse clicks and scrollbar events, except a click for the left button (used at the more prompt).
;; Doesn't use vgetc(), because it syncs undo and eats mapped characters.
;; Disadvantage: typeahead is ignored.
;; Translates the interrupt character for unix to ESC.

(defn- #_int get-keystroke []
    (let [a'len (atom (int 0))]
        (loop [#_int buflen 150 #_Bytes buf (Bytes. buflen) #_int waited 0]
            (cursor-on)
            (out-flush)
            ;; Leave room for check-termcode() to insert a key code (max 5 bytes plus NUL).
            ;; And fix-input-buffer() can triple the number of bytes.
            (let [#_int maxlen (/ (- buflen @a'len 5 1) 3)
                  [buflen buf maxlen]
                    (if (< maxlen 10)
                        ;; Need more space, might happen when receiving a long escape sequence.
                        (let [buflen (+ buflen 100) #_Bytes p (Bytes. buflen)]
                            (BCOPY p, buf, @a'len)
                            [buflen p (/ (- buflen @a'len 5 1) 3)])
                        [buflen buf maxlen])
                  ;; First time: blocking wait.
                  ;; Second time: wait up to 100ms for a terminal code to complete.
                  #_int n (ui-inchar (.plus buf @a'len), maxlen, (if (zero? @a'len) -1 100), 0)
                  waited
                    (cond (< 0 n)
                        (do ;; Replace zero by a special key code.
                            (swap! a'len + (fix-input-buffer (.plus buf @a'len), n))
                            0)
                    (< 0 @a'len)
                        (inc waited)                ;; keep track of the waiting time
                    :else
                        waited)
                  ;; Incomplete termcode and not timed out yet: get more characters.
                  n (check-termcode buf, buflen, a'len)
                  #_int c
                    (cond (and (< n 0) (or (not @p_ttimeout) (< (* waited 100) (if (< @p_ttm 0) @p_tm @p_ttm))))
                        nil
                    (== n KEYLEN_REMOVED)           ;; key code removed
                        (do (when (and (non-zero? @must_redraw) (not @need_wait_return) (non-flag? @State CMDLINE))
                                (update-screen 0)   ;; redrawing was postponed, do it now
                                (setcursor))        ;; put cursor back where it belongs
                            nil)
                    :else
                        (do (when (< 0 n)           ;; found a termcode: adjust length
                                (reset! a'len n))
                            (cond (zero? @a'len)    ;; nothing typed yet
                                nil
                            ;; Handle modifier and/or special key code.
                            (at? buf KB_SPECIAL)
                                (let-when [#_int c (toSpecial (.at buf 1), (.at buf 2))] (or (at? buf 1 KS_MODIFIER) (== c K_IGNORE)) => c
                                    (when (at? buf 1 KS_MODIFIER)
                                        (reset! mod_mask (char_u (.at buf 2))))
                                    (swap! a'len - 3)
                                    (when (< 0 @a'len)
                                        (BCOPY buf, 0, buf, 3, @a'len))
                                    nil)
                            (< @a'len (mb-byte2len (char_u (.at buf 0))))
                                nil                 ;; more bytes to get
                            :else
                                (let [#_int c (us-ptr2char (eos! buf (min @a'len (dec buflen))))]
                                    (if (== c @intr_char) ESC c))
                            ))
                    )]
                (recur-if (nil? c) [buflen buf waited] => c)
            ))
    ))

(defn- #_void msgmore [#_long n]
    ;; We don't want to overwrite another important message,
    ;; but do overwrite a previous "more lines" or "fewer lines" message,
    ;; so that "5dd" and then "put" reports the last action.
    (when (and (messaging) (or (nil? @keep_msg) @keep_msg_more))
        (let-when [#_long pn (if (< 0 n) n (- n))] (< @p_report pn)
            (let [#_Bytes buf (Bytes. MSG_BUF_LEN)]
                (if (== pn 1)
                    (vim-strncpy buf, (if (< 0 n) (u8 "1 more line") (u8 "1 line less")), (dec MSG_BUF_LEN))
;%%                 (vim_snprintf buf, MSG_BUF_LEN, (if (< 0 n) (u8 "%ld more lines") (u8 "%ld fewer lines")), pn)
                )
                (when @got_int
                    (vim-strcat buf, (u8 " (Interrupted)"), MSG_BUF_LEN))
                (when (msg buf)
                    (set-keep-msg buf, 0)
                    (reset! keep_msg_more true))
            )))
    nil)

;; flush map and typeahead buffers and give a warning for an error

(defn- #_void beep-flush []
    (flush-buffers false)
    (vim-beep)
    nil)

;; give a warning for an error

(defn- #_void vim-beep []
    (if @p_vb
        (out-str @T_VB)
        (out-char BELL))
    nil)

(defn- #_void prepare-to-exit []
    ;; Ignore SIGHUP, because a dropped connection causes a read error, which
    ;; makes Vim exit and then handling SIGHUP causes various reentrance problems.

;%% (.sigset libC SIGHUP, #_"/*SIG_IGN*/"nil)

    (windgoto (dec @Rows), 0)

    ;; Switch terminal mode back now, so messages end up on the "normal"
    ;; screen (if there are two screens).

    (settmode TMODE_COOK)
    (stop-termcap)
    (out-flush)
    nil)

;; Preserve files and exit.
;; When called ioBuff must contain a message.
;; NOTE: This may be called from deathtrap() in a signal handler,
;; avoid unsafe functions, such as allocating memory.

(defn- #_void preserve-exit [#_Bytes msg]
    (prepare-to-exit)

    (out-str msg)
    (screen-start)                 ;; don't know where cursor is now
    (out-flush)

    (out-str (u8 "Vim: Finished.\n"))

    (getout 1)
    nil)

;; Check for CTRL-C pressed, but only once in a while.
;; Should be used instead of ui-breakcheck() for functions that check for each line in the file.
;; Calling ui-breakcheck() each time takes too much time, because it can be a system call.

(final int BREAKCHECK_SKIP 32)

(atom! int breakcheck_count)

(defn- #_boolean slow-breakcheck []
    (when (<= BREAKCHECK_SKIP (swap! breakcheck_count inc))
        (reset! breakcheck_count 0)
        (ui-breakcheck))
    @got_int)

;; Like slow-breakcheck() but check 10 times less often.

(defn- #_boolean fast-breakcheck []
    (when (<= (* BREAKCHECK_SKIP 10) (swap! breakcheck_count inc))
        (reset! breakcheck_count 0)
        (ui-breakcheck))
    @got_int)

;; Return true when need to go to Insert mode because of 'insertmode'.
;; Don't do this when still processing a command or a mapping.
;; Don't do this when inside a ":normal" command.

(defn- #_boolean goto-im []
    (and @p_im (stuff-empty)))

;; Return true if in the current mode we need to use virtual.

(defn- #_boolean virtual-active []
    ;; While an operator is being executed we return "virtual_op",
    ;; because VIsual_active has already been reset,
    ;; thus we can't check for "block" being used.
    (if (!= @virtual_op MAYBE)
        (!= @virtual_op FALSE)
        (or (== @ve_flags VE_ALL) (and (flag? @ve_flags VE_BLOCK) @VIsual_active (== @VIsual_mode Ctrl_V)) (and (flag? @ve_flags VE_INSERT) (flag? @State INSERT)))
    ))

;; Get the screen position of the cursor.

(defn- #_int getviscol [#_window_C win]
    (let [a'x (atom (int))]
        (getvvcol win, (:w_cursor win), a'x, nil, nil)
        @a'x
    ))

;; Get the screen position of character col with a coladd in the cursor line.

(defn- #_int getviscol2 [#_window_C win, #_int col, #_int coladd]
    (let [a'x (atom (int))]
        (getvvcol win, (assoc (:w_cursor win) :col col :coladd coladd), a'x, nil, nil)
        @a'x
    ))

;; Go to column "wcol", and add/insert white space as necessary to get the cursor in that column.
;; The caller must have saved the cursor line for undo!

(defn- #_window_C coladvance-force [#_window_C win, #_int wcol]
    (let [[win pos _] (coladvance3 win, (:w_cursor win), true, false, wcol) win (assoc win :w_cursor pos)]
        (if (== wcol MAXCOL)
            (update win :w_valid & (bit-not VALID_VIRTCOL))
        (-> win ;; "w_virtcol" is valid
            (assoc :w_virtcol wcol)
            (update :w_valid | VALID_VIRTCOL)
        ))
    ))

;; Try to advance the cursor to the specified screen column.
;;
;; If virtual editing: fine-tune the cursor position.
;; All virtual positions off the end of a line should share
;; the "col" value (n.b. this is equal to STRLEN(line)),
;; beginning at "coladd" 0.
;;
;; Return true if desired column is reached, false if not.

(defn- #_[window_C boolean] coladvance? [#_window_C win, #_int wcol]
    (let [[win pos #_boolean ?] (coladvance3 win, (:w_cursor win), false, (virtual-active), wcol) win (assoc win :w_cursor pos)]
        (cond (or (== wcol MAXCOL) (not ?))
            [(update win :w_valid & (bit-not VALID_VIRTCOL)) ?]
        (not-at? (ml-get-cursor win) TAB) ;; "w_virtcol" is valid when not on a TAB
            [(-> win (assoc :w_virtcol wcol) (update :w_valid | VALID_VIRTCOL)) ?]
        :else
            [win ?]
        )
    ))

(defn- #_window_C coladvance [#_window_C win, #_int wcol]
    (let [[win _] (coladvance? win, wcol)]
        win
    ))

;; Return in "pos" the position of the cursor advanced to screen column "wcol".

(defn- #_[window_C pos_C] getvpos [#_window_C win, #_pos_C pos, #_int wcol]
    (let [[win pos _] (coladvance3 win, pos, false, (virtual-active), wcol)]
        [win pos]
    ))

(defn- #_[window_C pos_C boolean] coladvance3 [#_window_C win, #_pos_C pos, #_boolean addspaces, #_boolean finetune, #_int wcol]
    ;; addspaces: change the text to achieve our goal?
    ;; finetune: change char offset for the exact column
    ;; wcol: column to move to
    (let-when [#_Bytes line (ml-get (:lnum pos))
        #_boolean one_more (or (flag? @State INSERT) (!= @restart_edit NUL) (and @VIsual_active (not-at? @p_sel (byte \o))) (and (flag? @ve_flags VE_ONEMORE) (< wcol MAXCOL)))
        [win wcol #_int x #_int col abort]
            (if (<= MAXCOL wcol)
                (let [x (+ (dec (STRLEN line)) (if one_more 1 0))
                      win (if (and (or addspaces finetune) (not @VIsual_active))
                            (let [win (assoc win :w_curswant (+ (linetabsize line) (if one_more 1 0)))]
                                (if (< 0 (:w_curswant win)) (update win :w_curswant dec) win))
                            win
                        )]
                    [win wcol x wcol false]
                )
                (let [#_int width (- (:w_width win) (win-col-off win))
                      [#_int csize wcol]
                        (if (and finetune @(:wo_wrap (:w_options win)) (non-zero? (:w_width win)) (<= width wcol))
                            (let [csize (linetabsize line) csize (if (< 0 csize) (dec csize) csize)
                                  wcol (if (and (< (/ csize width) (/ wcol width)) (or (non-flag? @State INSERT) (< (inc csize) wcol)))
                                        ;; In case of line wrapping don't move the cursor beyond the right screen edge.
                                        ;; In Insert mode allow going just beyond the last character
                                        ;; (like what happens when typing and reaching the right window edge).
                                        (dec (* (inc (/ csize width)) width))
                                        wcol
                                    )]
                                [csize wcol])
                            [0 wcol])
                      a'head (atom (int 0)) [csize x col]
                        (loop-when [csize csize #_Bytes s line col 0] (and (<= col wcol) (non-eos? s)) => [csize (BDIFF s, line) col]
                            ;; Count a tab for what it's worth (if list mode not on).
                            (let [csize (win-lbr-chartabsize win, line, s, col, a'head)]
                                (recur csize (.plus s (us-ptr2len-cc s)) (+ col csize))
                            ))
                      ;; Handle all the special cases.  The virtual-active() check is needed to
                      ;; ensure that a virtual position off the end of a line has the correct indexing.
                      ;; The one_more comparison replaces an explicit add of one_more later on.
                      [csize x col]
                        (if (or (< wcol col) (and (not (virtual-active)) (not one_more)))
                            ;; Don't count the chars from 'showbreak'.
                            (let [csize (- csize @a'head)] [csize (dec x) (- col csize)])
                            [csize x col])
                      [x col abort]
                        (if (and (virtual-active) addspaces (or (and (!= col wcol) (!= col (inc wcol))) (< 1 csize)))
                            ;; 'virtualedit' is set: The difference between wcol and col is filled with spaces.
                            (if (eos? line x)
                                ;; Append spaces.
                                (let [#_int n (+ x (- wcol col))
                                      #_Bytes s (Bytes. (inc n))
                                      _ (loop-when-recur [i 0] (< i x) [(inc i)] (.be s i, (.at line i)))
                                      _ (loop-when-recur [i x] (< i n) [(inc i)] (.be s i, (byte \space)))
                                      _ (eos! s n)]
                                    (ml-replace (:lnum pos), s)
                                    (changed-bytes (:lnum pos), x)
                                    [n wcol false]
                                )
                                ;; Break a tab.
                                (let [#_int n (STRLEN line) #_int m (inc (- wcol col csize))] ;; negative!!
                                    (if (< csize (- m))
                                        [x col true] ;; abort!!
                                        (let [#_Bytes s (Bytes. (+ n csize))
                                              _ (loop-when [i 0 j 0] (< j n)
                                                    (let [i (if (!= j x)
                                                                (do (.be s i, (.at line j)) (inc i))
                                                                (loop-when-recur [i i k 0] (< k csize) [(inc i) (inc k)] => i
                                                                    (.be s i, (byte \space)))
                                                            )]
                                                        (recur i (inc j))
                                                    ))
                                              _ (eos! s (dec (+ n csize)))]
                                            (ml-replace (:lnum pos), s)
                                            (changed-bytes (:lnum pos), x)
                                            [(+ x (dec csize) m) (+ col m) false]
                                        ))
                                ))
                            [x col false]
                        )]
                    [win wcol x col abort]
                )
            )] (not abort) => [win pos false]

        (let [pos (assoc pos :col (max 0 x) :coladd 0)
              [pos col]
                (if finetune
                    (if (== wcol MAXCOL)
                        ;; The width of the last character is used to set coladd.
                        (if (not one_more)
                            (let [a'scol (atom (int)) a'ecol (atom (int)) _ (getvcol win, pos, a'scol, nil, a'ecol)]
                                [(assoc pos :coladd (- @a'ecol @a'scol)) col])
                            [pos col]
                        )
                        ;; The difference between wcol and col is used to set coladd.
                        (let [#_int m (- wcol col)
                              pos (if (< 0 m (- MAXCOL (* 2 (:w_width win)))) (assoc pos :coladd m) pos)]
                            [pos (+ col m)]
                        ))
                    [pos col]
                )]
            ;; prevent from moving onto a trail byte
            [win (mb-adjust-pos pos) (not (< col wcol))]
        )
    ))

;; Increment the cursor position.  See incp() for return values.

(defn- #_[window_C int] inc-cursor? [#_window_C win, #_boolean skip_eos]
    (let [[_ ?] ((if skip_eos incl incp) (:w_cursor win))] [(assoc win :w_cursor _) ?]))

(defn- #_window_C inc-cursor [#_window_C win, #_boolean skip_eos]
    (let [[_ ?] (inc-cursor? win, skip_eos)] _))

;; Increment the line pointer "p" crossing line boundaries as necessary.
;; Return 1 when going to the next line.
;; Return 2 when moving forward onto a NUL at the end of the line.
;; Return -1 when at the end of file.
;; Return 0 otherwise.

(defn- #_[pos_C int] incp [#_pos_C p]
    (let [#_Bytes s (ml-get-pos p)]
        (cond (non-eos? s) ;; still within line, move to next char (may be NUL)
            (let [#_int n (us-ptr2len-cc s)] [(update p :col + n) (if (non-eos? s n) 0 2)])
        (!= (:lnum p) (line-count @curbuf)) ;; there is a next line
            [(assoc p :lnum (inc (:lnum p)) :col 0 :coladd 0) 1]
        :else
            [p -1]
        )
    ))

;; incl(): same as incp(), but skip the NUL at the end of non-empty lines

(defn- #_[pos_C int] incl [#_pos_C p]
    (let [[p ? :as _] (incp p)] (if (and (<= 1 ?) (non-zero? (:col p))) (incp p) _)))

;; Decrement the cursor position.  See decp() for return values.

(defn- #_[window_C int] dec-cursor? [#_window_C win, #_boolean skip_eos]
    (let [[_ ?] ((if skip_eos decl decp) (:w_cursor win))] [(assoc win :w_cursor _) ?]))

(defn- #_window_C dec-cursor [#_window_C win, #_boolean skip_eos]
    (let [[_ ?] (dec-cursor? win, skip_eos)] _))

;; Decrement the line pointer "p" crossing line boundaries as necessary.
;; Return 1 when crossing a line, -1 when at start of file, 0 otherwise.

(defn- #_[pos_C int] decp [#_pos_C p]
    (let [p (assoc p :coladd 0)]
        (cond (< 0 (:col p))                ;; still within line
            (let [p (update p :col dec)
                  #_Bytes s (ml-get (:lnum p))
                  p (update p :col #(- % (us-head-off s, (.plus s %))))]
                [p 0])
        (< 1 (:lnum p))                     ;; there is a prior line
            (let [p (update p :lnum dec)
                  #_Bytes s (ml-get (:lnum p))
                  p (assoc p :col (STRLEN s))
                  p (update p :col #(- % (us-head-off s, (.plus s %))))]
                [p 1])
        :else
            [p -1]                          ;; at start of file
        )
    ))

;; decl(): same as decp(), but skip the NUL at the end of non-empty lines

(defn- #_[pos_C int] decl [#_pos_C p]
    (let [[p ? :as _] (decp p)] (if (and (== ? 1) (non-zero? (:col p))) (decp p) _)))

;; Get the line number relative to the current cursor position,
;; i.e. the difference between line number and cursor position.
;; Only look for lines that can be visible, folded lines don't count.

(defn- #_long get-cursor-rel-lnum [#_window_C win, #_long lnum]
    ;; lnum: line number to get the result for
    (- lnum (:lnum (:w_cursor win))))

;; Make sure win.w_cursor.lnum is valid.

(defn- #_window_C check-cursor-lnum [#_window_C win]
    (update-in win [:w_cursor :lnum] #(max 1 (min % (line-count @curbuf)))))

;; Make sure win.w_cursor.col is valid.

(defn- #_window_C check-cursor-col [#_window_C win]
    (let [_ (:w_cursor win) col' (:col _) coladd' (+ col' (:coladd _)) len (STRLEN (ml-get (:lnum _)))
          win (cond (zero? len)
                (assoc-in win [:w_cursor :col] 0)
            (<= len col')
                ;; Allow cursor past end-of-line when in Insert mode or restarting Insert mode, or in Visual mode and 'selection' isn't "old", or 'virtualedit' is set.
                (if (or (flag? @State INSERT) (non-zero? @restart_edit) (and @VIsual_active (not-at? @p_sel (byte \o))) (flag? @ve_flags VE_ONEMORE) (virtual-active))
                    (assoc-in win [:w_cursor :col] len)
                    ;; Move the cursor to the head byte.
                    (-> win (assoc-in [:w_cursor :col] (dec len))
                            (update :w_cursor mb-adjust-pos)
                    ))
            (< col' 0)
                (assoc-in win [:w_cursor :col] 0)
            :else
                win
            )]
        ;; In virtual editing we can leave the cursor at the old position, just set it to virtual; but don't do it at end-of-line.
        (cond (== col' MAXCOL)
            (assoc-in win [:w_cursor :coladd] 0)
        (== @ve_flags VE_ALL)
            (assoc-in win [:w_cursor :coladd] (max 0 (- coladd' (:col (:w_cursor win)))))
        :else
            win
        )
    ))

;; Make sure win.w_cursor in on a valid character.

(defn- #_window_C check-cursor [#_window_C win]
    (-> win (check-cursor-lnum) (check-cursor-col)))

;; Make sure win.w_cursor is not on the NUL at the end of the line.
;; Allow it when in Visual mode and 'selection' is not "old".

(defn- #_window_C adjust-cursor-col [#_window_C win]
    (if (and (pos? (:col (:w_cursor win))) (or (not @VIsual_active) (at? @p_sel (byte \o))) (== (gchar-cursor win) NUL))
        (update-in win [:w_cursor :col] dec)
        win
    ))

;; When "w_leftcol" has changed, adjust the cursor position.
;; Return true if the cursor was moved.

(defn- #_[window_C boolean] leftcol-changed? [#_window_C win]
    (let [win (changed-cline-bef-curs win)
          lastcol (dec (- (+ (:w_leftcol win) (:w_width win)) (win-col-off win)))
          win (validate-virtcol win)
          ;; If the cursor is right or left of the screen, move it to last or first character.
          [win changed?] (cond
                (< (- lastcol @p_siso) (:w_virtcol win))          [(coladvance win, (- lastcol @p_siso)) true]
                (< (:w_virtcol win) (+ (:w_leftcol win) @p_siso)) [(coladvance win, (+ (:w_leftcol win) @p_siso)) true]
                :else                                             [win false])
          ;; If the start of the char under the cursor is not on the screen, advance the cursor one more char.
          ;; If this fails (last char of the line), adjust the scrolling.
          a's (atom (int)) a'e (atom (int)) _ (getvvcol win, (:w_cursor win), a's, nil, a'e)
          [win changed?] (cond
                (< lastcol @a'e)            [(coladvance win, (dec @a's)) true]
                (< @a's (:w_leftcol win)) ;; there isn't another character ;; adjust "w_leftcol" instead
                                            (let [[win ?] (coladvance? win, (inc @a'e))] [(if (not ?) (-> win (assoc :w_leftcol @a's) (changed-cline-bef-curs)) win) true])
                :else                       [win changed?])
          win (if changed? (assoc win :w_set_curswant true) win)]
        [(redraw-later win, NOT_VALID) changed?]
    ))

(defn- #_window_C leftcol-changed [#_window_C win]
    (let [[win _] (leftcol-changed? win)]
        win
    ))

;; Copy "s" into newly allocated memory.

(defn- #_Bytes STRDUP [#_Bytes s]
    (let [n (inc (STRLEN s)) s' (Bytes. n)]
        (BCOPY s', s, n)
        s'
    ))

;; Copy up to "n" bytes of "s" into newly allocated memory and terminate with a NUL.
;; The allocated memory always has size "n + 1", also when "s" is shorter.

(defn- #_Bytes STRNDUP [#_Bytes s, #_int n]
    (let [s' (Bytes. (inc n))]
        (STRNCPY s', s, n)
        (eos! s' n)
    ))

;; Same as STRDUP(), but any characters found in esc_chars are preceded by a backslash.

(defn- #_Bytes vim-strsave-escaped [#_Bytes string, #_Bytes esc_chars, #_int cc]
    ;; First count the number of backslashes required, then allocate the memory and insert them.
    (let [#_int n (loop-when [#_Bytes s string n 1] (non-eos? s) => n                                       ;; count the trailing NUL
                    (let [#_int l (us-ptr2len-cc s)
                          [s n] (if (< 1 l)
                                    [(.plus s l) (+ n l)]                                                   ;; count a multibyte char
                                    [(.plus s 1) (+ n (if (some? (vim-strchr esc_chars, (.at s 0))) 2 1))]  ;; count a 'cc' + an ordinary char
                                )]
                        (recur s n)
                    ))
          #_Bytes q (Bytes. n)]
        (loop-when [#_Bytes s string #_Bytes p q] (non-eos? s) => (eos! p)
            (let [#_int l (us-ptr2len-cc s)
                  [s p] (if (< 1 l)
                            (do (BCOPY p, s, l) [(.plus s l) (.plus p l)])
                            (let [p (if (some? (vim-strchr esc_chars, (.at s 0))) (do (.be p 0, cc) (.plus p 1)) p)] (.be p 0, (.at s 0)) [(.plus s 1) (.plus p 1)])
                        )]
                (recur s p)
            ))
    q))

;; ASCII lower-to-upper case translation, language independent.

(defn- #_Bytes vim-strup [#_Bytes s]
    (when (some? s)
        (loop-when-recur [i 0] (non-eos? s i) [(inc i)] (let [c (.at s i)] (.be s i, (if (<= (byte \a) c (byte \z)) (- c 0x20) c)))))
    s)

;; Like STRDUP(), but make all characters uppercase.
;; This uses ASCII lower-to-upper case translation, language independent.

(defn- #_Bytes vim-strsave-up [#_Bytes s]
    (vim-strup (STRDUP s)))

;; Copy a character a number of times.
;; Does not work for multi-byte characters!

(defn- #_void copy-chars [#_Bytes s, #_int i, #_int n, #_int c]
    (loop-when-recur [i i n n] (< 0 n) [(inc i) (dec n)]
        (.be s i, c))
    nil)

;; Like strncpy(), but always terminate the result with one NUL.
;; "dst" must be "len + 1" long!

(defn- #_void vim-strncpy [#_Bytes dst, #_Bytes src, #_int len]
    (STRNCPY dst, src, len)
    (eos! dst len)
    nil)

;; Like strcat(), but make sure the result fits in "size" bytes
;; and is always NUL terminated.

(defn- #_void vim-strcat [#_Bytes dst, #_Bytes src, #_int size]
    (let [#_int dlen (STRLEN dst) #_int slen (STRLEN src)]
        (if (< size (+ dlen slen 1))
            (do (BCOPY dst, dlen, src, 0, (- size dlen 1)) (eos! dst (dec size)))
            (STRCPY (.plus dst dlen), src)
        ))
    nil)

;; Isolate one part of a string option where parts are separated with "sep_chars".
;; The part is copied into "buf[maxlen]".
;; "*option" is advanced to the next part.
;; The length is returned.

(defn- #_int copy-option-part [#_Bytes' a'option, #_Bytes buf, #_int maxlen, #_Bytes sep_chars]
    (let [s @a'option n 0
          ;; skip '.' at start of option part, for 'suffixes'
          [s n] (if (at? s (byte \.)) (do (.be buf n, (.at s 0)) [(.plus s 1) (inc n)]) [s n])
          [s n] (loop-when [s s n n] (and (non-eos? s) (nil? (vim-strchr sep_chars, (.at s 0)))) => [s n]
                    ;; skip backslash before a separator character and space
                    (let [s (if (and (at? s (byte \\)) (some? (vim-strchr sep_chars, (.at s 1)))) (.plus s 1) s)
                          n (if (< n (dec maxlen)) (do (.be buf n, (.at s 0)) (inc n)) n)]
                        (recur (.plus s 1) n)
                    ))
          _ (eos! buf n)
          s (if (and (non-eos? s) (not-at? s (byte \,))) (.plus s 1) s) ;; skip non-standard separator
          s (skip-to-option-part s)]
        (reset! a'option s)
    n))

;; Version of strchr() and strrchr() that handle unsigned char strings
;; with characters from 128 to 255 correctly.  It also doesn't return
;; a pointer to the NUL at the end of the string.

(defn- #_Bytes vim-strchr [#_Bytes p, #_int c]
    (loop-when p (non-eos? p) => nil
        (recur-if (!= (us-ptr2char p) c) (.plus p (us-ptr2len-cc p)) => p)
    ))

;; Version of strchr() that only works for bytes and handles unsigned char
;; strings with characters above 128 correctly.  It also doesn't return a
;; pointer to the NUL at the end of the string.

(defn- #_Bytes vim-strbyte [#_Bytes p, #_byte b]
    (loop-when p (non-eos? p) => nil
        (recur-if (not-at? p b) (.plus p 1) => p)
    ))

;; Search for last occurrence of "b" in "p".
;; Return null if not found.
;; Does not handle multi-byte char for "b"!

(defn- #_Bytes vim-strrchr [#_Bytes p, #_byte b]
    (loop-when-recur [#_Bytes q nil p p] (non-eos? p) [(if (at? p b) p q) (.plus p (us-ptr2len-cc p))] => q))

;; Vim has its own isspace() function, because on some machines isspace()
;; can't handle characters above 128.

(defn- #_boolean vim-isspace [#_int x]
    (or (<= 9 x 13) (== x (byte \space))))

;; Some useful tables.

(class! #_final modmasktable_C
    [
        (field int      mod_mask)       ;; bit-mask for particular key modifier
        (field int      mod_flag)       ;; bit(s) for particular key modifier
        (field byte     name)           ;; single letter name of modifier
    ])

(final modmasktable_C* mod_mask_table
    [
        (->modmasktable_C MOD_MASK_ALT,         MOD_MASK_ALT,    (byte \M)),
        (->modmasktable_C MOD_MASK_META,        MOD_MASK_META,   (byte \T)),
        (->modmasktable_C MOD_MASK_CTRL,        MOD_MASK_CTRL,   (byte \C)),
        (->modmasktable_C MOD_MASK_SHIFT,       MOD_MASK_SHIFT,  (byte \S)),
        (->modmasktable_C MOD_MASK_MULTI_CLICK, MOD_MASK_2CLICK, (byte \2)),
        (->modmasktable_C MOD_MASK_MULTI_CLICK, MOD_MASK_3CLICK, (byte \3)),
        (->modmasktable_C MOD_MASK_MULTI_CLICK, MOD_MASK_4CLICK, (byte \4)),
        ;; 'A' must be the last one
        (->modmasktable_C MOD_MASK_ALT,         MOD_MASK_ALT,    (byte \A))
    ])

;; Shifted key terminal codes and their unshifted equivalent.

(final int MOD_KEYS_ENTRY_SIZE 5)

(final byte* modifier_keys_table
    [
     ;; mod mask            with modifier           without modifier
        MOD_MASK_SHIFT,     (byte \&), (byte \9),   (byte \@), (byte \1),   ;; begin
        MOD_MASK_SHIFT,     (byte \&), (byte \0),   (byte \@), (byte \2),   ;; cancel
        MOD_MASK_SHIFT,     (byte \*), (byte \1),   (byte \@), (byte \4),   ;; command
        MOD_MASK_SHIFT,     (byte \*), (byte \2),   (byte \@), (byte \5),   ;; copy
        MOD_MASK_SHIFT,     (byte \*), (byte \3),   (byte \@), (byte \6),   ;; create
        MOD_MASK_SHIFT,     (byte \*), (byte \4),   (byte \k), (byte \D),   ;; delete char
        MOD_MASK_SHIFT,     (byte \*), (byte \5),   (byte \k), (byte \L),   ;; delete line
        MOD_MASK_SHIFT,     (byte \*), (byte \7),   (byte \@), (byte \7),   ;; end
        MOD_MASK_CTRL,      KS_EXTRA, KE_C_END,     (byte \@), (byte \7),   ;; end
        MOD_MASK_SHIFT,     (byte \*), (byte \9),   (byte \@), (byte \9),   ;; exit
        MOD_MASK_SHIFT,     (byte \*), (byte \0),   (byte \@), (byte \0),   ;; find
        MOD_MASK_SHIFT,     (byte \#), (byte \1),   (byte \%), (byte \1),   ;; help
        MOD_MASK_SHIFT,     (byte \#), (byte \2),   (byte \k), (byte \h),   ;; home
        MOD_MASK_CTRL,      KS_EXTRA, KE_C_HOME,    (byte \k), (byte \h),   ;; home
        MOD_MASK_SHIFT,     (byte \#), (byte \3),   (byte \k), (byte \I),   ;; insert
        MOD_MASK_SHIFT,     (byte \#), (byte \4),   (byte \k), (byte \l),   ;; left arrow
        MOD_MASK_CTRL,      KS_EXTRA, KE_C_LEFT,    (byte \k), (byte \l),   ;; left arrow
        MOD_MASK_SHIFT,     (byte \%), (byte \a),   (byte \%), (byte \3),   ;; message
        MOD_MASK_SHIFT,     (byte \%), (byte \b),   (byte \%), (byte \4),   ;; move
        MOD_MASK_SHIFT,     (byte \%), (byte \c),   (byte \%), (byte \5),   ;; next
        MOD_MASK_SHIFT,     (byte \%), (byte \d),   (byte \%), (byte \7),   ;; options
        MOD_MASK_SHIFT,     (byte \%), (byte \e),   (byte \%), (byte \8),   ;; previous
        MOD_MASK_SHIFT,     (byte \%), (byte \f),   (byte \%), (byte \9),   ;; print
        MOD_MASK_SHIFT,     (byte \%), (byte \g),   (byte \%), (byte \0),   ;; redo
        MOD_MASK_SHIFT,     (byte \%), (byte \h),   (byte \&), (byte \3),   ;; replace
        MOD_MASK_SHIFT,     (byte \%), (byte \i),   (byte \k), (byte \r),   ;; right arrow
        MOD_MASK_CTRL,      KS_EXTRA, KE_C_RIGHT,   (byte \k), (byte \r),   ;; right arrow
        MOD_MASK_SHIFT,     (byte \%), (byte \j),   (byte \&), (byte \5),   ;; resume
        MOD_MASK_SHIFT,     (byte \!), (byte \1),   (byte \&), (byte \6),   ;; save
        MOD_MASK_SHIFT,     (byte \!), (byte \2),   (byte \&), (byte \7),   ;; suspend
        MOD_MASK_SHIFT,     (byte \!), (byte \3),   (byte \&), (byte \8),   ;; undo
        MOD_MASK_SHIFT,     KS_EXTRA, KE_S_UP,      (byte \k), (byte \u),   ;; up arrow
        MOD_MASK_SHIFT,     KS_EXTRA, KE_S_DOWN,    (byte \k), (byte \d),   ;; down arrow

                                                                            ;; vt100 F1
        MOD_MASK_SHIFT,     KS_EXTRA, KE_S_XF1,     KS_EXTRA, KE_XF1,
        MOD_MASK_SHIFT,     KS_EXTRA, KE_S_XF2,     KS_EXTRA, KE_XF2,
        MOD_MASK_SHIFT,     KS_EXTRA, KE_S_XF3,     KS_EXTRA, KE_XF3,
        MOD_MASK_SHIFT,     KS_EXTRA, KE_S_XF4,     KS_EXTRA, KE_XF4,

        MOD_MASK_SHIFT,     KS_EXTRA, KE_S_F1,      (byte \k), (byte \1),   ;; F1
        MOD_MASK_SHIFT,     KS_EXTRA, KE_S_F2,      (byte \k), (byte \2),
        MOD_MASK_SHIFT,     KS_EXTRA, KE_S_F3,      (byte \k), (byte \3),
        MOD_MASK_SHIFT,     KS_EXTRA, KE_S_F4,      (byte \k), (byte \4),
        MOD_MASK_SHIFT,     KS_EXTRA, KE_S_F5,      (byte \k), (byte \5),
        MOD_MASK_SHIFT,     KS_EXTRA, KE_S_F6,      (byte \k), (byte \6),
        MOD_MASK_SHIFT,     KS_EXTRA, KE_S_F7,      (byte \k), (byte \7),
        MOD_MASK_SHIFT,     KS_EXTRA, KE_S_F8,      (byte \k), (byte \8),
        MOD_MASK_SHIFT,     KS_EXTRA, KE_S_F9,      (byte \k), (byte \9),
        MOD_MASK_SHIFT,     KS_EXTRA, KE_S_F10,     (byte \k), (byte \;),   ;; F10

        MOD_MASK_SHIFT,     KS_EXTRA, KE_S_F11,     (byte \F), (byte \1),
        MOD_MASK_SHIFT,     KS_EXTRA, KE_S_F12,     (byte \F), (byte \2),

        MOD_MASK_SHIFT,     (byte \k), (byte \B),   KS_EXTRA, KE_TAB,       ;; TAB pseudo code

        NUL
    ])

(class! #_final key_name_C
    [
        (field int      key)        ;; special key code or ascii value
        (field Bytes    name)       ;; name of key
    ])

(final key_name_C* key_names_table
    [
        (->key_name_C (int \space),     (u8 "Space")           ),
        (->key_name_C TAB,              (u8 "Tab")             ),
        (->key_name_C K_TAB,            (u8 "Tab")             ),
        (->key_name_C NL,               (u8 "NL")              ),
        (->key_name_C NL,               (u8 "NewLine")         ),  ;; alternative name
        (->key_name_C NL,               (u8 "LineFeed")        ),  ;; alternative name
        (->key_name_C NL,               (u8 "LF")              ),  ;; alternative name
        (->key_name_C CAR,              (u8 "CR")              ),
        (->key_name_C CAR,              (u8 "Return")          ),  ;; alternative name
        (->key_name_C CAR,              (u8 "Enter")           ),  ;; alternative name
        (->key_name_C K_BS,             (u8 "BS")              ),
        (->key_name_C K_BS,             (u8 "BackSpace")       ),  ;; alternative name
        (->key_name_C ESC,              (u8 "Esc")             ),
        (->key_name_C (int \|),         (u8 "Bar")             ),
        (->key_name_C (int \\),         (u8 "Bslash")          ),
        (->key_name_C K_DEL,            (u8 "Del")             ),
        (->key_name_C K_DEL,            (u8 "Delete")          ),  ;; alternative name
        (->key_name_C K_KDEL,           (u8 "kDel")            ),
        (->key_name_C K_UP,             (u8 "Up")              ),
        (->key_name_C K_DOWN,           (u8 "Down")            ),
        (->key_name_C K_LEFT,           (u8 "Left")            ),
        (->key_name_C K_RIGHT,          (u8 "Right")           ),
        (->key_name_C K_XUP,            (u8 "xUp")             ),
        (->key_name_C K_XDOWN,          (u8 "xDown")           ),
        (->key_name_C K_XLEFT,          (u8 "xLeft")           ),
        (->key_name_C K_XRIGHT,         (u8 "xRight")          ),

        (->key_name_C K_F1,             (u8 "F1")              ),
        (->key_name_C K_F2,             (u8 "F2")              ),
        (->key_name_C K_F3,             (u8 "F3")              ),
        (->key_name_C K_F4,             (u8 "F4")              ),
        (->key_name_C K_F5,             (u8 "F5")              ),
        (->key_name_C K_F6,             (u8 "F6")              ),
        (->key_name_C K_F7,             (u8 "F7")              ),
        (->key_name_C K_F8,             (u8 "F8")              ),
        (->key_name_C K_F9,             (u8 "F9")              ),
        (->key_name_C K_F10,            (u8 "F10")             ),

        (->key_name_C K_F11,            (u8 "F11")             ),
        (->key_name_C K_F12,            (u8 "F12")             ),

        (->key_name_C K_XF1,            (u8 "xF1")             ),
        (->key_name_C K_XF2,            (u8 "xF2")             ),
        (->key_name_C K_XF3,            (u8 "xF3")             ),
        (->key_name_C K_XF4,            (u8 "xF4")             ),

        (->key_name_C K_HELP,           (u8 "Help")            ),
        (->key_name_C K_UNDO,           (u8 "Undo")            ),
        (->key_name_C K_INS,            (u8 "Insert")          ),
        (->key_name_C K_INS,            (u8 "Ins")             ),  ;; alternative name
        (->key_name_C K_KINS,           (u8 "kInsert")         ),
        (->key_name_C K_HOME,           (u8 "Home")            ),
        (->key_name_C K_KHOME,          (u8 "kHome")           ),
        (->key_name_C K_XHOME,          (u8 "xHome")           ),
        (->key_name_C K_ZHOME,          (u8 "zHome")           ),
        (->key_name_C K_END,            (u8 "End")             ),
        (->key_name_C K_KEND,           (u8 "kEnd")            ),
        (->key_name_C K_XEND,           (u8 "xEnd")            ),
        (->key_name_C K_ZEND,           (u8 "zEnd")            ),
        (->key_name_C K_PAGEUP,         (u8 "PageUp")          ),
        (->key_name_C K_PAGEDOWN,       (u8 "PageDown")        ),
        (->key_name_C K_KPAGEUP,        (u8 "kPageUp")         ),
        (->key_name_C K_KPAGEDOWN,      (u8 "kPageDown")       ),

        (->key_name_C K_KPLUS,          (u8 "kPlus")           ),
        (->key_name_C K_KMINUS,         (u8 "kMinus")          ),
        (->key_name_C K_KDIVIDE,        (u8 "kDivide")         ),
        (->key_name_C K_KMULTIPLY,      (u8 "kMultiply")       ),
        (->key_name_C K_KENTER,         (u8 "kEnter")          ),
        (->key_name_C K_KPOINT,         (u8 "kPoint")          ),

        (->key_name_C K_K0,             (u8 "k0")              ),
        (->key_name_C K_K1,             (u8 "k1")              ),
        (->key_name_C K_K2,             (u8 "k2")              ),
        (->key_name_C K_K3,             (u8 "k3")              ),
        (->key_name_C K_K4,             (u8 "k4")              ),
        (->key_name_C K_K5,             (u8 "k5")              ),
        (->key_name_C K_K6,             (u8 "k6")              ),
        (->key_name_C K_K7,             (u8 "k7")              ),
        (->key_name_C K_K8,             (u8 "k8")              ),
        (->key_name_C K_K9,             (u8 "k9")              ),

        (->key_name_C (int \<),         (u8 "lt")              ),

        (->key_name_C K_DROP,           (u8 "Drop")            ),
        (->key_name_C K_ZERO,           (u8 "Nul")             ),

        (->key_name_C K_CURSORHOLD,     (u8 "CursorHold")      ),
    ])

;; Check if there is a special key code for "key" that includes the modifiers specified.

(defn- #_int simplify-key [#_int key, #_int' a'modifiers]
    (if (flag? @a'modifiers (| MOD_MASK_SHIFT MOD_MASK_CTRL MOD_MASK_ALT))
        ;; TAB is a special case.
        (if (and (== key TAB) (flag? @a'modifiers MOD_MASK_SHIFT))
            (do (swap! a'modifiers & (bit-not MOD_MASK_SHIFT))
                K_S_TAB)
            (let [#_byte* t modifier_keys_table #_byte key0 (KEY2TERMCAP0 key) #_byte key1 (KEY2TERMCAP1 key)]
                (loop-when [#_int i 0] (!= (... t i) NUL) => key
                    (if (and (== key0 (... t (+ i 3))) (== key1 (... t (+ i 4))) (non-zero? (& @a'modifiers (char_u (... t i)))))
                        (do (swap! a'modifiers & (bit-not (char_u (... t i))))
                            (TERMCAP2KEY (... t (+ i 1)), (... t (+ i 2))))
                        (recur (+ i MOD_KEYS_ENTRY_SIZE))
                    ))
            ))
        key
    ))

;; Change <xHome> to <Home>, <xUp> to <Up>, etc.

(defn- #_int handle-x-keys [#_int key]
    (condp == key
        K_XUP    K_UP
        K_XDOWN  K_DOWN
        K_XLEFT  K_LEFT
        K_XRIGHT K_RIGHT
        K_XHOME  K_HOME
        K_ZHOME  K_HOME
        K_XEND   K_END
        K_ZEND   K_END
        K_XF1    K_F1
        K_XF2    K_F2
        K_XF3    K_F3
        K_XF4    K_F4
        K_S_XF1  K_S_F1
        K_S_XF2  K_S_F2
        K_S_XF3  K_S_F3
        K_S_XF4  K_S_F4
        :else    key
    ))

;; Return a string which contains the name of the given key when the given modifiers are down.

(defn- #_Bytes get-special-key-name [#_int c, #_int modifiers]
    ;; Key, that stands for a normal character.
    (let [c (if (and (is-special c) (== (KEY2TERMCAP0 c) KS_KEY)) (char_u (KEY2TERMCAP1 c)) c)
          ;; Translate shifted special keys into unshifted keys and set modifier.
          ;; Same for CTRL and ALT modifiers.
          [modifiers c]
            (if (is-special c)
                (let [#_byte* t modifier_keys_table #_byte key0 (KEY2TERMCAP0 c) #_byte key1 (KEY2TERMCAP1 c)]
                    (loop-when [#_int i 0] (!= (... t i) NUL) => [modifiers c]
                        (if (and (== key0 (... t (+ i 1))) (== key1 (... t (+ i 2))))
                            [(| modifiers (char_u (... t i))) (TERMCAP2KEY (... t (+ i 3)), (... t (+ i 4)))]
                            (recur (+ i MOD_KEYS_ENTRY_SIZE))
                        )))
                [modifiers c])
          ;; try to find the key in the special key table
          #_Bytes y (find-special-key-name c)
          ;; When not a known special key, and not a printable character, try to extract modifiers.
          [c modifiers y]
            (if (and (< 0 c) (== (utf-char2len c) 1))
                (let [[c modifiers y]
                        (if (and (nil? y) (or (not (vim-isprintc c)) (== (& c 0x7f) (byte \space))) (!= (& c 0x80) NUL))
                            (let [c (& c 0x7f) modifiers (| modifiers MOD_MASK_ALT)]
                                ;; try again, to find the un-ALTed key in the special key table
                                [c modifiers (find-special-key-name c)])
                            [c modifiers y]
                        )]
                    (if (and (nil? y) (not (vim-isprintc c)) (< c (byte \space)))
                        [(+ c (byte \@)) (| modifiers MOD_MASK_CTRL) y]
                        [c modifiers y]
                    ))
                [c modifiers y])
          #_Bytes k (Bytes. (inc MAX_KEY_NAME_LEN)) k! #(do (.be k %1, %2) (inc %1))
          #_int x (k! 0, (byte \<))
          ;; translate the modifier into a string
          x (let [t mod_mask_table n (count t)]
                (loop-when [x x #_int i 0] (and (< i n) (!= (:name (... t i)) (byte \A))) => x
                    (let [x (if (== (& modifiers (:mod_mask (... t i))) (:mod_flag (... t i))) (-> x (k! (:name (... t i))) (k! (byte \-))) x)]
                        (recur x (inc i)))
                ))
          x (cond (some? y) ;; use name of special key
                (do (STRCPY (.plus k x), y) (STRLEN k))
            (is-special c) ;; unknown special key, may output t_xx
                (-> x (k! (byte \t)) (k! (byte \_)) (k! (KEY2TERMCAP0 c)) (k! (KEY2TERMCAP1 c)))
            ;; Not a special key, only modifiers, output directly.
            (< 1 (utf-char2len c))
                (+ x (utf-char2bytes c, (.plus k x)))
            (vim-isprintc c)
                (k! x, c)
            :else
                (let [#_Bytes s (transchar c)]
                    (loop-when-recur [x x #_int i 0] (non-eos? s i) [(inc x) (inc i)] => x
                        (.be k x, (.at s i)))
                ))
          x (k! x, (byte \>))]
        (eos! k x)
    ))

;; Try to find the name of key "c" in the special key table.

(defn- #_Bytes find-special-key-name [#_int c]
    (let [t key_names_table n (count t)]
        (loop-when [i 0] (< i n) => nil
            (recur-if (!= (:key (... t i)) c) [(inc i)] => (:name (... t i))))
    ))

;; VISUAL, SELECTMODE and OP_PENDING State are never set, they are equal to
;; NORMAL State with a condition.  This function returns the real State.

(defn- #_int get-real-state []
    (if (flag? @State NORMAL)
        (cond
            @VIsual_active (if @VIsual_select SELECTMODE VISUAL)
            @finish_op OP_PENDING
            :else @State
        )
        @State
    ))

;; Print an error message with one or two "%s" and one or two string arguments.
;; This is not in message.c to avoid a warning for prototypes.

(defn- #_boolean emsg3 [#_Bytes s, #_Bytes a1, #_Bytes a2]
    (or (emsg-not-now) ;; no error messages at the moment
        (do
;%%         (vim_snprintf @ioBuff, IOSIZE, s, a1, a2)
            (emsg @ioBuff)
        )
    ))

;; Print an error message with one "%ld" and one long int argument.
;; This is not in message.c to avoid a warning for prototypes.

(defn- #_boolean emsgn [#_Bytes s, #_long n]
    (or (emsg-not-now) ;; no error messages at the moment
        (do
;%%         (vim_snprintf @ioBuff, IOSIZE, s, n)
            (emsg @ioBuff)
        )
    ))

;;; ============================================================================================== VimT

;; Return true if the CursorHold event can be triggered.

(defn- #_boolean trigger-cursorhold []
    (let [miez? false]
        (and (not @did_cursorhold) miez? (not @Recording) (zero? (:tb_len @typebuf)) (let [state (get-real-state)] (or (== state NORMAL_BUSY) (flag? state INSERT))))
    ))

;;; ============================================================================================== VimU

;; undo.c: multi level undo facility
;;
;; The saved lines are stored in a list of lists (one for each buffer):
;;
;; b_u_oldhead------------------------------------------------+
;;                                                            |
;;                                                            V
;;                +--------------+    +--------------+    +--------------+
;; b_u_newhead--->| u_header     |    | u_header     |    | u_header     |
;;                |     uh_next------>|     uh_next------>|     uh_next---->null
;;         null<--------uh_prev  |<---------uh_prev  |<---------uh_prev  |
;;                |     uh_entry |    |     uh_entry |    |     uh_entry |
;;                +--------|-----+    +--------|-----+    +--------|-----+
;;                         |                   |                   |
;;                         V                   V                   V
;;                +--------------+    +--------------+    +--------------+
;;                | u_entry      |    | u_entry      |    | u_entry      |
;;                |     ue_next  |    |     ue_next  |    |     ue_next  |
;;                +--------|-----+    +--------|-----+    +--------|-----+
;;                         |                   |                   |
;;                         V                   V                   V
;;                +--------------+            null                null
;;                | u_entry      |
;;                |     ue_next  |
;;                +--------|-----+
;;                         |
;;                         V
;;                        etc.
;;
;; Each u_entry list contains the information for one undo or redo.
;; curbuf.b_u_curhead points to the header of the last undo (the next redo),
;; or is null if nothing has been undone (end of the branch).
;;
;; For keeping alternate undo/redo branches the uh_alt field is used.  Thus at
;; each point in the list a branch may appear for an alternate to redo.  The
;; uh_seq field is numbered sequentially to be able to find a newer or older
;; branch.
;;
;;                 +---------------+    +---------------+
;; b_u_oldhead --->| u_header      |    | u_header      |
;;                 |   uh_alt_next ---->|   uh_alt_next ----> null
;;         null <----- uh_alt_prev |<------ uh_alt_prev |
;;                 |   uh_prev     |    |   uh_prev     |
;;                 +-----|---------+    +-----|---------+
;;                       |                    |
;;                       V                    V
;;                 +---------------+    +---------------+
;;                 | u_header      |    | u_header      |
;;                 |   uh_alt_next |    |   uh_alt_next |
;; b_u_newhead --->|   uh_alt_prev |    |   uh_alt_prev |
;;                 |   uh_prev     |    |   uh_prev     |
;;                 +-----|---------+    +-----|---------+
;;                       |                    |
;;                       V                    V
;;                     null             +---------------+    +---------------+
;;                                      | u_header      |    | u_header      |
;;                                      |   uh_alt_next ---->|   uh_alt_next |
;;                                      |   uh_alt_prev |<------ uh_alt_prev |
;;                                      |   uh_prev     |    |   uh_prev     |
;;                                      +-----|---------+    +-----|---------+
;;                                            |                    |
;;                                           etc.                 etc.
;;
;; All data is allocated and will all be freed when the buffer is unloaded.

;; used in undo_end() to report number of added and deleted lines
(atom! long     u_newcount)
(atom! long     u_oldcount)

;; When 'u' flag included in 'cpoptions', we behave like vi.
;; Need to remember the action that "u" should do.

(atom! boolean  undo_undoes)

(atom! int      lastmark)

;; Save the current line for both the "u" and "U" command.
;; Returns true or false.

(defn- #_boolean u-save-cursor []
    (let [lnum (-> @curwin :w_cursor :lnum)]
        (u-save (dec lnum), (inc lnum))
    ))

;; Save the lines between "top" and "bot" for both the "u" and "U" command.
;; "top" may be 0 and bot may be curbuf.b_ml.ml_line_count + 1.
;; Returns false when lines could not be saved, true otherwise.

(defn- #_boolean u-save [#_long top, #_long bot]
    (let [lmax (line-count @curbuf)]
        (if (or (< lmax top) (<= bot top) (< (inc lmax) bot))
            false   ;; rely on caller to do error messages
            (do
                (if (== (+ top 2) bot)
                    (u-saveline (inc top)))
                (u-savecommon top, bot, 0, false)
            )
        )
    ))

;; Save the line "lnum" (used by ":s" and "~" command).
;; The line is replaced, so the new bottom line is lnum + 1.
;; Returns false when lines could not be saved, true otherwise.

(defn- #_boolean u-savesub [#_long lnum]
    (u-savecommon (dec lnum), (inc lnum), (inc lnum), false))

;; A new line is inserted before line "lnum" (used by :s command).
;; The line is inserted, so the new bottom line is lnum + 1.
;; Returns false when lines could not be saved, true otherwise.

(defn- #_boolean u-inssub [#_long lnum]
    (u-savecommon (dec lnum), lnum, (inc lnum), false))

;; Save the lines "lnum" - "lnum" + nlines (used by delete command).
;; The lines are deleted, so the new bottom line is lnum, unless the buffer becomes empty.
;; Returns false when lines could not be saved, true otherwise.

(defn- #_boolean u-savedel [#_long lnum, #_long nlines]
    (u-savecommon (dec lnum), (+ lnum nlines), (if (== nlines (line-count @curbuf)) 2 lnum), false))

;; Return true when undo is allowed.
;; Otherwise give an error message and return false.

(defn- #_boolean undo-allowed []
    ;; Don't allow changes in the buffer while editing the cmdline.
    ;; The caller of getcmdline() may get confused.
    (if (non-zero? @textlock)
        (do (emsg e_secure) false)
        true
    ))

;; Get the undolevle value for the current buffer.

(defn- #_long get-undolevel []
    @(:b_p_ul @curbuf))

;; Common code for various ways to save text before a change.
;; "top" is the line above the first changed line.
;; "bot" is the line below the last changed line.
;; "newbot" is the new bottom line.  Use zero when not known.
;; "reload" is true when saving for a buffer reload.
;; Returns false when lines could not be saved, true otherwise.

(defn- #_boolean u-savecommon [#_long top, #_long bot, #_long newbot, #_boolean reload]
    (ยง
        (when (not reload)
            ;; When making changes is not allowed, return false.
            ;; It's a crude way to make all change commands fail.
            (if (not (undo-allowed))
                ((ร RETURN) false)
            )

            (when (< (inc (line-count @curbuf)) bot)
                ;; This happens when the FileChangedRO autocommand changes
                ;; the file in a way it becomes shorter.
                (emsg (u8 "E881: Line count changed unexpectedly"))
                ((ร RETURN) false)
            )
        )

        ((ร long size =) (- bot top 1))

        ;; If curbuf.b_u_synced == true make a new header.

        (cond (:b_u_synced @curbuf)
        (do
            ;; Need to create new entry in b_changelist.
            (swap! curbuf assoc :b_new_change true)

            ((ร u_header_C uhp =) (if (<= 0 (get-undolevel)) (NEW_u_header_C) nil))

            ;; If we undid more than we redid, move the entry lists before
            ;; and including curbuf.b_u_curhead to an alternate branch.

            ((ร u_header_C[] a'old_curhead =) (atom (#_u_header_C object (:b_u_curhead @curbuf))))
            (when (some? @a'old_curhead)
                (swap! curbuf assoc :b_u_newhead (:ptr (:uh_next @a'old_curhead)))
                (swap! curbuf assoc :b_u_curhead nil)
            )

            ;; free headers to keep the size right

            (loop-when [] (and (< (get-undolevel) (:b_u_numhead @curbuf)) (some? (:b_u_oldhead @curbuf)))
                ((ร u_header_C uhfree =) (:b_u_oldhead @curbuf))

                (cond (== uhfree @a'old_curhead)
                (do
                    ;; Can't reconnect the branch, delete all of it.
                    (u-freebranch uhfree, a'old_curhead)
                )
                (nil? (:ptr (:uh_alt_next uhfree)))
                (do
                    ;; There is no branch, only free one header.
                    (u-freeheader uhfree, a'old_curhead)
                )
                :else
                (do
                    ;; Free the oldest alternate branch as a whole.
                    (loop-when [] (some? (:ptr (:uh_alt_next uhfree)))
                        ((ร uhfree =) (:ptr (:uh_alt_next uhfree)))
                        (recur)
                    )
                    (u-freebranch uhfree, a'old_curhead)
                ))
                (recur)
            )

            (when (nil? uhp)                ;; no undo at all
                (if (some? @a'old_curhead)
                    (u-freebranch @a'old_curhead, nil))
                (swap! curbuf assoc :b_u_synced false)
                ((ร RETURN) true)
            )

            ((ร uhp =) (assoc-in uhp [:uh_prev :ptr] nil))
            ((ร uhp =) (assoc-in uhp [:uh_next :ptr] (:b_u_newhead @curbuf)))
            ((ร uhp =) (assoc-in uhp [:uh_alt_next :ptr] @a'old_curhead))
            (cond (some? @a'old_curhead)
            (do
                ((ร uhp =) (assoc-in uhp [:uh_alt_prev :ptr] (:ptr (:uh_alt_prev @a'old_curhead))))
                (if (some? (:ptr (:uh_alt_prev uhp)))
                    ((ร uhp.uh_alt_prev.ptr.uh_alt_next.ptr =) uhp)
                )
                (swap! a'old_curhead assoc-in [:uh_alt_prev :ptr] uhp)
                (when (== (:b_u_oldhead @curbuf) @a'old_curhead)
                    (swap! curbuf assoc :b_u_oldhead uhp))
            )
            :else
            (do
                ((ร uhp =) (assoc-in uhp [:uh_alt_prev :ptr] nil))
            ))
            (when (some? (:b_u_newhead @curbuf))
                (swap! curbuf assoc-in [:b_u_newhead :uh_prev :ptr] uhp))

            ((ร uhp =) (assoc uhp :uh_seq (ร ++@curbuf.b_u_seq_last)))
            (swap! curbuf assoc :b_u_seq_cur (:uh_seq uhp))
            ((ร uhp =) (assoc uhp :uh_time (._time libC)))
            (swap! curbuf assoc :b_u_time_cur (inc (:uh_time uhp)))

            ((ร uhp =) (assoc uhp :uh_walk 0))
            ((ร uhp =) (assoc uhp :uh_entry nil))
            ((ร uhp =) (assoc uhp :uh_getbot_entry nil))
            (COPY-pos (:uh_cursor uhp), (:w_cursor @curwin)) ;; save cursor pos. for undo
            ((ร uhp =) (assoc uhp :uh_cursor_vcol (if (and (virtual-active) (< 0 (:coladd (:w_cursor @curwin)))) (getviscol @curwin) -1)))

            ;; save changed and buffer empty flag for undo
            ((ร uhp =) (assoc uhp :uh_flags (+ (if @(:b_changed @curbuf) UH_CHANGED 0) (if (flag? (:ml_flags (:b_ml @curbuf)) ML_EMPTY) UH_EMPTYBUF 0))))

            ;; save named marks and Visual marks for undo
            (dotimes [#_int i NMARKS]
                (COPY-pos (... (:uh_namedm uhp) i), (... (:b_namedm @curbuf) i))
            )
            (COPY-visualinfo (:uh_visual uhp), (:b_visual @curbuf))

            (swap! curbuf assoc :b_u_newhead uhp)
            (when (nil? (:b_u_oldhead @curbuf))
                (swap! curbuf assoc :b_u_oldhead uhp))
            (swap! curbuf update :b_u_numhead inc)
        )
        :else
        (do
            (if (< (get-undolevel) 0)        ;; no undo at all
                ((ร RETURN) true)
            )

            ;; When saving a single line, and it has been saved just before, it
            ;; doesn't make sense saving it again.  Saves a lot of memory when
            ;; making lots of changes inside the same line.
            ;; This is only possible if the previous change didn't increase or
            ;; decrease the number of lines.
            ;; Check the ten last changes.  More doesn't make sense and takes too long.

            (when (== size 1)
                ((ร u_entry_C uep =) (u-get-headentry))
                ((ร u_entry_C prev_uep =) nil)
                (dotimes [#_int i 10]
                    (if (nil? uep)
                        (ร BREAK)
                    )

                    ;; If lines have been inserted/deleted we give up.
                    ;; Also when the line was included in a multi-line save.
                    (if (or (if (!= (:uh_getbot_entry (:b_u_newhead @curbuf)) uep) (!= (+ (:ue_top uep) (:ue_size uep) 1) (if (zero? (:ue_bot uep)) (inc (line-count @curbuf)) (:ue_bot uep))) (!= (:ue_lcount uep) (line-count @curbuf))) (and (< 1 (:ue_size uep)) (<= (:ue_top uep) top) (<= (+ top 2) (+ (:ue_top uep) (:ue_size uep) 1))))
                        (ร BREAK)
                    )

                    ;; If it's the same line we can skip saving it again.
                    (when (and (== (:ue_size uep) 1) (== (:ue_top uep) top))
                        (when (< 0 i)
                            ;; It's not the last entry: get ue_bot for the last entry now.
                            ;; Following deleted/inserted lines go to the re-used entry.
                            (u-getbot)
                            (swap! curbuf assoc :b_u_synced false)

                            ;; Move the found entry to become the last entry.
                            ;; The order of undo/redo doesn't matter for the entries we move it over,
                            ;; since they don't change the line count and don't include this line.
                            ;; It does matter for the found entry if the line count is changed
                            ;; by the executed command.
                            ((ร prev_uep.ue_next =) (:ue_next uep))
                            ((ร uep =) (assoc uep :ue_next (:uh_entry (:b_u_newhead @curbuf))))
                            (swap! curbuf assoc-in [:b_u_newhead :uh_entry] uep)
                        )

                        ;; The executed command may change the line count.
                        (cond (non-zero? newbot)
                        (do
                            ((ร uep =) (assoc uep :ue_bot newbot))
                        )
                        (< (line-count @curbuf) bot)
                        (do
                            ((ร uep =) (assoc uep :ue_bot 0))
                        )
                        :else
                        (do
                            ((ร uep =) (assoc uep :ue_lcount (line-count @curbuf)))
                            (swap! curbuf assoc-in [:b_u_newhead :uh_getbot_entry] uep)
                        ))
                        ((ร RETURN) true)
                    )
                    ((ร prev_uep =) uep)
                    ((ร uep =) (:ue_next uep))
                )
            )

            ;; find line number for ue_bot for previous u-save()
            (u-getbot)
        ))

        ;; add lines in front of entry list

        ((ร u_entry_C uep =) (NEW_u_entry_C))

        ((ร uep =) (assoc uep :ue_size size))
        ((ร uep =) (assoc uep :ue_top top))
        (cond (non-zero? newbot)
        (do
            ((ร uep =) (assoc uep :ue_bot newbot))
        )

        ;; Use 0 for ue_bot if bot is below last line.
        ;; Otherwise we have to compute ue_bot later.

        (< (line-count @curbuf) bot)
        (do
            ((ร uep =) (assoc uep :ue_bot 0))
        )
        :else
        (do
            ((ร uep =) (assoc uep :ue_lcount (line-count @curbuf)))
            (swap! curbuf assoc-in [:b_u_newhead :uh_getbot_entry] uep)
        ))

        (cond (< 0 size)
        (do
            ((ร uep =) (assoc uep :ue_array (ร new Bytes[(int)size])))
            ((ร long lnum =) (inc top))
            (dotimes [#_int i size]
                (if (fast-breakcheck)
                    ((ร RETURN) false)
                )
                ((ร uep.ue_array[i] =) (STRDUP (ml-get (ร lnum++))))
            )
        )
        :else
        (do
            ((ร uep =) (assoc uep :ue_array nil))
        ))
        ((ร uep =) (assoc uep :ue_next (:uh_entry (:b_u_newhead @curbuf))))
        (swap! curbuf assoc-in [:b_u_newhead :uh_entry] uep)
        (swap! curbuf assoc :b_u_synced false)
        (reset! undo_undoes false)

        true
    ))

;; If 'cpoptions' contains 'u': Undo the previous undo or redo (vi compatible).
;; If 'cpoptions' does not contain 'u': Always undo.

(defn- #_void u-undo [#_int n]
    ;; If we get an undo command while executing a macro, we behave like the original vi.
    ;; If this happens twice in one macro the result will not be compatible.
    (let [n (if (not (:b_u_synced @curbuf)) (do (u-sync true) 1) n)]
        (if (nil? (vim-strbyte @p_cpo, CPO_UNDO))
            (reset! undo_undoes true)
            (swap! undo_undoes not))
        (u-doit n)
    )
    nil)

;; If 'cpoptions' contains 'u': Repeat the previous undo or redo.
;; If 'cpoptions' does not contain 'u': Always redo.

(defn- #_void u-redo [#_int n]
    (if (nil? (vim-strbyte @p_cpo, CPO_UNDO))
        (reset! undo_undoes false))
    (u-doit n)
    nil)

;; Undo or redo, depending on 'undo_undoes', 'count' times.

(defn- #_void u-doit [#_int count]
    (when (undo-allowed)
        (reset! u_newcount 0)
        (reset! u_oldcount (if (flag? (:ml_flags (:b_ml @curbuf)) ML_EMPTY) -1 0))
        (let [e (loop-when [n count] (< 0 n)
                    (cond @undo_undoes
                    (do (cond
                            (nil? (:b_u_curhead @curbuf)) (swap! curbuf assoc :b_u_curhead (:b_u_newhead @curbuf))                   ;; first undo
                            (< 0 (get-undolevel))         (swap! curbuf assoc :b_u_curhead (:ptr (:uh_next (:b_u_curhead @curbuf)))) ;; multi level undo ;; get next undo
                        )
                        (if (or (zero? (:b_u_numhead @curbuf)) (nil? (:b_u_curhead @curbuf)))
                            (do
                                (swap! curbuf assoc :b_u_curhead (:b_u_oldhead @curbuf)) ;; stick curbuf.b_u_curhead at end
                                (beep-flush) ;; nothing to undo
                                (when (== n count) (u8 "Already at oldest change"))
                            )
                            (do (u-undoredo true) (recur (dec n)))
                        ))
                    :else
                    (do
                        (if (or (nil? (:b_u_curhead @curbuf)) (<= (get-undolevel) 0))
                            (do
                                (beep-flush) ;; nothing to redo
                                (when (== n count) (u8 "Already at newest change"))
                            )
                            (do
                                (u-undoredo false)
                                ;; Advance for next redo.
                                ;; Set "newhead" when at the end of the redoable changes.
                                (when (nil? (:ptr (:uh_prev (:b_u_curhead @curbuf))))
                                    (swap! curbuf assoc :b_u_newhead (:b_u_curhead @curbuf)))
                                (swap! curbuf assoc :b_u_curhead (:ptr (:uh_prev (:b_u_curhead @curbuf))))
                                (recur (dec n))
                            ))
                    ))
                )]
            (if (some? e) (msg e) (u-undo-end @undo_undoes, false))
        ))
    nil)

;; Undo or redo over the timeline.
;; When "step" is negative go back in time, otherwise goes forward in time.
;; When "sec" is false make "step" steps, when "sec" is true use "step" as seconds.
;; When "absolute" is true use "step" as the sequence number to jump to.
;; "sec" must be false then.

(defn- #_void undo-time [#_long step, #_boolean sec, #_boolean absolute]
    (ยง
        ((ร boolean dosec =) sec)
        ((ร boolean above =) false)
        ((ร boolean did_undo =) true)

        ;; First make sure the current undoable change is synced.
        (when (not (:b_u_synced @curbuf))
            (u-sync true))

        (reset! u_newcount 0)
        (reset! u_oldcount 0)
        (when (flag? (:ml_flags (:b_ml @curbuf)) ML_EMPTY)
            (reset! u_oldcount -1))

;       u_header_C uhp = null;	// %% anno dunno

        (ร long target)
        (ร long closest)
        ;; "target" is the node below which we want to be.
        ;; Init "closest" to a value we can't reach.
        (cond absolute
        (do
            ((ร target =) step)
            ((ร closest =) -1)
        )
        :else
        (do
            ;; When doing computations with time_t subtract starttime, because
            ;; time_t converted to a long may result in a wrong number.
            ((ร target =) (+ (if dosec (- (:b_u_time_cur @curbuf) @starttime) (:b_u_seq_cur @curbuf)) step))
            (cond (< step 0)
            (do
                ((ร target =) (max 0 target))
                ((ร closest =) -1)
            )
            :else
            (do
                ((ร closest =) (if dosec (inc (- (._time libC) @starttime)) (+ (:b_u_seq_last @curbuf) 2)))
                ((ร target =) (min target (dec closest)))
            ))
        ))
        ((ร long closest_start =) closest)
        ((ร long closest_seq =) (:b_u_seq_cur @curbuf))

;       int mark = 0, nomark = 0;	// %% anno dunno

        ;; May do this twice:
        ;; 1. Search for "target", update "closest" to the best match found.
        ;; 2. If "target" not found search for "closest".
        ;;
        ;; When using the closest time we use the sequence number in the second
        ;; round, because there may be several entries with the same time.

        (loop-when-recur [#_int round 1] (<= round 2) [(inc round)]
            ;; Find the path from the current state to where we want to go.  The
            ;; desired state can be anywhere in the undo tree, need to go all over
            ;; it.  We put "nomark" in uh_walk where we have been without success,
            ;; "mark" where it could possibly be.
            ((ร mark =) (swap! lastmark inc))
            ((ร nomark =) (swap! lastmark inc))

            ((ร uhp =) (if (nil? (:b_u_curhead @curbuf)) (:b_u_newhead @curbuf) (:b_u_curhead @curbuf)))

            (loop-when [] (some? uhp)
                ((ร uhp =) (assoc uhp :uh_walk mark))
                ((ร long val =) (if dosec (- (:uh_time uhp) @starttime) (:uh_seq uhp)))

                (when (== round 1)
                    ;; Remember the header that is closest to the target.
                    ;; It must be at least in the right direction (checked with "b_u_seq_cur").
                    ;; When the timestamp is equal find the highest/lowest sequence number.
                    (when (and (if (< step 0) (<= (:uh_seq uhp) (:b_u_seq_cur @curbuf)) (> (:uh_seq uhp) (:b_u_seq_cur @curbuf)))
                               (if (and dosec (== val closest)) (if (< step 0) (< (:uh_seq uhp) closest_seq) (> (:uh_seq uhp) closest_seq))
                                                                (or (== closest closest_start)
                                                                    (if (< target val) (if (< target closest) (<= (- val target) (- closest target))
                                                                                                              (<= (- val target) (- target closest)))
                                                                                       (if (< target closest) (<= (- target val) (- closest target))
                                                                                                              (<= (- target val) (- target closest)))))))
                        ((ร closest =) val)
                        ((ร closest_seq =) (:uh_seq uhp))
                    )
                )

                ;; Quit searching when we found a match.  But when searching for a time,
                ;; we need to continue looking for the best uh_seq.
                (when (and (== target val) (not dosec))
                    ((ร target =) (:uh_seq uhp))
                    (ร BREAK)
                )

                ;; go down in the tree if we haven't been there
                (cond (and (some? (:ptr (:uh_prev uhp))) (!= (:uh_walk (:ptr (:uh_prev uhp))) nomark) (!= (:uh_walk (:ptr (:uh_prev uhp))) mark))
                (do
                    ((ร uhp =) (:ptr (:uh_prev uhp)))
                )
                ;; go to alternate branch if we haven't been there
                (and (some? (:ptr (:uh_alt_next uhp))) (!= (:uh_walk (:ptr (:uh_alt_next uhp))) nomark) (!= (:uh_walk (:ptr (:uh_alt_next uhp))) mark))
                (do
                    ((ร uhp =) (:ptr (:uh_alt_next uhp)))
                )
                ;; go up in the tree if we haven't been there and we are at the start of alternate branches
                (and (some? (:ptr (:uh_next uhp))) (nil? (:ptr (:uh_alt_prev uhp))) (!= (:uh_walk (:ptr (:uh_next uhp))) nomark) (!= (:uh_walk (:ptr (:uh_next uhp))) mark))
                (do
                    ;; If still at the start we don't go through this change.
                    (if (== uhp (:b_u_curhead @curbuf))
                        ((ร uhp =) (assoc uhp :uh_walk nomark))
                    )
                    ((ร uhp =) (:ptr (:uh_next uhp)))
                )
                :else
                (do
                    ;; need to backtrack; mark this node as useless
                    ((ร uhp =) (assoc uhp :uh_walk nomark))
                    ((ร uhp =) (if (some? (:ptr (:uh_alt_prev uhp))) (:ptr (:uh_alt_prev uhp)) (:ptr (:uh_next uhp))))
                ))
                (recur)
            )

            (if (some? uhp)    ;; found it
                (ร BREAK)
            )

            (when absolute
                (emsgn (u8 "E830: Undo number %ld not found"), step)
                ((ร RETURN) nil)
            )

            (when (== closest closest_start)
                (msg (if (< step 0) (u8 "Already at oldest change") (u8 "Already at newest change")))
                ((ร RETURN) nil)
            )

            ((ร target =) closest_seq)
            ((ร dosec =) false)
            ((ร above =) (or (< step 0) above))       ;; stop above the header
        )

        ;; If we found it: Follow the path to go to where we want to be.
        (when (some? uhp)
            ;; First go up the tree as much as needed.

            (loop-when [] (not @got_int)
                ((ร uhp =) (:b_u_curhead @curbuf))
                ((ร uhp =) (if (nil? uhp) (:b_u_newhead @curbuf) (:ptr (:uh_next uhp))))
                (if (or (nil? uhp) (!= (:uh_walk uhp) mark) (and (== (:uh_seq uhp) target) (not above)))
                    (ร BREAK)
                )
                (swap! curbuf assoc :b_u_curhead uhp)
                (u-undoredo true)
                ((ร uhp =) (assoc uhp :uh_walk nomark))   ;; don't go back down here
                (recur)
            )

            ;; And now go down the tree (redo), branching off where needed.

            (loop-when [] (not @got_int)
                ((ร uhp =) (:b_u_curhead @curbuf))
                (if (nil? uhp)
                    (ร BREAK)
                )

                ;; Go back to the first branch with a mark.
                (loop-when [] (and (some? (:ptr (:uh_alt_prev uhp))) (== (:uh_walk (:ptr (:uh_alt_prev uhp))) mark))
                    ((ร uhp =) (:ptr (:uh_alt_prev uhp)))
                    (recur)
                )

                ;; Find the last branch with a mark, that's the one.
                ((ร u_header_C last =) uhp)
                (loop-when [] (and (some? (:ptr (:uh_alt_next last))) (== (:uh_walk (:ptr (:uh_alt_next last))) mark))
                    ((ร last =) (:ptr (:uh_alt_next last)))
                    (recur)
                )
                (when (!= last uhp)
                    ;; Make the used branch the first entry in the list of
                    ;; alternatives to make "u" and CTRL-R take this branch.
                    (loop-when [] (some? (:ptr (:uh_alt_prev uhp)))
                        ((ร uhp =) (:ptr (:uh_alt_prev uhp)))
                        (recur)
                    )
                    (if (some? (:ptr (:uh_alt_next last)))
                        ((ร last.uh_alt_next.ptr.uh_alt_prev.ptr =) (:ptr (:uh_alt_prev last)))
                    )
                    ((ร last.uh_alt_prev.ptr.uh_alt_next.ptr =) (:ptr (:uh_alt_next last)))
                    ((ร last =) (assoc-in last [:uh_alt_prev :ptr] nil))
                    ((ร last =) (assoc-in last [:uh_alt_next :ptr] uhp))
                    ((ร uhp =) (assoc-in uhp [:uh_alt_prev :ptr] last))

                    (when (== (:b_u_oldhead @curbuf) uhp)
                        (swap! curbuf assoc :b_u_oldhead last))
                    ((ร uhp =) last)
                    (if (some? (:ptr (:uh_next uhp)))
                        ((ร uhp.uh_next.ptr.uh_prev.ptr =) uhp)
                    )
                )
                (swap! curbuf assoc :b_u_curhead uhp)

                (if (!= (:uh_walk uhp) mark)
                    (ร BREAK)      ;; must have reached the target
                )

                ;; Stop when going backwards in time and didn't find
                ;; the exact header we were looking for.
                (when (and (== (:uh_seq uhp) target) above)
                    (swap! curbuf assoc :b_u_seq_cur (dec target))
                    (ร BREAK)
                )

                (u-undoredo false)

                ;; Advance "curhead" to below the header we last used.
                ;; If it becomes null, then we need to set "newhead" to this leaf.
                (when (nil? (:ptr (:uh_prev uhp)))
                    (swap! curbuf assoc :b_u_newhead uhp))
                (swap! curbuf assoc :b_u_curhead (:ptr (:uh_prev uhp)))
                ((ร did_undo =) false)

                (if (== (:uh_seq uhp) target)   ;; found it!
                    (ร BREAK)
                )

                ((ร uhp =) (:ptr (:uh_prev uhp)))
                (when (or (nil? uhp) (!= (:uh_walk uhp) mark))
                    ;; Need to redo more but can't find it...
                    (emsg2 e_intern2, (u8 "undo-time()"))
                    (ร BREAK)
                )
                (recur)
            )
        )

        (u-undo-end did_undo, absolute)
        nil
    ))

;; u-undoredo: common code for undo and redo
;;
;; The lines in the file are replaced by the lines in the entry list at curbuf.b_u_curhead.
;; The replaced lines in the file are saved in the entry list for the next undo/redo.
;;
;; When "undo" is true we go up in the tree, when false we go down.

(defn- #_void u-undoredo [#_boolean undo]
    (ยง
        ((ร Bytes[] newarray =) nil)
        ((ร long newlnum =) MAXLNUM)
        ((ร u_entry_C newlist =) nil)
        ((ร u_header_C curhead =) (:b_u_curhead @curbuf))

        ((ร int old_flags =) (:uh_flags curhead))
        ((ร int new_flags =) (+ (if @(:b_changed @curbuf) UH_CHANGED 0) (if (flag? (:ml_flags (:b_ml @curbuf)) ML_EMPTY) UH_EMPTYBUF 0)))
        (swap! curwin setpcmark)

        ;; save marks before undo/redo

        ((ร pos_C[] namedm =) (ARRAY-pos NMARKS))
        (dotimes [#_int i NMARKS]
            (COPY-pos (... namedm i), (... (:b_namedm @curbuf) i))
        )

        ((ร visualinfo_C visualinfo =) (NEW_visualinfo_C))
        (COPY-visualinfo visualinfo, (:b_visual @curbuf))

        (swap! curbuf update :b_op_start assoc :lnum (line-count @curbuf) :col 0)
        (swap! curbuf update :b_op_end assoc :lnum 0 :col 0)

        ((ร FOR) (ร ((ร u_entry_C uep =) (ร curhead.uh_entry, nuep)) (some? uep) ((ร uep =) nuep))
            ((ร long top =) (:ue_top uep))
            ((ร long bot =) (:ue_bot uep))
            ((ร bot =) (if (zero? bot) (inc (line-count @curbuf)) bot))
            (when (or (> top (line-count @curbuf)) (<= bot top) (> bot (inc (line-count @curbuf))))
                (emsg (u8 "E438: u-undo: line numbers wrong"))
                (changed)          ;; don't want UNCHANGED now
                ((ร RETURN) nil)
            )

            ((ร int oldsize =) (int (- bot top 1)))       ;; number of lines before undo
            ((ร int newsize =) (int (:ue_size uep)))         ;; number of lines after undo

            (when (< top newlnum)
                ;; If the saved cursor is somewhere in this undo block,
                ;; move it to the remembered position.
                ;; Makes "gwap" put the cursor back where it was.
                ((ร long lnum =) (:lnum (:uh_cursor curhead)))
                (cond (and (<= top lnum) (<= lnum (+ top newsize 1)))
                (do
                    (swap! curwin assoc :w_cursor (:uh_cursor curhead))
                    ((ร newlnum =) (dec (:lnum (:w_cursor @curwin))))
                )
                :else
                (do
                    ;; Use the first line that actually changed.
                    ;; Avoids that undoing auto-formatting puts the cursor in the previous line.
                    ((ร int i =) (loop-when-recur [i 0] (and (< i newsize) (< i oldsize) (zero? (STRCMP (... (:ue_array uep) i), (ml-get (+ top 1 i))))) [(inc i)] => i))
                    (cond (and (== i newsize) (== newlnum MAXLNUM) (nil? (:ue_next uep)))
                    (do
                        ((ร newlnum =) top)
                        (swap! curwin assoc-in [:w_cursor :lnum] (inc newlnum))
                    )
                    (< i newsize)
                    (do
                        ((ร newlnum =) (+ top i))
                        (swap! curwin assoc-in [:w_cursor :lnum] (inc newlnum))
                    ))
                ))
            )

            ((ร boolean empty_buffer =) false)   ;; buffer became empty

            ;; delete the lines between top and bot and save them in "newarray"
            (cond (< 0 oldsize)
            (do
                ((ร newarray =) (ร new Bytes[oldsize]))

                ;; delete backwards, it goes faster in most cases
                (loop-when-recur [#_int i (dec oldsize) #_long lnum (dec bot)] (<= 0 i) [(dec i) (dec lnum)]
                    ((ร newarray[i] =) (STRDUP (ml-get lnum)))
                    ;; remember we deleted the last line in the buffer,
                    ;; and a dummy empty line will be inserted
                    ((ร empty_buffer =) (or (== (line-count @curbuf) 1) empty_buffer))
                    (ml-delete lnum, false)
                )
            )
            :else
            (do
                ((ร newarray =) nil)
            ))

            ;; insert the lines in u_array between top and bot
            (loop-when-recur [#_int i 0 #_long lnum top] (< i newsize) [(inc i) (inc lnum)]
                ;; If the file is empty, there is an empty line 1 that we
                ;; should get rid of, by replacing it with the new line.

                (if (and empty_buffer (zero? lnum))
                    (ml-replace 1, (... (:ue_array uep) i))
                    (ml-append lnum, (... (:ue_array uep) i)))
            )

            ;; adjust marks
            (when (!= oldsize newsize)
                (mark-adjust (inc top), (+ top oldsize), MAXLNUM, (- newsize oldsize))
                (when (> (:lnum (:b_op_start @curbuf)) (+ top oldsize))
                    (swap! curbuf update-in [:b_op_start :lnum] + (- newsize oldsize)))
                (when (> (:lnum (:b_op_end @curbuf)) (+ top oldsize))
                    (swap! curbuf update-in [:b_op_end :lnum] + (- newsize oldsize)))
            )

            (changed-lines (inc top), 0, bot, (- newsize oldsize))

            ;; set '[ and '] mark
            (swap! curbuf assoc-in [:b_op_start :lnum] (min (:lnum (:b_op_start @curbuf)) (inc top)))

            (cond (and (zero? newsize) (< (:lnum (:b_op_end @curbuf)) (inc top)))
            (do
                (swap! curbuf assoc-in [:b_op_end :lnum] (inc top))
            )
            (< (:lnum (:b_op_end @curbuf)) (+ top newsize))
            (do
                (swap! curbuf assoc-in [:b_op_end :lnum] (+ top newsize))
            ))

            (swap! u_newcount + newsize)
            (swap! u_oldcount + oldsize)
            ((ร uep =) (assoc uep :ue_size oldsize))
            ((ร uep =) (assoc uep :ue_array newarray))
            ((ร uep =) (assoc uep :ue_bot (+ top newsize 1)))

            ;; insert this entry in front of the new entry list

            ((ร nuep =) (:ue_next uep))
            ((ร uep =) (assoc uep :ue_next newlist))
            ((ร newlist =) uep)
        )

        ((ร curhead =) (assoc curhead :uh_entry newlist))
        ((ร curhead =) (assoc curhead :uh_flags new_flags))
        (when (and (flag? old_flags UH_EMPTYBUF) (bufempty))
            (swap! curbuf assoc-in [:b_ml :ml_flags] (| (:ml_flags (:b_ml @curbuf)) ML_EMPTY)))
        (if (flag? old_flags UH_CHANGED)
            (changed)
            (unchanged))

        ;; restore marks from before undo/redo

        (dotimes [#_int i NMARKS]
            (if (non-zero? (:lnum (... (:uh_namedm curhead) i)))
                (COPY-pos (... (:b_namedm @curbuf) i), (... (:uh_namedm curhead) i)))
            (if (non-zero? (:lnum (... namedm i)))
                (COPY-pos (... (:uh_namedm curhead) i), (... namedm i))
                ((ร curhead.uh_namedm[i].lnum =) 0)
            )
        )
        (when (non-zero? (:lnum (:vi_start (:uh_visual curhead))))
            (COPY-visualinfo (:b_visual @curbuf), (:uh_visual curhead))
            (COPY-visualinfo (:uh_visual curhead), visualinfo)
        )

        ;; If the cursor is only off by one line,
        ;; put it at the same position as before starting the change (for the "o" command).
        ;; Otherwise the cursor should go to the first undone line.

        (when (and (== (inc (:lnum (:uh_cursor curhead))) (:lnum (:w_cursor @curwin))) (< 1 (:lnum (:w_cursor @curwin))))
            (swap! curwin update-in [:w_cursor :lnum] dec))
        (cond (<= (:lnum (:w_cursor @curwin)) (line-count @curbuf))
        (do
            (cond (== (:lnum (:uh_cursor curhead)) (:lnum (:w_cursor @curwin)))
            (do
                (swap! curwin assoc-in [:w_cursor :col] (:col (:uh_cursor curhead)))
                (if (and (virtual-active) (<= 0 (:uh_cursor_vcol curhead)))
                    (swap! curwin coladvance (:uh_cursor_vcol curhead))
                    (swap! curwin assoc-in [:w_cursor :coladd] 0)
                )
            )
            :else
            (do
                (swap! curwin beginline (| BL_SOL BL_FIX))
            ))
        )
        :else
        (do
            ;; We get here with the current cursor line being past the end (e.g.
            ;; after adding lines at the end of the file, and then undoing it).
            ;; check-cursor() will move the cursor to the last line.  Move it to
            ;; the first column here.
            (swap! curwin update :w_cursor assoc :col 0 :coladd 0)
        ))

        ;; Make sure the cursor is on an existing line and column.
        (swap! curwin check-cursor)

        ;; Remember where we are for "g-" and ":earlier 10s".
        (swap! curbuf assoc :b_u_seq_cur (:uh_seq curhead))
        (when undo
            ;; We are below the previous undo.  However, to make ":earlier 1s"
            ;; work we compute this as being just above the just undone change.
            (swap! curbuf update :b_u_seq_cur dec)
        )

        ;; The timestamp can be the same for multiple changes,
        ;; just use the one of the undone/redone change.
        (swap! curbuf assoc :b_u_time_cur (:uh_time curhead))
        nil
    ))

;; If we deleted or added lines, report the number of less/more lines.
;; Otherwise, report the number of changes
;; (this may be incorrect in some cases, but it's better than nothing).

(defn- #_void u-undo-end [#_boolean did_undo, #_boolean absolute]
    ;; did_undo: just did an undo
    ;; absolute: used ":undo N"
    (when (messaging)
        (when (flag? (:ml_flags (:b_ml @curbuf)) ML_EMPTY)
            (swap! u_newcount dec))
        (swap! u_oldcount - @u_newcount)
        (let [#_Bytes msgstr
                (cond
                    (==  @u_oldcount -1) (u8 "more line")
                    (<   @u_oldcount  0) (u8 "more lines")
                    (==  @u_oldcount  1) (u8 "line less")
                    (< 1 @u_oldcount)    (u8 "fewer lines")
                    :else (do
                        (reset! u_oldcount @u_newcount)
                        (if (== @u_newcount 1) (u8 "change") (u8 "changes"))
                    ))
              [#_u_header_C uhp did_undo]
                (cond
                    (nil? (:b_u_curhead @curbuf))                                   [(:b_u_newhead @curbuf) did_undo]
                    ;; For ":undo N" we prefer a "after #N" message.
                    (and absolute (some? (:ptr (:uh_next (:b_u_curhead @curbuf))))) [(:ptr (:uh_next (:b_u_curhead @curbuf))) false]
                    did_undo                                                        [(:b_u_curhead @curbuf) did_undo]
                    :else                                                           [(:ptr (:uh_next (:b_u_curhead @curbuf))) did_undo]
                )
              #_Bytes msgbuf (Bytes. 80)]
            (if (some? uhp)
                (u-add-time msgbuf, (.size msgbuf), (:uh_time uhp))
                (eos! msgbuf))
            (ยง loop-when-recur [#_window_C win @firstwin] (some? win) [(:w_next win)]
                (when (< 0 @(:wo_cole (:w_options win)))
                    ((ร win =) (redraw-later win, NOT_VALID))))
            (smsg (u8 "%ld %s; %s #%ld  %s"), (if (< @u_oldcount 0) (- @u_oldcount) @u_oldcount), msgstr,
                                              (if did_undo (u8 "before") (u8 "after")), (if (some? uhp) (:uh_seq uhp) 0), msgbuf)
        ))
    nil)

;; u-sync: stop adding to the current entry list

(defn- #_void u-sync [#_boolean force] ;; force: Also sync when no_u_sync is set.
    ;; Skip it when already synced or syncing is disabled.
    (if-not (or (:b_u_synced @curbuf) (and (not force) (< 0 @no_u_sync)))
        (if (< (get-undolevel) 0)
            (swap! curbuf assoc :b_u_synced true)   ;; no entries, nothing to do
            (do
                (u-getbot)                 ;; compute ue_bot of previous u-save()
                (swap! curbuf assoc :b_u_curhead nil)
            )
        ))
    nil)

;; Put the timestamp of an undo header in "buf[buflen]" in a nice format.

(defn- #_void u-add-time [#_Bytes buf, #_int buflen, #_long seconds]
    (ยง if (<= 100 (- (._time libC) seconds))
        (let [#_tm_C curtime (._localtime libC seconds)]
            (if (< (- (._time libC) seconds) (* 60 60 12))
                ;; within 12 hours
                (.strftime libC buf, buflen, (u8 "%H:%M:%S"), curtime)
                ;; longer ago
                (.strftime libC buf, buflen, (u8 "%Y/%m/%d %H:%M:%S"), curtime)
            ))
;%%     (vim_snprintf buf, buflen, (u8 "%ld seconds ago"), (- (._time libC) seconds))
    )
    nil)

;; Get pointer to last added entry.
;; If it's not valid, give an error message and return null.

(defn- #_u_entry_C u-get-headentry []
    (let [ent (-> @curbuf :b_u_newhead :uh_entry)]
        (when (nil? ent)
            (emsg (u8 "E439: undo list corrupt")))
        ent
    ))

;; u-getbot(): compute the line number of the previous u-save()
;;              It is called only when b_u_synced is false.

(defn- #_void u-getbot []
    (ยง
        (when (some? (u-get-headentry)) ;; check for corrupt undo list
            (let [#_u_entry_C uep (:uh_getbot_entry (:b_u_newhead @curbuf))]
                (when (some? uep)
                    (let [lmax (line-count @curbuf)]
                        ;; the new ue_bot is computed from the number of lines that has been
                        ;; inserted (0 - deleted) since calling u-save().  This is equal to the
                        ;; old line count subtracted from the current line count.
                        ((ร uep =) (assoc uep :ue_bot (+ (:ue_top uep) (:ue_size uep) 1 (- lmax (:ue_lcount uep)))))
                        (when-not (<= 1 (:ue_bot uep) lmax)
                            (emsg (u8 "E440: undo line missing"))
                            ;; assume all lines deleted, will get all the old lines back without deleting the current ones
                            ((ร uep =) (assoc uep :ue_bot (inc (:ue_top uep))))
                        )
                        (swap! curbuf assoc-in [:b_u_newhead :uh_getbot_entry] nil)
                    ))
                (swap! curbuf assoc :b_u_synced true)
            ))
        nil
    ))

;; Free one header "uhp" and its entry list and adjust the pointers.

(defn- #_void u-freeheader [#_u_header_C uhp, #_u_header_C' a'uhpp]
    ;; uhpp: if not null reset when freeing this header
    (ยง
        ;; When there is an alternate redo list free that branch completely,
        ;; because we can never go there.
        (when (some? (:ptr (:uh_alt_next uhp)))
            (u-freebranch (:ptr (:uh_alt_next uhp)), a'uhpp))

        (if (some? (:ptr (:uh_alt_prev uhp)))
            ((ร uhp.uh_alt_prev.ptr.uh_alt_next.ptr =) nil)
        )

        ;; Update the links in the list to remove the header.
        (if (nil? (:ptr (:uh_next uhp)))
            (swap! curbuf assoc :b_u_oldhead (:ptr (:uh_prev uhp)))
            ((ร uhp.uh_next.ptr.uh_prev.ptr =) (:ptr (:uh_prev uhp)))
        )

        (cond (nil? (:ptr (:uh_prev uhp)))
        (do
            (swap! curbuf assoc :b_u_newhead (:ptr (:uh_next uhp)))
        )
        :else
        (do
            (loop-when-recur [#_u_header_C uhap (:ptr (:uh_prev uhp))] (some? uhap) [(:ptr (:uh_alt_next uhap))]
                ((ร uhap =) (assoc-in uhap [:uh_next :ptr] (:ptr (:uh_next uhp))))
            )
        ))

        (u-freeentries uhp, a'uhpp)
        nil
    ))

;; Free an alternate branch and any following alternate branches.

(defn- #_void u-freebranch [#_u_header_C uhp, #_u_header_C' a'uhpp]
    ;; uhpp: if not null reset when freeing this header
    (ยง
        ;; If this is the top branch we may need to use u-freeheader() to update all the pointers.
        (when (== uhp (:b_u_oldhead @curbuf))
            (while (some? (:b_u_oldhead @curbuf))
                (u-freeheader (:b_u_oldhead @curbuf), a'uhpp))
            ((ร RETURN) nil)
        )

        (when (some? (:ptr (:uh_alt_prev uhp)))
            ((ร uhp.uh_alt_prev.ptr.uh_alt_next.ptr =) nil))

        (loop-when [#_u_header_C next uhp] (some? next)
            ((ร u_header_C tofree =) next)
            (when (some? (:ptr (:uh_alt_next tofree)))
                (u-freebranch (:ptr (:uh_alt_next tofree)), a'uhpp))    ;; recursive
            ((ร next =) (:ptr (:uh_prev tofree)))
            (u-freeentries tofree, a'uhpp)
            (recur next)
        )
        nil
    ))

;; Free all the undo entries for one header and the header itself.
;; This means that "uhp" is invalid when returning.

(defn- #_void u-freeentries [#_u_header_C uhp, #_u_header_C' a'uhpp]
    ;; uhpp: if not null reset when freeing this header
    (when (== (:b_u_curhead @curbuf) uhp) (swap! curbuf assoc :b_u_curhead nil))
    (when (== (:b_u_newhead @curbuf) uhp) (swap! curbuf assoc :b_u_newhead nil))
    (when (and (some? a'uhpp) (== @a'uhpp uhp))
        (reset! a'uhpp nil))
    (swap! curbuf update :b_u_numhead dec)
    nil)

;; save the line "lnum" for the "U" command

(defn- #_void u-saveline [#_long lnum]
    (when (and (!= lnum (:b_u_line_lnum @curbuf)) (<= 1 lnum (line-count @curbuf)))
        (u-clearline)
        (let [cursor (:w_cursor @curwin)]
            (swap! curbuf assoc
                :b_u_line_lnum lnum
                :b_u_line_colnr (if (== (:lnum cursor) lnum) (:col cursor) 0)
                :b_u_line_ptr (STRDUP (ml-get lnum))))
    )
    nil)

;; clear the line saved for the "U" command
;; (this is used externally for crossing a line while in insert mode)

(defn- #_void u-clearline []
    (when (some? (:b_u_line_ptr @curbuf))
        (swap! curbuf assoc :b_u_line_ptr nil :b_u_line_lnum 0))
    nil)

;; Implementation of the "U" command.
;; Differentiation from vi: "U" can be undone with the next "U".
;; We also allow the cursor to be in another line.

(defn- #_window_C u-undoline [#_window_C win]
    (let-when [uln (:b_u_line_lnum @curbuf)] (and (some? (:b_u_line_ptr @curbuf)) (<= uln (line-count @curbuf))) => (do (beep-flush) win)
        (if (u-savecommon (dec uln), (inc uln), 0, false)
            (let [#_Bytes s (STRDUP (ml-get uln))]
                (ml-replace uln, (:b_u_line_ptr @curbuf))
                (changed-bytes uln, 0)
                (swap! curbuf assoc :b_u_line_ptr s)
                (let [#_int swp (:b_u_line_colnr @curbuf)]
                    (when (== (:lnum (:w_cursor win)) uln)
                        (swap! curbuf assoc :b_u_line_colnr (:col (:w_cursor win))))
                    (-> win
                        (update :w_cursor assoc :lnum uln :col swp)
                        (check-cursor-col)
                    )
                ))
            win
        )
    ))

;;; ============================================================================================== VimV

;; term.c: functions for controlling the terminal -------------------------------------------------

;; Each termcap is a list of btcap_C structures.
;; 'bt_key' is either a KS_xxx code (>= 0), or a K_xxx code.

(class! #_final btcap_C
    [
        (field int      bt_key)
        (field Bytes    bt_seq)
    ])

(final btcap_C* xterm_tcaps
    [
        (->btcap_C KS_NAME,      (u8 "xterm")                ),

        (->btcap_C KS_CE,        (u8 "\033[K")               ),
        (->btcap_C KS_AL,        (u8 "\033[L")               ),
        (->btcap_C KS_CAL,       (u8 "\033[%p1%dL")          ),
        (->btcap_C KS_DL,        (u8 "\033[M")               ),
        (->btcap_C KS_CDL,       (u8 "\033[%p1%dM")          ),
        (->btcap_C KS_CS,        (u8 "\033[%i%p1%d;%p2%dr")  ),
        (->btcap_C KS_CL,        (u8 "\033[H\033[2J")        ),
        (->btcap_C KS_CD,        (u8 "\033[J")               ),
        (->btcap_C KS_ME,        (u8 "\033[m")               ),
        (->btcap_C KS_MR,        (u8 "\033[7m")              ),
        (->btcap_C KS_MD,        (u8 "\033[1m")              ),
        (->btcap_C KS_UE,        (u8 "\033[m")               ),
        (->btcap_C KS_US,        (u8 "\033[4m")              ),
        (->btcap_C KS_MS,        (u8 "y")                    ),
        (->btcap_C KS_UT,        (u8 "y")                    ),
        (->btcap_C KS_LE,        (u8 "\b")                   ),
        (->btcap_C KS_CM,        (u8 "\033[%i%p1%d;%p2%dH")  ),
        (->btcap_C KS_SR,        (u8 "\033M")                ),
        (->btcap_C KS_CRI,       (u8 "\033[%p1%dC")          ),
        (->btcap_C KS_KS,        (u8 "\033[?1h\033=")        ),
        (->btcap_C KS_KE,        (u8 "\033[?1l\033>")        ),
        (->btcap_C KS_TI,        (u8 "\0337\033[?47h")       ),
        (->btcap_C KS_TE,        (u8 "\033[2J\033[?47l\0338")),
        (->btcap_C KS_CWS,       (u8 "\033[8;%p1%d;%p2%dt")  ),

        (->btcap_C K_UP,         (u8 "\033O*A")              ),
        (->btcap_C K_DOWN,       (u8 "\033O*B")              ),
        (->btcap_C K_RIGHT,      (u8 "\033O*C")              ),
        (->btcap_C K_LEFT,       (u8 "\033O*D")              ),
        ;; An extra set of cursor keys for vt100 mode.
        (->btcap_C K_XUP,        (u8 "\033[1;*A")            ),
        (->btcap_C K_XDOWN,      (u8 "\033[1;*B")            ),
        (->btcap_C K_XRIGHT,     (u8 "\033[1;*C")            ),
        (->btcap_C K_XLEFT,      (u8 "\033[1;*D")            ),
        ;; An extra set of function keys for vt100 mode.
        (->btcap_C K_XF1,        (u8 "\033O*P")              ),
        (->btcap_C K_XF2,        (u8 "\033O*Q")              ),
        (->btcap_C K_XF3,        (u8 "\033O*R")              ),
        (->btcap_C K_XF4,        (u8 "\033O*S")              ),
        (->btcap_C K_F1,         (u8 "\033[11;*~")           ),
        (->btcap_C K_F2,         (u8 "\033[12;*~")           ),
        (->btcap_C K_F3,         (u8 "\033[13;*~")           ),
        (->btcap_C K_F4,         (u8 "\033[14;*~")           ),
        (->btcap_C K_F5,         (u8 "\033[15;*~")           ),
        (->btcap_C K_F6,         (u8 "\033[17;*~")           ),
        (->btcap_C K_F7,         (u8 "\033[18;*~")           ),
        (->btcap_C K_F8,         (u8 "\033[19;*~")           ),
        (->btcap_C K_F9,         (u8 "\033[20;*~")           ),
        (->btcap_C K_F10,        (u8 "\033[21;*~")           ),
        (->btcap_C K_F11,        (u8 "\033[23;*~")           ),
        (->btcap_C K_F12,        (u8 "\033[24;*~")           ),
        (->btcap_C K_S_TAB,      (u8 "\033[Z")               ),
        (->btcap_C K_HELP,       (u8 "\033[28;*~")           ),
        (->btcap_C K_UNDO,       (u8 "\033[26;*~")           ),
        (->btcap_C K_INS,        (u8 "\033[2;*~")            ),
        (->btcap_C K_HOME,       (u8 "\033[1;*H")            ),
     ;; (->btcap_C K_S_HOME,     (u8 "\033O2H")              ),
     ;; (->btcap_C K_C_HOME,     (u8 "\033O5H")              ),
        (->btcap_C K_KHOME,      (u8 "\033[1;*~")            ),
        (->btcap_C K_XHOME,      (u8 "\033O*H")              ),      ;; other Home
        (->btcap_C K_ZHOME,      (u8 "\033[7;*~")            ),      ;; other Home
        (->btcap_C K_END,        (u8 "\033[1;*F")            ),
     ;; (->btcap_C K_S_END,      (u8 "\033O2F")              ),
     ;; (->btcap_C K_C_END,      (u8 "\033O5F")              ),
        (->btcap_C K_KEND,       (u8 "\033[4;*~")            ),
        (->btcap_C K_XEND,       (u8 "\033O*F")              ),      ;; other End
        (->btcap_C K_ZEND,       (u8 "\033[8;*~")            ),
        (->btcap_C K_PAGEUP,     (u8 "\033[5;*~")            ),
        (->btcap_C K_PAGEDOWN,   (u8 "\033[6;*~")            ),
        (->btcap_C K_KPLUS,      (u8 "\033O*k")              ),      ;; keypad plus
        (->btcap_C K_KMINUS,     (u8 "\033O*m")              ),      ;; keypad minus
        (->btcap_C K_KDIVIDE,    (u8 "\033O*o")              ),      ;; keypad /
        (->btcap_C K_KMULTIPLY,  (u8 "\033O*j")              ),      ;; keypad *
        (->btcap_C K_KENTER,     (u8 "\033O*M")              ),      ;; keypad Enter
        (->btcap_C K_KPOINT,     (u8 "\033O*n")              ),      ;; keypad .
        (->btcap_C K_KDEL,       (u8 "\033[3;*~")            ),      ;; keypad Del
    ])

(atom! boolean need_gather)                     ;; need to fill termleader[]
(final Bytes termleader (Bytes. (inc 256)))     ;; for check-termcode()

;; Parsing of the builtin termcap entries.

(defn- #_void parse-builtin-tcap []
    (ยง
        ((ร btcap_C[] tcaps =) xterm_tcaps)

        (loop-when-recur [#_int i 1] (< i (:length tcaps)) [(inc i)]
            ((ร int k =) (:bt_key (... tcaps i)))
            (cond (< k 0)
            (do
                ((ร Bytes name =) (-> (Bytes. 2) (.be 0, (KEY2TERMCAP0 k)) (.be 1, (KEY2TERMCAP1 k))))

                (if (nil? (find-termcode name))
                    (add-termcode name, (:bt_seq (... tcaps i))))
            )
            :else ;; KS_xx entry
            (do
                ;; Only set the value if it wasn't set yet.
                (when (or (nil? (... (... term_strings k) 0)) (== (... (... term_strings k) 0) EMPTY_OPTION))
                    ((ร term_strings[k][0] =) (:bt_seq (... tcaps i)))
                )
            ))
        )
    )
    nil)

;; Set terminal options.
;;
;; While doing this, until ttest(), some options may be null, be careful.

(defn- #_void set-term []
    (out-flush)

    ;; Reset a few things before clearing the old options.  This may cause
    ;; outputting a few things that the terminal doesn't understand, but the
    ;; screen will be cleared later, so this is OK.

    (stop-termcap)
    (clear-termcodes)
    (parse-builtin-tcap)

    ;; Any "stty" settings override the default for t_kb from the termcap.

    (get-stty)

    ;; If the termcap has no entry for 'bs' and/or 'del' and the ioctl()
    ;; also didn't work, use the default CTRL-H.
    ;; The default for t_kD is DEL, unless t_kb is DEL.

    (let [#_Bytes bs (find-termcode (u8 "kb"))
          bs (if (or (nil? bs) (eos? bs)) (let [bs CTRL_H_STR] (add-termcode (u8 "kb"), bs) bs) bs)
          #_Bytes del (find-termcode (u8 "kD"))]
        (when (and (or (nil? del) (eos? del)) (or (nil? bs) (not-at? bs DEL)))
            (add-termcode (u8 "kD"), DEL_STR)
        ))

    (ttest true)                        ;; make sure we have a valid set of terminal codes

    (reset! full_screen true)           ;; we can use termcap codes from now on

    ;; Initialize the terminal with the appropriate termcap codes.

    (when (!= @starting NO_SCREEN)
        (start-termcap))                 ;; may change terminal mode

    (set-shellsize 80, 24, false)       ;; may change Rows

    (when (!= @starting NO_SCREEN)
        (when @scroll_region
            (scroll-region-reset)))     ;; in case Rows changed
    nil)

;; the number of calls to ui-write is reduced by using the buffer "out_buf"

(final int OUT_SIZE      2047)

(final Bytes out_buf (Bytes. (inc OUT_SIZE)))
(atom! int out_pos)         ;; number of chars in "out_buf"

;; out-flush(): flush the output buffer

(defn- #_void out-flush []
    (let [#_int len @out_pos]
        (when (non-zero? len)
            ;; set out_pos to 0 before ui-write, to avoid recursiveness
            (reset! out_pos 0)
            (ui-write out_buf, len)
        ))
    nil)

;; Sometimes a byte out of a multi-byte character is written with out-char().
;; To avoid flushing half of the character, call this function first.

(defn- #_void out-flush-check []
    nil)

;; out-char(c): put a byte into the output buffer.
;;              Flush it if it becomes full.
;; This should not be used for outputting text on the screen
;; (use functions like msg-puts() and screen-putchar() for that).

(defn- #_void out-char [#_byte c]
    (when (== c (byte \newline))          ;; turn LF into CR-LF (CRMOD doesn't seem to do this)
        (out-char (byte \return)))

    (.be out_buf @out_pos, c)
    (swap! out_pos inc)

    ;; For testing we flush each time.
    (when (or (<= OUT_SIZE @out_pos) (non-zero? @p_wd))
        (out-flush))
    nil)

;; out-char-nf(c): like out-char(), but don't flush when "p_wd" is set

(defn- #_void out-char-nf [#_byte c]
    (when (== c (byte \newline))          ;; turn LF into CR-LF (CRMOD doesn't seem to do this)
        (out-char-nf (byte \return)))

    (.be out_buf @out_pos, c)
    (swap! out_pos inc)

    (when (<= OUT_SIZE @out_pos)
        (out-flush))
    nil)

(defn- #_Bytes _addfmt [#_Bytes buf, #_Bytes fmt, #_int val]
;%% (.sprintf libC buf, fmt, val)
    (loop-when-recur buf (non-eos? buf) (.plus buf 1) => buf))

(final Bytes tgoto_UP)	;; %% nada!
(final Bytes tgoto_BC)	;; %% nada!
(final Bytes tgoto_buffer (Bytes. 32))

;; Decode cm cursor motion string.
;; cm is cursor motion string, row and col are the desired destination.
;; Returns a pointer to the decoded string, or "OOPS" if it cannot be decoded.
;;
;; Accepted escapes are:
;;      %d       as in printf, 0 origin.
;;      %2, %3   like %02d, %03d in printf.
;;      %.       like %c
;;      %+x      adds <x> to value, then %.
;;      %>xy     if value > x, adds y. No output.
;;      %i       increments row & col. No output.
;;      %r       reverses order of row & col. No output.
;;      %%       prints as a single %.
;;      %n       exclusive or row & col with 0140.
;;      %B       BCD, no output.
;;      %D       reverse coding (x-2*(x%16)), no output.

(defn- #_Bytes _tgoto [#_Bytes cm, #_int col, #_int row] ;; cm: string, from termcap ;; col: x position ;; row: y position
    (if (some? cm)
        (let-when [a'm (atom {#_boolean :reverse false #_boolean :up false #_boolean :bc false}) ;; reverse flag ;; add upline ;; add backup
                   #_Bytes p
                    (loop-when [cm cm col col row row p tgoto_buffer] (non-eos? cm) => (eos! p)
                        (let-when [#_byte b (.at cm 0) cm (.plus cm 1)] (== b (byte \%)) => (recur cm col row (-> p (.be 0, b) (.plus 1)))  ;; normal char
                            (let [upbc- (fn [col row] (if (any == row TAB (byte \newline) (byte \u0004) (byte \u0000))              ;; these are chars that UNIX hates
                                                        (let [row (inc row)]                                                        ;; so go to next pos
                                                            (swap! a'm assoc (if (== (:reverse @a'm) (== row col)) :up :bc) true)   ;; and mark UP or BC
                                                            row)
                                                        row))
                                  b (.at cm 0) cm (.plus cm 1)] ;; % escape
                                (condp == b
                                    (byte \d) (recur cm col col (_addfmt p, (u8 "%d"), row))                                        ;; decimal
                                    (byte \2) (recur cm col col (_addfmt p, (u8 "%02d"), row))                                      ;; 2 digit decimal
                                    (byte \3) (recur cm col col (_addfmt p, (u8 "%03d"), row))                                      ;; 3 digit decimal

                                    (byte \>)                                                                                       ;; %>xy: if >x, add y
                                        (let [#_byte x (.at cm 0) cm (.plus cm 1) #_byte y (.at cm 0) cm (.plus cm 1)]
                                            (recur cm (if (< x col) (+ col y) col) (if (< x row) (+ row y) row) p))

                                    (byte \+)                                                                                       ;; %+c: add c
                                        (let [row (+ row (.at cm 0)) cm (.plus cm 1)]
                                            (recur cm col col (-> p (.be 0, (upbc- col row)) (.plus 1))))                           ;; %% fallthrough

                                    (byte \.)                                                                                       ;; print x/y
                                        (recur cm col col (-> p (.be 0, (upbc- col row)) (.plus 1)))

                                    (byte \r)                                                                                       ;; r: reverse
                                        (let [#_int _ row row col col _]
                                            (swap! a'm assoc :reverse true)
                                            (recur cm col row p))

                                    (byte \i) (recur cm (inc col) (inc row) p)                                                      ;; increment (1-origin screen)
                                    (byte \%) (recur cm col row (-> p (.be 0, (byte \%)) (.plus 1)))                                ;; %%=% literally
                                    (byte \n) (recur cm (bit-xor col 0140) (bit-xor row 0140) p)                                    ;; magic DM2500 code
                                    (byte \B) (recur cm (+ (<< (/ col 10) 4) (% col 10)) (+ (<< (/ row 10) 4) (% row 10)) p)        ;; bcd encoding
                                    (byte \D) (recur cm (- col (* 2 (& col 15))) (- row (* 2 (& row 15))) p)                        ;; magic Delta Data code

                                    (byte \p)                                                                                       ;; so, what?
                                        (let [#_byte d (.at cm 0) cm (.plus cm 1)]
                                            (recur-if (any == d (byte \1) (byte \2)) [cm col row p] => nil))                        ;; ignore %p1 and %p2

                                    nil ;; unknown escape
                                ))
                        ))] (some? p) => (u8 "OOPS")
            (when (:up @a'm)                                  ;; add upline
                (when (some? tgoto_UP)
                    (let [#_Bytes s (loop-when-recur [s tgoto_UP] (or (asc-isdigit (.at s 0)) (at? s (byte \.))) [(.plus s 1)] => s)]
                        (loop-when-recur [p p s (if (at? s (byte \*)) (.plus s 1) s)] (non-eos? s) [(-> p (.be 0, (.at s 0)) (.plus 1)) (.plus s 1)] => (eos! p)))
                ))
            (when (:bc @a'm)                                 ;; add backspace
                (if (some? tgoto_BC)
                    (let [#_Bytes s (loop-when-recur [s tgoto_BC] (or (asc-isdigit (.at s 0)) (at? s (byte \.))) [(.plus s 1)] => s)]
                        (loop-when-recur [p p s (if (at? s (byte \*)) (.plus s 1) s)] (non-eos? s) [(-> p (.be 0, (.at s 0)) (.plus 1)) (.plus s 1)] => (eos! p)))
                    (-> p (.be 0, (byte \backspace)) (.plus 1) eos!)
                ))
            tgoto_buffer
        )
        (u8 "OOPS")                          ;; kludge, but standard
    ))

;; Note: "s" may have padding information ahead of it, in the form of nnnTEXT or nnn*TEXT.
;;  nnn is the number of milliseconds to delay, and may be a decimal fraction (nnn.mmm).
;;  In case an asterisk is given, the delay is to be multiplied by "_affcnt".

(defn- #_int _tputs [#_Bytes s, #_int _affcnt] ;; affcnt: number of lines affected
    (let [i 0 i (if (asc-isdigit (.at s i))
                    (let [i                         (loop-when-recur [i (inc i)] (asc-isdigit (.at s i)) [(inc i)] => i)
                          i (if (at? s i (byte \.)) (loop-when-recur [i (inc i)] (asc-isdigit (.at s i)) [(inc i)] => i) i)
                          i (if (at? s i (byte \*)) (inc i) i)]
                        i) i)]
        (loop-when-recur i (non-eos? s i) (inc i)
            (out-char-nf (.at s i))))
    0)

;; A never-padding out-str:
;; use this whenever you don't want to run the string through tputs.
;; tputs above is harmless,
;; but tputs from the termcap library is likely to strip off leading digits,
;; that it mistakes for padding information, and "%i", "%d", etc.
;; This should only be used for writing terminal codes, not for outputting
;; normal text: use functions like msg-puts() and screen-putchar() for that.

(defn- #_void out-str-nf [#_Bytes s]
    ;; avoid terminal strings being split up
    (when (< (- OUT_SIZE 20) @out_pos)
        (out-flush))
    (loop-when-recur [#_int i 0] (non-eos? s i) [(inc i)]
        (out-char-nf (.at s i)))
    ;; For testing we write one string at a time.
    (when (non-zero? @p_wd)
        (out-flush))
    nil)

;; out-str(s): Put a character string a byte at a time into the output buffer.
;; This should only be used for writing terminal codes, not for outputting
;; normal text: use functions like msg-puts() and screen-putchar() for that.

(defn- #_void out-str [#_Bytes s]
    (when (and (some? s) (non-eos? s))
        ;; avoid terminal strings being split up
        (when (< (- OUT_SIZE 20) @out_pos)
            (out-flush))
        (_tputs s, 1)
        ;; For testing we write one string at a time.
        (when (non-zero? @p_wd)
            (out-flush)))
    nil)

;; cursor positioning using termcap parser

(defn- #_void term-windgoto     [#_int row, #_int col]      (out-str (_tgoto @T_CM, col, row))       nil)
(defn- #_void term-cursor-right [#_int i]                   (out-str (_tgoto @T_CRI, 0, i))          nil)
(defn- #_void term-append-lines [#_int line_count]          (out-str (_tgoto @T_CAL, 0, line_count)) nil)
(defn- #_void term-delete-lines [#_int line_count]          (out-str (_tgoto @T_CDL, 0, line_count)) nil)
(defn- #_void term-set-winsize  [#_int width, #_int height] (out-str (_tgoto @T_CWS, height, width)) nil)

(defn- #_void term-fg-color [#_int n]
    ;; Use "AF" termcap entry if present, "Sf" entry otherwise.
    (cond
        (non-eos? @T_CAF) (term-color @T_CAF, n)
        (non-eos? @T_CSF) (term-color @T_CSF, n)
    )
    nil)

(defn- #_void term-bg-color [#_int n]
    ;; Use "AB" termcap entry if present, "Sb" entry otherwise.
    (cond
        (non-eos? @T_CAB) (term-color @T_CAB, n)
        (non-eos? @T_CSB) (term-color @T_CSB, n)
    )
    nil)

(defn- #_void term-color [#_Bytes s, #_int n]
    (let [#_int i 2 ;; index in s just after <Esc>[
          ;; Special handling of 16 colors, because termcap can't handle it.
          ;; Also accept "\e[3%dm" for TERMINFO, it is sometimes used.
          [s n] (if (and (<= 8 n) (<= 16 @t_colors) (at? s ESC) (at? s 1 (byte \[)) (non-eos? s i) (or (== (STRCMP (.plus s (inc i)), (u8 "%p1%dm")) 0) (== (STRCMP (.plus s (inc i)), (u8 "%dm")) 0)) (or (at? s i (byte \3)) (at? s i (byte \4))))
                    (let [#_Bytes buf (Bytes. 20)]
;%%                     (.sprintf libC buf, (u8 "%s%s%%p1%%dm"), (if (== i 2) (u8 "\033[") (u8 "\233")), (if (at? s i (byte \3)) (if (<= 16 n) (u8 "38;5;") (u8 "9")) (if (<= 16 n) (u8 "48;5;") (u8 "10"))))
                        [buf (if (<= 16 n) n (- n 8))]
                    )
                    [s n]
                )]
        (out-str (_tgoto s, 0, n)))
    nil)

;; Make sure we have a valid set or terminal options.
;; Replace all entries that are null by EMPTY_OPTION.

(defn- #_void ttest [#_boolean pairs]
    ;; MUST have "cm": cursor motion.
    (when (eos? @T_CM)
        (emsg (u8 "E437: terminal capability \"cm\" required")))

    ;; If "cs" defined, use a scroll region, it's faster.
    (reset! scroll_region (non-eos? @T_CS))

    ;; optional pairs
    (when pairs
        ;; TP goes to normal mode for TI (invert) and TB (bold).
        (when (eos? @T_ME)
            (reset! T_ME (reset! T_MR (reset! T_MD EMPTY_OPTION))))
        (when (or (eos? @T_SO) (eos? @T_SE))
            (reset! T_SO (reset! T_SE EMPTY_OPTION)))
        (when (or (eos? @T_US) (eos? @T_UE))
            (reset! T_US (reset! T_UE EMPTY_OPTION)))
        (when (or (eos? @T_CZH) (eos? @T_CZR))
            (reset! T_CZH (reset! T_CZR EMPTY_OPTION)))

        ;; T_VE is needed even though T_VI is not defined.
        (when (eos? @T_VE)
            (reset! T_VI EMPTY_OPTION))

        ;; If 'mr' or 'me' is not defined use 'so' and 'se'.
        (when (eos? @T_ME)
            (reset! T_ME @T_SE)
            (reset! T_MR (reset! T_MD @T_SO)))

        ;; If 'so' or 'se' is not defined use 'mr' and 'me'.
        (when (eos? @T_SO)
            (reset! T_SE @T_ME)
            (reset! T_SO (if (eos? @T_MR) @T_MD @T_MR)))

        ;; If 'ZH' or 'ZR' is not defined use 'mr' and 'me'.
        (when (eos? @T_CZH)
            (reset! T_CZR @T_ME)
            (reset! T_CZH (if (eos? @T_MR) @T_MD @T_MR)))

        ;; "Sb" and "Sf" come in pairs.
        (when (or (eos? @T_CSB) (eos? @T_CSF))
            (reset! T_CSB EMPTY_OPTION)
            (reset! T_CSF EMPTY_OPTION))

        ;; "AB" and "AF" come in pairs.
        (when (or (eos? @T_CAB) (eos? @T_CAF))
            (reset! T_CAB EMPTY_OPTION)
            (reset! T_CAF EMPTY_OPTION))

        ;; If 'Sb' and 'AB' are not defined, reset "Co".
        (when (and (eos? @T_CSB) (eos? @T_CAB))
            (reset! T_CCO EMPTY_OPTION))
    )

    (reset! need_gather true)

;%% (reset! t_colors (.atoi libC @T_CCO))
    nil)

;; Check if the new shell size is valid, correct it if it's too small or way too big.

(defn- #_void check-shellsize []
    (let [m (min-rows)]
        (when (< @Rows m)           ;; need room for one window and command line
            (reset! Rows m))
        (limit-screen-size))
    nil)

;; Limit Rows and Cols to avoid an overflow in Rows * Cols.

(defn- #_void limit-screen-size []
    (swap! Rows min 1000)
    (swap! Cols #(max MIN_COLS (min % 10000)))
    nil)

(atom! long old__Rows)
(atom! long old__Columns)

;; Invoked just before the screen structures are going to be (re)allocated.

(defn- #_void win-new-shellsize []
    (when (or (!= @old__Rows @Rows) (!= @old__Columns @Cols))
        (ui-new-shellsize))
    (when (!= @old__Rows @Rows)
        (reset! old__Rows @Rows)
        (shell-new-rows))           ;; update window sizes
    (when (!= @old__Columns @Cols)
        (reset! old__Columns @Cols)
        (shell-new-columns))        ;; update window sizes
    nil)

;; Call this function when the Vim shell has been resized in any way.
;; Will obtain the current size and redraw (also when size didn't change).

(defn- #_void shell-resized []
    (set-shellsize 0, 0, false)
    nil)

(atom! int _2_busy)

;; Set size of the Vim shell.
;; If 'mustset' is true, we must set Rows and Cols,
;; do not get the real window size (this is used for the :win command).
;; If 'mustset' is false, we may try to get the real window size
;; and if it fails, use 'width' and 'height'.

(defn- #_void set-shellsize [#_int width, #_int height, #_boolean mustset]
    ;; Avoid recursiveness, can happen when setting the window size causes another window-changed signal.
    (when-not (or (non-zero? @_2_busy) (neg? width) (neg? height))
        (if (any == @State HITRETURN SETWSIZE)
            (reset! State SETWSIZE) ;; postpone the resizing
            (do
                (swap! _2_busy inc)

                (if (or mustset (and (not (ui-get-shellsize)) (non-zero? height)))
                    (do
                        (reset! Rows height)
                        (reset! Cols width)
                        (check-shellsize)
                        (ui-set-shellsize mustset)
                    )
                    (check-shellsize))

                ;; The window layout used to be adjusted here, but it now happens in
                ;; screen-alloc() (also invoked from screen-clear()).  That is because
                ;; the "_2_busy" check above may skip this, but not screen-alloc().

                (if (any == @State ASKMORE CONFIRM)
                    (screen-start)     ;; don't know where cursor is now
                    (screen-clear))

                (when (!= @starting NO_SCREEN)
                    (swap! curwin changed-line-abv-curs)
                    (swap! curwin invalidate-botline)

                    ;; We only redraw when it's needed:
                    ;; - While at the more prompt or executing an external command, don't redraw, but position the cursor.
                    ;; - While editing the command line, only redraw that.
                    ;; - Otherwise, redraw right now, and position the cursor.
                    ;; Always need to call update-screen() or screen-alloc(), to make sure Rows/Cols and the size of screenLines[] is correct!

                    (cond (any == @State ASKMORE CONFIRM)
                    (do
                        (screen-alloc false)
                        (repeat-message)
                    )
                    :else
                    (do
                        (when @(:wo_scb (:w_options @curwin))
                            (swap! curwin do-check-scrollbind true))

                        (cond (flag? @State CMDLINE)
                        (do
                            (update-screen NOT_VALID)
                            (redrawcmdline)
                        )
                        :else
                        (do
                            (swap! curwin update-topline)
                            (update-screen NOT_VALID)
                            (when (redrawing) (setcursor))
                        ))
                    ))

                    (cursor-on)        ;; redrawing may have switched it off
                )

                (out-flush)

                (swap! _2_busy dec)
            )
        ))
    nil)

;; Set the terminal to TMODE_RAW (for Normal mode)
;; or TMODE_COOK (for external commands and Ex mode).

(defn- #_void settmode [#_int tmode]
    (when @full_screen
        ;; When returning after calling a shell we want to really set the
        ;; terminal to raw mode, even though we think it already is, because
        ;; the shell program may have reset the terminal mode.
        ;; When we think the terminal is normal, don't try to set it to
        ;; normal again, because that causes problems (logout!) on some machines.

        (when (or (!= tmode TMODE_COOK) (!= @cur_tmode TMODE_COOK))
            (out-flush)
            (mch-settmode tmode)        ;; machine specific function
            (reset! cur_tmode tmode)
            (out-flush)))
    nil)

(defn- #_void start-termcap []
    (when (and @full_screen (not @termcap_active))
        (out-str @T_TI)                 ;; start termcap mode
        (out-str @T_KS)                 ;; start "keypad transmit" mode
        (out-flush)
        (reset! termcap_active true)
        (screen-start))                 ;; don't know where cursor is now
    nil)

(defn- #_void stop-termcap []
    (screen-stop-highlight)
    (reset-cterm-colors)
    (when @termcap_active
        (out-str @T_KE)                 ;; stop "keypad transmit" mode
        (out-flush)
        (reset! termcap_active false)
        (cursor-on)                     ;; just in case it is still off
        (out-str @T_TE)                 ;; stop termcap mode
        (screen-start)                  ;; don't know where cursor is now
        (out-flush))
    nil)

;; Return true when saving and restoring the screen.

(defn- #_boolean swapping-screen []
    (and @full_screen (non-eos? @T_TI)))

;; By outputting the 'cursor very visible' termcap code, for some windowed
;; terminals this makes the screen scrolled to the correct position.
;; Used when starting Vim or returning from a shell.

(defn- #_void scroll-start []
    (when (non-eos? @T_VS)
        (out-str @T_VS)
        (out-str @T_VE)
        (screen-start))             ;; don't know where cursor is now
    nil)

(atom! boolean cursor_is_off)

;; Enable the cursor.

(defn- #_void cursor-on []
    (when @cursor_is_off
        (out-str @T_VE)
        (reset! cursor_is_off false))
    nil)

;; Disable the cursor.

(defn- #_void cursor-off []
    (when @full_screen
        (when (not @cursor_is_off)
            (out-str @T_VI))          ;; disable cursor
        (reset! cursor_is_off true))
    nil)

(atom! int showing_mode NORMAL)

;; Set cursor shape to match Insert or Replace mode.

(defn- #_void term-cursor-shape []
    ;; Only do something when redrawing the screen and we can restore the mode.
    (when (and @full_screen (non-eos? @T_CEI))
        (cond (== (& @State REPLACE) REPLACE)
            (when (!= @showing_mode REPLACE)
                ;; Replace mode cursor ;; fall back to Insert mode cursor
                (let-when [#_Bytes s (if (non-eos? @T_CSR) @T_CSR @T_CSI)] (non-eos? s)
                    (out-str s)
                    (reset! showing_mode REPLACE)
                )
            )
        (flag? @State INSERT)
            (when (and (!= @showing_mode INSERT) (non-eos? @T_CSI))
                (out-str @T_CSI)                    ;; Insert mode cursor
                (reset! showing_mode INSERT)
            )
        (!= @showing_mode NORMAL)
            (do
                (out-str @T_CEI)                    ;; non-Insert mode cursor
                (reset! showing_mode NORMAL)
            )
        ))
    nil)

;; Set scrolling region for window 'win'.
;; The region starts 'off' lines from the start of the window.
;; Also set the vertical scroll region for a vertically split window.
;; Always the full width of the window, excluding the vertical separator.

(defn- #_void scroll-region-set [#_window_C win, #_int off]
    (out-str (_tgoto @T_CS, (dec (+ (:w_winrow win) (:w_height win))), (+ (:w_winrow win) off)))

    (when (and (non-eos? @T_CSV) (!= (:w_width win) @Cols))
        (out-str (_tgoto @T_CSV, (dec (+ (:w_wincol win) (:w_width win))), (:w_wincol win))))

    (screen-start)                 ;; don't know where cursor is now
    nil)

;; Reset scrolling region to the whole screen.

(defn- #_void scroll-region-reset []
    (out-str (_tgoto @T_CS, (dec @Rows), 0))

    (when (non-eos? @T_CSV)
        (out-str (_tgoto @T_CSV, (dec @Cols), 0)))

    (screen-start)                 ;; don't know where cursor is now
    nil)

;; List of terminal codes that are currently recognized.

(class! #_final termcode_C
    [
        (field Bytes    name    (Bytes. 2))     ;; termcap name of entry
        (field Bytes    code)                   ;; terminal code (in allocated memory)
        (field int      len)                    ;; STRLEN(code)
        (field int      modlen)                 ;; length of part before ";*~".
    ])

(defn- #_void COPY-termcode [#_termcode_C tc1, #_termcode_C tc0]
    (ยง
        (BCOPY (:name tc1), (:name tc0), 2)
        ((ร tc1.code =) (:code tc0))
        ((ร tc1.len =) (:len tc0))
        ((ร tc1.modlen =) (:modlen tc0))
        nil
    ))

(defn- #_termcode_C* ARRAY-termcode [#_int n]
    (vec (repeatedly n NEW_termcode_C)))

(atom! termcode_C* termcodes)

(atom! int tc_max_len)  ;; number of entries that termcodes[] can hold
(atom! int tc_len)      ;; current number of entries in termcodes[]

(defn- #_void clear-termcodes []
    (reset! tc_len 0)
    (reset! tc_max_len 0)
    (reset! termcodes nil)

    (reset! need_gather true)         ;; need to fill termleader[]
    nil)

;; Add a new entry to the list of terminal codes.
;; The list is kept alphabetical for ":set termcap"

(defn- #_void add-termcode [#_Bytes name, #_Bytes string]
    (ยง
        (when (or (nil? string) (eos? string))
            (del-termcode name)
            ((ร RETURN) nil)
        )

        ((ร Bytes code =) (STRDUP string))

        ((ร int len =) (STRLEN code))

        (reset! need_gather true)         ;; need to fill termleader[]

        ;; need to make space for more entries

        (when (== @tc_len @tc_max_len)
            (swap! tc_max_len + 20)
            ((ร termcode_C[] new_tc =) (ARRAY-termcode @tc_max_len))
            (dotimes [#_int i @tc_len]
                (COPY-termcode (... new_tc i), (... @termcodes i))
            )
            (reset! termcodes new_tc)
        )

        ;; Look for existing entry with the same name, it is replaced.
        ;; Look for an existing entry that is alphabetical higher, the new entry is inserted in front of it.

        ((ร int i =) (loop-when-recur [i 0] (< i @tc_len) [(inc i)] => i
            (if (< (char_u (.at (:name (... @termcodes i)) 0)) (char_u (.at name 0)))
                (ร CONTINUE)
            )
            (when (at? (:name (... @termcodes i)) 0 (.at name 0))
                (if (< (char_u (.at (:name (... @termcodes i)) 1)) (char_u (.at name 1)))
                    (ร CONTINUE)
                )

                ;; Exact match: May replace old code.

                (when (at? (:name (... @termcodes i)) 1 (.at name 1))
                    ;; Replace old code.
                    ((ร @termcodes[i].code =) nil)
                    (swap! tc_len dec)
                    (ร BREAK)
                )
            )

            ;; Found alphabetical larger entry, move rest to insert new entry.

            (loop-when-recur [#_int j @tc_len] (< i j) [(dec j)]
                (COPY-termcode (... @termcodes j), (... @termcodes (dec j)))
            )
            (ร BREAK)
        ))

;       @termcodes[i].name.be(0, name.at(0));
;       @termcodes[i].name.be(1, name.at(1));
        ((ร @termcodes[i].code =) code)
        ((ร @termcodes[i].len =) len)

        ;; For xterm we recognize special codes like "ESC[42;*X" and "ESC O*X" that accept modifiers.
        ((ร @termcodes[i].modlen =) 0)
        ((ร int j =) (termcode-star code, len))
        (if (< 0 j)
            ((ร @termcodes[i].modlen =) (- len 1 j))
        )
        (swap! tc_len inc)
        nil
    ))

;; Check termcode "code[len]" for ending in ;*X, <Esc>O*X or <M-O>*X.
;; The "X" can be any character.
;; Return 0 if not found, 2 for ;*X and 1 for O*X and <M-O>*X.

(defn- #_int termcode-star [#_Bytes code, #_int len]
    ;; Shortest is <M-O>*X.  With ; shortest is <CSI>1;*X.
    (if (and (<= 3 len) (at? code (- len 2) (byte \*)))
        (cond
            (and (<= 5 len) (at? code (- len 3) (byte \;)))
                2
            (or (and (<= 4 len) (at? code (- len 3) (byte \O))) (== (char_u (.at code (- len 3))) (+ (byte \O) 0x80)))
                1
            :else
                0)
        0))

(defn- #_Bytes find-termcode [#_Bytes name]
    (loop-when [#_int i 0] (< i @tc_len) => nil
        (let [tc (... @termcodes i)] (recur-if (not (and (at? (:name tc) 0 (.at name 0)) (at? (:name tc) 1 (.at name 1)))) [(inc i)] => (:code tc)))
    ))

(defn- #_void del-termcode [#_Bytes name]
    (when (some? @termcodes)
        (reset! need_gather true)               ;; need to fill termleader[]
        (loop-when [#_int i 0] (< i @tc_len)
            (if (and (at? (:name (... @termcodes i)) 0 (.at name 0)) (at? (:name (... @termcodes i)) 1 (.at name 1)))
                (del-termcode-idx i)
                (recur (inc i))
            )
        ))
    ;; Not found.  Give error message?
    nil)

(defn- #_void del-termcode-idx [#_int idx]
    (ยง
        ((ร @termcodes[idx].code =) nil)
        (swap! tc_len dec)
        (loop-when-recur [#_int i idx] (< i @tc_len) [(inc i)]
            (COPY-termcode (... @termcodes i), (... @termcodes (inc i)))
        )
        nil
    ))

;; Check if typebuf.tb_buf[] contains a terminal key code.
;; Check at typebuf.tb_buf[typebuf.tb_off].
;; Return 0 for no match, -1 for partial match, > 0 for full match.
;; Return KEYLEN_REMOVED when a key code was deleted.
;; With a match, the match is removed, the replacement code is inserted in
;; typebuf.tb_buf[] and the number of characters in typebuf.tb_buf[] is returned.
;; When "buf" is not null, buf[bufsize] is used instead of typebuf.tb_buf[].
;; "buflen" is then the length of the string in buf[] and is updated for inserts and deletes.

(defn- #_int check-termcode [#_Bytes buf, #_int bufsize, #_int' a'buflen]
    (ยง
        ;; Speed up the checks for terminal codes by gathering all first bytes used in termleader[].
        ;; Often this is just a single <Esc>.

        (when @need_gather
            (gather-termleader))

        (ร Bytes tp)
        (ร int len)

        (cond (nil? buf)
        (do
            (if (<= (:tb_len @typebuf) 0)
                ((ร RETURN) 0)
            )
            ((ร tp =) (.plus (:tb_buf @typebuf) (:tb_off @typebuf)))
            ((ร len =) (:tb_len @typebuf))      ;; length of the input
        )
        :else
        (do
            (if (<= @a'buflen 0)
                ((ร RETURN) 0)
            )
            ((ร tp =) buf)
            ((ร len =) @a'buflen)
        ))

        ;; Don't check characters after KB_SPECIAL, those are already
        ;; translated terminal chars (avoid translating ~@^Hx).

        (if (at? tp KB_SPECIAL)        ;; there are always 2 extra characters
            ((ร RETURN) 0)
        )

        ;; Skip this position if the character does not appear as the first character in 'term_strings'.
        ;; This speeds up a lot, since most termcodes start with the same character (ESC).

        ((ร Bytes q =) (loop-when-recur [q termleader] (and (non-eos? q) (!= (.at q 0) (.at tp 0))) [(.plus q 1)] => q))
        (if (eos? q)
            ((ร RETURN) 0)
        )

        ;; Skip this position if "p_ek" is not set and *tp is an ESC and we are in Insert mode.

        (if (and (at? tp ESC) (not @p_ek) (flag? @State INSERT))
            ((ร RETURN) 0)
        )

        ((ร Bytes key_name =) (Bytes. 2))
        ((ร int[] a'modifiers =) (atom (int 0)))      ;; no modifiers yet

        ((ร int slen =) 0)

        (loop-when-recur [#_int idx 0] (< idx @tc_len) [(inc idx)]
            ((ร slen =) (:len (... @termcodes idx)))

            (when (== (STRNCMP (:code (... @termcodes idx)), tp, (min len slen)) 0)
                (if (< len slen)             ;; got a partial sequence
                    ((ร RETURN) -1)              ;; need to get more chars
                )

                ;; When found a keypad key, check if there is another key that matches and use that one.
                ;; This makes <Home> to be found instead of <kHome> when they produce the same key code.

                (when (and (at? (:name (... @termcodes idx)) (byte \K)) (asc-isdigit (.at (:name (... @termcodes idx)) 1)))
                    (loop-when-recur [#_int j (inc idx)] (< j @tc_len) [(inc j)]
                        (when (and (== (:len (... @termcodes j)) slen) (zero? (STRNCMP (:code (... @termcodes idx)), (:code (... @termcodes j)), slen)))
                            ((ร idx =) j)
                            (ร BREAK)
                        )
                    )
                )

                (.be key_name 0, (.at (:name (... @termcodes idx)) 0))
                (.be key_name 1, (.at (:name (... @termcodes idx)) 1))
                (ร BREAK)
            )

            ;; Check for code with modifier, like xterm uses:
            ;; <Esc>[123;*X (modslen == slen - 3), also <Esc>O*X and <M-O>*X (modslen == slen - 2).
            ;; When there is a modifier the * matches a number.
            ;; When there is no modifier the ;* or * is omitted.

            (when (< 0 (:modlen (... @termcodes idx)))
                ((ร int modslen =) (:modlen (... @termcodes idx)))

                (when (== (STRNCMP (:code (... @termcodes idx)), tp, (min len modslen)) 0)
                    (if (<= len modslen)     ;; got a partial sequence
                        ((ร RETURN) -1)          ;; need to get more chars
                    )

                    (cond (at? tp modslen (.at (:code (... @termcodes idx)) (dec slen)))
                    (do
                        ((ร slen =) (inc modslen)) ;; no modifiers
                    )
                    (and (not-at? tp modslen (byte \;)) (== modslen (- slen 3)))
                    (do
                        (ร CONTINUE)   ;; no match
                    )
                    :else
                    (do
                        ;; Skip over the digits, the final char must follow.
                        ((ร int j =) (loop-when-recur [j (- slen 2)] (and (< j len) (asc-isdigit (.at tp j))) [(inc j)] => (inc j)))
                        (if (< len j)        ;; got a partial sequence
                            ((ร RETURN) -1)      ;; need to get more chars
                        )
                        (if (not-at? tp (dec j) (.at (:code (... @termcodes idx)) (dec slen)))
                            (ร CONTINUE)       ;; no match
                        )

                        ;; Match!  Convert modifier bits.
                        ((ร int n =) (- (.atoi libC (.plus tp (- slen 2))) 1))
                        (when (non-zero? (& n 1)) (swap! a'modifiers | MOD_MASK_SHIFT))
                        (when (non-zero? (& n 2)) (swap! a'modifiers | MOD_MASK_ALT))
                        (when (non-zero? (& n 4)) (swap! a'modifiers | MOD_MASK_CTRL))
                        (when (non-zero? (& n 8)) (swap! a'modifiers | MOD_MASK_META))

                        ((ร slen =) j)
                    ))

                    (.be key_name 0, (.at (:name (... @termcodes idx)) 0))
                    (.be key_name 1, (.at (:name (... @termcodes idx)) 1))
                    (ร BREAK)
                )
            )
        )

        (when (eos? key_name)
            ((ร RETURN) 0)               ;; no match found
        )

        ;; We only get here when we have a complete termcode match.

        ;; Change <xHome> to <Home>, <xUp> to <Up>, etc.

        ((ร int key =) (handle-x-keys (TERMCAP2KEY (.at key_name 0), (.at key_name 1))))

        ((ร Bytes string =) (Bytes. (inc MAX_KEY_CODE_LEN)))

        ;; Add any modifier codes to our string.

        ((ร int new_slen =) 0)           ;; length of what will replace the termcode
        (when (non-zero? @a'modifiers)
            ;; Some keys have the modifier included.
            ;; Need to handle that here to make mappings work.
            ((ร key =) (simplify-key key, a'modifiers))
            (when (non-zero? @a'modifiers)
                (.be string (ร new_slen++), KB_SPECIAL)
                (.be string (ร new_slen++), KS_MODIFIER)
                (.be string (ร new_slen++), @a'modifiers)
            )
        )

        ((ร int retval =) 0)

        ;; Finally, add the special key code to our string.
        (.be key_name 0, (KEY2TERMCAP0 key))
        (.be key_name 1, (KEY2TERMCAP1 key))
        (cond (at? key_name KS_KEY)
        (do
            ;; from ":set <M-b>=xx"
            ((ร new_slen =) (+ new_slen (utf-char2bytes (char_u (.at key_name 1)), (.plus string new_slen))))
        )
        (and (zero? new_slen) (at? key_name KS_EXTRA) (at? key_name 1 KE_IGNORE))
        (do
            ;; Do not put K_IGNORE into the buffer, do return KEYLEN_REMOVED to indicate what happened.
            ((ร retval =) KEYLEN_REMOVED)
        )
        :else
        (do
            (.be string (ร new_slen++), KB_SPECIAL)
            (.be string (ร new_slen++), (.at key_name 0))
            (.be string (ร new_slen++), (.at key_name 1))
        ))
        (eos! string new_slen)

        ((ร int extra =) (- new_slen slen))
        (cond (nil? buf)
        (do
            (cond (< extra 0)
            (do
                ;; remove matched chars, taking care of noremap
                (del-typebuf (- extra))
            )
            (< 0 extra)
            (do
                ;; insert the extra space we need
                (ins-typebuf (.plus string slen))
            ))

            (BCOPY (:tb_buf @typebuf), (:tb_off @typebuf), string, 0, new_slen)
        )
        :else
        (do
            (cond (< extra 0)
            (do
                ;; remove matched characters
                (BCOPY buf, 0, buf, (- extra), (+ @a'buflen extra))
            )
            (< 0 extra)
            (do
                ;; Insert the extra space we need.  If there is insufficient space return -1.
                (if (<= bufsize (+ @a'buflen extra new_slen))
                    ((ร RETURN) -1)
                )
                (BCOPY buf, extra, buf, 0, @a'buflen)
            ))

            (BCOPY buf, 0, string, 0, new_slen)
            (reset! a'buflen (+ @a'buflen (+ extra new_slen)))
        ))

        (if (non-zero? retval) retval (+ len extra))
    ))

;; Gather the first characters in the terminal key codes into a string.
;; Used to speed up check-termcode().

(defn- #_void gather-termleader []
    (eos! termleader 0)
    (loop-when [#_int n 0 #_int i 0] (< i @tc_len)
        (let [#_byte leader (.at (:code (... @termcodes i)) 0)
              n (if (nil? (vim-strchr termleader, leader)) (do (.be termleader n, leader) (let [n (inc n)] (eos! termleader n) n)) n)]
            (recur n (inc i))
        ))
    (reset! need_gather false)
    nil)

;; ui.c: functions that handle the user interface.
;; 1. Keyboard input stuff, and a bit of windowing stuff.  These are called
;;    before the machine specific stuff (mch_*) so that we can call the GUI
;;    stuff instead if the GUI is running.
;; 2. Clipboard stuff.
;; 3. Input buffer stuff.

(defn- #_void ui-write [#_Bytes s, #_int len]
    (mch-write s, len)
    nil)

;; ui-inchar(): low level input function.
;; Get characters from the keyboard.
;; Return the number of characters that are available.
;; If "wtime" == 0 do not wait for characters.
;; If "wtime" == -1 wait forever for characters.
;; If "wtime" > 0 wait "wtime" milliseconds for a character.
;;
;; "tb_change_cnt" is the value of typebuf.tb_change_cnt if "buf" points into it.
;; When typebuf.tb_change_cnt changes (e.g., when a message is received from a remote client)
;; "buf" can no longer be used.  "tb_change_cnt" is null otherwise.

(defn- #_int ui-inchar [#_Bytes buf, #_int maxlen, #_long wtime, #_int tb_change_cnt]
    ;; If we are going to wait for some time or block...
    (when (or (== wtime -1) (< 100 wtime))
        (vim-handle-signal SIGNAL_UNBLOCK)) ;; ... allow signals to kill us.
    (let [#_int len (mch-inchar buf, maxlen, wtime, tb_change_cnt)]
        (when (or (== wtime -1) (< 100 wtime))
            (vim-handle-signal SIGNAL_BLOCK)) ;; block SIGHUP et al.
        len))

;; Delay for the given number of milliseconds.
;; If ignoreinput is false then we cancel the delay if a key is hit.

(defn- #_void ui-delay [#_long msec, #_boolean ignoreinput]
    (mch-delay msec, ignoreinput)
    nil)

;; If the machine has job control, use it to suspend the program,
;; otherwise fake it by starting a new shell.
;; When running the GUI iconify the window.

(defn- #_void ui-suspend []
    (mch-suspend)
    nil)

;; Try to get the current Vim shell size.
;; Put the result in Rows and Cols.
;; Use the new sizes as defaults for 'columns' and 'lines'.
;; Return true when size could be determined, false otherwise.

(defn- #_boolean ui-get-shellsize []
    (let [#_boolean got (mch-get-shellsize)]
        (check-shellsize)
        got
    ))

;; Set the size of the Vim shell according to Rows and Cols, if possible.
;; The gui_set_shellsize() or mch-set-shellsize() function will try to set the new size.
;; If this is not possible, it will adjust Rows and Cols.

(defn- #_void ui-set-shellsize [#_boolean _mustset]
    ;; mustset: set by the user
    (mch-set-shellsize)
    nil)

;; Called when Rows and/or Cols changed.

(defn- #_void ui-new-shellsize []
    (when (and @full_screen (not @exiting))
        (mch-new-shellsize))
    nil)

(defn- #_void ui-breakcheck []
    (mch-breakcheck)
    nil)

;; Functions that handle the input buffer.
;; This is used for any GUI version, and the unix terminal version.
;;
;; For Unix, the input characters are buffered to be able to check for a CTRL-C.
;; This should be done with signals, but I don't know how to do that in a portable way
;; for a tty in RAW mode.
;;
;; For the client-server code in the console the received keys are put in the input buffer.

;; Internal typeahead buffer.
;; Includes extra space for long key code descriptions which would otherwise overflow.
;; The buffer is considered full when only this extra space (or part of it) remains.

(final int INBUFLEN 250)

(final Bytes    inbuf (Bytes. (+ INBUFLEN MAX_KEY_CODE_LEN)))
(atom! int      inbufcount)     ;; number of chars in inbuf[]

(defn- #_boolean is-input-buf-full  [] (<= INBUFLEN @inbufcount))
(defn- #_boolean is-input-buf-empty [] (zero? @inbufcount))

;; Read as much data from the input buffer as possible up to maxlen, and store it in buf.
;; Note: this function used to be Read() in unix.c

(defn- #_int read-from-input-buf [#_Bytes buf, #_int maxlen]
    (if (zero? @inbufcount)            ;; if the buffer is empty, fill it
        (fill-input-buf true))
    (let [maxlen (min maxlen @inbufcount)]
        (BCOPY buf, inbuf, maxlen)
        (swap! inbufcount - maxlen)
        (if (non-zero? @inbufcount)
            (BCOPY inbuf, 0, inbuf, maxlen, @inbufcount))
        maxlen
    ))

(atom! boolean did_read_something)
(atom! Bytes fib__rest)    ;; unconverted rest of previous read
(atom! int fib__restlen)

(defn- #_void fill-input-buf [#_boolean exit_on_error]
    (ยง if-not (is-input-buf-full)
        ;; fill_input_buf() is only called when we really need a character.
        ;; If we can't get any, but there is some in the buffer, just return.
        ;; If we can't get any, and there isn't any in the buffer, we give up and exit Vim.
        (let-when [#_int unconverted
                (if (some? @fib__rest)
                    ;; Use remainder of previous call, starts with an invalid character that may become valid when reading more.
                    (let [unconverted (min @fib__restlen (- INBUFLEN @inbufcount))]
                        (BCOPY inbuf, @inbufcount, @fib__rest, 0, unconverted)
                        (if (== unconverted @fib__restlen)
                            (reset! fib__rest nil)
                            (do
                                (swap! fib__restlen - unconverted)
                                (BCOPY @fib__rest, 0, @fib__rest, unconverted, @fib__restlen)
                            ))
                        (swap! inbufcount + unconverted)
                        unconverted)
                    0)
              #_int len
                (loop-when [len 0 #_int i 0] (< i 100) => len
                    (let-when [len (int (.read libC @read_cmd_fd, (.plus inbuf @inbufcount), (- INBUFLEN @inbufcount)))] (not (or (< 0 len) @got_int)) => len
                        ;; If reading stdin results in an error, continue reading stderr.
                        ;; This helps when using "foo | xargs vim".
                        (when (and (not @did_read_something) (zero? (.isatty libc @read_cmd_fd)) (zero? @read_cmd_fd))
                            (let [#_int m @cur_tmode]
                                ;; We probably set the wrong file descriptor to raw mode.
                                ;; Switch back to cooked mode, use another descriptor and set the mode to what it was.
                                (settmode TMODE_COOK)
                                ;; Use stderr for stdin, also works for shell commands.
                                (.close libc 0)
                                (.dup libc 2)
                                (settmode m)
                            ))
                        (recur-if exit_on_error [len (inc i)] => nil)
                    ))] (some? len)
            (if (or (< 0 len) @got_int)
                (do
                    (when (< 0 len)
                        (reset! did_read_something true))
                    (if @got_int ;; Interrupted, pretend a CTRL-C was typed.
                        (do (.be inbuf 0, Ctrl_C) (reset! inbufcount 1))
                        ;; May perform conversion on the input characters.  Include the unconverted rest of the previous call.
                        ;; If there is an incomplete char at the end, it is kept for the next time: reading more bytes should make conversion possible.
                        ;; Don't do this in the unlikely event that the input buffer is too small ("fib__rest" still contains more bytes).
                        (loop-when-recur len (< 0 len) (dec len)
                            ;; if a CTRL-C was typed, remove it from the buffer and set got_int
                            (when (at? inbuf @inbufcount Ctrl_C)
                                ;; remove everything typed before the CTRL-C
                                (BCOPY inbuf, 0, inbuf, @inbufcount, len)
                                (reset! inbufcount 0)
                                (reset! got_int true))
                            (swap! inbufcount inc))
                    ))
                (do
                    (preserve-exit (u8 "Vim: Error reading input, exiting...\n"))
                ))
        ))
    nil)

;; May update the shape of the cursor.

(defn- #_void ui-cursor-shape []
    (term-cursor-shape)
    (swap! curwin conceal-check-cursor-line)
    nil)

;; Check bounds for column number.

(defn- #_int check-col [#_int col]
    (cond (< col 0) 0 (<= @screenCols col) (dec @screenCols) :else col))

;; Check bounds for row number.

(defn- #_int check-row [#_int row]
    (cond (< row 0) 0 (<= @screenRows row) (dec @screenRows) :else row))

;; screen.c: code for displaying on the screen
;;
;; Output to the screen (console, terminal emulator or GUI window) is minimized by
;; remembering what is already on the screen, and only updating the parts that changed.
;;
;; screenLines[off]  Contains a copy of the whole screen, as it is currently
;;                   displayed (excluding text written by external commands).
;; screenAttrs[off]  Contains the associated attributes.
;; lineOffset[row]   Contains the offset into screenLines*[] and screenAttrs[]
;;                   for each line.
;; lineWraps[row]    Flag for each line whether it wraps to the next line.
;;
;; For double-byte characters, two consecutive bytes in screenLines[] can form one character
;; which occupies two display cells.  For UTF-8 a multi-byte character is converted to Unicode
;; and stored in screenLinesUC[].  screenLines[] contains the first byte only.  For an ASCII
;; character without composing chars screenLinesUC[] will be 0 and screenLinesC[][] is not used.
;; When the character occupies two display cells the next byte in screenLines[] is 0.
;; screenLinesC[][] contain up to 'maxcombine' composing characters
;; (drawn on top of the first character).  There is 0 after the last one used.
;;
;; The screen_*() functions write to the screen and handle updating screenLines[].
;;
;; update-screen() is the function that updates all windows and status lines.
;; It is called form the main loop when must_redraw is non-zero.  It may be
;; called from other places when an immediate screen update is needed.
;;
;; The part of the buffer that is displayed in a window is set with:
;; - w_topline (first buffer line in window)
;; - w_topfill (filler lines above the first line)
;; - w_leftcol (leftmost window cell in window),
;; - w_skipcol (skipped window cells of first line)
;;
;; Commands that only move the cursor around in a window, do not need to take
;; action to update the display.  The main loop will check if "w_topline" is
;; valid and update it (scroll the window) when needed.
;;
;; Commands that scroll a window change "w_topline" and must call
;; check-cursor() to move the cursor into the visible part of the window, and
;; call redraw-later(VALID) to have the window displayed by update-screen() later.
;;
;; Commands that change text in the buffer must call changed-bytes() or
;; changed-lines() to mark the area that changed and will require updating
;; later.  The main loop will call update-screen(), which will update each
;; window that shows the changed buffer.  This assumes text above the change
;; can remain displayed as it is.  Text after the change may need updating for
;; scrolling, folding and syntax highlighting.
;;
;; Commands that change how a window is displayed (e.g., setting 'list') or
;; invalidate the contents of a window in another way (e.g., change fold
;; settings), must call redraw-later(NOT_VALID) to have the whole window
;; redisplayed by update-screen() later.
;;
;; Commands that change how a buffer is displayed (e.g., setting 'tabstop')
;; must call redraw-curbuf-later(NOT_VALID) to have all the windows for the
;; buffer redisplayed by update-screen() later.
;;
;; Commands that change highlighting and possibly cause a scroll too must call
;; redraw-later(SOME_VALID) to update the whole window but still use scrolling
;; to avoid redrawing everything.  But the length of displayed lines must not
;; change, use NOT_VALID then.
;;
;; Commands that move the window position must call redraw-later(NOT_VALID).
;; TODO: should minimize redrawing by scrolling when possible.
;;
;; Commands that change everything (e.g., resizing the screen) must call
;; redraw-all-later(NOT_VALID) or redraw-all-later(CLEAR).
;;
;; Things that are handled indirectly:
;; - When messages scroll the screen up, msg_scrolled will be set and
;;   update-screen() called to redraw.

(final byte MB_FILLER_CHAR \<)     ;; character used when a double-width character doesn't fit.

;; The attributes that are actually active for writing to the screen.

(atom! int screen_attr)

;; Positioning the cursor is reduced by remembering the last position.
;; Mostly used by windgoto() and screen-char().

;; last known cursor position
(atom! int screen_cur_row)
(atom! int screen_cur_col)

(atom! match_C search_hl    (NEW_match_C))   ;; used for 'hlsearch' highlight matching

;; Buffer for one screen line (characters and attributes).

(atom! Bytes current_ScreenLine)

(final int SEARCH_HL_PRIORITY 0)

;; Ugly global: overrule attribute used by screen-char().
(atom! int screen_char_attr)

;; Redraw window "win" later with update-screen(type).
;; Set "must_redraw" only if not already set to a higher value,
;; e.g. if "must_redraw" is CLEAR, type NOT_VALID will do nothing.

(defn- #_window_C redraw-later [#_window_C win, #_int type]
    (if (< (:w_redr_type win) type)
        (let [win (assoc win :w_redr_type type)
              win (if (<= NOT_VALID type) (assoc win :w_lines_valid 0) win)]
            ;; "must_redraw" is the maximum of all windows
            (when (< @must_redraw type)
                (reset! must_redraw type))
            win)
        win
    ))

;; Force a complete redraw later.  Also resets the highlighting.
;; To be used after executing a shell command that messes up the screen.

(defn- #_void redraw-later-clear []
    (redraw-all-later CLEAR)
    ;; Use attributes that is very unlikely to appear in text.
    (reset! screen_attr (| HL_BOLD HL_UNDERLINE HL_INVERSE))
    nil)

;; Mark all windows to be redrawn later.

(defn- #_void redraw-all-later [#_int type]
    (ยง loop-when-recur [#_window_C win @firstwin] (some? win) [(:w_next win)]
        ((ร win =) (redraw-later win, type))
    )
    nil)

;; Mark all windows that are editing the current buffer to be updated later.

(defn- #_void redraw-curbuf-later [#_int type]
    (ยง loop-when-recur [#_window_C win @firstwin] (some? win) [(:w_next win)]
        ((ร win =) (redraw-later win, type))
    )
    nil)

;; Changed something in the current window, at buffer line "lnum", that
;; requires that line and possibly other lines to be redrawn.
;; Used when entering/leaving Insert mode with the cursor on a folded line.
;; Used to remove the "$" from a change command.
;; Note that when also inserting/deleting lines "w_redraw_top" and "w_redraw_bot"
;; may become invalid and the whole window will have to be redrawn.

(defn- #_window_C redraw-winline [#_window_C win, #_long lnum]
    (let [win (let-when [top (:w_redraw_top win)] (or (zero? top) (> top lnum)) => win (assoc win :w_redraw_top lnum))
          win (let-when [bot (:w_redraw_bot win)] (or (zero? bot) (< bot lnum)) => win (assoc win :w_redraw_bot lnum))]
        (redraw-later win, VALID)
    ))

;; update all windows that are editing the current buffer

(defn- #_void update-curbuf [#_int type]
    (redraw-curbuf-later type)
    (update-screen type)
    nil)

;; update-screen()
;;
;; Based on the current value of curwin.w_topline, transfer a screenfull
;; of stuff from Filemem to screenLines[], and update curwin.w_botline.

(defn- #_void update-screen [#_int type]
    (ยง
        ;; Don't do anything if the screen structures are (not yet) valid.
        (if (not (screen-valid true))
            ((ร RETURN) nil)
        )

        (when (non-zero? @must_redraw)
            ((ร type =) (max @must_redraw type))             ;; use maximal type

            ;; "must_redraw" is reset here, so when we run into some weird reason to redraw while busy redrawing (e.g. asynchronous scrolling),
            ;; or update-topline() in win-update() will cause a scroll, the screen will be redrawn later or in win-update().
            (reset! must_redraw 0)
        )

        ;; Need to update w_lines[].
        ((ร type =) (if (and (zero? (:w_lines_valid @curwin)) (< type NOT_VALID)) NOT_VALID type))

        ;; Postpone the redrawing when it's not needed and when being called recursively.
        (when (or (not (redrawing)) @updating_screen)
            (swap! curwin redraw-later type)                 ;; remember type for next time
            (reset! must_redraw type)
            (if (< INVERTED_ALL type)
                (swap! curwin assoc :w_lines_valid 0)       ;; don't use w_lines[].wl_size now
            )
            ((ร RETURN) nil)
        )

        (reset! updating_screen true)

        ;; if the screen was scrolled up when displaying a message, scroll it down

        (when (non-zero? @msg_scrolled)
            (reset! clear_cmdline true)
            (cond (< (- @Rows 5) @msg_scrolled)        ;; clearing is faster
            (do
                ((ร type =) CLEAR)
            )
            (!= type CLEAR)
            (do
                (check-for-delay false)
                ((ร type =) (if (not (screen-ins-lines 0, 0, @msg_scrolled, @Rows, nil)) CLEAR type))
                (loop-when-recur [#_window_C wp @firstwin] (some? wp) [(:w_next wp)]
                    (when (< (:w_winrow wp) @msg_scrolled)
                        (cond (and (< @msg_scrolled (+ (:w_winrow wp) (:w_height wp))) (< (:w_redr_type wp) REDRAW_TOP) (< 0 (:w_lines_valid wp)) (== (:w_topline wp) (:wl_lnum (... (:w_lines wp) 0))))
                        (do
                            ((ร wp =) (assoc wp :w_upd_rows (- @msg_scrolled (:w_winrow wp))))
                            ((ร wp =) (assoc wp :w_redr_type REDRAW_TOP))
                        )
                        :else
                        (do
                            ((ร wp =) (assoc wp :w_redr_type NOT_VALID))
                            (if (<= (+ (:w_winrow wp) (:w_height wp) (:w_status_height wp)) @msg_scrolled)
                                ((ร wp =) (assoc wp :w_redr_status true))
                            )
                        ))
                    )
                )
                (reset! redraw_cmdline true)
            ))
            (reset! msg_scrolled 0)
            (reset! need_wait_return false)
        )

        ;; reset cmdline_row now (may have been changed temporarily)
        (compute-cmdrow)

        ;; Check for changed highlighting.
        (when @need_highlight_changed
            (highlight-changed))

        (when (== type CLEAR)              ;; first clear screen
            (screen-clear)              ;; will reset clear_cmdline
            ((ร type =) NOT_VALID)
        )

        (when @clear_cmdline              ;; going to clear cmdline (done below)
            (check-for-delay false))

        ;; Force redraw when width of 'number' or 'relativenumber' column changes.
        (when (and (< (:w_redr_type @curwin) NOT_VALID) (!= (:w_nrwidth @curwin) (if (or @(:wo_nu (:w_options @curwin)) @(:wo_rnu (:w_options @curwin))) (number-width @curwin) 0)))
            (swap! curwin assoc :w_redr_type NOT_VALID))

        ;; Only start redrawing if there is really something to do.

        (when (== type INVERTED)
            (swap! curwin update-curswant))
        (when (and (< (:w_redr_type @curwin) type) (not (or (and (== type VALID) (:wl_valid (... (:w_lines @curwin) 0)) (== (:w_topline @curwin) (:wl_lnum (... (:w_lines @curwin) 0)))) (and (== type INVERTED) @VIsual_active (== (:w_old_cursor_lnum @curwin) (:lnum (:w_cursor @curwin))) (== (:w_old_visual_mode @curwin) @VIsual_mode) (flag? (:w_valid @curwin) VALID_VIRTCOL) (== (:w_old_curswant @curwin) (:w_curswant @curwin))))))
            (swap! curwin assoc :w_redr_type type))

        ;; Go from top to bottom through the windows, redrawing the ones that need it.

        ((ร boolean did_one =) false)
        (swap! search_hl assoc-in [:rmm :regprog] nil)

        (loop-when-recur [#_window_C wp @firstwin] (some? wp) [(:w_next wp)]
            (when (non-zero? (:w_redr_type wp))
                (cursor-off)
                (when (not did_one)
                    ((ร did_one =) true)
                    (start-search-hl)
                )
                ((ร wp =) (win-update wp))
            )

            ;; redraw status line after the window to minimize cursor movement
            (when (:w_redr_status wp)
                (cursor-off)
                ((ร wp =) (win-redr-status wp))
            )
        )
        (end-search-hl)

        ;; Reset b_mod_set flags.  Going through all windows is probably faster
        ;; than going through all buffers (there could be many buffers).
        (loop-when-recur [#_window_C wp @firstwin] (some? wp) [(:w_next wp)]
            (swap! curbuf assoc :b_mod_set false)
        )

        (reset! updating_screen false)

        ;; Clear or redraw the command line.
        ;; Done last, because scrolling may mess up the command line.
        (when (or @clear_cmdline @redraw_cmdline)
            (showmode)
        )
        nil
    ))

;; Return true if the cursor line in window "win" may be concealed, according to the 'concealcursor' option.

(defn- #_boolean conceal-cursor-line [#_window_C win]
    (let [cocu @(:wo_cocu (:w_options win))]
        (and (non-eos? cocu)
            (let [c (cond
                        (flag? (get-real-state) VISUAL) (byte \v)
                        (flag? @State INSERT)           (byte \i)
                        (flag? @State NORMAL)           (byte \n)
                        (flag? @State CMDLINE)          (byte \c)
                    )]
                (and (some? c) (some? (vim-strchr cocu, c)))
            )
        )
    ))

;; Check if the cursor line needs to be redrawn because of 'concealcursor'.

(defn- #_window_C conceal-check-cursor-line [#_window_C win]
    (let-when [cole @(:wo_cole (:w_options win))] (and (pos? cole) (conceal-cursor-line win)) => win
        ;; Need to recompute cursor column, e.g. when starting Visual mode without concealing.
        (-> win (assoc :w_redraw_cline true) (curs-columns true))
    ))

(defn- #_window_C update-single-line [#_window_C win, #_long lnum]
    (when (and (<= (:w_topline win) lnum) (< lnum (:w_botline win)))
        (loop-when [row 0 i 0] (< i (:w_lines_valid win))
            (let [wli (... (:w_lines win) i)]
                (if (== lnum (:wl_lnum wli))
                    (do
                        (screen-start) ;; not sure of screen cursor
                        (init-search-hl win)
                        (start-search-hl)
                        (prepare-search-hl win, lnum)
                        (win-line win, lnum, row, (+ row (:wl_size wli)), false)
                        (end-search-hl)
                    )
                    (recur (+ row (:wl_size wli)) (inc i))
                ))
        ))
    (assoc win :w_redraw_cline false))

;; Update a single window.
;; This may cause the windows below it also to be redrawn (when clearing the screen or scrolling lines).
;;
;; How the window is redrawn depends on "w_redr_type".
;; Each type also implies the one below it.
;;
;; NOT_VALID    redraw the whole window
;; SOME_VALID   redraw the whole window but do scroll when possible
;; REDRAW_TOP   redraw the top "w_upd_rows" window lines, otherwise like VALID
;; INVERTED     redraw the changed part of the Visual area
;; INVERTED_ALL redraw the whole Visual area
;; VALID        1. scroll up/down to adjust for a changed "w_topline"
;;              2. update lines at the top when scrolled down
;;              3. redraw changed text:
;;                 - if "b_mod_set" is set, update lines between "b_mod_top" and "b_mod_bot".
;;                 - if "w_redraw_top" is non-zero, redraw lines between "w_redraw_top" and "w_redr_bot".
;;                 - continue redrawing when syntax status is invalid.
;;              4. if scrolled up, update lines at the bottom.
;;
;; This results in three areas that may need updating:
;;
;; top: from first row to top_end (when scrolled down)
;; mid: from mid_start to mid_end (update inversion or changed text)
;; bot: from bot_start to last row (when scrolled up)

(atom! boolean _2_recursive)    ;; being called recursively

(defn- #_window_C win-update [#_window_C win]
    (ยง
        ((ร long o'botline =) (:w_botline win))

        ((ร int type =) (:w_redr_type win))

        (when (== type NOT_VALID)
            ((ร win =) (assoc win :w_redr_status true))
            ((ร win =) (assoc win :w_lines_valid 0))
        )

        ;; Window is zero-height: nothing to draw.
        (when (zero? (:w_height win))
            ((ร win =) (assoc win :w_redr_type 0))
            ((ร RETURN) win)
        )

        ;; Window is zero-width: Only need to draw the separator.
        (when (zero? (:w_width win))
            ;; draw the vertical separator right of this window
            (draw-vsep-win win, 0)
            ((ร win =) (assoc win :w_redr_type 0))
            ((ร RETURN) win)
        )

        (init-search-hl win)

        ((ร long mod_top =) 0)
        ((ร long mod_bot =) 0)
        ((ร boolean top_to_mod =) false)         ;; redraw above mod_top

        ;; Force redraw when width of 'number' or 'relativenumber' column changes.
        ((ร int i =) (if (or @(:wo_nu (:w_options win)) @(:wo_rnu (:w_options win))) (number-width win) 0))
        (cond (!= (:w_nrwidth win) i)
        (do
            ((ร type =) NOT_VALID)
            ((ร win =) (assoc win :w_nrwidth i))
        )
        (and (:b_mod_set @curbuf) (non-zero? (:b_mod_xlines @curbuf)) (non-zero? (:w_redraw_top win)))
        (do
            ;; When there are both inserted/deleted lines and specific lines to be
            ;; redrawn, "w_redraw_top" and "w_redraw_bot" may be invalid, just redraw
            ;; everything (only happens when redrawing is off for while).

            ((ร type =) NOT_VALID)
        )
        :else
        (do
            ;; Set mod_top to the first line that needs displaying because of changes.
            ;; Set mod_bot to the first line after the changes.

            ((ร mod_top =) (:w_redraw_top win))
            ((ร mod_bot =) (if (non-zero? (:w_redraw_bot win)) (inc (:w_redraw_bot win)) 0))
            ((ร win =) (assoc win :w_redraw_top 0))    ;; reset for next time
            ((ร win =) (assoc win :w_redraw_bot 0))
            (when (:b_mod_set @curbuf)
                ((ร mod_top =) (if (or (zero? mod_top) (< (:b_mod_top @curbuf) mod_top)) (:b_mod_top @curbuf) mod_top))
                ((ร mod_bot =) (if (or (zero? mod_bot) (< mod_bot (:b_mod_bot @curbuf))) (:b_mod_bot @curbuf) mod_bot))

                ;; When 'hlsearch' is on and using a multi-line search pattern,
                ;; a change in one line may make the Search highlighting in a previous line invalid.
                ;; Simple solution: redraw all visible lines above the change.
                ;; Same for a match pattern.

                (cond (and (some? (:regprog (:rmm @search_hl))) (re-multiline (:regprog (:rmm @search_hl))))
                (do
                    ((ร top_to_mod =) true)
                )
                :else
                (do
                    (loop-when-recur [#_matchitem_C mi (:w_match_head win)] (some? mi) [(:next mi)]
                        (when (and (some? (:regprog (:mi_match mi))) (re-multiline (:regprog (:mi_match mi))))
                            ((ร top_to_mod =) true)
                            (ร BREAK)
                        )
                    )
                ))
            )

            ;; When a change starts above "w_topline" and the end is below "w_topline",
            ;; start redrawing at "w_topline".
            ;; If the end of the change is above "w_topline": do like no change was made,
            ;; but redraw the first line to find changes in syntax.
            ((ร mod_top =) (if (and (non-zero? mod_top) (< mod_top (:w_topline win) mod_bot)) (:w_topline win) mod_top))

            ;; When line numbers are displayed, need to redraw all lines below
            ;; inserted/deleted lines.
            ((ร mod_bot =) (if (and (non-zero? mod_top) (non-zero? (:b_mod_xlines @curbuf)) @(:wo_nu (:w_options win))) MAXLNUM mod_bot))
        ))

        ((ร int top_end =) 0)                    ;; Below last row of the top area that needs updating.  0 when no top area updating.
        ((ร int mid_start =) 999)                ;; First row of the mid area that needs updating.     999 when no mid area updating.
        ((ร int mid_end =) 0)                    ;; Below last row of the mid area that needs updating.  0 when no mid area updating.
        ((ร int bot_start =) 999)                ;; First row of the bot area that needs updating.     999 when no bot area updating.

        ;; When only displaying the lines at the top, set top_end.
        ;; Used when window has scrolled down for msg_scrolled.

        (when (== type REDRAW_TOP)
            ((ร top_end =) (loop-when [#_int i 0 #_int j 0] (< i (:w_lines_valid win)) => top_end
                (let-when [j (+ j (:wl_size (... (:w_lines win) i)))] (< j (:w_upd_rows win)) => j
                    (recur (inc i) j)
                )
            ))
            ((ร type =) (if (zero? top_end)
                NOT_VALID ;; not found (cannot happen?): redraw everything
                VALID ;; top area defined, the rest is VALID
            ))
        )

        ;; Trick: we want to avoid clearing the screen twice.  screen-clear() will set
        ;; "screen_cleared" to true.  The special value MAYBE (which is still non-zero
        ;; and thus not false) will indicate that screen-clear() was not called.
        (when (!= @screen_cleared FALSE)
            (reset! screen_cleared MAYBE))

        ((ร boolean scrolled_down =) false)      ;; true when scrolled down when "w_topline" got smaller a bit

        ;; If there are no changes on the screen that require a complete redraw,
        ;; handle three cases:
        ;; 1: we are off the top of the screen by a few lines: scroll down
        ;; 2: win.w_topline is below win.w_lines[0].wl_lnum: may scroll up
        ;; 3: win.w_topline is win.w_lines[0].wl_lnum: find first entry in w_lines[] that needs updating.

        (cond (any == type VALID SOME_VALID INVERTED INVERTED_ALL)
        (do
            (cond (and (non-zero? mod_top) (== (:w_topline win) mod_top))
            (do
                ;; "w_topline" is the first changed line, the scrolling will be done further down.
            )
            (and (:wl_valid (... (:w_lines win) 0)) (< (:w_topline win) (:wl_lnum (... (:w_lines win) 0))))
            (do
                ;; New topline is above old topline: may scroll down.
                ((ร int j =) (int (- (:wl_lnum (... (:w_lines win) 0)) (:w_topline win))))

                (cond (< j (- (:w_height win) 2))        ;; not too far off
                (do
                    ((ร i =) (plines-many win, (:w_topline win), (dec (:wl_lnum (... (:w_lines win) 0)))))

                    (cond (< i (- (:w_height win) 2))    ;; less than a screen off
                    (do
                        ;; Try to insert the correct number of lines.
                        ;; If not the last window, delete the lines at the bottom.
                        ;; win-ins-lines may fail when the terminal can't do it.

                        (if (< 0 i)
                            (check-for-delay false))
                        (cond (win-ins-lines win, 0, i, false, (== win @firstwin))
                        (do
                            (when (non-zero? (:w_lines_valid win))
                                ;; Need to update rows that are new,
                                ;; stop at the first one that scrolled down.
                                ((ร top_end =) i)
                                ((ร scrolled_down =) true)

                                ;; Move the entries that were scrolled,
                                ;; disable the entries for the lines to be redrawn.
                                ((ร win =) (assoc win :w_lines_valid (min (+ (:w_lines_valid win) j) (:w_height win))))
                                ((ร int idx =) (loop-when-recur [idx (:w_lines_valid win)] (<= 0 (- idx j)) [(dec idx)] => idx
                                    (COPY-wline (... (:w_lines win) idx), (... (:w_lines win) (- idx j)))
                                ))
                                (loop-when-recur idx (<= 0 idx) (dec idx)
                                    ((ร win.w_lines[idx].wl_valid =) false)
                                )
                            )
                        )
                        :else
                        (do
                            ((ร mid_start =) 0)          ;; redraw all lines
                        ))
                    )
                    :else
                    (do
                        ((ร mid_start =) 0)              ;; redraw all lines
                    ))
                )
                :else
                (do
                    ((ร mid_start =) 0)                  ;; redraw all lines
                ))
            )
            :else
            (do
                ;; New topline is at or below old topline: May scroll up.
                ;; When topline didn't change, find first entry in w_lines[] that needs updating.

                ;; try to find win.w_topline in win.w_lines[].wl_lnum
                ((ร int j =) -1)
                ((ร int row =) 0)
                (loop-when-recur [#_int i 0] (< i (:w_lines_valid win)) [(inc i)]
                    (when (and (:wl_valid (... (:w_lines win) i)) (== (:wl_lnum (... (:w_lines win) i)) (:w_topline win)))
                        ((ร j =) i)
                        (ร BREAK)
                    )
                    ((ร row =) (+ row (:wl_size (... (:w_lines win) i))))
                )
                (cond (== j -1)
                (do
                    ;; if win.w_topline is not in win.w_lines[].wl_lnum redraw all lines
                    ((ร mid_start =) 0)
                )
                :else
                (do
                    ;; Try to delete the correct number of lines.
                    ;; win.w_topline is at win.w_lines[i].wl_lnum.

                    (when (< 0 row)
                        (check-for-delay false)
                        (if (win-del-lines win, 0, row, false, (== win @firstwin))
                            ((ร bot_start =) (- (:w_height win) row))
                            ((ร mid_start =) 0)          ;; redraw all lines
                        )
                    )
                    (when (and (or (zero? row) (< bot_start 999)) (non-zero? (:w_lines_valid win)))
                        ;; Skip the lines (below the deleted lines) that are still valid and
                        ;; don't need redrawing.  Copy their info upwards, to compensate for the
                        ;; deleted lines.  Set bot_start to the first row that needs redrawing.

                        ((ร bot_start =) 0)
                        ((ร int idx =) 0)                ;; current index in w_lines[]
                        (loop []
                            (COPY-wline (... (:w_lines win) idx), (... (:w_lines win) j))
                            ;; stop at line that didn't fit,
                            ;; unless it is still valid (no lines deleted)
                            (when (and (< 0 row) (< (:w_height win) (+ bot_start row (:wl_size (... (:w_lines win) j)))))
                                ((ร win =) (assoc win :w_lines_valid (inc idx)))
                                (ร BREAK)
                            )
                            ((ร bot_start =) (+ bot_start (:wl_size (... (:w_lines win) (ร idx++)))))

                            ;; stop at the last valid entry in w_lines[].wl_size
                            (when (<= (:w_lines_valid win) ((ร j =) (inc j)))
                                ((ร win =) (assoc win :w_lines_valid idx))
                                (ร BREAK)
                            )
                            (recur)
                        )
                    )
                ))
            ))

            ;; When starting redraw in the first line, redraw all lines.
            ;; When there is only one window it's probably faster to clear the screen first.
            (when (zero? mid_start)
                ((ร mid_end =) (:w_height win))
                (when (== @lastwin @firstwin)
                    ;; Clear the screen when it was not done by win-del-lines() or
                    ;; win-ins-lines() above, "screen_cleared" is false or MAYBE then.
                    (if (!= @screen_cleared TRUE)
                        (screen-clear))
                )
            )

            ;; When win-del-lines() or win-ins-lines() caused the screen to be
            ;; cleared (only happens for the first window) or when screen-clear()
            ;; was called directly above, "must_redraw" will have been set to
            ;; NOT_VALID, need to reset it here to avoid redrawing twice.
            (if (== @screen_cleared TRUE)
                (reset! must_redraw 0))
        )
        :else
        (do
            ;; Not VALID or INVERTED: redraw all lines.
            ((ร mid_start =) 0)
            ((ร mid_end =) (:w_height win))
        ))

        (when (== type SOME_VALID)
            ;; SOME_VALID: redraw all lines.
            ((ร mid_start =) 0)
            ((ร mid_end =) (:w_height win))
            ((ร type =) NOT_VALID)
        )

        ;; check if we are updating or removing the inverted part
        (when (or @VIsual_active (and (non-zero? (:w_old_cursor_lnum win)) (!= type NOT_VALID)))
            (ร long from)
            (ร long to)

            (cond @VIsual_active
            (do
                (cond (and @VIsual_active (or (!= @VIsual_mode (:w_old_visual_mode win)) (== type INVERTED_ALL)))
                (do
                    ;; If the type of Visual selection changed, redraw the whole selection.
                    ;; Also when the ownership of the X selection is gained or lost.

                    (cond (< (:lnum (:w_cursor @curwin)) (:lnum @VIsual_cursor))
                    (do
                        ((ร from =) (:lnum (:w_cursor @curwin)))
                        ((ร to =) (:lnum @VIsual_cursor))
                    )
                    :else
                    (do
                        ((ร from =) (:lnum @VIsual_cursor))
                        ((ร to =) (:lnum (:w_cursor @curwin)))
                    ))
                    ;; redraw more when the cursor moved as well
                    ((ร from =) (min from (:w_old_cursor_lnum win) (:w_old_visual_lnum win)))
                    ((ร to =) (max (:w_old_cursor_lnum win) (:w_old_visual_lnum win) to))
                )
                :else
                (do
                    ;; Find the line numbers that need to be updated: The lines
                    ;; between the old cursor position and the current cursor
                    ;; position.  Also check if the Visual position changed.

                    (cond (< (:lnum (:w_cursor @curwin)) (:w_old_cursor_lnum win))
                    (do
                        ((ร from =) (:lnum (:w_cursor @curwin)))
                        ((ร to =) (:w_old_cursor_lnum win))
                    )
                    :else
                    (do
                        ((ร from =) (:w_old_cursor_lnum win))
                        ((ร to =) (:lnum (:w_cursor @curwin)))
                        ((ร from =) (if (zero? from) to from))              ;; Visual mode just started
                    ))

                    (when (or (!= (:lnum @VIsual_cursor) (:w_old_visual_lnum win)) (!= (:col @VIsual_cursor) (:w_old_visual_col win)))
                        (if (non-zero? (:w_old_visual_lnum win))
                            ((ร from =) (min from (:w_old_visual_lnum win))))
                        ((ร from =) (min from (:lnum @VIsual_cursor)))
                        ((ร to =) (max (:w_old_visual_lnum win) (:lnum @VIsual_cursor) to))
                    )
                ))

                ;; If in block mode and changed column or curwin.w_curswant: update all lines.
                ;; First compute the actual start and end column.

                (when (== @VIsual_mode Ctrl_V)
                    ((ร int[] a'fromc =) (atom (int)))
                    ((ร int[] a'toc =) (atom (int)))
                    ((ร int save_ve_flags =) @ve_flags)

                    (if @(:wo_lbr (:w_options @curwin))
                        (reset! ve_flags VE_ALL))
                    (getvcols win, @VIsual_cursor, (:w_cursor @curwin), a'fromc, a'toc)
                    (reset! ve_flags save_ve_flags)
                    (swap! a'toc inc)
                    (when (== (:w_curswant @curwin) MAXCOL)
                        (reset! a'toc MAXCOL))

                    (when (or (!= @a'fromc (:w_old_cursor_fcol win)) (!= @a'toc (:w_old_cursor_lcol win)))
                        ((ร from =) (min from (:lnum @VIsual_cursor)))
                        ((ร to =) (max (:lnum @VIsual_cursor) to))
                    )
                    ((ร win =) (assoc win :w_old_cursor_fcol @a'fromc))
                    ((ร win =) (assoc win :w_old_cursor_lcol @a'toc))
                )
            )
            :else
            (do
                ;; Use the line numbers of the old Visual area.
                (cond (< (:w_old_cursor_lnum win) (:w_old_visual_lnum win))
                (do
                    ((ร from =) (:w_old_cursor_lnum win))
                    ((ร to =) (:w_old_visual_lnum win))
                )
                :else
                (do
                    ((ร from =) (:w_old_visual_lnum win))
                    ((ร to =) (:w_old_cursor_lnum win))
                ))
            ))

            ;; There is no need to update lines above the top of the window.

            ((ร from =) (max (:w_topline win) from))

            ;; If we know the value of "w_botline",
            ;; use it to restrict the update to the lines that are visible in the window.

            (when (flag? (:w_valid win) VALID_BOTLINE)
                ((ร from =) (min from (dec (:w_botline win))))
                ((ร to =) (min to (dec (:w_botline win))))
            )

            ;; Find the minimal part to be updated.
            ;; Watch out for scrolling that made entries in w_lines[] invalid.
            ;; E.g., CTRL-U makes the first half of w_lines[] invalid and sets top_end;
            ;; need to redraw from top_end to the "to" line.
            ;; A middle mouse click with a Visual selection may change the text above
            ;; the Visual area and reset wl_valid, do count these for mid_end (in srow).

            (when (< 0 mid_start)
                ((ร long lnum =) (:w_topline win))       ;; current buffer lnum to display
                ((ร int idx =) 0)                    ;; current index in w_lines[]
                ((ร int srow =) 0)                   ;; starting row of the current line
                ((ร mid_start =) (if scrolled_down top_end 0))
                (loop-when [] (and (< lnum from) (< idx (:w_lines_valid win)))   ;; find start
                    (cond (:wl_valid (... (:w_lines win) idx))
                    (do
                        ((ร mid_start =) (+ mid_start (:wl_size (... (:w_lines win) idx))))
                    )
                    (not scrolled_down)
                    (do
                        ((ร srow =) (+ srow (:wl_size (... (:w_lines win) idx))))
                    ))
                    ((ร idx =) (inc idx))
                    ((ร lnum =) (inc lnum))
                    (recur)
                )
                ((ร srow =) (+ srow mid_start))
                ((ร mid_end =) (:w_height win))
                (loop-when-recur idx (< idx (:w_lines_valid win)) (inc idx)          ;; find end
                    (when (and (:wl_valid (... (:w_lines win) idx)) (<= (inc to) (:wl_lnum (... (:w_lines win) idx))))
                        ;; Only update until first row of this line.
                        ((ร mid_end =) srow)
                        (ร BREAK)
                    )
                    ((ร srow =) (+ srow (:wl_size (... (:w_lines win) idx))))
                )
            )
        )

        (cond @VIsual_active
        (do
            ((ร win =) (assoc win :w_old_visual_mode @VIsual_mode))
            ((ร win =) (assoc win :w_old_cursor_lnum (:lnum (:w_cursor @curwin))))
            ((ร win =) (assoc win :w_old_visual_lnum (:lnum @VIsual_cursor)))
            ((ร win =) (assoc win :w_old_visual_col (:col @VIsual_cursor)))
            ((ร win =) (assoc win :w_old_curswant (:w_curswant @curwin)))
        )
        :else
        (do
            ((ร win =) (assoc win :w_old_visual_mode 0))
            ((ร win =) (assoc win :w_old_cursor_lnum 0))
            ((ร win =) (assoc win :w_old_visual_lnum 0))
            ((ร win =) (assoc win :w_old_visual_col 0))
        ))

        ;; reset got_int, otherwise regexp won't work
        ((ร boolean o'got_int =) @got_int)
        (reset! got_int false)

        ((ร boolean didline =) false)            ;; if true, we finished the last line
        ((ร boolean eof =) false)                ;; if true, we hit the end of the file

        ;; Update all the window rows.

        ((ร int idx =) 0)                    ;; first entry in w_lines[].wl_size
        ((ร int row =) 0)                    ;; current window row to display
        ((ร int srow =) 0)                   ;; starting row of the current line
        ((ร long lnum =) (:w_topline win))       ;; first line shown in window
        (loop []
            ;; stop updating when reached the end of the window
            ;; (check for _past_ the end of the window is at the end of the loop)
            (when (== row (:w_height win))
                ((ร didline =) true)
                (ร BREAK)
            )

            ;; stop updating when hit the end of the file
            (when (< (line-count @curbuf) lnum)
                ((ร eof =) true)
                (ร BREAK)
            )

            ;; Remember the starting row of the line that is going to be dealt with.
            ;; It is used further down when the line doesn't fit.
            ((ร srow =) row)

            ;; Update a line when it is in an area that needs updating,
            ;; when it has changes or w_lines[idx] is invalid.
            ;; bot_start may be halfway a wrapped line after using win-del-lines(),
            ;; check if the current line includes it.
            ;; When syntax folding is being used, the saved syntax states will
            ;; already have been updated, we can't see where the syntax state is
            ;; the same again, just update until the end of the window.

            ;; match in fixed position might need redraw if lines were inserted or deleted
            (cond (or (< row top_end) (and (<= mid_start row) (< row mid_end)) top_to_mod (<= (:w_lines_valid win) idx) (< bot_start (+ row (:wl_size (... (:w_lines win) idx)))) (and (!= mod_top 0) (or (== lnum mod_top) (and (<= mod_top lnum) (or (< lnum mod_bot) (and (some? (:w_match_head win)) (!= (:b_mod_xlines @curbuf) 0)))))))
            (do
                ((ร top_to_mod =) (if (== lnum mod_top) false top_to_mod))

                ;; When at start of changed lines:
                ;; may scroll following lines up or down to minimize redrawing.
                ;; Don't do this when the change continues until the end.

                (when (and (== lnum mod_top) (!= mod_bot MAXLNUM))
                    ((ร int old_rows =) 0)
                    ((ร int new_rows =) 0)
                    (ร int xtra_rows)

                    ;; Count the old number of window rows, using w_lines[], which should
                    ;; still contain the sizes for the lines as they are currently displayed.

                    ((ร i =) (loop-when-recur [i idx] (< i (:w_lines_valid win)) [(inc i)] => i
                        ;; Only valid lines have a meaningful wl_lnum.
                        ;; Invalid lines are part of the changed area.
                        (if (and (:wl_valid (... (:w_lines win) i)) (== (:wl_lnum (... (:w_lines win) i)) mod_bot))
                            (ร BREAK)
                        )
                        ((ร old_rows =) (+ old_rows (:wl_size (... (:w_lines win) i))))
                    ))

                    (cond (<= (:w_lines_valid win) i)
                    (do
                        ;; We can't find a valid line below the changed lines,
                        ;; need to redraw until the end of the window.
                        ;; Inserting/deleting lines has no use.
                        ((ร bot_start =) 0)
                    )
                    :else
                    (do
                        ;; Able to count old number of rows:
                        ;; count new window rows, and may insert/delete lines.
                        ((ร int j =) idx)
                        (loop-when-recur [#_long l lnum] (< l mod_bot) [(inc l)]
                            ((ร new_rows =) (+ new_rows (plines win, l, true)))
                            ((ร j =) (inc j))
                            (when (< (- (:w_height win) row 2) new_rows)
                                ;; it's getting too much, must redraw the rest
                                ((ร new_rows =) 9999)
                                (ร BREAK)
                            )
                        )
                        ((ร xtra_rows =) (- new_rows old_rows))
                        (cond (< xtra_rows 0)
                        (do
                            ;; May scroll text up.
                            ;; If there is not enough remaining text or scrolling fails,
                            ;; must redraw the rest.
                            ;; If scrolling works,
                            ;; must redraw the text below the scrolled text.
                            (cond (<= (- (:w_height win) 2) (- row xtra_rows))
                            (do
                                ((ร mod_bot =) MAXLNUM)
                            )
                            :else
                            (do
                                (check-for-delay false)
                                (if (not (win-del-lines win, row, (- xtra_rows), false, false))
                                    ((ร mod_bot =) MAXLNUM)
                                    ((ร bot_start =) (+ (:w_height win) xtra_rows))
                                )
                            ))
                        )
                        (< 0 xtra_rows)
                        (do
                            ;; May scroll text down.
                            ;; If there is not enough remaining text of scrolling fails,
                            ;; must redraw the rest.
                            (cond (<= (- (:w_height win) 2) (+ row xtra_rows))
                            (do
                                ((ร mod_bot =) MAXLNUM)
                            )
                            :else
                            (do
                                (check-for-delay false)
                                (cond (not (win-ins-lines win, (+ row old_rows), xtra_rows, false, false))
                                (do
                                    ((ร mod_bot =) MAXLNUM)
                                )
                                (< (+ row old_rows) top_end)
                                (do
                                    ;; Scrolled the part at the top that requires updating down.
                                    ((ร top_end =) (+ top_end xtra_rows))
                                ))
                            ))
                        ))

                        ;; When not updating the rest, may need to move w_lines[] entries.
                        (when (and (!= mod_bot MAXLNUM) (!= i j))
                            (cond (< j i)
                            (do
                                ;; move entries in w_lines[] upwards
                                ((ร int x =) (loop [x (+ row new_rows)]
                                    ;; stop at last valid entry in w_lines[]
                                    (when (<= (:w_lines_valid win) i)
                                        ((ร win =) (assoc win :w_lines_valid j))
                                        (ร BREAK)
                                    )
                                    (COPY-wline (... (:w_lines win) j), (... (:w_lines win) i))
                                    ;; stop at a line that won't fit
                                    (when (< (:w_height win) (+ x (:wl_size (... (:w_lines win) j))))
                                        ((ร win =) (assoc win :w_lines_valid (inc j)))
                                        (ร BREAK)
                                    )
                                    ((ร x =) (+ x (:wl_size (... (:w_lines win) j))))
                                    ((ร j =) (inc j))
                                    ((ร i =) (inc i))
                                    (recur x)
                                ))
                                ((ร bot_start =) (min bot_start x))
                            )
                            :else ;; j > i
                            (do
                                ;; move entries in w_lines[] downwards
                                ((ร j =) (- j i))
                                ((ร win =) (update win :w_lines_valid + j))
                                ((ร win =) (update win :w_lines_valid min (:w_height win)))
                                ((ร i =) (loop-when-recur [i (:w_lines_valid win)] (<= idx (- i j)) [(dec i)] => i
                                    (COPY-wline (... (:w_lines win) i), (... (:w_lines win) (- i j)))
                                ))

                                ;; The w_lines[] entries for inserted lines are now invalid,
                                ;; but wl_size may be used above.
                                ;; Reset to zero.
                                (loop-when-recur i (<= idx i) (dec i)
                                    ((ร win.w_lines[i].wl_size =) 0)
                                    ((ร win.w_lines[i].wl_valid =) false)
                                )
                            ))
                        )
                    ))
                )

                (cond (and (< idx (:w_lines_valid win)) (:wl_valid (... (:w_lines win) idx)) (== (:wl_lnum (... (:w_lines win) idx)) lnum) (< (:w_topline win) lnum) (non-flag? @dy_flags DY_LASTLINE) (< (:w_height win) (+ srow (:wl_size (... (:w_lines win) idx)))))
                (do
                    ;; This line is not going to fit.
                    ;; Don't draw anything here, will draw "@  " lines below.
                    ((ร row =) (inc (:w_height win)))
                )
                :else
                (do
                    (prepare-search-hl win, lnum)

                    ;; Display one line.

                    ((ร row =) (win-line win, lnum, srow, (:w_height win), (== mod_top 0)))
                ))

                ((ร win.w_lines[idx].wl_lnum =) lnum)
                ((ร win.w_lines[idx].wl_valid =) true)
                (when (< (:w_height win) row)              ;; past end of screen
                    ;; we may need the size of that too long line later on
                    ((ร win.w_lines[idx].wl_size =) (plines win, lnum, true))
                    ((ร idx =) (inc idx))
                    (ร BREAK)
                )
                ((ร win.w_lines[idx].wl_size =) (- row srow))
                ((ร idx =) (inc idx))
                ((ร lnum =) (inc lnum))
            )
            :else
            (do
                ;; This line does not need updating, advance to the next one.
                ((ร row =) (+ row (:wl_size (... (:w_lines win) (ร idx++)))))
                (if (< (:w_height win) row)              ;; past end of screen
                    (ร BREAK)
                )
                ((ร lnum =) (inc lnum))
            ))

            (when (< (line-count @curbuf) lnum)
                ((ร eof =) true)
                (ร BREAK)
            )
            (recur)
        )

        ;; End of loop over all window lines.

        ((ร win =) (update win :w_lines_valid max idx))

        ;; If we didn't hit the end of the file, and we didn't finish the last
        ;; line we were working on, then the line didn't fit.

        ((ร win =) (assoc win :w_empty_rows 0))
        (cond (and (not eof) (not didline))
        (do
            (cond (== lnum (:w_topline win))
            (do
                ;; Single line that does not fit!
                ;; Don't overwrite it, it can be edited.

                ((ร win =) (assoc win :w_botline (inc lnum)))
            )
            (flag? @dy_flags DY_LASTLINE)     ;; 'display' has "lastline"
            (do
                ;; Last line isn't finished: Display "@@@" at the end.

                (screen-fill (- (+ (:w_winrow win) (:w_height win)) 1), (+ (:w_winrow win) (:w_height win)), (- (+ (:w_wincol win) (:w_width win)) 3), (+ (:w_wincol win) (:w_width win)), (byte \@), (byte \@), (hl-attr HLF_AT))
                ((ร win =) (set-empty-rows win, srow))
                ((ร win =) (assoc win :w_botline lnum))
            )
            :else
            (do
                ((ร win =) (win-draw-end win, (byte \@), (byte \space), srow, (:w_height win), HLF_AT))
                ((ร win =) (assoc win :w_botline lnum))
            ))
        )
        :else
        (do
            (draw-vsep-win win, row)
            (cond eof                                ;; we hit the end of the file
            (do
                ((ร win =) (assoc win :w_botline (inc (line-count @curbuf))))
            )
            :else
            (do
                ((ร win =) (assoc win :w_botline lnum))
            ))

            ;; Make sure the rest of the screen is blank,
            ;; put '~'s on rows that aren't part of the file.
            ((ร win =) (win-draw-end win, (byte \~), (byte \space), row, (:w_height win), HLF_AT))
        ))

        ;; Reset the type of redrawing required, the window has been updated.
        ((ร win =) (assoc win :w_redr_type 0))

        ;; There is a trick with "w_botline".  If we invalidate it on each change that might modify it,
        ;; this will cause a lot of expensive calls to plines() in update-topline() each time.
        ;; Therefore the value of "w_botline" is often approximated, and this value is used to compute
        ;; the value of "w_topline".  If the value of "w_botline" was wrong, check that the value of
        ;; "w_topline" is correct (cursor is on the visible part of the text).  If it's not, we need to
        ;; redraw again.  Mostly this just means scrolling up a few lines, so it doesn't look too bad.
        ;; Only do this for the current window (where changes are relevant).

        ((ร win =) (update win :w_valid | VALID_BOTLINE))
        (when (and (== win @curwin) (!= (:w_botline win) o'botline) (not @_2_recursive))
            (reset! _2_recursive true)
            (swap! curwin update :w_valid & (bit-not VALID_TOPLINE))
            (swap! curwin update-topline)   ;; may invalidate "w_botline" again
            (when (non-zero? @must_redraw)
                ;; Don't update for changes in buffer again.
                ((ร boolean b =) (:b_mod_set @curbuf))
                (swap! curbuf assoc :b_mod_set false)
                (swap! curwin win-update)
                (reset! must_redraw 0)
                (swap! curbuf assoc :b_mod_set b)
            )
            (reset! _2_recursive false)
        )

        ;; restore got_int, unless CTRL-C was hit while redrawing
        (when (not @got_int)
            (reset! got_int o'got_int))
        win
    ))

;; Clear the rest of the window and mark the unused lines with "c1".
;; Use "c2" as the filler character.

(defn- #_window_C win-draw-end [#_window_C win, #_int c1, #_int c2, #_int row, #_int endrow, #_int hl]
    (let [r (:w_winrow win) c (:w_wincol win) w (:w_width win)]
        (let [#_int n
            (if (and (non-zero? @cmdwin_type) (== win @curwin)) ;; draw the cmdline character in the leftmost column
                (let [n (min 1 w)] (screen-fill (+ r row), (+ r endrow), c, (+ c n), @cmdwin_type, (byte \space), (hl-attr HLF_AT)) n)
                0)]
            (screen-fill (+ r row), (+ r endrow), (+ c n), (+ c w), c1, c2, (hl-attr hl))
        )
        (set-empty-rows win, row)
    ))

;; Advance **color_cols and return true when there are columns to draw.

(defn- #_boolean advance-color-col [#_int vcol, #_int* color_cols, #_int' a'cci]
    (while (< -1 (... color_cols @a'cci) vcol)
        (swap! a'cci inc))
    (< -1 (... color_cols @a'cci)))

;; used for p_extra when displaying lcs_eol at end-of-line
(final Bytes at_end_str (u8 ""))

;; draw_state: items that are drawn in sequence:
(final int
    WL_START   0,   ;; nothing done yet
    WL_CMDLINE 1,   ;; cmdline window column
    WL_NR      2,   ;; line number
    WL_BRI     3,   ;; 'breakindent'
    WL_SBR     4,   ;; 'showbreak' or 'diff'
    WL_LINE    5)   ;; text in the line

;; Display line "lnum" of window 'win' on the screen.
;; Start at row "startrow", stop when "endrow" is reached.
;; win.w_virtcol needs to be valid.
;;
;; Return the number of last row the line occupies.

(defn- #_int win-line [#_window_C win, #_long lnum, #_int startrow, #_int endrow, #_boolean _nochange]
    ;; nochange: not updating for changed text
    (ยง
        ((ร int c =) 0)
        ((ร int vcol =) 0)                          ;; virtual column (for tabs)
        ((ร int vcol_sbr =) -1)                     ;; virtual column after showbreak
        ((ร int vcol_prev =) -1)                    ;; "vcol" of previous character

        ((ร Bytes extra =) (Bytes. 18))            ;; "%ld" and 'fdc' must fit in here
        ((ร int n_extra =) 0)                        ;; number of extra chars
        ((ร Bytes p_extra =) nil)                  ;; string of extra chars, plus NUL
        ((ร int c_extra =) NUL)                      ;; extra chars, all the same
        ((ร int extra_attr =) 0)                     ;; attributes when n_extra != 0

        ((ร int lcs_eol_one =) @lcs_eol)              ;; lcs_eol until it's been used

        ((ร int saved_n_extra =) 0)  ;; saved "extra" items for when draw_state becomes WL_LINE (again)
        ((ร Bytes saved_p_extra =) nil)
        ((ร int saved_c_extra =) 0)
        ((ร int saved_char_attr =) 0)

        ((ร int n_attr =) 0)                         ;; chars with special attr
        ((ร int saved_attr2 =) 0)                    ;; char_attr saved for n_attr
        ((ร int n_attr3 =) 0)                        ;; chars with overruling special attr
        ((ร int saved_attr3 =) 0)                    ;; char_attr saved for n_attr3

        ((ร int n_skip =) 0)                         ;; nr of chars to skip for 'nowrap'

        ((ร int fromcol_prev =) -2)                  ;; start of inverting after cursor
        ((ร boolean noinvcur =) false)               ;; don't invert the cursor
        (ร pos_C top, bot)
        ((ร boolean lnum_in_visual_area =) false)

        ((ร int char_attr =) 0)                      ;; attributes for next character
        ((ร boolean attr_pri =) false)               ;; char_attr has priority
        ((ร boolean area_highlighting =) false)      ;; Visual or incsearch highlighting in this line
        ((ร int attr =) 0)                           ;; attributes for area highlighting
        ((ร int area_attr =) 0)                      ;; attributes desired by highlighting
        ((ร int search_attr =) 0)                    ;; attributes desired by 'hlsearch'
        ((ร int vcol_save_attr =) 0)                 ;; saved attr for 'cursorcolumn'
        ((ร int syntax_attr =) 0)                    ;; attributes desired by syntax
        ((ร int eol_hl_off =) 0)                     ;; 1 if highlighted char after EOL
        ((ร int multi_attr =) 0)                     ;; attributes desired by multibyte
        ((ร int mb_l =) 1)                           ;; multi-byte byte length
        ((ร int mb_c =) 0)                           ;; decoded multi-byte character
        ((ร boolean mb_utf8 =) false)                ;; screen char is UTF-8 char
        ((ร int[] u8cc =) (ร new int[MAX_MCO]))          ;; composing UTF-8 chars
        ((ร int trailcol =) MAXCOL)                  ;; start of trailing spaces
        ((ร boolean need_showbreak =) false)

        ((ร int line_attr =) 0)                      ;; attribute for the whole line
        ((ร int did_line_attr =) 0)

        ((ร int draw_state =) WL_START)              ;; what to draw next

        ((ร int syntax_flags =) 0)
        ((ร int[] a'syntax_seqnr =) (atom (int 0)))
        ((ร int prev_syntax_id =) 0)
        ((ร int conceal_attr =) (hl-attr HLF_CONCEAL))
        ((ร boolean is_concealing =) false)
        ((ร int boguscols =) 0)                      ;; nonexistent columns added to force wrapping
        ((ร int vcol_off =) 0)                       ;; offset for concealed characters
        ((ร boolean did_wcol =) false)
        ((ร int old_boguscols =) 0)

        (if (< endrow startrow)                  ;; past the end already!
            ((ร RETURN) startrow)
        )

        ((ร int row =) startrow)                     ;; row in the window, excl. "w_winrow"
        ((ร int screen_row =) (+ row (:w_winrow win)))     ;; row on the screen, incl. "w_winrow"

        ;; To speed up the loop below, set extra_check when there is linebreak,
        ;; trailing white space and/or syntax processing to be done.

        ((ร boolean extra_check =) @(:wo_lbr (:w_options win)))  ;; has syntax or linebreak

        ;; Check for columns to display for 'colorcolumn'.
        ((ร int[] color_cols =) (:w_p_cc_cols win))         ;; pointer to according columns array
        ((ร int[] a'cci =) (atom (int 0)))
        ((ร boolean draw_color_col =) false)                         ;; highlight colorcolumn
        ((ร draw_color_col =) (if (some? color_cols) (advance-color-col (- vcol vcol_off), color_cols, a'cci) draw_color_col))

        ;; handle visual active in this window

        ((ร int[] a'fromcol =) (atom (int -10)))            ;; start/end of inverting
        ((ร int[] a'tocol =) (atom (int MAXCOL)))
        (cond @VIsual_active
        (do
            (cond (ltoreq (:w_cursor @curwin), @VIsual_cursor)                ;; Visual is after curwin.w_cursor
            (do
                ((ร top =) (:w_cursor @curwin))
                ((ร bot =) @VIsual_cursor)
            )
            :else                                                ;; Visual is before curwin.w_cursor
            (do
                ((ร top =) @VIsual_cursor)
                ((ร bot =) (:w_cursor @curwin))
            ))

            ((ร lnum_in_visual_area =) (and (<= (:lnum top) lnum) (<= lnum (:lnum bot))))

            (cond (== @VIsual_mode Ctrl_V)                          ;; block mode
            (do
                (when lnum_in_visual_area
                    (reset! a'fromcol (:w_old_cursor_fcol win))
                    (reset! a'tocol (:w_old_cursor_lcol win))
                )
            )
            :else                                        ;; non-block mode
            (do
                (cond (and (< (:lnum top) lnum) (<= lnum (:lnum bot)))
                (do
                    (reset! a'fromcol 0)
                )
                (== lnum (:lnum top))
                (do
                    (cond (== @VIsual_mode (byte \V))             ;; linewise
                    (do
                        (reset! a'fromcol 0)
                    )
                    :else
                    (do
                        (getvvcol win, top, a'fromcol, nil, nil)
                        (when (== (gchar-pos top) NUL)
                            (reset! a'tocol (+ @a'fromcol 1)))
                    ))
                ))
                (when (and (!= @VIsual_mode (byte \V)) (== lnum (:lnum bot)))
                    (cond (and (at? @p_sel (byte \e)) (zero? (:col bot)) (zero? (:coladd bot)))
                    (do
                        (reset! a'fromcol -10)
                        (reset! a'tocol MAXCOL)
                    )
                    (== (:col bot) MAXCOL)
                    (do
                        (reset! a'tocol MAXCOL)
                    )
                    :else
                    (do
                        ((ร pos_C pos =) (NEW_pos_C))
                        (COPY-pos pos, bot)
                        (cond (at? @p_sel (byte \e))
                        (do
                            (getvvcol win, pos, a'tocol, nil, nil)
                        )
                        :else
                        (do
                            (getvvcol win, pos, nil, nil, a'tocol)
                            (swap! a'tocol inc)
                        ))
                    ))
                )
            ))

            ;; Check if the character under the cursor should not be inverted.
            ((ร noinvcur =) (or (and (not @highlight_match) (== lnum (:lnum (:w_cursor @curwin))) (== win @curwin)) noinvcur))

            ;; if inverting in this line set area_highlighting
            (when (<= 0 @a'fromcol)
                ((ร area_highlighting =) true)
                ((ร attr =) (hl-attr HLF_V))
            )
        )

        ;; handle 'incsearch' and ":s///c" highlighting

        (and @highlight_match (== win @curwin) (<= (:lnum (:w_cursor @curwin)) lnum) (<= lnum (+ (:lnum (:w_cursor @curwin)) @search_match_lines)))
        (do
            (if (== lnum (:lnum (:w_cursor @curwin)))
                (getvcol @curwin, (:w_cursor @curwin), a'fromcol, nil, nil)
                (reset! a'fromcol 0)
            )
            (cond (== lnum (+ (:lnum (:w_cursor @curwin)) @search_match_lines))
            (do
                ((ร pos_C pos =) (NEW_pos_C))
                ((ร pos =) (assoc pos :lnum lnum))
                ((ร pos =) (assoc pos :col @search_match_endcol))

                (getvcol @curwin, pos, a'tocol, nil, nil)
            )
            :else
            (do
                (reset! a'tocol MAXCOL)
            ))
            ;; do at least one character; happens when past end of line
            (when (== @a'fromcol @a'tocol)
                (reset! a'tocol (+ @a'fromcol 1)))
            ((ร area_highlighting =) true)
            ((ร attr =) (hl-attr HLF_I))
        ))

        ((ร area_highlighting =) (or (non-zero? line_attr) area_highlighting))

        ((ร Bytes line =) (ml-get lnum)) ;; current line
        ((ร Bytes ptr =) line)                                  ;; current position in "line"

        ;; 'nowrap' or 'wrap' and a single line that doesn't fit:
        ;; advance to the first character to be displayed.

        ((ร int v =) (if @(:wo_wrap (:w_options win)) (:w_skipcol win) (:w_leftcol win)))
        (when (< 0 v)
            ((ร Bytes prev_ptr =) ptr)
            (loop-when [] (and (< vcol v) (non-eos? ptr))
                ((ร c =) (win-lbr-chartabsize win, line, ptr, vcol, nil))
                ((ร vcol =) (+ vcol c))
                ((ร prev_ptr =) ptr)
                ((ร ptr =) (.plus ptr (us-ptr2len-cc ptr)))
                (recur)
            )

            ;; When:
            ;; - 'cuc' is set, or
            ;; - 'colorcolumn' is set, or
            ;; - 'virtualedit' is set, or
            ;; - the visual mode is active,
            ;; the end of the line may be before the start of the displayed part.

            ((ร vcol =) (if (and (< vcol v) (or @(:wo_cuc (:w_options win)) draw_color_col (virtual-active) @VIsual_active)) v vcol))

            ;; Handle a character that's not completely on the screen:
            ;; put 'ptr' at that character, but skip the first few screen characters.
            (when (< v vcol)
                ((ร vcol =) (- vcol c))
                ((ร ptr =) prev_ptr)
                ((ร n_skip =) (- v vcol))
            )

            ;; Adjust for when the inverted text is before the screen,
            ;; and when the start of the inverted text is before the screen.

            (cond (<= @a'tocol vcol)
            (do
                (reset! a'fromcol 0)
            )
            (and (<= 0 @a'fromcol) (< @a'fromcol vcol))
            (do
                (reset! a'fromcol vcol)
            ))

            ;; When "w_skipcol" is non-zero, first line needs 'showbreak'.
            ((ร need_showbreak =) (or @(:wo_wrap (:w_options win)) need_showbreak))
        )

        ;; Correct highlighting for cursor that can't be disabled.
        ;; Avoids having to check this for each character.

        (when (<= 0 @a'fromcol)
            (when noinvcur
                (cond (== @a'fromcol (:w_virtcol win))
                (do
                    ;; highlighting starts at cursor, let it start just after the cursor
                    ((ร fromcol_prev =) @a'fromcol)
                    (reset! a'fromcol -1)
                )
                (< @a'fromcol (:w_virtcol win))
                (do
                    ;; restart highlighting after the cursor
                    ((ร fromcol_prev =) (:w_virtcol win))
                ))
            )
            (when (<= @a'tocol @a'fromcol)
                (reset! a'fromcol -1))
        )

        ;; Handle highlighting the last used search pattern and matches.
        ;; Do this for both search_hl and the match list.

        ((ร matchitem_C mi =) (:w_match_head win))   ;; points to the match list
        ((ร boolean shl_flag =) false)           ;; whether search_hl has been processed
        (loop-when [] (or (some? mi) (not shl_flag))
            (ร match_C shl)                    ;; points to search_hl or a match
            (cond (not shl_flag)
            (do
                ((ร shl =) @search_hl)
                ((ร shl_flag =) true)
            )
            :else
            (do
                ((ร shl =) (:mi_hl mi))
            ))
            ((ร shl =) (assoc shl :startcol MAXCOL))
            ((ร shl =) (assoc shl :endcol MAXCOL))
            ((ร shl =) (assoc shl :attr_cur 0))
            ((ร v =) (BDIFF ptr, line))
            (if (some? mi)
                ((ร mi =) (assoc-in mi [:mi_pos :cur] 0))
            )
            (next-search-hl shl, lnum, v, mi)

            ;; Need to get the line again, a multi-line regexp may have made it invalid.
            ((ร line =) (ml-get lnum))
            ((ร ptr =) (.plus line v))

            (when (and (non-zero? (:lnum shl)) (<= (:lnum shl) lnum))
                ((ร shl =) (assoc shl :startcol (if (== (:lnum shl) lnum) (:col (... (:startpos (:rmm shl)) 0)) 0)))
                ((ร shl =) (assoc shl :endcol (if (== lnum (- (+ (:lnum shl) (:lnum (... (:endpos (:rmm shl)) 0))) (:lnum (... (:startpos (:rmm shl)) 0)))) (:col (... (:endpos (:rmm shl)) 0)) MAXCOL)))
                ;; Highlight one character for an empty match.
                (when (== (:startcol shl) (:endcol shl))
                    (if (non-eos? line (:endcol shl))
                        ((ร shl =) (update shl :endcol #(+ % (us-ptr2len-cc line, %))))
                        ((ร shl =) (update shl :endcol inc))
                    )
                )
                (when (< (long (:startcol shl)) v) ;; match at leftcol
                    ((ร shl =) (assoc shl :attr_cur (:attr shl)))
                    ((ร search_attr =) (:attr shl))
                )
                ((ร area_highlighting =) true)
            )
            ((ร mi =) (if (and (!= shl @search_hl) (some? mi)) (:next mi) mi))
            (recur)
        )

        ;; Cursor line highlighting for 'cursorline' in the current window.
        ;; Not when Visual mode is active, because it's not clear what is selected then.
        (when (and @(:wo_cul (:w_options win)) (== lnum (:lnum (:w_cursor win))) (not (and (== win @curwin) @VIsual_active)))
            ((ร line_attr =) (hl-attr HLF_CUL))
            ((ร area_highlighting =) true)
        )

        ((ร int col =) 0)                                        ;; visual column on screen
        ((ร int off =) (BDIFF @current_ScreenLine, @screenLines))  ;; offset in screenLines/screenAttrs

        ;; Repeat for the whole displayed line.

        (loop []
            ;; Skip this quickly when working on the text.
            (when (!= draw_state WL_LINE)
                (when (and (== draw_state (dec WL_CMDLINE)) (zero? n_extra))
                    ((ร draw_state =) WL_CMDLINE)
                    (when (and (non-zero? @cmdwin_type) (== win @curwin))
                        ;; Draw the cmdline character.
                        ((ร n_extra =) 1)
                        ((ร c_extra =) @cmdwin_type)
                        ((ร char_attr =) (hl-attr HLF_AT))
                    )
                )

                (when (and (== draw_state (dec WL_NR)) (zero? n_extra))
                    ((ร draw_state =) WL_NR)
                    ;; Display the absolute or relative line number.
                    ;; After the first fill with blanks when the 'n' flag isn't in 'cpo'.
                    (when (and (or @(:wo_nu (:w_options win)) @(:wo_rnu (:w_options win))) (or (== row startrow) (nil? (vim-strbyte @p_cpo, CPO_NUMCOL))))
                        ;; Draw the line number (empty space after wrapping).
                        (cond (== row startrow)
                        (do
                            (ร long num)
                            ((ร Bytes fmt =) (u8 "%*ld "))

                            (cond (and @(:wo_nu (:w_options win)) (not @(:wo_rnu (:w_options win))))
                            (do
                                ;; 'number' + 'norelativenumber'
                                ((ร num =) lnum)
                            )
                            :else
                            (do
                                ;; 'relativenumber', don't use negative numbers
                                ((ร num =) (Math/abs (get-cursor-rel-lnum win, lnum)))
                                (when (and (zero? num) @(:wo_nu (:w_options win)) @(:wo_rnu (:w_options win)))
                                    ;; 'number' + 'relativenumber'
                                    ((ร num =) lnum)
                                    ((ร fmt =) (u8 "%-*ld "))
                                )
                            ))

                            (.sprintf libC extra, fmt, (number-width win), num)
                            (when (< 0 (:w_skipcol win))
                                (loop-when-recur [p_extra extra] (at? p_extra (byte \space)) [(.plus p_extra 1)]
                                    (.be p_extra 0, (byte \-))
                                )
                            )
                            ((ร p_extra =) extra)
                            ((ร c_extra =) NUL)
                        )
                        :else
                        (do
                            ((ร c_extra =) (byte \space))
                        ))
                        ((ร n_extra =) (inc (number-width win)))
                        ((ร char_attr =) (hl-attr HLF_N))
                        ;; When 'cursorline' is set, highlight the line number of the current line differently.
                        ;; TODO: Can we use CursorLine instead of CursorLineNr when CursorLineNr isn't set?
                        ((ร char_attr =) (if (and (or @(:wo_cul (:w_options win)) @(:wo_rnu (:w_options win))) (== lnum (:lnum (:w_cursor win)))) (hl-attr HLF_CLN) char_attr))
                    )
                )

                (cond (and (:w_p_brisbr win) (== draw_state (dec WL_BRI)) (zero? n_extra) (non-eos? @p_sbr))
                (do
                    ;; draw indent after showbreak value
                    ((ร draw_state =) WL_BRI)
                )
                (and (:w_p_brisbr win) (== draw_state WL_SBR) (zero? n_extra))
                (do
                    ;; After the showbreak, draw the breakindent.
                    ((ร draw_state =) (dec WL_BRI))
                ))

                ;; draw 'breakindent': indent wrapped text accordingly
                (when (and (== draw_state (dec WL_BRI)) (zero? n_extra))
                    ((ร draw_state =) WL_BRI)
                    (when (and @(:wo_bri (:w_options win)) (zero? n_extra) (!= row startrow))
                        ((ร char_attr =) 0) ;; was: hl-attr(HLF_AT);
                        ((ร p_extra =) nil)
                        ((ร c_extra =) (byte \space))
                        ((ร n_extra =) (get-breakindent win, (ml-get lnum)))
                        ;; Correct end of highlighted area for 'breakindent',
                        ;; required when 'linebreak' is also set.
                        (when (== @a'tocol vcol)
                            (swap! a'tocol + n_extra))
                    )
                )

                (when (and (== draw_state (dec WL_SBR)) (zero? n_extra))
                    ((ร draw_state =) WL_SBR)
                    (when (and (non-eos? @p_sbr) need_showbreak)
                        ;; Draw 'showbreak' at the start of each broken line.
                        ((ร p_extra =) @p_sbr)
                        ((ร c_extra =) NUL)
                        ((ร n_extra =) (STRLEN @p_sbr))
                        ((ร char_attr =) (hl-attr HLF_AT))
                        ((ร need_showbreak =) false)
                        ((ร vcol_sbr =) (+ vcol (us-charlen @p_sbr)))
                        ;; Correct end of highlighted area for 'showbreak',
                        ;; required when 'linebreak' is also set.
                        (when (== @a'tocol vcol)
                            (swap! a'tocol + n_extra))
                        ;; combine 'showbreak' with 'cursorline'
                        ((ร char_attr =) (if (and @(:wo_cul (:w_options win)) (== lnum (:lnum (:w_cursor win)))) (hl-combine-attr char_attr, (hl-attr HLF_CUL)) char_attr))
                    )
                )

                (when (and (== draw_state (dec WL_LINE)) (zero? n_extra))
                    ((ร draw_state =) WL_LINE)
                    (cond (non-zero? saved_n_extra)
                    (do
                        ;; Continue item from end of wrapped line.
                        ((ร n_extra =) saved_n_extra)
                        ((ร c_extra =) saved_c_extra)
                        ((ร p_extra =) saved_p_extra)
                        ((ร char_attr =) saved_char_attr)
                    )
                    :else
                    (do
                        ((ร char_attr =) 0)
                    ))
                )
            )

            (when (and (== draw_state WL_LINE) area_highlighting)
                ;; handle Visual or match highlighting in this line
                                                            ;; not at margin
                (cond (or (== vcol @a'fromcol) (and (== (inc vcol) @a'fromcol) (== n_extra 0) (< 1 (us-ptr2cells ptr))) (and (== vcol_prev fromcol_prev) (< vcol_prev vcol) (< vcol @a'tocol)))
                (do
                    ((ร area_attr =) attr)                       ;; start highlighting
                )
                (and (!= area_attr 0) (or (== vcol @a'tocol) (and noinvcur (== vcol (:w_virtcol win)))))
                (do
                    ((ร area_attr =) 0)                          ;; stop highlighting
                ))

                (when (zero? n_extra)
                    ;; Check for start/end of search pattern match.
                    ;; After end, check for start/end of next match.
                    ;; When another match, have to check for start again.
                    ;; Watch out for matching an empty string!
                    ;; Do this for 'search_hl' and the match list (ordered by priority).

                    ((ร v =) (BDIFF ptr, line))
                    ((ร mi =) (:w_match_head win))
                    ((ร shl_flag =) false)
                    (loop-when [] (or (some? mi) (not shl_flag))
                        (ร match_C shl)        ;; points to search_hl or a match
                        (cond (and (not shl_flag) (or (and (some? mi) (< SEARCH_HL_PRIORITY (:priority mi))) (nil? mi)))
                        (do
                            ((ร shl =) @search_hl)
                            ((ร shl_flag =) true)
                        )
                        :else
                        (do
                            ((ร shl =) (:mi_hl mi))
                        ))
                        (if (some? mi)
                            ((ร mi =) (assoc-in mi [:mi_pos :cur] 0))
                        )
                        ;; marks that position match search is in progress
                        ((ร boolean pos_inprogress =) true)
                        (loop-when [] (or (some? (:regprog (:rmm shl))) (and (some? mi) pos_inprogress))
                            (cond (and (!= (:startcol shl) MAXCOL) (<= (:startcol shl) v) (< v (:endcol shl)))
                            (do
                                ((ร shl =) (update shl :endcol max (+ v (us-ptr2len-cc ptr))))
                                ((ร shl =) (assoc shl :attr_cur (:attr shl)))
                            )
                            (== v (:endcol shl))
                            (do
                                ((ร shl =) (assoc shl :attr_cur 0))
                                (next-search-hl shl, lnum, v, mi)
                                ((ร pos_inprogress =) (and (some? mi) (!= (:cur (:mi_pos mi)) 0)))

                                ;; Need to get the line again, a multi-line regexp may have made it invalid.
                                ((ร line =) (ml-get lnum))
                                ((ร ptr =) (.plus line v))

                                (when (== (:lnum shl) lnum)
                                    ((ร shl =) (assoc shl :startcol (:col (... (:startpos (:rmm shl)) 0))))
                                    ((ร shl =) (assoc shl :endcol (if (zero? (:lnum (... (:endpos (:rmm shl)) 0))) (:col (... (:endpos (:rmm shl)) 0)) MAXCOL)))

                                    (when (== (:startcol shl) (:endcol shl))
                                        ;; highlight empty match, try again after it
                                        ((ร shl =) (update shl :endcol #(+ % (us-ptr2len-cc line, %))))
                                    )

                                    ;; Loop to check if the match starts at the current position.
                                    (ร CONTINUE)
                                )
                            ))
                            (ร BREAK)
                            (recur)
                        )
                        ((ร mi =) (if (and (!= shl @search_hl) (some? mi)) (:next mi) mi))
                        (recur)
                    )

                    ;; Use attributes from match with highest priority
                    ;; among 'search_hl' and the match list.
                    ((ร search_attr =) (:attr_cur @search_hl))
                    ((ร mi =) (:w_match_head win))
                    ((ร shl_flag =) false)
                    (loop-when [] (or (some? mi) (not shl_flag))
                        (ร match_C shl)        ;; points to search_hl or a match
                        (cond (and (not shl_flag) (or (and (some? mi) (< SEARCH_HL_PRIORITY (:priority mi))) (nil? mi)))
                        (do
                            ((ร shl =) @search_hl)
                            ((ร shl_flag =) true)
                        )
                        :else
                        (do
                            ((ร shl =) (:mi_hl mi))
                        ))
                        ((ร search_attr =) (if (non-zero? (:attr_cur shl)) (:attr_cur shl) search_attr))
                        ((ร mi =) (if (and (!= shl @search_hl) (some? mi)) (:next mi) mi))
                        (recur)
                    )
                )

                ;; Decide which of the highlight attributes to use.
                ((ร attr_pri =) true)

                (cond (non-zero? area_attr)
                (do
                    ((ร char_attr =) (hl-combine-attr line_attr, area_attr))
                )
                (non-zero? search_attr)
                (do
                    ((ร char_attr =) (hl-combine-attr line_attr, search_attr))
                )
                ;; Use line_attr when not in the Visual or 'incsearch' area
                ;; (area_attr may be 0 when "noinvcur" is set).
                (and (non-zero? line_attr) (or (and (== @a'fromcol -10) (== @a'tocol MAXCOL)) (< vcol @a'fromcol) (< vcol_prev fromcol_prev) (<= @a'tocol vcol)))
                (do
                    ((ร char_attr =) line_attr)
                )
                :else
                (do
                    ((ร attr_pri =) false)
                    ((ร char_attr =) 0)
                ))
            )

            ;; Get the next character to put on the screen.

            ;; The "p_extra" points to the extra stuff that is inserted to represent
            ;; special characters (non-printable stuff) and other things.
            ;; When all characters are the same, c_extra is used.
            ;; "p_extra" must end in a NUL to avoid us-ptr2len-cc() reads past "p_extra[n_extra]".
            ;; For the '$' of the 'list' option, n_extra == 1, p_extra == "".

            (cond (< 0 n_extra)
            (do
                (cond (!= c_extra NUL)
                (do
                    ((ร c =) c_extra)
                    ((ร mb_c =) c)       ;; doesn't handle non-utf-8 multi-byte!
                    (cond (< 1 (utf-char2len c))
                    (do
                        ((ร mb_utf8 =) true)
                        ((ร u8cc[0] =) 0)
                        ((ร c =) 0xc0)
                    )
                    :else
                    (do
                        ((ร mb_utf8 =) false)
                    ))
                )
                :else
                (do
                    ((ร c =) (.at p_extra 0))

                    ((ร mb_c =) c)

                    ;; If the UTF-8 character is more than one byte, decode it into "mb_c".
                    ((ร mb_l =) (us-ptr2len-cc p_extra))
                    ((ร mb_utf8 =) false)
                    (cond (< n_extra mb_l)
                    (do
                        ((ร mb_l =) 1)
                    )
                    (< 1 mb_l)
                    (do
                        ((ร mb_c =) (us-ptr2char-cc p_extra, u8cc))
                        ((ร mb_utf8 =) true)
                        ((ร c =) 0xc0)
                    ))

                    ((ร mb_l =) (if (zero? mb_l) 1 mb_l))  ;; at the NUL at end-of-line

                    ;; If a double-width char doesn't fit display a '>' in the last column.
                    (cond (and (<= (dec (:w_width win)) col) (== (utf-char2cells mb_c) 2))
                    (do
                        ((ร c =) (byte \>))
                        ((ร mb_c =) c)
                        ((ร mb_l =) 1)
                        ((ร mb_utf8 =) false)
                        ((ร multi_attr =) (hl-attr HLF_AT))
                        ;; put the pointer back to output the double-width
                        ;; character at the start of the next line
                        ((ร n_extra =) (inc n_extra))
                        ((ร p_extra =) (.minus p_extra 1))
                    )
                    :else
                    (do
                        ((ร n_extra =) (- n_extra (dec mb_l)))
                        ((ร p_extra =) (.plus p_extra (dec mb_l)))
                    ))

                    ((ร p_extra =) (.plus p_extra 1))
                ))
                ((ร n_extra =) (dec n_extra))
            )
            :else
            (do
                ;; Get a character from the line itself.

                ((ร c =) (.at ptr 0))

                ((ร mb_c =) c)

                ;; If the UTF-8 character is more than one byte, decode it into "mb_c".
                ((ร mb_l =) (us-ptr2len-cc ptr))
                ((ร mb_utf8 =) false)
                (when (< 1 mb_l)
                    ((ร mb_c =) (us-ptr2char-cc ptr, u8cc))
                    ;; Overlong encoded ASCII or ASCII with composing char
                    ;; is displayed normally, except a NUL.
                    ((ร c =) (if (< mb_c 0x80) mb_c c))
                    ((ร mb_utf8 =) true)

                    ;; At start of the line we can have a composing char.
                    ;; Draw it as a space with a composing char.
                    (when (utf-iscomposing mb_c)
                        (loop-when-recur [#_int i (dec @screen_mco)] (< 0 i) [(dec i)]
                            ((ร u8cc[i] =) (... u8cc (dec i)))
                        )
                        ((ร u8cc[0] =) mb_c)
                        ((ร mb_c =) (byte \space))
                    )
                )

                (cond (or (and (== mb_l 1) (<= 0x80 c)) (and (<= 1 mb_l) (zero? mb_c)) (and (< 1 mb_l) (not (vim-isprintc mb_c))))
                (do
                    ;; Illegal UTF-8 byte: display as <xx>.
                    ;; Non-BMP character : display as ? or fullwidth ?.

                    (transchar-hex extra, mb_c)

                    ((ร p_extra =) extra)
                    ((ร c =) (.at p_extra 0))
                    (let [__ (atom (#_Bytes object p_extra))]
                        ((ร mb_c =) (us-ptr2char-adv __, true))
                        ((ร p_extra =) @__))
                    ((ร mb_utf8 =) (<= 0x80 c))
                    ((ร n_extra =) (STRLEN p_extra))
                    ((ร c_extra =) NUL)
                    (when (and (zero? area_attr) (zero? search_attr))
                        ((ร n_attr =) (inc n_extra))
                        ((ร extra_attr =) (hl-attr HLF_8))
                        ((ร saved_attr2 =) char_attr)    ;; save current attr
                    )
                )
                (zero? mb_l)                 ;; at the NUL at end-of-line
                (do
                    ((ร mb_l =) 1)
                ))

                ;; If a double-width char doesn't fit, display a '>' in the last column;
                ;; the character is displayed at the start of the next line.
                (cond (and (<= (dec (:w_width win)) col) (== (utf-char2cells mb_c) 2))
                (do
                    ((ร c =) (byte \>))
                    ((ร mb_c =) c)
                    ((ร mb_utf8 =) false)
                    ((ร mb_l =) 1)
                    ((ร multi_attr =) (hl-attr HLF_AT))
                    ;; Put pointer back so that the character will be
                    ;; displayed at the start of the next line.
                    ((ร ptr =) (.minus ptr 1))
                )
                (non-eos? ptr)
                (do
                    ((ร ptr =) (.plus ptr (dec mb_l)))
                ))

                ;; If a double-width char doesn't fit at the left side, display a '<'
                ;; in the first column.  Don't do this for unprintable characters.
                (when (and (< 0 n_skip) (< 1 mb_l) (zero? n_extra))
                    ((ร n_extra =) 1)
                    ((ร c_extra =) MB_FILLER_CHAR)
                    ((ร c =) (byte \space))
                    (when (and (zero? area_attr) (zero? search_attr))
                        ((ร n_attr =) (inc n_extra))
                        ((ร extra_attr =) (hl-attr HLF_AT))
                        ((ร saved_attr2 =) char_attr)    ;; save current attr
                    )
                    ((ร mb_c =) c)
                    ((ร mb_utf8 =) false)
                    ((ร mb_l =) 1)
                )

                ((ร ptr =) (.plus ptr 1))

                (when extra_check
                    ;; Get syntax attribute, unless still at the start of the line
                    ;; (double-wide char that doesn't fit).
                    ((ร v =) (BDIFF ptr, line))

                    ;; Found last space before word: check for line break.

                    (when (and @(:wo_lbr (:w_options win)) (... @breakat_flags (char_u (byte c))) (not (... @breakat_flags (char_u (.at ptr 0)))))
                        ((ร int mb_off =) (us-head-off line, (.minus ptr 1)))
                        ((ร Bytes p =) (.minus ptr (inc mb_off)))

                        ;; TODO: is passing 'p' for start of the line OK?
                        ((ร n_extra =) (dec (win-lbr-chartabsize win, line, p, vcol, nil)))
                        ((ร n_extra =) (if (and (== c TAB) (< (:w_width win) (+ n_extra col))) (- (int @(:b_p_ts @curbuf)) (% vcol (int @(:b_p_ts @curbuf))) 1) n_extra))

                        ((ร c_extra =) (if (< 0 mb_off) MB_FILLER_CHAR (byte \space)))
                        (when (vim-iswhite c)
                            (when (== c TAB)       ;; See "Tab alignment" below.
                                ((ร n_extra =) (+ n_extra vcol_off))
                                ((ร vcol =) (- vcol vcol_off))
                                ((ร vcol_off =) 0)
                                ((ร col =) (- col boguscols))
                                ((ร old_boguscols =) boguscols)
                                ((ร boguscols =) 0)
                            )
                            ((ร c =) (byte \space))
                        )
                    )

                    (when (and (!= trailcol MAXCOL) (BLT (.plus line trailcol), ptr) (== c (byte \space)))
                        ((ร c =) @lcs_trail)
                        (when (not attr_pri)
                            ((ร n_attr =) 1)
                            ((ร extra_attr =) (hl-attr HLF_8))
                            ((ร saved_attr2 =) char_attr)    ;; save current attr
                        )
                        ((ร mb_c =) c)
                        (cond (< 1 (utf-char2len c))
                        (do
                            ((ร mb_utf8 =) true)
                            ((ร u8cc[0] =) 0)
                            ((ร c =) 0xc0)
                        )
                        :else
                        (do
                            ((ร mb_utf8 =) false)
                        ))
                    )
                )

                ;; Handling of non-printable characters.

                (when (zero? (& (... @chartab (& c 0xff)) CT_PRINT_CHAR))
                    ;; When getting a character from the file, we may have to turn it
                    ;; into something else on the way to putting it into "screenLines".

                    (cond (== c TAB)
                    (do
                        ((ร int tab_len =) 0)
                        ((ร int vcol_adjusted =) vcol) ;; removed showbreak length
                        ;; Only adjust the "tab_len" when at the first column
                        ;; after the showbreak value was drawn.
                        ((ร vcol_adjusted =) (if (and (non-eos? @p_sbr) (== vcol vcol_sbr) @(:wo_wrap (:w_options win))) (- vcol (us-charlen @p_sbr)) vcol_adjusted))
                        ;; tab amount depends on current column
                        ((ร tab_len =) (- (int @(:b_p_ts @curbuf)) (% vcol_adjusted (int @(:b_p_ts @curbuf))) 1))

                        ;; tab amount depends on current column
                        ((ร n_extra =) tab_len)

                        ;; Tab alignment should be identical regardless of
                        ;; 'conceallevel' value.  So tab compensates of all
                        ;; previous concealed characters, and thus resets
                        ;; vcol_off and boguscols accumulated so far in the
                        ;; line.  Note that the tab can be longer than
                        ;; 'tabstop' when there are concealed characters.

                        ((ร n_extra =) (+ n_extra vcol_off))
                        ((ร vcol =) (- vcol vcol_off))
                        ((ร vcol_off =) 0)
                        ((ร col =) (- col boguscols))
                        ((ร old_boguscols =) boguscols)
                        ((ร boguscols =) 0)

                        ((ร mb_utf8 =) false)                    ;; don't draw as UTF-8

                        ((ร c_extra =) (byte \space))
                        ((ร c =) (byte \space))
                    )
                    (and (== c NUL) (and (or (<= 0 @a'fromcol) (<= 0 fromcol_prev)) (< vcol @a'tocol) (!= @VIsual_mode Ctrl_V) (< col (:w_width win)) (not (and noinvcur (== lnum (:lnum (:w_cursor win))) (== vcol (:w_virtcol win))))) (<= 0 lcs_eol_one))
                    (do
                        ;; Display a '$' after the line or highlight an extra character if the line break is included.

                        ;; For a diff line the highlighting continues after the "$".
                        (when (zero? line_attr)
                            ;; In virtualedit, visual selections may extend beyond end of line.
                            (cond (and area_highlighting (virtual-active) (!= @a'tocol MAXCOL) (< vcol @a'tocol))
                            (do
                                ((ร n_extra =) 0)
                            )
                            :else
                            (do
                                ((ร p_extra =) at_end_str)
                                ((ร n_extra =) 1)
                                ((ร c_extra =) NUL)
                            ))
                        )
                        ((ร c =) (byte \space))
                        ((ร lcs_eol_one =) -1)
                        ((ร ptr =) (.minus ptr 1))                 ;; put it back at the NUL
                        (when (not attr_pri)
                            ((ร extra_attr =) (hl-attr HLF_AT))
                            ((ร n_attr =) 1)
                        )
                        ((ร mb_c =) c)
                        (cond (< 1 (utf-char2len c))
                        (do
                            ((ร mb_utf8 =) true)
                            ((ร u8cc[0] =) 0)
                            ((ร c =) 0xc0)
                        )
                        :else
                        (do
                            ((ร mb_utf8 =) false)                ;; don't draw as UTF-8
                        ))
                    )
                    (!= c NUL)
                    (do
                        ((ร p_extra =) (transchar c))
                        ((ร n_extra =) (if (zero? n_extra) (dec (mb-byte2cells (byte c))) n_extra))
                        ((ร c_extra =) NUL)
                        (cond @(:wo_lbr (:w_options win))
                        (do
                            (ร Bytes p)

                            ((ร c =) (.at p_extra 0))
                            ((ร p =) (Bytes. (inc n_extra)))
                            (BFILL p, 0, (byte \space), n_extra)
                            (STRNCPY p, (.plus p_extra 1), (dec (STRLEN p_extra)))
                            (eos! p n_extra)
                            ((ร p_extra =) p)
                        )
                        :else
                        (do
                            ((ร n_extra =) (dec (mb-byte2cells (byte c))))
                            ((ร c =) (.at ((ร p_extra =) (.plus p_extra 1)) -1))
                        ))
                        (when (not attr_pri)
                            ((ร n_attr =) (inc n_extra))
                            ((ร extra_attr =) (hl-attr HLF_8))
                            ((ร saved_attr2 =) char_attr)        ;; save current attr
                        )
                        ((ร mb_utf8 =) false)                    ;; don't draw as UTF-8
                    )
                    (and @VIsual_active (any == @VIsual_mode Ctrl_V (byte \v)) (virtual-active) (!= @a'tocol MAXCOL) (< vcol @a'tocol) (< col (:w_width win)))
                    (do
                        ((ร c =) (byte \space))
                        ((ร ptr =) (.minus ptr 1))                             ;; put it back at the NUL
                    )
                    (and (!= line_attr 0) (< (- col boguscols) (:w_width win)))
                    (do
                        ;; Highlight until the right side of the window.
                        ((ร c =) (byte \space))
                        ((ร ptr =) (.minus ptr 1))                             ;; put it back at the NUL

                        ;; Remember we do the char for line highlighting.
                        ((ร did_line_attr =) (inc did_line_attr))

                        ;; don't do search HL for the rest of the line
                        ((ร char_attr =) (if (and (non-zero? line_attr) (== char_attr search_attr) (< 0 col)) line_attr char_attr))
                    ))
                )

                (cond (and (< 0 @(:wo_cole (:w_options win))) (or (!= win @curwin) (!= lnum (:lnum (:w_cursor win))) (conceal-cursor-line win)) (flag? syntax_flags HL_CONCEAL) (not (and lnum_in_visual_area (== (vim-strchr @(:wo_cocu (:w_options win)), (byte \v)) nil))))
                (do
                    ((ร char_attr =) conceal_attr)
                    (cond (and (!= prev_syntax_id @a'syntax_seqnr) (or (!= (syn-get-sub-char) NUL) (== @(:wo_cole (:w_options win)) 1)) (!= @(:wo_cole (:w_options win)) 3))
                    (do
                        ;; First time at this concealed item: display one character.
                        ((ร c =) (cond (!= (syn-get-sub-char) NUL) (syn-get-sub-char) (!= @lcs_conceal NUL) @lcs_conceal :else (byte \space)))

                        ((ร prev_syntax_id =) @a'syntax_seqnr)

                        ((ร vcol_off =) (if (< 0 n_extra) (+ vcol_off n_extra) vcol_off))
                        ((ร vcol =) (+ vcol n_extra))
                        (when (and @(:wo_wrap (:w_options win)) (< 0 n_extra))
                            ((ร boguscols =) (+ boguscols n_extra))
                            ((ร col =) (+ col n_extra))
                        )
                        ((ร n_extra =) 0)
                        ((ร n_attr =) 0)
                    )
                    (zero? n_skip)
                    (do
                        ((ร is_concealing =) true)
                        ((ร n_skip =) 1)
                    ))
                    ((ร mb_c =) c)
                    (cond (< 1 (utf-char2len c))
                    (do
                        ((ร mb_utf8 =) true)
                        ((ร u8cc[0] =) 0)
                        ((ร c =) 0xc0)
                    )
                    :else
                    (do
                        ((ร mb_utf8 =) false)    ;; don't draw as UTF-8
                    ))
                )
                :else
                (do
                    ((ร prev_syntax_id =) 0)
                    ((ร is_concealing =) false)
                ))
            ))

            ;; In the cursor line and we may be concealing characters:
            ;; correct the cursor column when we reach its position.
            (when (and (not did_wcol) (== draw_state WL_LINE) (== win @curwin) (== lnum (:lnum (:w_cursor win))) (conceal-cursor-line win) (<= (:w_virtcol win) (+ vcol n_skip)))
                ((ร win =) (assoc win :w_wrow row :w_wcol (- col boguscols)))
                ((ร did_wcol =) true)
            )

            ;; Don't override visual selection highlighting.
            ((ร char_attr =) (if (and (< 0 n_attr) (== draw_state WL_LINE) (not attr_pri)) extra_attr char_attr))

            ;; At end of the text line or just after the last character.

            (when (or (== c NUL) (== did_line_attr 1))
                ((ร long prevcol =) (- (BDIFF ptr, line) (if (== c NUL) 1 0)))

                ;; we're not really at that column when skipping some text
                ((ร prevcol =) (if (< prevcol (long (if @(:wo_wrap (:w_options win)) (:w_skipcol win) (:w_leftcol win)))) (inc prevcol) prevcol))

                ;; Invert at least one char, used for Visual and empty line or highlight
                ;; match at end of line.  If it's beyond the last char on the screen,
                ;; just overwrite that one (tricky!)
                ;; Not needed when a '$' was displayed for 'list'.

                ((ร boolean prevcol_hl_flag =) false)                ;; whether prevcol equals startcol of
                                                                ;; search_hl or one of the matches
                (cond (== prevcol (long (:startcol @search_hl)))
                (do
                    ((ร prevcol_hl_flag =) true)
                )
                :else
                (do
                    ((ร FOR) (ร ((ร mi =) (:w_match_head win)) (some? mi) ((ร mi =) (:next mi)))
                        (when (== prevcol (long (:startcol (:mi_hl mi))))
                            ((ร prevcol_hl_flag =) true)
                            (ร BREAK)
                        )
                    )
                ))
                                ;; highlight 'hlsearch' match at end of line
                (when (and (== @lcs_eol lcs_eol_one) (or (and (!= area_attr 0) (== vcol @a'fromcol) (or (!= @VIsual_mode Ctrl_V) (== lnum (:lnum @VIsual_cursor)) (== lnum (:lnum (:w_cursor @curwin)))) (== c NUL)) (and prevcol_hl_flag (<= did_line_attr 1))))

                    ((ร int n =) (if (<= (:w_width win) col) -1 0))

                    (cond (non-zero? n)
                    (do
                        ;; At the window boundary, highlight the last character
                        ;; instead (better than nothing).
                        ((ร off =) (+ off n))
                        ((ร col =) (+ col n))
                    )
                    :else
                    (do
                        ;; Add a blank character to highlight.
                        (.be @screenLines off, (byte \space))
                        ((ร @screenLinesUC[off] =) 0)
                    ))
                    (when (zero? area_attr)
                        ;; Use attributes from match with highest priority
                        ;; among 'search_hl' and the match list.
                        ((ร char_attr =) (:attr @search_hl))
                        ((ร mi =) (:w_match_head win))
                        ((ร shl_flag =) false)
                        (loop-when [] (or (some? mi) (not shl_flag))
                            (ร match_C shl)        ;; points to search_hl or a match
                            (cond (and (not shl_flag) (or (and (some? mi) (< SEARCH_HL_PRIORITY (:priority mi))) (nil? mi)))
                            (do
                                ((ร shl =) @search_hl)
                                ((ร shl_flag =) true)
                            )
                            :else
                            (do
                                ((ร shl =) (:mi_hl mi))
                            ))
                            ((ร char_attr =) (if (== (dec (BDIFF ptr, line)) (:startcol shl)) (:attr shl) char_attr))
                            ((ร mi =) (if (and (!= shl @search_hl) (some? mi)) (:next mi) mi))
                            (recur)
                        )
                    )
                    ((ร @screenAttrs[off] =) char_attr)
                    ((ร col =) (inc col))
                    ((ร off =) (inc off))
                    ((ร vcol =) (inc vcol))
                    ((ร eol_hl_off =) 1)
                )
            )

            ;; At end of the text line.

            (when (== c NUL)
                (when (and (< 0 eol_hl_off) (== (- vcol eol_hl_off) (:w_virtcol win)) (== lnum (:lnum (:w_cursor win))))
                    ;; highlight last char after line
                    ((ร col =) (dec col))
                    ((ร off =) (dec off))
                    ((ร vcol =) (dec vcol))
                )

                ;; Highlight 'cursorcolumn' & 'colorcolumn' past end of the line.
                ((ร v =) (if @(:wo_wrap (:w_options win)) (:w_skipcol win) (:w_leftcol win)))

                ;; check if line ends before left margin
                ((ร vcol =) (max (- (+ v col) (win-col-off win)) vcol))
                ;; Get rid of the boguscols now,
                ;; we want to draw until the right edge for 'cursorcolumn'.
                ((ร col =) (- col boguscols))
                ((ร boguscols =) 0)

                ((ร draw_color_col =) (if draw_color_col (advance-color-col (- vcol vcol_off), color_cols, a'cci) draw_color_col))

                (when (or (and @(:wo_cuc (:w_options win)) (<= (- vcol vcol_off eol_hl_off) (:w_virtcol win)) (< (:w_virtcol win) (+ (* (:w_width win) (inc (- row startrow))) v)) (!= lnum (:lnum (:w_cursor win)))) draw_color_col)
                    ((ร int rightmost_vcol =) 0)

                    ((ร rightmost_vcol =) (if @(:wo_cuc (:w_options win)) (:w_virtcol win) rightmost_vcol))
                    (when draw_color_col
                        ;; determine rightmost colorcolumn to possibly draw
                        (loop-when-recur [#_int i 0] (<= 0 (... color_cols (+ @a'cci i))) [(inc i)]
                            ((ร rightmost_vcol =) (max (... color_cols (+ @a'cci i)) rightmost_vcol))
                        )
                    )

                    (loop-when [] (< col (:w_width win))
                        (.be @screenLines off, (byte \space))
                        ((ร @screenLinesUC[off] =) 0)
                        ((ร col =) (inc col))
                        ((ร draw_color_col =) (if draw_color_col (advance-color-col (- vcol vcol_off), color_cols, a'cci) draw_color_col))

                        (cond (and @(:wo_cuc (:w_options win)) (== (- vcol vcol_off) (:w_virtcol win)))
                        (do
                            ((ร @screenAttrs[off++] =) (hl-attr HLF_CUC))
                        )
                        (and draw_color_col (== (- vcol vcol_off) (... color_cols @a'cci)))
                        (do
                            ((ร @screenAttrs[off++] =) (hl-attr HLF_MC))
                        )
                        :else
                        (do
                            ((ร @screenAttrs[off++] =) 0)
                        ))

                        (if (<= rightmost_vcol (- vcol vcol_off))
                            (ร BREAK)
                        )

                        ((ร vcol =) (inc vcol))
                        (recur)
                    )
                )

                (screen-line screen_row, (:w_wincol win), col, (:w_width win), false)
                ((ร row =) (inc row))

                ;; Update "w_cline_height" if the cursor line was updated (saves a call to plines() later).

                (when (and (== win @curwin) (== lnum (:lnum (:w_cursor @curwin))))
                    (swap! curwin assoc :w_cline_row startrow)
                    (swap! curwin assoc :w_cline_height (- row startrow))
                    (swap! curwin update :w_valid | VALID_CHEIGHT VALID_CROW)
                )

                (ร BREAK)
            )

            ;; line continues beyond line end
            (when (and (!= @lcs_ext NUL) (not @(:wo_wrap (:w_options win))) (== col (dec (:w_width win))) (or (non-eos? ptr) (and (non-zero? n_extra) (or (!= c_extra NUL) (non-eos? p_extra)))))
                ((ร c =) @lcs_ext)
                ((ร char_attr =) (hl-attr HLF_AT))
                ((ร mb_c =) c)
                (cond (< 1 (utf-char2len c))
                (do
                    ((ร mb_utf8 =) true)
                    ((ร u8cc[0] =) 0)
                    ((ร c =) 0xc0)
                )
                :else
                (do
                    ((ร mb_utf8 =) false)
                ))
            )

            ;; advance to the next 'colorcolumn'
            ((ร draw_color_col =) (if draw_color_col (advance-color-col (- vcol vcol_off), color_cols, a'cci) draw_color_col))

            ;; Highlight the cursor column if 'cursorcolumn' is set.
            ;; But don't highlight the cursor position itself.
            ;; Also highlight the 'colorcolumn' if it is different than 'cursorcolumn'.
            ((ร vcol_save_attr =) -1)
            (when (and (== draw_state WL_LINE) (not lnum_in_visual_area))
                (cond (and @(:wo_cuc (:w_options win)) (== (- vcol vcol_off) (:w_virtcol win)) (!= lnum (:lnum (:w_cursor win))))
                (do
                    ((ร vcol_save_attr =) char_attr)
                    ((ร char_attr =) (hl-combine-attr char_attr, (hl-attr HLF_CUC)))
                )
                (and draw_color_col (== (- vcol vcol_off) (... color_cols @a'cci)))
                (do
                    ((ร vcol_save_attr =) char_attr)
                    ((ร char_attr =) (hl-combine-attr char_attr, (hl-attr HLF_MC)))
                ))
            )

            ;; Store character to be displayed.
            ;; Skip characters that are left of the screen for 'nowrap'.

            ((ร vcol_prev =) vcol)
            (cond (or (< draw_state WL_LINE) (<= n_skip 0))
            (do
                ;; Store the character.

                (.be @screenLines off, c)
                (cond mb_utf8
                (do
                    ((ร @screenLinesUC[off] =) mb_c)
                    (if (zero? (& c 0xff))
                        (.be @screenLines off, 0x80)    ;; avoid storing zero
                    )
                    (dotimes [#_int i @screen_mco]
                        ((ร @screenLinesC[i][off] =) (... u8cc i))
                        (if (zero? (... u8cc i))
                            (ร BREAK)
                        )
                    )
                )
                :else
                (do
                    ((ร @screenLinesUC[off] =) 0)
                ))
                (cond (non-zero? multi_attr)
                (do
                    ((ร @screenAttrs[off] =) multi_attr)
                    ((ร multi_attr =) 0)
                )
                :else
                (do
                    ((ร @screenAttrs[off] =) char_attr)
                ))

                (when (< 1 (utf-char2cells mb_c))
                    ;; Need to fill two screen columns.
                    ((ร off =) (inc off))
                    ((ร col =) (inc col))
                    ;; UTF-8: Put a 0 in the second screen char.
                    (eos! @screenLines off)
                    ((ร vcol =) (inc vcol))
                    ;; When "tocol" is halfway a character, set it to the end
                    ;; of the character, otherwise highlighting won't stop.
                    (when (== @a'tocol vcol)
                        (swap! a'tocol inc))
                )
                ((ร off =) (inc off))
                ((ร col =) (inc col))
            )
            (and (< 0 @(:wo_cole (:w_options win))) is_concealing)
            (do
                ((ร n_skip =) (dec n_skip))
                ((ร vcol_off =) (inc vcol_off))
                ((ร vcol_off =) (if (< 0 n_extra) (+ vcol_off n_extra) vcol_off))
                (cond @(:wo_wrap (:w_options win))
                (do
                    ;; Special voodoo required if 'wrap' is on.
                    ;;
                    ;; Advance the column indicator to force the line drawing to wrap early.
                    ;; This will make the line take up the same screen space when parts are concealed,
                    ;; so that cursor line computations aren't messed up.
                    ;;
                    ;; To avoid the fictitious advance of 'col' causing trailing junk to be written
                    ;; out of the screen line we are building, 'boguscols' keeps track of the number
                    ;; of bad columns we have advanced.

                    (when (< 0 n_extra)
                        ((ร vcol =) (+ vcol n_extra))
                        ((ร col =) (+ col n_extra))
                        ((ร boguscols =) (+ boguscols n_extra))
                        ((ร n_extra =) 0)
                        ((ร n_attr =) 0)
                    )

                    (when (< 1 (utf-char2cells mb_c))
                        ;; Need to fill two screen columns.
                        ((ร boguscols =) (inc boguscols))
                        ((ร col =) (inc col))
                    )

                    ((ร boguscols =) (inc boguscols))
                    ((ร col =) (inc col))
                )
                :else
                (do
                    (when (< 0 n_extra)
                        ((ร vcol =) (+ vcol n_extra))
                        ((ร n_extra =) 0)
                        ((ร n_attr =) 0)
                    )
                ))
            )
            :else
            (do
                ((ร n_skip =) (dec n_skip))
            ))

            ;; Only advance the "vcol" when after the 'number' or 'relativenumber' column.
            ((ร vcol =) (if (< WL_NR draw_state) (inc vcol) vcol))

            ((ร char_attr =) (if (<= 0 vcol_save_attr) vcol_save_attr char_attr))

            ;; restore attributes after "predeces" in 'listchars'
            (if (and (< WL_NR draw_state) (< 0 n_attr3) (zero? ((ร n_attr3 =) (dec n_attr3))))
                ((ร char_attr =) saved_attr3)
            )

            ;; restore attributes after last 'listchars' or 'number' char
            (if (and (< 0 n_attr) (== draw_state WL_LINE) (zero? ((ร n_attr =) (dec n_attr))))
                ((ร char_attr =) saved_attr2)
            )

            ;; At end of screen line and there is more to come:
            ;; display the line so far.
            ;; If there is no more to display it is caught above.

            (when (and (<= (:w_width win) col) (or (non-eos? ptr) (and (non-zero? n_extra) (or (!= c_extra NUL) (non-eos? p_extra)))))
                (screen-line screen_row, (:w_wincol win), (- col boguscols), (:w_width win), false)
                ((ร boguscols =) 0)
                ((ร row =) (inc row))
                ((ร screen_row =) (inc screen_row))

                ;; When not wrapping and finished diff lines, or when displayed
                ;; '$' and highlighting until last column, break here.
                (if (or (not @(:wo_wrap (:w_options win))) (== lcs_eol_one -1))
                    (ร BREAK)
                )

                ;; When the window is too narrow draw all "@" lines.
                (when (!= draw_state WL_LINE)
                    ((ร win =) (win-draw-end win, (byte \@), (byte \space), row, (:w_height win), HLF_AT))
                    (draw-vsep-win win, row)
                    ((ร row =) endrow)
                )

                ;; When line got too long for screen break here.
                (when (== row endrow)
                    ((ร row =) (inc row))
                    (ร BREAK)
                )

                (when (and (== @screen_cur_row (dec screen_row)) (== (:w_width win) @Cols))
                    ;; Remember that the line wraps, used for modeless copy.
                    ((ร @lineWraps[screen_row - 1] =) true)

                    ;; Special trick to make copy/paste of wrapped lines work with xterm/screen:
                    ;; write an extra character beyond the end of the line.
                    ;; This will work with all terminal types (regardless of the xn,am settings).
                    ;; Only do this if the cursor is on the current line (something has been written in it).
                    ;; Don't do this for the GUI.
                    ;; Don't do this for double-width characters.
                    ;; Don't do this for a window not at the right screen border.

                    (when (not (or (== (utf-off2cells (... @lineOffset screen_row), (+ (... @lineOffset screen_row) @screenCols)) 2) (== (utf-off2cells (+ (... @lineOffset (dec screen_row)) (- @Cols 2)), (+ (... @lineOffset screen_row) @screenCols)) 2)))
                        ((ร int eoff =) (+ (... @lineOffset (dec screen_row)) (dec @Cols)))

                        ;; First make sure we are at the end of the screen line,
                        ;; then output the same character again to let the terminal know about the wrap.
                        ;; If the terminal doesn't auto-wrap, we overwrite the character.
                        (when (!= @screen_cur_col (:w_width win))
                            (screen-char eoff, (dec screen_row), (dec @Cols)))

                        ;; When there is a multi-byte character,
                        ;; just output a space to keep it simple.
                        (if (< 1 (us-byte2len (.at @screenLines eoff), false))
                            (out-char (byte \space))
                            (out-char (.at @screenLines eoff)))
                        ;; force a redraw of the first char on the next line
                        ((ร @screenAttrs[@lineOffset[screen_row]] =) -1)
                        (screen-start)     ;; don't know where cursor is now
                    )
                )

                ((ร col =) 0)
                ((ร off =) (BDIFF @current_ScreenLine, @screenLines))

                ;; reset the drawing state for the start of a wrapped line
                ((ร draw_state =) WL_START)
                ((ร saved_n_extra =) n_extra)
                ((ร saved_p_extra =) p_extra)
                ((ร saved_c_extra =) c_extra)
                ((ร saved_char_attr =) char_attr)
                ((ร n_extra =) 0)
                ((ร need_showbreak =) true)
            )
            (recur)
        )

        row
    ))

;; Return if the composing characters at "off_from" and "off_to" differ.
;; Only to be used when screenLinesUC[off_from] != 0.

(defn- #_boolean comp-char-differs [#_int off_from, #_int off_to]
    (loop-when [#_int i 0] (< i @screen_mco) => false
        (cond (!= (... (... @screenLinesC i) off_from) (... (... @screenLinesC i) off_to)) true (zero? (... (... @screenLinesC i) off_from)) false :else (recur (inc i)))
    ))

;; Check whether the given character needs redrawing:
;; - the (first byte of the) character is different
;; - the attributes are different
;; - the character is multi-byte and the next byte is different
;; - the character is two cells wide and the second cell differs.

(defn- #_boolean char-needs-redraw [#_int from, #_int to, #_int cols]
    (and (< 0 cols)
         (or (!= (.at @screenLines from) (.at @screenLines to))
             (!= (... @screenAttrs from) (... @screenAttrs to))
             (!= (... @screenLinesUC from) (... @screenLinesUC to))
             (and (!= (... @screenLinesUC from) 0)
                  (comp-char-differs from, to))
             (and (< 1 (utf-off2cells from, (+ from cols)))
                  (!= (.at @screenLines (inc from)) (.at @screenLines (inc to)))))))

;; Move one "cooked" screen line to the screen, but only the characters that
;; have actually changed.  Handle insert/delete character.
;; "coloff" gives the first column on the screen for this line.
;; "endcol" gives the columns where valid characters are.
;; "clear_width" is the width of the window.  It's > 0 if the rest of the line
;; needs to be cleared, negative otherwise.
;; "rlflag" is true in a rightleft window:
;;    When true and "clear_width" > 0, clear columns 0 to "endcol"
;;    When false and "clear_width" > 0, clear columns "endcol" to "clear_width"

(defn- #_void screen-line [#_int row, #_int coloff, #_int endcol, #_int clear_width, #_boolean rlflag]
    (ยง
        ((ร int col =) 0)
        ((ร boolean force =) false)              ;; force update rest of the line
        ((ร boolean clear_next =) false)

        ;; Check for illegal row and col, just in case.
        ((ร row =) (min row (dec @Rows)))
        ((ร endcol =) (min endcol @Cols))

        ((ร int off_from =) (BDIFF @current_ScreenLine, @screenLines))
        ((ร int off_to =) (+ (... @lineOffset row) coloff))
        ((ร int max_off_from =) (+ off_from @screenCols))
        ((ร int max_off_to =) (+ (... @lineOffset row) @screenCols))

        (when rlflag
            ;; Clear rest first, because it's left of the text.
            (when (< 0 clear_width)
                (loop-when [] (and (<= col endcol) (at? @screenLines off_to (byte \space)) (== (... @screenAttrs off_to) 0) (== (... @screenLinesUC off_to) 0))
                    ((ร off_to =) (inc off_to))
                    ((ร col =) (inc col))
                    (recur)
                )
                (if (<= col endcol)
                    (screen-fill row, (inc row), (+ col coloff), (+ endcol coloff 1), (byte \space), (byte \space), 0))
            )
            ((ร col =) (inc endcol))
            ((ร off_to =) (+ (... @lineOffset row) col coloff))
            ((ร off_from =) (+ off_from col))
            ((ร endcol =) (if (< 0 clear_width) clear_width (- clear_width)))
        )

        ((ร boolean redraw_next =) (char-needs-redraw off_from, off_to, (- endcol col)))

        (loop-when [] (< col endcol)
            ((ร int char_cells =) (if (< (inc col) endcol) (utf-off2cells off_from, max_off_from) 1))             ;; 1: normal char; 2: occupies two display cells

            ;; bool: does character need redraw?
            ((ร boolean redraw_this =) redraw_next)
            ;; redraw_this for next character
            ((ร redraw_next =) (or force (char-needs-redraw (+ off_from char_cells), (+ off_to char_cells), (- endcol col char_cells))))

            (when redraw_this
                ;; When writing a single-width character over a double-width
                ;; character and at the end of the redrawn text, need to clear out
                ;; the right halve of the old character.
                ;; Also required when writing the right halve of a double-width
                ;; char over the left halve of an existing one.
                ((ร clear_next =) (or (and (== (+ col char_cells) endcol) (or (and (== char_cells 1) (< 1 (utf-off2cells off_to, max_off_to))) (and (== char_cells 2) (== (utf-off2cells off_to, max_off_to) 1) (< 1 (utf-off2cells (inc off_to), max_off_to))))) clear_next))

                (.be @screenLines off_to, (.at @screenLines off_from))
                ((ร @screenLinesUC[off_to] =) (... @screenLinesUC off_from))
                (when (non-zero? (... @screenLinesUC off_from))
                    (dotimes [#_int i @screen_mco]
                        ((ร @screenLinesC[i][off_to] =) (... (... @screenLinesC i) off_from))
                    )
                )
                (if (== char_cells 2)
                    (.be @screenLines (inc off_to), (.at @screenLines (inc off_from)))
                )

                ;; The bold trick makes a single column of pixels appear in the
                ;; next character.  When a bold character is removed, the next
                ;; character should be redrawn too.  This happens for our own GUI
                ;; and for some xterms.
                (when @term_is_xterm
                    ((ร int hl =) (... @screenAttrs off_to))
                    ((ร hl =) (if (< HL_ALL hl) (syn-attr2attr hl) hl))
                    ((ร redraw_next =) (or (flag? hl HL_BOLD) redraw_next))
                )
                ((ร @screenAttrs[off_to] =) (... @screenAttrs off_from))
                ;; For simplicity, set the attributes of second half
                ;; of a double-wide character equal to the first half.
                (if (== char_cells 2)
                    ((ร @screenAttrs[off_to + 1] =) (... @screenAttrs off_from))
                )

                (screen-char off_to, row, (+ col coloff))
            )

            ((ร off_to =) (+ off_to char_cells))
            ((ร off_from =) (+ off_from char_cells))
            ((ร col =) (+ col char_cells))
            (recur)
        )

        (when clear_next
            ;; Clear the second half of a double-wide character of which
            ;; the left half was overwritten with a single-wide character.
            (.be @screenLines off_to, (byte \space))
            ((ร @screenLinesUC[off_to] =) 0)
            (screen-char off_to, row, (+ col coloff))
        )

        (when (and (< 0 clear_width) (not rlflag))
            ;; blank out the rest of the line
            (loop-when [] (and (< col clear_width) (at? @screenLines off_to (byte \space)) (== (... @screenAttrs off_to) 0) (== (... @screenLinesUC off_to) 0))
                ((ร off_to =) (inc off_to))
                ((ร col =) (inc col))
                (recur)
            )
            (when (< col clear_width)
                (screen-fill row, (inc row), (+ col coloff), (+ clear_width coloff), (byte \space), (byte \space), 0)
                ((ร off_to =) (+ off_to (- clear_width col)))
                ((ร col =) clear_width)
            )
        )

        (when (< 0 clear_width)
            ;; For a window that's left of another, draw the separator char.
            (cond (< (+ col coloff) @Cols)
            (let [a'hl (atom (int)) #_int c (fillchar-vsep a'hl)]
                (when (or (not-at? @screenLines off_to c) (!= (... @screenLinesUC off_to) (if (<= 0x80 c) c 0)) (!= (... @screenAttrs off_to) @a'hl))
                    (.be @screenLines off_to, c)
                    ((ร @screenAttrs[off_to] =) @a'hl)
                    (cond (<= 0x80 c)
                    (do
                        ((ร @screenLinesUC[off_to] =) c)
                        ((ร @screenLinesC[0][off_to] =) 0)
                    )
                    :else
                    (do
                        ((ร @screenLinesUC[off_to] =) 0)
                    ))
                    (screen-char off_to, row, (+ col coloff))
                )
            )
            :else
            (do
                ((ร @lineWraps[row] =) false)
            ))
        )
        nil
    ))

;; Mark all status lines for redraw.

(defn- #_void status-redraw-all []
    (ยง loop-when-recur [#_window_C win @firstwin] (some? win) [(:w_next win)]
        (when (non-zero? (:w_status_height win))
            ((ร win =) (assoc win :w_redr_status true))
            ((ร win =) (redraw-later win, VALID))	;; %% anno @curwin ??
        ))
    nil)

;; Redraw all status lines that need to be redrawn.

(defn- #_void redraw-statuslines []
    (ยง loop-when-recur [#_window_C win @firstwin] (some? win) [(:w_next win)]
        (when (:w_redr_status win)
            ((ร win =) (win-redr-status win))
        ))
    nil)

;; Draw the verticap separator right of window "win" starting with line "row".

(defn- #_void draw-vsep-win [#_window_C win, #_int row]
    (when (non-zero? (:w_vsep_width win))
        ;; draw the vertical separator right of this window
        (let [a'hl (atom (int)) #_int fc (fillchar-vsep a'hl)
              wr (:w_winrow win) wc (:w_wincol win) wh (:w_height win) ww (:w_width win)]
            (screen-fill (+ wr row), (+ wr wh), (+ wc ww), (+ wc ww 1), fc, (byte \space), @a'hl)
        ))
    nil)

(atom! boolean _3_busy)

;; Redraw the status line of window "win".
;;
;; If inversion is possible, we use it; else '=' characters are used.

(defn- #_window_C win-redr-status [#_window_C win]
    ;; It's possible to get here recursively when 'statusline' (indirectly) invokes ":redrawstatus".  Simply ignore the call then.
    (if @_3_busy
        win
        (let [_ (reset! _3_busy true)
              win (assoc win :w_redr_status false)
              win (cond (zero? (:w_status_height win))      ;; no status line, must be the last window
                    (do (reset! redraw_cmdline true) win)
                (not (redrawing))                           ;; don't redraw right now, do it later
                    (assoc win :w_redr_status true)
                :else
                    (let [#_Bytes s (Bytes. MAXPATHL)]
                        (vim-strncpy s, (u8 "[No Name]"), (dec MAXPATHL))
                        (trans-characters s, MAXPATHL)
                        (when @(:b_changed @curbuf)
                            (let [n (STRLEN s)] (-> s (.be n, (byte \space)) (.plus (inc n)) (STRCPY (u8 "[+]")))))
                        (let [m (max (/ (inc (:w_width win)) 2) (- @ru_col (- @Cols (:w_width win))))
                              [s n]
                                (if (< 1 m)                 ;; find first character that will fit
                                    (let [[n i] (loop-when-recur [n (us-string2cells s, -1) i 0]
                                                                 (and (<= (dec m) n) (non-eos? s i))
                                                                 [(- n (us-ptr2cells s, i)) (+ i (us-ptr2len-cc s, i))]
                                                              => [n i]
                                                )]
                                        (if (< 0 i) [(-> s (.plus (dec i)) (.be 0, (byte \<))) (inc n)] [s n]))
                                    [(u8 "<") 1]            ;; no room for file name!
                                )]
                            (let [row (+ (:w_winrow win) (:w_height win)) col (:w_wincol win)
                                  a'attr (atom (int)) #_int fillchar (fillchar-status a'attr, (== win @curwin))]
                                (screen-puts s, row, col, @a'attr)
                                (screen-fill row, (inc row), (+ col n), (+ col m), fillchar, fillchar, @a'attr))
                            (win-redr-ruler win, true)
                        ))
                )]
            ;; May need to draw the character below the vertical separator.
            (when (and (non-zero? (:w_vsep_width win)) (non-zero? (:w_status_height win)) (redrawing))
                (let [a'attr (atom (int)) #_int fillchar (if (stl-connected win) (fillchar-status a'attr, (== win @curwin)) (fillchar-vsep a'attr))]
                    (screen-putchar fillchar, (+ (:w_winrow win) (:w_height win)), (+ (:w_wincol win) (:w_width win)), @a'attr)
                ))
            (reset! _3_busy false)
            win)
    ))

;; Return true if the status line of window "win" is connected to the status
;; line of the window right of it.  If not, then it's a vertical separator.
;; Only call if (win.w_vsep_width != 0).

(defn- #_boolean stl-connected [#_window_C win]
    (loop-when [#_frame_C fr (:w_frame win)] (some? (:fr_parent fr)) => false
        (recur-if (nil? (:fr_next fr)) [(:fr_parent fr)] => (!= (:fr_layout (:fr_parent fr)) FR_COL))
    ))

;; Output a single character directly to the screen and update "screenLines".

(defn- #_void screen-putchar [#_int c, #_int row, #_int col, #_int attr]
    (let [#_Bytes buf (Bytes. (inc MB_MAXBYTES))]
        (eos! buf (utf-char2bytes c, buf))
        (screen-puts buf, row, col, attr))
    nil)

;; Get a single character directly from "screenLines" into "bytes[]".
;; Also return its attribute in "*a'attr".

(defn- #_void screen-getbytes [#_int row, #_int col, #_Bytes bytes, #_int' a'attr]
    (when (and (some? @screenLines) (< row @screenRows) (< col @screenCols))
        (let [#_int off (+ (... @lineOffset row) col)]

            (reset! a'attr (... @screenAttrs off))
            (.be bytes 0, (.at @screenLines off))
            (eos! bytes 1)

            (when (non-zero? (... @screenLinesUC off))
                (eos! bytes (utfc-char2bytes off, bytes)))
        ))
    nil)

;; Return true if composing characters for screen posn "off"
;; differs from composing characters in "u8cc".
;; Only to be used when screenLinesUC[off] != 0.

(defn- #_boolean screen-comp-differs [#_int off, #_int* u8cc]
    (loop-when [#_int i 0] (< i @screen_mco) => false
        (cond (!= (... (... @screenLinesC i) off) (... u8cc i)) true (zero? (... u8cc i)) false :else (recur (inc i)))
    ))

;; Put string '*text' on the screen at position 'row' and 'col', with
;; attributes 'attr', and update screenLines[] and screenAttrs[].
;; Note: only outputs within one row, message is truncated at screen boundary!
;; Note: if screenLines[], row and/or col is invalid, nothing is done.

(defn- #_void screen-puts [#_Bytes text, #_int row, #_int col, #_int attr]
    (screen-puts-len text, -1, row, col, attr)
    nil)

;; Like screen-puts(), but output "text[len]".  When "len" is -1 output up to a NUL.

(defn- #_void screen-puts-len [#_Bytes text, #_int textlen, #_int row, #_int col, #_int attr]
    (ยง
        ((ร boolean clear_next_cell =) false)
        ((ร boolean force_redraw_next =) false)

        (if (or (nil? @screenLines) (<= @screenRows row))       ;; safety check
            ((ร RETURN) nil)
        )

        ((ร int off =) (+ (... @lineOffset row) col))

        ;; When drawing over the right halve of a double-wide char clear out the left halve.
        ;; Only needed in a terminal.
        (when (and (< 0 col) (< col @screenCols) (!= (mb-fix-col col, row) col))
            (.be @screenLines (dec off), (byte \space))
            ((ร @screenAttrs[off - 1] =) 0)
            ((ร @screenLinesUC[off - 1] =) 0)
            ((ร @screenLinesC[0][off - 1] =) 0)
            ;; redraw the previous cell, make it empty
            (screen-char (dec off), row, (dec col))
            ;; force the cell at "col" to be redrawn
            ((ร force_redraw_next =) true)
        )

        ((ร Bytes ptr =) text)
        ((ร int len =) textlen)
        ((ร int[] u8cc =) (ร new int[MAX_MCO]))

        ((ร int max_off =) (+ (... @lineOffset row) @screenCols))
        (loop-when [] (and (< col @screenCols) (or (< len 0) (< (BDIFF ptr, text) len)) (non-eos? ptr))
            ((ร byte c =) (.at ptr 0))

            ;; check if this is the first byte of a multibyte
            ((ร int mbyte_blen =) (if (< 0 len) (us-ptr2len-cc-len ptr, (BDIFF (.plus text len), ptr)) (us-ptr2len-cc ptr)))

            ((ร int u8c =) (if (<= 0 len) (us-ptr2char-cc-len ptr, u8cc, (BDIFF (.plus text len), ptr)) (us-ptr2char-cc ptr, u8cc)))

            ((ร int mbyte_cells =) (utf-char2cells u8c))

            (when (< @screenCols (+ col mbyte_cells))
                ;; Only 1 cell left, but character requires 2 cells:
                ;; display a '>' in the last column to avoid wrapping.
                ((ร c =) (byte \>))
                ((ร mbyte_cells =) 1)
            )

            ((ร boolean force_redraw_this =) force_redraw_next)
            ((ร force_redraw_next =) false)

            ((ร boolean need_redraw =) (or (not-at? @screenLines off c) (and (== mbyte_cells 2) (not-at? @screenLines (inc off) 0)) (or (!= (... @screenLinesUC off) (if (and (< (char_u c) 0x80) (zero? (... u8cc 0))) 0 u8c)) (and (non-zero? (... @screenLinesUC off)) (screen-comp-differs off, u8cc))) (!= (... @screenAttrs off) attr)))

            (when (or need_redraw force_redraw_this)
                ;; The bold trick makes a single row of pixels appear in the next character.
                ;; When a bold character is removed, the next character should be redrawn too.
                ;; This happens for our own GUI and for some xterms.
                (when (and need_redraw (not-at? @screenLines off (byte \space)) @term_is_xterm)
                    ((ร int n =) (... @screenAttrs off))

                    ((ร n =) (if (< HL_ALL n) (syn-attr2attr n) n))
                    ((ร force_redraw_next =) (or (flag? n HL_BOLD) force_redraw_next))
                )
                ;; When at the end of the text and overwriting a two-cell character with
                ;; a one-cell character, need to clear the next cell.  Also when overwriting
                ;; the left halve of a two-cell char with the right halve of a two-cell char.
                ;; Do this only once (utf-off2cells() may return 2 on the right halve).
                (cond clear_next_cell
                (do
                    ((ร clear_next_cell =) false)
                )
                (and (if (< len 0) (eos? ptr mbyte_blen) (BLE (.plus text len), (.plus ptr mbyte_blen))) (or (and (== mbyte_cells 1) (< 1 (utf-off2cells off, max_off))) (and (== mbyte_cells 2) (== (utf-off2cells off, max_off) 1) (< 1 (utf-off2cells (inc off), max_off)))))
                (do
                    ((ร clear_next_cell =) true)
                ))

                (.be @screenLines off, c)
                ((ร @screenAttrs[off] =) attr)

                (cond (and (< (char_u c) 0x80) (zero? (... u8cc 0)))
                (do
                    ((ร @screenLinesUC[off] =) 0)
                )
                :else
                (do
                    ((ร @screenLinesUC[off] =) u8c)
                    (dotimes [#_int i @screen_mco]
                        ((ร @screenLinesC[i][off] =) (... u8cc i))
                        (if (zero? (... u8cc i))
                            (ร BREAK)
                        )
                    )
                ))
                (when (== mbyte_cells 2)
                    (eos! @screenLines (inc off))
                    ((ร @screenAttrs[off + 1] =) attr)
                )
                (screen-char off, row, col)
            )

            ((ร off =) (+ off mbyte_cells))
            ((ร col =) (+ col mbyte_cells))
            ((ร ptr =) (.plus ptr mbyte_blen))
            (when clear_next_cell
                ;; This only happens at the end, display one space next.
                ((ร ptr =) (u8 " "))
                ((ร len =) -1)
            )
            (recur)
        )

        ;; If we detected the next character needs to be redrawn,
        ;; but the text doesn't extend up to there, update the character here.
        (when (and force_redraw_next (< col @screenCols))
            (screen-char off, row, col)
        )
        nil
    ))

;; Prepare for 'hlsearch' highlighting.

(defn- #_void start-search-hl []
    (when (and @p_hls (not @no_hlsearch))
        (last-pat-prog (:rmm @search_hl))
        (swap! search_hl assoc :attr (hl-attr HLF_L))
        ;; Set the time limit to 'redrawtime'.
        (swap! search_hl assoc :nsec (profile-setlimit @p_rdt))
    )
    nil)

;; Clean up for 'hlsearch' highlighting.

(defn- #_void end-search-hl []
    (when (some? (:regprog (:rmm @search_hl)))
        (swap! search_hl assoc-in [:rmm :regprog] nil))
    nil)

;; Init for calling prepare-search-hl().

(defn- #_void init-search-hl [#_window_C win]
    (ยง
        ;; Setup for match and 'hlsearch' highlighting.  Disable any previous match.
        (loop-when-recur [#_matchitem_C mi (:w_match_head win)] (some? mi) [(:next mi)]
            (COPY-regmmatch (:rmm (:mi_hl mi)), (:mi_match mi))
            ((ร mi =) (assoc-in mi [:mi_hl :attr] (if (non-zero? (:hlg_id mi)) (syn-id2attr (:hlg_id mi)) 0)))
            ((ร mi =) (assoc-in mi [:mi_hl :lnum] 0))
            ((ร mi =) (assoc-in mi [:mi_hl :first_lnum] 0))
            ;; Set the time limit to 'redrawtime'.
            ((ร mi =) (assoc-in mi [:mi_hl :nsec] (profile-setlimit @p_rdt)))
        )
        (swap! search_hl assoc :lnum 0 :first_lnum 0)
        ;; time limit is set at the toplevel, for all windows
        nil
    ))

;; Advance to the match in window "win" line "lnum" or past it.

(defn- #_void prepare-search-hl [#_window_C win, #_long lnum]
    (ยง
        ;; When using a multi-line pattern, start searching at the top
        ;; of the window or just after a closed fold.
        ;; Do this both for search_hl and the match list.

        ((ร matchitem_C mi =) (:w_match_head win))
        ((ร boolean shl_flag =) false)               ;; whether search_hl has been processed
        (loop-when [] (or (some? mi) (not shl_flag))
            (ร match_C shl)                        ;; points to search_hl or a match
            (cond (not shl_flag)
            (do
                ((ร shl =) @search_hl)
                ((ร shl_flag =) true)
            )
            :else
            (do
                ((ร shl =) (:mi_hl mi))
            ))
            (when (and (some? (:regprog (:rmm shl))) (zero? (:lnum shl)) (re-multiline (:regprog (:rmm shl))))
                (if (zero? (:first_lnum shl))
                    ((ร shl =) (assoc shl :first_lnum (:w_topline win)))
                )
                (if (some? mi)
                    ((ร mi =) (assoc-in mi [:mi_pos :cur] 0))
                )
                ((ร boolean pos_inprogress =) true)  ;; marks that position match search is in progress
                ((ร int n =) 0)
                (loop-when [] (and (< (:first_lnum shl) lnum) (or (some? (:regprog (:rmm shl))) (and (some? mi) pos_inprogress)))
                    (next-search-hl shl, (:first_lnum shl), n, mi)
                    ((ร pos_inprogress =) (and (some? mi) (!= (:cur (:mi_pos mi)) 0)))
                    (cond (non-zero? (:lnum shl))
                    (do
                        ((ร shl =) (assoc shl :first_lnum (- (+ (:lnum shl) (:lnum (... (:endpos (:rmm shl)) 0))) (:lnum (... (:startpos (:rmm shl)) 0)))))
                        ((ร n =) (:col (... (:endpos (:rmm shl)) 0)))
                    )
                    :else
                    (do
                        ((ร shl =) (update shl :first_lnum inc))
                        ((ร n =) 0)
                    ))
                    (recur)
                )
            )
            ((ร mi =) (if (and (!= shl @search_hl) (some? mi)) (:next mi) mi))
            (recur)
        )
        nil
    ))

;; Search for a next 'hlsearch' or match.
;; Sets shl.lnum and shl.rmm contents.
;; Note: Assumes a previous match is always before "lnum", unless shl.lnum is zero.
;; Careful: Any pointers for buffer lines will become invalid.

(defn- #_void next-search-hl [#_match_C shl, #_long lnum, #_int mincol, #_matchitem_C mi]
    ;; shl: points to search_hl or a match
    ;; mincol: minimal column for a match
    ;; mi: to retrieve match positions if any
    (ยง
        (when (non-zero? (:lnum shl))
            ;; Check for three situations:
            ;; 1. If the "lnum" is below a previous match, start a new search.
            ;; 2. If the previous match includes "mincol", use it.
            ;; 3. Continue after the previous match.

            ((ร long l =) (+ (:lnum shl) (- (:lnum (... (:endpos (:rmm shl)) 0)) (:lnum (... (:startpos (:rmm shl)) 0)))))
            (cond (< l lnum)
            (do
                ((ร shl =) (assoc shl :lnum 0))
            )
            (or (< lnum l) (< mincol (:col (... (:endpos (:rmm shl)) 0))))
            (do
                ((ร RETURN) nil)
            ))
        )

        ;; Repeat searching for a match until one is found that includes "mincol"
        ;; or none is found in this line.

        (reset! called_emsg false)
        (loop []
            ;; Stop searching after passing the time limit.
            (when (profile-passed-limit (:nsec shl))
                ((ร shl =) (assoc shl :lnum 0))   ;; no match found in time
                (ร BREAK)
            )
            ;; Three situations:
            ;; 1. No useful previous match: search from start of line.
            ;; 2. Not Vi compatible or empty match: continue at next character.
            ;;    Break the loop if this is beyond the end of the line.
            ;; 3. Vi compatible searching: continue at end of previous match.

            (ร int matchcol)
            (cond (zero? (:lnum shl))
            (do
                ((ร matchcol =) 0)
            )
            (or (nil? (vim-strbyte @p_cpo, CPO_SEARCH)) (and (zero? (:lnum (... (:endpos (:rmm shl)) 0))) (<= (:col (... (:endpos (:rmm shl)) 0)) (:col (... (:startpos (:rmm shl)) 0)))))
            (do
                ((ร matchcol =) (:col (... (:startpos (:rmm shl)) 0)))
                ((ร Bytes ml =) (.plus (ml-get lnum) matchcol))
                (when (eos? ml)
                    ((ร matchcol =) (inc matchcol))
                    ((ร shl =) (assoc shl :lnum 0))
                    (ร BREAK)
                )
                ((ร matchcol =) (+ matchcol (us-ptr2len-cc ml)))
            )
            :else
            (do
                ((ร matchcol =) (:col (... (:endpos (:rmm shl)) 0)))
            ))

            (ร long nmatched)

            ((ร shl =) (assoc shl :lnum lnum))
            (cond (some? (:regprog (:rmm shl)))
            (do
                ;; Remember whether shl.rmm is using a copy of the regprog in mi.mi_match.
                ((ร boolean regprog_is_copy =) (and (!= shl @search_hl) (some? mi) (== shl (:mi_hl mi)) (== (:regprog (:mi_match mi)) (:regprog (:rmm (:mi_hl mi))))))

                ((ร nmatched =) (vim-regexec-multi (:rmm shl), lnum, matchcol, (:nsec shl)))
                ;; Copy the regprog, in case it got freed and recompiled.
                (if regprog_is_copy
                    ((ร mi =) (assoc-in mi [:mi_match :regprog] (:regprog (:rmm (:mi_hl mi)))))
                )

                (when (or @called_emsg @got_int)
                    ;; Error while handling regexp: stop using this regexp.
                    (when (== shl @search_hl)
                        (reset! no_hlsearch true))
                    ((ร shl =) (assoc-in shl [:rmm :regprog] nil))
                    ((ร shl =) (assoc shl :lnum 0))
                    (reset! got_int false)    ;; avoid the "Type :quit to exit Vim" message
                    (ร BREAK)
                )
            )
            (some? mi)
            (do
                ((ร nmatched =) (if (next-search-hl-pos shl, lnum, (:mi_pos mi), matchcol) 1 0))
            )
            :else
            (do
                ((ร nmatched =) 0)
            ))
            (when (zero? nmatched)
                ((ร shl =) (assoc shl :lnum 0))           ;; no match found
                (ร BREAK)
            )
            (when (or (< 0 (:lnum (... (:startpos (:rmm shl)) 0))) (<= mincol (:col (... (:startpos (:rmm shl)) 0))) (< 1 nmatched) (< mincol (:col (... (:endpos (:rmm shl)) 0))))
                ((ร shl =) (update shl :lnum + (:lnum (... (:startpos (:rmm shl)) 0))))
                (ร BREAK)                  ;; useful match found
            )
            (recur)
        )
        nil
    ))

(defn- #_boolean next-search-hl-pos [#_match_C shl, #_long lnum, #_posmatch_C posmatch, #_int mincol]
    ;; shl: points to a match
    ;; posmatch: match positions
    ;; mincol: minimal column for a match
    (ยง
        ((ร int bot =) -1)

        ((ร llpos_C tmp =) (NEW_llpos_C))

        ((ร shl =) (assoc shl :lnum 0))
        (loop-when-recur [#_int i (:cur posmatch)] (< i MAXPOSMATCH) [(inc i)]
            (if (zero? (:lnum (... (:pm_pos posmatch) i)))
                (ร BREAK)
            )
            (if (< (:col (... (:pm_pos posmatch) i)) mincol)
                (ร CONTINUE)
            )
            (when (== (:lnum (... (:pm_pos posmatch) i)) lnum)
                (cond (== (:lnum shl) lnum)
                (do
                    ;; partially sort positions by column numbers on the same line
                    (when (< (:col (... (:pm_pos posmatch) i)) (:col (... (:pm_pos posmatch) bot)))
                        (COPY-llpos tmp, (... (:pm_pos posmatch) i))
                        (COPY-llpos (... (:pm_pos posmatch) i), (... (:pm_pos posmatch) bot))
                        (COPY-llpos (... (:pm_pos posmatch) bot), tmp)
                    )
                )
                :else
                (do
                    ((ร bot =) i)
                    ((ร shl =) (assoc shl :lnum lnum))
                ))
            )
        )
        ((ร posmatch =) (assoc posmatch :cur 0))

        (when (== (:lnum shl) lnum)
            ((ร int start =) (if (zero? (:col (... (:pm_pos posmatch) bot))) 0 (- (:col (... (:pm_pos posmatch) bot)) 1)))
            ((ร int end =) (if (zero? (:col (... (:pm_pos posmatch) bot))) MAXCOL (+ start (:len (... (:pm_pos posmatch) bot)))))

            ((ร shl.rmm.startpos[0].lnum =) 0)
            ((ร shl.rmm.startpos[0].col =) start)
            ((ร shl.rmm.endpos[0].lnum =) 0)
            ((ร shl.rmm.endpos[0].col =) end)
            ((ร posmatch =) (assoc posmatch :cur (inc bot)))

            ((ร RETURN) true)
        )

        false
    ))

(defn- #_void screen-start-highlight [#_int attr]
    (reset! screen_attr attr)
    (when @full_screen
        (let [[#_attrentry_C aep attr]
                (if (< HL_ALL attr)                                  ;; special HL attr.
                    (let [aep (if (< 1 @t_colors) (syn-cterm-attr2entry attr) (syn-term-attr2entry attr))] [aep (if (some? aep) (:ae_attr aep) 0)])
                    [nil attr]
                )]

            (cond (and (flag? attr HL_BOLD) (some? @T_MD))          ;; bold
                (out-str @T_MD)
            ;; If the Normal FG color has BOLD attribute and the new HL has a FG color defined, clear BOLD.
            (and (some? aep) (< 1 @t_colors) (non-zero? (:ae_fg_color aep)) (non-zero? @cterm_normal_fg_bold))
                (out-str @T_ME))

            (when (and (flag? attr HL_STANDOUT) (some? @T_SO))      ;; standout
                (out-str @T_SO))
            (when (and (flag? attr (| HL_UNDERLINE HL_UNDERCURL)) (some? @T_US)) ;; underline or undercurl
                (out-str @T_US))
            (when (and (flag? attr HL_ITALIC) (some? @T_CZH))       ;; italic
                (out-str @T_CZH))
            (when (and (flag? attr HL_INVERSE) (some? @T_MR))       ;; inverse (reverse)
                (out-str @T_MR))

            ;; Output the color or start string after bold etc.,
            ;; in case the bold etc. override the color setting.

            (when (some? aep)
                (if (< 1 @t_colors)
                    (do
                        (when (non-zero? (:ae_fg_color aep)) (term-fg-color (dec (:ae_fg_color aep))))
                        (when (non-zero? (:ae_bg_color aep)) (term-bg-color (dec (:ae_bg_color aep))))
                    )
                    (when (some? (:ae_esc_start aep)) (out-str (:ae_esc_start aep)))
                ))
        ))
    nil)

(defn- #_void screen-stop-highlight []
    (when (non-zero? @screen_attr)
        (let [#_boolean me?
                (and (< HL_ALL @screen_attr) ;; output T_ME code ;; special HL attr.
                    (let [[#_attrentry_C aep me?]
                            (if (< 1 @t_colors)
                                (let [aep (syn-cterm-attr2entry @screen_attr)]
                                    ;; Assume that t_me restores the original colors!
                                    [aep (and (some? aep) (or (non-zero? (:ae_fg_color aep)) (non-zero? (:ae_bg_color aep))))])
                                (let [aep (syn-term-attr2entry @screen_attr)]
                                    [aep (and (some? aep) (some? (:ae_esc_stop aep)) (or (zero? (STRCMP (:ae_esc_stop aep), @T_ME)) (do (out-str (:ae_esc_stop aep)) false)))])
                            )]
                        (reset! screen_attr (if (some? aep) (:ae_attr aep) 0)) ;; did ":syntax clear"
                        me?))
              ;; Often all ending-codes are equal to T_ME.
              ;; Avoid outputting the same sequence several times.
              me? (if (flag? @screen_attr HL_STANDOUT)                   (or (zero? (STRCMP @T_SE, @T_ME))  (do (out-str @T_SE) me?))  me?)
              me? (if (flag? @screen_attr (| HL_UNDERLINE HL_UNDERCURL)) (or (zero? (STRCMP @T_UE, @T_ME))  (do (out-str @T_UE) me?))  me?)
              me? (if (flag? @screen_attr HL_ITALIC)                     (or (zero? (STRCMP @T_CZR, @T_ME)) (do (out-str @T_CZR) me?)) me?)]
            (when (or me? (flag? @screen_attr (| HL_BOLD HL_INVERSE)))
                (out-str @T_ME))
        )
        (when (< 1 @t_colors) ;; set Normal cterm colors
            (when (non-zero? @cterm_normal_fg_color) (term-fg-color (dec @cterm_normal_fg_color)))
            (when (non-zero? @cterm_normal_bg_color) (term-bg-color (dec @cterm_normal_bg_color)))
            (when (non-zero? @cterm_normal_fg_bold) (out-str @T_MD))
        ))
    (reset! screen_attr 0)
    nil)

;; Reset the colors for a cterm.  Used when leaving Vim.
;; The machine specific code may override this again.

(defn- #_void reset-cterm-colors []
    (when (< 1 @t_colors)
        ;; set Normal cterm colors
        (when (or (< 0 @cterm_normal_fg_color) (< 0 @cterm_normal_bg_color))
            (out-str @T_OP)
            (reset! screen_attr -1)
        )
        (when (non-zero? @cterm_normal_fg_bold)
            (out-str @T_ME)
            (reset! screen_attr -1)
        )
    )
    nil)

;; Put character screenLines["off"] on the screen at position "row" and "col",
;; using the attributes from screenAttrs["off"].

(defn- #_void screen-char [#_int off, #_int row, #_int col]
    (ยง
        ;; Check for illegal values, just in case (could happen just after resizing).
        (if (or (<= @screenRows row) (<= @screenCols col))
            ((ร RETURN) nil)
        )

        ;; Outputting a character in the last cell on the screen may scroll the
        ;; screen up.  Only do it when the "xn" termcap property is set, otherwise
        ;; mark the character invalid (update it when scrolled up).
        (when (and (eos? @T_XN) (== row (dec @screenRows)) (== col (dec @screenCols)))
            ((ร @screenAttrs[off] =) -1)
            ((ร RETURN) nil)
        )

        ;; Stop highlighting first, so it's easier to move the cursor.

        ((ร int attr =) (if (non-zero? @screen_char_attr) @screen_char_attr (... @screenAttrs off)))
        (when (!= @screen_attr attr)
            (screen-stop-highlight))

        (windgoto row, col)

        (when (!= @screen_attr attr)
            (screen-start-highlight attr))

        (cond (non-zero? (... @screenLinesUC off))
        (do
            ((ร Bytes buf =) (Bytes. (inc MB_MAXBYTES)))

            ;; Convert UTF-8 character to bytes and write it.
            (eos! buf (utfc-char2bytes off, buf))

            (out-str buf)
            (if (< 1 (utf-char2cells (... @screenLinesUC off)))
                (swap! screen_cur_col inc))
        )
        :else
        (do
            (out-flush-check)
            (out-char (.at @screenLines off))
        ))

        (swap! screen_cur_col inc)
        nil
    ))

;; Draw a rectangle of the screen, inverted when "invert" is true.
;; This uses the contents of screenLines[] and doesn't change it.

(defn- #_void screen-draw-rectangle [#_int row, #_int col, #_int height, #_int width, #_boolean invert]
    (when (some? @screenLines) ;; can't use "screenLines" unless initialized
        (when invert
            (reset! screen_char_attr HL_INVERSE))
        (loop-when-recur [#_int r row] (< r (+ row height)) [(inc r)]
            (let [#_int off (... @lineOffset r) #_int max_off (+ off @screenCols)]
                (loop-when-recur [#_int c col] (< c (+ col width)) [(inc (if (< 1 (utf-off2cells (+ off c), max_off)) (inc c) c))]
                    (screen-char (+ off c), r, c))
            ))
        (reset! screen_char_attr 0))
    nil)

;; Redraw the characters for a vertically split window.

(defn- #_void redraw-block [#_int row, #_int end, #_window_C win]
    (let [[#_int col #_int width] (if (some? win) [(:w_wincol win) (:w_width win)] [0 @Cols])]
        (screen-draw-rectangle row, col, (- end row), width, false))
    nil)

;; Fill the screen from 'start_row' to 'end_row', from 'start_col' to 'end_col'
;; with character 'c1' in first column followed by 'c2' in the other columns.
;; Use attributes 'attr'.

(defn- #_void screen-fill [#_int start_row, #_int end_row, #_int start_col, #_int end_col, #_int c1, #_int c2, #_int attr]
    (ยง
        ((ร boolean force_next =) false)

        ((ร end_row =) (min end_row @screenRows))           ;; safety check
        ((ร end_col =) (min end_col @screenCols))           ;; safety check

        (when (or (nil? @screenLines) (<= end_row start_row) (<= end_col start_col))        ;; nothing to do
            ((ร RETURN) nil)
        )

        ;; it's a "normal" terminal when not in a GUI or cterm
        ((ร boolean norm_term =) (<= @t_colors 1))

        (loop-when-recur [#_int row start_row] (< row end_row) [(inc row)]
            ;; When drawing over the right halve of a double-wide char clear out the left halve.
            ;; When drawing over the left halve of a double wide-char clear out the right halve.
            ;; Only needed in a terminal.
            (when (and (< 0 start_col) (!= (mb-fix-col start_col, row) start_col))
                (screen-puts-len (u8 " "), 1, row, (dec start_col), 0))
            (when (and (< end_col @screenCols) (!= (mb-fix-col end_col, row) end_col))
                (screen-puts-len (u8 " "), 1, row, end_col, 0))

            ;; Try to use delete-line termcap code, when no attributes or in a
            ;; "normal" terminal, where a bold/italic space is just a space.

            ((ร boolean did_delete =) false)
            (when (and (== c2 (byte \space)) (== end_col @Cols) (can-clear @T_CE) (or (zero? attr) (and norm_term (<= attr HL_ALL) (zero? (& attr (bit-not (| HL_BOLD HL_ITALIC)))))))
                ;; check if we really need to clear something

                ((ร int col =) (if (!= c1 (byte \space)) (inc start_col) start_col))                      ;; don't clear first char

                ((ร int off =) (+ (... @lineOffset row) col))
                ((ร int end_off =) (+ (... @lineOffset row) end_col))

                ;; skip blanks (used often, keep it fast!)
                (loop-when [] (and (< off end_off) (at? @screenLines off (byte \space)) (== (... @screenAttrs off) 0) (== (... @screenLinesUC off) 0))
                    ((ร off =) (inc off))
                    (recur)
                )
                (when (< off end_off)                  ;; something to be cleared
                    ((ร col =) (- off (... @lineOffset row)))
                    (screen-stop-highlight)
                    (term-windgoto row, col)        ;; clear rest of this screen line
                    (out-str @T_CE)
                    (screen-start)                 ;; don't know where cursor is now
                    ((ร col =) (- end_col col))
                    (loop-when [] (<= 0 ((ร col =) (dec col)))                   ;; clear chars in "screenLines"
                        (.be @screenLines off, (byte \space))
                        ((ร @screenLinesUC[off] =) 0)
                        ((ร @screenAttrs[off] =) 0)
                        ((ร off =) (inc off))
                        (recur)
                    )
                )
                ((ร did_delete =) true)                  ;; the chars are cleared now
            )

            ((ร int off =) (+ (... @lineOffset row) start_col))
            ((ร int c =) c1)
            (loop-when-recur [#_int col start_col] (< col end_col) [(inc col)]
                (when (or (not-at? @screenLines off c) (!= (... @screenLinesUC off) (if (<= 0x80 c) c 0)) (!= (... @screenAttrs off) attr) force_next)
                    ;; The bold trick may make a single row of pixels appear in
                    ;; the next character.  When a bold character is removed, the
                    ;; next character should be redrawn too.  This happens for our
                    ;; own GUI and for some xterms.
                    (when @term_is_xterm
                        (cond (and (not-at? @screenLines off (byte \space)) (or (< HL_ALL (... @screenAttrs off)) (flag? (... @screenAttrs off) HL_BOLD)))
                        (do
                            ((ร force_next =) true)
                        )
                        :else
                        (do
                            ((ร force_next =) false)
                        ))
                    )
                    (.be @screenLines off, c)
                    (cond (<= 0x80 c)
                    (do
                        ((ร @screenLinesUC[off] =) c)
                        ((ร @screenLinesC[0][off] =) 0)
                    )
                    :else
                    (do
                        ((ร @screenLinesUC[off] =) 0)
                    ))
                    ((ร @screenAttrs[off] =) attr)
                    (if (or (not did_delete) (!= c (byte \space)))
                        (screen-char off, row, col))
                )
                ((ร off =) (inc off))
                (when (== col start_col)
                    (if did_delete
                        (ร BREAK)
                    )
                    ((ร c =) c2)
                )
            )
            (if (== end_col @Cols)
                ((ร @lineWraps[row] =) false)
            )
            (when (== row (dec @Rows))                ;; overwritten the command line
                (reset! redraw_cmdline true)
                (if (and (== c1 (byte \space)) (== c2 (byte \space)))
                    (reset! clear_cmdline false))      ;; command line has been cleared
                (if (zero? start_col)
                    (reset! mode_displayed false))     ;; mode cleared or overwritten
            )
        )
        nil
    ))

;; Check if there should be a delay.
;; Used before clearing or redrawing the screen or the command line.

(defn- #_void check-for-delay [#_boolean check_msg_scroll]
    (when (and (or @emsg_on_display (and check_msg_scroll @msg_scroll)) (not @did_wait_return))
        (out-flush)
        (ui-delay 1000, true)
        (reset! emsg_on_display false)
        (if check_msg_scroll
            (reset! msg_scroll false))
    )
    nil)

;; screen-valid -  allocate screen buffers if size changed
;;   If "doclear" is true: clear screen if it has been resized.
;;      Returns true if there is a valid screen to write to.
;;      Returns false when starting up and screen not initialized yet.

(defn- #_boolean screen-valid [#_boolean doclear]
    (screen-alloc doclear)           ;; allocate screen buffers if size changed
    (some? @screenLines))

(atom! boolean _4_entered)  ;; avoid recursiveness

;; Resize the shell to Rows and Cols.
;; Allocate screenLines[] and associated items.
;;
;; There may be some time between setting Rows and Cols and (re)allocating
;; screenLines[].  This happens when starting up and when (manually) changing
;; the shell size.  Always use screenRows and screenCols to access items
;; in screenLines[].  Use Rows and Cols for positioning text etc. where the
;; final size of the shell is needed.

(defn- #_void screen-alloc [#_boolean doclear]
    (ยง
        ((ร int[][] smco =) (ร new int[MAX_MCO][]))

        ((ร int retry_count =) 0)

;       retry:
        (loop []
            ;; Allocation of the screen buffers is done only when the size changes and
            ;; when Rows and Cols have been set and we have started doing full screen stuff.

            (if (or (and (some? @screenLines) (== @Rows @screenRows) (== @Cols @screenCols) (some? @screenLinesUC) (== @p_mco @screen_mco)) (== @Rows 0) (== @Cols 0) (and (not @full_screen) (nil? @screenLines)))
                ((ร RETURN) nil)
            )

            ;; It's possible that we produce an out-of-memory message below, which
            ;; will cause this function to be called again.  To break the loop, just return here.

            (if @_4_entered
                ((ร RETURN) nil)
            )
            (reset! _4_entered true)

            ;; Note that the window sizes are updated before reallocating the arrays,
            ;; thus we must not redraw here!

            (swap! no_redraw inc)

            (win-new-shellsize)    ;; fit the windows in the new sized shell

            (comp-col)             ;; recompute columns for shown command and ruler

            ;; We're changing the size of the screen.
            ;; - Allocate new arrays for "screenLines" and "screenAttrs".
            ;; - Move lines from the old arrays into the new arrays, clear extra
            ;;   lines (unless the screen is going to be cleared).
            ;; - Free the old arrays.
            ;;
            ;; If anything fails, make "screenLines" null, so we don't do anything!
            ;; Continuing with the old "screenLines" may result in a crash, because the size is wrong.

            (loop-when-recur [#_window_C wp @firstwin] (some? wp) [(:w_next wp)]
                ((ร wp =) (win-free-lines wp))
            )

            ((ร Bytes slis =) (Bytes. (* (inc @Rows) @Cols)))
            (dotimes [#_int i MAX_MCO]
                ((ร smco[i] =) nil)
            )
            ((ร int[] sluc =) (ร new int[((int)(@Rows + 1)) * ((int)@Cols)]))
            (dotimes [#_int i @p_mco]
                ((ร smco[i] =) (ร new int[((int)(@Rows + 1)) * ((int)@Cols)]))
            )

            ((ร int[] sats =) (ร new int[((int)(@Rows + 1)) * ((int)@Cols)]))
            ((ร int[] lofs =) (ร new int[(int)@Rows]))
            ((ร boolean[] lwrs =) (ร new boolean[(int)@Rows]))

            (loop-when-recur [#_window_C wp @firstwin] (some? wp) [(:w_next wp)]
                ((ร wp =) (win-alloc-lines wp))
            )

            (dotimes [#_int r @Rows]
                ((ร lofs[r] =) (* r @Cols))
                ((ร lwrs[r] =) false)

                ;; If the screen is not going to be cleared, copy as much as
                ;; possible from the old screen to the new one and clear the rest
                ;; (used when resizing the window at the "--more--" prompt or
                ;; when executing an external command, for the GUI).

                (when (not doclear)
                    (BFILL slis, (... lofs r), (byte \space), @Cols)
                    (AFILL sluc, (... lofs r), 0, @Cols)
                    (dotimes [#_int i @p_mco]
                        (AFILL (... smco i), (... lofs r), 0, @Cols)
                    )
                    (AFILL sats, (... lofs r), 0, @Cols)

                    ((ร int r0 =) (+ r (- @screenRows @Rows)))
                    (when (and (<= 0 r0) (some? @screenLines))
                        ((ร int off =) (... @lineOffset r0))
                        ((ร int len =) (min @screenCols @Cols))

                        ;; When switching to utf-8 don't copy characters, they
                        ;; may be invalid now.  Also when "p_mco" changes.
                        (when (and (some? @screenLinesUC) (== @p_mco @screen_mco))
                            (BCOPY slis, (... lofs r), @screenLines, off, len)
                            (ACOPY sluc, (... lofs r), @screenLinesUC, off, len)
                            (dotimes [#_int i @p_mco]
                                (ACOPY (... smco i), (... lofs r), (... @screenLinesC i), off, len)
                            )
                        )
                        (ACOPY sats, (... lofs r), @screenAttrs, off, len)
                    )
                )
            )

            ;; Use the last line of the screen for the current line.
            (reset! current_ScreenLine (.plus slis (* @Rows @Cols)))

            (reset! screenLines slis)
            (reset! screenLinesUC sluc)
            (dotimes [#_int i @p_mco]
                ((ร @screenLinesC[i] =) (... smco i))
            )
            (reset! screen_mco (int @p_mco))
            (reset! screenAttrs sats)
            (reset! lineOffset lofs)
            (reset! lineWraps lwrs)

            ;; It's important that screenRows and screenCols reflect the actual
            ;; size of screenLines[].  Set them before calling anything.
            (reset! screenRows @Rows)
            (reset! screenCols @Cols)

            (reset! must_redraw CLEAR)        ;; need to clear the screen later
            (if doclear
                (screenclear2)
            )

            (reset! _4_entered false)
            (swap! no_redraw dec)

            ;; Do not apply autocommands more than 3 times to avoid an endless loop
            ;; in case applying autocommands always changes Rows or Cols.

            (when (and (zero? @starting) (<= ((ร retry_count =) (inc retry_count)) 3))
                ;; In rare cases, autocommands may have altered Rows or Cols,
                ;; jump back to check if we need to allocate the screen again.
                (ร CONTINUE retry)
            )

            (ร BREAK)
            (recur)
        )
        nil
    ))

(defn- #_void screen-clear []
    (check-for-delay false)
    (screen-alloc false)             ;; allocate screen buffers if size changed
    (screenclear2)                 ;; clear the screen
    nil)

(defn- #_void screenclear2 []
    (ยง
        (if (or (== @starting NO_SCREEN) (nil? @screenLines))
            ((ร RETURN) nil)
        )

        (reset! screen_attr -1)               ;; force setting the Normal colors
        (screen-stop-highlight)        ;; don't want highlighting here

        ;; blank out "screenLines"
        (dotimes [#_int i @Rows]
            (lineclear (... @lineOffset i), @Cols)
            ((ร @lineWraps[i] =) false)
        )

        (cond (can-clear @T_CL)
        (do
            (out-str @T_CL)              ;; clear the display
            (reset! clear_cmdline false)
            (reset! mode_displayed false)
        )
        :else
        (do
            ;; can't clear the screen, mark all chars with invalid attributes
            (dotimes [#_int i @Rows]
                (lineinvalid (... @lineOffset i), @Cols)
            )
            (reset! clear_cmdline true)
        ))

        (reset! screen_cleared TRUE)          ;; can use contents of "screenLines" now

        (win-rest-invalid @firstwin)
        (reset! redraw_cmdline true)
        (if (== @must_redraw CLEAR)       ;; no need to clear again
            (reset! must_redraw NOT_VALID))
        (compute-cmdrow)
        (reset! msg_row @cmdline_row)          ;; put cursor on last line for messages
        (reset! msg_col 0)
        (screen-start)                 ;; don't know where cursor is now
        (reset! msg_scrolled 0)               ;; can't scroll back
        (reset! msg_didany false)
        (reset! msg_didout false)
        nil
    ))

;; Clear one line in "screenLines".

(defn- #_void lineclear [#_int off, #_int width]
    (BFILL @screenLines, off, (byte \space), width)
    (AFILL @screenLinesUC, off, 0, width)
    (AFILL @screenAttrs, off, 0, width)
    nil)

;; Mark one line in "screenLines" invalid by setting the attributes to an invalid value.

(defn- #_void lineinvalid [#_int off, #_int width]
    (AFILL @screenAttrs, off, -1, width)
    nil)

;; Copy part of a screenline for vertically split window "win".

(defn- #_void linecopy [#_int to, #_int from, #_window_C win]
    (let [#_int off_to (+ (... @lineOffset to) (:w_wincol win)) #_int off_from (+ (... @lineOffset from) (:w_wincol win)) width (:w_width win)]
        (BCOPY @screenLines, off_to, @screenLines, off_from, width)
        (ACOPY @screenLinesUC, off_to, @screenLinesUC, off_from, width)
        (dotimes [#_int i @p_mco]
            (ACOPY (... @screenLinesC i), off_to, (... @screenLinesC i), off_from, width))
        (ACOPY @screenAttrs, off_to, @screenAttrs, off_from, width))
    nil)

;; Return true if clearing with term string "p" would work.
;; It can't work when the string is empty or it won't set the right background.

(defn- #_boolean can-clear [#_Bytes p]
    (and (non-eos? p) (or (<= @t_colors 1) (zero? @cterm_normal_bg_color) (non-eos? @T_UT))))

;; Reset cursor position.  Use whenever cursor was moved because of outputting
;; something directly to the screen (shell commands) or a terminal control code.

(defn- #_void screen-start []
    (reset! screen_cur_row (reset! screen_cur_col 9999))
    nil)

;; Move the cursor to position "row","col" in the screen.
;; This tries to find the most efficient way to move, minimizing the number of
;; characters sent to the terminal.

(final int
    GOTO_COST  7,   ;; assume a term-windgoto() takes about 7 chars
    HIGHL_COST 5)   ;; assume unhighlight takes 5 chars

(final int
    PLAN_LE    1,
    PLAN_CR    2,
    PLAN_NL    3,
    PLAN_WRITE 4)

(defn- #_void windgoto [#_int row, #_int col]
    (when (and (some? @screenLines) (or (!= col @screen_cur_col) (!= row @screen_cur_row)))
        ;; Check for valid position.
        (let [row (max 0 row) ;; window without text lines?
              row (min row (dec @screenRows))
              col (min col (dec @screenCols))
              ;; check if no cursor movement is allowed in highlight mode
              #_int noinvcurs (if (and (non-zero? @screen_attr) (eos? @T_MS)) HIGHL_COST 0)
              #_int goto_cost (+ GOTO_COST noinvcurs)
              ;; Plan how to do the positioning:
              ;;
              ;; 1. Use CR to move it to column 0, same row.
              ;; 2. Use T_LE to move it a few columns to the left.
              ;; 3. Use NL to move a few lines down, column 0.
              ;; 4. Move a few columns to the right with T_ND or by writing chars.
              ;;
              ;; Don't do this if the cursor went beyond the last column,
              ;; the cursor position is unknown then (some terminals wrap, some don't).
              ;;
              ;; First check if the highlighting attributes allow us to write
              ;; characters to move the cursor to the right.
              #_int cost
                (cond (and (<= @screen_cur_row row) (< @screen_cur_col @Cols))
                (let [#_int attr @screen_attr
                      ;; If the cursor is in the same row, bigger col, we can use CR or T_LE.
                      [#_Bytes bs #_int plan #_int wouldbe_col cost attr]
                        (cond (and (== row @screen_cur_row) (< col @screen_cur_col))
                            ;; "le" is preferred over "bc", because "bc" is obsolete ;; "cursor left" ;; "backspace character (old)
                            (let [bs (if (non-eos? @T_LE) @T_LE @T_BC)
                                  cost (if (non-eos? bs) (* (- @screen_cur_col col) (STRLEN bs)) 999)
                                  ;; using CR is less characters ;; CR is just one character
                                  [plan wouldbe_col cost] (if (< (inc col) cost) [PLAN_CR 0 1] [PLAN_LE col cost])
                                  ;; if ... stop highlighting
                                  [cost attr] (if (non-zero? noinvcurs) [(+ cost noinvcurs) 0] [cost attr])]
                                [bs plan wouldbe_col cost attr])
                        ;; If the cursor is above where we want to be, we can use CR LF.
                        (< @screen_cur_row row)
                            (let [cost (* (- row @screen_cur_row) 2) ;; CR LF
                                  ;; if ... stop highlighting
                                  [cost attr] (if (non-zero? noinvcurs) [(+ cost noinvcurs) 0] [cost attr])]
                                [nil PLAN_NL 0 cost attr])
                        ;; If the cursor is in the same row, smaller col, just use write.
                        :else
                            [nil PLAN_WRITE @screen_cur_col 0 attr])
                      ;; Check if any characters that need to be written have the correct attributes.  Also avoid UTF-8 characters.
                      cost (let-when [#_int i (- col wouldbe_col) cost (if (< 0 i) (+ cost i) cost)] (and (< cost goto_cost) (< 0 i)) => cost
                            ;; Check if the attributes are correct without additionally stopping highlighting.
                            (let [[#_int ai i] (loop-when [ai (+ (... @lineOffset row) wouldbe_col) i i] (< 0 i) => [ai i]
                                                   (recur-if (== (... @screenAttrs ai) attr) [(inc ai) (dec i)] => [(inc ai) i]))
                                  [i cost] (if (non-zero? i)
                                                (let [ai (dec ai) ;; Try if it works when highlighting is stopped here.
                                                    [i cost] (if (zero? (... @screenAttrs ai))
                                                                    (let [i (loop-when [ai ai i i] (< 0 i) => i
                                                                                (recur-if (== (... @screenAttrs ai) 0) [(inc ai) (dec i)] => i))] ;; => (inc ai)
                                                                        [i (+ cost noinvcurs)])
                                                                    [i cost])]
                                                    [i (if (non-zero? i) 999 cost)]) ;; different attributes, don't do it
                                                [i cost])]
                                ;; Don't use an UTF-8 char for positioning, it's slow.
                                (loop-when [cost cost #_int i wouldbe_col] (< i col) => cost
                                    (recur-if (== (... @screenLinesUC (+ (... @lineOffset row) i)) 0) [cost (inc i)] => 999))
                            ))]
                    ;; We can do it without term-windgoto()!
                    (when (< cost goto_cost)
                        (cond (== plan PLAN_LE)
                        (do
                            (when (non-zero? noinvcurs) (screen-stop-highlight))
                            (while (< col @screen_cur_col) (out-str bs) (swap! screen_cur_col dec))
                        )
                        (== plan PLAN_CR)
                        (do
                            (when (non-zero? noinvcurs) (screen-stop-highlight))
                            (out-char (byte \return))
                            (reset! screen_cur_col 0)
                        )
                        (== plan PLAN_NL)
                        (do
                            (when (non-zero? noinvcurs) (screen-stop-highlight))
                            (while (< @screen_cur_row row) (out-char (byte \newline)) (swap! screen_cur_row inc))
                            (reset! screen_cur_col 0)
                        ))
                        (let-when [#_int i (- col @screen_cur_col)] (< 0 i)
                            ;; Use cursor-right if it's one character only.
                            ;; Avoids removing a line of pixels from the last bold char, when using the bold trick in the GUI.
                            (if (and (non-eos? @T_ND) (eos? @T_ND 1))
                                (loop-when-recur i (< 0 i) (dec i) (out-char (.at @T_ND 0)))
                                (loop-when-recur [#_int off (+ (... @lineOffset row) @screen_cur_col) i i] (< 0 i) [(inc off) (dec i)]
                                    (when (!= (... @screenAttrs off) @screen_attr) (screen-stop-highlight))
                                    (out-flush-check)
                                    (out-char (.at @screenLines off))
                                ))
                        ))
                    cost
                )
                :else 999)]
            (when (<= goto_cost cost)
                (when (non-zero? noinvcurs) (screen-stop-highlight))
                (if (and (== row @screen_cur_row) (< @screen_cur_col col) (non-eos? @T_CRI))
                    (term-cursor-right (- col @screen_cur_col))
                    (term-windgoto row, col)))
            (reset! screen_cur_row row)
            (reset! screen_cur_col col)
        ))
    nil)

;; Set cursor to its position in the current window.

(defn- #_void setcursor []
    (when (redrawing)
        (swap! curwin validate-cursor)
        (windgoto (+ (:w_winrow @curwin) (:w_wrow @curwin)), (+ (:w_wincol @curwin) (:w_wcol @curwin))))
    nil)

;; Insert 'line_count' lines at 'row' in window 'win'.
;; if 'invalid' is true the win.w_lines[].wl_lnum is invalidated.
;; if 'mayclear' is true the screen will be cleared if it is faster than scrolling.
;; Returns false if the lines are not inserted, true for success.

(defn- #_boolean win-ins-lines [#_window_C win, #_int row, #_int line_count, #_boolean invalid, #_boolean mayclear]
    (ยง
        (if invalid
            ((ร win =) (assoc win :w_lines_valid 0))
        )

        (if (< (:w_height win) 5)
            ((ร RETURN) false)
        )

        ((ร line_count =) (min line_count (- (:w_height win) row)))

        ((ร maybean maybe =) (win-do-lines win, row, line_count, mayclear, false))
        (if (!= maybe MAYBE)
            ((ร RETURN) (!= maybe FALSE))
        )

        ;; If there is a next window or a status line, we first try to delete the
        ;; lines at the bottom to avoid messing what is after the window.
        ;; If this fails and there are following windows, don't do anything to avoid
        ;; messing up those windows, better just redraw.

        ((ร boolean did_delete =) false)
        (when (or (some? (:w_next win)) (non-zero? (:w_status_height win)))
            (cond (screen-del-lines 0, (- (+ (:w_winrow win) (:w_height win)) line_count), line_count, @Rows, false, nil)
            (do
                ((ร did_delete =) true)
            )
            (some? (:w_next win))
            (do
                ((ร RETURN) false)
            ))
        )

        ;; if no lines deleted, blank the lines that will end up below the window

        (when (not did_delete)
            ((ร win =) (assoc win :w_redr_status true))
            (reset! redraw_cmdline true)
            ((ร int nextrow =) (+ (:w_winrow win) (:w_height win) (:w_status_height win)))
            ((ร int lastrow =) (min (+ nextrow line_count) @Rows))
            (screen-fill (- nextrow line_count), (- lastrow line_count), (:w_wincol win), (+ (:w_wincol win) (:w_width win)), (byte \space), (byte \space), 0)
        )

        (when (not (screen-ins-lines 0, (+ (:w_winrow win) row), line_count, @Rows, nil))
            ;; deletion will have messed up other windows
            (when did_delete
                ((ร win =) (assoc win :w_redr_status true))
                (win-rest-invalid (:w_next win))
            )
            ((ร RETURN) false)
        )

        true
    ))

;; Delete "line_count" window lines at "row" in window "win".
;; If "invalid" is true curwin.w_lines[] is invalidated.
;; If "mayclear" is true the screen will be cleared if it is faster than scrolling
;; Return true for success, false if the lines are not deleted.

(defn- #_boolean win-del-lines [#_window_C win, #_int row, #_int line_count, #_boolean invalid, #_boolean mayclear]
    (ยง
        (if invalid
            ((ร win =) (assoc win :w_lines_valid 0))
        )

        ((ร line_count =) (min line_count (- (:w_height win) row)))

        ((ร maybean maybe =) (win-do-lines win, row, line_count, mayclear, true))
        (if (!= maybe MAYBE)
            ((ร RETURN) (!= maybe FALSE))
        )

        (if (not (screen-del-lines 0, (+ (:w_winrow win) row), line_count, @Rows, false, nil))
            ((ร RETURN) false)
        )

        ;; If there are windows or status lines below, try to put them at the
        ;; correct place.  If we can't do that, they have to be redrawn.

        (cond (or (some? (:w_next win)) (non-zero? (:w_status_height win)) (< @cmdline_row (dec @Rows)))
        (do
            (when (not (screen-ins-lines 0, (- (+ (:w_winrow win) (:w_height win)) line_count), line_count, @Rows, nil))
                ((ร win =) (assoc win :w_redr_status true))
                (win-rest-invalid (:w_next win))
            )
        )
        ;; If this is the last window and there is no status line, redraw the command line later.
        :else
        (do
            (reset! redraw_cmdline true)
        ))

        true
    ))

;; Common code for win-ins-lines() and win-del-lines().
;; Returns true or false when the work has been done.
;; Returns MAYBE when not finished yet.

(defn- #_maybean win-do-lines [#_window_C win, #_int row, #_int line_count, #_boolean mayclear, #_boolean del]
    (cond (or (not (redrawing)) (<= line_count 0))
        FALSE
    (and mayclear (< (- @Rows line_count) 5) (== (:w_width win) @Cols)) ;; only a few lines left: redraw is faster
    (do
        (screen-clear)      ;; will set win.w_lines_valid to 0
        FALSE
    )
    (<= (:w_height win) (+ row line_count)) ;; delete all remaining lines
    (do
        (screen-fill (+ (:w_winrow win) row), (+ (:w_winrow win) (:w_height win)), (:w_wincol win), (+ (:w_wincol win) (:w_width win)), (byte \space), (byte \space), 0)
        TRUE
    )
    :else
    (do ;; When scrolling, the message on the command line should be cleared, otherwise it will stay there forever.
        (reset! clear_cmdline true)
        ;; If the terminal can set a scroll region, use that.  Always do this in a vertically split window.
        ;; This will redraw from screenLines[] when t_CV isn't defined.  That's faster than using win-line().
        ;; Don't use a scroll region when we are going to redraw the text.
        (cond (or @scroll_region (!= (:w_width win) @Cols))
        (do
            (when (and @scroll_region (or (== (:w_width win) @Cols) (non-eos? @T_CSV)))
                (scroll-region-set win, row))
            (let [#_boolean r (if del
                        (screen-del-lines (+ (:w_winrow win) row), 0, line_count, (- (:w_height win) row), false, win)
                        (screen-ins-lines (+ (:w_winrow win) row), 0, line_count, (- (:w_height win) row), win)
                    )]
                (when (and @scroll_region (or (== (:w_width win) @Cols) (non-eos? @T_CSV)))
                    (scroll-region-reset))
                (if r TRUE FALSE)
            ))
        (some? (:w_next win))
            FALSE
        :else
            MAYBE
        ))
    ))

;; window 'win' and everything after it is messed up, mark it for redraw

(defn- #_void win-rest-invalid [#_window_C win]
    (ยง
        (loop-when [] (some? win)
            ((ร win =) (redraw-later win, NOT_VALID))
            ((ร win =) (assoc win :w_redr_status true))
            ((ร win =) (:w_next win))
            (recur)
        )
        (reset! redraw_cmdline true)
        nil
    ))

;; The rest of the routines in this file perform screen manipulations.
;; The given operation is performed physically on the screen.
;; The corresponding change is also made to the internal screen image.
;; In this way, the editor anticipates the effect of editing changes
;; on the appearance of the screen.
;; That way, when we call screenupdate a complete redraw isn't usually necessary.
;; Another advantage is that we can keep adding code to anticipate screen changes,
;; and in the meantime, everything still works.

;; types for inserting or deleting lines

(final int USE_T_CAL   1)
(final int USE_T_CDL   2)
(final int USE_T_AL    3)
(final int USE_T_CE    4)
(final int USE_T_DL    5)
(final int USE_T_SR    6)
(final int USE_NL      7)
(final int USE_T_CD    8)
(final int USE_REDRAW  9)

;; insert lines on the screen and update screenLines[]
;; 'end' is the line after the scrolled part.  Normally it is Rows.
;; When scrolling region used 'off' is the offset from the top for the region.
;; 'row' and 'end' are relative to the start of the region.
;;
;; return false for failure, true for success.

(defn- #_boolean screen-ins-lines [#_int off, #_int row, #_int line_count, #_int end, #_window_C win]
    ;; win: null or window to use width from
    (ยง
        ((ร boolean can_ce =) (can-clear @T_CE))

        ;; FAIL if
        ;; - there is no valid screen
        ;; - the screen has to be redrawn completely
        ;; - the line count is less than one
        ;; - the line count is more than 'ttyscroll'

        (when (or (not (screen-valid true)) (<= line_count 0) (< @p_ttyscroll line_count))
            ((ร RETURN) false)
        )

        ;; There are seven ways to insert lines:
        ;;
        ;; 0. When in a vertically split window and t_CV isn't set, redraw the characters from screenLines[].
        ;; 1. Use T_CD (clear to end of display) if it exists and the result of the insert is just empty lines.
        ;; 2. Use T_CAL (insert multiple lines) if it exists and T_AL is not present or line_count > 1.
        ;;    It looks better if we do all the inserts at once.
        ;; 3. Use T_CDL (delete multiple lines) if it exists and the result of the
        ;;    insert is just empty lines and T_CE is not present or line_count > 1.
        ;; 4. Use T_AL (insert line) if it exists.
        ;; 5. Use T_CE (erase line) if it exists and the result of the insert is just empty lines.
        ;; 6. Use T_DL (delete line) if it exists and the result of the insert is just empty lines.
        ;; 7. Use T_SR (scroll reverse) if it exists and inserting at row 0
        ;;    and the 'da' flag is not set or we have clear line capability.
        ;; 8. Redraw the characters from screenLines[].
        ;;
        ;; Careful: In a hpterm scroll reverse doesn't work as expected, it moves
        ;; the scrollbar for the window.  It does have insert line, use that if it exists.

        ((ร boolean result_empty =) (<= end (+ row line_count)))

        (ร int type)
        (cond (and (some? win) (!= (:w_width win) @Cols) (eos? @T_CSV))
        (do
            ((ร type =) USE_REDRAW)
        )
        (and (can-clear @T_CD) result_empty)
        (do
            ((ร type =) USE_T_CD)
        )
        (and (non-eos? @T_CAL) (or (< 1 line_count) (eos? @T_AL)))
        (do
            ((ร type =) USE_T_CAL)
        )
        (and (non-eos? @T_CDL) result_empty (or (< 1 line_count) (not can_ce)))
        (do
            ((ร type =) USE_T_CDL)
        )
        (non-eos? @T_AL)
        (do
            ((ร type =) USE_T_AL)
        )
        (and can_ce result_empty)
        (do
            ((ร type =) USE_T_CE)
        )
        (and (non-eos? @T_DL) result_empty)
        (do
            ((ร type =) USE_T_DL)
        )
        (and (non-eos? @T_SR) (zero? row) (or (eos? @T_DA) can_ce))
        (do
            ((ร type =) USE_T_SR)
        )
        :else
        (do
            ((ร RETURN) false)
        ))

        ;; For clearing the lines screen-del-lines() is used.  This will also take
        ;; care of t_db if necessary.

        (if (any == type USE_T_CD USE_T_CDL USE_T_CE USE_T_DL)
            ((ร RETURN) (screen-del-lines off, row, line_count, end, false, win))
        )

        ;; If text is retained below the screen, first clear or delete as many
        ;; lines at the bottom of the window as are about to be inserted so that
        ;; the deleted lines won't later surface during a screen-del-lines.

        (when (non-eos? @T_DB)
            (screen-del-lines off, (- end line_count), line_count, end, false, win))

        ((ร int cursor_row =) (+ row off))

        ;; Shift lineOffset[] line_count down to reflect the inserted lines.
        ;; Clear the inserted lines in screenLines[].

        ((ร row =) (+ row off))
        ((ร end =) (+ end off))
        (dotimes [#_int i line_count]
            (cond (and (some? win) (!= (:w_width win) @Cols))
            (do
                ;; need to copy part of a line
                ((ร int j =) (- end 1 i))
                (loop-when [] (<= row ((ร j =) (- j line_count)))
                    (linecopy (+ j line_count), j, win)
                    (recur)
                )
                ((ร j =) (+ j line_count))
                (if (can-clear (u8 " "))
                    (lineclear (+ (... @lineOffset j) (:w_wincol win)), (:w_width win))
                    (lineinvalid (+ (... @lineOffset j) (:w_wincol win)), (:w_width win)))
                ((ร @lineWraps[j] =) false)
            )
            :else
            (do
                ((ร int j =) (- end 1 i))
                ((ร int temp =) (... @lineOffset j))
                (loop-when [] (<= row ((ร j =) (- j line_count)))
                    ((ร @lineOffset[j + line_count] =) (... @lineOffset j))
                    ((ร @lineWraps[j + line_count] =) (... @lineWraps j))
                    (recur)
                )
                ((ร @lineOffset[j + line_count] =) temp)
                ((ร @lineWraps[j + line_count] =) false)
                (if (can-clear (u8 " "))
                    (lineclear temp, @Cols)
                    (lineinvalid temp, @Cols))
            ))
        )

        (screen-stop-highlight)
        (windgoto cursor_row, 0)

        ;; redraw the characters
        (cond (== type USE_REDRAW)
        (do
            (redraw-block row, end, win)
        )
        (== type USE_T_CAL)
        (do
            (term-append-lines line_count)
            (screen-start)         ;; don't know where cursor is now
        )
        :else
        (do
            (dotimes [#_int i line_count]
                (cond (== type USE_T_AL)
                (do
                    (if (and (non-zero? i) (non-zero? cursor_row))
                        (windgoto cursor_row, 0))
                    (out-str @T_AL)
                )
                :else ;; type == USE_T_SR
                (do
                    (out-str @T_SR)
                ))
                (screen-start)         ;; don't know where cursor is now
            )
        ))

        ;; With scroll-reverse and 'da' flag set we need to clear the lines that
        ;; have been scrolled down into the region.

        (when (and (== type USE_T_SR) (non-eos? @T_DA))
            (dotimes [#_int i line_count]
                (windgoto (+ off i), 0)
                (out-str @T_CE)
                (screen-start)         ;; don't know where cursor is now
            )
        )

        true
    ))

;; delete lines on the screen and update screenLines[]
;; 'end' is the line after the scrolled part.  Normally it is Rows.
;; When scrolling region used 'off' is the offset from the top for the region.
;; 'row' and 'end' are relative to the start of the region.
;;
;; Return true for success, false if the lines are not deleted.

(defn- #_boolean screen-del-lines [#_int off, #_int row, #_int line_count, #_int end, #_boolean force, #_window_C win]
    ;; force: even when line_count > p_ttyscroll
    ;; win: null or window to use width from
    (ยง
        ;; FAIL if
        ;; - there is no valid screen
        ;; - the screen has to be redrawn completely
        ;; - the line count is less than one
        ;; - the line count is more than 'ttyscroll'

        (if (or (not (screen-valid true)) (<= line_count 0) (and (not force) (< @p_ttyscroll line_count)))
            ((ร RETURN) false)
        )

        ;; Check if the rest of the current region will become empty.

        ((ร boolean result_empty =) (<= end (+ row line_count)))

        ;; We can delete lines only when 'db' flag not set or when 'ce' option available.

        ((ร boolean can_delete =) (or (eos? @T_DB) (can-clear @T_CE)))

        (ร int type)

        ;; There are six ways to delete lines:
        ;;
        ;; 0. When in a vertically split window and t_CV isn't set, redraw the characters from screenLines[].
        ;; 1. Use T_CD if it exists and the result is empty.
        ;; 2. Use newlines if row == 0 and count == 1 or T_CDL does not exist.
        ;; 3. Use T_CDL (delete multiple lines) if it exists and line_count > 1 or none of the other ways work.
        ;; 4. Use T_CE (erase line) if the result is empty.
        ;; 5. Use T_DL (delete line) if it exists.
        ;; 6. Redraw the characters from screenLines[].

        (cond (and (some? win) (!= (:w_width win) @Cols) (eos? @T_CSV))
        (do
            ((ร type =) USE_REDRAW)
        )
        (and (can-clear @T_CD) result_empty)
        (do
            ((ร type =) USE_T_CD)
        )
        (and (zero? row) (or (== line_count 1) (eos? @T_CDL)))
        (do
            ((ร type =) USE_NL)
        )
        (and (non-eos? @T_CDL) (< 1 line_count) can_delete)
        (do
            ((ร type =) USE_T_CDL)
        )
        (and (can-clear @T_CE) result_empty (or (nil? win) (== (:w_width win) @Cols)))
        (do
            ((ร type =) USE_T_CE)
        )
        (and (non-eos? @T_DL) can_delete)
        (do
            ((ร type =) USE_T_DL)
        )
        (and (non-eos? @T_CDL) can_delete)
        (do
            ((ร type =) USE_T_CDL)
        )
        :else
        (do
            ((ร RETURN) false)
        ))

        ((ร int cursor_row =) (+ row off))
        ((ร int cursor_end =) (+ end off))

        ;; Now shift lineOffset[] line_count up to reflect the deleted lines.
        ;; Clear the inserted lines in screenLines[].

        ((ร row =) (+ row off))
        ((ร end =) (+ end off))
        (dotimes [#_int i line_count]
            (cond (and (some? win) (!= (:w_width win) @Cols))
            (do
                ;; need to copy part of a line
                ((ร int j =) (+ row i))
                (loop-when [] (<= ((ร j =) (+ j line_count)) (dec end))
                    (linecopy (- j line_count), j, win)
                    (recur)
                )
                ((ร j =) (- j line_count))
                (if (can-clear (u8 " "))
                    (lineclear (+ (... @lineOffset j) (:w_wincol win)), (:w_width win))
                    (lineinvalid (+ (... @lineOffset j) (:w_wincol win)), (:w_width win)))
                ((ร @lineWraps[j] =) false)
            )
            :else
            (do
                ;; whole width, moving the line pointers is faster
                ((ร int j =) (+ row i))
                ((ร int temp =) (... @lineOffset j))
                (loop-when [] (<= ((ร j =) (+ j line_count)) (dec end))
                    ((ร @lineOffset[j - line_count] =) (... @lineOffset j))
                    ((ร @lineWraps[j - line_count] =) (... @lineWraps j))
                    (recur)
                )
                ((ร @lineOffset[j - line_count] =) temp)
                ((ร @lineWraps[j - line_count] =) false)
                (if (can-clear (u8 " "))
                    (lineclear temp, @Cols)
                    (lineinvalid temp, @Cols))
            ))
        )

        (screen-stop-highlight)

        (cond (== type USE_REDRAW)                 ;; redraw the characters
        (do
            (redraw-block row, end, win)
        )
        (== type USE_T_CD)              ;; delete the lines
        (do
            (windgoto cursor_row, 0)
            (out-str @T_CD)
            (screen-start)                      ;; don't know where cursor is now
        )
        (== type USE_T_CDL)
        (do
            (windgoto cursor_row, 0)
            (term-delete-lines line_count)
            (screen-start)                      ;; don't know where cursor is now
        )

        ;; Deleting lines at top of the screen or scroll region: Just scroll
        ;; the whole screen (scroll region) up by outputting newlines on the last line.

        (== type USE_NL)
        (do
            (windgoto (dec cursor_end), 0)
            (loop-when-recur [#_int i (dec line_count)] (<= 0 i) [(dec i)]
                (out-char (byte \newline))           ;; cursor will remain on same line
            )
        )
        :else
        (do
            (loop-when-recur [#_int i (dec line_count)] (<= 0 i) [(dec i)]
                (cond (== type USE_T_DL)
                (do
                    (windgoto cursor_row, 0)
                    (out-str @T_DL)             ;; delete a line
                )
                :else ;; type == USE_T_CE
                (do
                    (windgoto (+ cursor_row i), 0)
                    (out-str @T_CE)             ;; erase a line
                ))
                (screen-start)                  ;; don't know where cursor is now
            )
        ))

        ;; If the 'db' flag is set, we need to clear the lines that have been
        ;; scrolled up at the bottom of the region.

        (when (and (non-eos? @T_DB) (any == type USE_T_DL USE_T_CDL))
            (loop-when-recur [#_int i line_count] (< 0 i) [(dec i)]
                (windgoto (- cursor_end i), 0)
                (out-str @T_CE)                 ;; erase a line
                (screen-start)                  ;; don't know where cursor is now
            )
        )

        true
    ))

;; Show the current mode and ruler.
;;
;; If clear_cmdline is true, clear the rest of the cmdline.
;; If clear_cmdline is false there may be a message there that needs to be cleared only if a mode is shown.
;;
;; Return the length of the message (0 if no message).

(defn- #_int showmode []
    (let-when [#_boolean do_mode (and @p_smd (or (flag? @State INSERT) (!= @restart_edit 0) @VIsual_active))
          #_int length
            (cond (and (not do_mode) (not @Recording))
                ;; Clear the whole command line.  Will reset "clear_cmdline".
                (do (when @clear_cmdline (msg-clr-cmdline)) 0)
            (or (not (redrawing)) (and (char-avail) (not @keyTyped)))
                ;; Don't show mode right now, when not redrawing or inside a mapping.
                ;; Call char-avail() only when we are going to show something, because it takes a bit of time.
                (do (reset! redraw_cmdline true) nil) ;; show mode later
            :else
                (let [#_boolean nwr_save @need_wait_return
                      ;; wait a bit before overwriting an important message
                      _ (check-for-delay false)
                      ;; if the cmdline is more than one line high, erase top lines
                      #_boolean need_clear @clear_cmdline]
                    (when (and @clear_cmdline (< @cmdline_row (dec @Rows)))
                        (msg-clr-cmdline))                  ;; will reset clear_cmdline
                    ;; Position on the last line in the window, column 0.
                    (msg-pos-mode)
                    (cursor-off)
                    (let [#_int attr (hl-attr HLF_CM)]                 ;; Highlight mode
                        (when do_mode
                            (msg-puts-attr (u8 "--"), attr)
                            (cond
                                (flag? @State VREPLACE_FLAG) (msg-puts-attr (u8 " VREPLACE"), attr)
                                (flag? @State REPLACE_FLAG)  (msg-puts-attr (u8 " REPLACE"), attr)
                                (flag? @State INSERT)        (msg-puts-attr (u8 " INSERT"), attr)
                                (== @restart_edit (byte \I)) (msg-puts-attr (u8 " (insert)"), attr)
                                (== @restart_edit (byte \R)) (msg-puts-attr (u8 " (replace)"), attr)
                                (== @restart_edit (byte \V)) (msg-puts-attr (u8 " (vreplace)"), attr)
                            )
                            (when (and (flag? @State INSERT) @p_paste)
                                (msg-puts-attr (u8 " (paste)"), attr))
                            (when @VIsual_active
                                ;; Don't concatenate separate words to avoid translation problems.
                                (-> (condp == (+ (if @VIsual_select 4 0) (if (== @VIsual_mode Ctrl_V) 2 0) (if (== @VIsual_mode (byte \V)) 1 0))
                                        0 (u8 " VISUAL")
                                        1 (u8 " VISUAL LINE")
                                        2 (u8 " VISUAL BLOCK")
                                        4 (u8 " SELECT")
                                        5 (u8 " SELECT LINE")
                                        6 (u8 " SELECT BLOCK"))
                                    (msg-puts-attr attr))
                            )
                            (msg-puts-attr (u8 " --"), attr)
                        )
                        (when @Recording
                            (msg-puts-attr (u8 "recording"), attr)
                        ))
                    (reset! mode_displayed true)
                    (when (or need_clear do_mode @Recording @clear_cmdline)
                        (msg-clr-eos))
                    (reset! msg_didout false)             ;; overwrite this message
                    (let [length @msg_col]
                        (reset! msg_col 0)
                        (reset! need_wait_return nwr_save)    ;; never ask for hit-return for this
                        length
                    ))
            )] (some? length) => 0
        ;; In Visual mode the size of the selected area must be redrawn.
        (when @VIsual_active (clear-showcmd @curwin))
        ;; If the last window has no status line,
        ;; the ruler is after the mode message and must be redrawn.
        (when (and (redrawing) (zero? (:w_status_height @lastwin)))
            (swap! lastwin win-redr-ruler true))
        (reset! redraw_cmdline false)
        (reset! clear_cmdline false)
        length
    ))

;; Position for a mode message.

(defn- #_void msg-pos-mode []
    (reset! msg_col 0)
    (reset! msg_row (dec @Rows))
    nil)

;; Delete mode message.  Used when ESC is typed which is expected to end
;; Insert mode (but Insert mode didn't end yet!).
;; Caller should check "mode_displayed".

(defn- #_void unshowmode [#_boolean force]
    ;; Don't delete it right now, when not redrawing or inside a mapping.
    (if (and (redrawing) (or force (not (char-avail)) @keyTyped))
        (do (msg-pos-mode)
            (when @Recording
                (msg-puts-attr (u8 "recording"), (hl-attr HLF_CM)))
            (msg-clr-eos))
        (reset! redraw_cmdline true))       ;; delete mode later
    nil)

;; Get the character to use in a status line.  Get its attributes in "*attr".

(defn- #_int fillchar-status [#_int' a'attr, #_boolean is_curwin]
    (let [#_int fill (if is_curwin
                (do (reset! a'attr (hl-attr HLF_S)) @fill_stl)
                (do (reset! a'attr (hl-attr HLF_SNC)) @fill_stlnc)
            )]
        ;; Use fill when there is highlighting, and highlighting of current window differs, or the fillchars differ, or this is not the current window.
        (if (and (non-zero? @a'attr) (or (!= (hl-attr HLF_S) (hl-attr HLF_SNC)) (not is_curwin) (== @firstwin @lastwin) (!= @fill_stl @fill_stlnc)))
            fill
            (if is_curwin (byte \^) (byte \=)))
    ))

;; Get the character to use in a separator between vertically split windows.
;; Get its attributes in "*attr".

(defn- #_int fillchar-vsep [#_int' a'attr]
    (reset! a'attr (hl-attr HLF_C))
    (if (and (zero? @a'attr) (== @fill_vert (byte \space))) (byte \|) @fill_vert))

;; Return true if redrawing should currently be done.

(defn- #_boolean redrawing []
    (and (zero? @no_redraw) (not (and @p_lz (char-avail) (not @keyTyped) (not @do_redraw)))))

;; Return true if printing messages should currently be done.

(defn- #_boolean messaging []
    (not (and @p_lz (char-avail) (not @keyTyped))))

;; Show current status info in ruler and various other places.
;; If "always" is false, only show ruler if position has changed.

(defn- #_window_C showruler [#_window_C win, #_boolean always]
    (if (or always (redrawing)) (win-redr-ruler win, always) win))

(defn- #_window_C win-redr-ruler [#_window_C win, #_boolean always]
    ;; If 'ruler' is off or redrawing is disabled, don't do anything.
    ;; Also check if cursor.lnum is valid, since win-redr-ruler() may be
    ;; called after deleting lines, before cursor.lnum is corrected.
    (let-when [lmax (line-count @curbuf)] (and @p_ru (<= (:lnum (:w_cursor win)) lmax)) => win
        ;; Check if not in Insert mode and the line is empty (will show "0-1").
        (let-when [#_boolean empty (and (non-flag? @State INSERT) (eos? (ml-get (:lnum (:w_cursor win)))))
              win (validate-virtcol win)
              ;; Only draw the ruler when something changed.
              ? (or @redraw_cmdline always (!= (:w_ru_cursor win) (:w_cursor win))
                                           (!= (:w_ru_virtcol win) (:w_virtcol win))
                                           (!= (:w_ru_topline win) (:w_topline win))
                                           (!= (:w_ru_line_count win) lmax)
                                           (!= (:w_ru_empty win) empty)
                )] ? => win

            (cursor-off)
            (let [a'attr (atom (int)) [row fillchar off width]
                    (if (non-zero? (:w_status_height win))
                        [(+ (:w_winrow win) (:w_height win)) (fillchar-status a'attr, (== win @curwin)) (:w_wincol win) (:w_width win)]
                        [(dec @Rows) (do (reset! a'attr 0) (byte \space)) 0 @Cols])
                  #_final #_int RULER_BUF_LEN 70 #_Bytes s (Bytes. RULER_BUF_LEN)
;%%               _ (vim_snprintf s, RULER_BUF_LEN, (u8 "%ld,"), (if (flag? (:ml_flags (:b_ml @curbuf)) ML_EMPTY) 0 (:lnum (:w_cursor win))))
                  #_int n (STRLEN s)
                  _ (col-print (.plus s n), (- RULER_BUF_LEN n), (if empty 0 (inc (:col (:w_cursor win)))), (inc (:w_virtcol win)))
                  ;; Add a "50%" if there is room for it.
                  #_int n (STRLEN s)
                  _ (get-rel-pos win, (.plus s (inc n)), (- RULER_BUF_LEN (inc n)))
                  ;; Don't print at the last column of the last line (scrolls the screen up on some terminals).
                  #_int e (+ n (mb-string2cells (.plus s (inc n))) (if (zero? (:w_status_height win)) 1 0))
                  ;; Never use more than half the window/screen width, leave the other half for the filename.
                  #_int m (max 0 (- @ru_col (- @Cols width))) m (max (/ (inc width) 2) m)]
                (when (< (+ m e) width) ;; need at least 3 chars left for get-rel-pos() + NUL
                    (let [n (loop-when-recur [n n e e] (and (< (+ m e) width) (< (+ n 3 1) RULER_BUF_LEN)) [(+ n (utf-char2bytes fillchar, (.plus s n))) (inc e)] => n)]
                        (get-rel-pos win, (.plus s n), (- RULER_BUF_LEN n))
                    ))
                ;; Truncate at window boundary.
                (loop-when [#_int n 0 #_int i 0] (non-eos? s i) => s
                    (let [n (+ n (us-ptr2cells s, i))]
                        (recur-if (<= (+ m n) width) [n (+ i (us-ptr2len-cc s, i))] => (eos! s i))
                    ))
                (screen-puts s, row, (+ m off), @a'attr)
                (let [_ @redraw_cmdline] ;; don't redraw the cmdline because of showing the ruler
                    (screen-fill row, (inc row), (+ m off (STRLEN s)), (+ off width), fillchar, fillchar, @a'attr)
                    (reset! redraw_cmdline _))
                (assoc win :w_ru_cursor (:w_cursor win)
                           :w_ru_virtcol (:w_virtcol win)
                           :w_ru_topline (:w_topline win)
                           :w_ru_line_count lmax)
                           :w_ru_empty empty
            ))
    ))

;; Return the width of the 'number' and 'relativenumber' column.
;; Caller may need to check if 'number' or 'relativenumber' is set.
;; Otherwise it depends on 'numberwidth' and the line count.

(defn- #_int number-width [#_window_C win]
    (ยง
        (ร long lnum)
        (cond (and @(:wo_rnu (:w_options win)) (not @(:wo_nu (:w_options win))))
        (do
            ;; cursor line shows "0"
            ((ร lnum =) (:w_height win))
        )
        :else
        (do
            ;; cursor line shows absolute line number
            ((ร lnum =) (line-count @curbuf))
        ))

        (if (and (== lnum (:w_nrwidth_line_count win)) (== (:w_nuw_cached win) @(:wo_nuw (:w_options win))))
            ((ร RETURN) (:w_nrwidth_width win))
        )

        ((ร win =) (assoc win :w_nrwidth_line_count lnum))

        ((ร int n =) 0)
        (loop []
            ((ร lnum =) (/ lnum 10))
            ((ร n =) (inc n))
            (recur-if (< 0 lnum) [])
        )

        ;; 'numberwidth' gives the minimal width plus one
        ((ร n =) (max (dec (int @(:wo_nuw (:w_options win)))) n))

        ((ร win =) (assoc win :w_nrwidth_width n))
        ((ร win =) (assoc win :w_nuw_cached @(:wo_nuw (:w_options win))))
        n
    ))

;; Return the current cursor column.  This is the actual position on the screen.
;; First column is 0.

(defn- #_int screen-screencol []
    @screen_cur_col)

;; Return the current cursor row.  This is the actual position on the screen.
;; First row is 0.

(defn- #_int screen-screenrow []
    @screen_cur_row)

;;; ============================================================================================== VimW

;; window.c ---------------------------------------------------------------------------------------

(final Bytes m_onlyone (u8 "Already only one window"))

;; all CTRL-W window commands are handled here, called from normal-cmd().

(defn- #_void do-window [#_int nchar, #_long Prenum, #_int xchar] ;; xchar: extra char from ":wincmd gx" or NUL
    (let [#_Bytes cbuf (Bytes. 40) #_long Prenum1 (if (zero? Prenum) 1 Prenum)]
        (condp ==? nchar
            ;; split current window in two parts, horizontally
            [(byte \S) Ctrl_S (byte \s)]
                (if (non-zero? @cmdwin_type) (emsg e_cmdwin) (do (reset-VIsual-and-resel) (win-split Prenum, 0)))

            ;; split current window in two parts, vertically
            [Ctrl_V (byte \v)]
                (if (non-zero? @cmdwin_type) (emsg e_cmdwin) (do (reset-VIsual-and-resel) (win-split Prenum, WSP_VERT)))

            ;; quit current window
            [Ctrl_Q (byte \q)]
                (do (reset-VIsual-and-resel) (cmd-with-count (u8 "quit"), cbuf, (.size cbuf), Prenum) (do-cmdline-cmd cbuf))

            ;; close current window
            [Ctrl_C (byte \c)]
                (do (reset-VIsual-and-resel) (cmd-with-count (u8 "close"), cbuf, (.size cbuf), Prenum) (do-cmdline-cmd cbuf))

            ;; close all but current window
            [Ctrl_O (byte \o)]
                (if (non-zero? @cmdwin_type)
                    (emsg e_cmdwin)
                    (do (reset-VIsual-and-resel) (cmd-with-count (u8 "only"), cbuf, (.size cbuf), Prenum) (do-cmdline-cmd cbuf))
                )

            ;; cursor to next window with wrap around ;; cursor to previous window with wrap around
            [Ctrl_W (byte \w) (byte \W)]
                (cond (non-zero? @cmdwin_type)
                    (emsg e_cmdwin)
                (and (== @firstwin @lastwin) (!= Prenum 1)) ;; just one window
                    (beep-flush)
                :else
                (let [#_window_C win
                        (cond (non-zero? Prenum)                    ;; go to specified window
                            (loop-when-recur [win @firstwin n Prenum] (and (< 1 n) (some? (:w_next win))) [(:w_next win) (dec n)] => win)
                        (== nchar (byte \W))           ;; go to previous window
                            (or (:w_prev @curwin) @lastwin)       ;; wrap around
                        :else                        ;; go to next window
                            (or (:w_next @curwin) @firstwin)      ;; wrap around
                        )]
                    (win-goto win)
                ))

            ;; cursor to window below
            [(byte \j) K_DOWN Ctrl_J]
                (if (non-zero? @cmdwin_type) (emsg e_cmdwin) (win-goto-ver false, Prenum1))

            ;; cursor to window above
            [(byte \k) K_UP Ctrl_K]
                (if (non-zero? @cmdwin_type) (emsg e_cmdwin) (win-goto-ver true, Prenum1))

            ;; cursor to left window
            [(byte \h) K_LEFT Ctrl_H K_BS]
                (if (non-zero? @cmdwin_type) (emsg e_cmdwin) (win-goto-hor true, Prenum1))

            ;; cursor to right window
            [(byte \l) K_RIGHT Ctrl_L]
                (if (non-zero? @cmdwin_type) (emsg e_cmdwin) (win-goto-hor false, Prenum1))

            ;; cursor to top-left window
            [(byte \t) Ctrl_T]
                (win-goto @firstwin)

            ;; cursor to bottom-right window
            [(byte \b) Ctrl_B]
                (win-goto @lastwin)

            ;; cursor to last accessed (previous) window
            [(byte \p) Ctrl_P]
                (if (some? @prevwin) (win-goto @prevwin) (beep-flush))

            ;; exchange current and next window
            [(byte \x) Ctrl_X]
                (if (non-zero? @cmdwin_type) (emsg e_cmdwin) (win-exchange Prenum))

            ;; rotate windows downwards
            [Ctrl_R (byte \r)]
                (if (non-zero? @cmdwin_type) (emsg e_cmdwin) (do (reset-VIsual-and-resel) (win-rotate false, Prenum1)))

            ;; rotate windows upwards
            (byte \R)
                (if (non-zero? @cmdwin_type) (emsg e_cmdwin) (do (reset-VIsual-and-resel) (win-rotate true, Prenum1)))

            ;; move window to the very top/bottom/left/right
            [(byte \K) (byte \J) (byte \H) (byte \L)]
                (if (non-zero? @cmdwin_type)
                    (emsg e_cmdwin)
                    (win-totop Prenum, (| (if (any == nchar (byte \H) (byte \L)) WSP_VERT 0) (if (any == nchar (byte \H) (byte \K)) WSP_TOP WSP_BOT)))
                )

            ;; make all windows the same height
            (byte \=)
                (win-equal nil, false, (byte \b))

            ;; increase current window height
            (byte \+)
                (win-setheight @curwin, (+ (:w_height @curwin) Prenum1))

            ;; decrease current window height
            (byte \-)
                (win-setheight @curwin, (- (:w_height @curwin) Prenum1))

            ;; set current window height
            [Ctrl__ (byte \_)]
                (win-setheight @curwin, (if (non-zero? Prenum) Prenum 9999))

            ;; increase current window width
            (byte \>)
                (win-setwidth @curwin, (+ (:w_width @curwin) Prenum1))

            ;; decrease current window width
            (byte \<)
                (win-setwidth @curwin, (- (:w_width @curwin) Prenum1))

            ;; set current window width
            (byte \|)
                (win-setwidth @curwin, (if (non-zero? Prenum) Prenum 9999))

            [K_KENTER CAR]
                nil

         ;; :else
                (beep-flush)
        )
        nil
    ))

(defn- #_void cmd-with-count [#_Bytes cmd, #_Bytes bufp, #_int bufsize, #_long Prenum]
    (let [#_int len (STRLEN cmd)]
        (STRCPY bufp, cmd)
        (when (< 0 Prenum)
;%%         (vim_snprintf (.plus bufp len), (- bufsize len), (u8 "%ld"), Prenum)
        )
        nil
    ))

;; split the current window, implements CTRL-W s and :split
;;
;; "size" is the height or width for the new window, 0 to use half of current height or width.
;;
;; "flags":
;; WSP_VERT: vertical split.
;; WSP_TOP:  open window at the top-left of the shell (help window).
;; WSP_BOT:  open window at the bottom-right of the shell (quickfix window).
;;
;; return false for failure, true otherwise

(defn- #_boolean win-split [#_int size, #_int flags]
    (if (and (flag? flags WSP_TOP) (flag? flags WSP_BOT))
        (do (emsg (u8 "E442: Can't split topleft and botright at the same time")) false)
        (win-split-ins size, flags, nil, 0)
    ))

;; When "new_wp" is null: split the current window in two.
;; When "new_wp" is not null: insert this window at the far top/left/right/bottom.
;; return false for failure, true otherwise

(defn- #_boolean win-split-ins [#_int size, #_int flags, #_window_C new_wp, #_int dir]
    (ยง
        ((ร int new_size =) size)
        ((ร boolean do_equal =) false)
        ((ร int oldwin_height =) 0)

        ((ร window_C oldwin =) (cond (flag? flags WSP_TOP) @firstwin (flag? flags WSP_BOT) @lastwin :else @curwin))

        ((ร int need_status =) 0)
        ;; add a status line when p_ls == 1 and splitting the first window
        (when (and (== @lastwin @firstwin) (== @p_ls 1) (zero? (:w_status_height oldwin)))
            (when (and (<= (:w_height oldwin) @p_wmh) (nil? new_wp))
                (emsg e_noroom)
                ((ร RETURN) false)
            )
            ((ร need_status =) STATUS_HEIGHT)
        )

        (ร byte layout)
        (cond (flag? flags WSP_VERT)
        (do
            ((ร layout =) FR_ROW)

            ;; Check if we are able to split the current window and compute its width.

            ;; Current window requires at least 1 space.
            ((ร int wmw1 =) (if (== @p_wmw 0) 1 (int @p_wmw)))
            ((ร int needed =) (inc wmw1))
            (ร int minwidth)
            (ร int available)
            (cond (flag? flags (| WSP_BOT WSP_TOP))
            (do
                ((ร minwidth =) (frame-minwidth @topframe, :NOWIN))
                ((ร available =) (:fr_width @topframe))
                ((ร needed =) (+ needed minwidth))
            )
            @p_ea
            (do
                ((ร minwidth =) (frame-minwidth (:w_frame oldwin), :NOWIN))
                ((ร frame_C prevfrp =) (:w_frame oldwin))
                (loop-when-recur [#_frame_C fr (:fr_parent (:w_frame oldwin))] (some? fr) [(:fr_parent fr)]
                    (when (== (:fr_layout fr) FR_ROW)
                        (loop-when-recur [#_frame_C fr2 (:fr_child fr)] (some? fr2) [(:fr_next fr2)]
                            ((ร minwidth =) (if (!= fr2 prevfrp) (+ minwidth (frame-minwidth fr2, :NOWIN)) minwidth))
                        )
                    )
                    ((ร prevfrp =) fr)
                )
                ((ร available =) (:fr_width @topframe))
                ((ร needed =) (+ needed minwidth))
            )
            :else
            (do
                ((ร minwidth =) (frame-minwidth (:w_frame oldwin), :NOWIN))
                ((ร available =) (:fr_width (:w_frame oldwin)))
                ((ร needed =) (+ needed minwidth))
            ))
            (when (and (< available needed) (nil? new_wp))
                (emsg e_noroom)
                ((ร RETURN) false)
            )
            ((ร new_size =) (if (zero? new_size) (/ (:w_width oldwin) 2) new_size))
            ((ร new_size =) (max wmw1 (min new_size (- available minwidth 1))))

            ;; if it doesn't fit in the current window, need win-equal()
            ((ร do_equal =) (or (< (- (:w_width oldwin) new_size 1) @p_wmw) do_equal))

            ;; We don't like to take lines for the new window from a 'winfixwidth' window.
            ;; Take them from a window to the left or right instead, if possible.
            (when @(:wo_wfw (:w_options oldwin))
                (win-setwidth oldwin, (+ (:w_width oldwin) new_size)))

            ;; Only make all windows the same width if one of them (except oldwin)
            ;; is wider than one of the split windows.
            (when (and (not do_equal) @p_ea (zero? size) (not-at? @p_ead (byte \v)) (some? (:fr_parent (:w_frame oldwin))))
                ((ร frame_C fr =) (:fr_child (:fr_parent (:w_frame oldwin))))
                (loop-when [] (some? fr)
                    (when (and (!= (:fr_win fr) oldwin) (some? (:fr_win fr)) (or (< new_size (:w_width (:fr_win fr))) (< (- (:w_width oldwin) new_size 1) (:w_width (:fr_win fr)))))
                        ((ร do_equal =) true)
                        (ร BREAK)
                    )
                    ((ร fr =) (:fr_next fr))
                    (recur)
                )
            )
        )
        :else
        (do
            ((ร layout =) FR_COL)

            ;; Check if we are able to split the current window and compute its height.

            ;; Current window requires at least 1 space.
            ((ร int wmh1 =) (if (== @p_wmh 0) 1 (int @p_wmh)))
            ((ร int needed =) (+ wmh1 STATUS_HEIGHT))
            (ร int minheight)
            (ร int available)
            (cond (flag? flags (| WSP_BOT WSP_TOP))
            (do
                ((ร minheight =) (+ (frame-minheight @topframe, :NOWIN) need_status))
                ((ร available =) (:fr_height @topframe))
                ((ร needed =) (+ needed minheight))
            )
            @p_ea
            (do
                ((ร minheight =) (+ (frame-minheight (:w_frame oldwin), :NOWIN) need_status))
                ((ร frame_C prevfrp =) (:w_frame oldwin))
                (loop-when-recur [#_frame_C fr (:fr_parent (:w_frame oldwin))] (some? fr) [(:fr_parent fr)]
                    (when (== (:fr_layout fr) FR_COL)
                        (loop-when-recur [#_frame_C fr2 (:fr_child fr)] (some? fr2) [(:fr_next fr2)]
                            ((ร minheight =) (if (!= fr2 prevfrp) (+ minheight (frame-minheight fr2, :NOWIN)) minheight))
                        )
                    )
                    ((ร prevfrp =) fr)
                )
                ((ร available =) (:fr_height @topframe))
                ((ร needed =) (+ needed minheight))
            )
            :else
            (do
                ((ร minheight =) (+ (frame-minheight (:w_frame oldwin), :NOWIN) need_status))
                ((ร available =) (:fr_height (:w_frame oldwin)))
                ((ร needed =) (+ needed minheight))
            ))
            (when (and (< available needed) (nil? new_wp))
                (emsg e_noroom)
                ((ร RETURN) false)
            )
            ((ร oldwin_height =) (:w_height oldwin))
            (when (non-zero? need_status)
                ((ร oldwin =) (assoc oldwin :w_status_height STATUS_HEIGHT))
                ((ร oldwin_height =) (- oldwin_height STATUS_HEIGHT))
            )
            ((ร new_size =) (if (zero? new_size) (/ oldwin_height 2) new_size))
            ((ร new_size =) (max wmh1 (min new_size (- available minheight STATUS_HEIGHT))))

            ;; if it doesn't fit in the current window, need win-equal()
            ((ร do_equal =) (or (< (- oldwin_height new_size STATUS_HEIGHT) @p_wmh) do_equal))

            ;; We don't like to take lines for the new window from a 'winfixheight' window.
            ;; Take them from a window above or below instead, if possible.
            (when @(:wo_wfh (:w_options oldwin))
                (win-setheight oldwin, (+ (:w_height oldwin) new_size STATUS_HEIGHT))
                ((ร oldwin_height =) (:w_height oldwin))
                ((ร oldwin_height =) (if (non-zero? need_status) (- oldwin_height STATUS_HEIGHT) oldwin_height))
            )

            ;; Only make all windows the same height if one of them (except oldwin)
            ;; is higher than one of the split windows.
            (when (and (not do_equal) @p_ea (zero? size) (not-at? @p_ead (byte \h)) (some? (:fr_parent (:w_frame oldwin))))
                ((ร frame_C fr =) (:fr_child (:fr_parent (:w_frame oldwin))))
                (loop-when [] (some? fr)
                    (when (and (!= (:fr_win fr) oldwin) (some? (:fr_win fr)) (or (< new_size (:w_height (:fr_win fr))) (< (- oldwin_height new_size STATUS_HEIGHT) (:w_height (:fr_win fr)))))
                        ((ร do_equal =) true)
                        (ร BREAK)
                    )
                    ((ร fr =) (:fr_next fr))
                    (recur)
                )
            )
        ))

        ((ร window_C wp =) new_wp)

        ;; allocate new window structure and link it in the window list

        (cond (and (non-flag? flags WSP_TOP) (or (flag? flags WSP_BOT) (flag? flags WSP_BELOW) (and (non-flag? flags WSP_ABOVE) (if (flag? flags WSP_VERT) @p_spr @p_sb))))
        (do
            ;; new window below/right of current one
            (if (nil? new_wp)
                ((ร wp =) (newWindow oldwin))
                (win-append oldwin, wp))
        )
        :else
        (do
            (if (nil? new_wp)
                ((ร wp =) (newWindow (:w_prev oldwin)))
                (win-append (:w_prev oldwin), wp))
        ))

        (when (nil? new_wp)
            (if (nil? wp)
                ((ร RETURN) false)
            )

            ((ร wp =) (assoc wp :w_frame (newFrame wp)))

            ;; make the contents of the new window the same as the current one
            ((ร wp =) (win-init wp, @curwin))
        )

        ;; Reorganise the tree of frames to insert the new window.

        (ร frame_C curfrp)
        (ร boolean before)
        (cond (flag? flags (| WSP_TOP WSP_BOT))
        (do
            (cond (or (and (== (:fr_layout @topframe) FR_COL) (non-flag? flags WSP_VERT)) (and (== (:fr_layout @topframe) FR_ROW) (flag? flags WSP_VERT)))
            (do
                ((ร curfrp =) (:fr_child @topframe))
                (when (flag? flags WSP_BOT)
                    (loop-when [] (some? (:fr_next curfrp))
                        ((ร curfrp =) (:fr_next curfrp))
                        (recur)
                    )
                )
            )
            :else
            (do
                ((ร curfrp =) @topframe)
            ))
            ((ร before =) (flag? flags WSP_TOP))
        )
        :else
        (do
            ((ร curfrp =) (:w_frame oldwin))
            ((ร before =) (cond (flag? flags WSP_BELOW) false (flag? flags WSP_ABOVE) true (flag? flags WSP_VERT) (not @p_spr) :else (not @p_sb)))
        ))

        (when (or (nil? (:fr_parent curfrp)) (!= (:fr_layout (:fr_parent curfrp)) layout))
            ;; Need to create a new frame in the tree to make a branch.
            ((ร frame_C fr =) (NEW_frame_C))
            (COPY-frame fr, curfrp)
            ((ร curfrp =) (assoc curfrp :fr_layout layout))
            ((ร fr =) (assoc fr :fr_parent curfrp))
            ((ร fr =) (assoc fr :fr_next nil))
            ((ร fr =) (assoc fr :fr_prev nil))
            ((ร curfrp =) (assoc curfrp :fr_child fr))
            ((ร curfrp =) (assoc curfrp :fr_win nil))
            ((ร curfrp =) fr)
            (cond (some? (:fr_win fr))
            (do
                ((ร oldwin =) (assoc oldwin :w_frame fr))
            )
            :else
            (do
                (loop-when-recur [fr (:fr_child fr)] (some? fr) [(:fr_next fr)]
                    ((ร fr =) (assoc fr :fr_parent curfrp))
                )
            ))
        )

        ((ร frame_C fr =) (if (nil? new_wp) (:w_frame wp) (:w_frame new_wp)))
        ((ร fr =) (assoc fr :fr_parent (:fr_parent curfrp)))

        ;; Insert the new frame at the right place in the frame list.
        (if before
            (frame-insert curfrp, fr)
            (frame-append curfrp, fr))

        ;; Set "w_fraction" now so that the cursor keeps the same relative vertical position.
        (if (< 0 (:w_height oldwin))
            ((ร oldwin =) (set-fraction oldwin)))
        ((ร wp =) (assoc wp :w_fraction (:w_fraction oldwin)))

        (cond (flag? flags WSP_VERT)
        (do
            ((ร wp.w_options.@wo_scr =) @(:wo_scr (:w_options @curwin)))

            (when (non-zero? need_status)
                ((ร oldwin =) (win-new-height oldwin, (dec (:w_height oldwin))))
                ((ร oldwin =) (assoc oldwin :w_status_height need_status))
            )
            (cond (flag? flags (| WSP_TOP WSP_BOT))
            (do
                ;; set height and row of new window to full height
                ((ร wp =) (assoc wp :w_winrow 0))
                ((ร wp =) (win-new-height wp, (- (:fr_height curfrp) (if (< 0 @p_ls) 1 0))))
                ((ร wp =) (assoc wp :w_status_height (if (< 0 @p_ls) 1 0)))
            )
            :else
            (do
                ;; height and row of new window is same as current window
                ((ร wp =) (assoc wp :w_winrow (:w_winrow oldwin)))
                ((ร wp =) (win-new-height wp, (:w_height oldwin)))
                ((ร wp =) (assoc wp :w_status_height (:w_status_height oldwin)))
            ))
            ((ร fr =) (assoc fr :fr_height (:fr_height curfrp)))

            ;; "new_size" of the current window goes to the new window,
            ;; use one column for the vertical separator
            ((ร wp =) (win-new-width wp, new_size))
            (cond before
            (do
                ((ร wp =) (assoc wp :w_vsep_width 1))
            )
            :else
            (do
                ((ร wp =) (assoc wp :w_vsep_width (:w_vsep_width oldwin)))
                ((ร oldwin =) (assoc oldwin :w_vsep_width 1))
            ))
            (cond (flag? flags (| WSP_TOP WSP_BOT))
            (do
                (if (flag? flags WSP_BOT)
                    (frame-add-vsep curfrp))
                ;; Set width of neighbor frame.
                (frame-new-width curfrp, (- (:fr_width curfrp) (+ new_size (if (flag? flags WSP_TOP) 1 0))), (flag? flags WSP_TOP), false)
            )
            :else
            (do
                ((ร oldwin =) (win-new-width oldwin, (- (:w_width oldwin) (inc new_size))))
            ))
            (cond before     ;; new window left of current one
            (do
                ((ร wp =) (assoc wp :w_wincol (:w_wincol oldwin)))
                ((ร oldwin =) (update oldwin :w_wincol + (inc new_size)))
            )
            :else            ;; new window right of current one
            (do
                ((ร wp =) (assoc wp :w_wincol (+ (:w_wincol oldwin) (:w_width oldwin) 1)))
            ))
            ((ร oldwin =) (frame-fix-width oldwin))
            ((ร wp =) (frame-fix-width wp))
        )
        :else
        (do
            ;; width and column of new window is same as current window
            (cond (flag? flags (| WSP_TOP WSP_BOT))
            (do
                ((ร wp =) (assoc wp :w_wincol 0))
                ((ร wp =) (win-new-width wp, @Cols))
                ((ร wp =) (assoc wp :w_vsep_width 0))
            )
            :else
            (do
                ((ร wp =) (assoc wp :w_wincol (:w_wincol oldwin)))
                ((ร wp =) (win-new-width wp, (:w_width oldwin)))
                ((ร wp =) (assoc wp :w_vsep_width (:w_vsep_width oldwin)))
            ))
            ((ร fr =) (assoc fr :fr_width (:fr_width curfrp)))

            ;; "new_size" of the current window goes to the new window,
            ;; use one row for the status line
            ((ร wp =) (win-new-height wp, new_size))
            (if (flag? flags (| WSP_TOP WSP_BOT))
                (frame-new-height curfrp, (- (:fr_height curfrp) (+ new_size STATUS_HEIGHT)), (flag? flags WSP_TOP), false)
                ((ร oldwin =) (win-new-height oldwin, (- oldwin_height (+ new_size STATUS_HEIGHT)))))
            (cond before     ;; new window above current one
            (do
                ((ร wp =) (assoc wp :w_winrow (:w_winrow oldwin)))
                ((ร wp =) (assoc wp :w_status_height STATUS_HEIGHT))
                ((ร oldwin =) (update oldwin :w_winrow + (:w_height wp) STATUS_HEIGHT))
            )
            :else            ;; new window below current one
            (do
                ((ร wp =) (assoc wp :w_winrow (+ (:w_winrow oldwin) (:w_height oldwin) STATUS_HEIGHT)))
                ((ร wp =) (assoc wp :w_status_height (:w_status_height oldwin)))
                ((ร oldwin =) (assoc oldwin :w_status_height STATUS_HEIGHT))
            ))
            (if (flag? flags WSP_BOT)
                (frame-add-statusline curfrp))
            ((ร wp =) (frame-fix-height wp))
            ((ร oldwin =) (frame-fix-height oldwin))
        ))

        (when (flag? flags (| WSP_TOP WSP_BOT))
            (win-comp-pos))

        ;; Both windows need redrawing

        ((ร wp =) (redraw-later wp, NOT_VALID))
        ((ร wp =) (assoc wp :w_redr_status true))
        ((ร oldwin =) (redraw-later oldwin, NOT_VALID))
        ((ร oldwin =) (assoc oldwin :w_redr_status true))

        (when (non-zero? need_status)
            (reset! msg_row (dec @Rows))
            (reset! msg_col @sc_col)
            (msg-clr-eos-force)    ;; old command/ruler may still be there
            (comp-col)
            (reset! msg_row (dec @Rows))
            (reset! msg_col 0)            ;; put position back at start of line
        )

        ;; equalize the window sizes.

        (when (or do_equal (non-zero? dir))
            (win-equal wp, true, (if (flag? flags WSP_VERT) (if (== dir (byte \v)) (byte \b) (byte \h)) (if (== dir (byte \h)) (byte \b) (byte \v)))))

        ;; Don't change the window height/width to 'winheight' / 'winwidth' if a size was given.
        (ร int i)
        (cond (flag? flags WSP_VERT)
        (do
            ((ร i =) (int @p_wiw))
            (if (non-zero? size)
                (reset! p_wiw size))
        )
        :else
        (do
            ((ร i =) (int @p_wh))
            (if (non-zero? size)
                (reset! p_wh size))
        ))

        ;; Keep same changelist position in new window.
        ((ร wp =) (assoc wp :w_changelistidx (:w_changelistidx oldwin)))

        ;; make the new window the current window

        (win-enter wp)
        (if (flag? flags WSP_VERT)
            (reset! p_wiw i)
            (reset! p_wh i))

        true
    ))

;; Initialize window "win" from window "won".
;; Used when splitting a window and when creating a new tab page.
;; The windows will both edit the same buffer.

(defn- #_window_C win-init [#_window_C win, #_window_C won]
    (swap! curbuf update :b_nwindows inc)
    (let [win (assoc win :w_cursor (:w_cursor won)
                         :w_valid 0
                         :w_curswant (:w_curswant won)
                         :w_set_curswant (:w_set_curswant won)
                         :w_topline (:w_topline won)
                         :w_leftcol (:w_leftcol won)
                         :w_pcmark (:w_pcmark won)
                         :w_prev_pcmark (:w_prev_pcmark won)
                         :w_wrow (:w_wrow won)
                         :w_fraction (:w_fraction won)
                         :w_prev_fraction_row (:w_prev_fraction_row won))
          win (copy-jumplist win, won)
          win (win-copy-options win, won)
          _ (check-colorcolumn win)]
        win
    ))

;; Check if "win" is a pointer to an existing window.

(defn- #_boolean win-valid [#_window_C win]
    (and (some? win)
        (loop-when [#_window_C w @firstwin] (some? w) => false
            (recur-if (!= w win) [(:w_next w)] => true))
    ))

;; Exchange current and next window.

(defn- #_void win-exchange [#_long Prenum]
    (ยง
        (when (== @lastwin @firstwin)        ;; just one window
            (beep-flush)
            ((ร RETURN) nil)
        )

        ;; find window to exchange with

        ((ร frame_C fr1 =) (cond (non-zero? Prenum)
        (do
            (loop-when-recur [fr1 (:fr_child (:fr_parent (:w_frame @curwin))) Prenum (dec Prenum)] (and (some? fr1) (< 0 Prenum)) [(:fr_next fr1) (dec Prenum)] => fr1)
        )
        (some? (:fr_next (:w_frame @curwin)))    ;; Swap with next.
        (do
            (:fr_next (:w_frame @curwin))
        )
        :else    ;; Swap last window in row/col with previous.
        (do
            (:fr_prev (:w_frame @curwin))
        )))

        ;; We can only exchange a window with another window, not with a frame containing windows.
        (if (or (nil? fr1) (nil? (:fr_win fr1)) (== (:fr_win fr1) @curwin))
            ((ร RETURN) nil)
        )

        ((ร window_C wp =) (:fr_win fr1))

        ;; 1. remove curwin from the list.  Remember after which window it was in wp2
        ;; 2. insert curwin before wp in the list
        ;; if wp != wp2
        ;;    3. remove wp from the list
        ;;    4. insert wp after wp2
        ;; 5. exchange the status line height and vsep width.

        ((ร window_C wp2 =) (:w_prev @curwin))
        ((ร frame_C fr2 =) (:fr_prev (:w_frame @curwin)))
        (when (!= (:w_prev wp) @curwin)
            (win-remove @curwin)
            (frame-remove (:w_frame @curwin))
            (win-append (:w_prev wp), @curwin)
            (frame-insert fr1, (:w_frame @curwin))
        )
        (when (!= wp wp2)
            (win-remove wp)
            (frame-remove (:w_frame wp))
            (win-append wp2, wp)
            (if (nil? fr2)
                (frame-insert (:fr_child (:fr_parent (:w_frame wp))), (:w_frame wp))
                (frame-append fr2, (:w_frame wp)))
        )

        ((ร int temp =) (:w_status_height @curwin))
        (swap! curwin assoc :w_status_height (:w_status_height wp))
        ((ร wp =) (assoc wp :w_status_height temp))
        ((ร temp =) (:w_vsep_width @curwin))
        (swap! curwin assoc :w_vsep_width (:w_vsep_width wp))
        ((ร wp =) (assoc wp :w_vsep_width temp))

        ;; If the windows are not in the same frame, exchange the sizes to avoid
        ;; messing up the window layout.  Otherwise fix the frame sizes.
        (cond (!= (:fr_parent (:w_frame @curwin)) (:fr_parent (:w_frame wp)))
        (do
            ((ร temp =) (:w_height @curwin))
            (swap! curwin assoc :w_height (:w_height wp))
            ((ร wp =) (assoc wp :w_height temp))
            ((ร temp =) (:w_width @curwin))
            (swap! curwin assoc :w_width (:w_width wp))
            ((ร wp =) (assoc wp :w_width temp))
        )
        :else
        (do
            (swap! curwin frame-fix-height)
            ((ร wp =) (frame-fix-height wp))
            (swap! curwin frame-fix-width)
            ((ร wp =) (frame-fix-width wp))
        ))

        (win-comp-pos)                 ;; recompute window positions

        (win-enter wp)
        (swap! curwin redraw-later CLEAR)
        nil
    ))

;; rotate windows: if upwards true the second window becomes the first one
;;                 if upwards false the first window becomes the second one

(defn- #_void win-rotate [#_boolean upwards, #_int count]
    (ยง
        (when (== @firstwin @lastwin)            ;; nothing to do
            (beep-flush)
            ((ร RETURN) nil)
        )

        ;; Check if all frames in this row/col have one window.
        (loop-when-recur [#_frame_C fr (:fr_child (:fr_parent (:w_frame @curwin)))] (some? fr) [(:fr_next fr)]
            (when (nil? (:fr_win fr))
                (emsg (u8 "E443: Cannot rotate when another window is split"))
                ((ร RETURN) nil)
            )
        )

        (loop-when count (< 0 count)
            (ร window_C wp1, wp2)

            (cond upwards            ;; first window becomes last window
            (do
                ;; remove first window/frame from the list
                ((ร frame_C fr =) (:fr_child (:fr_parent (:w_frame @curwin))))
                ((ร wp1 =) (:fr_win fr))
                (win-remove wp1)
                (frame-remove fr)

                ;; find last frame and append removed window/frame after it
                ((ร fr =) (loop-when-recur fr (some? (:fr_next fr)) (:fr_next fr) => fr))
                (win-append (:fr_win fr), wp1)
                (frame-append fr, (:w_frame wp1))

                ((ร wp2 =) (:fr_win fr))   ;; previously last window
            )
            :else                    ;; last window becomes first window
            (do
                ;; find last window/frame in the list and remove it
                ((ร frame_C fr =) (loop-when-recur [fr (:w_frame @curwin)] (some? (:fr_next fr)) [(:fr_next fr)] => fr))
                ((ร wp1 =) (:fr_win fr))
                ((ร wp2 =) (:w_prev wp1))   ;; will become last window
                (win-remove wp1)
                (frame-remove fr)

                ;; append the removed window/frame before the first in the list
                (win-append (:w_prev (:fr_win (:fr_child (:fr_parent fr)))), wp1)
                (frame-insert (:fr_child (:fr_parent fr)), fr)
            ))

            ;; exchange status height and vsep width of old and new last window
            ((ร int n =) (:w_status_height wp2))
            ((ร wp2.w_status_height =) (:w_status_height wp1))
            ((ร wp1.w_status_height =) n)
            ((ร wp1 =) (frame-fix-height wp1))
            ((ร wp2 =) (frame-fix-height wp2))

            ((ร n =) (:w_vsep_width wp2))
            ((ร wp2.w_vsep_width =) (:w_vsep_width wp1))
            ((ร wp1.w_vsep_width =) n)
            ((ร wp1 =) (frame-fix-width wp1))
            ((ร wp2 =) (frame-fix-width wp2))

            ;; recompute "w_winrow" and "w_wincol" for all windows
            (win-comp-pos)
            (recur (dec count))
        )

        (swap! curwin redraw-later CLEAR)
        nil
    ))

;; Move the current window to the very top/bottom/left/right of the screen.

(defn- #_void win-totop [#_int size, #_int flags]
    (if (== @lastwin @firstwin)
        (beep-flush)
        (let [#_int height (:w_height @curwin) a'dir (atom (int))]
            ;; Remove the window and frame from the tree of frames.
            (winframe-remove @curwin, a'dir)
            (win-remove @curwin)
            (last-status false)         ;; may need to remove last status line
            (win-comp-pos)              ;; recompute window positions

            ;; Split a window on the desired side and put the window there.
            (win-split-ins size, flags, @curwin, @a'dir)
            (when (non-flag? flags WSP_VERT)
                (win-setheight @curwin, height)
                (when @p_ea
                    (win-equal @curwin, true, (byte \v))))
        ))
    nil)

;; Make all windows the same height.
;; 'next_curwin' will soon be the current window, make sure it has enough rows.

(defn- #_void win-equal [#_window_C next_curwin, #_boolean current, #_int dir]
    ;; next_curwin: pointer to current window to be or null
    ;; current: do only frame with current window
    ;; dir: 'v' for vertically, 'h' for horizontally, 'b' for both, 0 for using "p_ead"
    (let [dir (if (zero? dir) (.at @p_ead 0) dir)]
        (win-equal-rec (if (nil? next_curwin) @curwin next_curwin), current, @topframe, dir, 0, 0, @Cols, (:fr_height @topframe)))
    nil)

;; Set a frame to a new position and height, spreading the available room equally over contained frames.
;; The window "next_curwin" (if not null) should at least get the size from 'winheight' and 'winwidth' if possible.

(defn- #_void win-equal-rec [#_window_C next_curwin, #_boolean current, #_frame_C topfr, #_int dir, #_int col, #_int row, #_int width, #_int height]
    ;; next_curwin: pointer to current window to be or null
    ;; current: do only frame with current window
    ;; topfr: frame to set size off
    ;; dir: 'v', 'h' or 'b', see win-equal()
    ;; col: horizontal position for frame
    ;; row: vertical position for frame
    ;; width: new width of frame
    ;; height: new height of frame
    (ยง
        ((ร int extra_sep =) 0)
        (ร int wincount, totwincount = 0)
        ((ร int next_curwin_size =) 0)
        ((ร int room =) 0)
        ((ร boolean has_next_curwin =) false)

        (cond (== (:fr_layout topfr) FR_LEAF)
        (do
            ;; Set the width/height of this frame.
            ;; Redraw when size or position changes
            (when (or (!= (:fr_height topfr) height) (!= (:w_winrow (:fr_win topfr)) row) (!= (:fr_width topfr) width) (!= (:w_wincol (:fr_win topfr)) col))
                ((ร topfr =) (assoc-in topfr [:fr_win :w_winrow] row))
                (frame-new-height topfr, height, false, false)
                ((ร topfr =) (assoc-in topfr [:fr_win :w_wincol] col))
                (frame-new-width topfr, width, false, false)
                (redraw-all-later CLEAR)
            )
        )
        (== (:fr_layout topfr) FR_ROW)
        (do
            ((ร topfr =) (assoc topfr :fr_width width))
            ((ร topfr =) (assoc topfr :fr_height height))

            (when (!= dir (byte \v))                 ;; equalize frame widths
                ;; Compute the maximum number of windows horizontally in this frame.
                ((ร int n =) (frame-minwidth topfr, :NOWIN))
                ;; add one for the rightmost window, it doesn't have a separator
                ((ร extra_sep =) (if (== (+ col width) @Cols) 1 0))
                ((ร totwincount =) (/ (+ n extra_sep) (inc (int @p_wmw))))
                ((ร has_next_curwin =) (frame-has-win topfr, next_curwin))

                ;; Compute width for "next_curwin" window and room available for other windows.
                ;; "m" is the minimal width when counting "p_wiw" for "next_curwin".

                ((ร int m =) (frame-minwidth topfr, next_curwin))
                ((ร room =) (- width m))
                (cond (< room 0)
                (do
                    ((ร next_curwin_size =) (+ (int @p_wiw) room))
                    ((ร room =) 0)
                )
                :else
                (do
                    ((ร next_curwin_size =) -1)
                    (loop-when-recur [#_frame_C fr (:fr_child topfr)] (some? fr) [(:fr_next fr)]
                        ;; If 'winfixwidth' set keep the window width if possible.
                        ;; Watch out for this window being the next_curwin.
                        (when (frame-fixed-width fr)
                            ((ร n =) (frame-minwidth fr, :NOWIN))
                            ((ร int new_size =) (:fr_width fr))
                            (cond (frame-has-win fr, next_curwin)
                            (do
                                ((ร room =) (+ room (- @p_wiw @p_wmw)))
                                ((ร next_curwin_size =) 0)
                                ((ร new_size =) (max (int @p_wiw) new_size))
                            )
                            :else
                            (do
                                ;; These windows don't use up room.
                                ((ร totwincount =) (- totwincount (/ (+ n (if (nil? (:fr_next fr)) extra_sep 0)) (inc @p_wmw))))
                            ))
                            ((ร room =) (- room (- new_size n)))
                            (when (< room 0)
                                ((ร new_size =) (+ new_size room))
                                ((ร room =) 0)
                            )
                            ((ร fr =) (assoc fr :fr_newwidth new_size))
                        )
                    )
                    (when (== next_curwin_size -1)
                        (cond (not has_next_curwin)
                        (do
                            ((ร next_curwin_size =) 0)
                        )
                        (and (< 1 totwincount) (< @p_wiw (/ (+ room (- totwincount 2)) (dec totwincount))))
                        (do
                            ;; Can make all windows wider than 'winwidth', spread the room equally.
                            ((ร next_curwin_size =) (/ (+ room (int @p_wiw) (* (dec totwincount) (int @p_wmw)) (dec totwincount)) totwincount))
                            ((ร room =) (- room (- next_curwin_size @p_wiw)))
                        )
                        :else
                        (do
                            ((ร next_curwin_size =) (int @p_wiw))
                        ))
                    )
                ))

                ((ร totwincount =) (if has_next_curwin (dec totwincount) totwincount))          ;; don't count curwin
            )

            (loop-when-recur [#_frame_C fr (:fr_child topfr)] (some? fr) [(:fr_next fr)]
                ((ร wincount =) 1)
                (ร int new_size)
                (cond (nil? (:fr_next fr))
                (do
                    ;; last frame gets all that remains (avoid roundoff error)
                    ((ร new_size =) width)
                )
                (== dir (byte \v))
                (do
                    ((ร new_size =) (:fr_width fr))
                )
                (frame-fixed-width fr)
                (do
                    ((ร new_size =) (:fr_newwidth fr))
                    ((ร wincount =) 0)       ;; doesn't count as a sizeable window
                )
                :else
                (do
                    ;; Compute the maximum number of windows horiz. in "fr".
                    ((ร int n =) (frame-minwidth fr, :NOWIN))
                    ((ร wincount =) (/ (+ n (if (nil? (:fr_next fr)) extra_sep 0)) (inc (int @p_wmw))))
                    ((ร int m =) (frame-minwidth fr, next_curwin))
                    ((ร boolean hnc =) (if has_next_curwin (frame-has-win fr, next_curwin) false))
                    ((ร wincount =) (if hnc (dec wincount) wincount))            ;; don't count next_curwin
                    ((ร new_size =) (if (zero? totwincount) room (/ (+ (* wincount room) (>>> totwincount 1)) totwincount)))
                    (cond hnc            ;; add next_curwin size
                    (do
                        ((ร next_curwin_size =) (- next_curwin_size (- @p_wiw (- m n))))
                        ((ร new_size =) (+ new_size next_curwin_size))
                        ((ร room =) (- room (- new_size next_curwin_size)))
                    )
                    :else
                    (do
                        ((ร room =) (- room new_size))
                    ))
                    ((ร new_size =) (+ new_size n))
                ))

                ;; Skip frame that is full width when splitting or closing a window,
                ;; unless equalizing all frames.
                (if (or (not current) (!= dir (byte \v)) (some? (:fr_parent topfr)) (!= new_size (:fr_width fr)) (frame-has-win fr, next_curwin))
                    (win-equal-rec next_curwin, current, fr, dir, col, row, new_size, height))
                ((ร col =) (+ col new_size))
                ((ร width =) (- width new_size))
                ((ร totwincount =) (- totwincount wincount))
            )
        )
        :else ;; topfr.fr_layout == FR_COL
        (do
            ((ร topfr =) (assoc topfr :fr_width width))
            ((ร topfr =) (assoc topfr :fr_height height))

            (when (!= dir (byte \h))                 ;; equalize frame heights
                ;; Compute maximum number of windows vertically in this frame.
                ((ร int n =) (frame-minheight topfr, :NOWIN))
                ;; add one for the bottom window if it doesn't have a statusline
                ((ร extra_sep =) (if (and (== (+ row height) @cmdline_row) (zero? @p_ls)) 1 0))
                ((ร totwincount =) (/ (+ n extra_sep) (inc (int @p_wmh))))
                ((ร has_next_curwin =) (frame-has-win topfr, next_curwin))

                ;; Compute height for "next_curwin" window and room available for other windows.
                ;; "m" is the minimal height when counting "p_wh" for "next_curwin".

                ((ร int m =) (frame-minheight topfr, next_curwin))
                ((ร room =) (- height m))
                (cond (< room 0)
                (do
                    ;; The room is less then 'winheight', use all space for the current window.
                    ((ร next_curwin_size =) (+ (int @p_wh) room))
                    ((ร room =) 0)
                )
                :else
                (do
                    ((ร next_curwin_size =) -1)
                    (loop-when-recur [#_frame_C fr (:fr_child topfr)] (some? fr) [(:fr_next fr)]
                        ;; If 'winfixheight' set keep the window height if possible.
                        ;; Watch out for this window being the next_curwin.
                        (when (frame-fixed-height fr)
                            ((ร n =) (frame-minheight fr, :NOWIN))
                            ((ร int new_size =) (:fr_height fr))
                            (cond (frame-has-win fr, next_curwin)
                            (do
                                ((ร room =) (+ room (- @p_wh @p_wmh)))
                                ((ร next_curwin_size =) 0)
                                ((ร new_size =) (max (int @p_wh) new_size))
                            )
                            :else
                            (do
                                ;; These windows don't use up room.
                                ((ร totwincount =) (- totwincount (/ (+ n (if (nil? (:fr_next fr)) extra_sep 0)) (inc @p_wmh))))
                            ))
                            ((ร room =) (- room (- new_size n)))
                            (when (< room 0)
                                ((ร new_size =) (+ new_size room))
                                ((ร room =) 0)
                            )
                            ((ร fr =) (assoc fr :fr_newheight new_size))
                        )
                    )
                    (when (== next_curwin_size -1)
                        (cond (not has_next_curwin)
                        (do
                            ((ร next_curwin_size =) 0)
                        )
                        (and (< 1 totwincount) (< @p_wh (/ (+ room (- totwincount 2)) (dec totwincount))))
                        (do
                            ;; Can make all windows higher than 'winheight', spread the room equally.
                            ((ร next_curwin_size =) (/ (+ room (int @p_wh) (* (dec totwincount) (int @p_wmh)) (dec totwincount)) totwincount))
                            ((ร room =) (- room (- next_curwin_size @p_wh)))
                        )
                        :else
                        (do
                            ((ร next_curwin_size =) (int @p_wh))
                        ))
                    )
                ))

                ((ร totwincount =) (if has_next_curwin (dec totwincount) totwincount))          ;; don't count curwin
            )

            (loop-when-recur [#_frame_C fr (:fr_child topfr)] (some? fr) [(:fr_next fr)]
                ((ร wincount =) 1)
                (ร int new_size)
                (cond (nil? (:fr_next fr))
                (do
                    ;; last frame gets all that remains (avoid roundoff error)
                    ((ร new_size =) height)
                )
                (== dir (byte \h))
                (do
                    ((ร new_size =) (:fr_height fr))
                )
                (frame-fixed-height fr)
                (do
                    ((ร new_size =) (:fr_newheight fr))
                    ((ร wincount =) 0)       ;; doesn't count as a sizeable window
                )
                :else
                (do
                    ;; Compute the maximum number of windows vert. in "fr".
                    ((ร int n =) (frame-minheight fr, :NOWIN))
                    ((ร wincount =) (/ (+ n (if (nil? (:fr_next fr)) extra_sep 0)) (inc (int @p_wmh))))
                    ((ร int m =) (frame-minheight fr, next_curwin))
                    ((ร boolean hnc =) (if has_next_curwin (frame-has-win fr, next_curwin) false))
                    ((ร wincount =) (if hnc (dec wincount) wincount))            ;; don't count next_curwin
                    ((ร new_size =) (if (zero? totwincount) room (/ (+ (* wincount room) (>>> totwincount 1)) totwincount)))
                    (cond hnc            ;; add next_curwin size
                    (do
                        ((ร next_curwin_size =) (- next_curwin_size (- @p_wh (- m n))))
                        ((ร new_size =) (+ new_size next_curwin_size))
                        ((ร room =) (- room (- new_size next_curwin_size)))
                    )
                    :else
                    (do
                        ((ร room =) (- room new_size))
                    ))
                    ((ร new_size =) (+ new_size n))
                ))
                ;; Skip frame that is full width when splitting or closing a window,
                ;; unless equalizing all frames.
                (when (or (not current) (!= dir (byte \h)) (some? (:fr_parent topfr)) (!= new_size (:fr_height fr)) (frame-has-win fr, next_curwin))
                    (win-equal-rec next_curwin, current, fr, dir, col, row, width, new_size)
                )
                ((ร row =) (+ row new_size))
                ((ร height =) (- height new_size))
                ((ร totwincount =) (- totwincount wincount))
            )
        ))
        nil
    ))

;; Return true if there is only one window.

(defn- #_boolean one-window []
    (loop-when [#_boolean seen_one false #_window_C win @firstwin] (some? win) => true
        (recur-if (not seen_one) [true (:w_next win)] => false)
    ))

;; Close window "win".  Only works for the current tab page.
;; If "_unload" is true related buffer may be unloaded.
;;
;; Returns false when the window was not closed.

(defn- #_boolean win-close [#_window_C win, #_boolean _unload]
    (cond (one-window)
        (do (emsg (u8 "E444: Cannot close last window")) false)
    (== @firstwin @lastwin)
        false
    :else
        (do ;; Close the link to the buffer.
            (close-buffer win)
            ;; Free the memory used for the window and get the window that received the screen space.
            (let [a'dir (atom (int)) #_window_C wp (win-free-mem win, a'dir) #_boolean close_curwin (== win @curwin)]
                ;; Make sure curwin isn't invalid.
                ;; It can cause severe trouble when printing an error message.
                ;; For win-equal() curbuf needs to be valid too.
                (when close_curwin
                    (reset! curwin wp))

                (if (and @p_ea (or (at? @p_ead (byte \b)) (at? @p_ead @a'dir)))
                    (win-equal @curwin, true, @a'dir)
                    (win-comp-pos))

                (when close_curwin
                    (win-enter-ext wp, true))

                ;; If last window has a status line now and we don't want one, remove the status line.
                (last-status false)

                (redraw-all-later NOT_VALID)
                true
            ))
    ))

;; Free the memory used for a window.
;; Returns a pointer to the window that got the freed up space.

(defn- #_window_C win-free-mem [#_window_C win, #_int' a'dir] ;; dir: set to 'v' or 'h' for direction if 'ea'
    ;; Remove the window and its frame from the tree of frames.
    (let [#_window_C w (winframe-remove win, a'dir)] (win-free win) w))

;; Remove a window and its frame from the tree of frames.
;; Returns a pointer to the window that got the freed up space.

(defn- #_window_C winframe-remove [#_window_C win, #_int' a'dir] ;; dir: set to 'v' or 'h' for direction if 'ea'
    (ยง
        ;; If there is only one window there is nothing to remove.

        (if (== @firstwin @lastwin)
            ((ร RETURN) nil)
        )

        ((ร frame_C frp_close =) (:w_frame win))

        ;; Remove the window from its frame.

        ((ร frame_C fr2 =) (win-altframe win))
        ((ร window_C wp =) (frame2win fr2))

        ;; Remove this frame from the list of frames.
        (frame-remove frp_close)

        (cond (== (:fr_layout (:fr_parent frp_close)) FR_COL)
        (do
            ;; When 'winfixheight' is set, try to find another frame in the column
            ;; (as close to the closed frame as possible) to distribute the height to.
            (when (and (some? (:fr_win fr2)) @(:wo_wfh (:w_options (:fr_win fr2))))
                ((ร frame_C fr =) (:fr_prev frp_close))
                ((ร frame_C fr3 =) (:fr_next frp_close))
                (loop-when [] (or (some? fr) (some? fr3))
                    (when (some? fr)
                        (when (and (some? (:fr_win fr)) (not @(:wo_wfh (:w_options (:fr_win fr)))))
                            ((ร fr2 =) fr)
                            ((ร wp =) (:fr_win fr))
                            (ร BREAK)
                        )
                        ((ร fr =) (:fr_prev fr))
                    )
                    (when (some? fr3)
                        (when (and (some? (:fr_win fr3)) (not @(:wo_wfh (:w_options (:fr_win fr3)))))
                            ((ร fr2 =) fr3)
                            ((ร wp =) (:fr_win fr3))
                            (ร BREAK)
                        )
                        ((ร fr3 =) (:fr_next fr3))
                    )
                    (recur)
                )
            )
            (frame-new-height fr2, (+ (:fr_height fr2) (:fr_height frp_close)), (== fr2 (:fr_next frp_close)), false)
            (reset! a'dir (byte \v))
        )
        :else
        (do
            ;; When 'winfixwidth' is set, try to find another frame in the column
            ;; (as close to the closed frame as possible) to distribute the width to.
            (when (and (some? (:fr_win fr2)) @(:wo_wfw (:w_options (:fr_win fr2))))
                ((ร frame_C fr =) (:fr_prev frp_close))
                ((ร frame_C fr3 =) (:fr_next frp_close))
                (loop-when [] (or (some? fr) (some? fr3))
                    (when (some? fr)
                        (when (and (some? (:fr_win fr)) (not @(:wo_wfw (:w_options (:fr_win fr)))))
                            ((ร fr2 =) fr)
                            ((ร wp =) (:fr_win fr))
                            (ร BREAK)
                        )
                        ((ร fr =) (:fr_prev fr))
                    )
                    (when (some? fr3)
                        (when (and (some? (:fr_win fr3)) (not @(:wo_wfw (:w_options (:fr_win fr3)))))
                            ((ร fr2 =) fr3)
                            ((ร wp =) (:fr_win fr3))
                            (ร BREAK)
                        )
                        ((ร fr3 =) (:fr_next fr3))
                    )
                    (recur)
                )
            )
            (frame-new-width fr2, (+ (:fr_width fr2) (:fr_width frp_close)), (== fr2 (:fr_next frp_close)), false)
            (reset! a'dir (byte \h))
        ))

        ;; If rows/columns go to a window below/right its positions need to be updated.
        ;; Can only be done after the sizes have been updated.
        (when (== fr2 (:fr_next frp_close))
            ((ร int[] a'row =) (atom (int (:w_winrow win))))
            ((ร int[] a'col =) (atom (int (:w_wincol win))))

            (frame-comp-pos fr2, a'row, a'col)
        )

        (when (and (nil? (:fr_next fr2)) (nil? (:fr_prev fr2)))
            ;; There is no other frame in this list, move its info to the parent and remove it.
            ((ร fr2.fr_parent.fr_layout =) (:fr_layout fr2))
            ((ร fr2.fr_parent.fr_child =) (:fr_child fr2))
            (loop-when-recur [#_frame_C fr (:fr_child fr2)] (some? fr) [(:fr_next fr)]
                ((ร fr =) (assoc fr :fr_parent (:fr_parent fr2)))
            )
            ((ร fr2.fr_parent.fr_win =) (:fr_win fr2))
            (if (some? (:fr_win fr2))
                ((ร fr2.fr_win.w_frame =) (:fr_parent fr2))
            )
            ((ร frame_C fr =) (:fr_parent fr2))

            ((ร fr2 =) (:fr_parent fr))
            (when (and (some? fr2) (== (:fr_layout fr2) (:fr_layout fr)))
                ;; The frame above the parent has the same layout,
                ;; have to merge the frames into this list.
                (if (== (:fr_child fr2) fr)
                    ((ร fr2.fr_child =) (:fr_child fr))
                )
                ((ร fr =) (assoc-in fr [:fr_child :fr_prev] (:fr_prev fr)))
                (if (some? (:fr_prev fr))
                    ((ร fr =) (assoc-in fr [:fr_prev :fr_next] (:fr_child fr)))
                )
                (loop-when-recur [#_frame_C fr3 (:fr_child fr)] true [(:fr_next fr3)]
                    ((ร fr3.fr_parent =) fr2)
                    (when (nil? (:fr_next fr3))
                        ((ร fr3.fr_next =) (:fr_next fr))
                        (if (some? (:fr_next fr))
                            ((ร fr =) (assoc-in fr [:fr_next :fr_prev] fr3))
                        )
                        (ร BREAK)
                    )
                )
            )
        )

        wp
    ))

;; Find out which frame is going to get the freed up space when "win" is closed.
;; if 'splitbelow'/'splitleft' the space goes to the window above/left.
;; if 'nosplitbelow'/'nosplitleft' the space goes to the window below/right.
;; This makes opening a window and closing it immediately keep the same window layout.

(defn- #_frame_C win-altframe [#_window_C win]
    (if (== @firstwin @lastwin)
        (:w_frame @curwin)
        (let [#_frame_C fr (:w_frame win)
              #_boolean b (if (and (some? (:fr_parent fr)) (== (:fr_layout (:fr_parent fr)) FR_ROW)) @p_spr @p_sb)]
            (if (or (and (not b) (some? (:fr_next fr))) (nil? (:fr_prev fr)))
                (:fr_next fr)
                (:fr_prev fr)
            ))
    ))

;; Find the left-upper window in frame "fr".

(defn- #_window_C frame2win [#_frame_C fr]
    (loop-when-recur fr (nil? (:fr_win fr)) (:fr_child fr) => (:fr_win fr)))

;; Return true if frame "fr" contains window "win".

(defn- #_boolean frame-has-win [#_frame_C fr, #_window_C win]
    (if (== (:fr_layout fr) FR_LEAF)
        (== (:fr_win fr) win)
        (loop-when [fr (:fr_child fr)] (some? fr) => false
            (recur-if (not (frame-has-win fr, win)) [(:fr_next fr)] => true)
        )
    ))

;; Set a new height for a frame.  Recursively sets the height for contained
;; frames and windows.  Caller must take care of positions.

(defn- #_void frame-new-height [#_frame_C topfr, #_int height, #_boolean topfirst, #_boolean wfh]
    ;; topfirst: resize topmost contained frame first
    ;; wfh: obey 'winfixheight' when there is a choice; may cause the height not to be set
    (ยง
        (cond (some? (:fr_win topfr))
        (do
            ;; Simple case: just one window.
            ((ร (:fr_win topfr) =) (win-new-height (:fr_win topfr), (- height (:w_status_height (:fr_win topfr)))))
        )
        (== (:fr_layout topfr) FR_ROW)
        (do
            (ร frame_C fr)
            (loop []
                ;; All frames in this row get the same new height.
                ((ร fr =) (loop-when-recur [fr (:fr_child topfr)] (some? fr) [(:fr_next fr)] => fr
                    (frame-new-height fr, height, topfirst, wfh)
                    (when (< height (:fr_height fr))
                        ;; Could not fit the windows, make the whole row higher.
                        ((ร height =) (:fr_height fr))
                        (ร BREAK)
                    )
                ))
                (recur-if (some? fr) [])
            )
        )
        :else    ;; fr_layout == FR_COL
        (do
            ;; Complicated case: resize a column of frames.
            ;; Resize the bottom frame first, frames above that when needed.

            ((ร frame_C fr =) (:fr_child topfr))
            (when wfh
                ;; Advance past frames with one window with 'wfh' set.
                (loop-when [] (frame-fixed-height fr)
                    ((ร fr =) (:fr_next fr))
                    (if (nil? fr)
                        ((ร RETURN) nil)         ;; no frame without 'wfh', give up
                    )
                    (recur)
                )
            )
            (when (not topfirst)
                ;; Find the bottom frame of this column.
                (loop-when [] (some? (:fr_next fr))
                    ((ร fr =) (:fr_next fr))
                    (recur)
                )
                (when wfh
                    ;; Advance back for frames with one window with 'wfh' set.
                    (loop-when [] (frame-fixed-height fr)
                        ((ร fr =) (:fr_prev fr))
                        (recur)
                    )
                )
            )

            ((ร int extra_lines =) (- height (:fr_height topfr)))
            (cond (< extra_lines 0)
            (do
                ;; reduce height of contained frames, bottom or top frame first
                (loop-when [] (some? fr)
                    ((ร int h =) (frame-minheight fr, nil))
                    (cond (< (+ (:fr_height fr) extra_lines) h)
                    (do
                        ((ร extra_lines =) (+ extra_lines (- (:fr_height fr) h)))
                        (frame-new-height fr, h, topfirst, wfh)
                    )
                    :else
                    (do
                        (frame-new-height fr, (+ (:fr_height fr) extra_lines), topfirst, wfh)
                        (ร BREAK)
                    ))
                    (cond topfirst
                    (do
                        (loop []
                            ((ร fr =) (:fr_next fr))
                            (recur-if (and wfh (some? fr) (frame-fixed-height fr)) [])
                        )
                    )
                    :else
                    (do
                        (loop []
                            ((ร fr =) (:fr_prev fr))
                            (recur-if (and wfh (some? fr) (frame-fixed-height fr)) [])
                        )
                    ))
                    ;; Increase "height" if we could not reduce enough frames.
                    ((ร height =) (if (nil? fr) (- height extra_lines) height))
                    (recur)
                )
            )
            (< 0 extra_lines)
            (do
                ;; increase height of bottom or top frame
                (frame-new-height fr, (+ (:fr_height fr) extra_lines), topfirst, wfh)
            ))
        ))
        ((ร topfr =) (assoc topfr :fr_height height))
        nil
    ))

;; Return true if height of frame "fr" should not be changed because of the 'winfixheight' option.

(defn- #_boolean frame-fixed-height [#_frame_C fr]
    (cond (some? (:fr_win fr))
        ;; Frame with one window: fixed height if 'winfixheight' set.
        @(:wo_wfh (:w_options (:fr_win fr)))
    (== (:fr_layout fr) FR_ROW)
        (loop-when [fr (:fr_child fr)] (some? fr) => false
            ;; The frame is fixed height if one of the frames in the row is fixed height.
            (recur-if (not (frame-fixed-height fr)) [(:fr_next fr)] => true)
        )
    :else ;; (== (:fr_layout fr) FR_COL)
        (loop-when [fr (:fr_child fr)] (some? fr) => true
            ;; The frame is fixed height if all of the frames in the row are fixed height.
            (recur-if (frame-fixed-height fr) [(:fr_next fr)] => false)
        )
    ))

;; Return true if width of frame "fr" should not be changed because of the 'winfixwidth' option.

(defn- #_boolean frame-fixed-width [#_frame_C fr]
    (cond (some? (:fr_win fr))
        ;; Frame with one window: fixed width if 'winfixwidth' set.
        @(:wo_wfw (:w_options (:fr_win fr)))
    (== (:fr_layout fr) FR_COL)
        (loop-when [fr (:fr_child fr)] (some? fr) => false
            ;; The frame is fixed width if one of the frames in the row is fixed width.
            (recur-if (not (frame-fixed-width fr)) [(:fr_next fr)] => true)
        )
    :else ;; (== (:fr_layout fr) FR_ROW)
        (loop-when [fr (:fr_child fr)] (some? fr) => true
            ;; The frame is fixed width if all of the frames in the row are fixed width.
            (recur-if (frame-fixed-width fr) [(:fr_next fr)] => false)
        )
    ))

;; Add a status line to windows at the bottom of "fr".
;; Note: Does not check if there is room!

(defn- #_void frame-add-statusline [#_frame_C fr]
    (ยง
        (cond (== (:fr_layout fr) FR_LEAF)
        (do
            ((ร window_C win =) (:fr_win fr))
            (when (zero? (:w_status_height win))
                (if (< 0 (:w_height win))    ;; don't make it negative
                    ((ร win =) (update win :w_height dec))
                )
                ((ร win =) (assoc win :w_status_height STATUS_HEIGHT))
            )
        )
        (== (:fr_layout fr) FR_ROW)
        (do
            ;; Handle all the frames in the row.
            (loop-when-recur [fr (:fr_child fr)] (some? fr) [(:fr_next fr)]
                (frame-add-statusline fr)
            )
        )
        :else ;; fr.fr_layout == FR_COL
        (do
            ;; Only need to handle the last frame in the column.
            ((ร fr =) (loop-when-recur [fr (:fr_child fr)] (some? (:fr_next fr)) [(:fr_next fr)] => fr))
            (frame-add-statusline fr)
        ))
        nil
    ))

;; Set width of a frame.  Handles recursively going through contained frames.
;; May remove separator line for windows at the right side (for win-close()).

(defn- #_void frame-new-width [#_frame_C topfr, #_int width, #_boolean leftfirst, #_boolean wfw]
    ;; leftfirst: resize leftmost contained frame first
    ;; wfw: obey 'winfixwidth' when there is a choice; may cause the width not to be set
    (ยง
        (cond (== (:fr_layout topfr) FR_LEAF)
        (do
            ;; Simple case: just one window.
            ((ร window_C win =) (:fr_win topfr))
            ;; Find out if there are any windows right of this one.
            ((ร frame_C fr =) (loop-when-recur [fr topfr] (some? (:fr_parent fr)) [(:fr_parent fr)] => fr
                (if (and (== (:fr_layout (:fr_parent fr)) FR_ROW) (some? (:fr_next fr)))
                    (ร BREAK)
                )
            ))
            (if (nil? (:fr_parent fr))
                ((ร win =) (assoc win :w_vsep_width 0))
            )
            ((ร win =) (win-new-width win, (- width (:w_vsep_width win))))
        )
        (== (:fr_layout topfr) FR_COL)
        (do
            (ร frame_C fr)
            (loop []
                ;; All frames in this column get the same new width.
                ((ร fr =) (loop-when-recur [fr (:fr_child topfr)] (some? fr) [(:fr_next fr)] => fr
                    (frame-new-width fr, width, leftfirst, wfw)
                    (when (< width (:fr_width fr))
                        ;; Could not fit the windows, make whole column wider.
                        ((ร width =) (:fr_width fr))
                        (ร BREAK)
                    )
                ))
                (recur-if (some? fr) [])
            )
        )
        :else    ;; fr_layout == FR_ROW
        (do
            ;; Complicated case: resize a row of frames.
            ;; Resize the rightmost frame first, frames left of it when needed.

            ((ร frame_C fr =) (:fr_child topfr))
            (when wfw
                ;; Advance past frames with one window with 'wfw' set.
                (loop-when [] (frame-fixed-width fr)
                    ((ร fr =) (:fr_next fr))
                    (if (nil? fr)
                        ((ร RETURN) nil)         ;; no frame without 'wfw', give up
                    )
                    (recur)
                )
            )
            (when (not leftfirst)
                ;; Find the rightmost frame of this row.
                (loop-when [] (some? (:fr_next fr))
                    ((ร fr =) (:fr_next fr))
                    (recur)
                )
                (when wfw
                    ;; Advance back for frames with one window with 'wfw' set.
                    (loop-when [] (frame-fixed-width fr)
                        ((ร fr =) (:fr_prev fr))
                        (recur)
                    )
                )
            )

            ((ร int extra_cols =) (- width (:fr_width topfr)))
            (cond (< extra_cols 0)
            (do
                ;; reduce frame width, rightmost frame first
                (loop-when [] (some? fr)
                    ((ร int w =) (frame-minwidth fr, nil))
                    (cond (< (+ (:fr_width fr) extra_cols) w)
                    (do
                        ((ร extra_cols =) (+ extra_cols (- (:fr_width fr) w)))
                        (frame-new-width fr, w, leftfirst, wfw)
                    )
                    :else
                    (do
                        (frame-new-width fr, (+ (:fr_width fr) extra_cols), leftfirst, wfw)
                        (ร BREAK)
                    ))
                    (cond leftfirst
                    (do
                        (loop []
                            ((ร fr =) (:fr_next fr))
                            (recur-if (and wfw (some? fr) (frame-fixed-width fr)) [])
                        )
                    )
                    :else
                    (do
                        (loop []
                            ((ร fr =) (:fr_prev fr))
                            (recur-if (and wfw (some? fr) (frame-fixed-width fr)) [])
                        )
                    ))
                    ;; Increase "width" if we could not reduce enough frames.
                    ((ร width =) (if (nil? fr) (- width extra_cols) width))
                    (recur)
                )
            )
            (< 0 extra_cols)
            (do
                ;; increase width of rightmost frame
                (frame-new-width fr, (+ (:fr_width fr) extra_cols), leftfirst, wfw)
            ))
        ))
        ((ร topfr =) (assoc topfr :fr_width width))
        nil
    ))

;; Add the vertical separator to windows at the right side of "fr".
;; Note: Does not check if there is room!

(defn- #_void frame-add-vsep [#_frame_C fr]
    (ยง
        (cond (== (:fr_layout fr) FR_LEAF)
        (do
            ((ร window_C win =) (:fr_win fr))
            (when (zero? (:w_vsep_width win))
                (if (< 0 (:w_width win))     ;; don't make it negative
                    ((ร win =) (update win :w_width dec))
                )
                ((ร win =) (assoc win :w_vsep_width 1))
            )
        )
        (== (:fr_layout fr) FR_COL)
        (do
            ;; Handle all the frames in the column.
            (loop-when-recur [fr (:fr_child fr)] (some? fr) [(:fr_next fr)]
                (frame-add-vsep fr)
            )
        )
        :else ;; fr.fr_layout == FR_ROW
        (do
            ;; Only need to handle the last frame in the row.
            ((ร fr =) (loop-when-recur [fr (:fr_child fr)] (some? (:fr_next fr)) [(:fr_next fr)] => fr))
            (frame-add-vsep fr)
        ))
        nil
    ))

;; Set frame width from the window it contains.

(defn- #_window_C frame-fix-width [#_window_C win]
    (assoc-in win [:w_frame :fr_width] (+ (:w_width win) (:w_vsep_width win))))

;; Set frame height from the window it contains.

(defn- #_window_C frame-fix-height [#_window_C win]
    (assoc-in win [:w_frame :fr_height] (+ (:w_height win) (:w_status_height win))))

;; Compute the minimal height for frame "topfr".
;; Uses the 'winminheight' option.
;; When "next_curwin" isn't null, use "p_wh" for this window.
;; When "next_curwin" is NOWIN, don't use at least one line for the current window.

(defn- #_int frame-minheight [#_frame_C topfr, #_window_C next_curwin]
    (cond (some? (:fr_win topfr))
        (if (== (:fr_win topfr) next_curwin)
            (+ @p_wh (:w_status_height (:fr_win topfr)))
            (let [m (+ @p_wmh (:w_status_height (:fr_win topfr)))] ;; window: minimal height of the window plus status line
                (if (and (zero? @p_wmh) (== (:fr_win topfr) @curwin) (nil? next_curwin)) (inc m) m) ;; current window is minimal one line high
            ))
    (== (:fr_layout topfr) FR_ROW) ;; get the minimal height from each frame in this row
        (loop-when-recur [m 0 fr (:fr_child topfr)] (some? fr) [(max (frame-minheight fr, next_curwin) m) (:fr_next fr)] => m)
    :else                          ;; add up the minimal heights for all frames in this column
        (loop-when-recur [m 0 fr (:fr_child topfr)] (some? fr) [(+ m (frame-minheight fr, next_curwin)) (:fr_next fr)] => m)
    ))

;; Compute the minimal width for frame "topfr".
;; When "next_curwin" isn't null, use "p_wiw" for this window.
;; When "next_curwin" is NOWIN, don't use at least one column for the current window.

(defn- #_int frame-minwidth [#_frame_C topfr, #_window_C next_curwin] ;; next_curwin: use "p_wh" and "p_wiw" for next_curwin
    (cond (some? (:fr_win topfr))
        (if (== (:fr_win topfr) next_curwin)
            (+ @p_wiw (:w_vsep_width (:fr_win topfr)))
            (let [m (+ @p_wmw (:w_vsep_width (:fr_win topfr)))] ;; window: minimal width of the window plus separator column
                (if (and (zero? @p_wmw) (== (:fr_win topfr) @curwin) (nil? next_curwin)) (inc m) m) ;; current window is minimal one column wide
            ))
    (== (:fr_layout topfr) FR_COL) ;; get the minimal width from each frame in this column
        (loop-when-recur [m 0 fr (:fr_child topfr)] (some? fr) [(max (frame-minwidth fr, next_curwin) m) (:fr_next fr)] => m)
    :else                          ;; add up the minimal widths for all frames in this row
        (loop-when-recur [m 0 fr (:fr_child topfr)] (some? fr) [(+ m (frame-minwidth fr, next_curwin)) (:fr_next fr)] => m)
    ))

;; Try to close all windows except current one.

(defn- #_void close-others [#_boolean message, #_boolean forceit]
    ;; forceit: always hide all other windows
    (if (one-window)
        (when message (msg m_onlyone))
        (do
            (loop-when [#_window_C win @firstwin] (win-valid win)
                (let [#_window_C nextw (:w_next win)]
                    (when (!= win @curwin)               ;; don't close current window
                        ;; Check if it's allowed to abandon this window.
                        (let-when [changed @(:b_changed @curbuf)] (or (not changed) (< 1 (:b_nwindows @curbuf)) forceit)
                            (win-close win, (not changed))
                        ))
                    (recur nextw)
                ))
            (when (and message (!= @lastwin @firstwin))
                (emsg (u8 "E445: Other window contains changes")))
        ))
    nil)

;; Allocate the first window and put an empty buffer in it.
;; Called from main().

(defn- #_void win-alloc-first []
    (reset! curwin (newWindow nil))

    (reset! curbuf (newBuffer))

    (init-chartab false)

    (unchanged)

    (swap! curbuf assoc :b_nwindows 1)          ;; there is one window

    (swap! curwin assoc :w_valid 0)             ;; mark cursor position as being invalid
    (swap! curwin assoc :w_topline 1)           ;; need to set "w_topline"
    (swap! curwin assoc :w_nrwidth_line_count 0)

    (swap! curwin redraw-later NOT_VALID)

    (swap! curwin update :w_cursor assoc :lnum 1 :col 0 :coladd 0)
    (swap! curwin assoc :w_curswant 0)
    (swap! curwin update :w_pcmark assoc :lnum 1 :col 0)       ;; pcmark not cleared but set to line 1
    (swap! curwin update :w_prev_pcmark assoc :lnum 0 :col 0)
    (swap! curwin assoc :w_topline 1 :w_botline 2 :w_lines_valid 0)

    (let [fr (-> (newFrame @curwin) (assoc :fr_height (- @Rows @p_ch) :fr_width @Cols))]
        (swap! curwin assoc :w_frame fr)
        (reset! topframe fr))

    (reset! ch_used @p_ch)
    nil)

;; Create a frame for window "win".

(defn- #_frame_C newFrame [#_window_C win]
    (assoc (NEW_frame_C) :fr_layout FR_LEAF :fr_win win))

;; Initialize the window and frame size to the maximum.

(defn- #_void win-init-size []
    (let [rows (- @Rows @p_ch) cols @Cols]
        (swap! firstwin assoc :w_height rows :w_width cols)
        (swap! topframe assoc :fr_height rows :fr_width cols))
    nil)

;; Go to another window.
;; When jumping to another buffer, stop Visual mode.  Do this before
;; changing windows so we can yank the selection into the '*' register.
;; When jumping to another window on the same buffer, adjust its cursor
;; position to keep the same Visual area.

(defn- #_void win-goto [#_window_C win]
    (ยง
        (if (text-locked)
            (do (beep-flush) (text-locked-msg))
            (let [#_window_C won @curwin]

                (when @VIsual_active
                    ((ร win =) (assoc win :w_cursor (:w_cursor won))))

                (win-enter win)

                ;; Conceal cursor line in previous window, unconceal in current window.
                (when (and (win-valid won) (pos? @(:wo_cole (:w_options won))) (zero? @msg_scrolled))
                    ((ร won =) (update-single-line won, (:lnum (:w_cursor won)))))
                (when (and (pos? @(:wo_cole (:w_options @curwin))) (zero? @msg_scrolled))
                    (swap! curwin assoc :w_redraw_cline true))
            ))
    nil))

;; Move to window above or below "count" times.

(defn- #_void win-goto-ver [#_boolean up, #_long count]
    (ยง
        ((ร frame_C foundfr =) (:w_frame @curwin))

;       end:
        (loop-when [count count] (< 0 count)

            ;; First go upwards in the tree of frames until we find a upwards or downwards neighbor.

            (ร frame_C nfr)
            (loop [#_frame_C fr foundfr]
                (if (== fr @topframe)
                    (ร BREAK end)
                )
                ((ร nfr =) (if up (:fr_prev fr) (:fr_next fr)))
                (if (and (== (:fr_layout (:fr_parent fr)) FR_COL) (some? nfr))
                    (ร BREAK)
                )
                (recur (:fr_parent fr))
            )

            ;; Now go downwards to find the bottom or top frame in it.

            (loop []
                (when (== (:fr_layout nfr) FR_LEAF)
                    ((ร foundfr =) nfr)
                    (ร BREAK)
                )
                ((ร frame_C fr =) (:fr_child nfr))
                (when (== (:fr_layout nfr) FR_ROW)
                    ;; Find the frame at the cursor row.
                    ((ร fr =) (loop-when fr (and (some? (:fr_next fr)) (<= (+ (:w_wincol (frame2win fr)) (:fr_width fr)) (+ (:w_wincol @curwin) (:w_wcol @curwin)))) => fr
                        (recur (:fr_next fr))
                    ))
                )
                ((ร nfr =) (if (and (== (:fr_layout nfr) FR_COL) up) (loop-when-recur fr (some? (:fr_next fr)) (:fr_next fr) => fr) fr))
                (recur)
            )
            (recur (dec count))
        )

        (when (some? foundfr)
            (win-goto (:fr_win foundfr)))
        nil
    ))

;; Move to window left or right "count" times.

(defn- #_void win-goto-hor [#_boolean left, #_long count]
    (ยง
        ((ร frame_C foundfr =) (:w_frame @curwin))

;       end:
        (loop-when [count count] (< 0 count)

            ;; First go upwards in the tree of frames until we find a left or right neighbor.

            (ร frame_C nfr)
            (loop [#_frame_C fr foundfr]
                (if (== fr @topframe)
                    (ร BREAK end)
                )
                ((ร nfr =) (if left (:fr_prev fr) (:fr_next fr)))
                (if (and (== (:fr_layout (:fr_parent fr)) FR_ROW) (some? nfr))
                    (ร BREAK)
                )
                (recur (:fr_parent fr))
            )

            ;; Now go downwards to find the leftmost or rightmost frame in it.

            (loop []
                (when (== (:fr_layout nfr) FR_LEAF)
                    ((ร foundfr =) nfr)
                    (ร BREAK)
                )
                ((ร frame_C fr =) (:fr_child nfr))
                (when (== (:fr_layout nfr) FR_COL)
                    ;; Find the frame at the cursor row.
                    ((ร fr =) (loop-when fr (and (some? (:fr_next fr)) (<= (+ (:w_winrow (frame2win fr)) (:fr_height fr)) (+ (:w_winrow @curwin) (:w_wrow @curwin)))) => fr
                        (recur (:fr_next fr))
                    ))
                )
                ((ร nfr =) (if (and (== (:fr_layout nfr) FR_ROW) left) (loop-when-recur fr (some? (:fr_next fr)) (:fr_next fr) => fr) fr))
                (recur)
            )
            (recur (dec count))
        )

        (when (some? foundfr)
            (win-goto (:fr_win foundfr)))
        nil
    ))

;; Make window "win" the current window.

(defn- #_void win-enter [#_window_C win]
    (win-enter-ext win, false)
    nil)

;; Make window "win" the current window.
;; Can be called with "curwin_invalid" true, which means that curwin has just been closed and isn't valid.

(defn- #_void win-enter-ext [#_window_C win, #_boolean curwin_invalid]
    (when (or (!= win @curwin) curwin_invalid)
        ;; Might need to scroll the old window before switching, e.g. when the cursor was moved.
        (swap! curwin update-topline)
        (when (not curwin_invalid)
            (reset! prevwin @curwin)                        ;; remember for CTRL-W p
            (swap! curwin assoc :w_redr_status true))

        (reset! curwin win)

        (swap! curwin check-cursor)
        (when (not (virtual-active))
            (swap! curwin assoc-in [:w_cursor :coladd] 0))
        (swap! curwin changed-line-abv-curs)                ;; assume cursor position needs updating
        (swap! curwin assoc :w_redr_status true)
        (when (non-zero? @restart_edit)
            (swap! curwin redraw-later VALID))          ;; causes status line redraw
        ;; set window height to desired minimal value
        (cond (and (< (:w_height @curwin) @p_wh) (not @(:wo_wfh (:w_options @curwin))))
            (win-setheight @curwin, @p_wh)
        (zero? (:w_height @curwin))
            (win-setheight @curwin, 1)
        )
        ;; set window width to desired minimal value
        (when (and (< (:w_width @curwin) @p_wiw) (not @(:wo_wfw (:w_options @curwin))))
            (win-setwidth @curwin, @p_wiw)
        ))
    nil)

;; Allocate a window structure and link it in the window list.

(defn- #_window_C newWindow [#_window_C after]
    (let [win (NEW_window_C)
          win (win-alloc-lines win)]
        ;; link the window in the window list
        (win-append after, win)
        (-> win
            (assoc :w_wincol 0, :w_width @Cols)
            ;; position the display and the cursor at the top of the file
            (assoc :w_topline 1, :w_botline 2)
            (assoc-in [:w_cursor :lnum] 1)
            (assoc :w_scbind_pos 1)
            ;; We won't calculate "w_fraction" until resizing the window.
            (assoc :w_fraction 0, :w_prev_fraction_row -1)
            (assoc :w_match_head nil, :w_next_match_id 4)
        )
    ))

;; Remove window 'win' from the window list and free the structure.

(defn- #_void win-free [#_window_C win]
    (ยง
        (when (== @prevwin win)
            (reset! prevwin nil))

        ((ร win =) (win-free-lines win))

        (clear-matches win)

        ((ร win =) (assoc win :w_p_cc_cols nil))

        (win-remove win)
        nil
    ))

;; Append window "win" in the window list after window "after".

(defn- #_void win-append [#_window_C after, #_window_C win]
    (ยง
        ((ร window_C before =) (if (nil? after) @firstwin (:w_next after)))      ;; after null is in front of the first

        ((ร win =) (assoc win :w_next before))
        ((ร win =) (assoc win :w_prev after))
        (if (nil? after)
            (reset! firstwin win)
            ((ร after =) (assoc after :w_next win))
        )
        (if (nil? before)
            (reset! lastwin win)
            ((ร before =) (assoc before :w_prev win))
        )
        nil
    ))

;; Remove a window from the window list.

(defn- #_void win-remove [#_window_C win]
    (ยง
        (if (some? (:w_prev win))
            ((ร win =) (assoc-in win [:w_prev :w_next] (:w_next win)))
            (reset! firstwin (:w_next win)))

        (if (some? (:w_next win))
            ((ร win =) (assoc-in win [:w_next :w_prev] (:w_prev win)))
            (reset! lastwin (:w_prev win)))
        nil
    ))

;; Append frame "fr" in a frame list after frame "after".

(defn- #_void frame-append [#_frame_C after, #_frame_C fr]
    (ยง
        ((ร fr =) (assoc fr :fr_next (:fr_next after)))
        ((ร after =) (assoc after :fr_next fr))
        (if (some? (:fr_next fr))
            ((ร fr =) (assoc-in fr [:fr_next :fr_prev] fr))
        )
        ((ร fr =) (assoc fr :fr_prev after))
        nil
    ))

;; Insert frame "fr" in a frame list before frame "before".

(defn- #_void frame-insert [#_frame_C before, #_frame_C fr]
    (ยง
        ((ร fr =) (assoc fr :fr_next before))
        ((ร fr =) (assoc fr :fr_prev (:fr_prev before)))
        ((ร before =) (assoc before :fr_prev fr))
        (if (some? (:fr_prev fr))
            ((ร fr =) (assoc-in fr [:fr_prev :fr_next] fr))
            ((ร fr =) (assoc-in fr [:fr_parent :fr_child] fr))
        )
        nil
    ))

;; Remove a frame from a frame list.

(defn- #_void frame-remove [#_frame_C fr]
    (ยง
        (if (some? (:fr_prev fr))
            ((ร fr =) (assoc-in fr [:fr_prev :fr_next] (:fr_next fr)))
            ((ร fr =) (assoc-in fr [:fr_parent :fr_child] (:fr_next fr)))
        )
        (when (some? (:fr_next fr))
            ((ร fr =) (assoc-in fr [:fr_next :fr_prev] (:fr_prev fr)))
        )
        nil
    ))

;; Allocate w_lines[] for window "win".

(defn- #_window_C win-alloc-lines [#_window_C win]
    (assoc win :w_lines_valid 0, :w_lines (ARRAY-wline @Rows)))

;; Free w_lines[] for window "win".

(defn- #_window_C win-free-lines [#_window_C win]
    (assoc win :w_lines nil))

;; Called from win-new-shellsize() after Rows changed.
;; This only does the current tab page, others must be done when made active.

(defn- #_void shell-new-rows []
    (when (some? @firstwin)
        (let [rows (max (frame-minheight @topframe, nil) (- @Rows @p_ch))]
            ;; First try setting the heights of windows with 'winfixheight'.
            ;; If that doesn't result in the right height, forget about that option.
            (frame-new-height @topframe, rows, false, true)
            (when (not (frame-check-height @topframe, rows))
                (frame-new-height @topframe, rows, false, false))

            (win-comp-pos)              ;; recompute "w_winrow" and "w_wincol"
            (compute-cmdrow)
            (reset! ch_used @p_ch)
        ))
    nil)

;; Called from win-new-shellsize() after Cols changed.

(defn- #_void shell-new-columns []
    (when (some? @firstwin)
        (let [cols @Cols]
            ;; First try setting the widths of windows with 'winfixwidth'.
            ;; If that doesn't result in the right width, forget about that option.
            (frame-new-width @topframe, cols, false, true)
            (when (not (frame-check-width @topframe, cols))
                (frame-new-width @topframe, cols, false, false))

            (win-comp-pos)                  ;; recompute "w_winrow" and "w_wincol"
        ))
    nil)

;; Update the position for all windows, using the width and height of the frames.
;; Returns the row just after the last window.

(defn- #_int win-comp-pos []
    (let [a'row (atom (int 0)) a'col (atom (int 0))]
        (frame-comp-pos @topframe, a'row, a'col)
        @a'row
    ))

;; Update the position of the windows in frame "topfr",
;; using the width and height of the frames.
;; "*row" and "*col" are the top-left position of the frame.
;; They are updated to the bottom-right position plus one.

(defn- #_void frame-comp-pos [#_frame_C topfr, #_int' a'row, #_int' a'col]
    (ยง
        ((ร window_C win =) (:fr_win topfr))
        (cond (some? win)
        (do
            (when (or (!= (:w_winrow win) @a'row) (!= (:w_wincol win) @a'col))
                ;; position changed, redraw
                ((ร win =) (assoc win :w_winrow @a'row))
                ((ร win =) (assoc win :w_wincol @a'col))
                ((ร win =) (redraw-later win, NOT_VALID))
                ((ร win =) (assoc win :w_redr_status true))
            )
            (swap! a'row + (:w_height win) (:w_status_height win))
            (swap! a'col + (:w_width win) (:w_vsep_width win))
        )
        :else
        (do
            ((ร int startrow =) @a'row)
            ((ร int startcol =) @a'col)
            (loop-when-recur [#_frame_C fr (:fr_child topfr)] (some? fr) [(:fr_next fr)]
                (if (== (:fr_layout topfr) FR_ROW)
                    (reset! a'row startrow)        ;; all frames are at the same row
                    (reset! a'col startcol)        ;; all frames are at the same col
                )
                (frame-comp-pos fr, a'row, a'col)
            )
        ))
        nil
    ))

;; Set the window height of window "win" and take care of repositioning other windows to fit around it.

(defn- #_void win-setheight [#_window_C win, #_int height]
    ;; Always keep current window at least one line high, even when 'winminheight' is zero.
    (let [height (if (== win @curwin) (max 1 @p_wmh height) height)]
        (frame-setheight (:w_frame win), (+ height (:w_status_height win)))
        (let [#_int row (win-comp-pos)] ;; recompute the window positions
            ;; If there is extra space created between the last window and the command line, clear it.
            (when (and @full_screen (zero? @msg_scrolled) (< row @cmdline_row))
                (screen-fill row, @cmdline_row, 0, @Cols, (byte \space), (byte \space), 0))
            (reset! cmdline_row row)
            (reset! msg_row row)
            (reset! msg_col 0)
            (redraw-all-later NOT_VALID)
        ))
    nil)

;; Set the height of a frame to "height"
;; and take care that all frames and windows inside it are resized.
;; Also resize frames on the left and right if they are in the same FR_ROW frame.
;;
;; Strategy:
;; If the frame is part of a FR_COL frame, try fitting the frame in that frame.
;; If that doesn't work (the FR_COL frame is too small),
;; recursively go to containing frames to resize them and make room.
;; If the frame is part of a FR_ROW frame, all frames must be resized as well.
;; Check for the minimal height of the FR_ROW frame.
;; At the top level we can also use change the command line height.

(defn- #_void frame-setheight [#_frame_C cufr, #_int height]
    (when (!= (:fr_height cufr) height)
        (cond (nil? (:fr_parent cufr)) ;; topframe: can only change the command line
            (let [height (min height (- @Rows @p_ch))]
                (when (< 0 height)
                    (frame-new-height cufr, height, false, false)))
        (== (:fr_layout (:fr_parent cufr)) FR_ROW)
            (let [height (max (frame-minheight (:fr_parent cufr), nil) height)]
                ;; Row of frames: also need to resize frames left and right of this one.
                ;; First check for the minimal height of these.
                (frame-setheight (:fr_parent cufr), height))
        :else
            ;; Column of frames: try to change only frames in this column.
            ;; Do this twice:
            ;; 1: compute room available, if it's not enough try resizing the containing frame.
            ;; 2: compute the room available and adjust the height to it.
            ;; Try not to reduce the height of a window with 'winfixheight' set.
            (let [[#_int room #_int rest #_int rcmd height] ;; room: total number of lines available ;; rcmd: lines available from cmdline
                    (loop-when [ro 0 re 0 rc 0 height height #_int run 1] (<= run 2) => [ro re rc height]
                        (let [[ro re] (loop-when [ro 0 re 0 #_frame_C fr (:fr_child (:fr_parent cufr))] (some? fr) => [ro re]
                                (let [re (if (and (!= fr cufr) (some? (:fr_win fr)) @(:wo_wfh (:w_options (:fr_win fr)))) (+ re (:fr_height fr)) re)
                                      ro (+ ro (:fr_height fr)) ro (if (!= fr cufr) (- ro (frame-minheight fr, nil)) ro)]
                                    (recur ro re (:fr_next fr))
                                ))
                              rc (if (== (:fr_width cufr) @Cols) (max 0 (- (- @Rows @p_ch) (+ (:w_winrow @lastwin) (:w_height @lastwin) (:w_status_height @lastwin)))) 0)]
                            (cond (<= height (+ ro rc))
                                [ro re rc height]
                            (or (== run 2) (== (:fr_width cufr) @Cols))
                                [ro re rc (min height (+ ro rc))]
                            :else
                            (do
                                (frame-setheight (:fr_parent cufr), (- (+ height (frame-minheight (:fr_parent cufr), :NOWIN)) @p_wmh 1))
                                (recur ro re rc height (inc run))
                            ))
                        ))
                  ;; Compute the number of lines we will take from others frames (can be negative!).
                  #_int take (- height (:fr_height cufr))
                  ;; If there is not enough room, also reduce the height of a window with 'winfixheight' set.
                  rest (min rest (- (+ room rcmd) height))
                  ;; If there is only a 'winfixheight' window and making the window smaller, need to make the other window taller.
                  rest (if (and (< take 0) (< (- room (:fr_height cufr)) rest)) 0 rest)
                  take (if (and (< 0 take) (< 0 rcmd)) ;; use lines from cmdline first
                            (let [rcmd (min rcmd take)] (swap! topframe update :fr_height + rcmd) (- take rcmd)) take)
                  a'm (atom {:take take :rest rest})]
                ;; Set the current frame to the new height.
                (frame-new-height cufr, height, false, false)
                ;; First take lines from the frames after the current frame.
                ;; If that is not enough, takes lines from frames above the current frame.
                (doseq [step- [:fr_next :fr_prev]]
                    (loop-when [#_frame_C fr (step- cufr)] (and (some? fr) (non-zero? (:take @a'm)))
                        (let [#_int h0 (frame-minheight fr, nil) h (:fr_height fr)]
                            (cond (and (< 0 (:rest @a'm)) (some? (:fr_win fr)) @(:wo_wfh (:w_options (:fr_win fr))))
                            (do
                                (cond (<= h (:rest @a'm))
                                (do
                                    (swap! a'm update :rest - h)
                                )
                                :else
                                (do
                                    (swap! a'm update :rest max (- h (:take @a'm)))
                                    (swap! a'm update :take - (- h (:rest @a'm)))
                                    (frame-new-height fr, (:rest @a'm), false, false)
                                    (swap! a'm assoc :rest 0)
                                ))
                            )
                            :else
                            (do
                                (cond (< (- h (:take @a'm)) h0)
                                (do
                                    (swap! a'm update :take - (- h h0))
                                    (frame-new-height fr, h0, false, false)
                                )
                                :else
                                (do
                                    (frame-new-height fr, (- h (:take @a'm)), false, false)
                                    (swap! a'm assoc :take 0)
                                ))
                            ))
                            (recur (step- fr))
                        ))
                ))
        ))
    nil)

;; Set the window width of window "win" and take care of repositioning other windows to fit around it.

(defn- #_void win-setwidth [#_window_C win, #_int width]
    ;; Always keep current window at least one column wide, even when 'winminwidth' is zero.
    (let [width (if (== win @curwin) (max 1 @p_wmw width) width)]
        (frame-setwidth (:w_frame win), (+ width (:w_vsep_width win)))
        (win-comp-pos) ;; recompute the window positions
        (redraw-all-later NOT_VALID))
    nil)

;; Set the width of a frame to "width"
;; and take care that all frames and windows inside it are resized.
;; Also resize frames above and below if they are in the same FR_ROW frame.
;;
;; Strategy is similar to frame-setheight().

(defn- #_void frame-setwidth [#_frame_C cufr, #_int width]
    (when (and (!= (:fr_width cufr) width) (some? (:fr_parent cufr))) ;; if topframe: can't change width
        (cond (== (:fr_layout (:fr_parent cufr)) FR_COL)
            (let [width (max (frame-minwidth (:fr_parent cufr), nil) width)]
                ;; Column of frames: also need to resize frames above and below of this one.
                ;; First check for the minimal width of these.
                (frame-setwidth (:fr_parent cufr), width))
        :else
            ;; Row of frames: try to change only frames in this row.
            ;; Do this twice:
            ;; 1: compute room available, if it's not enough try resizing the containing frame.
            ;; 2: compute the room available and adjust the width to it.
            (let [[#_int room #_int rest width] ;; room: total number of lines available
                    (loop-when [ro 0 re 0 width width #_int run 1] (<= run 2) => [ro re width]
                        (let [[ro re] (loop-when [ro 0 re 0 #_frame_C fr (:fr_child (:fr_parent cufr))] (some? fr) => [ro re]
                                (let [re (if (and (!= fr cufr) (some? (:fr_win fr)) @(:wo_wfw (:w_options (:fr_win fr)))) (+ re (:fr_width fr)) re)
                                      ro (+ ro (:fr_width fr)) ro (if (!= fr cufr) (- ro (frame-minwidth fr, nil)) ro)]
                                    (recur ro re (:fr_next fr))
                                ))]
                            (cond (<= width ro)
                                [ro re width]
                            (or (== run 2) (<= (- @Rows @p_ch) (:fr_height cufr)))
                                [ro re (min width ro)]
                            :else
                            (do
                                (frame-setwidth (:fr_parent cufr), (- (+ width (frame-minwidth (:fr_parent cufr), :NOWIN)) @p_wmw 1))
                                (recur ro re width (inc run))
                            ))
                        ))
                  ;; Compute the number of lines we will take from others frames (can be negative!).
                  #_int take (- width (:fr_width cufr))
                  ;; If there is not enough room, also reduce the width of a window with 'winfixwidth' set.
                  rest (min rest (- room width))
                  ;; If there is only a 'winfixwidth' window and making the window smaller, need to make the other window narrower.
                  rest (if (and (< take 0) (< (- room (:fr_width cufr)) rest)) 0 rest)
                  a'm (atom {:take take :rest rest})]
                ;; Set the current frame to the new width.
                (frame-new-width cufr, width, false, false)
                ;; First take lines from the frames right of the current frame.
                ;; If that is not enough, takes lines from frames left of the current frame.
                (doseq [step- [:fr_next :fr_prev]]
                    (loop-when [#_frame_C fr (step- cufr)] (and (some? fr) (non-zero? (:take @a'm)))
                        (let [#_int w0 (frame-minwidth fr, nil) w (:fr_width fr)]
                            (cond (and (< 0 (:rest @a'm)) (some? (:fr_win fr)) @(:wo_wfw (:w_options (:fr_win fr))))
                            (do
                                (cond (<= w (:rest @a'm))
                                (do
                                    (swap! a'm update :rest - w)
                                )
                                :else
                                (do
                                    (swap! a'm update :rest max (- w (:take @a'm)))
                                    (swap! a'm update :take - (- w (:rest @a'm)))
                                    (frame-new-width fr, (:rest @a'm), false, false)
                                    (swap! a'm assoc :rest 0)
                                ))
                            )
                            :else
                            (do
                                (cond (< (- w (:take @a'm)) w0)
                                (do
                                    (swap! a'm update :take - (- w w0))
                                    (frame-new-width fr, w0, false, false)
                                )
                                :else
                                (do
                                    (frame-new-width fr, (- w (:take @a'm)), false, false)
                                    (swap! a'm assoc :take 0)
                                ))
                            ))
                            (recur (step- fr))
                        ))
                ))
        ))
    nil)

;; Check 'winminheight' for a valid value.
;; TODO: handle vertical splits

(defn- #_void win-setminheight []
    (loop-when-recur [mess true]
                     (and (pos? @p_wmh) (neg? (loop-when-recur [room (- @p_wh) win @firstwin] (some? win) [(+ room (- (:w_height win) @p_wmh)) (:w_next win)] => room)))
                     [false]
        (swap! p_wmh dec)
        (when mess (emsg e_noroom)))
    nil)

(final long FRACTION_MULT 16384)

;; Set "w_fraction" for the current "w_wrow" and "w_height".

(defn- #_window_C set-fraction [#_window_C win]
    (assoc win :w_fraction (/ (+ (* (:w_wrow win) FRACTION_MULT) (/ (:w_height win) 2)) (:w_height win))))

;; Set the height of a window.
;; This takes care of the things inside the window,
;; not what happens to the window position, the frame or to other windows.

(defn- #_window_C win-new-height [#_window_C win, #_int height]
    ;; Don't want a negative height.  Happens when splitting a tiny window.  Will equalize heights soon to fix it.
    (let-when [#_int prev_height (:w_height win) height (max 0 height)] (!= (:w_height win) height) => win ;; nothing to do
        (let-when [[win _]
            (if (< 0 (:w_height win))
                ;; When setting 'laststatus', this may call win-new-height() recursively.
                (let [win (if (== win @curwin) (validate-cursor win) win)] ;; "w_wrow" needs to be valid
                    (if (!= (:w_height win) prev_height)
                        [win false]
                        [(if (!= (:w_wrow win) (:w_prev_fraction_row win)) (set-fraction win) win) true]
                    ))
                [win true])
        ] _ => win ;; Recursive call already changed the size, bail out here to avoid the following to mess things up.

            (let [win (assoc win :w_height height, :w_skipcol 0)
                  win ;; Don't change "w_topline" when height is zero.  Don't set "w_topline" when 'scrollbind' is set and this isn't the current window.
                    (if (and (< 0 height) (or (not @(:wo_scb (:w_options win))) (== win @curwin)))
                        ;; Find a value for "w_topline" that shows the cursor at the same relative position in the window as before (more or less).
                        (let [#_long lnum (max 1 (:lnum (:w_cursor win))) ;; can happen when starting up
                              win (assoc win :w_wrow (/ (+ (dec (* (:w_fraction win) height)) (/ FRACTION_MULT 2)) FRACTION_MULT))
                              #_int line_size (dec (plines-col win, lnum, (:col (:w_cursor win))))
                              #_int sline (- (:w_wrow win) line_size)
                              [sline win]
                                (if (<= 0 sline) ;; Make sure the whole cursor line is visible, if possible.
                                    (let [#_int rows (plines win, lnum, false)]
                                        (if (< (- (:w_height win) rows) sline)
                                            [(- (:w_height win) rows) (update win :w_wrow - (- rows line_size))]
                                            [sline win]
                                        ))
                                    [sline win]
                                )]
                            (cond (< sline 0)
                                ;; Cursor line would go off top of screen if "w_wrow" was this high.
                                ;; Make cursor line the first line in the window.
                                ;; If not enough room, use "w_skipcol".
                                (let [win (assoc win :w_wrow line_size)
                                      win
                                        (if (and (<= (:w_height win) (:w_wrow win)) (< 0 (- (:w_width win) (win-col-off win))))
                                            (let [win (update win :w_skipcol + (- (:w_width win) (win-col-off win)))
                                                  win (update win :w_wrow dec)]
                                                (loop-when win (<= (:w_height win) (:w_wrow win)) => win
                                                    (let [win (update win :w_skipcol + (- (:w_width win) (win-col-off win)) (win-col-off2 win))
                                                          win (update win :w_wrow dec)]
                                                        (recur win))
                                                ))
                                            win
                                        )]
                                    (set-topline win, lnum))
                            (< 0 sline)
                                (let [[lnum line_size sline]
                                        (loop-when [lnum lnum line_size line_size sline sline] (and (< 0 sline) (< 1 lnum)) => [lnum line_size sline]
                                            (let [lnum (dec lnum) line_size (plines win, lnum, true) sline (- sline line_size)]
                                                (recur lnum line_size sline)
                                            ))
                                      [lnum win]
                                        (cond (< sline 0) ;; Line we want at top would go off top of screen.  Use next line instead.
                                            [(inc lnum) (update win :w_wrow - line_size sline)]
                                        (< 0 sline) ;; First line of file reached, use that as topline.
                                            [1 (update win :w_wrow - sline)]
                                        :else
                                            [lnum win]
                                        )]
                                    (set-topline win, lnum))
                            :else
                                win
                            ))
                        win)
                  win (if (== win @curwin)
                        (let [win (if (non-zero? @p_so) (update-topline win) win)]
                            (curs-columns win, false)) ;; validate "w_wrow"
                        win)
                  win (if (< 0 prev_height) (assoc win :w_prev_fraction_row (:w_wrow win)) win)
                  _ (win-comp-scroll win)
                  win (redraw-later win, SOME_VALID)
                  win (assoc win :w_redr_status true)]
                (invalidate-botline win)
            ))
    ))

;; Set the width of a window.

(defn- #_window_C win-new-width [#_window_C win, #_int width]
    (let [win (assoc win :w_width width, :w_lines_valid 0)
          win (changed-line-abv-curs win)
          win (invalidate-botline win)
          win (if (== win @curwin)
                (-> win
                    (update-topline)
                    (curs-columns true)) ;; validate "w_wrow"
                win)
          win (redraw-later win, NOT_VALID)]
        (assoc win :w_redr_status true)
    ))

(defn- #_void win-comp-scroll [#_window_C win]
    (reset! (:wo_scr (:w_options win)) (max 1 (>>> (:w_height win) 1)))
    nil)

;; command-height: called whenever "p_ch" has been changed

(defn- #_void command-height []
    (let [#_long old_p_ch @ch_used]
        ;; Use the value of "p_ch" that we remembered.  This is needed for when the GUI starts up, we can't be sure in what order things happen.
        (reset! ch_used @p_ch)
        ;; Find bottom frame with width of screen.
        (let-when [#_frame_C fr (loop-when-recur [fr (:w_frame @lastwin)] (and (!= (:fr_width fr) @Cols) (some? (:fr_parent fr))) [(:fr_parent fr)] => fr)
                   ;; Avoid changing the height of a window with 'winfixheight' set.
                   fr (loop-when-recur fr (and (some? (:fr_prev fr)) (== (:fr_layout fr) FR_LEAF) @(:wo_wfh (:w_options (:fr_win fr)))) (:fr_prev fr) => fr)
                   _ (if (!= @starting NO_SCREEN)
                        (do (reset! cmdline_row (- @Rows @p_ch))
                            (if (< old_p_ch @p_ch)                ;; "p_ch" got bigger
                                (do
                                    (loop-when [#_long ch old_p_ch fr fr] (< ch @p_ch)
                                        (if (some? fr)
                                            (let [#_int h (min (- (:fr_height fr) (frame-minheight fr, nil)) (- @p_ch ch))]
                                                (frame-add-height fr, (- h))
                                                (recur (+ ch h) (:fr_prev fr)))
                                            (do (emsg e_noroom)
                                                (reset! p_ch ch)
                                                (reset! ch_used @p_ch)
                                                (reset! cmdline_row (- @Rows @p_ch)))
                                        ))
                                    ;; Recompute window positions.
                                    (win-comp-pos)
                                    ;; Clear the lines added to cmdline.
                                    (when @full_screen
                                        (screen-fill @cmdline_row, @Rows, 0, @Cols, (byte \space), (byte \space), 0))
                                    (reset! msg_row @cmdline_row)
                                    (reset! redraw_cmdline true)
                                    nil)
                                (do
                                    (when (< @msg_row @cmdline_row)
                                        (reset! msg_row @cmdline_row))
                                    (reset! redraw_cmdline true)
                                    :_)
                            ))
                        :_)] (some? _)
            (frame-add-height fr, (- old_p_ch @p_ch))
            ;; Recompute window positions.
            (when (!= fr (:w_frame @lastwin))
                (win-comp-pos))
        ))
    nil)

;; Resize frame "fr" to be "n" lines higher (negative for less high).
;; Also resize the frames it is contained in.

(defn- #_void frame-add-height [#_frame_C fr, #_int n]
    (ยง
        (frame-new-height fr, (+ (:fr_height fr) n), false, false)
        (loop []
            ((ร fr =) (:fr_parent fr))
            (if (nil? fr)
                (ร BREAK)
            )
            ((ร fr =) (update fr :fr_height + n))
            (recur)
        )
        nil
    ))

;; Add or remove a status line for the bottom window(s), according to the value of 'laststatus'.
;; Don't make a difference between horizontal or vertical split.

(defn- #_void last-status [#_boolean morewin]
    ;; morewin: pretend there are two or more windows
    (last-status-rec @topframe, (or (== @p_ls 2) (and (== @p_ls 1) (or morewin (!= @lastwin @firstwin)))))
    nil)

(defn- #_void last-status-rec [#_frame_C fr, #_boolean statusline]
    (ยง
        (cond (== (:fr_layout fr) FR_LEAF)
        (do
            ((ร window_C win =) (:fr_win fr))
            (cond (and (non-zero? (:w_status_height win)) (not statusline))
            (do
                ;; remove status line
                ((ร win =) (win-new-height win, (inc (:w_height win))))
                ((ร win =) (assoc win :w_status_height 0))
                (comp-col)
            )
            (and (zero? (:w_status_height win)) statusline)
            (do
                ;; Find a frame to take a line from.
                ((ร frame_C fp =) fr)
                (loop-when [] (<= (:fr_height fp) (frame-minheight fp, nil))
                    (when (== fp @topframe)
                        (emsg e_noroom)
                        ((ร RETURN) nil)
                    )
                    ;; In a column of frames: go to frame above.
                    ;; If already at the top or in a row of frames: go to parent.
                    ((ร fp =) (if (and (== (:fr_layout (:fr_parent fp)) FR_COL) (some? (:fr_prev fp))) (:fr_prev fp) (:fr_parent fp)))
                    (recur)
                )
                ((ร win =) (assoc win :w_status_height 1))
                (cond (!= fp fr)
                (do
                    (frame-new-height fp, (dec (:fr_height fp)), false, false)
                    ((ร win =) (frame-fix-height win))
                    (win-comp-pos)
                )
                :else
                (do
                    ((ร win =) (win-new-height win, (dec (:w_height win))))
                ))
                (comp-col)
                (redraw-all-later SOME_VALID)
            ))
        )
        (== (:fr_layout fr) FR_ROW)
        (do
            ;; vertically split windows, set status line for each one
            (loop-when-recur [#_frame_C fp (:fr_child fr)] (some? fp) [(:fr_next fp)]
                (last-status-rec fp, statusline)
            )
        )
        :else
        (do
            ;; horizontally split window, set status line for last one
            ((ร frame_C fp =) (loop-when-recur [fp (:fr_child fr)] (some? (:fr_next fp)) [(:fr_next fp)] => fp))
            (last-status-rec fp, statusline)
        ))
        nil
    ))

;; Return the minimal number of rows that is needed on the screen to display the current number of windows.

(defn- #_int min-rows []
    (if (nil? @firstwin) MIN_ROWS (inc (max 0 (frame-minheight @topframe, nil)))))      ;; count the room for the command line

;; Delete all matches in the match list of window 'win'.

(defn- #_void clear-matches [#_window_C win]
    (ยง
        (loop-when [] (some? (:w_match_head win))
            ((ร matchitem_C mi =) (:next (:w_match_head win)))
            ((ร win.w_match_head.mi_match.regprog =) nil)
            ((ร win =) (assoc win :w_match_head mi))
            (recur)
        )

        (swap! curwin redraw-later SOME_VALID)
        nil
    ))

;; Return true if "topfr" and its children are at the right height.

(defn- #_boolean frame-check-height [#_frame_C topfr, #_int height]
    (if (!= (:fr_height topfr) height)
        false
        (if (== (:fr_layout topfr) FR_ROW)
            (loop-when [#_frame_C fr (:fr_child topfr)] (some? fr) => true
                (recur-if (== (:fr_height fr) height) [(:fr_next fr)] => false))
            true
        )
    ))

;; Return true if "topfr" and its children are at the right width.

(defn- #_boolean frame-check-width [#_frame_C topfr, #_int width]
    (if (!= (:fr_width topfr) width)
        false
        (if (== (:fr_layout topfr) FR_COL)
            (loop-when [#_frame_C fr (:fr_child topfr)] (some? fr) => true
                (recur-if (== (:fr_width fr) width) [(:fr_next fr)] => false))
            true
        )
    ))

;; move.c: Functions for moving the cursor and scrolling text.
;;
;; There are two ways to move the cursor:
;; 1. Move the cursor directly, the text is scrolled to keep the cursor in the window.
;; 2. Scroll the text, the cursor is moved into the text visible in the window.
;; The 'scrolloff' option makes this a bit complicated.

(class! #_final lineoff_C
    [
        (field long     lnum)       ;; line number
        (field int      height)     ;; height of added line
    ])

;; Compute win.w_botline for the current win.w_topline.
;; Can be called after win.w_topline changed.

(defn- #_window_C comp-botline [#_window_C win]
    (let [win (check-cursor-moved win) lmax (line-count @curbuf)
          ;; if "w_cline_row" is valid, start there; else have to start at "w_topline"
          [lnum done] (if (flag? (:w_valid win) VALID_CROW) [(:lnum (:w_cursor win)) (:w_cline_row win)] [(:w_topline win) 0])
          [lnum done win]
            (loop-when [lnum lnum done done win win] (<= lnum lmax) => [lnum done win]
                (let [n (plines win, lnum, true)
                      win (if (== lnum (:lnum (:w_cursor win)))
                            (-> win (assoc :w_cline_row done, :w_cline_height n)
                                    (redraw-for-cursorline)
                                    (update :w_valid | VALID_CROW VALID_CHEIGHT))
                            win)
                      n (+ done n)]
                    (recur-if (<= n (:w_height win)) [(inc lnum) n win] => [lnum done win]))
            )]
        ;; "w_botline" is the line that is just below the window
        (-> win (assoc :w_botline lnum) (update :w_valid | VALID_BOTLINE VALID_BOTLINE_AP)
            (set-empty-rows done))
    ))

;; Redraw when "w_cline_row" changes and 'relativenumber' or 'cursorline' is set.

(defn- #_window_C redraw-for-cursorline [#_window_C win]
    (let-when [wops (:w_options win)] (and (or @(:wo_rnu wops) @(:wo_cul wops)) (non-flag? (:w_valid win) VALID_CROW)) => win
        (redraw-later win, SOME_VALID)
    ))

;; Update curwin.w_topline and redraw if necessary.
;; Used to update the screen before printing a message.

(defn- #_window_C update-topline-redraw [#_window_C win]
    (let [win (update-topline win)]
        (when (non-zero? @must_redraw)
            (update-screen 0))
        win
    ))

;; Update "w_topline" to move the cursor onto the screen.

(defn- #_window_C update-topline [#_window_C win]
    (let-when [#_long save_so @p_so] (screen-valid true) => win
        ;; If the window height is zero, just use the cursor line.
        (if (zero? (:w_height win))
            (let [cln (:lnum (:w_cursor win))]
                (-> win (assoc :w_topline cln, :w_botline cln)
                        (update :w_valid | VALID_BOTLINE VALID_BOTLINE_AP)
                        (assoc :w_scbind_pos 1)))
            (let-when [win (check-cursor-moved win)] (non-flag? (:w_valid win) VALID_TOPLINE) => win
                (let [o'topline (:w_topline win)
                      [#_boolean check_botline win]
                        (if (bufempty)
                            ;; If the buffer is empty, always set topline to 1.
                            [false (let [win (if (!= (:w_topline win) 1) (redraw-later win, NOT_VALID) win)]
                                (-> win (assoc :w_topline 1, :w_botline 2)
                                        (update :w_valid | VALID_BOTLINE VALID_BOTLINE_AP)
                                        (assoc :w_scbind_pos 1))
                                )]
                            ;; If the cursor is above or near the top of the window,
                            ;; scroll the window to show the line the cursor is in, with 'scrolloff' context:
                            ;; if the cursor is above topline, scrolling is always needed;
                            ;; if the cursor is far below topline, scrolling down is never needed.
                            (if (and (< 1 (:w_topline win)) (or (< (:lnum (:w_cursor win)) (:w_topline win)) (check-top-offset win)))
                                ;; If we weren't very close to begin with, we scroll to put the cursor in the middle of the window.
                                ;; Otherwise put the cursor near the top of the window.
                                (if (<= (max 2 (dec (/ (:w_height win) 2))) (- (+ (:w_topline win) @p_so) (:lnum (:w_cursor win))))
                                    [false (scroll-cursor-halfway win, false)]
                                    [true (scroll-cursor-top win, (scrolljump-value win), false)])
                                [true win])
                        )]
                    ;; If the cursor is below the bottom of the window, scroll the window to put the cursor on the window.
                    ;; When "w_botline" is invalid, recompute it first, to avoid a redraw later.
                    ;; If "w_botline" was approximated, we might need a redraw later in a few cases,
                    ;; but we don't want to spend (a lot of) time recomputing "w_botline" for every small change.
                    (let [win (if check_botline
                                (let [win (if (non-flag? (:w_valid win) VALID_BOTLINE_AP) (validate-botline win) win)]
                                    (if (<= (:w_botline win) (line-count @curbuf))
                                        (let [cln (:lnum (:w_cursor win)) check_botline
                                                (or (<= (:w_botline win) cln)
                                                    (and (<= (- (:w_botline win) @p_so) cln)
                                                        ;; Cursor is (a few lines) above botline, check if there are 'scrolloff' window lines below the cursor.
                                                        ;; If not, need to scroll.
                                                        (let [n (loop-when [n (:w_empty_rows win) loff (->lineoff_C cln 0)] (< (:lnum loff) (:w_botline win)) => n
                                                                    (let [n (+ n (:height loff))] (recur-if (< n @p_so) [n (botline-forw loff, win)] => n))
                                                                )]
                                                            (< n @p_so)
                                                        ))
                                                )]
                                            (if check_botline
                                                (if (<= (+ (inc (- cln (:w_botline win))) @p_so) (inc (:w_height win)))
                                                    (scroll-cursor-bot win, (scrolljump-value win), false)
                                                    (scroll-cursor-halfway win, false))
                                                win
                                            ))
                                        win
                                    ))
                                win
                            )
                          win (update win :w_valid | VALID_TOPLINE)
                          ;; Need to redraw when topline changed.
                          win (if (!= (:w_topline win) o'topline)
                                (let [win (if (non-zero? (:w_skipcol win)) (let [win (assoc win :w_skipcol 0)] (redraw-later win, NOT_VALID)) (redraw-later win, VALID))]
                                    ;; May need to set "w_skipcol" when cursor in "w_topline".
                                    (if (== (:lnum (:w_cursor win)) (:w_topline win)) (validate-cursor win) win))
                                win
                            )]
                        (reset! p_so save_so)
                        win
                    ))
            ))
    ))

;; Return the 'scrolljump' value to use for window "win".
;; When 'scrolljump' is positive use it as-is.
;; When 'scrolljump' is negative use it as a percentage of the window height.

(defn- #_int scrolljump-value [#_window_C win]
    (let [sj @p_sj] (if (< sj 0) (/ (* (:w_height win) (- sj)) 100) sj)))

;; Return true when there are no 'scrolloff' lines above the cursor for window "win".

(defn- #_boolean check-top-offset [#_window_C win]
    (and (< (:lnum (:w_cursor win)) (+ (:w_topline win) @p_so))
        ;; Count the visible screen lines above the cursor line.
        (loop-when [n 0 loff (->lineoff_C (:lnum (:w_cursor win)) 0)] (< n @p_so) => false
            (let [loff (topline-back loff, win)] ;; Stop when included a line above the window.
                (recur-if (<= (:w_topline win) (:lnum loff)) [(+ n (:height loff)) loff] => true)
            ))
    ))

(defn- #_window_C update-curswant [#_window_C win]
    (if (:w_set_curswant win)
        (let [win (validate-virtcol win)]
            (assoc win :w_curswant (:w_virtcol win) :w_set_curswant false))
        win
    ))

;; Check if the cursor has moved.  Set the "w_valid" flag accordingly.

(defn- #_window_C check-cursor-moved [#_window_C win]
    (let [cursor (:w_cursor win) leftcol (:w_leftcol win)]
        (cond (!= (:lnum cursor) (:lnum (:w_valid_cursor win)))
            (-> win (update :w_valid & (bit-not (| VALID_WROW VALID_WCOL VALID_VIRTCOL VALID_CHEIGHT VALID_CROW VALID_TOPLINE)))
                    (assoc :w_valid_cursor cursor, :w_valid_leftcol leftcol))
        (or (!= (:col cursor) (:col (:w_valid_cursor win))) (!= leftcol (:w_valid_leftcol win)) (!= (:coladd cursor) (:coladd (:w_valid_cursor win))))
            (-> win (update :w_valid & (bit-not (| VALID_WROW VALID_WCOL VALID_VIRTCOL)))
                    (update :w_valid_cursor assoc :col (:col cursor) :coladd (:coladd cursor))
                    (assoc :w_valid_leftcol leftcol))
        :else win)
    ))

;; Call this function when some window settings have changed, which require
;; the cursor position, botline and topline to be recomputed and the window
;; to be redrawn, e.g. when changing the 'wrap' option or folding.

(defn- #_window_C changed-window-setting [#_window_C win]
    (-> win
        (assoc :w_lines_valid 0)
        (changed-line-abv-curs)
        (update :w_valid & (bit-not (| VALID_BOTLINE VALID_BOTLINE_AP VALID_TOPLINE)))
        (redraw-later NOT_VALID)
    ))

;; Set win.w_topline to a certain number.

(defn- #_window_C set-topline [#_window_C win, #_long lnum]
    ;; Approximate the value of "w_botline".
    (let [win (update win :w_botline + (- lnum (:w_topline win)))]
        (-> win
            (assoc :w_topline lnum, :w_topline_was_set true)
            (update :w_valid & (bit-not (| VALID_WROW VALID_CROW VALID_BOTLINE VALID_TOPLINE)))
            ;; Don't set VALID_TOPLINE here, 'scrolloff' needs to be checked.
            (redraw-later VALID)
        )
    ))

;; Call this function when the length of the cursor line (in screen cells) has changed, and the change is before the cursor.
;; Need to take care of "w_botline" separately!

(defn- #_window_C changed-cline-bef-curs [#_window_C win]
    (update win :w_valid & (bit-not (| VALID_WROW VALID_WCOL VALID_VIRTCOL VALID_CHEIGHT VALID_TOPLINE))))

;; Call this function when the length of a line (in screen cells) above the cursor have changed.
;; Need to take care of "w_botline" separately!

(defn- #_window_C changed-line-abv-curs [#_window_C win]
    (update win :w_valid & (bit-not (| VALID_WROW VALID_WCOL VALID_VIRTCOL VALID_CROW VALID_CHEIGHT VALID_TOPLINE))))

;; Make sure the value of win.w_botline is valid.

(defn- #_window_C validate-botline [#_window_C win]
    (if (non-flag? (:w_valid win) VALID_BOTLINE) (comp-botline win) win))

;; Mark "w_botline" as invalid (because of some change in the buffer).

(defn- #_window_C invalidate-botline [#_window_C win]
    (update win :w_valid & (bit-not (| VALID_BOTLINE VALID_BOTLINE_AP))))

(defn- #_window_C approximate-botline [#_window_C win]
    (update win :w_valid & (bit-not VALID_BOTLINE)))

;; Validate cursor position.  Makes sure "w_wrow" and "w_wcol" are valid.
;; "w_topline" must be valid, you may need to call update-topline() first!

(defn- #_window_C validate-cursor [#_window_C win]
    (let [win (check-cursor-moved win)
          row|col (| VALID_WROW VALID_WCOL) #_| valid? (== (& (:w_valid @curwin) row|col) row|col)]
        (if (not valid?) (curs-columns win, true) win)
    ))

;; Compute "w_cline_row" and "w_cline_height" upon the current value of "w_topline".

(defn- #_window_C curs-rows [#_window_C win]
    (let [#_boolean all_invalid (or (not (redrawing)) (zero? (:w_lines_valid win)) (< (:w_topline win) (:wl_lnum (... (:w_lines win) 0))))
          [win #_int i]
            (loop-when [win (assoc win :w_cline_row 0) #_long lnum (:w_topline win) i 0] (< lnum (:lnum (:w_cursor win))) => [win i]
                (let-when [wli (... (:w_lines win) i)
                    [valid? i' :as _]
                        (cond
                            (or all_invalid (<= (:w_lines_valid win) i))        [false i]
                            (or (< (:wl_lnum wli) lnum) (not (:wl_valid wli)))  nil             ;; skip changed or deleted lines
                            (== (:wl_lnum wli) lnum)                            [true i]
                            (< lnum (:wl_lnum wli))                             [false (dec i)] ;; hold at inserted lines
                        )
                ] (some? _) => (recur win lnum (inc i))
                    (let [win (update win :w_cline_row + (if valid? (:wl_size (... (:w_lines win) i')) (plines win, lnum, true)))]
                        (recur win (inc lnum) (inc i')))
                ))
          win (check-cursor-moved win)
          win (if (non-flag? (:w_valid win) VALID_CHEIGHT)
                (let [wli (... (:w_lines win) i) m (:w_lines_valid win)
                      n (cond (or all_invalid (== i m) (and (< i m) (or (not (:wl_valid wli)) (!= (:wl_lnum wli) (:lnum (:w_cursor win))))))
                            (plines win, (:lnum (:w_cursor win)), true)
                        (< m i)
                            0 ;; a line that is too long to fit on the last screen row
                        :else
                            (:wl_size wli)
                        )]
                    (assoc win :w_cline_height n))
                win)
          win (redraw-for-cursorline win)]
        (update win :w_valid | VALID_CROW VALID_CHEIGHT)
    ))

;; Validate "w_virtcol" only.

(defn- #_window_C validate-virtcol [#_window_C win]
    (let-when [win (check-cursor-moved win)] (non-flag? (:w_valid win) VALID_VIRTCOL) => win
        (let-when [a'vcol (atom (int (:w_virtcol win))) _ (getvvcol win, (:w_cursor win), nil, a'vcol, nil)
              win (-> win (assoc :w_virtcol @a'vcol) (update :w_valid | VALID_VIRTCOL))
        ] @(:wo_cuc (:w_options win)) => win
            (redraw-later win, SOME_VALID)
        )
    ))

;; Validate "w_cline_height" only.

(defn- #_window_C validate-cheight [#_window_C win]
    (let-when [win (check-cursor-moved win)] (non-flag? (:w_valid win) VALID_CHEIGHT) => win
        (let [n (plines win, (:lnum (:w_cursor win)), true)]
           (-> win (assoc :w_cline_height n) (update :w_valid | VALID_CHEIGHT))
        )
    ))

;; Validate "w_wcol" and "w_virtcol" only.

(defn- #_window_C validate-cursor-col [#_window_C win]
    (let-when [win (validate-virtcol win)] (non-flag? (:w_valid win) VALID_WCOL) => win
        (let [col (:w_virtcol win) off (win-col-off win) col (+ col off) off (+ (- (:w_width win) off) (win-col-off2 win)) n (- col (:w_width win))
              wrap @(:wo_wrap (:w_options win))
              col (if (and wrap (<= 0 n) (< 0 off)) (- col (* (inc (/ n off)) off)) col)]
           (-> win (assoc :w_wcol (max 0 (- col (:w_leftcol win)))) (update :w_valid | VALID_WCOL))
        )
    ))

;; Compute offset of a window, occupied by absolute or relative line number,
;; fold column and sign column (these don't move when scrolling horizontally).

(defn- #_int win-col-off [#_window_C win]
    (let [wops (:w_options win)]
        (+ (if (or @(:wo_nu wops) @(:wo_rnu wops)) (inc (number-width win)) 0) (if (or (zero? @cmdwin_type) (!= win @curwin)) 0 1))
    ))

;; Return the difference in column offset for the second screen line of a wrapped line.
;; It's 8 if 'number' or 'relativenumber' is on and 'n' is in 'cpoptions'.

(defn- #_int win-col-off2 [#_window_C win]
    (let [wops (:w_options win)]
        (if (and (or @(:wo_nu wops) @(:wo_rnu wops)) (some? (vim-strbyte @p_cpo, CPO_NUMCOL))) (inc (number-width win)) 0)
    ))

;; Compute "w_wcol" and "w_virtcol".  Also updates "w_wrow", "w_cline_row" and "w_leftcol".
;; may_scroll: when true, may scroll horizontally

(defn- #_window_C curs-columns [#_window_C win, #_boolean may_scroll]
    ;; First make sure that "w_topline" is valid (after moving the cursor).
    (let [win (update-topline win)
          ;; Next make sure that "w_cline_row" is valid.
          win (if (non-flag? (:w_valid win) VALID_CROW) (curs-rows win) win)
          ;; Compute the number of virtual columns.
          a'startcol (atom (int)) a'vcol (atom (int (:w_virtcol win))) a'endcol (atom (int)) _ (getvvcol win, (:w_cursor win), a'startcol, a'vcol, a'endcol)
          win (assoc win :w_virtcol @a'vcol)
          #_int extra (win-col-off win) ;; offset for first screen row
          win (assoc win :w_wcol (+ (:w_virtcol win) extra))
          _ (swap! a'endcol + extra)
          ;; Now compute "w_wrow" counting screen rows from "w_cline_row".
          win (assoc win :w_wrow (:w_cline_row win))
          #_int textwidth (- (:w_width win) extra)
          [win #_int width]
            (cond (<= textwidth 0) ;; No room for text, put cursor in last char of window.
                [(assoc win :w_wcol (dec (:w_width win)) :w_wrow (dec (:w_height win))) 0]
            (and @(:wo_wrap (:w_options win)) (non-zero? (:w_width win)))
                (let [width (+ textwidth (win-col-off2 win))]
                    ;; long line wrapping, adjust "w_wrow"
                    (if (<= (:w_width win) (:w_wcol win))
                        ;; this same formula is used in validate-cursor-col()
                        (let [#_int n (inc (/ (- (:w_wcol win) (:w_width win)) width))
                              win (update win :w_wcol - (* n width))
                              win (update win :w_wrow + n)
                              ;; When cursor wraps to first char of next line in Insert mode,
                              ;; the 'showbreak' string isn't shown, backup to first column.
                              win (if (and (non-eos? @p_sbr) (eos? (ml-get-cursor win)) (== (:w_wcol win) (mb-string2cells @p_sbr))) (assoc win :w_wcol 0) win)]
                            [win width])
                        [win width]
                    ))
            ;; No line wrapping: compute "w_leftcol" if scrolling is on and line is not folded.
            ;; If scrolling is off, "w_leftcol" is assumed to be 0.
            may_scroll
                ;; If cursor is left of the screen, scroll rightwards.
                ;; If cursor is right of the screen, scroll leftwards.
                ;; If we get closer to the edge than 'sidescrolloff', scroll a little extra.
                (let [#_int loff (- @a'startcol (:w_leftcol win) @p_siso) #_int roff (inc (- @a'endcol (- (+ (:w_leftcol win) (:w_width win)) @p_siso)))
                      win (if (or (< loff 0) (< 0 roff))
                            (let [#_int diff (if (< loff 0) (- loff) roff)
                                  #_int lcol ;; When far off or not enough room on either side, put cursor in middle of window.
                                    (if (or (zero? @p_ss) (<= (/ textwidth 2) diff) (<= loff roff))
                                        (- (:w_wcol win) extra (/ textwidth 2))
                                        ((if (< loff 0) - +) (:w_leftcol win) (max @p_ss diff)))
                                  lcol (max 0 lcol)]
                                ;; screen has to be redrawn with new "w_leftcol"
                                (if (!= lcol (:w_leftcol win)) (-> win (assoc :w_leftcol lcol) (redraw-later NOT_VALID)) win))
                            win)
                      win (update win :w_wcol - (:w_leftcol win))]
                    [win 0])
            (< (:w_leftcol win) (:w_wcol win))
                (let [win (update win :w_wcol - (:w_leftcol win))]
                    [win 0])
            :else
                [(assoc win :w_wcol 0) 0])
          o'skipcol (:w_skipcol win) a'plines (atom (int 0))
          win (if (and (or (<= (:w_height win) (:w_wrow win))
                           (and (or (< 0 o'skipcol) (<= (:w_height win) (+ (:w_wrow win) @p_so)))
                                (<= (:w_height win) (dec (reset! a'plines (plines win, (:lnum (:w_cursor win)), false))))))
                       (!= (:w_height win) 0) (== (:lnum (:w_cursor win)) (:w_topline win)) (< 0 width) (!= (:w_width win) 0))
                ;; Cursor past end of screen.  Happens with a single line that does not fit on screen.
                ;; Find a skipcol to show the text around the cursor.  Avoid scrolling all the time.
                ;; Compute value of "extra":
                ;; 1: less than "p_so" lines above
                ;; 2: less than "p_so" lines below
                ;; 3: both of them
                (let [extra (if (< (:w_virtcol win) (+ (:w_skipcol win) (* @p_so width))) 1 0)
                      ;; Compute last display line of the buffer line that we want at the bottom of the window.
                      _ (swap! a'plines #(dec (if (zero? %) (plines win, (:lnum (:w_cursor win)), false) %)))
                      #_int n (min (+ (:w_wrow win) @p_so) @a'plines)
                      extra (if (<= (+ (:w_height win) (/ (:w_skipcol win) width)) n) (+ extra 2) extra)
                      win (cond (or (== extra 3) (< @a'plines (* @p_so 2)))
                            ;; not enough room for 'scrolloff', put cursor in the middle
                            (let [n (max 0 (- (/ (:w_virtcol win) width) (/ (:w_height win) 2)))
                                  ;; don't skip more than necessary
                                  n (min n (inc (- @a'plines (:w_height win))))]
                                (assoc win :w_skipcol (* n width)))
                        (== extra 1)
                            ;; less then 'scrolloff' lines above, decrease skipcol
                            (let [n (/ (dec (+ (- (+ (:w_skipcol win) (* @p_so width)) (:w_virtcol win)) width)) width)]
                                (if (< 0 n)
                                    (let [n (min n (/ (:w_skipcol win) width))]
                                        (update win :w_skipcol - (* n width)))
                                    win
                                ))
                        (== extra 2)
                            (do ;; less then 'scrolloff' lines below, increase skipcol
                                (reset! a'endcol (* (inc (- n (:w_height win))) width))
                                (while (< (:w_virtcol win) @a'endcol)
                                    (swap! a'endcol - width))
                                (update win :w_skipcol max @a'endcol))
                        :else
                            win)
                      win (update win :w_wrow - (/ (:w_skipcol win) width))
                      win (if (<= (:w_height win) (:w_wrow win))
                            ;; small window, make sure cursor is in it
                            (let [n (inc (- (:w_wrow win) (:w_height win)))] (-> win (update :w_skipcol + (* n width)) (update :w_wrow - n)))
                            win
                        )]
                    (let [extra (/ (- o'skipcol (:w_skipcol win)) width)]
                        (cond
                            (< 0 extra) (win-ins-lines win, 0, extra, false, false)
                            (< extra 0) (win-del-lines win, 0, (- extra), false, false)
                        ))
                    win)
                (assoc win :w_skipcol 0))
          win (if (!= o'skipcol (:w_skipcol win)) (redraw-later win, NOT_VALID) win)
          ;; Redraw when "w_virtcol" changes and 'cursorcolumn' is set.
          win (if (and @(:wo_cuc (:w_options win)) (non-flag? (:w_valid win) VALID_VIRTCOL)) (redraw-later win, SOME_VALID) win)]
        (update win :w_valid | VALID_WCOL VALID_WROW VALID_VIRTCOL)
    ))

;; Scroll window "win" down by "n" logical lines.  "CTRL-Y"

(defn- #_window_C scrolldown [#_window_C win, #_long n]
    (let [win (validate-cursor win)                     ;; "w_wrow" needs to be valid
          [win done]                                    ;; total # of physical lines done
            (loop-when [win win done 0 n n] (and (< 0 n) (< 1 (:w_topline win))) => [win done]
                (let [win (update win :w_topline dec)
                      done (+ done (plines win, (:w_topline win), true))
                      win (update win :w_botline dec)   ;; approximate "w_botline"
                      win (invalidate-botline win)]
                    (recur win done (dec n))
                ))
          win (update win :w_wrow + done)               ;; keep "w_wrow" updated
          win (update win :w_cline_row + done)          ;; keep "w_cline_row" updated
          ;; Compute the row number of the last row of the cursor line
          ;; and move the cursor onto the displayed part of the window.
          wrow (:w_wrow win)
          [win wrow]
            (if (and @(:wo_wrap (:w_options win)) (non-zero? (:w_width win)))
                (let [win (-> win (validate-virtcol) (validate-cheight))]
                    [win (+ wrow (- (:w_cline_height win) 1 (/ (:w_virtcol win) (:w_width win))))])
                [win wrow])
          [win ?]
            (loop-when [win win ? false wrow wrow] (and (<= (:w_height win) wrow) (< 1 (:lnum (:w_cursor win)))) => [win ?]
                (let [wrow (- wrow (plines win, (:lnum (:w_cursor win)), true))
                      win (update-in win [:w_cursor :lnum] dec)
                      win (update win :w_valid & (bit-not (| VALID_WROW VALID_WCOL VALID_CHEIGHT VALID_CROW VALID_VIRTCOL)))]
                    (recur win true wrow))
            )]
        (if ? (coladvance win, (:w_curswant win)) win)
    ))

;; Scroll window "win" up by "n" logical lines.  "CTRL-E"

(defn- #_window_C scrollup [#_window_C win, #_long n]
    (let [lmax (line-count @curbuf)
          win (assoc win :w_topline (min (+ (:w_topline win) n) lmax))
          win (assoc win :w_botline (min (+ (:w_botline win) n) (inc lmax))) ;; approximate "w_botline"
          win (update win :w_valid & (bit-not (| VALID_WROW VALID_CROW VALID_BOTLINE)))]
        (if (< (:lnum (:w_cursor win)) (:w_topline win))
            (let [win (assoc-in win [:w_cursor :lnum] (:w_topline win))
                  win (update win :w_valid & (bit-not (| VALID_WROW VALID_WCOL VALID_CHEIGHT VALID_CROW VALID_VIRTCOL)))]
                (coladvance win, (:w_curswant win)))
            win)
    ))

;; Add one line above "loff.lnum".
;; This can be a filler line, a closed fold or a (wrapped) text line.
;; Returns the height of the added line in "loff.height".
;; Lines above the first one are incredibly high: MAXCOL.

(defn- #_lineoff_C topline-back [#_lineoff_C loff, #_window_C win]
    (let [n (dec (:lnum loff))] (assoc loff :lnum n :height (if (< n 1) MAXCOL (plines win, n, true)))))

;; Add one line below "loff.lnum".
;; This can be a filler line, a closed fold or a (wrapped) text line.
;; Returns the height of the added line in "loff.height".
;; Lines below the last one are incredibly high: MAXCOL.

(defn- #_lineoff_C botline-forw [#_lineoff_C loff, #_window_C win]
    (let [n (inc (:lnum loff))] (assoc loff :lnum n :height (if (< (line-count @curbuf) n) MAXCOL (plines win, n, true)))))

;; Recompute topline to put the cursor at the top of the window.
;; Scroll at least "min_sj" lines.
;; If "always" is true, always set topline (for "zt").

(defn- #_window_C scroll-cursor-top [#_window_C win, #_int min_sj, #_boolean always]
    ;; Decrease topline until it has become 1 or (part of) the cursor line is moved off the screen or
    ;; moved at least 'scrolljump' lines and there are at least 'scrolloff' lines above and below the cursor.
    (let [o'topline (:w_topline win)
          cln (:lnum (:w_cursor win)) lmax (line-count @curbuf)
          win (validate-cheight win)
          #_int used (:w_cline_height win) #_int done (if (< cln (:w_topline win)) used 0)
          ;; Check if the lines from "top" to "bot" fit in the window.
          ;; If they do, set "topline" and advance "top" and "bot" to include more lines.
          [used #_long topline]
            (loop-when [#_int extra 0, used used, done done, topline cln, #_long top (dec cln), #_long bot (inc cln)] (< 0 top) => [used topline]
                (let [#_int n (plines win, top, true)
                      used (+ used n (if (and (<= (+ extra n) @p_so) (< bot lmax)) (plines win, bot, true) 0))]
                    (if (< (:w_height win) used)
                        [used topline]
                        (let [done (+ done (if (< top (:w_topline win)) n 0))]
                            ;; If scrolling is needed, scroll at least 'sj' lines.
                            (if (and (or (<= (:w_topline win) topline) (< min_sj done)) (<= @p_so extra))
                                [used topline]
                                (recur (+ extra n) used done top (dec top) (inc bot))
                            ))
                    )))]
        ;; If we don't have enough space, put cursor in the middle.
        ;; This makes sure we get the same position when using "k" and "j" in a small window.
        (if (< (:w_height win) used)
            (scroll-cursor-halfway win, false)
            ;; If "always" is false, only adjust topline to a lower value, higher value may happen with wrapping lines.
            (let [win (if (or (< topline (:w_topline win)) always) (assoc win :w_topline topline) win)
                  win (update win :w_topline min (:lnum (:w_cursor win)))
                  win (if (!= (:w_topline win) o'topline) (update win :w_valid & (bit-not (| VALID_WROW VALID_CROW VALID_BOTLINE VALID_BOTLINE_AP))) win)]
                (update win :w_valid | VALID_TOPLINE)
            ))
    ))

;; Set "w_empty_rows" for window "win" having used up "used" screen rows for text lines.

(defn- #_window_C set-empty-rows [#_window_C win, #_int used]
    (assoc win :w_empty_rows (if (zero? used)
        0    ;; single line that doesn't fit
        (- (:w_height win) used)
    )))

;; Recompute topline to put the cursor at the bottom of the window.
;; Scroll at least "min_sj" lines.
;; If "set_topbot" is true, set topline and botline first (for "zb").
;; This is messy stuff!!!

(defn- #_window_C scroll-cursor-bot [#_window_C win, #_int min_sj, #_boolean set_topbot]
    (let [o'topline (:w_topline win) o'botline (:w_botline win) o'valid (:w_valid win) o'empty_rows (:w_empty_rows win)
          cln (:lnum (:w_cursor win)) lmax (line-count @curbuf)
          win (if set_topbot
                (let [win (assoc win :w_topline (inc cln) :w_botline (inc cln))
                      win (let [[win #_int used]
                                (loop-when [win win used 0] (< 1 (:w_topline win)) => [win used]
                                    (let [loff (topline-back (->lineoff_C (:w_topline win) 0), win)]
                                        (if (or (== (:height loff) MAXCOL) (< (:w_height win) (+ used (:height loff))))
                                            [win used]
                                            (recur (assoc win :w_topline (:lnum loff)) (+ used (:height loff)))
                                        )))]
                            (set-empty-rows win, used))
                      win (if (!= (:w_topline win) o'topline) (update win :w_valid & (bit-not (| VALID_WROW VALID_CROW))) win)]
                    (update win :w_valid | VALID_BOTLINE VALID_BOTLINE_AP))
                (validate-botline win))
          ;; The screen rows of the cursor line itself are always used.
          win (validate-cheight win)
          #_long n
            (let [#_int used (:w_cline_height win)
                  ;; If the cursor is below botline, we will at least scroll by the height of the cursor line.
                  ;; Correct for empty lines, which are really part of botline.
                  #_int done (if (<= (:w_botline win) cln) (- used (if (== cln (:w_botline win)) (:w_empty_rows win) 0)) 0)
                  ;; Stop counting lines to scroll when
                  ;; - hitting start of the file
                  ;; - scrolled nothing or at least 'sj' lines
                  ;; - at least 'so' lines below the cursor
                  ;; - lines between botline and cursor have been counted
                  [used done]
                    (loop-when [#_int extra 0, used used, done done, loff (->lineoff_C cln 0), boff (->lineoff_C cln 0)] (< 1 (:lnum loff)) => [used done]
                        ;; Stop when scrolled nothing or at least "min_sj", found "extra" context for 'scrolloff' and counted all lines below the window.
                        (if (and (or (and (or (<= done 0) (<= min_sj done)) (<= @p_so extra)) (< lmax (inc (:lnum boff)))) (<= (:lnum loff) (:w_botline win)))
                            [used done]
                            (let [loff (topline-back loff, win) ;; Add one line above.
                                  used (if (== (:height loff) MAXCOL) MAXCOL (+ used (:height loff)))]
                                (if (< (:w_height win) used)
                                    [used done]
                                    ;; Count screen rows that are below the window.
                                    (let [done (+ done
                        #_red!              (if (<= (:w_botline win) (:lnum loff)) (- (:height loff) (if (== (:lnum loff) (:w_botline win)) (:w_empty_rows win) 0)) 0))]
                                        (if (< (:lnum boff) lmax)
                                            (let [boff (botline-forw boff, win) ;; Add one line below.
                                                  used (+ used (:height boff))]
                                                (if (< (:w_height win) used)
                                                    [used done]
                                                    (let [[extra done]
                                                            (if (or (< extra @p_so) (< done min_sj))
                                                                ;; Count screen rows that are below the window.
                                                                (let [done (+ done
                        #_red!              (if (<= (:w_botline win) (:lnum boff)) (- (:height boff) (if (== (:lnum boff) (:w_botline win)) (:w_empty_rows win) 0)) 0))]
                                                                    [(+ extra (:height boff)) done])
                                                                [extra done]
                                                            )]
                                                        (recur extra used done loff boff))
                                                ))
                                            (recur extra used done loff boff)
                                        ))
                                ))
                        ))]
                (cond (<= done 0)                               ;; "w_empty_rows" is larger, no need to scroll
                    0
                (< (:w_height win) used)                        ;; more than a screenfull, don't scroll but redraw
                    used
                :else                                           ;; scroll minimal number of lines
                    (loop-when [boff (->lineoff_C (dec (:w_topline win)) 0) #_int i 0 n 0] (and (< i done) (< (:lnum boff) (:w_botline win)))
                            => (if (< i done) 9999 n)           ;; below "w_botline", don't scroll
                        (let [boff (botline-forw boff, win)]
                            (recur boff (+ i (:height boff)) (inc n)))
                    )
                )
            )
          ;; Scroll up if the cursor is off the bottom of the screen a bit, otherwise put it at 1/2 of the screen.
          win (if (and (<= (:w_height win) n) (< min_sj n)) (scroll-cursor-halfway win, false) (scrollup win, n))
          ;; If topline didn't change we need to restore "w_botline" and "w_empty_rows" (we changed them).
          ;; If topline did change, update-screen() will set botline.
          win (if (and (== (:w_topline win) o'topline) set_topbot) (assoc win :w_botline o'botline :w_empty_rows o'empty_rows :w_valid o'valid) win)]
        (update win :w_valid | VALID_TOPLINE)
    ))

;; Recompute "w_topline" to put the cursor halfway the window "win".
;; If "atend" is true, also put it halfway at the end of the file.

(defn- #_window_C scroll-cursor-halfway [#_window_C win, #_boolean atend]
    (let [cln (:lnum (:w_cursor win)) lmax (line-count @curbuf)
          #_long topline
            (loop-when [#_int above 0, #_int below 0, loff (->lineoff_C cln 0), boff (->lineoff_C cln 0), #_int used (plines win, cln, true), topline cln] (< 1 topline) => topline
                (let-when [[below boff used :as _]
                        (if (<= below above)         ;; add a line below the cursor first
                            (if (< (:lnum boff) lmax)
                                (let [boff (botline-forw boff, win) used (+ used (:height boff))]
                                    (if (< (:w_height win) used)
                                        nil
                                        [(+ below (:height boff)) boff used]))
                                [(inc below) boff (if atend (inc used) used)]) ;; count a "~" line
                            [below boff used])] (some? _) => topline
                    (let-when [[above loff used topline :as _]
                            (if (< above below)          ;; add a line above the cursor
                                (let [loff (topline-back loff, win) used (if (== (:height loff) MAXCOL) MAXCOL (+ used (:height loff)))]
                                    (if (< (:w_height win) used)
                                        nil
                                        [(+ above (:height loff)) loff used (:lnum loff)]))
                                [above loff used topline])] (some? _) => topline
                        (recur above below loff boff used topline)
                    )))]
        (-> win
            (assoc :w_topline topline)
            (update :w_valid & (bit-not (| VALID_WROW VALID_CROW VALID_BOTLINE VALID_BOTLINE_AP)))
            (update :w_valid | VALID_TOPLINE)
        )
    ))

;; Correct the cursor position so that it is in a part of the screen at least 'so' lines from the top and bottom, if possible.
;; If not possible, put it at the same position as scroll-cursor-halfway().
;; When called, topline must be valid!

(defn- #_window_C cursor-correct [#_window_C win]
    ;; How many lines we would like to have above/below the cursor depends on whether the first/last line of the file is on screen.
    (let-when [aw @p_so, bw @p_so, lmin 1, lmax (line-count @curbuf)
          [aw bw] (if (== (:w_topline win)      lmin)  [0 (min bw (/      (:w_height win)  2))] [aw bw])
          win (validate-botline win)
          [bw aw] (if (== (:w_botline win) (inc lmax)) [0 (min aw (/ (dec (:w_height win)) 2))] [bw aw])
          ;; If there are sufficient file-lines above and below the cursor, we can return now.
          cln (:lnum (:w_cursor win))
    ] (or (< cln (+ (:w_topline win) aw)) (<= (- (:w_botline win) bw) cln)) => win
        ;; Narrow down the area where the cursor can be put by taking lines from the top and the bottom until:
        ;; - the desired context lines are found
        ;; - the lines from the top is past the lines from the bottom
        (let [[topline botline]
                (loop-when [a 0 b 0 top' (:w_topline win) bot' (dec (:w_botline win))] (and (or (< a aw) (< b bw)) (< top' bot')) => [top' bot']
                    (let [[b bot'] (if (and (< b bw) (or (<= b a) (<= aw a))) [(+ b (plines win, bot', true)) (dec bot')] [b bot'])
                          [a top'] (if (and (< a aw) (or (<  a b) (<= bw b))) [(+ a (plines win, top', true)) (inc top')] [a top'])]
                        (recur a b top' bot')
                    ))
              inv- #(update % :w_valid & (bit-not (| VALID_WROW VALID_WCOL VALID_CHEIGHT VALID_CROW)))
              win (cond
                    (or (== topline botline) (zero? botline))                (assoc-in win [:w_cursor :lnum] topline)
                    (< botline topline)                                      (assoc-in win [:w_cursor :lnum] botline)
                    (and (< cln topline) (< lmin (:w_topline win)))  (-> win (assoc-in     [:w_cursor :lnum] topline) inv-)
                    (and (< botline cln) (<= (:w_botline win) lmax)) (-> win (assoc-in     [:w_cursor :lnum] botline) inv-)
                    :else                                                win
                )]
            (update win :w_valid | VALID_TOPLINE)
        )
    ))

;; Move "count" pages up or down.
;;
;; return false for failure, true otherwise

(defn- #_[window_C boolean] onepage? [#_window_C win, #_int dir, #_long count]
    (let-when [lmin 1 lmax (line-count @curbuf)] (!= lmin lmax) => (do (beep-flush) [win false]) ;; nothing to do
        (let [o'topline (:w_topline win)
              [win #_boolean ok]
                (loop-when [win win count count] (< 0 count) => [win true]
                    (let [win (validate-botline win)]
                        ;; It's an error to move a page
                        ;; - up when the first line is already on the screen.
                        ;; - down when the last line is on the screen and topline is 'scrolloff' lines from it.
                        (if (if (== dir FORWARD) (and (<= (- lmax @p_so) (:w_topline win)) (< lmax (:w_botline win))) (== (:w_topline win) lmin))
                            (do (beep-flush) [win false])
                            (let [win (cond (== dir FORWARD)
                                        (if (< lmax (:w_botline win)) ;; at end of file
                                            (let [win (assoc win :w_topline lmax)]
                                                (update win :w_valid & (bit-not (| VALID_WROW VALID_CROW))))
                                            ;; For the overlap, start with the line just below the window and go upwards.
                                            (let [#_lineoff_C loff (get-scroll-overlap win, (:w_botline win), -1)
                                                  win (assoc win :w_topline (:lnum loff))
                                                  win (assoc-in win [:w_cursor :lnum] (:w_topline win))]
                                                (update win :w_valid & (bit-not (| VALID_WCOL VALID_CHEIGHT VALID_WROW VALID_CROW VALID_BOTLINE VALID_BOTLINE_AP)))
                                            ))
                                    :else
                                        ;; Find the line at the top of the window that is going to be the line at the bottom of the window.
                                        ;; Make sure this results in the same line as before doing CTRL-F.
                                        (let [#_lineoff_C loff (get-scroll-overlap win, (dec (:w_topline win)), 1) loff (update loff :lnum min lmax)
                                              win (assoc-in win [:w_cursor :lnum] (:lnum loff))
                                              ;; Find the line just above the new topline to get the right line at the bottom of the window.
                                              loff (loop-when [loff loff #_long n 0] (and (<= n (:w_height win)) (<= lmin (:lnum loff))) => loff
                                                        (let [loff (topline-back loff, win)]
                                                            (recur loff (if (== (:height loff) MAXCOL) MAXCOL (+ n (:height loff)))))
                                                )]
                                            (if (< (:lnum loff) lmin) ;; at begin of file
                                                (let [win (assoc win :w_topline lmin)]
                                                    (update win :w_valid & (bit-not (| VALID_WROW VALID_CROW VALID_BOTLINE))))
                                                ;; Go two lines forward again.
                                                (let [loff (botline-forw loff, win) loff (botline-forw loff, win)]
                                                    ;; Always scroll at least one line.  Avoid getting stuck on very long lines.
                                                    (if (<= (:w_topline win) (:lnum loff))
                                                        (let [win (update win :w_topline dec)
                                                              win (comp-botline win)
                                                              win (assoc-in win [:w_cursor :lnum] (dec (:w_botline win)))]
                                                            (update win :w_valid & (bit-not (| VALID_WCOL VALID_CHEIGHT VALID_WROW VALID_CROW))))
                                                        (let [win (assoc win :w_topline (:lnum loff))]
                                                            (update win :w_valid & (bit-not (| VALID_WROW VALID_CROW VALID_BOTLINE))))
                                                    ))
                                            ))
                                    )]
                                (recur win (dec count)))
                        )))
              win (cursor-correct win)
              win (if ok (beginline win, (| BL_SOL BL_FIX)) win)
              win (update win :w_valid & (bit-not (| VALID_WCOL VALID_WROW VALID_VIRTCOL)))
              ;; Avoid the screen jumping up and down when 'scrolloff' is non-zero.
              ;; But make sure we scroll at least one line (happens with mix of long wrapping lines and non-wrapping line).
              win (if (and ok (== dir FORWARD) (check-top-offset win))
                    (let [win (scroll-cursor-top win, 1, false)]
                        (if (and (<= (:w_topline win) o'topline) (< o'topline lmax)) (assoc win :w_topline (inc o'topline)) win))
                    win
                )]
            [(redraw-later win, VALID) ok]
        )
    ))

(defn- #_window_C onepage [#_window_C win, #_int dir, #_long count]
    (let [[win _] (onepage? win, dir, count)]
        win
    ))

;; Decide how much overlap to use for page-up or page-down scrolling.
;; This is symmetric, so that doing both keeps the same lines displayed.
;; Three lines are examined:
;;
;;  before CTRL-F           after CTRL-F / before CTRL-B
;;     etc.                     l1
;;  l1 last but one line        ------------
;;  l2 last text line           l2 top text line
;;  -------------               l3 second text line
;;  l3                             etc.

(defn- #_lineoff_C get-scroll-overlap [#_window_C win, #_long lnum, #_int dir]
    (let [#_int min_height (- (:w_height win) 2)         #_lineoff_C loff (->lineoff_C lnum (plines win, lnum, true))          #_int h1 (:height loff)]
        (if (< min_height h1)
            loff ;; no overlap
            (let [#_lineoff_C over0 loff                 loff (if (< 0 dir) (botline-forw loff, win) (topline-back loff, win)) #_int h2 (:height loff)]
                (if (or (== h2 MAXCOL) (< min_height (+ h2 h1)))
                    over0 ;; no overlap
                    (let [#_lineoff_C over1 loff         loff (if (< 0 dir) (botline-forw loff, win) (topline-back loff, win)) #_int h3 (:height loff)]
                        (if (or (== h3 MAXCOL) (< min_height (+ h3 h2)))
                            over0 ;; no overlap
                            (let [#_lineoff_C over2 loff loff (if (< 0 dir) (botline-forw loff, win) (topline-back loff, win)) #_int h4 (:height loff)]
                                (if (or (== h4 MAXCOL) (< min_height (+ h4 h3 h2)) (< min_height (+ h3 h2 h1)))
                                    over1 ;; 1 line overlap
                                    over2 ;; 2 lines overlap
                                ))
                        ))
                ))
        )))

;; Scroll 'scroll' lines up or down.

(defn- #_window_C halfpage [#_window_C win, #_boolean ctrl_d, #_long Prenum]
    (when (non-zero? Prenum)
        (reset! (:wo_scr (:w_options win)) (min Prenum (:w_height win))))
    (let [scr (min @(:wo_scr (:w_options win)) (:w_height win))
          win (validate-botline win)
          win (cond ctrl_d ;; scroll the text up
                (let [lmax (line-count @curbuf) [win scr]
                        (loop-when [win win scr scr sed 0 room (:w_empty_rows win)] (and (< 0 scr) (<= (:w_botline win) lmax)) => [win scr]
                            (let [n (plines win, (:w_topline win), true) scr (- scr n)]
                                (if (and (< scr 0) (< 0 sed))
                                    [win scr]
                                    (let [win (update win :w_topline inc)
                                          win (update win :w_valid & (bit-not (| VALID_CROW VALID_WROW)))
                                          win (if (< (:lnum (:w_cursor win)) lmax)
                                                (-> win
                                                    (update-in [:w_cursor :lnum] inc)
                                                    (update :w_valid & (bit-not (| VALID_VIRTCOL VALID_CHEIGHT VALID_WCOL))))
                                                win)
                                          ;; Correct "w_botline" for changed "w_topline".
                                          ;; Won't work when there are filler lines.
                                          [win room]
                                            (loop [win win room (+ room n)]
                                                (let-when [n (plines win, (:w_botline win), true)] (<= n room) => [win room]
                                                    (let [win (update win :w_botline inc) room (- room n)]
                                                        (recur-if (<= (:w_botline win) lmax) [win room] => [win room])
                                                    ))
                                            )]
                                        (recur win scr (+ sed n) room))
                                ))
                        )]
                    (if (< 0 scr) ;; when hit bottom of the file: move cursor down
                        (-> win
                            (update-in [:w_cursor :lnum] + scr)
                            (check-cursor-lnum))
                        win)
                )
            :else ;; scroll the text down
                (let [lmin 1 [win scr]
                        (loop-when [win win scr scr sed 0] (and (< 0 scr) (< lmin (:w_topline win))) => [win scr]
                            (let [n (plines win, (dec (:w_topline win)), true) scr (- scr n)]
                                (if (and (< scr 0) (< 0 sed))
                                    [win scr]
                                    (let [win (update win :w_topline dec)
                                          win (update win :w_valid & (bit-not (| VALID_CROW VALID_WROW VALID_BOTLINE VALID_BOTLINE_AP)))
                                          win (if (< lmin (:lnum (:w_cursor win)))
                                                (-> win
                                                    (update-in [:w_cursor :lnum] dec)
                                                    (update :w_valid & (bit-not (| VALID_VIRTCOL VALID_CHEIGHT VALID_WCOL))))
                                                win
                                            )]
                                        (recur win scr (+ sed n)))
                                ))
                        )]
                    (if (< 0 scr) ;; when hit top of the file: move cursor up
                        (update-in win [:w_cursor :lnum] #(max lmin (- % scr)))
                        win
                    ))
            )]
        (-> win
            (cursor-correct)
            (beginline (| BL_SOL BL_FIX))
            (redraw-later VALID)
        )
    ))

(defn- #_void do-check-cursorbind []
    (let [cursor (:w_cursor @curwin) curswant (:w_curswant @curwin) set_curswant (:w_set_curswant @curwin)
          o'curwin @curwin o'VIsual_select @VIsual_select o'VIsual_active @VIsual_active]
        (reset! VIsual_select (reset! VIsual_active false))
        ;; loop through the cursorbound windows
        (loop-when-recur (reset! curwin @firstwin) (some? @curwin) (swap! curwin :w_next)
            ;; skip original window and windows with 'noscrollbind'
            (when (and (!= @curwin o'curwin) @(:wo_crb (:w_options @curwin)))
                (swap! curwin assoc :w_cursor cursor, :w_curswant curswant, :w_set_curswant set_curswant)
                ;; Make sure the cursor is in a valid position.
                ;; Temporarily set "restart_edit" to allow the cursor to be beyond the EOL.
                (let [_ @restart_edit] (reset! restart_edit TRUE) (swap! curwin check-cursor) (reset! restart_edit _))
                ;; Correct cursor for multi-byte character.
                (swap! curwin update :w_cursor mb-adjust-pos)
                (swap! curwin redraw-later VALID)
                ;; Only scroll when 'scrollbind' hasn't done this.
                (when (not @(:wo_scb (:w_options @curwin)))
                    (swap! curwin update-topline))
                (swap! curwin assoc :w_redr_status true)
            ))
        ;; reset current-window
        (reset! VIsual_select o'VIsual_select)
        (reset! VIsual_active o'VIsual_active)
        (reset! curwin o'curwin))
    nil)

;;; ============================================================================================== VimX

;; syntax.c: code for syntax highlighting ---------------------------------------------------------

;; Structure that stores information about a highlight group.
;; The ID of a highlight group is also called group ID.
;; It is the index in the highlight_ga array PLUS ONE.

(class! #_final hl_group_C
    [
        (field Bytes        sg_name)            ;; highlight group name
        (field Bytes        sg_name_u)          ;; uppercase of "sg_name"
;; for normal terminals
        (field int          sg_term)            ;; "term=" highlighting attributes
        (field Bytes        sg_start)           ;; terminal string for start highl
        (field Bytes        sg_stop)            ;; terminal string for stop highl
        (field int          sg_term_attr)       ;; screen attr for term mode
;; for color terminals
        (field int          sg_cterm)           ;; "cterm=" highlighting attr
        (field boolean      sg_cterm_bold)      ;; bold attr was set for light color
        (field int          sg_cterm_fg)        ;; terminal fg color number + 1
        (field int          sg_cterm_bg)        ;; terminal bg color number + 1
        (field int          sg_cterm_attr)      ;; screen attr for color term mode
    ])

(defn- #_void COPY-hl-group [#_hl_group_C sg1, #_hl_group_C sg0]
    (ยง
        ((ร sg1.sg_name =) (:sg_name sg0))
        ((ร sg1.sg_name_u =) (:sg_name_u sg0))
        ((ร sg1.sg_term =) (:sg_term sg0))
        ((ร sg1.sg_start =) (:sg_start sg0))
        ((ร sg1.sg_stop =) (:sg_stop sg0))
        ((ร sg1.sg_term_attr =) (:sg_term_attr sg0))
        ((ร sg1.sg_cterm =) (:sg_cterm sg0))
        ((ร sg1.sg_cterm_bold =) (:sg_cterm_bold sg0))
        ((ร sg1.sg_cterm_fg =) (:sg_cterm_fg sg0))
        ((ร sg1.sg_cterm_bg =) (:sg_cterm_bg sg0))
        ((ร sg1.sg_cterm_attr =) (:sg_cterm_attr sg0))
        nil
    ))

;; highlight groups for 'highlight' option
(atom! hl_group_C*  highlight_ga    0)

(final int MAX_HL_ID       20000)       ;; maximum value for a highlight ID.

;; An attribute number is the index in attr_table plus ATTR_OFF.

(final int ATTR_OFF (inc HL_ALL))

;; The attributes of the syntax item that has been recognized.

(atom! int current_sub_char)

;; Return conceal substitution character

(defn- #_int syn-get-sub-char []
    @current_sub_char)

;; Reset the cterm colors to what they were before Vim was started,
;; if possible.  Otherwise reset them to zero.

(defn- #_void restore-cterm-colors []
    (reset! cterm_normal_fg_color 0)
    (reset! cterm_normal_fg_bold 0)
    (reset! cterm_normal_bg_color 0)
    nil)

;; Table with the specifications for an attribute number.
;; Note that this table is used by ALL buffers.
;; This is required because the GUI can redraw at any time for any buffer.

(atom! attrentry_C* term_attr_table     0)
(atom! attrentry_C* cterm_attr_table    0)

(atom! boolean _4_recursive)

;; Return the attr number for a set of colors and font.
;; Add a new entry to the term_attr_table, cterm_attr_table or gui_attr_table, if the combination is new.
;; Return 0 for error (no more room).

(defn- #_int get-attr-entry [#_attrentry_C* table, #_attrentry_C aep]
    (ยง
        ;; Try to find an entry with the same specifications.

        (dotimes [#_int i (:ga_len table)]
            ((ร attrentry_C taep =) (... (:ga_data table) i))
            (if (and (== (:ae_attr aep) (:ae_attr taep)) (or (and (== table @term_attr_table) (== (nil? (:ae_esc_start aep)) (nil? (:ae_esc_start taep))) (or (nil? (:ae_esc_start aep)) (== (STRCMP (:ae_esc_start aep), (:ae_esc_start taep)) 0)) (== (nil? (:ae_esc_stop aep)) (nil? (:ae_esc_stop taep))) (or (nil? (:ae_esc_stop aep)) (== (STRCMP (:ae_esc_stop aep), (:ae_esc_stop taep)) 0))) (and (== table @cterm_attr_table) (== (:ae_fg_color aep) (:ae_fg_color taep)) (== (:ae_bg_color aep) (:ae_bg_color taep)))))
                ((ร RETURN) (+ i ATTR_OFF))
            )
        )

        ((ร final int MAX_TYPENR =) 65535)

        (when (< MAX_TYPENR (+ (:ga_len table) ATTR_OFF))
            ;; Running out of attribute entries!
            ;; Remove all attributes, and compute new ones for all groups.
            ;; When called recursively, we are really out of numbers.

            (when @_4_recursive
                (emsg (u8 "E424: Too many different highlighting attributes in use"))
                ((ร RETURN) 0)
            )
            (reset! _4_recursive true)

            (clear-hl-tables)

            (reset! must_redraw CLEAR)

            (dotimes [#_int i (:ga_len @highlight_ga)]
                (set-hl-attr i)
            )

            (reset! _4_recursive false)
        )

        ;; This is a new combination of colors and font, add an entry.

        (.ga_grow table 1)

        ((ร attrentry_C taep =) (ร table.ga_data[table.ga_len++] =) (NEW_attrentry_C))

        ((ร taep =) (assoc taep :ae_attr (:ae_attr aep)))
        (cond (== table @term_attr_table)
        (do
            ((ร taep =) (assoc taep :ae_esc_start (if (nil? (:ae_esc_start aep)) nil (STRDUP (:ae_esc_start aep)))))
            ((ร taep =) (assoc taep :ae_esc_stop (if (nil? (:ae_esc_stop aep)) nil (STRDUP (:ae_esc_stop aep)))))
        )
        (== table @cterm_attr_table)
        (do
            ((ร taep =) (assoc taep :ae_fg_color (:ae_fg_color aep)))
            ((ร taep =) (assoc taep :ae_bg_color (:ae_bg_color aep)))
        ))

        (+ (dec (:ga_len table)) ATTR_OFF)
    ))

;; Clear all highlight tables.

(defn- #_void clear-hl-tables []
    (ยง
        (dotimes [#_int i (:ga_len @term_attr_table)]
            ((ร attrentry_C taep =) (... (:ga_data @term_attr_table) i))
            ((ร taep =) (assoc taep :ae_esc_start nil))
            ((ร taep =) (assoc taep :ae_esc_stop nil))
        )
        (.ga_clear @term_attr_table)
        (.ga_clear @cterm_attr_table)
        nil
    ))

;; Combine special attributes (e.g., for spelling)
;; with other attributes (e.g., for syntax highlighting).
;; "prim_attr" overrules "char_attr".
;; This creates a new group when required.
;; Since we expect there to be few spelling mistakes we don't cache the result.
;; Return the resulting attributes.

(defn- #_int hl-combine-attr [#_int char_attr, #_int prim_attr]
    (ยง
        ((ร attrentry_C char_aep =) nil)
        (ร attrentry_C spell_aep)

        (if (zero? char_attr)
            ((ร RETURN) prim_attr)
        )
        (if (and (<= char_attr HL_ALL) (<= prim_attr HL_ALL))
            ((ร RETURN) (| char_attr prim_attr))
        )

        ((ร attrentry_C new_en =) (NEW_attrentry_C))

        (when (< 1 @t_colors)
            ((ร char_aep =) (if (< HL_ALL char_attr) (syn-cterm-attr2entry char_attr) char_aep))
            (cond (some? char_aep)
            (do
                (COPY-attrentry new_en, char_aep)
            )
            :else
            (do
                (ZER0-attrentry new_en)
                (if (<= char_attr HL_ALL)
                    ((ร new_en.ae_attr =) char_attr)
                )
            ))

            (cond (<= prim_attr HL_ALL)
            (do
                ((ร new_en.ae_attr =) (| (:ae_attr new_en) prim_attr))
            )
            :else
            (do
                ((ร spell_aep =) (syn-cterm-attr2entry prim_attr))
                (when (some? spell_aep)
                    ((ร new_en.ae_attr =) (| (:ae_attr new_en) (:ae_attr spell_aep)))
                    (if (< 0 (:ae_fg_color spell_aep))
                        ((ร new_en.ae_fg_color =) (:ae_fg_color spell_aep))
                    )
                    (if (< 0 (:ae_bg_color spell_aep))
                        ((ร new_en.ae_bg_color =) (:ae_bg_color spell_aep))
                    )
                )
            ))

            ((ร RETURN) (get-attr-entry @cterm_attr_table, new_en))
        )

        ((ร char_aep =) (if (< HL_ALL char_attr) (syn-term-attr2entry char_attr) char_aep))
        (cond (some? char_aep)
        (do
            (COPY-attrentry new_en, char_aep)
        )
        :else
        (do
            (ZER0-attrentry new_en)
            (if (<= char_attr HL_ALL)
                ((ร new_en.ae_attr =) char_attr)
            )
        ))

        (cond (<= prim_attr HL_ALL)
        (do
            ((ร new_en.ae_attr =) (| (:ae_attr new_en) prim_attr))
        )
        :else
        (do
            ((ร spell_aep =) (syn-term-attr2entry prim_attr))
            (when (some? spell_aep)
                ((ร new_en.ae_attr =) (| (:ae_attr new_en) (:ae_attr spell_aep)))
                (when (some? (:ae_esc_start spell_aep))
                    ((ร new_en.ae_esc_start =) (:ae_esc_start spell_aep))
                    ((ร new_en.ae_esc_stop =) (:ae_esc_stop spell_aep))
                )
            )
        ))

        (get-attr-entry @term_attr_table, new_en)
    ))

;; Get the highlight attributes (HL_BOLD etc.) from an attribute nr.
;; Only to be used when "attr" > HL_ALL.

(defn- #_int syn-attr2attr [#_int attr]
    (let [#_attrentry_C aep (if (< 1 @t_colors) (syn-cterm-attr2entry attr) (syn-term-attr2entry attr))]
        (if (nil? aep) 0 (:ae_attr aep))
    ))

(defn- #_attrentry_C syn-term-attr2entry [#_int attr]
    (let [attr (- attr ATTR_OFF)]
        (if (< attr (:ga_len @term_attr_table)) (... (:ga_data @term_attr_table) attr) nil)
    ))

(defn- #_attrentry_C syn-cterm-attr2entry [#_int attr]
    (let [attr (- attr ATTR_OFF)]
        (if (< attr (:ga_len @cterm_attr_table)) (... (:ga_data @cterm_attr_table) attr) nil)
    ))

;; Set the attribute numbers for a highlight group.
;; Called after one of the attributes has changed.

(defn- #_void set-hl-attr [#_int idx]
    ;; idx: index in array
    (ยง
        ((ร hl_group_C[] hlt =) (:ga_data @highlight_ga))
        ((ร hl_group_C sgp =) (... hlt idx))

        ;; The "Normal" group doesn't need an attribute number.
        (if (and (some? (:sg_name_u sgp)) (zero? (STRCMP (:sg_name_u sgp), (u8 "NORMAL"))))
            ((ร RETURN) nil)
        )

        ;; For the term mode: If there are other than "normal" highlighting
        ;; attributes, need to allocate an attr number.

        (cond (and (nil? (:sg_start sgp)) (nil? (:sg_stop sgp)))
        (do
            ((ร sgp =) (assoc sgp :sg_term_attr (:sg_term sgp)))
        )
        :else
        (do
            ((ร attrentry_C at_en =) (NEW_attrentry_C))
            ((ร at_en.ae_attr =) (:sg_term sgp))
            ((ร at_en.ae_esc_start =) (:sg_start sgp))
            ((ร at_en.ae_esc_stop =) (:sg_stop sgp))
            ((ร sgp =) (assoc sgp :sg_term_attr (get-attr-entry @term_attr_table, at_en)))
        ))

        ;; For the color term mode: If there are other than "normal"
        ;; highlighting attributes, need to allocate an attr number.

        (cond (and (zero? (:sg_cterm_fg sgp)) (zero? (:sg_cterm_bg sgp)))
        (do
            ((ร sgp =) (assoc sgp :sg_cterm_attr (:sg_cterm sgp)))
        )
        :else
        (do
            ((ร attrentry_C at_en =) (NEW_attrentry_C))
            ((ร at_en.ae_attr =) (:sg_cterm sgp))
            ((ร at_en.ae_fg_color =) (:sg_cterm_fg sgp))
            ((ร at_en.ae_bg_color =) (:sg_cterm_bg sgp))
            ((ร sgp =) (assoc sgp :sg_cterm_attr (get-attr-entry @cterm_attr_table, at_en)))
        ))
        nil
    ))

;; Lookup a highlight group name and return it's ID.
;; If it is not found, 0 is returned.

(defn- #_int syn-name2id [#_Bytes name]
    (ยง
        ((ร Bytes name_u =) (vim-strsave-up name))

        ((ร hl_group_C[] hlt =) (:ga_data @highlight_ga))

        ((ร int i =) (loop-when [i (dec (:ga_len @highlight_ga))] (<= 0 i) => i
            (if (and (some? (:sg_name_u (... hlt i))) (zero? (STRCMP name_u, (:sg_name_u (... hlt i)))))
                (ร BREAK)
            )
            (recur (dec i))
        ))
        (inc i)
    ))

;; Find highlight group name in the table and return it's ID.
;; The argument is a pointer to the name and the length of the name.
;; If it doesn't exist yet, a new entry is created.
;; Return 0 for failure.

(defn- #_int syn-check-group [#_Bytes pp, #_int len]
    (let [#_Bytes name (STRNDUP pp, len) #_int id (syn-name2id name)]
        (if (zero? id) (syn-add-group name) id)
    ))

;; Add new highlight group and return it's ID.
;; "name" must be an allocated string, it will be consumed.
;; Return 0 for failure.

(defn- #_int syn-add-group [#_Bytes name]
    (ยง
        ;; Check that the name is ASCII letters, digits and underscore.
        (loop-when-recur [#_Bytes p name] (non-eos? p) [(.plus p 1)]
            (cond (not (vim-isprintc (.at p 0)))
            (do
                (emsg (u8 "E669: Unprintable character in group name"))
                ((ร RETURN) 0)
            )
            (and (not (asc-isalnum (.at p 0))) (not-at? p (byte \_)))
            (do
                ;; This is an error, but since there previously was no check only give a warning.
                (msg (u8 "W18: Invalid character in group name"))
                (ร BREAK)
            ))
        )

        (when (<= MAX_HL_ID (:ga_len @highlight_ga))
            (emsg (u8 "E849: Too many highlight and syntax groups"))
            ((ร RETURN) 0)
        )

        ;; Make room for at least one other syntax_highlight entry.

        ((ร hl_group_C[] hlt =) (.ga_grow @highlight_ga 1))

        ((ร hlt[@highlight_ga.ga_len] =) (NEW_hl_group_C))
        ((ร hlt[@highlight_ga.ga_len].sg_name =) name)
        ((ร hlt[@highlight_ga.ga_len].sg_name_u =) (vim-strsave-up name))

        (swap! highlight_ga update :ga_len inc)

        (:ga_len @highlight_ga) ;; ID is index plus one
    ))

;; Translate a group ID to highlight attributes.

(defn- #_int syn-id2attr [#_int hl_id]
    (let [hl_id (syn-get-final-id hl_id) #_hl_group_C sgp (... (:ga_data @highlight_ga) (dec hl_id))]       ;; index is ID minus one
        (if (< 1 @t_colors) (:sg_cterm_attr sgp) (:sg_term_attr sgp))
    ))

;; Translate a group ID to the final group ID (following links).

(defn- #_int syn-get-final-id [#_int hl_id]
    (if (<= 1 hl_id (:ga_len @highlight_ga))
        hl_id
        0                   ;; Can be called from eval!!
    ))

;; The HL_FLAGS must be in the same order as the HLF_ enums!
;; When changing this also adjust the default for 'highlight'.

(final int* #_"[/*HLF_COUNT*/]" hl_flags
    [
        \8, \@, \e, \i, \l, \m, \M, \n, \N, \r, \s, \S, \c, \t, \v, \w, \-, \!, \., \o
    ])

;; Translate the 'highlight' option into attributes in highlight_attr[] and
;; set up the user highlights User1..9.  If FEAT_STL_OPT is in use, a set of
;; corresponding highlights to use on top of HLF_SNC is computed.
;; Called only when the 'highlight' option has been changed and upon first
;; screen redraw after any :highlight command.
;; Return false when an invalid flag is found in 'highlight'; true otherwise.

(defn- #_boolean highlight-changed []
    (ยง
        ((ร int id_SNC =) -1)
        ((ร int id_S =) -1)

        (reset! need_highlight_changed false)

        ;; Clear all attributes.

        (dotimes [#_int hlf HLF_COUNT]
            ((ร @highlight_attr[hlf] =) 0)
        )

        ;; First set all attributes to their default value.
        ;; Then use the attributes from the 'highlight' option.

        (dotimes [#_int i 2]
            ((ร Bytes p =) (if (non-zero? i) @p_hl (get-highlight-default)))
            (if (nil? p)      ;; just in case
                (ร CONTINUE)
            )

            (loop-when [] (non-eos? p)
                ((ร int hlf =) (loop-when-recur [hlf 0] (< hlf HLF_COUNT) [(inc hlf)] => hlf
                    (if (== (... hl_flags hlf) (.at p 0))
                        (ร BREAK)
                    )
                ))
                ((ร p =) (.plus p 1))
                (if (or (== hlf HLF_COUNT) (eos? p))
                    ((ร RETURN) false)
                )

                ;; Allow several hl_flags to be combined, like "bu" for bold-underlined.

                ((ร int attr =) 0)
                ((ร p =) (loop-when-recur p (and (non-eos? p) (not-at? p (byte \,))) (.plus p 1) => p            ;; parse upto comma
                    (if (vim-iswhite (.at p 0))           ;; ignore white space
                        (ร CONTINUE)
                    )

                    (if (< HL_ALL attr)  ;; Combination with ':' is not allowed.
                        ((ร RETURN) false)
                    )

                    (condp ==? (.at p 0)
                        (byte \b)
                        (do
                            ((ร attr =) (| attr HL_BOLD))
                            (ร BREAK)
                        )
                        (byte \i)
                        (do
                            ((ร attr =) (| attr HL_ITALIC))
                            (ร BREAK)
                        )
                       [(byte \-) (byte \n)]                      ;; no highlighting
                        (do
                            (ร BREAK)
                        )
                        (byte \r)
                        (do
                            ((ร attr =) (| attr HL_INVERSE))
                            (ร BREAK)
                        )
                        (byte \s)
                        (do
                            ((ร attr =) (| attr HL_STANDOUT))
                            (ร BREAK)
                        )
                        (byte \u)
                        (do
                            ((ร attr =) (| attr HL_UNDERLINE))
                            (ร BREAK)
                        )
                        (byte \c)
                        (do
                            ((ร attr =) (| attr HL_UNDERCURL))
                            (ร BREAK)
                        )
                        (byte \:)
                        (do
                            ((ร p =) (.plus p 1))                        ;; highlight group name
                            (if (or (non-zero? attr) (eos? p))      ;; no combinations
                                ((ร RETURN) false)
                            )
                            ((ร Bytes end =) (vim-strchr p, (byte \,)))
                            ((ร end =) (if (nil? end) (.plus p (STRLEN p)) end))
                            ((ร int id =) (syn-check-group p, (BDIFF end, p)))
                            (if (zero? id)
                                ((ร RETURN) false)
                            )
                            ((ร attr =) (syn-id2attr id))
                            ((ร p =) (.minus end 1))
                            (cond (== hlf HLF_SNC)
                            (do
                                ((ร id_SNC =) (syn-get-final-id id))
                            )
                            (== hlf HLF_S)
                            (do
                                ((ร id_S =) (syn-get-final-id id))
                            ))
                            (ร BREAK)
                        )
                        (ร DEFAULT)
                        (do
                            ((ร RETURN) false)
                        )
                    )
                ))
                ((ร @highlight_attr[hlf] =) attr)

                ((ร p =) (skip-to-option-part p))             ;; skip comma and spaces
                (recur)
            )
        )

        ;; Setup the user highlights
        ;;
        ;; Temporarily utilize 10 more hl entries.  Have to be in there
        ;; simultaneously in case of table overflows in get-attr-entry()

        ((ร hl_group_C[] hlt =) (.ga_grow @highlight_ga 10))

        ((ร int n =) (:ga_len @highlight_ga))
        (dotimes [#_int i 10]
            ((ร hlt[n + i] =) (NEW_hl_group_C))
        )

        ;; Make sure id_S is always valid to simplify code below.
        (when (zero? id_S)
            ((ร hlt[n + 9].sg_term =) (... @highlight_attr HLF_S))
            ((ร id_S =) (+ n 10))
        )

        (dotimes [#_int i 9]
            ((ร Bytes userhl =) (Bytes. 10))
            (.sprintf libC userhl, (u8 "User%d"), (inc i))

            ((ร int id =) (syn-name2id userhl))
            (when (non-zero? id)
                (cond (zero? id_SNC)
                (do
                    ((ร hlt[n + i].sg_term =) (... @highlight_attr HLF_SNC))
                    ((ร hlt[n + i].sg_cterm =) (... @highlight_attr HLF_SNC))
                )
                :else
                (do
                    (COPY-hl-group (... hlt (+ n i)), (... hlt (dec id_SNC)))
                ))

                ;; Apply difference between UserX and HLF_S to HLF_SNC.
                ((ร hlt[n + i].sg_term =) (bit-xor (:sg_term (... hlt (+ n i))) (bit-xor (:sg_term (... hlt (dec id))) (:sg_term (... hlt (dec id_S))))))
                (if (BNE (:sg_start (... hlt (dec id))), (:sg_start (... hlt (dec id_S))))
                    ((ร hlt[n + i].sg_start =) (:sg_start (... hlt (dec id))))
                )
                (if (BNE (:sg_stop (... hlt (dec id))), (:sg_stop (... hlt (dec id_S))))
                    ((ร hlt[n + i].sg_stop =) (:sg_stop (... hlt (dec id))))
                )
                ((ร hlt[n + i].sg_cterm =) (bit-xor (:sg_cterm (... hlt (+ n i))) (bit-xor (:sg_cterm (... hlt (dec id))) (:sg_cterm (... hlt (dec id_S))))))
                (if (!= (:sg_cterm_fg (... hlt (dec id))) (:sg_cterm_fg (... hlt (dec id_S))))
                    ((ร hlt[n + i].sg_cterm_fg =) (:sg_cterm_fg (... hlt (dec id))))
                )
                (if (!= (:sg_cterm_bg (... hlt (dec id))) (:sg_cterm_bg (... hlt (dec id_S))))
                    ((ร hlt[n + i].sg_cterm_bg =) (:sg_cterm_bg (... hlt (dec id))))
                )

                (swap! highlight_ga assoc :ga_len (+ n i 1))
                (set-hl-attr (+ n i))         ;; at long last we can apply
            )
        )

        (swap! highlight_ga assoc :ga_len n)
        (dotimes [#_int i 10]
            ((ร hlt[n + i] =) nil)
        )

        true
    ))

;;; ============================================================================================== VimY

;; oops!

(final cmdname_C* cmdnames
    [
        (->cmdname_C (u8 "close"),         ex-close,         (| BANG RANGE NOTADR COUNT CMDWIN),                           ADDR_WINDOWS),
        (->cmdname_C (u8 "fixdel"),        ex-fixdel,           CMDWIN,                                                    ADDR_LINES),
        (->cmdname_C (u8 "only"),          ex-only,          (| BANG NOTADR RANGE COUNT),                                  ADDR_WINDOWS),
        (->cmdname_C (u8 "retab"),         ex-retab,         (| RANGE DFLALL BANG WORD1 CMDWIN),                           ADDR_LINES),
        (->cmdname_C (u8 "substitute"),    ex-sub,           (| RANGE EXTRA CMDWIN),                                       ADDR_LINES),
        (->cmdname_C (u8 "set"),           ex-set,           (| EXTRA CMDWIN),                                             ADDR_LINES),
        (->cmdname_C (u8 "stop"),          ex-stop,          (| BANG CMDWIN),                                              ADDR_LINES),
        (->cmdname_C (u8 "suspend"),       ex-stop,          (| BANG CMDWIN),                                              ADDR_LINES),
        (->cmdname_C (u8 "syncbind"),      ex-syncbind,         0,                                                         ADDR_LINES),
    ])

;;; ============================================================================================== VimG

;; Main loop: execute Normal mode commands until exiting Vim.
;; Also used to handle commands in the command-line window, until the window is closed.

(defn- #_void main-loop [#_boolean cmdwin]
    ;; cmdwin: true when working in the command-line window
    (let [#_oparg_C oa (NEW_oparg_C)]                       ;; operator arguments
        (while (or (not cmdwin) (zero? @cmdwin_result))
            (when (stuff-empty)
                (when @need_wait_return                     ;; if wait-return still needed ...
                    (swap! curwin wait-return FALSE))       ;; ... call it now
                (when (and @need_start_insertmode (goto-im) (not @VIsual_active))
                    (reset! need_start_insertmode false)
                    (stuff-string (u8 "i"))                 ;; start insert mode next
                ))
            ;; Reset "got_int" now that we got back to the main loop.
            ;; Except when inside a ":g/pat/cmd" command, then the "got_int" needs to abort the ":g" command.
            ;; For ":g/pat/vi" we reset "got_int" when used once.
            ;; When used a second time we go back to Ex mode and abort the ":g" command.
            (when @got_int
                (when (not @quit_more)
                    (vgetc))                ;; flush all buffers
                (reset! got_int false))
            (reset! msg_scroll false)
            (reset! quit_more false)
            ;; If skip redraw is set (for ":" in wait-return()), don't redraw now.
            ;; If there is nothing in the stuff_buffer or do_redraw is true, update cursor and redraw.
            (cond @skip_redraw
                (reset! skip_redraw false)
            (or @do_redraw (stuff-empty))
                (let [#_boolean lupd (and (not @finish_op) (pos? @(:wo_cole (:w_options @curwin))) (not (eqpos @last_cursormoved, (:w_cursor @curwin))))
                      ;; Trigger CursorMoved if the cursor moved.
                      [#_long lold #_long lnew]
                        (if lupd
                            (let [lold (:lnum @last_cursormoved)
                                  _ (reset! last_cursormoved (:w_cursor @curwin))
                                  lnew (:lnum @last_cursormoved)]
                                [lold lnew])
                            [0 0])]
                    ;; Before redrawing, make sure "w_topline" is correct, and "w_leftcol" if lines don't wrap, and "w_skipcol" if lines wrap.
                    (swap! curwin update-topline)
                    (swap! curwin validate-cursor)
                    (cond
                        @VIsual_active (update-curbuf INVERTED)    ;; update inverted part
                        (non-zero? @must_redraw) (update-screen 0)
                        (or @redraw_cmdline @clear_cmdline) (showmode))
                    (redraw-statuslines)
                    ;; display message after redraw
                    (when (some? @keep_msg)
                        ;; msg-attr-keep() will set "keep_msg" to null, must free the string here.
                        ;; Don't reset "keep_msg", msg-attr-keep() uses it to check for duplicates.
                        (msg-attr @keep_msg, @keep_msg_attr))
                    (reset! emsg_on_display false)    ;; can delete error message now
                    (reset! did_emsg false)
                    (reset! msg_didany false)         ;; reset lines_left in msg-start()
                    (may-clear-sb-text)        ;; clear scroll-back text on next msg
                    (swap! curwin showruler false)
                    (when (and lupd (or (!= lold lnew) (conceal-cursor-line @curwin) (:w_redraw_cline @curwin)))
                        (when (and (!= lold lnew) (<= lold (line-count @curbuf)))
                            (swap! curwin update-single-line lold))
                        (swap! curwin update-single-line lnew)
                        (swap! curwin update :w_valid & (bit-not VALID_CROW)))
                    (setcursor)
                    (cursor-on)
                    (reset! do_redraw false)
                ))
            ;; Update "w_curswant" if "w_set_curswant" has been set.
            ;; Postponed until here to avoid computing "w_virtcol" too often.
            (swap! curwin update-curswant)
            ;; Get and execute a normal mode command.
            (normal-cmd oa, true)
        ))
    nil)

;; Exit properly.
(defn- #_void getout [#_int exitval]
    (reset! exiting true)

    ;; Position the cursor on the last screen line, below all the text.
    (windgoto (dec @Rows), 0)

    (when @did_emsg
        ;; give the user a chance to read the (error) message
        (reset! no_wait_return FALSE)
        (swap! curwin wait-return FALSE)
    )

    (mch-exit exitval))

;;; ============================================================================================== VimZ

(defn #_void -main [& #_String* args]
;%% (reset! starttime (._time libC))

    ;; Allocate the first window and buffer.
    ;; Can't do anything without it, exit when it fails.

    (win-alloc-first)

    (init-yank)                            ;; init yank buffers

    ;; Set the default values for the options.

    (set-init-1)

    ;; Don't redraw until much later.
    (swap! no_redraw inc)

    ;; mch-init() sets up the terminal (window) for use.
    ;; This must be done after resetting full_screen, otherwise it may move the cursor (MSDOS).
    ;; Note that we may use mch-exit() before mch-init()!

    (mch-init)

    (set-term)                             ;; set terminal capabilities (will set full_screen)
    (screen-start)                         ;; don't know where cursor is now

    ;; Set the default values for the options that use Rows and Cols.

    (ui-get-shellsize)                     ;; inits Rows and Cols
    (win-init-size)

    (reset! cmdline_row (int (- @Rows @p_ch)))
    (reset! msg_row @cmdline_row)
    (screen-alloc false)                     ;; allocate screen buffers

    (set-init-2 @curwin)

    (reset! msg_scroll true)
    (reset! no_wait_return TRUE)

    ;; Start putting things on the screen.
    ;; Scroll screen down before drawing over it.
    ;; Clear screen now, so file message will not be cleared.

    (reset! starting NO_BUFFERS)
    (reset! no_wait_return FALSE)
    (reset! msg_scroll false)

    ;; When switching screens and something caused a message from a vimrc script,
    ;; need to output an extra newline on exit.
    (when (and (or @did_emsg @msg_didout) (non-eos? @T_TI))
        (reset! newline_on_exit true))

    ;; When done something that is not allowed or error message call wait-return.
    ;; This must be done before start-termcap(), because it may switch to another screen.
    ;; It must be done after settmode(TMODE_RAW), because we want to react on a single key stroke.
    ;; Call settmode and start-termcap here, so the T_KS and T_TI may be defined by set-term().

    (settmode TMODE_RAW)

    (when (or @need_wait_return @msg_didany)
        (swap! curwin wait-return TRUE))

    (start-termcap)                         ;; start termcap if not done by wait-return()

    (if @scroll_region
        (scroll-region-reset))              ;; in case Rows changed
    (scroll-start)                         ;; may scroll the screen to the right position

    (screen-clear)                      ;; clear screen

    (reset! no_wait_return TRUE)

    (swap! curwin setpcmark)

    ;; If opened more than one window, start editing files in the other windows.

    ;; make the first window the current window
    (win-enter @firstwin)

    (reset! no_redraw 0)
    (redraw-all-later NOT_VALID)
    (reset! no_wait_return FALSE)
    (reset! starting 0)

    ;; start in insert mode
    (when @p_im
        (reset! need_start_insertmode true))

    ;; If ":startinsert" command used, stuff a dummy command to be
    ;; able to call normal-cmd(), which will then start Insert mode.
    (when (non-zero? @restart_edit)
        (stuff-char K_NOP))

    ;; Call the main command loop.  This never returns.

    (main-loop false)

    #_nil 0)
